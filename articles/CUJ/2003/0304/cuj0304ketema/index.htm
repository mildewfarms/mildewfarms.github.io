<HTML><HEAD><TITLE>HexWeb HTML</TITLE></HEAD><body bgcolor="#FFFFFF" text="#000000"><H2>Creating STL Containers in Shared Memory</h2><h3>Grum Ketema</h3><i>This special-purpose allocator makes STL available in a shared memory scenario.</i><P>Shared memory is one of the IPC (interprocess communication) facilities available in every major version of Unix. It allows two or more processes to map the same set of physical-memory segments to their address space. Since the memory segments are common to all processes that are attached to them, the processes can communicate through the common data in the shared-memory segments. Thus, as the name implies, shared memory is a set of physical-memory segments that are shared among processes. When a process attaches to shared memory, it receives a pointer to the beginning of the shared segments; the process then can use the memory just like any other memory. Of course, care must be taken when a shared-memory segment is accessed or written to synchronize with another process that has access to the same physical memory.<P>Consider the following code, which works on most Unix systems:<P><pre>//Get shared memory id//shared memory keyconst key_t ipckey = 24568;   //shared memory permission; can be//read and written by anybodyconst int perm = 0666;//shared memory segment sizesize_t shmSize = 4096;//Create shared memory if not//already created with specified//permissionint shmId = shmget  (ipckey,shmSize,IPC_CREAT|perm);if (shmId ==-1) {  //Error}//Attach the shared memory segmentvoid* shmPtr = shmat(shmId,NULL,0);struct commonData* dp =  (struct commonData*)shmPtr;//detach shared memoryshmdt(shmPtr);</pre><h3>Types of Data Structures in Shared Memory</h3>Care must be taken when placing data in shared memory. Consider the following structure:<P><pre>Struct commonData {  int sharedInt;  float  sharedFloat;  char* name;Struct CommonData* next;};</pre>Process A does the following:<p><pre>//Attach shared memorystruct commonData* dp =  (struct commonData*) shmat    (shmId,NULL,0);dp-&gt;sharedInt = 5;..dp-&gt;name = new char [20];strcpy(dp-&gt;name,"My Name");dp-&gt;next = new struct commonData();</pre>Some time later, process B does the following:<P><pre>struct commonData* dp =  (struct commonData*) shmat    (shmId,NULL,0);//count = 5;int count = dp-&gt;sharedInt;//problemprintf("name = [%s]\n",dp-&gt;name);dp = dp-&gt;next;  //problem</pre>Data members <B>name</B> and <B>next</B> of <B>commonData</B> are allocated from the heap in process A's address space. <B>name</B> and <B>next</B> are pointing to an area of memory that is only accessible by process A. When process B accesses <B>dp-&gt;name</B> or <B>dp-&gt;next</B>, it will cause a memory violation since it is accessing a memory area outside of its address space. At the minimum, process B will get garbage for the <B>name</B> and <B>next</B> values. Thus all pointers in shared memory should point to locations within shared memory. (That is why C++ classes that contain virtual function tables -- those that inherit from classes that have virtual member functions cannot be placed in shared memory -- is another topic.)<P>As a result of these restrictions, data structures designed to be used in shared memory usually tend to be simple.<P><h3>C++ STL Containers in Shared Memory</h3>Imagine placing STL containers, such as maps, vectors, lists, etc., in shared memory. Placing such powerful generic data structures in shared memory equips processes using shared memory for IPC with a powerful tool. No special data structures need to be designed and developed for communication through shared memory. In addition, the full range of STL's flexibility can be used as an IPC mechanism. STL containers manage their own memory under the covers. When an item is inserted into an STL list, the list container automatically allocates memory for internal data structures to hold the inserted item.<P>Consider placing an STL container in shared memory. The container itself allocates its internal data structure. It is an impossible task to construct an STL container on the heap, copy the container into shared memory, and guarantee that all the container's internal memory is pointing to the shared-memory area.<P>Process A does the following:<P><pre>//Attach to shared memoryvoid* rp = (void*)shmat(shmId,NULL,0);//Construct the vector in shared//memory using placement newvector&lt;int&gt;* vpInA = new(rp) vector&lt;int&gt;*;//The vector is allocating internal data//from the heap in process A's address//space to hold the integer value(*vpInA)[0] = 22;</pre>Process B does the following:<P><pre>vector&lt;int&gt;* vpInB =  (vector&lt;int&gt;*) shmat(shmId,NULL,0);//problem - the vector contains internal //pointers allocated in process A's address //space and are invalid here int i = *(vpInB)[0];</pre><h3>C++ STL Allocators to the Rescue</h3>One of the type arguments to an STL container template is an allocator class. The allocator class is an abstraction of a memory-allocation model. The default allocator allocates memory from the heap. The following is a partial definition of the <B>vector</B> class in STL:<P><pre>template&lt;class T, class A = allocator&lt;T&gt; &gt;  class vector {    //other stuff};</pre>Consider the following declaration:<P><pre>//User supplied allocator myAllocvector&lt;int,myAlloc&lt;int&gt; &gt; alocV;  </pre>Assume <B>myAlloc&lt;int&gt;</B> allocates memory from shared memory. The vector <B>alocV</B> is constructed entirely from shared-memory space.<P>Process A does the following:<P><pre>//Attach to shared memoryvoid* rp = (void*)shmat(shmId,NULL,0);//Construct the vector in shared memory//using placement newvector&lt;int&gt;* vpInA =  new(rp) vector&lt;int,myAlloc&lt;int&gt;&gt;*;//The vector uses myAlloc&lt;int&gt; to allocate//memory for its internal data structure//from shared memory(*v)[0] = 22;</pre>Process B does the following:<P><pre>vector&lt;int&gt;* vpInB =  (vector&lt;int,myAlloc&lt;int&gt; &gt;*) shmat    (shmId,NULL,0);//Okay since all of the vector is//in shared memoryint i = *(vpInB)[0];</pre>All processes attached to the shared memory may use the vector safely. In this case, all memory allocated to support the class is allocated from the shared memory, which is accessible to all the processes. By supplying a user-defined allocator, an STL container can be placed in shared memory safely.<P><h3>A Shared Memory Based STL Allocator</h3><a href="cuj0304ketema_l1.htm">Listing 1</a> shows an implementation of the C++ Standard STL allocator. The STL allocator is itself a template. The <B>Pool</B> class does the shared-memory allocation and deallocation.<P> <a href="cuj0304ketema_l2.htm">Listing 2</a> shows the <B>Pool</B> class definition.   <B>Pool</B>'s static member <B>shm_</B> is of type <B>shmPool</B>. There is   a single instance of <B>shmPool</B> per process, and it represents shared memory.   <B>shmPool</B>'s constructor creates and attaches the desired size of shared   memory. Shared-memory parameters, such as the shared-memory key, number of shared-memory   segments, and size of each segment, are passed to the <B>shmPool</B> class constructor   through environmental variables. The data member <B>segs_</B> is the number   of shared-memory segments; <B>segSize_</B> is the size of each shared-memory   segment. The <B>path_</B> and <B>key_</B> data members are used to create a   unique <B>ipckey</B>. <B>shmPool</B> creates one semaphore for each shared segment   to synchronize memory-management activities among processes attached to the   shared-memory segment. <B>shmPool</B> constructs a <B>Chunk</B> class in each   of the shared-memory segments. <B>Chunk</B> represents a shared-memory segment.   For each shared-memory segment, the shared-memory identifier <B>shmId_</B>,   a semaphore <B>semId_</B> to control access to the segment, and a pointer to   the <B>Link</B> structure that represents the free list are kept in the <B>Chunk</B>   class.<P><h3>Placing an STL Container in Shared Memory</h3>Suppose process A places several STL containers in shared memory. How does process B find these containers in shared memory? One way is for process A to place the containers at fixed offsets in the shared memory. Process B then can go to the specified addresses to obtain the containers. A cleaner way is for process A to create an STL map in shared memory at a known address. Then process A can create containers anywhere in shared memory and store the pointers to the containers in the map using a name as a key to the map. Process B knows how to get to the map since it is at an agreed location in shared memory. Once process B obtains the map, it can use the containers' names to get the containers. <a href="cuj0304ketema_l3.htm">Listing 3</a> shows a container factory. The <B>Pool</B> class method's <B>setContainer</B> places the map at a well-known address. The <B>getContainer</B> method returns the map. The factory's methods are used to create, retrieve, and remove containers from shared memory. The container types passed to the container factory should have <B>SharedAllocator</B> as their allocator.<P><h3>Conclusion</h3>The scheme described here can be used to create STL containers in shared memory. The total size of shared memory (<B>segs_* segSize_</B>) should be large enough to accommodate the STL container's largest size, since <B>Pool</B> does not create new shared memory if it runs out of space.<P>The complete source code is available for download at &lt;www.cuj.com/code&gt;.<P><h3>References</h3>Bjarne Stroustrup. <I>The C++ Programming Language</I>, Third Edition (Addison-Wesley, 1997).<P>Matthew H. Austern. <I>Generic Programming and the STL: Using and Extending the C++ Standard Template Library</I> (Addison-Wesley, 1999). <p><h3>About the Author</h3>Grum Ketema has Masters degrees in Electrical Engineering and Computer Science. With 17 years of experience in software development, he has been using C since 1985, C++ since 1988, and Java since 1997. He has worked at AT&amp;T Bell Labs, TASC, Massachusetts Institute of Technology, SWIFT, BEA Systems, and Northrop.<p></BODY></HTML>