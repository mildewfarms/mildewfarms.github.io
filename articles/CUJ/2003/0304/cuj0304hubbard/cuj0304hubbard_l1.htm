<HTML><HEAD><TITLE>Listing 1: read, write, and llseek entry points</TITLE></HEAD><body bgcolor="#FFFFFF" text="#000000"><B> Listing 1:</B>	read, write, and llseek entry points<p><pre>ssize_tRobotArmController_read(struct file * apFile,char * apBuffer, size_t aLength, loff_t * aOffset){    RobotArmControllerData * pDevice = 0;    ssize_t bytesRead = 0;    if( !apFile || !apFile-&gt;private_data )    {        printk(KERN_INFO "ERROR in RobotArmController_read: \                 NULL input detected.\n");        return -EINVAL;    }    pDevice = apFile-&gt;private_data;    if( pDevice-&gt;mOffset &gt; *aOffset  )    {    *aOffset = pDevice-&gt;mOffset;    }    if( *aOffset &gt;= pDevice-&gt;mSize )    {        *aOffset = 0;        pDevice-&gt;mOffset = *aOffset;        return 0;    }    if (down_interruptible(&amp;gSem))    {        printk(KERN_INFO "Error in RobotArmController_read, \               down_interruptible call.\n");        return -ERESTARTSYS;    }    if (copy_to_user(apBuffer, &amp;pDevice-&gt;mpBuffer[*aOffset],        pDevice-&gt;mSize - *aOffset))    {        printk(KERN_INFO "Error in RobotArmController_read, \                copy_from_user routine.\n");        up(&amp;gSem);        return -EFAULT;    }    bytesRead = pDevice-&gt;mSize - *aOffset;    *aOffset += bytesRead;    pDevice-&gt;mOffset = *aOffset;    up(&amp;gSem);    return bytesRead;}ssize_tRobotArmController_write( struct file *     apFile,                      const char *         apBuffer,                      size_t               aLength,                      loff_t *             aOffset){    RobotArmControllerData * pDevice = 0;    if( !apFile || !apFile-&gt;private_data )    {        printk(KERN_INFO "ERROR in RobotArmController_write: \                NULL input detected.\n");        return -EINVAL;    }    pDevice = apFile-&gt;private_data;    if( aLength &gt;  MAX_FULL_DRIVER_STORAGE - 1)    {        printk(KERN_INFO "ERROR in RobotArmController_write: \                Input is too long to accept.\n");        return -ENOMEM;    }    if (down_interruptible(&amp;gSem))    {        printk(KERN_INFO "Error in RobotArmController_write, \                down_interruptible call.\n");        return -ERESTARTSYS;    }    if (copy_from_user(pDevice-&gt;mpBuffer, apBuffer, aLength))    {        printk(KERN_INFO "Error in RobotArmController_write, \                copy_from_user routine.\n");        up(&amp;gSem);        return -EFAULT;    }    pDevice-&gt;mpBuffer[aLength] = '\0';    pDevice-&gt;mSize = aLength;    *aOffset += aLength;    up(&amp;gSem);    return aLength;}loff_t RobotArmController_llseek(struct file * apFile,                                 loff_t aOffset, int whence){    // return -ESPIPE; //This is how to disable llseek.    RobotArmControllerData * pDevice = 0;    loff_t           newPosition = 0;    if( !apFile || !apFile-&gt;private_data )    {        printk(KERN_INFO "ERROR in RobotArmController_llseek: \                NULL input detected.\n");        return -EINVAL;    }    pDevice = apFile-&gt;private_data;    switch(whence)    {    case 0: // SEEK_SET        newPosition = aOffset;        break;    case 1: // SEEK_CUR        newPosition = pDevice-&gt;mOffset + aOffset;        break;    case 2: // SEEK_END        newPosition = pDevice-&gt;mSize + aOffset;        break;    default:        return -EINVAL;    }    if( newPosition &lt; 0 )    {    return -EINVAL;    }    pDevice-&gt;mOffset = newPosition;    return newPosition;}</pre></BODY></HTML>