<HTML><HEAD><TITLE>Letters</TITLE></HEAD><body bgcolor="#FFFFFF" text="#000000"><H2>We Have Mail</h2><I>Letters to the editor may be sent via email to </I>cujed@cmp.com<I>, or via the postal service to Letters to the Editor, </I>C/C++ Users Journal<I>, 1601 W. 23rd St., Ste 200, Lawrence, KS 66046-2700.</I><P> <hr>I read with interest Thomas Becker's column (<I>CUJ</I>, February 2003) on using template metaprogramming to provide default values for non-trailing function arguments and would like to respond to his request for alternative techniques.<P> Defaulting function arguments is essentially an exercise in selective binding,   where function arguments are bound either to a specified default value or to   the supplied value.<P> The code as described in the column has the unfortunate property that you   must supply a tuple object encapsulating the parameters to the function <B>Foo</B>,   so the mechanism for determining the default intrudes into the client code.<P> I offer a sample file (available for download at &lt;www.cuj.com/code&gt;)   that provides an alternative mechanism for generalized default function parameters.   The metaprogramming content is less and is restricted to the use overload resolution   and function template argument type deduction, but the impact on client code   is also much less -- for a function with three <B>arg</B>s, the call at the   client site is <B>foo(arg1,arg2,arg3)</B>, where any of <B>arg[1,2,3]</B> can   be <B>defaultValue()</B>.<P> It requires thought by the writer of the wrapper function -- parameters that   are passed by non-<B>const</B> reference <I>must</I> be non-<B>const</B> in   the wrapper function, and parameters that are passed by value, or <B>const</B>   reference, should be taken as <B>const</B> references in the wrapper function.   Also, <B>checkForDefaultVal</B> and <B>checkForDefaultRef</B> should be used   as appropriate. However, I don't think this is really any more than required   by Becker's proposed solution. In most cases, I would expect the wrapper function   and <B>checkForDefaultXXX</B> functions to be completely optimized away by the   compiler, since they are very simple inline functions, and the effect would   therefore be as if the caller had specified the defaults right at the call site.<P> Anthony Williams<P> <I>Hello Anthony,</I><P><I> Thank you very much for your feedback on my February </i>CUJ<I> column. I agree with you that yours is the better solution. Clearly, the intrusion on the client code is minimal. (It's hard to see how it could be less at all.) As far as the burden on the implementer of the function is concerned, we're probably in the same ballpark. Therefore, you win in the overall rating. It seems that I was out on a limb with my idea of packaging the arguments in a tuple.</i><P> <i>Thanks again for your feedback.</i><br> <i> Best,</i><br><i> Thomas Becker</I><hr><P> I have a couple of comments regarding Matthew Wilson's article "C/C++ Tip   #10: Efficient Integer to String Conversions," which appeared in the December   2002 issue.<P> First, there seems to be a bit of duplicated code. Why not rewrite the <B>signed_integer_to_string</B>   function like this:<P> <pre>template &lt;class C, class I&gt;inline const C *signed_integer_to_string  (C *buf, size_t ccBuf, I i){  C *psz = buf + ccBuf - 1;  *psz = 0;  bool negative = i &lt; 0;  do  {    signed lsd = i % 10;    i /= 10;    --psz;    *psz =       get_digit_character&lt;C&gt;()[lsd];  } while (i != 0);  if (negative)    *(--psz) = C('-');  return psz;}</pre>Or better yet, like this:<P> <pre>template &lt;class C, class I&gt;inline const C *signed_integer_to_string  (C *buf, size_t ccBuf, I i){  C *psz = const_cast&lt;C *&gt;    (unsigned_integer_to_string      (buf, ccBuf, i));  if (i &lt; 0)    *(--psz) = C('-');  return psz;}</pre>Second, from a user's point of view, it seems that filling the buffer backwards from the end can cause some problems. If I dynamically allocate a buffer, I now have to keep track of two pointers: one for my buffer and one for my string. If I statically allocate a buffer on the stack, I need to make sure my buffer does not go out of scope before I am finished with the string.<P> Please let me know if I am missing something.<P> Thanks,<br> Shawn Odekirk<P> <I>Hi Shawn,</i><P><I> The reason I did not elect to use the first of your two suggested implementations   (in fact it is virtually identical to an early implementation) is simply that   it is less efficient than the current implementation on most of the compilers   supported by the STLSoft libraries.</i><P> <i>The second solution you describe is the elegant one; the prosaic reason why   I did not use it is that some compilers -- GCC being the standout miscreant   -- have significantly worse performance (GCC has a stunning degradation of up   to 40%!) with it, and no compilers have noticeably better performance. </I><P><I> Since STLSoft is all about portability, and <B>integer_to_string</B>   is all about performance, the GCC performance dictates the current implementation.   I did think about having it conditionally compile for the others, but couldn't   see the point in introducing the potential maintenance headaches.</I><P><I> As for your second point about the buffer, you're not missing anything.   In order to have maximal efficiency and be thread-safe without using proprietary   extensions such as <B>__declspec(thread)</B> (which does not work in   explicitly loaded DLLs, so one wonders why they bother...), the user must supply   his own buffer. But since string representations of integral types have a fixed   maximum size (4/3, 6/5, 11/10, 20/19 characters -- for signed/unsigned 8-, 16-,   32-, 64-bits), and frame memory is cheap, this seems like a relatively painless   cost. As I said in the article, if you don't really need the speed, stick to   <B>sprintf()</B>; of course, you still need to provide the memory there, so....</I><P><I> Thanks very much for your interest. I hope you found the functions useful.   I'd be keen to hear any other thoughts on the STLSoft libraries you may have   in the future.</I><P> <i>Best regards,</i><br><i>Matthew Wilson</I><P> <hr>I have received several emails to point out one bug in the code included with   my article "C/C++ Tip #11: Overwrite Iterator" in <I>CUJ</I>, December 2002.   The problem relates to the assignment operator. The function as it was published:<P> <pre>overwrite_iterator&amp; operator=  (const Cont::value_type&amp; val){  iter ==    cont.end() ? cont.push_back(val) :    (*iter = val, ++iter);  return *this;}</pre>should instead read:<P> <pre>overwrite_iterator&amp; operator=  (const Cont::value_type&amp; val){  iter ==    cont.end() ? (cont.push_back(val),    iter = cont.end()) : (*iter =      val, ++iter);  return *this;}</pre>The bug makes the iterator not work for <B>vector</B> and <B>deque</B> containers, but it still works for <B>list</B>.<P>Ray Virzi <p></BODY></HTML>