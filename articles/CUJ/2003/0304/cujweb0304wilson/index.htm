<HTML>   
     <HEAD>
<TITLE>April 2003/Book Review</TITLE></HEAD>
<BODY BACKGROUND="" BGCOLOR="#FFFFFF" TEXT="#000000">
<H2 ALIGN="center">Book Review: <i>C++ Network Programming, Volume 2</i></H2>
<H3 ALIGN="center">Reviewed by Matthew Wilson</H3>

<HR>

<table>
<tr>
<td><b>Title:</b></td>
<td><a href="http://www.awprofessional.com/catalog/product.asp?product_id={D413AF82-B7B9-4FEB-886B-BB301168D213}"><i>C++ Network Programming, Volume 2: Systematic Reuse with ACE and Frameworks</i></a></td>
</tr>
<tr>
<td><b>Authors:</b></td>
<td>Douglas C. Schmidt and Stephen D. Huston</td>
</tr>
<tr>
<td><b>Publisher:</b></td>
<td>Addison Wesley Professional, 2002</td>
</tr>
<tr>
<td><b>Pages:</b></td>
<td>384</td>
</tr>
<tr>
<td><b>Price:</b></td>
<td>$39.99</td>
</tr>
</table>

<p><i>C++ Network Programming, Volume 2: Systematic Reuse with ACE and Frameworks</i>, by Douglas Schmidt and Stephen Huston, continues on from their <i>C++ Network Programming, Volume 1: Mastering Complexity with ACE and Patterns</i>. Volume 1 focused on encapsulating and abstracting low-level, OS-specific networking primitives into the ACE OS adaptation layer and C++ wrapper facades. Volume 2 builds on this foundation by tackling framework focuses and the use of ACE for system implementations. It does this by enhancing and extending the logging service example introduced in Volume 1.</p>
<p>Chapter 1 serves as an introduction to the book, and to the patterns/framework approach taken. It was pretty heavy going, until the authors started getting into specifics, whereupon my mental fog lifted, and I became impatient to reach Chapter 3.</p>
<p>Chapter 2 continues the introduction on foundational concepts by thoroughly covering the issues of services, servers, and configuration in some detail. Services are characterized as short duration versus long, internal versus external, stateful versus stateless, layered versus monolithic. Servers and configurations are given similarly deep treatments. This was also a bit hard going, but interesting and a useful foundation nonetheless.</p>
<p>Chapter 3 onwards represents the meat of the book, covering the various frameworks available with ACE. At this point, I started to get really interested. Each of the frameworks &#151; including Reactor, Service Configurator, Task, Acceptor-Connector, and Proactor &#151; are given a thorough treatment, incorporating a real-world issue to be solved, the design of the framework, and an acknowledgement of any constraints or shortcomings necessitated by the requirements of portability and efficiency.</p>
<p>The best chapter is the last, Chapter 9, on the ACE Streams framework. This chapter illustrates the usefulness and power of ACE, by demonstrating how significant functionality can be built into systems by making use of the <b>ACE_Task</b>, <b>ACE_Module</b>, and <b>ACE_Stream</b> classes. This is powerful stuff, almost plug-and-play networking, and helps to answer any qualms one might have as to whether to make the non-trivial investment in learning necessary to adopt the ACE approach.</p>
<p>I found the authors' honesty in not expressing any OS partiality both pleasing and refreshing. (The description of the <b>Timer</b> classes, <b>select()</b>, and the <b>ACE_WFMO_Reactor</b> class are particularly interesting in this regard.) Coupled with the pragmatic approach they have taken with ACE's implementation and their description of it, this appeals a great deal and lends confidence that they have indeed created a high-quality <i>and</i> platform-independent solution.</p>
<p>The book's style is mostly, though not entirely, good. The authors make extensive use of UML, which helps with consistency (though it had me rushing to my bookshelf a couple of times). On the downside, the type seems too large, especially in the diagrams and the code extracts; it's the first time I've read a book that seemed to be bursting from its seams. Though the authors (or their editors) did a sterling job of keeping the code from crossing page boundaries, I was left wanting more. (Of course books cannot keep up with 1,600 x 1,200 screens, but there is still plenty of scope for a smaller type and more code.)</p> 
<p>There are a great many (61) sidebars, which provide pleasant bite-sized informational snippets. However, this is somewhat distracting. Because there are so many and they are easier to read than the main text, it is all too easy to lose one's thread. Oh, and you'd better like with the word reify, as I've never encountered it so many times in one text.</p>
<p>Each chapter suffers from a restatement of the general thrust of the book, which is that reuse is good and ACE facilitates reuse. This is unnecessary, since the first two chapters make that point well enough.</p> 
<p>The index is good, and the bibliography impressive; my book wish list has just doubled in size. But the glossary is nothing less than superb. All books should have glossaries like this!</p>
<p>Strangely, given that Addison-Wesley published it, there are some badly rendered diagrams. The boxes and lines in two in particular are barely discernable. Also, there are a couple of production errors: notably one sidebar title begins with &quot;<b>ACE_Service-uscoreHandler</b>,&quot; which should be &quot;<b>ACE_Service_Handler</b>.&quot; Hopefully I have just a review copy, and yours will not be similarly afflicted.</p>
<p>Overall it is impossible not to be impressed, if not a little overawed, with the book. I find myself at once feeling a strong need to (re)read more about patterns (not to mention the wealth of references mentioned in the bibliography) and wanting to rush out and start work on a distributed project using ACE. I look forward to a real-world situation in which to test the claims that ACE can make great gains in productivity without sacrificing flexibility and (especially) efficiency. To quote from Chapter 1's summary &quot;the continual rediscovery and reinvention ... has kept the cost ... too high for too long.&quot; ACE aims to address this, and this book ably demonstrates how. I promise to try ACE in my next networking task.</p> 
<p>I would say that this book, along with Volume 1, would be useful reading for anyone wanting to get to grips with distributed network programming, whether they end up using ACE or not. (Although if half the claims are true, I expect that ACE would be the library of choice, especially if multiple hardware platforms are to be targeted.) It is not a beginner's book, nor particularly easy to read (it is very different from the Meyers/Sutter/Dewhurst easily digestible style), but it is informative, interesting, and does not give the impression of having omitted anything important. It does, however, seem to rely on a lot of prior knowledge, in particular regarding patterns terminology, so it would be wise to read <i>Design Patterns</i> <a href="#1">[1]</a> and <i>Pattern-Oriented Software Architecture</i> <a href="#2">[2]</a> first.</p>

<H3>Notes</H3>

<p><a name="1"></a>[1] Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides. <i>Design Patterns</i> (Addison-Wesley, 1995).</p>
<p><a name="2"></a>[2] Douglas C. Schmidt. <i>Pattern-Oriented Software Architecture, Volume 2: Patterns for Concurrent and Networked Objects</i> (John Wiley &amp; Sons, 2000).</p>

<H3>About the Author</H3>

<p><b>Matthew Wilson</b> holds a degree in Information Technology and a PhD in 
  Electrical Engineering and is a software development consultant for Synesis 
  Software. Matthew's work interests are in writting bullet-proof real-time, GUI, 
  and software-analysis software in C, C++, and Java. He has been working with 
  C++ for over 10 years and is currently bringing STLSoft.org and its offshoots 
  into the public domain. Matthew can be contacted via <A HREF="mailto:matthew@synesis.com.au">matthew@synesis.com.au</a>. 
</BODY></HTML>
