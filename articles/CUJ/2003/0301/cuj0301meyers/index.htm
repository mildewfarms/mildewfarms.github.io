<HTML><HEAD><TITLE>The New C: Statements and Loops</TITLE></HEAD><body bgcolor="#FFFFFF" text="#000000"><H2>The New C: Statements and Loops</H2><H3>Randy Meyers</H3><i>Our C specialist helps you become a loop specialist.</i><p>Several years ago, Jill, a friend of mine, was interviewing an applicant for a job with her company. Jill's employer had several openings for programmers working in different specialties: compilers, operating systems, user interfaces. Jill, wishing to match the applicant with the proper job opening, asked, "What type of programming do you like to do?"<P>The job applicant paused for a second to consider the question carefully. He then answered, "Loops. I like to write loops."<P>I have never quite made up my mind if the job candidate was being overly specific or overly general. On one hand, I have never heard, "Whoa, we need a loop here. Better call in a specialist." On the other hand, loops are useful in almost all forms of programming, even compilers, where recursive algorithms give loops a run for their money.<P>This column is dedicated to everyone who has ever written a loop and realized that a lot of work was going to happen in it. Which brings us to this month's subject, the changes to statements made in the 1999 revision of the C Standard. Although C99 did not create any new types of statements, it did introduce some new rules regarding the existing statements that increase their flexibility and perhaps allow you to avoid bugs. Ultimately, the statements most affected are loops.<P><h3>Mixing Declarations and Statements</h3>As I have written before [1], C99 no longer requires all of the declarations in a block to appear before all of the statements in the block. There are two properties important to understanding declarations that appear after statements.<P> The first property is that statements cannot use identifiers before they are   declared for the simple reason that the names are not yet accessible. This rule   should not be surprising since it has always been true that declarations cannot   use identifiers declared in later declarations. <a href="cuj0301meyers_l1.htm">Listing   1</a> shows invalid references to identifiers declared later in the block.<P>Some readers might think that <B>struct</B> and <B>union</B> tags are an exception to this rule. However, merely mentioning an identifier after the <B>struct</B> or <B>union</B> keywords declares that identifier as a <B>struct</B> or <B>union</B> tag, even if you do not provide a brace-enclosed list of declarations for the members of the new <B>struct</B> or <B>union</B> type. The rules for tags are somewhat involved (see 6.7.2.3 of [2]) and have been the same since the early days of C and even forward into C++ (although C++ rules out a few contexts, such as casts may not declare new types as a side effect). Tags do not violate the no-reference-before-declaration rule, and I will not discuss them specifically any further.<P>The second property necessary to understanding declarations following statements is that if an object in a block with automatic storage duration (declared without the <B>static</B> or <B>extern</B> keywords) is initialized, the initialization happens at run time when the declaration is reached. In other words, the initialization functions like an assignment statement, and every time the declaration is executed, the object will receive the specified value.<P>Thus, there is no difference between this pair of statements in a block:<P><pre>int x;x = f();</pre>and this statement:<P><pre>int x = f();</pre>In both cases, <B>x</B> will be set to the return value of calling <B>f</B> every time the statements are executed.<P><h3>Why Mix?</h3>This leads to the reason why you should take advantage of being able to intermix declarations and executable statements. If you do not declare a variable until you can give it its first value, then you can never reference it while it is uninitialized. A simple change in programming style can eliminate an entire class of hard-to-find run-time bugs.<P> Consider <a href="cuj0301meyers_l2.htm">Listing 2</a>. There could be hundreds   of statements between the declaration of <B>sum</B> and the first assignment   to <B>sum</B>. The compiler will be no help at all if a programmer "cleaning   up" the function manages to move the <B>printf</B> that references <B>sum</B>   to before <B>sum</B> gets a value. In a large function, and sometimes even in   a small function, it is very easy to lose track of the region of program text   that sets the value of a variable.<P>In contrast, what if the loop-computing <B>sum</B> had been written as:<P><pre>  int sum = 0;  for (i = 0; i &lt; 5; ++i)    sum += a[i];</pre>There would be no vast region of program text during which you could reference <B>sum</B>, but <B>sum</B> would not have the correct value. The compiler would prohibit such references.<P><h3>Differences between C and C++</h3>C99, C++, and Java all permit intermixing declarations and statements within a block, so it is a new programming style with which you should become familiar. However, the difference between how C and C++ accomplish this can lead to two differences in what is valid code.<P>The grammar for C++ just makes a declaration another type of statement. Thus, wherever you can have a statement, you can have a declaration. However, the grammar for C99 says that a compound statement (brace-enclosed block) is a sequence of block items, and block items are either statements or declarations.<P>A first glance, this appears to accomplish the same thing, since you can now put statements and declarations in a block in any order. But, while C and C++ both agree you can put a <B>goto</B> label on a statement, C++ considers declarations to be statements, and C99 does not. So the following is valid C++:<P><pre>// C++ onlyloop: int x = 0;</pre>but not valid C99. You can write the equivalent in C99:<P><pre>//valid C99 and C++loop: ;int x = 0;</pre>since empty statements (a single semicolon) are valid both in C and C++. (However, I hope you really do not care about the ins and outs of <B>goto</B> labels.)<P>The second place where the two grammars for C99 and C++ permit differences is that there are contexts in the languages that permit a single statement. C++ permits a declaration to be there, but C99 does not. For example:<P><pre>// C++, not C99for (i = 0; i &lt; 5; ++i)    int x;</pre>That code probably looks pretty alien to old C programmers. So alien that there might be a moment of panic wondering what the code does. Do you end up with five variables named <B>x</B>?<P><h3>Implicit Blocks</h3>The meaning of the above loop becomes clear once you know that C++ (and now C99) defines the statement that is the body of a loop as being a block even if it is not enclosed in braces. That block is entered and exited upon every pass of a loop. Thus, the above loop is exactly like:<P><pre>for (i = 0; i &lt; 5; ++i) {    int x;}</pre>In other words, create and destroy a variable named <B>x</B> five times. Most compilers will eliminate all code for such a loop. Many will even complain that a variable was declared but never referenced.<P> You ask, if C99 does not permit a declaration in such a context, why does   it borrow the C++ rule that the body of a <B>for</B>, <B>while</B>, and <B>do-while</B>   loop is a block? The primary motivation is that it gives well-defined semantics   to compound literals [3]. Compound literals are a new form of structured constant   that allow you to create an unnamed object by "casting" a brace-enclosed initializer   to the right type. In <a href="cuj0301meyers_l3.htm">Listing 3</a>, the function   <B>diagonal</B> draws a diagonal line of the indicated length by calling <B>drawpixel</B>.   The function <B>drawpixel</B> takes an argument that is a pointer to a point.   The call to <B>drawpixel</B> in <B>diagonal</B> creates an unnamed object of   type <B>struct</B> <B>POINT</B> using the compound-literal syntax and passes   the address of that unnamed object to <B>drawpixel</B>. The lifetime of that   unnamed object is the implicit block that is the body of the loop.<P>C99 and C++ not only make the bodies of <B>for</B>, <B>while</B>, and <B>do-while</B> loops implicit blocks, they also make the <B>then</B> and <B>else</B> clauses of <B>if</B> statements and the body of a <B>switch</B> statement also implicit blocks.<P>Not only are the various bodies of loops and <B>switch</B> statements and the <B>then</B> and <B>else</B> clauses of <B>if</B> statements implicit blocks, but the entire statement itself is another implicit block containing those blocks. Thus:<P><pre>for (/*...*/; /*...*/; /*...*/)  /*stmt */</pre>means exactly the same as:<P><pre>{  for (/*...*/; /*...*/; /*...*/) {    /*stmt */  }}</pre>likewise for the <B>if</B>, <B>switch</B>, <B>while</B>, and <B>do-while</B> statements. In case you are worried, entering and exiting a block, even one that reserves storage, takes little or no time. Except when variable length arrays [4, 5, 6, 7] are used, most compilers generate code to allocate stack space only once upon entering a function. (The amount of space allocated is the minimum amount necessary to handle the maximum requirements of any of the blocks in the function.)<P> Again, compound literals provide part of the motivation for making these entire   statements implicit, local blocks. However, there is an additional, more obvious   reason that applies only to the <B>for</B> statement. C99 adopted the feature   from C++ and Java where the first item in the parenthesized list following the   <B>for</B> keyword (the "initializer" clause) can be either a declaration or   an expression. Let's rewrite that loop from <a href="cuj0301meyers_l2.htm">Listing   2</a>:<P><pre>int sum = 0;for (int i = 0; i &lt; 5; ++i)    sum += a[i];</pre>Now not only has the declaration <B>sum</B> been moved to the first point that it is needed, but the declaration of <B>i</B> has been moved to the first point it is needed. The scope of <B>i</B> is just the loop itself. It cannot be referenced before the loop or after. Since they are separate scopes, all of the loops in an enclosing block can have their own index variable named <B>i</B>. (C++ programmers beware: some older C++ compilers do not consider the loop itself to be a block, and any index variable you declare will persist to the end of the explicit block enclosing the <B>for</B> loop.)<P>Note, C99 did not pick up the C++ feature that allows declarations as the controlling expressions of <B>while</B>, <B>if</B>, <B>switch</B>, or <B>do-while</B> statements. The most common uses of declarations in those contexts are an idiom involving the C++-only feature of run-time type identification. C programmers would likely never find declarations useful in those contexts.<P><h3>Conclusion</h3>We have come full circle. C99 adopted a feature from C++ and Java that permits intermixing declarations and code in order to allow safer programming. While there are some minor differences between C99 and C++ regarding this, they are in obscure and not very useful dark corners. Additional implicit blocks were introduced into the language to support the new contexts for declarations and expressions that have the side effect of creating unnamed objects. This ultimately opened a new place to allow declarations, the initializer clause of a <B>for</B> statement. The ultimate goal is to support a style of programming that eliminates uninitialized variable bugs.<P><h3>References</h3>[1]  Randy Meyers. "The New C: Declarations and Initializations," <I>C/C++ Users Journal</I>, April 2001.<P>[2]  ANSI/ISO/IEC 9899:1999, Programming Languages -- C. 1999. Available in Adobe PDF format for $18 from &lt;www.techstreet.com/ ncitsgate.html&gt;.<P>[3]  Randy Meyers. "The New C: Compound Literals," <I>C/C++ Users Journal</I>, June 2001.<P>[4]  Randy Meyers. "The New C: Why Variable Length Arrays," <I>C/C++ Users Journal</I>, October 2001.<P>[5]  Randy Meyers. "The New C: Variable Length Arrays, Part 2," <I>C/C++ Users Journal</I>, December 2001.<P>[6]  Randy Meyers. "The New C: Variable Length Arrays, Part 3: Pointers and Parameters," <I>C/C++ Users Journal</I>, January 2002.<P>[7]  Randy Meyers. "The New C: Variable Length Arrays, Part 4: VLA <B>typedef</B>s and Flexible Array Members," <I>C/C++ Users Journal</I>, March 2002.<p><h3>About the Author</h3>Randy Meyers is a consultant providing training and mentoring in C, C++, and Java. He is the current chair of J11, the ANSI C committee, and previously was a member of J16 (ANSI C++) and the ISO Java Study Group. He worked on compilers for Digital Equipment Corporation for 16 years and was Project Architect for DEC C and C++. He can be reached at <B>rmeyers@ix.netcom.com</B>.<p></BODY></HTML>