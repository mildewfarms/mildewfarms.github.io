<HTML><HEAD><TITLE>How Not to Use RTTI</TITLE></HEAD><body bgcolor="#FFFFFF" text="#000000"><h3>How Not to Use RTTI</h3>It's no lie that RTTI is an easily-abused feature of C++ -- most texts point out (correctly) that using RTTI to determine an object's specific type is almost always the result of flawed design. As an example, see what happens when one developer (mis)uses RTTI to discover whether an object can be safely deleted:<P><pre>void DeleteShape(Shape* S){  if(dynamic_cast&lt;Triangle*&gt;(S))    delete S;  else if(dynamic_cast&lt;Circle*&gt;(S))    delete S;  else if(dynamic_cast&lt;PageBorder*&gt;(S))    delete S;  else if(dynamic_cast&lt;Ruler*&gt;(S))    return;  else if(dynamic_cast&lt;LayoutGrid*&gt;(S))    return;}</pre>Note that there are three classes (apparently) that can be deleted, and (maybe) two that can't. Regrettably, this code will compile and work in the short term; I say regrettably because problems will inevitably begin to appear as the program evolves. What happens when a new class is introduced, say, <B>Ellipse</B>? The code will continue to compile, and the application will continue to run, yet <B>Ellipse</B> objects won't be deletable unless the developer remembers to go back and modify the implementation of <B>DeleteShape()</B>. Similarly, what happens when the capabilities of an object change? Suppose a later release of the application does allow the user to delete <B>Ruler</B> objects -- again, the developer must remember to alter <B>DeleteShape()</B> to allow it. Conversely, if an object's behavior changes from deletable to non-deletable without a corresponding update to <B>DeleteShape()</B>, a user may delete an object that they shouldn't have, probably leading to a <B>segfault</B> at run time. In all of these scenarios, behavioral changes in unknown numbers of objects have to be matched with changes to an otherwise unrelated function -- a serious violation of encapsulation. That ought to be enough to warn you away from this sort of code, but if it isn't, consider that this design cannot accommodate plug-in objects (popular in the graphics world), because the author of <B>DeleteShape()</B> can't possibly know in advance the type names of every <B>Shape</B>-derived class that might be written by a third party! Finally, consider that <B>DeleteShape()</B> is just one function -- if you have to resort to such trickery here, you'll undoubtedly have to do it in myriad other places, adding up to a maintenance nightmare. The moral of the story is that you should never need to use RTTI to find out the actual concrete type of an object at run time -- anytime you're tempted to do so, it's a surefire pointer to problems in the design. You should be testing objects for their capabilities instead of their type, as described in the accompanying article.</BODY></HTML>