<HTML><HEAD><TITLE>Contract Programming and RTTI</TITLE></HEAD><body bgcolor="#FFFFFF" text="#000000"><H2>Contract Programming and RTTI</H2><H3>Timothy M. Shead</H3><i>RTTI is not just for implementers of software tools. It's also handy for validating interface compliance.</i><P><h3>Introduction</h3>Few of the features in C++ are as poorly understood as RTTI (Run-Time Type Information). Most C++ texts demonstrate in detail how not to use RTTI, without any corresponding examples of appropriate use, while widespread "conventional wisdom" takes it for granted that RTTI is inefficient and bloated. Is RTTI merely a concession to old-fashioned coding practices and poor design? This article argues that, used judiciously, RTTI can be a powerful tool for managing software complexity through Contract Programming [1].<P><h3>Background</h3>The use of polymorphism to abstract object behavior is well understood by C++ developers. Many of us were introduced to polymorphism through some variation of the <B>Shape</B> class [2], which defines an abstract base for objects in a hypothetical drawing program:<P><pre>class Shape{public:  virtual void Draw() = 0;}</pre>Concrete classes (e.g., <B>Triangle</B>, <B>Circle</B>, <B>Box</B>) are then derived from <B>Shape</B> and implement the <B>Shape::Draw()</B> method. The drawing program stores and manipulates these objects through their <B>Shape</B> base class, and polymorphism guarantees that the correct implementation of <B>Draw()</B> will be called for each individual object at run time.<P>The example usually ends there, which is fine for an illustration of polymorphism, but hardly constitutes a realistic example of a drawing application -- in a real working program, <B>Shape</B>-derived objects will have to support everything from serialization to deletion, selection, grouping, 2-D transformations, and more. More importantly, as the set of <B>Shape</B> behaviors grows, so does the likelihood that some shapes will not support every behavior, requiring additional methods to test for supported behavior at run time:<P><pre>class Shape{public:  virtual bool IsDrawable() = 0;  virtual void Draw() = 0;  virtual bool IsSerializable() =    0;  virtual void Save(    std::ostream&amp; Stream) = 0;  virtual bool IsSelectable() = 0;  virtual void Select() = 0;  virtual void Deselect() = 0;  virtual bool IsSelected() = 0;  virtual bool IsMovable() = 0;  virtual void Move    (const double X,     const double Y) = 0;  virtual bool IsDeletable() = 0;  /* ... and so on ... */};</pre>This design is unsatisfying for three reasons:<P>1.  Complexity -- bringing together many otherwise unrelated behaviors into a single interface.<P>2.  Rigidity -- forcing all derivatives to implement every method, whether they are applicable to that concrete object or not.<P>3.  Lack of run-time safety -- although tests are provided for each behavior, there is no way to force a client to actually use those tests at run-time prior to calling the associated methods.<P>The result is implementations such as the following, for a hypothetical on-screen formatting object that is visible, but can't be selected, modified, or deleted by the application user:<P><pre>class Ruler : public Shape{public:  bool IsDrawable()    { return true; }  void Draw()    { /* Specifics for drawing         a ruler here */ }    bool IsSerializable()    { return false; }  void Save    (std::ostream&amp; Stream) {}    bool IsSelectable()    { return false; }  void Select() {}  void Deselect() {}  bool IsSelected()    { return false; }    bool IsMovable()    { return false; }  void Move(const double X,    const double Y) {}    bool IsDeletable()    { return false; }  /* ... and so on ... */};</pre>Note how this class consists almost entirely of unused, empty implementations [3]. Fortunately, there's a better alternative -- the Contract Programming model.<P><h3>Introducing Contract Programming</h3>The problem introduced is a common one in software engineering: given a broad range of well-defined behaviors and a collection of objects of unknown capability, determine at run time which objects support which behavior. This situation arises anytime objects are being instantiated via the Factory Design Pattern and is especially pertinent in applications that support run-time plug-ins -- since objects written by third parties are by definition unknown to the original application authors, some type of negotiation must occur at run time after the plug-in objects have been instantiated to determine their capabilities. The Contract Programming model addresses this problem with a two-pronged approach. First, the range of behaviors supported by the system is defined by a series of tightly defined interfaces of narrow scope. Interfaces are the "contracts" in Contract Programming -- they define sets of services that are implemented by an object and accessed by a client -- if a client holds a specific interface to an object, it knows that it can call the methods of that interface with predictable, well-defined results, without any knowledge of the object's concrete type. In C++, an interface can be implemented as a class with no data members, no constructors, and nothing but pure, virtual methods [4]. Although the <B>Shape</B> class technically fits this definition of an interface, it certainly isn't "narrow in scope," so the first step in applying the Contract Programming model to the drawing application is to split the <B>Shape</B> class into several more manageable interfaces:<P><pre>class Drawable{public:  virtual void Draw() = 0;};class Serializable{public:  virtual void Save(std::ostream&amp; Stream) = 0;};class Selectable{public:  virtual void Select() = 0;  virtual void Deselect() = 0;  virtual bool IsSelected() = 0;};class Movable{public:  virtual void Move(const double X,    const double Y) = 0;};</pre>Now, each concrete class can multiply inherit from only those interfaces that it intends to implement [5]:<P><pre>class Triangle :  public Drawable,  public Serializable,  public Selectable,  public Movable{public:  /* Implementations of all     four interfaces here */};class Ruler :  public Drawable{public:  // Implement Drawable here};</pre>This cleans up our objects considerably, by eliminating both "unused" methods and tests for run-time capabilities. It also brings us to the second half of the Contract Programming model: some means must be provided to query an object at run time for the interfaces it supports. Querying objects for interfaces is the bread-and-butter of Contract Programming, and it is where RTTI (finally) enters the picture.<P><h3>Putting RTTI to Work</h3>Assume that a client holds a <B>Drawable</B> interface implemented by an object:<P><pre>Drawable* const drawable =  new Triangle();</pre>The client would like to place the object (if possible) in a new location within the drawing; to do so, it must find out if the object can be moved, by querying it for the <B>Movable</B> interface. If the object does, in fact, implement <B>Movable</B>, the client will use the interface to carry out the desired changes. But how does it query for an interface? Several solutions are possible; one of the simplest and most elegant is to use RTTI via <B>dynamic_cast</B>. Clients can use <B>dynamic_cast</B> to cast (query) any interface to any other interface -- the result of the <B>dynamic_cast</B> will either be the requested interface, if it's implemented by the concrete object, or <B>NULL</B>:<P><pre>Movable* const movable =  dynamic_cast&lt;Movable*&gt;(drawable);if(movable)  movable-&gt;Move(5, 10);</pre>Note that there's nothing special about the choice of interfaces in this example: I could have applied <B>dynamic_cast</B> to any of the four interfaces I've defined to query for any of the others. Note too that this use of <B>dynamic_cast</B> is semantically quite different from what textbooks warn against (see <a href="cuj0301shead_s1.htm">sidebar</a>) -- instead of testing an object to see if it is a specific type, you are testing it for a specific capability, as defined by an interface class.<P><h3>Off into the Great Unknown</h3>One difficulty glossed over in the preceding discussion is how to store a collection of shapes now that the <B>Shape</B> class has been replaced with the interface classes <B>Drawable</B>, <B>Serializable</B>, <B>Selectable</B>, and <B>Movable</B>. Presumably, the original drawing application declared a container of shapes as something along the lines of:<P><pre>typedef std::vector&lt;Shape*&gt; Shapes;</pre>Clearly, this will have to change now that the <B>Shape</B> class has been replaced, but to what? Choosing to use a container of a specific type of interface such as <B>Drawable</B> would mean that all objects within the container must support the <B>Drawable</B> interface. This might be a fairly safe choice for a simple drawing application, but then again, it might not -- and why build constraints into the design if you don't have to?<P>A second, related issue is that it would be useful to write functions that take objects of unknown capabilities as parameters. For example, the following code fragment can be used to deselect any <B>Selectable</B> object:<P><pre>Selectable* const selectable =  dynamic_cast&lt;Selectable*&gt;(    any_interface_here);if(selectable)  selectable-&gt;Deselect();</pre>Wrapping this code in a function makes good programming sense, but what type should that function take as an argument? Again, choosing one of the four interface types would be a problem -- suppose the function is declared as:<P><pre>void DeselectShape(  Movable* const Shape);</pre>You would then have to provide a <B>Movable</B> interface in order to call <B>DeselectShape()</B>:<P><pre>DeselectShape(  dynamic_cast&lt;Movable*&gt;(    any_interface_here));</pre>which, translated into English, says "if this object is <B>Movable</B>, and it's <B>Selectable</B>, deselect it" -- clearly not what I originally had in mind, since <B>DeselectShape()</B> should deselect any object whether it's <B>Movable</B> or not.<P>What you need to solve both these problems is an "ambiguous" or "unknown" interface. While <B>void*</B> might seem like a logical choice, it won't do the job: you can't <B>dynamic_cast</B> from <B>void*</B> to another type [6]. The solution is to create a special interface, <B>Unknown</B>, that all other interfaces derive from [7]:<P><pre>class Unknown{protected:  virtual ~Unknown() {}};class Drawable :  public virtual Unknown{/* same as before */};class Serializable :  public virtual Unknown{/* same as before */};class Selectable :  public virtual Unknown{/* same as before */};class Movable :  public virtual Unknown{/* same as before */};</pre>Now you can create a collection of objects whose capabilities are completely unknown until you test for them:<P><pre>typedef std::vector&lt;Unknown*&gt; Shapes;</pre>Furthermore, you can define functions that will take any interface type as an argument:<P><pre>void DeselectShape(  Unknown* const Shape){  /* same as before */}</pre><h3>Using Proper Protection</h3>When designing interfaces, don't forget to pay attention to proper access control. I recommend the following:<P>1. Provide a protected default constructor for all interfaces (including Unknown). You'll need one for "empty" interfaces like Unknown that don't contain pure virtual methods, to prevent clients from instantiating them as if they were objects:<P><pre>// Interface to nowhere!Unknown* a = new Unknown();</pre>The non-empty interfaces can't be instantiated (because they contain pure virtuals), but they'll still require a default constructor in order to compile after you apply recommendation 2, below.<P>Since you are providing a default interface constructor that will be called from derived classes, you must make it protected instead of private and provide an implementation. I prefer inline implementations, to avoid linking and interdependency issues:<P><pre>class Unknown{protected:  Unknown() {}  virtual ~Unknown() {}};</pre>2. Provide a protected copy constructor and assignment operator for all interfaces (including <B>Unknown</B>). This will prevent compilation of code whose behavior would otherwise be undefined:<P><pre>Unknown* const a = new Triangle();Unknown* const b = new Circle();*a = *b; // Assignment of a Circle         // to a Triangle!Unknown* CopyShape(Unknown* const Shape){  // Tries to create a copy, but of what?  return new Unknown(*Shape);}</pre>The bottom line is that with Contract Programming the concrete type that an interface points to is unknown, so direct copies can't be made [8].<P>Again, copy constructors and assignment operators should be protected and defined inline so that the implementer of an interface can use copy construction and assignment in his implementations.<P>3. Ensure all interfaces have a virtual destructor. The need for virtual destructors in base classes is well documented -- they guarantee that calling <B>operator delete</B> with a base class (interface) pointer calls the correct destructor for the derived (implementation) class. In this case, the <B>Unknown</B> interface provides a virtual destructor so derived interfaces don't have to.<P>4. (Optional) Make the destructor protected in all interfaces and create a special interface for deleting objects. While item 3 is sufficient to meet language requirements and write working software, I feel that the Contract Programming model calls for additional prudence: querying for interfaces means holding multiple pointers to a single object, so anything that prevents casual or accidental deletion of the object through one pointer will prevent mishaps with the other(s). For this reason I generally define protected destructors for all interfaces (including <B>Unknown</B>) and provide a special interface with a public destructor for destroying objects:<P><pre>class Deletable :  public Unknown{public:  virtual ~Deletable() {}  /* ... and-so-on ... */};</pre>With these changes in place, an object can only be deleted after querying for the <B>Deletable</B> interface:<P><pre>void DestroyShape(Unknown* const Shape){  Deletable* const deletable =    dynamic_cast&lt;Deletable*&gt;(Shape);  if(deletable)    delete deletable;}</pre>In addition to protecting against accidents, using the <B>Deletable</B> interface gives us the flexibility to create "indestructible" objects that don't implement it, such as Singletons or other objects with explicitly managed lifetimes. An attempt to destroy such an object through the <B>DestroyShape</B> function will be quietly ignored. <p><h3>Alternatives</h3>There are several alternatives to the above approach to Contract Programming: the Mozilla project's XPCOM [8] and the proprietary Microsoft COM are just two. Each provides the interface/query model that you've seen, plus language and process independence: a COM component written in C++ can interact with a COM component written in JavaScript, running in a different process or on some other host. This language independence imposes significant constraints on how applications are written within either framework and is beyond the scope of this article.<P>In brief, the two COMs break functionality down into interfaces, which are (again) classes that contain only pure, virtual methods with no data members [9]. All interfaces derive from a special interface, <B>IUnknown</B>. Unlike the <B>Unknown</B> interface described above, <B>IUnknown</B> contains three methods: <B>QueryInterface()</B>, <B>AddRef()</B>, and <B>Release()</B>. The need for these three methods is dictated by the language independence of their frameworks: <B>dynamic_cast</B> could never work on an object written in another language (or residing in another process), so the <B>QueryInterface()</B> method has to be provided in its place. Because <B>QueryInterface()</B> is a member of <B>IUnknown</B>, and all other interfaces derive from <B>IUnknown</B>, you can call <B>QueryInterface()</B> with any interface to obtain any other supported interface on an object. Similarly, destructors don't exist for objects written in another language, so <B>AddRef()</B> and <B>Release()</B> allow clients to control the lifetimes of objects through reference counting.<P>Of course, if language or process independence for objects is important to your design, you'll want to go with one of the two COMs. Even if you don't require their features you may want to look into one of the numerous simpler frameworks that have been written, or consider writing one of your own, if you prefer the <B>QueryInterface()</B> route to <B>dynamic_cast</B>. The efficiency issues surrounding such a choice are addressed in the next section; I will only point out here that whatever framework you use/develop will have to provide:<P>1.  A means of uniquely identifying interface types.<P>2.  A method to query an object for the interfaces that it supports.<P>3.  An implementation of that method in every class that supports interfaces.<P>Items 1 and 3 taken together are the real problems with this approach -- the maintenance of some type of registry for interface identifiers, coupled with the need to write code on a class-by-class basis to identify which interfaces a class supports, is error prone and difficult to maintain at best. Using RTTI capitalizes nicely on the fact that the compiler knows at compile time exactly which interfaces a class implements. Nevertheless, a homemade framework of this type is included in the sample code for your inspection (available for download at &lt;www.cuj.com/code&gt;); you should compare it to the RTTI version and note the added complexity.<P><h3>How Much Does RTTI Cost?</h3>Now that you have a flexible, portable Contract Programming framework, one last item remains: the cost of it all. As you've seen above, there are many alternatives to the RTTI-based framework presented in this article. The key question is: are they more efficient, in time or space? One of the most pervasively held beliefs that I encountered while learning about RTTI took the form of anecdotal newsgroup lore along the lines of "I turned on RTTI in the compiler, and my executable size immediately increased by five percent." While it's certainly true that there are costs associated with using RTTI, it's important to know exactly what they are so that you can make an informed decision about whether to use it or not. You may find along the way that RTTI is not as expensive as you think. For example, if you've ever wondered how a try-catch block knows how to catch a specific type of exception while allowing others to continue unwinding the call stack, the answer is RTTI. In fact, RTTI was added in part to the language by making public the mechanisms that already existed to support exception handling. If your code (or the code in a library you're using) uses exceptions, you are already using RTTI, in which case the cost of putting it to additional use is probably zero!<P>Getting down to specifics, compilers typically support RTTI first by creating a <B>type_info</B> structure for every class type in your application. In turn, each class' <B>type_info</B> privately contains a searchable list of references to the <B>type_info</B> structures for its base classes. That's the first cost: <B>sizeof(type_info) + sizeof(type_info*)*(number of base classes)</B> per class. Second, a pointer to a class' <B>type_info</B> is inserted into the virtual function table for that class. This pointer is what <B>typeid</B> and <B>dynamic_cast</B> use to look up the dynamic type of an object at run time. That's the second cost: one additional virtual table pointer per class. And that's all. Whether this overhead is objectionable to you will probably hinge on the number of classes in your application: the footprint of an application with many small, simple class types will grow proportionally larger with RTTI enabled than that of an application with fewer, larger class types. Another thing to consider will be how often RTTI will be used as part of your design: a 3-D graphics application I maintain that makes heavy use of the Contract Programming model actually decreased in size when I switched from a homemade <B>QueryInterface()</B>-based framework to an RTTI framework. A program with a more conventional design that only needs to handle a few objects via the Contract Programming model might see different results.<P>At run time the results are less ambiguous -- there are no run-time overheads introduced by RTTI, aside from the execution times of <B>typeid</B> and <B>dynamic_cast</B>. Finding the concrete type of an object at run time via <B>typeid</B> is strictly a matter of obtaining a reference to the object's <B>type_info</B> structure through its virtual function table and is thus roughly equivalent in cost to any other virtual function lookup. Testing for interfaces with <B>dynamic_cast</B> is a little more complicated: after looking up the <B>type_info</B> structures of the source and target classes, <B>dynamic_cast</B> must then descend recursively through the source class' list of base-class <B>type_info</B> references, looking for a match with the target class. In a shallow class hierarchy, this is roughly equivalent to what an implementation of <B>QueryInterface()</B> has to do, and I have found in practice that the RTTI-based framework can query for interfaces just as quickly as other frameworks.<P><h3>Summary</h3>Standard C++ RTTI can be used to quickly and portably apply the Contract Programming model to handling complex interactions with objects of unknown capability at run time. Although alternative frameworks exist, they typically impose significant restrictions on how objects are handled, add considerable complexity when building software, and are much less portable. Homemade alternatives to RTTI may not be any more efficient, add significant complexity and maintenance requirements, and are considerably more error prone. The source code accompanying this article (available at &lt;www.cuj.com/code&gt;) presents the sample drawing application in three versions: one without the Contract Programming model, one with homemade RTTI, and one with Standard C++ RTTI.<P><h3>Notes and References</h3>[1]  The working title for this article was "RTTI -- Our Misunderstood Friend."<P>[2]  Bjarne Stroustrup. <I>The C++ Programming Language</I>, 2nd Edition (Addison Wesley, 1992).<P>[3]  The implementation of <B>Ruler::IsSelected()</B> is particularly troubling -- note that <B>Ruler::IsSelectable()</B> returns false, indicating that this is an unsupported feature, while <B>IsSelected()</B> is returning a valid result as if nothing is wrong.<P>[4]  Scott Meyers calls this a "protocol class" in <I>Effective C++</I>, 2nd Edition (Addison Wesley, 1998), but I prefer the term "interface" as it is more widely used and applicable to languages and frameworks other than Standard C++, including XPCOM, Microsoft COM, and Java.<P>[5]  If you thought the Java language didn't support multiple inheritance -- surprise! This form of multiple inheritance (from interfaces) is a staple of Java.<P>[6]  That's because <B>void*</B> is more than just "pointer to unknown" -- it's effectively "pointer to unknowable."<P>[7]  Yes, I know that this is the dreaded Diamond Inheritance Pattern. I would argue, though, that since the <B>Unknown</B> interface has no data members, no constructors, and no methods, this design doesn't suffer from the problems traditionally associated with multiple inheritance diamonds.<P>[8]  The Mozilla Project, &lt;www.mozilla.org&gt;.<P>[9]  Actually, they're virtual function tables that are laid out as if they were C++ classes -- which is why a C++ program can call methods on an XPCOM/Microsoft COM interface implemented by a program written in C or JavaScript.<p><h3>About the Author</h3>Timothy M. Shead is a former U.S. Marine, now working as a senior software engineer with nine years experience in Sunnyvale, CA. You can see the principles outlined in this article at work in a large scale environment at Tim's website, &lt;http://k3d.sourceforge.net&gt;.<p></body></HTML>