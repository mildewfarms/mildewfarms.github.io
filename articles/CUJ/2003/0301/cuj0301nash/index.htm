<HTML><HEAD><TITLE>Combining STL with SAX and XPath for Effective XML Parsing</TITLE></HEAD><body bgcolor="#FFFFFF" text="#000000"><H2>Combining STL with SAX and XPath for Effective XML Parsing</h2><h3>David Nash</h3><i>A simple template and a dash of STL make parsing XML a straightforward proposition.</i><p>Programmers have two systems for parsing an XML document: DOM (Document Object Model) and SAX (Simple API for XML). Parsers that support the first system read the whole document into a data structure in memory and then provide access to it using the W3C's DOM API. This approach requires that the whole document fit into memory and takes a little time while the parsing is done. Furthermore, the user then has to navigate the DOM tree to gain access to the data in the document.<P>SAX is an event-driven system in that the parser calls user-supplied event handlers as it encounters occurrences of various parts of the XML document, such as elements, text, and so on. The user code in the handlers must process the data as necessary.<P>This article describes an efficient way to parse an XML document, using Standard C++ library containers in conjunction with a SAX parser, resulting in fast de-serialization of data from an XML file directly to data structures held in memory.<P><h3>A Data Element Class</h3>XML data may represent a variety of different kinds of data, plain character strings, integers, floating-point numbers, etc. A look at the W3C's XML-Schema recommendation shows the number of data types that have been anticipated and provided by this standard. You need a way to read from an XML text element into any one of a number of C++ data types. Ideally this solution should also be extensible for user-defined types.<P>You can achieve this goal through the use of a polymorphic <B>DataElement</B> class, representing an individual XML element. By passing text from the XML document to the <B>put</B> method, this class has the ability to convert and store textual XML data in any data structure the user wishes:<P><pre>class Element{public:  virtual void put    (const std::string&amp; s) const=0;  virtual ~Element() {}};</pre>Clearly this class is a base class, as evidenced by the pure virtual method <B>put</B>, and the virtual destructor, which ensures proper behavior if you delete objects of classes derived from this class via a base type pointer.<P>For each type of data you wish to parse from the XML, you need a new derived class with an appropriately typed data member pointing at a variable suitable to hold the data item. As the following sections describe, you can either derive this class explicitly, or you can implement the class through a class template.<P><h3>Explicitly Deriving Concrete Classes</h3>You can derive a specific class for each data type you need to parse. The class must include a suitably overridden <B>put</B> method that can convert the character data from the XML document into the specific data type you need.<P>For example, a class for type <B>long</B> would look like this:<P><pre>class LongElement : public Element{  long* ptr_;public:  LongElement(long* ptr) : ptr_(ptr)  {}  virtual void put    (const std::string&amp; text) const  {    if (ptr_)    {      *ptr_=atol(text.c_str());    }  }};</pre>The disadvantage of this design is that you need to define a different derived class for each data type on which you want to operate.<P><h3>Using a Class Template</h3>I said there were two ways to do this, and you do have a choice of how to implement this: inclusion polymorphism (a.k.a. inheritance) or parametric polymorphism, more commonly known to C++ programmers as templates. Given that you are only changing the type of data operated on, I suggest implementing this as a class template.<P>The crucial factor is the design of the <B>put</B> method. Since each derived class handles a different type of data, you need a way to code this function in such a way that you don't need to specialize the template for each type -- which would negate the advantage of using a template. The ideal way would be to use a conversion function that itself is a template. Luckily such functions exist in the standard <B>iostream</B> library, which handles the conversion of varied data types to and from character streams, such as you might find in an XML document.<P>The template version of the derived class looks like this:<P><pre>template&lt;typename T&gt;class ElementData : public Element{  T&amp; ref_;public:  ElementData(T&amp; item) : ref_(item)  {}  virtual void put(const std::string&amp; s) const  {    std::istringstream stream(s);    stream &gt;&gt; ref_;  }};</pre>You can see that, like the non-templated version, this class overrides the <B>put</B> method to copy the XML data it is passed into the data storage it was given in its constructor. However this class can cope with any type for which a stream extraction operator has been defined.<P><h3>Managing Data Elements</h3>So, you have a number of classes (i.e., different instantiations of the template) that can hold a pointer to a data item (a program variable, in other words). How are you going to manage objects of these types and how will they fit into the SAX parsing methodology?<P>Remembering that the SAX parser will call a handler object for the start and end of each element and each piece of character data in the XML document, you need to arrange for the <B>put</B> method of the appropriate object to be called at the appropriate time with each piece of data.<P>The best way to do this is to use a look-up table that will direct you to the relevant <B>ElementData</B> object for each piece of XML text. For this, you can use the look-up table data structure supplied with the C++ Standard library, STL <B>map</B> class template.<P>If you are familiar with the <B>std::map</B>, you will recall that it takes two main template arguments, and these are the types of the key into the map and the type of the item to be stored. In this case, these are <B>std::string</B> and a pointer to <B>ElementData</B> respectively. Declare a <B>typedef</B> to make your life easier:<P><pre>typedef std::map&lt;const std::string, const Element*&gt; ElementMap_t;</pre>And what do you use for the key of the map? Since you are mapping from each XML element to its data item, the key must identify the XML element in question. This means you should use its name as the key.<P><h3>How It Will Work</h3>With what you have so far, try to parse the following simple XML document:<P><pre>&lt;?xml version='1.0' ?&gt;&lt;Person&gt;  &lt;FirstName&gt;Elvis&lt;/FirstName&gt;  &lt;LastName&gt;Presley&lt;/LastName&gt;  &lt;DateOfBirth&gt;    &lt;Year&gt;1935&lt;/Year&gt;    &lt;Month&gt;1&lt;/Month&gt;    &lt;Day&gt;8&lt;/Day&gt;  &lt;/DateOfBirth&gt;&lt;/Person&gt;</pre>You want to store each individual data item in a separate variable, each with its own <B>ElementData</B> object with the template instantiated for the appropriate type:<P><pre>std::string FirstName;std::string LastName;struct Date {  int year, month, day;};Date dob;ElementMap_t element_map;element_map.insert(std::make_pair  ("FirstName", ElementData&lt;std::string&gt;(FirstName));element_map.insert(std::make_pair  ("LastName", ElementData&lt;std::string&gt;(LastName));element_map.insert(std::make_pair  ("Year", ElementData&lt;int&gt;(dob.year));element_map.insert(std::make_pair  ("Month", ElementData&lt;int&gt;(dob.month));element_map.insert(std::make_pair  ("Day", ElementData&lt;int&gt;(dob.day));</pre>Then you need a SAX parser with a handler that looks up each XML element in the map and calls the <B>put</B> method on the object it finds there, passing the character text from that element.<P><h3>XPath</h3>The element names in the element map above are hardly descriptive. What if the XML document has more than one date, e.g., a start and an end of a period? You need a more specific way to identify the element in the document.<P>XPath allows you to specify an element in an XML document using a hierarchical directory-path-like notation. The root of the document is represented by a slash, and each element name is appended, separated by more slashes.<P>Some examples from the document above:<P><pre>  /Person  /Person/FirstName  /Person/DateOfBirth/Month</pre>XPath is much more expressive than this, but you can use this simple form of the notation to identify individual elements of the XML document.<P><h3>The SAX Handler</h3>Several XML parsers include SAX capabilities. I will use the Xerces C++ parser from the Apache project as an example, although the technique could just as easily be applied to any other SAX parser.<P>The SAX handler is the piece that does all the work. The handler has a number of methods that are called by the parser as the XML document is processed. In this case, you are concerned with the beginning and end of XML elements, and with character text. You use the beginning and end element notifications to keep a record of where you are in the XML document, constructing an XPath string as you go along. This path to the current element is stored on a stack. Any character data for the active element is accumulated until you reach the end of the element. When you do reach the end of an element, you pop the top item off the stack so that the previous element's path becomes the active path.<P>Here is the declaration of the class:<P><pre>class MySaxHandler : public HandlerBase{  const ElementMap_t&amp; element_map_;  std::stack&lt;std::string&gt; current_path_;  std::ostringstream current_text_;public:  MySaxHandler(const ElementMap_t&amp; map);  void startElement(const XMLCh* const name,                    AttributeList&amp; atts);  void endElement(const XMLCh* const name);  void characters(const XMLCh*const text,                  const unsigned int length);};</pre>The constructor simply initializes the object's member variable with a reference to your element map.<P><pre>MySaxHandler::MySaxHandler  (const ElementMap_t&amp; map)  : element_map_(map){}</pre><h3>Handler Methods</h3>First, <B>startElement</B> registers the start of a new XML element and adds it to the XPath name on your stack:<P><pre>void MySaxHandler::startElement(  const XMLCh* const name,  AttributeList&amp; atts){  std::ostringstream this_path;  if (!current_path_.empty())    this_path&lt;&lt;current_path_.top();  this_path &lt;&lt; 'c:\www.cuj.com/';  write_xml(this_path, name);  current_path_.push(this_path.str());}</pre>The reason for using a <B>stringstream</B> rather than a simple string is so that you can take advantage of the <B>ostream</B> inserter function <B>write_xml</B> used above. In a moment, I will show how this will handle conversion of <B>XMLCh</B> unicode characters to your local encoding. However, for reasons you shall soon see, this needs to be an explicit <B>write_xml</B> function rather than an overloaded <B>operator&lt;&lt;</B>.<P>Next, <B>characters</B> is called by the SAX parser for all textual element content. You simply maintain a <B>stringstream</B> and insert the new characters into it whenever you get some.<P><pre>void MySaxHandler::characters(  const XMLCh*const text,  const unsigned int length){  write_xml(current_text_, text);}</pre>Finally, at the end of each element, <B>endElement</B> finds the element in question by looking up its XPath name in the map and then calls <B>put</B> to write the characters saved so far to the stored pointer:<P><pre>void MySaxHandler::endElement(const XMLCh* const name){  if (!current_path_.empty())  {    ElementMap_t::const_iterator      i=element_map_.find(current_path_.top());    if (i != element_map_.end())    {      i-&gt;second-&gt;put(current_text_.str());    }    current_path_.pop();    current_text_.str("");  }}</pre><h3>XML Character Encoding</h3>The XML standard allows you to represent the characters that make up an XML document in any encoding you like. XML parsers use a number of rules to determine the correct encoding, including the <B>encoding=</B> attribute on the <B>&lt;?xml ?&gt;</B> declaration at the beginning of the document.<P>The Xerces SAX parser represents characters using an <B>XMLCh</B> data type and passes strings by pointers to this character type. These XML characters are represented in a Unicode encoding, whereas to store them in standard strings you need them in the local encoding. Xerces provides a static <B>XMLString::transcode</B> function to perform this conversion. The conversion could be automated by building it into the insertion operator for the type <B>XMLCh</B>.<P>However, <B>XMLCh</B> is a <B>typedef</B> from <B>short</B>, which makes it difficult -- you can't overload based on a <B>typedef</B> because <B>typedef</B> does not create a new type, but simply an alias. Therefore <B>short</B>'s standard inserter will be used by the compiler instead. To get around this problem, there are several alternatives: you could use a different function to insert in the stream (rather than <B>operator&lt;&lt;</B>) or explicitly translate the encoding before inserting in the stream.<P>Here is the function <B>write_xml</B>  used earlier to transcode and write XML characters to a stream:<P><pre>void write_xml(std::ostream&amp; target,               const XMLCh* s){  char *p = XMLString::transcode(s);  target &lt;&lt; p;  delete [] p;}</pre>To avoid the call to <B>delete[]</B>, you could replace the <B>char*</B> with a smart pointer capable of holding and deleting an array (unlike <B>std::auto_ptr</B>). If <B>target&lt;&lt;p</B> could throw, for example, this smart pointer would be necessary to make the function exception-safe.<P><h3>Using the SAX Processor</h3>With the handler class in place and now using XPath-style element names, you can rewrite the parsing code. First, add a helper function to make it easier to add an element to the map:<P><pre>template&lt;typename T&gt;void AddElement(ElementMap_t&amp; map,                T&amp; ref,                const std::string&amp; path){  map.insert(std::make_pair    (path, new ElementData&lt;T&gt;(ref)));}</pre>In a production system, this could even be automatically called by a program that gets the information from a metadata repository of some kind.<P>The final code looks like this:<P><pre>char filename[]="file.xml"ElementMap_t element_map;AddElement(element_map, FirstName,           "c:\www.cuj.com/Person/FirstName");AddElement(element_map, LastName,           "c:\www.cuj.com/Person/LastName");AddElement(element_map, dob.year,           "c:\www.cuj.com/Person/DateOfBirth/Year");AddElement(element_map, dob.month,           "c:\www.cuj.com/Person/DateOfBirth/Month");AddElement(element_map, dob.day,           "c:\www.cuj.com/Person/DateOfBirth/Day");MySaxHandler handler(element_map);parser.setDocumentHandler(&amp;handler);parser.parse(filename);</pre><h3>Further Refinement</h3>An obvious enhancement is to enable multiple occurrences of the same element name in the XML document to store data in corresponding multiple variables, a feature that is not provided by the code I have presented here.<P>Another improvement would be to build in support for multiple XML document types. Since the element map objects contain full XPath names for each element, the same map could be used, and it would continue to uniquely identify each element as it is discovered in any known XML document type.<h3>About the Author</h3>David Nash has an honors degree in Computer Science and is a professional member of the British Computer Society and a member of the Association of C and C++ Users. He is a senior software developer working for an international software house in the City of London. Although he has been using C and C++ for the last 10 years, he has diverse interests and is the author of <I>Linux in Easy Steps</I> and <I>The KDE Bible</I>.<p></BODY></HTML>