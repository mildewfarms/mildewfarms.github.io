<HTML><HEAD><TITLE>Thinking in STL: You Know It Don't Come Easy</TITLE></HEAD><body bgcolor="#FFFFFF" text="#000000"><H2>Thinking in STL: You Know It Don't Come Easy</H2><H3>Leor Zolman</H3><i>Leor graciously shares his incremental journey toward a very elegant and useful initialization utility for STL containers.</i><P>After several years of reading and thinking about STL, listening to experts talk about it, and even writing the scaffolding to test all the STL code fragments from Scott Meyers' <I>Effective STL</I> [2], I came up with a half-way original, STL-related application of my own: a library of templates to assist in the initialization of containers from lists of arbitrary constant values. This project evolved into my freeware InitUtil library [3].<P>Dan Saks has described the process of learning how to program as akin to reliving the evolutionary stages of computer programming, from machine/assembly language through procedural and then object-oriented languages [4]. If some of us take longer to traverse this path than others, then I could be poster child for the slow learners. About half way (two to three iterations) into the development of a key template function of InitUtil, I realized that this code had begun life as a C-style function (with all the attendant pointer/memory-management complexity modern C++ is so good at eliminating) and that I was now in the midst of "STL-izing" it. I was, in a way, reliving the evolutionary step from pointer-based to STL/iterator-based programming. Boy, did Dan's observation hit home in that moment.<P>I suspect I may not be the only one experiencing this transition anxiety. In this article, I document the steps I went through before arriving at a "pure" STL-based implementation of a simple little template function named <B>make_s</B>.<P><h3>Successive Refinement?</h3>A Computer Science professor I once knew claimed that all software should compile cleanly and run perfectly the very first time. That is, he claimed that debugging would not be necessary if you simply designed and constructed software using some "methodology du jour" he would have been happy to tell me about, if I'd asked. I never did. Perhaps that's because I enjoy the process of successive refinement of software by subjective "feel": envision it, code it, debug, and run it; envision improvements, code them, debug, and run them; when none of the envisioned improvements are worth taking the time or trouble to code, the project is finished.<P>I'm not smart enough to go from scratch directly to the best solution to a programming problem, skipping the intermediate stages. Plus, I'm seldom careful enough to produce any program over about five lines long that compiles and runs perfectly the first time. Thus, the InitUtil library is the result of the usual iterative development process.<P>It all began with the template function <B>make_s</B>. <B>make_s</B> parses a comma-delimited list of string values (passed as a single text parameter) and produces an STL-compatible container of <B>std::string</B> objects as its return value. A second Boolean parameter, with the default value of <B>false</B>, tells whether or not to preserve leading spaces in a string. The specific flavor of container desired is specified via explicit template specialization during instantiation. Some examples:<P><pre>// Create a list of strings,// skip leading spaces [5]:list&lt;string&gt; ls =  make_s&lt;list&lt;string&gt; &gt;(  "this, is, a, test, of, the,"  "emergency, broadcast, system");// Create a deque of strings,// preserve leading spaces:deque&lt;string&gt; dl =  make_s&lt;deque&lt;string&gt; &gt;(  "here, is another, one , with,"  "all , leading,  spaces  ,"  "preserved", true);</pre>(There was also a companion function template named <B>make_i</B> for parsing numeric rather than string values [6]. However, since the subject of this article is the evolution of the parsing algorithm for <B>value_type</B>s of <B>std::string</B>, I'm only going to discuss the evolution of <B>make_s</B>. The algorithm I show in the final version of <B>make_s</B> does survive essentially intact throughout the naming/calling convention improvements subsequently made to InitUtil.)<P><h3>Evolution</h3><a href="cuj0301zolman_f1.htm">Figure 1</a> shows the first version of <B>make_s</B> that compiled and actually worked. It also clearly shows my historical bias toward C strings (<B>char *s</B>) for representing text, to wit:<P><ul><li>   The in-text parameter to <B>make_s</B> is defined as a <B>const char *</B>.<li>   I parse the input into individual C strings by replicating the parameter string (lines 12-13) and then stuff <B>NUL</B> bytes into the position of each comma (or the original trailing <B>NUL</B>) in line 22. In my one initial concession to STL, I took advantage of the ability to use <B>char *</B>s as iterators and employed the <B>std::find</B> algorithm in line 21 to search for commas in the text.<li>   As each string is detected, I construct <B>std::string</B> objects from the C pointer <B>curPos</B> and then insert those strings into the temporary container using the container's own <B>push_back</B> function [7].<li>   Before returning, the temporary buffer holding the copy of the input string has to be deallocated.</ul>While this pointer-intensive function did indeed work, the memory allocation issues and the poking of <B>NUL</B> bytes into the middle of a string seemed gratuitously primitive for a utility designed to work alongside STL. To save myself embarrassment, I really wanted <B>make_s</B> to employ more STL features within its own implementation.<P>The first issue I decided to excise was the <B>NUL</B> stuffing. While C pointers are dependent upon a specific value, <B>NUL</B>, to delimit the end of a string, the workings of past-the-end iterators in STL are such that the specific value, if any, beyond the last element of a sequence is immaterial. I began my next version of <B>make_s</B> by switching from the <B>std::string</B> constructor that accepts a C string to the one that accepts a pair of iterators. I had now eliminated the need to modify the source text via <B>NUL</B> stuffing.<P> At the same time, I noticed that the temporary <B>std::string</B> object <B>s</B>   was only being used in two adjacent lines of code (<a href="cuj0301zolman_f1.htm">Figure   1</a>, lines 28-29). Rather than separately instantiating the string on one   line and then using it on the next, I wrote one statement (<a href="cuj0301zolman_f2.htm">Figure   2</a>, line 28) combining the instantiation of a temporary string object (using   the aforementioned two-iterator constructor) with the insertion of that object   into its container. Along with eliminating a named variable, this approach also   seems more likely to offer aggressive code optimizers the opportunity to earn   their keep.<P>Having streamlined the parsing algorithm, I next turned my attention to my choice of data types. Even though the main loop's code appears quite clean while employing the "pointer as iterator" technique, the initialization and cleanup at the extremes of the function make it painfully obvious you're still dealing with raw pointers here. Does the use of these pointers actually offer any benefits? Well, the generated code is nice and short ... but so what?<P>Code size isn't everything. That's a lesson I recently learned well: part of my STL Error Decryptor package [8] is the Proxy CL program, a plug-in replacement for Microsoft Visual C's <B>CL.EXE</B> compiler driver. The original implementation, using C strings exclusively, resulted in a 40-KB executable. I had resisted switching over to using <B>std::string</B> because I was afraid of the potential code bloat the inclusion of <B>std::string</B> would cause. After lamenting to him about the many internal buffer overflows and related problems I'd been grappling with, Thomas Becker (a major contributor to the Proxy CL program) finally shamed me into dropping the C strings, and the subsequent version of the Proxy CL used <B>std::string</B> exclusively for text manipulation. This STL-ized version weighed in at around 200 KB, but I don't think anybody noticed. [9]. Even though 200 KB is over three times the entire system address space of the machines I'd cut my teeth on as an 8080 programmer, by today's standards a program of that size seems to be considered minuscule. In any case, not a single string-related problem ever arose within the Proxy CL program again. I deemed this a worthwhile tradeoff ... it was time to bid <B>make_s</B>'s C strings farewell.<P> Fortunately, due to pointer/iterator duality, the logic of <B>make_s</B>'s   parsing loop remains essentially the same whether the variables are <B>char</B>   pointers or iterators into a <B>std::string</B>. Whereas originally I had to   compute the pointer to the end of the input text by adding the text length to   the beginning pointer (<a href="cuj0301zolman_f2.htm">Figure 2</a>, line 15),   <B>std::string</B> provides the past-the-end iterator I need directly via its   <B>end()</B> member function. I take advantage of <B>end()</B> in the third   version of <B>make_s</B> (<a href="cuj0301zolman_f3.htm">Figure 3</a>, line   19). At this point, it also finally dawned on me that there was no longer any   need to manually replicate the input text. In fact, all the dynamic allocation   code could have been stripped out back in version 2, and the only change I'd   have had to make was to add the <B>const</B> qualifier to a few <B>char</B>   pointer definitions. The fact I hadn't realized this just goes to show that   to a C programmer, the association between text processing and dynamic allocation   is deeply ingrained, indeed.<P> The third version of <B>make_s</B> still accepts a <B>char *</B> as a function   parameter, but uses it only once to define the automatic <B>std::string</B>   object (<a href="cuj0301zolman_f3.htm">Figure 3</a>, line 11) used for all subsequent   processing. My original reason for leaving the in-text parameter as a <B>char   *</B> in version 3 (rather than accepting a <B>std::string</B> and letting <B>string</B>'s   constructor handle actual parameters of type <B>char *</B>) was that a <B>char   *</B> is cheaper to pass than a <B>std::string</B> ... but that would actually   <I>not</I> be the case if the <B>std::string</B> were passed by <I>reference</I>.   Even if the caller of <B>make_s</B> passes a <B>char *</B> as a parameter, it   would work because the compiler would generate a temporary <B>std::string</B>   object to be referenced by the formal parameter. There would even be a potential   gain in efficiency, for if the caller maintained a single <B>std::string</B>   object for use in multiple calls to <B>make_s</B>, a <B>std::string</B> construction   would be avoided for every call. There would no longer any <B>std::string</B>   construction <I>within</I> <B>make_s</B>, resulting in a net savings of one   string constructor call for each use (beyond the first) of the same string in   a call to the function. The penultimate version of <B>make_s</B> (<a href="cuj0301zolman_f4.htm">Figure   4</a>) thus accepts the text input parameter by reference-to-<B>const</B>-string,   and that's the end of it: <B>make_s</B> has now been fully converted from using   raw <B>char</B> pointers to using <B>std::string</B>.<P> There was just one more thing still troubling me. It was so subtle, that I   thought of it once, forgot about it, and later remembered there was <I>something</I>   else I could do, but not what it was. It took another week (in fact, until the   morning of the day of writing this) before I remembered the issue: that pesky   inner loop (<a href="cuj0301zolman_f4.htm">Figure 4</a>, lines 21-22). You're   supposed to prefer the use of STL algorithms to explicit loops, right? So they   say. As simple as this loop (to locate the first non-whitespace character) is,   it's still a loop and thus might qualify for rewriting using a straight call   to some appropriate STL algorithm. In fact it does, as illustrated in <a href="cuj0301zolman_f5.htm">Figure   5</a> (lines 20-21) via use of the <B>std::find_if</B> algorithm, the <B>std::not1</B>   function adapter, and the <B>std::ptr_fun</B> pointer adapter for ordinary functions   (to allow the application of <B>isspace</B> to the algorithm). Despite the perk   of no longer needing to explicitly guard against the possibility of dereferencing   an end iterator, does this conversion necessarily constitute an improvement?   I'm not really sure. I'd have to characterize that as a religious issue. (But,   I'd tend toward the non-STL solution. Call me a Luddite.)<P><h3>Conclusion</h3>Normally I'd have no desire to share early drafts of my software projects. In this case, however, there may be some value in having documented the sequence of successive refinements that propelled this code from pointer land to STL land. Perhaps after viewing the entire journey, you may recognize similar patterns looking to emerge in your own projects -- and remember the shortcut I had to learn the hard way: go directly to STL, do not pass pointers, do not collect 200 coding errors.<P><h3>Notes</h3>[1]  Apologies to Bruce Eckel and Ringo Starr.<P>[2]  This source code archive may be downloaded from &lt;www.bdsoft.com/resources/estlcode.html&gt;.<P>[3]  The complete container initialization library may be downloaded from &lt;www.bdsoft.com/tools/initutil.html&gt;. I say this package is "half-way" original because the structure of these template functions was first put forth by Musser et. al. in their book, <I>STL Tutorial and Reference Guide, 2nd Edition</I> (Addison-Wesley, 2001). InitUtil expands upon the <B>make</B> template presented in that book.<P>[4]  Dan Saks. "Stepping Up to C++: Writing Your First Class," <I>C Users Journal</I>, March 1991.<P>[5]  As Scott Meyers pointed out to me, specifying the <B>value_type</B> of the container shouldn't be necessary since <B>make_s</B> only creates containers of <B>string</B>s. However, that is an issue somewhat tangential to the point of this article; it and other design improvements resulting from pre-publication review (such as Robert Schwartz's suggestion to generalize the ',' delimiter between strings) have been incorporated into the distribution versions of InitUtil. As far as the versions of <B>make_s</B> shown here are concerned, what you see is what I wrote....<P>[6]  Ultimately, through the use of partial template specialization, InitUtil evolved to the point where a single template function name, <B>make_cont</B>, would serve to initialize containers of both string and non-string <B>value_type</B>s. This supercedes both <B>make_i</B> and <B>make_s</B>, even though the two cases are handled quite distinctly. The only compilers I own that can actually compile the latest version of InitUtil (version .92), however, are Comeau C++, gcc 3x, and Metrowerks CodeWarrior 8. Since many current compilers do not yet support partial template specialization and/or other ANSI/ISO C++ features that InitUtil v.92 depends upon, I'm continuing to distribute an alternate version that tolerates Microsoft Visual C++ 6 and .NET by dropping <B>set</B>/<B>multiset</B> support (so as not to require partial template specialization).<P>[7]  <B>push_back</B> won't work for <B>set</B> and <B>multiset</B>, since those containers don't provide it. In the distribution versions of InitUtil, the insertion of values into a container is performed with the aid of a function object using <B>push_back</B>, and twin specializations (for <B>set</B> and <B>multiset</B>) both employing <B>insert</B>. Thus, all standard containers are supported orthogonally for the more Standard-compliant compilers (with the exception of <B>map</B> and <B>multimap</B>, which aren't currently supported).<P>[8]  Leor Zolman. "An STL Error Message Decryptor for Visual C++," <I>C/C++ Users Journal</I>, July 2001, &lt;www.cuj.com/articles/2001/0107/0107b/0107b.htm?topic=articles&gt;.<P>[9]  Of course, this wasn't an embedded system. As Dan Saks pointed out to me, such a jump in code size might not be as easily tolerated in <I>that</I> genre.<p><h3>About the Author</h3>Leor Zolman gives away software development tools and sells/teaches on-site programming workshops in C/C++, STL, Java, Perl, and Unix (Fundamentals and Korn Shell) via his website, &lt;www.bdsoft.com&gt;. Email him at <B>leor@bdsoft.com</B>.<p></BODY></HTML>