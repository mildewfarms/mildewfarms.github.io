<HTML><HEAD><TITLE>The Boehm Collector for C and C++</TITLE></HEAD><body bgcolor="#FFFFFF" text="#000000"><h2>The Boehm Collector for C and C++</h2><h3>Gene Michael Stover</h3><i>Portable, open-source garbage collection, if you're ready for it.</i><p>Now, garbage collection is available for C and C++ programmers. You don't need a new language or a special compiler; it works with plain old C and C++. It's the Boehm collector. The techniques I describe in this article should work with any compiler and operating system to which Boehm has been ported. The Boehm collector works on C++ compilers, ISO/ANSI C compilers, and even pre-Standard C compilers.<P><h3>What Is the Boehm Collector?</h3>The Boehm collector is an open-source library written in C by Hans-J. Boehm. It provides a replacement for <B>malloc</B>, but you don't need to free memory that you allocate with the Boehm collector. You can obtain the Boehm collector at &lt;www.hpl.hp.com/ personal/Hans_Boehm/gc&gt;. On Unix, you install it with <B>./configure; make</B>. It also installs on Windows.<P>The Boehm collector has two headers files and one linkable library. For C, the header file is <B>&lt;gc.h&gt;</B>; for C++, it's <B>&lt;gc_cpp.h&gt;</B>. On Unix, the linkable library is <B>-lgc</B>. To use the Boehm collector, your programs must <B>#include</B> <B>&lt;gc.h&gt;</B> or <B>&lt;gc_cpp.h&gt;</B>, and you must link the program with <B>-lgc</B> (or whatever your platform calls the library).<P>The main interface to the Boehm collector is the function <B>GC_MALLOC</B>. Just like the <B>malloc</B> you know and love, <B>GC_MALLOC</B> allocates a block of memory and returns a pointer to it. Unlike <B>malloc</B>, you don't need to free memory that was allocated by <B>GC_MALLOC</B>. The Boehm collector will free the memory when it is appropriate to do so. It also provides a <B>GC_FREE</B> function that you can use to free a block of memory explicitly. In theory, you can use <B>GC_FREE</B> as a performance improvement. However, in the three large applications and innumerable tiny programs I've written since I began using the Boehm collector, I've found exactly one case in which <B>GC_FREE</B> was necessary to improve performance.<P><h3>Performance</h3>If you're curious or skeptical about the Boehm collector, try an experiment like <a href="cuj0303stover_l1.htm">Listing 1</a>. In a loop, <a href="cuj0303stover_l1.htm">Listing 1</a> creates a large linked list and destroys it. It runs the loop once using <B>malloc</B> and <B>free</B> and then again using <B>GC_MALLOC</B>. (To free the list in the presence of garbage collection, the program just forgets about the list; there's no need to free each node.) For each allocation method, the program prints the number of lists created and destroyed, the number of seconds it looped, the rate at which lists were created and destroyed, and that rate relative to <B>malloc</B>'s rate. (<B>malloc</B>'s relative rate will be 1.0.) When running <a href="cuj0303stover_l1.htm">Listing 1</a> and similar programs on GNU/Linux, I've seen the Boehm collector perform 1.69 times faster than <B>malloc</B>/<B>free</B>; on OpenBSD, more than twice as fast; and on Microsoft Windows NT 4, more than 13 times faster. <P><h3>Plain C</h3>The Boehm collector provides one main function, <B>GC_MALLOC</B>, which is conceptually equivalent to <B>malloc</B>, but you don't need to free the memory. So to use the Boehm collector when programming in plain C, use <B>GC_MALLOC</B> and never free anything.<P>Older libraries will allocate memory with <B>malloc</B>. Standard C's <B>strdup</B> is one such offender. You must be careful to call <B>free</B> on memory that those functions <B>malloc</B> for you, and you must be careful not to allow them to call <B>free</B> on memory you've allocated with <B>GC_MALLOC</B>. Also, the Boehm collector might not take memory that was <B>malloc</B>ed into account when determining what memory it can recycle, so it's best to rely on <B>GC_MALLOC</B> whenever possible [1].<P>If you are able to convert those old libraries to use the Boehm collector instead of <B>malloc</B>, the danger of mixing <B>GC_MALLOC</B> with <B>free</B> will disappear. A nice side effect of the conversions is that many lines of source code disappear; a benefit of garbage collection is that you needn't write code to guard against leaking memory in the face of exceptions.<P> <B>GC_MALLOC</B> is a bit of a bother to type, and who knows, maybe I'll use   a different garbage collection system in the future. So I wrap <B>GC_MALLOC</B>   in a function called <B>xmalloc</B>. I similarly wrap <B>GC_FREE</B> and <B>GC_REALLOC</B>.   <a href="cuj0303stover_l2.htm">Listing 2</a> shows example implementations of   these functions.<P>That's all you need to know to use the Boehm collector in C.<P><h3>C++'s Double-Edged Sword of Destruction</h3>C++'s destructors create some problems for garbage collectors. The problems aren't insurmountable, but you need to understand them or it will always bother you that garbage collectors can't call all your destructors for you.<P>Notice that languages with built-in garbage collection don't use destructors. Java has destructors (called finalizers), true, but they are discouraged, and it is explicit that the programmer cannot predict when or whether Java's garbage collector will call an object's destructor. C# offers destructors and <B>Finalize</B> methods, but, like Java, doesn't allow programmers to call destructors directly. Python has similar semantics. Ada, Lisp, and Smalltalk don't have destructors except as implementation-specific extensions. Why do those languages avoid destructors?<P>A garbage collector can't guarantee that all destructors are called in the same order you'd call them explicitly. If there are referential cycles in your data, such as from a circularly linked list, a bi-directionally linked list, or a more general network of data, the garbage collector can either (1) fail to collect the memory involved or (2) collect it in some arbitrary order. What's more, isolating those networks can be difficult, so even a garbage collector that promises to collect them all might wait until the end of the program. So in the general case of using a garbage collector, you can't predict when or whether a particular block of memory will be recycled. For these reasons, languages with built-in garbage collection choose to avoid destructors.<P>C++ has had destructors from its beginning, and they play important roles in some programming idioms that C++ programmers use. For example, the "object creation is resource acquisition" idiom depends on them. So C++ needs destructors. It's an apparent dilemma, reconciling C++'s use of destructors with garbage collection's inability to guarantee when or whether a given destructor is called, but in practice, it isn't a problem.<P>For example, mutual exclusion can be implemented conveniently with a lock object on the stack. It's important that the lock object's constructor and destructor are called at appropriate times. Likewise, you usually create <B>fstream</B> objects on the stack, and it's important that the <B>fstream</B>'s destructor is called to close the file. When an object is on the stack, garbage collection isn't involved at all, so its destructor will be called correctly, when your program exits the lexical block containing the object. These important cases present no conflict between destructors and garbage collection.<P>Even if you must allocate a <B>new</B> object, if you know when to call a destructor at run time, you can determine the place in the code to explicitly delete it. So the destructor will execute at the correct time, and the garbage collection system will reclaim the memory in its own time. This suggests that garbage collection is a form of memory management, destructors are part of object management, and the two don't need to overlap.<P>In programs without garbage collection, a common activity in destructors is to free memory, but once a program uses the Boehm collector, the destructor doesn't have this responsibility, so all the memory-management code in destructors disappears. Many destructors disappear entirely.<P><h3>Boehm's C++ Interface</h3>The Boehm collector's C++ interface is declared in a header file called <B>&lt;gc_cpp.h&gt;</B>, which comes with the Boehm collector distribution.<P>For POD (Plain Old Data) and for classes without destructors, you can use the Boehm collector's overloaded <B>::operator new (GCPlacement)</B>. To allocate POD or an object under the Boehm collector's control, specify <B>UseGC</B> for the <B>GCPlacement</B> argument. For example, you could allocate an <B>int</B> with <B>int *i = new (UseGC) int;</B>. Use the new POD or object normally, but never, ever delete it. If you delete it, the compiler will probably emit its usual code to free memory, which will conflict with the Boehm collector. The Boehm collector won't even try to call the destructors on data allocated this way.<P>For classes with destructors, the Boehm collector provides class <B>gc</B>. It overrides <B>operator new</B> and <B>operator delete</B> so that you may allocate and delete instances. The Boehm collector will recycle the memory automatically, but if you want the destructor to be called, you must delete the object yourself. You may create instances on the stack; their destructors will be called because the Boehm collector won't be involved at all.<P>If you need a new class with destructors that the Boehm collector calls automatically, you may subclass the Boehm collector's class <B>gc_cleanup</B>. It's like class <B>gc</B> except that it arranges for the Boehm collector to call the destructor immediately before recycling an instance's memory. Remember that you have no guarantee that all instances will be recycled.<P> <a href="cuj0303stover_l3.htm">Listing 3</a> demonstrates all three techniques.   Notice that I don't delete the POD; that would be an error. I delete the <B>ManualDelete</B>   objects explicitly, which I must do if I want their destructors called. I delete   one of the <B>AutoDelete</B> instances explicitly to show that it can be done,   but I rely on the Boehm collector to delete the rest. Also notice that I create   <B>ManualDelete</B>s and <B>AutoDelete</B>s on the stack to show that it can   be done. In the program's output (<a href="cuj0303stover_l4.htm">Listing 4</a>),   notice that the destructors for all the <B>ManualDelete</B> instances were called   but that some <B>AutoDelete</B> destructors were not. That's an example of how   you cannot predict when or whether a garbage collector will recycle any particular   object.<P>There's one more type of class you might need to use with the Boehm collector: classes whose destructors must be called but which are not subclasses of <B>gc</B> or <B>gc_cleanup</B>. In other words, it's most classes you're likely to encounter. If you allocate, say, an <B>std::list</B> with <B>new(UseGC)</B>, you'll need to delete that list to call its destructor, but if you delete it, the C++ compiler will emit non-Boehm deallocation code, which will cause an error.<P> So what to do? Simple: create a class template whose instance classes are   subclasses of the old class and of Boehm's <B>gc_cleanup</B>. <a href="cuj0303stover_l5.htm">Listing   5</a> shows class template <B>Boehmable</B>, which makes a new, garbage-collected   class from an old class and <B>gc_cleanup</B>. You can rely on the Boehm collector   to call most of the destructors; I've included some counting code to demonstrate   that. (The counting code isn't needed in production.) When you must ensure that   a destructor is called, you can delete an object yourself, but be sure that   in the lexical scope where you do so, the compiler knows that the object you   are deleting inherits from <B>gc_cleanup</B>. If not, the compiler will emit   an ordinary <B>delete</B> instead of <B>gc_cleanup</B>'s overridden <B>operator   delete</B>.<P><h3>STL Collections</h3>Collections from the STL work fine with the Boehm collector because they manage their memory internally. (That's encapsulation in action.) In addition, you can create an allocator that uses Boehm's <B>GC_MALLOC</B>, and you can give that allocator to your STL collections so that all the memory they allocate will be subject to garbage collection. This isn't necessary, though, because the semantics of STL collections allow them to determine precisely when to delete their privately allocated memory, and they are already implemented with that in mind. In other words, where STL collections meet the Boehm collector, just use the STL collections normally.<P>If you write your own classes that are similarly able to determine when their memory isn't needed, it's best if you allocate that memory through the Boehm collector because the Boehm collector works best when it controls most (or all) dynamically allocated memory. The documentation warns that the Boehm collector might not scan <B>malloc</B>ed memory, so it could recycle a memory region if the only reference to it were in a <B>malloc</B>ed block of memory, but I haven't seen this situation arise. So in those cases where you can easily and definitely determine when a chunk of memory is no longer needed, free it explicitly by calling <B>GC_FREE</B> (or the <B>xfree</B> I suggested for plain C).<P><h3>C++ Heuristics</h3>I've described a lot of details about using the Boehm collector with C++. To summarize them as rules of thumb, they are:<P>1.  Adopt the mental habit of keeping work out of destructors. C++ programmers must make this change for maximum benefit from garbage collection, whether it's the Boehm collector or some future version of C++ that compiles to a virtual machine with built-in garbage collection.<P>2.  Use <B>new (UseGC) ...</B> to allocate POD. Never delete it!<P>3.  Make <B>gc</B> or <B>gc_cleanup</B> a virtual base class of your new classes.<P>4.  Use class template <B>Boehmable</B> with old classes.<P>5.  If the timing of an object's destructor is critical, it means the object must be on the stack. (<B>fstream</B>s and lock objects are examples.)<P><h3>Extra Boehm Collector Details</h3>The basic interface I've described is all you need to use the Boehm collector most of the time, but the Boehm collector provides other options, which are documented in <B>&lt;gc.h&gt;</B>. The most useful of these is probably finalizer functions. There are also functions to allocate uncollectable memory and atomic memory, but these are optimizations and I haven't needed any of them in practice. I suspect they should be invoked if and only if your profiler tells you they are needed.<P><h3>Conclusion</h3>Programmers from languages that have had garbage collection for a long time can attest that garbage collection improves programmer productivity. Now, thanks to the Boehm collector, it's easy for C and C++ programmers to use these benefits, too.<P><h3>Note</h3>[1]  C library implementers could treat <B>malloc</B> and <B>free</B> as a standard interface to memory management. Their default behaviors could be the traditional <B>malloc</B> and <B>free</B>, but you could specify alternative functions at run time, such as <B>GC_MALLOC</B> and <B>GC_FREE</B>. That would allow you to choose your own memory-management system, possibly for debugging or because you have one that's specially optimized for your application domain. Old code would still work fine.<p><h3>About the Author</h3>Gene Michael Stover (<B>gene@acm.org</B>) is an independent consultant. His current primary interests include online publishing and source-code portability.<p></BODY></HTML>