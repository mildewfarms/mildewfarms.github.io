<HTML><HEAD><TITLE>Limiting Template Symbol Size</TITLE></HEAD><body bgcolor="#FFFFFF" text="#000000"><h2>Limiting Template Symbol Size</h2><h3>Alex Gontmakher and Shachar Itzhaki</h3>One of the most important improvements of C++ over C is the ability to distinguish at compile time between different functions with the same name. This feature, however, comes at a price: the function names must be mangled (i.e., modified to contain both the name of the class they belong to and the descriptions of the parameters).<p><P> The mangled names are usually only slightly longer than the original ones.   However, when you start using templates, the symbols begin getting very large,   and that can become a serious problem. In fact, one of the worst problems in   the once long-awaited Microsoft VC++ 4 was that it was unable to compile STL-based   code because of 256-character limit on the symbol size. But it can get much   worse than that. <a href="cuj0303gontmak_l1.htm">Listing 1</a> shows a seemingly   innocent piece of code that uses a map from a string to a vector of strings.   When compiled with g++, the size of the largest symbol produced by the compiler   is 1,997 bytes! This is actually quite modest compared to other compilers. For   example, if compiled with HP aCC compiler, the largest symbol produced is 4,246   bytes. To make things even worse, aCC has 4,000-byte limit on symbol size, so   normally it is not able to compile the code at all. <P>One solution to the problem is to just use shorter names in your code. For instance, instead of template <B>&lt;class T&gt;</B> class <B>my_proj::AVeryLongDescriptiveName</B>, you could use just <B>my_proj::AShortName</B> and then define a <B>typedef</B> to be able to use the long variant of the name in your code. Unfortunately, this solution requires template <B>typedefs</B>, which are not currently a part of the C++ Standard (if planned for inclusion in the future).<P>However, there is an easy way to solve the problem -- template parameter substitution.<P>Note that you do not have to actually hold <B>std::string</B>s in the map, but instead something compatible with them. Therefore, you can write a simple non-template class <B>gtring</B> that inherits <B>std::string</B> and use it as the key to the map. Similarly, you can inherit <B>gstringvector</B> from <B>std::vector&lt;std::string&gt;</B>.<P>In inheriting <B>gtring</B> from <B>std::string</B>, you lose none of the latter's functionality, except possibly for some of the constructors. Therefore, the substitution is transparent to the users of the map.<P> <a href="cuj0303gontmak_l2.htm">Listing 2</a> shows the full implementation   of this technique. In the first case (<B>#ifdef SMART</B>), only the first parameter   is substituted. In the second (<B>#ifdef SMARTER</B>), we change both parameters. <P> <a href="cuj0303gontmak_t1.htm">Table 1</a> shows the size of the largest   symbol in the resulting program. As you can see, the size is reduced by more   than a factor of five. <P> You may find this technique useful even when the compiler does not choke on   your code. <a href="cuj0303gontmak_t2.htm">Table 2</a> shows the size of the   executable file when compiled with the different options. You can see that the   file size is reduced by a factor of two, saving as much as 800 KB on a single   template instance. <p><h3>About the Authors</h3>Alex Gontmakher has a B.A. and M.A. in Computer Science from Technion, Israel Institute of Technology, and is currently studying towards a Ph.D. In addition, he is working as a full-time software engineer. His interests include parallel programming and computer architecture.<P>Shachar Itzhaki works as a full-time software engineer. His expertise includes C++ and Python programming and software design. He is currently studying towards an M.Sc. degree in Computer Science at the Open University.<p></BODY></HTML>