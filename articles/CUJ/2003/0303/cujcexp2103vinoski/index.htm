<HTML>   
     <HEAD>
<TITLE>March 2003/Object Interconnections</TITLE></HEAD>
<BODY BACKGROUND="" BGCOLOR="#FFFFFF" TEXT="#000000">

<HR>

<H2 ALIGN="center"><FONT COLOR="#800000">Object Interconnections: CORBA Metaprogramming Mechanisms, Part 1: Portable Interceptors Concepts and Components</FONT></H2>
<H3 ALIGN="center"><FONT COLOR="#800000">Douglas C. Schmidt and Steve Vinoski</FONT></H3>

<HR>
<BLOCKQUOTE>

<p>CORBA middleware has been used successfully in domains ranging from telecommunications to aerospace, process automation, and e-commerce to enable developers to create applications rapidly that can meet a particular set of requirements with a reasonable amount of effort. Historically, however, many CORBA solutions have tightly coupled interfaces and implementations, which make it hard to adapt to requirement or environment changes that occur late in an application's life cycle (i.e., during deployment and/or at run time). To address this problem, CORBA supports <i>metaprogramming mechanisms</i> <a href="#1">[1]</a> that improve the adaptability of distributed applications by allowing their behavior to be modified with little or no change to existing application software.</p> 
<p>This column describes CORBA <i>Portable Interceptors</i>, which are objects that an ORB invokes in the path of an operation invocation to monitor or modify the behavior of the invocation transparently. Portable Interceptors are a metaprogramming mechanism that implements the <i>Interceptor pattern</i> [<a href="#2">2</a>, <a href="#3">3</a>], which allows applications to extend and control the behavior of a framework. Since the CORBA Portable Interceptor specification is fairly large, we focus on concepts and components in this column and defer our C++ programming examples until the next column. Subsequent columns will then discuss other CORBA metaprogramming mechanisms, such as extensible transports and smart proxies.</p>

<H3><FONT COLOR="#000080">Overview of CORBA Metaprogramming Mechanisms</FONT></H3>

<p>CORBA middleware provides stub and skeleton mechanisms that serve as a &quot;glue&quot; between the client and servants, respectively, and the ORB. CORBA stubs implement the Proxy pattern <a href="#4">[4]</a> and marshal operation information and data type parameters into a standardized request format. Likewise, CORBA skeletons implement the Adapter pattern <a href="#4">[4]</a> and demarshal the operation information and typed parameters stored in the standardized request format.</p>
<p>CORBA stubs and skeletons can be generated automatically from interfaces defined using OMG IDL. A CORBA IDL compiler transforms application-supplied OMG IDL definitions into stubs and skeletons written using a particular programming language, such as C++ or Java. In addition to providing programming language and platform transparency, an IDL compiler eliminates common sources of network programming errors and provides opportunities for automated compiler optimizations <a href="#5">[5]</a>.</p>
<p>Traditionally, the stubs and skeletons generated by an IDL compiler are fixed (i.e., the code emitted by the IDL compiler is determined at translation time). This design shields application developers from the tedious and error-prone network programming details needed to transmit client operation invocations to server object implementations. Fixed stubs and skeletons make it hard, however, for applications to adapt readily to certain types of changes in requirement or environmental conditions, such as: </p>

<UL><LI>The need to log information or monitor system resource utilization may not be recognized until after an application has been deployed.</LI>
<LI>There may be a need to acquire extra debugging information at run time about a problematic application at a customer site.</LI>
<LI>Remote operations may require additional parameters and authentication protocols to execute securely in certain environments. </LI>
<LI>The priority at which clients invoke or servers handle a request may vary according to environmental conditions, such as the amount of CPU or network bandwidth available at run time.</LI>
<LI>The actual host on which a remote operation is executed may need to change at run time depending on system workload and resource availability. </LI>
</UL>

<p>In applications based on CORBA middleware with conventional fixed stubs/skeletons, these types of changes often require reengineering and restructuring of existing application software. One way to minimize the impact of these changes is to employ metaprogramming mechanisms that allow applications to adapt to various types of changes with little or no modifications to existing software. For example, stubs, skeletons, and certain other points in the end-to-end operation invocation path can be treated as meta-objects <a href="#1">[1]</a>, which are objects that refine the capability of base-level objects that comprise the bulk of application programs.</p>
<p>As shown in <a href="vinoski_fig1.htm">Figure 1</a>, CORBA ORBs are responsible for transmitting client operation invocations to target objects. When a client invokes an operation, a stub implemented as a meta-object can act in conjunction with transport-protocol meta-objects to access and/or transform a client operation invocation into a message and transmit it to a server. Corresponding meta-objects on the server's request processing path can access and/or perform inverse transformations on the operation invocation message and dispatch the message to its servant. An invocation result is delivered in a similar fashion in the reverse direction.</p>
<p>As all operation invocations pass through meta-objects, certain aspects of application and middleware behavior can be adapted transparently when system requirements and environmental conditions change by simply modifying the meta-objects. To modify meta-objects, the DOC middleware can either (1) provide mechanisms for developers to install customized meta-objects for the client or (2) embed hooks implementing a MOP (meta-object protocol) <a href="#1">[1]</a> in the meta-objects and provide mechanisms to install objects implementing the MOP to strategize these meta-object behaviors. In the context of CORBA, there are various mechanisms that can implement the MOP:</p> 

<UL>
<LI><b>Smart Proxies</b>, which are application-defined stub implementations that transparently override the default stubs created by an ORB to customize client behavior on a per-interface basis.</LI>
<LI><b>Portable Interceptors</b>, which are objects that an ORB invokes in the path of an operation invocation to monitor or modify the behavior of the invocation transparently.</LI>
<LI><b>Servant Managers</b>, which allow server applications to register objects that activate servants on demand, rather than creating all servants before listening for requests.</LI>
<LI><b>Extensible Transports</b>, which decouple the ORB's transport protocols from its component architecture so that developers can add new protocols without requiring changes to the ORB or application software.</LI>
</UL>

<p>This column focuses on Portable Interceptors; Servant Managers were described in <a href="#6">[6]</a>. Future columns in this series will cover Smart Proxies and Extensible Transports.</p>

<H3><FONT COLOR="#000080">Overview of Portable Interceptors</FONT></H3>

<p>As outlined above, CORBA Portable Interceptors are a metaprogramming mechanism that can increase the flexibility of client and server applications. Portable Interceptors are standard meta-objects that stubs, skeletons, and certain points in the end-to-end operation invocation path can invoke at predefined &quot;interception points.&quot; Two types of interceptors are defined in the CORBA Portable Interceptor specification:</p>

<UL>
<LI><b>Request interceptors</b>, which deal with operation invocations.</LI>
<LI><b>IOR interceptors</b>, which insert information into IORs (interoperable object references). </LI>
</UL>

<p>We describe both types of interceptors in this section. </p>

<H4><FONT COLOR="#000080">Request Interceptors</FONT></H4>

<p>Request interceptors can be decomposed into client request interceptors and server request interceptors, which are designed to intercept the flow of a request/reply sequence through the ORB at specific points on clients and servers, respectively. Developers can install instances of these interceptors into an ORB via an IDL interface defined by the CORBA Portable Interceptor specification. Regardless of what interface or operation is invoked, after request interceptors are installed they will be called on every operation invocation at the predetermined ORB interception points shown in <a href="vinoski_fig2.htm">Figure 2</a>.</p>
<p>As shown in <a href="vinoski_fig2.htm">Figure 2</a>, request interception points occur at four points along the end-to-end invocation path from client to server. There are a total of 10 different interception hook methods that can be called at different points in this interceptor chain, including:</p>

<UL><LI><i>When a client sends a request </i>(e.g., the <b>send_request()</b> hook is called on the client before the request is marshaled).</LI>
<LI><i>When a server receives a request </i>(e.g., the <b>receive_request()</b> hook is called on the server after the request is demarshaled).</LI>
<LI><i>When a server sends a reply</i> (e.g., the <b>send_reply()</b> hook is called on the server before the reply is marshaled). </LI>
<LI><i>When a client receives a reply</i> (e.g., the <b>receive_reply()</b> hook is called on the client after the reply is demarshaled).</LI>
</UL>

<p>Compared to a client invocation path, a server invocation path has an additional interception point called <b>receive_request_service_contexts()</b>, which is invoked before the POA dispatches a servant manager. This interception point prevents unnecessary upcalls to a servant. For example, in the CORBA Security Service <a href="#7">[7]</a> framework this interception point can be used to inspect security-related credentials piggybacked in a service context list entry. If the credentials are valid, the upcall can proceed to other interceptors (if they exist) or to the servant; if not, an exception will be returned to the client.</p> 
<p>Application developers can customize the behavior of their software at interception points as follows:</p>

<OL><LI>Subclass from the appropriate base class, such as <b>PortableInterceptor::ClientRequestInterceptor</b> or <b>PortableInterceptor::ServerRequestInterceptor</b>, and overriding the appropriate hook method(s), such as <b>send_request()</b> or <b>receive_request()</b>.</LI>
<LI>Creating an instance of the subclass and registering it with the ORB. Interceptors are installed in the ORB via an <b>ORBInitializer</b> object and registered by implementing its <b>pre_init()</b> or <b>post_init()</b> method and calling <b>PortableInterceptor::register_orb_initializer()</b> prior to calling <b>CORBA::ORB_init()</b>.</LI>
</OL>

<p>At run time, an interceptor can examine the state of the request that it is associated with and perform various actions based on the state. For example, interceptors can invoke other CORBA operations, access information in a request, insert/extract piggybacked messages in a request's service context list, redirect requests to other target objects, and/or throw exceptions based on the object the original request is invoked upon and the type of the operation. Each of these capabilities is described below:</p>

<UL>
<LI><b>Nested invocations.</b> A request interceptor can invoke operations on other CORBA objects before the current invocation it is intercepting completes. For example, monitoring and debugging utilities can use this feature to log information associated with each operation invocation. To avoid causing infinite recursion, developers must be careful to act only on targeting interfaces and operations they intend to affect when performing nested invocations in an interceptor. </LI>
<LI><b>Accessing request information.</b> Request interceptors can access information associated with an invocation, such as the operation name, parameters, exception lists, return values, and the request id via the MOP interface as defined in the Portable Interceptor specification. Interceptors cannot, however, modify parameters or return values. This request/reply information is encapsulated in an instance of <b>ClientRequestInfo</b> or <b>ServerRequestInfo</b> classes, which derive from the <b>RequestInfo</b> class and contain the information listed above for each invocation. For example, client request interceptors are passed <b>ClientRequestInfo</b> and server request interceptors are passed <b>ServerRequestInfo</b>. These <b>RequestInfo</b>-derived objects can use features provided by the CORBA <b>Dynamic</b> module, which we've covered in our recent columns on Dynamic CORBA [<a href="#8">8</a>, <a href="#9">9</a>, <a href="#10">10</a>]. This module is a combination of pseudo-IDL types, such as <b>RequestContext</b> and <b>Parameter</b>, declared in earlier CORBA specifications. These types facilitate on-demand access of request information from <b>RequestInfo</b> to avoid unnecessary overhead if an interceptor does not need all the information available with <b>RequestInfo</b>.</LI>
<LI><b>Service context manipulation.</b> As mentioned earlier, request interceptors cannot change parameters or the return value of an operation. They can, however, manipulate service contexts that are piggybacked in operation requests and replies exchanged between the clients and servers. A service context is a sequence field in a GIOP message that can transmit &quot;out-of-band&quot; information, such as authentication credentials, transaction contexts, operation priorities, or policies associated with requests. For example, the CORBA Security Service <a href="#7">[7]</a> uses request interceptors to insert user identity via service contexts. Likewise, the CORBA Transaction Service uses request interceptors to insert transaction-related information into service contexts so it can perform extra operations, such as commit/rollback, based on the operation results in a transaction. Each service context entry has a unique service context identifier that applications and CORBA components can use to extract the appropriate service context.</LI> 
<LI><b>Location forwarding.</b> Request interceptors can be used to forward a request to a different location, which may or may not be known to the ORB in advance. This capability is performed via the <b>PortableInterceptor::ForwardRequest</b> exception, which allows an interceptor to inform the ORB that a retry should occur upon the new object indicated in the exception. The exception can also indicate whether the new object should be used for all future invocations or just for the forwarded request. Since the <b>ForwardRequest</b> exception can be raised at most interception points, it can be used to provide fault tolerance and load balancing <a href="#11">[11]</a>. For example, the IOR of a replicated object can be used as the forward object in this exception. When the object dies for some reason &#151; and  this situation is conveyed to the interceptor &#151; this exception can be raised even before the POA tries to make an upcall.</LI>
<LI><b>Multiple interceptors.</b> Multiple request interceptors can be registered with an ORB, which will then iterate through them and invoke the appropriate interception operation at every interception point according to the following rules: </LI> 
    <OL><LI>For each request interceptor, only one <i>starting interception point</i> can be called for a given invocation. A starting interception point is the first point invoked in a request/reply sequence. For instance, the starting points for a client ORB include <b>send_request()</b> and <b>send_poll()</b>. Likewise, the starting point for a server ORB is <b>receive_request_service_contexts()</b>.</LI>
        <LI>For each request interceptor, only one <i>ending interception point</i> can be called for a given invocation. The ending interception point is the last juncture where an interception may occur in the request/reply sequence. The ending interception points on a client ORB are <b>receive_reply()</b>, <b>receive_exception()</b>, and <b>receive_other()</b> and the ending interception points for a server ORB consist of <b>send_reply()</b>, <b>send_exception()</b>, and <b>send_other()</b>.</LI>
        <LI>There can be multiple intermediate interception points.</LI>
        <LI>Intermediate interception points cannot be invoked in the case of an exception.</LI>
        <LI>The ending interception point for a given interceptor will be called only if the starting interception point runs to completion.</LI></OL>
<p>Multiple interceptors are invoked using a flow-stack model. When initiating an operation invocation, an interceptor is pushed onto the stack after its starting interception point completes successfully. When an invocation completes, the interceptors are popped off the stack and invoked in reverse order. The flow-stack model ensures that only interceptors executed successfully for an operation can process the reply/exceptions.</p> 
<LI><b>Exception handling.</b> Request interceptors can affect the outcome of a request by raising exceptions in the inbound or outbound invocation path. In such cases, the <b>send_exception()</b> operation of a server request interceptor is invoked on the reply path and is received at the client in the <b>receive_exception()</b> interceptor hook. When a <b>send_exception()</b> or <b>receive_exception()</b> operation raises a <b>ForwardRequest</b> exception, the other interceptors have their <b>send_other()</b> and <b>receive_other()</b> interception points invoked, respectively. </LI> 
</UL>

<H4><FONT COLOR="#000080">IOR Interceptors</FONT></H3>

<p>IIOP v1.1 introduced an attribute called <i>components</i>, which contains a list of <i>tagged components</i> to be embedded within an IOR. When an IOR is created, tagged components provide a placeholder for an ORB to store extra information pertinent to the object. This information can contain various types of QoS information related to security, server thread priorities, network connections, CORBA policies, or other domain-specific information.</p> 
<p>The original IIOP v1.0 specification provided no standard way for applications or services to add new tagged components into an IOR. Services that require this field were therefore forced to use proprietary ORB interfaces, which impeded their portability. The Portable Interceptors specification resolves this problem by defining <i>IOR interceptors</i>.</p>
<p>IOR interceptors are objects invoked by the ORB when it creates IORs. They allow an IOR to be customized (e.g., by appending tagged components). Whereas request interceptors access operation-related information via <b>RequestInfo</b>s, IOR interceptors access IOR-related information via <b>IORInfo</b>s. <a href="vinoski_fig3.htm">Figure 3</a> illustrates the behavior of IOR interceptors.</p>
<p>A server ORB that is responsible for creating an IOR contains an <i>IOR interceptor repository</i>. In turn, this repository contains a series of IOR interceptors that have been registered with the ORB. When the server process requests the ORB to create an IOR, the ORB iterates through the IOR interceptors in the repository using the <b>establish_components()</b> operation. The IOR interceptors then add tagged components to the IOR being generated by referring to the <b>IORInfo</b> passed in by calling <b>add_ior_component()</b> or <b>add_ior_component_to_profile()</b>.</p>

<H3><FONT COLOR="#000080">Concluding Remarks</FONT></H3>

<p>CORBA shields developers from many tedious and error-prone aspects of programming distributed applications. Without proper support from the middleware, however, it can be hard to evolve distributed applications after they are deployed. This column has discussed how the concepts and components in the CORBA Portable Interceptors specification help the adaptability of distributed applications by allowing their behavior to be modified without changing existing software drastically. Interceptors can be applied to either servers or clients and can access operation-specific information. They therefore provide an effective metaprogramming mechanism to handle advanced features, such as authentication and authorization, transparently end-to-end.</p>
<p>This column concludes the introduction to our multi-part series on CORBA metaprogramming mechanisms. Our next column will illustrate how to program Portable Interceptors using C++. Subsequent columns will cover other CORBA metaprogramming mechanisms. As always, if you have comments, questions, or suggestions regarding CORBA or our column in general, please let us know at <a href="mailto:object_connect@cs.wustl.edu">object_connect@cs.wustl.edu</a>.</p>

<H3><FONT COLOR="#000080">References</FONT></H3>

<p><a name="1"></a>[1] Nanbor Wang, Douglas C. Schmidt, Ossama Othman, and Kirthika Parameswaran. &quot;Evaluating Metaprogramming Mechanisms for ORB Middleware,&quot; <i>IEEE Communication Magazine</i>, October 2001.</p>
<p><a name="2"></a>[2] Douglas C. Schmidt, Michael Stal, Hans Rohnert, and Frank Buschmann. <i>Pattern-Oriented Software Architecture: Patterns for Concurrent and Networked Objects</i> (Wiley and Sons, 2000).</p>
<p><a name="3"></a>[3] Steve Vinoski. &quot;Toward Integration: Chain of Responsibility,&quot; <i>IEEE Internet Computing</i>, November/December 2002, pp. 80-83.</p>
<p><a name="4"></a>[4] Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides. <i>Design Patterns: Elements of Reusable Object-Oriented Software</i> (Addison-Wesley, 1995).</p>
<p><a name="5"></a>[5] Eric Eide, Kevin Frei, Bryan Ford, Jay Lepreau, and Gary Lindstrom. &quot;Flick: A Flexible, Optimizing IDL Compiler,&quot; Proceedings of ACM SIGPLAN '97 Conference on Programming Language Design and Implementation (PLDI), Las Vegas, NV, June 1997.</p>
<p><a name="6"></a>[6] Douglas C. Schmidt and Steve Vinoski. &quot;C++ Servant Managers for the Portable Object Adapter,&quot; <i>C++ Report</i>, September 1998.</p>
<p><a name="7"></a>[7] Object Management Group. &quot;Security Service Specification,&quot; OMG Document formal/02-03-11version 1.8, March 2002. </p>
<p><a name="8"></a>[8] Steve Vinoski and Douglas C. Schmidt. &quot;Object Interconnections: Dynamic CORBA: Part 1, The Dynamic Invocation Interface,&quot; <i>C/C++ Users Journal</i> <i>C++ Experts Forum</i>, July 2002, <a href="c:\www.cuj.com/experts/2007/vinoski.htm">&lt;www.cuj.com/experts/2007/vinoski.htm&gt;</a>.</p>
<p><a name="9"></a>[9] Steve Vinoski and Douglas C. Schmidt. &quot;Object Interconnections: Dynamic CORBA: Part 2, Dynamic Any,&quot; <i>C/C++ Users Journal C++ Experts Forum</i>, September 2002, <a href="c:\www.cuj.com/experts/2009/vinoski.htm">&lt;www.cuj.com/experts/2009/vinoski.htm&gt;</a>.</p>
<p><a name="10"></a>[10] Steve Vinoski and Douglas C. Schmidt. &quot;Object Interconnections: Dynamic CORBA: Part 3, The Dynamic Skeleton Interface,&quot; <i>C/C++ Users Journal C++ Experts Forum</i>, November 2002, <a href="c:\www.cuj.com/experts/2011/vinoski.htm">&lt;www.cuj.com/experts/2011/vinoski.htm&gt;</a>.</p>
<p><a name="11"></a>[11] Ossama Othman, Carlos O'Ryan, and Douglas C. Schmidt. &quot;An  Efficient Adaptive Load Balancing Service for CORBA,&quot; <i>IEEE Distributed Systems Online</i>, March 2001.</p>
<p><a name="12"></a>[12] Object Management Group. &quot;The Common Object Request Broker: Architecture and Specification Revision 3.0,&quot; OMG Technical Document formal/XYZ02-06-33, July 2002. </p>
<p><a name="13"></a>[13] Michi Henning and Steve Vinoski. <i>Advanced CORBA Programming with C++</i> (Addison-Wesley, 1999).</p>

<H3><FONT COLOR="#000080">About the Author</FONT></H3>
<p><B><A HREF="http://www.iona.com/hyplan/vinoski/">Steve Vinoski</A></B> is vice president of Platform Technologies and chief architect for IONA Technologies and is also an IONA Fellow. A frequent speaker at technical conferences, he has been giving CORBA tutorials around the globe since 1993. Steve helped put together several important OMG specifications, including CORBA 1.2, 2.0, 2.2, and 2.3; the OMG IDL C++ Language Mapping; the ORB Portability Specification; and the Objects By Value Specification. In 1996, he was a charter member of the OMG Architecture Board. He is currently the chair of the OMG IDL C++ Mapping Revision Task Force. He and Michi Henning are the authors of <a href="http://cseng.aw.com/book/0,,0201379279,00.html"><i>Advanced CORBA Programming with C++</i></a>, published in January 1999 by Addison Wesley Longman. Steve also represents IONA in the W3C (World Wide Web Consortium) Web Services Architecture Working Group.</p> 
<p><B><A HREF="http://www.cs.wustl.edu/~schmidt/">Doug Schmidt</A></b> is a full professor at Vanderbilt University.  His research focuses on patterns, optimization principles, model-based software development, and empirical analyses of object-oriented techniques that facilitate the development of high-performance, real-time distributed object computing middleware on parallel processing platforms running over high-speed networks and embedded-system interconnects. He is the lead author of the books <A HREF="http://www.cs.wustl.edu/~schmidt/POSA/"><i>Pattern-Oriented Software Architecture: Patterns for Concurrent and Networked Objects</i></A>, published by Wiley and Sons, and <A HREF="http://www.cs.wustl.edu/~schmidt/ACE/book1/"><i>C++ Network Programming: Mastering Complexity with ACE and Patterns</i></A> and <A HREF="http://www.cs.wustl.edu/~schmidt/ACE/book2/"><i>C++ Network Programming: Systematic Reuse with ACE and Frameworks</i></A> both published by Addison-Wesley. He can be contacted at <A HREF="mailto:schmidt@isis-server.isis.vanderbilt.edu ">schmidt@isis-server.isis.vanderbilt.edu</A>.</p>


</BLOCKQUOTE></BODY></HTML>
