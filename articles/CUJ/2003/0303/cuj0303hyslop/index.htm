<HTML><HEAD><TITLE>Conversations: Once Is Not Enough</TITLE></HEAD><body bgcolor="#FFFFFF" text="#000000"><HR><h2>Conversations: Once Is Not Enough</h2><h3><font color="000080">Jim Hyslop and Herb Sutter</font></h3><i>Don't let Singletons degenerate into global variables.</i><p><I>Copyright 2003, Jim Hyslop and Herb Sutter</I><P>I was trying to write unit tests for some code I'd developed. Trying -- that's what the code was, all right. I kept running into brick walls. I suppressed my urge to let out a primeval scream and settled for a nice, quiet sigh.<P>"Wazzup, pardner?" Wendy's voice floated over the cubicle wall. Either I had sighed louder than I'd thought, or Wendy was developing the same kind of prescience that the Guru seemed to have.<P>"It's these darn unit tests," I said as I gophered up to talk to her. "I keep having to link in more and more objects just to test the one little piece I'm working on. The class I'm working on uses some Singletons, so I have to link in their object files. Those Singletons use other Singletons, and so on, so now I have this huge, bloated mess. It's getting to the point that I have to instantiate most of the services just to test this one simple object."<P>"And that, my child, is but one reason to avoid Singletons." I almost fell off my chair as I jumped at the Guru's soft voice behind me.<P>"Come again?" I said, as I climbed down.<P>"You have discovered -- or should I say, rediscovered -- one of the reasons for avoiding Singletons: they make your writings difficult to test. Your object depends on the service object to provide specific services and behavior. The simplest way to test your object is to replace the service object with a mock object [1]."<P>"I know that," I said, trying to keep the smugness out of my voice, "but another team wrote the service and implemented it as a Singleton. I can't go back to them and ask them to rewrite their code, so I had no choice..."<P>"No choice, say you?" the Guru interrupted. "Always there are choices. Instead of directly calling the Singleton's entry point, your object can accept a pointer or reference to the service object in its initialization or creation functions. Your unit test can simply create a mock service object and pass that to your object to be tested. Consider this parable," the Guru picked up the whiteboard marker and began writing in her fine, spidery script:<P><pre>class HighlyCoupled{  void SomeMemberFn()  {    AService &amp; service =      AService::Instance();    service.DoSomething();  }};</pre>"This class suffers from Singleton abuse. It is tightly coupled to the Singleton, making it difficult to test. Instead, you can keep a reference to the service as a class member:"<P><pre>class LessCoupled{  AService &amp; service_;  void SomeMemberFn()  {    service_.DoSomething();  }public:  LessCoupled(AService &amp; service)  : service_( service )  {}};</pre>"Or, if the service is used by only one or two member functions, pass it as a parameter to the function:"<P><pre>class EvenLessCoupled{   void SomeMemberFn(     AService &amp; service )  {    service.DoSomething();  }};</pre>"Now, passing a mock object in your unit test becomes trivial."<P>"What did you call it... 'Singleton abuse'?" I asked.<P>"My child, the Singleton design pattern is one of the most inappropriately used patterns. Singletons are intended to be used when a class must have exactly one instance, no more, no less [2]. In many cases where scribes use Singletons, the fact that it is a 'single instance' just happens to be a coincidence. The application could happily instantiate multiple instances with no problems.<P>"Scribes frequently use Singletons in a misguided attempt to replace global variables. I have, for example, been on projects where the Singleton has been described as 'a well-known object' -- does that not sound like a global variable, my child?"<P>"Umm... no, not really," I drawled after a bit of consideration. I wrote on my whiteboard:<P><pre>S &amp;S::Instance(){  static S theInstance;  return theInstance;}</pre>"I don't see a global variable here."<p>"Ah, my child, but there is a global variable -- a global variable named <B>S::Instance()</B>. Consider this parable:<P><pre>class T { /* whatever */ };T globalT;</pre>"What is the difference between <B>globalT</B> and <B>theInstance</B>? Both variables have static storage duration, do they not?"<P>"But!" I cried. "<B>globalT</B> has global scope, whereas <B>theInstance</B>'s scope is limited to the member function. Therefore the Singleton is not a global variable."<P>"By the letter of the Holy Standard, yes, its scope is limited to the member function. Its lifetime, however, is not. Meditate upon these two allegories:"<P><pre>globalT.DoSomething();S::Instance().DoSomething();</pre>"What is the difference, in terms of how they are used, between <B>globalT</B> and <B>S::Instance()</B>?"<P>The Guru paused while the gears churned in my brain. I wasn't convinced yet.<P>"Allow me to take this allegory one step further," she continued. "Recall that a reference is an alias for an existing object:"<P><pre>T globalT = someInitFunction();S &amp; globalS = S::Instance();globalS.DoSomething();globalT.DoSomething();</pre>"The similarity becomes clearer, does it not? A Singleton is, for all intents and purposes, a global variable. Therefore, never create a Singleton whose sole purpose is to mask a global variable. The Singleton does not do away with the global; it merely renames it. The Singleton clarifies nothing and forces extra typing, causing some scribes to exceed the 34 character limit for code samples imposed by certain print magazines."<P>"Hold on, back the truck up a second," inspiration finally hit me. "There's another difference here: initialization order. You don't know when <B>globalT</B> will be initialized, relative to global objects in other translation units, but you do know when <B>theInstance</B> will be initialized. So you can use the Singleton pattern to smooth over static initialization order problems." I scribbled on the whiteboard:<P><pre>extern T globalT;U notSoGood( globalT );U muchBetter( T::Instance() );</pre>"If the translation unit with <B>notSoGood</B> gets initialized before the translation unit with <B>globalT</B>, then you could be in big trouble. But with a Singleton, that problem goes away -- <B>muchBetter</B> can rely on the Singleton being initialized first."<P>"That is true, my child," the Guru pushed back a graying lock of hair, "but yours is not an argument in favor of Singletons, but rather an argument against global variables."<P>"The Singleton is a deceptively complex concept. On the surface, it seems quite simple. However, crafting a Singleton that initializes properly, is thread safe, and can be destroyed safely is not a trivial matter. Indeed, the prophet Vlissides has preached on the theme of destroying a Singleton [3]."<P>"So," I soed, "are you proposing that Singleton should be considered harmful?"<P>"No, my child," the Guru said softly, "not in the least. The problem is not with Singletons, but with the rampant overzealous application of the Singleton pattern where not appropriate. When your only tool is a hammer..."<P>"Everything looks like a nail," I finished as the Guru turned and silently glided away.<P><h3><font color="000080">Notes</font></h3><p>[1]  See also &lt;http://c2.com/cgi/wiki?MockObject&gt;.<P>[2]  Gamma, Helm, Johnson, and Vlissides. <I>Design Patterns: Elements of Reusable Object-Oriented Software</I> (Addison-Wesley, 1994).<P>[3]  J. Vlissides. "To Kill A Singleton," <I>C++ Report</I>, June 1996. <p><h3><font color="000080">About the Authors</font></h3><p>Herb Sutter (&lt;www.gotw.ca&gt;) is convener of the ISO C++ standards committee, author of the acclaimed books <I>Exceptional C++</I> and <I>More Exceptional C++</I>, and one of the instructors of The C++ Seminar (&lt;www.gotw.ca/cpp_seminar&gt;). In addition to his independent writing and consulting, he is also C++ community liaison for Microsoft. <P>Jim Hyslop is a senior software designer with over 10 years programming experience in C and C++. Jim works at Leitch Technology International Inc., where he deals with a variety of applications, ranging from embedded applications to Windows programs. He can be reached at <B>jhyslop@ieee.org</B>. <HR></BODY></HTML>