<HTML><HEAD><TITLE> Listing 2:	Test program</TITLE></HEAD><body bgcolor="#FFFFFF" text="#000000"><B> Listing 2:</b>	Test program<p><pre>// Test program for math-complex.h.  This file can be// compiled by either C99 or C++.#include &lt;stdio.h&gt;#include "math-complex.h"static const long double pi =  3.141592653589793238462643383279502884197L;int main(){    // The three complex types store two components of the    // underlying floating point type.    printf("sizeof(float)=%2d        sizeof(float_complex)=%2d\n",      (int) sizeof(float), (int) sizeof(float_complex));    printf("sizeof(double)=%2d       sizeof(double_complex)=%2d\n",      (int) sizeof(double), (int) sizeof(double_complex));    printf("sizeof(long double)=%2d  sizeof(long_double_complex)=%2d\n",      (int) sizeof(long double), (int) sizeof(long_double_complex));    double_complex x, y, z;    x = double_complex(1,2);    y = double_complex(2,2);    // You may mix complex and the corresponding real type    z = x + y + 10.0;    printf("(1+2i)+(2+2i)+10 = %g+%gi\n", real(z), imag(z));    // But different complex types must be cast to a    // common type or C++ rejects the program.    long_double_complex w = long_double_complex(2,3);    x = (double_complex) w * double_complex(5, 6);    printf("(2+3i) * (5+6i) = %g+%gi\n", real(x), imag(x));    x /= double_complex(5, 6);    printf("(-8+27i) / (5+6i) = %g+%gi\n", real(x), imag(x));    // e raised to the imaginary pi power is -1    w = exp(long_double_complex(0., pi));    printf("exp(pi*i) = %Lf+%Lfi\n", real(w), imag(w));    // log of -1 is imaginary pi    w = log(long_double_complex(-1, 0));    printf("complex log(-1) = %Lf+%Lfi   (difference from pi=%Lg)\n",      real(w), imag(w), imag(w) - pi);    // absolute value of a complex number is a real number:    // the square root of the sum of the squares of the real    // and imaginary parts    printf("abs(float_complex(3,4)) = %f\n", abs(float_complex(3,4)));    // You may raise a real number to a complex power    x = pow(exp(1.0), double_complex(0., pi));    printf("e to the imaginary pi power = %f+%fi\n",      real(x), imag(x));    // Or a complex number to a real power    x = pow(double_complex(0, 1), 2.0);    printf("i squared = %f+%fi\n",      real(x), imag(x));    // Or a complex number to a complex power    x = pow(double_complex(1, 1), double_complex(1, 1));    printf("(1+1i) to the power (1+1i) = %f+%fi\n",      real(x), imag(x));    // Finally, square roots of negative numbers...    x = sqrt(double_complex(-1.0, 0));    printf("square root of -1 = %g+%gi\n",      real(x), imag(x));    // arg() returns the angle     long double ld = arg(long_double_complex(1., 1.));    printf("arg(1+1i) = %Lf   (difference from pi/4=%Lg)\n",       ld, pi/4 - ld);    // the conjugate of a complex number is the number with the    // imaginary part's sign reversed.    x = conj(double_complex(2., 3.));    printf("conj(2+3i)) = %g+%gi\n",      real(x), imag(x));    // The complex trigonometric and hyperbolic functions    x = double_complex(1,1);    y = cos(x);    printf("cos((1+1i)) = %f+%fi\n",      real(y), imag(y));    y = sin(x);    printf("sin((1+1i)) = %f+%fi\n",      real(y), imag(y));    y = tan(x);    printf("tan((1+1i)) = %f+%fi\n",      real(y), imag(y));    y = cosh(x);    printf("cosh((1+1i)) = %f+%fi\n",      real(y), imag(y));    y = sinh(x);    printf("sinh((1+1i)) = %f+%fi\n",      real(y), imag(y));    y = tanh(x);    printf("tanh((1+1i)) = %f+%fi\n",      real(y), imag(y));    return 0;}</pre></BODY></HTML>