<HTML><HEAD><TITLE>The New C: Complex Arithmetic: In the Intersection of C and C++</TITLE></HEAD><body bgcolor="#FFFFFF" text="#000000"><h2>The New C: Complex Arithmetic: In the Intersection of C and C++</h2><h3>Randy Meyers and Dr. Thomas Plum</h3><i>Compatible complex arithmetic between C and C++. It's easier than you think.</i>Many of C99's features came from extensions that vendors had made to their C compilers to permit FORTRAN programmers to move to C. A case in point: Cray Research had FORTRAN programmers who wished to be C programmers, but they needed FORTRAN's support for complex numbers.<P>C++ has had complex numbers since its early days, so adding complex data types to C99 has had the potential to increase the intersection between C and C++. However, C by necessity took a different approach to supporting complex numbers than C++. C++ added support for complex numbers via the library using classes, templates, and overloaded operators. C99 added complex numbers directly into the language as new built-in types and new rules for handling expressions. C++ uses template syntax for naming complex types, for example, <B>complex&lt;double&gt;</B>. C99 uses the traditional sequence-of-keywords approach, for example, <B>double</B> <B>complex</B>. C++ uses constructors to create complex numbers, <B>complex&lt;double&gt;(1.,2.)</B>. C99 does not even have constructors.<P>At first, the gulf between the class library approach and the built-into-the-language approach seems large. However, these differences are more syntax than semantics; these differences between complex arithmetic in C99 and C++ can be reconciled by a small header file. This should not really be a surprise since one of C++'s design goals was that the programmer should be able in effect to extend the language by writing class types and overloads. The approach used to add a language feature should not matter much.<P> This month's installment does something a little different. Rather than just   discuss a new feature in C99 and occasionally compare it to C++, we are going   to concentrate on the intersection between C99 and C++. We are going to discuss   how to write programs that use complex arithmetic and compile equally well under   either C++ or C99. The key to opening the large intersection between C and C++   <B>complex</B> is the small header file named <B>math-complex.h</B> (shown in   <a href="cuj0303meyers_l1.htm">Listing 1</a>).<P><h3>The Intersection</h3>Our header <B>math-complex.h</B> defines three complex types: <B>float_complex</B>, <B>double_complex</B>, and <B>long_double_complex</B>. Each type contains two scalars of the corresponding real type, with a real part and an imaginary part, in Cartesian (rectangular) form. The header provides capabilities (in both C and C++) for initialization in the format of the C++ dyadic constructor:<P><pre>float_complex x =  float_complex(1.f, 2.f);</pre>In <B>math-complex.h</B>, the initializer syntax mechanisms will convert the arguments to the specified complex type, so we can write <B>float_complex(1, 2)</B> and omit the floating suffixes.<P>Both C and C++ provide the usual arithmetic operators: plus, minus, times, divide, unary plus, and unary minus. Both provide the corresponding assignment operators (<B>+=</B>, <B>-=</B>, <B>*=</B>, and <B>/=</B>), as well as ordinary assignment (<B>=</B>). Equality (<B>==</B>) and inequality (<B>!=</B>) are provided, but less than and greater than are not provided. (There is no simple one-dimensional meaning for "less" or "greater" among complex numbers.)<P>All these operators accept one operand of complex type mixed with an operand of the corresponding real type. For example,<P><pre>double_complex y = double_complex(3, 4);// now y contains double_complex(12., 16.)y *= 4.;</pre>In general, C99 permits trouble-free mixing of operand types, such as adding a <B>float_complex</B> and a <B>double_complex</B>. However, to program in the C/C++ intersection, you should stick to the same type forms (all <B>float</B>, all <B>double</B>, or all <B>long</B> <B>double</B>). Therefore, all your conversions should be shown explicitly, using casts or assignment. Continuing from the previous example, we could write:<P><pre>long_double_complex z =  long_double_complex(4, 5);z += (long_double_complex)y.;// now z contains// long_double_complex(16.L, 21.L)</pre>Both C and C++ provide the complex trigonometric and hyperbolic functions (i.e., <B>sin</B>, <B>cos</B>, <B>tan</B>, <B>sinh</B>, <B>cosh</B>, and <B>tanh</B>), but the corresponding inverse functions are not (yet) part of C++ (and are arguably used much less frequently anyway). The most common complex math functions are provided by both C and C++ (i.e., <B>exp</B>, <B>log</B>, and <B>sqrt</B>). The type of the result is the same (<B>complex</B>) type as the operand.<P>The absolute value function, <B>abs()</B>, is also provided. Note, however, that the absolute value of a complex number is its magnitude in polar form. In other words, it is a real number whose type is the same as the floating-point type underlying the complex number.<P>The <B>pow(x, y)</B> function may be used to raise <B>x</B> to the <B>y</B> power. Either <B>x</B> or <B>y</B> or both may be complex numbers. If either operand is a complex number, the result is also complex. The same restrictions apply as using complex types in expressions: both operands should be the same complex type or you may mix <B>complex</B> with the corresponding real floating-point type.<P>Several functions are specifically for the complex domain. In <B>math-complex.h</B>, we have provided them with the C++ form of their names (which omit an unnecessary leading <B>c</B>). We will show the <B>float_complex</B> forms; the corresponding <B>double_complex</B> and <B>long_double_complex</B> versions are obvious.<P><pre>float imag(float_complex z);</pre>returns the imaginary component of <B>z</B>.<P><pre>float real(float_complex z);</pre>returns the real component of <B>z</B>.<P><pre>float arg(float_complex z);</pre>returns the phase angle (the "argument") of <B>z</B>.<P><pre>float_complex conj(float_complex z);</pre>returns the complex conjugate of <B>z</B> (i.e., <B>float_complex(real(z), -imag(z))</B>).<P>The <B>real</B> and <B>imag</B> functions are very frequently used to extract the components of complex numbers. For example:<P><pre>static const long double pi =  3.141592653589793238462643383279502884197L;long_double_complex w = exp(long_double_complex(0., pi));printf("w = %Lf+%Lfi\n", real(w), imag(w));</pre><h3>The Header</h3><a href="cuj0303meyers_l1.htm">Listing 1</a> shows the <B>math-complex.h</B> header. The name of the header comes from the fact that including the header provides the same benefits as including both <B>&lt;math.h&gt;</B> and <B>&lt;complex.h&gt;</B> for C and <B>&lt;cmath&gt;</B> and <B>&lt;complex&gt;</B> for C++. After including the header, overloads for both the <B>real</B> and <B>complex</B> math functions are available for use.<P><h3>The C++ Section</h3>The header is divided into two parts by conditional compilation. The first part is the code used when compiling under C++ to provide the compatibility intersection.<P>The first thing that the C++ section does is to include <B>&lt;cmath&gt;</B> and <B>&lt;complex&gt;</B> to define the complex data types and overloaded functions for both the real and complex types.<P>The second thing that the C++ section does is to give a using directive that allows types and functions from the C++ library to be accessed without the <B>std::</B> prefix. (ANSI C++ has placed the standard library into a namespace named <B>std</B>.)<P>The third thing that the C++ section does is to declare synonyms for the complex types using <B>typedef</B>s. This allows the complex types to be accessed with names like <B>float_complex</B> rather than <B>complex&lt;float&gt;</B>. The <B>typedef</B>s also have another effect. In C++, when you declare a synonym for a class type using <B>typedef</B>, you also implicitly declare synonyms for the constructors of the class type. Thus, you can construct objects of that type using the <B>typedef</B> name. For example, <B>float_complex(1,1)</B> is equivalent to <B>complex&lt;float&gt;(1,1)</B>.<P><h3>The C99 Section</h3>The first thing that the C99 section does is to include a new C99 Standard header named <B>&lt;tgmath.h&gt;</B>, which in turn includes the C99 Standard headers <B>&lt;math.h&gt;</B> and <B>&lt;complex.h&gt;</B>. However, <B>&lt;tgmath.h&gt;</B>'s real purpose is to define overloads for all of the math functions in the C99 library so that the proper function is called based on the function's argument(s). For example, calling <B>sqrt()</B> with a <B>float</B> argument calls <B>sqrtf()</B> to take a <B>float</B> square root. Calling <B>sqrt()</B> with a <B>long</B> <B>double</B> argument calls <B>sqrtl()</B> to take a <B>long</B> <B>double</B> square root. Calling <B>sqrt()</B> with a <B>float</B> <B>complex</B> argument calls <B>csqrtf()</B> to take a <B>float</B> <B>complex</B> square root, and so on. Note that C99 does not provide overload support for user-written functions; it just provides built-in support for overloads in the library via <B>&lt;tgmath.h&gt;</B>.<P>The second thing that the C99 section does is to declare synonyms for the complex types using <B>typedef</B>s.<P>The third thing that the C99 section does is to define macros to provide the C equivalent of the C++ constructors for creating complex values from two real floating-point values. You might notice that the macros have the same name as the <B>typedef</B>s. This is not a problem since function-like macros (macros that take arguments) are only expanded by the preprocessor if the name of the macro is immediately followed by an open parenthesis (possibly proceeding whitespace).<P>The fourth thing that the C99 section does is to provide macros to rename four functions whose names in <B>&lt;tgmath.h&gt;</B> differ from the names of those functions in C++.<P>The remarkable thing about the header is that it is so short and simple.<P> <a href="cuj0303meyers_l2.htm">Listing 2</a> is an example program that uses   the header. The program can be compiled by C or C++ and can be used to test   your C++ or C99 implementation for some flaw that would prevent programming   in the intersection.<P> <a href="cuj0303meyers_l3.htm">Listing 3</a> shows sample output from running   the program.<P><h3>C++ Provisions above the Intersection Features</h3>We turn now from our discussion of the C/C++ intersection to consider what is excluded when you use the intersection. To begin with, there are several additional functions in the C++ complex library (i.e., <B>norm</B>, <B>polar</B>, and <B>log10</B>):<P><pre>float norm(float_complex z);</pre>returns the squared magnitude of <B>z</B>.<P><pre>float_complex polar(float rho, float theta);</pre>returns the complex value corresponding to a complex number whose magnitude is <B>rho</B> and whose phase angle is <B>theta</B>.<P><pre>float_complex log10(float_complex z);</pre>returns the complex base-10 logarithm of <B>x</B>.<P>If your environment provides both C++ and C99 libraries, an <B>extern</B> "<B>C</B>" wrapper written in C++ could trivially provide these functions to your C99 applications.<P>On a more fundamental level, the C++ implementation of complex data types uses the C++ template syntax. In theory, this would provide an easy method to define a complex arithmetic on top of some "special" floating-point foundation, such as an interval arithmetic. However, the C++ Standard requires the <B>complex&lt;T&gt;</B> template to work properly only for <B>float</B>, <B>double</B>, and <B>long</B> <B>double</B>, so your "special" complex might or might not work, with no guarantees.<P><h3>C99 Provisions above the Intersection Features</h3>There are several additional functions in the C99 complex library (i.e., <B>cacos</B>, <B>casin</B>, <B>catan</B>, <B>cacosh</B>, <B>casinh</B>, and <B>catanh</B> -- the inverse trig functions). (These are likely to be added to the next revision of C++ and may already be available as extensions in some C++ libraries.) Again, if your environment provides both C++ and C99 libraries, a wrapper written in C++ could trivially provide these functions to your C++ applications.<P>More fundamentally, the rules for type balancing and type promotion are built-in in C99, so most combinations of mixed-type operands will silently promote to the "wider" argument type. Usually, this will "do the right thing," but occasionally in numerical work the programmer might appreciate a warning about the mixed precision.<P>There is another feature of the C99 implementation that we have avoided mentioning -- the (pure) <B>Imaginary</B> type. In theory, this permits C99 complex applications to get the precisely correct result in certain boundary cases of IEEE floating-point complex arithmetic. However, the C99 Standard defines the <B>Imaginary</B> type as optional, not required. Furthermore, to our knowledge, it is not provided in any existing implementation. For these reasons, we consider <B>Imaginary</B> to be of mostly theoretical interest.<P><h3>Cost/Benefit of Working in the Intersection</h3>Confining our focus to programs that use complex arithmetic, how important are the features that are left out of the intersection? In our opinion, they are not very important. Mixed-mode arithmetic may on balance be a useful shorthand, but fundamentally it provides nothing beyond occasionally eliminating type-balancing casts. The slight differences in the library inventories can often be handled with trivial wrapper functions.<P>Therefore our conclusion regarding complex arithmetic is to recommend the use of the "intersection" style for complex-arithmetic applications. It's possible that in some environments, the C99 implementation will produce faster code execution. On the other hand, there will doubtless be environments in which there is no C99 implementation. And a C++ implementation that incorporates "small-object" optimization is capable of being just as fast as the C99 implementation. In any event, the application that is written in the "intersection" complex style can be compiled as C++ or compiled as C99, whichever works best for each environment.<p><h3>About the Authors</h3>Randy Meyers is a consultant providing training and mentoring in C, C++, and Java. He is the current chair of J11, the ANSI C committee, and previously was a member of J16 (ANSI C++) and the ISO Java Study Group. He worked on compilers for Digital Equipment Corporation for 16 years and was Project Architect for DEC C and C++. He can be reached at <B>rmeyers@ix.netcom.com</B>.<P>Dr. Thomas Plum has authored four books on C and co-authored <I>Efficient C</I> (with Jim Brodie) and <I>C++ Programming Guidelines</I> (with Daniel Saks). He has been an officer of the United States and international C and C++ standards committees. His company Plum Hall Inc. provides test suites for C, C++, Java, and C#.<p></BODY></HTML>