<HTML><HEAD><TITLE>Quick Integer Powers</TITLE></HEAD><body bgcolor="#FFFFFF" text="#000000"><h2>Quick Integer Powers</h2><h3>Phillip K. Janert</h3>C is notoriously lacking an operator to raise floating-point numbers to small integer powers. Neither does the standard library provide such a function. For the (most common) case of squares, writing <I>x*x</I> is an option, however, this quickly becomes cumbersome and in particular hideously inefficient if <I>x</I> is not a simple variable but an expression like <I>sin(log(x))</I>. The use of macros, though popular, does not help this situation. Macros actually make the situation worse by hiding the repeated evaluation of the argument. For higher powers (four and up), you have to find another solution anyway.<P>One efficient algorithm employs the <I>repeated-squaring</I> method. The repeated-squaring method works as follows: if the value of <I>x*x</I> is already at hand, it is more efficient to calculate <I>x</I>4 as <I>(x*x)*(x*x)</I> rather than starting from scratch using <I>x*x*x*x</I>. You can decompose any integer power into a sequence of repeated squares.<P>The algorithm below examines each bit in the exponent, starting with the rightmost bit. If the bit is set, the result variable <B>h</B> is multiplied by <B>x</B>, which holds the base raised to the current power of <B>2</B>. In either case, <B>x</B> is subsequently squared, and the exponent is shifted one bit to the right (i.e., divided by <B>2</B>). This process is repeated until the exponent is exhausted. Note that the exponent is passed as <B>unsigned</B> <B>int</B>: this way, the C Standard guarantees that the bits shifted in from the left will be <B>0</B>. To find a negative integer power, you must call <B>1.0/qip(x, abs(n))</B>.<P><pre>/* Compute pow(x,n) for positive   integer n through repeated   squarings */double qip(double x,    unsigned int n){    double h = 1.0;    while(n){        if(n&amp;1){ h *= x; }        x *= x;        n &gt;&gt;= 1;    }    return h;}</pre><a href="cuj0303janert_t1.htm">Table 1</a> shows the results of a very crude performance comparison. The values in the table represent the factor by which <B>qip(x,n)</B> is faster than <B>pow(x,n)</B> for various values of <B>n</B>. For <B>n=2</B>, <B>qip</B> is almost three times as fast as <B>pow</B>, but the speed-up degrades quickly as <B>n</B> becomes larger. The results do not depend insignificantly on <B>x</B>.<p><h3>About the Author</h3>Philipp K. Janert, Ph.D., is a software project consultant and server programmer in Seattle, WA. He also maintains the beyondCode.org website. Contact him at <B>janert@ieee.org</B>.<p></BODY></HTML>