<HTML><HEAD><TITLE>Conversations: Factory Redux, Part 1</TITLE></HEAD><body bgcolor="#FFFFFF" text="#000000"><h2>Conversations: Factory Redux, Part 1</h2><H3>Jim Hyslop and Herb Sutter</H3><I>Adding generic persistence factories the modern C++ way.</I><P><I>Copyright 2003, Jim Hyslop and Herb Sutter </I><P>"Hey, have you been up to the factory lately?" Wendy poked her head into my cubicle. "They've set up a new surface-mount production line that can handle more complex boards." Being less into embedded programming than Wendy was and, therefore, less in tune with the hardware engineering department of our company, I understood this news only slightly better than a tribal chief in the deep, dark Amazon rain forest might understand the significance of who won the baseball All-Star game.<P>"With the older machines," she patiently explained, "we were pretty limited in what we could do. The new machines are more flexible and let us do a wider variety of printed circuit boards."<P>"I wish my factory were that flexible," I sighed. Wendy cocked her eyebrow quizzically. "You remember the templated Factory Method pattern that the Guru showed me a while back?"[1]<P>"Oh, right," Wendy nodded, "then you figured out how to use that factory to save objects to a file.[2] So what's the problem?"<P>"Well, the factory worked great, as long as you use nothing but default constructors. The creation function accepts no parameters. But then I read Alexandrescu's chapters on factories -- there's a lot of good stuff in that book -- and I made the creation function a template argument[3]:<P><pre>template&lt;class AncestorType, typename classIDKey =   defaultIDKeyType, typename BaseCreateFn =   auto_ptr&lt; AncestorType &gt;    (*)()&gt;class genericFactory{</pre>"And that works great, because now I can use different sets of parameters for different class hierarchies, like this:"<P><pre>auto_ptr&lt; Widget &gt; widget =  genericFactory&lt; Widget &gt;::    instance().create();typedef auto_ptr&lt; Gadget &gt;  ( * GadgetCreator )( int );auto_ptr&lt; Gadget &gt; gadget =  genericFactory&lt;    Gadget,    string,    GadgetCreator  &gt;::instance().create( 42 );</pre>"I sense a 'but...' here," Wendy prompted.<P>"Well, yeah," I sighed. "This approach works great, as long as all the classes in the hierarchy accept the same number and type of parameters in their constructors. All objects derived from <B>Gadget</B> have to take an <B>int</B> parameter in their constructor. I'm running into more and more classes that can't be default constructed, and where the derived classes take a different set of arguments than their parents, like:"<P><pre>class Base{public:  Base( int );};class Derived : public Base{public:  Derived( string );};</pre>"Well, what about a parallel hierarchy?" Wendy asked as she took over at the keyboard:<P><pre>class Base{public:  struct BaseParams  {    int value_;  };  Base( int );  Base( const BaseParams &amp; );};class Derived : public Base{  string word_;public:  struct DerivedParams :    public BaseParams  {    string word_;  };  Derived( string );  Derived( const DerivedParams &amp; dp )  : Base( dp ), word_( dp.word_ )  {}};</pre>"Now, each class takes a single parameter, which can be customized for each class in the hierarchy. And, since the parameter uses inheritance, it can be easily handled by the factory."<P>"Very good, my daughter." Once again, I jumped at the Guru's voice in my ear. "But this is one step into a larger world. The challenge now, my children, is to take this scheme and make it generic."<P>"Generic in what way?" I asked. "The factory is already generic, and with this new parallel hierarchy it will probably serve without modifications for a long time."<P>"True, my apprentice, the factory is generic," the Guru replied. "But what of the class itself? Show me how you would implement the actual save and restore functions."<P>I turned to my keyboard. Having just been presented with the parallel inheritance scheme, I hadn't had any chance to work out the details.<P>"Ah, well," I stalled for time, "I guess the <B>BaseParams</B> class is pretty much a value type, which can be default constructed. I can use the original factory to save and restore it:"<P><pre>struct BaseParams{  int value_;  void save( ostream &amp; ) const;  void restore( istream &amp;);  virtual void do_save( ostream &amp;);</pre> "And that, my child, is the challenge," the Guru interrupted. "How can you make the persistence code more general, so that the object does not care where it is being stored? Suppose, for example, that the next project stores the object in a database. How can this be structured so that you do not need to modify the class?"<P>"Oh, I see. Ah...well...it's easy," I lied. "I'd just...um...I dunno."<P>"Worry not, my child," the Guru said. She paused as Bob passed by, scowling, on his way out the door. After he was gone, it was amazing to watch the transformation as she relaxed, dropping the Guru act.<P>"It's OK," she said, "I didn't expect you to know. Let's start with the framework that the classes will need. The template factory that you created is, when boiled down to its essence, a mechanism for associating a token with a pointer-to-a-function. Let's extend the factory to associate the token with two functions: one to create the objects and one to save the objects. We need to set up the default parameters so that existing code does not break."[4] She sat down at the keyboard, and started typing:<P><pre>class DoNothingClass{};template&lt;  class AncestorType,  typename classIDKey =     defaultIDKeyType,  typename Source=DoNothingClass,  typename Sink = DoNothingClass,  typename Parameter =     DoNothingClass,  typename ConcreteCreateFn =     auto_ptr&lt;AncestorType&gt;     (*)( ),  typename ConcreteSaveFn =     void (*)( Sink &amp;,             const Parameter &amp; )&gt;class GenericFactory{  struct Functions  {    ConcreteCreateFn creator;    ConcreteSaveFn saver;  };  typedef map&lt;classIDKey,    Functions&gt; FN_REGISTRY;  FN_REGISTRY registry;public:  void registerFunctions(    const classIDKey &amp; clName,    ConcreteCreateFn creator,    ConcreteSaveFn saver = NULL)  {    Functions funcs;    funcs.creator = creator;    funcs.saver = saver;    registry[clName]=funcs;  }</pre>"The <B>registerFunctions</B> member," the Guru explained as she typed, "is very much like the original function -- it creates the association between the class identifier and the create and save functions."<P><pre>  auto_ptr&lt;AncestorType&gt;  create(    const classIDKey &amp;className,    Source &amp; source ) const  {    auto_ptr&lt;AncestorType&gt; ret(0);    typename      FN_REGISTRY::const_iterator      regEntry =        registry.find(className);    if ( regEntry !=         registry.end())    {      auto_ptr&lt;AncestorType&gt;        tmp(          (*regEntry).second.            creator( source )        );      ret=tmp;    }    return ret;  }</pre>"The create function is pretty much the same as your original, except that it accepts an argument from which the class will be created, and passes that argument on to the creation function."<P><pre>  void save(    const classIDKey &amp;className,    Sink &amp;sink,    Parameter &amp; param  ) const  {    typename      FN_REGISTRY::const_iterator        regEntry =          registry.find(className);    if ( regEntry !=         registry.end())    {      (*regEntry).second.saver(                   sink,                   param );    }  }</pre>"The save function is the new one. This function looks up the specified class identifier, and if the class is registered, it calls the associated save function.<P>"Now, back to my original question: how to isolate the class hierarchy from the saving mechanism." I gave her my tried-and-trusted deer-in-the-headlights look. She sighed. "Let's work this up from first principles. How do you write generic code?"<P>"Templates," I said immediately, glad to be able to answer something.<P>"Exactly. Let's start with a simple template, which we'll add to the factory's header file:"<P><pre>template&lt;  typename T,  typename Storage&gt;class PersistentStorage{public:  explicit PersistentStorage(      Storage &amp; s );  T &amp; restore();  void save( const T &amp; );};</pre>"This template will be used inside the function that creates the object, that is, the function that gets registered as the creator parameter in <B>GenericFactory::registerFunctions</B>.<P>"The next step is to plug this into the helper classes you wrote for your factory, and extend the helper class to make the <B>istream</B> and <B>ostream</B> into template arguments." She called up the original code on my monitor. "The existing <B>registerInFactory</B> template will work fine for objects that can be default constructed, so we'll add a new class template:"<P><pre>template&lt;  class AncestorType,  typename AncestorParameter,  class ConcreteType,  typename ConcreteParameter,  typename Source,  typename Sink,  typename ConcreteCreateFn =    auto_ptr&lt;AncestorType&gt;    (*)( Source &amp; ),  typename classIDKey =    defaultIDKeyType&gt;class RegisterInFactoryWithParams{public:  static auto_ptr&lt; AncestorType &gt;  createInstance( Source &amp; source )  {    PersistentStorage    &lt;      ConcreteParameter,      Source    &gt; storage( source );    return auto_ptr&lt; AncestorType &gt;(      new ConcreteType(        storage.restore()      )    );  }</pre>"The <B>createInstance</B> function instantiates the template, then calls the <B>restore()</B> function to retrieve the object that was stored. The newly created object is then initialized with the resulting <B>ConcreteParameter</B> object."<P>"Wait a second," I interrupted. "How does the <B>PersistentStorage</B> template know how to retrieve the object? It still doesn't know what kind of object it's dealing with."<P>"That is true," the Guru said, "but you'll notice that the <B>PersistentStorage</B> functions in the base template have no implementations. The <B>PersistentStorage</B> template can never be instantiated as-is, you must provide partial or full specializations of the template. That is part of the storage-specific implementation you need to write. At this moment, though, I'm just building the framework. Next we have the static member function that saves the object:"<P><pre>  static void saveInstance(    Sink &amp; sink,    const AncestorParameter &amp; ap )  {    PersistentStorage    &lt;      ConcreteParameter,      Sink    &gt; storage( sink );    storage.save(      static_cast      &lt;        const ConcreteParameter &amp;      &gt; ( ap )    );  }</pre>"And finally, the glue that binds it into the factory: the constructor for the <B>RegisterInFactoryWithParams</B> template.<P><pre>  RegisterInFactoryWithParams(     const classIDKey &amp;id )  {    GenericFactory    &lt;      AncestorType,      classIDKey,      Source,      Sink,      AncestorParameter,      ConcreteCreateFn    &gt;    ::instance().registerFunctions(        id,        createInstance,        saveInstance );  }};</pre>"As with your original helper, the constructor instantiates the factory, and registers the static create and save functions in the factory. The framework is now complete, ready for you to plug your class hierarchy into it."<P>"This is the part I'm waiting to see," Wendy piped up. I had forgotten she was watching. The Guru started to speak, but my stomach interrupted with a loud rumbling.<P>"Saved by the bell," the Guru said. "I may be thin, but I need to eat too. We'll continue after lunch."<P><I>Next: how to incorporate the PersistentStorage&lt;&gt; framework into your class hierarchy, and a summary of the pros and cons of this approach.</I><P><h3>Acknowledgments</h3>Our thanks to the many readers who have sent comments on the previous version of the factory, pointing out flaws and some portability issues. Our thanks also to Scott Meyers, whose comments about "default-constructors-always-exist lemmings" forced a re-think of the design to accommodate a wider variety of constructors.<P><h3>References</h3>1.  "Conversations: Abstract Template, Factory Style," C/C++ Users Journal Experts Forum, June 2001, c:\www.cuj.com/experts/1906/hyslop.htm.<P>2.  "Conversations: How To Persist an Object," C/C++ Users Journal Experts Forum, July 2001, c:\www.cuj.com/experts/1907/hyslop.htm.<P>3.  <I>Modern C++ Design: Generic Programming and Design Patterns Applied</I>. Andrei Alexandrescu, Addison-Wesley, 2001.<P>4.  For brevity, only those functions that are new or changed from the original factory are shown here. For details on the full factory, see [1] or the sample code available at c:\www.cuj.com/code.<P><h3>About the Authors</h3>Herb Sutter(&lt;www.gotw.ca&gt;) is convener of the ISO C++ standards committee, author of the acclaimed books <I>Exceptional C++</I> and <I>More Exceptional C++</I>, and one of the instructors of The C++ Seminar (&lt;www.gotw.ca/cpp_seminar&gt;). In addition to his independent writing and consulting, he is also C++ community liaison for Microsoft. <P>Jim Hyslop is a senior software designer with over 10 years programming experience in C and C++. Jim works at Leitch Technology International Inc., where he deals with a variety of applications, ranging from embedded applications to Windows programs. He can be reached at <B>jhyslop@ieee.org</B>.<p></BODY></HTML>