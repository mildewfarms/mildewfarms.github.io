<HTML><HEAD><TITLE>Optimizing Custom Memory Allocators</TITLE></HEAD><body bgcolor="#FFFFFF" text="#000000"><h2>Optimizing Custom Memory Allocators</h2><H3>Sebastien Marc</h3><I>Yet another success story for modern template techniques -- this time optimizing a custom memory scheme.</I><P>It all started innocently. We had just finished the implementation of an XP ( eXtreme Programming) iteration of our Linux financial risk engine and were doing some load testing. We had to handle tens of thousands of financial positions in a matter of minutes, so scalability was important. The first big report got through, but the engine shot up in memory to 500 MB. The second run worried me as the engine shot up to 700 MB for the same report. The third run was a disaster. The server swapped, spending most of its time in an I/O wait state and taking forever to compute the profit and losses of each position.<P>Our application was suffering from unacceptable memory fragmentation.<P>Fortunately C++ provides the tools to fight memory fragmentation: custom memory allocators. We began to implement custom allocators to map (<B>mmap</B> system call) critical chunks of memory needed during the computation of the report, and we decided to implement custom containers using these allocators. The solutions worked well. Memory went down at the end of each report, and the fragmentation disappeared. But the code was very inefficient. The required time for a report nearly doubled. After <B>quantify</B>ing the engine on Solaris (a pity <B>quantify</B> does not exist on Linux), we realized most of the time was spent calling the destructors for the objects in our containers.<P>Below is code using part of the implementation of a specific container:<P><pre>template &lt;class T&gt;void destroyit(T* tPtr){  tPtr-&gt;~T();}template &lt;class Contained,  unsigned int size&gt;class Container{public:  Container()      :holderPtr_(NULL), bytes_        (size*sizeof(Contained))    {      holderPtr_ =        (Contained*) mmap(0, bytes_,          PROT_READ|PROT_WRITE,          MAP_PRIVATE, zerofd, 0);      // Use placement new to      // initialize our objects.      for(int i=0; i&lt;size; i++)        new (holderPtr_ + i) Contained();    }  virtual ~Container()    {      long nelements =        bytes_ / sizeof(Contained);      for(int i=0; i&lt;nelements; i++)        destroyit(holderPtr_ + i);      munmap(holderPtr_,bytes_);    }  private:  Contained* holderPtr_;  unsigned long bytes_;};</pre>This container memory-maps its memory, which reduces the fragmentation of the heap by reallocating part of the memory needed by the application into a different segment. Therefore uses like:<P><pre>{  // Uses the heap  std::auto_ptr&lt;MyClass&gt; mPtr    (new MyClass());  // Time to allocate prices. Do  // it using  our container  // because we do not want  to  //fragment the heap when prices  //are deleted.  // Container holding a 100 prices.  Container&lt;PriceClass, 100&gt; c;  // Do other things.}</pre>significantly optimize memory usage by reducing fragmentation.<P>That was great, but what about:<P><pre>{  // Container holding a 100 prices.  Container&lt;double, 100&gt; c;}</pre>Stop and think about it for a minute. You may think that this code does not compile because there is a compilation error when the <B>destroy&lt;double&gt;</B> function is instantiated. However, the code really does compile. See paragraph 12.4.15 of the ANSI C++ Standard: "The notation for an explicit call of a destructor can be used for any scalar type name." This rule means that calling a destructor on a double or any fundamental type is allowed. It will not do anything, but it will compile and link.<P>So, when the container goes out of scope, its destructor enters a dreadful loop, trying to call 100 destructors on each <B>double</B>! That's not a model of efficiency and was definitely the main performance bottleneck of our risk engine. (Believe it or not, this appears to be how the standard STL vector container on the latest sparcWorks compiler is implemented).<P>Here is the design challenge: how to design the container to call the destructors of contained classes but avoid entering a loop when your container contains fundamental data types.<P>Modern C++ design and some of the template techniques described by Alexandrescu will help. Fasten your seat belts, here is the code to handle the case of <B>double</B>. I'll then generalize the solution to other types.<P>Start by defining two static types:<P><pre>struct Yes_type {};struct No_type {};</pre>The compiler uses these two types at compile time to help decide when to instantiate a function that will destroy an array of objects (calling their destructor) and when to instantiate a function that will not call the destructors, therefore optimizing efficiency.<P>I can then have the following functions:<P><pre>template &lt;class T&gt;void destroyit(T* tPtr, long bytes, No_type){}template &lt;class T&gt;void destroyme(T* tPtr){  tPtr-&gt;~T();}template &lt;class T&gt;void destroyit(T* tPtr, long bytes, Yes_type){  long nelements = bytes / sizeof(T);  for(int i=0; i&lt;nelements; i++)    destroyme(tPtr + i);}</pre><B>destroyit</b> destroys an array of objects in both cases. <B>tPtr</B> points to the beginning of the array; <B>bytes</B> is the size in bytes of the memory pointed to by <B>tPtr</B>. <B>No_type</B> and <B>Yes_type</B> are just there to allow me to redefine the function. If I pass <B>No_type</B> (when a type does not have a destructor), I get rid of the loop!<P>Now the tricky part is to call the appropriate <B>destroyit</B> function in the destructor of the container. You can call the appropriate <B>destroyit</B> function by introducing yet another static type:<P><pre>template &lt;class T&gt; struct Container_type_traits{  typedef Yes_type has_destructor;};</pre>and a specialization in the case of <B>double</B>:<P><pre>struct Container_type_traits&lt;double&gt;{   typedef No_type has_destructor;};</pre>In plain English, the <B>typedef</B> of <B>Container_type_traits</B> will be <B>Yes_type</B> if <B>T</B> is any type but <B>double</B>. If the type is <B>double</B>, the <B>typedef</B>'s type is <B>No_type</B>.<P>The destructor for the container is:<P><pre>virtual ~Container(){  destroyit(holderPtr_, bytes_,Container_type_traits&lt;Contained&gt;::has_destructor());  munmap(holderPtr_,bytes_);}</pre>It is fairly simple to tie everything up now. I am just instantiating a <B>Yes_type</B> or <B>No_type</B> structure as the third parameter of <B>destroyit</B>, depending on the type of the contained object. If the object is a <B>double</B>, the structure is <B>No_type</B>; otherwise the structure is <B>Yes_type</B>.<P>I can now complete the implementation by specializing <B>Container_type_traits</B> structures for all the types I know do not need their destructor to be called (all the basic types qualify).<P>You can generalize this approach to many different applications. This technique allowed me to reduce memory fragmentation while maintaining a high level of performance.<P><h3>About the Author</h3>Sebastien Marc has spent the last eight years developing financial applications for Reuters in France and New York City. He is now working as a consultant for Cambridge Technology Partners in Switzerland.<p></BODY></HTML>