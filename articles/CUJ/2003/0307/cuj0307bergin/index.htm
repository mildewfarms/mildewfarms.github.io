<HTML><HEAD><TITLE>Using a Typelist to Create a Flexible Compound Sorting Object</TITLE></HEAD><body bgcolor="#FFFFFF" text="#000000"><h2>Using a Typelist to Create a Flexible Compound Sorting Object</h2><H3>Thomas Bergin</h3><I>The power of typelists applied to multiple-key sorts.</I><P> This paper describes the class <B>order_by</B> that performs a compound sort   on a container of objects according to one or more attributes. To provide flexibility,   I'll use a typelist to represent the desired sort order. This technique allows   the user to supply multiple comparison-function objects to specify the compound   sort order while retaining compile-time type checking.<P> <h3>Justification for The Class order_by</h3>The class is called <B>order_by</B> because it provides the same functionality as the SQL <B>ORDER BY</B> clause. For example, a <B>PERSON </B>table may exist that contains the columns "FIRST," "LAST," "MIDDLE," "STATE," "ZIP," and "ID." A user can return the contents of the table sorted in a number of different ways by using the <B>ORDER BY </B>clause.<P> <pre>SELECT * FROM PERSON   ORDER BY IDSELECT * FROM PERSON   ORDER BY LAST, FIRST, IDSELECT * FROM PERSON   ORDER BY STATE, ZIP, LAST, FIRST, ID</pre>This last example retrieves the data such that it is sorted by state, then each record with the same state is sorted by zip, each with the same state and zip is sorted by last name, and so on. This is known as a "compound sort."<P> Retrieving the data set presorted from the database works fine in many cases,   but not when the same data needs to be resorted multiple times. In the case   where many clients need to receive the same data set in multiple unique formats,   it becomes necessary to perform the same query multiple times just to get the   various sort orders. <P> The class <B>order_by</B> provides this functionality for containers of objects   where the concept of "less than" applies to multiple attributes. For example,   a <B>person</B> object exists that contains the data members <B>first</B>, <B>last</B>,   <B>middle</B>, <B>state</B>, <B>zip</B>, and <B>id</B>. A set of <B>less_than</B>   function objects also exists, each taking two arguments of type <B>person const   &amp;</B> and each examining one particular data attribute. (Refer to <a href="cuj0307bergin_l1.htm">Listing   1</a> for a contrived example.) <P> The <B>order_by</B> constructor can receive two random access iterators into   a container of <B>person</B> objects and sort the collection in any desired   order (see examples above).Using this class, a data set can be retrieved in   only one call to the database and then presented in many different ways.<P> An alternate approach to using the <B>order_by</B> object is to use a set   of function objects that perform the <B>less_than</B> operation on multiple   attributes at once. For example, each of the following function objects may   be written for a class with three attributes: <B>first, last, id</B>.<P> <pre>less_first    less_first_last    less_first_last_idless_last     less_last_first    less_first_id_lastless_ssn      less_first_id      less_last_first_id              less_id_first      less_last_id_first              less_last_id       less_id_first_last              less_id_last       less_id_last_first</pre>Any of these compound-comparison function objects can be passed as a third argument to the standard <B>sort</B> function, resulting in the desired order. (<a href="cuj0307bergin_l2.htm">Listing 2</a> shows an implementation of <B>struct less_last_first_id</B> and its usage.) However, there are two problems with this approach: <P> <ul>  <li> The number of function objects required to provide all compound sorting     permutations;   <li> The dependencies of the various components in the project.</ul><h3>Function Object Permutations</h3>In order to cover all possible compound-sorting permutations in this class, 15 function objects (3! + (3!/1!) + (3!/2!)) are required. A class with four attributes requires 64 function objects (4! + (4!/1!) + (4!/2!) + (4!/3!)). The number of comparison types becomes unmanageable very quickly.<P> <h3>Component Dependencies</h3>Function objects that compare the attributes of a certain class belong to the interface of that class. As part of the interface, they belong in the same translation unit as the class definition. (The function object definitions are in the same header as the class definition.) <P> One obvious motivation for this rule is that the comparison function objects   can take advantage of a friend declaration to save at least two calls to public   member access functions (see the text box titled "<a href="cuj0307bergin_s1.htm">Friendship</a>").   But more important than the efficiency issue is the presentation of a single   coherent interface to the class. A function that compares two objects of a class   by one specific attribute must model a unique concept. By not placing the comparison   function objects in the same translation unit, you are allowing a user to define   their own varieties and possibly cause the class to behave in unpredictable   ways. <P> Since the comparison function objects must reside in the same header as the   class definition, any modification to this file causes all translation units   that depend on this class to be recompiled and retested. It is unlikely that   the designer of the class is going to know all of the sorting permutations that   future users are ever going to require, and it is equally unrealistic for the   class designer to include all possible compound-sorting permutations in the   file. Therefore, the project using standard sort with compound function objects   (<a href="cuj0307bergin_l2.htm">Listing 2</a>) has established a fragile dependency   by placing a component that is likely to change above more stable components   in the dependency graph. [2] <P> The <B>order_by</B> object allows a class with multiple comparable attributes   to define only the comparison function objects that correspond to these attributes.   This decouples the class from the sorting requirements of future users.<P> <h3>Implementation</h3>Typelist [3] is key to the design of class <B>order_by</B> because there is simply no other mechanism to cope with an unknown number of unknown types at compile time. Just as an ellipsis is used in a function declaration to indicate that you do not know the number or even the type of all of the arguments, a typelist is used as a template parameter when you do not know the number or type of the template parameters. The distinction between these two methods is that a Typelist still allows for compile-time type checking. <P> A typelist is a template <B>struct</B> containing two <B>typedef</B>s: <B>Head</B>   and <B>Tail</B> (<a href="cuj0307bergin_l3.htm">Listing 3</a>). A typelist does   not have any data members or member functions. Its only purpose is to provide   the alternate type names for the two template parameters. Since a typelist is   itself a type, the <B>Tail</B> type of a typelist can be another typelist (Figures   <a href="cuj0307bergin_f1a.htm">1a</a>, <a href="cuj0307bergin_f1b.htm">1b</a>,   and <a href="cuj0307bergin_f1c.htm">1c</a>). In this way, a typelist is chained   together like a compile-time singly linked list of types. An empty <B>struct   NullType</B> is used to indicate the end of a list. <P> The class <B>order_by</B> provides a mechanism to apply the comparison function   objects in a typelist to subsequent subsets of the data to achieve the desired   compound sort. (Refer to the <B>order_by.h</B> in <a href="cuj0307bergin_l4.htm">Listing   4</a>.) <P> The <B>order_by</B> object gets the type of the container holding the objects   and the typelist of comparison-function objects as template parameters. The   length of the typelist is determined using the <B>Typelist::Length</B> [3] template   construct and is stored in the enum <B>n</B>. Since this occurs at compile time,   <B>n</B> can be used in turn as a template parameter for the next instantiation   of class <B>order_by</B>. The type of the comparison function at the current   offset in the typelist is <B>typedef</B>'d to <B>comp_type</B> using the <B>Typelist::TypeAt</B>   [3] template construct. This is used to call the standard <B>sort</B> function   on the range specified by the constructor arguments. The <B>comp_type</B> is   also used with the standard <B>equal_range</B> function to determine the subsets   of the container (differentiated by the attribute associated with <B>comp_type</B>).<P> (Again in English.) The <B>order_by</B> function first sorts the entire container   using the first comparison function object. The code then enters a <B>while</B>   loop where the container is broken up into subsets of equal items based on this   comparison type. A new <B>order_by</B> object is created receiving the subset   of items and the index of the next function object. This <B>order_by</B> object   knows nothing of the previous object and thinks that it has received the entire   container and the first comparison function object. This occurs in classic "recursive   style" until there are no more function objects by which to sort, and all of   the equal ranges in the outermost container are sorted.<P> The instantiation of the subsequent <B>order_by</B> objects uses the expression   <B>((i+1==n)?(0xFFFF):(i+1))</B> as the third integral template parameter. This   indicates that the next typelist index is to be used unless it would be past   the end of the typelist, in which case, a marker value is substituted. This   is possible because <B>i</B> and <B>n</B> are compile-time constants and operator   <B>?:</B>, unlike an <B>if-then-else </B>statement, is also evaluated at compile   time. The marker integer is used as the partial specialization of the <B>order_by</B>   class template to end the template recursion.<P> I refer to the cascading function calls as "recursive style" out of convenience   only. Although one function calling itself looks like classic recursion, this   case is different because it is a constructor. The only true recursion that   is taking place is in the compile-time recursive template instantiation of the   various versions of the <B>order_by</B> class (one distinct <B>order_by</B>   object for each item in the Typelist). The calls appear to be recursive in the   code, but in reality, they are simply calls made between the template instantiations   of the <B>order_by</B> objects.<P> The effect of instantiating an <B>order_by</B> object with a typelist containing   four types is to create four <B>order_by</B> objects that call each other's   constructors in the order determined by the typelist.<P> <h3>Type Checking</h3>Although <B>equal_range</B> only requires forward iterators, <B>sort </B>requires random access iterators. Any attempt to create an <B>order_by </B>object with a container type that does not support random access iterators results in a compile-time error. Any attempt to place a function object into the typelist that does not have the <B>bool operator()(T const &amp;, T const &amp;) const</B> signature also results in a compile error. (This is the advantage of a typelist solution: If it compiles, it works.)<P> <h3>Runtime Implications of Using a Typelist Solution</h3>It is not possible to create a new type at run time. Therefore, all of the <B>order_by</B> objects created for a specific typelist are created at compile time. The implication is that all sorting permutations that need to exist at run time need to exist in the code.<P> If a separate typelist needs to be created for each compound-sorting permutation,   why bother using a typelist solution at all? The answer is in the dependency   relationships. The code that defines the various typelists may need to be modified   each time a new compound sort is required by a user, but this code does not   have to reside in the file containing the comparison function objects and class   definition. This code can be isolated from the other modules, and, therefore,   the source of instability is isolated from the highly depended-upon components. <P> <a href="cuj0307bergin_f2a.htm">Figure 2a</a> shows the dependency graph of   a project using a <B>sort_logic</B> component. The <B>person.h</B> in this project   contains multiple-compound comparison function objects and uses the standard   sort function to perform the sorting (as shown in <a href="cuj0307bergin_l2.htm">Listing   2</a>). The <B>sort_logic</B> component collects the runtime information and   calls the <B>sort</B> function, depending on which type of sorting is required.   (This may occur by reading a list of client options from a database, getting   a user's preferences from a cookie, and so on.) The person object is fairly   ubiquitous and many components in the project depend on it. In this case, when   a user of the <B>sort_logic</B> component needs to account for a new type of   sorting, the <B>person.h</B> file must be modified. This necessitates the recompilation   and retesting of all dependent components (<B>A</B>, <B>B</B>, and <B>C</B>). <P> <a href="cuj0307bergin_f2b.htm">Figure 2b</a> shows the dependency graph of   a project that uses the <B>order_by</B> object for compound sorting. A new component   <B>person_sel</B> has been added that contains the known sorting requirements   (Please refer to <a href="cuj0307bergin_l5.htm">Listing 5</a>). In each <B>case</B>   block, the construction of object <B>o</B> sorts the container according to   the Typelist provided as its second template parameter. The <B>sort_logic</B>   component works as it did before: collecting the runtime information and calling   the proper sort. However, in this case, the person component only contains one   comparison-function object per attribute and has no knowledge of any of the   sorting requirements. When a new compound sort is needed, only the <B>person_sel.h</B>   file is modified and all of the other components that have included the <B>person.h</B>   do not know or care. <P> In this way, the characteristic of the project that is most likely to change   is isolated from the component that needs to be the most stable.<P> <h3>Summary</h3>Is all of this work worth the effort? Of course it is. If you are defining a class you should only be concerned with creating a complete, coherent object, not with trying to predict downstream business rules. The class <B>person</B> in this case only cares that each of its attributes can be used to order a collection of its objects. The class <B>order_by</B> exists so that classes such as <B>person</B> can exist in blissful ignorance of how they are being used. The insulation of highly depended-upon components from highly unstable components helps to create a project that painlessly allows for the inevitable changes.<P> The use of typelist allows for the best of both worlds: the flexibility of   using unknown numbers of unknown types and the desirability of compile-time   type checking.<P> <h3>References</h3>[1] John Lakos. <I>Large-Scale C++ Software Design</I>. (Addison-Wesley, 1996).<P> [2] R.C. Martin, "Large-scale Stability," C++ Report, 9(2), pp. 54-60, February   1997.<P> [3] Andrei Alexandrescu. <I>Modern C++ Design</I>. (Addison-Wesley, 2001).<P> <h3>About the Author</h3>Thomas Bergin is currently working at the Kansas City, MO office of the National Insurance Producer Registry (Affiliate of the National Association of Insurance Commissioners).<p> </BODY></HTML>