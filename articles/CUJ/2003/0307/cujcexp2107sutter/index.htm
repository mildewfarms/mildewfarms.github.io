<html><head><title>Sutter's Mill -- July 2003</title><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"></head><body bgcolor="#FFFFFF" text="#000000"><h2>(Mostly) Private</h2><h3>Herb Sutter</h3><p><i>In C++, to what extent are the private parts of a class really truly   private? In this month's column, we see how private names are definitely not   accessible from outside nonfriend code, and yet they do leak out of a class   in small ways - some of which are well-known, others of which are not. </i><p><font color="#0000CC">[Note: In the previous column, I said I'd talk about   <b>inline</b> in this column. I decided to put it off for one column so   that this time I can first cover another fun topic: <b>private</b>. Next   time it'll be <b>inline</b>'s turn.] </font><blockquote>  <p><cite>"So, just how private is <b>private</b>, Private?" [1] </cite></p></blockquote><p>Quick &#151; assuming that the <b>Twice</b> functions are defined in another   translation unit that is included in the link, should the following C++ program   compile and run correctly? If no, why not? If yes, what is the output? <p><pre>// Example 1: Twice(x) returns 2*x//class Calc {public:  double              Twice( double d );private:  int                 Twice( int i );  std::complex&lt;float&gt; Twice( std::complex&lt;float&gt; c );};int main() {  Calc c;  return c.Twice( 21 );}</pre><p> At the heart of the solution lies this question: In C++, to what extent are   the <b>private</b> parts of a class, such as Example 1's <b>Twice</b>, really   truly private? In this column, I'll show how <b>private</b> names are definitely   not accessible from outside nonfriend code, and yet they can and do leak out   of a class in small ways &#151; some of which are well-known, others of which   aren't, and a few of which can even be done as a calculated, deliberate act. <p><h3>The Basic Story: Accessibility</h3><p>The fundamental thing to recognize is this: Like <b>public</b> and <b>protected</b>,   <b>private</b> is an access specifier. That is, it controls what other code   may have access to the member's name &#151; and that's all. Quoting from the   C++ Standard [2], the opening words of clause 11 state: <blockquote>   <p>"A member of a class can be </blockquote><ul>  <li> <b>private</b>; that is, its name can be used only by members and friends     of the class in which it is declared. </li>  <li><b>protected</b>; that is, its name can be used only by members and friends     of the class in which it is declared, and by members and friends of classes     derived from this class (see class.protected). </li>  <li><b>public</b>; that is, its name can be used anywhere without access restriction."   </li></ul><p>This is pretty basic stuff, but for completeness let's look at a simple example   that makes it clear that access is indeed well controlled and there's no standards-conforming   way around this. Example 2 demonstrates that nonfriend code outside the class   can never get to a private member function by name either directly (by explicit   call) or indirectly (via a function pointer), because the function name can't   be used at all, not even to take the function's address [3]:<p><pre>// Example 2: I can't get No::Satisfaction//class No {private:  void Satisfaction() { }};int main() {  No no;  <b>no.Satisfaction();             // error</b>  typedef void (No::*PMember)();  <b>PMember p = &No::Satisfaction; // error</b>  return (no.*p)();              // nice try...}</pre><p> There's just no way for outside code to incant the name of the function. To   the question: "Just how private is <b>private</b>?", we now have the first bit   of an answer: <blockquote>  <p><b>A <code>private</code></b><b> member's name is only <i>accessible</i>     to other members and friends. </b> </p></blockquote><p>If that were the whole story, this would be a short (and rather pointless) article. But, of course, accessibility is not the whole story.<p><h3>The Other Story: Visibility</h3><p>The keyword <b>private</b> does indeed control a member's <i>accessibility</i>.   But there is another concept that is related to (but often confused with) accessibility,   and that is <i>visibility</i>. Let's return now to the Example 1 program, and   the question: Will it compile and run correctly? <p>The short answer is no. In the form shown, the Example 1 program is not legal and will not compile correctly. There are two reasons why. The first one is a fairly obvious error:<p><pre>// Example 1 (repeated with annotation)//class Calc {public:  double              Twice( double d );private:  int                 Twice( int i );  <b>std::complex&lt;float&gt; Twice( std::complex&lt;float&gt; c );                      // error: std::complex not declared</b>};int main() {  Calc c;  return c.Twice( 21 );}</pre><p> Every C++ programmer knows that, even though the version of <b>Twice</b> that   takes a <b>complex</b> object isn't <i>accessible</i> to the code in <b>main</b>,   it's still <i>visible</i> and constitutes a source dependency. In particular,   even though the code in <b>main</b> can't possibly ever care about <b>complex</b>   &#151; it can't even so much as use the name of <b>Twice</b>(<b>complex&lt;float&gt;</b>)   (it can't call it or even take its address), and the use of <b>complex</b> can't   possibly affect <b>Calc</b>'s size or layout in any way &#151; there still at   minimum must be at least a forward declaration of <b>complex</b> for this code   to hope to compile. (If <b>Twice</b>(<b>complex&lt;float&gt;</b>) were also   defined inline, then a full definition of <b>complex</b> would be required too,   even though it still couldn't possibly matter to this code.) <p>To the question: "Just how private is <b>private</b>?", we now have another   bit of the answer: <blockquote>  <p><b>A <code>private</code> member is <i>visible</i> to all code that sees     the class's definition. This means that its parameter types must be declared     even if they can never be needed in this translation unit... </b></p></blockquote><p>Everyone knows we can fix this easily enough by adding <b>#include &lt;complex&gt;</b>,   so let's do that. This leaves us with the second, and probably less obvious,   problem: <p><pre>// Example 3: A partly fixed version of Example 1//#include &lt;complex&gt;class Calc {public:  double              Twice( double d );private:  int                 Twice( int i );  std::complex&lt;float&gt; Twice( std::complex&lt;float&gt; c );};int main() {  Calc c;  <b>return c.Twice( 21 ); // error, Twice is inaccessible</b>}</pre><p> This result surprises a fair number of C++ developers. Some programmers expect   that since the only accessible overload of <b>Twice</b> takes a <b>double</b>,   and <b>21</b> can be converted to a <b>double</b>, then that function should   be called. That's not, in fact, what happens, for a simple reason: Overload   resolution happens before accessibility checking. <p>When the compiler has to resolve the call to <b>Twice</b>, it does three main   things, in order: <ol>  <li>Before doing anything else, the compiler searches for a scope that has at     least one entity named <b>Twice</b> and makes a list of candidates. In this     case, name lookup first looks in the scope of <b>Calc</b> to see if there     is at least one function named <b>Twice</b>; if there isn't, base classes     and enclosing namespaces will be considered in turn, one at a time, until     a scope having at least one candidate is found. In this case, though, the     very first scope the compiler looks in already has an entity named <b>Twice</b>     &#151; in fact, it has three of them, and so that trio becomes the set of     candidates. (For more information about name lookup in C++, with discussion     about how it affects the way you should package your classes and their interfaces,     see also Items 31-34 in <i>Exceptional C++</i>. [4]) </li>  <li> Next, the compiler performs overload resolution to pick the unique best     match out of the list of candidates. In this case, the argument is 21, which     is an <b>int</b>, and the available overloads take a <b>double</b>, an <b>int</b>,     and a <b>complex&lt;float&gt;</b>. Clearly the <b>int</b> parameter is the     best match for the <b>int</b> argument (it's an exact match and no conversions     are required), and so <b>Twice(int)</b> is selected. </li>  <li>Finally, the compiler performs accessibility checking to determine whether     the selected function can be called. In this case... boom thud splatter. </li></ol><p>It doesn't matter that the only accessible function, <b>Twice(double)</b>,   could in fact be a match; it can never be called, because there is a better   match, and a better match always matters more than a more accessible match. <p>Interestingly, even an ambiguous match matters more than a more accessible match. Consider this slight change to Example 3:<p><pre>// Example 4(a): Introducing ambiguity//#include &lt;complex&gt;class Calc {public:  double              Twice( double d );private:  <b>unsigned            Twice( unsigned i );</b>  std::complex&lt;float&gt; Twice( std::complex&lt;float&gt; c );};int main() {  Calc c;  <b>return c.Twice( 21 ); // error, Twice is ambiguous</b>}</pre><p> In this case, we never get past the second step: Overload resolution fails   to find a unique best match out of the candidate list, because the actual parameter   type <b>int</b> could be converted to either <b>unsigned</b> or <b>double</b>   and those two conversions are considered equally good according to the language   rules. Because the two functions are equally good matches, the compiler can't   choose between them and the call is ambiguous. The compiler never even gets   to the accessibility check. <p>More interestingly, perhaps, is that even an impossible match matters more   than a more accessible match. Consider this rearrangement of Example 3: <p><pre>// Example 4(b): Introducing plain old name hiding//#include &lt;string&gt;int Twice( int i ); // now a global functionclass Calc {private:  std::string Twice( std::string s );public:  int Test() {    <b>return Twice( 21 ); // error, Twice(string) is unviable</b>  }};int main() {  return Calc().Test();}</pre><p> Again, we never get past the second step: Overload resolution fails to find   any viable match out of the candidate list (which now is only <b>Calc::Twice(string)</b>),   because the actual parameter type <b>int</b> can't be converted to <b>string</b>.   The compiler again never even gets to the accessibility check. Remember, as   soon as a scope is found that contains at least one entity with the given name,   the search ends &#151; even if that candidate turns out to be uncallable and/or   inaccessible. Other potential matches in enclosing scopes will never be considered. <p>To the question: "Just how private is <b>private</b>?", we now have yet another   bit of the answer: <blockquote>  <p><b>A <code>private</code> member is <i>visible</i> to all code that sees     the class's definition. This means that ... it participates in name lookup     and overload resolution and so can make calls invalid or ambiguous even though     it itself could never be called. </b></p></blockquote><p>Bjarne Stroustrup writes about these effect in <i>The Design and Evolution   of C++ </i>[5]: <blockquote>  <p>"Making <b>public</b>/<b>private</b> control visibility, rather than access,     would have a change from public to private quietly change the meaning of the     program from one legal interpretation (access [in our example, <b>Calc::Twice(int)</b>])     to another (access [in our example, <b>Calc::Twice(double)</b>]). I no longer     consider this argument conclusive (if I ever did) but the decision made has     proven useful in that it allows programmers to add and remove public and private     specifications during debugging without quietly changing the meaning of programs.     I do wonder if this aspect of the C++ definition is the result of a genuine     design decision." </p></blockquote><p><h3>Back to the First Story: Granting Access</h3><p>As the first part of our answer to the "how private is <b>private</b>?" question,   I said that a private member is only <i>accessible</i> to (its name can only   be used by) other members and friends. Note that I deliberately avoided saying   anything like &quot;'it can only be called by other members or friends,&quot;   because that's actually not true. Accessibility establishes the code's right   to use the name. Let me emphasize that point from the earlier quote from the   C++ Standard: <blockquote>   <p>"A member of a class can be </p></blockquote><ul>  <li><b>private</b>; that is, its <i>name</i> can be used only by members and     friends of the class in which it is declared." </li></ul><p>If code that has the right to use the name (in this case, a member or friend)   uses the name to form a function pointer, and passes that pointer out to other   code, the receiving code can use that pointer whether or not the receiving code   has the right to use the member's name &#151; it no longer needs the name, because   it's got a pointer. Example 5 illustrates this technique at work, where a member   function that has access to the name of <b>Twice(int)</b> uses that access to   leak a pointer to that member: <p><pre>// Example 5: Granting access//class Calc;typedef int (Calc::*PMember)(int);class Calc {public:  PMember CoughItUp() { return &Calc::Twice; }private:  int    Twice( int i );};int main() {  Calc c;  PMember p = c.CoughItUp(); // yields access to Twice(int)  return (c.*p)( 21 );       // ok}</pre><p> To the question: "Just how private is <b>private</b>?", we now have one final   (at least, final for this article) bit of the answer: <blockquote>  <p><b>Code that has access to a member can grant that access to any other code,     by leaking a (name-free) pointer to that member.</b> </p></blockquote><p><h3>Summary</h3><p>So, how private is <b>private</b>? Here's what we've found: <p>A <b>private</b> member's name is only <i>accessible</i> to other members and   friends. But code that has access to a member can grant that access to any other   code, by leaking a (name-free) pointer to that member. <p>A <b>private</b> member is <i>visible</i> to all code that sees the class's   definition. This means that a <b>private</b> member's parameter types must be   declared even if they can never be needed in this translation unit, and it participates   in name lookup and overload resolution and so can make calls invalid or ambiguous   even though it itself could never be called. <p><h3>Notes and References</h3><p>[1] C. Heap, F. Ictional, and O. B. Scure. <i>Military Sounding</i> (Reference,   2003). <br>  [2] ISO/IEC 14882:1998(E), International Standard, Programming Languages - C++.   <br>  [3] Undefined hacks like trying to <b>#define private public</b> are nonstandard,   deplorable, and reportedly punishable by law in 42 states. <br>  [4] H. Sutter. <i>Exceptional C++ </i>(Addison-Wesley, 2000). <br>  [5] B. Stroustrup. <i>The Design and Evolution of C++ </i>(Addison-Wesley, 1994),   page 55. <p> </body></html>