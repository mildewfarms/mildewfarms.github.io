<html><head><title>Listing 2</title><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"></head><body bgcolor="#FFFFFF" text="#000000"><b>Listing 2</b><pre>// brute-force approach to the// event producer-consumer idiom#include &lt;iostream&gt;#include &lt;ostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;// interface of the listenerclass ActionListener{public:    virtual void actionPerformed() = 0;};// some class that can generate eventsclass SomeClass{public:    // registration function    void addListener(ActionListener *p)    {        listeners_.push_back(p);    }    // some other functions    // ...    void foo();private:    // collection of pointers to listeners    typedef vector&lt;ActionListener*&gt; ListenerBag;    ListenerBag listeners_;    // some other members    // ...};// some function that can produce an eventvoid SomeClass::foo(){    // ...    // produce an event and notify    // all listeners that are registered    ListenerBag::iterator it;    ListenerBag::iterator itend = listeners_.end();    for (it = listeners_.begin(); it != itend; ++it)    {         (*it)-&gt;actionPerformed();    }}// some listener classclass MyListener : public ActionListener{public:    MyListener(const string &name) : name_(name) {}    void actionPerformed()    {        cout &lt;&lt; name_            &lt;&lt; " : Action performed, sir!" &lt;&lt; endl;    }private:    string name_;};int main(){    MyListener l1("listener 1");    MyListener l2("listener 2");    SomeClass someobject;    someobject.addListener(&l1);    someobject.addListener(&l2);    // ...    someobject.foo();    // ...    return 0;}</pre></body></html>