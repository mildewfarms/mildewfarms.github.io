<html><head><title>Listing 4</title><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"></head><body bgcolor="#FFFFFF" text="#000000"><b>Listing 4</b><pre>// the core interface of the Messaging classtemplate&lt;    class Listener,    typename Context = int,    class Mutex = NoSynchronization,    class BagType = std::vector&lt;Listener*&gt;&gt;class Messaging{public:    // registers the listener    // listeners registered more than once will be notified    // once for each registration    void addListener(Listener *listener)    {        listeners_.add(listener);    }    // unregisters the listener    // it doesn't hurt if it's not already registered    // multiply registered listeners should also multiply    // unregister themselves    void removeListener(Listener *listener)    {        listeners_.remove(listener);    }protected:    // this method should be called by the derived class    // to trigger event dispatching    void raiseEvent(const Context &context)    {        typedef typename BagType::iterator iterator;        BagType frozen(listeners_.getFrozen());        iterator it;        iterator itend = frozen.end();        for (it = frozen.begin(); it != itend; ++it)        {            Listener *p = static_cast&lt;Listener*&gt;(*it);            dispatchEvent(p, context);        }    }    // this is intended to be overriden in a derived class    // and is responsible for the actual dispatching    // this method is called for every registered listener    // (once for each registration)    // the overriding method should call the listener,    // using (or not) the context as a clue    virtual void dispatchEvent(Listener *listener,                                const Context &context) = 0;private:    // the synchronized container for keeping pointers    // to listener objects    ListenersCollection&lt;Listener, Mutex, BagType&gt; listeners_;};</pre></body></html>