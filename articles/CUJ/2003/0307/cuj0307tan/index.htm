<html><head><title>Exploring EDA Algorithms with the Boost Graph Library</title><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"></head><body bgcolor="#FFFFFF" text="#000000"><h2>Exploring EDA Algorithms with the Boost Graph Library</h2><h2>by Kwee H. Tan</h2><h3>Introduction</h3><p>Electronic design automation (EDA) algorithms are very much graph-based. For   example, a logic circuit can be considered as a graph of vertices, each vertex   representing some digital function. A simulation algorithm will start at the   inputs and propagate the changes until output vertices are reached. An automatic   test pattern generation (ATPG) algorithm may start with a simulated fault on   one edge, and work backwards and forwards to find the set of inputs that will   make the fault observable at some set of outputs. <p> This article describes a tool that I created to learn and explore EDA algorithms   on different circuits. Since this is a learning tool, I concentrate more on   how I leveraged other open source tools and <i>C/C++ Users Journal</i> (CUJ)   contributions to put the infrastructure together. <p> The outcome is a medium-sized project (started by a letter from Michael Solem   in a March 2002 CUJ; see references) that: <ul>  <li> currently builds and runs (which provides a working baseline),</li>  <li>can be used as a C++ and BGL learning tool,</li>  <li>and, can be used as an EDA algorithms learning tool. </li></ul><p> The most recent CUJ article on Boost Graph Library (BGL) (Vitaly Ablavsky's   "Applying BGL to Computational Geometry"; see references) hints at VC6 compiler   problems and encourages the user to take the effort to learn BGL. I've provided   a <a href="tans1.html" target="_blank">sidebar</a> on the common problems encountered   and their solutions or workarounds. <p> Finally, I'll also illustrate the value of reading CUJ, and, getting the CD-ROM  ( in my case, Release 4) for past articles and source code (see <a href="tans2.html" target="_blank">sidebar   2</a>). <p> <h2>BGL provides an executable specification for graph algorithms </h2><p> The <a href="http://www.boost.org/libs/graph/doc/table_of_contents.html" target="_blank">BGL</a>   (Boost Graph Library; see references) provides standardized access to generic   graph structures and algorithms so that many problems that require a graph solution   can be easily mapped and implemented, in a reusable manner. This allows the   user to concentrate on his problem area and rely on BGL's high-level graph concepts   for graph access and manipulation. <p> BGL can be adapted to work with any pre-existing graphs by creating adaptors   for the target graph format. In fact, adaptors already exist for use with AT&T's   <a href="http://www.research.att.com/sw/tools/graphviz/" target="_blank">Graphviz</a>   (see references), LEDA, and Stanford Graphbase. This means that a graph algorithm   developed with BGL can be reviewed and, better yet, executed by peers anywhere   in the world. Test graphs can similarly be exchanged and imported. <p> <h2>Software infrastructure</h2><p> In order to use a graph algorithm, some software infrastructure for the following   aspects needed to be created: <ol>  <li> circuit visualization </li>  <li>circuit input/output </li>  <li>circuit representation </li>  <li>multivalued logic </li>  <li>trace and debug </li></ol><p> As it turns out, BGL provided a simple and effective solutions for 1-3, while   browing the CUJ CD-ROM provided reusable components for 4 and 5. <p> <h2>Using BGL in an ATPG algorithm</h2><p> I was interested in a basic automatic test pattern generation ( ATPG ) algorithm   as described in <i>Application-Specific Integrated Circuits</i> by Michael John   Sebastian Smith (see references). Although I could follow the high-level description   given, there were details missing, and I decided to implement it with BGL to   get a flavor for what it actually took. <p> The problem can be stated as follows : Given an electrical cicuit and a selected   fault on one net (either stuck-at-one or stuck-at-zero), we want to find the   set of inputs that will make the fault observable at an output. <p> Informally, the algorithm can be described as : <ol>  <li> Set the objective vertex to the vertex thats input is the fault to be simulated.   </li>  <li>Start with an objective vertex or set of objective vertices </li>  <li>Backtrace from the objective vertex to input nodes, and set the input nodes     to values that will help meet the objective. This generally means using enabling     logic values so that the fault will be propagated. </li>  <li>For each backtrace set of input nodes and values, simulate the circuit to     see if it is possible to reach some output. As the simulation progresses and     the fault is propagated, update the D Frontier. If we reach an output, we     are done. Repeat with 2, picking an objective from the D Frontier. </li></ol><p> If you are wondering what the D Frontier is, that's exactly what I wondered   after reading the textbook. By attempting to implement the algorithm, it quickly   became clear why and how we need this structure. This class is encapsulated   in the source file, <b>DFrontier.hpp</b>. <p> To implement step 3, BGL has the concept of a reverse_graph that allows a   directed graph to be traversed backwards. In fact, the code below shows the   implementation used in the backtraceVertex function: <p> <code> backtraceVertex(){ <br>  ...<br>  BacktraceVisitor&lt;reverse_graph&gt;&lt;G&gt; &gt; backtraceVisitor(_g,_e,_setVS);   depth_first_visit(*_pRG,v,backtraceVisitor,&GraphColorMap[0]); <br>  ...<br>  } </code> <p> Step 4 requires a special kind of forward graph traversal. <p> I originally started using a BGL depth first search (DFS) visitor because   the simulation can stop as soon as we reach an output, and we want to drive   an input as far as we can before trying another input. There was a catch &#151;   the DFS does a complete traversal and there is no provision to break out of   the search early. <p> Posing the question on the BGL Web site, the main suggestion was to throw   an exception in the visitor code and catch it in the calling code. I found an   alternate solution by looking at the BGL's <b>depth_first_search.hpp</b> and   changed a line of <b>depth_first_visit_impl</b> traversal loop from : <p> <code> for (tie(ei, ei_end) = out_edges(u, g); ei != ei_end; ++ei) { ... }   </code> <p> to : <p> <code> for (tie(ei, ei_end) = out_edges(u, g); (ei != ei_end) && (vis.continueSearch());   ++ei){ ... } </code> <p> By exposing a function called <b>continueSearch()</b> in my DFS visitor, I   could use it to break out of a DFS traversal when I needed to. <p> Unfortunately, further testing revealed a flaw in the use of DFS. It turns   out that the propagation of simulation values may require visiting a vertex   several times, essentially as many times as changes arrive at the inputs. A   DFS traversal only visits a vertex once. I ended up with a custom traversal   implemented in the pair of functions <b>propagateVertex</b> and <b>propagateChange</b>.   The beauty of using BGL is that this sort of discovery and rework is much easier   to do. <p> <h2>Circuit visualization and IO </h2><p> <a href="http://www.research.att.com/sw/tools/graphviz/" target="_blank">GraphViz</a>   is the short name for the Graph Visualization Project. Developed at AT&T and   placed in open source, it provides a collection of tools for manipulating graph   structures and generating graph layouts (see references). <p> My motivation for using Graphviz came directly from the BGL documentation.   "The Graphviz package provides tools that automatically layout and draw graphs.   It is available at <a href="http://www.research.att.com/sw/tools/graphviz/" target="_blank">http://www.research.att.com/sw/tools/graphviz/</a>.   In fact, all of the graph drawings in the BGL book (see references) were created   using Graphviz. The Graphviz tools use a special file format for graphs, called   dot files. BGL includes a parser for reading this file format into a BGL graph&quot;. <p> BGL's built-in support for Graphviz graphs and digraphs, saves me the time   in building a graph visualization system. Besides, my requirements were quite   basic: <ol>  <li> Add labels to edges and vertices (typically by editing the .dot file) </li>  <li>Viewing the input and output graphs (with the dotty utility) </li></ol><p> There are two general ways of using Graphviz with BGL. One is to use it solely   for visualization. In this case, the code will copy the Graphviz graph or digraph   into an internal graph structure for processing, and then write out a Graphviz   graph at the end. The other way is to directly operate on the Graphviz graph/digraph   itself. The value of the property called "label" is displayed in the dotty window   when the graph is viewed. This seemed simpler, and was the approach I took.   However, there was one minor problem &#151; the default definition of GraphvizDigraph   in <b>Graphviz.hpp</b> is: <p> <code>typedef subgraph&lt;adjacency_list&gt;&lt;boost::vecS, boost::vecS,   <br>  boost::directedS, GraphvizVertexProperty, GraphvizEdgeProperty, <br>  GraphvizGraphProperty&gt; &gt; GraphvizDigraph; </code> <p> In order to traverse the diagraph in both directions, this line has to be   changed to: <p> <code> typedef subgraph&lt;adjacency_list&gt;&lt;boost::vecS, boost::vecS,   <br>  boost::bidirectionalS, GraphvizVertexProperty, GraphvizEdgeProperty, <br>  GraphvizGraphProperty&gt; &gt; GraphvizDigraph; </code> <p> The <b>bglgraphviz.lib</b> then has to be rebuilt and linked in with the main   program. <p> <b>Circuit representation</b> <p> An electrical circuit consists of logic units or devices and electrical connections   (called nets) between them. A logic unit's output may be connected to the inputs   of several other logic units. Special devices called inputs and outputs pertain   to where electrical signals may be applied and observed/measured. <p> The nature of outputs driving inputs suggests that a GraphvizDigraph is a   natural representation. Vertices are used to represent the logic devices. For   simplicity, the vertex label has the format &lt;name:func&gt;. Logic values   are read and written on the edge labels. BGL provides a convenient syntax to   access these properties. They look like <b>vertexMap[vertexId]["label"]</b>   for vertex labels and <b>edgeMap[edgeId]["label"]</b> for edge labels. <p> While a GraphvizDigraph captures the essential pieces of a circuit for my   purposes, I should point out that its use implies some simplifications: <ol>  <li> In an electrical circuit diagram, the output of a logic unit X, can be     connected to several other logic units, A, B, and C, for example. This is     approximated by attaching multiple directed edges from X to A, X to B, X to     C. Internally, our algorithm will set all output edges to the same value.   </li>  <li>I was not able to use custom shapes in Graphviz. Thus, the vertex shapes     defaulted to ellipse, instead of the standard electrical model symbols (e.g.,     triangle for inverters, half-ellipses for nands and nors). I instead used     the naming convention (<b>U2:not</b>, <b>U3:nand</b>, <b>U5:in</b>, etc.)     to specify the different logic units.</li>  <li>Edge connections are not orthogonal as in standard electrical circuits,     but curved. </li></ol><p> <h2>Multivalued logic</h2><p> The ATPG algorithm uses a 5 value logic system called the D-Calculus (Michael   John Sebastian Smith's <i>Application-Specific Integrated Circuits</i>; see   references). The 5 basic logic values are <b>ZERO</b>, <b>ONE</b>, <b>D</b>,   <b>_D</b>, and <b>X</b>. <b>D</b> and<b> _D</b> are used to represent a simultaneus   good circuit/bad circuit state. For example, <b>D</b> is used to represent a   <b>ONE</b> in a good circuit, and a <b>ZERO</b> in a bad circuit, while<b> _D</b>   is used to represent a <b>ZERO</b> in a good circuit, and a <b>ONE</b> in a   bad circuit. The <b>X</b> is the standard "undefined" or "don't care" state.   <b>X</b>s are typically used to initial circuits to simulate a random power-up   situation. <p> The five-value logic system is ideally implemented as a enum. However, the   C++ enum has several shortcomings that limit their usage. Art Walker's enum++   ( see references ) is a tool that generates first-class enumerations that provide   for type-safe, bounded symbol sets, with IO support built in. I only needed   to add additional support for functors. <p> With a simple one-line input specification to the enum_gen tool, like so: <p> <code> enum DLogic{ ZERO,ONE,D,_D,X}; </code> <p> and I got working code. <p> <h2>Running the program</h2><table width="150" border="0" cellpadding="0" align="right">  <tr>     <td><a href="tanf1.jpg" target="_blank"><img src="tanf1_thm.jpg" width="200" height="172"></a></td>  </tr>  <tr>     <td> <div align="center"><a href="tanf1.jpg" target="_blank">Figure 1</a></div></td>  </tr></table><p>The program was developed on VC6 Sp3 and Comeau 4.3.0.1. At the time of writing,   Boost was at 1.25.1. The <a href="code.zip" target="_blank">source code</a>   distribution contains a test directory, with a sample <b>Not2.dot</b> circuit.   The Graphviz dotty tool can be used to view the circuit/graph. <p>By invoking <b>atpg.exe -atpg -r Not2.dot -w Not2_out.dot</b>, the output circuit   <b>Not2_out.dot</b> is created and again can be viewed with dotty. Use atpg.exe   -h for some usage information. <p> <a href="tanf1.jpg" target="_blank">Figure 1</a> shows how the circuits look   on my machine. <p> <h2>References</h2><p> "A Handy Debugger Class", Maurice J Fox, <i>C/C++ Users Journal</i>, April   2001<br>  "An   STL Error Message Decryptor for Visual C++", Leor Zolman, <i>C/C++ Users   Journal</i>, July 2001<br>  "Application-Specific Integrated Circuits", Michael John Sebastian Smith, <a href="http://www.aw.com/" target="_blank">Addison-Wesley</a>,   Section 14.5.1 The D-Calculus <br>  "Application-Specific Integrated Circuits", Michael John Sebastian Smith, <a href="http://www.aw.com/" target="_blank">Addison-Wesley</a>,   Section 14.5.2 Basic ATPG Algorithm <br>  "Applying BGL to Computational Geometry", Vitaly Ablavsky, <i>C/C++ Users Journal</i>,   August 2002<br>  "<a href="http://support.microsoft.com/default.aspx?scid=kb;en-us;242190" target="_blank">BUG:   Full Koenig Lookup Works Only For Operators</a>", Knowledgebase article Q242190   <br>  "Enum++ - an enum class generator", Art Walker, <i>C/C++ Users Journal</i>,   March 1999 <br>  "Migrating to Namespaces", Herb Sutter, <i>Dr. Dobb's Journal</i>, October 2000   <br>  <i>The Boost Graph Library</i> (page 82), by Jeremy Siek and others, <a href="http://www.aw.com/" target="_blank">Addison-Wesley</a>   2001 <br>  "We Have Mail", letter from Michael Solem, <i>C/C++ Users Journal</i>, March   2002 <p><b>Web sites</b> <p> Boost Graph Library at <a href="http://www.boost.org/libs/graph/doc/table_of_contents.html" target="_blank">http://www.boost.org/libs/graph/doc/table_of_contents.html</a>   <br>  Graphviz tools at <a href="http://www.research.att.com/sw/tools/graphviz/" target="_blank">http://www.research.att.com/sw/tools/graphviz/</a> <p> <h3>About the Author</h3><p>Kwee Heong Tan is a software engineer with 9 years of experience in C/C++ and   6 years in Perl. He holds an M.Sc in Computer Science and a B.E. in Electrical   Engineering. He has worked for the EDA companies Mentor Graphics and Genedax   Design Automation over the last 13 years on various tools and products like   library management, VHDL validation, IC layout and verification, and design   framework on both Unix and Windows. He is currently between jobs and can be   reached at tan.k.h@juno.com. </body></html>