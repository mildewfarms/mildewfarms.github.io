<HTML><HEAD><TITLE>Space Efficient Sets and Maps</TITLE></HEAD><body bgcolor="#FFFFFF" text="#000000"><h2>Space Efficient Sets and Maps</h2><h3>Michael Carrato</h3><I>Combining the best of the vector and associative container worlds.</I><P><h3>Introduction</h3>Standard C++ provides a rich set of collection templates, including the tree-based associative collections <B>std::set</B> and <B>std::map</B>. <B>std::set</B> and <B>std::map</B> are flexible, scalable, and highly performing, but there are cases where the size overhead of the internal trees is impractical. This impracticality is especially evident for small data types, where the size overhead of tree-based collections can be as high as 300%.<P>Sorted vectors, on the other hand, have very little overhead and have gained in popularity among developers in search of a leaner, meaner associative collection. However, the rigid structure of sorted vectors limits their flexibility, relegating them to special-purpose use.<P>This article describes a new type of sorted-vector-based associative collection, which is almost as flexible as the tree-based collections and almost as space efficient as pure sorted vectors. The result is a general purpose, space efficient, drop-in replacement for the standard associative containers, <B>std::set</B> and <B>std::map</B>.<P><h3>Background</h3><h3>The Amazing std::vector</h3>Structurally, the Standard C++ vector could not be any simpler. Implemented internally as a contiguous array of elements, the Standard C++ vector achieves random access to elements by simple pointer arithmetic, and space overhead is minimal.<P>Yet, despite its structural simplicity, <B>std::vector</B> is a powerhouse: small, fast, flexible, scalable. I have always been fascinated by one particular feature of <B>std::vector</B>: its ability to expand its capacity automatically in amortized constant time [1], despite having to recreate its entire structure to expand.<P>The reason for this amazing property is that <B>std::vector</B> always allocates some extra space when expanding, just in case you decide to add more to the end. And, most importantly, the amount of extra space is a multiplicative factor of the current capacity.<P>To summarize the complexity analysis of <B>std::vector::push_back</B>, by allocating extra space in multiplicative increments, "the N's cancel" and the resulting expansion complexity is independent of the size of the container. In layman's terms: as the collection grows, the extra space allocated grows too, meaning that reallocation happens less often as the collection gets bigger. It's a brilliant, mathematically sound design, the compounding interest of the collection world.<P>The raw power and flexibility of <B>std::vector</B> has made it the ordered collection of choice for many applications where a linked list might have been used in the past. As long as inserts and erases occur only at the end of the collection, <B>std::vector</B> is generally superior in speed and space to <B>std::list</B>, for most applications.<P><h3>Sorted Vectors</h3>Sorted vectors do not, in general, benefit from this efficient expansion property. The reason is that each insert or erase in a sorted vector forces a reorganization of the entire structure, copying an average of <I>N/2</I> elements per insert/erase. This is unacceptable for all but the most limited applications: where the collection size is small, or where modifications are rare.<P>The ideal solution would be to find a way to allocate extra space in a sorted vector, just like regular vectors do, but do it in such a way that does not require objects to be moved en masse for each modification. The key is to generalize the concept of extra space so that the same principle can be applied for sorted collections.<P><h3>Design</h3><h3>The "Extra Space"</h3>In <B>std::vector</B>, the extra space takes the form of uninitialized memory at the end of the buffer. During a reallocation, <B>std::vector</B> allocates space for <I>N + kN</I> elements, where <I>k</I> is the expansion factor. As the vector grows, the extra <I>kN</I> elements are filled in.<P>But, in order to satisfy the amortized constant complexity constraint, it doesn't matter where the extra elements go, or even how they're stored. The only thing that is important is that <I>kN</I> elements are efficiently stored somewhere, somehow, without incurring a reallocation (and recopying) of the vector. The other details are incidental, from a complexity standpoint.<P>It happens that the extra space for <B>std::vector</B> is located past the end of the valid elements. But <B>std::vector</B> <B>push_back</B> complexity would be no different if the extra space were a separate data structure entirely. In fact, if such an implementation could be made to look contiguous to the user, this might even be a valid design for <B>std::vector</B>.<P>This reveals an important constraint in designing the "extra space." Whatever the implementation, it must appear seamless to the user. For sorted vectors, the elements in the extra space must always appear to be in sorted order with respect to the rest of the collection. And, to be compatible with tree-based collections, inserts into the extra space must happen in <I>O(log(N))</I> time, or better.<P>The following sections describe the design of a hybrid collection, <B>CompactSet</B>, with the core elements stored in a sorted vector, and the new elements inserted into a <B>std::set</B>. This <B>set</B> serves as the extra space, storing elements efficiently, in sorted order, until enough have accumulated to rebuild the sorted vector.<P><B>CompactMap</B> is also provided in the source code (available for download at &lt;www.cuj.com/code&gt;), as a simple manipulation of <B>CompactSet</B> to allow both keys and values.<P><h3>CompactSet: A Hybrid Collection</h3><B>CompactSet</b> consists of the following members:<P><li>  <B>archiveSet</B>: a sorted vector-based collection that contains the base <I>N</I> elements of the collection.<P><li>  <B>dynamicSet</B>: a <B>std::set</B> that contains up to <I>kN</I> newly inserted elements.<P><li>  <B>compactionThreshold</B>: an integer containing the maximum size of the extra space.<P>When first constructed, <B>archiveSet</B> is empty. Elements are inserted into <B>dynamicSet</B> until its size equals <B>compactionThreshold</B>, at which point <B>dynamicSet</B> is merged into <B>archiveSet</B>. This step is called compaction. After compaction, <B>compactionThreshold</B> is set (as a multiplicative factor of <I>N</I>, where <I>N</I> has increased), and the process starts over again.  <P> <a href="cuj0307carrato_f1.htm">Figure 1</a> shows an example <B>CompactSet</B>     of integers just before compaction. The archive set contains values from the     previous compaction, and the dynamic set contains values inserted since then.  <P> Compaction merges the two collections into a new, larger <B>archiveSet</B>,     shown in <a href="cuj0307carrato_f2.htm">Figure 2</a>. <B>dynamicSet</B> is     cleared, in preparation for the next batch of inserts.  <P><h3>Compaction</h3>Compaction must occur in linear time (or better), and the rebuilt archive set must be in sorted order.<P>Fortunately, there is a standard algorithm that satisfies these constraints: <B>set_union</B>. This function takes two sorted collections as input, merging the values into a third sorted collection, in linear time.<P>By analogy to the <B>std::vector</B> expansion algorithm, <B>CompactSet</B> compaction occurs in amortized constant time, as long as <B>compactionThreshold</B> is always initialized to a multiplicative factor of the collection size.<P><h3>A United Front</h3>In order for <B>CompactSet</B> to act like a standard <B>set</B>, it must present a united front to the user at all times. The implementation must hide the complexities of the hybrid implementation, essentially merging the two internal collections dynamically for every member function. In reality, no actual merging occurs (except during compaction), but each function must act as if it is working on a merged <B>std::set</B>. And each function must run in a complexity that is no worse than the corresponding <B>std::set</B> version.<P><h3>Implementation and Complexity Analysis</h3><B>CompactSet</b> mimics the <B>std::set</B> interface, which can be broken down into four basic operations:<P><ul><li>  Find<li>  Insert<li>  Erase<li>  Iterate</ul>The following sections describe the algorithms for implementing each of these operations in <B>CompactSet</B>.<P><h3>Find</h3><B>find</b> must locate a value and return its iterator. Since a value may occur in either of the two collections (or neither, but not both), both must be checked. The algorithm for finding a value <B>val</B> is as follows:<P><pre>If(dynamicSet.contains(val))  return dynamicSet.find(val)Else if (archiveSet. contains(val))  return archiveSet.find(val)Else return end()</pre>Neglecting the iterator construction for now, this algorithm does no more than <I>2log(N)</I> comparisons. This is complexity <I>O(log(N))</I>, like <B>std::set::find</B>.<P><h3>Insert</h3>The <B>std::set</B> specification does not allow duplicates. So <B>CompactSet::insert</B> must ensure no more than one copy of a given value exists in both <B>archiveSet</B> and <B>dynamicSet</B>.<P><B>insert</B> first searches for the value in <B>dynamicSet</B>. If the value exists there, it returns immediately, since <B>std::set</B> does not reinsert existing values. Otherwise, <B>insert</B> attempts to insert the value into <B>archiveSet</B>, by calling <B>archiveSet.tryInsert</B>.<P>This may seem to be a contradiction, since <B>archiveSet</B> does not generally allow efficient inserts. However, there is one case where <B>archiveSet</B> can efficiently insert a value: when the value fits into a slot where another element was previously erased. And, of course, the value may already exist in <B>archiveSet</B>, in which case <B>tryInsert</B> succeeds without inserting the value.<P>Therefore, <B>tryInsert</B> returns one of the following three state codes:<P><ul><li>  <B>existed</B>: the value already existed and was not inserted.<li>  <B>inserted</B>: the value was inserted as a new element.<li>  <B>insertionFailed</B>: the value could not be inserted efficiently.</ul>If <B>archiveSet.tryInsert</B> returns <B>insertionFailed</B>, the value is inserted into the "extra space," <B>dynamicSet</B>. (The other return codes are necessary so that <B>CompactSet::insert</B> can construct the return value.)<P>A complexity analysis reveals that there are no worse than <I>2log(N)</I> comparisons. In addition, compaction may occur as a result of <B>insert</B>. So the total complexity for <B>insert</B> is <I>(O(log(N)) + amortized O(1))</I>. This is equivalent to <I>amortized</I> <I>O(log(N))</I>, which is, on average, the same as <B>std::set</B> <B>insert</B>.<P><h3>Erase</h3>The <B>erase</B> algorithm was not described in the design section. Most of the design was in terms of <B>insert</B>. However, <B>erase</B> is analogous to <B>insert</B> in many ways and shares many of the same design concepts.<P>Like <B>insert</B>, <B>erase</B> triggers a compaction based on the <B>compactionThreshold</B> variable and does so in such a way that the performance guarantees are preserved: <B>erase</B> runs in <I>amortized</I> <I>O(log(N))</I>.<P>However, <B>erase</B> presents an additional problem: if the value to be erased happens to be in <B>archiveSet</B>, how can it be erased without incurring a linear performance hit?<P>The solution is to hold a parallel collection of Booleans in a <B>vector&lt;bool&gt;</B> member named <B>deleted</B>. The <B>deleted</B> vector is resized to the number of elements in <B>archiveSet</B>, and each Boolean is initially false. A value of true in the <B>deleted</B> vector indicates that the corresponding value in <B>archiveSet</B> has been erased. The <B>deleted</B> vector adds only one bit per element of overhead.<P>The <B>archiveSet.erase</B> function locates the index of the value to be erased in <B>archiveSet</B> and sets the corresponding Boolean to true in the <B>deleted</B> vector. During the next compaction, the erased values are filtered out, and the <B>deleted</B> vector is reset.  <P> A side effect of this design is deferred value destruction (see <a href="cuj0307carrato_s1.htm">sidebar</a>).  <P>The basic algorithm for <B>CompactSet::erase(val)</B> is as follows:<P><pre>archiveEraseCount = archiveSet.erase(val)//might still be in the dynamicSetif(archiveEraseCount ==  0)  dynamicSet.erase(val)</pre><h3>Iterate</h3>Iterators were the most difficult piece to design and implement. The iterator must be able to navigate forward and backward through the two heterogeneous collections, merging dynamically. And it must support all iterator operations in constant time.<P><B>CompactSet</B> iterators contain the following members:<P><ul><li>  <B>archiveIter</B>: current <B>archiveSet</B> iterator.<li>  <B>dynamicIter</B>: current <B>dynamicSet</B> iterator.<li>  <B>archiveIsCurrent</B>: Boolean that indicates the current active element (archive or dynamic).<li>  <B>collectionPtr</B>: points to the owner collection.</ul>The two iterator members, <B>archiveIter</B> and <B>dynamicIter</B>, indicate the current iteration position in each of the internal sets. One points to the current value, and the other points to the upper bound of the current value in the non-current collection. In other words, the non-current iterator points to the value that would follow the current value in that collection. If the non-current collection has no value greater than the current value, the non-current iterator contains <B>end</B>.<P>The <B>archiveIsCurrent</B> Boolean member indicates which iterator is current.<P>The <B>CompactSet</B> <B>end</B> iterator is represented by <B>end</B> iterators in both <B>archiveIter</B> and <B>dynamicIter</B>.<P>The <B>collectionPtr</B> member is a pointer to the iterator's parent <B>CompactSet</B>. This is necessary so that the iterator manipulation functions can access the <B>begin</B> and <B>end</B> iterators for the internal sets, which are needed for traversal.<P>The above constraints define a valid <B>CompactSet</B> iterator. Iterator traversal functions (operators <B>++</B> and <B>--</B>) always return valid iterators. However, any insert or erase operation invalidates all iterators. This is the most significant deviation from the <B>std::set</B> specification, whose iterators remain valid for the life of the collection.  <P> <a href="cuj0307carrato_f3.htm">Figure 3</a> shoes an example <B>CompactSet</B>     iterator. This diagram shows the <B>begin</B> iterator for a sample <B>CompactSet</B>     with 14 total members (7 in each internal set). Calling <B>begin</B> should     return an iterator pointing to the value <B>1</B>, the lowest value in the     entire collection. In this case, <B>1</B> happens to be in the dynamic set.     Therefore, <B>dynamicIter</B> points to <B>1</B> and is defined to be current.     (<B>archiveIsCurrent</B> is set to <B>false</B>.)  <P>The non-current iterator, <B>archiveIter</B>, points to value <B>2</B>, which is the upper bound of the current value (<B>1</B>) in the archive set.<P><h3>Manipulating the Iterator</h3>The algorithm for incrementing the iterator is as follows:<P><pre>Increment the current iterator.Set archiveIsCurrent to (*archiveIter &lt; *dynamicIter)</pre>  <a href="cuj0307carrato_f4.htm">Figure 4</a> shows the iterator from <a href="cuj0307carrato_f3.htm">Figure   3</a>, incremented once. The current iterator (which was <B>dynamicIter</B>)   has been incremented, so that it points to value <B>3</B>. Since <B>2 &lt; 3</B>,   <B>archiveIter</B> is now current, and <B>archiveIsCurrent</B> gets the value   <B>true</B>.   <P>Decrementing is similar:<P><pre>Decrement both iterators.Set archiveIsCurrent to (*dynamicIter &lt; *archiveIter)Increment the non-current iterator.</pre>Decrementing is slightly more complicated than incrementing. This is by design: increments are generally more common in user code, and the iterators are optimized for incrementing.<P>(The boundary conditions are not included in these descriptions. In the actual code, there are checks to avoid running off the ends of the archive and dynamic sets).<P>Dereferencing is simply a matter of dereferencing the current iterator.<P>All iterator functions run in constant time.  <P> <a href="cuj0307carrato_f5.htm">Figure 5</a> compares the functionality     of the standard tree-based collections (<B>set</B>, <B>map</B>) with <B>Loki::AssocVector</B>     (a pure associative vector implementation, designed primarily for small, static     collections [2]) and <B>CompactSet</B>/<B>Map</B>.  <P><h3>Making It Configurable with Policies</h3>In <I>Modern C++ Design</I> [2], Andrei Alexandrescu introduces the concept of policies, which are used to customize the behavior of a class. The policy class is passed as a template argument in the class declaration.<P>The <B>MaximizeSpeed</B> policy uses <B>std::vector</B> as the base collection for <B>archiveSet</B>. During compaction, a new <B>std::vector</B> is created, and the elements are merged into that new <B>std::vector</B>. Memory usage effectively doubles during this process. At the end of compaction, the original <B>std::vector</B> is removed, and memory usage drops back down. So, even though the steady-state memory usage is low, the transient memory usage is not.<P>The <B>MinimizeSpace</B> policy uses <B>std::deque</B> for the <B>archiveSet</B> collection. Compaction for the <B>MinimizeSpace</B> policy destroys the original sets as it builds the new one, resulting in much lower transient space usage during compaction. (This feature relies on deallocating <B>erase</B> in <B>std::deque</B>, which is not the case for some versions of the standard library.) The cost of this space efficiency is performance: <B>MinimizeSpace</B> is significantly slower than <B>MaximizeSpeed</B>. But the <B>MinimizeSpace</B> version allows for efficient storage and manipulation of <B>CompactSet</B>s even in environments with extremely limited memory.<P><h3>Source Code and Further Documentation</h3>Full source code and documentation for <B>CompactSet</B> and <B>CompactMap</B> can be downloaded at &lt;www.cuj.com/code&gt;. See the documentation for more details on the implementation. The code has been tested with GCC 3.1, GCC 2.95.2, Borland CC 5.5, and Microsoft Visual Studio 6.0. Due to compiler limitations, policies are not available in the GCC 2.95.2 and Microsoft Visual Studio 6.0 versions.<P><h3>Notes</h3>[1]  Bjarne Stroustrup. <I>The C++ Programming Language</I> (Addison-Wesley, 2000).<P>[2]  Andrei Alexandrescu. <I>Modern C++ Design</I> (Addison-Wesley, 2001).<P><h3>About the Author</h3>Michael Carrato received his MS degree in computer engineering from the State University of New York at Buffalo. He has nine years of professional experience in design and development in C/C++, Java, and Smalltalk. He currently works as a software engineer at Cymfony, Inc., in Williamsville, NY, and can be reached at <B>mcarrato@hotmail.com</B>.<p></BODY></HTML>