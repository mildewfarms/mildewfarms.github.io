<HTML><HEAD><TITLE>Deferred Value Destruction for erase</TITLE></HEAD><body bgcolor="#FFFFFF" text="#000000"><h3>Deferred Value Destruction for erase</h3>All of the standard collection <B>erase</B> functions actually perform two functions:<P>1.  Remove the element from the collection.<P>2.  Destroy the value contained by that element.<P>In all cases, the destroy is immediate: when <B>erase</B> returns, the value's destructor has been called. However, the design of <B>CompactSet</B> deviates from this convention: the value destruction may be deferred until some point after <B>erase</B> has returned. In fact, if the erased value is part of <B>archiveSet</B>, it must not be destroyed until a compaction occurs.<P>The reason for this is that the erased value must hold its position in the sorted vector so that future binary searches on the vector are valid. If the value were destroyed prematurely, the binary search might access the destroyed element while searching for another value. The value must remain valid until its destructor is called (some time later, during compaction).<P>This condition is satisfied for all pure value types (including all primitive types, <B>std::string</B>s, and the standard collections, provided the value type of the collection is a pure value). Any class that destroys all of its state in its destructor will work with deferred destruction.<P>Classes that do not manage their own resources may not be compatible with <B>CompactSet</B>. In particular, any design that destroys or alters the contents of the value immediately after it has been erased will not work with <B>CompactSet</B>.</BODY></HTML>