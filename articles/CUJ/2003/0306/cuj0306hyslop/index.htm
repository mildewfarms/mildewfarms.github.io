<HTML><HEAD><TITLE>Conversations: Imagine</TITLE></HEAD><body bgcolor="#FFFFFF" text="#000000"><H2>Conversations: Imagine</h2><H3>Jim Hyslop and Herb Sutter</H3><P> <i>Portability without #idefs? It's (sort of) easy if you really try.</i> <p> <I>Copyright 2003, Jim Hyslop and Herb Sutter</I> <UL>  Imagine there's no <B>ifdef</B>s<br>  It's easy if you try<br>  No badly ported source<br>  Making programmers cry<br>  Imagine you are eas'ly<br>  Reading all the code...[1]</ul><P> "Well, that was easier than I thought," I sighed to myself as I stretched   out the kinks in my neck. I had just finished porting some of our application's   code to a different platform and was giving it one last once-over before checking   it in. <P> <pre>#ifdef _WIN32#include &lt;windows.h&gt;#else#include &lt;sys/select.h&gt;#endif#ifndef _WIN32int mystrncmp( const char * string1,    const char * string2,    size_t max ){  ... custom implementation of  ... case-insensitive strncmp}#endifint someClass::f(#ifdef _WIN32  HANDLE waitHandle,#else  int    waitDescriptor,#endif  const char * name ){#ifdef _WIN32  bool match = _strnicmp( name,        knownValue_, max_ ) == 0;#else  bool match = mystrncmp( name,        knownValue_, max_ ) == 0;#endif  if ( match )  {    int waitResult;#ifdef _WIN32    waitResult = WaitForSingleObject(        waitHandle,        timeout_ );    if ( waitResult == WAIT_OBJECT_0 )    {      waitResult -= WAIT_OBJECT_0;    }#else    struct timeval timeout;    fd_set fds;    FD_SET( 0, &amp;fds );    timeout.tv_sec = timeout_ / 1000;    timeout.tv_usec = (timeout_ % 1000)      * 1000;    waitResult = select( 1, &amp;fds,                NULL, NULL,                &amp;timeout );#endif    if ( waitResult != 0 )    {      ... error handling and      ... exit function    }    ... whatever  }}</pre>I reached for the keyboard to check the code in. Snap! I jumped as the Guru announced her presence in her customary way: snapping closed a large book inches away from my ear. (At least, that's what it felt like -- Wendy always insisted the Guru was always several feet away from me.) <P> "Call you that portable code, do you my apprentice?" the Guru asked in a firm   voice. "Unreadable, it is, and brittle." <P> "Well, I agree it's not the prettiest code, but I don't think it's that unreadable,"   I argued. <P> "Not yet," the Guru replied, "but it is only a matter of time. My child, remember   that we write software that runs on several different platforms. When the code   is ported to a third platform, you will need another layer of conditional code.   The code will quickly degrade into an unreadable morass of conditional statements,   until it resembles the worst open-source project." She shuddered melodramatically   [2]. "Conditionally compiled code, especially in the name of portability, is   almost always a mistake. Indeed, many pious scribes are able to write portable   code without resorting to this hideousness -- although these same scribes are   quick to point out that their own experience does not always cover all possible   situations [3]." <P> "But it's supposed to be portable code," I protested. "How am I supposed to   write it portably if I can't use any conditional compilation?" <P> "My apprentice, have you forgotten that you have more tools than conditional   compilation at your disposal? First let us remove the conditional directives   surrounding <B>#include</B> directives." The Guru pointed at the top of my code: <P> <pre>#ifdef _WIN32#include &lt;windows.h&gt;#else#include &lt;sys/select.h&gt;#endif</pre>"These directives can be replaced by a single <B>#include</B> statement. In this case, the include statements are there to pick up declarations required for waiting," she picked up a whiteboard marker and began writing in her fine script: <P> <pre>#include "platform_wait.h"</pre>"The exact contents of that file will be platform-specific. For example, the first file will contain:" <P> <pre>// file: windows/platform_wait.h#include &lt;windows.h&gt;</pre>"and the second file," she continued, "will contain:" <P> <pre>// file: others/platform_wait.h#include &lt;sys/select.h&gt;</pre>"Most, if not all, compilers allow you control over which directories to search for included files. Each platform's make file will take advantage of this option, to specify exactly which file gets included by the directive. The make file for platform A will include the command-line option <B>'c:\www.cuj.com/I include/windows'</B>, and the make file for platform B will include the option <B>'c:\www.cuj.com/I include/others'</B>." <P> "Now, my child, let us examine another part of the code," the Guru highlighted   certain sections of my code: <P> <pre>#ifndef _WIN32int mystrncmp( const char * string1,    const char * string2,    size_t max ){  ... custom implementation of  ... case-insensitive strncmp}#endif{#ifdef _WIN32  bool match = _strnicmp( name,        knownValue_, max_ ) == 0;#else  bool match = mystrncmp( name,        knownValue_, max_ ) == 0;#endif</pre>"This code demonstrates one of the two classic cases where conditional compilation is simply tossed in. You have one platform that provides a case-insensitive <B>strncmp</B> function, and another that does not. Thus, on some platforms you must emulate the behavior provided by other platforms. <P> "Rather than use two different code paths, prefer to use a single code path.   In this situation, always use the emulation. The resulting code is much simpler,   and easier to read and follow. The prophets Spencer and Collyer point out that   five levels of conditional compilation -- a depth not too unlikely in a widely-ported   application -- results in 32 potential code paths, each of which must be tested   [4]. In any case, you must provide the custom function, so there is no benefit   to sometimes using the built-in functionality, and sometimes using the custom   functionality. <P> "And finally, here," she indicated the remaining code: <P> <pre>int someClass::f(#ifdef _WIN32  HANDLE waitHandle,#else  int    waitDescriptor,#endif  const char * name ){  if ( match )  {    int waitResult;#ifdef _WIN32    waitResult = WaitForSingleObject(        waitHandle,        timeout_ );    if ( waitResult == WAIT_OBJECT_0 )    {      waitResult = 0;    }#else    struct timeval timeout;    fd_set fds;    FD_SET( 0, &amp;fds );    timeout.tv_sec = timeout_ / 1000;    timeout.tv_usec = (timeout_ % 1000) * 1000;    waitResult = select( 1, &amp;fds,                NULL, NULL,                &amp;timeout );#endif    if ( waitResult != 0 )    {      ... error handling and      ... exit function    }</pre>"your platforms provide substantially the same functionality, but with different implementations. Here, you can provide an abstraction of the functionality and extract the platform-specific code to individual source files, in a manner similar to the header files above. Spencer and Collyer refer to this as providing an interface. First, provide the interface:" <P> <pre>// file: common_wait.h#include "platform_wait.h"int wait( WaitObject, int timeout );// file: windows/platform_wait.h#include &lt;windows.h&gt;typedef HANDLE WaitObject;// file: others/platform_wait.h#include &lt;sys/select.h&gt;typedef int WaitObject;</pre>"Now, we create small source files to implement the waiting:" <P> <pre>// file: windows/platform_wait.cppint wait( WaitObject wo, timeout to ){  ... Windows implementation goes here}// file: others/platform_wait.cppint wait( WaitObject wo, timeout to ){  ... other implementations go here}</pre>"Now, finally, your main line code is clean and simple:" <P> <pre>#include "common_wait.h"int mystrncmp( const char * string1,    const char * string2,    size_t max ){  ... custom implementation of  ... case-insensitive strncmp}int someClass::f(  WaitObject waitHandle,  const char * name ){  if (mystrncmp( name,        knownValue_, max_ ) == 0 )  {    int waitResult =      wait( waitHandle, timeout_ );    if ( waitResult != 0 )    {      ... error handling and      ... exit function    }    ... whatever  }}</pre>"That's a lot of work, and a lot of files," I sighed. <P> "Portability is work, my child. Spencer and Collyer preach that writing readable,   maintainable portable code is a fundamental design issue. Therefore great care   and thought should go into writing portable code." <P> "Wait a second," I interjected. "What if you have to do some processing on   one platform, but not on another? For example, I was looking at the source code   for an open-source project, and on some platforms the program tries to lock   the process into physical memory, because the application is time-sensitive.   Not all platforms have that capability, though, so the code is surrounded by   an <B>#ifdef</B> block." <P> "Ah, my child," the Guru said, "that is but a variation on a theme. Or, more   precisely, it is a combination of the two situations. The first step is to create   an interface:" <P> <pre>// file: process_lock.hint lock_process();// file: main application file#include "process_lock.h"void initialize(){  if ( lock_process() &lt; 0 )    ... error handling  ... other init}</pre>"Now, we implement this function in platform-specific files:" <P> <pre>// file: platform_a/lock.cppint lock_process(){  ... perform steps specific  ... to platform A}// file: platform_b/lock.cppint lock_process(){  ... perform steps specific  ... to platform B}// file: platform_c/lock.cppint lock_process(){  // this platform doesn't  // support locking  return 0;}</pre>I sat silent for a moment, letting all this percolate through my brain. "So, are you really saying that you never need conditional compilation?" <P> "Indeed no, my child," the Guru smiled. "Conditional compilation will always   be with us, even leaving aside the blessed 'include guard' idiom. There may   well be times when an occasional <B>#ifdef</B> is required. In those rare situations,   prefer to keep the conditional code in the header files and out of the main   logic. And always test for features, never for platforms, for it is the truth   that variations among compilers are rarely confined to a single platform." <P> "Features?" I quizzed. The Guru picked up the whiteboard marker once more: <P> <pre>// Not a good way:#ifdef _WIN32// much better way:#ifndef HAVE_MEMBER_FN_TEMPLATES</pre>"Now, my child," the Guru said softly as she glided away, "make the changes I have suggested, and then you will be ready to check in the files." <P> <h3>Notes</h3><p> [1] With apologies to John Lennon. <P> [2] For any readers who might consider this a gratuitous slam against the   open source movement, please note the slam against non-standards-conforming   compilers at the end of the article. <P> [3] One notable example is C++ expert James Kanze, a moderator for the USENET   group comp.lang.c++.moderated and a member of the ISO C++ Standards Committee,   whose recent comments in comp.lang.c++.moderated inspired this article. <P> [4] Henry Spencer and Geoff Collyer. "<B>#ifdef</B> Considered Harmful, or   Portability Experience with C News", Summer 1992 USENIX. Available online at   &lt;www.chris-lott.org/ resources/cstyle/ifdefs.pdf&gt;. <p> <h3>About the Authors</h3><p> Herb Sutter (<b>www.gotw.ca</b>) is convener of the ISO C++ standards committee,   author of the acclaimed books Exceptional C++ and More Exceptional C++, and   one of the instructors of The C++ Seminar (<b>www.gotw.ca/cpp_seminar</b>). In addition   to his independent writing and consulting, he is also C++ community liaison   for Microsoft.  <p>Jim Hyslop is a senior software designer with over 10 years programming   experience in C and C++. Jim works at Leitch Technology International Inc.,   where he deals with a variety of applications, ranging from embedded applications   to Windows programs. He can be reached at <b>jhyslop@ieee.org</b>.<p></BODY></HTML>