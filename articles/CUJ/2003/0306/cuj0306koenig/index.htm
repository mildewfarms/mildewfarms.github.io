<HTML><HEAD><TITLE>C++ Made Easier: Simple Loops, Generalized</TITLE></HEAD><body bgcolor="#FFFFFF" text="#000000"><h2>C++ Made Easier: Simple Loops, Generalized</h2><p> <H3>Andrew Koenig and Barbara E. Moo</h3><P> <i>Compelling motivation for a universal loop-coding style.</i> <P> <h3>Introduction</h3><p> If you ask most programmers to write a loop that writes the values <B>0</B>,   <B>1</B>, <B>2</B>, and so on through <B>n-1</B>, on the standard output, you   will probably see something like this: <P> <pre>// Example 1for (int i = 0; i &lt; n; ++i)     std::cout &lt;&lt; i &lt;&lt; std::endl;</pre>where <B>++i</B> might appear, equivalently, as <B>i++</B>. If you ask for a loop that writes the same values in the opposite sequence, you will probably see something like this: <P> <pre>// Example 2for (int i = n-1; i &gt;= 0; --i)     std::cout &lt;&lt; i &lt;&lt; std::endl;</pre>These loops are nicely related and solve their respective problems in obvious, straightforward ways. <P> Nevertheless, in recent years, we have been changing our style so that we   can write loops in a form that works not only for integers such as <B>i</B>   and <B>n</B> in these two examples, but also for unsigned integers and iterators.   As one example of this stylistic change, in <I>Accelerated C++</I>, we made   a point of using <B>!=</B> instead of <B>&lt;</B> to terminate loops, which   means that we would solve our first problem this way: <P> <pre>// Example 3for (int i = 0; i != n; ++i)     std::cout &lt;&lt; i &lt;&lt; std::endl;</pre>even though we expect many readers to find that usage unfamiliar. <P> We use this style even though it courts disaster if we try to count downward: <P> <pre>// Can you find the error before you// read on?for (int i = n-1; i != 0; --i)     std::cout &lt;&lt; i &lt;&lt; std::endl;</pre>The problem here, of course, is that if <B>n</B> is zero before the loop starts, the first value of <B>i</B> will be <B>-1</B>, so the program will never terminate. <P> We avoid such disasters by counting downward in a completely different style: <P> <pre>// Example 4aint i = n;while (i != 0) {     --i;     std::cout &lt;&lt; i &lt;&lt; std::endl;}</pre>or, alternatively: <P> <pre>// Example 4bfor (int i = n; i != 0; ) {     --i;     std::cout &lt;&lt; i &lt;&lt; std::endl;}</pre>One reason to use the same form of loop for different types is to avoid having to remember which kind of loop to use for which type. Unsigned integers, of course, are never negative, which means that we must be especially careful when we use them in loops that count down to zero. Iterators always support <B>==</B> and <B>!=</B> comparisons, but they do not always support <B>&lt;</B>, <B>&gt;</B>, <B>&lt;=</B>, or <B>&gt;=</B>, which means that if we wish to cater to iterators, we must restrict ourselves to equality and inequality comparisons. <P> The rest of this article will explain in greater detail the consequences of   our desire for generality, by examining various ways of writing values on the   standard output stream. We will leave it to our readers to generalize the bodies   of our loops to encompass other computations. <P> <h3>Unsigned Values</h3><p> It is easy to forget that C++ has both signed and unsigned integers, because   many programs do not use unsigned integers explicitly. Nevertheless, unsigned   integers are important for expressing sizes. One reason is that by foregoing   the possibility of negative values, unsigned integers can express a larger range   of positive values than can plain integers. Accordingly, on some C++ implementations,   it is possible to create an object that is so large that its size will not fit   in a plain integer, but will nevertheless fit in an unsigned integer. For this   reason, both the C and C++ standards say that the <B>sizeof</B> operator returns   an unsigned type, and C++ programs often use unsigned quantities to express   sizes. <P> Our first generalization, then, will be to allow for the possibility that   <B>i</B> and <B>n</B> might be unsigned. In that case, we can see that Example   2 stops working: <P> <pre>// Example 2 with unsigned values// This code no longer worksfor (unsigned i = n-1; i &gt;= 0; --i)     std::cout &lt;&lt; i &lt;&lt; std::endl;</pre>The problem, of course, is that <B>i &gt;= 0</B> is always true if <B>i</B> is unsigned, so the loop will never terminate. Moreover, if <B>n</B> is zero, the value of <B>n - 1</B> will underflow, which again is hardly what we want. <P> Of course, it is obvious in this example that <B>i</B> is unsigned, so it   is almost as obvious that the comparison <B>i &gt;= 0</B> is a mistake. In practice,   unsigned values sometimes appear in subtler contexts. For example, suppose that   <B>v</B> has type <B>std::vector&lt;int&gt;</B>, and we want to write the elements   of <B>v</B> on the standard output stream in reverse order. We might be tempted   to do so this way: <P> <pre>// This code doesn't work either.  // Do you see why?for (std::vector&lt;int&gt;::size_type i =      v.size()-1; i &gt;= 0; --v)     std::cout &lt;&lt; v[i] &lt;&lt; std::endl;</pre>Like the previous example, this loop will fail because <B>i</B> is unsigned. This time, however, the fact that <B>i</B> is unsigned is not evident from the code -- in order to see the problem, you have to know that the standard containers' <B>size_type</B> members represent unsigned types. <P> The lesson here is that if we might be using unsigned integers, we must avoid   any computation that might create or require a negative value. Therefore, we   must always verify that <I>i</I> is strictly positive before we decrement it,   and we must not compute <B>n - 1</B> unless we know that <B>n</B> is not zero. <P> How can we rewrite our loop under these constraints? We know that the loop   must do three things: <P> <li> Initialize <B>i</B> to a value computed from <B>n</B>.   <P> <li> Compare <B>i</B> to <B>0</B>.   <P> <li> Decrement <B>i</B>.   <P> We must begin by initializing <B>i</B>, because otherwise <B>i</B> doesn't     have a meaningful value. Moreover, because <B>n</B> might be zero, we cannot     yet compute <B>n - 1</B>, so we have little choice but to have verified that     <B>i</B> is not zero.   <P> The resulting loop looks like our Example 4, except that <B>i</B> is unsigned:   <P>   <pre>// This version worksunsigned i = n;while (i != 0) {     --i;     std::cout &lt;&lt; i &lt;&lt; std::endl;}</pre>  In other words, if we wish to write a loop that counts downward, and we want   it to work with unsigned values, we should write a loop that looks like Example   4a or the equivalent 4b, rather than one like Example 2.   <P> Of course, most loops count upward, not downward, and for such loops, even     with unsigned integers, we don't have a reason yet to prefer <B>!=</B> to     <B>&lt;</B>. In particular, Example 1 works just fine with unsigned values     even though it uses <B>&lt;</B> instead of <B>!=</B>. To see why we prefer     Example 3 to Example 1, we have to generalize our loop to deal with iterators     rather than with integers.   <P>   <h3>Iterators</h3>  <p> Let's change our original problem: instead of writing a sequence of consecutive     integers on the standard output stream, we wish to write each element of an     object named <B>x</B>, which has type <B>std::list&lt;int&gt;</B>. If we try     to adapt our Example 1 to solve this problem, we run into trouble:   <P>   <pre>// This code doesn't workfor (std::list&lt;int&gt;::iterator i =     x.begin(); i &lt; x.end(); ++i)     std::cout &lt;&lt; *i &lt;&lt; std::endl;</pre>  The difficulty is that the <B>std::list</B> class does not offer random-access   iterators. Rather, it offers only bidirectional iterators, which support <B>==</B>   and <B>!=</B> but not <B>&lt;</B>, <B>&gt;</B>, <B>&lt;=</B>, or <B>&gt;=</B>.   Accordingly, we must write <B>i != x.end()</B> rather than <B>i &lt; x.end()</B>,   giving us a loop that looks like this:   <P>   <pre>// This version worksfor (std::list&lt;int&gt;::iterator i =      x.begin(); i != x.end(); ++i)     std::cout &lt;&lt; *i &lt;&lt; std::endl;</pre>  Note that this loop has the same form as our original Example 3:   <P>   <pre>// Example 3, repeated for conveniencefor (int i = 0; i != n; ++i)     std::cout &lt;&lt; i &lt;&lt; std::endl;</pre>  We can see the resemblance by changing <B>i</B>'s type from <B>int</B> to <B>std::list&lt;int&gt;::iterator</B>,   the initial value <B>0</B> to <B>x.begin()</B>, the upper bound <B>n</B> to   <B>x.end()</B>, and by writing <B>*i</B> instead of <B>i</B>. These substitutions   change only types and values; they do not change the overall form of the loop.   <P> Let us now turn our attention to counting backward. If we wish to generalize     backward-counting loops to encompass iterators, not only must we avoid order     comparisons such as <B>&lt;</B>, but we must also not try to compute iterator     values that refer to a point before the beginning of a container.   <P> For any standard-library container, it is possible to form an iterator that     refers to any element of the container. It is also possible to form an iterator     that refers to a position immediately after the last element of the container     -- in fact, the <B>end</B> member yields just such an iterator. However, there     is no guarantee of being able to form an iterator that refers to a position     immediately before the first element. For example:   <P>   <pre>// Create an object of type std::list with one element// x starts out emptystd::list&lt;int&gt; x;x.push_back(42); // x now has one element// Create two iterators that refer to// that element// p refers to x's elementstd::list&lt;int&gt;::iterator p = x.begin();// So does qstd::list&lt;int&gt;::iterator q = p;// Increment one iterator; decrement the other// p now refers to a position just past// the end of x++p;// This assertion will succeed.assert(p == x.end());--q; // Undefined behavior!</pre>  We made both iterators, <B>p</B> and <B>q</B>, refer to the only element of   <B>x</B>. If we now increment <B>p</B>, it refers to a position just past the   end of <B>x</B>. If we decrement <B>q</B>, the resulting behavior is undefined,   because the C++ library defines only an off-the-end iterator, not an off-the-beginning   iterator.   <P> This situation is similar to what saw with unsigned integers: if we want     to deal with the range from <B>0</B> up to and not including <B>n</B>, we     can compute the value that is just after the end of the range (namely <B>n</B>),     but we cannot compute the value that is just before the beginning of the range     (namely <B>-1</B>).   <P> We infer that to write a loop that uses iterators to count backward, we     should use the same technique that we used for unsigned integers, namely Examples     4a and 4b:   <P>   <pre>// Example 4a with iterator valuesstd::list&lt;int&gt;::iterator i = x.end();while (i != x.begin()) {     --i;     std::cout &lt;&lt; *i &lt;&lt; std::endl;}// Example 4b with iterator valuesfor (std::list&lt;int&gt;::iterator i = x.end();   i != x.begin(); ) {     --i;     std::cout &lt;&lt; *i &lt;&lt; std::endl;}</pre>  We can use either of these forms to count backward through signed or unsigned   integers and also through random-access or bidirectional iterators.   <P>   <h3>Conclusion</h3>  <p> One of the most common everyday programming tasks is doing something to     every element in a range, typically a range of integers or container elements.     The most common way of iterating through a range of integers:   <P>   <pre>for (int i = 0; i &lt; n; ++i)     std::cout &lt;&lt; i &lt;&lt; std::endl;</pre>  does not generalize to elements of containers that support only forward or bidirectional   iterators. However, by changing <B>&lt;</B> to <B>!=</B>, we obtain a single   form that supports both integers and iterators.   <P> The situation is more problematic for backward iteration. Here, the common     form:   <P>   <pre>for (int i = n-1; i &gt;= 0; --i)     std::cout &lt;&lt; i &lt;&lt; std::endl;</pre>  does not even support unsigned integers, let alone iterators. However, by writing   this loop as:   <P>   <pre>int i = n;while (i != 0) {     --i;     std::cout &lt;&lt; i &lt;&lt; std::endl;}</pre>  or, alternatively:   <p>   <pre>for (int i = n; i != 0; ) {     --i;     std::cout &lt;&lt; i &lt;&lt; std::endl;}</pre>  we obtain a form that works not only for signed and unsigned integers, but also   for bidirectional or random-access iterators [1].   <P> When there are several ways of writing a particular computation, we believe     it is useful to keep an eye out for forms that work with multiple types and     to get into the habit of using them instead of forms that work only with specific     types.   <P>   <h3>Note</h3>  <p> [1] Note that we said bidirectional iterators, not forward iterators. We     can't use forward iterators to iterate backward, so we won't try.   <p>   <h3>About the Authors</h3>  <p> Andrew Koenig is a member of the Communication Software Research Department     at AT&amp;T's Shannon Laboratory, and the Project Editor of the C++ standards     committee. A programmer for more than 30 years, 15 of them in C++, he has     published more than 150 articles about C++ and speaks on the topic worldwide.     He is the author of <I>C Traps and Pitfalls</I> and co-author of <I>Ruminations     on C++</I> and <I>Accelerated C++.</I>  <p>   <P> Barbara E. Moo is an independent consultant with 20 years' experience in     the software field. During her nearly 15 years at AT&amp;T, she worked on     one of the first commercial projects ever written in C++, managed the company's     first C++ compiler project, and directed the development of AT&amp;T's award-winning     WorldNet Internet service business. She is co-author of <I>Ruminations on     C++</I> and <I>Accelerated C++ </I>and lectures worldwide.  <p> </BODY></HTML>