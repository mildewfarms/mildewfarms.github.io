<HTML><HEAD><TITLE>Expression Templates</TITLE></HEAD><body bgcolor="#FFFFFF" text="#000000"><B>STL &amp; Generic Programming</B><P> <H2>Expression Templates</H2><H3> Thomas Becker</H3><i>How to optimize computationally-intensive operations with templates.</i><P> <h3>Introduction</h3>This is the second in a short series of articles on the subject of using C++ template and template metaprogramming techniques to create highly efficient code that makes C++ acceptable for scientific and numerical programming. In my last column, I talked about loop unrolling via inline function templates. I also mentioned a much more difficult problem, namely, the elimination of gratuitous temporary objects and gratuitous loop iterations when overloading operators such as <B>operator+</B> for algebraic objects such as matrices. Expression templates solve that problem. Todd Veldhuizen and David Vandevoorde independently invented expression templates. Todd Veldhuizen's original article from the now defunct <I>C++ Report</I> is reprinted in <I>C++ Gems</I> [1]. David Vandevoorde's take on expression templates can be found in the book on C++ templates he wrote with Nicolai Josuttis [2]. This book is highly recommended reading even if you're not all that interested in advanced topics such as expression templates. It is clearly the definitive source and reference for all your template-related questions.<P> <h3>Gratuitous Temporaries and Loops</h3><p> Suppose that we are working on a piece of software, perhaps a library for   scientific programming, that supports matrices and algebraic matrix operations   such as addition and multiplication. If we did this in C++, we would, of course,   have a class template <B>Matrix</B>. <a href="cuj0306becker_l1.htm">Listing   1</a> shows what is probably the simplest possible implementation of such a   class template. A real-life matrix class would not look quite like this, but   the details of the design and implementation are irrelevant for the discussion   at hand. Our matrix class would of course be incomplete without overloaded operators   for the algebraic operations. <a href="cuj0306becker_l1.htm">Listing 1</a> has   a naive version of <B>operator+</B> for matrices. Suppose now that we have two   matrices of <B>double</B>s <B>A</B> and <B>B</B> of equal size <I>n x m</I>,   and we write: <P> <pre>Matrix&lt;double, n, m&gt; S = A + B;</pre>Without any optimization occurring, executing the overloaded <B>operator+</B> will construct a temporary matrix object from which the matrix <B>S</B> is then copy-constructed. In this case, it is quite likely that your compiler will optimize away the temporary by applying what is known as RVO (return value optimization): Instead of creating a temporary and copying it, the sums of the elements of <B>A</B> and <B>B</B> will be placed directly into the matrix <B>S</B>. However, RVO is an elusive beast (for example, see [3]). All we must do is to consider a situation where the matrix <B>S</B> has been constructed and used before:<P> <pre>Matrix&lt;double, n, m&gt; S;// work with SS = A + B;</pre>This is certainly a plausible scenario. In this case, RVO is not going to happen: the assignment operator takes a <B>const</B> reference to a matrix as its argument. That reference needs to be bound to something, and that something can only be a temporary object created by <B>operator+</B>. In the world of serious scientific programming and number crunching, the machine code that is thus generated from the assignment <B>S = A + B</B> is simply laughable. These people want to see one iteration over the <I>n x m</I> matrix positions, during which the elements of <B>A</B> and <B>B</B> are added and the sums are placed in the respective positions of <B>S</B>. Instead, we make one iteration to add the elements of <B>A</B> and <B>B</B> and park them all in a temporary memory area. Then we make a second iteration to move the sums from the temporary location to the target matrix <B>S</B>, which is clearly a colossally dumb thing to do in a context where time and space efficiency are an overriding concern. Therefore, if we want to save scientific and numerical software engineers from eternal damnation in the dank and musty world of Fortran, we have to do something about this. As a matter of fact, avoiding the creation and/or copying of gratuitous temporaries has been a hot topic in the C++ community for quite some time. Andrei Alexandrescu's article [3] shows the current state of the art in this area. However, amazing and important as his techniques are, they do not completely solve the problems we're having here with matrix addition. Suppose we have three matrices <B>A</B>, <B>B</B>, and <B>C</B>, and we write:<P> <pre>Matrix&lt;double, n, m&gt; S;// work with SS = A + B + C;</pre>Under <a href="cuj0306becker_l1.htm">Listing 1</a>'s naive implementation, this will place the sums of <B>A</B> and <B>B</B> into a temporary matrix (one iteration over <I>n x m</I> positions). It will then place the sum of that temporary matrix and <B>C</B> into a second temporary matrix (a second iteration over <I>n x m</I> elements). Finally it will copy the elements of the second temporary to <B>S</B> (a third iteration over <I>n x m</I> elements). We could now embark on a long discussion of all the different ways to get rid of the creation and/or copying of the temporaries. However, none of this would satisfy the serious scientific software engineer. The only way to placate her is to not only get rid of all the temporary objects, but also to ensure that only one iteration over the <I>n x m</I> matrix positions takes place. That is what expression templates do. I'll show you what they are and what they do first, and then I'll explain why they're called "expression templates." <P> <h3>Expression Templates</h3><p> The conventional overloaded <B>operator+</B> as shown at the end of <a href="cuj0306becker_l1.htm">Listing   1</a> places the sum of its operands into a matrix object and returns that object.   The only way to stomp out gratuitous temporary objects and gratuitous iterations   arising from this operator once and for all is to change <B>operator+</B> radically   so that it never even performs the summation. Instead, <B>operator+</B> will   create and return an object of a completely different kind. It is a lightweight   object that holds nothing but references to the two operands of the summation.   This object passes itself off as the actual sum of the two operands by implementing   the method <B>ElementAt</B>, which returns the sum of the elements at position   <B>(i,j)</B> of the two operands. The method computes that sum on the fly from   the references to the two operands that the object holds. <P> <a href="cuj0306becker_l2.htm">Listing 2</a> shows a first (but ultimately   useless) attempt at an implementation. Class <B>EtMatrixAdd</B> provides the   lightweight objects as described earlier. A new <B>operator+</B> simply constructs   an <B>EtMatrixAdd</B> object from its operands and returns it. Finally, a new   assignment operator takes an <B>EtMatrixAdd</B> object as its right-hand side.   The implementation of that new assignment operator is simple, because, as I   said before, the <B>EtMatrixAdd</B> object passes itself off as a matrix containing   the sum of the two operands by implementing <B>ElementAt</B>. <a href="cuj0306becker_l2.htm">Listing   2</a> does not show a matrix copy constructor that works with the new <B>EtMatrixAdd</B>   class, but it would not be difficult to make that work as well. Now if we have   three matrices <B>S</B>, <B>A</B>, and <B>B</B>, all of equal size, and we write: <P> <pre>S = A + B;</pre>then there will be no temporary matrix objects. <B>operator+</B> returns a temporary lightweight object of type <B>EtMatrixAdd</B>, which holds references to the matrices <B>A</B> and <B>B</B>. The loop inside the assignment operator calculates the desired sum at each position by calling the lightweight object's method <B>ElementAt</B>, which simply fetches and adds the respective elements of the operands <B>A</B> and <B>B</B>. We have thus pretty much achieved the performance of a handwritten loop.<P> The code in <a href="cuj0306becker_l2.htm">Listing 2</a> is far from providing   a general solution to our problems. To see why, let us look at the sum of three   matrices again: <P> <pre>S = A + B + C;</pre>Here, the compiler would first apply our new <B>operator+</B> to the two matrices <B>A</B> and <B>B</B>. The result is a temporary, lightweight object of type <B>EtMatrixAdd</B> that holds references to the matrices <B>A</B> and <B>B</B>. In other words, the compiler acts as if we had written:<P> <pre>EtMatrixAdd&lt;double, n, m&gt; Temp1 = A + B;</pre>Next, the compiler must generate code for the addition <B>Temp1 + C</B>, and the result of that addition should be a second temporary lightweight object <B>Temp2</B> that holds references to the two operands <B>Temp1</B> and <B>C</B>. However, that's not possible with what we have so far. Our <B>operator+</B> can only add two matrices, but not an <B>EtMatrixAdd</B> object and a matrix. Furthermore, our lightweight <B>EtMatrixAdd</B> objects can only hold references to matrices, but not to other <B>EtMatrixAdd</B> objects. <a href="cuj0306becker_l3.htm">Listing 3</a> fixes these two shortcomings. <a href="cuj0306becker_l3.htm">Listing 3</a> looks fairly complicated, but if you understand the code in <a href="cuj0306becker_l2.htm">Listing 2</a>, you really don't have to look at <a href="cuj0306becker_l3.htm">Listing 3</a> in much detail. Here's the gist of the changes: First, <B>EtMatrixAdd</B> has been modified to take two additional template parameters, <B>LeftOp</B> and <B>RightOp</B>. Instead of holding references to two matrices, the new <B>EtMatrixAdd</B> holds references to <B>LeftOp</B> and <B>RightOp</B>. In <a href="cuj0306becker_l2.htm">Listing 2</a>'s assignment operator, which allows us to assign from an <B>EtMatrixAdd</B> object to a matrix, the old <B>EtMatrixAdd</B> type has been replaced with the new one. Otherwise, the assignment operator has remained the same. Similarly, <B>operator+</B> for the addition of two matrices remains essentially the same, except for the two new template arguments to the <B>EtMatrixAdd</B> object that it returns. Finally, there is now a second <B>operator+</B> for adding an <B>EtMatrixAdd</B> object to a matrix object. The result is, of course, simply an <B>EtMatrixAdd</B> object that holds references to the two operands. <P> We have thus made it possible for the compiler to handle the line:<P> <pre>S = A + B + C;</pre>The code that gets generated is the same code that would be generated from these lines:<P> <pre>typedef Matrix&lt;double, n, m&gt; Mat;EtMatrixAdd&lt;double, n, m, Mat, Mat&gt;Temp1 = A + B;EtMatrixAdd&lt;  double, n, m,  EtMatrixAdd&lt;double, n, m, Mat, Mat&gt;,  Mat&gt;Temp2 = Temp1 + C;S = Temp2;</pre>The addition <B>A + B</B> is performed using the first <B>operator+</B> in <a href="cuj0306becker_l3.htm">Listing 3</a>, and the result is an <B>EtMatrixAdd</B> object that holds references to <B>A</B> and <B>B</B>. The addition <B>Temp1 + C</B> is performed using the second <B>operator+</B> in <a href="cuj0306becker_l3.htm">Listing 3</a>, and the result is an <B>EtMatrixAdd</B> object that holds references to <B>Temp1</B> and <B>C</B>. The assignment <B>S = Temp2</B> loops over all matrix positions <B>(i, j)</B> and performs the assignment: <P> <pre>S.ElementAt(i, j) = Temp2.ElementAt(i, j);</pre>The function call on the right-hand side is in fact the inlined one-liner:<P> <pre>Temp1.ElementAt(i, j) + C.ElementAt(i, j);</pre>and this in turn resolves, via inlining, to:<P> <pre>A.ElementAt(i, j) + B.ElementAt(i, j) + C.ElementAt(i, j);</pre>Therefore, the assignment:<P> <pre>S = A + B + C</pre>is performed as efficiently as with a handwritten loop.<P> <h3>Taking a Step Back</h3><p> The code in <a href="cuj0306becker_l3.htm">Listing 3</a> is still a far cry   from maturity. The main problem here is that an addition's operands can be two   entirely different things, namely good old matrix objects and new lightweight   objects. The mature implementations of [1] and [2] resolve this by defining   one class template, which, via an additional template parameter, can morph into   a good old matrix or into a new lightweight object. There are a number of subtleties   and gotchas along the way, so if you're thinking about using expression templates   or even implementing them yourself, make sure to study [2] or [3] very carefully.   However, there is no need to go into any of that here, because as far as the   idea behind expression templates is concerned, we have it all in <a href="cuj0306becker_l3.htm">Listing   3</a>. <P> So why the term "expression template?" Take another look at the type of the   temporary object <B>Temp2</B> that was created when performing the addition   <B>A + B + C</B>. If we suppress the template arguments <B>double</B>, <B>n</B>,   and <B>m</B> for readability, that type becomes:<P> <pre>EtMatrixAdd&lt;EtMatrixAdd&lt;Mat, Mat&gt;, Mat&gt;</pre>It is plain to see that the nested structure of this type represents the parse tree of the expression <I>(x + y) + z</I>. A concrete object of this type augments that parse tree by references to concrete operands. And finally, an assignment such as:<P> <pre>S = A + B + C</pre>amounts to an evaluation of the expression, based on the parse tree that is in the type and the operands that are in the object. Looking at things in this way explains the term "expression templates" for class templates such as our <B>EtMatrixAdd</B>. It also reveals, in yet another way, the enormous power of C++ templates. We previously saw how to use them to write full-fledged programs that get executed at compile time. Here, they are used to generate, at compile time, parse trees of algebraic expressions that allow efficient evaluation of these expressions at run time.<P> <h3>References</h3><P>[1] Todd Veldhuizen. "Expression Templates," in Stanley B. Lippman (Editor), <I>C++ Gems</I> (SIGS Books and Multimedia, 1996), pp. 475-488.<P> [2] David Vandevoorde and Nicolai M. Josuttis. <I>C++ Templates: The Complete   Guide</I> (Addison-Wesley, 2002).<P> [3] Andrei Alexandrescu. "Generic&lt;Programming&gt;: Move Constructors,"   <I>C/C++ Users Journal C++ Experts Forum</I>, February 2003, &lt;www.cuj.com/experts/2102/alexandr.htm&gt;. <H3>About the Author</h3><p><p>Thomas Becker works as a senior software engineer for Zephyr Associates, Inc. in Zephyr Cove, Lake Tahoe. He can be reached at <B>thomas@styleadvisor.com</B>.<P> </BODY></HTML>