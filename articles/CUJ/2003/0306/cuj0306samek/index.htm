<HTML><HEAD><TITLE>The Embedded Angle: D&eacute;j&agrave; Vu</TITLE></HEAD><body bgcolor="#FFFFFF" text="#000000"><h2>The Embedded Angle: D&eacute;j&agrave; Vu</h2><P> <H3> Miro Samek</H3><P> <i>It's D&eacute;j&agrave; Vu all over again as Miro reveals the object-oriented   nature of the behavorial abstractions that pervade embedded programs.</i><P> In the last installment of this column ("Who Moved my State?," <I>CUJ</I>,   April 2003), I touched on the benefits of using state machines in programming   reactive (event-driven) systems. However, while the traditional Finite State   Machines (FSMs) are an excellent tool for tackling smaller problems, it's also   generally known that they tend to become unmanageable even for moderately involved   systems. Due to the phenomenon known as "state explosion," the complexity of   a traditional FSM tends to grow much faster than the complexity of the reactive   system it describes. This happens because the traditional state machine formalism   inflicts repetitions. For example, if you try to represent the behavior of just   about any nontrivial system (such as the calculator I described in the last   column) with a traditional FSM, you'll immediately notice that many events (e.g.,   the Clear event) are handled identically in many states. A conventional FSM,   however, has no means of capturing such a commonality and requires repeating   the same actions and transitions in many states. What's missing in the traditional   state machines is the mechanism for factoring out the common behavior in order   to share it across many states.<P> The formalism of <I>statechart</I>s, invented by David Harel in the 1980s   (see David Harel, "Statecharts: A Visual Formalism for Complex Systems," <I>Science   of Computer Programming, 8</I>, 1987, available online from &lt;http://www.wisdom.weizmann.ac.il/~dharel/SCANNED.PAPERS/Statecharts.pdf&gt;),   addresses exactly this shortcoming of the conventional FSMs. Statecharts provide   a very efficient way of sharing behavior, so that the complexity of a statechart   no longer explodes but tends to faithfully represent the complexity of the reactive   system it describes. Obviously, formalism like this is a godsend to embedded   systems programmers (or any programmers working on reactive systems), because   it makes the state machine approach truly applicable to real-life problems.<P> <h3>Reuse of Behavior in Reactive Systems</h3>All reactive systems seem to reuse behavior in a similar way. For example, the characteristic look-and-feel of all Graphical User Interfaces (GUIs) results from the same pattern, which Charles Petzold calls the "Ultimate Hook" (see Charles Petzold, <I>Programming Windows 95, The Definite Developer's Guide to the Windows 95 API</I>, Microsoft Press, 1996). The pattern is brilliantly simple. A GUI system dispatches every event first to the application (e.g., Windows calls a specific function inside the application, passing the event as an argument). If not handled by the application, the event flows back to the system. This establishes a hierarchical order of event processing. The application, which is conceptually at a lower level of the hierarchy, has the first shot at every event; thus, the application can customize every aspect of its behavior. At the same time, all unhandled events flow back to the higher level (i.e., to the GUI system), where they are processed according to the standard look-and-feel. This is an example of <I>programming-by-difference </I>because the application programmer needs to code only the differences from the standard system behavior.<P> Harel statecharts bring the "Ultimate Hook" pattern to the logical conclusion   by combining it with the state machine formalism. The most important innovation   of statecharts over the classical FSMs is the introduction of hierarchically   nested states (that's why statecharts are also called <I>hierarchical state   machines</I>). The semantics associated with state nesting (shown in <a href="cuj0306samek_f1.htm">Figure   1</a>(a)) are as follows: If a system is in the nested state <B>s11</B> (called   substate), it also (implicitly) is in the surrounding state <B>s1</B> (the superstate).   This state machine will attempt to handle any event in the context of state   <B>s11</B> (which is at the lower level of the hierarchy). However, if state   <B>s11</B> does not prescribe how to handle the event, the event is not quietly   discarded (as in a traditional "flat" state machine); rather, it is automatically   handled at the higher level context of state <B>s1</B>. This is what is meant   by the system being in state <B>s11</B> as well as <B>s1</B>. Of course, state   nesting is not limited to one level only, and the simple rule of event processing   applies recursively to any level of nesting. <P> As you can see, the semantics of hierarchical state decomposition are designed   to facilitate sharing of behavior through the direct support for the "Ultimate   Hook" pattern. The substates (nested states) need only define the differences   from the superstates (surrounding states). A substate can easily reuse the common   behavior from its superstate(s) by simply ignoring commonly handled events,   which are then automatically handled by higher level states. In this manner,   the substates can share all aspects of behavior with their superstates. For   example, in a state model of a PELICAN (PEdestrian LIght CONtrolled) crossing   shown in <a href="cuj0306samek_f1.htm">Figure 1b</a>, states <B>vehiclesEnabled</B>   and <B>pedestriansEnabled</B> share a common transition <B>OFF</B> to the <B>off</B>   state, defined in their common superstate <B>operational</B>. <P> <h3>Behavioral Inheritance</h3>The fundamental character of state nesting in Hierarchical State Machines (HSMs) comes from combining hierarchy with programming-by-difference, which is otherwise known in software as <I>inheritance</I>. In Object-Oriented Programming (OOP), the concept of class inheritance lets you define a new kind of class rapidly in terms of an old one by specifying only how the new class differs from the old class. State nesting introduces another fundamental type of inheritance, called <I>behavioral inheritance</I> (see M. Samek and Paul Y. Montgomery "State-Oriented Programming," <I>Embedded Systems Programming</I>, August 2000, available online from &lt;http://www.embedded.com/2000/0008/0008feat1.htm&gt;). Behavioral inheritance lets you define a new state as a specific kind of another state, by specifying only the differences from the existing state rather than defining the whole new state from scratch.<P> As class inheritance allows subclasses to <I>adapt</I> to new environments,   behavioral inheritance allows substates to <I>mutate</I> by adding new behavior   or by overriding existing behavior. Nested states can introduce new behavior   by adding new state transitions or reactions (also known as internal transitions)   for events that are not recognized by superstates. This corresponds to adding   new methods to a subclass. Alternatively, a substate may also process the same   events as the superstates but will do it in a different way. In this manner,   the substate can override the inherited behavior, which corresponds to a subclass   overriding a (virtual in C++) method defined by its parents. In both cases,   overriding the inherited behavior leads to polymorphism.<P> <h3>Liskov Substitution Principle for States</h3>Because behavioral inheritance is just a specific kind of inheritance, the universal law of generalization -- the Liskov Substitution Principle (LSP) -- should be applicable to state hierarchies as well as class taxonomies. In its traditional formulation for classes, LSP requires that every instance of a subclass must continue to act as though it were also an instance of the superclass. From the programming standpoint, LSP means that any code designed to work with the instance of the superclass should continue to work correctly if an instance of the subclass is used instead.<P> The LSP extends naturally for hierarchical states and requires in this case   that every substate continue to behave as though it were also the superstate.   For example, all substates nested inside the <B>vehiclesEnabled</B> state of   the PELICAN crossing (such as <B>vehiclesGreen</B> or <B>vehiclesYellow</B>,   shown in <a href="cuj0306samek_f2.htm">Figure 2</a>) should share the same basic   characteristics of the <B>vehiclesEnabled</B> state. In particular, being in   the <B>vehiclesEnabled</B> state means that the vehicles are allowed (by a green   or yellow light) and simultaneously the pedestrians are not allowed (by the   DON'T WALK signal). To be compliant with the LSP, none of the substates of <B>vehiclesEnabled</B>   should disable the vehicles or enable the pedestrians. In particular, disabling   vehicles (by switching the red light), or enabling the pedestrians (by displaying   the WALK signal) in any of the nested states <B>vehiclesGreen</B> or <B>vehiclesYellow</B>   would be inconsistent with being in the superstate <B>vehiclesEnabled</B> and   would be a violation of the LSP (it will also be a safety hazard in this case). <P> Compliance with the LSP allows you to build better (correct) state hierarchies   and make efficient use of abstraction. For example, in an LSP-compliant state   hierarchy, you can safely "zoom out" and work at the higher level of the <B>vehiclesEnabled</B>   state (thus abstracting away the specifics of <B>vehiclesGreen</B> and <B>vehiclesYellow</B>).   As long as all the substates are consistent with their superstate, such abstraction   is meaningful. On the other hand, if the substates violate basic assumptions   of being in the superstate, zooming out and ignoring specifics of the substates   will be incorrect.<P> <h3>Guaranteed Initialization and Cleanup</h3>Every state in a UML statechart can have optional entry actions, which are executed upon entry to a state, as well as optional exit actions, which are executed upon exit from a state. Entry and exit actions are associated with states, not transitions. Regardless of how a state is entered or exited, all of its entry and exit actions will be executed.<P> The value of entry and exit actions is often underestimated. However, entry   and exit actions are as important in HSMs as class constructors and destructors   are in OOP because they provide for <I>guaranteed</I> initialization and cleanup.   For example, consider the <B>vehiclesEnabled</B> state from <a href="cuj0306samek_f1.htm">Figure   1b</a>, which corresponds to the traffic lights configuration that enables vehicles   and disables pedestrians. This state has a very important safety-critical requirement:   always disable the pedestrians (by turning on the DON'T WALK signal) when vehicles   are enabled. Of course, you could arrange for such a behavior by adding an appropriate   action (switching the DON'T WALK signal) to every transition path leading into   the <B>vehiclesEnabled</B> state. However, such a solution would potentially   cause the repetition of this action on many transitions. More importantly, such   an approach is error-prone in view of changes to the state machine. For instance,   a programmer upgrading a PELICAN crossing to a PUFFIN (Pedestrian User Friendly   INtelligent) crossing might simply forget to turn on the DON'T WALK signal on   all transitions into the <B>vehiclesEnabled</B> state or any of its substates.   Entry and exit actions allow you to implement the desired behavior in a safer,   simpler, and more intuitive way. You could specify turning on the DON'T WALK   signal upon the <I>entry</I> to <B>vehiclesEnabled</B>. This solution is superior   because it avoids potential repetitions of this action on transitions and eliminates   the basic safety hazard of leaving the WALK signal turned on while vehicles   may be allowed into the crossing. The semantics of entry actions guarantees   that, regardless of the transition path, the DON'T WALK signal will be turned   on when the traffic controller is in the <B>vehiclesEnabled</B> state. <P> NOTE: An equally correct alternative design is to switch the DON'T WALK signal   in the exit action from <B>pedestriansEnabled</B> and to switch the red light   for vehicles in the exit action from <B>vehiclesEnabled</B>.<P> Obviously, you can also use entry and exit actions in the classical (nonhierarchical)   FSMs. In fact, the lack of hierarchy in this case makes the implementation of   this feature almost trivial. For instance, one way of implementing entry and   exit actions is to dispatch reserved signals (e.g., <B>ENTRY_SIG</B> and <B>EXIT_SIG</B>)   to the state machine. The <B>FsmTran_()</B> method (see the April installment   of this column) could dispatch the <B>EXIT_SIG</B> signal to the current state   (transition source) and then dispatch the <B>ENTRY_SIG</B> signal to the target.   Such an implementation of the <B>FsmTran_()</B> method might look as follows   (the complete code in C and C++ is available from the code archive at &lt;www.cuj.com/code&gt;):<P> <pre>static Event const entryEvt = { ENTRY_SIG };static Event const exitEvt = { EXIT_SIG };void FsmTran_(Fsm *me, State target) {   FsmDispatch(me, &amp;exitEvt);   /* exit the source */   me-&gt;state__ = target; /*   change current state */   FsmDispatch(me, &amp;entryEvt); /* enter the target */}</pre>However, entry and exit actions are particularly important and powerful in HSMs because they often determine the <I>identity</I> of hierarchical states. For example, the identity of the <B>vehiclesEnabled</B> state is determined by the fact that the vehicles are enabled and pedestrians disabled. These conditions must be established before entering any substate of <B>vehiclesEnabled</B> because entry actions to a substate, such as <B>vehiclesGreen</B> (see <a href="cuj0306samek_f2.htm">Figure 2</a>), rely on proper initialization of the <B>vehiclesEnabled</B> superstate and perform only the differences from this initialization. Consequently, the order of execution of entry actions must always proceed from the outermost state to the innermost state. Not surprisingly, this order is analogous to the order in which class constructors are invoked. Construction of a class always starts at the top of the class hierarchy and follows through all inheritance levels down to the class being instantiated. The execution of exit actions, which corresponds to destructor invocation, proceeds in the exact reverse order, starting from the innermost state (corresponding to the most derived class). <P> HINT: Try to make your state machine as much a Moore automaton as possible.   (Moore automata associate actions with states rather than transitions.) That   way you achieve a safer design (in view of future modifications) and your states   will have better-defined identity.<P> <h3>Zooming in...</h3><P> <a href="cuj0306samek_f2.htm">Figure 2</a> shows a complete UML state diagram   of the PELICAN crossing (a "zoomed in" version of the diagram from <a href="cuj0306samek_f1.htm">Figure   1b</a>). I believe that this HSM represents quite faithfully the behavior of   the pedestrian crossing in front of the midtown shopping center on Middlefield   Road in Palo Alto. I have tested the crossing several times (the drivers sure   loved me for it) and have determined that it operates as follows. Nominally,   vehicles are enabled and pedestrians disabled. To activate the traffic light   switch, a pedestrian must push a button (let's call this event <B>PEDESTRIAN_WAITING</B>).   In response, the vehicles get the yellow light. After a few seconds, vehicles   get a red light and pedestrians get the WALK signal, which shortly thereafter   changes to a flashing DON'T WALK signal. When the DON'T WALK signal stops flashing,   vehicles get the green light. After this cycle, the traffic lights don't respond   to the <B>PEDESTRIAN_WAITING</B> event immediately, although the button "remembers"   that it has been pushed. The traffic light controller always gives the vehicles   a minimum of several seconds of green light before repeating the cycle. <P> Perhaps the most interesting element of the state model from <a href="cuj0306samek_f2.htm">Figure   2</a> (except the aforementioned use of entry actions to avoid basic safety   hazards) is the way it guarantees the minimal green light time for the vehicles.   The HSM models it with two states, <B>vehiclesGreen</B> and <B>vehiclesGreenInt,</B>   as well as with the <B>isPedestrianWaiting</B> flag. The state <B>vehiclesGreen</B>   corresponds to the uninterruptible green light for the vehicles. The occurrence   of the <B>PEDESTRIAN_WAITING</B> event in this state doesn't trigger any transition   but merely sets the <B>isPedestrianWaiting</B> flag to "remember" that the button   was pressed. The only criterion for exiting <B>vehiclesGreen</B> is the occurrence   of the <B>TIMEOUT</B> event, which triggers a transition either to <B>vehiclesYellow</B>   (if the <B>isPedestrianWaiting</B> flag is set) or to the <B>vehiclesGreenInt</B>   state, the latter corresponding to the interruptible green light for vehicles. <P> Another interesting aspect of this state model is the generation of the <B>TIMEOUT</B>   events by means of only one timer object. (A timer is a facility that dispatches   an event to the state machine after a preprogrammed time interval.) Typically,   timers are scarce system resources that need to be allocated (here indicated   by the <B>SetTimer()</B> action) and recycled (by the <B>KillTimer()</B> action).   Note how the state machine enables using only one <B>TIMEOUT</B> event (different   states handle the same event differently), and how entry and exit actions help   to initialize and clean up the timer. In particular, please note that the timer   is never leaked, even in the case of the always enabled <B>OFF</B> transition   inherited from the <B>operational</B> superstate.<P> <h3>A Pie-in-the-Sky?</h3><P> If I left this quick introduction to HSMs only at the level of the state diagram   from <a href="cuj0306samek_f2.htm">Figure 2</a>, you would probably walk away   with the impression that the whole approach is just a pie-in-the-sky. The diagram   in <a href="cuj0306samek_f2.htm">Figure 2</a> might look clever, perhaps, but   how does it lead to better code? <P> Contrary to a widespread misconception, you don't need sophisticated CASE   tools to translate UML state diagrams to efficient and highly maintainable C   or C++. To prove the point, I have placed the full implementation of the PELICAN   crossing both in C and C++ into the CUJ code archive at &lt;www.cuj.com/code&gt;.   I have embedded the HSM into a Windows application (see <a href="cuj0306samek_f3.htm">Figure   3</a>), because I needed a timer to dispatch <B>TIMEOUT</B> events to the state   machine. Note, however, that the underlying coding technique is not at all Windows-   or GUI-specific. In particular, the HSM implementation can be used in embedded   systems in conjunction with any infrastructure to execute state machines. <P> <P> EXERCISE: test the GUI application (either C or C++ version) and correlate   its behavior with the state diagram from <a href="cuj0306samek_f2.htm">Figure   2</a> (you might find the current state display handy). Subsequently, set breakpoints   at all exit actions from states and convince yourself that the application never   leaks the Windows timer. <P> <P> While I don't have here room for a detailed discussion of the HSM implementation   that you'll find online, I'd only like to mention the it is a straightforward   extension of the FSM technique I presented in the April column. As before, <B>State</B>   is defined as a pointer-to-function in C (and pointer-to-member-function in   C++), however the signature of state handler methods has changed. In an HSM,   the state handler additionally returns the superstate, thus providing information   about the nesting of a given state. More precisely, a state handler method must   return a pointer to the superstate handler, if it doesn't handle the event,   or <B>NULL</B> if it does. To guarantee that all states have superstates, the   <B>QHsm</B> class (base class for derivation of HSMs, analogous to the <B>Fsm</B>   class from the April column) provides the <B>top</B> state as the ultimate root   of the state hierarchy. The <B>top</B> state handler cannot be overridden and   always returns <B>NULL</B>. These conventions make the implementation of the   <B>QHsmDispatch()</B> method simple:<P> <pre>void QHsmDispatch(QHsm *me, QEvent const *e) {  me-&gt;source__ = me-&gt;state__;  do {   me-&gt;source__ = (QState)(*me-&gt;source__)(me, e);  } while (me-&gt;source__ != 0);}</pre>As you can see, every event dispatched to an HSM passes through a chain of state handlers until a state handler returns <B>NULL</B>, which indicates that either the event has been handled or the top state has been reached.<P> As a client programmer, you don't need to know the internal details of the   <B>QHsm</B> class. The main point is that the resulting HSM implementation provides   a very straightforward mapping between the diagram and the code, and it is easy   to modify at any stage of the development process. I encourage you to undertake   the following two exercises:<P> <P> EXERCISE: Modify the state machine to implement the alternative design of   switching the DON'T WALK signal in the exit action from <B>pedestriansEnabled</B>   and switching the red light for vehicles in the exit action from <B>vehiclesEnabled</B>.   Recompile and test.<P> EXERCISE: Modify the initial transition in the <B>vehiclesEnabled </B>state   to enter the <B>vehiclesGreenInt</B> substate. In addition, change the target   of the <B>TIMEOUT</B> transition for state <B>pedestriansFlash</B> from <B>vehiclesEnabled</B>   to <B>vehiclesGreen</B>.<P> <P> <h3>End-Around Check</h3><P> Many writings about HSMs cautiously use the term "inheritance" to describe sharing of behavior between substates and superstates (e.g., see the OMG specification of UML v1.4 at &lt;cgi.omg.org/ <BR>docs/formal/01-09-67.pdf&gt;). Please note, however, that the term <I>behavioral inheritance</I> is not part of the UML vocabulary and should not be confused with the traditional (class) inheritance applied to entire state machines (classes that internally embed state machines). A few readers of my last column were disappointed that after criticizing the Visual Basic calculator I didn't present a better state machine-based design. Actually, I do have a bullet-proof calculator, based on an HSM, which you can find at &lt;www.quantum-leaps.com/ <BR>cookbook/recipes.htm#HSM_Design&gt;.<P> I have also received a few letters from embedded programmers who seemed intimidated   by UML. I believe that the concerns are largely exaggerated. It takes just a   few hours to get acquainted with the most basic UML diagrams. (I get the most   mileage from the sequence diagram, state diagram, and class diagram.) I think   that the ability to read basic UML diagrams belongs to every embedded programmer's   skill set in the same way as the ability to read schematics. If I were to recommend   a book, I'd probably start with Martin Fowler's <I>UML Distilled: A Brief Guide   to the Standard Object Modeling Language (2nd Edition)</I>, Addison-Wesley,   1999.<P> If you want to know the difference between Zebra, Pelican, Puffin, Toucan,   and Pegasus pedestrian crossings, go to &lt;www.2pass.co.uk/crossing.htm&gt;.<P> Finally, I hope you experienced a strange feeling of <I>d&eacute;j&agrave;   vu</I> when you read about programming-by-difference, inheritance, guaranteed   initialization and cleanup, and the LSP in the context of state machines. Such   a close analogy between the fundamental concepts of OOP and HSMs is truly remarkable.   Indeed, the analogy adds another dimension to the OOP. The traditional OO method   seems to stop short at the boundary of a class, leaving the <I>internal</I>   implementation of individual class methods to mostly procedural techniques.   The concept of behavioral inheritance goes beyond that frontier. Behavioral   inheritance allows applying the OO concepts <I>inside</I> reactive classes.<P> <h3>About the Author</h3><P>Miro Samek has been developing embedded real-time software for almost 12 years. He is the author of <I>Practical Statecharts in C/C++: Quantum Programming for Embedded Systems</I> (CMP Books, 2002). Dr. Samek is the lead software architect at IntegriNautics Corporation (Menlo Park, CA) and a consultant to the industry. He previously worked at GE Medical Systems, where he has developed safety-critical, real-time software for diagnostic imaging x-ray machines. He earned his Ph.D. in nuclear physics at GSI (Darmstadt, Germany) where he conducted heavy-ion experiments. Miro welcomes feedback and can be reached at <B>miro@quantum-leaps.com</B>.<P> </BODY></HTML>