<HTML><HEAD><TITLE>Function Overloading Based on Arbitrary Properties of Types</TITLE></HEAD><body bgcolor="#FFFFFF" text="#000000"><H2>Function Overloading Based on Arbitrary Properties of Types</h2><P> <h3>Jaakko J&auml;rvi, Jeremiah Willcock, Howard Hinnant, and Andrew Lumsdaine</h3><P> <i>With these groundbreaking Function Enablers, you have much more control   over function overload resolution than you thought.</i><p> <h3>Introduction</h3><p> The C++ function overloading rules are far from simple, complicated by special   rules about template and non-template functions, implicit conversions, automatic   template argument deduction, etc. This article describes a lesser-known and   seemingly minor part of these rules, which conceals a true gem for generic programming.   In a nutshell, these rules allow template functions to be selectively included   in or excluded from the overload resolution. Any properties of the argument   types that can be expressed as compile-time Boolean constants can be used as   criteria in this selection.<P> This article builds on the (independent) findings of Paul Mensonides and Jason   Shirk. They showed how to manipulate the overload resolution set [1, 2] and   used this result to define traits classes, such as <B>is_class</B> for testing   whether a given type is a class type and <B>has_member</B> for testing whether   a class type has a member function of a given name and type. This article generalizes   the technique, packages it into an easy-to-use template, and, more importantly,   demonstrates its significant implications for generic programming.<P> The technique allows overloading a function for a set of types that do not   derive from a common base class. Thus a generic library author can overload   operators and other functions with a fully generic interface, but still have   them match only the types for which they are designed. As an example, we define   a flexible Java-style string concatenation operator that automatically converts   a non-string operand into a string. The programmer has full control over the   set of types the concatenation operator matches. This same technique solves   the problems with the relational operators in the infamous <B>rel_ops</B> namespace.   As another example application, the article shows an alternative mechanism for   tag dispatching, an idiom for statically dispatching from an interface function   to specialized implementation functions. In general, the technique is useful   in disambiguating conflicting function overloads.<P> <h3>Background</h3>It is easy to end up with invalid type expressions while instantiating function templates. As an example, consider the following two overloaded functions:<P> <pre>int negate(int i) { return -i; }template &lt;class F&gt;typename F::result_typenegate(const F&amp; f) { return -f(); }</pre>The latter overload is meant to work with standard function objects where the member type <B>result_type</B> specifies the return type. Now examine a call, such as:<P> <pre>negate(1)</pre>The first overload is clearly a better match, but the compiler must nevertheless make an attempt to instantiate the second overload as well. This results in the prototype:<P> <pre>int::result_type negate(const int&amp;);</pre>The return type <B>int::result_type</B> is obviously invalid. A compile-time error here would undoubtedly annoy the programmer as a valid and better matching overload exists, and indeed, the code compiles fine. The compiler removes the erroneous prototype from the overload resolution set, and thus the invalid return type does not cause an error.<P> Instantiating a function template is a two-phase process. First, the template   argument values are deduced from the types of the actual arguments passed in   to the function. Second, these deduced values are substituted for all occurrences   of the template parameters in the return and parameter types of the function.   As an example, in the call <B>negate(1)</B>, the value of the template argument   <B>F</B> is deduced to be <B>int</B> based on the type of the function argument.   The value <B>int</B> is then substituted for all occurrences of <B>F</B>, leading   to the return type <B>int::result_type</B>.<P> If the substitution process leads to an invalid type, argument deduction fails,   and the function is not added to the overload resolution set. Hence, if we can   find a controlled way to make this substitution process result in an invalid   type, we have a tool that can remove a function from the overload resolution   set. The Standard contains nine rules describing explicitly what an invalid   type means in this context. One of the cases is an attempt to refer to a nested   <B>typedef</B> that does not exist, as in expression <B>int::result_type</B>.   A pointer to a reference type and a function type in which a parameter has <B>void</B>   type are other examples of invalid types that cause type deduction to fail.<P> The above described parts of the overload resolution rules are well hidden   in the Standard, but a careful reading of sections 14.8.2 (paragraphs 2 and   4) and 14.8.3 should assure you that a Standard-conforming C++ compiler must   behave as explained above.<P> <h3>Function Enablers and Disablers</h3><p> We have packaged the enabling/disabling functionality into two easy-to-use   templates, <B>enable_if</B> and <B>disable_if</B>. The definition of <B>enable_if</B>   is as follows:<P> <pre>template &lt;bool B, class T = void&gt;struct enable_if {  typedef T type;};template &lt;class T&gt;struct enable_if&lt;false, T&gt; {};</pre>This template takes two parameters, a Boolean constant <B>B</B> and a type <B>T</B>. Depending on the value of <B>B</B>, <B>enable_if</B> either defines a nested <B>typedef</B> named <B>type</B> as <B>T</B> (<B>true</B> case) or defines no such <B>typedef</B> (<B>false</B> case). In other words, <B>enable_if&lt;true, T&gt;::type</B> equals <B>T</B>, whereas <B>enable_if&lt;false, T&gt;::type</B> is an expression that refers to a nonexistent nested type (which is one of the special invalid types that lead to removing the function from the overload resolution set). The rationale for the default value <B>void</B> for parameter <B>T</B> is explained in the end of this section.<P> The <B>disable_if</B> template can be defined similarly, except for the negated   condition. It is not strictly necessary to have both the enabler and disabler;   one can always negate the conditional expression at the site of using <B>enable_if</B>.   However, in some cases, it is more intuitive to think of disabling a function   under particular conditions, instead of enabling it under the negated conditions.<P> To use the packaged enablers (the term enabler refers to both the <B>enable_if</B>   and <B>disable_if</B> templates), you simply wrap the function's actual return   type in an <B>enable_if</B> or <B>disable_if</B> template. In the following   example, the <B>foo</B> function is always enabled, whereas <B>bar</B> is never   enabled:<P> <pre>template &lt;class T&gt;typename enable_if&lt;true, T&gt;::typefoo(T t) { return t; }template &lt;class T&gt;typename enable_if&lt;false, T&gt;::typebar(T t) { return t; }</pre>A call to <B>foo</B> with any (copy-constructible) argument type succeeds, but all calls to <B>bar</B> fail because <B>bar</B> will never be added to the overload resolution set. It is as if no definition for <B>bar</B> existed.<P> <pre>foo(1); // ok, returns 1bar(1); // fails, no such function</pre>In real code, it would be pointless to write enablers where the condition always evaluates to the same truth value. Enablers become useful when the truth value of their condition depends on the properties of one or more template arguments. To write such expressions, we need compile-time reflection mechanisms. Reflection means the ability to query and operate on properties of language constructs within the language itself. The direct support for reflection is limited in C++, but with some inventive template techniques, a notable set of compile-time reflection tools can be implemented as a template library. These tools come in the form of traits classes. In <a href="cuj0306jarvi_t1.htm">Table 1</a>, we describe some of the traits classes from the Boost type traits library [3, 4]. <P> As an example, the following function template is only enabled for arithmetic   types:<P> <pre>template &lt;class T&gt;typename enable_if&lt;is_arithmetic&lt;T&gt;::value, T&gt;::typefoo(T t);</pre>We have also found compile-time <B>if</B> statements and other tools for template metaprogramming helpful in writing the enabler conditions (see for example [5, 6]).<P> Note that instead of the return type, you can place the enabler into a function's   parameter type. Typically, you would introduce an extra parameter and give it   a default value so that the call sites of the function would not be affected.   For example:<P> <pre>template &lt;class T&gt;T foo (T t,       typename enable_if&lt;is_arithmetic&lt;T&gt;::value&gt;::type* = 0);</pre>Note that when <B>enable_if</B> is used as an argument type, the nested <B>typedef</B> in <B>enable_if</B> can always have the same type <B>void</B> making the second argument to <B>enable_if</B> unnecessary. This is the reason why <B>void</B> is the default value for the second argument of <B>enable_if</B>.<P> We prefer to use enablers in the return type, particularly as an important   application of enablers is operator functions, where the number of parameters   is fixed. On the other hand, the technique works with member function templates,   such as templated constructors. Constructors do not have return types; thus,   an enabler in a constructor must be placed into a parameter.<P> <h3>Applications</h3><p> <h3>Java-Style String Concatenation</h3><p> Java provides special support for the string concatenation operator (<B>+</B>).   This operator requires that at least one of the operands is of type <B>String</B>.   The other operand is converted to <B>String</B> if necessary. For example:<P> <pre>1 + " is less than " + 2</pre>evaluates to the string <B>"1 is less than 2"</B>. Function enablers provide a convenient way to implement this same behavior in C++. Unlike in Java, all objects in C++ are not convertible to strings by default. Therefore, we first need a function to convert objects of other types to strings:<P> <pre>template &lt;class T&gt;std::string to_string(const T&amp; t) {  std::ostringstream s;  s &lt;&lt; t;  return s.str();}</pre>Any <I>output streamable</I> type (any type that can be written into an output stream) can be converted to a string with this function. Next we need a traits class telling which types are output streamable:<P> <pre>template &lt;class T&gt;struct is_output_streamable {  static const bool value =    is_arithmetic&lt;T&gt;::value;};</pre>This primary template specifies that all arithmetic types are output streamable. By default, any other type is thus not output streamable. By adding specializations for this template, we can declare any type output streamable.<P> The next task is to write the enabling condition for the concatenation operator.   The operator should be enabled as long as at least one of its arguments is a   string, and any non-string argument is output streamable. The following traits   class implements this logic:<P> <pre>template &lt;class A, class B&gt;struct can_concatenate {  static const bool value =  ( is_same&lt;A, string&gt;::value &amp;&amp;    is_output_streamable&lt;B&gt;::value)  ||  ( is_same&lt;B, string&gt;::value &amp;&amp;    is_output_streamable&lt;A&gt;::value);};</pre>With the above tools, just one definition of the concatenation function suffices:<P> <pre>template &lt;class A, class B&gt;typename enable_if&lt;  can_concatenate&lt;A, B&gt;::value,  string&gt;::typeoperator+(const A&amp; a, const B&amp; b) {  return to_string(a) + to_string(b);}</pre>The enabler template evaluates the <B>can_concatenate</B> condition, and either allows <B>operator+</B> to be considered for overload resolution or not. The primary template of <B>is_output_streamable</B> defines all arithmetic types to be output streamable, so the expression (corresponding to the Java example above):<P> <pre>1 + string(" is less than ") + 2</pre>evaluates to the string <B>"1 is less than 2"</B>.<P> Consider a user-defined class <B>my_class</B> that supports writing to an   output stream:<P> <pre>class my_class { ... };ostream&amp; operator&lt;&lt;(ostream&amp; o, const my_class&amp; a) {     return (o &lt;&lt; "my_class!");}</pre>A new specialization for <B>is_output_streamable</B> is enough to make <B>operator+</B> accept objects of this type:<P> <pre>template &lt;&gt;struct is_output_streamable&lt;my_class&gt; {  static const bool value = true;};</pre>For example, the expression<P> <pre>string("This is ") + my_class()</pre>now evaluates to the string <B>"This is my_class!"</B>.<P> <h3>Operators in rel_ops</h3><p>The standard library provides default implementations for <B>!=</B>, <B>&gt;</B>, <B>&lt;=</B>, and <B>&gt;=</B> based on the two operators <B>==</B> and <B>&lt;</B>. The definition of <B>operator!=</B> serves as an example:<P> <pre>template &lt;class T&gt;bool operator!=(const T&amp; x, const T&amp; y){ return !(x == y); }</pre>The intention behind these operators was to save programmers from writing boilerplate code. During the standardization process, it was realized that these operators match too greedily and were thus placed into a separate namespace <B>std::rel_ops</B>. The idea was that the programmer would implement <B>operator==</B> and <B>operator&lt;</B> for some class <B>T</B> and import the other relational operators into <B>T</B>'s namespace with <B>using</B> directives. It turned out, however, that the introduction of the <B>rel_ops</B> subnamespace did not solve the approach's fundamental problems. Legitimate uses of the <B>rel_ops</B> operators can still lead to subtle ambiguity errors or worse, errors in program logic due to the best matching function not being what the programmer expects. In general, namespaces are too coarse a mechanism for controlling when operators with fully generic interfaces should be available and when not.<P> Function enablers give the fine-grained control that is required [7]. The   solution is analogous to the Java-style string concatenation implementation   above. An enabler is added to each relational operator definition in <B>rel_ops</B>.   For example, here is the definition of the <B>!=</B> operator:<P> <pre>template &lt;class T&gt;inline typename enable_if&lt;  use_rel_ops&lt;T&gt;::value,  bool&gt;::typeoperator!=(const T&amp; t, class T&amp; u){ return !(t == u); }</pre>The traits class <B>use_rel_ops</B> controls whether the default definitions should be used or not:<P> <pre>template &lt;class T&gt;struct use_rel_ops {  static const bool value = false;};</pre>The primary template sets the default to <B>false</B>, and the default definitions for relational operators are thus only enabled for types that specialize the <B>use_rel_ops</B> template.<P> <h3>Resolving Ambiguities</h3><p>Consider the following scenario: you have a function template with, say, two parameters and a set of overloads for different types of the first parameter:<P> <pre>template &lt;class A, class B&gt;void foo(A a, B b);template &lt;class B&gt;void foo(int a, B b);template &lt;class B&gt;void foo(float a, B b);</pre>Further, suppose there is some type <B>Special_B</B> that is a special case for the second argument. You want to add an overload for this case, such that it would always be chosen, whatever the type of the first argument. Adding just the definition:<P> <pre>template &lt;class A&gt;void foo(A a, Special_B b);</pre>does not give the desired result; calls where both arguments are one of the special cases would be ambiguous. The call <B>foo(1, Special_B())</B> is an example of one such call.<P> The traditional way to solve the ambiguities is to add a disambiguating overload   for each ambiguous case:<P> <pre>template &lt;&gt;void foo(int a, Special_B b);template &lt;&gt;void foo(float a, Special_B b);</pre>Two additional overloaded functions are enough here, but with more arguments and more special argument types, this solution does not scale well.<P> Function enablers can control which functions are considered for overload   resolution and can thus help in resolving ambiguities. In the following set   of overloaded functions, the cases where the first argument has type <B>int</B>   or <B>float</B> are only considered if the second argument is not of type <B>Special_B</B>:<P> <pre>template &lt;class A, class B&gt;void foo(A a, B b);template &lt;class B&gt;typename disable_if&lt;is_same&lt;B, Special_B&gt;, void&gt;::typefoo(int a, B b);template &lt;class B&gt;typename disable_if&lt;is_same&lt;B, Special_B&gt;, void&gt;::typefoo(float a, B b);template &lt;class A&gt;void foo(A a, Special_B b);</pre>Note that overload resolution is an interplay between function enablers and traditional overload resolution, and thus not all definitions need to use the <B>enable_if</B> or <B>disable_if</B> templates.<P> The Standard <B>pow</B> function is a prime example of the case outlined above.   The standard library contains 10 <B>pow</B> overloads, attempting to cover <B>float</B>s,   <B>double</B>s, <B>long</B> <B>double</B>s, and instances of <B>std::complex</B>.   The Standard Library also provides overloads for the cases where the exponent   is of an integral type, as this case allows a more efficient implementation.   Even with the 10 overloads, some reasonable calls result in compile-time errors,   or even worse, silently give incorrect results. As an example, the call<P> <pre>std::pow(std::complex&lt;float&gt;(9, 0), 0.5)</pre>ends up converting the second argument to the integer <B>0</B> and thus produces <B>1</B> as the result, rather than the correct answer <B>3</B>. The call <P> <pre>std::pow(9.0, std::complex&lt;float&gt;(0.5))</pre>fails to compile altogether, as does the call <B>std::pow(1, 1)</B>. Using function enablers, just 3 overloads, compared to the current 10, are enough to cover all the currently supported cases, fix the error cases and unintuitive behavior, and add support for integral types. A bit of extra machinery is required to deduce the return types correctly, though.<P> <h3>Tag Dispatching</h3><p>Tag dispatching is a common technique used in generic algorithms to select an appropriate implementation based on properties of argument types. For example, the standard library defines a set of iterator categories, such as <I>Input Iterator</I> and <I>Random Access Iterator</I>, and defines a tag class for each category. Furthermore, the library provides a traits class for querying the tag of a particular iterator type so that a generic algorithm can choose the most efficient implementation for each iterator type. For example, advancing n steps is a constant-time operation for random access iterators, but a linear-time one for input iterators.<P> Indeed, many of the function templates implementing the standard algorithms   are just dispatching functions that delegate the work to different implementation   functions based on the implementation in the iterator categories of the argument   types. The <B>advance</B> function (based on the implementation in the GNU C++   Standard Library v3) is one such example:<P> <pre>template &lt;class It, class Dist&gt;inline void advance(It&amp; i, Dist n) {  typedef typename     iterator_traits&lt;It&gt;::iterator_category Cat;   __advance(i, n, Cat());}</pre>The first line resolves the iterator category of the first argument and forwards the call to the <B>__advance</B> function, which is overloaded for different iterator categories. We omit the <B>__advance</B> implementations for brevity.<P> Tag dispatching with function enablers lets us do without a separate interface   function and dispatch directly into the implementation templates:<P> <pre>template &lt;class It, class Dist&gt;inline typename enable_if&lt;  is_random_access_iter&lt;It&gt;::value,  void&gt;::typeadvance(It&amp; i, Dist n) { i += n; }template &lt;class It, class Dist&gt;inline typename enable_if&lt;  is_input_iter&lt;It&gt;::value &amp;&amp;  !is_random_access_iter&lt;It&gt;::value,  void&gt;::typeadvance(It&amp; i, Dist n){ while (n--) ++i; }</pre>We omit the implementations of the <B>is_input_iter</B> and <B>is_random_access_iter</B> traits classes here for brevity. Note that the latter <B>advance</B> function is enabled if <B>It</B> is at least an input iterator and not a random access iterator. This is because both definitions of <B>advance</B> are fully generic. If they were ever enabled at the same time, the definitions would be ambiguous. Consequently, you need to exercise some care in designing the enabling rules.<P> Tag dispatching is a well-established idiom in modern template libraries,   and we are not suggesting replacing the current dispatching scheme, say, in   standard library implementations with function enablers. Using function enablers   can, however, be more intuitive in some situations. Particularly, different   functions can have different return types with no extra effort, whereas combining   different return types into one interface function can be cumbersome.<P> <h3>Conclusions</h3><p>This article describes an obscure part of the C++ overload resolution rules, which under special conditions leads to the removal of template functions from the overload resolution set. With the tools described in this article, these conditions can be created with ease, giving the programmer the means to enable and disable function templates based on properties of the argument types.<P> Function enablers and disablers provide solutions to several problems in generic   programming in C++, such as disambiguating otherwise ambiguous overloaded declarations   and doing static dispatching without an intermediate dispatcher function. In   general, the tools presented allow a generic function to be overloaded for a   set of types that do not have a common base class.<P> The possibility to enable and disable functions on (almost) arbitrary properties   of function arguments is a powerful tool. We suspect that this article is a   starting point rather than a comprehensive list of the technique's applications.<P> <h3>Future Work</h3><p>Matching partial specializations of class templates is performed with the same set of rules as function template argument deduction. This means that a partial specialization of a class template can only match if template argument deduction does not fail, and thus the set of rules we describe in the background section can be exploited to enable and disable class template specializations. Richard Smith reported this finding [9]. Our general-purpose enablers work out-of-the-box; all that is needed is one extra template parameter with the default value <B>void</B>. In specializations, this extra parameter is a condition wrapped inside an enabler template. For example:<P> <pre>template &lt;class T, class U = void&gt; class A;template &lt;class T&gt;class A&lt;vector&lt;T&gt;,        typename enable_if&lt;is_arithmetic&lt;T&gt;::value&gt;::type&gt;;template &lt;class T&gt;class A&lt;vector&lt;T&gt;,        typename disable_if&lt;is_arithmetic&lt;T&gt;::value&gt;::type&gt;;</pre>Here, <B>A&lt;vector&lt;float&gt; &gt;</B> matches the first specialization, while <B>A&lt;vector&lt;string&gt; &gt;</B> matches the second one. As with function templates, the condition can be any expression that depends on the template arguments to the class and can be evaluated at compile time. Exploring the consequences and applications of this kind of "conditional specialization" remains as future work.<P> <h3>Workarounds for Too Eager Compilers</h3><p>We successfully tested function enablers using the GCC 3.2, Metrowerks 8.1, Intel 6.0 for Linux, and KAI C++ 4.0 compilers. However, in some cases the compiler needed guidance to get on the right path. With <B>enable_if</B> and <B>disable_if</B>, two overloaded function templates can have identical formal parameter lists but still not be ambiguous. For example:<P> <pre>template &lt;class T&gt;typename enable_if&lt;cond, T&gt;::type foo(T t);template &lt;class T&gt;typename disable_if&lt;cond, T&gt;::type foo(T t);</pre>Even though these two functions can never be enabled simultaneously, some compilers tend to just look at the parameter lists at the time of compiling the definitions of the functions, and an error occurs if identical parameter lists are found. If this issue arises, there are two easy workarounds:<P> <li> Use an extra dummy parameter with a distinct type that disambiguates the   function prototypes. To hide this parameter from the caller, you should provide   a default value for it.  <P> <li> Define the "ambiguous" functions in different namespaces and bring them into   a common namespace with <B>using</B> declarations. For example:  <P>   <pre>namespace A {  template &lt;class T&gt;  typename enable_if&lt;cond, T&gt;::type foo(T t);}namespace B {  template &lt;class T&gt;  typename disable_if&lt;cond, T&gt;::type foo(T t);}using A::foo;using B::foo;</pre><h3>Notes and References</h3><p>[1]  Paul Mensonides. "is_enum&lt;T&gt; ATTN: Andrei Alexandrescu and ilk," thread of Usenet articles in comp.lang.c++.moderated, March 2002.<P>[2]  Jason Shirk. "has_member?," thread of articles in the C++ Boost mailing list &lt;www.boost.org&gt; (message 27342), March 2002.<P>[3]  The Boost type traits library, &lt;www.boost.org/libs/type_traits&gt;, 2002.<P>[4]  John Maddock and Steve Cleary. "C++ Type Traits," <I>Dr. Dobb's Journal</I>, October 2000.<P>[5]  Krzysztof Czarnecki and Ulrich W. Eisenecker. <I>Generative Programming: Methods, Tools, and Applications</I> (Addison-Wesley, 2000).<P>[6]  Aleksei Gurtovoy and David Abrahams. The Boost C++ Metaprogramming Library, 2002.<P>[7]  There are other approaches to safely "import" default definitions for a set of operators, see the Boost Operators library [8].<P>[8]  The Boost Operators library, &lt;www.boost.org&gt;, 2002.<P>[9]  Richard Smith. "A default_constructible traits," thread of Usenet articles in comp.lang.c++.moderated, January 2002.<p><h3>About the Authors</h3><p>Howard Hinnant is a refugee from the aerospace industry. He holds a B.S. in Aerospace Engineering from Texas A&amp;M University and an M.S. in the same field from Stanford University. For the past five years, he has been responsible for the C++ Standard library that ships with Metrowerks CodeWarrior on GameCube, Macintosh, Palm, PlayStation 2, Windows, etc. Howard is also active in the C++ Standards committee. He can be contacted at <B>hinnant@metrowerks.com</B>.<P>Jaakko J&auml;rvi is currently a post-doctoral researcher in the Open Systems Laboratory within the Pervasive Technology Laboratories at Indiana University. He has a Ph.D. in Computer Science from the University of Turku, Finland. He's a contributing member of the C++ Boost community and actively participates in C++ standardization work.<P>Andrew Lumsdaine received the Ph.D. from MIT in 1992. He is currently an Associate Professor in the Computer Science Department at Indiana University, where his teaching and research interests include numerical analysis, mathematical software, parallel processing, generic programming, software engineering, and cluster computing. He is concurrently the associate director of the Open Systems Laboratory, one of the IU Pervasive Technology Laboratories funded by the Lilly Endowment. The mission of the Open Systems Lab is to improve programmer productivity through better practices, tools, and languages -- and to develop and promote these technologies in an open fashion. He is a member of IEEE, SIAM, and ACM.<P>Jeremiah Willcock is currently a graduate student at Indiana University and is working in the Open Systems Laboratory within the Pervasive Technology Laboratories. He has an M.S. in Computer Science and Engineering degree from the University of Notre Dame du Lac, 2002.<p></BODY></HTML>