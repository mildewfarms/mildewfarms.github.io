<title>June2003/Generic Printable ENUM++</title>
<h2 ALIGN="center">Generic Printable ENUM++</h2>
<h3 ALIGN="center">Mitch Besser</h3>

<hr>

<h3>Introduction</h3>

<p>Have you ever wished you could easily print an <b>enum</b> variable's value as formatted text rather than just printing its internal integer representation? Have you ever modified an <b>enum</b>'s constants only to later rummage through mountains of source code looking for what broke from the change? Most programmers accept these shortcomings as an inevitable consequence of using the standard C++ <b>enum</b>.

<p>The common, simple, and tedious nature of augmenting and maintaining <b>enum</b>s makes them good candidates for applying automatic code generation and generic programming techniques.

<p>When I think of generic programming in C++, I immediately think of C++ templates. While templates are a great feature, they have a few limitations. For one, they do not allow you to pass in string literals as template arguments. Luckily, templates are not the only tool available for generating code or writing generic C++. The Boost library <a href="#1">[1]</a> contains a framework of macros that help when C++ templates fall short.

<h3>Requirements and Goals</h3>

<p>Before developing a standard C++ <b>enum</b> enhancement (hereafter referred to as <b>ENUM++</b>), I first created the following list of requirements:

<ol>
<li>Allow conversion of values to formatted text
<li>Facilitate <b>std::istream</b> and <b>std::ostream</b> support
<li>Implement STL style iteration
<li>Detect out of range values
<li>Standardize the uninitialized state
<li>Allow compile-time configurable behavior
</ol>

<p>I also wanted to ensure that <b>ENUM++</b> was applicable to the widest possible audience. For this purpose, I added the following goals:

<ol>
<li>Make <b>ENUM++</b> easy to use
<li>Make <b>ENUM++</b> difficult to misuse
<li>Make <b>ENUM++</b> a drop-in replacement for standard C++ <b>enum</b>s
</ol>

<p>I wanted to support as many features of the standard C++ <b>enum</b> as possible, so that previously written C++ code could take advantage of <b>ENUM++</b> with minimal source code modifications.

<ol start=4>
<li>Keep sizeof(<b>ENUM++</b>)==sizeof(<b>enum</b>)
</ol>

<p>This helps keep <b>ENUM++</b> binary compatible with standard C++ <b>enum</b> types. This is often important to maintenance programmers attempting to replace an <b>enum</b> with <b>ENUM++</b> functionality.

<ol start=5>
<li>Keep <b>ENUM++</b> as efficient as standard C++ <b>enum</b>s
</ol>

<p>Standard C++ <b>enum</b>s were designed to be efficient, so a wholesale replacement needs to be just as efficient.

<h3>Basic Architecture</h3>

<p>Standard C++ <b>enum</b>s act like <b>int</b>s with some additional features and restrictions. In some ways, <b>enum</b>s can be considered a subclass of the more primitive <b>int</b> data type. In much the same manner, it would be convenient to design <b>ENUM++</b> as a subclass of the standard C++ <b>enum</b> type as shown in <a href="besser_l1.htm">Listing 1</a>.

<p>Unfortunately, <b>&lt;enum E></b> is not a valid template parameter. Another problem is that you cannot inherit any C++ primitive data types, including <b>enum</b>s. Given these imposed limitations, I instead chose to generate a wrapper class around a private standard C++ <b>enum</b> member. Access to the wrapped member is made available through generated member functions and overloaded operators.

<p>A drawback with this approach is that it requires scoped access to the <b>ENUM++</b> constants through the wrapping class. A solution to this problem is to generate a duplicate of the enum constants outside of the wrapping class. <a href="besser_l2.htm">Listing 2</a> shows the generated <b>MatrixMovie</b> architecture.

<p>This basic architecture is generated by a series of macros with help from the Boost library. While macros can take the drudgery out of generating code, they have some well known &quot;evil&quot; <a href="#2">[2]</a> properties. Therefore, I moved everything I could into a base class template named <b>_EnumSuper</b>. I only fell back to using macros for the chores that could not otherwise be done in the <b>_EnumSuper</b> template.

<h3>Usage</h3>

<p>You will need to <b>#include enum.h</b> prior to any use of <b>ENUM++</b>. The <b>enum.h</b> header internally <b>#include</b>s <b>StreamUDT.h</b> <a href="#3">[3]</a>, so you will need to make sure it is available in your <b>include</b> path as well. The <b>enum.h</b> header also relies on having the Boost preprocessor library <a href="#1">[1]</a> installed.

<p>Next, consider coding an <b>enum</b> type called <b>MatrixMovie</b> as follows:

<pre>
enum MatrixMovie {UNINITIALIZED=-1, Matrix,
 MatrixReloaded, MatrixRevolutions, SIZE};
</pre>

<p>Instead, replace the above standard C++ <b>enum</b> with the following <b>ENUM++</b> macro:

<pre>
ENUM3(MatrixMovie, Matrix, MatrixReloaded, MatrixRevolutions);
</pre>

<p>The <b>enum</b> type is the macro's first parameter. In this case there are three Matrix movies, so you must use the <b>ENUM++</b> macro <b>ENUM3(...)</b>. Unfortunately, C++ does not allow macros with a variable number of arguments, so you must specify the number in the macro's name. The good news is that if you miscount, your compiler will let you know.

<p>Notice the <b>UNINITIALIZED</b> and <b>SIZE</b> constants are missing from the <b>ENUM++</b> version. You may omit these because <b>ENUM++</b> automatically generates uninitialized state support and a <b>size()</b> member function.

<p>Once declared, your <b>ENUM++</b> type can be used just like a standard C++ <b>enum</b>, except variables of your <b>ENUM++</b> type have additional capabilities. For example, you could write a <b>print_matrix_movies()</b> function that loops and prints all the matrix movies as shown in <a href="besser_l3.htm">Listing 3</a>. If a fourth Matrix movie is ever made, you will not need to change the function at all. All that is required is to change <b>ENUM3(MatrixMovie, ...)</b> to <b>ENUM4(MatrixMovie, ..., MatrixOverkill, ...)</b> and you are done.

<p><a href="besser_l4.htm">Listing 4</a> contains a partial list of the generated <b>MatrixMovie</b> members. For a complete and detailed list of <b>ENUM++</b> functionality, see the <b>enum.h</b> header file.

<p>If you want to use <b>std::iostreams</b> with <b>ENUM++</b> variables, you can additionally define the following:

<pre>
// defines operator>>
DEFINE_ENUM_ISTREAM(MatrixMovie);

// defines operator&lt;&lt;
DEFINE_ENUM_OSTREAM(MatrixMovie);
</pre>

These macros allow reading and writing <b>ENUM++</b> values as formatted text via C++ streams. For example, by using the <b>DEFINE_ENUM_OSTREAM</b> macro, you could rewrite the <b>print_matrix_movies()</b> function without loops by using the STL copy algorithm as shown in <a href="besser_l5.htm">Listing 5</a>.

<h3>Formatting and Streaming</h3>

<p>A generated <b>ENUM++</b> class will need to convert its <b>enum</b> constants into formatted text in order to print them. C++ templates cannot do this without help because template parameters cannot be string literals. The C++ preprocessor stringize operator (<b>#</b>) provides barely enough help. The problem with the preprocessor stringize operator is that you probably do not want to print the <b>enum</b> constant exactly as it is typed in the source code. For example, it would be much nicer for your users to read the value <b>MatrixReloaded</b> formatted as "Matrix Reloaded" rather than the spaceless "MatrixReloaded".

<p>In order to format the text, <b>ENUM++</b> starts by first generating an unformatted text map lookup table something like the following:

<pre>
const char* map[]={"Matrix",
 "MatrixReloaded", "MatrixRevolutions"};
</pre>

<p>In order to process the unformatted text, <b>ENUM++</b> contains a Singleton <a href="#4">[4]</a> class template named <b>_EnumText</b> that creates all the formatting information during its one time only construction. There are two tables of information created.

<p>The first table contains formatted text created from the unformatted text map. The table is filled in by a simple parser that inserts spacing where appropriate. The parser makes an educated guess regarding spacing by using capital letters and numbers as a guide. If the parser finds an underscore within a constant, it assumes the programmer explicitly decided where the spaces should go and instead just performs a simple character substitution of underscores ('_') with spaces (' ').

<p>The second table contains the best matching order to be used when extracting streaming text and converting it into an <b>ENUM++</b> instance (<b>_EnumText:: best_match_order_</b>). The best matching order is defined as the descending order from the longest to the shortest formatted string. For example, a stream of incoming text containing "Matrix Revolutions" could match either the constant <b>Matrix</b> or <b>MatrixRevolutions</b>. By having the matching algorithm try the longest text first, the best possible match is found. If this were not done, the algorithm would stop short by matching "Matrix," leaving "Revolutions" behind in the input stream for the next stream reading operation to process.

<p>With both of these tables in hand, facilitating C++ stream support becomes a reasonably easy task. I used a modified version of code taken from the book <i>Standard C++ IOStreams and Locales</i> <a href="#5">[5]</a>. The basic technique used is to write two member functions named <b>get_stream()</b> and <b>put_stream()</b>. The functions convert between the value's internal representation and its formatted text representation. The function names are well known to a pair of function templates found in the file <b>StreamUDT.h</b>. The templates take care of all the gritty details encountered when dealing with stream insertion and extraction.

<p>All of this is well and good until you want to explicitly initialize <b>enum</b> constants like so:

<pre>
ENUM3(MatrixMovie, Matrix,
 MatrixReloaded=2, MatrixRevolutions=2);
</pre>

<p>If you did this, the generated text map lookup table would require another level of indirection and therefore add a slight inefficiency. However, the most troublesome aspect of explicit initializers is the loss of a 1-to-1 relationship guarantee between the internal <b>int</b> representation and the programmer's abstraction. In other words, explicit initializers open the possibility that two enumeration constants will have the same value. It then becomes impossible to tell the difference between them at runtime.

<p><b>ENUM++</b> solves this problem by forbidding the use of explicit enumeration initializers. As you will see, introducing this restriction makes other problems go away as well. The <b>enum</b> abstraction is primarily about a list of unique constants. The values they take are often of secondary importance. <b>ENUM++</b> focuses its efforts on this primary usage.

<h3>Iteration</h3>

<p>Imagine <b>enum</b>s as compile-time containers of constants. Furthermore, imagine you want to perform some action with each contained constant. It then becomes easy to see why iteration is a desirable feature. Standard C++ <b>enum</b>s contain no direct support for incrementing or decrementing between <b>enum</b> constants.

<p>If <b>ENUM++</b> constants were not sequential, iterating through an <b>ENUM++</b> container would conflict with the efficiency goal. For example, it might be desirable to have the <b>++</b> operator skip over gaps as follows:

<pre>
ENUM3(MatrixMovie, Matrix,
 MatrixReloaded=2, MatrixRevolutions);
mm=Matrix;
mm++;
assert(mm==MatrixReloaded); // ?
</pre>

<p>The value of <b>mm</b> is now ambiguous in terms of <b>MatrixMovie</b> constants. Making the above assertion work would require the separation of the iterator from its value. In the STL, the separation of iterators from containers is fundamental, but doing that here would reduce efficiency. As with printing, disallowing explicit initialization sidesteps the entire issue. This is a tradeoff of drop-in compatibility for efficiency.

<p>Using <b>enum</b> values for iteration now becomes a simple matter of overloading operators as needed. I loosely modeled the list of operators available after the STL random access iterator concept specification <a href="#6">[6]</a>. Like all STL iterators, being one beyond the last element&#8212;using a half closed, half open interval <b>[begin(), end())</b>&#8212;is supported.

<h3>Misuse Detection</h3>

<p>It is desirable to automatically detect as much <b>ENUM++</b> misuse as possible. <b>ENUM++</b> detects misuse at compile-time and run-time. Detecting misuse at compile-time is more effective than detecting it at run-time. Run-time detection requires that test cases be thorough enough to exercise the software completely. On the other hand, reliance on compile-time detection techniques is intrinsically incomplete. <b>ENUM++</b> performs both types of misuse detection.

<p><b>ENUM++</b> detects three different compile-time misuses:

<ol>
<li>Miscounted <b>ENUM++</b> macro parameters
<li>Assignment of ints to <b>ENUM++</b> variables
<li>Explicit constant initialization
</ol>

<p>The detection of explicit constant initialization is the most interesting of the three. <b>ENUM++</b> does this while generating the unformatted text map by producing an entry that will not compile. For example, the <b>ENUM++</b> macro:
 
<pre>
ENUM3(MatrixMovie, Matrix,
 MatrixReloaded=2, MatrixRevolutions);
</pre>

<p>generates a text map like the following:

<pre>
const char* map[]=
{
  {(Matrix,
   "Matrix")},
  {(MatrixReloaded=2, // error
   "MatrixReloaded=2")},
  {(MatrixRevolutions,
   "MatrixRevolutions")}
};
</pre>

<p>Normally, the left side of the comma operator is evaluated and then ignored. However, in the case of <b>MatrixReloaded</b>, the initializer is syntactically treated like an assignment to a constant. Your compiler is bound to see this as an error.

<p>Run-time detection comes in two phases&#8212;during software development and after software release.

<p>During development you want to detect and debug as many problems as possible. The speed of execution is not nearly as important as diagnosing bugs. Therefore, it is worth the small run-time cost of generating a default constructor that initializes <b>ENUM++</b> variables to a known state and generating code that deems out of range values as bugs.

<p>In order to help detect bugs, <b>ENUM++</b> uses two distinct but related constants&#8212;<b>ENUM_INVALID_VALUE</b> and <b>ENUM_DEFAULT_VALUE</b>. <b>ENUM_INVALID_VALUE</b> defines an internal value that <b>ENUM++</b> will consider a bad state when accessed. <b>ENUM_DEFAULT_VALUE</b> defines an internal value that the default constructor and the <b>clear()</b> method both use for initialization. As a default, both <b>ENUM_INVALID_VALUE</b> and <b>ENUM_DEFAULT_VALUE</b> are defined as -1. For example, the following code increments an invalid value causing an assertion:

<pre>
MatrixMovie mm;
++mm; // asserts and increments.
</pre>

<p>Finding problems after software is released is too late. When mistakes happen, it is good to know that your software's behavior will not depend upon the stack's internal state or any other non-reproducible system state. Since <b>mm</b> is initially set to <b>ENUM_DEFAULT_VALUE (-1)</b>, <b>mm</b> will still increment its internal value to <b>MatrixMovie::Matrix (0)</b>. Unless configured otherwise, <b>ENUM++</b> mimics and stabilizes the standard C++ <b>enum</b> behavior.

<h3>Configurable Behavior</h3>

<p>Since the <b>ENUM++</b> programmer's interface is a set of macros, using template parameters as policy settings <a href="#7">[7]</a> is not possible. Configuration of <b>ENUM++</b> is instead accomplished by defining preprocessor values that are used during compilation. For example, you can redirect run-time assertions by appropriately defining the <b>ENUM_ASSERT</b> macro. If you do nothing, <b>ENUM++</b> automatically chooses default preprocessor values that are reasonable for most projects. Read the enum.h header documentation to see all the configuration settings available.

<h3>Summary</h3>

<p>Even a fundamental C++ feature like <b>enum</b> can be improved. If your project has a large number of enumerations that require frequent modifications, <b>ENUM++</b> will significantly reduce your effort. <b>ENUM++</b>'s only notable restriction is its lack of support for <b>enum</b>'s explicit constant initialization syntax. This restriction is mitigated by <b>ENUM++</b>'s standardization of the uninitialized state and the generation of a <b>size()</b> member function. As is often the case with software, it is the small fundamental improvements that have the largest impacts.

<h3>References</h3>

<p><a name="1"></a>[1] <a href="http://www.boost.org">&lt;http://www.boost.org&gt;</a>, "Preprocessor Metaprogramming"

<p><a name="3"></a>[2] <a href="http://www.parashift.com/c++-faq-lite/misc-technical-issues.html#faq-38.4">&lt;http://www.parashift.com/c++-faq-lite/misc-technical-issues.html#faq-38.4&gt;</a>

<p><a name="2"></a>[3] &lt;www.cuj.com/code/&gt;

<p><a name="4"></a>[4] Gamma, Helm, Johnson and Vlissides. <i>Design Patterns: Elements of Reusable Object-Oriented Software</i> (Addison-Wesley, 1994)

<p><a name="5"></a>[5] Langer, Kreft. <i>Standard C++ IOStreams and Locales: Advanced Programmer's Guide and Reference</i>, "3.1.5 Generic Inserters and Extractors" (Addison-Wesley, 2000)

<p><a name="6"></a>[6] <a href="http://www.sgi.com/tech/stl/Iterators.html">&lt;http://www.sgi.com/tech/stl/Iterators.html&gt;</a>

<p><a name="7"></a>[7] Alexandrescu. <i>Modern C++ Design: Generic Programming and Design Patterns Applied</i>, "1. Policy-Based Class Design" (Addison-Wesley, 2000)

<h3>About the Author</h3>

<p><b>Mitch Besser</b> is a Senior Software Engineer and Consultant with <a href="http://www.solutionlogic.com/">Solution Logic, Inc.</a> based in Portland, Oregon. Mitch received a BSc in Wildlife Biology from the University of Montana in Missoula, MT and an MSc in Software Design and Development from the University of St. Thomas in St. Paul, MN. Mitch can be contacted at <a href="bessermt@yahoo.com">bessermt@yahoo.com</a>. 
