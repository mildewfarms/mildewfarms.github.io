<HTML>
<HEAD>
<TITLE>Patterns of Thinking</TITLE>
</HEAD><BODY>
<h2>Patterns of Thinking</h2>
<H3>Miro Samek</H3>

<P>Several years ago, I attended an &#147;Object-Oriented Analysis and Design&#148; training course. The instructor began with brushing up on the fundamental OO concepts. When explaining inheritance, the instructor spontaneously compared inheriting from a class to passing traits from parents to the offspring in a family. At first, this &#147;family tree&#148; metaphor seemed to make a lot of sense and most attendees nodded approvingly. However, when the instructor discussed inheritance further, she mentioned that inheritance establishes the &#147;is a&#148; (is-a-kind-of) relationship between the child and the parent classes, and that the child class has all the attributes and behaviors of the parent class, but is typically more specialized. At this point, one attendee raised an objection that he didn&#146;t have all of his father&#146;s attributes and behaviors and he didn&#146;t feel like a more specialized version of his father. For example, he had no coronary disease &#147;attribute&#148;, didn&#146;t support the smoking &#147;operation&#148;, and didn&#146;t feel fully substitutable for his father (or his grandmother, for that matter). Consequently, the Liskov Substitution Principle didn&#146;t seem to apply to a family tree, as it should to a class hierarchy.<P>

<P>Apparently, the &#147;family tree&#148; metaphor wasn&#146;t working very well, although it evidently inspired much of the terminology used in OOP (parent, child, ancestor, sibling, class family, etc.). I don&#146;t recall exactly how the instructor helped to resolve the confusion, but I do remember that she didn&#146;t offer any better analogy for class inheritance. Most probably, the instructor made this analogy up &#147;on the fly&#148; without paying much attention to the facts, but the other possibility is that the inaccurate analogy reflected her way of thinking about inheritance. Both possibilities offer interesting insights. First, the story indicates that analogies and metaphors appear in software quite frequently and often spontaneously, but their role is usually underestimated. This is unfortunate, because analogies and metaphors, when chosen correctly, may help students climb the learning curve more quickly. Conversely, severe difficulties arise when the analogies chosen are incomplete, inaccurate, or irrelevant. The second insight from the story is that analogies and metaphors offer a unique way to quickly &#147;look&#148; into somebody&#146;s mind &#151; an ability that is critical in the software business.<P>

<P>Coming back to the unfortunate &#147;family tree&#148; metaphor, I was included in a small group of attendees that discussed this matter during a break. In a short brainstorming session, we came up with a much better metaphor, based on the classification of living organisms in biology. This &#147;biological classification&#148; metaphor had no problems explaining correctly the &#147;is a&#148; relationship between classes, and what it means that a subclass is a more specialized version of the superclass. For instance, a class <B>RedRose</B> is a kind of <B>Flower</B>, and a <B>Flower</B> is a kind of <B>Plant</B>. <B>RedRose</B> has all the attributes of a <B>Flower</B> as well as of a <B>Plant</B>, but is more specialized. When you have a collection of <B>Flowers</B>, some of them may very well be <B>RedRoses</B>, because it always makes sense to substitute a <B>RedRose</B> for a <B>Flower</B>. The &#147;biology classification&#148; metaphor provides countless more examples that illustrate virtually all the nuances and concepts encountered in class inheritance, including polymorphism. Such a metaphor is more valuable than you might initially think, because it establishes the correct <I>pattern of thinking</I> about the fundamental software concept.<P>

<h3>System Metaphor and Conceptual Integrity</h3>
<P>Metaphors and analogies have been widely used in software for decades. It is not an exaggeration to say that the venerable desktop metaphor, the spreadsheet metaphor, or more recently the shopping-cart metaphor have literally changed civilization. All of these are examples of <I>system metaphors</I>, that is, metaphors that provide a general idea of how a whole system works. The system metaphor has been subject of many studies, books, and papers.[1] Recently, eXtreme Programming (XP) has brought the system metaphor once again to the attention of developers by elevating it to a key programming practice.[2]<P>

<P>Contrary to widespread beliefs, the primary intention of the desktop, the spreadsheet, or the shopping-cart metaphor is not to exactly imitate office furniture, accounting pads, or physical aisles in a supermarket. Indeed, users don&#146;t expect the computer screen to be exactly as hard to erase or change as real paper is, or the virtual aisles of an online store to be exactly as cluttered and hard to navigate as real ones. The function of a system metaphor is not a strict mapping between the source and target domains. Rather, the critically important role of a system metaphor is in establishing a consistent user&#146;s <I>conceptual model</I>, which represents what the user is likely to think, and how the user is likely to respond.<P>

<P>As observed in XP however, a consistent conceptual model is helpful not just for the end-users; it is invaluable for software developers because it provides the most difficult part of the design &#151; the coherent architecture. With such a model in hand, designers don&#146;t need to invent potentially inconsistent policies and behaviors &#151; they can simply consult the real-life model to see how it solves various problems. The system metaphor thus serves as an objective arbiter in resolving various design conflicts and ultimately guards the <I>conceptual integrity</I> of the design.<P>

<h3>Metaphors and Learning</h3>
<P>While the system metaphor can vastly benefit software developers, it is mostly a side effect of the conceptual integrity, which is then reflected in better software structure. Other types of metaphors and analogies specifically aimed at guiding the learning process and improving the understanding of new concepts can benefit software developers much more directly.<P>

<P>In order to appreciate how metaphors influence learning new software concepts, it is interesting to realize how humans organize and modify their knowledge. When people learn new things, they automatically try to map new concepts to familiar ones in the spontaneous process of &#147;making analogies&#148;. A problem occurs when these spontaneous analogies are incorrect. The new knowledge interferes with the old knowledge (learning interference), and the learning process is more difficult than it would be if the individual did not have the conflicting knowledge in the first place.<P>

<P>For example, a study on retraining procedure-oriented developers in object-oriented programming [3] shows clearly that software developers are more likely to recall, rather than forget their existing knowledge. This research reveals that attempts to map familiar procedural concepts often resulted in inaccurate analogies, which increased the time it took the learners to make effective use of the object-oriented development model. The study further emphasized the role of the instructor in helping the learners make correct analogies. Instructors, who are aware of any incorrect analogies their students make, can guide the students toward understanding which aspects in the analogies are correct and which are incorrect. It&#146;s much better for the instructor to offer correct analogies explicitly, rather than to rely on the spontaneous analogies made up (consciously or subconsciously) by the students. It is in this spirit that I offered the mapping between procedural and object-oriented programming in an earlier installment of this column [4]. Similarly, in the June installment [5], I showed that many familiar OOP concepts have their counterparts in hierarchical state machines.<P>

<P>The benefits of using such &#147;concept metaphors&#148; for improving the learning process apply more generally than to learning entirely new concepts. Metaphors and analogies have a unique capacity to shed new light on already known ideas and thus can help you discover new aspects of already familiar concepts. For example, the &#147;assertions as fuses&#148; analogy [6] offers a novel view of assertions as a controlled-damage protection mechanism, which complements the &#147;assertions as contracts&#148; metaphor that underlies the design by contract methodology.<P>

<h3>Mining Concept Metaphors</h3>
<P>In response to the June installment of this column dedicated to hierarchical state machines [5], a reader wrote me: <I>&#147;while [traditional] state machines supply an abstract representation of a system in the real world, the concept of states within states does not correspond to any reality.&#148;</I> At first this statement struck me as being exactly backwards, because I always thought that the only &#147;real&#148; reactive systems correspond to hierarchical state machines, of which the flat (non-hierarchical) versions are merely special, somewhat degenerated corner cases. After a while, I realized that probably the reader&#146;s mental model of a state machine and mine were based on different metaphors. Metaphors it must be, since only through analogies and metaphors can abstract software concepts correspond to any &#147;reality&#148; and thus gain meaning for us. The whole discussion of what it means to &#147;understand&#148; a software concept borders on philosophy. However, given that analogies and metaphors can be so beneficial for understanding and mastering new concepts, the pragmatic question is: What is a good metaphor for a state machine?<P>

<P>Just as in the case of the &#147;biological classification&#148; metaphor for class inheritance, a good strategy for mining concept metaphors seems to be to look for examples of the concept successfully applied in existing systems (e.g., biological classification as an example of class taxonomy). The source domain for the abstract concept metaphor, such as state machine, is most likely to be science, and not the familiar physical objects or everyday activities, as in the case of the much less abstract system metaphor. Therefore, the problem of finding a good metaphor for the state machine concept boils down to finding a good example of stateful behavior in other branches of science. Such behavior is fundamental and pervasive in the microscopic world of elementary particles, atoms, and molecules, as explained by the laws of quantum mechanics [7].<P>

<P>A possible critique of the &#147;quantum metaphor&#148; for state machines might be that most programmers are not familiar enough with the source domain &#151; contemporary physics in this case. However, the physics background necessary to benefit from the metaphor is really at the level of high-school textbooks and popular science articles. I believe that most programmers have heard about electrons, atoms, quantum numbers, quantum states, or quantum leaps.<P>

<P>If you make the effort to understand the basic principles governing the microscopic world, the &#147;quantum metaphor&#148; might turn out to be very valuable to you, because it has a very rich structure and correctly explains many specific aspects of state machines (all of these are criteria that Kim Halskov Madsen proposed for choosing successful metaphors) [1]. Perhaps the most interesting is the observation that virtually all quantum states are hierarchically decomposed (degenerated in physics language). Degeneration is always an indication of some <I>symmetry</I> of the system. For example, the degeneration of angular momentum substates of an atom comes from the spherical symmetry of the atom. Simple experiments, such as subjecting atoms to magnetic fields lower the symmetry, and partially remove the degeneration allowing us to &#147;see&#148; the state hierarchy (Zeeman effect). The concept of nested states corresponds thus to physical reality and is not just theoretical.<P>

<P>I found the quantum metaphor very valuable, and in fact, it has shaped my understanding of state machines. As always with a good analogy, the quantum metaphor explains the fundamental character of state nesting and its function in capturing and representing the symmetry of the system. This observation alone (i.e., the link between state nesting and the symmetry of a system) is already a sufficient payoff from the metaphor. Yet, there is so much more to be learned from the quantum analogy. For instance, the mechanism of quantum leaps provides excellent insights into the true role of the run-to-completion (RTC) processing model in state machines. Likewise, the mechanism of virtual particle exchange provides a very good model of communication among concurrent state machines (active object computing model).<P>

<P>The main point here is that in contrast to system metaphors, &#147;concept metaphors&#148; involve thinking that is more abstract and typically draws from science. In other words, don&#146;t sign off on all of the stuff that you once learned in math, biology, chemistry, or physics, because it can come in handy in your software work. The results might surprise you.<P>

<h3>Metaphors and Social Intelligence</h3>
<P>The beneficial impact of metaphors on improving communication within software teams has already been observed for the system metaphor. As a natural byproduct, the source domain of such a metaphor provides a common system of names for objects and the relationships among them. This can become jargon in the best sense: a powerful, specialized, shorthand vocabulary for all stakeholders of a software project.<P>

<P>Actual case studies indicate, however, that while metaphorical representations indeed dominate software discussions, system metaphors are not the ones most commonly applied. The most frequently used are anthropomorphic comparisons known as na&iuml;ve psychology [8]. Developers often speak in terms of what a software component &#147;needs&#148;, &#147;knows&#148;, &#147;is trying to do&#148;, or &#147;thinks&#148; is happening. These anthropomorphic metaphors (identified in vast majority of all spoken representations in the Herbsleb&#146;s study) strike many as sloppy and imprecise. Dijkstra, for example, has gone so far as to propose that computer science faculty implement a system of fines to stamp out such sloppiness among students.<P>

<P>However, the new research suggests that instead of fighting the &#147;sloppy&#148; metaphorical representations, software practitioners and teachers could use them to their advantage. Na&iuml;ve psychology seems to be a special kind of metaphor, in that it exploits a specific cognitive capability that has evolved to handle the increasingly complex social interactions in early human societies [9]. These natural skills, which develop without any special instruction in all intact humans, match many tasks encountered in software development. In designing or understanding a complex, multi-component software system, it is extremely important to be able to keep track of what state each component is in, what it is &#147;trying&#148; to do, what it &#147;knows&#148; about the rest of the system, how is it likely to behave, how is it likely to fail, and so on. The skills of na&iuml;ve psychology seem to allow a software developer to keep track of this sort of information with little effort, because of a built-in capability known as social intelligence.<P>

<P>The pervasive use of na&iuml;ve psychology in virtually all software discussions, although certainly not part of any standard software engineering curriculum, indicates how critical a role social intelligence plays in collaborative software development. Perhaps nowhere is it more evident than in pair programming advocated by XP. In pair programming, software is created in small incremental steps, as ideas move back and forth between the more stable media such as  a whiteboard or a computer screen, and the transitory verbal medium of conversation between the two developers. The point is that most of the critical creative work occurs during these periods of discussion when the primary representation is just the spoken language. If you&#146;ve ever tried to pair-program, you must have noticed how much of the discussion revolves around anthropomorphic representations and role-playing. By insisting on informal, high-bandwidth, face-to-face communication between pairs of developers, XP makes a much better use of the social intelligence than other &#147;heavyweight&#148; methodologies. Indeed, due to engaging the social intelligence, a pair of programmers typically creates more code and better code than the same two developers working separately.<P>

<P>Another way of tapping the potential of social intelligence is to employ programming paradigms and techniques that offer more opportunities to use na&iuml;ve psychology than others. For example, the object-oriented method encourages partitioning the problem into a specialized, encapsulated &#147;society&#148; of objects, which collaborate on the common task. Some visual representations such as UML sequence diagrams, lend themselves to na&iuml;ve psychological discussions. More specific to embedded software, the active object computing model [7] makes very good use of the social intelligence, because applications based on autonomous stateful active objects (actors) closely resemble human organizations [10]. There is some growing evidence that such programming models and techniques reduce the need for clarification in the discussion of design ideas.<P>

<h3>An Adjunct to Existing Methods</h3>
<P>Most software engineering tasks are sufficiently complex that many kinds of methods and many specific cognitive abilities of the brain must be used in turn, or better yet, simultaneously. For example, the particular value of visual languages (such as UML), lies in tapping the potential of high-bandwidth &#147;spatial intelligence&#148;, as opposed to &#147;lexical intelligence&#148; used with textual information. While clearly not all visual representations are useful for all purposes, when visualization matches a task well, the visual processing capabilities of the brain allow a tremendous amount of information to be conveyed in compact form. Moreover, this effect is not just limited to faster information transfer; the quality of the thinking has improved [12].<P>

<P>In this context, metaphorical representations based on na&iuml;ve psychology, are a very important adjunct to visualization techniques, because they make explicit use of another powerful cognitive capability of the human brain identified as the &#147;social intelligence&#148;. In this sense, the old saying &#147;a picture is worth a thousand words&#148; can be modified to &#147;a metaphor is worth a thousand words&#148;.<P>

<P>Other types of metaphors (concept metaphors and system metaphors to some degree) seem to complement the design-pattern approach to software development. Design patterns excel in capturing solutions to recurring software problems, but they haven&#146;t been able to capture the patterns of thinking that experts use. Metaphors and analogies offer a unique view into experts&#146; minds and convey the particular way the experts see and understand the problem.<P>

<h3>A Word of Caution</h3>
<P>The special cognitive abilities of the human brain, such as the &#147;social intelligence&#148; (or the &#147;spatial intelligence&#148;, for that matter) didn&#146;t evolve to solve software problems. Analogies and metaphors (or visualization techniques) are just a trick to take advantage of these powerful &#147;hardware accelerators&#148; of the brain to solve different problems than those for which they were designed. The catch is that it might not work with all people, or might work differently in different people. If the &#147;quantum metaphor&#148; for state machines doesn&#146;t do the trick for you, move on, and try to understand hierarchical state machines some other way. One excellent explanation how state hierarchy arises naturally in every non-trivial reactive system appeared as a point/counterpoint debate between Steve Mellor and Bran Selic, published in the March 2000 issue of the ESP magazine [13].<P>

<h3>End Around Check</h3>
<P>I&#146;m sure that you have used system metaphors, concept metaphors, or na&iuml;ve psychology before, but perhaps you didn&#146;t fully realize the fact. I hope that this article will make you more aware of the different roles metaphors and analogies can play in software development, and that there is more to it than just the venerable system metaphor. I hope you start paying more attention to how you and others use metaphors with the goal of making better use of the natural god-given abilities built into your brain. I hope you start thinking more about metaphors, learn their limits, and remember their critical aspects. Perhaps you will start collecting metaphors?<P>

<P>In doing my online research for this article, I was amazed at the number and quality of publications related to metaphors in software. It seems that a slow, but noticeable groundswell is developing in favor of metaphorical thinking in software. In fact, it appears that metaphors and analogies have the potential to one day become as hot a topic as design patterns are today.<P>

<P>I&#146;d like to close with the quotation from Stefan Banach, a Polish mathematician who founded modern functional analysis and made major contributions to the theory of topological vector spaces. He wrote: <I>&#147;Good mathematicians see analogies between theorems and theories. The very best ones see analogies between analogies.&#148;<P>
</I>

<h3>References</h3>
<P>[1]  Kim Halskov Madsen. &#147;A Guide to Metaphorical Design&#148; <I>Communications of the ACM</I>, December 1994.<P>
<P>[2]  Kent Beck. <I>eXtreme Programming Explained</I>, Addison-Wesley, 2000.<P>
<P>[3]  Mary L. Manns and H. James Nelson. &#147;Retraining Procedure-Oriented Developers: An Issue of Skill Transfer&#148;, <I>Journal of Object-Oriented Programming</I>, Vol. 9, No. 7, 1996.<P>
<P>[4]  Miro Samek. &#147;OOP in C&#148; sidebar in &#147;Who Moved my State?&#148;, <I>C/C++ Users Journal</I>, April 2003.<P>
<P>[5]  Miro Samek. &#147;D&eacute;j&agrave; Vu&#148;, <I>C/C++ Users Journal</I>, June 2003.<P>
<P>[6]  Miro Samek. &#147;An Exception or a Bug?&#148;, <I>C/C++ Users Journal</I>, August 2003.<P>
<P>[7]  Miro Samek. &#147;Quantum Programming for Embedded Systems: Toward a Hassle-Free Multithreading&#148;, <I>C/C++ Users Journal</I>, March 2003.<P>
<P>[8]  James D. Herbsleb. &#147;Metaphorical Representation in Collaborative Software Engineering&#148;, Available online at &lt;<a href="http://www.cs.cmu.edu/~jdh/collaboratory/research_papers/WACC_99.pdf">www.cs.cmu.edu/~jdh/collaboratory/research_papers/WACC_99.pdf</a>&gt;.<P>
<P>[9]  Nicholas Humphrey. <I>The Inner Eye: Social Intelligence in Evolution</I>, Oxford Paperbacks, 2002.<P>
<P>[10]  Arthur Allen. &#147;Actor-Based Computing: Vision Forestalled, Vision Fulfilled&#148; &lt;<a href="http://www.charis.com/documents/agent98.pdf">www.charis.com/documents/agent98.pdf</a>&gt;.<P>
<P>[11]  David Harel. &#147;Biting the Silver Bullet: Toward a Brighter Future for System Development&#148;, <I>Computer</I>, January 1992, available online at &lt;<a href="http://www.wisdom.weizmann.ac.il/~dharel/SCANNED.PAPERS/BitingTheSilverBullet.pdf">www.wisdom.weizmann.ac.il/~dharel/SCANNED.PAPERS/BitingTheSilverBullet.pdf</a>&gt;.<P>
[12]  Steve Mellor and Bran Selic. Point/Counterpoint, <I>Embedded Systems Programming Journal</I>, March 2000). <BR>
&lt;<a href="http://www.embedded.com/2000/0003/0003feat1.htm">www.embedded.com/2000/0003/0003feat1.htm</a>&gt; and &lt;<a href="http://www.embedded.com/2000/0003/0003feat2.htm">www.embedded.com/2000/0003/0003feat2.htm</a>&gt;. <P>

<hr>
<i><B>Miro Samek</B> is the author of </I>Practical Statecharts in C/C++: Quantum 
Programming for Embedded Systems<I>, CMP Books, 2002. He is the lead software 
architect at IntegriNautics Corp. (Menlo Park, CA) and a consultant to industry. 
Miro previously worked at GE Medical Systems, where he has developed safety-critical, 
real-time software for diagnostic imaging X-ray machines. He earned his Ph.D. 
in nuclear physics at GSI (Darmstadt, Germany) where he conducted heavy-ion experiments. 
Miro welcomes feedback and can be reached at <a href="mailto:miro@quantum-leaps.com">miro@quantum-leaps.com</a>.</i>
</HTML>
