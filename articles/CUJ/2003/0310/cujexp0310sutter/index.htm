<html>
<head>
<title>Trip Report: April 2003</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
</head>

<body bgcolor="#FFFFFF" text="#000000">
<h2>Trip Report: April 2003</h2>
<h3>by Herb Sutter</h3>
<p>In this column, I want to deliver a trip report on the April 2003 C++ Standards 
  meeting. Whereas the big news in the October 2002 meeting was that the first 
  two extensions (<b>tuple</b> [1] and <b>function</b> [2], see also [3]) were 
  adopted for the standard library extensions technical report, in April no fewer 
  than 10 more were added. What were they, and which ones might you particularly 
  care about? That's this month's topic.</p>
<h3>Background and Overview</h3>
<p>The C++ Standards meeting (ISO WG21, ANSI J16) was hosted by ACCU in Oxford, 
  UK, from April 6-11, 2003. The C++ committee meets twice a year, in the spring 
  and fall, and has been working on four major work items:</p>
<ul>
  <li><i>Defect Reports (DRs).</i> Processing DRs and answering questions about 
    the existing standard. </li>
  <li><i>Performance Technical Report (Performance TR).</i> The Performance TR 
    is focused primarily on hardware issues and embedded systems work, but also 
    on C++ implementability (for example, how to implement and use exceptions 
    for best performance). The Performance TR is now essentially done and ready 
    for the final stages of ISO balloting to become an official technical report.</li>
  <li><i>Library Technical Report (Library TR).</i> The Library TR is a vehicle 
    to add new functionality to the standard library, and is limited to considering 
    only those additions that don't require any extensions to the core language. 
    This TR is intended to feed into C++0x, the next revision of C++ currently 
    being developed. Today, working implementations of most parts are available 
    via Boost [5] and, as of this writing (Summer 2003), at least two major standard 
    library implementers that I know of are tracking the TR and have started work 
    to create their own implementations of all or part of it. Bottom line: The 
    facilities in this TR are serious, real, and en route to your desktop. I've 
    covered two of them already in recent installments of this column ([1], [2], 
    [3]) and will cover more in the future.</li>
  <li><i>Evolution WG.</i> The C++ Evolution Working Group is considering additional 
    items not covered by the Library TR because they would involve core language 
    changes. The EWG's goal at this meeting was to consider a batch of concrete 
    proposals, but not to accept any yet at this meeting.</li>
</ul>
<p> Note the division of work between the Library TR and the Evolution WG: The 
  former deals with library-only extensions that do not require additional language 
  support, and the latter with proposals that require language extensions to do 
  well. Some items are being accepted in the Library TR as &quot;hackaround&quot; 
  extensions that work around today's C++ language limitations. If and when the 
  EWG closes those holes with better language extensions, the library hackarounds 
  can be refined or abandoned.</p>
<p> The above list does not mention the first Technical Corrigendum (TC1), the 
  first &quot;service pack&quot; to the existing standard, because the technical 
  work on that set of corrections was completed two years ago and since then has 
  just been winding its way through the ISO red tape.</p>
<p> For more details more about the history and future of the C++ Standards process 
  and how these pieces interact, see [4].</p>
<h3>News From This Meeting</h3>
<p>Here's what happened in Oxford, in roughly chronological order.</p>
<p> First, <i>Technical Corrigendum 1 (TC1) was approved by ISO</i> earlier this 
  year. It will be published as an updated edition of the Standard, with all changes 
  applied. (The list of diffs from C++98 will also be available, possibly freely.) 
  The amended standard with the TC1 corrections applied to it will be known informally 
  as &quot;C++03&quot; (not to be confused with the next-generation C++0x work 
  going on right now for the next major revision of the standard), and formally 
  as ISO 14882:2003(E).<br>
  <br>
  <i>The Performance TR is complete</i> and ready for ISO balloting. As a result 
  of the Oxford meeting, the final text of the Performance TR was approved and 
  will soon be transmitted to ISO for balloting. Publication will be delayed a 
  little because ISO administrative rules require two more ballots, each of which 
  takes at least several months to prepare and conduct, but the technical work 
  on the document is done.</p>
<p> <i>The <b>export</b> feature was reaffirmed</i> and continues to be a required 
  part of ISO C++. At this meeting, I and Tom Plum brought a paper presenting 
  reasons why in the future the committee might consider removing the <b>export</b> 
  as a required part of the language. This was discussed in depth, and the committee 
  decided to retain <b>export</b>. In particular, it is hoped that over the next 
  few years we will be able to see more real-world experience with <b>export</b>-enabled 
  compilers based on EDG's front end to evaluate the true usefulness of the feature 
  for templates in production code. [6]</p>
<p> The biggest news is that <i>the Library TR was expanded from 2 to 12 approved 
  proposals.</i> At the previous meeting (October 2002), the first two library 
  extensions were approved for the Library TR. At this meeting, 10 new library 
  extensions were approved. You can get at them via the C++ committee web site 
  (for this and other useful standards-related links, see [7]). In order by paper 
  number, they are:</p>
<p>N1422, &quot;A Proposal to Add Mathematical Special Functions to the C++ Standard 
  Library&quot;<br>
  N1424, &quot;A Proposal to add Type Traits to the Standard Library&quot;<br>
  N1429, &quot;A Proposal to add Regular Expression to the Standard Library&quot;<br>
  N1432, &quot;A Proposal to Add an Enhanced Member Pointer Adaptor to the Library 
  Technical Report&quot;<br>
  N1450, &quot;A Proposal to Add General Purpose Smart Pointers to the Library 
  Technical Report&quot;<br>
  N1452, &quot;A Proposal to Add an Extensible Random Number Facility to the Standard 
  Library&quot;<br>
  N1453, &quot;A proposal to add a reference wrapper to the standard library&quot;<br>
  N1454, &quot;A uniform method for computing function object return types&quot;<br>
  N1455, &quot;A Proposal to Add an Enhanced Binder to the Library Technical Report&quot;<br>
  N1456, &quot;A Proposal to Add Hash Tables to the Standard Library (revision 
  4)&quot;</p>
<p> These proposals have been approved for inclusion in the Library TR draft working 
  document, but of course that document itself is still in an early draft form 
  and everyone understands that it's subject to further refinement and adjustment. 
  Most of the facilities were accepted with a short list of known &quot;tweaks&quot; 
  or changes that need to be made before they're in final form ready for official 
  publication.</p>
<p> These proposals, together with the two already accepted, form the bulk of 
  the first library technical report. Now, this doesn't mean that you should hold 
  back from submitting new proposals! New library proposals are still welcome 
  and will continue to be considered, either for a second library technical report 
  or for the C++0x standard itself.</p>
<p> Finally, one question that arose again at the April meeting was the simple 
  but profound: &quot;Which namespace will the Library TR extensions live in?&quot; 
  The sentiment at the meeting was that they will likely be declared in a nested 
  namespace named <b>std::tr1</b>.</p>
<h3>Lifetime Issues: Stability versus Growth</h3>
<p>So here we are in 2003 making changes to Standard C++. We have a Library TR 
  as a vehicle to formalize new standard library additions (relatively) quickly, 
  and the main C++0x work as the primary vehicle to create Version 2.0 of the 
  C++ Standard and able to handle both language and library extensions.</p>
<p> Fine and dandy. The question is, what's the right balance between stability 
  and growth? Consider:</p>
<ul>
  <li>Users want their languages to stay the same: An important language like 
    C++ should be stable and thus suitable for major investments.</li>
  <li>Users want their languages to change: Dead languages can afford to fossilize, 
    whereas useful and living languages need to evolve over time.</li>
</ul>
<p> The C++ committee is trying to address both of those needs. For one thing, 
  you can see above the emphasis on aggressive extension to the standard library, 
  rather than to the core language. Library extensions don't add complexity to 
  an admittedly already complex language, and they don't add intellectual overhead 
  either because people who don't care about the new library extensions can pretty 
  much just blissfully ignore them (unless they're maintaining someone else's 
  code that uses them, of course).</p>
<p> Even in the core language, however, changes and extensions are not being considered 
  willy-nilly in a mad rush to see what cool new thing can be grafted on next. 
  Although at times it may seem like there is a long list of potential changes 
  on the Evolution WG's list, only a handful are serious front-running candidates 
  for standardization while many others are nice-to-haves that are less likely 
  to be considered appropriate for widespread standardized use. And every proposal 
  has to be explicit about what impact, if any, it would have on the existing 
  language, and on how it interacts with existing language features.</p>
<p> Only time will tell where the committee really draws the line for C++0x extensions, 
  but an appropriately conservative approach still holds the day as of this writing. 
  Next time: A closer look at one of the new Library TR proposals. Stay tuned.</p>
<h3>References</h3>
<p>[1] H. Sutter. &quot;Tuples&quot; 
  (C/C++ Users Journal, 21(6), June 2003).<br>
  [2] H. Sutter. &quot;Generalized Function 
  Pointers&quot; (C/C++ Users Journal, 21(8), August 2003).<br>
  [3] H. Sutter. &quot;Generalizing Observer&quot; 
  (C/C++ Users Journal, 21(9), September 2003).<br>
  [4] H. Sutter. &quot;The New C++&quot; 
  (C/C++ Users Journal, 20(2), February 2002).<br>
  [5] <a href="http://www.boost.org">http://www.boost.org</a><br>
  [6] <a href="http://www.edg.com">http://www.edg.com</a><br>
  [7] <a href="http://www.gotw.ca/iso">http://www.gotw.ca/iso</a></p>
</body>
</html>
