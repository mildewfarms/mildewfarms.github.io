<HTML>   
     <HEAD>
<TITLE>February 2003/Using Templates in Practice</TITLE></HEAD>
<BODY BACKGROUND="" BGCOLOR="#FFFFFF" TEXT="#000000">
<H2 ALIGN="center">Using Templates in Practice</H2>
<H3 ALIGN="center">David Vandevoorde and Nicolai M. Josuttis</H3>

<HR>

<p><b>Chapter 6 (pages 61-86) taken from the book <i>C++ Templates</i> by Vandevoorde &amp; Josuttis.   &copy; 2002 Pearson Education Inc. Reproduced by permission of Pearson Education,  Inc.  All rights reserved.</b></p>

<p>Template code is a little different from ordinary code. In some ways templates lie somewhere between macros and ordinary (nontemplate) declarations. Although this may be an oversimplification, it has consequences not only for the way we write algorithms and data structures using templates, but also for the day-to-day logistics of expressing and analyzing programs involving templates.</p>
<p>In this chapter we address some of these practicalities without necessarily delving into the technical details that underlie them. Many of these details are explored in Chapter 10. To keep the discussion simple, we assume that our C++ compilation systems consist of fairly traditional compilers and linkers (C++ systems that don't fall in this category are quite rare).</p>

<H3>6.1 The Inclusion Model</H3>

<p>There are several ways to organize template source code. This section presents the most popular approach as of the time of this writing: the inclusion model.</p>

<H4>6.1.1 Linker Errors</H4>

<p>Most C and C++ programmers organize their nontemplate code largely as follows:</p>

<UL>
<LI>Classes and other types are entirely placed in <i>header files</i>. Typically, this is a file with a <b>.hpp</b> (or <b>.H</b>, <b>.h</b>, <b>.hh</b>, <b>.hxx</b>) filename extension.</LI>
<LI>For global variables and (noninline) functions, only a declaration is put in a header file, and the definition goes into a so-called <i>dot-C file</i>. Typically, this is a file with a <b>.cpp</b> (or <b>.C</b>, <b>.c</b>, <b>.cc</b> or <b>.hxx</b>) filename extension.</LI>
</UL>

<p>This works well: It makes the needed type definition easily available throughout the program and avoids duplicate definition errors on variables and functions from the linker.</p>
<p>With these conventions in mind, a common error about which beginning template programmers complain is illustrated by the following (erroneous) little program. As usual for &quot;ordinary code,&quot; we declare the template in a header file:</p>

<pre>
<i>// basics/myfirst.hpp</i>

#ifndef MYFIRST_HPP
#define MYFIRST_HPP

<i>//declaration of template</i>
template &lt;typename T&gt;
void print_typeof (T const&amp;);

#endif<i> // MYFIRST_HPP</i>
</pre>

<p><b>print_typeof()</b> is the declaration of a simple auxiliary function that prints some type information. The implementation of the function is placed in a dot-C file:</p>

<pre>
<i>// basics/myfirst.cpp</i>    

#include &lt;iostream&gt;    
#include &lt;typeinfo&gt;    
#include &quot;myfirst.hpp&quot;    

<i>// implementation/definition of template</i>
template &lt;typename T&gt;
void print_typeof (T const&amp; x)
{
    std::cout &lt;&lt; typeid(x).name() &lt;&lt; std::endl;
}
</pre>

<p>The example uses the <b>typeid</b>  operator to print a string that describes the type of the expression passed to it (see Section 5.6 on page 58).</p>
<p>Finally, we use the template in another dot-C file, into which our template declaration is <b>#include</b>d:</p>

<pre>
<i>// basics/myfirstmain.cpp</i>
#include &quot;myfirst.hpp&quot;

<i>// use of the template</i>
int main()
{
    double ice = 3.0;
    print_typeof(ice); <i>//call function template for type</i> double
}
</pre>

<p>A C++ compiler will most likely accept this program without any problems, but the linker will probably report an error, implying that there is no definition of the function <b>print_typeof()</b>. </p>
<p>The reason for this error is that the definition of the function template <b>print_typeof()</b> has not been instantiated. In order for a template to be instantiated, the compiler must know which definition should be instantiated and for what template arguments it should be instantiated. Unfortunately, in the previous example, these two pieces of information are in files that are compiled separately. Therefore, when our compiler sees the call to <b>print_typeof()</b> but has no definition in sight to instantiate this function for <b>double</b>, it just assumes that such a definition is provided elsewhere and creates a reference (for the linker to resolve) to that definition. On the other hand, when the compiler processes the file <b>myfirst.cpp</b>, it has no indication at that point that it must instantiate the template definition it contains for specific arguments.</p>

<H4>6.1.2 Templates in Header Files</H4>

<p>The common solution to the previous problem is to use the same approach that we would take with macros or with inline functions: We include the definitions of a template in the header file that declares that template. For our example, we can do this by adding</p>

<pre>
#include &quot;myfirst.cpp&quot;
</pre>

<p>at the end of <b>myfirst.hpp</b> or by including <b>myfirst.cpp</b> in every dot-C file that uses the template. A third way, of course, is to do away entirely with <b>myfirst.cpp</b>  and rewrite <b>myfirst.hpp</b>  so that it contains all template declarations <i>and </i>template definitions:</p>

<pre>
<i>// basics/myfirst2.hpp</i>

#ifndef MYFIRST_HPP
#define MYFIRST_HPP

#include &lt;iostream&gt;
#include &lt;typeinfo&gt;

<i>// declaration of template</i>
template &lt;typename T&gt;
void print_typeof (T const&amp;);

<i>// implementation/definition of template</i>
template &lt;typename T&gt;
void print_typeof (T const&amp; x)
{
    std::cout &lt;&lt; typeid(x).name() &lt;&lt; std::endl;
}

#endif<i> // MYFIRST_HPP</i>
</pre>

<p>This way of organizing templates is called the <i>inclusion model</i>. With this in place, you should find that our program now correctly compiles, links, and executes.</p>
<p>There are a few observations we can make at this point. The most notable is that this approach has considerably increased the cost of including the header file <b>myfirst.hpp.</b> In this example, the cost is not the result of the size of the template definition itself, but the result of the fact that we must also include the headers used by the definition of our template &#151; in this case <b>&lt;iostream&gt;</b> and <b>&lt;typeinfo&gt;</b>. You may find that this amounts to tens of thousands of lines of code because headers like <b>&lt;iostream&gt;</b> contain similar template definitions.</p>
<p>This is a real problem in practice because it considerably increases the time needed by the compiler to compile significant programs. We will therefore examine some possible ways to approach this problem in upcoming sections. However, real-world programs quickly end up taking hours to compile and link (we have been involved in situations in which it literally took days to build a program completely from its source code).</p> 
<p>Despite this build-time issue, we do recommend following this inclusion model to organize your templates when possible. We examine two alternatives, but in our opinion their engineering deficiencies are more serious than the build-time issue discussed here. They may have other advantages not directly related to the engineering aspects of software development, however.</p>
<p>Another (more subtle) observation about the inclusion approach is that noninline function templates are distinct from inline functions and macros in an important way: They are not expanded at the call site. Instead, when they are instantiated, they create a new copy of a function. Because this is an automatic process, a compiler could end up creating two copies in two different files, and some linkers could issue errors when they find two distinct definitions for the same function. In theory, this should not be a concern of ours: It is a problem for the C++ compilation system to accommodate. In practice, things work well most of the time, and we don't need to deal with this issue at all. For large projects that create their own library of code, however, problems occasionally show up. A discussion of instantiation schemes in Chapter 10 and a close study of the documentation that came with the C++ translation system (compiler) should help address these problems.</p>
<p>Finally, we need to point out that what applies to the ordinary function template in our example also applies to member functions and static data members of class templates, as well as to member function templates.</p>

<H3>6.2 Explicit Instantiation</H3>

<p>The inclusion model ensures that all the needed templates are instantiated. This happens because the C++ compilation system automatically generates those instantiations as they are needed. The C++ standard also offers a construct to instantiate templates manually: the <i>explicit instantiation directive</i>.</p>

<H4>6.2.1 Example of Explicit Instantiation</h4>

<p>To illustrate manual instantiation, let's revisit our original example that leads to a linker error (see page 62). To avoid this error we add the following file to our program:</p>

<pre>
<i>// basics/myfirstinst.cpp</i>

#include &quot;myfirst.cpp&quot;
<i>// explicitly instantiate </i>print_typeof()<i> for type </i>double
template void print_typeof&lt;double&gt;(double const&amp;);
</pre>

<p>The explicit instantiation directive consists of the keyword <b>template</b> followed by the fully substituted declaration of the entity we want to instantiate. In our example, we do this with an ordinary function, but it could be a member function or a static data member. For example:</p>

<pre>
<i>// explicitly instantiate a constructor of </i>MyClass&lt;&gt; <i>for</i> int
template MyClass&lt;int&gt;::MyClass();

<i>// explicitly instantiate a function template </i>max()<i> for </i>int
template int const&amp; max (int const&amp;, int const&amp;);
</pre>

<p>You can also explicitly instantiate a class template, which is short for requesting the instantiation of all its instantiatable members. This excludes members that were previously specialized as well as those that were already instantiated:</p>

<pre>
<i>// explicitly instantiate class </i>Stack&lt;&gt;<i> for </i>int <i>:</i>
template class Stack&lt;int&gt;;

<i>// explicitly instantiate some member functions of </i>Stack&lt;&gt;<i> for strings:</i>
template Stack&lt;std::string&gt;::Stack();
template void Stack&lt;std::string&gt;::push(std::string const&amp;);
template std::string Stack&lt;std::string&gt;::top();

<i>// ERROR: can't explicitly instantiate a member function of a</i>
<i>//        class that was itself explicitly instantiated:</i> 

template Stack&lt;int&gt;::Stack();
</pre>

<p>There should be, at most, one explicit instantiation of each distinct entity in a program. In other words, you could explicitly instantiate both <b>print_typeof&lt;int&gt;</b> and <b>print_typeof&lt;double&gt;</b>, but each directive should appear only once in a program. Not following this rule usually results in linker errors that report duplicate definitions of the instantiated entities.</p>
<p>Manual instantiation has a clear disadvantage: We must carefully keep track of which entities to instantiate. For large projects this quickly becomes an excessive burden; hence we do not recommend it. We have worked on several projects that initially underestimated this burden, and we came to regret our decision as the code matured.</p>
<p>However, explicit instantiation also has a few advantages because the instantiation can be tuned to the needs of the program. Clearly, the overhead of large headers is avoided. The source code of template definition can be kept hidden, but then no additional instantiations can be created by a client program. Finally, for some applications it can be useful to control the exact location (that is, the object file) of a template instance. With automatic instantiation, this may not be possible (see Chapter 10 for details).</p>

<table>
<tr>
      <td align=center><IMG SRC="web0302b_fig1.gif" width="369" height="398"></td>
    </tr>
<tr><td align=center><i>Figure 6.1. Separation of template declaration and definition</i></td></tr>
</table>

<H4>6.2.2 Combining the Inclusion Model and Explicit Instantiation</H4>

<p>To keep the decision open whether to use the inclusion model or explicit instantiation, we can provide the declaration and the definition of templates in two different files. It is common practice to have both files named as header files (using an extension ordinarily used for files that are intended to be <b>#included</b>), and it is probably wise to stick to this convention. (Thus, <b>myfirst.cpp</b> of our motivating example becomes <b>myfirstdef.hpp</b>, with preprocessor guards around the code inserted.) Figure 6.1 demonstrates this for a <b>Stack&lt;&gt;</b> class template.</p> 
<p>Now if we want to use the inclusion model, we can simply include the definition header file <b>stackdef.hpp</b>. Alternatively, if we want to instantiate the templates explicitly, we can include the declaration header <b>stack.hpp</b> and provide a dot-C file with the necessary explicit instantiation directives (see Figure 6.2).</p>

<table>
<tr>
      <td align=center><IMG SRC="web0302b_fig2.gif" width="369" height="355"></td>
    </tr>
<tr><td align=center><i>Figure 6.2. Explicit instantiation with two template header files</i></td></tr>
</table>

<H3>6.3 The Separation Model</H3>

<p>Both approaches advocated in the previous sections work well and conform entirely to the C++ standard. However, this same standard also provides the alternative mechanism of <i>exporting </i>templates. This approach is sometimes called the C++ template <i>separation model</i>.</p>

<H4>6.3.1 The Keyword export</H4>

<p>In principle, it is quite simple to make use of the <b>export</b> facility: Define the template in just one file, and mark that definition and all its nondefining declarations with the keyword<b> export</b>. For the example in the previous section, this results in the following function template declaration:</p>

<pre>
<i>// basics/myfirst3.hpp</i>
#ifndef MYFIRST_HPP
#define MYFIRST_HPP
<i>// declaration of template</i>
export
template &lt;typename T&gt;
void print_typeof (T const&amp;);

#endif <i>// MYFIRST_HPP</i>
</pre>

<p>Exported templates can be used without their definition being visible. In other words, the point where a template is being used and the point where it is defined can be in two different translation units. In our example, the file <b>myfirst.hpp</b> now contains only the <i>declaration </i>of the member functions of the class template, and this is sufficient to use those members. Comparing this with the original code that was triggering linker errors, we had to add only one <b>export</b> keyword in our code and things now work just fine.</p>
<p>Within a preprocessed file (that is, within a translation unit), it is sufficient to mark the first declaration of a template with <b>export</b>. Later redeclarations, including definitions, implicitly keep that attribute. This is why <b>myfirst.cpp</b> does not need to be modified in our example. The definitions in this file are implicitly exported because they were so declared in the <b>#include</b>d header file. On the other hand, it is perfectly acceptable to provide redundant <b>export</b> keywords on template definitions, and doing so may improve the readability of the code.</p> 
<p>The keyword <b>export</b> really applies to function templates, member functions of class templates, member function templates, and static data members of class templates. <b>export</b> can also be applied to a class template declaration. It implies that every one of its exportable members is exported, but class templates themselves are not actually exported (hence, their definitions still appear in header files). You can still have implicitly or explicitly defined inline member functions. However, these inline functions are not exported:</p>

<pre>
export template &lt;typenameT&gt;
class MyClass {
  public:
    void memfun1();    <i>// exported</i>
    void memfun2(){    <i>// not exported because implicitly inline</i>
      ...
    }
    void memfun3();    <i>// not exported because explicitly inline</i>
      ...
};

template &lt;typename T&gt;
inline void MyClass&lt;T&gt;::memfun3 ()
{
      ...
}
</pre>


<p>However, note that the keyword <b>export</b> cannot be combined with <b>inline</b> and must always precede the keyword <b>template</b>. The following is invalid:</p>

<pre>
template &lt;typename T&gt;
class Invalid {
  public:
    export void wrong(T);      <i>// ERROR: </i>export<i> not followed by </i>template
};

export template&lt;typename T&gt;    <i>// ERROR: both </i>export<i> and </i>inline
inline void Invalid&lt;T&gt;::wrong(T)
{
}

export inline T const&amp; max (T const&amp;a, T const&amp; b)
{                              <i>// ERROR: both </i>export<i> and </i>inline
    return a &lt; b ? b : a;
}
</pre>

<H4>6.3.2 Limitations of the Separation Model</H4>

<p>At this point it is reasonable to wonder why we're still advocating the inclusion approach when exported templates seem to offer just the right magic to make things work. There are a few different aspects to this choice.</p>
<p>First, even four years after the standard came out, only one company has actually implemented support for the <b>export</b> keyword. (As far as we know, Edison Design Group, Inc. <a href="#3">[<i>EDG</i>]</a> is still that company. Their technology is available through other vendors, however.) Therefore, experience with this feature is not as widespread as other C++ features. Clearly, this also means that at this point experience with exported templates is fairly limited, and all our observations will ultimately have to be taken with a grain of salt. It is possible that some of our misgivings will be addressed in the future (and we show how to prepare for that eventuality).</p>
<p>Second, although <b>export</b> may seem quasi-magical, it is not <i>actually </i>magical. Ultimately, the instantiation process has to deal with both the place where a template is instantiated and the place where its definition appears. Hence, although these two seem neatly decoupled in the source code, there is an invisible coupling that the system establishes behind the scenes. This may mean, for example, that if the file containing the definition changes, both that file and all the files that instantiate the templates in that file may need to be recompiled. This is not substantially different from the inclusion approach, but it is no longer obviously visible in the source code. As a consequence, dependency management tools (such as the popular <b>make</b> and <b>nmake</b> programs) that use traditional source-based techniques no longer work. It also means that quite a few bits of extra processing by the compiler are needed to keep all the bookkeeping straight; and in the end, the build times may not be better than those of the inclusion approach.</p>
<p>Finally, exported templates may lead to surprising semantic consequences, the details of which are explained in Chapter 10.</p>
<p>A common misconception is that the <b>export</b> mechanism offers the potential of being able to ship libraries of templates without revealing the source code for their definitions (just like libraries of nontemplate entities). (Not everybody considers this <i>closed-source </i>approach a plus.) This is a misconception in the sense that hiding code is not a language issue: It would be equally possible to provide a mechanism to hide included template definitions as to hide exported template definitions. Although this may be feasible (the current implementations do not support this model), it unfortunately creates new challenges in dealing with template compilation errors that need to refer to the hidden source code.</p> 

<H4>6.3.3 Preparing for the Separation Model</H4>

<p>One workable idea is to prepare our sources in such a way that we can easily switch between the inclusion and export models using a harmless dose of preprocessor directives. Here is how it can be done for our simple example;</p>

<pre>
<i>// basics/myfirst4.hpp</i>
#ifndef MYFIRST_HPP
#define MYFIRST_HPP

<i>// use </i>export<i> if </i>USE-EXPORT<i> is defined</i>
#if defined (USE_EXPORT)
#define EXPORT export
#else
#define EXPORT
#endif

<i>// declaration of template</i>
EXPORT
template &lt;typename T&gt;
void print_typeof (T const&amp;);


<i>// include definition if </i>USE_EXPORT<i> is not defined</i>
#if !defined(USE_EXPORT)
#include &quot;myfirst.cpp&quot;
#endif

#endif<i> // MYFIRST_HPP</i>
</pre>

<p>By defining or omitting the preprocessor symbol <b>USE_EXPORT</b>, we can now select between the two models. If a program defines <b>USE_EXPORT</b>  before it includes <b>myfirst.hpp</b>, the separation model is used:</p>

<pre>
<i>// use separation model:</i>
#define USE_EXPORT
#include &quot;myfirst.hpp&quot;
...
</pre>

<p>If a program does not define <b>USE_EXPORT</b>, the inclusion model is used because in this case <b>myfirst.hpp</b> automatically includes the definitions in <b>myfirst.cpp</b>:</p>

<pre>
<i>// use inclusion model:</i>
#include &quot;myfirst.hpp&quot;
...
</pre>

<p>Despite this flexibility, we should reiterate that besides the obvious logistical differences, there can be subtle semantic differences between the two models.</p>
<p>Note that we can also explicitly instantiate exported templates. In this case the template definition can be in another file. To be able to choose between the inclusion model, the separation model, and explicit instantion, we can combine the organization controlled by <b>USE_EXPORT</b> with the conventions described in Section 6.2.2 on page 67.</p>

<H3>6.4 Templates and inline</H3>

<p>Declaring short functions to be inline is a common tool to improve the running time of programs. The <b>inline</b> specifier indicates to the implementation that inline substitution of the function body at the point of call is preferred over the usual function call mechanism. However, an implementation is not required to perform this inline substitution at the point of call.</p>
<p>Both function templates and inline functions can be defined in multiple translation units. This is usually achieved by placing the definition in a header file that is included by multiple dot-C files.</p>
<p>This may lead to the impression that function templates are inline by default. However, they're not. If you write function templates that should be handled as inline functions, you should use the <b>inline</b> specifier (unless the function is inline already because it is defined inside a class definition).</p>
<p>Therefore, many short template functions that are not part of a class definition should be declared with <b>inline</b>. (We may not always apply this rule of thumb because it may distract from the topic at hand.)</p>

<H3>6.5 Precompiled Headers</H3>

<p>Even without templates, C++ header files can become very large and therefore take a long time to compile. Templates add to this tendency, and the outcry of waiting programmers has in many cases driven vendors to implement a scheme usually known as <i>precompiled headers</i>. This scheme operates outside the scope of the standard and relies on vendor-specific options. Although we leave the details on how to create and use precompiled header files to the documentation of the various C++ compilation systems that have this feature, it is useful to gain some understanding of how it works.</p>
<p>When a compiler translates a file, it does so starting from the beginning of the file and works through to the end. As it processes each token from the file (which may come from <b>#include</b>d files), it adapts its internal state, including such things as adding entries to a table of symbols so they may be looked up later. While doing so, the compiler may also generate code in object files.</p>
<p>The precompiled header scheme relies on the fact that code can be organized in such a manner that many files start with the same lines of code. Let's assume for the sake of argument that every file to be compiled starts with the same <i>N </i>lines of code. We could compile these <i>N </i>lines and save the complete state of the compiler at that point in a so-called <i>precompiled header</i>. Then, for every file in our program, we could reload the saved state and start compilation at line <i>N+1</i>. At this point it is worthwhile to note that reloading the saved state is an operation that can be orders of magnitude faster than actually compiling the first <i>N </i>lines. However, saving the state in the first place is typically more expensive than just compiling the <i>N </i>lines. The increase in cost varies roughly from 20 to 200 percent.</p> 
<p>The key to making effective use of precompiled headers is to ensure that &#151; as much as possible &#151;  files start with a maximum number of common lines of code. In practice this means the files must start with the same <b>#include</b>  directives, which (as mentioned earlier) consume a substantial portion of our build time. Hence, it can be very advantageous to pay attention to the order in which headers are included. For example, the following two files</p> 

<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;list&gt;
...
</pre>

<p>and</p>

<pre>
#include &lt;list&gt;
#include &lt;vector&gt;
...
</pre>

<p>inhibit the use of precompiled headers because there is no common initial state in the sources.</p>
<p>Some programmers decide that it is better to <b>#include</b> some extra unnecessary headers than to pass on an opportunity to accelerate the translation of a file using a precompiled header. This decision can considerably ease the management of the inclusion policy. For example, it is usually relatively straightforward to create a header file named <b>std.hpp</b> that includes all the standard headers (In theory, the standard headers do not actually need to correspond to physical files. In practice, however, they do, and the files are very large.):</p> 


<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;deque&gt;
#include &lt;list&gt;
...
</pre>

<p>This file can then be precompiled, and every program file that makes use of the standard library can then simply be started as follows:</p>


<pre>
#include &quot;std.hpp&quot;
...
</pre>

<p>Normally this would take a while to compile, but given a system with sufficient memory, the precompiled header scheme allows it to be processed significantly faster than almost any single standard header would require without precompilation. The standard headers are particularly convenient in this way because they rarely change, and hence the precompiled header for our <b>std.hpp</b> file can be built once. (Some committee members find the concept of a comprehensive <b>std.hpp</b> header so convenient that they have suggested introducing it as a standard header. We would then be able to write <b>#include &lt;std&gt;</b>. Some even suggest that it should be implicitly included so that all the standard library facilities become available without <b>#include.</b>) Otherwise, precompiled headers are typically part of the dependency configuration of a project (for example, they are updated as needed by the popular <b>make</b> tool).</p>
<p>One attractive approach to manage precompiled headers is to create <i>layers </i>of precompiled headers that go from the most widely used and stable headers (for example, our <b>std.hpp</b> header) to headers that aren't expected to change all the time and therefore are still worth precompiling. However, if headers are under heavy development, creating precompiled headers for them can take more time than what is saved by reusing them. A key concept to this approach is that a precompiled header for a more stable layer can be reused to improve the precompilation time of a less stable header. For example, suppose that in addition to our <b>std.hpp</b>  header (which we have precompiled), we also define a <b>core.hpp</b> header that includes additional facilities that are specific to our project but nonetheless achieve a certain level of stability:</p> 

<pre>
#include &quot;std.hpp&quot;
#include &quot;core_data.hpp&quot;
#include &quot;core_algos.hpp&quot;
...
</pre>

<p>Because this file starts with <b>#include &quot;std.hpp&quot;</b>, the compiler can load the associated precompiled header and continue with the next line without recompiling all the standard headers. When the file is completely processed, a new precompiled header can be produced. Applications can then use <b>#include &quot;core.hpp&quot; </b>to provide access quickly to large amounts of functionality because the compiler can load the latter precompiled header.</p>

<H3>6.6 Debugging Templates</H3>


<p>Templates raise two classes of challenges when it comes to debugging them. One set of challenges is definitely a problem for writers of templates: How can we ensure that the templates we write will function for <i>any </i>template arguments that satisfy the conditions we document? The other class of problems is almost exactly the opposite: How can a user of a template find out which of the template parameter requirements it violated when the template does not behave as documented?</p>
<p>Before we discuss these issues in depth, it is useful to contemplate the kinds of constraints that may be imposed on template parameters. In this section we deal mostly with the constraints that lead to compilation errors when violated, and we call these constraints <i>syntactic constraints</i>. Syntactic constraints can include the need for a certain kind of constructor to exist, for a particular function call to be unambiguous, and so forth. The other kind of constraint we call <i>semantic constraints</i>.</p>
<p>These constraints are much harder to verify mechanically. In the general case, it may not even be practical to do so. For example, we may require that there be a <b>&lt;</b> operator defined on a template type parameter (which is a syntactic constraint), but usually we'll also require that the operator actually defines some sort of ordering on its domain (which is a semantic constraint).</p>
<p>The term <i>concept </i>is often used to denote a set of constraints that is repeatedly required in a template library. For example, the C++ standard library relies on such concepts as <i>random access iterator </i>and <i>default constructible</i>. Concepts can form hierarchies in the sense that one concept can be a refinement of another. The more refined concept includes all the constraints of the other concept but adds a few more. For example, the concept <i>random access iterator </i>refines the concept <i>bidirectional iterator </i>in the C++ standard library. With this terminology in place, we can say that debugging template code includes a significant amount of determining how concepts are violated in the template implementation and in their use.</p>

<H4>6.6.1 Decoding the Error Novel</H4>

<p>Ordinary compilation errors are normally quite succinct and to the point. For example, when a compiler says &quot;<b>class x has no member 'fun'</b>,&quot;  it usually isn't too hard to figure out what is wrong in our code (for example, we might have mistyped <b>run</b> as <b>fun</b>). Not so with templates. Consider the following relatively simple code excerpt using the C++ standard library. It contains a fairly small mistake: list&lt;string&gt; is used, but we are searching using a <b>greater&lt;int&gt;</b> function object, which should have been a <b>greater&lt;string&gt;</b> object:</p> 

<pre> 
std::list&lt;std::string&gt; coll;
...
<i>// Find the first element greater than </i>&quot;A&quot;
std::list&lt;std::string&gt;::iterator pos;
pos = std::find_if(coll.begin(),coll.end(),                <i>// range </i>
                   std::bind2nd(std::greater&lt;int&gt;(),&quot;A&quot;)); <i>// criterion</i>
</pre>

<p>This sort of mistake commonly happens when cutting and pasting some code and forgetting to adapt parts of it.</p>
<p>A version of the popular GNU C++ compiler reports the following error:</p>

<pre>
/local/include/stl/_algo.h: In function 'struct _STL::_List_iterator&lt;_STL::basic _string
&lt;char,_STL::char_traits&lt;char&gt;,_STL::allocator&lt;char&gt;&gt;,_STL::_Nonconst_traits
&lt;_STL::basic_string&lt;char,_STL::char_traits&lt;char&gt;,_STL::allocator&lt;char&gt;&gt;&gt;&gt;
_STL::find_if&lt;_STL::_List_iterator&lt;_STL::basic_string&lt;char,_STL::char_traits&lt;char&gt;,
_STL::allocator&lt;char&gt;&gt;,_STL::_Nonconst_traits&lt;_STL::basic_string&lt;char,_STL::char_traits&lt;char&gt;,
_STL::allocator&lt;char&gt;&gt;&gt;&gt;,_STL::binder2nd&lt;_STL::greater&lt;int&gt;&gt;&gt;(_STL::_List_iterator
&lt;_STL::basic_string&lt;char,_STL::char_traits&lt;char&gt;,_STL::allocator&lt;char&gt;&gt;&gt;&gt;,
_STL::_Nonconst_traits&lt;_STL::basic_string&lt;char,_STL::char_traits&lt;char&gt;,_STL::allocator&lt;char&gt;&gt;&gt;&gt;,
_STL::_List_iterator&lt;_STL::basic_string&lt;char,_STL::char_traits&lt;char&gt;,_STL::allocator&lt;char&gt;&gt;,
_STL::_Nonconst_traits&lt;_STL::basic_string&lt;char,_STL::char_traits&lt;char&gt;,_STL::allocator&lt;char&gt;&gt;&gt;&gt;,
_STL::binder2nd&lt;_STL::greater&lt;int&gt;&gt;,_STL::input_iterator_tag)':
/local/include/stl/_algo.h:115: instantiated from '_STL::find_if&lt;_STL::_List_iterator
&lt;_STL::basic_string&lt;char,_STL::char_traits&lt;char&gt;,_STL::allocator&lt;char&gt;&gt;, _STL::Nonconst_traits
&lt;_STL::basic_string&lt;char,_STL::char_traits&lt;char&gt;,__STL::allocator&lt;char&gt;&gt;&gt;&gt;,
_STL::binder2nd&lt;_STL::greater&lt;int&gt;&gt;&gt;(_STL::_List_iterator&lt;_STL::basic_string&lt;char,
_STL::char_traits&lt;char&gt;,_STL::allocator&lt;char&gt;&gt;,_STL::_Nonconst_traits&lt;_STL::basic_string&lt;char,
_STL::char_traits&lt;char&gt;,_STL::allocator&lt;char&gt;&gt;&gt;&gt;,_STL::_List_iterator&lt;_STL::basic_string&lt;char,
_STL::char_traits&lt;char&gt;,_STL::allocator&lt;char&gt;&gt;,_STL::Nonconst_traits&lt;_STL::basic_string&lt;char,
_STL::char_traits&lt;char&gt;,_STL::allocator&lt;char&gt;&gt;&gt;&gt;,_STL:: binder2nd&lt;_STL::greater&lt;int&gt;&gt;)'
testprog.cpp:18: instantiated from here
/local/include/stl/_algo.h:78: no match for call to '(_STL:binder2nd&lt;_STL::greater&lt;int&gt;&gt;) 
(_STL::basic_string&lt;char,_STL::char_traits&lt;char&gt;,_STL::allocator&lt;char&gt;&gt;&amp;)'
/local/include/stl/_function.h:261: candidates are: bool _STL::binder2nd&lt;
_STL::greater&lt;int&gt; &gt;::operator ()(const int &amp;) const
</pre>

<p>A message like this starts looking more like a novel than a diagnostic. It can also be overwhelming to the point of discouraging novice template users. However, with some practice, messages like this become manageable, and the errors are relatively easily located.</p> 
<p>The first part of this error message says that an error occurred in a function template instance (with a horribly long name) deep inside the <b>/local/include/stl/_algo.h</b> header. Next, the compiler reports why it instantiated that particular instance. In this case it all started on line 18 of <b>testprog.cpp</b> (which is the file containing our example code), which caused the instantiation of a <b>find_if</b> template on line 115 of the <b>_algo.h</b> header. The compiler reports all this in case we simply were not expecting all these templates to be instantiated. It allows us to determine the chain of events that caused the instantiations.</p> 
<p>However, in our example we're willing to believe that all kinds of templates needed to be instantiated, and we just wonder why it didn't work. This information comes in the last part of the message: The part that says &quot;<b>no match for call</b>&quot; implies that a function call could not be resolved because the types of the arguments and the parameter types didn't match. Furthermore, just after this, the line containing&quot;<b>candidates are</b>&quot; explains that there was a single candidate type expecting an integer type (parameter type <b>const int&amp;</b>). Looking back at line 18 of the program, we see <b>std::bind2nd(std::greater&lt;int&gt;(),&quot;A&quot;</b>), which does indeed contain an integer type (<b>&lt;int&gt;</b>) that is not compatible with the string type objects for which we're looking in our example. Replacing <b>&lt;int&gt; </b>with <b>&lt;std::string&gt; </b>makes the problem go away.</p>
<p>There is no doubt that the error message could be better structured. The actual problem could be omitted before the history of the instantiation, and instead of using fully expanded template instantiation names like<b> MyTemplate&lt;YourTemplate&lt;int&gt; &gt;</b>, decomposing the instance as in <b>MyTemplate&lt;T&gt; with T=YourTemplate&lt;int&gt; </b>can reduce the overwhelming length of names. However, it is also true that all the information in this diagnostic could be useful in some situations. It is therefore not surprising that other compilers provide similar information (although some use the structuring techniques mentioned).</p> 

<H4>6.6.2 Shallow Instantiation</H4>

<p>Diagnostics such as those discussed earlier arise when errors are found after a long chain of instantiations. To illustrate this, consider the following somewhat contrived code:</p>

<pre>
template &lt;typename T&gt;
void clear (T const&amp; p)
{
  *p = 0; <i>// assumes </i>T<i> is a pointer-like type</i>
}

template &lt;typename T&gt;
void core (T const&amp; p)
{
  clear(p);
}

template &lt;typename T&gt;
void middle (typename
T::Index p)
{
  core(p);
}

template &lt;typename T&gt;
void shell (T const&amp; env)
{
  typename T::Index I;
  middle&lt;T&gt;(i);
}

class Client {
  public:
    typedef int Index;
};

Client main_client;

int main()
{
  shell(main_client);
}
</pre>

<p>This example illustrates the typical layering of software development: High-level function templates like <b>shell()</b> rely on components like <b>middle(),</b> which themselves make use of basic facilities like <b>core().</b> When we instantiate <b>shell(),</b> all the layers below it also need to be instantiated. In this example, a problem is revealed in the deepest layer: <b>core()</b> is instantiated with type <b>int</b> (from the use of <b>Client::Index</b> in <b>middle()</b>) and attempts to dereference a value of that type, which is an error. A good generic diagnostic includes a trace of all the layers that led to the problems, but we observe that so much information can appear unwieldy.</p>
<p>An excellent discussion of the core ideas surrounding this problem can be found in <a href="#5">[<i>StroustrupDnE</i>]</a>, in which Bjarne Stroustrup identifies two classes of approaches to determine earlier whether template arguments satisfy a set of constraints: through a language extension or through earlier parameter use. We cover the former option to some extent in Section 13.11 on page 218. The latter alternative consists of forcing any errors in <i>shallow instantiations</i>. This is achieved by inserting unused code with no other purpose than to trigger an error if that code is instantiated with template arguments that do not meet the requirements of deeper levels of templates.</p>
<p>In our previous example we could add code in <b>shell()</b> that attempts to dereference a value of type <b>T::Index</b>. For example:</p>

<pre>
template (typename T&gt;
inline void ignore(T const&amp;)
{
{

template &lt;typename T&gt;
void shell (T const&amp; env)
{
  class ShallowChecks {
    void deref(T::Index ptr) {
      ignore(*ptr);
    }
  };
  typename T::Index I;
  middle(i);
}
</pre>

<p>If <b>T</b> is a type such that <b>T::Index</b> cannot be dereferenced, an error is now diagnosed on the local class <b>ShallowChecks.</b> Note that because the local class is not actually used, the added code does not impact the running time of the <b>shell()</b> function. Unfortunately, many compilers will warn about the fact that <b>ShallowChecks</b> is not used (and neither are its members). Tricks such as the use of the <b>ignore()</b> template can be used to inhibit such warnings, but they add to the complexity of the code.</p> 
<p>Clearly, the development of the dummy code in our example can become as complex as the code that implements the actual functionality of the template. To control this complexity it is natural to attempt to collect various snippets of dummy code in some sort of library. For example, such a library could contain macros that expand to code that triggers the appropriate error when a template parameter substitution violates the concept underlying that particular parameter. The most popular such library is the <i>Concept Check Library</i>, which is part of the Boost distribution (see <a href="#1">[<i>BCCL</i>]</a>).</p>
<p>Unfortunately, the technique isn't particularly portable (the way errors are diagnosed differs considerably from one compiler to another) and sometimes masks issues that cannot be captured at a higher level.</p>

<H4>6.6.3 Long Symbols</H4>

<p>The error message analyzed in Section 6.6.1 on page 75 demonstrates another problem of templates: Instantiated template code can result in very long symbols. For example, in the implementation used earlier <b>std::string</b> is expanded to</p>

<pre>
_STL::basic_string&lt;char,_STL::char_traits&lt;char&gt;,
                           _STL::allocator&lt;char&gt; &gt;
</pre>

<p>Some programs that use the C++ standard library produce symbols that contain more than 10,000 characters. These very long symbols can also cause errors or warnings in compilers, linkers, and debuggers. Modern compilers use compression techniques to reduce this problem, but in error messages this is not apparent.</p>

<H4>6.6.4 Tracers</H4>

<p>So far we have discussed bugs that arise when compiling or linking programs that contain templates. However, the most challenging task of ensuring that a program behaves correctly at run time often <i>follows </i>a successful build. Templates can sometimes make this task a little more difficult because the behavior of generic code represented by a template depends uniquely on the client of that template (certainly much more so than ordinary classes and functions). A tracer is a software device that can alleviate that aspect of debugging by detecting problems in template definitions early in the development cycle.</p> 
<p>A tracer is a user-defined class that can be used as an argument for a template to be tested. Often, it is written just to meet the requirements of the template and no more than those requirements. More important, however, a tracer should generate a <i>trace </i>of the operations that are invoked on it. This allows, for example, to verify experimentally the efficiency of algorithms as well as the sequence of operations.</p>
<p>Here is an example of a tracer that might be used to test a sorting algorithm:</p> 

<pre>
<i>//basics/tracer.hpp</i>

#include &lt;iostream&gt;

class SortTracer {
  private:
    int value;    <i>// integer value to be sorted</i>
    int generation;    <i>// generation of this tracer</i>
    static long n_created;     <i>// number of constructor calls</i>
    static long n_destroyed;    <i>// number of destructor calls</i>
    static long n_assigned    <i>// number of assignments</i>
    static long n_compared;    <i>// number of comparisons</i>
    static long n_max_live;    <i>//maximum of existing objects</i>
    <i>//recompute maximum of existing objects</i>
    static void update_max_live() {
      if (n_created-n_destroyed &gt; n_max_live) {
          n_max_live = n_created-n_destroyed;
      }
  }

public:
  static long creations() {
    return n_created;
  }
  static long destructions() {
    return n_destroyed;
  }
  static long assignments() {
    return n_assigned;
  }
  static long comparisons() {
    return n_compared;
  }
  static long_max_live() {
    return n_max_live;
  }

public:
  <i>// constructor</i>
  SortTracer (int v = 0) : value(v), generation(1) {
    ++n_created;
    update_max_live();
    std::cerr &lt;&lt; &quot;SortTracer #&quot; &lt;&lt; n_created
              &lt;&lt; &quot;, created generation &quot; &lt;&lt; generation
              &lt;&lt; &quot; (total: &quot; &lt;&lt; n_created - n_destroyed
              &lt;&lt; &quot;)\n&quot;;<p></p>
 
  }  

  <i>// copy constructor</i>
  SortTracer (SortTracer const&amp; b)
    : value(b.value), generation(b.generation+1) {
      ++n_created;
      update_max_live();
      std::cerr &lt;&lt; &quot;SortTracer #&quot; &lt;&lt; n_created
                &lt;&lt; &quot;, copied as generation &quot; &lt;&lt; generation
                &lt;&lt; &quot;(total: &quot; &lt;&lt; n_created - n_destroyed
                &lt;&lt; &quot;)\n&quot;;
  }

  <i>// destructor</i>
  ~SortTracer() {
    ++n_destroyed;
    update_max_live();
    std::cerr &lt;&lt; &quot;SortTracer generation&quot; &lt;&lt; generation
              &lt;&lt; &quot; destroyed (total: &quot;
              &lt;&lt; n_created - n_destroyed &lt;&lt; &quot;)\n&quot;;
  }
  <i>// assignment</i>
  SortTracer&amp; operator= (SortTracer const&amp; b) {
    ++n_assigned;
    std::cerr &lt;&lt; &quot;SortTracer assignment #&quot; &lt;&lt; n_assigned
              &lt;&lt; &quot; (generation &quot; &lt;&lt; generation
              &lt;&lt; &quot;)\n&quot;;
    value = b.value;
    return *this;
  }

  <i>// comparison</i>
  friend bool operator &lt; (SortTracer const&amp; a,
                          SortTracer const&amp; b) {
    ++n_compared;
    std::cerr &lt;&lt; &quot;SortTracer comparison #&quot; &lt;&lt; n_compared
              &lt;&lt; &quot; (generation &quot; &lt;&lt; a.generation
              &lt;&lt; &quot; &lt; &quot; &lt;&lt; b.generation
              &lt;&lt; &quot;)\n&quot;;
    return a.value &lt; b.value;
  }

  int val() const {
    return value;
  }
};
</pre>

<p>In addition to the value to sort, <b>value</b>,  the tracer provides several members to trace an actual sort: <b>generation</b> traces for each object how many copies it is from the original. The other static members trace the number of creations (constructor calls), destructions, assignment comparisons, and the maximum number of objects that ever existed.</p>
<p>The static members are defined in a separate dot-C file: </p>

<pre>
<i>// basics/tracer.cpp</i>
#include &quot;tracer.hpp&quot;

long SortTracer::n_created = 0;
long SortTracer::n_destroyed = 0;
long SortTracer::n_max_live = 0;
long SortTracer::n_assigned = 0;
long SortTracer::n_compared = 0;
</pre>

<p>This particular tracer allows us to track the pattern or entity creation and destruction as well as assignments and comparisons performed by a given template. The following test program illustrates this for the <b>std::sort</b> algorithm of the C++ standard library:</p>

<pre>
<i>// basics/tracertest.cpp</i>

#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &quot;tracer.hpp&quot;

int main()
{
  <i>// prepare sample input:</i>
  SortTracer input[] = { 7, 3, 5, 6, 4, 2, 0, 1, 9, 8 };

  <i>// print initial values:</i>
  for (int i=0; i&lt;10; ++i) {
    std::cerr &lt;&lt; input [i].val() &lt;&lt; ' ';
  }
  std::cerr &lt;&lt;  std::endl;

  <i>// remember initial conditions:</i>
  long created_at_start = SortTracer::creations();
  long max_live_at_start = SortTracer::max_live();
  long assigned_at_start = SortTracer::assignments();
  long compared_at_start = SortTracer::comparisons();
  
  <i>// execute algorithm:</i>
  std::cerr &lt;&lt; &quot;---[ Start std::sort() ]--------------------\n&quot;;
  std::sort&lt;&gt;(&amp;input[0], &amp;input[9]+1);
  std::cerr &lt;&lt; &quot;---[ End std::sort() ]----------------------\n&quot;;
  
  <i>// verify result:</i>
  for (int i=0; i&lt;10; ++i) {
    std::cerr &lt;&lt; input[i].val() &lt;&lt; ' ';
  }
  std::cerr &lt;&lt; &quot;\n\n&quot;;
  
  <i>// final report:</i>
  std::cerr &lt;&lt; &quot;std::sort() of 10 SortTracer's&quot;
            &lt;&lt; &quot; was performed by:\n &quot;
            &lt;&lt; SortTracer::creations() - created_at_start
            &lt;&lt; &quot; temporary tracers\n &quot;
            &lt;&lt; &quot;up to &quot;
            &lt;&lt; SortTracer::max_live()
            &lt;&lt; &quot; tracers at the same time (&quot;
            &lt;&lt; max_live_at_start &lt;&lt; &quot; before)\n &quot;
            &lt;&lt; SortTracer::assignments() - assigned_at_start
            &lt;&lt; &quot; assignments\n &quot;
            &lt;&lt; SortTracer::comparisons() - compared_at_start
            &lt;&lt; &quot; comparisons\n\n&quot;;
}
</pre>

<p>Running this program creates a considerable amount of output, but much can be concluded from the &quot;final report.&quot; For one implementation of the <b>std::sort()</b>function, we find the following:</p>

<pre>
std::sort() of 10 SortTracer's was performed by:
  15 temporary tracers
  up to 12 tracers at the same time (10 before)
  33 assignments
  27 comparisons
</pre>

<p>For example, we see that although 15 temporary tracers were created in our program while sorting, at most two additional tracers existed at any one time.</p>
<p>Our tracer thus fulfills two roles: It proves that the standard <b>sort()</b>algorithm requires no more functionality than our tracer (for example, operators <b>==</b> and <b>&gt;</b> were not needed), and it gives us a sense of the cost of the algorithm. It does not, however, reveal much about the correctness of the sorting template.</p>

<H4>6.6.5 Oracles</H4>

<p>Tracers are relatively simple and effective, but they allow us to trace the execution of templates only for specific input data and for a specific behavior of its related functionality. We may wonder, for example, what conditions must be met by the comparison operator for the sorting algorithm to be meaningful (or correct), but in our example we have only tested a comparison operator that behaves exactly like less-than for integers.</p> 
<p>An extension of tracers is known in some circles as <i>oracles </i>(or <i>run-time analysis oracles</i>). They are tracers that are connected to a so-called <i>inference engine</i> &#151; a program that can remember assertions and reasons about them to infer certain conclusions. One such system that was applied to certain parts of a standard library implementation is called <i>MELAS </i>and is discussed in <a href="#4">[<i>MusserWangDynaVeri</i>]</a>. (One author, David Musser, was also a key figure in the development of the C++ standard library. Among other things, he designed and implemented the first associative containers.)</p> 
<p>Oracles allow us, in some cases, to verify template algorithms dynamically without fully specifying the substituting template arguments (the oracles are the arguments) or the input data (the inference engine may request some sort of input assumption when it gets stuck). However, the complexity of the algorithms that can be analyzed in this way is still modest (because of the limitations of the inference engines), and the amount of work is considerable. For these reasons, we do not delve into the development of oracles, but the interested reader should examine the publication mentioned earlier (and the references contained therein).</p> 

<H4>6.6.6 Archetypes</H4>

<p>We mentioned earlier that tracers often provide an interface that is the minimal requirement of the template they trace. When such a minimal tracer does not generate run-time output, it is sometimes called an <i>archetype</i>. An archetype allows us to verify that a template implementation does not require more syntactic constraints than intended. Typically, a template implementer will want to develop an archetype for every concept identified in the template library.</p> 

<H3>6.7 Afternotes</H3>

<p>The organization of source code in header files and dot-C files is a practical consequence of various incarnations of the so-called <i>one-definition rule </i>or <i>ODR</i>. An extensive discussion of this rule is presented in Appendix A.</p>
<p>The inclusion versus separation model debate has been a controversial one. The inclusion model is a pragmatic answer dictated largely by existing practice in C++ compiler implementations. However, the first C++ implementation was different: The inclusion of template definitions was implicit, which created a certain illusion of <i>separation </i>(see Chapter 10 for details on this original model).</p> 
<p><a href="#5">[<i>StroustrupDnE</i>]</a> contains a good presentation of Stroustrup's vision for template code organization and the associated implementation challenges. It clearly wasn't the inclusion model. Yet, at some point in the standardization process, it seemed as if the inclusion model was the only viable approach after all. After some intense debates, however, those envisioning a more decoupled model garnered sufficient support for what eventually became the separation model. Unlike the inclusion model, this was a theoretical model not based on any existing implementation. It took more than five years to see its first implementation published (May 2002).</p>
<p>It is sometimes tempting to imagine ways of extending the concept of precompiled headers so that more than one header could be loaded for a single compilation. This would in principle allow for a finer grained approach to precompilation. The obstacle here is mainly the preprocessor: Macros in one header file can entirely change the meaning of subsequent header files. However, once a file has been precompiled, macro processing is completed, and it is hardly practical to attempt to patch a precompiled header for the preprocessor effects induced by other headers.</p> 
<p>A fairly systematic attempt to improve C++ compiler diagnostics by adding dummy code in high level templates can be found in Jeremy Siek's <i>Concept Check Library </i>(see <a href="#1">[<i>BCCL</i>]</a>). It is part of the Boost library (see <a href="#2">[<i>Boost</i>]</a>).</p>

<H3>6.8 Summary</H3>

<UL>
<LI>Templates challenge the classic compiler-plus-linker model. Therefore there are different approaches to organize template code: the inclusion model, explicit instantiation, and the separation model.</LI>
<LI>Usually, you should use the inclusion model (that is, put all template code in header files).</LI>
<LI>By separating template code into different header files for declarations and definitions, you can more easily switch between the inclusion model and explicit instantiation.</LI>
<LI>The C++ standard defines a separate compilation model for templates (using the keyword <b>export</b>). It is not yet widely available, however.</LI>
<LI>Debugging code with templates can be challenging.</LI>
<LI>Template instances may have very long names.</LI>
<LI>To take advantage of precompiled headers, be sure to keep the same order for <b>#include</b> directives.</LI>
</UL>

<H3>Bibliography</H3>

<p><a name="1"></a>[<i>BCCL</i>] Jeremy Siek. <i>The Boost Concept Check Library</i>, <a href="http://www.boost.org/libs/concept_check/concept_check.htm">&lt;www.boost.org/libs/concept_check/concept_check.htm&gt;</a>.</p>
<p><a name="2"></a>[<i>Boost</i>] <i>The Boost Repository for Free, Peer-Reviewed C++ Libraries</i>, <a href="http://www.boost.org">&lt;www.boost.org&gt;</a>.</p>
<p><a name="3"></a>[<i>EDG</i>] Edison Design Group. <i>Compiler Front Ends for the OEM Market</i>, <a href="http://www.edg.com">&lt;www.edg.com&gt;</a>.</p>
<p><a name="4"></a>[<i>MusserWangDynaVeri</i>] D.R. Musser and C. Wang. <i>Dynamic Verification of C++ Generic Algorithms</i>, IEEE Transactions on Software Engineering, Vol. 23, No. 5, May 1997.</p>
<p><a name="5"></a>[<i>StroustrupDnE</i>] Bjarne Stroustrup. <i>Bjarne Stroustrup's C++ Glossary</i>, <a href="http://www.research.att.com/~bs/glossary.html">&lt;www.research.att.com/~bs/glossary.html&gt;</a>.</p>

<H3>About the Authors</H3>

<p><b>David Vandevoorde</b> is an engineer at the Edison Design Group. He is an active member of the ANSI C++ Standards Committee, and a cofounder of the newsgroup comp.lang.c++.moderated. A graduate of the Brussels Free University and the Rensselaer Polytechnic University, his interests include algorithm development, programming languages, and teaching. He is the author of <i>C++ Solutions: Companion to the C++ Programming Language, Third Edition</i> (Addison-Wesley, 1998). See <a href="http://www.vandevoorde.com">&lt;www.vandevoorde.com&gt;</a>.</p>
<p><b>Nicolai M. Josuttis</b> is an independent technical consultant who designs object-oriented software for the telecommunications, traffic, finance, and manufacturing industries. He is an active member of the C++ Standards Committee Library Working Group. Nicolai has written several books on object-oriented programming and C++, including <i>The C++ Standard Library</i> (Addison-Wesley, 1999). See <a href="http://www.josuttis.com">&lt;www.josuttis.com&gt;</a>.

<p><b>Vandevoorde/Josuttis, <i>C++ Templates</i>, pp. 61-86. &copy; 2003 Pearson Education Inc. Reproduced by permission of Pearson Education, Inc. All rights reserved.</b></p>

</BODY></HTML>

