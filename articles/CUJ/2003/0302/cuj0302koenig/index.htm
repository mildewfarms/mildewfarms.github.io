<HTML><HEAD><TITLE>C++ Made Easier: Handles and Exception Safety, Part 4 -- Tracking References without Counters</TITLE></HEAD><body bgcolor="#FFFFFF" text="#000000"><h2>C++ Made Easier: Handles and Exception Safety, Part 4 -- Tracking References without Counters</h2><H3>Andrew Koenig and Barbara E. Moo</H3><i>Intelligent design gives you a Better Handle -- efficient, non-intrusive, and exception-safe.</i><p><h3>Introduction and Review</h3>The articles in this series so far have centered on the notion of a handle class. We can attach an object of a handle class to an object of another class and use the handle in place of the object to which it is attached. We would like to be able to copy a handle independently from copying the associated object. Accordingly, we must allow for the possibility that two or more handles might refer to the same object:<P><P><img src="cuj0302koenig_f1.gif" width="258" height="77"><P> In such a case, when we destroy a handle, we must avoid destroying the object   to which a handle is attached unless we know that no other handles are attached   to that object. We have solved this problem so far giving each object an associated   use count, which counts how many handles are attached to that object.<P>The first kind of use count that we developed was intrusive, in the sense that it resides in the object itself. Then we moved on to a non-intrusive use count, which is a separate object. Most recently, we defined a class, named <B>Use</B>, which encapsulates the idea of a use count:<P><pre>class Use {public:  Use(): refcnt (new unsigned(1))     { }  Use(const Use&amp; u): refcnt (u.refcnt)     { ++*refcnt; }  ~Use() {    if (--*refcnt == 0) delete refcnt;  }  Use&amp; operator=(const Use&amp;);  operator size_t() const {    return *refcnt;  }private:  unsigned* refcnt;};Use&amp; Use::operator=(const Use&amp; u){  ++*u.refcnt;  if (--*refcnt == 0)    delete refcnt;  refcnt = u.refcnt;  return *this;}</pre>We can use this class as part of a handle class by including a member of type <B>Use</B> as part of the handle. To illustrate this technique, we have been using the classic example of a class named <B>Shape</B>, which acts as a handle attached to an object from a hierarchy rooted in <B>Shape_base</B>:<P><pre>class Shape {public:  Shape(Shape_base*b): p(b) { }  ~Shape() {    if (u == 1) delete p;  }  Shape&amp; operator=(const Shape&amp;);  // Cause this handle to be the  // only one referring to its  // object, by copying the object  // if necessary.  void make_unique() {    // Are there other objects    // that share this one?    if (u &gt; 1) {      // This definition might      // throw.      Use new_u;      // If the following assignment       // throws, no state change has       // happened yet.      p = p-&gt;clone();      // Now we can change the      // state safely.      u = new_u;    }  }  void draw() const { p-&gt;draw(); }  // We can put other functions  // here as neededprivate:  Use u;  Shape_base* p;};</pre>Suppose, for example, that we were to write:<P><pre>Shape s1(new Circle);Shape s2(s1);</pre>We would then have a data structure that looks like this:<P><P><img src="cuj0302koenig_f2.gif" width="258" height="96"> <P>Here, <B>u</B> is the <B>Use</B> object that is part of each <B>Shape</B>,   and <B>p</B> is the pointer to <B>Shape_base</B> that is also part of each <B>Shape</B>   object.<P><h3>The Problem</h3>Our last article concerned itself specifically with the <B>make_unique</B> function, the purpose of which is to ensure that a handle is the only one associated with its particular object. Before we arrived at the present version of <B>make_unique</B>, we tried to define it as:<P><pre>  // Incorrect -- not exception-safe.  if (u &gt; 1) {  // Are there other objects that share this one?    u = Use();     // If so, create a new copy.    p = p-&gt;clone();  }</pre>This strategy is exception-unsafe. The reason is that when we evaluate <B>p-&gt;clone()</B> to form a copy of the object to which our handle is attached, we have already set <B>u</B> to refer to a new use-count object. If evaluating <B>p-&gt;clone()</B> throws an exception, we cannot simply propagate this exception to our caller because <B>u</B> refers to a newly created use count with a value of one. Therefore, when our handle object is destroyed, it will decrement the counter to zero and will then destroy the object to which our handle is attached. This destruction will happen even if there are other handles attached to the same object.<P>The form we actually used for the <B>make_unique</B> function guards against this possibility by avoiding any change to the value of <B>u</B> until after successfully calling <B>p-&gt;clone</B>.<P>Unfortunately, the fact that constructing a <B>Use</B> object might throw an exception causes another, more serious problem. Consider our earlier example:<P><pre>// Incorrect -- not exception-safeShape s1(new Circle);</pre>This usage is so obvious that you probably did not notice anything wrong with it. Indeed, even though we have now marked it with a comment noting that it is exception-unsafe, you may have difficulty finding the reason. The point is that because class <B>Shape</B> has a member of class <B>Use</B>, it is possible for the act of allocating a <B>Shape</B> object to throw an exception if there is insufficient memory for the <B>Use</B> member to allocate its counter. Consider what happens in that case:<P><ul><li>  Part of constructing <B>s1</B> is to execute its constructor. To do so, it is necessary to evaluate the constructor's arguments before executing the constructor itself. Accordingly, the new <B>Circle</B> object must be allocated before anything else happens.<li>  Part of constructing <B>s1</B> is constructing <B>s1</B>'s <B>Use</B> member. Let's assume that the <B>Use</B> member throws an exception during construction. Then this exception will propagate out through the <B>Shape</B> object, causing an exit from the block that contains the definition of that <B>Shape</B> object.<li>  As part of exiting that block, <B>s1</B>, which is presumably a local variable, is destroyed. However, there is no way of destroying the <B>Circle</B> object that was allocated by <B>new Circle</B> to pass to the <B>Shape</B> constructor. After all, the <B>Shape</B> constructor has not yet had a chance even to examine the address of the <B>Circle</B> object, let alone store it for later deletion.</ul>In other words, as a side effect of the fact that the <B>Use</B> constructor might throw an exception, the seemingly obvious usage:<P><pre>Shape s1(new Circle);</pre>has the possibility of creating a memory leak. Moreover, this possibility is particularly insidious because it will happen only when <B>new Circle</B> succeeds and the <B>Shape</B> constructor then runs out of memory. In other words, the memory leak happens in circumstances that are obscure enough that it is difficult for ordinary testing strategies to reveal it.<P>How can we avoid such obscure problems?<P><h3>The Solution</h3>The memory leak is possible for a reason that we have seen before: the program changes the state of the system and then does something that might throw an exception. Specifically, it executes <B>new Circle</B>, which changes the system state by allocating a resource, and then constructs a <B>Shape</B> object, which might throw an exception as part of constructing its <B>Use</B> member.<P>We had a similar problem in the definition of <B>make_unique</B>: the original version of <B>make_unique</B> assigned a new value to <B>u</B>, changing the state, and then tried to execute <B>p-&gt;clone()</B>, which might throw an exception. We solved the problem there by taking care to do the operations in the right order: first we created a <B>Use</B> object, which might throw an exception, but did not change the state; next we called <B>p-&gt;clone()</B>, which might throw an exception or change the state, but not both; and finally -- only after <B>p-&gt;clone()</B> was known to have succeeded -- we changed the state of <B>u</B>.<P>Unfortunately, it is difficult to use the same strategy here. For example, we might write:<P><pre>// might throw, but no state change yetShape s1;// might throw or change state, but not bothShape_base* p = new Circle;try {  s1 = Shape(p);  // might throw} catch(...) {  delete p;  throw;}</pre>but who wants to have to go through such gyrations merely to create a handle?<P>A much simpler way of avoiding this problem is to ensure that:<P><pre>Shape s1(new Circle);</pre>contains only a single operation that is capable of throwing an exception. We do not control the definition of class <B>Circle</B>, so we have no chance of making <B>new Circle</B> immune to exceptions. Therefore, we shall have to avoid exceptions in the <B>Shape</B> constructor. In order to do so, we shall have to redesign the constructor so that it does not allocate any dynamic memory, which implies that we shall have to avoid any dynamic memory allocation in the constructor of class <B>Use</B>.<P>How is such a redesign possible? One way is to go back to intrusive reference counting. As long as the reference count is part of the <B>Shape_base</B> object itself, no extra allocation is needed. However, suppose we want to stick with a non-intrusive strategy. Where can we possibly store the reference-counting information?<P>The answer is that although we do not wish to intrude on the <B>Shape_base</B> hierarchy, there is no reason not to intrude on the <B>Use</B> objects themselves. Suppose that instead of making each <B>Use</B> object refer to a separate counter, we instead link together all of the <B>Use</B> objects that refer to a particular <B>Shape_base</B> object. Then we might have a data structure that looks like this:<p><img src="cuj0302koenig_fg3.gif" width="258" height="118"></p>Here, the box marked <B>forw</B> in each handle object points to the next object in sequence, and the box marked <B>back</B> points to the previous object in the same sequence.<P>It should be clear that this data structure can do almost everything for us that our earlier data structure, with its dynamically allocated counter, can do, and that the new data structure does not require any dynamic memory allocation. We say "almost everything" because the new data structure does not offer the ability to determine quickly the value of the counter. If we want to know how many handles refer to an object, we have little recourse but to visit all of the handles and count them.<P>Fortunately, we do not normally care how many handles refer to an object; we care only whether that number is one. Therefore, we can replace the operator <B>size_t</B> in our <B>Use</B> class with, say, a member function named <B>only</B> that returns a <B>bool</B> indicator of whether its object is the only one in its chain.<P>With that change in mind, we can implement our revised <B>Use</B> class:<P><pre>class Use {public:  Use(): forw(this), back(this) { }  ~Use() { remove(); }  Use(const Use&amp; u) { insert(u); }  Use&amp; operator=(const Use&amp; u) {    if (this != &amp;u) {      remove();      insert(u);    }    return *this;  }  bool only() const;private:  mutable const Use* forw;  mutable const Use* back;  void insert(const Use&amp;) const;  void remove() const;};</pre>We are defining the constructor, destructor, copy constructor, and assignment operator in terms of two functions, <B>insert</B> and <B>remove</B>, which we shall define soon. The assignment operator is the only one of these functions that presents any difficulty. It checks for self-assignment, in which case it does nothing. Otherwise, it removes the current object from the list that it occupies and inserts it into right-hand side's list. In either case, it returns <B>*this</B>. We note in passing that the usual rule of thumb -- that assignment operators that check for self-assignment are exception-unsafe -- does not apply to this example because this assignment operator does nothing that could possibly throw an exception.<P>The <B>insert</B> function will insert our object into the list corresponding to another <B>Use</B> object; the <B>remove</B> function will remove our object from the (only) list in which it resides.<P>We define <B>forw</B> and <B>back</B> as being <B>mutable</B> because we will want the <B>insert</B> and <B>remove</B> to be able to modify these pointers even for a <B>const</B> object. For example, note that the copy constructor calls <B>insert</B> with a reference to a <B>const</B> <B>Use</B> object. In order for <B>insert</B> to put that object into a doubly linked list, it must be able to modify that object's pointers even though the object is <B>const</B>. The way to arrange for such modification is to use <B>mutable</B>.<P>Next, let us write the <B>insert</B> and <B>remove</B> functions. The easiest way to understand these functions is to draw a picture of the data structure yourself and add and remove links as needed:<P><pre>void Use::insert(const Use&amp; u) const {  this-&gt;back = &amp;u;  this-&gt;forw = u.forw;  this-&gt;back-&gt;forw = this-&gt;forw-&gt;back = this;}void Use::remove() const {  this-&gt;forw-&gt;back = this-&gt;back;  this-&gt;back-&gt;forw = this-&gt;forw;}</pre>All that remains is to define the <B>only</B> function. This function turns out to be nearly trivial, because <B>Use</B> object is the only one in its list if and only if it is linked to itself:<P><pre>bool Use::only() const {  return this == this-&gt;forw;}</pre>In order to use the revised <B>Use</B> class, we need to change our <B>Shape</B> class slightly, because we can no longer convert a <B>Use</B> object to an integer. Instead, we call the <B>only</B> function directly:<P><pre>class Shape {public:  Shape(Shape_base* b): p(b) { }  ~Shape() { if (u.only()) delete p; }  Shape&amp; operator=(const Shape&amp;);  void make_unique() {    // Are there other objects that share    // this one?    if (!u.only()) {        // If it throws, no state change yet.      p = p-&gt;clone();      // This statement cannot throw!      u = Use();    }  }  void draw() const { p-&gt;draw(); }  // Insert other functions as neededprivate:  Use u;  Shape_base* p;};</pre>Note the simplification of the <B>make_unique</B> function. We now call <B>p-&gt;clone()</B> first; either it throws an exception or it doesn't. If it throws an exception, there haven't been any state changes yet, so we're safe. If it doesn't throw its exception, we assign the result to <B>p</B>. This assignment changes the state -- but now, assigning <B>Use()</B> to <B>u</B> cannot throw an exception because it no longer allocates any dynamic memory! Therefore, this sequence of operations is safe.<P><h3>Discussion</h3>When programs get into trouble over exceptions, the act of throwing the exception itself is rarely the cause or the trouble. Rather, the trouble comes when the program allocates a resource that it fails to free in the exceptional case.<P>One strategy for avoiding such trouble is to catch exceptions and to free explicitly whatever resources were allocated before the exception happened. However, it is often possible to simplify such programs by doing first whatever might throw the exception and only then allocating resources that might have to be freed explicitly.<P>We saw one example of this strategy when we rewrote:<P><pre>{  u = Use();  p = p-&gt;clone();}</pre>as:<P><pre>{  Use new_u;  p = p-&gt;clone();  u = new_u;}</pre>Here, only the call to <B>p-&gt;clone()</B> allocated a resource, so we took care to call it only after creating the <B>Use</B> object, which might have thrown an exception.<P>When we learned that even this strategy was insufficient to make:<P><pre>Shape s1(new Circle);</pre>work in all cases, we used the same strategy again when we rewrote the definition of <B>Use</B> to ensure that it would never throw an exception.<P>Our rewritten <B>Use</B> class combines the advantage of the intrusive approach, which avoids having to allocate dynamic memory, with the advantage of the non-intrusive approach, which avoids the need to rewrite the class to which the handle is attached.<p><h3>About the Authors</h3>Andrew Koenig is a member of the Large-Scale Programming Research Department at AT&amp;T's Shannon Laboratory, and the Project Editor of the C++ standards committee. A programmer for more than 30 years, 15 of them in C++, he has published more than 150 articles about C++ and speaks on the topic worldwide. He is the author of <I>C Traps and Pitfalls</I> and co-author of <I>Ruminations on C++</I>.<P>Barbara E. Moo is an independent consultant with 20 years' experience in the software field. During her nearly 15 years at AT&amp;T, she worked on one of the first commercial projects ever written in C++, managed the company's first C++ compiler project, and directed the development of AT&amp;T's award-winning WorldNet Internet service business. She is co-author of <I>Ruminations on C++</I> and lectures worldwide.<p></BODY></HTML>