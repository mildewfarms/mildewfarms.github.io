<HTML><HEAD><TITLE>STL &amp; Generic Programming: C++ Metaprogramming Applied</TITLE></HEAD><body bgcolor="#FFFFFF" text="#000000"><h2>STL &amp; Generic Programming: C++ Metaprogramming Applied</h2><H3>Thomas Becker</H3><i>Template metaprogramming transcends academic musing. This article serves as a bridge to its practical uses.</i><P><h3>Introduction</h3>My last three columns were an introduction to C++ template metaprogramming. Naturally, all my examples were simplified in one way or another. In fact, I pointed out several times that you should not use any of my examples verbatim. For each and every one of them, there was a better and more mature version to be found in the Boost library [1]. That's all very well, because simplified examples are an important part of any introductory exposition. However, no introduction is complete without at least one example that is representative of real-life situations. Therefore, I found myself confronted with the daunting task of coming up with an application of C++ metaprogramming that fits into one column, can be considered of real interest rather than just a toy application, and is not already in the Boost library [1] or in Andrei Alexandrescu's book [2]. I think I found something. Well, almost. What I will present to you here is a slightly simplified version of my solution to the problem. The real solution is available for download at &lt;www.cuj.com/code&gt;.<P><h3>Better Default Function Arguments</h3>As we all know, C++ allows us to specify default values for function parameters. However, if we specify a default value for one parameter, then we must do the same for all remaining parameters. Moreover, if a caller wishes to use the default value for a particular parameter, then she necessarily gets the default values for all remaining parameters. I guess everybody has been in a situation where it would have been convenient to have default function arguments without these restrictions. In this imaginary C++, it would be possible to declare a function like this:<P><pre>class X;void Foo(int i=42, const X&amp;,  int j=43);</pre>A caller could then select the default value for any parameter that specifies a default, using the imaginary <B>default</B> keyword, like this:<P><pre>X anX;Foo(default, anX, 43);</pre>I remember several people mentioning casually that this kind of default function argument specification can be "faked" with C++ metaprogramming. However, I have never seen an actual implementation. Therefore, this will be my real-life application of metaprogramming techniques. To be honest, I should say that there is probably a reason why I have never seen this implemented before: the whole thing works nicely, but it is not exactly painless to use. You have to really want these generalized default arguments before you would actually use this. But then, it all depends.<P><h3>The General Idea</h3>Since we do not have the aforementioned <B>default</B> keyword in real C++, we must come up with something else that the caller of a function can put where the default argument is desired. The solution is to use a dummy argument of a special type whose sole purpose is to indicate the use of the default argument. With this idea, we can take a shot at some pseudocode for the function <B>Foo</B> described above.<P><pre>class default_parameter_tag{};template&lt;  typename ArgType1,  typename ArgType3&gt;void Foo(ArgType1 arg1,  const X&amp; arg2, ArgType3 arg3){  int arg1_processed;  if(ArgType1 converts to int)    arg1_processed = arg1;  else if(ArgType1 ==    default_parameter_tag)    arg1_processed = 42;  else    assert(false);    // similarly for arg3  // ...}</pre>The selection of the correct if branch should of course happen at compile time, and the <B>assert</B> should be a compile error. Conceptually, this is exactly how our implementation will work: the types of the arguments for which there are default values will be template parameters. When the client passes a dummy object of type <B>default_parameter_tag</B> as an argument, our mechanism will use that type information to detect that the default value should be used for the respective function argument.<P>There is just one more thing to consider before we can tackle the implementation: in order to get a generic solution that works smoothly for any number of function parameters and every possible combination of default values, we must package the function arguments into some sort of structure that can be generated at compile time. In my last column, I showed you exactly this kind of structure as an application of typelists. I also mentioned that Boost has a much more mature implementation of the same idea, namely Jaakko J&auml;rvi's tuple class [3]. Basically, this is what we want to use here. However, in order to incorporate the default argument processing seamlessly into the tuple manipulation, I have written my own tuple class for this special purpose.<P><h3>The Implementation</h3><a href="cuj0302becker_l1.htm">Listing 1</a> shows the definition of a class named <B>parameter_tuple</B>. It is a tuple class that is tailored to work for the purpose of generalized default function arguments. Notice how the code makes ample use of Boost's MetaC++ functions such as <B>add_reference</B>. Let me first remind you how tuples work. Conceptually, a tuple is a plain old <B>struct</B> with <B>get</B> and <B>set</B> methods. Technically, tuples use a nested structure to hold their data. A tuple has two member variables. The first one is the first data member. The second one is another tuple that holds the remaining data members, using the same nested structure. A good way to visualize a tuple is as a set of Russian dolls, where each doll holds a penny and another doll. In my last column, I used a simple tuple class as an example for the application of typelists. I also mentioned that it is possible to write a tuple class without the explicit use of typelists. This is because the nested structure of tuples mirrors the nested structure of typelists. Therefore, the underlying typelist of a tuple (namely, the list of types of the tuple's data members) can be incorporated into the tuple class itself. This is what I have done here. The MetaC++ function <B>nth_parameter_type</B> in <a href="cuj0302becker_l1.htm">Listing 1</a> demonstrates this: it retrieves the type of the <B>nth</B> element of a tuple (i.e., the <B>nth</B> type on the typelist that is implicitly contained in the tuple). If you ignore the various constructors of the class <B>parameter_tuple</B> for now, you won't find it difficult to understand how it is just a simple tuple class. <P>Let us now look at how the class <B>parameter_tuple</B> is used to provide us with generalized function parameters. To this end, we'll use the function <B>Foo</B> that we declared earlier in imaginary C++ like this:<P><pre>class X;void Foo(int i=42, const X&amp;, int j=43);</pre>To really get the intended default arguments, we now declare <B>Foo</B> like this:<P><pre>template&lt;typename ParameterTuple&gt;void Foo(const ParameterTuple&amp; args);</pre>In fact, any function that wishes to use our generalized default parameters must be declared exactly like this. Therefore, it is necessary to document the actual, intended types of the parameters with the declaration. The best way to do this is to provide a <B>typedef</B> for the correct type of <B>parameter_tuple</B>.<P><pre>typedef make_parameter_tuple_type&lt;  int, const X&amp;, int  &gt;::ret FooParams;</pre><a href="cuj0302becker_l1.htm">Listing 1</a> has the definition of the MetaC++ function <B>make_parameter_tuple_type</B>, which creates an instantiation of the class template <B>parameter_tuple</B> with the indicated element types.<P>Let us now look at how a client would call the function <B>Foo</B>. If no default values at all are to be used, then the client may use the <B>typedef</B> <B>FooParams</B> to package the arguments:<P><pre>X anX;Foo(FooParams(52, anX, 53));</pre>Notice how we are using the first <B>parameter_tuple</B> constructor here, which takes as its arguments the elements that the tuple is to hold. If default values are to be used for some or all of the parameters that allow default values, then dummy objects of type <B>default_parameter_tag</B> must be passed in the respective locations. For this to be possible, the packaging tuple must have the appropriate type. This type can be obtained by looking at the definition of <B>FooParams</B> and then placing the type <B>default_parameter_tag</B> in each slot where a default value is to be used. For example, the following call to <B>Foo</B> uses the default for the first argument:<P><pre>typedef make_parameter_tuple_type&lt;  default_parameter_tag,  const X&amp;,  int  &gt;::ret FooParamsDefault1;  X anX;Foo(FooParamsDefault1(  default_parameter_tag(),  anX,  53  ));</pre>The <B>typedef</B> <B>FooParamsDefault1</B> could be provided by the implementer of <B>Foo</B>, or it could be left to the client to figure it out. Either way, it's not exactly as pretty as you might wish. It would of course be much nicer if we could create the <B>parameter_tuple</B> using one of those little <B>make</B> functions that abound in the STL, using function template argument deduction to avoid having to explicitly name the template arguments. However, that would not work here because function template argument deduction would fail to deduce reference types like the <B>const X&amp;</B> in our example.<P> Now let's look at the implementation of <B>Foo</B> in <a href="cuj0302becker_l2.htm">Listing   2</a>. The first two lines of the function definition introduce the default   values for the first and third parameters. To this end, another instantiation   of the class template <B>parameter_tuple</B> is introduced via the <B>typedef</B>   <B>FooDefaultParams</B>. This instantiation is obtained from the original <B>FooParams</B>   by inserting the type <B>mandatory_parameter_tag</B> in each argument slot where   no default value will be provided. In the second line of <B>Foo</B>'s definition,   an object named <B>default_args</B> of type <B>FooDefaultParams</B> is declared   and filled with the default values for the respective arguments. Dummy objects   of type <B>mandatory_parameter_tag</B> are used where no default values are   provided.<P>The crucial part is the line:<P><pre>FooParams args    (client_args, default_args);</pre>Here, the final argument tuple for <B>Foo</B> gets constructed, and here is where a MetaC++ program gets executed to decide at compile time if and when default values for the arguments are to be used. Look at the definition of <B>parameter_tuple</B> in <a href="cuj0302becker_l1.htm">Listing 1</a> and find the constructor from two <B>parameter_tuple</B> objects. First, notice that the constructor works recursively: it first constructs the element of the tuple, and then it recursively constructs the nested tuple. Next, notice that there is a default version of the constructor, and there is an overload for the case where the element type of the first argument is <B>default_parameter_tag</B> [4]. Therefore, when the compiler creates the nested function calls to the constructor from the source line:<P><pre>FooParams args    (client_args, default_args);</pre> it actually executes a meta-if branching on each nesting level. If the argument that the client has passed in the object <B>client_args</B> is of the type default_parameter_tag, then the second version of the constructor gets called, which means that the default value is used for that argument. Otherwise, the first version of the constructor is called, and the client's argument is used.<P> At this point in the definition of <B>Foo</B>, the final set of arguments   is available in the tuple <B>args</B>. <a href="cuj0302becker_l2.htm">Listing   2</a> shows a call to an internal helper function <B>FooInternal</B> as the   final line. The reason for this is that for each combination of default values   and client-supplied values of <B>Foo</B>, <B>Foo</B>'s template parameter <B>ParameterTuple</B>   has a different value. Therefore, the compiler will instantiate a completely   separate version of <B>Foo</B> for each of these combinations. To avoid the   code bloat that would result from this, the actual body of <B>Foo</B> should   be delegated to the helper <B>FooInternal</B>. In this example, it is clear   how the helper function should be declared:<P><pre>void FooInternal(int, const X&amp;, int);</pre>In general, there is an additional subtlety about the helper function. Ideally, the entire default argument mechanism should be set up so that by the time the final function arguments have been put in the <B>parameter_tuple</B> object, only one copy has been made of each argument that is passed by value. The version that I am describing here does not fulfill that requirement: it makes two copies of each value argument, one when the client packages the arguments and another when the implementer creates the tuple containing the final function arguments. The version that you will find on the <I>CUJ</I> website, &lt;www.cuj.com/code&gt;, fixes that, at the cost of making the source code considerably more complex. Either way, if we pass value arguments to the helper function by value again, then another copy will be made. Therefore, the helper function should take all arguments that were originally passed by value as <B>const</B> references, or as plain references if the implementer of the helper function insists on (ab)using value parameters as modifiable local variables.<P> The version of <B>parameter_tuple</B> that is presented in <a href="cuj0302becker_l1.htm">Listing   1</a> works for functions with up to four parameters. The places where it needs   to be modified to accommodate more parameters are marked in the code with the   comment "EXTEND," and it should be clear what the necessary modifications are.<P><h3>Conclusion</h3>Both the code presented in <a href="cuj0302becker_l1.htm">Listing 1</a> and the final version available at &lt;www.cuj.com/code&gt; have been compiled and tested with the Metrowerks compiler v4.2.5.766. I would be interested to know how this code fares with other compilers. (I know what the answer is for Microsoft Visual C++.) Also, the whole thing is my first shot at solving the problem of generalized default arguments. I would be interested to know if anybody has any ideas for a solution that is less intrusive and easier to use.<P><h3>References</h3>[1] &lt;www.boost.org&gt;<P>[2]  Andrei Alexandrescu. <I>Modern C++ Design</I> (Addison-Wesley, 2001).<P>[3]  &lt;www.boost.org/libs/tuple/doc/ tuple_users_guide.html&gt;<P>[4]  From the point of view of MetaC++, the second version of the constructor can be viewed as a partial specialization that implements an if branching. Technically, however, it is an overload and not a partial specialization. For a complete discussion of this subject, see: Herb Sutter. "Sutter's Mill: Why Not Specialize Function Templates?" <I>C/C++ Users Journal</I>, July 2001.<p><h3>About the Author</h3>Thomas Becker works as a senior software engineer for Zephyr Associates, Inc. in Zephyr Cove, Lake Tahoe. He can be reached at <B>thomas@styleadvisor.com</B>.<p></BODY></HTML>