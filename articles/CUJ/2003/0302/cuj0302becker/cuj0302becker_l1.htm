<HTML><HEAD><TITLE>Listing 1:	Class parameter_tuple</TITLE></HEAD><body bgcolor="#FFFFFF" text="#000000"><B>Listing 1:</B>	Class parameter_tuple<p><pre>#include&lt;boost/type_traits/transform_traits.hpp&gt;#include&lt;boost/type_traits/cv_traits.hpp&gt;class nil {public:  typedef nil element_type;  typedef nil nested_type;  nil() {}  nil(const nil&amp;) {}  nil(const nil&amp;, const nil&amp;) {}  nil(const nil&amp;, const nil&amp;, const nil&amp;) {}  nil(const nil&amp;, const nil&amp;, const nil&amp;, const nil&amp;) {}  /* EXTEND */};  template&lt;typename FP, int n&gt;class nth_parameter_type {public:  typedef nth_parameter_type&lt;FP::nested_type, n-1&gt;::ret     ret;};template&lt;typename FP&gt;class nth_parameter_type&lt;FP, 0&gt; {public:  typedef typename FP::element_type ret;};// Tag classes for mandatory and default parameters.class default_parameter_tag{};class mandatory_parameter_tag{};// Class parameter_tupletemplate&lt;typename Head, typename Tail&gt;class parameter_tuple {  typedef typename Head element_type;  typedef typename Tail nested_type;    typedef boost::add_reference&lt;element_type&gt;::type      element_reference_type;  typedef boost::add_reference&lt;boost::add_const&lt;    element_type    &gt;::type&gt;::type  element_const_reference_type;    typedef boost::add_reference&lt;boost::add_const&lt;    nested_type    &gt;::type&gt;::type rest_const_reference_type;  template&lt;int n&gt;  class nth_parameter_tag{};public:  // Constructor from n elements  parameter_tuple(    element_const_reference_type elem_0,    typename boost::add_reference&lt;boost::add_const&lt;      nth_parameter_type&lt;Tail, 0&gt;::ret      &gt;::type&gt;::type elem_1 = nil(),    typename boost::add_reference&lt;boost::add_const&lt;      nth_parameter_type&lt;Tail, 1&gt;::ret      &gt;::type&gt;::type elem_2 = nil(),    typename boost::add_reference&lt;boost::add_const&lt;      nth_parameter_type&lt;Tail, 2&gt;::ret      &gt;::type&gt;::type elem_3 = nil()    /* EXTEND */ ) :    m_element(elem_0),    m_rest(elem_1, elem_2, elem_3 /* EXTEND */ ) {}  // Copy constructor from two function parameter objects,   // default implementation: copy element from first arg.  template&lt;typename Rhs1Head, typename Rhs1Tail,            typename Rhs2Head, typename Rhs2Tail&gt;  parameter_tuple(    const parameter_tuple&lt;Rhs1Head, Rhs1Tail&gt;&amp; rhs1,    const parameter_tuple&lt;Rhs2Head, Rhs2Tail&gt;&amp; rhs2    ) :    m_element(rhs1.get_element()),    m_rest(rhs1.get_rest(), rhs2.get_rest()) {}  // Copy constructor from two function parameter objects,  // overload when the element type of the first argument  // is default_parameter: copy element from second arg.  template&lt;typename Rhs1Tail, typename Rhs2Head,            typename Rhs2Tail&gt;  parameter_tuple(    const parameter_tuple&lt;      default_parameter_tag, Rhs1Tail&gt;&amp; rhs1,    const parameter_tuple&lt;Rhs2Head, Rhs2Tail&gt;&amp; rhs2) :    m_element(rhs2.get_element()),    m_rest(rhs1.get_rest(), rhs2.get_rest()) {}    // Get function to retrieve the nth parameter.  template&lt;int m&gt;  typename boost::add_reference&lt;    typename nth_parameter_type&lt;      parameter_tuple&lt;Head, Tail&gt;, m&gt;::ret&gt;::type   get_parameter()  {return get_parameter_internal(nth_parameter_tag&lt;m&gt;());}  // Get functions to retrieve the element and the  // tail. These must be public for the copy constructors.  element_const_reference_type get_element() const  { return m_element; }  //  rest_const_reference_type get_rest() const  { return m_rest; }  private:  element_type m_element;  nested_type m_rest;  // Get function to retrieve the nth parameter, default  //  implementation: look in the nested rest object.  template&lt;int m&gt;  typename boost::add_reference&lt;    typename nth_parameter_type&lt;      parameter_tuple&lt;Head, Tail&gt;, m      &gt;::ret&gt;::type   get_parameter_internal(nth_parameter_tag&lt;m&gt;)  { return m_rest.get_parameter&lt;m-1&gt;(); };  // Get function to retrieve the nth parameter, overload  // for m=0: return the element.  element_reference_type get_parameter_internal(    nth_parameter_tag&lt;0&gt;)  { return m_element; };    // Prevent assignment and copy construction.  parameter_tuple(const parameter_tuple&amp;);  parameter_tuple&amp; operator=(const parameter_tuple&amp;);};// parameter_tuple type generatortemplate&lt;typename T1=nil, typename T2=nil,          typename T3=nil, typename T4=nil         /* EXTEND */&gt;class make_parameter_tuple_type {public:  typedef typename parameter_tuple&lt;    T1, typename make_parameter_tuple_type&lt;      T2, T3, T4 /* EXTEND */&gt;::ret&gt; ret;};// Kicks in for zero arguments passedtemplate&lt;&gt;class make_parameter_tuple_type&lt;  nil, nil, nil, nil /* EXTEND */ &gt;{  public:    typedef typename nil ret;};</pre></BODY></HTML>