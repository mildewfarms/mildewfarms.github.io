<HTML><HEAD><TITLE>Conversations: Points of Order</TITLE></HEAD><body bgcolor="#FFFFFF" text="#000000"><h2>Conversations: Points of Order</h2><h3>Jim Hyslop and Herb Sutter</h3><i>A poignant reminder that locks tend to be global, despite appearances to the contrary, and should be verified globally.</i><P><I>Copyright 2003, Jim Hyslop and Herb Sutter</I><P>It was a cold day, but then February days were almost always cold. It didn't help that the day had got off to a worse-than-usual start: in my bleary post-waking pre-work routine I had a difficult time putting on my socks, only to discover it was because I'd already put on my boots. I sighed, took off my boots, put the socks on, put the boots back on, and was still shaking my head blearily as I walked out the door, vaguely hoping that a morning coffee or three would help.<P>It was to be an inauspicious harbinger of events later in the day.<P>I had just settled in at work and was slowly beginning to get into the flow of things when Wendy came by. "Yo, pardner," she said. "Got a minute?"<P>"Sure. What's up?"<P>"Kerry needs some help." She nodded in the direction of Kerry's cube. "It's with <I>Bahb's</I> code, so I suggested he come see you. Heh. Kerry's over there organizing his thoughts and mustering his courage. Just a heads-up, he'll be by soon."<P>"Sure," I agreed again, and thought to myself, <I>Mustering up courage? Am I starting to intimidate him?</I> Then I realized what she meant: my going along with the Guru's shtick was having an increasing effect on the poor intern, and I was a bit surprised when I found myself smiling at that thought.<P>Wendy left, and soon enough I heard footsteps approaching. Before Kerry could actually appear, I said: "Yes, young one?"<P>The footsteps paused, then resumed, and Kerry hove into view. "Uh, d'you mean me?"<P>"Yes," I said while still typing and only then turned and smiled. "What can I do for you?"<P>"Uh..." he said, seeming already slightly flustered. "Uh, well, I have a problem with some code that I think Bob wrote. I've got a simplified version to show you."<P>"Good job, glad you distilled down the example," I said approvingly. "Show away!" I made a grand gesture, and he pulled up the function on my screen:<P><pre>void Process( Queue&amp; q ){  int i = 0;  Lock&lt;Mutex&gt; l( sendQ ); // acquire  Send( "--- Send Begin---" );  while( i &lt; q.size() )  {    // acquire    Lock&lt;Mutex&gt; l( q[i].mutex );    Send( q[i].payload, i++ );  } // release q[i].mutex lock  Send( "--- Send End---" );} // release sendQ lock</pre>The <B>Lock</B> helper template created an object that acquired a lock on the designated mutex during construction and released the lock when it went out of scope. The code was pretty easy to figure out.<P>"Aaah," I aaahed pretty quickly. "I see your problem."<P>"Uh... you do?"<P>"Yes," I continued. "Consider: what's wrong with the second <B>Send()</B> call?" I pointed at the line:<P><pre>    Send( q[i].payload, i++ );</pre>Kerry wore a blank look. The wheels were turning, though, that I could see. I wondered if smoke would come wisping out of his ears. But the kid was game, I'd always give him that, and presently he said: "Uh, I suppose..."<P>"Right!" I interrupted. "That's exactly right, it's <B>i</B>! The variable <B>i</B> is being used in two argument expressions in the same function call. The order of evaluation of the function arguments is undefined, so either <B>q[i].payload</B> or <B>i++</B> could be evaluated first. If the former, you're fine. If the latter, you're well and truly hosed because on the last loop iteration you'll be trying to invoke <B>q[q.size()]</B>, which is off the end of the container. Not only shouldn't the side effect of incrementing <B>i</B> appear in the function parameter, but the whole thing would work better as a <B>for</B> loop." I edited his code to demonstrate:<P><pre>void Process( Queue&amp; q ){  Lock&lt;Mutex&gt; l( sendQ ); // acquire  Send( "--- Send Begin---" );  for( int i = 0; i &lt; q.size(); ++i )  {    // acquire    Lock&lt;Mutex&gt; l( q[i].mutex );     Send( q[i].payload, i );  } // release q[i].mutex lock  Send( "--- Send End---" );} // release sendQ lock</pre>I smiled. "I could have used iterators, but I noticed the code needed the index anyway, so I left it in. Get it?"<P>"Oh. Thanks." Kerry paused, pondering this, and then tentatively ventured: "But that's not my problem."<P>I blinked. "Eh?"<P>"My problem," Kerry explained patiently, "is that this code hangs every so often, and I don't know why."<P>"Right, that's what I said. You'll get an access viola--"<P>"No, no," Kerry broke in gently. "I see that problem now, but that's not the problem I'm having. The code doesn't blow up, at least not on the compilers we're using. What's happening is that the program hangs and won't respond. Intermittently. Once in a while. In front of our biggest customer, at an internal raw demo this morning, actually."<P>"Oh." I blinked again. "Right. Uh, well..."<P><I>Snap!</I> I jumped, but got at least a little satisfaction in noticing that Kerry jumped slightly higher. I had been too absorbed in the problem to notice the Guru come up behind us until she had snapped her book shut. "My apprentice, my novice," she greeted us. "A point of order, if you please."<P>"Yes, we were just discussing that," I agreed, pointing at the offending lines of code I had just fixed. "We've fixed the ordering problem already, but it turns out that Kerry actually has a different problem."<P>"Indeed," the Guru smiled. "As you say, 'Ah, I see your problem.' But it is still <I>a point of order</I>, as I said. One does not put on one's shoe before one puts on one's sock." I started at this and wondered if she had a spy cam in my room. But she was already continuing: "Prithee tell, have you looked at the other uses of the <B>Queue</B>?"<P>"Other uses?" Kerry and I chorused.<P>"Other uses." The Guru bowed gracefully, reopened her tome, and glided away. "You might start with <B>ExceptionReport()</B>..." her voice floated back just as she turned the corner.<P>I did a quick grep and found the code the Guru was talking about. Simplified, it boiled down to this:<P><pre>void ExceptionReport( Queue&amp; q ){  for( int i = 0; i &lt; q.size(); ++i )  {    Lock&lt;Mutex&gt; l( q[i].mutex );    if( MeetsCertainCriteria( q[i].payload ) )    {      Lock&lt;Mutex&gt; l( sendQ );      Send( q[i].payload, i );    }  }}</pre>I had to look at it for a minute before I got the point, and Kerry beat me to it by a hair: "Stinkin' locks," he said, and I was momentarily surprised at the vehemence of his comment.<P>"Yeah," I agreed. "Stinkin' locks. So, go ahead, finish the thought... tell me what we have here."<P>"It's a deadlock," Kerry said, gaining confidence. "We have two pieces of code, and they're acquiring two locks in reverse order, and every so often they just go hang. In <B>Process()</B>, we know we're going to output lots of stuff to a <B>Send</B> queue, so we lock the <B>Send</B> queue just once for the whole operation..."<P>"Why?"<P>"...to avoid needlessly releasing and reacquiring the lock, which would be inefficient. And then each item in the queue is protected by a mutex, so we lock it, output it, and release the lock on that item."<P>"Right. And what about <B>ExceptionReport()</B>?"<P>"There, we don't know yet if we'll even emit anything," Kerry said and sighed. "So there's no point in acquiring the <B>Send</B> queue lock until we know we're actually going to stuff something into it. So we get to each item in the queue, lock it, inspect it, and then if we need to send it we lock the <B>Send</B> queue lock too and then release both locks in reverse order."<P>"And sometimes...?"<P>"And sometimes <B>Process()</B> might be running in one thread while <B>ExceptionReport()</B> is running in another thread, and they try to acquire the same two locks in the reverse order. But... but the way the code is now, for both functions, just seems like the right thing to do in each case. Isn't it?"<P>"Sure it is," I agreed. "Sometimes some requirement has to give somewhere. How would you do it?"<P>"I don't know."<P>"Well," I welled, "we just have to acquire locks in the same order always or change one thread to not acquire them both. So we could change <B>Process()</B> to store all the items to be sent into a temporary area and only then acquire the <B>Send</B> lock once to send them all; that's a space overhead, but it means <B>Process()</B> won't ever acquire both locks at the same time because all the work on the <B>Queue</B> would happen first before any <B>Send()</B> work happens. Or we could make changes to <B>ExceptionReport()</B>, say to acquire the <B>Send</B> lock for the whole scope of the function whether it's needed or not."<P>"And you found that other problem too."<P>"Right. Never write code that depends on the order of evaluation of function arguments."<P>"Order," Kerry muttered to himself. "Order. Order..."<P>"Right, yeah. Like she said--" I looked around quickly, checking for silent footsteps sneaking up on us, but the Guru was nowhere in sight. "--both problems were a point of order. 'Scuse me now," I finished as I got up, "but I think I'll go practice changing my socks."<p><h3>About the Authors</h3>Herb Sutter (&lt;www.gotw.ca&gt;) is convener of the ISO C++ standards committee, author of the acclaimed books <I>Exceptional C++</I> and <I>More Exceptional C++</I>, and one of the instructors of The C++ Seminar (&lt;www.gotw.ca/cpp_seminar&gt;). In addition to his independent writing and consulting, he is also C++ community liaison for Microsoft. <P>Jim Hyslop is a senior software designer with over 10 years programming experience in C and C++. Jim works at Leitch Technology International Inc., where he deals with a variety of applications, ranging from embedded applications to Windows programs. He can be reached at <B>jhyslop@ieee.org</B>.<p></BODY></HTML>