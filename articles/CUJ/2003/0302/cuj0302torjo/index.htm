<HTML><HEAD><TITLE>Testing with Paired Messages</TITLE></HEAD><body bgcolor="#FFFFFF" text="#000000"><H2>Testing with Paired Messages</H2><h3>John Torjo</h3><i>A trace file can help debug a program, but only if you can decipher the trace file. This technique will help.</i><p>In complex applications, one of the reasons for logging is to track bugs. However, as logs grow larger, the task of finding errors becomes increasingly difficult. You'll have a better chance of discovering the problem if your log isn't clogged with miscellaneous unrelated messages. However, sometimes an innocuous message contains a clue. This article resolves these seemingly contradictory insights by introducing the concept of paired messages.<P>In complex applications, you end up logging a lot of messages in pairs: "Start receiving data for client jt2001," "End receiving data for client jt2001," etc. But most likely, the pairs are far apart. Between the two messages in a pair, you will find other messages, stating what happened between the start of an action and the end of the same action. A <I>paired message</I> is composed of two messages: one that describes the start of an action, and one that describes the end of the same action. The first message (the one describing the start of the action) must occur first. The second message is written later when the action ends.<P>If the second message in the pair is written to the log, the action completes successfully. The strategy described in this article eliminates completed pairs from the log so that the log contains only:<P><ul><li>   <I>Un-paired messages</I>. An un-paired message is an unfinished paired message. That is, the first message occurred but the second message has not yet occurred.<li>   <I>Non-paired messages</I>. A non-paired message is a message that does not belong to a pair. For instance, it's an informational message, like "Found the word 'html' in file 'C:\test.html'."</ul>In case of an error, you can consult the log -- the Isolated Messages Log -- and immediately see which actions were currently unfinished at the time the error occurred. Once you have determined the possible cause of the error, you can consult the ALL Messages Log to learn more about the context in which the error occurred. The ALL Messages Log contains all messages: paired, un-paired, and non-paired.<P>This article describes how you can hunt for errors in your programs using a Isolated Messages Log. I have implemented the Isolated Messages Log in Windows, using Visual C++ v6. However, it should be easily ported to other platforms as well.<P> <a href="cuj0302torjo_f1.htm">Figure 1</a> shows an example of Isolated Messages   Log and <a href="cuj0302torjo_f2.htm">Figure 2</a> shows a small part of an   ALL Messages Log.<P><h3>Message Writing</h3>The logging method described in this article requires two steps:<P>1.  Write all messages to both the ALL Messages Log and the Isolated Messages Log.<P>2.  Periodically refresh the Isolated Messages Log to remove completed pairs.<P>You can refresh the Isolated Messages Log either manually or automatically (see the later section titled "Refreshing").<P>The first step is to write messages to the logs. The <B>CPairedMessagesLog</B> class (available for download at &lt;www.cuj.com/code&gt;) writes each message to the Isolated Messages Log and the ALL Messages Log.<P>Say you have a reference to a <B>CPairedMessagesLog</B> object. How do you write to it? <P>In order to uniquely identify a paired message, you assign it a unique message ID. Non-paired messages don't need an ID.<P>When writing a paired message, you can do it in two ways:<P>1.  Automatically -- a Message ID is automatically assigned:<P><pre>CPairedMessagesLog&lt;&gt;::paired_log  MessageLog = log.next_paired();MessageLog  &lt;&lt; "Start receiving from ["   &lt;&lt; nSatteliteNo  &lt;&lt; "] satellite" &lt;&lt; std::endl;// ... user codeMessageLog  &lt;&lt; "End receiving from ["   &lt;&lt; nSatteliteNo  &lt;&lt; "] satellite" &lt;&lt; std::endl;</pre>2.  Manually -- you get a message ID or provide your own unique message ID:<P><pre>// get a Message ID, OR provide your ownCPairedMessagesLog&lt;&gt;::message_id_type  MessageID = log.nextmessageid();  log.paired( MessageID)  &lt;&lt; "Start receiving from ["   &lt;&lt; nSatteliteNo  &lt;&lt; "] satellite" &lt;&lt; std::endl;// ... user codelog.paired( MessageID)  &lt;&lt; "End receiving data from ["   &lt;&lt; nSatteliteNo  &lt;&lt; "] satellite" &lt;&lt; std::endl;</pre>Writing a non-paired message is done like this:<P><pre>log.not_paired()  &lt;&lt; "Satellite [" &lt;&lt; nSatelliteNo  &lt;&lt; "] has been checked: no malfunctions."  &lt;&lt; std::endl;</pre>As you can see, writing the message is done in an STL-stream manner. You use <B>operator &lt;&lt;</B> to write any type of data. Terminating a message is done with <B>std::endl</B>. Actually, it must end with <B>std::endl</B> (see the sidebar, "<a href="cuj0302torjo_s2.htm"><B>std::endl</B> Usage</a>").<P>As a matter of fact, the functions <B>paired</B>, <B>non_paired</B>, and <B>next_paired</B> all return STL stream objects. That is, you can pass them to functions that accept <B>std::basic_stream&lt; char_type&gt;</B> arguments or even use manipulators to write to them.<P> You can also indent messages (see the sidebar, "<a href="cuj0302torjo_s1.htm">Indenting   Messages</a>").<P><h3>Construction</h3>Constructing a <B>CPairedMessagesLog</B> can be done in two ways:<P>1)  <B>CPairedMessagesLog( strLogFileName, strAllMessagesLogFileName)</B>. This definition is almost self-explanatory, with one more detail: the refresh type is "Auto Refresh at 10 seconds" (see "Refreshing" below).<P> 2) <B>CPairedMessagesLog( CPairedMessagesLog::Settings settings)</B>. This   further refines the settings of the <B>CPairedMessagesLog</B>. <a href="cuj0302torjo_l1.htm">Listing   1</a> shows the definition of the <B>Settings class</B> (also, see "Refreshing"   below).<P>Notes:<P><ul><li>   If <B>strAllMessagesLogFileName</B> is empty, there won't be an ALL Messages Log. However, I don't recommend using this.<li>   <B>strLogFileName</B> must contain the full path to the file. This is because the file will be opened and closed multiple times. Therefore, even if by chance the current directory changes, <B>strLogFileName</B> should point to the same file on disk!</ul><h3>Refreshing</h3>The ALL Messages Log does not need refreshing. You append each message to its end. But the Isolated Messages Log needs to be refreshed. Why? Once a full paired message is written (i.e., the end of an action has been written to the log), you must delete this paired message from the log.<P>The following types of refreshing are allowed:<P><ul><li>   Every time: this will refresh the log each time any message (paired message or non-paired message) is written to it. Note that you won't rewrite the whole log unless necessary. For instance, when a new non-paired message is written, you just append it to the log; you don't need to rewrite the log!</ul>  Advantage: at any given time, you will have an up-to-date log.<P> Disadvantage: this type of refreshing might be inefficient when large amounts of data get written to the log very fast.<p><ul><li>   Auto refresh at <I>X</I> seconds: this will refresh, on a dedicated thread, the log automatically at <I>X</I> seconds.</ul> Advantage: this is very efficient.<P> Disadvantage: in case the application crashes, you might lose some data.<P>Also, you can manually refresh at any time by calling the <B>Refresh</B> function. You can even implement a mechanism to <B>Refresh</B> the Isolated Messages Log just before your application crashes.<P>The default refresh is auto refresh at 10 seconds.<P><h3>Implementation Details</h3>The most important functions from <B>CPairedMessagesLog</B> class are:<P><ul><li>   <B>WritePairedMessage</B>, which writes a part of a paired message (i.e., the start or the end of an action)<li>   <B>WriteNonPairedMessage</B>, which writes a non-paired message</ul>I have created an abstract class, <B>CMessageHandlerStream</B>, which is STL stream-derived. When the <B>CMessageHandlerStream</B> is flushed (e.g., when <B>std::endl</B> is written to it -- see the sidebar, "<a href="cuj0302torjo_s2.htm"><B>std::endl</B> Usage</a>"), it calls a virtual function, <B>OnNewMessage( strMessage)</B>, where <B>strMessage</B> is the message written so far, up to the <B>flush</B>. Internally, in <B>CPairedMessagesLog</B>, I have created two classes: <B>COnePairedMessageLog</B> and <B>CNonPairedLog</B>. Both are derived from <B>CMessageHandlerStream</B>. <B>COnePairedMessageLog</B>'s <B>OnNewMessage</B> calls <B>WritePairedMessage</B> to write a part of a paired message. <B>CNonPairedLog</B>'s <B>OnNewMessage</B> calls <B>WriteNonPairedMessage</B> to write a non-paired message.<P>As I said before, the <B>paired</B>, <B>non_paired</B>, and <B>next_paired</B> functions all return STL stream objects. As a matter of fact, <B>paired</B> and <B>next_paired</B> return a <B>COnePairedMessageLog</B> object, and <B>non_paired</B> returns a <B>CNonPairedLog</B> object.<P>So, when you write:<P><pre>log.next_paired();  &lt;&lt; "Start receiving from [" &lt;&lt; nSatteliteNo  &lt;&lt; "] satellite" &lt;&lt; std::endl;</pre>when <B>std::endl</B> is written, the <B>COnePairedMessageLog</B> stream is flushed, which in turn calls <B>OnNewMessage</B>, which calls <B>WritePairedMessage</B> for this message.<P>And when you write:<P><pre>log.not_paired()  &lt;&lt; "Satellite [" &lt;&lt; nSatelliteNo  &lt;&lt; "] has been checked: no malfunctions." &lt;&lt; std::endl;</pre>when <B>std::endl</B> is written, the <B>CNonPairedLog</B> stream is flushed, which in turn calls <B>OnNewMessage</B>, which calls <B>WriteNonPairedMessage</B> for this message.<P>Internally, when the Isolated Messages Log is rewritten (refreshed), you must make sure you preserve the order of messages (un-paired and non-paired). For the un-paired messages, this is a simple task since each message has an ID. However, it's not so easy with the non-paired messages. Somehow, you must know where each non-paired message is to be written, related to the other un-paired messages. In order to accomplish this, I have made each non-paired message belong to a paired message. For example, the "satellite [5] has been checked" non-paired message will always be written after the paired message with the ID of <B>6</B>. When refreshing, it will write all un-paired messages with IDs less or equal than <B>6</B> and then write the "satellite [5] has been checked" non-paired message, and so on. Having each non-paired message be written after a certain paired message is enough to preserve the order of messages while refreshing.<P>Note that I'm not saying anything about the full paired messages. This is because once a full paired message has been written to the log (i.e., the start and end of an action), the action will have completed successfully. So, it will be removed from the Isolated Messages Log. Therefore, you don't need to worry about full paired messages.<P><h3>Testing the Test</h3>I have developed a small test for the Isolated Messages Log (available for download at &lt;www.cuj.com/code&gt;).<P>I have a class, <B>do_for_each_file_t</B>, which does a certain action for all files in a given folder plus its subfolders. In order to improve its performance, I have allowed executing actions for different files in parallel (assuming that each action operates only on the file to which it is assigned).<P>On the main thread, I have created two threads. On the first thread, I examine all files in a given folder, checking if a word is found. After a while (five seconds), the expiry thread is started, which starts deleting files. Soon after, the application might crash. This is because it will most likely try to examine an already deleted file.<P>This simulates a very simple proxy with a cache mechanism. It allows a search function (search through cached files) and expires unaccessed files once in a while. Of course, it has a bug. Since searching is done with multithreading, it should check whether a file exists before trying to read from it!<P><h3>Checking the Isolated Messages Log and ALL Messages Log!</h3>In <a href="cuj0302torjo_f1.htm">Figure 1</a>, line 3, "Expiring files started" gives you an indication that the bug is related somehow to the expiration of files. Lines 11, 12, and 14 show that one of the files <B>1[1].swf</B>, <B>24909;type=t;uniq=58381[1].htm</B>, or <B>31[1].gif</B> caused the crash.<P> By examining <a href="cuj0302torjo_f2.htm">Figure 2</a> (which contains the   last lines of an ALL Messages Log), you can see the context of the crash, which   shows that most of the files have been processed correctly. The last line shows   that the file that most likely caused the crash is <B>31[1].gif</B>. This should   give you an indication that the bug appeared while expiration and searching   were executed in parallel. This will lead you, when searching, to first check   if the file exists before reading from it.<P>Notes:<P><ul><li>   When running this test, compile in release mode -- otherwise the application might not crash at all! Make sure you run the test with at least 5,000 files, and the files should usually be larger than 10K. I suggest you copy and paste some of your "Temporary Internet Files" (from the IE cache).<li>   If you decide to run the test, make sure you don't mistakenly erase important data!</ul><h3>Possible Improvements</h3>A few improvements can be made to <B>CPairedMessagesLog</B>. For instance, you can argue that over time you might end up keeping a lot of messages (both un-paired messages and non-paired messages) internally, and that you should have some kind of expiring mechanism. Well, you are right. But, I chose not to implement this, since the <B>CPairedMessages</B> log is mainly for testing. For this reason, there won't be too many messages internally, since there will be very few un-paired messages at a given time. Note that having too many un-paired messages at a given time only means that there are a lot of bugs in the tested code.<P>Implementing an expiring mechanism is not an easy task. You can do it by having a maximum number of un-paired messages kept internally (say, 1,000 un-paired messages). If you reach this limit, you should remove half of the un-paired messages and log this information somewhere. You can choose to remove the oldest messages, but you have to keep an extra property for each paired message: the time when the start of the action has been written. You also should do the same for non-paired messages.<P>Another improvement would be to have an additional template parameter for the internal log classes. Instead of using <B>std::basic_ofstream</B> logs, you could use another log class. For instance, instead of writing to a file, you might want to write to a window.<P>And last but not least, you might want each message to be preceded by the time it's been written. This is useful only for the ALL Messages Log file. To do this, you should modify the <B>WritePairedMessage</B>/<B>WriteNonPairedMessage</B> functions.<P>I recommend you implement these improvements only if necessary.<P><h3>Conclusion</h3>The Isolated Messages Log is a valuable tool in the programmer's toolkit. I hope you will enjoy it as much as I have.<p><h3>About the Author</h3>John Torjo has loved C++ since he first used it. He has experience in large projects, using STL/templates. Currently he's a freelancer and can be reached at <B>john.torjo@peoplefirstsoft.com</B>.<p></BODY></HTML>