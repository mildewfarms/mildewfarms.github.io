<HTML><HEAD><TITLE>Two C++ Gotchas</TITLE></HEAD><body bgcolor="#FFFFFF" text="#000000"><h2>Two C++ Gotchas</H2><h3>Steve Dewhurst</h3><i>Get this before they get you.</i><P>Adapted from S. Dewhurst, C++ Gotchas: Avoiding Common Problems in Coding and Design (#29 &amp; #97). &copy; 2003 Pearson Education, Inc. Reproduced by permission of Pearson Education, Inc. All rights reserved.<h3></h3><I>Steve Dewhurst's book </I>C++ Gotchas: Avoiding Common Problems in Coding and Design <I>[1] begins thus</I>:<P><ul>This book is the result of nearly two decades of minor frustrations, serious bugs, late nights, and weekends spent involuntarily at the keyboard. This collection consists of 99 of some of the more common, severe, or interesting C++ gotchas, most of which I have (I'm sorry to say) experienced personally. The term "gotcha" has a rather cloudy history, and a variety of definitions. For the purposes of this book, we'll define C++ gotchas as common and preventable problems in C++ programming and design. The gotchas described here run the gamut from minor syntactic annoyances to basic design flaws to full-blown sociopathic behavior." [2] </ul><I>Following are two prize Gotchas...</I><P><h3>Gotcha #29:	Converting through void *</h3>Even C programmers know that a <B>void *</B> is second cousin to a cast and should be avoided to the extent possible. As with a cast, converting a typed pointer to <B>void *</B> removes all useful type information. Typically, the original type of the pointer must be "remembered" and restored when the <B>void *</B> is used. If the type is resupplied correctly, everything will work fine (except, of course, that having to remember types for later casting implies that the design needs work).<P><pre>void *vp = new int(12);// . . .// will workint *ip = static_cast&lt;int *&gt;(vp); </pre>Unfortunately, even this simple use of <B>void *</B> can open the door to portability problems. Remember that <B>static_cast</B> is the cast operator we use (when we must cast) for relatively safe and portable conversions. For example, one might use a <B>static_cast</B> to cast from a base class pointer to a publicly derived class pointer. For unsafe, platform-dependent conversions, we're forced to use <B>reinterpret_cast</B>. For example, one might use a <B>reinterpret_cast</B> to cast from an integer to a pointer or between pointers to unrelated types:<P><pre><font color="#FF0000">// error!char *cp = static_cast&lt;char *&gt;(ip); </font>// works.char *cp = reinterpret_cast&lt;char *&gt;(ip);</pre>The use of <B>reinterpret_cast</B> is a clear indication to you and to the readers and maintainers of your code that you're not only casting, but that you're casting in a potentially nonportable way. Use of a <B>void *</B> intermediary allows that important warning to be circumvented:<P><pre><font color="#FF0000">// put int addr into a char *!char *cp = static_cast&lt;char *&gt;(vp);</font></pre>It gets worse. Consider a user interface that allows the address of a "Widget" to be stored and later retrieved:<P><pre><font color="#FF0000">typedef void *Widget;void setWidget( Widget );Widget getWidget();</font></pre>Users of this interface recognize that they have to remember the type of <B>Widget</B> they set, so they can restore its type information when it's retrieved:<P><pre>// In some header file . . .class Button {   // . . .};class MyButton : public Button {   // . . .};// elsewhere . . .MyButton *mb = new MyButton;<font color="#FF0000">setWidget( mb );</font>// somewhere else entirely . . .// might work!<font color="#FF0000">Button *b = static_cast &lt;Button *&gt;   (getWidget());</font></pre>This code will usually work, even though we lose some type information when we extract the <B>Widget</B>. The stored <B>Widget</B> refers to a <B>MyButton</B> but is extracted as a <B>Button</B>. The reason this code will often work has to do with the likely way that the storage for a class object is laid out in memory.<P> Typically, a derived class object contains the storage for its base class   sub-object starting at offset <B>0</B>, as if its base class part were the first   data member of the derived class, and simply appends any additional derived   class data below that, as in <a href="cuj0302dewhurst_f1.htm">Figure 1</a>.   Therefore, the address of a derived class object is generally the same as that   of its base class. (Note, however, that the Standard guarantees correct results   only if the address in the <B>void *</B> is converted to exactly the same type   used to set the <B>void *</B>. See Gotcha #70 for one way this code could fail   even under single inheritance.) <P>However, this code is fragile, in that a remote change during maintenance may introduce a bug. In particular, a straightforward and proper use of multiple inheritance may break the code:<P><pre>// in some header file . . .class Subject {   // . . .};class ObservedButton :   public Subject, public Button {   // . . .};// elsewhere . . .ObservedButton *ob = new ObservedButton;<font color="#FF0000">setWidget( ob );</font>// . . .<font color="#FF0000">Button *badButton =   static_cast&lt;Button *&gt;(getWidget()); // disaster!</font></pre>The problem is with the layout of the derived class object under multiple inheritance. An <B>ObservedButton</B> has two base class parts, and only one of them can have the same address as the complete object. Typically, storage for the first base class (in this case, <B>Subject</B>) is placed at offset <B>0</B> in the derived class, followed by the storage for subsequent base classes (in this case, <B>Button</B>), followed by any additional derived class data members, as in <a href="cuj0302dewhurst_f2.htm">Figure 2</a>. Under multiple inheritance, a single object commonly has multiple valid addresses.<P>Ordinarily this is not a problem, since the compiler is aware of the various offsets and can perform the correct adjustments at compile time:<P><pre>Button *bp = new ObservedButton;ObservedButton *obp =   static_cast&lt;ObservedButton *&gt;(bp);</pre>In the code above, <B>bp</B> correctly points to the <B>Button</B> part of the <B>ObservedButton</B> object, not to the start of the object. When we cast from a <B>Button</B> pointer to an <B>ObservedButton</B> pointer, the compiler is able to adjust the address so that it points to the start of the <B>ObservedButton</B> object. It's not hard, since the compiler knows the offset of each base class part within a derived class, as long as it knows the type of the base and derived classes.<P>And that's our problem. When we use <B>setWidget</B>, we throw away all useful type information. When we cast the result of <B>getWidget</B> to <B>Button</B>, the compiler can't perform the adjustment to the address. As a result, the <B>Button</B> pointer is actually referring to a <B>Subject</B>!<P>Void pointers do have their uses, as do casts, but they should be used sparingly. It's never a good idea to use a <B>void *</B> as part of an interface that requires one use of the interface to resupply type information lost through another use.<P><h3>Gotcha #97:	Cosmic Hierarchies</h3>More than a decade ago, the C++ community decided that the use of "cosmic" hierarchies (architectures in which every object type is derived from a root class, usually called <B>Object</B>) was not an effective design approach in C++. There were a number of reasons for rejecting this approach, both on the design level and on the implementation level.<P>From a design standpoint, cosmic hierarchies often give rise to generic containers of "objects." The content of these containers are often unpredictable and lead to unexpected run-time behavior. Bjarne Stroustrup's classic counterexample considered the possibility of putting a battleship in a pencil cup -- something a cosmic hierarchy would allow but that would probably surprise a user of the pencil cup.<P>A pervasive and dangerous assumption among inexperienced designers is that an architecture should be as flexible as possible. Error. Rather, an architecture should be as close to the problem domain as possible while retaining sufficient flexibility to permit reasonable future extension. When "software entropy" sets in and new requirements are difficult to add within the existing structure, the code should be refactored into a new design. Attempts to create maximally flexible architectures a priori are similar to attempts to create maximally efficient code without profiling; there will be no useful architecture, and there will be a loss of efficiency. (See also Gotcha #72.)<P>This misapprehension of the goal of an architecture, coupled with an unwillingness to do the hard work of abstracting a complex problem domain, often results in the reintroduction of a particularly noxious form of cosmic hierarchy:<P><pre><font color="#FF0000">class Object { public:   Object( void *, const type_info &amp; );   virtual ~Object();   const type_info &amp;type();   void *object();   // . . .};</font></pre>Here, the designer has abdicated all responsibility for understanding and properly abstracting the problem domain and has instead created a wrapper that can be used to effectively "cosmicize" otherwise unrelated types. An object of any type can be wrapped in an <B>Object</B>, and we can create containers of <B>Object</B>s into which we can put anything at all (and frequently do).<P>The designer may also provide the means to perform a type-safe conversion of an <B>Object</B> wrapper to the object it wraps:<P><pre><font color="#FF0000">template &lt;class T&gt;T *dynamicCast( Object *o ) {   if( o &amp;&amp; o-&gt;type() == typeid(T) )      return reinterpret_cast&lt;T *&gt;         (o-&gt;object());   return 0;}</font></pre>At first glance, this approach may seem acceptable (if somewhat ungainly), but consider the problem of extracting and using the content of a container that can contain anything at all:<P><pre><font color="#FF0000">void process( list&lt;Object *&gt; &amp;cup ) {   typedef list&lt;Object *&gt;::iterator I;   for( I i(cup.begin()); i != cup.end();        ++i ) {       if( Pencil *p =           dynamicCast&lt;Pencil&gt;(*i) )           p-&gt;write();       else if( Battleship *b =           dynamicCast&lt;Battleship&gt;(*i) )           b-&gt;anchorsAweigh();       else           throw InTheTowel();   }}</font></pre>Any user of the cosmic hierarchy will be forced to engage in a silly and childish "guessing game," the object of which is to uncover type information that shouldn't have been lost in the first place. In other words, that a pencil cup can't contain a battleship doesn't indicate a design flaw in the pencil cup. The flaw may be found in the section of code that thinks it's reasonable to perform such an insertion. It's unlikely that the ability to put a battleship in a pencil cup corresponds to anything in the application domain, and this is not the type of coding we should encourage or submit to. A local requirement for a cosmic hierarchy generally indicates a design flaw elsewhere.<P>Since our design abstractions of pencil cups and battleships are simplified models of the real world (whatever "real" means in the context), it's worth considering the analogous real-world situation. Imagine that, as the designer of a (physical) pencil cup, you received a complaint from one of your users that his ship didn't fit in the cup. Would you offer to fix the pencil cup, or would you offer some other type of assistance?<P>The repercussions of this abdication of design responsibility are extensive and serious. Any use of a container of <B>Object</B>s is a potential source of an unbounded number of type-related errors. Any change to the set of object types that may be wrapped as <B>Object</B>s will require maintenance to an arbitrary amount of code, and that code may not be available for modification. Finally, because no effective architecture has been provided, every user of the container is faced with the problem of how to extract information about the anonymous objects.<P>Each of these acts of design will result in different and incompatible ways of detecting and reporting errors. For example, one user of the container may feel just a bit silly asking questions like "Are you a pencil? No? A battleship? No? ..." and opt for a capability-query approach. The results are not much better (see Gotcha #99).<P> Often, the presence of an inappropriate cosmic hierarchy is not as obvious   as it is in the case we just discussed. Consider a hierarchy of assets, as in   <a href="cuj0302dewhurst_f3.htm">Figure 3</a>.<P>It's not immediately clear whether the <B>Asset</B> hierarchy is overly general or not, especially in this high-level picture of the design. Often the suitability of a design choice is not clear until much lower-level design or coding has taken place. If the general nature of the hierarchy leads to certain disreputable coding practices (see Gotchas #98 and 99), it's probably a cosmic hierarchy and should be refactored out of existence. Otherwise, it may simply be an acceptably general hierarchy.<P> Sometimes, refactoring our perceptions can improve a hierarchy, even without   source code changes. Many of the problems associated with cosmic hierarchies   have to do with employing an overly general base class. If we reconceptualize   the base class as an interface class and communicate this reconceptualization   to the users of the hierarchy, as in <a href="cuj0302dewhurst_f4.htm">Figure   4</a>, we can avoid many of the damaging coding practices mentioned earlier.<P>Our design no longer expresses a cosmic hierarchy but three separate hierarchies that leverage independent subsystems through their corresponding interfaces. This is a conceptual change only, but an important one. Now employees, vehicles, and contracts may be manipulated as assets by an asset subsystem, but the subsystem, because it's ignorant of classes derived from <B>Asset</B>, won't attempt to uncover more precise information about the <B>Asset</B> objects it manipulates. The same reasoning applies to the other interface classes, and the possibility of a run-time type-related error is small.<P><h3>Notes</h3>[1]  Steve Dewhurst. <I>C++ Gotchas: Avoiding Common Problems in Coding and Design</I> (Addison-Wesley, 2002).<P>[2]  Ibid., p. xi.<p><h3>About the Author</h3>Stephen C. Dewhurst (&lt;www.semantics.org&gt;) is the president of Semantics Consulting, Inc., located among the cranberry bogs of southeastern Massachusetts. He specializes in C++ consulting, and training in advanced C++ programming, STL, and design patterns. Steve is also one of the featured instructors of The C++ Seminar (&lt;www.gotw.ca/cpp_seminar&gt;).<p></BODY></HTML>