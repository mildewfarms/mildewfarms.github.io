<HTML><HEAD><TITLE>Listing 2:	Code for scanning through the heap portion of memory and solution to the guard region problem</TITLE></HEAD><body bgcolor="#FFFFFF" text="#000000"><B>Listing 2:</b>	Code for scanning through the heap portion of memory and solution to the guard region problem<p><pre>static jmp_buf jmpenv;static void segvHandler(int signo){  longjmp(jmpenv, 1);}static struct sigaction oaction;#define SET_SIGSEGV_ACTION { \  struct sigaction action; \  action.sa_sigaction = NULL; \  action.sa_handler = segvHandler; \  action.sa_mask = 0; \  action.sa_flags = SA_RESTART; \  sigaction(SIGSEGV, &amp;action, &amp;oaction); }#define RESET_SIGSEGV_ACTION \  sigaction (SIGSEGV, &amp;oaction, NULL);#define SETJMP(e) setjmp(e)static void memtrackCheckLeaks(void){  void** scanPoint;  /* check initialized data, BSS, and heap */  SET_SIGSEGV_ACTION;  for(scanPoint = (void**)&amp;_fdata;       scanPoint &lt; (void**)sbrk(0);       ++scanPoint)  {    if (SETJMP(jmpenv) == 0)    {      for(; scanPoint &lt; (void**)sbrk(0); ++scanPoint)      {        if (scanPoint == (void**)&amp;memList[0])         {          scanPoint = (void**)&amp;memList[memListAllocated];        }        else if (*scanPoint &gt;= lowAddress &amp;&amp; *scanPoint &lt;=           highAddress)        {          AllocRec* mem;          if ((mem = memList_find(*scanPoint)) != NULL)          {            mem-&gt;refExists |= REF_TO_START;          }          else if ((mem = memList_findInRange(*scanPoint)) != NULL)          {            mem-&gt;refExists |= REF_TO_WITHIN;          }        }      }    }  }  RESET_SIGSEGV_ACTION;</pre></BODY></HTML>