<HTML><HEAD><TITLE>Automated Memory Checking in C</TITLE></HEAD><body bgcolor="#FFFFFF" text="#000000"><h2>Automated Memory Checking in C</h2><h3>Zlatko Marcok</h3><i>If you know the physical layout of your system's memory, you can verify its integrity automatically. Here's how.</i><P><h3>Introduction</h3>Memory management poses problems for even experienced programmers. Memory leaks, writing past allocated bounds, and incorrect releasing of memory can make a program perform unpredictably. Some languages, such as Java, are based on the premise that the problem is too complex for programmers and should be handled at the system level. In C, where efficiency is paramount, the programmer takes responsibility for memory management. C programmers can find help through commercially available tools or build extra monitoring code around the standard memory functions. The extra code records information about memory allocations and ensures that memory is used properly. If you are fortunate enough to work on a project in its initial phases, you can call your custom memory allocation functions directly. If you already have a large existing code base, you can still take advantage of your custom memory management functions with only minor source-code changes. All you need is a cooperative C preprocessor. This article presents a technique, called the memtrack library, for linking custom memory functions into a large project. The memtrack library will notify you of the following with a high degree of certainty:<P><ul><li>  Memory being released or reallocated, where the pointer is invalid or does not refer to the start of the allocated block.<li>  Memory being released multiple times.<li>  The functions <B>strdup</B>, <B>strcpy</B>, or <B>strcat</B> being called with invalid parameters or attempting a write beyond allocated bounds.<li>  A potential or actual memory leak.</ul>This article is applicable to all Unix systems. However, some of the information is specific to DEC Unix and the DEC Alpha architecture. In particular, to detect memory leaks, you must know where to look for memory references, so you must know how a program is laid out in the OS-specific virtual memory. Hopefully, I have presented enough background to enable you to fill in your own OS-specific information.<P><h3>Memory in a Unix Program</h3>A program in a Unix system is divided into the following segments [1]:<P><ul><li>  A text segment, containing the executable instructions.<li>  A data segment, containing initialized global variables.<li>  A BSS (Block Started by Symbol) segment, containing uninitialized global variables. BSS is a historical assembler directive.<li>  The stack segment, containing automatic variables and function return information.<li>  The heap segment, containing dynamically allocated memory. The heap region grows, usually from low to high addresses, when there is not enough memory in the heap to satisfy a request.</ul>Typically, the stack and heap are at opposite ends of an address space. On the DEC Alpha, a process in virtual memory is organized from low to high addresses in the following order: stack, text, data, BSS, and heap [2]. The variables providing the addresses of the segment boundaries are documented in the Unix section 3 man page entitled <B>end</B>, and the section 2 man page entitled <B>brk</B>. The locations of interest are the start of the text segment (<B>&amp;_ftext</B>), the start of the initialized data region (<B>&amp;_fdata</B>), the start of the heap (<B>&amp;_end</B>), and the end of the heap (<B>sbrk(0)</B>).<P><h3>Implementation</h3>To provide the required diagnostic information, the memtrack library records the filename and line number from which a memory allocation function is called. On a large established project, it is impractical to change all the function calls to provide this information. The solution is possible with the C preprocessor. When the compiler is invoked, the <B>-D</B> option is used to define replacements in source code. For example, if you specify <B>-Dmalloc=MEMTRACK_MALLOC</B>, all instances of <B>malloc</B> will be replaced with <B>MEMTRACK_MALLOC</B>. In <B>memtrack.h</B> (<a href="cuj0302marcok_l1.htm">Listing 1</a>), <B>MEMTRACK_MALLOC(size)</B> is defined as <B>memtrackMalloc(size, __FILE__, __LINE__)</B>, providing the filename and line number to <B>memtrackMalloc</B>. <B>memtrackMalloc</B> executes the Standard C <B>malloc</B> and returns the result. This idea is extended to <B>calloc</B>, <B>realloc</B>, <B>valloc</B>, <B>strdup</B>, <B>strcpy</B>, <B>strcat</B>, and <B>free</B>. The definitions are undone within <B>memtrack.c</B> (available for download from &lt;www.cuj.com/code&gt;), allowing the Standard C versions of the functions to be called from there.<P>The memtrack library maintains a dynamic array, <B>memList</B>, of allocation record (<B>AllocRec</B>) structures. When memory is allocated, an allocation record is created and appended to <B>memList</B>. When memory is freed, the record is overwritten with the last <B>memList</B> item. This keeps the array packed with minimal overhead for insertions and deletions. <B>memList</B> grows or shrinks as needed in increments of <B>MEMLIST_CHUNK</B> (defined as <B>512</B>) elements. The variables <B>memListAllocated</B> and <B>memListConsumed</B> record how much free space is available.<P>When a request is made to use allocated memory, <B>memList</B> is searched for the allocation record to validate the request. If an allocation record cannot be found or the pointer is suspect, a warning message is displayed, but the operation continues as requested, giving the caller the benefit of the doubt. <B>memList</B> may be out of sync with reality if libraries not compiled with the memtrack definitions release memory allocated through memtrack. This is rare; typically, the allocation and release of memory is done from the same module. In my experience, the warnings have always indicated an error in programming. In cases where a pointer is invalid, such as a non-heap space being freed, the operation is not done, and an error message is printed.<P>Each allocation request made through the memtrack library actually allocates one element more than was requested. The extra element at the end stores a one-byte sentinel, defined by <B>END_SENTINEL</B>. The library periodically checks the sentinels of all allocations, to ensure that memory has not been written past its allocated bounds.<P>When memory is freed, it is filled with <B>FREED_FLAG</B>, a printable character, to make freed memory usage more visible. Memory is freed by <B>memtrackFree</B>. The function checks for a non-heap pointer (i.e., one out of the heap range). If the pointer seems good, the function searches for the allocation record using <B>memList_remove</B>, which removes the record from <B>memList</B> and returns a copy of it. If the allocation record is not found, the function uses <B>memList_findInRange</B> to check if the pointer being freed refers to within some allocated block. This may be a programming error and a warning message is printed. If no allocation block can be found, <B>memtrackFree</B> checks for <B>FREED_FLAG</B> at the pointer. The presence of the flag may indicate that the memory has already been freed and causes a warning message.<P>The memtrack versions of <B>malloc</B>, <B>calloc</B>, <B>valloc</B>, and <B>strdup</B> are straightforward because they deal with the request for new memory; the <B>memtrackRealloc</B> function is more complicated. The <B>realloc</B> function is typically used to reallocate previously allocated memory, copying the contents of the old memory location to the new location. However, if it is called with <B>NULL</B>, it functions as <B>malloc</B>, and if it is called with 0 as the new size, it functions as f<B>ree</B>. The first thing <B>memtrackRealloc</B> does is determine how it is called and delegates the work to <B>memtrackFree</B> or <B>memtrackMalloc</B> if required. It searches for an allocation record and performs the same validation checks as <B>memtrackFree</B>: checking that the pointer has not been freed and that it refers to the start of an allocated region.<P><h3>Detecting Memory Overrun</h3>Most versions of the <B>malloc</B> family allocate more memory than requested, using the extra memory for record keeping. Writing beyond allocated bounds can corrupt these records and other program data, causing an abort or invalid behavior. Such problems are hard to diagnose because they are intermittent and the symptoms are usually far removed from the cause. Memory overrun can occur whenever a pointer is used to write to memory, so it cannot always be caught as it occurs, but it can be caught when done through a function. The functions <B>strcpy</B> and <B>strcat</B> are particularly susceptible to overrun because they don't have an explicit length parameter. The memtrack library redefines these two functions so that the destination size is passed to the functions with the source and destination parameters. The <B>sizeof</B> operator calculates the destination size during compilation. If the destination happens to be an array, <B>sizeof</B> will evaluate to the length of the array. In this way, the code:<P><pre>char d[32]; strcpy(d,"abc");</pre>becomes:<P><pre>char d[32];memtrackStrcpy(d,"abc",32,f.c,1);</pre>If <B>sizeof(destination)</B> equals <B>sizeof(char*)</B>, the destination is assumed to be a pointer, and its allocation record is searched for in <B>memList</B>. With the allocation record, the functions determine the space available for the operation -- keeping in mind that the memory size recorded in the allocation block must accommodate the <B>END_SENTINEL</B>. The memtrack versions of <B>strcpy</B> and <B>strcat</B> will fulfill the request up to the valid end of the destination, if it can be determined. They will not allow a memory overrun and will print a warning message if one is attempted. If no allocation record is found, the string operation is performed silently. Other functions that could be redefined in this way are <B>memcpy</B>, <B>memccpy</B>, <B>memset</B>, <B>memmove</B>, <B>bcopy</B>, and <B>bzero</b>.<P>The <B>memtrackCheckSentinels</B> function checks that all allocated blocks have the <B>END_SENTINEL</B> byte in place. This function produces an error message, stating the point of allocation, for each block missing <B>END_SENTINEL</B>.<P><h3>Detecting Memory Leaks</h3>Memory leaks are divided into two categories -- leaks and potential leaks. In this implementation, a leak occurs when no memory location available to the process contains a reference to the allocated block. A potential leak occurs when the only reference to an allocated block points to within the block. Potential leaks usually become real leaks, or -- even worse -- invalid calls to <B>free</B>. The <B>memtrackCheckLeaks</B> function detects leaks by examining each writeable location of the program, interpreting its value as a candidate pointer, and searching for an allocation record corresponding to the pointer. Each allocation record found is marked as having either a reference to the start of or to within its allocated block, as the case may be. For efficiency, the <B>lowAddress</B> and <B>highAddress</B> variables represent the address extremes of allocated memory. Candidate pointers outside this range are not searched for in <B>memList</B>. When all the writeable locations have been examined, the allocation records are checked. Those having no references marked are displayed as leaks, and those having only references to within their allocated blocks are displayed as potential leaks.<P>Candidate pointers are obtained by searching the stack, heap area, environment area, and optionally, the machine integer registers. Checking machine registers is the most problematic and least critical. Each processor has its own specific number of general-purpose integer registers, and each compiler seems to have its own syntax for embedded assembler code. The source code available at &lt;www.cuj.com/code&gt; shows the method for a DEC Alpha architecture using the DEC cc compiler. Using the DEC cc compiler, the syntax <B>asm("mov $1, %v0)</B> will move the value in register <B>1</B> to the return register (<B>%v0</B>) where it can be picked up as a return value by C. This is done for each register, resulting in a register snapshot. It is necessary to take a snapshot before making any search through <B>memList</B> since the search itself will cause <B>memList</B> addresses to be placed into the registers. Don't be concerned if you cannot read the registers on your machine. I've run the implementation without the register checking with no loss in effectiveness.<P>The stack is searched from the current frame, up to the start of the program text segment (<B>&amp;_ftext</B>). The current stack-frame address is roughly the address of a local variable in the <B>memtrackCheckLeaks</B> function. The remaining address space is checked from the start of the initialized data region (<B>&amp;_fdata</B>), to the end of the heap (<B>sbrk(0)</B>). Naturally, the memory containing <B>memList</B> itself is bypassed, since it has references to all allocated memory. Finally, the environment area is searched. The environment area (see <B>man environ(5)</B>) is an array of strings that may be modified by a program through the <B>setenv</B> function call. A program may pass allocated memory to <B>setenv</B>, so the environment area must be checked to prevent false leak reports.<P>memtrack will not catch all leaks. It is not possible to determine if a value in memory that looks like a pointer is really a pointer, and there may be occurrences where a value is mistaken as an actual reference to allocated memory. Circular references that are no longer accessible from the program's variables also create an undetectable leak. For example, if a reference to allocated block <B>x</B> is placed in an allocated block <B>y</B>, and vice versa, and the program's references to <B>x</B> and <B>y</B> are lost, an undetectable leak is created.<P><h3>Automating Checking</h3>Checking for memory leaks and corrupted memory is triggered by a change to <B>memList</B> so that no function calls need to be added to existing source. Because the leak checking is relatively time consuming, it is executed automatically only if the time given by <B>AUTOCHECK_PERIOD</B> has elapsed since the last check. For debugging purposes, you can modify a program to explicitly call <B>memtrackCheckPeriodic(int period)</B>, which checks for memory leaks if <B>period</B> seconds have elapsed since the last leak check and checks for corrupted end-of-block sentinels on each call.<P><h3>Integration into a Project</h3>To integrate the memtrack library into your project, you need to make the following definitions when the compiler is invoked:<P><pre>-Dcalloc=MEMTRACK_CALLOC -Dmalloc=MEMTRACK_MALLOC-Drealloc=MEMTRACK_REALLOC -Dvalloc=MEMTRACK_VALLOC-Dfree=MEMTRACK_FREE -Dstrdup=MEMTRACK_STRDUP-Dstrcat=MEMTRACK_STRCAT -Dstrcpy=MEMTRACK_STRCPY</pre>Large projects typically have a central makefile that is included in all other makefiles. The central makefile usually contains compiler- and machine-specific flags and is the ideal place to put the definitions.<P>Each source file that contains any of the redefined routines needs to include <B>memtrack.h</B>. A large project typically has at least one header file of utility functions that is included almost everywhere. By adding <B>memtrack.h</B> to that header file, you will greatly reduce the number of source files you must edit.<P>You must also link in the object file produced by <B>memtrack.c</B>. If you have a library of utility functions that is common to most of your executables, then simply add <B>memtrack.o</B> to that library. For executables that do not use the library, you will have to edit their makefiles to link in the library. My experience has been that by appending the memtrack library to existing code in this way, minimal changes need to be made in a well-organized project.<P>During your linking, you might get a message such as <B>Error: Undefined: MEMTRACK_MALLOC</B>. This may be the result of <B>memtrack.h</B> missing from a particular source file. Find the source file by scanning through all the object files for the <B>MEMTRACK</B> text; go to the top of your build tree and execute the (Korn) shell script:<P><pre>#!/usr/bin/kshfor i in 'find . -name "*.o"'do    if [[ 'nm $i | grep MEMTRACK         | wc -l' -ne 0 ]]    then        echo $i    fidone</pre>This script will print out all the object files whose source files require <B>memtrack.h</B>. Edit the corresponding source files and rebuild.<P>The link will also fail if some of the functions to be redefined are actually passed as parameters. For example:<P><pre>void f1(void* data,        void(*freeFun)(void*)) {    freeFun(data);}void f2(void) {    f1(buf, free)}</pre>In this case, the function redefinition scheme will not work even with <B>memtrack.h</B> present. The solution is to create a proxy function with the same signature, as shown below:<P><pre>static void myFree(void* buf) {    free(buf);}void f2(void) {    f1(buf, myFree)}</pre><h3>Multithreading Issues</h3>The memtrack library is POSIX thread safe. You can build it in multithreaded mode by defining <B>MULTI_THREAD</B>. In multithreaded mode, all access to <B>memList</B> is protected by a mutex declared in the <B>mutexOp</B> function, and the macros <B>MUTEX_LOCK</B> and <B>MUTEX_RELEASE</B> are defined to call that function. In a multithreaded program, each thread's stack is placed on the heap. At the end of each thread stack is a guard region designed to cause a segmentation violation when accessed. Unfortunately, I have not found a way to determine the start and end of all the guard regions, nor have I been able to deactivate them. <a href="cuj0302marcok_l2.htm">Listing 2</a> shows code to scan through the heap portion of memory and my heavy-handed solution to the guard region problem. The code uses a signal handler in combination with <B>setjmp</B>/<B>longjmp</B> to push its way through the guard regions. Before the heap is scanned, the <B>SET_SIGSEGV_ACTION</B> macro sets the <B>segvHandler</B> function to be executed on a segmentation violation. The <B>SETJMP</B> macro issues a <B>setjmp</B> call, saves the current execution context, and returns <B>0</B>. When the <B>segvHandler</B> is called, it executes a <B>longjmp</B>, bringing the program back to the point of the <B>setjmp</B> function call. However, now the <B>setjmp</B> returns <B>1</B>, not <B>0</B>, passing control to the outer loop and incrementing the <B>scanPoint</B>. In this way, the inaccessible regions are eventually passed and scanning can continue. After the heap scan, the original <B>SIGSEGV</B> action is restored with <B>RESET_SIGSEGV_ACTION</B>. In single-threaded mode, the macros <B>SETJMP</B>, <B>MUTEX_LOCK</B>, <B>MUTEX_RELEASE</B>, <B>SET_SIGSEGV_ACTION</B>, and <B>RESET_SIGSEGV_ACTION</B> are no-ops.<P><h3>Conclusion</h3>The techniques described here use some features of the preprocessor that may not be common knowledge. These features may require research into some esoteric aspects of Unix system programming. However, you'll find no tricky algorithms here. Once you know the conventions of how memory is laid out in your system, the operations are straightforward. Considering that, I have been both pleased and surprised at the effectiveness of this solution. I've integrated it into a 700-file, 500,000-line project (excluding header files) with ease. It has exposed many instances of memory leaks, memory overruns, usage of freed memory, and freeing of automatic variables. I have found this technique especially useful as an instructional tool for novices, but it has saved me from my own code on many occasions as well.<P><h3>References</h3>[1]  W. Richard Stevens. <I>Advanced Programming in the Unix Environment</I> (Addison-Wesley, 1993), Chapter 7.<P>[2]  <I>Digital Unix Assembly Language Programmer's Guide</I> (Digital Equipment Corporation, March 1996), Chapter 7.<p><h3>About the Author</h3>Zlatko Marcok has a BASc in Computer Engineering from the University of Waterloo, Canada. He has been developing software for 11 years and is currently on contract with Ontario Power Generation. Reach him at <B>wmarcok@pathcom.com</B>.<p></BODY></HTML>