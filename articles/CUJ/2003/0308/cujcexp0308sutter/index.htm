<html><head><title>Generalized Function Pointers</title><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"></head><body><h2>Generalized Function Pointers</h2><h3>by Herb Sutter</h3><I>Copyright (c) 2003 Herb Sutter</I> <p><i>The <b>function</b> facility, recently adopted by the C++ standards committee, provides   a generalized way of working with arbitrary functions when all you know (or   need to know) is their signature. In fact, as it turns out, you don't even need   to know the target function's exact signature -- any target function with a   compatible signature, meaning one where the parameter and return types are appropriately   covertible, will work just fine.</i><p>Last time [1], I gave an overview of tuple types, one of the first two library   extensions that were approved in October 2002 for the standard library extensions   technical report (the "Library TR"). In this article, I'll cover the other:   Doug Gregor's proposal for polymorphic function object wrappers. [2] Note that   both of these facilities come directly from the Boost project [3], an important   (and free) collection of C++ libraries available for you to download and try   out today. <p> In brief, the <b>function</b> facility provides a generalized way of working   with arbitrary functions when all you know (or need to know) is their signature.   In fact, as it turns out, you don't even need to know the target function's   exact signature - any target function with a compatible signature, meaning one   where the parameter and return types are appropriately convertible, will work   just fine. <p> <h3>A Motivating Example</h3><p>Functions and functionlike things are everywhere: C++ has member functions,   static member functions, and nonmember (namespace scope) functions, and on top   of that it has functors (objects having an overloaded <b>operator()</b>) that   can be invoked as though they were functions. (I'm going to use the term &quot;functors&quot;   for the latter, instead of the alternative &quot;function objects,&quot; to   avoid confusion with &quot;<b>function</b> objects&quot; which means objects   of the <b>function</b> library we're discussing.)</p><p>Calling a plain old function is easy: </p><pre>// Example 1(a): Calling a nonmember function//string AppendA( string s ) { return s + 'a'; } string test = "test";// Making an immediate call is easy:// cout &lt;&lt; AppendA( test ) &lt;&lt; endl;             // immediate call</pre><p>When it comes to using a function, however, it turns out that <i>what</i> and   <i>when</i> to call aren't always decided at the same time. That is, a program   may determine early on exactly which function needs to be called, long before   it is ready to actually make the call; as noted in [2], a prime and common example   is registering a callback function. In cases like that, we routinely know to   squirrel away a reference to the function, typically by using a function pointer: <pre>// Example 1(a), continued//// Making a delayed call involves storing a pointer// (or reference) to the function://<font color="#009900">typedef string (*F)( string ); F f = &AppendA;                               // select function...</font>// ... later...cout &lt;&lt; <font color="#009900">f( test )</font> &lt;&lt; endl;                    <font color="#009900">// ... make delayed call</font></pre><p>This is handy and pretty flexible, in that <b>f</b> can be made to point to any nonmember   function that takes and returns a <b>string</b>. <p>But of course the above method doesn't work for all functions and functionlike   things. For example, what if we instead wanted to do this with a member function?   "That's easy," someone might say, "we just have to store a member function pointer   instead of a free function pointer, and then use it appropriately." That's true,   and it means we would write code that looks something like this: <pre>// Example 1(b): Calling a member function//class B {public:  virtual string AppendB( string s ) { return s + 'b'; }};class Derived : public B {  string AppendB( string s ) { return s + "bDerived"; }}; string test = "test";B b;Derived der;// Making an immediate call is easy://cout &lt;&lt; b.AppendB( test ) &lt;&lt; endl;            // immediate call// Making a delayed call involves storing a pointer// (or reference) to the member function, and requires// some appropriate object to call it on://<font color="#009900">typedef string (B::*F)( string );F f = &B::AppendB;                            // select function...</font>// ... later...cout &lt;&lt; <font color="#009900">(b.*f)( test )</font> &lt;&lt; endl;               <font color="#009900">// ... make delayed call</font>cout &lt;&lt; <font color="#009900">(der.*f)( test )</font> &lt;&lt; endl;             // ... another delayed call,                                              //   virtual dispatch works</pre><p>That's fine, and this works, but note that it's already considerably less flexible   than in Example 1(a). Why? Because the <b>f</b> in Example 1(b) can only be   made to point to member functions <I>of class <b>B</b></I> that take and return   a <b>string</b>; this <b>f</b> can't be used to point to a member function of   any other class, even if it otherwise has the right signature. While we're at   it, note one more limitation: This <b>f</b> also doesn't carry around with it   the knowledge of which <b>B</b> object to invoke. We can get rid of this last   limitation, remembering the object on which the call should be made, by using   the standard function binders: <pre>// Example 1(b), continued: Alternative, using binders//<font color="#009900">typedef binder1st&lt;mem_fun1_t&lt;string,B,string&gt; &gt; F2;F2 f2 = bind1st( mem_fun( &B::AppendB ), &b );</font> // ... later...cout &lt;&lt; <font color="#009900">f2( test )</font> &lt;&lt; endl;                   <font color="#009900">// ... make delayed call</font>f2 = bind1st( mem_fun( &B::AppendB ), <font color="#009900">&der</font> );// ... later...cout &lt;&lt; <font color="#009900">f2( test )</font> &lt;&lt; endl;                   // ... another delayed call,                                              //  virtual dispatch works</pre><p>The type of <b>F2</b> is unfortunately ugly, and it still is limited to binding   to member functions of class <b>B</b> having an exact signature. <p>Of course, if the thing we wanted to call was actually a functor object, then   none of the above options would work, this despite the fact that for immediate   calls the functor can indeed be used seamlessly as though it were a function: <pre>// Example 1(c): Calling a functor//class C {public:  string operator()( string s ) { return s + 'c'; }}; string test = "test";C c;// Making an immediate call is easy://cout &lt;&lt; c( test ) &lt;&lt; endl;                    // immediate call// Making a delayed call is trickier. There's no easy way without// fixing the type of the object as a C, such as by taking a C&...://<font color="#009900">typedef C& F;F f = c;                                      // select functor...</font>// ... later...cout &lt;&lt; <font color="#009900">f( test )</font> &lt;&lt; endl;                    <font color="#009900">// ... make delayed call</font>// ...or by arranging for C to inherit from some common base class// with a virtual operator() and then taking a pointer or reference// to that base.</pre><p>That covers nonmember functions, member functions, and functors. Finally, on   a note that applies to all of these, what if you have a function (or functor)   that you could call directly just fine, but the parameter types, although compatible,   aren't quite identical? Consider a variant of Example 1(a): <pre>// Example 1(d): 1(a) with slightly different types//// A little class just to get some conversions happeningclass Name {public:  Name( string s ) : s_( s ) { }  string Get() const { return s_; }private:  string s_;};// Stubbed-in function to demonstrate varying// parameter and return types:<font color="#009900">const char*</font> AppendD( <font color="#009900">const Name&</font> s ) {  static string x;  x = s.Get() + 'd';  return x.c_str();} string test = "test";// Making an immediate call is still easy://cout &lt;&lt; AppendD( test ) &lt;&lt; endl;              // immediate call// But the typedef from Example 1(a) no longer works,// even though the rest of the call is unchanged://<font color="#009900">typedef string (*F)( string ); F f = &AppendD;                               // error: type mismatch</font>// ... later (in our dreams)...cout &lt;&lt; <font color="#009900">f( test )</font> &lt;&lt; endl;                    <font color="#009900">// ... never get here</font></pre><h3>Enter function</h3><p>What if we had a facility that let you form a "function pointer" to any function   or functionlike thing? That would be genuinely useful. Enough people think it   would be genuinely useful, in fact, that many have gone off and written their   own using C++'s powerful templates, and today several versions of such facilities   exist; see [2] for some references. And <b>function</b> in the draft standard   library technical report is just such a facility, so "That's great, these already   exist," one might think. "Why write yet another one for the library technical   report?" Because these existing facilities are interesting (good), useful (even   better), and not always portable or compatible (oops). <p align="left">When something is genuinely and widely useful, and people keep   reinventing the same wheel in slightly different variations, we have a prime   candidate for standardization. After all, just imagine what the world would   be like if, instead of one standard <b>std::string</b>, every vendor supplied   their own incompatible <b>string</b> (or <b>CString</b>, or <b>RWString</b>,   or <b>blah_string</b>) type with different names and different interfaces and   features to learn and relearn on every system. Those of you who've been around   C++ since about 1995 or earlier don't need to imagine the horror of lots of   incompatible string types; you've lived it. Even today with a standard <b>string</b>,   we still have some of those variant vendor-specific string types floating around,   but at least there are far fewer of them than there used to be. Similarly now   with generalized function pointers, the standards committee felt it was time   we had a single general-purpose fucntion wrapper that we can rely on portably,   and the one that the committee has chosen to bless is <b>function</b>. <p>The <b>function</b> template takes a function signature as its only required   template parameter. (Following the practice of much of the rest of the standard   library, it also takes an optional allocator template parameter, which I'm going   to ignore henceforth.) Its declaration looks like this: <pre>template&lt;typename Function, typename Allocator = std::allocator&lt;void&gt; &gt;class function;</pre><p>How do you pass a function signature as a template parameter? The syntax may   seem slightly odd at first, but once you've seen it it's just what you'd think: <pre>function&lt; <font color="#009900">string (string)</font> &gt; f;                // can bind to anything that                                              // takes and returns a string</pre><p>Any function or functor that is callable with the specified signature can be   bound to the <b>function</b> object. In particular, the <b>function</b> object   above can bind to <I>all</I> of the functions shown in the earlier examples,   as demonstrated in Example 1(e): <pre>// Example 1(e): One function&lt;&gt; to bring them all,// and flexibly to bind them//// This code uses the same class and function definitions// from Examples 1(a) through (d)//string test = "test";B b;Derived der;C c;<font color="#009900">function&lt;string (string)&gt; f;</font>                  // can bind to anything that                                              // takes and returns a string<font color="#009900">f = &AppendA;</font>                                 // bind to a free functioncout &lt;&lt; f( test ) &lt;&lt; endl;<font color="#009900">f = bind1st( mem_fun( &B::AppendB ), &b );</font>cout &lt;&lt; f( test ) &lt;&lt; endl;	// bind to a member function<font color="#009900">f = bind1st( mem_fun( &B::AppendB ), &der );</font>cout &lt;&lt; f( test ) &lt;&lt; endl;                    // with virtual dispatch<font color="#009900">f = c;</font>                                        // bind to a functorcout &lt;&lt; f( test ) &lt;&lt; endl;<font color="#009900">f = &AppendD;</font>                                 // bind to a function with acout &lt;&lt; f( test ) &lt;&lt; endl;                    // different but compatible signature</pre><p>"Wow," you say? Wow indeed. Note in particular the implicit conversions going   on in the last case, for which we didn't even have legal code in Example 1(d)   - <b>AppendD</b>'s actual parameter and return types are not <b>string</b>,   but can be converted from and to a <b>string</b>, respectively, and that's good   enough for <b>function&lt; string (string) &gt;</b>. &nbsp;<h3>Another Motivating Example: Higher-Order Functions</h3>What if you want to write a function that returns a function? Today, you have two main choices: First, you could return a pointer to function, in which case that's all you get; in particular, you can't easily strap on state information, or a member function prebound to some variable that can carry the state. Second, you could return a full-fledged functor, but in that case there's a lot of boilerplate code that you'll reproduce each time. Instead, as Gregor demonstrates in [2], you can use a generalized <b>function</b> as follows. <p>Let's say you want to write an <b>arithmetic_operation</b> function whose purpose   in life is to return a functor that can perform some appropriate operation on   two <b>int</b>s, so that the calling code can store it and later invoke it at   the appropriate time. The catch: It has to decide <I>at runtime</I> what kind   of operation will be needed; perhaps you want to add, or perhaps you want to   subtract, or multiply, or divide, and so on. The <b>arithmetic_operation</b>   function should decide which is needed, create an appropriate functor (e.g,   <b>std::plus&lt;&gt;</b>, <b>std::minus&lt;&gt;</b>, etc.), and return it -   but then how do you write the return type of <b>arithmetic_operation</b>, when   the functors being returned all have different types? What you need is a return   type that can be constructed from any of those types of objects -- in this case,   a <b>function&lt;int (int, int)&gt;</b>: <pre>// Example 2: Higher-order functions// (reproduced from [2], section Ib)//function&lt;int (int x, int y)&gt; arithmetic_operation(char k){  switch (k) {    case '+': return plus&lt;int&gt;();    case '-': return minus&lt;int&gt;();    case '*': return multiplies&lt;int&gt;();    case 'c:\www.cuj.com/': return divides&lt;int&gt;();    case '%': return modulus&lt;int&gt;();    default: assert(0);  }}</pre><p>Note what's going on here: At runtime, the <b>arithmetic_operation</b> function   decides what kind of operation will be needed. Since each type can be bound   to a <b>function&lt;int (int, int)&gt;</b>, we're done; no fuss, no muss. <p> <h3>More To Come: Observer, Comparisons, and Multicast, Oh My!</h3>I have quite a bit more to say about <b>function</b> - more, as it turns out, than fits well in this overview column. While writing this overview, I inadvertently also stumbled straight into an analysis of a generalized Observer pattern implementation using function that has already turned into a (very long) article in its own right: the next <I>Sutter's Mill</I> column [5] (also published here in the CUJ Experts Forum). I've devoted that upcoming column to a deeper analysis of <b>function</b>. In that column, we will see how <b>function</b> is a powerful tool for generalizing important design patterns (e.g., Observer), but we will also see how that same analysis highlights two limitations in <b>function</b>'s design. One of the limitations is significant and fixable, and the other is less significant because there is an easy workaround. These two limitations are: <ul>  <li>    <div align="left"><I>Comparison</I>: The only significant limitation of <b>function</b>       is that <b>function</b> objects can't be compared, not even for equality.       As I will argue in depth in the upcoming companion column, there are compelling       reasons why <b>function</b> should provide at least equality comparison       (<b>==</b> and <b>!=</b>). This is possible and usefully implementable,       albeit with a ripple effect into the standard function binders (e.g., <b>std::mem_fun</b>).     </div>  <li> <i>Multicast</i>: Another, but fortunately less significant, limitation of   <b>function</b> is that a <b>function</b> object can only be bound to one thing   at a time. The reason this is not too significant a limitation is that there's   a perfectly good workaround: It's possible to build a <b>multi_function</b>   on top of <b>function</b> pretty easily and effectively, and I will motivate   and demonstrate that as well in the companion column, including a sample (i.e.,   working, but rough) implementation.</ul>   <h3>Summary</h3> <p>For all of its power, <b>function</b> isn't all that expensive to use. Gregor   notes: &quot;A <b>boost::function&lt;&gt;</b> object is 3 pointers large (it could   be optimized to 2 in most cases), and requires one extra indirect call (through   a function pointer) for each invocation of the <b>boost::function&lt;&gt;</b> object.   If one is careful, you can make sure that no big arguments are copied by the   bridge to further reduce the penalty for large objects, although I haven't implemented   this. (It's a simple application of, e.g., <b>boost::call_traits</b> to the parameter   list).&quot; [6]<p>Further, it's again a testament to the power of C++ that a <b>function</b>   that works with all functions and functors can be implemented purely as a library   facility, without any extensions to the existing standard C++ core languages.   Don't try this at home in less-flexible languages. <p>In the next <I>The New C++ column</I>, I'll give a trip report on the April   2003 C++ standards meeting, held in Oxford, UK. The big news: Whereas in the   October 2002 meeting the first two extensions were adopted for the standard   library extensions technical report, in April no fewer than <I>ten</I> more   were added. What were they, and which ones might you particularly care about?   Stay tuned. <p><h3>References</h3><p>[1] H. Sutter. "Tuples" (<I>C/C++ Users Journal</I>, 21(6), June 2003). </p><p>[2] D. Gregor. "A Proposal to add a Polymorphic Function Object Wrapper to   the Standard Library," ISO/ANSI C++ standards committee paper (ISO/IEC JTC1/SC22/WG21   paper N1402, ANSI/NCITS J16 paper 02-0060). </p><p>[3] www.boost.org</p><p>[4] H. Sutter. <I>More Exceptional C++</I> (Addison-Wesley, 2002). An earlier   version of this material is available online at <I>www.gotw.ca/gotw/057.htm</I>. </p><p>[5] H. Sutter. "Generalizing Observer" (<I>C/C++ Users Journal</I>, 21(9),   September 2003). [<I>should be published within 2-3 weeks of this article</I>]</p><p>[6] D. Gregor, private communication</p><p><h3>About the Author</h3>Herb Sutter (&lt;www.gotw.ca&gt;) is convener of the ISO C++ standards committee, author of the acclaimed books <i>Exceptional C++</i> and <i>More Exceptional C++</i>, and one of the instructors of The C++ Seminar (&lt;www.gotw.ca/cpp_seminar&gt;). In addition to his independent writing and consulting, he is also C++ community liaison for Microsoft. </body></html>