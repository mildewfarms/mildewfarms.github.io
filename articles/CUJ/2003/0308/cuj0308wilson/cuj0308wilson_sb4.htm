<HTML><HEAD><TITLE>NULL Strings</TITLE></HEAD><body bgcolor="#FFFFFF" text="#000000"><h3>NULL Strings</h3>The standard library string <B>c_str()</B> method returns "a null-terminated array of characters representing the string's contents" [2]. It is important to note that it does not qualify this definition with whether the represented string is empty, so the implementation of the string may store a null pointer when an instance is in an "empty" state. But when called in that state it must still return a valid string; obviously it should return the empty string. A typical implementation would be like the following:<P> <pre>template &lt;...&gt;inline char_type const *string_class&lt;...&gt;::c_str() const{  return m_buffer != 0 ? m_buffer : "";}</pre>With C-strings, ie., <B>char const *</B>, an empty string can come in two forms, the empty string (which is a pointer to an array of one character, with value 0), or it can be the null string (which is the null pointer). This is a serious disparity. On many architectures, de-referencing the null pointer causes an access violation, and it is in all cases undefined, so it is something we want to avoid.<P> The strategy I chose for the string access shims was to implement <B>c_str_ptr</B>   to match the semantics of <B>c_str()</B>, hence it never returns a null pointer.   What this means is that any algorithm that uses the <B>c_str_ptr</B> shims can   rely on the fact that it will never be presented with a null string.<P> However, some uses of shims might require a NULL pointer to be returned when   the string is empty. This is supported by the shim <B>c_str_ptr_null</B>. Each   <B>c_str_ptr()</B> shim in the STLSoft libraries has a matching <B>c_str_ptr_null()</B>   shim, some of which are shown in <a href="cuj0308wilson_l11.htm">Listing 11</a>. </BODY></HTML>