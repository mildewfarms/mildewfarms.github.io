<HTML><HEAD><TITLE>Conversations: Factory Redux, Part 2</TITLE></HEAD><body bgcolor="#FFFFFF" text="#000000"><h2>Conversations: Factory Redux, Part 2</h2><h3>Jim Hyslop and Herb Sutter</h3> <i>Revisiting the Template Method factory, with a generic &lt;twist&gt; to it. This month: incorporating the PersistentStorage&lt;&gt; framework into your class hierarchy, and a summary of the pros and cons of this technique.</i><p>After we had all returned from lunch, we &#150;&#150; the Guru, Wendy, and I &#150;&#150; gathered at my cubicle to go over the rest of the persistence framework.<P> "This morning," the Guru began, "we finished the factory. Now that the framework   is complete, we can plug your class hierarchy into it. Suppose we want to write   code that uses streams for persistence. In your source code that deals with   persistence for the Base class to and from streams, you register the functions   by instantiating a <B>RegisterInFactory</B> object, specifying <B>istream</B>   and <B>ostream</B> as template arguments for the <B>Source</B> and <B>Sink</B>:"<pre>namespace {  RegisterInFactoryWithParams  &lt;     Base,     Base::BaseParams,     Base,     Base::BaseParams,     istream,     ostream  &gt;  registerBase( Base::baseID() );}</pre>"We're using the <B>BaseParams</B> struct you came up with," the Guru nodded at Wendy. "The class hierarchy is not entirely isolated from the persistence framework. We can create new objects easily enough without intruding into the hierarchy, but the base class will have to provide a means of saving the required information."<P> "I'll bet I know how this is going to work," I said. I took over the keyboard,   and modified the <B>Base</B> class: <pre>class Base{  template&lt; typename Sink &gt;  virtual void write( Sink &amp; o ) const;  </pre>"That would be the precise implementation," the Guru said, "but you've overlooked one minor point: Member template functions cannot be virtual, so I'm afraid it's going to have to be a little more roundabout than that."<P> "Why is that? Why can't template functions be virtual?" I wondered aloud.<P> "That will have to wait for another conversation," the Guru smiled enigmatically.   She erased what I wrote. "We will, of course, need a virtual function of some   sort, so that the persistence framework can deal only with the base class. The   virtual function will return an <B>auto_ptr</B> to a <B>BaseParams</B> class.   The contents of that class can then be passed to the <B>PersistentStorage&lt;&gt;</B>   framework for saving." <pre>class Base{public:  struct BaseParams  {    int value_;  };  virtual auto_ptr&lt; BaseParams &gt;    retrieveStorageInfo() const;</pre>"We also need to provide a function to perform the writing. We can use a member-function template to keep it generic, and not tied to streams." <pre>  template&lt;     typename Source,    typename Sink,    typename RestoreFn,    typename SaveFn  &gt;  void write( Sink &amp; o ) const  {    PersistentStorage    &lt;       string,       Sink     &gt;( o ).save( classID() );    GenericFactory    &lt;      Base,      BaseKeyType,      Source,      Sink,      BaseParams,      RestoreFn,      SaveFn    &gt;::instance().save(         classID(),         o,         *retrieveStorageInfo()    );  }   virtual BaseKeyType    classID() const;};</pre>"That's it, we're done," she said.<P> "Er, not quite," I said. "How does my program actually perform the saving   and restoring?" The Guru did not reply, but simply pushed the keyboard over   to me. I thought for a moment, then decided to start with the saving: <pre>typedef auto_ptr&lt; Base &gt;   (* BaseStreamRestoreFn)   ( istream &amp; ); typedef void    (*BaseStreamSaveFn)   ( ostream &amp;,      const Base::BaseParams &amp; );void saveBaseToStream(    Base &amp;b, ostream &amp; o){  b.write&lt;     istream,     ostream,    BaseStreamRestoreFn,    BaseStreamSaveFn  &gt;( o );}</pre>The Guru nodded her approval. "Very good. Now walk me through the save process."<P> "The <B>saveBaseToStream()</B> function calls the instantiation of the write   member function. The <B>Base::write</B> member function first writes the class's   type. Then it calls <B>GenericFactory::save()</B>, passing it the class type,   the output object (in this case, <B>ostream</B>), and the parameters to save.   The class type is retrieved from the virtual <B>classId()</B> function, the   output is specified in the member-template function instantiation as <B>istream</B>,   and the parameter is retrieved via the virtual function <B>retrieveStorageInfo()</B>.<P> "<B>GenericFactory::save</B>, which you wrote this morning, looks up the class   type in its registry, and invokes the save function registered with it. In the   case of a <B>Base</B> class, it calls <B>registerBase.saveInstance()</B>. <B>saveInstance()</B>   instantiates a <B>PersistentStorage&lt; Base::BaseParams</B>, <B>ostream &gt;   object</B>, and calls its <B>save()</B> function. The... um... the <B>PersistentStorage</B>...   uh, we forgot to specialize that."<P> "Quite so," the Guru said calmly. "Write a specialization for it now. Make   it generic as well, not tied to <B>ostream</B>." I thought for a moment. <pre>template&lt; typename Storage &gt;class PersistentStorage&lt;  Base::BaseParams, Storage &gt;{public:  explicit PersistentStorage(     Storage &amp; os )    : warehouse_( os )  {  }  void save(     const Base::BaseParams &amp; bp   ) const  {    PersistentStorage&lt; int,       Storage &gt;    ( warehouse_ ).save( bp.value_ );  }protected:    Storage &amp; warehouse_;private:    Base::BaseParams param_;};</pre>"Right, we're cooking now," I said. "The <B>PersistentStorage&lt; Base::BaseParams</B>, <B>Storage &gt;</B> partial specialization will use specializations for the <B>int</B> member. I'll create a specialization for <B>PersistentStorage&lt; int, std::ostream &gt;</B>, and in its <B>save()</B> function I'll insert the value into the stream."<P> "Well done, my child," the Guru dropped momentarily back in her act, as Bob   walked by on his way to get a latte. "My daughter," she nodded at Wendy, "would   you care to write the restore part of the picture?" Wendy slid in at the keyboard.<P> "First, I'm going to provide a <B>typedef</B>," she said as she tapped at   the keyboard.<P> "Getting a little lazy in your old age?" I knew Wendy had just celebrated   her birthday, and was a little sensitive about that topic.<P> "Watch it, junior," she said in her best imitation of Bob. "There's another   reason for the <B>typedef</B> &#150;&#150; the factory takes a lot of parameters,   and you don't want to risk getting some of them wrong." <pre>typedef GenericFactory&lt;         Base,         string,         istream,         ostream,        Base::BaseParams,         BaseStreamRestoreFn,        BaseStreamSaveFn        &gt; BaseFactoryUsingStreams;auto_ptr&lt;Base&gt;restoreBaseFromStream(     istream &amp;i ){  BaseFactoryUsingStreams &amp;     factory =    BaseFactoryUsingStreams::      instance();  string className =     PersistentStorage    &lt;      string,      istream    &gt;( infile ).restore();  auto_ptr&lt;Base&gt; newBase(     factory.create(       className,      infile ) );  return newBase;}</pre>"The <B>restoreBaseFromStream</B> function reads the class identifier from the stream and just passes that on to the factory's <B>create</B> function, along with the input stream. I'll also have to write specializations for <B>PersistentStorage&lt; string, istream &gt;</B> and <B>PersistentStorage&lt; string</B>, <B>ostream &gt;</B>. [1] The interesting part is in the specialization on <B>PersistentStorage&lt; Base::BaseParams, Storage &gt;</B>." She added the restore function to the specialization: <pre>  Base::BaseParams &amp; restore()  {    param_.value_ =       PersistentStorage&lt;         int,         Storage&gt;( warehouse_ ).        restore();    return param_;  }</pre>"Like the <B>save()</B> function, this function will take advantage of an int/ostream specialization, and pass on the work to it."<P> "Well done " the Guru said. "Now, we have to turn our attention to the derived   classes. For the derived class, we need to do four things: register the class   in the factory, create the <B>DerivedParams</B> struct, override the <B>retrieveStorageInfo</B>   function, and provide a <B>PersistentStorage</B> partial specialization. Registering   the class is simple enough:" <pre>RegisterInFactoryWithParams&lt;  Base,   Base::BaseParams,  Derived,   Derived::DerivedParams,   istream,   ostream&gt; registerWithParams(     Derived::derivedClassID() );</pre>"Well, the <B>DerivedParams</B> will be pretty straightforward," I said, as I took the keyboard from Wendy and started typing:<pre>struct DerivedParams :   public Base::BaseParams{  std::string word_;};</pre>I smiled as I slid the keyboard back to Wendy. Then I caught the Guru's expression, and my heart sank. I had seen that expression many times before, when I was sure I had the answer but had overlooked something.<P> "Perhaps you should override the <B>retrieveStorageInfo</B> function," she   simply said.<P> "Uh, OK," I replied. <pre>auto_ptr&lt; Base::BaseParams &gt;Derived::retrieveStorageInfo() const{    auto_ptr&lt; BaseParams &gt; bp(      Base::retrieveStorageInfo()    );</pre>"Oh, I get it now," I said. "The <B>DerivedParams</B> struct has to be initialized from the <B>BaseParams</B> struct that we get from <B>Base::retrieveStorageInfo()</B>, so we need to add an overloaded constructor to <B>DerivedParams</B>." I went back, and added the requisite constructor to <B>DerivedParams</B>: <pre>  DerivedParams(    const BaseParams &amp; bp,    const string &amp; word )  : BaseParams( bp ),    word_( word )  {  }</pre>I smiled at the Guru. My smile faded, though, because she still had that "you're forgetting something" look on her face.<P> "Perhaps you should implement the <B>PersistentStorage::restore </B>function   now," she said. I turned to the keyboard again: <pre>template&lt; typename Storage &gt;class PersistentStorage&lt;  Derived::DerivedParams,  Storage &gt;: public PersistentStorage  &lt;    Base::BaseParams,    Storage  &gt;{  typedef PersistentStorage  &lt;    Base::BaseParams,    Storage   &gt; Parent;public:  Derived::DerivedParams &amp; restore()  {    Derived::DerivedParams param(      Parent::restore(),      PersistentStorage&lt;        std::string,        Storage&gt;( warehouse_ ).        restore()      );    return param;  }</pre>"Ah, of course," I said as soon as I finished typing. "The <B>restore() </B>function returns a reference, so it can't return a local object. The object it returns will have to have a longer lifetime, so I'll have to... um..." I faltered, as I thought about how to fix the problem.<P> "...make the param object a member of the <B>PersistentStorage</B> template,"   the Guru picked up smoothly. "Since in this case, the member is initialized   when the <B>PersistentStorage</B> template is initialized, it cannot use overloaded   constructors to set up the member variables, you will have to provide an assignment   operator." She took over the keyboard, and added the assignment operator. <pre>DerivedParams &amp; operator=(  const BaseParams &amp; bp ){  BaseParams::operator=(bp);  return *this;}</pre>She paused before erasing the constructor. "There are, of course, certain implementations that will require you to construct the <B>DerivedParams</B> object each time you call restore," she said. "When you are restoring objects that contain references to other objects, the <B>DerivedParameters</B> cannot, of course, reseat the reference to refer to the new object, so it must be reconstructed. Handling references in persistence, though, is a much wider topic, and deserves a conversation on its own." <P> "Now, though, you are ready to finish off the <B>retrieveStorageInfo </B>function."   She slid the keyboard back to me. <pre>auto_ptr&lt; Base::BaseParams &gt;Derived::retrieveStorageInfo() const{  auto_ptr&lt; BaseParams &gt; bp(    Base::retrieveStorageInfo()  );  auto_ptr&lt; DerivedParams &gt;    ret( new DerivedParams );  *ret = *bp;  ret-&gt;word_ = word_;  return auto_ptr&lt; BaseParams &gt;    ( ret.release() );}</pre>"Ick," I said, "I'm dynamically allocating two objects, one of which is only used to initialize the final object being returned."<P> "Well, you could make it a two-stage creation," Wendy commented. "Have one   virtual function that returns a new, default-initialized parameter object, and   another function that initializes it." She wrote on my whiteboard: <pre>auto_ptr&lt; BaseParams &gt;  createStorageInfo() const;void setStorageValues(  BaseParams &amp; ) const;</pre>"The drawback here, of course, is having two virtual functions to override, instead of one."<P> "Let us stick with the original approach for now," the Guru interrupted, "as   time grows short. Now you will want to rework your <B>PersistentStorage</B>   template's restore function." <pre>Derived::DerivedParams &amp; restore(){  param_ = Parent::restore();  param_.word_ = PersistentStorage  &lt;    std::string,    Storage  &gt;( warehouse_ ). restore();  return param_;}</pre>"It's simple enough," I explained. "I use the assignment operator to reinitialize the <B>BaseParams</B> portion, then set the <B>DerivedParams</B> portion &#150;&#150; the <B>word_ </B>member<B> </B>&#150;&#150; and return the member."<P> "All that remains now is to finish the implementation of the <B>PersistentStorage</B>   template specialization, for the <B>save()</B> function." Wendy took over at   the keyboard: <pre>  void save( const Derived::DerivedParams &amp; params )  {    Parent::save( params );    PersistentStorage    &lt;      std::string,      Storage    &gt;( warehouse_ ).save(      params.word_ );  }</pre>"This one really is straightforward," she explained. "All we do is invoke the parent specialization of <B>PersistentStorage</B>, then store our own data."<P> "Well, done, my children," the Guru slipped back into her act, as Bob returned   from the lunch room with his latte. "My apprentice, what are the benefits of   this approach?"<P> "Well, for one, the class hierarchy is isolated from its storage medium. We   wrote specializations to use stream storage, but if we wanted to use, say, a   database, then all we have to do is provide a new set of specializations. These   specializations can be in completely independent source files.<P> "For another, we're not limited in the class constructors. Each class in the   hierarchy can take its own number and type of parameters."<P> "Wendy, the drawbacks?"<P> "It still suffers from the static initialization order problem. You can't   be sure a particular class will be registered before <B>main</B> executes.<P> "You have to have access to the source files&#150;&#150;you couldn't use this   on a third party class hierarchy. Not as-is, at least; you might be able to   provide a wrapper class hierarchy for persistence."<P> "Well done, my children," the Guru said as she got up and glided away.<h3>Notes</h3>[1] Space does not permit showing the specializations for <B>int</B> and stream. The source code for this article, available at &lt;www.cuj.com/code&gt;, contains a complete working program, that includes these specializations. <h3>About the Author</h3><P> Herb Sutter (&lt;www.gotw.ca&gt;)   is convener of the ISO C++ standards committee, author of the acclaimed books   <I>Exceptional C++</I> and <I>More Exceptional C++</I>, and one of the instructors   of The C++ Seminar (&lt;www.gotw.ca/cpp_seminar&gt;).   In addition to his independent writing and consulting, he is also C++ community   liaison for Microsoft. <p> Jim Hyslop is a senior software designer with over 10 years programming experience   in C and C++. Jim works at Leitch Technology International Inc., where he deals   with a variety of applications, ranging from embedded applications to Windows   programs. He can be reached at jhyslop@ieee.org. </BODY></HTML>