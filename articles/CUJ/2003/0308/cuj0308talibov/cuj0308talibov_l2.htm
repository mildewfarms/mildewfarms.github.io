<HTML><HEAD><TITLE>HexWeb HTML</TITLE></HEAD><body bgcolor="#FFFFFF" text="#000000"><B> Listing 2:</B>	<B>CSslCredentials class<P>... // other code not shown<P><P>// definition<P><P>class CSslCredentials<P>{<P>  friend class CSslProvider;<P><P>protected:<P>  CSslCredentials();<P>  ~CSslCredentials();<P><P>public:<P>  HRESULT Obtain(BOOL bAsServer, LPCTSTR strPrincipal, <P>    LPCTSTR strStore, BOOL bMutualAuth = FALSE, <P>    DWORD dwProtoFlags = 0);<P>  HRESULT Obtain(BOOL bAsServer, LPCTSTR strPrincipal, <P>    HCERTSTORE hStore, BOOL bMutualAuth = FALSE, <P>    DWORD dwProtoFlags = 0);<P>  HRESULT Obtain(DWORD dwProtoFlags = 0);<P>  <P>  HRESULT Attach(CredHandle hCredentials, BOOL bAsServer, <P>    BOOL bMutualAuth = FALSE, DWORD dwProtoFlags = 0);<P>  HRESULT Detach();<P><P>  BOOL IsServer() {return m_bServer;}<P>  BOOL MutualAuthRequired() {return m_bMutualAuth;}<P>  DWORD GetProtoFlags() {return m_dwProtoFlags;}<P><P>  BOOL HasCredHandle() <P>  {<P>    return SecIsValidHandle(&amp;m_hCredentials);<P>  }<P><P>  PCredHandle GetHandle() <P>  {<P>    return (HasCredHandle() ? &amp;m_hCredentials : NULL);<P>  }<P><P>  void CleanUp();<P><P>private:<P>  HRESULT OpenSysStore(LPCTSTR strStore, HCERTSTORE&amp; hStore);<P>  HRESULT FindCertificate(HCERTSTORE hStore, <P>    LPCTSTR strPrincipal, PCCERT_CONTEXT&amp; certContext);<P>  HRESULT ObtainImpl(PCCERT_CONTEXT certContext, <P>    BOOL bAsServer, BOOL bMutualAuth, DWORD dwProtoFlags);<P><P>private:<P>  CredHandle m_hCredentials;<P>  BOOL m_bServer;<P>  BOOL m_bMutualAuth;<P>  DWORD m_dwProtoFlags;<P>  HCERTSTORE m_hStore;<P><P>};<P><P>... // other code not shown<P><P>// implementation<P><P>HRESULT CSslCredentials::ObtainImpl(PCCERT_CONTEXT certContext,<P>                  BOOL bAsServer, <P>                  BOOL bMutualAuth, <P>                  DWORD dwProtoFlags)<P>{<P>  // Build Schannel credentials structure.<P>  SCHANNEL_CRED credSchannel = {0};<P>  credSchannel.dwVersion = SCHANNEL_CRED_VERSION;<P>  credSchannel.grbitEnabledProtocols = dwProtoFlags;<P><P>  if (certContext != NULL)<P>  {<P>    credSchannel.cCreds = 1;<P>    credSchannel.paCred = &amp;certContext;<P>  }<P><P>  // Create SSL credentials.<P>  TimeStamp tsExpires;<P>  HRESULT hr = CSspiLib::AcquireCredentialsHandle(<P>      NULL,<P>      UNISP_NAME,<P>      (bAsServer ? <P>        SECPKG_CRED_INBOUND : <P>        SECPKG_CRED_OUTBOUND),<P>      NULL,<P>      &amp;credSchannel,<P>      NULL,<P>      NULL,<P>      &amp;m_hCredentials,<P>      &amp;tsExpires);<P><P>  // See, if we have succeeded<P>  if (SUCCEEDED(hr))<P>  {<P>    m_bServer = bAsServer;<P>    if (m_bServer)<P>      m_bMutualAuth = bMutualAuth;<P>    m_dwProtoFlags = dwProtoFlags;<P>  }<P>  else<P>    TRACE(_T("Line: %d. Error: 0x%08X\n"), __LINE__, hr);<P><P>  return hr;<P>}<P><P>... // other code not shown<P><P>HRESULT CSslCredentials::OpenSysStore(LPCTSTR strStore, <P>                    HCERTSTORE&amp; hStore)<P>{<P>  CT2CA storeName(strStore);<P>  m_hStore = ::CertOpenSystemStore(0, storeName);<P>  if (m_hStore == NULL)<P>  {<P>    DWORD dwErrCode = ::GetLastError();<P>    return HRESULT_FROM_WIN32(dwErrCode);<P>  }<P><P>  return S_OK;<P>}<P><P>HRESULT CSslCredentials::FindCertificate(<P>          HCERTSTORE hStore, <P>          LPCTSTR strPrincipal, <P>          PCCERT_CONTEXT&amp; certContext)<P>{<P>  USES_CONVERSION;<P>  CT2CA hostName(strPrincipal);<P>  ASSERT(m_hStore != NULL);<P>  certContext = ::CertFindCertificateInStore(<P>    m_hStore, <P>    X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, <P>    0,<P>    CERT_FIND_SUBJECT_STR_A,<P>    hostName,<P>    NULL);<P><P>  if (certContext == NULL)<P>  {<P>    DWORD dwErrCode = ::GetLastError();<P>    return HRESULT_FROM_WIN32(dwErrCode);<P>  }<P><P>  return S_OK;<P>}<P></pre>
</BODY></HTML>