<HTML><HEAD><TITLE>C++ Made Easier: Four First Steps to Modern C++ Programming</TITLE></HEAD><body bgcolor="#FFFFFF" text="#000000"><h2>C++ Made Easier: Four First Steps to Modern C++ Programming</h2><H3>Andrew Koenig and Barbara E. Moo</h3><p><i>The title says it all. Get on board, if you haven't done so already.</i> <p>One reason that C++ became popular is its familiarity to C programmers. Especially   in C++'s early days, this familiarity made it easy for C programmers to learn   C++ as an addition to what they already knew. As a result, most people who taught   and wrote about C++ at that time assumed C as a prerequisite&#150;&#150;or taught   the fundamentals of C before covering the rest of C++. </p><P> In the past few years, it has become easier to learn C++ without having to   learn C first. One important reason is that several essential parts of the C   language and Standard Library have C++ counterparts that have become universally   available as part of the C++ Standard. These C++ counterparts are easier to   use and fit better with the rest of C++ than do the C versions. Accordingly,   programmers who wish to use C++ effectively have a good reason not to bother   with those parts of C unless they need them for other purposes.<P> These C++ facilities were not part of the earliest C++ implementations. When   the C++ Standard was published in 1998, most implementations had not yet caught   up to the standard. This fact is not surprising; usually it takes at least four   years between the decision to make a major change in a software system and the   time that the change becomes widely available to users. Accordingly, when we   wrote <I>Accelerated</I> C++ (published in 2000, two years after the C++ Standard),   we expected that although the C++ Standard Library would be generally available,   some early readers would have to change the book's programs slightly to deal   with their implementations' limitations. We also expected that any such difficulty   would go away over the next couple of years. It is now nearly five years since   the C++ Standard's publication, and, as we expected, the programs in <I>Accelerated</I>   C++ work just fine on current C++ implementations. In short, Standard C++ has   entered the mainstream, so it is time for us to start taking advantage of it   as a matter of course.<P> In <I>Accelerated C++</I>, we tried to follow three principles consistently:<ul><li> Explain ideas in an order that will let the reader solve useful problems   as quickly as possible, rather than grouping similar features together. <li> Explain how to use library facilities that already exist before explaining   how to implement one's own libraries.   <li> Use the standard C++'s library facilities instead of their C counterparts.</ul>  <P> At the time, these three principles were radically different from the usual     ways of teaching C++. Even today, we believe that reasonable people can disagree     about the first two principles.  <P> The third principle is a different matter. Now that good implementations     of the Standard Library are widely available, we believe that it is time for     everyone who sets out to teach, learn, or use C++ to prefer key parts of the     C++ Library to their C counterparts. Programmers who wish to learn more about     C can do so later.  <P> In this context, we consider four parts of the C++ Library to be particularly     important: strings, typed input-output, vectors, and algorithms. The rest     of this article will explain these notions, and why we think they are important.    <h3>Strings</h3>  Of all the ways in which the C++ Library makes programming easier, the <B>string</B>   class probably offers the biggest payoff for the least effort. A data structure   such as   <pre>     struct Person {          std::string name, address;     };</pre>  offers an easy way to store character data that might vary in length, without   having to worry about memory allocation, bounds checking, and all of the other   problems that come with C-style string handling. In particular, using the <B>string</B>   class makes it much easier to write programs that avoid the "buffer overrun''   bugs that are the source of so many recent, heavily publicized security problems.  <P> We would have thought by now that the security benefits alone of using the     standard <B>string</B> class instead of dealing explicitly with character     arrays would be so obvious that there would be no need for us to advocate     using <B>string</B>s instead of character arrays. Nevertheless, we still see     programs that use data structures such as   <pre>     struct Person {          char name[30], address[50];     };</pre>  People who use such data structures take a host of problems on their shoulders.   For example, how should a program treat a person with a name longer than 30   characters? All too many programs assume that such a name will never appear,   and then crash when it comes along. For that matter, how should a program treat   a person with a name that is exactly 30 characters long, noting that the null   character at the end of C-style strings usually makes them take up one character   more than their nominal length?  <P> To make these questions more concrete, suppose <B>p</B> is an object of     type <B>Person</B>. Now imagine that you have just read a name into a local     variable named <B>name</B>, that you wish to copy this name into <B>p.name</B>,     and that you do not know how long the name in <B>name</B> is. If you are using     the C version of <B>struct</B> <B>Person</B>, there are several ways of solving     this problem, all of them flawed. For example, you might write     <pre>     strcpy(p.name, name);</pre>  but if <B>name</B> is too long, this call will crash. Alternatively, you can   defend against the crash by writing:     <pre>     strncpy(p.name, name, sizeof(p.name));</pre>  This version won't crash even if <B>name</B> is too long, but it will omit the   null terminator from the end of <B>p.name</B>, possibly provoking a crash later.   Of course, this call to <B>strncpy</B> will also quietly truncate a name that   is too long, a side effect that may or may not be desirable.   <P> It is possible to defend against the delayed crash by writing:     <pre>     strncpy(p.name, name, sizeof(p.name));     p.name[sizeof(p.name)-1] = '\0';</pre>  This revision forces the last character of <B>p.name</B> to be a null character.   If the name in <B>name</B> is exactly 29 characters long, this null character   will act as a terminator; otherwise it will have no effect. Would you have thought   of the need to put this null character there if we hadn't pointed it out to   you?   <p>In contrast, if we are using the C++ version of <B>struct Person</B>, we     can write:     <pre>     p.name = name;</pre>  For that matter, this code will work regardless of whether <B>name</B> is a   <B>string</B> or a null-terminated character array. Virtually every other operation   on standard C++ strings is similarly easier and safer than the corresponding   operation on C-style strings.  <h3>Typed input-output</h3>  The classic first C program is one that merely announces its existence on the   standard output stream:     <pre>     #include &lt;studio.h&gt;     int main()     {          printf("Hello, world!\n");          return 0;     }</pre>  Even this tiny program conceals two problems that point C++ beginners in the   wrong direction. The first problem is that the program suggests that <B>Hello,   world!</B> is data to be printed. That suggestion is misleading: The string   <B>"Hello, world!\n"</B> is really a <I>format</I> that describes the output.   The distinction between format and data is important because some characters,   particularly the <B>%</B> character, have special meanings as part of format   strings but not as part of data strings. We can make the program less misleading   by rewriting it:     <pre>     #include &lt;stdio.h&gt;     int main()     {          printf("%s\n", "Hello, world!");          return 0;     }</pre>  This revision makes it plain that what we are printing is the string <B>Hello,   world!</B>, and that we are following that string by a newline that we are treating   as a line terminator, rather than as part of the data. The revised version also   reveals the second problem: The <B>printf</B> format strings can contain sequences   of characters, each beginning with <B>%</B>, that correspond to the other arguments   to <B>printf</B>. The reason that this correspondence is the problem is that   the particular characters that follow the <B>%</B> are required to match the   <I>type</I> of the corresponding argument.  <P> To see why the type-matching requirement is a problem, consider the following     statement:     <pre>     printf("%d\n", 12.34);        /* undefined behavior */</pre>  This statement tries to write a double value (<B>12.34</B>) with a format string   (<B>%d</B>) that demands an <B>int</B>; the effect of doing so is undefined.   Implementations are permitted to check whether the relevant part of the format   string matches the type of the associated expression, but they are not required   to do so. Moreover, such checking is not always feasible at compile time, and   the effect at run time of failure to check is anyone's guess.  <P> In contrast, the standard C++ input-output library uses overloading to choose     appropriate formatting during compilation. For example, the classical first     C++ program,     <pre>     #include &lt;iostream&gt;     int main()     {          std::cout &lt;&lt; "Hello, world!" &lt;&lt; std::endl;          return 0;     }</pre>  does not use a format string at all. Instead, it uses an output format that   is inferred from the fact that <B>"Hello, world!"</B> is a string literal. In   that sense, this C++ program expresses more clearly than its C counterpart the   idea of printing the string <B>Hello, world!</B> followed by a newline.  <P> From a C++ viewpoint, the need to match format strings with argument types     is more than just a matter of run-time safety. For one thing, <B>printf</B>     formats do not encompass even such commonly used C++ types as <B>string</B>.     Programs that use <B>string</B>s have to go to extra trouble to print them     with <B>printf</B>:     <pre>     string hello = "Hello, world!";     printf("%s\n", hello.c_str());</pre>  Here, the call to <B>c_str</B> returns a value that is appropriate to pass as   an argument to <B>printf</B>. Again, the effect of a program that tries to print   <B>hello</B> instead of <B>hello.c_str()</B> is undefined. Programmers who use   the native C++ I/O library can avoid this inconvenience:     <pre>     string hello = "Hello, world!";     std::cout &lt;&lt; hello &lt;&lt; std::endl;</pre>  Because the C++ Library overloads <B>&lt;&lt;</B> appropriately, the type of   <B>hello</B> selects the appropriate output routine, and the programmer does   not have to mention the type of <B>hello</B> explicitly in order to print it.  <P> It is even harder to use <B>printf</B> in the presence of templates. In     general, objects' types in template code are unknown until the program is     compiled, which makes it difficult to choose appropriate characters for format     strings as part of writing a program. Indeed, an appropriate format string     may not even exist, because there is no way to extend <B>printf</B> format     strings to encompass user-defined types.  <P> Because the C++ Library uses overloading to select the format to use, there     is no particular problem in adding new types to the ones that already exist;     one merely writes new overloaded versions of <B>&lt;&lt;</B>. Moreover, in     a statement such as:     <pre>     std::cout &lt;&lt; x;</pre>  the compiler will select the appropriate <B>&lt;&lt; </B>during compilation,   without the programmer having to know the type of <B>x</B> as part of writing   the program.   <h3>Vectors</h3>  A question that surfaces frequently on Usenet is "Why doesn't C++ let you say   how many elements an array has at run time?" The typical example looks something   like this:     <pre>     int n;     std::cin &gt;&gt; n;     int x[n];             // Why isn't this                           // legal?</pre>  The typical answer is that one can write it this way instead:     <pre>     int n;     std::cin &gt;&gt; n;     std::vector&lt;int&gt; x(n);</pre>  This answer is true, but misleading, because in practice, merely being able   to allocate an array of a given size is not enough, even if the size doesn't   need to be known during compilation. A typical case is when one has a collection   of data, and not until after one has read the entire collection that one knows   how many elements it has. For example:     <pre>     std::vector&lt;int&gt; x;     int n;     while (std::cin &gt;&gt; n)          x.push_back(n);</pre>  Here, the vector <B>x</B> starts out with no elements at all. Each iteration   of the loop appends an element to <B>x</B>. When the program reaches the end   of the input, all of the input values are in <B>x</B>. Until then, <B>x</B>   grows as needed to accommodate the input data.  <P> The library has to do a surprising amount of work to get this kind of allocation     right. To see how much work it is, try doing it yourself. We shall dismiss     right away the notion of using <B>malloc</B> or <B>free</B>, because these     functions allocate raw memory, not C++ objects. Therefore, we shall explore     the consequences of using <B>new</B> and <B>delete</B> to allocate dynamically     sized arrays. For example, let's suppose we've allocated an array with <B>n</B>     elements of type <B>T</B>:     <pre>     T* array = new T[n];</pre>  At this point, <B>array</B> points to the initial element of the array that   we've allocated. Suppose that we want to cause this array to contain <B>m</B>   elements instead. We might do so this way:     <pre>     T* newarray = new T[m];     std::copy(array, array +         std::min(m, n), newarray);     delete[] array;     array = newarray;</pre>  The first line of this code allocates the new array, which we want to contain   <B>m</B> elements. The second line relies on the fact that when we add an integer   <B>x</B> to a pointer to an array element, the result is a pointer to a position   <B>x</B> elements further into the array. In other words, <B>array</B> points   to an element of an array &#150;&#150; in this case, element number <B>0</B>.   Therefore, if we add an integer to <B>array</B>, we get a pointer to the corresponding   element. So <B>array + std::min(m, n)</B> is a pointer to element number <B>m</B>   or element number <B>n</B> of the array, whichever is first. <B>array + std::min(m,   n)</B> points one past the last element we wish to copy from the old array to   the new array. The call to <B>std::copy</B> copies just those elements.  <P> However, this code has a problem: It's not exception safe. If an exception     occurs while <B>std::copy</B> is executing, some of the elements of the array     will have been copied and others won't. Moreover, we will have two arrays     sitting around, one with <B>array</B> pointing to its initial element and     the other with <B>newarray</B> pointing to its initial element. We can make     this code behave better in the presence of exceptions by rewriting it this     way:     <pre>     {         T* newarray = new T[m];         try {             std::copy(array, array +                  std::min(m, n),                       newarray);         } catch(...) {             delete[] newarray;             throw;         }         delete[] array;         array = newarray;     }</pre>  This rewrite offers what is usualy called the <I>strong exception guarantee</I>:   Either it completes successfully or it leaves the program in the state it was   in before the code started. If the call to <B>new</B> throws an exception, it   should be obvious that the state is back where it was. If an exception occurs   inside <B>std::copy</B>, then we delete the new array and propagate the exception   to the surrounding context. As usual, we assume that destructors and <B>delete</B>   statements will not throw exceptions.  <P> If we use the <B>vector</B> class instead, we can reallocate a <B>vector</B>     to contain <B>m</B> elements, while offering the strong exception guarantee,     simply by calling     <pre>     v.resize(m);</pre>  We can imagine reasons why one might eventually want to learn how to deal with   memory explicitly, but we feel strongly that there is no reason to do so until   after becoming thoroughly familiar with vectors.    <h3>Algorithms</h3>  Many C Library functions, such as <B>sqrt</B>, are also useful in C++. However,   several C functions are intended to offer generic algorithms; the C++ versions   of these functions are much more useful. Two such functions that are particularly   important to avoid are <B>memset</B> and <B>memcpy</B>. For example, we sometimes   see code like this:     <pre>     double x[100], y[100];     // ...     memcpy(x, y, sizeof(x));</pre>  In C, this example is probably the most sensible way to copy the contents of   <B>y</B> into <B>x</B>. However, it is an example of very bad technique in C++,   because it works only if <B>x</B> and <B>y</B> are of so-called POD types&#150;&#150;that   is, that they have no user-defined (or library-defined) constructors or assignment   operators. So, for example, if <B>x</B> and <B>y</B> were arrays of <B>strings</B>,   this example would fail. A much better way of accomplishing the same thing in   C++ is:     <pre>     std::copy(y, y + 100, x);</pre>  The first two arguments to <B>std::copy</B> are the beginning and one past the   end of the range to copy; the third argument is the beginning of the destination.  <P> Because <B>std::copy</B> takes user-defined assignment into account, this     usage would work equally well if <B>x</B> and <B>y</B> were arrays of strings     or of other user-defined or library types.  <P> Heeding our earlier advice to use <B>vector</B>s would have simplified the     program still further:     <pre>     vector&lt;double&gt; x, y;     // ...     x = y;</pre>  The <B>memset</B> function is particularly problematic because people often   use it in ways that are technically illegitimate. For example:     <pre>     int x[100];     // ...     memset(x, 0, sizeof(x));</pre>  The call to <B>memset</B> sets every byte of the memory that <B>x</B> occupies   to zero. On most C++ implementations, doing so will cause the integer elements   of <B>x</B> to take on the value zero. However, this behavior is not guaranteed,   which makes this program fragment particularly insidious. In effect, such uses   of <B>memset</B> cause bugs that no amount of testing can ever be assured of   revealing. A much better way to accomplish the same thing is to use the <B>std::fill_n</B>   function:     <pre>     int x[100];     // ...     std::fill_n(x, 100, 0);</pre>  The first argument points to the initial element to be filled, the second argument   is the number of elements, and the third is the value to use to fill the range.   So, for example, instead of calling <B>std::fill_n</B> to initialize <B>x</B>,   we can write     <pre>     std::fill(x, x + 100, 0);</pre>  In such contexts, the <B>std::fill</B> function is also often useful. Like <B>std::copy</B>,   its first two arguments denote a range; the third argument is the value to use   to fill the range.  <P> Another C function to avoid is <B>qsort</B>. To see why, here's an example     of what it takes to use it. Suppose, again, that <B>x</B> is an array with     100 elements:     <pre>     int x[100];</pre>  To use <B>qsort</B> to sort this array, we would call <B>qsort</B> this way:     <pre>     qsort(x, 100, sizeof(int),          compare);</pre>  The first argument is a pointer to the initial element of the array to be sorted.   The second and third arguments are the number of elements and the size, in bytes,   of a single element. The fourth argument is a comparison function, which we   must supply.  <P> The comparison function takes pointers to two elements of the array and     returns a negative, zero, or positive value, depending on the relative order     of the elements. Because <B>qsort</B> is intended to be generic, its arguments     can't be pointers to a specific type. In C++, the usual way to deal with generic     types is by using templates. However, C doesn't have templates, so <B>qsort</B>     can't use templates for genericity. Instead, <B>qsort</B> passes the comparison     function two pointers to <B>const</B> <B>void</B>, which we must cast into     pointers to the appropriate type. Here is one possible comparison function:     <pre>     int compare(const void* p1,          const void* p2)     {          int i1 = *(const int*) p1;          int i2 = *(const int*) p2;          if (i1 &lt; i2)               return -1;          if (i1 &gt; i2)               return 1;          return 0;     }</pre>  In contrast, using <B>std::sort</B> to sort this array is much simpler:     <pre>     std::sort(x, x + 100);</pre>  Moreover, <B>std::sort</B> can also sort vectors.  <P> We cannot imagine a case in which it is better to use <B>qsort</B> in a     C++ program than it is to use <B>std::sort</B>. Indeed, because <B>qsort</B>     effectively uses <B>memcpy</B> to copy the elements of the array that it is     sorting, there is no reliable way to use <B>qsort</B> to sort an array of     strings or of many other user-defined types.  <h3>Conclusion</h3>  C++ became popular because it offered C programmers a way of programming more   abstractly. Because of this fact, most people who set out to teach and learn   C++ in its early days began by assuming a knowledge of C++ &#150;&#150; and   by teaching that knowledge to students who did not already have it. As a result,   it became customary to introduce people to C++ through C.  <P> Now that good implementations of the Standard C++ Library are generally     available, the situation has changed. We believe that the most effective way     to teach -- or learn -- C++ is to bypass several fundamental parts of C entirely.  <P> Strings and vectors make many kinds of programs dramatically easier to write     than do their C counterparts. Moreover, because they relieve the programmer     of the burden of keeping track of memory, they make buffer overruns and related     security problems much less likely.  <P> The C++ input-output and algorithm libraries make programs easier to write     by taking advantage of the C++ language's abstraction facilities. Accordingly,     they keep working in the face of user-defined types in ways that the C facilities     cannot do.  <P> Arrays, <B>printf</B>, <B>malloc</B>, <B>free</B>, <B>strcpy</B>, <B>strncpy</B>,     <B>memcpy</B>, <B>memmove</B>, and <B>qsort</B> all have their place. However,     we believe that place should no longer be part of introducing C++ to new programmers,     whether or not they already know C. <p><h3>About the Author</h3><p> Andrew Koenig retired from AT&amp;T's research division in June, 2003. A programmer   for more than 35 years, 17 of them in C++, he has published more than 150 articles   about C++ and speaks on the topic worldwide. He is the author of <I>C Traps   and Pitfalls</I> and co-author of <I>Ruminations on C++</I> and <I>Accelerated   C++</I>. <P> Barbara E. Moo is an independent consultant with 20 years' experience in the   software field. During her nearly 15 years at AT&amp;T, she worked on one of   the first commercial projects ever written in C++, managed the company's first   C++ compiler project, and directed the development of AT&amp;T's award-winning   WorldNet Internet service business. She is co-author of <I>Ruminations on C++</I>   and <I>Accelerated C++ </I>and lectures worldwide. </BODY></HTML>