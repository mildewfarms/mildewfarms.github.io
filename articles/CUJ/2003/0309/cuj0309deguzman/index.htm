<HTML><HEAD><TITLE>The Spirit Parser Library: Inline Parsing in C++</TITLE></HEAD><body bgcolor="#FFFFFF" text="#000000"><h2>The Spirit Parser Library: Inline Parsing in C++</h2><h3>Joel de Guzman and Dan Nuffer</h3> <i>Powerful parsing made easy via modern template techniques.</i> <P> <h3>Introduction</h3>Everyday programming often requires writing parsers. The Internet and networking opened up the information floodgates such that software engineers have to deal with more human-to-computer communication, as well as computer-to-computer communication. HTML, XML, SQL, RDF, XDR, Postscript, OS shells, scripting languages, and even tasks such as extracting command-line options and reading files require various degrees of parsing. <P> Unfortunately, many programmers do not approach parser creation as a language   design task, and they code parsers by hand. For simple to moderately complex   tasks, many programmers stay away from tools such as YACC because of the "jumbo   jet" syndrome. (It's just too big and detached from the application.)   Many of today's parsing tasks would have been well served by a C++ library-based   parser somewhere between Posix-style regular expressions and a full-blown parser. <P> Spirit is an attempt to fill the missing gap between existing regular-expression   tools and computer-language-oriented parser generators. It is an object-oriented,   back-tracking, recursive descent parser generator framework implemented using   template metaprogramming techniques. Expression templates, taking advantage   of the expressiveness of operator overloading in C++, allow Spirit to approximate   the syntax of EBNF (Extended Backus Normal Form) completely in C++ using a syntax   closely resembling EBNF. (For more information on EBNF, see the <a href="cuj0309deguzman_sb1.htm">sidebar</a>.) <P> The Spirit library lets you write a target grammar exclusively in C++. Inline   EBNF grammar specifications can mix freely with other C++ code and generate   immediately executable parsers thanks to the generative power of C++ templates. <P> Character input is not limited to 8-bit ASCII. The library can easily work   with 16- and 32-bit characters such as Unicode. In fact, input data is an abstract   concept not limited to characters. Spirit can process data in the form of plain   bytes, user-defined <B>struct</B>s, or even objects. <P> <h3>Quick Start</h3>To elucidate, here is a trivial example. Parse a parenthesized, comma-delimited stream of unsigned integers of the form:  <pre>(i1, i2, i3 ... iN)</pre>and store the extracted numbers in a vector. First, define a rule for parsing unsigned integers. In standard EBNF, you would write this as:  <pre>&lt;integer&gt; ::= &lt;digit&gt;+</pre>This EBNF rule can be read as an unsigned integer is composed of one or more digits. Spirit's stylized C++/EBNF (SEBNF, for brevity) syntax attempts to mimic EBNF as closely as possible:  <pre>integer = +digit;</pre>Constrained to C++'s syntax, we deviate slightly from standard EBNF. EBNF's positive closure <B>+</B>, used to signify a one-or-more occurrence of <B>digit</B>, becomes prefix instead of postfix. (Spirit uses <B>+digit</B> instead of <B>digit+</B>.) Also, the assignment <B>=</B> operator, initiating a production rule declaration, replaces EBNF's <B>::=</B>.  <P><B>integer</B> is in itself a parser that can recognize numbers such as 1,   2, 123, and 456. Note that, by default, white spaces are skipped. Thus, in the   example, an input such as "1 2 3" is legal. However, we want the parser   to inhibit the skipping of white spaces when parsing numbers. This task is accomplished   by using the <B>lexeme</B> directive.  <pre> integer = lexeme[ +digit ];</pre><b>digit</b> is one of Spirit's primitives: a range of single character literals from 0..9. Actually, there are also predefined primitives for parsing integers and real numbers. Here, <B>integer</B> is explicitly defined. <P> Now we continue with the rest of the grammar. Remember that what we want is   a comma-delimited string of integers enclosed in parentheses. In standard EBNF,   this grammar would be written as:  <pre>&lt;numbers&gt; ::=   '(' &lt;integer&gt; (',' &lt;integer&gt;)* ')'</pre>So how would one write this in C++ using Spirit?  <pre>numbers =   '(' &gt;&gt; integer &gt;&gt; *(',' &gt;&gt; integer) &gt;&gt; ')';</pre>As already mentioned, the requisite changes from the original EBNF specification stems from the syntax restrictions imposed by C++. Most obviously, our SEBNF syntax necessitates a sequencing operator <B>&gt;&gt;</B> where in EBNF a white space would suffice. We say <B>'a &gt;&gt; b'</B> in Spirit instead of <B>'a b'</B>. Not unlike the positive closure <B>+</B> already mentioned, the Kleene star <B>*</B>, used to signify a zero-or-more occurrence of the enclosed expression <B>(',' &gt;&gt; integer)</B>, is prefix instead of postfix. <P> Finally we have a complete grammar for our trivial example:  <pre>rule&lt;&gt; integer, numbers;integer = lexeme[ +digit ];numbers = '(' &gt;&gt; integer &gt;&gt; *(',' &gt;&gt; integer) &gt;&gt; ')';</pre>Through the magic of expression templates, this code is perfectly valid C++. The production rule <B>numbers</B> is in fact an object that has a member function <B>parse</B> that does the work. As far as C++ is concerned, <B>integer</B> and <B>numbers</B> are objects that have to be declared before they are used. The first line starts with these requisite C++ type declarations. <P> The Spirit library has facilities to attach semantic actions to various points   in a grammar so as to produce a complete and fully working parser. Here is a   semantic action that inserts a parsed number into a vector:  <pre>std::vector&lt;long&gt; my_vec;void push(char const* str, char const* end){    my_vec.push_back(std::strtol(str, NULL, 10));}</pre>The function <B>push</B> accepts an iterator <B>str</B> that points to the first matching character, as well as an iterator <B>end</B> pointing to one past the last valid character. We want to attach this function to the <B>integer</B> production rule:  <pre>integer = lexeme[ (+digit)[&amp;push] ];</pre>Every time the parser recognizes a valid number, the number is appended to <B>my_vec</B>. <P> <h3>A More Complicated Example: The Classic Calculator Grammar</h3>The following is the EBNF grammar for an arithmetic expression:  <pre>&lt;integer&gt;     ::= '-'? &lt;digit&gt;+&lt;factor&gt;      ::= &lt;integer&gt;              | '(' &lt;expression&gt; ')'              | '-' &lt;factor&gt;&lt;term&gt;        ::= &lt;factor&gt; ( '*' &lt;factor&gt; | 'c:\www.cuj.com/' &lt;factor&gt; )*&lt;expression&gt;  ::= &lt;term&gt; ('+' &lt;term&gt; | '-' &lt;term&gt; )*</pre>Here is the corresponding snippet of code that uses SEBNF to define the same grammar:  <pre>rule&lt;&gt; expression, term, factor, integer;integer     = lexeme[ (!ch_p('-') &gt;&gt; +digit) ];factor      = integer            | '(' &gt;&gt; expression &gt;&gt; ')'            | '-' &gt;&gt; factor;term        = factor &gt;&gt; *( '*' &gt;&gt; factor | 'c:\www.cuj.com/' &gt;&gt; factor);expression  = term &gt;&gt; *( '+' &gt;&gt; factor | '-' &gt;&gt; term);</pre>The first line declares all of the rules. It is necessary to forward declare the rules because the <B>factor</B> rule references the <B>expression</B> rule, but the <B>expression</B> rule is defined later. <P> The <B>integer</B> rule will recognize an integer with an optional sign. The   <B>ch_p('-')</B> generates a parser that will accept the <B>-</B> character.   This rule uses three of the Spirit operators: <B>!</B>, <B>&gt;&gt;</B>, and   <B>+</B>. <B>!a</B> is equivalent to <B>a?</B> in EBNF and indicates that <B>a</B>   is optional. It will be matched zero or one time. <P> The <B>factor</B> rule introduces the <B>|</B> operator. This operator specifies   alternatives in which the expression <B>'a | b'</B> means that either <B>a</B>   or <B>b</B> will be matched. <P> Take note that the <B>factor</B> rule does not explicitly use <B>ch_p</B>.   Instead, the <B>'('</B>, <B>')'</B>, and <B>'-'</B> are applied directly as   arguments to the <B>&gt;&gt;</B> operator. If one of the operands in a binary   expression is a Spirit parser, such as the <B>factor</B> rule, the other operand   may be a literal character. The result of such an expression is another Spirit   parser. <B>ch_p</B> is used in the <B>integer</B> rule because a unary operator   <B>(!)</B> is applied. Without the <B>ch_p</B>, <B>!'-'</B> would simply evaluate   to false. <P> This example is not very useful, although it is valid code. All it can do   is recognize a string that belongs to the grammar. <a href="cuj0309deguzman_l1.htm">Listing   1</a> contains the complete code for a calculator that evaluates the expression   given to it. <P> A semantic action can be either a free function or function object (or functor   in STL terminology). One may be attached to any expression within a Spirit grammar   definition, using the expression <B>p[a]</B> where <B>p</B> is a parser and   <B>a</B> is a semantic action. When a match is made, the action will be called   and passed beginning and ending iterators (much like an STL algorithm) to the   input that was matched. <P> The <B>push_int</B> semantic action functor converts its input from a string   into a long <B>int</B> and then pushes it onto <B>evaluation_stack</B>. <P> The <B>do_op</B> semantic action template <B>struct</B> will apply another   function to the top two values popped from <B>evaluation_stack</B> and then   push the result back onto the stack. It is used to perform all binary arithmetic   operations done in the calculator. <P> For each binary operation (<B>+</B>, <B>-</B>, <B>*</B>, and <B>/</B>), the   appropriate <B>do_op</B> is created using the function objects from the standard   library to do the operations. The <B>make_op</B> helper function facilitates   creating <B>do_op</B> classes. <P> The <B>do_negate</B> semantic action will be called when the unary negation   <B>-</B> operator is invoked. <B>do_negate</B> pops a value from <B>evaluation_stack</B>,   negates it, and pushes the result back onto the stack. <P> After the parser has been created, the program reads a line from <B>cin</B>.   The expression is then parsed using the free <B>parse</B> function from the   library. Various <B>parse</B> functions in Spirit can be used in different situations.   The <B>parse</B> function used in the example takes as its parameters a <B>NULL</B>   terminated string, the top-level rule (traditionally called the start symbol)   of the grammar to be used for parsing, and a skip parser, which in this case   is <B>spirit::space</B>. The skip parser instructs the involved parser what   to skip. Using <B>spirit::space</B> as the skip parser simply means that all   space characters in between symbols and words in the input will be skipped. <P> <B>parse</B> returns a <B>parse_info struct</B>:  <pre>template &lt;typename IteratorT&gt;struct parse_info{    IteratorT  stop;    bool       match;    bool       full;    unsigned   length;};</pre>The member <B>stop</B> points to the final parse position (i.e., parsing processed the input up to this point). <B>match</B> is true if parsing is successful, which may be so if the parser consumed all the input (full match) or if the parser consumed only a portion of the input (partial match). <B>full</B> will be true when a full match occurs, meaning the parser consumed all the input. <B>length</B> is the number of characters consumed by the parser and is valid only if a successful match has occurred. <P> Finally, if the parse was successful, the result of the expression is printed   along with a success message. <P> Compiling the example is straightforward because the Spirit library consists   of only headers, as all the classes are templates. This makes it easy to use.   The library can be used straight out of the box. You only need to include the   <B>spirit.hpp</B> header. There is no library to link against. <P> <h3>Spirit behind the Scenes</h3><h3>The Parser</h3>The most fundamental concept behind Spirit's design is the <B>parser</B> class. A parser models a recognizer of a language from the simplest to the most complex. It has a conceptual member function:  <pre>parse(iterator&amp; first, iterator last)</pre>This function does the work of inspecting the <B>iterator</B> range and reporting success or failure. The iterator <B>first</B>, which is passed by reference, is advanced accordingly when a match is found. <P> The <B>parse</B> member function is conceptual, as opposed to virtual, in   the sense that the base class <B>parser</B> does not really have any such member   function. Subclasses must provide one. The conceptual base class is a template   class parametized by its subclass, which gives it access to its subclass. Whenever   a parser is asked to do its task, it delegates the task to its subclass. This   process is very similar to how virtual functions work, but the difference is   that the member function is bound statically instead of dynamically (run-time   bound). James Coplien first popularized this technique of compile-time polymorphism   in an article in <I>C++ Report</I> entitled "Curiously Recurring Template   Patterns" [1]. <a href="cuj0309deguzman_l2.htm">Listing 2</a> shows the   <B>parser</B> class and some examples of trivial subclasses. <P> Though quite simple, the example is not contrived, but it is an actual part   of the library. A <B>chlit</B> object merely compares a single character for   a match and advances the iterator one step forward when successful. The success   of a parse is encoded in a <B>match</B> object returned by the member function   <B>parse</B>. Aside from reporting a true or false result, the number of matching   characters from the input can also be obtained from this object. <P> <h3>Composites</h3>By itself, the <B>chlit</B> class might not seem very useful. Yet, composed to form a hierarchy, trivial parser classes can produce quite complex and elaborate parsing functionalities (see the <B>alternative</B> class in <a href="cuj0309deguzman_l3.htm">Listing 3</a> for an example). <P> This class is a composite parser class. It has two sub-parsers: <B>left</B>   and <B>right</B>. <B>parse</B> returns a success if one of its subjects is successful. <P> Through object composition alone, we can build parsers of arbitrary complexity.   The library includes a couple of predefined primitives (like <B>chlit</B>) as   well as composites (such as <B>alternative</B>). Primitives for parsing include   literal strings, ranges, and numerics. Composites include alternatives, sequences,   intersections, and differences. These parsers can be combined to form a hierarchy   in a multitude of ways. <P> <h3>Operators</h3>Primitives and composites can be composed to form more complex composites using operator overloading, coded in a way that mimics EBNF. Composing an <B>alternative</B>, for example requires two operands and is accomplished by overloading the operator <B>|</B> as shown here:  <pre>template &lt;typename A, typename B&gt;inline alternative&lt;A, B&gt;operator | (parser&lt;A&gt; const&amp; a, parser&lt;B&gt; const&amp; b){    return alternative&lt;A, B&gt;(        a.derived(), b.derived());}</pre>Given two <B>chlit</B> objects <B>a</B> and <B>b</B>, we can form an alternative composite object using the <B>|</B> operator:  <pre>a | b</pre>Assuming that both <B>a</B> and <B>b</B> have the type <B>chlit&lt;char&gt;</B>, the resulting composite is:  <pre>alternative&lt;chlit&lt;char&gt;, chlit&lt;char&gt; &gt;</pre>Continuing the example, the expression:  <pre>a | b | c</pre>where <B>a</B>, <B>b</B>, and <B>c</B> all have the type <B>chlit&lt;char&gt;</B>, will generate a nested composite with the type:  <pre>alternative&lt;alternative&lt;     chlit&lt;char&gt;, chlit&lt;char&gt; &gt;,     chlit&lt;char&gt; &gt;</pre>All composite parsers follow the same style of object aggregation. The difference lies in the algorithms used by each class's <B>parse</B> member function. The <B>sequence</B> class appears in <a href="cuj0309deguzman_l4.htm">Listing 4</a>. <P> The <B>sequence</B> class is very similar to <B>alternative</B>, but it has   a slight twist in the implementation of its <B>parse</B> member function. <B>sequence</B>   matches both its subjects (<B>left</B> and <B>right</B>) in strict sequence.   Like <B>alternative</B>, <B>sequence</B> has a corresponding overloaded operator:   the <B>&gt;&gt;</B> operator. <P> <h3>Unary and Binary Composites</h3>So far, we have just tackled binary composites such as <B>alternative</B> and <B>sequence</B>. Unary composites work similarly to binary composites but with only a single subject. The Kleene star, used for zero or more iterations, and the positive closure, used for one or more iterations, are examples of unary composites. <a href="cuj0309deguzman_l5.htm">Listing 5</a> shows the Kleene star class implementation. <P> As is obvious by now, binary composites inherit from the binary class that   does the work of storing a copy of its left and right subjects. In the same   vein, unary composites inherit from the unary class, similar to the binary class   but with only one subject. Most fundamentally, all parsers, whether primitive   or composite, inherit from the base <B>parser</B> class. <P> All entities in the library are variations of the examples presented. There   are entities that deal with <B>set</B>-like operations, iteration (Kleene star   and its brethren), semantic actions (hooks to external C/C++ code), directives   (unary composites that modify the functionality of its subjects), parser assertions,   and error handlers. <P> <h3>The Rule</h3>Ultimately, we want to encapsulate an arbitrarily complex parser expression in a placeholder variable that can be used just like any other parser. This is the tricky part. How do you encode an arbitrarily complex type, produced by a rather complex compositional expression, into a variable without knowing its exact type beforehand? <P> The problem is that each expression evaluates to a unique type signature.   As shown above, the expression <B>a | b</B> results in a type quite different   from the expression <B>a | b | c</B>, for example. Yet, we want both <B>rule   = a | b</B> and <B>rule = a | b | c</B> to work. The only similarity between   any types produced by compositional expressions is that they have the <B>parser</B>   base class. Even then, <B>parser</B> is parameterized by its derived class.   Thus, two parser bases with different derived template parameters are essentially   unique types. <P> The solution: encode the type in a run-time polymorphic class that is derived   from an <B>abstract_parser</B> class and contains a virtual member function   <B>parse</B>. Make both the copy constructor and assignment operator of the   rule member templates parameterized by the type of parser argument. Whenever   the copy constructor or assignment operator of the rule is invoked, a concrete   instance of this <B>abstract_parser</B> is created. A pointer to <B>abstract_parser</B>   is saved in a member variable. <P> <a href="cuj0309deguzman_l6.htm">Listing 6</a> shows the class declaration   of our <B>abstract_parser</B>. Also shown is <B>concrete_parser</B>, a subclass   that knows about the type of parser and multiply inherits from <B>parser</B>   and <B>abstract_parser</B>. <P> <a href="cuj0309deguzman_l7.htm">Listing 7</a> shows a rule's assignment   operator. This assignment operator is a template member function parameterized   by the type of the parser parameter. Any unique parser type composed using SEBNF   expressions, no matter how complex, can be encapsulated this way. Now that the   right-hand side (<B>rhs</B>) of an assignment (and copy constructor) can be   encapsulated in a rule, the rule may be used anywhere just like any other parser. <P> <h3>Future of Spirit</h3>Spirit is available for free download from &lt;http://spirit.sourceforge.net/&gt;. It is open source using the zlib/libpng license that permits use for any purpose, including commercial applications. The latest source code and documentation can be found at this site. This article gives a glimpse of Spirit v1.2 (available for download from &lt;www.cuj.com/code/&gt;). Work on Spirit is progressing rapidly. Currently Spirit is at version 1.6.1. <P> Most importantly, Spirit has been recently accepted into Boost (&lt;www.boost <p>rg&gt;). Boost is a repository of free peer-reviewed portable C++ source libraries.   Boost's goal is to establish "existing practice" and provide   reference implementations so that the Boost libraries are suitable for eventual   standardization. <P> Apart from some trivial interface changes and a more extensive set of features,   most of the basic concepts introduced in this article are still pertinent to   the latest version. <P> The extensible nature of the library makes it easy to adopt new features that   might be awkward, if not impossible to implement, using traditional parsing   techniques. Hosting declarative EBNF in imperative C++ results in a unique hybrid   where we can have the best of both worlds. For example, dynamic parsers, in   which the behavior of the parser is modified or extended dynamically at run   time, are possible. Also, discussion is ongoing regarding the possibility of   incorporating other parsing techniques apart from recursive descent. <P> <h3>Conclusion</h3>Spirit makes it easy to write parsers directly in C++. Thanks to the expressiveness of C++ operator overloading and the flexibility of template metaprogramming, grammars can be written in a high-level syntax very similar to EBNF. These grammar descriptions can mix freely with C++ code. Semantic actions, attached to any part of the grammar, seamlessly link EBNF grammar specifications to C++ code. The intricacies of the parsing engine framework are hidden beneath an intuitive C++/EBNF interface. Using Spirit is an order of a magnitude easier, compared to coding a parser by hand or perhaps even using a stand-alone parser such as YACC. Since everything is done in C++, there is no need to use an external parser generator along with all the excess baggage that comes with it. Spirit is a flexible, lightweight, and simple-to-use C++ library suitable for many parsing related programming tasks. <P> <h3>Notes and References</h3>[1] James Coplien. "Curiously Recurring Template Patterns," <I>C++ Report</I>, February 1995. <P> [2] Todd Veldhuizen. "Expression Templates," <I>C++ Report</I>,   June 1995. <P> [3] Peter Naur (ed.). "Report on the Algorithmic Language ALGOL 60,"   <I>CACM</I>, May 1960. <P> [4] Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides. <I>Design   Patterns, Elements of Reusable Object-Oriented Software</I> (Addison-Wesley,   1995). <P> [5] T. J. Parr, H. G. Dietz, and W. E. Cohen. <I>PCCTS Reference Manual</I>,   Version 1.00 (School of Electrical Engineering, Purdue University, West Lafayette,   August 1991). <P> [6] Adrian Johnstone and Elizabeth Scott. "RDP, A Recursive Descent Compiler   Compiler," <I>Technical Report CSD TR 97 25</I>, Dept. of Computer Science,   Egham, Surrey, England, Dec. 20, 1997. <P> [7] Joel de Guzman. "Spirit Version 1.1," &lt;<a href="http://spirit.sourceforge.net/spirit_1_1_doc.html" target="_blank">http://spirit.sourceforge.net/spirit_1_1_doc.html</a>&gt;,   July 2001. <P> [8] Joel de Guzman. "Spirit Version 1.2," &lt;<a href="http://spirit.sourceforge.net/index.php?doc=docs/v1_2/index.html" target="_blank">http://spirit.sourceforge.net/index.php?doc=docs/v1_2/index.html</a>&gt;,   November 2001. <h3>About the Authors</h3><P>Dan Nuffer is a software engineer. His interests include parsers, compilers, C++ XML, software engineering and Linux. <P> <P> Joel de Guzman is a consultant and software engineer at Boost Consulting (&lt;www.boost-consulting.com&gt;)   with specialization and expertise in the implementation of generic libraries   and frameworks, Joel is adept at writing code using modern C++ techniques, especially,   but not limited to, template metaprogramming and functional programming in C++.   After work, Joel loves to play distortion-laden heavy rock guitar, play around   in his home studio, and record his own compostions. </BODY></HTML>