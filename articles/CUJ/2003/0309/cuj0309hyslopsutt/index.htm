<HTML><HEAD><TITLE>Conversations: From C++ to Shining C</TITLE></HEAD><body bgcolor="#FFFFFF" text="#000000"><H2>Conversations: From C++ to Shining C</h2><H3> Jim Hyslop and Herb Sutter</H3><i>See your way to handily exposing C++ objects to C.</i><P> </B>Wendy must have overhead me muttering, because she gophered up and asked:   "What do you mean, 'I just don't see?' "<P> I leaned back from my workstation, letting my hands drop wearily onto my armrests.   "Oh, sorry. I was talking about the programming language C. I just don't   C. I'm used to objects and generic programming and everything now, and   I hate dropping out of that to just structured programming."<P> She smiled. "Oh, you must be working on the customer interface layer."<P> "Right," I sighed, "and it's my first time in there. I   don't see -- or C -- why we don't just bite the bullet and   expose all the functionality in C++. It would be a lot easier. Everything underneath   is written in C++ anyway. Then we could just expose the classes and not have   to wrap everything. I'm not even sure how to wrap my objects well in a   non-object language, anyway."<P> This time I saw a shadow approaching out of the corner of my eye, and for   once wasn't completely startled when the Guru glided up silently and said:   "Easier? For you, perhaps. And what you do not know, you should desire   to learn."<P> We good-morninged her. Then I said: "Say, you'd be a good one to   tell us. Why do we write our interface APIs in C? That's so 20th-century,   isn't it?"<P> The Guru looked at me searchingly, as though she were weighing what was in   my mind and heart. After a few seconds, it started to feel uncomfortable, and   I wondered whether I shouldn't have kept my mouth shut. Too late for that   now, though. I braced myself for the consequences.<P> Finally, she said quietly: "And what, my apprentice, is wrong with C?"<P> The answer seemed so obvious that I barely dared express it. "Well, uh,   it's not object-oriented."<P> She said cryptically: "A wise prophet once said, and I paraphrase, 'Objects   is as objects does.' " [1]<P> Then she kept looking at me, so I blurted: "And it's not type-safe.   It's old. It's... uh, well, it's..."<P> "C is important and will be so for some time. It is certainly a portable   <I>lingua franca</I> like no other," she corrected. "A true master   programmer has no room for language bigotry. All languages have advantages and   drawbacks, and a master programmer knows many and can learn any. What is important   is to choose the right language for the task at hand. In this case, tell me:   What are the advantages of C?"<P> "Uh, well..." I looked at Wendy, who suddenly seemed to remember   something urgent she had to do and disappeared back into her cubicle. No help   there. But the Guru had said <I>lingua franca</I>, so I took that as a hint.   "I suppose it's available on a lot of platforms."<P> "Good," the Guru nodded. "Indeed, on more platforms than probably   any other language. And...?"<P> "And... uh, er, um..." I just couldn't think of anything else.<P> "It is a <I>lingua franca</I>, my child," she reminded me. "That   applies between different platforms, but it applies also between different languages   on even the same platform. When was the last time you spoke with one of our   customers?" she added, sharply changing tack.<P> "Actually, I've been really busy on our code. We have a lot to do   in this release, and I haven't had time to talk to customers."<P> She arched an eyebrow. "Oh, really?"<P> "Well, yes, but this release is all about delivering great new value   to the customer, so my work is still all customer-centric," I defended.<P> She just looked at me.<P> "Well... isn't it?" I added weakly.<P> She sighed. "Apprentice... no, let's skip that," she said,   looking around and not seeing anyone in earshot, besides Wendy who didn't   need the act. "Look here, how will you know what the customer needs unless   you know the customer? Too many programmers work too many hours on too many   features that don't do what customers need. 'This too is vanity and   a striving after wind,' I could add. I asked you about customers for a   reason: many of our customers who will be using our API do not use C++; many   use C, others use Fortran, still others use Basic and Java, and nearly all languages   can call into C APIs in one way or another. And even the customers we have who   do use C++ don't all use the same compiler, which usually means they aren't   link-compatible and can't call directly into our C++ binaries anyway. And   even those few customers who do use the same compiler as we do often use a different   version of the standard library, which means ODR violations because of incompatible   implementations of standard library facilities like <B>string</B> and <B>vector</B>.   A C API is still the common denominator that lets all of these users use our   software, regardless of the programming language or compiler or standard library   they're using. It's no accident that shared libraries and DLLs and   such most frequently have plain-C entry points."<P> I absorbed all of this. "Okay, I get it," I nodded, "and that's   a huge advantage of C. Okay. But how can I wrap my C++ objects in C without   losing fidelity and functionality..." Then I saw Bob coming back from his   morning coffee break, and segued into: "..., oh master?"<P> She smiled beatifically. "You cannot always, my apprentice," she   acknowledged, "but very close you can come. Show me the class you are working   with."<P> "Okay, here's a sample C++ class I was working on to get started."   I launched my editor and pulled up the following code:<pre>  // x.h: My sample C++ class  //  class X {  public:   X();   ~X();   int Func1( int flags );   int Func2( std::string s, std::complex&lt;double&gt; c );  private:    int member1;    double member2;    std::string member3;    std::vector&lt; boost::shared_ptr&lt;Y&gt; &gt; member4;  };  X operator+( const X&amp;, const X&amp; );</pre>"So here are some of my problems," I continued, ticking them off on my fingers. "One: The C caller can't use <B>new</B> or call a constructor, so how does he create an <B>X</B> object? Two: Ditto for <B>delete</B> and destruction. Three: C has no concept of member functions, so how do I expose <B>Func1</B>? Four: Even if I can expose a member function, I have types in the signature that C knows nothing about, like objects and template specializations. Five: What about the overloaded operator, when C has no idea about operator overloading? Six: I have members of types that C knows nothing about, so I can't even mention them in declaring the class where C can see it. ... I guess those are the main questions," I finished.<P> "Much thought have you given to this," the Guru commended. "The   last question is the easiest: The class <B>X</B> shall remain unchanged, and   be never seen by the C programmer. May I?" She indicated the keyboard.   I passed it to her, and she pulled up a chair and started two files:<pre>  // x_api.h: C API for X  //  extern "C" {    // do everything through an opaque pointer    typedef void* X_HANDLE;  }  // x_api.c: implementing the C API for X  //  #include "x_api.h"  #include "x.h"  extern "C" {    // ...initially empty...  }</pre>"The C-compatible caller only ever uses dynamically created <B>X_HANDLE</B> objects and knows nothing about their internal structure. Now, pray tell, what is the first thing the caller will need to do to create one?"<P> "Well, I'd say he'd have to write '<B>new X;</B>'...   but he can't."<P> "Indeed. So we shall simply have to do it for him." She added to   the two files:<pre>  // In x_api.h:    X_HANDLE XCreate();  // In x_api.c:    X_HANDLE XCreate() { return new X; }</pre>"Okay, the conversion to <B>void*</B> is implicit," I commented. "That answers my first question. I think I see what destruction would be, by symmetry, although I'll have to explicitly cast from <B>void*</B> to <B>X*</B>. May I answer my own second question?" She pushed the keyboard to me, and I added:<pre>  // In x_api.h:    void XFree( X_HANDLE );  // In x_api.c:    void XFree( X_HANDLE x ) { delete static_cast&lt;X*&gt;( x ); }</pre>"Is that the right cast?" I asked. "I didn't want to use a C-style cast, and I didn't think I needed a <B>dynamic_cast</B>."<P> "Indeed," the Guru agreed. "You could use <B>dynamic_cast</B>   and check for a successful cast, in order to detect errors where the caller   passes in a pointer he did not receive from <B>XCreate</B>, but this suffices   well for now. Apprentice, you have the keyboard: What about <B>Func1</B>?"<P> "I'm not sure," I scratched my head. "That's a member   function..."<P> "As was the destructor," the Guru reminded quietly.<P> "...and has an implicit <B>this</B> parameter that I'd have to figure   out how to -- Oh! But I just did that with the destructor, and I made it   explicit! I'll just do that again:"<pre>  // In x_api.h:    int XFunc1( X_HANDLE, int flags );  // In x_api.c:    int XFunc1( X_HANDLE x, int flags )     { return static_cast&lt;X*&gt;( x )-&gt;Func1( flags ); }</pre>"How's that?"<P> "Well done," she nodded graciously. "Note also that this is   still all object-oriented, although not in a language with direct support for   objects. [2] Now: What of <B>Func2</B>?"<P> "That's where I always get into trouble," I admitted. "<B>Func2</B>   takes non-C parameters -- a <B>string</B> and a <B>complex&lt;double&gt;</B>.   C doesn't know what those are. I suppose in C the equivalent to a <B>string</B>   is a <B>char*</B>, but there's no <B>complex</B> -- well, there is   in the C99 standard I think, but we don't have a C99 compiler so that doesn't   help us."<P> "More to the point, our customers are unlikely to be able to all use   a C99 interface," the Guru agreed. "So consider: Using a <B>char*</B>   is the native C idiom for a <B>string</B>. That is correct, and you can write   at least that much. Go ahead, try," she prompted.<P> I took a breath, and wrote:<pre>  // In x_api.h:    int XFunc2( X_HANDLE x, const char* s,                /* ??? complex&lt;double&gt; c ??? */ );  // In x_api.c:    int XFunc2( X_HANDLE x, const char* s,                /* ??? complex&lt;double&gt; c ??? */ ) {     return static_cast&lt;X*&gt;( x )-&gt;Func2( s, c );    }</pre>"That looks right to me, so far," I said.<P> "It is."<P> "But I don't see how to generalize it to deal with the <B>complex</B>   parameter." I looked at her.<P> "Consider this," the Guru said. "You can pass the <B>const   char*</B> naturally where the <B>string</B> is expected. But it is not the same   type, so what is happening there?"<P> "Obviously the converting constructor is getting called to turn the <B>const   char*</B> into a <B>string</B>. But... oh, I think I see! You also have to take   out any non-C parameters and replace them with something that makes sense, usually   something that the parameter's constructor can take. I'll also need   an explicit conversion, where I could get away with an implicit conversion for   the <B>string</B>." I edited the code to read:<pre>  // In x_api.h:    int XFunc2( X_HANDLE x, const char* s,                double re, double im );  // In x_api.c:    int XFunc2( X_HANDLE x, const char* s,                double re, double im ) {     return static_cast&lt;X*&gt;( x )-&gt;              Func2( s, std::complex&lt;double&gt;( re, im ) );    }</pre>"I think that's it!" I enthused.<P> "Indeed, it is," the Guru smiled. "It is possible that you   have a parameter type that cannot be constructed from C builtin types only,   however, and only from one or more other class types. But in that case you should   either not expose that part of the interface, or also expose those other class   types the same way you are exposing <B>X</B>."<P> "That answers all of my questions, then, except for the operator. If   I overload operators like +, they can't be accessed by the calling C code,   can they?"<P> "Not directly, no," she agreed.<P> "Then what?"<P> She looked at me, waiting for me to get it on my own. There must be something   we'd already covered that would work here. But what? The only thing we'd   done is represent constructors and member functions in a C-callable way...<P> Then the penny dropped. I'd represented those functions as free functions,   with new names. I just had to wrap the operators in uniquely named functions   too. I wrote:<pre>  // In x_api.h:    void XAdd( X_HANDLE dest, const X_HANDLE lhs,               const X_HANDLE rhs );  // In x_api.c:    void XAdd( X_HANDLE dest, const X_HANDLE lhs,               const X_HANDLE rhs ) {     *static_cast&lt;X*&gt;( dest ) = *static_cast&lt;const X*&gt;( lhs ) +                                *static_cast&lt;const X*&gt;( rhs );    }</pre>"Good," the Guru agreed. I saved the code, and admired the completed result:<pre>  // x_api.h: C API for X  //  extern "C" {    typedef void* X_HANDLE;    X_HANDLE XCreate();    void XFree( X_HANDLE );    int XFunc1( X_HANDLE, int flags );    int XFunc2( X_HANDLE x, const char* s,                double re, double im );    void XAdd( X_HANDLE dest, const X_HANDLE lhs,               const X_HANDLE rhs );  }  // x_api.c: implementing the C API for X  //  #include "x_api.h"  #include "x.h"  extern "C" {    X_HANDLE XCreate() { return new X; }    void XFree( X_HANDLE x ) { delete static_cast&lt;X*&gt;( x ); }    int XFunc1( X_HANDLE x, int flags )     { return static_cast&lt;X*&gt;( x )-&gt;Func1( flags ); }    int XFunc2( X_HANDLE x, const char* s,                double re, double im ) {     return static_cast&lt;X*&gt;( x )-&gt;              Func2( s, std::complex&lt;double&gt;( re, im ) );    }    void XAdd( X_HANDLE dest, const X_HANDLE lhs,               const X_HANDLE rhs ) {     *static_cast&lt;X*&gt;( dest ) = *static_cast&lt;const X*&gt;( lhs ) +                                *static_cast&lt;const X*&gt;( rhs );    }  }</pre>I added a quick test mainline:<pre>  int main() {    X_HANDLE x = XCreate();    XFunc1( x, 0 );    XFunc2( x, "xyzzy", 3.14159, 2.71828 );    XFree( x );  }</pre>I compiled it, and it worked. I sat back, satisfied.<P> "Your time has come," the Guru said, "to go code many things..."   She stood up, smiling. And as she drifted away, I happily turned to providing   object-oriented C wrappers to my C++ types -- and, to my surprise, not really   minding it at all.<P> Wendy must have overhead me muttering, because she gophered up again and asked   mischievously: "What do you mean, 'Now I see?' "<P> "Now I C..." I repeated to myself and coded on, ignoring Wendy's   teasing.<P> <h3>References</h3>[1] F. Gump. Robert Zemeckis and the ILM (Paramount, 1994).<P> [2] H. Sutter. <I>Exceptional C++</I>, Item 32 (Addison-Wesley, 2000). <h3>About the Authors</h3>Herb Sutter (&lt;www.gotw.ca&gt;) is convener of the ISO C++ standards committee, author of the acclaimed books <I>Exceptional C++</I> and <I>More Exceptional C++</I>, and one of the instructors of The C++ Seminar (&lt;www.gotw.ca/cpp_seminar&gt;). In addition to his independent writing and consulting, he is also C++ community liaison for Microsoft. <P> <P> Jim Hyslop is a senior software designer with over 10 years programming experience   in C and C++. Jim works at Leitch Technology International Inc., where he deals   with a variety of applications, ranging from embedded applications to Windows   programs. He can be reached at jhyslop@ieee.org. </BODY></HTML>