<HTML><HEAD><TITLE>The Same STL Algorithms -- Only Better</TITLE></HEAD><body bgcolor="#FFFFFF" text="#000000"><h2>The Same STL Algorithms -- Only Better</h2><h3>Vladimir Batov</h3><i>Cleaner iteration with a better for_each.</i> <p>If you are not using STL algorithms yet, you should be. In this article, I'll show how to enjoy   using STL algorithms without being repelled by the seemingly unavoidable awkwardness   of the standard member function adapters.<P> With all due respect towards STL algorithms, I am certainly sympathetic with   those clinging to archaic, sub-optimal, and unsafe constructs such as:<pre>for (vector::iterator it = v.begin();     it != v.end(); ++it){  it-&gt;do_something();}</pre>After all, from time to time, I myself am guilty of using such relics despite all the persuasive arguments from the masters [1]. Okay, okay, I am still working on it, although I'll step forward and say that true friends do not ask others to remember and maintain torturous constructs such as:<pre>class Foo { ... void draw() const; };extern void draw(const Foo&amp;);for_each(b, e, ptr_fun(draw));for_each(b, e, mem_fun(&amp;Foo::draw));for_each(b, e, mem_fun_ref(&amp;Foo::draw));</pre>The first line passes a non-member function (<B>draw</B>) to an algorithm. The second line passes a member function (<B>&amp;Foo::draw</B>) to an algorithm working on the sequence of pointers to objects. The third line passes a member function (<B>&amp;Foo::draw</B>) to an algorithm working on the sequence of objects.<P> Confusing? It certainly is to me. If you found yourself grumbling about "if-this-if-that"   scenarios and <B>ptr_fun</B>, <B>mem_fun</B>, and <B>mem_fun_ref</B> "beauties,"   you are not alone.<P> As Scott Meyers puts it, "They are unpleasant to type, annoying to read,   and resistant to comprehension" (see [1], Item 41). I would most certainly   prefer using STL algorithms in a friendlier way. For instance, without <B>ptr_fun</B>,   <B>mem_fun</B>, and <B>mem_fun_ref</B>: <pre>class Widget{ ...  void draw() const  bool move();};extern void draw(const Widget&amp;);vector&lt;Widget&gt;  v1;vector&lt;Widget*&gt; v2;for_each(b1, e1, draw);for_each(b1, e1, &amp;Widget::draw);for_each(b1, e1, &amp;Widget::move);for_each(b2, e2, &amp;Widget::draw);</pre>It turns out that getting rid of adapters is disappointingly easy to achieve. <a href="cuj0309batov_l1.htm">Listing 1</a> shows the extended <B>aux::for_each</B> interface consisting of three overloaded functions. The first function (lines 3-9) is the original <B>std::for_each</B> interface, which is still used with non-member functions (e.g., <B>draw(const Widget&amp;)</B>) and function adapters (e.g., <B>bind2nd</B>). The other two functions (lines 11-33) are called respectively for <B>const</B> and non-<B>const</B> member functions (e.g., <B>Widget::draw</B>). They merely call the standard <B>for_each</B> algorithm with an appropriate functor object (lines 20 and 32). In the <B>std</B> namespace, you have to call <B>mem_fun</B> "convenience" functions to create those functors themselves. The following code shows the guts of the <B>std::mem_fun</B> declared in <B>&lt;functional&gt;</B>. <pre>template &lt;class R, class T&gt;mem_fun_t&lt;R, T&gt;mem_fun(R (T::*func)()){  return mem_fun_t&lt;R, T&gt;(func);}template &lt;class R, class T&gt;const_mem_fun_t&lt;R, T&gt;mem_fun(R (T::*func)() const){  return const_mem_fun_t&lt;R, T&gt;(func);}</pre>As <B>aux::for_each</B> functions create appropriate functors directly, in the <B>aux</B> namespace, you do not need <B>mem_fun</B> function adapters. You might have already guessed it -- you do not need <B>mem_fun_ref</B> either. Those adapters are the same as <B>mem_fun</B>, but they return functors of the <B>mem_fun_ref_t</B> and <B>const_mem_fun_ref_t</B> types. (If you stumbled on these types and your eyes refused to read them properly, they have <B>_ref_t</B> at the end.) The <B>std::mem_fun_t</B> and <B>std::mem_fun_ref_t</B> look very much alike:<pre>// Simplified and beautified versions// of the standard functors.template &lt;class Return, class Type&gt;class mem_fun_t{  typedef Return (Type::*Func)();  public:  explicit mem_fun_t(Func func)  : func_(func) {}     Return operator()(Type* obj) const  {    return (obj-&gt;*func_)();  }  private: Func func_;};template &lt;class Return, class Type&gt;class mem_fun_ref_t{  typedef Return (Type::*Func)();  public:  explicit mem_fun_t(Func func)  : func_(func) {}     Return operator()(Type&amp; obj) const  {    return (obj.*func_)();  }  private: Func func_;};</pre>The only differences are that the <B>operator</B> functions accept different types (pointers and references) and, consequently, use pointer or reference syntax to call a member function. Therefore, it appears only logical to merge the functionality into one <B>aux::mem_fun_t</B> class:<pre>namespace aux {template &lt;class Return, class Type&gt;class mem_fun_t{  typedef Return (Type::*Func)();  public:  explicit mem_fun_t(Func func)  : func_(func) {}     Return operator()(Type* obj) const  {    return (obj-&gt;*func_)();  }  Return operator()(Type&amp; obj) const  {    return (obj.*func_)();  }  private: Func func_;};}</pre>Or if you prefer closer relations with the <B>std::mem_fun_t</B> cousin: <pre>template &lt;class R, class T&gt;struct mem_fun_t : std::mem_fun_t&lt;R, T&gt;{  typedef R (T::*Func)();  typedef std::mem_fun_t&lt;R, T&gt; super;  explicit mem_fun_t(Func func)  : super(func) {}     R operator()(T* obj) const  {    return super::operator()(obj);  }  R operator()(T&amp; obj) const  {    return super::operator()(&amp;obj);  }};</pre>The <B>aux::const_mem_fun_t</B> is constructed in the same fashion. The complete source code is available at &lt;www.cuj.com/code/&gt;. <h3>Note</h3>[1] Scott Meyers. <I>Effective STL</I> (Addison-Wesley, 2001).   <h3>About the Author</h3>With a beginning in machine code (yes, those zeros and ones) some 25 years ago, Vladimir Batov has been developing software ever since for nuclear power stations, air traffic control, military radars, many other things and just for fun. These days, apart from his interest in C++ and sofware design, he enjoys good books, tennis, sunsets over the bay in Melbourne, Australia, and digging in the sand on the beach with his daughter. He can be reached at vbatov@preston.net.</BODY></HTML>