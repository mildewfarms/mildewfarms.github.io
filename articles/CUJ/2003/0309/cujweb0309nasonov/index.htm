<html><head><title>I/O System: dynamic_any Campaign</title><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"></head><body bgcolor="#FFFFFF" text="#000000"><h2>I/O System: dynamic_any Campaign</h2><h3>Alexander Nasonov</h3><p><i>The dynamic_any library, which is currently under review for inclusion   with Boost, lets you manipulate objects of unknown type through interfaces discovered   by runtime type identification.</i><p>Before reading this article I recommend that you re-read TC++PL [1], section   25.4.1 where Bjarne Stroustrup introduced a simple I/O system. He found an elegant   solution for reading values of different types from an input stream. In general,   an I/O system should be able to operate without explicit knowledge about stored   classes. In [1] it is implemented through the <b>Io_obj</b> interface: <pre><i>// Code is taken from [1]</i>class Io_obj {public:    virtual Io_obj* clone() const = 0; // polymorphic    virtual ~Io_obj() {}};</pre><p> The library returns a pointer to <b>Io_obj</b>, which can then be casted to   the actual class the pointer points to: <pre><i>// Code is taken from [1]</i>void user(){    <i>// ... open file assumed to hold shapes, and attach ss as an istream for that file</i>    Io_obj* p = get_obj(ss); <i>// read object from stream</i>    if(Shape* sp = dynamic_cast&lt;Shape*&gt;(p)) {        sp-&gt;draw();        <i>// ...</i>    }    else    {        <i>// oops: non-shape in Shape file</i>    }}</pre><p> The first important part of this code is the<b>get_obj</b> function. Refer   to [1] for implementation details. This function reads a unique class prefix   from the input stream and finds a make function for the class, which is then   called. The pointer <b>p</b> returned from <b>get_obj</b> can be cast to the   expected class. This is the second important point of this code. <p> Of course, every class is supposed to be storable and should have support   for the<b>Io_obj</b> interface. Although you can change the class hierarchy   by deriving from <b>Io_obj</b> and implementing its virtual functions, there   is no need, because Bjarne has a better alternative! You can adapt your class   using the <b>Io</b> class template: <pre><i>// Code is taken from [1]</i>template&lt;class T&gt; class Io : public T, public Io_obj {public:    Io* clone() const { return new Io(*this); } <i>// using copy constructor</i>    Io(istream&amp;); <i>// initialize from input stream</i>    static Io* new_io(istream&amp; s) { return new Io(s); }    // ...};</pre><p> The way the <b>Io&lt;T&gt;</b> is derived is a key of success. This class   supports <b>Io_obj</b> interface as well as class specific interface. <p> You may notice one inconvenience. The result of <b>the get_obj</b> function   is a dynamically allocated pointer. It means that you are responsible for memory   management and you should never forget to delete the object. It can be handled   with smart pointers, though. For example, you can use <b>Boost.smart_ptr</b> library   [3]. <p> Nevertheless, this technique allows you to hide different class hierarchies   behind <b>the Io_obj</b> interface and get access to a concrete class as you   need it. Indeed, using Stroustrup's words: "In general, these techniques can   be used to invoke a function based on a string supplied by a user and <u>to   manipulate objects of unknown type through interfaces discovered through run-time   type identification</u>". I underlined the second part of the sentence to emphasize   the main purpose of the dynamic_any library I'm presenting here. <p> Those of you who are familiar with the Boost.any library [2] may notice that   the underlined text intersects with this library. Class <b>any</b> defined by   this library is a holder of other types. A user can store an integer value or   a string there. Generally speaking, any type that obeys the ValueType concept   can be stored by the <b>any</b> class. ValueType is a type that behaves like   a value; in particular, it has copy constructor that copies. Class <b>any</b>   itself has normal copy semantics and can be considered as a ValueType (but you   can't have a nested <b>any</b> value held by other <b>any</b> value). <p> Access to <b>any</b> content is made in cast-like style. All this is implemented   by the dynamic_any library as well. Let's start with a simple example to get   the first impression about library capabilities: <pre>dynamic_any::any&lt;&gt; a(0); <i>// a holds int(0)</i>int i = extract&lt;int&gt;(a); // <i>extract a copy of int(0)</i>a = 'z'; <i>// change a's content to char('z')</i>char&amp; z = extract&lt;char&amp;&gt;(a); <i>// direct access to a's content</i></pre><p> This interface is powerful enough to be used as a holder of I/O objects.The <b>user</b> function defined in [1] can be rewritten as:<pre>typedef dynamic_any::any&lt;&gt; io_any;io_any get_obj(std::istream&amp;);void user(){    <i>// ... open file assumed to hold shapes, and attach ss as an istream for that file</i>    io_any a = get_obj(ss); <i>// read object from stream</i>    try    {        Shape&amp; s = extract&lt;Shape&amp;&gt;(a);        s.draw();        <i>// ...</i>    }    catch(const bad_extract &amp;)    {        <i>// oops: non-shape in Shape file</i>    }}</pre><p> Compare this code with the original <b>user</b> function line by line. The   original version of the function can give you a hint of how <b>io_any</b> is   implemented. You may recognize a pointer to the <b>Io_obj</b> class in the <b>io_any</b>   implementation and <b>dynamic_cast</b> inside an <b>extract</b> function. <p> A couple of important notices should be made before going further. First,   you don't need to deal with pointers anymore. Second, an advantage can be seen   from the possible implementation of make function, which is called from <b>get_obj</b>   function: <pre>template&lt;class T&gt;io_any make_fun(std::istream&amp; ss){    T value;    if(ss &gt;&gt; value)        return io_any(value);    else        throw ReadError();}</pre><p> The point is that <b>Io&lt;T&gt;</b> is not used. The <b>Io&lt;T&gt;</b> trick   moves into the <b>io_any</b> implementation. What we have instead is very straightforward   code in <b>return io_any(value)</b> telling us that what <b>io_any</b> we are   returning holds a copy of <b>value</b>. <p> In general, the <b>any</b> class template has better semantics than the <b>Io_obj</b>   interface to express the fact that a value of unknown type should be returned.   In addition, the returned object has normal copy semantics and it owns the stored   value. All C++ programmers are familiar with this semantics and therefore they   will start using the class properly. <h3>Extending the <b>io_any</b> Interface</h3><p> So far, only the input part of the I/O system is implemented. How do I implement   the output part of it? Well, if you are using the <b>Io_obj</b> hierarchy, you   can just add the pure virtual function <b>write</b> to <b>Io_obj</b> and implement   it in the <b>Io</b> class template. This function can be easily called then: <pre>void echo(std::istream&amp; in, std::ostream&amp; out){    if(Io_obj* p = get_obj(in))    {        std::auto_ptr&lt;Io_obj&gt; delete_guarantee(p);        p-&gt;write(out);    }}</pre><p> In the case of <b>io_any</b>, you can't add a new virtual function because   <b>io_any</b> is not designed as a polymorphic class with an extensible interface.   Although you could do it using an if-else-if statement, it's not a recommended   method [1], section 15.4.5): <pre><i>// Not recommended because not scalable, error-prone etc</i>void echo(std::istream&amp; in, std::ostream&amp; out){    io_any a = get_obj(in);    if(Circle* p = extract&lt;Circle*&gt;(&amp;a))        writeCircle(out, p);    else if(Triangle* p = extract&lt;Triangle*&gt;(&amp;a))        writeTriangle(out, p);    <i>// ...</i>    else        throw UnknownType();}</pre><p> New functions can be defined in the <b>dynamic_any</b> library in a different   way. The scheme is simple. You implement every function as a class derived from   the <b>dynamic_any::function</b> class template, put these functions into a   typelist, and then use this typelist as a template parameter for the <b>dynamic_any::any</b>   class template. Every function listed in the typelist can then be called. <p> The Boost MPL library [5] is used to provide typelist functionality. There   is another typelist library defined in the Loki library [6], but I prefer to   use MPL because it has an STL-like interface to manipulate with typelists. It   helps to implement the library in a straightforward manner and makes reading   the code an easy task [5]. <p> To define your own function, you have to derive from the class template <b>function</b>.   This class template has two template parameters. The first parameter should   be a function you are defining. This is required because the design of <b>function</b>   is based on curiously recurring template patterns [4]. The second parameter   is a signature of your function. Draw special attention to <b>anyT</b> in the   signature. It is used as a placeholder for the <b>any</b> class template. At   least one parameter should contain <b>anyT</b> in the form of possibly a const-qualified   <b>anyT</b> or a reference to <b>anyT</b>. For example, a signature <b>std::ostream&amp;   (std::ostream&amp;, const anyT&amp;)</b> for the class <b>writer</b>, defined   below, tells us that <b>writer</b> returns <b>std::ostream&amp;</b>,<b> </b>and   that it has two parameters. The first parameter has type <b>std::ostream&amp;</b>   while the second parameter is an <b>any</b> class template passed by reference.   The definition of <b>writer</b> is: <pre>class writer  : public dynamic_any::function&lt;               writer, <i>// curiously recurring template pattern</i>               std::ostream&amp; (std::ostream&amp;, const anyT&amp;)           &gt;{  public:    template&lt;class T&gt;    std::ostream&amp; call(std::ostream&amp; out, const T&amp; value) const    {        write_prefix&lt;T&gt;(out); <i>// write unique class prefix</i>        return out &lt;&lt; value; <i> // write value</i>    }};</pre><p> The implementation is put into a <b>call</b> member-function. You may notice   that it has the same signature with one difference: <b>anyT</b> is replaced   with <b>T</b>. Why so? When you are calling <b>writer</b> you're passing <b>any</b>,   which, in general, holds an unknown type. The type is resolved during the call   and a value of known type <b>T</b> is passed to the<b> call</b> member-function.   You may think of <b>writer</b> as being implemented like this: <pre><i>// Implementation of wrt(out, obj) in case obj holds a value of type T</i>template&lt;OperationList&gt;std::ostream&amp; writer_call_impl(const writer&amp; wrt,                               std::ostream&amp; out,                               const any&lt;OperationList&gt;&amp; obj){    <i>// Check at compile-time that writer is in OperationList</i>    static_assert&lt;contains&lt;OperationList,writer&gt; &gt;();    <i>// Extract and call</i>    const T&amp; value = extract&lt;const T&amp;&gt;(obj);    return wrt.call(out, value);}</pre><p> Well, <b>writer</b> is implemented. Let's use it!<pre>typedef mpl::list&lt;writer&gt; operation_list;typedef dynamic_any::any&lt;operation_list&gt; io_any;void echo(std::istream&amp; in, std::ostream&amp; out){    io_any a = get_obj(in);    writer wrt; <i>// function object</i>    wrt(out, a); <i>// writer call</i>}</pre><p> This is nothing new for experienced C++ developers familiar with function   objects. They can be used directly (see example above) or can be passed to standard   algorithms like <b>for_each</b> in the example below: <pre>void echo_all(std::istream&amp; in, std::ostream&amp; out){    std::vector&lt;io_any&gt; v = get_all(in);    std::for_each(v.begin(), v.end(), boost::bind(writer(), out, _1));}</pre>    <p> More functions can de defined for <b>io_any</b>. Depending on your problem   domain, you may add, for example, visitor support or less comparison to create   a heterogeneous set. Less comparison is most interesting because two <b>any</b>   values are compared. In general, the library cannot dispatch a call of two <b>any</b>   values that hold arbitrary types. A call can be made only if they hold the same   type or one type is a public unambiguous base of another. Otherwise, they are   dispatched in a different way (see the <b>no_call</b> function below). The library   also has more precise control over the type of passed arguments (<b>call_ex</b>). <p> Take a look at the <b>less</b> implementation, which first compares by type   and then by value: <pre>class less : public dynamic_any::function&lt;less, bool (const anyT&amp;, const anyT&amp;)&gt;{  public:    template&lt;class T, class OperationList&gt;    bool call_ex(const T&amp; t1, const any&lt;OperationList&gt;&amp; a1,                 const T&amp; t2, const any&lt;OperationList&gt;&amp; a2) const    {        <i>// one argument always has type T while other may be derived from T</i>        return a1.type() == a2.type() ? t1 &lt; t2 : a1.type().before(a2.type());    }        template&lt;class OperationList&gt;    bool no_call(const any&lt;OperationList&gt;&amp; a1, const any&lt;OperationList&gt;&amp; a2) const    {        <i>// a1 and a2 never holds same type</i>        return a1.type().before(a2.type());    }};</pre><p> In contrast to the <b>call</b> function, which is designed to be as simple   as possible, <b>call_ex</b> has more arguments for better control. Every <b>anyT</b>-based   argument is represented by two arguments in the <b>call_ex</b> function. The   first one is an extracted value (derived-to-base conversion may be applied!)   while the second is the original <b>any</b> from where the value was extracted.   Although you can't change the content of a1 and a2, you may check stored types. <p> When a1 and a2 hold types without a "common base," <b>no_call</b> is used.   By default, it throws <b>bad_function_call</b> but in the example, it's overridden   to allow comparison of different held types. <p> So defined <b>less</b> can be easily added to a list of    supported functions:<pre>typedef mpl::list&lt;writer, less&gt; operation_list;typedef dynamic_any::any&lt;operation_list&gt; io_any;typedef std::set&lt;io_any, less&gt; heterogeneous_set;</pre><p> Of course, every function adds requirements for stored types. After adding   <b>less</b> to the operation list you are able to hold only less comparable   types. <h3>Conclusion</h3><p> The I/O system presented in the article is not a bullet-proof solution. Capable   I/O systems should do much more. Those who find this approach useful can develop   it further by just adding more functions to the list of supported operations. <p> The example section of the library has an <b>io_any.cpp</b> file, where you   can find visitor support for the I/O system [7]. <p> You'll find the <b>dynamic_any</b> library at &lt;<a href="http://cpp-experiment.sourceforge.net" target="_blank">http://cpp-experiment.sourceforge.net</a>&gt;The   library is not yet accepted into the boost. It means that much can be changed   during the review process. I expect some changes to operators support. The name   of the library is also under discussion. All comments about the library are   highly appreciated. You are welcome to join the boost mailing lists! <h3>References</h3><p> [1] Bjarne Stroustrup. <em>The C++ Programming Language</em>, Special ed.   (Addison-Wesley Longman, 2000). <p> [2] Kevlin Henney. Boost.any library, <a href="http://www.boost.org/doc/html/any.html" target="_blank">http://www.boost.org/doc/html/any.html</a>. <p> [3] Greg Colvin, Beman Dawes, Peter Dimov, and Darin Adler. Boost.smart_ptr   library, <a href="http://www.boost.org/libs/smart_ptr/index.htm" target="_blank">http://www.boost.org/libs/smart_ptr/index.htm</a>. <p> [4] James O. Coplien. &quot;Curiously Recurring Template Patterns&quot;, <em>C++   Report</em>, February 1995. <p> [5] Aleksey Gurtovoy. Boost MPL library. <a href="http://www.boost.org/libs/mpl/doc/index.html" target="_blank">http://www.boost.org/libs/mpl/doc/index.html</a> <p> [6] Andrei Alexandrescu. <em>Modern C++ Design</em> (Addison-Wesley Longman,   2001). <p> [7] Alexander Nasonov. dynamic_any library, <a href="http://cpp-experiment.sourceforge.net">http://cpp-experiment.sourceforge.net</a>.<h3>About the Author</h3>Alexander Nasonov is currently a guest researcher at the the Competence Center for Advanced Satellite Communication (SatCom) at the Fraunhofer Institute for Open Communication Systems (FOKUS) &lt;<a href="http://www.fokus.fhg.de/" target="_blank">http://www.fokus.fhg.de/</a>&gt;. </body></html></body></html>