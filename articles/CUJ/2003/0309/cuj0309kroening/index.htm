<HTML><HEAD><TITLE>Eclipse: A Developer's Story</TITLE></HEAD><body bgcolor="#FFFFFF" text="#000000"><H2>Eclipse: A Developer's Story</h2><h3>Mary Kroening</h3><i>A case study showing Eclipse at work on a real project.</i><P> We are the makers of a Prolog language development system that runs on   a variety of Windows and Unix platforms. Prolog differs from conventional programming   languages in that it is non-procedural and rule-based. It has built-in search   and pattern-matching capabilities--so programs run forwards looking for   a match, then backwards on failure or to find additional matches. And, unlike   other Prolog implementations, we specialize in embedding Prolog modules in conventional   (procedural) languages and tools such as Java, C++, .NET, Delphi and Web servers.<P> Our existing IDE dates from the early 90's and was showing its age. So   last year we started thinking seriously about a replacement. We wanted an IDE   that would run on multiple platforms, and we wanted to support all the modern   conveniences.<P> The question was how to do that without a budget of the likes of Microsoft   or Borland? When we learned of Eclipse, we were immediately intrigued. Eclipse   offered: <ul><li> True open source licensing where we could develop and own our Prolog-specific   additions yet contribute to the base product for all to benefit.   <li> Ready-to-run downloads for a wide variety of Windows and Unix platforms.   <li> Full source code and remote debugging support. The latter is especially important   to us because our customers develop Prolog components as part of larger applications   instead of stand-alone Prolog programs. Debugging embedded components (especially   those running on Web servers) is especially challenging without remote debugging.</ul>  <P> Eclipse also allowed our users to develop both parts of their application     using the same IDE. That is, they could develop the user interface in Java     or C++ and an intelligent logic-base and/or rule-base in Prolog without ever     leaving Eclipse.  <P> There were also some downsides:   <ul><li> Because Eclipse is written in Java, the minimum download for the Eclipse   Platform (runtime) and Java is just under 30mb. Our current product download   is just over 5mb, so that is a very large increase for our international customers.   <li> Eclipse dynamically configures itself at startup (which makes it easy to   extend), but this means initial start-up can take 10-20 seconds.   <li> Project handling is confusing and inflexible. However, Eclipse plans to remedy   this in a future release.</ul>  <P> On balance, clearly an Eclipse-based IDE would offer many more features     than we could ever hope to build from scratch. But, could we get Eclipse to     adapt to a Prolog developer's needs for building components in a non-procedural     programming language, and at what cost?  <P>   <h3>A Pilot Project</h3>  To answer this question, we started with a pilot project to put together a Prolog   editor with syntax coloring, an outliner, a project builder (compile and link)   and a Prolog interpreter (a.k.a listener). This last item is a necessary and   common feature for Prolog development. It took a little over a month to get   a very rough prototype, but that was enough to convince us that Eclipse was   the right choice and that it was flexible enough to handle non-procedural languages.  <P> The prototype also clearly demonstrated the 80-20 rule. 80% of the work     could be done in 20% of the time and vice versa. So, how did we go about building     the prototype, and ultimately our Amzi! Eclipse IDE?  <P>   <h3>Learning Eclipse</h3>  We started first by learning about Eclipse as a user, then as a developer. Along the way we discovered that some things are very easy to do, and others ridiculously difficult. The Eclipse SDK (software development kit) and website (&lt;www.eclipse.org&gt;) offers manuals, articles, examples, source code, newsgroups, mailing lists, and a bug and enhancement database. <P> Start by downloading the "Eclipse SDK" and the "Example Plug-Ins".     This includes everything you need to run Eclipse as a user, write Java programs,     and develop your own plug-ins (the PDE, Plug-in Development Environment).  <P>   <h3>What to Build?</h3>  Before any extensions can be built, one or more plug-ins needs to be created.   A plug-in is a set of extensions to Eclipse. It can range from a single action   (say a button or menu choice) to a full set of views, editors, actions and more.  <P> To start Eclipse development, you can either open one of the example plug-ins,     or you can create your own plug-in from scratch. We recommend you try the     former first.  <P> If you want build an entire IDE, you will probably have many extensions     organized into multiple plug-ins. A group of related plug-ins that is installed     and work together is called a <I>feature</I>. Typically the user view of a     feature is called a <I>perspective</I>, which is an arrangement of tools,     menus and <I>views</I> that are tailored for a specific development task.     A view is a window that provides its own menu and buttons and performs a specific     task (e.g., editor, outline, task list).  <P> We built an Eclipse feature and perspective for Prolog, and we created extensions     to the built-in Debugger perspective for debugging Prolog components. Our     extensions are:  <ul><li> * Prolog Source File Editor    Editor Preferences  <li> * Prolog Source File Outliner  <li> * Project Cross Referencer    <li>Project Creator and Properties   <li> Project Builder (for compiling and linking Prolog modules)   <li> * Prolog Listener (for interpreted code)    <li>Prolog Runtime (for object code)    <li>Source Code Debugger    <li>Remote Source Code Debugger    <li>About Box    <li>On-Line Help    <li>Install Site for the Prolog Feature</ul>  <P> You can see the extensions marked with an asterisk in the screen shot of the   Prolog perspective (see <a href="cuj0309kroening_f1.htm">Figure 1</a>). <P> It has taken about 6 months of full-time effort to develop our Prolog perspective     and debugger extensions for Prolog code. What follows below are insights we     gained along the way.  <P>   <h3>How to Build it?</h3>  Eclipse has a clean object-oriented architecture based on plug-ins. Each plug-in   is described by an XML file. Each entry in the XML file describes a specific   extension. Usually a Java Class implements an extension, so the name of that   class is included in the XML entry. The "Platform Plug-In Developer Documentation"   describes all the extension points.  <P> An Eclipse extension takes one of three forms:  <ul><li> Implements a Java interface. In this case you write a Java Class that provides   code for all of the methods defined in that interface. For example, in the Prolog   Debugger, the <B>PrologStackFrame</B> class implements the <B>IStackFrame</B>interface.   <li> Extends an existing object. In this case you write one more Java Classes   that add and override methods of an interface implementation provided by Eclipse.   For example, Eclipse provides a TextEditor object that implements almost a dozen   interfaces. We created a <B>PrologEditor</B> that extends <B>TextEditor</B>   and overrides methods such as <B>initializeEditor()</B>.   <li> Extends an existing object and implements one or more Java interfaces. This   combines both of the above methods. For example, the primary debugger object,   <B>PrologDebugTarget</B>, extends <B>PlatformObject</B> and implements the <B>IDebugTarget</B>,   <B>IStep</B>, <B>IDebugEventSetListener</B>, <B>IBreakpointListener</B> interfaces.</ul>  <P> You can start your development work in a single plug-in. In fact, you can     put all of your extensions in just one plug-in. However, if you are building     a large number of extensions, chances are you will need and want multiple     plug-ins to do this. This is because Eclipse loads plug-ins as they are needed     by the user. So you don't want to fill up memory and delay the user to     load a bunch of code that is not needed. For this reason, most developers     put at least their debugger in a separate plug-in (some also split the debugger     user interface from the internal debug model).  <P> If you start with a single plug-in, you will find the 'refactor'     command makes it very easy to rename and move classes between plug-ins when     you need to split into multiple plug-ins or re-organize your architecture.  <P> Also, plug-ins must be in a strict hierarchy (this may not be documented     anywhere), so your user interface plug-in can call your debug plug-in, but     not vice versa. This is an important point when choosing a structure for your     extensions (see how Java, C++, and COBOL organize theirs).   <P>   <h3>Prolog Editor + Outliner + Cross Referencer</h3>  In Prolog, system functions are called <I>predicates</I>. The list of built-in   predicates varies by both Prolog implementation, and under Amzi!, by what libraries   and Prolog extensions you are using. So being able to dynamically highlight   the built-in predicate names is a very useful editor feature.  <P> The current Java Editor example is top-notch and includes keyword coloring     among its many features. It illustrates almost everything you might want to     have in your own editor. This is because the Eclipse folks have been moving     functionality from the Java Development Tool into the base product. Changing     the keyword list was quite easy, we simply built a function that calls Prolog     to find out what the current system predicates are.  <P> Some of the other features are more difficult to add or modify, especially     breakpoint setting/clearing. In these cases, experiment carefully as it takes     a long time to grasp the subtle interactions between the various editor functions     and the code that provides the implementations.  <P> Associated with the editors is the outliner. Our source file outline view   provides a tree of the Prolog predicates (see <a href="cuj0309kroening_f2.htm">Figure   2</a>). For us, the parser was very easy to build because Prolog can parse Prolog   in only a few lines of code. If your outliner is tree-based and the parser isn't   too hard to create, you will find an outliner very easy to build from the Property   Sheet example. <P> Once the outline was complete, the cross-reference view was easily built as   it is also tree-based. Again, it was easy to adapt our existing command-line   cross-referencing tool (written in Prolog) to be callable from Eclipse (see   <a href="cuj0309kroening_f3.htm">Figure 3</a>). <P>   <h3>Editor (and Other) Preferences</h3>  Eclipse supports a variety of preferences that the user can set to control how   the various views work. There is a trick for editor preferences. The base editor   in Eclipse (called <B>TextEditor</B>) relies on having preference entries with   particular names and values (see <B>TextEditorPreferenceConstants</B>). So the   best thing to do is to study Eclipse's editor preference page before building   one for your editor.  <P> As to adding your additional preferences and pages, the only difficulty     is that there are two ways to make them, and most of the existing tools (Java,     C++, COBOL) use the old way. So read the article "Simplifying Preference     Pages with Field Editors" to see if you can use the new way, which will     save much effort. Also see the <B>ReadmeTool</B> sample that has a Preferences     Page.  <P>   <h3>Prolog Projects, Properties and Builder</h3>  The primary challenge with projects is how to organize the structure Eclipse   provides to meet your needs. Eclipse allows only one project in a directory,   which is a new limitation for us that required reorganizing our samples. The   questions we had to address were: <ul><li> Where will the executable files reside? We decided on an optional bin directory.   <li> Where will we store the additional project properties? We added a build.properties   file that is a format (file extension) that can be viewed/edited by Eclipse.   <li> What files will be included in the build (compile/link) and loaded when the   Prolog Interpreter or Runtime is started? We decided to include only source   files in the top-level directory of the project, and files can be excluded in   the Project Properties.   <li> Where will the Amzi! Prolog configuration file reside? We copy one into each   project.</ul>  <P> Again the examples provide a New Project Wizard and a PropertySheet. The     builder interface (IncrementalProjectBuilder) is straightforward to implement.     The article "Project Natures and Builders" is very helpful. Eclipse     also has a marker facility that lets you create entries on the Tasks View     for each compile/link error. Each marker is optionally associated with a file     and a line number. We also create 'problem' tasks when our outline     or cross reference parser finds syntax errors in a source file. The article     "Mark My Words: Using markers to tell users about problems and tasks"     describes this facility very well.  <P>   <h3>Prolog Listener and Runtime</h3>  Eclipse provides support for running external tools and re-directing the input/output   to a Console View. So we could have simply called our command-line Prolog interpreter.   But then we could not take advantage of an IDE and have start/stop buttons,   copy/paste and command-line editing.  <P> So to build an Eclipse view for our interpreter, we needed a calling interface     that redirects the user input and output. Getting that to work under Eclipse,     though, was another story. Eclipse is very picky about what threads can access     the user interface (understandably so). This meant that although our interpreter     could run in another thread (so as to not lock up the rest of Eclipse) it     has what we could only term as a nasty set of callbacks and synchronized buffers.  <P> The other major challenge for the interpreter and the runtime is Eclipse's     launch mechanism. A new article, "We Have Lift-off: The Launching Framework     in Eclipse" would have saved us countless hours. But, our architecture     caused us problems nonetheless. Eclipse makes the assumption that for launch,     a Java Process will be created to run an executable file.  <P> However, since our Prolog is embeddable within Java (and other languages),     many of our users never create an operating system executable file that can     be run in this way. Instead we call our Prolog virtual machine directly from     Java. This led to a number of days struggling with threads. The difficulty     is that while Java Processes can be killed, Java Threads cannot. So reliably     notifying a thread that it is time to end was most difficult in an environment     with input/output being redirected. We implemented a stop button, control-break     key and handled view closing.  <P> Also, the Eclipse launch mechanism is overkill for many situations. It is     very powerful because it lets you specify all the parameters needed to run     a program. But, Prolog has very few requirements in this area. So we also     built "Launch Shortcuts" that directly run a Prolog project in the     interpreter, debugger or runtime. To make this work, requires automatically     building an Eclipse launch configuration on the fly.  <P>   <h3>Source Code and Remote Debugger</h3>  Once you've mastered program launching in a non-debug environment, you   are ready to tackle a source code debugger. Unfortunately this remains one of   the most difficult plug-ins to build. There is very little documentation, no   examples, no articles and the Java, C++ and COBOL debuggers are terribly complex.  <P> Our best advice is to start with the debug model (see org.eclipse.debug.core.model     in the Eclipse documentation. We found a newsgroup article that got me started     by explaining the following:  <P> The top-level is a <B>DebugTarget</B>. When you launch a debug session you     create a <B>DebugTarget</B> in a new thread. <B>DebugTargets</B> own Processes     and Threads (you must have at least one of each). Threads own <B>StackFrames</B>.     <B>StackFrames</B> own Variables and their Values, and Registers and Memory     Blocks. If you create a <B>DebugEventListener</B> and <B>BreakpointListener</B>     then you can watch how Eclipse interacts with your debug model implementation.  <P> The biggest problem we faced with the debugger, and Eclipse, is our desire     to highlight the currently executing line of code with either a different     icon (not possible) or a different color. We needed to do this because Prolog     can be in one of four different states on each line of code (call, fail, redo     and exit). We received some excellent help from another developer as well     as the Eclipse developers directly (on the mailing lists). Although we did     get it to work, we unfortunately have to open a new editor window. But, we've     put in our enhancement requests, and this is something they have already implemented     for the next release.  <P> As a side note, we did consider attempting a change to the Eclipse source     code and submitting it to the developers for possible inclusion in a future     release. But then existing Eclipse users could not install our Prolog extensions     until that new release was available, so we decided against this.  <P> Out of the sixmonths of development, about half have been used for the debugger.     However, the good news is once you've built a source level debugger,     getting it to work remotely is a piece of cake as Eclipse is designed perfectly     for this.  <P>   <h3>Conclusions</h3>  We can hardly wait for each new release of Eclipse. It keeps getting better and easier to use. As this article goes to press our Amzi! Eclipse IDE goes out to our users. Early beta testing shows that the new IDE is very favorably received. The system predicates coloring and source code debugger are big hits (as we hoped). If you would like to try our software, please visit us at &lt;www.amzi.com&gt;. <h3>About the Author</h3>Mary Kroening is one of the founders of Amzi! inc. and is the principal author of the Amzi! Eclipse IDE. She has been developing and marketing PC software for almost 30 years starting with the Altair 8800.</BODY> </BODY></HTML>