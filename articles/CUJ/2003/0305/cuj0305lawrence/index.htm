<HTML><HEAD><TITLE>An Idea for Dynamic C Strings</TITLE></HEAD><body bgcolor="#FFFFFF" text="000000"><H2>An Idea for Dynamic C Strings</H2><h3>Daniel Lawrence </h3><P> <p><i>Give &lt;string.h&gt; its walking papers with this slick dynamic string   library for C. </i></p><p>Native string handling in C leaves something to be desired. C provides no automatic   bounds checking and no automatic growth. The programmer must always know the   size of the buffer he is working with and must check sizes on every buffer operation.   This is tedious and error prone. This article presents an idea that might make   C -string handling a little easier.<P><h3>Usual Solutions</h3><p>The usual solution to the string problem involves special string structures and a library of functions. The structures hold buffer sizes, and the library functions grow character arrays whenever necessary.<P>A typical structure looks something like this:<P><pre>struct {     char *buf;     size_t size;     size_t len;};</pre><B>size</b> is the allocated size of the buffer, and <B>len</B> is the amount of the buffer currently used. Every time <B>buf</B> is written to, <B>size</B> and <B>len</B> are checked. If the operation would cause the buffer to overrun, the buffer is grown using <B>realloc</B> first.<P>The advantage to a system like this is that the string may contain any characters, including embedded <B>\0</B>s. However, every operation on the string requires a special function, and there have to be ways to convert back and forth between the special buffer and native C strings. These special buffers don't really feel like strings, and there is the question of how well these special structures will integrate with additional third-party libraries that may be part of the application. Additionally, the initialization and freeing of these special structures are themselves housekeeping operations that must be managed. The programmer almost has to "buy into" non-standard string management techniques.<P><h3>What We Want</h3><p>Although the special string structures do work, they are sometimes a bit over the top. They are cumbersome to use. What we really want is something that is compatible with native strings, but will handle automatic growth. Embedded <B>\0</B>s are not always necessary, so perhaps a simpler idea can be used to augment native string handling just a little.<P><h3>Idea</h3><p>Consider the fact that the standard memory allocation functions <B>malloc</B> and friends carry the same information as the above structure. When you <B>free</B> an allocated region of memory, the allocation library knows the size of the chunk. The programmer does not have to manage anything but a pointer to the actual usable memory area.<P>The same idea might be used to manage dynamic strings. Suppose you have a specialized string allocation function that returns a normal <B>char *</B>, but also records allocation size information somewhere else, like <B>malloc</B> does. And suppose you have other string functions such as <B>string_cat</B>, which can find this size information based on a given <B>char *</B>. <B>string_cat</B> would then be able to grow the string as necessary because it can easily look up the allocated size of the buffer based on the address of the destination string.<P>That idea is the basis for the simple library described here. The library consists of some functions that can determine the allocated size of a string, as well as a few functions to do things like copying, concatenating, and formatting strings. Because these functions can grow strings, we cannot rely on the regular <B>strcpy</B> and <B>strcat</B> type of functions. But otherwise, the strings managed by the library are normal C strings with <B>\0</B> termination, and they can be passed around via <B>char *</B> as usual.<P><h3>Implementation</h3><p>The simplistic implementation used currently consists of an array of structures like this:<P><pre>struct {     char *s;     size_t size;}</pre>The length of the string is available via <B>strlen()</B>, so it is not recorded in the <B>struct</B>.<P>When a dynamic string is allocated, a free element is found in the array and <B>s</B> and <B>size</B> are set. If the array needs to grow, <B>realloc</B> is used to extend it automatically.<P>Given a <B>char *</B> to a dynamic string, it is possible to scan the array looking for the corresponding element. This search uses the string's address as the key. When it finds a match, it knows the allocated size. The library rejects strings it has not allocated itself.<P>The following are some of the string management functions available in the library. The common theme is that a destination is passed to the function. This is expected to be <B>NULL</B>, which causes the function to allocate a new dynamic string, or the address of an existing dynamic string known to the library. The function will look up the size of the string and <B>realloc</B> the buffer, if necessary, before doing the operation. The function will then return the string's address. A <B>NULL</B> return value indicates there was not enough memory to complete the operation, and that the destination string has been freed.<P>The side effect of automatically freeing a string when there isn't enough memory is useful in simplifying code. See the file copy example below.<P><pre>char *string_copy(char *dst, char *src);</pre>Copy the string <B>src</B> to the dynamic string <B>dst</B>.<P><pre>char *string_cat(char *dst, ..., NULL);</pre>Concatenate the strings listed between <B>dst</B> and <B>NULL</B> to the dynamic string <B>dst</B>. Any number of strings may be listed before the <B>NULL</B>. For example:<P><pre>s = string_cat(s, "dir", "c:\www.cuj.com/", "file", NULL);char *string_sprintf(char *buf, char *fmt, ...);</pre>This is similar to <B>sprintf</B>, except that the dynamic string <B>buf</B> is used as the destination for the formatted string.<P><pre>char *string_getline(char *buf, FILE *f, int *err);</pre>This is similar to <B>fgets</B>, except that the <B>\n</B>-terminated line from <B>f</B> is placed in the dynamic string <B>buf</B> and the <B>\n</B> is not preserved.<P><pre>char *string_free(char *s);</pre>This explicitly frees the dynamic string <B>s</B>. If <B>s</B> is actually a string managed by the library, it will be freed and <B>NULL</B> will be returned. Otherwise <B>s</B> is returned. This is the only function that will not abort the application if passed a "martian" string.<P>If the "dynamic string" passed to a library function is not actually a string allocated and managed by the library, the library functions will print a "martian" message on <B>stderr</B> and abort the application.<P><h3>Examples</h3><p>Here is a simple-minded way to copy files:<P><pre>char *buf = NULL;while ((buf = string_getline(buf, stdin, NULL)) != NULL)     puts(buf);</pre>This code takes advantage of two features of <B>string_getline</B>. First, because <B>buf</B> is <B>NULL</B> the first time it is passed to <B>string_getline</B>, a new dynamic string will automatically be allocated. Second, when the loop terminates because <B>buf</B> has become <B>NULL</B> again, the dynamic string has already been freed.<P>Here is a function to construct path names:<P><pre>char *mkpath(char *buf, char *dir, char *name){     return string_sprintf(          buf,          "%s/%s",          dir,          name     );}</pre>Because I am passing a dynamic string (<B>buf</B>) to <B>mkpath</B> and I am returning the result of <B>string_sprintf</B>, <B>mkpath</B> itself has no knowledge of dynamic strings. It can be called like this:<P><pre>char *path = NULL;if ((path = mkpath(path, "etc", "app.conf")) == NULL)     ...error out of memory...f = fopen(path, "r");</pre>Before this example function returns, you could call <B>string_free(path)</B>, or you could declare <B>path</B> static.<P><h3>Weaknesses</h3><p>This obviously isn't the perfect solution to string handling in C. There are some weaknesses.<P>Because you are using native C strings, <B>\0</B>s are still string terminators and cannot be embedded in strings.<P>The extra bookkeeping involved in tracking the dynamic string lengths slows down string manipulations somewhat. On the other hand, any dynamic string implementation will have to do the same bookkeeping, so this library might not be any worse.<P>The current implementation uses a linear list. An optimized implementation could use some sort of hash on <B>char *</B> or some other speedy lookup function.<P><h3>Where to Get the Library</h3><p>Renamed versions of these string functions are available as part of The Toolbox at &lt;www.alphazed.co.uk/software/toolbox/&gt;. A real application that uses these dynamic string functions is available at &lt;www.alphazed.co.uk/software/path/&gt; and at &lt;www.cuj.com/ code&gt;.<h3> About The Author</h3><p>Daniel Lawrence lives in London with his wife Judith and little boy Cain. He runs AlphaZed Ltd., a Unix admin and programming company, &lt;www.alphazed.co.uk&gt;.<p></BODY></HTML>