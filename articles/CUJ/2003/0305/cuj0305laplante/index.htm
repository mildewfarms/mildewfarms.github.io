<HTML><HEAD><TITLE>Efficient Thread Coordination</TITLE></HEAD><body bgcolor="#FFFFFF" text="000000"><h2 align="center"> </h2><h2>Efficient Thread Coordination</h2><h3>John LaPlante</h3><i>Improve your thread control logic and make your program faster at the same time.</i><p> <h3>Introduction</h3><P> Have you ever written a background thread similar to the following?<P> <pre>extern bool   bExit;extern IOPort in;const  int    PERIOD = 100; // mswhile ( ! bExit){  stat = BlockOnInput(in, PERIOD);  if (Success(stat) &amp;&amp; !bExit)    ReadInputAndDoWork(in);}</pre>This is a common, but potentially sub-optimal way to write a thread that responds to multiple forms of input. This approach is technically incorrect as well [1]. This thread listens for both incoming I/O using <B>BlockOnInput</B> and cancellation requests from an external thread via global variable <B>bExit</B>. The code relies on rapid polling of the <B>bExit</B> flag in order to respond to cancellation requests.<P> Performance-wise, there are two problems with this example:<P> 1. Response latency: during the portion of time the worker thread is "blocked"   waiting for I/O, there is no way to interrupt it. For any given timeout <I>T</I>,   the best average response time we can expect is <I>T/2</I>.<P> 2. Polling overhead: the worker thread is expected to poll variable <B>bExit</B>.   This incurs CPU overhead. More significant however is the cost of entering/exiting   the blocking routine.<P> This article presents a C++ class that solves these problems. It provides   fast interruption of background threads with virtually no application polling.   It allows polymorphic handling of multiple threads and is extensible via template   parameters for platform independence and varying I/O models.<P><h3>Why Control Threads?</h3><p> Why would you need to interrupt or otherwise externally control a perfectly   good background thread? At a minimum, your application would benefit from a   graceful and responsive shutdown when complete -- forceful thread termination   APIs, when available, are often considered risky [2]. At other times, it may   be desirable to have background threads switch state to begin another task.   There may be cases where you want to halt processing in order to quickly respond   to some sort of emergency event. The design ideas presented here evolved from   requirements to respond quickly to shutdown events in large, multithreaded,   factory automation systems.<P> In modern operating environments, as a thread author, you are urged to signal   threads with familiar inter-thread communication mechanisms and allow them to   change state gracefully themselves. Let's explore how to do this efficiently.<P><h3>Polling versus Blocking</h3><p> From your application's point of view, your thread will generally be   in one of two states:<P> 1. Running: your thread is actively executing code or APIs that do not suspend   your thread -- it is getting CPU time. This corresponds to the <B>ReadInputAndDoWork</B>   call in my example.<P> 2. Suspended: your thread is taking little or no CPU time. This is done with   the help of the operating system and can take the form of a simple sleep API;   wait APIs, which operate on semaphores, mutexes, condition variables, etc.;   or blocking I/O APIs such as <B>read</B>, <B>select</B>, etc. [3]. This corresponds   to the <B>BlockOnInput</B> call in my example.<P> You can interrupt a thread that is running by having it regularly poll some   intermediate variable or object. You will be forced to face the "<a href="cuj0305laplante_s1.htm">Overhead   versus Latency Conundrum</a>" (see sidebar) for these portions of your code,   so get used to it. <P> Interrupting a suspended thread is more interesting. A blocked thread can   resume in the following ways:<P> <ul>  <li> Timeout: the wait times out. This is not interrupting your thread.   <li> Wait satisfaction: the wait is satisfied by receipt of the desired event     or data. Again, this is not interrupting the thread but rather normal operation.   <li> Simulate wait satisfaction: arrange your logic to simulate the event for     which your thread is waiting, but use a special value that differentiates     the event. Alternatively you could force an intentional error condition.   <li> Multiple-input waiting API: satisfy a secondary input channel of a "multiple-input"     waiting API. Some operating systems provide assistance with APIs that can     "listen" for more than one event or I/O channel simultaneously.     The <B>select</B> socket call and Windows' <B>WaitForMultipleObjects</B>     are common examples that are exploited here. Your environment may provide     other such facilities [4].</ul>Simulating wait satisfaction of your object may not always be possible. Even if it is, it requires you to expose an interface to your blocking object and include special handling of your semaphore message or error condition. This type of logic can obfuscate your code.<P> A "multiple-input" wait is elegant and more logically correct. The   <B>ThreadMediator</B> class presented here relies on the availability of such   an API. With this operating system support, you can implement fast and efficient   interruption of blocked threads [5] without polling.<P><h3>Design</h3><p> I have named the base class <B>ThreadMediator</B> because it is loosely based   on the Mediator pattern outlined by the classic GoF <I>Design Patterns</I> book   [6]. As described in the book, a mediator:<P> ...is responsible for controlling and coordinating the interactions of a group   of objects. The mediator serves as an intermediary that keeps objects in the   group from referring to each other explicitly. [7] <P> In this design, a mediator object derived from <B>ThreadMediator</B> is used   as an intermediary for communication between a controller thread and a worker   thread. Much like the Mediator pattern, this intermediate object isolates the   controller thread from the worker thread and also centralizes the thread synchronization   logic. However, <B>ThreadMediator</B> models this coordination between just   two objects, rather than a group of objects as intended by the original Mediator   pattern.<P> Also similar to the Mediator pattern, <B>ThreadMediator</B> supports polymorphism,   so you can use a different mediator with each background thread. The controller   thread simply sees the uniform polymorphic interface to the base class. <P> <a href="cuj0305laplante_f1.htm">Figure 1</a> illustrates the structure of   the sample code (available for download from &lt;www.cuj.com/code&gt;). A mediator   object exists for each background thread. Whenever each background thread must   perform some lengthy waiting operation, it is done uniformly through calls,   such as <B>Wait</B> or <B>Sleep</B>, on the mediator object. This includes waits   on thread synchronization objects, waits for I/O, or sleep calls. <P> When there is a need to signal these background threads, the controller thread   sends its intentions via the mediator objects, in this case, with the <B>Signal</B>   function.<P> <B>ThreadMediator</B> responds to this signal by causing an exception to be   thrown immediately within the target background thread. It is the responsibility   of the programmer to arrange for the proper <B>try</B>/<B>catch</B> blocks to   handle this exception in each of the background threads and respond accordingly.   <B>ThreadMediator</B> classes include a templated argument for the type of exception   thrown, so it can dovetail with existing exception architectures.<P> The sample code includes three types of threads to illustrate several typical   uses for thread mediation. These include:<P> <ul>  <li> <B>MonitorThread</B>: periodically awakens to perform a task.   <li> <B>SocketThread</B>: handles input from a socket.   <li> <B>DeviceThread</B>: starts a command on an external device and waits for     completion.</ul><B>MonitorThread</B> is really just a simple timer that is interruptible while asleep.<P> <B>SocketThread</B> is based on familiar BSD sockets. This example waits for   UDP input from any port.<P> The <B>DeviceThread</B> code emulates an external device with driver semantics   that communicate completion status by signaling a Win32 synchronization object   handle, such as an event. In the sample code, this is simulated with a Win32   waitable timer handle.<P> Recoded with this mediator design, my original example boils down to something   like this:<P> <pre>try{  while (true)  {    mediator.Wait(in,INFINITE);    ReadInputAndDoWork(in);  }}catch(SomeException &amp; ex){  // Handle the signal request}</pre>Notice that the timeout for the blocking call is now infinite. The code no longer polls. Instead, the operating system is performing this function more efficiently for you. The main execution loop of all three example threads looks very similar to this.<P><h3>Class Structure</h3><p> <a href="cuj0305laplante_f2.htm">Figure 2</a> shows a class diagram of the   <B>ThreadMediator</B> hierarchy. At the top is an abstract <B>ThreadMediator</B>.   This class exposes an interface intended for the controller thread that allows   signaling of the threads for interruption. See <a href="cuj0305laplante_l1.htm">Listing   1</a> (<B>ThreadMediator.h</B>) for the implementation. <P> <B>ThreadMediatorImpl</B> extends <B>ThreadMediator</B>, adding an interface   intended for the background threads. This includes all the waiting functions.   <B>ThreadMediatorImpl</B> adds little in the way of logic however. Most of the   real logic is delegated to a private object parameterized by the template token   <B>Sync</B> in <a href="cuj0305laplante_f2.htm">Figure 2</a>. (Recall Coplien's   Handle/Body and Envelope/Letter idioms, but think compile-time polymorphism   for the inner class [8]). <B>Sync</B> is also referred to variously as "synchronizer"   throughout the code. <P> The controller thread treats multiple concrete mediators polymorphically through   the <B>ThreadMediator</B> interface. Each background thread can use a different   type of mediator object, tailored for the type of synchronization or I/O that   is needed. The controller thread only sees the common abstract <B>ThreadMediator</B>   base class interface they all share. This is a key underpinning of the formal   Mediator pattern, although it is considered optional in simple situations [9].<P> The <B>ThreadMediator</B> and <B>ThreadMediatorImpl</B> classes constitute   the platform-independent portion of the hierarchy. The synchronizer classes   isolate platform-dependant code from the mediator classes. Additionally, the   synchronizer classes isolate the underlying I/O model, whether it is sockets,   events, messages, etc. Think of the synchronizer classes as user-supplied classes   that you hand code to extend the Mediator pattern for different I/O models and/or   platforms.<P> The sample code includes two synchronizer classes: <B>SocketSynchronizer</B>   and <B>Win32Synchronizer</B>. <a href="cuj0305laplante_l2.htm">Listing 2</a>   (<B>Win32Synchronizer.h</B>) shows the implementation of the shorter of the   two, <B>Win32Synchronizer</B>. <P> <B>Win32Synchronizer</B> holds a private <B>HANDLE</B> member <B>_signalObject</B>,   which is initialized as an <B>Event</B>. Its <B>Wait</B> function therefore   also takes a <B>HANDLE</B> argument as the application object for which to wait.   <B>Win32Synchronizer</B> uses <B>WaitForMultipleObjects</B> [10] to perform   blocking waits. Calls to <B>WaitForMultipleObjects</B> include the private <B>_signalObject</B>   event as the first in the handle array. If there is another object to be waited   for, that is added as the second handle in the array.<P> When an external thread wants to interrupt the background thread, it calls   <B>Signal</B>, which calls <B>SetEvent</B> on the <B>_signalObject</B> event.   Meanwhile the background thread, presumably already blocked in the <B>WaitForMultipleObjects</B>   call, will awaken immediately, <B>WaitForMultipleObjects</B> will return status   that <B>_signalObject</B> is signaled, and an exception is thrown. The type   of exception thrown is a template parameter to the provided synchronizer classes.<P> <B>SocketSynchronizer</B> works similarly to <B>Win32Synchronizer</B> except   that the private <B>_signalObject</B> member is of type <B>SOCKET</B>, and all   blocking waits are performed through <B>select</B>. Its <B>Wait</B> function   therefore takes a <B>SOCKET</B> argument as the application object for which   to wait. When <B>Signal</B> is called, the <B>_signalObject</B> socket is closed,   notifying <B>select</B> that it is ready to read [11], and the whole exception   throwing exercise ensues. In a Unix environment, <B>select</B> allows you to   wait on file-like handles other than sockets such as external devices, pipes,   etc.<P><h3>Running the Example</h3><p> <a href="cuj0305laplante_l3.htm">Listing 3</a> (<B>Main.cpp</B>) starts at   the top level of a simple example. Three thread objects are created, and references   to them are stored polymorphically in an array for convenience. These background   threads are started, and then the main thread goes to sleep, awaiting keyboard   input from the user. <P> At this point, the background threads begin to print their current activity   to the screen. You will observe them alternating between blocked and unblocked   activity, with randomly varying timeouts just to keep things interesting. Upon   receipt of an Enter keystroke (newline) from the user, the main thread awakens   immediately and calls <B>Signal</B> on the mediator object for every background   thread. This is done indirectly through a delegation function on the thread   base class. You will observe the response from all threads as they exit quickly.<P><h3>Extensions and Limitations</h3><p> There are some variations on this implementation that come to mind. One possible   extension is to overload the <B>Wait</B> function to take an array of synchronization   objects. Another obvious extension is error handling, which has been ignored   in the sample code.<P> The sample code for <B>SocketSynchronizer</B> uses the brute force technique   of simply closing the signaling socket. An alternative implementation would   be to create a socket pair (<B>socketpair</B> [12]) and treat <B>_signalObject</B>   like a pipe, using simple character writes to signal <B>select</B>.<P> You can also opt to signal your threads with something other than exceptions,   such as return codes. If retaining the exception-based strategy, ensure that   your application is relatively exception-compliant by using "Acquisition   is Initialization" coding models [13], or rigorously <B>try</B>/<B>catch</B>ing   wherever a resource leak may occur from thrown exceptions.<P> The sample code was developed under Windows with Visual C++ 6.0 to illustrate   the use of both <B>select</B> and the Win32 <B>WaitForMultipleObjects</B> call   in the same application. Those portions that are not Win32-centric, such as   the base mediator classes and the socket classes, should port pretty cleanly   to other environments, but this has been left as an exercise for the reader.<P> It should also be noted that Win32's <B>CreateWaitableTimer</B> has been   used in the device simulations, so this application requires Windows NT 4 or   later and will not run under Windows 9x derivatives.<P> I have used this strategy successfully in two real-world applications. It   has improved the efficiency and robustness of both, while isolating the details   of control logic. Perhaps your applications can benefit as well.<p><b>Sidebar:</b> <a href="cuj0305laplante_s2.htm">To Poll or Not to Poll --   That is the Question</a> <h3>Notes</h3><p> [1] Many would argue it is incorrect because of unsynchronized access to <B>bExit</B>   from multiple threads, especially on multiprocessor machines. Technically this   is true; however since <B>bExit</B> is a single, atomic byte and is being tested   only for zero/non-zero values, I believe this risk vanishes in practice.<P> [2] Win32's <B>TerminateThread</B> is described by Microsoft as "a   dangerous function that should only be used in the most extreme cases."   See &lt;http://msdn.microsoft.com/library/en-us/dllproc/ base/terminatethread.asp&gt;.<P> [3] W. Richard Stevens. <I>Advanced Programming in the Unix Environment</I>   (Addison-Wesley, 1992), p. 396.<P> [4] Some examples here might include <B>ev_receive</B> (pSOS) and <B>ajevwat</B>   (AMX). If your thread pumps some form of message, messaging APIs work nicely   in this context, such as <B>msgQReceive</B> (VxWorks), <B>MsgReceive</B> (QNX),   and <B>GetMessage</B> (Win32).<P> [5] The terms "fast" and "efficient" are completely relative.   What is meant here is fast and efficient relative to the underlying operating   system.<P> [6] Erich Gamma, Richard Helm, Ralph Johnson, John Vlissides. <I>Design Patterns:   Elements of Reusable Object-Oriented Software</I> (Addison-Wesley, 1995).<P> [7] Erich Gamma, et al. p. 274.<P> [8] James Coplien. <I>Advanced C++: Programming Styles and Idioms</I> (Addison-Wesley,   1992).<P> [9] Erich Gamma, et al. p. 278.<P> [10] &lt;http://msdn.microsoft.com/library/en-us/dllproc/base/ waitformultipleobjects.asp&gt;<P> [11] This is actually correct behavior; see [1], p. 400.<P> [12] Douglas Comer. <I>Internetworking with TCP/IP: Principles, Protocols,   and Architectures</I>, 4th Edition (Prentice-Hall, 2000), p. 416.<P> [13] Bjarne Stroustrup. <I>The C++ Programming Language</I>, 3rd Edition (Addison-Wesley,   2000), Section 14.4.<P> [14] See &lt;www.osl.iu.edu/download/mpidc95/papers/html/ nieplocha/polling.html&gt;   for a similar discussion.<P> [15] &lt;http://info.iet.unipi.it/~luigi/polling/&gt;<h3>About the Author</h3> <p>John LaPlante holds two B.S. degrees and has programmed computers   for 20 years, including incarnations with Hewlett-Packard, The Learning Company,   Akamai, Mindport, Loral Corp., and GSI Lumonics. He currently resides in San   Diego, CA with his cat, dog, wife, and three kids, automating DNA analysis hardware   for Illumina Inc. and can be reached at <B>jlaplante@illumina.com</B>.<p> </BODY></HTML>