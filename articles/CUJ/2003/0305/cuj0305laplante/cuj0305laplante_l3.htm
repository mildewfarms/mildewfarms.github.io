<HTML><HEAD><TITLE>Listing 3:	Main.cpp </TITLE></HEAD><body bgcolor="#FFFFFF" text="000000"><B> Listing 3:</B>	Main.cpp<pre>/*===========================================================*\    This is the main entry point for the thread demo.\*===========================================================*/#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;#include &lt;vector&gt;#include "MonitorThread.h"#include "SocketThread.h"#include "DeviceThread.h"#include "Miscellaneous.h"int main(int argc, char* argv[]){    #ifdef WIN32        WSADATA wsaData;        DWORD status = ::WSAStartup(2, &amp;wsaData);    #endif    // All thread objects allocated as locals here.    MonitorThread   monitor("Monitor", 3000);    DeviceThread    deviceThread("Device");    SocketThread    socketThread("Socket");    // Put pointers into polymorphic array for looping    std::vector &lt;Win32Thread *&gt; threads;    threads.push_back(&amp;monitor);    threads.push_back(&amp;deviceThread);    threads.push_back(&amp;socketThread);    // Start all threads - call Start() on each    std::for_each(threads.begin(), threads.end(),         std::mem_fun(Win32Thread::Start));    Print("All threads started");    Print("Press Enter to interrupt...");    // Block this thread, waiting for Enter key    int ch = std::cin.get();    // User pressed Enter key.    // Interrupt all threads - call Signal() on each    std::for_each(threads.begin(), threads.end(),         std::mem_fun(Win32Thread::Signal));    // Wait for all threads - call WaitToExit() on each    std::for_each(threads.begin(), threads.end(),         std::mem_fun(Win32Thread::WaitToExit));    Print("All threads complete");    #ifdef WIN32        ::WSACleanup();    #endif    return 0;}</pre></BODY></HTML>