<HTML><HEAD><TITLE>No Brain, No Gain</TITLE></HEAD><body bgcolor="#FFFFFF" text="000000"><h2>Uncaught Exceptions: No Brain, No Gain<P></H2><H3>Bobby Schmidt</H3><P><i>Learn how not to declare template friends and implement assignment operators, lest you actually make these mistakes.</i><P>Copyright &copy; 2003 Robert H. Schmidt<P>Thanks to a wildcat strike by most lobes in my brain's right hemisphere, I have no creative preamble this month. My cerebrum and I are in contract negotiations at this moment and hope to have a deal struck soon. Until then I'm replacing my wildcat brain with my domestic cats' brains [1].<P>The feline writing technique is subtle and deft, yet passionate and creative. As I watch them work, I know I'm in the presence of truly gifted minds. Here's an actual untouched sample of my stale original:<P>Working<P>and the cats' incomparable enhancement:<P><pre>Wor""""""""""""""""""""""""""""""""""||||||\\\\'?|{{{^66,5pssssssssssssssssssssssssssssss-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------0pppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppp[[[[[[[[[[000000---------------97tg</pre>My meager thoughts pale beside their tttthouuuughts. Like Lazarus Long, the cats clearly believe that moderation is for monks.<P>Most incredibly of all, this talent manifests through "random" walks on the keyboard. Random indeed! I can only surmise that this appearance of randomness is a clever form of obfuscation, to keep other lesser talents from stealing their technique.<P><h3>Smarter Than the Average Pointer</h3><p> <b><font size="+2">Q</font></b>&nbsp;Hi Bobby,<P>There is a discussion at our company about whether it is beneficial to use <B>auto_ptr</B>. The opinion against it is that:<P><ul><li>  Pulling in the header file <B>&lt;memory&gt;</B> slows down compiling.<li>  If we watch for small problems associated with using bald pointers, such as memory leaks, references to invalid pointers could be avoided without using <B>auto_ptr</B>.</ul>I would appreciate your opinion on this subject.<P>Regards,<P>-- Bao Tran<P><P><b><font size="+2">A </font></b>&nbsp;Yes, there are reasons to avoid <B>auto_ptr</B>. But I've never before had anyone suggest that compilation time is one of them.<P>All else held equal, including a header will usually degrade compilation speed -- so trivially the allegation against <B>#include &lt;memory&gt;</B> is correct. However, the important question to ask is: does the degradation make a <I>significant</I> difference?<P>Have you or your team done benchmarks to determine just how much drag <B>#include</B> <B>&lt;memory&gt;</B> puts on your builds? I'm guessing not. Unless you are building on glacial hardware, have zillions of source files, or rebuild frequently, I can't imagine that <B>#include</B> <B>&lt;memory&gt;</B> will significantly compromise your build times [2].<P>As to the second allegation: sorry, but that argument is tantamount to saying "if we avoid all of the problems associated with real arrays, then we don't need vectors." Well yeah, sure; but if those problems were so easily avoided, or if containers and smart pointers existed purely to solve those problems, then nobody would need them.<P>There are reasons beyond memory-leak prevention for using smart pointers. Among them:<P><ul><li>  Smart pointers can track and profile their own usage patterns.<li>  Smart pointers can selectively enable or disable pointer-like behavior.<li>  Smart pointers can selectively enable or disable usage with certain types.<li>  Smart pointers can allow allocation/deallocation schemes beyond the usual <B>new</B> and <B>delete</B>.</ul><B>auto_ptr</B> can't do any of these things, but other smart-pointer types can. For a most extreme example of such smart pointers -- no, eccentric genius pointers -- see chapter 7 of Andrei Alexandrescu's book <I>Modern C++ Design</I> (Addison-Wesley, 2001). His publisher has made that chapter available free online [3].<P>In a narrow sense, I agree with your colleagues that you should avoid <B>auto_ptr</B>, but not for the reasons you give. You should avoid it mostly because it makes some limiting assumptions and has one trick feature (ownership semantics) that is more liability than asset [4].<P>At the same time, I think you would be remiss if you abandoned all smart-pointer usage. I would actually encourage the opposite tack: that you keep raw-pointer usage to a minimum, mostly for interfacing with C and C-like code, for those few places truly requiring highest performance, or for the lowest-level implementation of smart pointers and similar objects.<P><h3>No Friend of Mine</h3><p><b><font size="+2">Q</font></b>&nbsp;Hi Bobby,<P>Why won't the following code compile in C++?<P><pre>template&lt;typename T&gt;class A    {    friend class T;    };</pre>My compiler complains:<P><pre>template parameter T may not be used in an elaborated type specifier</pre>What exactly is an elaborated type specifier and why can't <B>T</B> be used in one? <B>T</B> is well known at compile time, so why can't the compiler perform the (expected?) substitution?<P>Thanks for your time!<br>-- Shane Neph<P><P><b><font size="+2">A </font></b>&nbsp;Elaborated type specifier. Say it with me: elaborated type specifier. Ahhh, the way it rolls off the tongue. Exquisite. Poetic.<P>Reverie over.<P>Here's the grammatical definition, hot from the C++ Standard griddle:<P><P><I>elaborated-type-specifier:</I><BR>  <I>class-key </I><B>::</B>opt <I>nested-name-specifier</I>opt<I> identifier</I><BR>  <B>enum ::</B>opt<I> nested-name-specifier</I>opt<I> identifier</I><BR>  <B>typename ::</B>opt<I> nested-name-specifier identifier</I><BR>  <B>typename ::</B>opt<I> nested-name-specifier</I> <B>template</B>opt<I> template-id</I><P>O-kay...<P>Here's a simple and imprecise definition: a type name prefixed or "elaborated" with the type's kind (<B>class</B>, <B>enum</B>, and so on).<P>Some examples:<P><pre>class Tclass ::Tclass X::Tclass ::X::Tstruct Tenum Ttypename Ttypename template T</pre>In your case the elaborated type specifier is:<P><pre>class T</pre>in the context of:<P><pre>friend class T;</pre>Your compiler complains that you can't use the template parameter <B>T</B> in this context. You counter that the compiler is being too picky, and that it should know that <B>T</B> is perfectly okay in this context.<P>I don't know if your counter is true or not, since I don't have a complete example. It doesn't really matter: the compiler is correct, in that it's following the language rules. Indeed, just after the grammatical definition I show above, the Standard has this lovely passage:<P>If the <I>identifier</I> resolves to a <I>typedef-name</I> or a template <I>type-parameter</I>, the <I>elaborated-type-specifier</I> is ill-formed.<P>In your example, the identifier (<B>T</B>) resolves to a template type parameter. That fact renders the elaborated type specifier (<B>class T</B>) invalid.<P>As if reading your mind, the passage's authors continue:<P>Note: this implies that, within a class template with a template type-parameter T, the declaration<P><pre>      friend class T;</pre>is ill-formed.<P>D&eacute;j&agrave; Vu!<P>Why are the rules constructed this way? Consider:<P><pre>template&lt;typename T&gt;class A    {    friend class T;    };class X    {    // whatever    };A&lt;X&gt; x;</pre>You're thinking this last line should work, since the compiler knows that <B>X</B> is a class and can therefore be made a friend of <B>A&lt;X&gt;</B>. But now consider:<P><pre>A&lt;int&gt; x2;</pre>For this to work the way you want, <B>A&lt;int&gt;</B> would instantiate as:<P><pre>class A&lt;int&gt;    {    friend class int;    };</pre>I'm sure you see the problem: <B>int</B> can't be a friend of anyone in any context.<P>One easy solution to your problem is to remove the <B>friend</B> declaration from the primary declaration and move it selectively into specializations. A simple example:<P><pre>class X    {    };//// primary declaration of A//template&lt;typename T&gt;class A    {    };//// specialization of A&lt;X&gt;//template&lt;&gt;class A&lt;X&gt;    {    friend class X;    };</pre>You could make the argument that this grammar limitation is arbitrary, since the language rules allow other template constructions that make assumptions about the type parameter. The example:<P><pre>template&lt;typename T&gt;class A2    {    typename T::X x;    };</pre>assumes that <B>T</B> is something that can have members at all, has a particular member named <B>X</B>, and that <B>X</B> is a type. That seems a much more ambitious assumption than does <B>class T</B>; yet the <B>A2</B> declaration is allowed while the <B>A</B> declaration is not [5].<P><h3>Refuse to Reuse</h3><p><b><font size="+2">Q</font></b>&nbsp;Often times when writing classes I find that the bulk of the code in the assignment operator is just code from the destructor followed by code from the copy constructor. When actually trying to put that observation into actual code, however, I can only do it partially, and even that doesn't seem right. The included code illustrates all of the things I've tried with their results and error messages. (I'm using Visual C++ .NET.)<P>Questions:<P><ul><li>  Why does <B>X(x)</B> put an anonymous <B>x</B> instance on the stack?<li>  Why doesn't <B>(this-&gt;*...)(...)</B> work?<li>  Why <I>does</I> <B>(this-&gt;...)(...)</B> work?</ul>Any illumination you could provide on these questions would be deeply appreciated.<P>-- Daniel Mathews<P><P> <b><font size="+2">A </font></b>&nbsp;My slightly edited version of your sample   appears as <a href="cuj0305schmidt_l1.htm">Listing 1</a>. I've attached a number   (#1 through #10) to each test case in your code. I'll target my answers to those   numbered cases. After that I'll make some general observations. <P>Case #1: You can call the destructor explicitly (as I discuss for Case #8), but not by its simple unqualified name <B>~X()</B>. The compiler interprets that expression as <B>~ X()</B>, where <B>~</B> is the unary complement operator. As the compiler error suggests, you cannot take the unary complement of an <B>X</B> object, because type <B>X</B> doesn't define <B>operator~</B> and doesn't convert to some other type that allows the built-in <B>~</B> operator.<P>Case #2: In one of those potentially ambiguous grammar points, <B>X(x)</B> could be either an expression creating a temporary <B>X</B> initialized from <B>x</B>, or the declaration of an <B>X</B> object named <B>x</B>. According to the tie-breaking rules, it's a declaration of <B>x</B>. If you immediately follow this line with another <B>X(x)</B>, your compiler will validate my claim, by flagging <B>x</B> as multiply declared. If you really want to construct a temporary <B>X</B> from <B>x</B>, use the cast notation <B>(X) x</B>.<P>Case #3: You say this works. It shouldn't. The <B>-&gt;*</B> operator requires a right operand of type "pointer to member of <B>X</B>." The expression <B>f</B> is not a pointer to an <B>X</B> member and does not convert to a pointer to an <B>X</B> member. If you insist on the pointer-to-member notation, try the truly unpleasant <B>(this-&gt;*&amp;X::f)()</B>.<P>Cases #4 and #5: Nope, you can't call constructors and destructors this way. Your error messages refer to the appearance of the type name <B>X</B> in the offending expressions.<P>Case #6: This shouldn't work. See Case #3.<P>Case #7: Finally! Something that compiles and actually should compile. In this context, the expression <B>this-&gt;f</B> is equivalent to the much simpler <B>f</B>.<P>Case #8: This is the correct pattern for explicitly calling the <B>X</B> destructor. If you want to be pedantic, you can use the fully qualified form <B>this-&gt;X::~X</B>. Sometimes you need this second form: if <B>~X</B> were a virtual destructor called from a class derived from <B>X</B>, then <B>this-&gt;~X()</B> would (virtually) call the derived-class destructor, while <B>this-&gt;X::~X()</B> would (statically) call the <B>X</B> destructor [5].<P>Case #9: This is the correct pattern for invoking the assignment operator as a regular function call rather than as an infix operator. In this context, you can shorten <B>this-&gt;operator=</B> to <B>operator=</B>.<P>Case #10: This fails, as it should. Unlike destructors, constructors cannot be called explicitly. Ultimately this is the capability you really want.<P>Now for my general observations. The realization you describe is ancient, one that just about all of us run into eventually. Barring technicalities of object identity and lifetime, a copy assignment operation is tantamount to an in-place copy construction over the foundation of a just-destructed object. Since the in-place "copy construction" into old memory is very often the same operation as a genuine copy construction into new memory, you reasonably want to reuse the same code for both.<P>But as you discovered, you can't call a constructor directly. The closest you can easily come is to pull the common code into a normal (non-constructor) function and call that from both your copy constructor and copy-assignment operator:<P><pre>class X    {public:    X(X const &amp;x)        {        construct(x);        }    X &amp;operator=(X const &amp;x)        {        if (&amp;x != this)            {            this-&gt;~X();            construct(x);            }        return *this;        }private:    void construct(X const &amp;)        {        // ...        }    };</pre>This pattern, while common, is not without limitation:<P><ul><li>  <B>const</B> members must have their values set in a constructor's member initializer list. Once set, <B>const</B> members cannot be changed without a mild hack.<li>  Reference members must be bound to their referenced objects in a constructor's member initializer list. Once bound, reference members cannot be rebound to other objects without a severe hack [7].<li>  In the copy constructor, each member is initialized (either explicitly in an initialization list, or implicitly by default construction), and then effectively "reinitialized" in construct. At best this redundancy may cause inefficiency; at worst it may distort your program's semantics.<li> Inheritance complicates the pattern. For an example, see Case #8 above. Also consider what happens if <B>operator=</B> is virtual in <B>X</B> or <B>X</B>'s base. </ul>I'll also note that the simple pattern of testing for self-assignment:<P><pre>if (&amp;x != this)</pre>does not work in the general case, especially when complicated inheritance hierarchies are involved. In addition, as Herb Sutter explains [8], exception-safe code typically doesn't require this check. Even if you don't particularly care about exception safety, I suggest you read Herb's piece anyway, as it shows an alternative (and now commonly accepted) approach to copy assignment.<P><h3>Notes</h3><p>[1]  Oh, alright, since someone will ask: the cats names are John Lodge and Artemis, where John Lodge = the Moody Blues' bassist, and Artemis = the Greek goddess of the hunt. They are twins, and I've had them pretty much since they were born. They will have their 15th birthday just as this column hits the streets.<P>[2]  I'm talking here strictly of header-inclusion time, not template-instantiation time. If you reference <B>auto_ptr</B> all over the place for lots of different types, the instantiation times for all of those <B>auto_ptr</B> specializations could add up.<P>[3]  &lt;www.aw.com/samplechapter/ 0201704315.pdf&gt;<P>[4]  Now "avoid" does not mean "never use," for there are times that <B>auto_ptr</B> is useful and correct. If you never assign them, restrict them to fairly bounded scopes, and use them just to guarantee object deletion, <B>auto_ptr</B>s can be reasonable tools. (Chuck Allison tells me he uses them, so you know they can't be all bad.)<P>[5]  Yes, yes, yes, I know that if you try instantiating <B>A</B> with a type that doesn't have a proper <B>X</B> member, the compilation will fail. But that failure occurs at the point of <B>A</B> instantiation; if you never instantiate <B>A</B>, the compilation can succeed. The example using <B>friend class T</B> will always fail at the point of <B>A</B> declaration, even if you don't actually instantiate <B>A</B>.<P>[6]  Destructors alter the usual virtualization rules. Normally if you call a function virtually, you land in some function with the same name. But if you call a destructor virtually, you can land in a function with a different name. For example, if <B>D</B> is derived from <B>B</B>, a virtual call to <B>~B</B> from a <B>D</B> object would land in <B>~D</B> -- a differently-named function.<P>[7]  You can change the value of the referenced object, but not the actual reference itself -- a subtle but real distinction.<P>[8]  &lt; www.gotw.ca/gotw/059.htm&gt;<p><h3>About the Author</h3><p>Although Bobby Schmidt makes most of his living as a writer and content strategist for the Microsoft Developer Network (MSDN), he runs only Apple Macintoshes at home. In previous career incarnations, Bobby has been a pool hall operator, radio DJ, private investigator, and astronomer. You may summon him on the Internet via <B>BobbySchmidt@mac.com</B>.<p></BODY></HTML>