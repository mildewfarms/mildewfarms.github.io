<HTML><HEAD><TITLE>Listing 1:	SecureAllocator</TITLE></HEAD><body bgcolor="#FFFFFF" text="000000"><B> Listing 1:</B>	SecureAllocator<p><pre>template&lt;    class T,    class ScrubPolicy = ScrubOnDestroy&lt;BasicScrubber&gt;,    class AllocPolicy = NoSwapHeap,    class LockPolicy = NoLocking&lt;AllocPolicy&gt;&gt;class SecureAllocator{public:    // Common allocator typedefs    ...    size_type max_size()    {        return getAllocator().max_count(sizeof(T));    }    pointer allocate(size_type num, const_pointer hint = 0)    {        LockPolicy::Lock lock;        void* pmem = getAllocator().doAlloc(num * sizeof(T), hint);        if (!pmem)        {            throw std::bad_alloc();        }        return static_cast&lt;pointer&gt;(pmem);    }    void deallocate(pointer pmem, size_type num)    {        LockPolicy::Lock lock;        getScrubber().onDeallocate(pmem, num * sizeof(T));        getAllocator().doFree(pmem, num * sizeof(T));    }    void construct(pointer pmem, const value_type&amp; val)    {         new(pmem) value_type(val);    }    void destroy(pointer pmem)    {        pmem-&gt;~value_type();        getScrubber().onDestroy(pmem, sizeof(T));    }private:    AllocPolicy&amp; getAllocator()    {        return PolicyHolder&lt;AllocPolicy&gt;::getPolicy();    }    ScrubPolicy&amp; getScrubber()    {        return PolicyHolder&lt;ScrubPolicy&gt;::getPolicy();    }};template &lt;class Policy&gt;class PolicyHolder{public:    typedef MutexLocking&lt;Policy*&gt;::VolatileType        PtrType;    static Policy&amp; getPolicy()    {        static PtrType pPol = NULL;        if (pPol == NULL)        {            typename MutexLocking&lt;PolicyHolder&lt;Policy&gt; &gt;::Lock lock;            if (pPol == NULL)            {                pPol = new Policy();            }        }        return *pPol;    }};</pre></BODY></HTML>