<HTML><HEAD><TITLE>A Secure Storage Allocator Template</TITLE></HEAD><body bgcolor="#FFFFFF" text="000000"><h2 align="center"> </h2><h2>A Secure Storage Allocator Template</h2><h3>Edward Elliott</h3><p><i>A policy-based approach to protecting sensitive data.</i><p>Secure storage of secrets is a long-standing issue in software design. One   tiny aspect of this general problem is storing sensitive data (cryptographic   keys, passwords, etc.) in physical memory. System-dependent factors in the handling   of virtual memory make relying on the standard virtual memory abstractions insecure   [1]. <P>Fortunately, STL containers use allocators, allowing precise user control of memory allocations and deallocations. A secure allocator template can be devised to deal with some of the security issues of memory management. Using such an allocator, STL containers can hold sensitive data, bringing their reliability and ease-of-use to the management of cryptographic keys and passwords.<P>I will discuss the design of a thread-safe secure allocator template suitable for use with STL containers. The allocator is policy-based for easy extensibility. I will provide source code for Windows/Microsoft Visual C++ and Linux/gcc (available for download at &lt;www.cuj.com/code&gt;). Adapting the code for other platforms (especially Unix-like platforms) and compilers should be easy. Those interested only in using the allocator can skip to the "Usage" section below, but be aware of this approach's limitations given in the "Conclusion."<P><h3>Motivation</h3><p>Handling sensitive information requires particular attention to detail. Data such as cryptographic keys, passwords, and secret access tokens must be handled in a way that minimizes the chances of an adversary learning the data. An "adversary" here could be another process on the same machine, an eavesdropping host along a communications path, or even a person glancing at a console over the shoulder of a system administrator.<P>Consider a program holding a secret key in memory at run time. What happens when the process is done with the key and releases the memory back to the operating system? The system makes this memory available to other processes. On some systems, an attacker can run a trivial program on the target machine that continually requests memory from the system, inspects its contents for keys, and releases it. As a result, a process should overwrite sensitive data before releasing its memory.<P>Data written to magnetic storage media suffers even more vulnerabilities. "Deleting" a file usually involves nothing more than removing an entry from a directory table. The blocks containing the file's data remain on disk, where they can be read at any time by another program [2]. Commercial undelete programs exploit this behavior to recover files. More sophisticated attacks using special equipment can even read overwritten data off a disk [3].<P>To counter these threats, the prudent course is to ensure sensitive data never hits the disk. Secrets stored in physical memory can potentially be paged out to a swap file by the virtual memory manager. A security-conscious program should therefore try to prevent sensitive memory from being swapped to disk. Otherwise, copies of the data may remain on the disk long after the program has terminated.<P>The benefits of an allocator that can perform these tasks are obvious. As with any type of data, STL containers greatly simplify the chores of management.<P><h3>Design</h3><p>The design of allocators in general is beyond the scope of this article. Comprehensive treatment of that topic may be found in Chapter 15 of [4] and Items 10 and 11 of [5]. For now, it is enough to note that allocators are invoked to handle four events in an object's life cycle: memory allocation, object construction, object destruction, and memory deallocation. The methods that perform these tasks are shown in pseudocode below:<P><pre>class SecureAllocator{  pointer allocate(size_type num);  void deallocate(pointer pmem);  void construct(pointer pmem,       const value_type&amp; val);  void destroy(pointer pmem);}</pre>Following the example of the Loki library, the secure allocator will be built around orthogonal policies (see Chapter 1 of [6] for an introduction to policy-based design). Briefly, a policy defines an interface that abstracts a design choice or feature [7]. A policy class implements that interface in one particular way. A host class (template, usually) uses a policy class to accomplish a task without knowing how it is done.<P>Allocators themselves are a good example of a policy. The interface an allocator must provide is only described in design documents. A concrete allocator class implements that interface in one particular way. A host class such as <B>std::vector</B> uses an allocator to obtain memory without knowing the details. Changing the memory allocation behavior of <B>std::vector</B> is as easy as changing a template parameter.<P>Here, the allocator will be hosting policies. As already noted, a secure allocator should enforce two behaviors. First, it should wipe the contents of any memory it has allocated before returning it to the operating system. Second, it should prevent the memory it allocates from being paged out to disk by the virtual memory manager.<P>The first of these, wiping memory, makes a good candidate for a policy. For one, it is independent of an allocator's other tasks: the method of wiping memory has no effect on how to allocate memory or construct an object. Secondly, there are several good ways to wipe memory depending on the situation, including sometimes not at all.<P>Each concrete choice of a wiping method makes the allocator suitable for some applications but unsuitable for others. A policy is a good way to isolate this choice so the allocator can be used in a wide variety of applications.<P>The policy that determines how to wipe sensitive data from memory will be called <B>ScrubPolicy</B>. It will have a method, <B>doScrub</B>, that wipes the contents of a memory block passed to it.<P>The only remaining question is when to perform a scrub. The allocator provides two opportunities to do so: when an object is destructed or when its memory is deallocated. A conservative approach dictates that sensitive data be stored for as short a time as possible to minimize risk of compromise [8]. On the other hand, deallocations are much less frequent than destructions and can process the memory for multiple objects at one time. From an efficiency standpoint, memory should be scrubbed on deallocation.<P>Rather than arbitrarily choosing one or the other, <B>ScrubPolicy</B> will allow both methods. <B>SecureAllocator</B> will call two <B>ScrubPolicy</B> methods, <B>onDestroy</B> and <B>onDeallocate</B>, at the appropriate times instead of calling <B>doScrub</B> directly. Each <B>ScrubPolicy</B> class will choose when to perform a scrub by having one of these methods invoke <B>doScrub</B> and the other do nothing. Since <B>deallocate</B> should seldom be on the critical execution path of a program, <B>SecureAllocator</B> will default to a conservative <B>ScrubPolicy</B>.<P>In pseudocode, <B>SecureAllocator</B>'s use of <B>ScrubPolicy</B> will look like this:<P><pre>class SecureAllocator{  void destroy(pointer pmem)  {    call *pmem's destructor    ScrubPolicy::onDestroy(      pmem, size of *pmem);  }  void deallocate(pointer pmem)  {    ScrubPolicy::onDeallocate(      pmem, size of *pmem);    deallocate pmem  }}</pre>At first glance, whether to allow paging of sensitive memory to disk also appears suitable for a policy. There are at least two incompatible choices that make sense under certain conditions: disable paging or do nothing [9]. In fact, the first iteration of my design had a <B>SwapPolicy</B> class that handled all paging issues. But during implementation, I realized the allocation method and <B>SwapPolicy</B> interact quite a bit.<P>Most modern operating systems limit the amount of memory an unprivileged process can lock into RAM. Additionally, since the unit of swapping is a physical page, locking a memory block causes at least an entire page to be locked in place. As a result, all sensitive data should be allocated on separate pages from ordinary data. Otherwise, fragmentation (of sorts) will reduce the memory available for sensitive data.<P>This makes some allocation strategies, such as <B>malloc</B> and the global <B>new</B> operator, incompatible with a no-swap strategy. Allocation and swapping are not truly independent functions. Therefore I decided to use a single policy, <B>AllocPolicy</B>, which handles both the allocation and swap duties. <B>SecureAllocator</B> simply hands off memory requests to <B>AllocPolicy</B>, as the following pseudocode demonstrates:<P><pre>class SecureAllocator{  pointer allocate(size_type num)  {    return AllocPolicy::doAlloc(      num * size of object);  }  void deallocate(pointer pmem)  {    AllocPolicy::doFree(pmem);  }}</pre>Almost all of <B>SecureAllocator</B>'s functionality is now in place. The only remaining piece is thread safety. In keeping with the policy-based design, <B>SecureAllocator</B> will use a third policy, <B>LockPolicy</B>, to provide synchronization when appropriate.<P>The threading policies covered in [6] are much more general than needed here and only implemented on the Windows platform. However, the basics are the same. <B>LockPolicy</B> will define an internal class called <B>Lock</B>. At the beginning of any method that may require synchronization, <B>SecureAllocator</B> will create a <B>LockPolicy::Lock</B> local variable.<P>Thread-safe implementations of <B>LockPolicy</B> will lock a synchronization object (most likely a mutex) in <B>Lock</B>'s constructor and unlock it in the destructor, which will be called when the method terminates. Single-threaded implementations of <B>LockPolicy</B> will have an empty <B>Lock</B> class, which does nothing. The following pseudocode demonstrates the usage:<P><pre>void someMethod(args){  LockPolicy::Lock lock;  // method is now synchronized  // method body goes here  // lock is destroyed on return}</pre><B>SecureAllocator</b> will only use <B>LockPolicy</B> to synchronize two methods this way: <B>allocate</B> and <B>deallocate</B>. Thus <B>AllocPolicy</B>'s <B>doAlloc</B> and <B>doFree</B> methods will always be synchronized, as will <B>ScrubPolicy</B>'s <B>onDeallocate</B>. <B>SecureAllocator</B> itself uses no member, static, or global variables, so there is no need to synchronize any of its other code. This leaves only the code in <B>ScrubPolicy::onDestroy</B>.<P>The decision not to synchronize the <B>destroy</B> method, which calls <B>onDestroy</B>, is based on two factors. One, <B>ScrubPolicy</B> is not likely to contain or access any non-<B>const</B> variables. Its <B>doScrub</B> method simply overwrites the contents of sensitive memory. In many cases, scrubbing with a fixed byte such as zero (or not scrubbing at all) will suffice.<P>Two, the performance penalty of synchronizing <B>destroy</B> is significantly higher than synchronizing <B>allocate</B> and <B>deallocate</B>. <B>allocate</B> and <B>deallocate</B> can operate on memory for many objects per invocation, whereas <B>destroy</B> must be called once per object.<P>Vectors, for instance, commonly ensure that growing the container is an amortized constant-time operation by doubling storage when more room is needed. This means <B>allocate</B> will only be called (on average) <B>log(N)</B> times as the vector grows to size <B>N</B>. But <B>destroy</B> must be called at least <B>N</B> times, once for each object in the vector. Synchronizing every <B>destroy</B> is thus much more expensive than synchronizing every <B>allocate</B> and <B>deallocate</B>.<P>If a <B>ScrubPolicy</B> implementation does require synchronization for <B>onDestroy</B>, it can be done separately in that method itself.<P><h3>Implementation</h3><p>While the design was kept sufficiently generic to accommodate any application, an implementation must consider its target audience. The assumed scenario from here on out will be an application handling small amounts of sensitive data. That is, assume the program holds tens, at most hundreds, of passwords, cryptographic keys, or secret access tokens in memory at any one time.<P>I feel this scenario covers the vast majority of applications likely to benefit from the allocator. It encompasses software as diverse as instant messengers, web browsers, peer-to-peer clients, compression software, and office suites [10]. It can even support a PGP-type program, which was the initial motivation for the project. Applications for which this particular implementation may be unsuitable, such as high-volume e-commerce servers, can follow the approach herein to craft an implementation that fits their needs.<P><h3>SecureAllocator</h3><p> <B>SecureAllocator</b>'s implementation should be straightforward by now.   Like any allocator, <B>SecureAllocator</B> will be a template with a parameter   for the type of object being allocated. It will also have three other template   parameters for the three policies discussed: <B>AllocPolicy</B>, <B>ScrubPolicy</B>,   and <B>LockPolicy</B>. The relevant parts of <B>SecureAllocator</B> are shown   in <a href="cuj0305elliott_l1.htm">Listing 1</a>. <P>While Loki often uses templates as template parameters, <B>SecureAllocator</B>'s template parameters must be concrete classes. This is a concession made for widely used compilers that don't support template template parameters, such as Microsoft Visual C++.<P><B>SecureAllocator</B>'s usage of its <B>AllocPolicy</B> and <B>ScrubPolicy</B> requires some explanation. The C++ Standard says the semantics of two instances of the same allocator class that compare as non-equal are implementation-defined (Section 20.1.5). Basically this means cross-platform allocators can only have static variables.<P>This leaves several options for how <B>SecureAllocator</B> can use <B>AllocPolicy</B> and <B>ScrubPolicy</B>. Having <B>SecureAllocator</B> subclass these policy classes just pushes the problem off on them. Another inelegant, brute-force approach is to make the policy interface methods static. Both these solutions force the policy class to store all its variables statically as well.<P>A better approach is for <B>SecureAllocator</B> to define static variables of each policy class type, like <B>static AllocPolicy ap</B>, and call the policy methods through <B>ap</B>. The problem here is the order of dynamic initialization for variables in different translation units is undefined by the Standard. <B>SecureAllocator</B> may be called on to allocate memory at any phase of the program, including before <B>ap</B> is constructed [11].<P>To solve this, <B>SecureAllocator</B> can instead store a pointer, <B>static AllocPolicy *ap</B>. Because pointers are primitive types, their initialization is guaranteed during the loading phase, before any dynamic initialization occurs. A simple method to retrieve the object can test <B>ap</B> for null and construct a new <B>AllocPolicy</B> the first time:<P><pre>static AllocPolicy *ap = NULL;AllocPolicy&amp; getAllocPolicy(){  if (ap == NULL)  {    ap = new AllocPolicy();  }  return *ap;}</pre>There are still two remaining hurdles. First, recall that <B>SecureAllocator</B> is a template parameterized by the type of object it's allocating. <B>SecureAllocator&lt;char&gt;</B>, <B>SecureAllocator&lt;int&gt;</B>, and <B>SecureAllocator&lt;Foo&gt;</B> are all different classes, each with its own copy of the static <B>AllocPolicy</B> pointer. For most scenarios, all memory should be allocated from the same <B>AllocPolicy</B> object to reduce fragmentation.<P> To achieve this, an external class will store the <B>AllocPolicy</B> and <B>ScrubPolicy</B>   pointers. The <B>PolicyHolder</B> template in <a href="cuj0305elliott_l1.htm">Listing   1</a> provides this functionality. Any <B>SecureAllocator</B> class can retrieve   the same <B>AllocPolicy</B> pointer from <B>PolicyHolder</B>. <B>PolicyHolder</B>   is essentially a Singleton manager. Loki's <B>SingletonHolder</B> class does   the same thing more flexibly, but doesn't compile on nearly as many platforms. <P>Two down, one to go. The <B>getAllocPolicy</B> method shown above (now in <B>PolicyHolder</B>) is not thread-safe. <B>SecureAllocator</B> could synchronize before every call to <B>PolicyHolder</B>, but the <B>destroy</B> method needs to use <B>ScrubPolicy</B>. Synchronizing every <B>destroy</B> call was already deemed too expensive. Also, since <B>PolicyHolder</B> is generic enough to be useful outside <B>SecureAllocator</B>, it would be nice if <B>PolicyHolder</B> provided its own synchronization.<P><B>PolicyHolder</B> could take a <B>LockPolicy</B> template parameter for synchronization. Since <B>SecureAllocator</B> does not accept template template parameters, it would have no clean way to provide <B>PolicyHolder</B> with a <B>LockPolicy</B> class other than the one passed to it. But <B>SecureAllocator</B> and <B>PolicyHolder</B> can't use the same <B>LockPolicy</B> class because <B>SecureAllocator</B> sometimes locks that mutex before <B>PolicyHolder</B> is even called (as in the <B>SecureAllocator::allocate</B> method).<P>Instead, <B>PolicyHolder</B> will always use a multithreaded <B>LockPolicy</B> class of its own to implement the Double-Checked Locking pattern. This ensures <B>PolicyHolder</B> can be used in multithreaded contexts. Even single-threaded programs will incur the overhead for the mutex. However, since the mutex is only locked once, the first time <B>getPolicy</B> is called, the expense is negligible.<P><h3>ScrubPolicy</h3><p> <a href="cuj0305elliott_l2.htm">Listing 2</a> contains several classes implementing   <B>ScrubPolicy</B>. Most applications should use the <B>BasicScrubber</B> class   for scrubbing, which overwrites a memory block with the byte <B>0x00</B>. The   <B>NoScrubber</B> class doesn't perform any scrubbing at all; it is primarily   intended for systems in which the operating system zeros out memory pages as   they are released. <B>HeavyScrubber</B> overwrites memory multiple times with   complementary bit patterns. It is generally not considered any more effective   than <B>BasicScrubber</B> for wiping solid-state DRAM memory. However, other   memory types (SRAM, flash, etc.) with different electromagnetic properties may   benefit from <B>HeavyScrubber</B>. Those truly paranoid about data retention   may find it useful even with DRAM <P>These three classes only implement the <B>doScrub</B> method. The templates <B>ScrubOnDestroy</B> and <B>ScrubOnDeallocate</B> adapt them for use in <B>SecureAllocator</B>. Each passes one of the <B>onDestroy</B>/<B>onDeallocate</B> calls on to <B>doScrub</B> while ignoring the other. This separates the task of implementing a scrubber from deciding when it will be called.<P>The default <B>ScrubPolicy</B> for <B>SecureAllocator</B> is <B>ScrubOnDestroy&lt;BasicScrubber&gt;</B>.<P><h3>AllocPolicy</h3><p><B>AllocPolicy</b> proves a little trickier to implement. As already noted, an implementation that disables paging should make allocations from a contiguous region of virtual memory. The only way to obtain such a region with Standard C/C++ library functions is via <B>malloc</B> or <B>new</B>, which not only reserve a region of virtual memory but also allocate and commit it. In this case, <B>AllocPolicy</B> would have to acquire chunks of memory in page-sized increments and then break them into smaller chunks to satisfy <B>SecureAllocator</B>'s requests. In other words, this approach involves implementing another memory manager on top of <B>malloc</B> or <B>new</B>.<P>Fortunately, we can avoid this road by taking advantage of system-specific features. The Win32 virtual memory interface includes a set of heap functions. Windows heaps provide exactly the features <B>AllocPolicy</B> needs. A heap reserves a region of the virtual memory space for itself, but only commits pages when needed. As the heap grows, its virtual memory region may not remain contiguous, but fragments will at least be multiples of the page size. A heap also satisfies allocations of arbitrary size, handling the bookkeeping itself. In fact, <B>malloc</B> and <B>new</B> on Win32 are usually implemented on top of a heap object.<P> Win32 also provides functions to disable and enable swapping of memory pages:   <B>VirtualLock</B> and <B>VirtualUnlock</B>. Using these functions, implementing   <B>AllocPolicy</B> with no swapping becomes trivial. <a href="cuj0305elliott_l3.htm">Listing   3</a> shows a Win32 version of the class <B>NoSwapHeap</B>, which allocates   memory and prevents it being paged out to disk. <P><B>NoSwapHeap</B>'s constructor creates a new heap and retrieves the system page size. The <B>doAlloc</B> method requests <B>numBytes</B> of memory from the heap and locks any pages that the memory block straddles into place with <B>VirtualLock</B>. If the allocation or lock fails, it throws a <B>std::bad_alloc</B> exception, freeing the memory first when necessary. The <B>doFree</B> method unlocks pages that are empty (through the <B>removeBlock</B> call) and frees the memory.<P><B>VirtualLock</B> doesn't keep track of how many times it locks a page. If five memory blocks are allocated from one page, and <B>VirtualLock</B> is called five times, the first call to <B>VirtualUnlock</B> will unlock the entire page. Obviously the page cannot be unlocked until all five blocks are released and the page is empty.<P>The <B>PageTracker</B> class keeps track of the pages in use. The <B>addBlock</B> method, called on every allocation, stores the page index and increments an allocation count. When a block is freed, <B>removeBlock</B> decrements the counter and unlocks the page when it reaches zero. <B>PageTracker</B> can be subclassed by any <B>AllocPolicy</B> implementation for this purpose.<P>Data is stored in a vector sorted by page index for fast lookups. This adds <B>2 * sizeof(size_t)</B> memory overhead to each page in use (stored on a different page, though), which on a typical system with a four-byte <B>size_t</B> and 4 KB pages is negligible. Occasionally as new pages are used, the vector will be reallocated, but pages will usually be added at the end of the vector, amortizing the insertion cost down to a constant factor.<P><B>NoSwapHeap</B> defines no destructor and never releases its heap with <B>HeapDestroy</B>. This is a small but necessary resource leak, which the system cleans up on process termination. Because <B>SecureAllocator</B> can potentially be called to allocate memory at any time, there is no way to properly schedule the destruction of the <B>AllocPolicy</B> held by <B>PolicyHolder</B>. This is why <B>PolicyHolder</B> never deletes the <B>AllocPolicy</B> object it creates, and why <B>AllocPolicy</B> classes can't rely on being destructed.<P><B>NoSwapHeap</B> can be easily adapted to other systems that allow users to create their own heaps, like AIX. Linux, however, provides no memory interfaces akin to heaps. The only system calls for managing memory are low-level functions like <B>mmap</B> and <B>sbrk</B>. Even user-space libraries providing higher-level memory constructs are hard to come by. Thus a different approach is called for.<P>Fortunately, Doug Lea's excellent memory manager, sometimes called <B>dlmalloc</B>, provides a solution. Normally, <B>dlmalloc</B> is used as a drop-in replacement for <B>malloc</B>. However, it can optionally use different names for its own memory functions, so it may be used side-by-side with the system <B>malloc</B> implementation. In this mode, it effectively functions as a separate memory heap, obtaining raw pages of memory from the system, which it manages itself.<P> <B>NoSwapDLMalloc</B>, shown in <a href="cuj0305elliott_l4.htm">Listing 4</a>,   implements a no-swap allocation policy suitable for use on Linux (and many other   Unix systems). The <B>doAlloc</B> and <B>doFree</B> methods are sufficiently   like <B>NoSwapHeap</B>'s to warrant little discussion. The differences are that   <B>dlmalloc</B> and <B>dlfree</B> are called to allocate memory, and <B>mlock</B>   and <B>munlock</B> are used to disable and enable paging. <B>NoSwapDLMalloc</B>   also subclasses <B>PageTracker</B> to track allocations on each page. <P>A word of caution: <B>NoSwapDLMalloc</B> may not be suitable for some systems even though it compiles on them. For example, at least some versions of BSD require memory addresses passed to <B>mlock</B> and <B>munlock</B> to be multiples of the page size. Adapting the class for these systems should be trivial.<P><h3>LockPolicy</h3><p> <a href="cuj0305elliott_l5.htm">Listing 5</a> shows two implementations of   <B>LockPolicy</B>. The <B>MutexLocking</B> class provides a <B>Lock</B> inner   class suitable for synchronizing multiple threads. <B>MutexLocking</B> contains   a static mutex from the Boost library to provide cross-platform synchronization.   The template parameter <B>Target</B> only serves to create different <B>MutexLocking</B>   classes (with different mutexes) for different uses. <P>The <B>NoLocking</B> class defines an empty do-nothing inner <B>Lock</B> class. The template parameter <B>Target</B> only serves as a dummy parameter here to maintain similarity with <B>MutexLocking</B>.<P>The <B>VolatileType typedef</B> in both templates is used to add the <B>volatile</B> keyword to types in a multithreaded environment, while omitting it in single-threaded programs to allow for compiler optimizations.<P><h3>Usage</h3><p>Fortunately, using <B>SecureAllocator</B> is easy. Simply provide a <B>SecureAllocator</B> class as the allocator parameter to any STL container. <B>SecureAllocator</B>'s policy template parameters all have good defaults; most applications won't need to change them. Often a single line will suffice:<P><pre>typdef std::vector&lt;char,  SecureAllocator&lt;char&gt; &gt; SecureCharVector;</pre>Those with more advanced needs can choose from the predefined policy classes or define their own. Just make sure the <B>LockPolicy</B> passed to <B>SecureAllocator</B> is tied to <B>AllocPolicy</B>. Usage is still quite simple, if lengthy:<P><pre>typedef std::vector&lt;Foo, SecureAllocator&lt;Foo,  CustomAllocPolicy, ScrubOnDestroy&lt;CustomScrubber&gt;,  MutexLocking&lt;CustomAllocPolicy&gt; &gt; &gt; SecureFooVector;</pre>Other concerns involve how certain containers are implemented. Some versions of vector allocate large chunks (up to 2 KB) of memory unless <B>reserve</B> is called before inserting data (see page 149 in [4]). Obviously storing 16-byte cryptographic keys in such vectors can waste a lot of precious locked memory if not prevented.<P>Many <B>std::string</B> implementations employ small local buffers to avoid allocating small strings from the free store [5]. Such string objects may store all their data on the stack and never use their allocator. Unless you are certain your platform's string implementation does not do this, the <B>std::string</B> container is best avoided.<P><h3>Conclusion</h3><p>The <B>SecureAllocator</B> template can mitigate some of the easiest attacks on sensitive data stored in memory. By disabling paging, exploits that obtain data from the hard disk are prevented.  Overwriting data before releasing memory to the operating system precludes another process from obtaining the same memory block and reading the data.<P>However, there are still many ways to compromise such data. Sophisticated attacks described in [3] can retrieve overwritten data from solid-state memory even hours or days after the power is removed. Usually, compromise is even easier. On most systems, a process run as the same user ID or administrator (root) can view the contents of another process's memory. Also, next to nothing can be done in software to protect machines with poor physical security or untrustworthy administrators.<P>Likewise, it is important to remember that the security of a program depends on many more factors than just how well it protects sensitive data. Everything from choice of cryptographic algorithms and access control to race conditions and random number generation has the potential for security vulnerabilities. Two excellent books, [12] and [13], provide a good overview of security issues to keep in mind when building software. Of course, there is still no substitute for the trained eye of an experienced security developer.<P><h3>Notes</h3><p>[1]  This is the case under very common threat models in a multi-user environment.<P>[2]  This usually involves bypassing the file-system driver and accessing the disk directly.<P>[3]  The classic (and most comprehensive) treatment of problems with data storage is found in Peter Gutmann's "Secure Deletion of Data from Magnetic and Solid-State Memory," Sixth USENIX Security Symposium Proceedings, 1996. Available at &lt;www.cs.auckland.ac.nz/~pgut001/pubs/secure_del.html&gt;.<P>[4]  Nicolai M. Josuttis. <I>The C++ Standard Library: A Tutorial and Reference</I> (Addison-Wesley, 1999).<P>[5]  Scott Meyers. <I>Effective STL</I> (Addison-Wesley, 2001).<P>[6]  Andrei Alexandrescu. <I>Modern C++ Design</I> (Addison-Wesley, 2001).<P>[7]  Because policies are only design concepts, the interface definition never appears in code outside a concrete policy implementation.<P>[8]  As will be seen, memory is still open to other attacks besides the ones <B>SecureAllocator</B> aims to prevent. <P>[9]  Paging sensitive data is allowable on some systems, like those that encrypt their swap files.<P>[10]  This says nothing about the security of how passwords and keys are actually used in such applications.  Secure memory storage will do nothing to alleviate poor passwords or weak cryptographic algorithms.<P>[11]  Imagine a global variable of type <B>vector&lt;byte</B>, <B>SecureAllocator&gt;</B> declared in another translation unit.<P>[12]  John Viega and Gary McGraw. <I>Building Secure Software</I> (Addison-Wesley, 2002).<P>[13]  Michael Howard and David LeBlanc. <B>Writing Secure Code</B> (Microsoft Press, 2002).<p><h3>About the Author</h3><p>Edward Elliott has spent time as a software developer and college lecturer He may be reached at <B>secpub@eddeye.net</B>.<p> </BODY></HTML>