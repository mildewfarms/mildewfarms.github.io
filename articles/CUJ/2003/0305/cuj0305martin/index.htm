<HTML><HEAD><TITLE>Implicit Type Conversion Operator with a Good Piece of Pi</TITLE></HEAD><body bgcolor="#FFFFFF" text="000000"><h2>C/C++ Tip #16: Implicit Type Conversion Operator with a Good Piece of Pi</h2><h3>Curt L. Martin</h3><p>The software group I work for uses a typed-out approximation constant as the preferred method for expressing pi. Unfortunately, when you rely on a typed-out version of pi, the value of pi becomes susceptible to human error. A few months ago I accidentally typed the following:<P><pre>double const PI =  3.141926535897932384626433832795;  // wrong</pre>The brains who remember pi past the fourth decimal place will quickly see that this wrong. The correct approximation of pi is:<P><pre>double const PI =  3.1415926535897932384626433832795;  // correct</pre>I started looking for an efficient way to express pi without typing a long constant. When I programmed in FORTRAN, I specified pi through a snippet of code with the following C equivalent:<P><pre>double const PI = 2.0 * acos(0.0);</pre>However, forcing the computer to calculate pi through an arc cosine function is a little backward in light of the present-day emphasis on elegance and speed.<P>Several years ago when I was programming in Intel assembly language, I stumbled across the following opcode for the math coprocessor side of the Intel chip:<P><pre>fldpi;  load constant onto stack, pi ( 3.14159...)</pre>When I found this opcode, I was not using the math coprocessor side of the Intel chip, so I just placed the information in the back of my mind until recently.<P>Opcode <B>fldpi</B> pushes onto the x87 chip's stack the value constant pi, which is a 66-bit constant that is rounded to double extended-precision floating-point format (64 bit). This 66-bit value is two bits more than is allowed in a double extended-precision floating-point value. Thus the value guarantees no loss of significance in a source operand [1, 2]. Opcode <B>fldpi</B> has been on the math coprocessor since the days of the 387 chip.<P>With the above information, I derived the following function:<P><pre>// inline version is reduced to two OPCODESinline double PI(){  double x;  // memory location to pop too  __asm  {    fldpi;  // Push pi onto the FPU register stack    fstp x; // Copy ST(0) to m64 real and pop register stack  }  return x}</pre>This function provides an accurate and efficient means of expressing pi. However, being the lazy person that I am, I was not interested in replacing all instances of <B>PI</B> with a function call <B>PI()</B>. So I created the following class with a single method, which is an implicit type-conversion operator [3]. The class implicitly converts any instance of <B>struct CPi</B> into a <B>double</B> that has the value of pi.<P>Normally, I think that the implicit type-conversion operator is a dangerous tool that should not be used, but, in this case, I believe I have found an exception, where not using an implicit type-conversion operator would have made it more difficult to read the code.<P><pre>struct CPi{  // Conversion operator  operator double () const  {    double x;     // memory location to store to    __asm fldpi;  // Load constant onto stack, pi (3.14159...)    __asm fst x;  // Floating point store    return x;     // must have a return value  }};static Cpi PI;</pre>With the preceding code, I can use the instance of my <B>Cpi struct</B> in the following way:<P><pre>// Calculate the area of a circledouble Area = PI * radius * radius;</pre>When you look at the assembly language produced by the preceding line, the call to the instance of <B>PI</B> is reduced to two opcodes.<P>This class is only for use with Microsoft Visual C++ v6.0. With a few modifications, you could create a version of the class for other compilers that work on the Intel processor.<P>Using this class, I have secretly replaced the old way of using constant <B>double</B> with an instantiated object with the same name, and no one knows the difference (that is, until they read this article).<P><h3>Notes</h3><p>[1]  The <I>IA-32 Intel Architecture Software Developer's Manual Volume 1: Basic Architecture</I>, pp. 8-26, &lt;http://developer.intel.com/&gt;.<P>[2]  <I>The IA-32 Intel Architecture Software Developer's Manual, Volume 2: Instruction Set Reference</I>, pp. 3-242.<P>[3]  Scott Meyers. <I>More Effective C++</I> (Addison-Wesley, 1995).<p><h3>About the Author</h3><p>Curt L. Martin holds a B.S. in Aerospace Engineering from the University of Texas at Arlington. Currently he is a software developer in the Las Vegas, NV area. His former employers include Lockheed-Martin at Johnson Space Center and Hughes Aircraft. In his spare time, he is a US Army Reserve Officer and enjoys hiking in the Southern Nevada area.<p></BODY></HTML>