<HTML><HEAD><TITLE>Floating-Point Math: In the Intersection of C and C++</TITLE></HEAD><body bgcolor="#FFFFFF" text="000000"><h2>The New C: Floating-Point Math: In the Intersection of C and C++</h2><h3>Randy Meyers and Dr. Thomas Plum</h3><i>Type-generic math for everyone.</i><P>In our March column, we presented the new complex arithmetic feature of C99 and introduced a small <B>include</B> file that we wrote, <B>math-complex.h</B>, that permits common source using complex arithmetic to be written in the intersection of C99 and C++. Perhaps the most amazing thing about <B>math-complex.h</B> is how only a few lines of code in that file can resolve the differences between C99's built-in complex data type and C++'s class library-based <B>complex</B>.<P> However, the usefulness of <B>math-complex.h</B> (see <a href="cuj0305myers_l1.htm">Listing   1</a>) extends beyond complex arithmetic. As you might guess from the header's   name, C programmers can think of <B>math-complex.h</B> as a shorthand for including   both of the two standard headers <B>&lt;math.h&gt;</B> and <B>&lt;complex.h&gt;</B>,   while C++ programmers can view it as a shorthand for including both <B>&lt;cmath&gt;</B>   and <B>&lt;complex&gt;</B>. In addition, <B>math-complex.h</B> also resolves   most of the differences in floating-point math between C and C++ and thus permits   both C99 and C++ programmers to write common source in the intersection of the   two languages. The March column discussed this intersection with respect to   complex arithmetic. This column discusses the intersection with respect to real   number arithmetic. <P><h3>&lt;tgmath.h&gt;</h3><p>Before discussing the features of the intersection, it is useful to look at a new C99 feature that is used by <B>math-complex.h</B> in order to provide to C programmers one of the useful features in the C++ floating-point library.<P>When the C++ committee created the <B>&lt;cmath&gt;</B> header from the C language header <B>&lt;math.h&gt;</B>, it added <B>float</B> and <B>long</B> <B>double</B> overloads for the math functions operating on <B>double</B>s. This allowed the math functions to return the same type of result as their argument. For example, if you call <B>sqrt()</B> with a <B>float</B>, <B>double</B>, or <B>long</B> <B>double</B> argument, a <B>float</B>, <B>double</B>, or <B>long</B> <B>double</B> result respectively will be calculated and returned.<P>Having only one name for a library function independent of the argument types is a useful feature that has been used by FORTRAN programmers for over two decades. It has two primary advantages:<P>1.  Convenience: programmers only need remember one name for any math function.<P>2.  Flexibility: occasionally, numerical programmers must change the type of their floating-point data. For example, when porting to a new system, <B>float</B> variables might need to become <B>double</B> since <B>float</B> on the new system does not have the required precision. Also, sometimes the easiest way to discover whether <B>float</B> has enough precision for a calculation is to convert the program to <B>double</B> to see if it produces the same results. If the library functions have the same name regardless of their argument types, then there are fewer places in the program that need to be edited if a data type is changed.<P>C99 did not add a general-purpose overloading feature that allows programmers to write their own overloaded functions. It did however add a new header file, <B>&lt;tgmath.h&gt;</B>, that defines macros that act like the overloaded math functions in C++. These "type-generic" macros inspect the types of their arguments and call the appropriate library function to handle arguments of those types. For example, the type generic macro <B>sqrt()</B> when passed an argument of type <B>float</B>, <B>double</B>, <B>long</B> <B>double</B>, <B>float</B> <B>complex</B>, <B>double</B> <B>complex</B>, or <B>long</B> <B>double</B> <B>complex</B> calls the functions <B>sqrtf</B>, <B>sqrt</B>, <B>sqrtl</B>, <B>csqrtf</B>, <B>csqrt</B>, and <B>csqrtl</B>, respectively. While C99 requires implementations to implement the macros, it does not tell the implementations how to do so. Most implementations will probably invent special-purpose, private extensions to support <B>&lt;tgmath.h&gt;</B>.<P>When compiled by C99, <B>math-complex.h</B> includes <B>&lt;tgmath.h&gt;</B> so that both C and C++ programmers can use overloaded functions when using the math library. (When discussing the intersection of C99 and C++, we will use the terms "function" and "overloaded function" uniformly rather than dwell on the C99 implementation detail that the "functions" are really macros that achieve their ends without a general-purpose overloading mechanism in the language.)<P><h3>What Features Are Provided in the Intersection?</h3><p>Both C and C++ provide the usual arithmetic operators: plus, minus, times, divide, unary-plus, and unary-minus, on the <B>float</B>, <B>double</B>, and <B>long</B> <B>double</B> types. Both provide the corresponding assignment-operators (<B>+=</B>, <B>-=</B>, <B>*=</B>, and <B>/=</B>), as well as ordinary assignment (<B>=</B>). Equality (<B>==</B>), inequality (<B>!=</B>), less-than (<B>&lt;</B>), less-or-equal (<B>&lt;=</B>), greater-than (<B>&gt;</B>), and greater-or-equal (<B>&gt;=</B>) are provided in each language.<P>Since the three floating types are built-in (in C90, C99, and C++), all these operators accept one operand of one floating type mixed with an operand of any floating or integral type.<P>Both C and C++ provide the floating-point trigonometric and hyperbolic functions (i.e., <B>sin</B>, <B>cos</B>, <B>tan</B>, <B>sinh</B>, <B>cosh</B>, and <B>tanh</B>) and the corresponding inverse trig functions (<B>asin</B>, <B>acos</B>, <B>atan</B>, and <B>atan2</B>), but C++ does not (yet) provide the inverse hyperbolic functions (<B>asinh</B>, <B>acosh</B>, and <B>atanh</B>). The most common math functions are provided by C90, C99, and C++ (i.e., <B>abs</B>, <B>ceil</B>, <B>exp</B>, <B>exp2</B>, <B>fabs</B>, <B>floor</B>, <B>fmod</B>, <B>frexp</B>, <B>ldexp</B>, <B>log</B>, <B>log10</B>, <B>pow</B>, and <B>sqrt</B>). The type of the result is the same floating-point type as the operand.<P><h3>What Does C++ provide, above the Intersection Features?</h3><p>We turn now from our discussion of the C/C++ intersection to consider what is left out when you use the intersection. There is one C++ feature not provided in C99, namely the same-name overloads of <B>modf</B>:<P><pre>float modf(float, float *);double modf(double, double *);long double modf(long double,  long double *);</pre>In C99, the <B>float</B> and <B>long</B> <B>double</B> versions are available only by the names <B>modff</B> and <B>modfl</B>, respectively. Therefore, to permit working in the biggest intersection of C++ and C99, our <B>math-complex.h</B> header must provide two overloads for the <B>__cplusplus</B> version:<P><pre>inline float modff  (float xf, float *pxf) {    return modf(xf, pxf);  }inline long double modfl  (long double xl, long double *pxl) {    return modf(xl, pxl);  }</pre>To work in the intersection, after including <B>math-complex.h</B>, you must use the name <B>modff</B>, <B>modf</B>, or <B>modfl</B> appropriately; because of the pointer argument, the compiler will diagnose any lapses in your code.<P><h3>What Does C99 Provide, above the Intersection Features?</h3><p>There are many additional functions in the C99 library, above the library C90 and C++. Here we will list all the <B>double</B> versions; each returns <B>double</B>, unless indicated otherwise; <B>x</B> and <B>y</B> are <B>double</B>, <B>n</B> is <B>int</B>, and <B>ln</B> is <B>long</B> <B>int</B>. The C99 "type-generic math" header also provides <B>float</B> and <B>long</B> <B>double</B> versions with the same name.<P><ul><li>  <B>expm1(x)</B> returns <B>e^x- 1</B> (where <B>e^x</B> means "<B>e</B> to the power <B>x</B>").<li>  <B>ilogb(x)</B> returns (as <B>int</B>) the exponent of <B>x</B> as a signed <B>int</B> value.<li>  <B>log1p(x)</B> returns the base-<B>e</B> logarithm of <B>(x+1)</B>.<li>  <B>log2(x)</B> returns the base-<B>2</B> logarithm of <B>x</B>.<li>  <B>logb(x)</B> returns the exponent of <B>x</B> as a signed floating-point value.<li>  <B>scalbn(x, n)</B> and <B>scalbln(x, ln)</B> return <B>x</B> times <B>FLT_RADIX^n</B>.<li>  <B>cbrt(x)</B> returns the real cube root of <B>x</B>.<li>  <B>hypot(x, y)</B> returns the square root of the sum of the squares of <B>x</B> and <B>y</B>.<li>  <B>erf(x)</B> returns the error function of <B>x</B>.<li>  <B>erfc(x)</B> returns the complementary error function of <B>x</B> (i.e., one minus <B>erf(x)</B>).<li>  <B>lgamma(x)</B> returns the natural logarithm of the absolute value of <B>gamma</B> of <B>x</B>.<li>  <B>tgamma(x)</B> returns <B>gamma</B> of <B>x</B>.<li>  <B>nearbyint(x)</B> returns the rounded integer value of <B>x</B>, in the current rounding mode, without raising the "inexact" floating-point exception.<li>  <B>rint(x)</B> returns the rounded integer value of <B>x</B>, in the current rounding mode, possibly raising the "inexact" floating-point exception.<li>  <B>lrint(x)</B> returns (as <B>long</B> <B>int</B>) the rounded integer value of <B>x</B>, in the current rounding mode. (A <B>long</B> <B>long</B> <B>int</B> version is available in C99, but not in Standard C++.)<li>  <B>round(x)</B> returns the rounded integer value of <B>x</B>, rounding halfway cases away from zero regardless of the current rounding mode.<li>  <B>lround(x)</B> returns (as <B>long</B> <B>int</B>) the rounded integer value of <B>x</B>, rounding halfway cases away from zero regardless of the current rounding mode. (A <B>long</B> <B>long</B> <B>int</B> version is available in C99, but not in Standard C++.)<li>  <B>trunc(x)</B> returns the value of <B>x</B> truncated (towards zero) to the nearest integer.<li>  <B>remainder(x, y)</B> returns the remainder <B>x-n*y</B>, where <B>n</B> is the integer nearest the exact value of <B>x/y</B> (if <B>|x-n*y|</B> equals <B>1/2</B>, then <B>n</B> is even) as required by IEC 60559.<li>  <B>remquo(x, y, int *quo)</B> returns <B>remainder(x, y)</B> and stores into <B>*quo</B> a value whose sign is the sign of <B>x/y</B> and whose magnitude is congruent modulo <B>2*n</B> to the magnitude of the integral quotient of <B>x/y</B>, where <B>n</B> is an implementation-defined integer greater than or equal to <B>3</B>.<li>  <B>copysign(x, y)</B> returns a value with the magnitude of <B>x</B> and the sign of <B>y</B>.<li>  <B>nextafter(x, y)</B> returns the next representable value after <B>x</B> in the direction of <B>y</B>.<li>  <B>nexttoward(x, long double y)</B> returns the next representable value after <B>x</B> in the direction of <B>y.</B><li>  <B>fdim(x, y)</b> returns <B>x-y</B> if <B>x&gt;y</B>, otherwise returns <B>+0</B>.<li>  <B>fmax(x, y)</B> returns the maximum of <B>x</B> and <B>y</B>.<li>  <B>fmin(x, y)</B> returns the minimum of <B>x</B> and <B>y</B>.</ul>In our opinion, all of the functions listed here could appropriately be included in your own <B>math-complex.h</B> compatibility header and used in any application that you want to write in the intersection of C and C++. They are likely to be added to the next revision of C++ and may already be available as extensions in some C++ libraries. As we commented in March, if your environment provides both C++ and C99 libraries, a wrapper written in C++ could trivially provide these functions to your C++ applications. Alternatively, some of these functions are already available in Unix or POSIX libraries.<P><h3>Cost/Benefit of Working in the Intersection</h3><p>We have avoided discussion of the special features and behaviors specifically provided by C99 for the boundary cases of IEEE (or "IEC 559") floating-point arithmetic, including NaNs, infinities, signed zeroes, rounding modes, floating-point exceptions, and the functions and macros that manipulate these features. We also avoided discussion of fused-multiply-add and <B>long</B> <B>long</B> integers. If any of these are important to your work, then C99 is clearly your choice, and there would be little value to working in the intersection. Otherwise, we recommend the use of the "intersection" style for your arithmetic applications. As we mentioned in March, in some environments, the C99 implementation will produce faster code execution. On the other hand, there will be environments with no C99 implementation. And a C++ implementation with "small-object" optimization can be as fast as C99. In any event, the application that is written in the "intersection" style can be compiled as C++ or compiled as C99, whichever works best for each environment.<P><h3>Example Program</h3><p> <a href="cuj0305myers_l1.htm">Listing 1</a> shows the <B>math-complex.h</B>   header. <a href="cuj0305myers_l2.htm">Listing 2</a> is a short example program   that illustrates that the result type of an overloaded function call depends   on the argument type used in the call. <a href="cuj0305myers_l3.htm">Listing   3</a> shows sample output from running the program. <P>The <I>CUJ</I> website (&lt;www.cuj.com/code&gt;) contains an expanded version of the test program plus an updated version of the complex arithmetic test from the March column.<p><h3>About the Authors</h3><p>Randy Meyers is a consultant providing training and mentoring in C, C++, and Java. He is the current chair of J11, the ANSI C committee, and previously was a member of J16 (ANSI C++) and the ISO Java Study Group. He worked on compilers for Digital Equipment Corporation for 16 years and was Project Architect for DEC C and C++. He can be reached at <B>rmeyers@ix.netcom.com</B>.<P>Dr. Thomas Plum has authored four books on C, and co-authored <I>Efficient C</I> (with Jim Brodie) and <I>C++ Programming Guidelines</I> (with Daniel Saks). He has been an officer of the United States and international C and C++ standards committees. His company Plum Hall Inc. provides test suites for C, C++, Java, and C#. His address is <B>tplum@plumhall.com</B>.<p></BODY></HTML>