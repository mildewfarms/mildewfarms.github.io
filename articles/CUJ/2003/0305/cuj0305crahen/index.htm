<HTML><HEAD><TITLE>Efficient Thread Coordination</TITLE></HEAD><body bgcolor="#FFFFFF" text="000000"><h2 align="center"> </h2><h2>The Guard Idiom: Enhancing the Scoped Locking Idiom</h2><h3>Eric D. Crahen</h3><p><i>More flexible locks for your multithreaded programs.</i><p> <P><h3>Introduction</h3><p> The Scoped Locking Idiom ensures that a resource, typically a lock such as   a mutex or some other synchronization primitive, is acquired and held for the   duration of the scope of a block of code and is automatically released when   that scope ends. The Scoped Locking Idiom makes use of the RAII (resource acquisition   is initialization) concept. When a block of code begins, an object, commonly   referred to as a <I>guard</I> or <I>sentry</I>, is constructed and attempts   to acquire a resource. This marks the beginning of the locking scope. When that   object goes out of scope, it is destroyed, releasing the resource it previously   held and ending the locking scope.<P> <pre>// A simple Scoped Locktemaplte &lt;typename LOCK&gt;class ScopedLock {  LOCK&amp; _lock;public:  ScopedLock(LOCK&amp; lock) : _lock(lock) {    _lock.acquire();  }  ~ScopedLock() {    _lock.release();  }};</pre>This is a very simple and effective technique that can increase the safety and robustness of code that must be synchronized by eliminating programmer errors. By placing a sentry object in some block of code, a locking scope can be defined that will match the scope of that sentry object's lifetime. A good deal of effort can be eliminated; a programmer no longer needs to ensure the lock is released at each point control may leave the block. This task can be quite tedious, especially when considering code where exceptions may be thrown with that block. Eliminating the effort involved in writing and maintaining this code is very desirable.<P> The Scoped Locking Idiom is limited only in that it is designed for use with   simple locking scopes that are locked with the lifetime of a sentry object.   The Guard Idiom extends the Scoped Locking concept by introducing a means to   control the extent of the locking scope so that it is not so closely bound to   that single object's lifetime.<P><h3>The Guard Idiom</h3><p> The Guard Idiom is fundamentally very similar to the Scoped Locking Idiom.   However, they differ in one important aspect. Scoped locks (objects employing   the Scoped Locking Idiom) are designed to work independently, which is all that   is required when dealing with a simple locking scope. Guards (objects employing   the Guard Idiom), on the other hand, are designed to cooperate with one another,   which introduces some flexibility and makes some new locking behaviors possible.   By allowing guards to interact, locking scopes can now be defined that do not   necessarily begin and end with the creation and destruction of a single object.<P> The Guard Idiom can help improve the robustness and eliminate programmer error   for the following kinds of locking scopes.<P> <ul>  <li> Simple/block scopes: this is the classic Scoped Locking behavior in which     a locking scope begins with the construction of a sentry object and ends when     that object goes out of scope. This is useful for protecting a block of code.   <li> Nested scopes: this allows an outer locking scope to be defined that acts     somewhat like a simple or block scope. The locking scope begins when the outer     sentry object is created and ends when that same outer sentry is destroyed.     The block defined by this sentry's lifetime may contain one or more inner     sentry objects that define temporary openings in the locking scope to be created.     The lock held by the outer sentry is temporarily released when an inner sentry     is constructed and reacquired when the inner sentry is destroyed.   <li> Overlapped scopes: this is useful where techniques such as lock chaining     (acquiring a second lock and then releasing the first) are used. For instance,     a strategy commonly employed to reduce contention and increase the aliveness     of threads dealing with a large data structure is to use multiple locks. By     chaining locks together, serialization can be maintained for a single operation,     while several threads operate on different areas of the shared object by spreading     the contention over several locks.   <li> Transferable scopes: transferring scopes allows a sentry to be created     in one block of code, marking the beginning of a locking scope, and then transferring     that locking scope to another sentry outside the block of code where the original     sentry object lived. This can be very convenient for tasks such as creating     proxy classes that serialize access to an entire object.</ul><h3>Designing the Guard Idiom</h3><p> The implementation of a guard consists of four elements:<P> 1. A <B>Lockable</B> object: an object with <B>acquire</B>/<B>release</B>   semantics that provides an abstraction for the real locking mechanism, typically   a <B>Mutex</B>.<P> 2. A sentry: denotes a scope by its lifetime. However this scope does not   define the locking scope as it does with the Scoped Locking Idiom. Rather, it   holds a reference to <B>Lockable</B> object that will be operated on and presents   a simple interface for the user.<P> 3. The <B>LockHolder</B> object: maintains and shares any state that is associated   with a <B>Lockable</B> object. This can be thought of as a stateful wrapper   for a <B>Lockable</B> object.<P> 4. The locking policy: specifies the details of how a sentry will act, or   how it will interact with another sentry. This involves encapsulating the details   of determining when to invoke the <B>Lockable</B> object's <B>acquire</B>   or <B>release</B> methods, as well as any other state change that might be appropriate.<P><h3>Implementing the Guard Idiom</h3><p> Most implementations of the Scoped Locking Idiom are realized as a template   that provides a very simple and convenient syntax. One goal in implementing   a guard is produce a template that maintains the simple, easy-to-use syntax   that will provide the power to introduce the additional kinds of flexibility   in creating and using locking scopes.<P> The implementation described in this article lets you define <B>Lockable</B>   objects as they are normally defined in the Scoped Locking Idiom. The <B>Lockable</B>   objects used throughout this article follow a simple <B>acquire</B>/<B>release</B>   protocol and conform to the following interface.<P> <pre>class Lockable {public:  virtual ~Lockable() {}  virtual void acquire() = 0;  virtual void release() = 0; };</pre>Some variants may elect to use a non-virtual interface instead.<P> State is maintained by an instance of the <B>LockHolder</B> class. This class   wraps a <B>Lockable</B> object, adding a small amount of state information and   a few functions that work with that information.<P> <pre>template &lt;class LockType&gt;class LockHolder {  LockType &amp;_lock;  bool _enabled; public:  template &lt;class T&gt;  LockHolder(T&amp; t) :    _lock(extract(t)._lock), _enabled(true) { }  LockHolder(LockHolder&amp; holder) :    _lock(holder._lock), _enabled(true) { }  LockHolder(LockType&amp; lock) :    _lock(lock), _enabled(true) { }  ~LockHolder() throw() {}  void disable() { _enabled = false; }  bool isDisabled() { return !_enabled; }  LockType&amp; getLock() { return _lock; } protected:  template &lt;class T&gt;  static LockHolder&amp; extract(T&amp; t) {    return static_cast&lt;LockHolder&amp;&gt;(t);  }};</pre>Locking policies are the most complicated portion of the implementation. The locking policies, implemented as classes with static template member functions for compatibility with older compilers, define four functions.<P> <pre>// Signatures of a locking policies functionstemplate &lt;class LockType&gt;createScope(LockHolder&lt;LockType&gt;&amp; l);template &lt;class LockType&gt;destroyScope(LockHolder&lt;LockType&gt;&amp; l);template &lt;class LockType1, class LockType2&gt;shareScope(LockHolder&lt;LockType1&gt;&amp; l1,  LockHolder&lt;LockType2&gt;&amp; l2);template &lt;class LockType1, class LockType2&gt;transferScope(LockHolder&lt;LockType1&gt;&amp; l1,  LockHolder&lt;LockType2&gt;&amp; l2);</pre>These functions will be delegated to by the sentry, which is realized by the Guard template, at the appropriate times, as determined by syntax. Syntax will provide important clues to the sentry regarding when it is appropriate to take action. For instance, a guard that is created using a <B>Lockable</B> object as its only parameter is a clue that a new basic locking scope is being created, and <B>createScope</B> is delegated to in the policy. Creating a guard via a copy constructor is a clue that an existing locking scope is about to be shared with, and possibly modified by, another guard.<P> Creating a policy that provides the classic Scoped Locking behavior is very   straightforward.<P> <pre>class ClassicScope {public:  template &lt;class LockType&gt;  static void createScope    (LockHolder&lt;LockType&gt;&amp; l) {    l.getLockable().acquire();  }  template &lt;class LockType&gt;  static void destroyScope    (LockHolder&lt;LockType&gt;&amp; l) {    l.getLockable().release();  }};</pre>You can create a Guard template that preserves the desired syntax by extending the <B>LockHolder</B> class and delegating to the policy class, as shown in <a href="cuj0305crahen_l1.htm">Listing 1</a>. <a href="cuj0305crahen_l2.htm">Listing 2</a> shows some examples of the Guard Idiom in use. <P><h3>An Example</h3><p> The <B>GuardedObject</B> template attached illustrates a simple application   of the ideas described in this article. The <B>GuardObject</B> template is intended   not as a full smart pointer but rather as a wrapper for a single object. This   simple demonstration shows how one might apply the Guard idiom to create locking   proxies. This notion could be taken further and used to implement a full smart   pointer with locking proxies. However, the focus here is on how the locking   proxies would work out and not on the details of reference counting, assignment   operators, and all the other things you'd find in a real smart pointer.<P><h3>Conclusion</h3><p> The Guard Idiom adds a small level of indirection to the Scoped Locking Idiom   and in doing so achieves an enormous amount of flexibility in controlling the   extent of the locking scope. A complete implementation is available electronically,   for free, as a part of the ZThreads library (&lt;http://zthread.sourceforge.net&gt;).<P><h3>References</h3><p> [1] Douglas C. Schmidt. "Strategized Locking, Thread-safe Decorator,   and Scoped Locking: Patterns and Idioms for Simplifying Multithreaded C++ Components,"   <I>C++ Report</I>, September 1999.<P> [2] Bjarne Stroustrup. <I>The C++ Programming Language</I>, 3rd Edition (Addison-Wesley,   1998).<P><h3>About the Author</h3><p>Eric D. Crahen is a software developer for IBM. He can be reached   at <B>crahen@code-foo.com</B>.<p> </BODY></HTML>