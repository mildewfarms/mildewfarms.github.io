<HTML>   
     <HEAD>
<TITLE>September 2002 C++ .NET Solutions/Standard C++ Meets Managed C++</TITLE></HEAD>
<BODY BACKGROUND="" BGCOLOR="#FFFFFF" TEXT="#000000">
<H2><A HREF="../toccnet.htm"></A><FONT COLOR="#FF0000">   C++ .NET Solutions</FONT></H2>

<HR>

<H2 ALIGN="center"><FONT COLOR="#800000">Standard C++ Meets Managed C++</FONT></H2>
<H3 ALIGN="center"><FONT COLOR="#800000">Herb Sutter</FONT></H3>

<BLOCKQUOTE>
<p>Managed C++: as small a superset of Standard C++ as possible, but no smaller.</p>
</BLOCKQUOTE>

<HR>
<BLOCKQUOTE>
<p>These are exciting times for C++ no matter where you look. In this article, I&#146;ll focus on giving an overview of two overlapping and hopefully converging paths:</p>
<UL><LI>   The roadmap for Standard C++.</LI>
<LI>   The roadmap for C++ within Microsoft and with .NET.</LI></UL>

<p>In particular, this article surveys some of the major points of compatibility and incompatibility between Standard C++ and Microsoft&#146;s managed extensions for C++ (a.k.a. Managed C++), and how the two are planned to converge in the future.</p>

<H3><FONT COLOR="#000080">Standard C++</FONT></H3>

<p>The first C++ Standard was published in 1998; it&#146;s also known as C++98. Work is now just getting underway for Standard C++&#146;s next revision, which will be complete sometime this decade and so is being referred to as C++0x, where the &#147;x&#148; will be filled in later.</p>
<p>In other articles, I and other writers have given an overview of where Standard C++ is today and where it&#146;s going in the near and medium-term future; see <a href="#1">[1]</a> for Matt Austern&#146;s introduction, and <a href="#2">[2]</a>, <a href="#3">[3]</a>, and <a href="#4">[4]</a> for my own overviews of the state of the union and the C++ standardization process&#146;s organization, history, and next steps. <a href="fig1.htm">Figure 1</a> reproduces a figure from <a href="#3">[3]</a> that outlines the standards process and the major efforts under way that can or will influence the development of C++0x. See <a href="#3">[3]</a> for more details about the committees and other entities in that figure that I don&#146;t discuss again here.</p>
<p>Without rehashing that earlier material, there are several general trends or interests worth noting. The following areas are of particular interest to the standards committee as we work toward C++0x:</p>
<UL><LI>   <I>Threading (and other concurrent programming support).</I> Standard C++ today is notoriously silent on the subject of threads. That&#146;s just odd in a world where it&#146;s common to write multithreaded systems, and where other languages and pretty much all major operating system environments do provide explicit concurrency support. Threading and concurrency is therefore a specific area where C++0x is likely to adopt a solution that acknowledges threads in the C++ language and library and sets out the guaranteed semantics and effects you should be able to portably rely on.</LI>
<LI>   <I>Running on a virtual machine.</I> A commonly-asked question about Standard C++ is, &#147;Can I compile C++ to run on the JVM?&#148; As managed virtual-machine environments grow in popularity and become a more common platform target that real programmers are writing real code for, it&#146;s important that the next version of Standard C++ have something to say about managed environments so that C++ continues to be a first-class language for all platforms.</LI>
<LI>   <I>Distributed and network programming.</I> In Standard C++ right now, there&#146;s no notion of proxy objects, marshalling, network streams, or anything like that. That&#146;s a little dated, because modern programs do a lot of those things these days, especially in the most quickly growing categories of software development. The people working on C++0x are specifically interested in finding ways to better support such facilities in a standard and portable way.</LI>
<LI>   <I>Garbage collection.</I> Today&#146;s Standard C++ says nothing about GC (garbage collection). You can create an add-on GC library for C++ and design it to be intrusive or non-intrusive, and you can define extended semantics for running C++ in your own GC-enabled environment, but neither of those is truly satisfying because neither gives the same level of portable support as in-language GC support. Here are two particular examples:</LI>
<OL><LI>Many GC environments use nondeterministic destruction, possibly with some notion of finalization separate from memory reclamation. This means that, unlike normal C++, you can&#146;t tell when objects will actually be destroyed and their memory deleted and that those events might or might not happen at the same time on a particular system.</LI>
<LI>Some GC environments use compacting garbage collectors, which can be problematic because C++ programs generally don&#146;t expect objects to shift around in memory on their own. (Think about what happens to pointers to those objects.) Conservative garbage collectors do not require the ability to move objects.</LI></OL>
</UL>
<p>Dealing with GC is also of interest in C++0x. The GC issue also touches on other things under way in the standards world, such as the C++ community&#146;s recurring interest in adding to Standard C++ a new concept called a <I>move constructor</I>, a kind of copy constructor that knows that the source object will immediately cease to exist. The concept of move constructors happens to fit well with compacting garbage collectors, which move objects around in just such a way.</p>
<p>There are other areas of interest in C++0x, but those are several of the larger ones.</p>

<H3><FONT COLOR="#000080">C++ at Microsoft</FONT></H3>
<p>Microsoft has a large investment in the C++ language. Virtually all Microsoft products are written in C++: that includes all flavors of Windows, Internet Explorer, Office, FrontPage, Exchange, SQL Server, the games and sims, Visual Studio itself (including the C# compiler and other languages, and excluding only some parts such as the Base Class Libraries that ship with the .NET framework which were written in C#) &#151; pretty much the whole shooting match. Does Microsoft care about C++? They clearly do, and they equally clearly need to continue to care, because of their heavy vested interest in C++ code.</p>
<p>For years, C++ has been central to Microsoft, but regrettably Standard C++ has not.</p>
<p>Microsoft may use C++ a lot, but for some years now it hasn&#146;t had a great reputation for standards conformance in the C++ world. For much of the 1990s, they&#146;ve been a laggard, haven&#146;t cared much about implementing the Standard, and didn&#146;t even show up at our standards meetings. Things started changing a couple of years ago; now for the past two years or so they&#146;ve resumed active attendance and are contributing at standards meetings, and finally there&#146;s some real product evidence in the pipeline that conformance to the C++ Standard is important at Microsoft.</p>
<p>But you can soon judge for yourself: a lot of catch-up work has been done in the past year, to the point where the version of Visual C++ currently under development (which should be in beta by the time you read this) is one of the most standards-compliant C++ compilers running today on any platform. It&#146;s hard to overstate just how big a turnaround that is &#151; sadly overdue, but welcome nonetheless given the large number of people who use the Visual C++ compiler and the influence it has well beyond the Windows world, as many of the world&#146;s C++ programs that target non-Windows environments target Windows too.</p>
<p>The other Big Thing happening at Microsoft is the .NET platform. Given .NET&#146;s importance at Microsoft, it&#146;s clearly in everyone&#146;s best interests that C++ work well on that virtual-machine managed platform. But hey, .NET defines a lot of platform facilities &#151; ones that are accessible via object-oriented, not just procedural, access to a common framework through a CLR (Common Language Runtime).</p>
<p>And, interestingly enough, .NET happens to provide support for, among other things, all of the points mentioned in the previous section as large areas of interest for C++0x:</p>
<UL><LI>   <I>Threading (and other concurrent programming support).</I> The CLR provides a common threading model and support for locking and other primitives necessary for robust concurrent programming.</LI>
<LI>   <I>Running on a virtual machine.</I> A key idea of .NET is to abstract the OS platform, as Windows already abstracts the hardware platform. In particular, code runs in a virtual machine in a managed environment.</LI>
<LI>   <I>Distributed and network programming.</I> .NET provides built-in services for proxies, marshalling, network streams, distributed services, and other important network programming tools.</LI>
<LI>   <I>Garbage collection.</I> The current .NET garbage collector is a compacting GC, which means that objects can be moved around in memory in a way not (easily) usefully detectable to a naive C++ program. Today, a program has to &#147;pin&#148; objects in place during times when the program has to be able to assume they don&#146;t move. It might be possible that in the future the CLR might allow custom garbage collectors, which would allow the creation of conservative GCs that don&#146;t need to perform memory compaction, but in the meantime defining move semantics for C++ objects could go a long way to making compacting GCs compatible with C++ objects. Further, the notion of separating finalization (destruction) from memory deallocation would allow deterministic finalization while still running in a managed environment. These are opportunities for improved convergence between Standard C++ and Managed C++.</LI>
</UL>
<p>There are many other things .NET provides, but those are the ones that happen to directly target some of the same areas that are also of interest in C++0x standardization.</p>
<p>Standard C++ is designed to be highly portable and platform neutral so that it can be implemented on pretty much any platform, or at least all important ones. Is that at odds with .NET? Maybe not. .NET definitely has strong Windows roots, but two things are interesting: a) the core parts of the CLR, known as the CLI, are now an ECMA standard and may soon become an ISO standard; and b) even now multiple implementations of that Standard, including an implementation by Microsoft for FreeBSD of all things, are available or under development for non-Windows platforms. It&#146;s a little early to tell, but the indications at the moment are that .NET might end up being a platform applicable for production use much more widely than just on Windows boxes. We&#146;ll see.</p>

<H3><FONT COLOR="#000080">The Question: What about Standard C++ and Managed C++?</FONT></H3>
<p>Today, Managed C++ is Microsoft&#146;s attempt to extend Standard C++ in ways that directly support .NET&#146;s CLR and its threading, virtual machine, and garbage collection facilities, as well as its related GUI, network, and other libraries. Those things are also of interest to future Standard C++. Perhaps in the future there can be some synergy here, depending on the various participants&#146; interest, or perhaps not. Regardless, what is interesting and worth noting is how people are being driven to solve the same problems, and how they&#146;re being solved in production in something reasonably close to Standard C++ today.</p>
<p>Managed C++ is a strict superset of Standard C++, but it&#146;s as minimal a superset as possible. The Visual C++ engineers say, convincingly, that this is not a case of &#147;embrace and extend.&#148; They tried, and are trying, to create as few differences with Standard C++ as possible. Indeed, Managed C++ will continue to work toward closer convergence with Standard C++, further increasing the overlap; perhaps, in adopting semantics for things like garbage collection, Standard C++ might in the future even move toward closer convergence with managed environments.</p>
<p>Where does Standard C++ fit with Managed C++, and how do they work together? Let&#146;s consider the current status of C++ on .NET. To follow along, see <a href="fig2.htm">Figure 2</a>, which attempts to illustrate pictorially the overlap that Managed C++ provides with Standard C++ and .NET programming.</p>

<H3><FONT COLOR="#000080">Compiling Standard C++ Code to the .NET CLR</FONT></H3>
<p>&#147;Can I compile my existing C++ program with <B>/clr</B> and run it on .NET?&#148; This is the first and probably most basic scenario for moving code to the CLR, and it works completely. (The exceptions you&#146;re likely to encounter aren&#146;t actually Standard C++, as I&#146;ll describe in a moment).</p>
<p>This scenario is important to you as a C++ programmer with existing code and skills, and for the same reasons it&#146;s important to the vast majority of Microsoft developers. As noted, virtually all Microsoft products are written in C++, so Microsoft clearly has a heavy vested interest in C++. So do you. Today, you can take any conforming C++ program and compile it with <B>/clr</B>... and it just works. For example, you can take the many thousands of lines of code in the Office application suite, compile it with <B>/clr</B> to .NET&#146;s IL, and have Office run entirely on the .NET runtime. That&#146;s a pretty important accomplishment.</p>
<p>The one slight gotcha is actually outside the area of the C++ Standard, but only just beyond its edge. Let&#146;s take a moment to look at it in a little more detail.</p>

<H3><FONT COLOR="#000080">Meet the One Definition Rule</FONT></H3>
<p>Standard C++ has something called the ODR (One Definition Rule), which says that your program can compile more than one definition of the same function or class in different places in the program and happily link them all together and that&#146;s perfectly legal, as long as all those definitions are exactly identical. Now, clearly, in the normal course of affairs, you don&#146;t want a class <B>X</B> in one source file to have a different definition from class <B>X</B> in another source file, and usually you don&#146;t, which is all kosher, fat-free, and morally sublime.</p>
<p>But here&#146;s the rub: in the real world, real programs occasionally do let some minor ODR violations creep in, and they usually don&#146;t mind (or even know) because the violations are so slight that they don&#146;t always actually interfere noticeably with the meaning of the program. By the way, if all the qualifications in that last sentence worry you slightly, good; they ought to, even though they do reflect real-world practice and what many code bases are living with, knowingly or not.</p>
<p>For example, consider template functions declared in header files. The way the Microsoft compiler implements the template inclusion model, a template will be instantiated in every translation unit that uses it. Of course, being neat and orderly minded, you don&#146;t want to just keep them all and have lots of copies of the template littering your executable image in the end, not a bit of it &#151; and so Something Must Be Done about all the copies. Not surprisingly, the Someone Who Must Do It is the linker.</p>
<p>In native mode, the Visual C++ linker just picks one instantiation and throws away the rest, assuming that all the copies are the same &#151; after all, Standard C++ says they must be, right? So even though the template might have slightly different definitions in different translation units, the effect of those slight differences is often innocuous or at least unnoticed, even though they could be potentially harmful. I&#146;m certainly not implying that you should be writing code that knowingly violates the ODR, because such code does harbor pitfalls and violates the Standard; I&#146;m only pointing out the reality that such code exists in the wild, that it can creep in undetected, and that you might have some like it already and just not know about it if the effects happen to be benign. &#147;So what if a class has an extra friend in one place, or otherwise looks a little different here or there?&#148; say many compilers/linkers, including native-mode Visual C++, and happily accept your program with nary a burp, ignoring the minor breach of etiquette.</p>
<p>Life in .NET under the CLR is stricter. In C++ compiled for .NET, such slight ODR violations that may have crept into your code base will probably manifest as a linker error. Why? Because, whereas the native linker just picks one of the copies and leaves the rest alone, the URT (Universal Runtime) actively merges metadata from different translation units, and if it sees something inconsistent it will complain. (Given that it&#146;s complaining about things that really were already potentially harmful and almost certainly unnoticed in the first place, this is probably a good thing.)</p>
<p>As long as you know what it is you&#146;re looking for and what to expect, such errors are usually easy to resolve and good to resolve. For purists, it doesn&#146;t affect the point that all standards-conforming C++ programs compile fine to .NET, because they do. For realists, it&#146;s worth noting that while Standard C++ maps just fine to .NET, not all real-world programs limit themselves strictly to the Standard, and compiling with <B>/clr</B> may flag existing potential errors you may not be already aware of.</p>

<H3><FONT COLOR="#000080">Goodies, Limitations, and Opportunities</FONT></H3>
<p>Beyond just compiling Standard C++, there is some pretty strong support in Managed C++ for targeting the CLR&#146;s managed environment. In particular, Managed C++ allows you to create managed types, identified with the <B>__gc</B> keyword, whose objects will live on the managed heap and that can be consumed by other .NET languages. Here &#147;can be consumed&#148; means that other .NET languages can not only create and use instances, but can do things like seamlessly inherit from the class. Managed C++ also makes it possible to consume (including to inherit from) types and facilities from the .NET framework itself, as well as ones someone may choose to write in other .NET languages.</p>
<p>There are, however, two major classes of current limitations between today&#146;s Managed C++ and today&#146;s CLR:</p>

<UL><LI>   First, you can&#146;t take all of Standard C++ into the managed world. In particular, as shown in <a href="fig2.htm">Figure 2</a>, while you can create class templates and you can create managed <B>__gc</B> classes, you can&#146;t create <B>__gc</B> class templates. It would clearly be nice to remove this category of limitations.</LI>
<LI>   Second, non-<B>__gc</B> C++ objects can&#146;t be made available for seamless consumption by other .NET languages. Some of these cases exist because of technical barriers of the kind that compiler writers need to solve; others, however, fall squarely into the &#147;clear low-hanging fruit&#148; category, because for example there&#146;s little reason not to emit full metadata for C++ PODs (&#147;plain old data,&#148; a Standard C++ term for simple data structs without full class-like behavior and restrictions).</LI></UL>

<p>Finally, Microsoft is working to extend the CLR in particular ways, notably to add support for run-time generics; compile-time generics are already powerfully available in C++&#146;s templates. How well the CLR version of generics will overlap with the C++ facility remains to be seen, but clearly providing good compatibility and allowing the CLR versions to be used natively by C++ and vice versa is an important feature. The Visual C++ team knows it.</p>

<H3><FONT COLOR="#000080">Summary</FONT></H3>
<p>C++ is the premier language for systems and performance-oriented development on Windows and .NET, period &#151; it certainly is that at Microsoft, and few modern programs in any organization can afford to say, &#147;oh, well, we&#146;ll just take a 30% performance hit and use some other language.&#148; Most of us work on projects where the next release&#146;s feature queue includes several performance-related requests, and in many application domains such as scientific and engineering work, &#147;pretty fast&#148; is never fast enough. Many applications likewise just can&#146;t live (easily) without the power of being able to work at every level from bit twiddling to high-level abstraction all within the same language. That means that a large number of our software projects now need, and will continue to need, the power and flexibility of a language like C++, even as we use it to write distributed and web applications and server software.</p>
<p>Microsoft&#146;s stated goal for Managed C++ is to allow everything you can do in Standard C++ to have full first-class support on the .NET CLR. That is, you should be able to use all C++ features on managed types (so Microsoft has to allow constructs like <B>template __gc class Whatever</B> , which is not yet supported today). Conversely, you should be able to write to the CLR with the same power as any other .NET language, so that other languages can consume our safe, fast, and efficient code as easily as code written in their own language. Some of this is here today, and more needs to come in the next releases. In some areas, achieving full convergence will be very difficult; for example, C++ has multiple inheritance and the CLR does not. But Standard-Managed convergence is still a valuable and important goal for C++ at Microsoft, and for the wider C++ community who are not well served by competing &#147;flavors&#148; of a language. That&#146;s the kind of situation that a standard is supposed to prevent, and Standard C++ has done a great job of unifying pre-standard implementations.</p>
<p>As the time now comes to consider Standard C++&#146;s continued role as a premier player in the new world of web services and virtual machines and network programming, Managed C++ provides probably the most prominent design for using C++ in such modern environments. Overlap with Standard C++ could be better, and the team knows it and is working hard to resolve the remaining limitations.</p>
<p>It will be interesting to see what convergence and improvements the next releases of both Standard C++ and Managed C++ will bring.</p>

<H3><FONT COLOR="#000080">References</FONT></H3>
<p><a name="1"></a>[1]  Matt Austern. &#147;The Standard Librarian: And Now for Something Completely Different,&#148; <I>C/C++ Users Journal</I>, January 2002), &lt;www.cuj.com/experts/2001/austern.htm&gt;.</p>
<p><a name="2"></a>[2]  Herb Sutter. &#147;Sutter&#146;s Mill: Toward a Standard C++0x Library, Part 1,&#148; <I>C/C++ Users Journal</I>, January 2002, &lt;www.gotw.ca/publications/mill20.htm&gt;.</p>
<p><a name="3"></a>[3]  Herb Sutter. &#147;The New C++,&#148; <I>C/C++ Users Journal C++ Experts Forum</I>, February 2002, &lt;www.cuj.com/experts/2002/sutter.htm&gt;.</p>
<p><a name="4"></a>[4]  Herb Sutter. &#147;The New C++: The Group of Seven &#151; Extensions Under Consideration for the C++ Standard Library,&#148; <I>C/C++ Users Journal C++ Experts Forum</I>, April 2002, &lt;www.cuj.com/experts/2004/sutter.htm&gt;.</p>

<p><i><B>Herb Sutter</B> (&lt;www.gotw.ca&gt;) is secretary of the ISO/ANSI C++ standards committee, author of the acclaimed books <I>Exceptional C++</I> and <I>More Exceptional C++</I>, and one of the instructors of The C++ Seminar (&lt;www.gotw.ca/cpp_seminar&gt;). In addition to his independent writing and consulting, he is also a C++ community liaison for Microsoft.</i></p>

</blockquote></body></html>
