<HTML>   
     <HEAD>
<TITLE>January 2002/A Stream Class for Calling Perl from C++</TITLE></HEAD>
<BODY BACKGROUND="" BGCOLOR="#FFFFFF" TEXT="#000000">
<H2><A HREF="../tocjan.htm"></A><FONT COLOR="#FF0000">   Mixed-Language Programming</FONT></H2>

<HR>

<H2 ALIGN="center"><FONT COLOR="#800000">A Stream Class for Calling Perl from C++</FONT></H2>
<H3 ALIGN="center"><FONT COLOR="#800000">Robert Y. Seward</FONT></H3>

<BLOCKQUOTE>
<p>Mixing Perl and C++ just got a whole lot easier.</p>
</BLOCKQUOTE>

<HR>
<BLOCKQUOTE>

<H3><FONT COLOR="#000080">Introduction</FONT></H3>

<p>One nice aspect of Perl is that you can mix Perl with C/C++ by either creating Perl modules written as C++ shared libraries or embedding Perl into a C++ application, allowing you to take advantage of the strengths of both C++ and Perl in one application. One difficulty that I have encountered in doing this is calling Perl from C++. Calling Perl from C++ can be useful to access data that resides in Perl space, to use existing Perl libraries, to create code on the fly, or to simply run some functions that are more suitable for Perl. While calling Perl from C++ is useful, it is not easy. I have seen several wrappers around the Perl API that attempt to make it easier to use, but most of these either lack all the functionality I needed or weren&#146;t much easier to use than the original API. To solve this problem, I have implemented two C++ wrappers, one using the stream interface to send commands to Perl and one to convert the results into standard C++ types. The interface allows you to do just about anything you can do in a normal Perl script, while being as easy as writing to a file and reading from an array. <a href="list1.htm">Listing 1</a> shows some example code using the <B>PerlStream</B> and <B>PerlValue</B> classes.</p>

<H3><FONT COLOR="#000080">Calling Perl from C the Hard Way</FONT></H3>

<p>When you call Perl from C, you have at your disposal a number of C functions that Perl provides to do this kind of thing. What follows is a very condensed version of what can be found in the Perl documentation (<B>man perlguts</B> and <B>man perlcall</B> on Unix).</p>
<p>A Perl value is represented in C with a pointer to an <B>SV</B> type. This <B>SV*</B> can point to any type of Perl value: scalar, array, hash, reference, etc. There are a bunch of macros and functions that Perl provides to query an <B>SV*</B> and to convert back and forth between <B>SV</B>s and standard C types. If an <B>SV*</B> points to an array, you can cast it to an <B>AV*</B> and do all the normal Perl array operations with it. Similarly, if an <B>SV*</B> points to a hash, you can cast it to an <B>HV*</B> and do hash operations with it.</p>
<p>One tricky thing about <B>SV</B>s is reference counting and mortality. In normal Perl code, Perl cleans up variables that are no longer in use by doing reference counting on each value. When programming in C, the cleanup is not so automatic. You must take care to &#147;free&#148; a value either by decrementing the reference count or by telling Perl that the value is &#147;mortal.&#148; Mortality means that Perl will wait to decrement the reference count until the end of the current scope and will free the value if the reference count goes to zero. Think of this in terms of the C++ behavior of calling the destructor on a local variable at the end of the current scope, with the twist that Perl&#146;s &#147;destructor&#148; is not called if the local variable is still in use elsewhere.</p>
<p>You can run Perl code from C by either calling a Perl function or running the C equivalent of Perl&#146;s <B>eval</B> function. In both cases, you have to manipulate the Perl stack by pushing <B>SV</B>s onto the stack before the call and popping <B>SV</B>s off the stack after the call. Also, you must explicitly tell Perl if you want to run the Perl code in a scalar, array, or void context and if you want Perl to keep the error (the <B>$@</B> Perl variable). Lastly, after popping the results off the stack, you have to use Perl functions and macros to determine what the <B>SV</B> is (<B>int</B>, <B>double</B>, reference, etc.) and convert the <B>SV</B> to a C type. Dealing with array references and hash references adds to the complexity.</p>
<p>To get a taste of what this can look like, take a look at the <B>PerlStream</B> <B>execute</B> function on line 29 of <a href="list2.htm">Listing 2</a>. I do not want to explain all the details about each funny Perl macros &#151; read the Perl documentation. I just want to point out that, while this may be second nature for Larry Wall, this is not easy for me to understand. I always have the gnawing feeling that I may be corrupting the Perl stack, leaking memory, or doing some other horrible thing. In fact, I have done all of these at various times when using the Perl API, so the fear is justified.</p>

<H3><FONT COLOR="#000080">An Easier Way, Part I: The PerlStream</FONT></H3>

<p>The <B>ostream</B> to send an evaluation string to Perl is actually two classes: <B>PerlStream</B> and <B>PerlStreamBuf</B>. All concrete streams, such as <B>stringstream</B>s and <B>fstream</B>s, have this same underlying two-class design. The stream part handles all formatting operations, such as converting floating-point numbers to a character string. The result of the formatting is a sequence of characters, which are sent to the stream buffer. The stream buffer takes the characters and sends them to the appropriate device, possibly buffering the characters before sending them on.</p>
<p>When you want to create a new stream class, most often you really want the stream buffer part to be different, but want the formatting operations to be just like a normal stream. As a result, the new stream class is usually a very simple class, just inheriting from <B>stream</B>, whereas the stream buffer class does most of the work.</p>
<p>Things are no different for the <B>PerlStream</B> class. The <B>PerlStream</B> class definition is shown in <a href="list3.htm">Listing 3</a>, starting at line 96. The class gets all the formatting functionality by just inheriting from <B>ostream</B>. There is only one data member: the <B>PerlStreamBuf</B> that is associated with this <B>PerlStream</B> object. The constructor passes this <B>PerlStreamBuf</B> to the underlying <B>ostream</B> via <B>ostream</B>&#146;s constructor so that it knows where to send the formatting results. The <B>PerlStream</B> class&#146;s member functions are all just wrappers around the real functions in <B>PerlStreamBuf</B>.</p>
<p><B>PerlStreamBuf</B> needs to accumulate all characters sent to it in some buffer, waiting for the user to tell it to send it on to Perl. At that point, <B>PerlStreamBuf</B> evaluates the accumulated code and clears the buffer, getting ready for the next set of code.</p>
<p>To implement this, I chose to not give <B>PerlStreamBuf</B>&#146;s <B>streambuf</B> base class a buffer at all. If the base class has no buffer, it calls the <B>overflow</B> virtual function with every character. So, I defined <B>overflow</B> to append the given character to the string <B>mBuffer</B>, as shown in line 23 of <a href="list2.htm">Listing 2</a>. Although this is not the intended use of <B>overflow</B>, it makes the design of <B>PerlStreamBuf</B> trivial. Note that I also redefine the <B>xputs</B> virtual member function (<a href="list2.htm">Listing 2</a>, line 26) as a performance optimization, since the base class makes one call to <B>xputs</B> for a string instead of calling <B>overflow</B> for each character in the string.</p>
<p>The <B>perl_execute</B> that initiates the Perl evaluation is called an I/O manipulator. For a complete discussion of manipulators, see <a href="#1">[1]</a>. Briefly, <B>perl_execute</B> is a function defined to take an <B>ostream</B> and return an <B>ostream</B> (see <a href="list3.htm">Listing 3</a>, line 107), and <B>&lt;iomanip&gt;</B> defines an output operator that causes the function to be called when used like this, passing the <B>ostream</B> as its argument. <B>perl_execute</B> will then call the <B>PerlStream</B>&#146;s <B>execute</B> member function.</p>
<p>The code for <B>execute</B> is shown in <a href="list2.htm">Listing 2</a> starting at line 29. Most of the code is best understood by reading the Perl documentation, but a couple of points are worth noting. First, the code passes two flags to <B>perl_eval_sv</B>: one to tell Perl the execution context and one to tell it to keep the error. By default, <B>PerlStream</B> will tell Perl to execute the code in a scalar context (meaning the code will return at most one value). Alternatively, you can have Perl execute the code in a void context (nothing is returned) or an array context (any number of values are returned) by calling the <B>array</B> and <B>voidc</B> <B>PerlStream</B> member functions. These functions set the <B>mContext</B> member data to the appropriate value, which is then passed on to Perl. The <B>G_KEEPERR</B> flag tells Perl to set <B>ERRSV</B> (the C equivalent of <B>$@</B>) if <B>eval</B> failed. The code checks for an error by calling <B>SvTRUE</B> on <B>ERRSV</B>.</p>
<p>Secondly, the code for <B>execute</B> is getting the values from the Perl stack. All the return values, in the form of <B>SV*</B>s, are put into the <B>mRtnVals</B> vector. So that Perl will not destroy these values at the end of the current scope (the <B>FREETMPS</B>/<B>LEAVE</B> statements), the code increments the reference count on all of them. As mentioned before, this prevents Perl from destroying the <B>SV</B>s and all underlying objects (arrays, hashes, etc.). The code will eventually decrement the reference counts by calling <B>freePerlValues</B>, allowing Perl to free the memory if nothing else is using it, at the beginning of <B>execute</B> and in the <B>PerlStreamBuf</B> destructor.</p>

<H3><FONT COLOR="#000080">An Easier Way, Part II: The PerlValue Class</FONT></H3>

<p>The <B>PerlStream</B> class has the <B>[]</B> operator overloaded to access the <B>SV*</B>s returned by Perl, but converts them into a <B>PerlValue</B> object. The <B>PerlValue</B> class, defined in <a href="list3.htm">Listing 3</a> starting at line 12, is just a thin wrapper around all the Perl macros and functions that query <B>SV*</B> about its type and convert an <B>SV*</B> to C types. The conversions are done with C++ conversion operators, which are automatically called when the compiler is faced with the need to convert from a <B>PerlValue</B> to some other type, as in an assignment.</p>
<p>For example, on lines 9 and 10 of <a href="list1.htm">Listing 1</a>, <B>ps[0]</B> and <B>ps[-2]</B> return a <B>PerlValue</B> object. C++ calls the <B>int</B> conversion operator on the assignment to <B>two</B> and calls the <B>double</B> conversion operator on the assignment to <B>five</B>. The code to implement the conversions and type queries are simple wrappers around the corresponding Perl functions. For example, <B>isInt</B> (line 1 of <a href="list2.htm">Listing 2</a>) calls the Perl function <B>SvIOK</B>, and the conversion to an <B>int</B> (member function <B>Int</B> on line 4) calls the Perl function <B>SvIV</B>. Like Perl, a <B>PerlValue</B> will happily convert from one Perl scalar (<B>string</B>, <B>int</B>, or <B>double</B>) to another on demand. A side effect of this is that the return values of <B>isInt</B>, <B>isNumber</B>, <B>isDouble</B>, and <B>isString</B> can actually change after some of these conversions are done.</p>
<p>If the <B>SV</B> is an array or hash reference, you can access the values in the array or hash by using the <B>PerlValue</B>&#146;s <B>[]</B> operator. If the argument passed in to <B>operator[]</B> is an <B>int</B>, then <B>PerlValue</B> will try to use its <B>SV</B> as an array reference and use the argument as the array index. Like Perl, a negative array index will index from the end of the array. If the argument to <B>operator[]</B> is a <B>char*</B> or <B>string</B>, then <B>PerlValue</B> will try to use its <B>SV</B> as a hash reference and use the argument as the hash key. These can be chained together as in lines 11 and 16 of <a href="list1.htm">Listing 1</a>. By default, <B>PerlValue</B> will silently tolerate an out-of-range index and values that are not really array or hash references. Alternatively, you can tell <B>PerlValue</B> to throw an exception in such cases.</p>
<p>You can also iterate over all values of an array or hash the same way you would iterate over an STL vector or map. Examples of this are on lines 21 and 26 of <a href="list1.htm">Listing 1</a>. The array iterator is just like an STL vector iterator: you can move forwards and backwards, and the motion can be in any size steps. The hash iterator is more restrictive than an STL map iterator because Perl&#146;s interface is more restrictive. Namely, you can only iterate forward, and you can only have one iterator per hash. A second iterator will set the first iterator back to the beginning of the hash.</p>
<p>The code to implement the iterators is mostly straightforward wrappers around Perl functions. The array iterator, implemented with the <B>PerlValue::array_iter</B> class, keeps an index into the array. The hash iterator, implemented with the <B>PerlValue::hash_iter</B> class, lets Perl handle the hash iteration. The one tricky part of both iterators is implementing the <B>operator-&gt;</B> function. For the array iterator, the function needs to return a pointer to a <B>PerlValue</B> object, but a <B>PerlValue</B> has to be constructed to wrap around the real <B>SV*</B> that is in the array. If the function constructs a local object, it can&#146;t return a pointer to that because the object will cease to exist as soon as the function returns. If the function constructs an object with <B>new</B>, the caller has to remember to free it. The solution to this quandary is to return a <B>PerlValue::ptr</B> object. This object contains a <B>PerlValue</B> and will continue to exist past the function return. The <B>PerlValue::ptr</B> class has its <B>operator-&gt;</B> overloaded to access the encapsulated <B>PerlValue</B>. So, on line 26 of <a href="list1.htm">Listing 1</a>, <B>ai-&gt;isInt()</B> gets expanded to <B>ai.operator-&gt;().operator-&gt;()-&gt;isInt()</B> &#151; <I>two</I> calls to <B>operator-&gt;</B>! The hash iterator has something similar, but <B>operator-&gt;</B> returns a <B>PerlValue::hash_return_ptr</B>, which contains a <B>pair&lt;const char*,PerlValue&gt;</B>.</p>

<H3><FONT COLOR="#000080">Error Handling</FONT></H3>

<p>When I designed <B>PerlStream</B>/<B>PerlValue</B>, I wanted to preserve some of Perl&#146;s flexibility in handling errors. By default, Perl will tolerate all sorts of abuse: array out-of-range errors, dereferencing undefined values, etc. However, you can use <B>strict</B> and run it with the <B>-w</B> option to give some amount of error checking. <B>PerlStream</B>/<B>PerlValue</B> does the same. By default, it will silently handle any error condition and do a somewhat sensible thing.</p>
<p>Alternatively, you can tell <B>PerlStream</B> what errors you want to know about. The possible classes of errors are evaluation errors (problems with the code sent to Perl), array out-of-bounds conditions, invalid hash lookups, and casting errors. Casting errors cover a number of problems (e.g., getting a scalar from a reference, getting a hash from a scalar, and getting an array from a hash). If an error is enabled, <B>PerlStream</B> and <B>PerlValue</B> will throw an exception when the error is encountered.</p>
<p>One thing that it is <I>not</I> flagged as an error is converting a text string to an integer or <B>double</B> or converting a <B>double</B> to an integer. Since these are all Perl scalar values, Perl does these conversions somewhat automatically, and often these conversions are legitimate.</p>
<p>All exception classes inherit from the standard <B>exception</B> class, so one can catch all of them by catching an <B>exception</B> type. An example of catching an exception is shown on line 33 of <a href="list1.htm">Listing 1</a>. Each exception has an error message that can be retrieved with the <B>what</B> member function. An example of an exception class, <B>PerlEvalError</B>, is shown on line 1 of <a href="list3.htm">Listing 3</a>.</p>

<H3><FONT COLOR="#000080">Conclusion</FONT></H3>

<p>I presented two classes, <B>PerlStream</B> and <B>PerlValue</B>, that making dealing with the Perl API much easier without sacrificing any flexibility. <B>PerlStream</B> is conceptually simple to grasp and relatively easy to write. Such a paradigm could be easily adapted to APIs of other languages such as Tcl or Python.</p>

<H3><FONT COLOR="#000080">Note</FONT></H3>

<p><a name="1"></a>[1]  Bjarne Stroustrup. <I>The C++ Programming Language</I>, Chapter 21, &#147;Streams&#148; (Addison-Wesley, 1997). </p>

<p><i><B>Robert Y. Seward</B> graduated from Texas A&amp;M University in 1982 with a BS in Electical Engineering. He has worked at General Dynamics, Varo, and Convex Computer, and is currently employed with Hewlett-Packard in Ft. Collins, CO. He is currently a team leader for timing CAD tools in the microprocessor design labs. He has been programming in C for 15 years, C++ for 7 years, and Perl for 5 years.</i></p>

<h4><a href="../../../source/2002/jan02/seward.zip"></a></h4>

</blockquote></body></html>
