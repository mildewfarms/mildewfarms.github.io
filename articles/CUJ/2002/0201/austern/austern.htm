<HTML>   
     <HEAD>
<TITLE>January 2002/The Standard Librarian</TITLE></HEAD>
<BODY BACKGROUND="" BGCOLOR="#FFFFFF" TEXT="#000000">
<H2><A HREF="../tocjan.htm"></A><FONT COLOR="#FF0000">   C/C++ Contributing Editors</FONT></H2>

<HR>

<H2 ALIGN="center"><FONT COLOR="#800000">The Standard Librarian: And Now for Something Completely Different</FONT></H2>
<H3 ALIGN="center"><FONT COLOR="#800000">Matt Austern</FONT></H3>

<BLOCKQUOTE>
<p>C++0x is imminent. Here's a glance at what's happening and a suggestion on how you can contribute.</p>
</BLOCKQUOTE>

<HR>
<BLOCKQUOTE>
<p>This isn&#146;t the column I&#146;d intended to write. I was planning to write about an interesting technique in template programming, but I&#146;m now sitting in sunny Redmond, Washington, where I&#146;ve come for the October meeting of the C++ Standardization Committee. I&#146;m not going to present any new classes in this column, or explain any obscure corners of the standard library; it&#146;s clear that there&#146;s something more important.</p>
<p>The C++ Standard was finished in 1997 and released in 1998. What has the Standardization Committee been doing for the last three years? There&#146;s a simple answer: standards maintenance. The Standard was a large project, and, like all large projects, it had bugs. (It still has some.) There were inconsistencies, ambiguities, components that couldn&#146;t be implemented, and requirements that didn&#146;t mean what we thought they did. We&#146;ve been fixing those problems as we&#146;ve found them and as they&#146;ve been reported to us. We have now finished a &#147;Technical Corrigendum,&#148; which is bureaucratese for a patch that fixes many of these bugs.</p>
<p>If you&#146;re curious about the sort of things the committee has been dealing with, we make two lists available: one for issues having to do with the core language (&lt;http://anubis.dkuug.dk/jtc1/sc22/wg21/docs/cwg_active.html&gt;) and one for issues having to do with the standard library (&lt;http://anubis.dkuug.dk/jtc1/sc22/wg21/docs/lwg-active.html&gt;).</p>
<p>Maintenance isn&#146;t a very glamorous activity; it&#146;s only noticed when it&#146;s done poorly. Some of the issues before the committee are serious (as you&#146;ll see if you take a look at those two lists), and sometimes we&#146;ve had to work hard to figure out the right answer, but we haven&#146;t made many really visible changes. That&#146;s deliberate, of course: our main goal has been stability. We&#146;ve tried to avoid surprises. When we&#146;ve made changes, we&#146;ve usually tried to restore something that everybody assumed was already the case. If nobody but language lawyers ever notices what we&#146;ve been doing for the last three years, then we&#146;ve been doing our job.</p>

<H3><FONT COLOR="#000080">Library Extensions</FONT></H3>

<p>That&#146;s all changing. Stability was the right goal for the last couple of years, but people &#151; the Standardization Committee, and the C++ community as a whole &#151; have gradually become more and more interested in doing new things, not just maintaining the old. It&#146;s the right time. There&#146;s been a lot of good work in C++, and implementations are finally getting to the level where it&#146;s possible for us to write standard C++ without compromises; it&#146;s becoming less and less necessary to litter your code with workarounds for a half dozen deficient compilers. It&#146;s time for us to standardize more of what people need today, not just what people needed five years ago.</p>
<p>The C++ Standardization Committee lives underneath a larger bureaucracy, and we&#146;ve set the official process in motion. By the time you read this, we expect that we will have formal permission to begin working on extensions. We&#146;re starting with the library.</p>
<p>Why the library? Partly it&#146;s because there&#146;s a pretty strong feeling that now isn&#146;t the time for us to be making big changes in the core language. We already have a language with a great deal of expressive power, and we&#146;re still learning what we can do with it. Every so often I still sometimes will learn about some new and surprising technique that I hadn&#146;t previously realized was possible; modern ideas of good C++ style are very different from what would have been considered good style 10 years ago. Partly we want to focus on the library because user demand for new libraries is extremely high. And partly it&#146;s because it seems more consistent with the C++ philosophy: we want to provide general abstraction facilities, not special-case features. We didn&#146;t define a built-in complex number type, for example; we defined <B>std::complex</B> as part of the standard library, using classes and templates and operator overloading. Finally, it&#146;s much easier to experiment with libraries than with language extensions; not many of us are in a position to tinker with C++ compilers.</p>
<p>This doesn&#146;t mean that the core language will remain absolutely unchanged, of course, but it does mean we&#146;ll mainly think about language changes in the context of what we need for better libraries: we&#146;ll change the language only if we find a convincing argument that the abstraction facilities of the existing language are inadequate. Maybe we&#146;ll need some changes to namespace aliasing rules, for example, to support versioning of the standard library &#151; we won&#146;t know until we try. Or perhaps we&#146;ll find there are some library components that can&#146;t be implemented in any reasonable way without <B>typedef</B> templates &#151; when I look at some of the elegant techniques in Andrei Alexandrescu&#146;s book <a href="#1">[1]</a>, I sometimes think I&#146;m just seeing a shadow of what his work might look like if we had <B>typedef</B> templates. For example:</p>

<pre>
template &lt;typename A, typename B&gt;
typedef typelist&lt;A, typelist&lt;B, nil_type&gt; &gt;
        typelist2&lt;A, B&gt;;
</pre>

<p>It&#146;s always difficult to say in advance exactly what we want to see, but we do at least have some ideas about the directions we&#146;re most interested in <a href="#2">[2]</a>:</p>

<UL>
<LI>   <I>Filling obvious gaps.</I> One of the most frequent questions people ask about the Standard C++ library is &#147;Why doesn&#146;t it have hash tables?&#148; There isn&#146;t really any good reason. There&#146;s a historical reason, which is trivial: the proposal was presented at the wrong time. Lots of vendors do provide hash tables as a nonstandard extension. If we see an obvious gap in the library, and especially if it turns out that vendors provide it anyway (either as an extension or for the library&#146;s own internal use), then it&#146;s a good candidate.</LI>
<LI>   <I>Better compatibility between C and C++.</I> The world has changed in the last few years, and one of the things that has changed is the C language. The C++ language was deliberately designed to be very compatible with the standard C language <a href="#3">[3]</a>. The C++ Standard references the version of the C Standard that was defined in 1989 (sometimes called &#147;ANSI C&#148;), but there&#146;s now a newer version of the C Standard. It has new keywords and new library facilities. We should look at past and future work in C, and we should ensure that future versions of C++ and future versions of C become more compatible with each other.</LI>
<LI>   <I>Better infrastructure for library building.</I> Some of the most exciting work in C++ development today involves template-based programming, even template metaprogramming. By experience, the C++ community has learned that many of these techniques use a few common base components. Many people have independently invented such ideas as type traits classes, compile-time <B>IF</B>, compile-time boolean operations, expression templates, and dispatching on categories. Standardization would mean that people wouldn&#146;t have to waste time on such reinvention and reimplementation.</LI>
<LI>   <I>Better support for novices.</I> Just as we&#146;ve learned new techniques for C++ programming, so we&#146;ve learned new techniques for teaching C++ <a href="#4">[4]</a>. However, there are still some facilities that are too difficult to explain and too easy for a non-expert to use incorrectly. Can these facilities be changed, or at least supplemented by other components that were designed specifically for teaching?</LI>
<LI>   <I>Support for (some) important application domains.</I> This is a dangerous goal, because it&#146;s not clear where to draw the line. I don&#146;t think we want to have a C++ Standard with packages for molecular dynamics, or accounting, or DSP, or CAD. On the other hand, some application areas are important to a wide range of programmers. Many different kinds of programs need better text processing than we have in the standard library; I think that most of us, for example, have used one of the many third-party regular expression libraries. Nowadays most of us care about networking, and many of us are moving in the direction of distributed programming. High-performance numerics come up again and again. The importance of internationalization, including such character sets as ISO 10646, will only grow. We can&#146;t solve everyone&#146;s problems, but we can try to solve the ones that matter most.</LI>
</UL>

<p>Naturally, this isn&#146;t an exclusive list: sometimes you don&#146;t realize you wanted something until you see it! At least to some extent, we should be opportunistic. By definition, really innovative work will be something that we couldn&#146;t have asked for in advance, something we couldn&#146;t have been expecting. Alex Stepanov&#146;s STL, for example, with its separation of containers and algorithms and with its reliance on abstract requirements rather than on inheritance, was a brilliant innovation in library design. It was recognized as such &#151; but only after people saw it. </p>

<H3><FONT COLOR="#000080">What You Can Do</FONT></H3>

<p>Design by committee rarely works well. The C++ language was largely the invention of one person, Bjarne Stroustrup <a href="#5">[5]</a>. With very few exceptions, every major feature of C++ has been the work of one person or of a small group. A standards committee can evaluate, can refine and modify, can accept or reject, but for the most part it can&#146;t invent. We expect that the committee will be looking at proposals presented by others. (Individual committee members can and will contribute proposals, of course, but not the committee itself.)</p>
<p>At the time of writing, the standardization committee hasn&#146;t yet sent out a call for proposals. (By the time you read this, I expect that we will have.) But even though we haven&#146;t asked for proposals yet, we&#146;ve already received some anyway! We started looking at those proposals at this meeting. Here are a few of them:</p>

<UL><LI>   <I>C99&#146;s </I><B>&lt;inttypes.h&gt;</B><I>.</I> C99 defines a new header, <B>&lt;inttypes.h&gt;</B>, that makes it easier to talk about integer types with specific sizes. It includes <B>typedef</B>s like <B>int_least16_t</B> (the smallest signed integer type that&#146;s at least 16 bits long) and <B>uint32_t</B> (an unsigned integer type that&#146;s exactly 32 bits long; this <B>typedef</B> is undefined if there is no such type). In one sense, of course, this header doesn&#146;t give you anything you didn&#146;t have already. It doesn&#146;t define any new types: the integer types are still <B>short</B>, <B>int</B>, <B>long</B>, and so on. But, if the exact size of a type matters for your program, <B>&lt;inttypes.h&gt;</B> gives you a way to ask for the right type without using ugly <B>#ifdef</B>s. It&#146;s likely that this facility will be adopted into C++: lots of users want it, and C compatibility has been and is an important goal.</LI>
<LI>   <I>&#147;Smart pointers.&#148; </I> The C++ library defines just one smart pointer class: <B>std::auto_ptr</B>. In some circles, <B>auto_ptr</B> has a bad reputation. My own opinion is that the only real problem with <B>auto_ptr</B> is that it&#146;s overused: it&#146;s the only smart pointer class in the Standard, and a lot of programmers assume that means that they&#146;re supposed to use <B>auto_ptr</B> for everything. It&#146;s a natural assumption, but it&#146;s wrong: <B>auto_ptr</B> was never intended to solve anything but one narrow problem. We need to add some more smart pointer classes, ones that are suitable for a wider range of uses. One very natural possibility, one that&#146;s already in wide use, is Boost&#146;s <B>shared_ptr</B> <a href="#6">[6]</a>.</LI>
<LI>   <I>Hash tables.</I> At least three library vendors provide hash tables as an extension. One of the things a standard is supposed to do is reflect existing practice, so this is a natural candidate. The tricky part is that we&#146;ve got multiple almost-compatible implementations. How do we resolve the differences?</LI>
</UL>

<p>We&#146;re still early in this process, and there are many unanswered questions: we&#146;ve received a few proposals, and we&#146;ve given some of them a first look, but we certainly haven&#146;t yet made a definite decision to adopt any of the ones we&#146;ve seen. It&#146;s not too late for new proposals; we&#146;re near the beginning of this process, not the end.</p>
<p>And that, finally, is the important part. All we&#146;ve seen so far is the first crop of proposals. The C++ community is large, and there has been an enormous amount of good work on C++ libraries. We want to standardize the best possible extensions, not just the ones we happen to notice first.</p>
<p>If you&#146;ve done some of that work, if you&#146;ve written something that you would like to see added to the Standard C++ library, now is your chance! We want to see your proposals.</p>
<p>We still need to work out some of the details on how to submit a proposal for a library extension, but a pretty safe bet is that you&#146;ll be able to do it by posting it to the Usenet newsgroup <B>comp.std.c++</B>, and the moderators of that group will forward it to the C++ Standardization Committee as appropriate. Just remember that a proposal should be more than a wish. A proposal should describe something that has actually been implemented; it should solve an important problem; and it should discuss why you made the design decisions that you did.</p>
<p>Keep watching this space! We live in interesting times.</p>

<H3><FONT COLOR="#000080">Notes</FONT></H3>

<p><a name="1"></a>[1]  Andrei Alexandrescu. <I>Modern C++ Design: Generic Programming and Design Patterns Applied</I> (Addison-Wesley, 2001).</p>
<p><a name="2"></a>[2]  This list is largely inspired by Bjarne Stroustrup&#146;s list of future directions. See, for example, the <I>Future Directions for C++</I> panel discussion at &lt;http://technetcast.ddj.com/tnc_play_stream.html?stream_id=560&gt;.</p>
<p><a name="3"></a>[3]  Not 100 percent compatible, of course; C++ is not a strict superset of C. The unofficial slogan for many years has been &#147;As close to C as possible, but no closer.&#148;</p>
<p><a name="4"></a>[4]  See, for example, Andrew Koenig and Barbara Moo. <I>Accelerated C++</I> (Addison-Wesley, 2000).</p>
<p><a name="5"></a>[5]  Bjarne Stroustrup. <I>The Design and Evolution of C++</I> (Addison-Wesley, 1994).</p>
<p><a name="6"></a>[6]  &lt;http://www.boost.org/libs/smart_ptr/index.htm&gt;</p>

<p><i><B>Matt Austern</B> is the author of <I>Generic Programming and the STL</I> and the chair of the C++ standardization committee&#146;s library working group. He works at AT&amp;T Labs &#151; Research and can be contacted at <B>austern@research.att.com</B>.</i></p>

</blockquote></body></html>
