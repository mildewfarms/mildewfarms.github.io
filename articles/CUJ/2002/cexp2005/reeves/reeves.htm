<HTML>   
     <HEAD>
<TITLE>May 2002 C++ Experts Forum/The (B)Leading Edge</TITLE></HEAD>
<BODY BACKGROUND="" BGCOLOR="#FFFFFF" TEXT="#000000">
<H2><A HREF="../../20.05/tocmay.htm"></A><FONT COLOR="#FF0000">   C++ Experts Forum</FONT></H2>

<HR>

<H2 ALIGN="center"><FONT COLOR="#800000">The (B)Leading Edge: Musings on the IndexedFile Design</FONT></H2>
<H3 ALIGN="center"><FONT COLOR="#800000">by Jack W. Reeves</FONT></H3>

<HR>
<BLOCKQUOTE>

<p>This month's edition of &quot;The (B)Leading Edge&quot; is going to step back from my usual modus operandi of looking at code and instead look at some larger issues. A columnist in one of <i>C/C++ User's Journal</i>'s sister publications has remarked that unlike a book, where the author usually presents a finished product, a column provides both the opportunity and (often) the necessity of presenting a work in progress. That is certainly the case with what I am doing now. For those who may not have followed my previous columns all that closely, let me make a brief summary. I am developing an <b>IndexedFile</b> class. This class is intended to provide a persistent object storage mechanism that allows retrieval of items by key. In my previous column <a href="#1">[1]</a>, I presented the first draft of my <b>IndexedFile</b> class interface. The class interface is modeled on that of the <b>map</b>/<b>multimap</b> classes in the C++ Standard library, but its underlying implementation is based on the <b>XDRStream</b> classes that I have developed previously <a href="#2">[2]</a>. <b>XDRStream</b>s are in turn intended to provide IOStreams-like interfaces to the XDR presentation layer protocol. </p> 
<p>The <b>IndexedFile</b> class provides a number of features that I think are important, but that I have not found in any other similar libraries I have looked at. First, it allows variable length data items and keys. There is a maximum upper size to a key, but even that aspect is under the control of the user. Second, the data items that can be stored in the <b>IndexedFile</b> do not have to be of the same type &#151; an <b>IndexedFile</b> can handle objects from an entire class hierarchy. Finally, the <i>index</i> part of an <b>IndexedFile</b> is represented by a separate class of its own: <b>BtreeIndex</b>. While objects of this type can be used independently of an <b>IndexedFile</b>, one of my primary assumptions was that they would be most useful in building secondary indexes for an <b>IndexedFile</b>. </p> 
<p>Given the fact that <b>BtreeIndex</b> is a separate class that maintains an index in an external file, it should be fairly obvious and understandable that the underlying implementation of an <b>IndexedFile</b> consists of two actual files: one an ordinary <b>XDRStream</b> that holds the actual data items, and a second that is the <b>XDRStream</b> for the <b>BtreeIndex</b>. </p>  
<p>I noted in my previous column that I was not trying to build a replacement for a database engine. Nevertheless, I am aware that most database engines have something similar to this mechanism at their heart. I was recently having dinner with a good friend of mine. This friend happens to have a couple orders of magnitude more database experience than I do. He also happens to be a top-notch object-oriented software architect. I was describing my <b>IndexedFile</b> class to him, and, in return, he was asking some very probing questions about its implementation &#151; most of which I could answer. One of his questions &#151; recast into the current vernacular &#151; was &quot;if you delete an item from the <b>IndexedFile</b>, do iterators referring to other items in the file remain valid?&quot; I answered &quot;no.&quot; The iterators for <b>IndexedFile</b> are based upon the iterator for the <b>BtreeIndex</b>. Recall that a <b>Btree</b> consists of <i>pages</i>, each of which contains several <b>(key,link)</b> pairs. The <b>BtreeIndex</b> iterator contains the page ID and slot number of the key it represents. Deleting an item in the <b>IndexedFile</b> means deleting the key in the <b>BtreeIndex</b>. In turn, that would cause all the keys with slot numbers higher than the current key on its page to shift down one slot, invalidating all iterators that refer to those keys. Furthermore, if the page gets consolidated, then all the iterators for one page will be invalidated. While not all iterators would be invalidated by a deletion, it didn't seem possible to present a useful algorithm for determining which iterators would still be valid, and which would not. So I simply noted that all iterators should be considered invalid after a deletion.</p> 
<p>My friend remarked that an alternative might be to simply mark the removed item as &quot;dead&quot; and leave it in the file. This would allow iterators to remain valid across deletions, but would require that the file be compacted periodically to get rid of the dead items. I noted that such an approach would solve only the problem with deletions, I would still have a problem whenever a new item was added to <b>IndexedFile</b> and a new key had to be inserted into the index. At this point, the conversation turned to other topics.</p> 
<p>Afterward, I spent some time thinking about my friend's question. If you are familiar with the associative containers of the Standard C++ library (and I hope you are), then you know that one of the features of those containers (and <b>list</b>) is that their iterators remain valid over insertions and deletions (except for the iterator of a deleted item, of course). I have actually designed code that exploited this fact <a href="#3">[3]</a>. I wondered how important it might be for an <b>IndexedFile</b> class to have the same type of behavior. The truth is, I do not have any idea. Since I do not have any real project experience with <b>IndexedFile</b> yet, I do not have any idea about what might turn out to be important details. The fact that my friend had asked the question, however, seemed to indicate that the issue could be important, at least in some circumstances.</p> 
<p>So I thought about what changes I would need to make to the design of <b>IndexedFile</b> in order to ensure that iterators into the file remained valid across insertions and deletions. It is said that all problems in computer science can be solved by another level of indirection, and I was pretty sure this was one of them. I fairly quickly realized that the <i>data</i> file portion of my <b>IndexedFile</b> already had the right properties. I never try to reclaim space in the data file &#151; new items are always added at the end. This means the file has to be compacted periodically, but there is a member function to do just that. If an <b>IndexedFile</b> iterator contained the actual <b>(key,link)</b> that referenced the item in the data file, instead of containing a <b>BtreeIndex</b> iterator, then that iterator would remain valid until the file was compacted, or the item was deleted.</p> 
<p>Adopting this change, however, opened up all kinds of other considerations. First, the iterator would now have to carry the actual key value. I had decided early on that I did not want my <b>BtreeIndex</b> iterator carrying the actual key value, and the same reasoning applies to the <b>IndexedFile</b> iterator. Iterators are supposed to be lightweight objects (in some intuitive sense). In particular, iterators are usually passed by value and are often copied or assigned one to another. Now consider the simple case where the key is a <b>string</b>. Many standard library implementations provide a reference counted <b>string </b>class, but they are not required to do so. The only portable assumption has to be that if <b>key</b> is a <b>string</b>, then copying an iterator containing such a key would involve copying the <b>string</b> data as well. Since <b>string</b>s can vary in size, this probably means doing a free store allocation. At this point, the supposedly lightweight object is demonstrating some pretty heavy behavior. I had no illusions that <b>IndexedFile</b> iterators (or <b>BtreeIndex</b> iterators) would meet the requirements specified in the Standard for true STL iterators, but I did not want to gratuitously mess with their behavior either, so I was reluctant to have iterators carry actual keys.</p> 
<p>If I did not want the iterator to carry the key, then I could go back to where I started. In my original plans for <b>IndexedFile</b>, I envisioned it storing just items, where each item would contain its own key, and the user would have to provide a functor that would extract the key from the item. I had changed to the present idea where keys and items were separate because it seemed more flexible in the long run.</p>
<p>Another aspect that would change (<b>IndexedFile</b> iterators are not based upon the <b>BtreeIndex</b> iterators) was how to actually increment the iterator. Incrementing a <b>BtreeIndex</b> iterator is fairly straightforward: just increment the slot number and then check to see if you have run off the page. Since the pages at a given level in the index tree are linked together, running off the page means using the first slot of the next page. (Note that you do not have to actually access the next page in this case; it is sufficient to know that it exists.) Incrementing an <b>IndexedFile</b> iterator that does not contain the <b>BtreeIndex</b> iterator first involves finding the corresponding <b>BtreeIndex</b> iterator, which would mean searching the index for the corresponding <b>(key,link)</b> pair. (Here we see that extra level of indirection that was mentioned above.) Like having the iterator carry the key value, doing it this way would seem to add another extra layer of complexity onto what is typically a fairly lightweight iterator operation. Also, I should mention that my current design calls for an <b>IndexedFile</b> to support non-unique keys (like a <b>multimap</b>). Searching an index with multiple identical keys for a specific entry would technically be an <b>O(n)</b> operation over the number of identical keys that had to be searched. If I were to restrict <b>IndexedFile</b> to unique keys, then incrementing an iterator and doing a find by key would be basically the same operation.</p>
<p>So the question of how important it is to have iterators remain valid across insertions and deletions means answering other questions such as how important is being able to support non-unique keys, how important is being able to efficiently copy iterators, and how important is it that sequential access be more efficient than keyed access. I spent some time thinking about all of this without reaching any conclusions &#151; at least not yet.</p> 
<p>Now let me turn to the actual implementation and look at some other issues. I implemented the <b>BtreeIndex</b> class and <b>IndexedFile</b> over a couple of long weekends. When I first started testing, I promptly discovered that my interface was inadequate in terms of error handling. I expected <b>IndexedFile</b> to have a simple file-like interface, so it had operations like <b>open</b> and <b>close</b>. Unfortunately, since I did not derive <b>IndexedFile</b> from class <b>XDR_Stream</b>, it did not inherit the base class' interface to the file status information. So, I quickly added that. </p> 
<p>Next, I discovered that I had a problem with the IOStreams <b>openmode</b>. The <b>IndexedFile</b> <b>open</b> function accepts an <b>openmode</b> parameter that is the same as for IOStreams. This parameter is passed through unchanged to the <b>open</b> function for the <i>data</i> file, but having an <i>index</i> file opened with a mode of <b>out</b> does not make a lot sense (i.e., even if you are just adding items to the <i>index</i> you have to be able to read the file). So, internally, I always added <b>in</b> to the <b>openmode</b> for the <i>index</i> file. Unfortunately, the IOStreams requirements state that if you open a file for <b>in</b> or <b>in|out</b>, then the file must exist. If the file does not exist, then the open fails. Not only does this cause a problem for the <i>index</i>, but it seemed reasonable to me that many times someone might want to both create a new <b>IndexedFile</b> and then use it immediately for retrieval. With the standard IOStreams interpretation of <b>openmode</b>, you first have to open a file with mode <b>== out</b> to guarantee that it gets created if it does not exist and then close the file and reopen it with mode <b>== in|out</b> to be able to both write to it and read from it. I could handle the problem for the <i>index</i> file internally (which I do), but I wondered about trying to change the behavior for the overall <b>IndexedFile</b> class. I thought briefly about just eliminating the <b>openmode</b> parameter. If I did that, then an <b>IndexedFile</b> would always be opened for both reading and writing, and a new one would be created if it did not exist. I rejected that idea because I wanted to keep some type of <b>openmode </b>just to be able to open an <b>IndexedFile</b> in read-only mode. </p> 
<p>Next, I wondered if I should not just go ahead and create a file if one did not exist when an <b>openmode</b> of <b>in|out</b> was specified. This would have been a change from the documented, standard behavior for <b>openmode</b>, however, and I am very reluctant to change standard behavior &#151; even to make it better. I decided, for now, to keep the behavior of <b>openmode</b> the way it is specified in the Standard. </p> 
<p>Finally, let me toss out a couple of truly internal implementation issues. One of my pet peeves about many of the object-oriented designs that I have reviewed as a consultant is that they often have reasonably good high-level abstractions, but seem to be implemented in C for all practical purposes. In other words, there are no intermediate abstractions in the implementation. Naturally, my <b>IndexedFile</b> implementation is based upon several intermediate classes. One obvious internal class of <b>BtreeIndex</b> is class <b>Page</b>. Briefly recall that a <b>BtreeIndex</b> consists of fixed-size <i>pages</i> that are stored in the external file. Each such page contains some number of keys and links to other pages. Since my external file was an <b>XDRStream</b>, my actual <b>Page</b> class does not look exactly like its external representation, but is instead an abstraction that can be written to or read from the external file by the appropriate <b>XDRStream</b> insert or extract functions. In typical object-oriented fashion, these <b>XDRStream</b> functions are member functions of class <b>Page</b>.</p> 
<p>There is also a <b>RootPage</b> class. <b>RootPage</b> is a different class because it contains some different information than an ordinary <b>Page</b>. Nevertheless, it also contains some of the same information, so class <b>RootPage</b> derives from <b>Page</b>. This allows the root page to be passed like an ordinary page to functions that recursively search the tree. Again, in typical object-oriented fashion, the insertion and extractor functions of <b>Page</b> are virtual and are overridden by class <b>RootPage</b>. </p>
<p>Besides being able to transfer the class' data to and from the external representation, class <b>Page</b> also provides a function to insert a new <b>(key,link)</b> pair into the page. Again, this seems like a perfectly reasonable object-oriented design. But now it gets tricky. When a page is full, attempting to insert a new key should cause the existing page to be split into two new pages. Additionally, a link to the new page must be inserted into the parent of the original page. Of course, if the root page is split, a new root page must be created and links to both of the existing pages inserted into it. Traditional object-oriented design would say that a <b>Page</b> should be able to tell if it was full or not and know how to split itself if required. Originally, that is what I planned to do, but I ran into a few problems. </p> 
<p>Unlike the <i>data</i> file, the <i>index</i> attempts to reuse empty pages rather than just always creating a new page. These empty pages are held in a link list chained off the root page. So first, splitting a page requires checking to see if there are any existing free pages available, which means accessing the root page. </p> 
<p>Then there is the problem of the page cache. From the very beginning, I knew that <b>BtreeIndex</b> would have a cache of recently read pages. This was essential for any kind of reasonable performance. Specifically, I did not want a find operation to read one or more pages into memory in order to locate a key, return an iterator to that key, and then have the dereference operation of the iterator re-read the same pages into memory. So, all requests for a page (other than for a new page) go through the page cache. Naturally, the <b>PageCache</b> is also a class. Besides being responsible for fetching pages from external storage when they are not in the cache, class <b>PageCache</b> also is responsible for making sure that internal pages are flushed back to external storage and then deleted when they fall out of the cache. When a page is split, if the new page is taken from the empty list, then that page is retrieved via the cache by requesting it via its page ID. If a new page is created however, then somehow the new page needs to be given back to the cache so that it can be managed properly from then on. </p> 
<p>Finally, there is the question of how to take care of inserting the link to the new page into the parent page. Of the three things I have mentioned so far, this is the only one I had really thought about before I started doing the implementation. I figured it was simple; each page would just contain a link to its parent. I gave up this idea rather quickly when I realized that splitting a parent would require accessing half the pages linked from that page in order to update their parent links. Given that I expected a typical page to contain 100 or more links when it was full, this did not seem like such a good idea. Without a link to its parent, however, there is no way a page can completely handle the case where it needs to split itself. </p> 
<p>After playing with several options (there are limits to even what a columnist might present), I settled on the following functionality. </p>

<OL>
<LI><b>Page</b> provides a function named <b>must_split</b>. This returns a boolean to indicate whether the page is overfull or not. It is up to the upper-layer <b>BtreeIndex</b> function to call this function whenever it has performed an operation (such as inserting a new key) that could cause the <b>Page</b> to become overfull.</LI>
<LI><b>Page</b> provides a <b>split</b> function. This is a virtual function since the <b>RootPage</b> split is different than for a regular <b>Page</b>. This function takes a pointer to the <b>BtreeIndex</b> class itself. That allows it to access the <b>get_free_page</b> function of <b>BtreeIndex</b> that will return an empty page, either from the free list maintained in the root page, or by creating a new page from the free store.</LI>
<LI>The <b>get_free_page</b> function will call the <b>PageCache::add_page</b> function if it has to create a new page.</LI>
<LI>The <b>split</b> function returns the pointer to the new page to the calling function, which is responsible for seeing that it gets inserted into the parent page.</LI>
</OL>
<p>If all of the issues I have discussed above are not perfectly clear, do not worry about it. The point of this column was not the details of this design. Instead, the whole point of this column was to set the stage for me to drag out one of my standard soapboxes. My desire to do this was triggered by two recent events: first, Dr. Robert Martin offered to reprint in his upcoming book an article I wrote back in 1992 titled &quot;What is Software Design?&quot; <a href="#4">[4]</a>. My argument in that article was that <i>the source code is the design.</i> The second event in this chain was a presentation that I recently saw by Ivar Jacobson about future trends in software. In that presentation, Dr. Jacobson argued for &quot;UML all the way down.&quot; I agree with a lot of Dr. Jacobson's dreams, but this one I have a problem with.</p>
<p>What I have tried to do in this column is present just a few of the typical considerations that often go into any type of design effort. The issue about the lifetime of iterators is a fundamental aspect of the class's design, yet where would it have turned up in any type of typical design documentation. Maybe, if this class design had been part of a formal project, with the typical requirements for design documents and reviews, the question would have been raised early. Certainly, I think that if someone with my friend's level of experience had been involved, it probably would have been. But that is itself a problem. My friend has literally several decades worth of experience. How often does the typical design review actually have participants that have that kind of relevant background? </p> 
<p>The issue about needing the interface to provide functions allowing the underlying file status to be checked probably should have been caught by me. But I didn't catch it until I actually had the entire class implemented and started testing. Again, if this had been part of the typical &quot;first we do a design and freeze it, then we code&quot; type of project, would this oversight have been caught earlier? I do not know, but my own feeling is that if I didn't catch it, I would have to say the odds were probably less than 50/50 that anyone else would either.</p> 
<p>Finally, the issues that came up with what interface the <b>Page</b> class needed in order to provide a reasonable abstraction supporting the splitting of pages while at the same time keeping the <b>Page</b> class reasonably self-contained are ones that I defy just about anyone to anticipate without actually getting into implementing the code to do a page split. As I noted above, I had thought about one aspect of the functionality &#151; the need to insert a new reference into a parent &#151; but I got even that wrong.</p> 
<p>And the point of all this? The point is that what I wrote in 1992 seems even more true to me today than it did back then: the source code is the design. Designing software is tough. Maybe there are a few Mozart-like geniuses out there that can see an entire design in their head before they write one line of code, but for the vast majority of us, designing software is a continuous feedback loop of discovery and refinement. In other words, designing software and implementing software are the same thing. In the grand scheme of things, <b>IndexedFile</b> is not that big of a class. If I can come up with so many different issues during the implementation of a relatively small piece of software, what is the reality for large-scale systems?</p> 
<p>It may be true that something like UML can represent 80% of the code in a software module (this is Jacobson's figure &#151; not mine). However, that remaining 20% is not only critical to the functioning of the software, but I contend that until you actually do that 20% your other 80% is nothing more than a preliminary guess. It is not unusual for that last 20% to cause a 100% rewrite of the other 80%. Even under good circumstances, figuring out that last 20% is likely to change at least 20% of the other 80%. At the end of my &quot;What Is Software Design?&quot; article, I noted that what we really need in the software industry is more expressive programming languages. I noted that C++ was a step in the right direction, but only a step. Instead of Dr. Jacobson's &quot;UML all the way down,&quot; what I really think we need is a programming language X that is both powerful and flexible enough that we can say &quot;X all the way up.&quot; In the meantime, we will have to make do with what we have, and I still think C++ is a pretty good choice.</p> 

<H3><FONT COLOR="#000080">Notes</FONT></H3>

<p><a name="1"></a>[1] Jack Reeves. &quot;The (B)Leading Edge: Building an Indexed File Class using <b>XDR_Stream</b>,&quot; <i>C/C++ User's Journal C++ Experts Forum</i>, March 2002, &lt;www.cuj.com/experts/2003/reeves.htm&gt;.</p>
<p><a name="2"></a>[2] Jack Reeves. &quot;The (B)Leading Edge: Using the <b>XDR_Stream</b> Class, Part II&quot;, <i>C/C++ User's Journal C++ Experts Forum</i>, November 2001, &lt;www.cuj.com/experts/1911/reeves.htm&gt;.</p>
<p><a name="3"></a>[3] Jack Reeves. &quot;The (B)Leading Edge: Simple Memory Management Classes,&quot; <i>C++ Report</i>, July 2000.</p>
<p><a name="4"></a>[4] Jack Reeves. &quot;What is Software Design?&quot; <i>The C++ Journal</i>, July 1992.</p>

<p><i><B>Jack W. Reeves</b> is an engineer and consultant specializing in object-oriented software design and implementation. His background includes Space Shuttle simulators, military CCCI systems, medical imaging systems, financial data systems, and numerous middleware and low-level libraries. He currently is living and working in Europe and can be contacted via <b>jack_reeves@bleading-edge.com</b>.</p>

</BLOCKQUOTE></BODY></HTML>
