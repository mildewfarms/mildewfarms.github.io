<HTML>   
     <HEAD>
<TITLE>May 2002/The Boost.Threads Library</TITLE></HEAD>
<BODY BACKGROUND="" BGCOLOR="#FFFFFF" TEXT="#000000">
<H2><A HREF="../tocmay.htm"></A><FONT COLOR="#FF0000">   Multithreading</FONT></H2>

<HR>

<H2 ALIGN="center"><FONT COLOR="#800000">The Boost.Threads Library</FONT></H2>
<H3 ALIGN="center"><FONT COLOR="#800000">Bill Kempf</FONT></H3>

<BLOCKQUOTE>
<p>Standard C++ threads are imminent. CUJ predicts they will derive from the Boost.Threads library, explored here by the eminent author.</p>
</BLOCKQUOTE>

<HR>
<BLOCKQUOTE>
<p>Just a few years ago it was uncommon for a program to be written with multiple threads of execution. Today Internet server applications run multiple threads of execution to efficiently handle multiple client connections. To maximize throughput, transaction servers execute services on separate threads. GUI applications perform lengthy operations in a separate thread to keep the user interface responsive. The list goes on.</p>
<p>The C++ Standard doesn&#146;t mention threads, leaving programmers to wonder whether it&#146;s even possible to write multithreaded C++ programs. Though it is not possible to write standards-compliant multithreaded programs, programmers none the less write multithreaded programs in C++ using the libraries provided by their OS that expose the system&#146;s support for threads. However, there are at least two major problems with doing this: these libraries are almost universally C libraries and require careful use in C++, and each OS provides its own set of libraries for handling multithreaded support. Therefore, the resulting code is not only non-standard, but also non-portable <a href="#1">[1]</a>. Boost.Threads is a library designed to address both problems.</p>
<p>Boost <a href="#2">[2]</a> is an organization started by members of the C++ Standards Committee Library Working Group to develop new source libraries for C++. Its current membership includes approximately 2,000 members. Many libraries can be found in the Boost source distribution <a href="#3">[3]</a>. To make these libraries thread-safe, Boost.Threads was created.</p>
<p>Many C++ experts provided input to the design of Boost.Threads. The interface was designed from the ground up and is not just a simple wrapper around any C threading API. Many features of C++ (such as the existence of constructors/destructors, function objects, and templates) were fully utilized to make the interface more flexible. The current implementation works for POSIX, Win32, and Macintosh Carbon platforms.</p>

<H3><FONT COLOR="#000080">Thread Creation</FONT></H3>

<p>The <B>boost::thread</B> class represents a thread of execution in the same way the <B>std::fstream</B> class represents a file. The default constructor creates an instance representing the current thread of execution. An overloaded constructor takes a function object called with no arguments and returning nothing. This constructor starts a new thread of execution, which in turn calls the function object.</p>
<p>At first it appears that this design is less useful than the typical C approach to creating a thread where a <B>void</B> pointer can be passed to the routine called by the new thread, which allows data to be passed. However, because Boost.Threads uses a function object instead of just a function pointer, it is possible for the function object to carry data needed by the thread. This approach is actually more flexible and is type safe. When combined with functional libraries, such as Boost.Bind, this design actually allows you to easily pass any amount of data to the newly created thread.</p>
<p>Currently, not a lot can be done with a thread object created in Boost.Threads. In fact only two operations can be performed. Thread objects can easily be compared for equality or inequality using the <B>==</B> and <B>!=</B> operators to verify if they refer to the same thread of execution, and you can wait for a thread to complete by calling <B>boost::thread::join</B>. Other threading libraries allow you to perform other operations with a thread (for example, set its priority or even cancel it). However, because these operations don&#146;t easily map into portable interfaces, research is being done to determine how they can be added to Boost.Threads.</p>
<p><a href="list1.htm">Listing 1</a> illustrates a very simple use of the <B>boost::thread</B> class. A new thread is created that simply writes &#147;Hello World&#148; out to <B>std::cout</B>, while the <B>main</B> thread waits for it to complete.</p>

<H3><FONT COLOR="#000080">Mutexes</FONT></H3>

<p>Anyone who has written a multithreaded program understands how critical it is for multiple threads not to access shared resources at the same time. If one thread tries to change the value of shared data at the same time as another thread tries to read the value, the result is undefined behavior. To prevent this from happening, make use of some special primitive types and operations. The most fundamental of these types is known as a mutex (the abbreviation for &#147;mutual exclusion&#148;). A mutex allows only a single thread access to a shared resource at one time. When a thread needs to access the shared resource, it must first &#147;lock&#148; the mutex. If any other thread has already locked the mutex, this operation waits for the other thread to unlock the mutex first, thus ensuring that only a single thread has access to the shared resource at a time.</p>
<p>The mutex concept has several variations. Two large categories of mutexes that Boost.Threads supports include the simple mutex and the recursive mutex. A simple mutex can only be locked once. If the same thread tries to lock a mutex twice, it deadlocks, which indicates that the thread will wait forever. With a recursive mutex, a single thread may lock a mutex several times and must unlock the mutex the same number of times to allow another thread to lock the mutex.</p>
<p>Within these two broad categories of mutexes, there are other variations on how a thread can lock the mutex. A thread may attempt to lock a mutex in three ways:</p>

<OL><LI>Try and lock the mutex by waiting until no other thread has the mutex locked.</LI>
<LI>Try and lock the mutex by returning immediately if any other thread has the mutex locked.</LI>
<LI>Try and lock the mutex by waiting until no other thread has the mutex locked or until a specified amount of time has elapsed.</LI></OL>

<p>It appears that the best possible mutex type is a recursive type that allows all three forms of locking. However, overhead is involved with each variation, so Boost.Threads allows you to pick the most efficient mutex type for your specific needs. This leaves Boost.Threads with six mutex types, listed in order of preference based on efficiency: <B>boost::mutex</B>, <B>boost::try_mutex</B>, <B>boost::timed_mutex</B>, <B>boost::recursive_mutex</B>, <B>boost::recursive_try_mutex</B>, and <B>boost::recursive_timed_mutex</B>.</p>
<p>Deadlock may occur if every time a mutex is locked it is not subsequently unlocked. This is the most common possible error, so Boost.Threads is designed to make this impossible (or at least very difficult). No direct access to operations for locking and unlocking any of the mutex types is available. Instead, mutex classes define nested <B>typedef</B>s for types that implement the RAII (Resource Acquisition in Initialization) idiom for locking and unlocking a mutex. This is known as the Scoped Lock <a href="#4">[4]</a> pattern. To construct one of these types, pass in a reference to a mutex. The constructor locks the mutex and the destructor unlocks it. C++ language rules ensure the destructor will always be called, so even when an exception is thrown, the mutex will always be unlocked properly.</p>
<p>This pattern helps to ensure proper usage of a mutex. However, be aware that although the Scoped Lock pattern ensures that the mutex is unlocked, it does not ensure that any shared resources remain in a valid state if an exception is thrown; so just as with programming for a single thread of execution, ensure that exceptions don&#146;t leave the program in an inconsistent state. Also, the locking objects must not be passed to another thread, as they maintain state that&#146;s not protected from such usage.</p>
<p><a href="list2.htm">Listing 2</a> illustrates a very simple use of the <B>boost::mutex</B> class. Two new threads are created, which loop 10 times, writing out an <B>id</B> and the current loop count to <B>std::cout</B>, while the <B>main</B> thread waits for both to complete. The <B>std::cout</B> object is a shared resource, so each thread uses a global mutex to ensure that only one thread at a time attempts to write to it.</p>
<p>Many users will note that passing data to the thread in <a href="list2.htm">Listing 2</a> required writing a function object by hand. Although the code is trivial, it can be tedious writing this code every time. There is an easier solution, however. Functional libraries allow you to create new function objects by binding another function object with data that will be passed to it when called. <a href="list3.htm">Listing 3</a> shows how the Boost.Bind library can be used to simplify the code from <a href="list2.htm">Listing 2</a> by removing the need for a hand-coded function object.</p>

<H3><FONT COLOR="#000080">Condition Variables</FONT></H3>

<p>Sometimes it&#146;s not enough to lock a shared resource and use it. Sometimes the shared resource needs to be in some specific state before it can be used. For example, a thread may try and pull data off of a stack, waiting for data to arrive if none is present. A mutex is not enough to allow for this type of synchronization. Another synchronization type, known as a condition variable, can be used in this case.</p>
<p>A condition variable is always used in conjunction with a mutex and the shared resource(s). A thread first locks the mutex and then verifies that the shared resource is in a state that can be safely used in the manner needed. If it&#146;s not in the state needed, the thread waits on the condition variable. This operation causes the mutex to be unlocked during the wait so that another thread can actually change the state of the shared resource. It also ensures that the mutex is locked when the thread returns from the wait operation. When another thread changes the state of the shared resource, it needs to notify the threads that may be waiting on the condition variable, enabling them to return from the wait operation.</p>
<p><a href="list4.htm">Listing 4</a> illustrates a very simple use of the <B>boost::condition</B> class. A class is defined implementing a bounded buffer, a container with a fixed size allowing FIFO input and output. This buffer is made thread-safe internally through the use of a <B>boost::mutex</B>. The <B>put</B> and <B>get</B> operations use a condition variable to ensure that a thread waits for the buffer to be in the state needed to complete the operation. Two threads are created, one that puts 100 integers into this buffer and the other pulling the integers back out. The bounded buffer can only hold 10 integers at one time, so the two threads wait for the other thread periodically. To verify that it is happening, the <B>put</B> and <B>get</B> operations output diagnostic strings to <B>std::cout</B>. Finally, the <B>main</B> thread waits for both threads to complete.</p>

<H3><FONT COLOR="#000080">Thread Local Storage</FONT></H3>

<p>Many functions are not implemented to be reentrant. This means that it is unsafe to call the function while another thread is calling the same function. A non-reentrant function holds static data over successive calls or returns a pointer to static data. For example, <B>std::strtok</B> is not reentrant because it uses static data to hold the string to be broken into tokens.</p>
<p>A non-reentrant function can be made into a reentrant function using two approaches. One approach is to change the interface so that the function takes a pointer or reference to a data type that can be used in place of the static data previously used. For example, POSIX defines <B>strtok_r</B>, a reentrant variant of <B>std::strtok</B>, which takes an extra <B>char**</B> parameter that&#146;s used instead of static data. This solution is simple and gives the best possible performance; however, it means changing the public interface, which potentially means changing a lot of code. The other approach leaves the public interface as is and replaces the static data with thread local storage (sometimes referred to as thread-specific storage).</p>
<p>Thread local storage is data that&#146;s associated with a specific thread (the current thread). Multithreading libraries give access to thread local storage through an interface that allows access to the current thread&#146;s instance of the data. Every thread gets its own instance of this data, so there&#146;s never an issue with concurrent access. However, access to thread local storage is slower than access to static or local data; therefore it&#146;s not always the best solution. However, it&#146;s the only solution available when it&#146;s essential not to change the public interface.</p>
<p>Boost.Threads provides access to thread local storage through the smart pointer <B>boost::thread_specific_ptr</B>. The first time every thread tries to access an instance of this smart pointer, it has a <B>NULL</B> value, so code should be written to check for this and initialize the pointer on first use. The Boost.Threads library ensures that the data stored in thread local storage is cleaned up when the thread exits.</p>
<p><a href="list5.htm">Listing 5</a> illustrates a very simple use of the <B>boost::thread_specific_ptr</B> class. Two new threads are created to initialize the thread local storage and then loop 10 times incrementing the integer contained in the smart pointer and writing the result to <B>std::cout</B> (which is synchronized with a mutex because it is a shared resource). The <B>main</B> thread then waits for these two threads to complete. The output of this example clearly shows that each thread is operating on its own instance of data, even though both are using the same <B>boost::thread_specific_ptr</B>.</p>

<H3><FONT COLOR="#000080">Once Routines</FONT></H3>

<p>There&#146;s one issue left to deal with: how to make initialization routines (such as constructors) thread-safe. For example, when a &#147;global&#148; instance of an object is created as a singleton for an application, knowing that there&#146;s an issue with the order of instantiation, a function is used that returns a static instance, ensuring the static instance is created the first time the method is called. The problem here is that if multiple threads call this function at the same time, the constructor for the static instance may be called multiple times as well, with disastrous results.</p>
<p>The solution to this problem is what&#146;s known as a &#147;once routine.&#148; A once routine is called only once by an application. If multiple threads try to call the routine at the same time, only one actually is able to do so while all others wait until that thread has finished executing the routine. To ensure that it is executed only once, the routine is called indirectly by another function that&#146;s passed a pointer to the routine and a reference to a special flag type used to check if the routine has been called yet. This flag is initialized using static initialization, which ensures that it is initialized at compile time and not run time. Therefore, it is not subject to multithreaded initialization problems. Boost.Threads provides calling once routines through <B>boost::call_once</B> and also defines the flag type <B>boost::once_flag</B> and a special macro used to statically initialize the flag named <B>BOOST_ONCE_INIT</B>.</p>
<p><a href="list6.htm">Listing 6</a> illustrates a very simple use of <B>boost::call_once</B>. A global integer is statically initialized to zero and an instance of <B>boost::once_flag</B> is statically initialized using <B>BOOST_ONCE_INIT</B>. Then <B>main</B> starts two threads, both trying to &#147;initialize&#148; the global integer by calling <B>boost::call_once</B> with a pointer to a function that increments the integer. Next <B>main</B> waits for these two threads to complete and writes out the final value of the integer to <B>std::cout</B>. The output illustrates that the routine truly was only called once because the value of the integer is only one.</p>

<H3><FONT COLOR="#000080">The Future of Boost.Threads</FONT></H3>

<p>There are several additional features planned for Boost.Threads. There will be a <B>boost::read_write_mutex</B>, which will allow multiple threads to read from the shared resource at the same time, but will ensure exclusive access to any threads writing to the shared resource. There will also be a <B>boost::thread_barrier</B>, which will make a set of threads wait until all threads have &#147;entered&#148; the barrier. A <B>boost::thread_pool</B> is also planned to allow for short routines to be executed asynchronously without the need to create or destroy a thread each time.</p>
<p>Boost.Threads has been presented to the C++ Standards Committee&#146;s Library Working Group for possible inclusion in the Standard&#146;s upcoming Library Technical Report, as a prelude to inclusion in the next version of the Standard. The committee may consider other threading libraries; however, they viewed the initial presentation of Boost.Threads favorably, and they are very interested in adding some support for multithreaded programming to the Standard. So, the future is looking good for multithreaded programming in C++.</p>

<H3><FONT COLOR="#000080">Notes</FONT></H3>

<p><a name="1"></a>[1]  The POSIX standard defines multithreaded support in what&#146;s commonly known as the pthread library. This provides multithreaded support for a wide range of operating systems, including Win32 through the pthreads-win32 port. However, this is a C library that fails to address some C++ concepts and is not available on all platforms.</p>
<p><a name="2"></a>[2]  Visit the Boost website at &lt;http://www.boost.org&gt;.</p>
<p><a name="3"></a>[3]  See Bjorn Karlsson&#146;s article, &#147;Smart Pointers in Boost,&#148; in <I>C/C++ Users Journal</I>, April 2002.</p>
<p><a name="4"></a>[4]  Douglas Schmidt, Michael Stal, Hans Rohnert, and Frank Buschmann. <I>Pattern-Oriented Software Architecture Volume 2 </I>&#151;<I> Patterns for Concurrent and Networked Objects</I> (Wiley, 2000). </p>

<p><i><B>William E. Kempf</B> received his BS in CompSci/Math from Doane College. He&#146;s been in the industry for 10 years and is currently a senior application developer for First Data Resources, Inc. He is the author of the Boost.Threads library, and an active Boost member. He can be contacted at <B>wekempf@cox.net</B>.</i></p>

<h4><a href="../../../source/2002/may02/kempf.zip"></a></h4>
</blockquote></body></html>
