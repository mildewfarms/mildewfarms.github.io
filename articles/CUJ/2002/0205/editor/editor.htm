<HTML>   
     <HEAD>
<TITLE>May 2002/Editor's Forum</TITLE></HEAD>
<BODY BACKGROUND="" BGCOLOR="#FFFFFF" TEXT="#000000">
<H2><A HREF="../tocmay.htm"></A><FONT COLOR="#FF0000">   Departments</FONT></H2>

<HR>

<H2 ALIGN="center"><FONT COLOR="#800000">Editor's Forum</FONT></H2>

<HR>
<BLOCKQUOTE>

<H3><FONT COLOR="#000080">Is Portability Still Important?</FONT></H3>

<p>I suppose it depends on what you mean by &#147;portability.&#148; The ability to take code to other platforms was once a cherished freedom. If another vendor&#146;s hardware was faster, or a new compiler generated better code, you wanted to go there.</p>
<p>Before C things weren&#146;t so easy, of course. Yes, there were standards in place, such as ANSI FORTRAN, but building real-world software systems often required using non-standard features, especially for I/O. Besides, in those days, hardware was large and astronomically pricey, so companies were usually tethered to a single hardware vendor or service provider. Indeed, compilers were developed by the hardware vendors, who had no interest in enabling customers to leave the fold.</p>
<p>The relative affordability of mid-range computers and the attendant proliferation of Unix installations in the 70s and 80s broke the Big Iron shackles and had an influence on the design of C. In the C community, in fact, portability became a way of life. Every seasoned C developer was accustomed to using <B>typedef</B>s and conditional compilation without much conscious effort. It was just the way things were done.</p>
<p><I>CUJ</I> had its beginnings in the days of online bulletin boards frequented by microcomputer owners who were reaping the benefits of C&#146;s support for portable code. You could dial up the C Users Group server, download C source for your favorite software tool or game, run it through your compiler (very likely not the one the author used), and presto! You were up and running with a new editor (remember MicroEmacs?) or text formatter (<B>nroff</B>, for example). I had the same tool set at work on the Vax as I had at home on my 8086, and the only price I had to pay was to change a <B>#define</B> or two before compiling.</p>
<p>As users came to demand more of their applications, the OS shackles clamped on again, since the most popular requests, graphics and threading, are by nature platform dependent. A small number of cross-platform GUI libraries popped up, but they didn&#146;t last long. POSIX threads gave cross-platform portability to the Unix world, but that&#146;s not as big a world as it used to be. (See Bill Kempf&#146;s excellent article on Boost.Threads in this issue for a threading library that ports to Win32, POSIX, and the MacIntosh.)</p>
<p>And then came Java. By placing support for threads and graphics in the virtual machine, your GUIs and multithreaded applications could go anywhere the JVM could take them. No solution is perfect, of course, and there are those who think that Java&#146;s threading model leaves a lot to be desired, but no matter &#151; much of Java&#146;s appeal is its OS independence.</p>
<p>But that&#146;s not the point, really. Too many of us seem to forget what prompted the portability concept in the first place. It wasn&#146;t just about compiler independence, nor platform independence, as nice as they are. It was about not being dependent upon one particular <I>company</I>, whether it&#146;s their hardware, operating system, or virtual platform. The shackles of monopoly are certainly the most insidious of all. Part of the appeal of C and C++ is that they are non-proprietary. You can be sure that ISO C and C++ will stay that way, and that C++0x will include features, like portable threads, that will aid you in your fight for independence.</p>
<p>Chuck Allison<br>
Senior Editor<br>
<B>cda@freshsources.com</B></p>
</blockquote></body></html>
