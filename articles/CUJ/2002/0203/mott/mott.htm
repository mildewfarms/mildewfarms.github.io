<HTML>   
     <HEAD>
<TITLE>March 2002/Writing KDE Applications</TITLE></HEAD>
<BODY BACKGROUND="" BGCOLOR="#FFFFFF" TEXT="#000000">
<H2><A HREF="../tocmar.htm"></A><FONT COLOR="#FF0000">   Linux</FONT></H2>

<HR>

<H2 ALIGN="center"><FONT COLOR="#800000">Writing KDE Applications</FONT></H2>
<H3 ALIGN="center"><FONT COLOR="#800000">Jason Mott</FONT></H3>

<BLOCKQUOTE>
<p>The Linux desktop is maturing on schedule. Here&#146;s a look at developing event-driven GUI apps in KDE.</p>
</BLOCKQUOTE>

<HR>
<BLOCKQUOTE>
<p>If you need to write a desktop application in the Linux environment and your audience is the average user, look no further than KDE <a href="#1">[1]</a>. KDE is one of the most popular desktop environments on Linux. It is certainly the most mature and user friendly. The KDE API stands above its competitors for speed to market, quick learning curve, and overall great software design.</p>
<p>At the core of KDE is Qt, an API written by Trolltech (&lt;www.trolltech.com&gt;). KDE&#146;s API is written on top of Qt. This article does not focus on Qt itself. (Qt is practically its own high-level language with built-in tools and libraries.) Instead, this article focuses on Qt&#146;s unique approach to handling events and how a programmer can manage Qt events through the KDE interface. It is possible to develop applications using only Qt, but if Linux is your destination, I recommend using the KDE layer. Using KDE gives your application better integration with the Linux desktop. Some advantages of using KDE over Qt alone include giving your application drag-and-drop support with other KDE applications (and even some Gnome <a href="#2">[2]</a> applications), interprocess communication through KDE&#146;s DCOP (Desktop Communication Protocol), easy configuration saving and reading, and a consistent look-and-feel with other KDE applications.</p>
<p>To compile the examples in this article, you need to be running KDE with its included IDE, KDevelop. The examples in this article were developed and tested under KDE 2.2.1 using Qt 2.3.1 and KDevelop 2.0. I won&#146;t discuss the details of installing KDE and KDevelop. Please refer to &lt;www.kde.org&gt; and &lt;www.kdevelop.org&gt; for more information. Every popular Linux distribution comes with KDE and KDevelop, so you may also find information on installing KDE and KDevelop with your distribution&#146;s install disks. KDevelop includes a full reference for Qt and KDE classes. See KDevelop&#146;s online reference manual for more details on the APIs mentioned in this article.</p>

<H3><FONT COLOR="#000080">Background</FONT></H3>

<p>The KDE project began in October of 1996 when its founder, Matthias Ettrich, envisioned making a Unix desktop environment out of the Qt API. He developed KDE under the GPL (GNU Public License). The KDE team even eventually convinced Trolltech to release a GPL version of Qt. KDE runs on a number of different flavors of Unix and other operating systems, but Linux is its native home.</p>

<H3><FONT COLOR="#000080">KDevelop</FONT></H3>

<p>The example I&#146;ll be outlining will use KDevelop. KDevelop is a mature application that assists with developing KDE applications. It has a project tree, a syntax-highlighting text editor, and a full suite of wrappers for Linux&#146;s GNU compiling tools (<B>gcc</B>, <B>make</B>, <B>automake</B>, <B>autoconf</B>, etc.). In fact, when KDevelop creates a project, the project never needs KDevelop for building. It sets up everything to be buildable on the command line using the standard GNU tools mentioned above. When KDevelop starts, it runs through some setup and then provides a wizard for creating a project. If you don&#146;t get the wizard on startup, select &#147;Project -&gt; New&#148; from the menu bar. The first page of the wizard gives you several choices of applications. The main categories are KDE, Gnome, Qt, Terminal, and Others. As you can see, almost any C/C++ project can be developed with KDevelop. Under the KDE option, several sub-options exist. Each one is explained if you highlight the option. The first three (Mini, Normal, and MDI) are options that create a skeleton stand-alone KDE application. The Mini option is just a plain-Jane window to which you must add code to get anything. It doesn&#146;t come with anything unless you make additions. The Normal option is what you&#146;d usually use; it sets up a lot of stock code that gives you a menu bar, toolbar, and status bar. It also sets up some classes that use the Document-View design model. The MDI (Multiple Document Interface) option is for applications that will have inner windows. KDevelop itself is an example of MDI; you can have many text-editing windows open within the application&#146;s main window.</p>
<p>Once you&#146;re in KDevelop, you&#146;ll see that it has lots of build options, documentation browsing, and debugging options. The interface is pretty familiar if you&#146;ve used IDEs before. If you are new (and even if you&#146;re not), take the KDevelop tutorial (which will be a nice complement to this article). To take the tutorial, select &#147;Help -&gt; KDE Application Tutorials&#148; from the menu bar.</p>

<H3><FONT COLOR="#000080">Hello World!</FONT></H3>

<p>Enough set-up talk, it&#146;s code time! Assuming you&#146;re at your Linux desktop running KDE with all the aforementioned versions, fire up KDevelop. Select &#147;Project&#148; and choose &#147;New...&#148;. You&#146;ll notice the wizard has lots of great choices, and I encourage you to play with all of them. For the sake of simplicity, and to get going quickly with our first example, choose &#147;KDE 2 Mini&#148; for the type of application you want to build. I chose the Mini option because it has the least amount of skeleton code, and that makes it easier to focus on the &#147;slots and signals&#148; example I&#146;ll show in this article. If you want to keep consistent with this example, call the application &#147;HelloWorld&#148; and put it in /usr/local/src/cuj. This will give you a basic frame that will demonstrate the key features explained in this article (when the examples are completed).</p>
<p>When the wizard completes, you&#146;ll have a directory full of files and subdirectories. Fear not, you only need to worry about a few files in this example. The files that start with &#147;Makefile&#148; or &#147;conf&#148; are used by the GNU tools <B>make</B>, <B>automake</B>, and <B>autoconf</B>. Within the context of KDevelop, you never need to touch these files. The files named with all caps (INSTALL, TODO, AUTHORS, and COPYING) are files you can edit to give users of your source code information. The &#147;admin&#148; directory is where KDevelop stores all its internal-use files. The &#147;doc&#148; directory is where the application&#146;s documentation is stored. KDevelop offers some nice documentation creation tools (like <B>kdoc</B>) &#151; check out &#147;Project -&gt; Make API-Doc&#148; and &#147;Project -&gt; Make User-Manual&#148; in the menu bar. There will also be a directory named after the name of the application (&#147;helloworld&#148; in this example). This is the directory that holds the source code and is where most of the editing takes place. The files edited in this example (<B>main.cpp</B> and <B>helloworld.cpp</B>) are in this directory.</p>
<p><a href="list1.htm">Listing 1</a> shows the <B>main</B> function from <B>main.cpp</B>. There isn&#146;t much to it, but it sets up a very basic KDE application. (Note: there is a <B>KMainWindow</B> class that does even more for you before you get started. I&#146;ve omitted the <B>KMainWindow</B> class here for simplicity&#146;s sake. As a next step after you read this, I encourage you to browse the KDE documentation to learn more about <B>KMainWindow</B> and its many great features.) Lines 04-09 in <a href="list1.htm">Listing 1</a> set up a <B>KAboutData</B> object and register that application&#146;s arguments into a static method of the <B>KCmdLineArgs</B> class. After these calls, the arguments and about data can be accessed anytime in the application through static methods in <B>KCmdLineArgs</B>.</p>
<p>The <B>KApplication</B> class comes into play in line 11 of <a href="list1.htm">Listing 1</a>. <B>KApplication</B> is the granddaddy core of all KDE applications. It handles all the events from X (the Unix core GUI components, on which most Unix GUI&#146;s are built, including Qt&#146;s Linux version) and gives you access to fonts, theme options, and session management. <B>KApplication</B> does a lot of work for you behind the scenes. There isn&#146;t much you need to do with <B>KApplication</B> in this example except to tell it what its main widget is going to be. The main widget will display the interface of the application. KDevelop creates a skeleton main widget class called <B>HelloWorld</B> (because that is what I defined as the application&#146;s name). which is just a derived <B>QTWidget</B>. Once the <B>HelloWorld</B> class is created, it is up to the creator to make the class do anything. Later, I will add additional code to the <B>HelloWorld</B> class. I warn you, though; the example isn&#146;t pretty. It&#146;s only to demonstrate functionality.</p>

<H3><FONT COLOR="#000080">Slots and Signals</FONT></H3>

<p>Most GUI libraries handle events with callbacks. Callbacks are pointers to methods (or sometimes objects) that are registered with an event handler and called upon when some event happens. Events come in the form of user input (i.e., a mouse click or a keyboard press) or some other component wanting to &#147;announce&#148; something (i.e., a timer that has run out or state that has changed).</p>
<p>To deal with events, you create signals (the announcing of an event) and slots (methods that handle events), and you can connect any signal to any slot with the <B>connect</B> method present in all <B>QObject</B>s (of which your class must be a derivative to use slots and signals). One thing this example will not cover is signals and slots with arguments. When using arguments, you must make sure that the argument prototype of the signal is the same as the argument prototype of the slot.</p>
<p>To show you how to create signals and slots and how to connect them, I have made the <B>HelloWorld</B> application with a button called &#147;Count Button&#148; that increments a number below it and a button called &#147;Reset Button&#148; that resets the number to zero. When the counter reaches its maximum, the &#147;Count Button&#148; is disabled until the &#147;Reset Button&#148; is clicked.</p>
<p>As you will learn later in this article, Qt uses a pre-compiler, moc (Meta Object Compiler), that comes with Qt to manage callbacks for signals and slots. Until moc is explained, some of the code in this article will seem like incorrect C++ syntax, but don&#146;t worry. The moc pre-compiler standardizes the syntax by using macros and adding methods to your classes.</p>
<p>In the application you&#146;ve started in KDevelop, open up the file <B>helloworld.h</B>. <a href="list2.htm">Listing 2</a> is the <B>HelloWorld</B> class definition from <B>helloworld.h</B>. Add lines 03 and 10-23 to your code. The <B>Q_OBJECT</B> macro call is crucial to enabling slots and signals. Slots are just methods, but you tell moc they are slots by listing them under <B>public slots:</B>. As I will explain later, the &#147;incorrect syntax&#148; is corrected using the Standard C++ preprocessor. <a href="list2.htm">Listing 2</a> declares three slots that will be defined in <B>helloworld.cpp</B>. Signals are declared the same way, but under the label <B>signals:</B>, which is turned into <B>protected:</B> by the Standard C++ preprocessor.</p>
<p>For slots and signals to work, a <B>QMetaObject</B> must be created with moc. Without the benefit of KDevelop, you&#146;d need to run Qt&#146;s included pre-compiler moc on every header file that defines a <B>QObject</B>. moc creates an additional <B>.cpp</B> file that defines some extra methods in your class (which are declared in the <B>Q_OBJECT</B> macro as well as under the <B>signals:</B> label). The new file is usually named after the header file, but called <B>.moc.cpp</B> (e.g., <B>helloworld.h</B> produces a <B>helloworld.moc.cpp</B>). The actual name of the new file is defined with command-line options to moc, but in KDevelop this is all handled for you using the abovementioned naming convention. moc does not alter your header files; it just uses them to figure out what to put into the new <B>.moc.cpp</B> file. There should be one <B>.moc.cpp</B> file for each <B>.h</B> file that defines a class that uses slots and signals. moc also does not compile the generated <B>.moc.cpp</B> file. That can be done normally. KDevelop calls moc on your header files and compiles and links the new <B>.moc.cpp</B> files for you <a href="#3">[3]</a>.</p>
<p>Next, you have to define the slots and connect them to signals. You don&#146;t have to worry about defining signals, as moc defines those for you. All you have to do is &#147;emit&#148; them when you want to evoke an event. To see how to do this, open up <B>helloworld.cpp</B> and see <a href="list3.htm">Listing 3</a>, which shows the code you should add to define the slots. Remember these slots are really just regular methods and can be called as such if the need arises in your applications. As slots, though, they can be connected to signals via the <B>connect</B> method.</p>
<p>The buttons in this example are brought to life with the code in <a href="list4.htm">Listing 4</a>, which should be added to the <B>HelloWorld::HelloWorld(parent, name)</B> constructor in <B>helloworld.cpp</B>. Many slots and signals come built-in with KDE/Qt&#146;s classes. Buttons, for example, have a <B>clicked</B> signal that can be connected with any slot that doesn&#146;t take arguments. (Remember, slots can only be attached to signals whose prototype matches.) The <B>clicked</B> signal of buttons is what this example uses. See <a href="tab1.htm">Table 1</a> for an overview of the <B>QPushButton</B>&#146;s stock slots and signals.</p>
<p>As seen in <a href="list4.htm">Listing 4</a>, there are three widgets added to the <B>HelloWorld</B> main widget: two buttons and one label. Notice these are pointers, and the objects are created on the heap. It is important to do it this way, as Qt cleans up for you. (No deletes are necessary in the destructor for Qt widgets <a href="#4">[4]</a>.) The first button (<a href="list4.htm">Listing 4</a>, line 04) is the &#147;Count Button.&#148; The label (<a href="list4.htm">Listing 4</a>, line 08) is used to display the counter number. Finally, the second button (<a href="list4.htm">Listing 4</a>, line 12) is used to reset the counter to zero.</p>
<p>The three calls to <B>connect</B> on lines 16-18 in <a href="list4.htm">Listing 4</a> glue this application together. Line 16 says to call the <B>intCount</B> slot when <B>countButton</B> emits the <B>clicked</B> signal. <B>intCount</B> (<a href="list3.htm">Listing 3</a>, lines 01-12) increments the counter by one and checks to see if it hits the <B>MAX_COUNT</B> constant (<a href="list2.htm">Listing 2</a>, line 20). If it is below the <B>MAX_COUNT</B>, it will update the label with the new number. If it is the <B>MAX_COUNT</B> or greater <a href="#5">[5]</a>, it will set the count to <B>MAX_COUNT</B>, emit the <B>maxCountReached</B> signal, and print &#147;Max count reached!&#148; plus the max count to the label.</p>
<p>Line 17 in <a href="list4.htm">Listing 4</a> says to call the <B>disableCountButton</B> slot when the <B>maxCountReached</B> signal is emitted. This signal is the only signal defined by this application and is emitted in the <B>intCount</B> slot when the counter reaches its limit. Yes, you can emit signals within slots, but be careful of infinite loops! As the name implies, the <B>disableCountButton</B> slot makes the &#147;Count Button&#148; unusable, thus preventing the user from making the count go over the <B>MAX_COUNT</B> amount.</p>
<p>Finally, line 18 in <a href="list4.htm">Listing 4</a> says to call the <B>resetCount</B> slot when the <B>resetButton</B> is <B>clicked</B>. The <B>resetCount</B> slot puts the count at zero, enables the &#147;Count Button,&#148; and sets the label to the new count. And that&#146;s our &#147;Hello World&#148; application that demonstrates slots and signals. If you haven&#146;t done so already, in KDevelop go to &#147;Build&#148;, select &#147;Execute&#148;, and enjoy your new useless application. Hey, it never said &#147;Hello World!&#148; I&#146;ve left that to you.</p>

<H3><FONT COLOR="#000080">What moc Does</FONT></H3>

<p>When KDevelop runs moc on your header files (or when you run moc on your header files manually) it creates a file that adds <B>className</B>, <B>tr</B>, <B>initMetaObject</B>, and <B>staticMetaObject</B> methods to the class, as well as methods for all your declared signals. The first four mentioned are declared in the <B>Q_OBJECT</B> macro (which is why it&#146;s required). In addition, moc adds a member property <B>metaObj</B>, which is a singleton <B>QMetaObject</B> instance created in <B>staticMetaObject</B>. When the <B>staticMetaObject</B> creates the <B>metaObj</B>, it takes all the slots and signals, puts them into two structure arrays (one <B>QMetaData</B> structure array for slots and one for signals), and uses them in the constructor of the <B>QMetaObject</B> instance (<B>metaObj</B>) for this class. In the <B>HelloWorld</B> example, open up <B>helloworld.moc.cpp</B> and examine it for more details. (If you built the application yourself rather than downloading it, the file won&#146;t be there until your first compile.)</p>
<p>When you compile your code with the C++ compiler, all instances of the words <B>emit</B>, <B>slots</B>, and <B>signals</B> in <B>QObject</B>s are either removed or replaced because of <B>#define</B>s in the Qt header file <B>qobjectdefs.h</B>. (This is how KDE/Qt gets away with the non-standard syntax.) Note that the <B>emit</B> keyword is only syntactic sugar. It is designed to remind the programmer (and tell the maintainer) that this is a signal (and thus its definition is in the file created by moc for that class). The code would work just as well without <B>emit</B> in front of the call to the signal. Don&#146;t ever omit <B>emit</B>, however, because you never know what the future holds for this keyword.</p>

<H3><FONT COLOR="#000080">Conclusion</FONT></H3>

<p>As far as GUI development goes, KDE is a very easy programming environment once you&#146;ve conquered the slots and signals. I&#146;ve concentrated on slots and signals in this article. However, many concepts were sacrificed in this article to emphasize slots and signals. Your next step should be to read up on <B>KMainWindow</B> and how KDE implements the Document-View model and the MDI. Also, you&#146;ll be interested in the <B>KAction</B> class. KDevelop comes complete with online tutorials on these and many more subjects. I recommend two good books, <I>KDE 2.0 Development</I>, by David Sweet et. al (Sams Publishing, 2000), and <I>KDE Programming Bible</I>, by Arthur Griffith (IDG Books, 2000)</p>

<H3><FONT COLOR="#000080">Notes</FONT></H3>

<p><a name="1"></a>[1]  KDE stands for &#147;K Desktop Environment&#148; and the &#147;K&#148; is meaningless.</p>
<p><a name="2"></a>[2]  Gnome is another desktop environment for Linux (&lt;www.gnome.org&gt;).</p>
<p><a name="3"></a>[3]  If you were compiling &#147;by hand,&#148; <B>.moc.cpp</B> files can be compiled and linked with your program in one of two ways: either compile the <B>.moc.cpp</B> file in the same manner as other <B>.cpp</B> files and link a resulting <B>.moc.o</B> file at the end, or just put an <B>#include</B> directive in your <B>.cpp</B> file (knowing the naming convention) that is going to use it.</p>
<p><a name="4"></a>[4]  Qt cleans up its widgets for you. Anytime you create a widget with a parent argument or register a widget with another widget, Qt&#146;s stock code will clean up for you. This is why all child widgets should be created on the heap (a pointer using <B>new</B>) and not on the stack. The only class created on the stack should be the <B>KApplication</B> class (see <a href="list1.htm">Listing 1</a>).</p>
<p><a name="5"></a>[5]  It would only be greater in a race condition, as the example code shown here is not thread safe.</p>

<p><i><B>Jason Mott</B> is a lead developer at Auragen Communications, Inc. (&lt;www.auragen.com&gt;), a top web development firm located in Rochester, NY, where he develops web applications in Java, Perl, and sometimes VBScript. He also serves there as a Linux systems consultant. Jason is a Linux freak and C/C++ enthusiast. In his spare time he codes KDE applications. He recently took over the Konverse project (a KDE Jabber client) and helps out with Komba (a KDE Network Neighborhood browser). He can be reached at <B>jmott@users.sourceforge.net</B>.</i></p>

<h4><a href="../../../source/2002/mar02/mott.zip"></a></h4>
</blockquote></body></html>
