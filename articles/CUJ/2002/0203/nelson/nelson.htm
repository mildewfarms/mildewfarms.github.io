<HTML>   
     <HEAD>
<TITLE>March 2002/C++ Algorithms: next_permutation</TITLE></HEAD>
<BODY BACKGROUND="" BGCOLOR="#FFFFFF" TEXT="#000000">
<H2><A HREF="../tocmar.htm"></A><FONT COLOR="#FF0000">   Features</FONT></H2>

<HR>

<H2 ALIGN="center"><FONT COLOR="#800000">C++ Algorithms: next_permutation</FONT></H2>
<H3 ALIGN="center"><FONT COLOR="#800000">Mark Nelson</FONT></H3>

<BLOCKQUOTE>
<p>On the elegance of next_permutation, which might even help you with your homework, by the way.</p>
</BLOCKQUOTE>

<HR>
<BLOCKQUOTE>
<p>My daughter&#146;s math teacher at Hockaday School in Dallas wants his sixth-grade students to enjoy their class. He&#146;s fond of sending home interesting problems that are meant to be both entertaining and enriching. As most parents probably know, this can only mean trouble! Last week, Mr. Bourek sent home a worksheet containing a set of variations on the traditional magic square. Students were given various shapes, such as triangles, stars, etc., and asked to fill in a set of consecutive numbers at the vertices. The goal was to come up with an arrangement of numbers such that various rows, columns, and diagonals all added up to a given sum. Kaitlin worked her way through most of the problems in fairly quick order. But the shape shown in <a href="fig1.htm">Figure 1</a> managed to stump her.</p>
<p>The problem was simple enough. All she had to do was place the numbers one through nine in the nine positions of the figure so that the sum of all the straight lines was 17. Although Kaitlin was able to knock the other problems out quickly, this one was still unsolved after 15 minutes &#151; well past the normal sixth-grade attention span. Even worse, after another 10 minutes of my help, we were no closer to a solution. That&#146;s when I decided it was time for a brute force approach. I remembered that the Standard C++ library had a handy function, <B>next_permutation</B>, that would let me iterate through all the possible arrangements of the figure with just a couple of lines of code. All I had to do was check the five different sums for each permutation and I&#146;d have the answer in no time.</p>
<p>The resulting program is shown in <a href="list1.htm">Listing 1</a>, and its output is given below:</p>

<pre>
100706 : 3 5 9 8 2 1 6 4 7
114154 : 3 8 6 5 2 4 9 1 7
246489 : 7 1 9 4 2 5 6 8 3
259937 : 7 4 6 1 2 8 9 5 3
362880 permutations were tested
</pre>

<p>A little quick sketching will show you that the four solutions are simply rotations and mirror images of the one true solution. You can also see that randomly putting down numbers makes the odds almost 100,000:1 against finding a solution. Not quite as bad as the lottery, but it clearly shows that random guessing isn&#146;t going to work. (Kaitlin asked me to give her the center position only, upon which she solved the rest of it in roughly 30 seconds.)</p>

<H3><FONT COLOR="#000080">Magic Permutations</FONT></H3>

<p>From this program, you can see that <B>next_permutation</B> is a handy function to have in the C++ library. In my case, it meant the difference between writing an impulse program versus fiddling around with pencil and paper for another hour. What really makes <B>next_permuation</B> interesting to me is the fact that it can generate permutations without keeping any additional information beyond the sequence being juggled. I can generate a permutation, go off, and do whatever I like with it, even write the numbers out to a file and save them for later. Regardless of what I do, <B>next_permuation</B> will always generate the next set in the series given only the previous one as input.</p>
<p>Just writing a function to generate permutations isn&#146;t particularly hard. One easy way to tackle the problem is with a recursive approach. If the string you want to permute is <B>n</B> characters long, you execute a loop that makes <B>n</B> passes &#151; one pass per character in the string. Each time <B>i</B> passes through the loop, you remove character <B>i</B> from the string and keep it as a prefix. You then print out all the permutations of the remaining substring concatenated with the prefix character. To generate the permutations of the substring, you recursively call the permutation function. The only additional piece of logic required is a test to see if a substring is only one character long. If it is, you don&#146;t need to call the permutation function, because you already have the only permutation of the substring.</p>
<p>For example, to print the permutations of <B>"abc"</B>, you first strip off the <B>a</B> character and then get the permutations of <B>"bc"</B>. To get those permutations, you first strip off the <B>b</B> character and get a resulting permutation list of <B>"c"</B>. Concatenating with the prefix character <B>b</B> results in the permutation <B>"bc"</B>. You then strip off the <B>c</B> character and get a resulting permutation list of <B>"b"</B>. Concatenating with the prefix character <B>c</B> results in the permutation <B>"cb"</B>. The results when combined with the prefix character <B>a</B> give strings <B>"abc"</B> and <B>"acb"</B>. You then repeat the process for prefix <B>b</B> and substring <B>"ac"</B> and then for prefix <B>c</B> and substring <B>"ab"</B>.</p>
<p>Using the C++ Standard library&#146;s string class makes it fairly easy to implement this logic. <a href="list2.htm">Listing 2</a> shows the program <B>permute.cpp</B>, which implements this algorithm relatively faithfully. This approach to generating permutations is okay, but its recursive nature makes it unattractive for use in a library. A library user wants to repeatedly call a function that returns a permutation and then do something with the returned value. The code in <a href="list2.htm">Listing 2</a> won't work in this paradigm &#151; there's no way to return from deep inside the nested loop without losing the entire context the algorithm uses to generate permutations. <B>next_permutation</B> manages to avoid this trouble by using a simple algorithm that can sequentially generate all the permutations of a sequence (in the same order as the algorithm I described above) without maintaining any internal state information.</p>
<p>The first time I saw this code was in the original STL (Standard Template Library) published by Alexander Stepanov and Ming Lee at Hewlett-Packard. The original code is shown in <a href="list3.htm">Listing 3</a>. Using this function is simple. You call it repeatedly, asking it to permute a given sequence. If you start with a sequence in ascending order, <B>next_permutation</B> will work its way through all possible permutations of the sequence, eventually returning a value of <B>false</B> when there are no more permutations left.</p>

<H3><FONT COLOR="#000080">Internals of next_permutation</FONT></H3>

<p>You don&#146;t need to be an STL expert to understand this code, but if you&#146;ve never been exposed to this new part of the C++ Standard library, there are a few things you need to know. First, iterators (and the <B>BidirectionalIterator</B> type used here) are an STL abstraction of pointers. When looking at this code, you can think of the iterators as pointers. The permutation sequence is defined by iterators <B>first</B> and <B>last</B>. <B>first</B> points to the first element in the sequence, while <B>last</B> points one past the last element. The code shown in <a href="list3.htm">Listing 3</a> also uses two other STL functions: <B>iter_swap</B> swaps the values pointed to by its two arguments, and <B>reverse</B> simply reverses the sequence defined by its two arguments. By convention of course, the first argument points to the start of the sequence to be reversed, and the last argument points one past the end of the sequence.</p>
<p>To help illustrate the workings of this algorithm, I&#146;ve included a listing of a permutation sequence in <a href="fig2.htm">Figure 2</a>. It contains all 120 permutations of a five-digit sequence. With this output example, plus <a href="list3.htm">Listing 3</a>, it is fairly easy to see how this code works. The function first does a cursory check for sequences of length zero or one and returns <B>false</B> if it finds either. Naturally, sequences of those lengths only have one permutation, so they must always return <B>false</B>. After passing those tests, the algorithm goes into a search loop. It starts at the end of the sequence and works its way towards the front, looking for two consecutive members of the sequence for which member <B>n</B> is less than member <B>n+1</B>. These members are pointed to by iterators <B>i</B> and <B>ii</B> respectively. If the function doesn&#146;t find two values that pass this test, it means all permutations have been generated. You can see this in <a href="fig2.htm">Figure 2</a> for the very last value, <B>54321</B>.</p>
<p>Once iterators <B>i</B> and <B>ii</B> have been properly located, there are still a few more steps left. The next step is to again start searching from the end of the sequence for the first member that is greater than or equal to the member pointed to by <B>i</B>. Because of the previous search for <B>i</B> and <B>ii</B>, you know that at worst the search will end at <B>ii</B>, but it might end earlier. Once this member is located, it is pointed to by iterator <B>j</B>.</p>
<p>Once these three iterators are located, there are only two more simple steps. First, a call is made to <B>iter_swap( i, j )</B>. This call simply swaps the members pointed to by <B>i</B> and <B>j</B>. Finally, a call is made to <B>reverse( ii, last )</B>. This reverses the sequence that starts at <B>ii</B> and ends at the end of the sequence. The end result is a routine that is short, simple, and runs in linear time. You really can&#146;t ask for much more than that.</p>

<H3><FONT COLOR="#000080">Walking through an Example</FONT></H3>

<p>For a quick look at the algorithm in action, consider what happens when you call <B>next_permutation( "23541" )</B>. After passing through the initial size tests, the algorithm will search for suitable values for iterators <B>i</B> and <B>ii</B>. (Remember that you are searching from the end of the sequence for the first adjacent pair for which the value pointed to by <B>i</B> is less than the value pointed to by <B>ii</B>, and <B>i</B> is one less than <B>ii</B>.) The first pair of values that meet the test are seen when <B>i</B> points to <B>3</B> and <B>ii</B> points to <B>5</B>. After that, a second search starts from the end for the first value of <B>j</B> where <B>j</B> points to a greater value than that pointed to by <B>i</B>. This is seen when <B>j</B> points to <B>4</B>. Once these three iterators are set, there are only two tasks left to perform. The first is to call <B>iter_swap( i, j )</B>, which swaps the values pointed to by the iterators <B>i</B> and <B>j</B>. After the function does this, you are left with the modified sequence <B>"24531"</B>. The last step is to call <B>reverse( ii, last )</B>, which reverses the sequence starting at <B>ii</B> and finishing at the end of the sequence. This yields <B>"24135"</B>. <a href="fig2.htm">Figure 2</a> shows that the result demonstrated here does agree with the output of the program.</p>

<H3><FONT COLOR="#000080">An Additional Charming Attribute</FONT></H3>

<p>The algorithm shown here has one additional feature that is quite useful. It properly generates permutations when some of the members of the input sequence have identical values. For example, when I generate all the permutations of <B>"ABCDE"</B>, I will get 120 unique character sequences. But when I generate all the permutations of <B>"AAABB"</B>, I only get 10. This is because there are six different identical permutations of <B>"AAA"</B>, and two identical permutations of <B>"BB"</B>. When I run this input set through a set of calls to <B>next_permutation</B>, I see the correct output:</p>

<pre>
AAABB AABAB AABBA ABAAB ABABA
ABBAA BAAAB BAABA BABAA BBAAA
</pre>

<p>This might have you scratching your head a bit. How does the algorithm know that there are six identical permutations of <B>"AAA"</B>? The recursive implementation of a permutation generator I showed in <a href="list2.htm">Listing 2</a> treats the permutations of <B>"AAABB"</B> just as it does <B>"ABCDE"</B>, obligingly printing out 120 different sequences. It doesn&#146;t know or care that there are a huge number of identical permutations in the output sequence. It&#146;s easy to see why the brute force code in <a href="list2.htm">Listing 2</a> doesn&#146;t notice the duplicates. It never pays any attention to the contents of the string that it is permuting. It couldn&#146;t possibly notice that there were duplicates. It just merrily swaps characters without paying any attention to their value. The STL algorithm, on the other hand, actually performs comparisons of the elements that it is interchanging and uses their relative values to determine what interchanging will be done. In the example from the last section, you saw that an input of <B>"24531"</B> will generate a next permutation of <B>"24135"</B>. What if the string had a pair of duplicates, as in <B>"24431"</B>? If the algorithm were ignorant of character values, the next permutation would undoubtedly be <B>"24134"</B>. In the previous case, iterators <B>i</B> and <B>ii</B> were initially set to offsets of <B>1</B> and <B>2</B> within the string. But in this case, since the value pointed to by <B>i</B> must be less than the value pointed to by <B>ii</B>, the two iterators have to be decremented to positions <B>0</B> and <B>1</B>. <B>j</B> would again point to position <B>3</B>. The subsequent swap operation yields <B>"34421"</B>, and the reverse function produces a final result of <B>"31244"</B>. Remember that the algorithm works by progressively bubbling the larger values of the string into position <B>0</B>; you can see that this permutation has already jumped well ahead of the permutation of <B>"24531"</B> on its way to completion. Thus, the algorithm &#147;knows&#148; how to deal with duplicate values.</p>

<H3><FONT COLOR="#000080">Conclusion</FONT></H3>

<p>The addition of the STL to the C++ Standard library gave us a nice grab bag of functions that automate many routine tasks. <B>next_permuation</B> turned out to be just what I needed to solve a sixth-grade math problem. It might be time for you to look through the declarations in the <B>&lt;algorithm&gt;</B> header file to see what else the standards committee laid on our doorstep.</p>

<p><i><B>Mark Nelson</B> is a programmer for Cisco Systems in Richardson, Texas. He is presently working on IP Telephony projects for Cisco. You can reach Mark at <B>markn@ieee.org</B> or via his website at &lt;www.dogma.net/markn&gt;.</i></p>

<h4><a href="../../../source/2002/mar02/nelson.zip"></a></h4>
</blockquote></body></html>
