<HTML>   
     <HEAD>
<TITLE>December 2002/We Have Mail</TITLE></HEAD>
<BODY BACKGROUND="" BGCOLOR="#FFFFFF" TEXT="#000000">
<H2><A HREF="../tocdec.htm"></A><FONT COLOR="#FF0000">   Departments</FONT></H2>

<HR>

<H2 ALIGN="center"><FONT COLOR="#800000">We Have Mail</FONT></H2>

<HR>
<BLOCKQUOTE>
<p><I>Letters to the editor may be sent via email to </I>cujed@cmp.com<I>, or via the postal service to Letters to the Editor, </I>C/C++ Users Journal<I>, 1601 W. 23rd St., Ste 200, Lawrence, KS 66046-2700.</I></p>

<hr><p><I>CUJ</I>,</p>
<p>In the July 2002 issue, Bjarne Stroustrup in &#147;C and C++: Siblings&#148; writes about the following program:</p>

<pre>
main()
{
    printf(&#147;Hello, world\n&#148;);
}
</pre>

<p>Stroustrup says: &#147;As a C++98 program, it has two errors. As a C99 program, it has the same two errors, and if those were fixed, the meaning would be subtly different from the identical C++ program.&#148;</p>
<p>I was puzzled by what the subtle difference would be and posted the question to <B>comp.lang.c++.moderated</B> and <B>comp.lang.c.moderated</B> (difference between C++98 and C99). Could the author please explain what the difference is? I&#146;m still looking for the answer and would like to post it to the newsgroups (if I may).</p>
<p>Boris Pulatov</p>

<p><I>The two errors are:</I></p>

<OL><LI><I>The missing </I><B>int</B><I> type for </I><B>main()</B><I> &#151; because neither C++ nor C99 allows </I><B>implicit int</B><I>.</I></LI>
<LI><I>The lack of inclusion of </I><B>&lt;stdio.h&gt;</B><I> to provide a declaration for </I><B>printf()</B><I>.</I></LI></OL>

<p><I>I had two &#147;subtleties&#148; in mind when I wrote that sentence: </I></p>

<OL><LI><I>In C++, </I><B>main()</B><I> cannot be called from within the program, but in C99 it can.</I></LI>
<LI><I>In C++, </I><B>main()</B><I> implicitly returns </I><B>0</B><I> if you fall through its end.</I></LI></OL>

<p><I>The reason I didn&#146;t explicitly say what I had in mind was that I wanted people to consider what subtle differences there might be in even trivial examples and how difficult it is to keep all the differences between the dialects of C and C++ straight in your mind.</I></p>
<p><I>It appears that I made my point better than I had expected, because I hadn&#146;t noticed that C99 had adopted the C++ rule of implicitly returning </I><B>0</B><I>. Even experts get caught at times. There may be other &#147;subtleties&#148; in this trivial example, but I don&#146;t think so. The key point is that when examples get less trivial, the possibilities for &#147;subtleties&#148; can increase dramatically.</I></p>
<p><I>Bjarne Stroustrup</I></p>

<hr><p>I was most interested to see your articles and focus on delegates and events for C++ in relationship to those of C#.  Besides the possibility shown by J. Daniel Smith (&#147;Inside .NET&#146;s Delegates and Events Using C++,&#148; <I>CUJ</I>, September 2002) of providing delegates and events in C++, there are at least two well-known implementations of such a concept for C++ already in existence, which are more complete and more flexible. The first is by Andrei Alexandrescu in his book <I>Modern C++ Design</I> (Addison-Wesley, 2001) in his Loki library, explained in his chapter on &#147;Generalized Functors&#148; and his <B>Loki::Functor</B> class. The other exists in the Boost library&#146;s <B>boost:function</B> and <B>boost::bind</B> implementations. Both of these implementations provide for the definition of a delegate and its event in a declaration of a single instantiated class template and provide for that declaration to encompass an arbitrary return type and a number of arbitrary parameter types. Both provide mechanisms for binding functions, function objects, or member functions to the declaration as a callback.</p>
<p>As an extension to the C++ language using the same accepted double underscore (__) notation as the .NET Managed C++ Extensions, Borland&#146;s C++ Builder has had for over six years a __closure keyword, which provides a supremely easy callback for events, among other uses. In C++ Builder&#146;s __closure implementation, one just assigns the address of any class object&#146;s member function, of the appropriate function signature, to a __closure of that same function signature in order to provide an event callback mechanism. The event handler can subsequently be called at any later time through the __closure pointer.  I bring in these examples to illustrate that whether through inventive programming using Standard C++ syntax, or through a language extension, C++ already has the equivalent of the C# delegate/event handling ,and that facility is nothing new to the C++ language implementations.</p>
<p>Eddie Diener</p>

<p><I>We heard from other readers pointing to alternative approaches, such as the Boost solution. J. Daniel Smith responds, &#147;I failed to mention the Boost library in my closing comments; this was an oversight on my part. However, the focus of my article was to gain a better understanding of C#/.NET-style delegates and events by showing (one way) they could be implemented in Standard C++; making use of the Boost library for this purpose might not have been as elucidating.&#148; </I></p>
<p><I>By the way, in case any readers haven&#146;t noticed, we at </I>CUJ<I> are big supporters of the Boost libraries. You&#146;ll find articles on Boost in the April, May, August, and November 2002 issues of </I>CUJ<I>. We hope to continue our support for Boost in 2003. If you have a proposal related to Boost, please send it in. See Andreas Wickner&#146;s letter below for a Boost solution to this question of delegates in events. &#151; jc</I></p>

<hr><p>Dear <I>CUJ</I>,</p>
<p>In the conclusion of his article &#147;Inside .NET&#146;s Delegates and Events Using C++&#148; (September 2002), J. Daniel Smith mentions that &#147;A more elegant and pure C++ solution might leverage adapters and binders from the Standard C++ library&#148;. In fact, I think it should be noted that using the marvelous tools from the Boost library, everything shown in the article can be reduced to a few simple lines of code. The resulting style also allows for delegating to function objects and simple functions, which makes it in my opinion more flexible than what is offered by .NET delegates and events. An example that loosely follows the example in Mr. Smith&#146;s article is available for download from &lt;www.cuj.com/code&gt;.</p>
<p>Regards,</p>
<p>Andreas Wickner</p>

<hr>
<p>While reading the first two articles of the <I>C/C++ Users Journal</I> (September 2002), I asked myself many times whether the name of the journal had been changed without me noticing.</p>
<p>I am no &#147;hardcore C++ programmer;&#148; I use Java when speed is not an issue, but I read the <I>C/C++ Users Journal</I> to learn more about C/C++, just like I read a car magazine to find out more about cars.</p>
<p>Given that you wish to inform readers what is going on in the world around us, in my opinion the first two articles were quite worthless from a C++ programmer&#146;s point of view.</p>
<p>I will start with a question: What does the author of the first article (&#147;The .NET Managed Extensions to C++&#148;), Stanley Lippman, wish to tell the reader?</p>
<p>I found the answer at the end of his article (p. 11): &#147;... many of our basic assumptions as C++ programmers are considered bad habits of an obsolete technology that need to be corrected.&#148;</p>
<p>In my opinion, this is the same as telling the readers of a car magazine that &#147;cars endanger the environment and everyone should stop using them.&#148; Do you think that this is wise, even if what is being written is true?</p>
<p>Also, some of the arguments the author points out really annoyed me; for example, on page 8: &#147;[CLR] solves many of the implementation problems of COM.&#148;</p>
<p>Of course it is an option to solve the problems of a library, which has some design flaws (COM) by changing the programming language, but I naturally tend to look for other solutions first.</p>
<p>The second article by J. Daniel Smith (&#147;Inside .NET&#146;s Delegates and Events Using C++,&#148; ends much the same (p. 21): &#147;It sure is easier to add new functionality at the compiler level instead of writing templates.&#148;</p>
<p>Oh well. Maybe it is. Still, this is no reason to do so. Experts should know that the easiest way often turns out not to be the best.</p>
<p>I will stop here. Although I&#146;m angry, I don&#146;t want to insult anyone. I just hope that the next issue of the <I>C/C++ Users Journal</I> will again provide only valuable information for C/C++ developers.</p>
<p>Best regards,</p>
<p>Lothar May</p>

<p><I>Dear Lothar:</I></p>
<p><I>Although our primary focus is on C and C++, we try to keep pace with developments in programming as it is actually practiced by our readers. We view Java, Managed C++, and C# also in the &#147;C family of languages&#148; &#151; they all share a C-based syntax and have evolved ultimately from C. These languages also affect a large number of developers (no matter the reason). We will continue to focus mainly on C and C++, but we would consider ourselves uninformed and remiss if we did not track developments in related areas. The attention to .NET in the September issue reflects the fact that September was our &#147;C# and .NET&#148; issue. Other issues will focus on different themes.</I></p>
<p><I>As far as your first reference to Stanley Lippman&#146;s article, it is best to keep the quotation in its context: &#147;The truth is that, in this managed Oz, many of our basic assumptions are considered bad habits of an obsolete technology that need to be corrected. (That is putting it in very stark terms.) If the native Kansas is our home, with shared beliefs and specialized support for the environment, then we are strangers in this strange, Oz-like land of the CLR.&#148; </I></p>
<p><I>Because </I>CUJ<I> is published in the real Kansas, as you can imagine, we have all heard far too many Oz analogies; however, since we started into this one, it is worth pointing out that the author is saying the assumptions of C/C++ are considered bad habits only within the strange, mysterious environment of .NET. Note also that these habits are &#147;considered&#148; bad, not that they are bad. It is also worth remembering that Oz, though dreamlike and wondrous, was not a particularly hospitable place and certainly wasn&#146;t for everybody. Dorothy, for instance, didn&#146;t like it and wanted to go home. The author is not intending to repudiate C++ but to offer a warning to those who wish to travel through .NET with C++ as a roadmap. &#151; jc </I></p>

<h4><a href="../../../source/2002/dec02/letters.zip"></a></h4>
</blockquote></body></html>
