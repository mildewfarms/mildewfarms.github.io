<html><HEAD>
<TITLE>April 2002/The Standard Librarian/Sidebar</TITLE></HEAD>
<BODY BACKGROUND="" BGCOLOR="#FFFFFF" TEXT="#000000">

<H3 align=center><FONT COLOR="#000080">Standardese for the Hash Table Proposal</FONT></H3>

<HR>

<BLOCKQUOTE>

<H3><FONT COLOR="#000080">A. Requirements</FONT></H3>

<p>Hashed associative containers provide an ability for fast retrieval of data based on keys. The worst-case complexity for most operations is linear, but the average case is much faster. The library provides four basic kinds of hashed associative containers: <b>hash_set</b>, <b>hash_map</b>, <b>hash_multiset</b>, and <b>hash_multimap</b>.</p>
<p>Each hashed associative container is parameterized by <b>Key</b>, by a function object <b>Hash</b> that acts as a hash function for values of type <b>Key</b>, and on a binary predicate <b>Pred</b> that induces an equivalence relation on values of type <b>Key</b>. Additionally, <b>hash_map</b> and <b>hash_multimap</b> associate an arbitrary <i>mapped type</i> <b>T</b> with the <b>Key</b>.</p>
<p>A hash function is a function object that takes a single argument of type <b>Key</b> and returns a value of type <b>std::size_t</b> in the range <b>[0, std::numeric_limits&lt;std::size_t&gt;::max())</b>. </p>
<p>Two values <b>k1</b> and <b>k2</b> of type <b>Key</b> are considered equal if the container's equality function object returns <b>true</b> when passed those values. If <b>k1</b> and <b>k2</b> are equal, the hash function must return the same value for both. </p>
<p>A hashed associative container supports <i>unique keys</i> if it may contain at most one element for each key. Otherwise, it supports <i>equivalent keys</i>. <b>hash_set</b> and <b>hash_map</b> support unique keys. <b>hash_multiset</b> and <b>hash_multimap</b> support equivalent keys. In containers that support equivalent keys, elements with equivalent keys are adjacent to each other.</p>
<p>For <b>hash_set</b> and <b>hash_multiset</b> the value type is the same as the key type. For <b>hash_map</b> and <b>hash_multimap</b> it is equal to <b>std::pair&lt;const Key, T&gt;</b>.</p>
<p>The iterator types <b>iterator</b> and <b>const_iterator</b> of a hashed associative container are of at least the forward iterator category. For hashed associative containers where the key type and value type are the same, both <b>iterator</b> and <b>const_iterator</b> are const iterators.</p>
<p>The elements of a hashed associative container are organized into <i>buckets</i>. Keys with the same hash code appear in the same bucket. The number of buckets is automatically increased as elements are added to a hashed associative container so that the average number of elements per bucket is kept below a bound. Rehashing invalidates iterators, changes ordering between elements, and changes which buckets elements appear in, but does not invalidate pointers or references to elements. </p> 
<p>In the following table, <b>X</b> is a hashed associative container class, <b>a</b> is an object of type <b>X</b>, <b>a_uniq</b> is an object of type <b>X</b> when <b>X</b> supports unique keys, <b>a_eq</b> is an object of type <b>X</b> when <b>X</b> supports equivalent keys, <b>i</b> and <b>j</b> are input iterators that refer to <b>value_type</b>, <b>[i, j)</b> is a valid range, <b>p</b> and <b>q2</b> are valid iterators to <b>a</b>, <b>q</b> and <b>q1</b> are valid dereferenceable iterators to <b>a</b>, <b>[q1, q2)</b> is a valid range in <b>a</b>, <b>r</b> and <b>r1</b> are valid dereferenceable <b>const</b> iterators to <b>a</b>, <b>r2</b> is a valid <b>const</b> iterator to <b>a</b>, <b>[r1, r2)</b> is a valid range in <b>a</b>, <b>t</b> is a value of type <b>X::value_type</b>, <b>k</b> is a value of type <b>key_type</b>, <b>hf</b> is a value of type <b>hasher</b>, <b>eq</b> is a value of type <b>key_equal</b>, <b>n</b> is a value of type <b>size_type</b>, and <b>z</b> is a value of type <b>double</b>. </p>


<table width=400 border=1>
 <tr>
  <td colspan=4 align=center><b>Hashed Associative Container Requirements (in Addition to Container)</b></td>
 </tr>
 <tr>
  <td align=center><b>Expression</b></td>
  <td align=center><b>Return Type</b></td>
  <td align=center><b>Assertion/Note<br>
  Pre/Post-Condition</b></td>
  <td align=center><b>Complexity</b></td>
 </tr>
 <tr>
  <td><b>X::key_type</b></td>
  <td><b>Key</b></td>
  <td><b>Key</b> is <b>Assignable</b> and <b>CopyConstructible</b></td>
  <td>Compile time</td>
 </tr>
 <tr>
  <td><b>X::hasher</b></td>
  <td><b>Hash</b></td>
  <td><b>Hash</b> is a unary function object that takes an argument of type <b>Key</b> and returns a value of type <b>std::size_t</b>.</td>
  <td>Compile time</td>
 </tr>
 <tr>
  <td><b>X::key_equal</b></td>
  <td><b>Pred</b></td>
  <td><b>Pred</b> is a binary predicate that takes two arguments of type <b>Key</b>. <b>Pred</b> is an equivalence relation.</td>
  <td>Compile time</td>
 </tr>
 <tr>
  <td><b>X::local_iterator</b></td>
  <td>An iterator type whose category, value type, difference type, and pointer and reference types are the same as <b>X::iterator</b>'s. </td> 
  <td>A <b>local_iterator</b> object may be used to iterate through a single bucket, but may not be used to iterate across buckets.</td>
  <td>Compile time</td>
 </tr>
 <tr>
  <td><b>X::const_local_iterator</b></td>
  <td>An iterator type whose category, value type,  difference type, and pointer and reference types are the same as <b>X::const_iterator</b>'s.</td>
  <td>A <b>const_local_iterator</b> object may be used to iterate through a single bucket, but may not be used to iterate across buckets.</td>
  <td>Compile time</td>
 </tr>
 <tr>
  <td><b>X(n, hf, eq)</b><br>
  <b>X a(n, hf, eq);</b></td>
  <td>X</td>
  <td>Constructs an empty container with at least <b>n</b> buckets, using <b>hf</b> as the hash function and <b>hf</b> as the key equality predicate.</td>
  <td>Constant</td>
 </tr>
 <tr>
  <td><b>X(n, hf) </b><br>
  <b>X a(n, hf);</b></td>
  <td>X</td>
  <td>Constructs an empty container with at least <b>n</b> buckets, using <b>hf</b> as the hash function and <b>key_equal()</b> as the key equality predicate.</td>
  <td>Constant</td>
 </tr>
 <tr>
  <td><b>X(n)</b><br>
  <b>X a(n);</b></td>
  <td>X</td>
  <td>Constructs an empty container with at least <b>n</b> buckets, using <b>hasher()</b> as the hash function and <b>key_equal()</b> as the key equality predicate.</td>
  <td>Constant</td>
 </tr>
 <tr>
  <td><b>X()</b><br>
  <b>X a;</b></td>
  <td>X</td>
  <td>Constructs an empty container with an unspecified number of buckets, using <b>hasher()</b> as the hash function and <b>key_equal</b> as the key equality predicate.</td>
  <td>Constant</td>
 </tr>
 <tr>
  <td><b>X(i, j, n, hf, eq) </b><br>
  <b>X a(i, j, n, hf, eq);</b></td>
  <td>X</td>
  <td>Constructs an empty container with at least <b>n</b> buckets, using <b>hf</b> as the hash function and <b>hf</b> as the key equality predicate, and inserts elements from <b>[i, j)</b> into it.</td>
  <td>Average case O(N) <br>(N is <br><b>std::distance(i, j)</b>);<br> worse case O(N<sup>2</sup>)</td>
 </tr>
 <tr>
  <td><b>X(i, j, n, hf)</b><br>
  <b>X a(i, j, n, hf);</b></td>
  <td>X</td>
  <td>Constructs an empty container with at least <b>n</b> buckets, using <b>hf</b> as the hash function and <b>key_equal()</b> as the key equality predicate, and inserts elements from <b>[i, j)</b> into it.</td>
  <td>Average case O(N) <br>(N is <br><b>std::distance(i, j)</b>);<br> worse case O(N<sup>2</sup>)</td>
 </tr>
 <tr>
  <td><b>X(i, j, n) </b><br>
  <b>X a(i, j, n);</b></b></td>
  <td>X</td>
  <td>Constructs an empty container with at least <b>n</b> buckets, using <b>hasher()</b> as the hash function and <b>key_equal()</b> as the key equality predicate, and inserts elements from <b>[i, j)</b> into it.</td>
  <td>Average case O(N) <br>(N is <br><b>std::distance(i, j)</b>); <br>worse case O(N<sup>2</sup>)</td>
 </tr>
 <tr>
  <td><b>X(i, j) </b><br>
  <b>X a(i, j);</b></td>
  <td>X</td>
  <td>Constructs an empty container with an unspecified number of buckets, using <b>hasher()</b> as the hash function and <b>key_equal</b> as the key equality predicate, and inserts elements from <b>[i, j)</b> into it.</td>
  <td>Average case O(N)<br> (N is <br><b>std::distance(i, j)</b>);<br> worse case O(N<sup>2</sup>)</td>
 </tr>
 <tr>
  <td>
  <b>a.hash_funct()</b></td>
  <td><b>hasher</b></td>
  <td>Returns the hash function out of which <b>a</b> was constructed.</td>
  <td>Constant</td>
 </tr>
 <tr>
  <td><b>a.key_eq()</b></td>
  <td><b>key_equal</b></td>
  <td>Returns the key equality function out of which <b>a</b> was constructed.</td>
  <td>Constant</td>
 </tr>
 <tr>
  <td>
  <b>a_uniq.insert(t)</b></td>
  <td><b>std::pair&lt;iterator, bool&gt;</b></td>
  <td>Inserts <b>t</b> if and only if there is no element in the container with key equivalent to the key of <b>t</b>. The <b>bool</b> component of the returned pair indicates whether the insertion takes place, and the <b>iterator</b> component points to the element with key equivalent to the key of <b>t</b>. </td>
  <td>Average case O(1); worst case O(<b>a_uniq.size()</b>)</td>
 </tr>
 <tr>
  <td><b>a_eq.insert(t)</b></td>
  <td><b>iterator</b></td>
  <td>Inserts <b>t</b>, and returns an iterator pointing to the newly inserted element. </td>
  <td>Average case O(1); worst case O(<b>a_uniq.size()</b>)</td>
 </tr>
 <tr>
  <td><b>a.insert(r, t)</b></td>
  <td><b>iterator</b></td>
  <td>Equivalent to <b>a.insert(t)</b>. Return value is an iterator pointing to the element with the key equivalent to that of <b>t</b>. The const iterator <b>r</b> is a hint pointing to where the search should start. Implementations are permitted to ignore the hint. </td> 
  <td>Average case O(1); worst case O(<b>a.size()</b>)</td>
 </tr>
 <tr>
  <td><b>a.insert(i, j)</b></td>
  <td><b>void</b></td>
  <td>Pre: <b>i</b> and <b>j</b> are not iterators in <b>a</b>. <br>
  Equivalent to <b>a.insert(t)</b> for each element in <b>[i,j)</b>.</td>
  <td>Average case O(N), where N is <b>std::distance(i, j)</b>; worst case O(N * <b>a.size()</b>)</td>
 </tr>
 <tr>
  <td><b>a.erase(k)</b></td>
  <td><b>size_type</b></td>
  <td>Erases all elements with key equivalent to <b>k</b>. Returns the number of elements erased.</td>
  <td>Average case O(<b>a.count(k)</b>); worst case O(<b>a.size()</b></td>
 </tr>
 <tr>
  <td><b>a.erase(r)</b></td>
  <td><b>void</b></td>
  <td>Erases the element pointed to by <b>r</b>.</td>
  <td>Average case O(1); worst case O(<b>a.size()</b>)</td>
 </tr>
 <tr>
  <td><b>a.erase(r1, r2)</b></td>
  <td><b>void</b></td>
  <td>Erases all elements in the range <b>[r1, t2)</b>.</td>
  <td>Average case O(<b>std::distance(r1, r2)</b>); worst case O(<b>a.size()</b>)</td>
 </tr>
 <tr>
  <td><b>a.clear()</b></td>
  <td><b>void</b></td>
  <td>Erases all elements in the container. <br>
  Post: <b>a.size() == 0</b></td>
  <td>Linear</td>
 </tr>
 <tr>
  <td><b>a.find(k)</b></td>
  <td><b>iterator</b>;<br>
  <b>const_iterator</b> for const <b>a</b></td>
  <td>Returns an iterator pointing to an element with key equivalent to <b>k</b>, or <b>a.end()</b> if no such element exists.</td>
  <td>Average case O(1); worst case O(<b>a.size()</b>)</td>
 </tr>
 <tr>
  <td><b>a.count(k)</b></td>
  <td><b>size_type</b></td>
  <td>Returns the number of elements with key equivalent to <b>k</b>.</td>
  <td>Average case O(1); worst case O(<b>a.size()</b>)</td>
 </tr>
 <tr>
  <td><b>a.equal_range(k)</b></td>
  <td><b>std::pair&lt;iterator, iterator&gt;</b>;<br>
  <b>std::pair&lt;const_iterator, const_iterator&gt;</b> for const <b>a</b> </td>
  <td>Returns a range containing all elements with keys equivalent to <b>k</b>. Returns <b>std::make_pair(a.end(), a.end())</b> if no such elements exist.</td>
  <td>Average case O(<b>a.count(k)</b>); worst case O(<b>a.size()</b>)</td>
 </tr>
 <tr>
  <td><b>a.bucket_count()</b></td>
  <td><b>size_type</b></td>
  <td>Returns the number of buckets that <b>a</b> contains.</td>
  <td>Constant</td>
 </tr>
 <tr>
  <td><b>a.max_bucket_count()</b></td>
  <td><b>size_type</b></td>
  <td>Returns an upper bound on the number of buckets that <b>a</b> might ever contain. </td>
  <td>Constant</td>
 </tr>
 <tr>
  <td><b>a.bucket(k)</b></td>
  <td><b>size_type</b></td>
  <td>Returns the index of the bucket in which elements with keys equivalent to <b>k</b> would be found, if any such elements exist. <br>
  Post: the return value is in the range <b>[0, a.bucket_count())</b>. </td>
  <td>Constant</td>
 </tr>
 <tr>
  <td><b>a.bucket_size(n)</b></td>
  <td><b>size_type</b></td>
  <td>Pre: <b>n</b> is in the range <b>[0, a.bucket_count())</b>.<br>
  Returns the number of elements in the <b>n</b><sup>th</sup> bucket.</td>
  <td>O(<b>a.bucket_size(n)</b>)</td>
 </tr>
 <tr>
  <td><b>a.begin(n)</b></td>
  <td><b>local_iterator</b>; <br>
  <b>const_local_iterator</b> for const <b>a</b></td>
  <td>Pre: <b>n</b> is in the range <b>[0, a.bucket_count())</b>.<br>
  Note: <b>[a.begin(n), a.end(n))</b> is a valid range containing all of the elements in the <b>n</b><sup>th</sup> bucket. </td>
  <td>Constant</td>
 </tr>
 <tr>
  <td><b>a.end(n)</b></td>
  <td><b>local_iterator</b>; <br>
  <b>const_local_iterator</b> for const <b>a</b></td>
  <td>Pre: <b>n</b> is in the range <b>[0, a.bucket_count())</b>.</td>
  <td>Constant</td>
 </tr>
 <tr>
  <td><b>a.load_factor()</b></td>
  <td><b>double</b></td>
  <td>Returns the average number of elements per bucket.</td>
  <td>Constant</td>
 </tr>
 <tr>
  <td><b>a.max_load_factor()</b></td>
  <td><b>double</b></td>
  <td>Returns a number that the container attempts to keep the load factor less than or equal to. The container automatically increases the number of buckets as necessary to keep the load factor below this number.<br>
  Post: return value is positive.</td>
  <td>Constant</td>
 </tr>
 <tr>
  <td><b>a.set_max_load_factor(z)</b></td>
  <td><b>void</b></td>
  <td>Pre: <b>z</b> is positive. <br>
  Changes the container's maximum load load factor. <br>
  Post: <b>a.max_load_factor() == z</b></td>
  <td>Constant</td>
 </tr>
 <tr>
  <td><b>a.rehash(n)</b></td>
  <td><b>void</b></td>
  <td>Pre: <b>n &gt; a.size() / a.max_load_factor()</b>.<br>
  Changes the number of buckets so that it is at least <b>n</b>.</td>
  <td>O(<b>a.size()</b>).</td>
 </tr>
</table>


<H3><FONT COLOR="#000080">B. Hash Function</FONT></H3>

<H4><FONT COLOR="#000080">1. To be added to the &lt;functional&gt; synopsis</FONT></H4>

<pre>
    // Hash function base template
    template &lt;class T&gt; struct hash;

    // Hash function specializations

    template &lt;&gt; struct hash&lt;char&gt;;
    template &lt;&gt; struct hash&lt;signed char&gt;;
    template &lt;&gt; struct hash&lt;unsigned char&gt;;
    template &lt;&gt; struct hash&lt;wchar_t&gt;;
    template &lt;&gt; struct hash&lt;short&gt;;
    template &lt;&gt; struct hash&lt;int&gt;;
    template &lt;&gt; struct hash&lt;long&gt;;
    template &lt;&gt; struct hash&lt;unsigned short&gt;;
    template &lt;&gt; struct hash&lt;unsigned int&gt;;
    template &lt;&gt; struct hash&lt;unsigned long&gt;;

    template &lt;class charT, class traits&gt;
    struct hash&lt;std::basic_string&lt;charT, traits&gt; &gt;;

    template&lt;&gt; struct hash&lt;const char*&gt;;
    template&lt;&gt; struct hash&lt;char*&gt;;
</pre>

<H4><FONT COLOR="#000080">2. Class template hash</FONT></H4>

<p>The function object <b>hash</b> is used as the default hash function by the <i>hashed associative containers</i>. This class template is required to be instantiable only for the following types: <b>char</b>, <b>signed char</b>, <b>unsigned char</b>, <b>wchar_t</b>, <b>short</b>, <b>int</b>, <b>long</b>, <b>unsigned short</b>, <b>unsigned int</b>, <b>unsigned long</b>, <b>char*</b>, <b>const char*</b>, and (for any valid set of <b>charT</b>, <b>traits</b>, and <b>Alloc</b>) <b>std::basic_string&lt;charT, traits, Alloc&gt;</b>. </p>

<pre>
    template &lt;class T&gt;
    struct hash : public std::unary_function&lt;T, std::size_t&gt;
    {
      std::size_t operator()(T val) const;
    };
</pre>

<p>The return value of <b>operator()</b> is unspecified, except that equal arguments yield the same result. For <b>char*</b> and <b>const char*</b>, two arguments <b>s1</b> and <b>s2</b> yield the same result if <b>std::strcmp(s1, s2) == 0</b>. </p>

<H3><FONT COLOR="#000080">C. Hashed Associative Containers</FONT></H3>

<H4><FONT COLOR="#000080">1. Header &lt;hash_set&gt; synopsis</FONT></H4>

<pre>
namespace std {
 template &lt;class Value,
            class Hash = hash&lt;Value&gt;,
            class Pred = std::equal_to&lt;Value&gt;,
            class Alloc = std::allocator&lt;Value&gt; &gt; class hash_set;

 template &lt;class Value, class Hash, class Pred, class Alloc&gt;
 bool operator==(const hash_set&lt;Value, Hash, Pred, Alloc&gt;&amp;,
                 const hash_set&lt;Value, Hash, Pred, Alloc&gt;&amp;);

 template &lt;class Value, class Hash, class Pred, class Alloc&gt;
 bool operator!=(const hash_set&lt;Value, Hash, Pred, Alloc&gt;&amp;,
                 const hash_set&lt;Value, Hash, Pred, Alloc&gt;&amp;);

 template &lt;class Value,
            class Hash = hash&lt;Value&gt;,
            class Pred = std::equal_to&lt;Value&gt;,
            class Alloc = std::allocator&lt;Value&gt; &gt; class hash_multiset;

 template &lt;class Value, class Hash, class Pred, class Alloc&gt;
 bool operator==(const hash_multiset&lt;Value, Hash, Pred, Alloc&gt;&amp;,
                 const hash_multiset&lt;Value, Hash, Pred, Alloc&gt;&amp;);

 template &lt;class Value, class Hash, class Pred, class Alloc&gt;
 bool operator!=(const hash_multiset&lt;Value, Hash, Pred, Alloc&gt;&amp;,
                 const hash_multiset&lt;Value, Hash, Pred, Alloc&gt;&amp;);}
</pre>

<H4><FONT COLOR="#000080">2. Header &lt;hash_map&gt; synopsis</FONT></H4>

<pre>
namespace std { 
 template &lt;class Key,
            class T,
            class Hash = hash&lt;Key&gt;,
            class Pred = std::equal_to&lt;Key&gt;,
            class Alloc = std::allocator&lt;std::pair&lt;const Key, T&gt; &gt; &gt; class hash_set;

 template &lt;class Key, class T, class Hash, class Pred, class Alloc&gt; 
 bool operator==(const hash_set&lt;Key, T, Hash, Pred, Alloc&gt;&amp;,    
                 const hash_set&lt;Key, T, Hash, Pred, Alloc&gt;&amp;);

 template &lt;class Key, class T, class Hash, class Pred, class Alloc&gt;
 bool operator!=(const hash_set&lt;Key, T, Hash, Pred, Alloc&gt;&amp;,
                 const hash_set&lt;Key, T, Hash, Pred, Alloc&gt;&amp;);

 template &lt;class Key,
            class T,
            class Hash = hash&lt;Key&gt;,
            class Pred = std::equal_to&lt;Key&gt;,
            class Alloc = std::allocator&lt;std::pair&lt;const Key, T&gt; &gt; &gt; class hash_multiset;

 template &lt;class Key, class T, class Hash, class Pred, class Alloc&gt; 
 bool operator==(const hash_multiset&lt;Key, T, Hash, Pred, Alloc&gt;&amp;,
                 const hash_multiset&lt;Key, T, Hash, Pred, Alloc&gt;&amp;);

 template &lt;class Key, class T, class Hash, class Pred, class Alloc&gt;
 bool operator!=(const hash_multiset&lt;Key, T, Hash, Pred, Alloc&gt;&amp;,
                 const hash_multiset&lt;Key, T, Hash, Pred, Alloc&gt;&amp;);}</pre>

<H4><FONT COLOR="#000080">3. Class template hash_set</FONT></H4>

<p>A <b>hash_set</b> is a kind of hashed associative container that supports unique keys (a <b>hash_set</b> contains at most one of each key value) and in which the elements' keys are the elements themselves.</p>
<p>A <b>hash_set</b> satisfies all of the requirements of a container and of a hashed associative container. It provides the operations described in the preceding requirements table for unique keys; that is, a <b>hash_set</b> supports the <b>a_uniq</b> operations in that table, not the <b>a_eq</b> operations. For a <b>hash_set</b><b>&lt;Value&gt;</b> the <b>key type</b> and the value type are both <b>Value</b>. The <b>iterator</b> and <b>const_iterator</b> types are both const iterator types. It is unspecified whether or not they are the same type.</p>
<p>This section only describes operations on <b>hash_set</b> that are not described in one of the requirement tables, or for which there is additional semantic information.</p>

<pre>
 namespace std {
    template &lt;class Value, 
              class Hash = hash&lt;Value&gt;,
              class Pred = std::equal_to&lt;Value&gt;,
              class Alloc = std::allocator&lt;Value&gt; &gt;
    class hash_set
    {
    public:
      // types
      typedef Value                                    key_type;
      typedef Value                                    value_type;
      typedef Hash                                     hasher;
      typedef Pred                                     key_equal;
      typedef Alloc                                    allocator_type;
      typedef typename allocator_type::pointer         pointer;
      typedef typename allocator_type::const_pointer   const_pointer;
      typedef typename allocator_type::reference       reference;
      typedef typename allocator_type::const_reference const_reference;
      typedef <b>implementation defined</b>            size_type;
      typedef <b>implementation defined</b>            difference_type;

      typedef <b>implementation defined</b>            iterator;
      typedef <b>implementation defined</b>            const_iterator;

      typedef <b>implementation defined</b>
              local_iterator;
      typedef <b>implementation defined</b>
              const_local_iterator;
      // construct/destroy/copy
      explicit hash_set(size_type n = <b>implementation defined</b>,
                        const hasher&amp; hf = hasher(),
                        const key_equal&amp; eql = key_equal(),
                        const allocator_type&amp; a = allocator_type());
      template &lt;class InputIterator&gt;
        hash_set(InputIterator f, InputIterator l,
                 size_type n = <b>implementation defined</b>,
                 const hasher&amp; hf = hasher(),
                 const key_equal&amp; eql = key_equal(),
                 const allocator_type&amp; a = allocator_type());
      hash_set(const hash_set&amp;);
      ~hash_set();
      hash_set&amp; operator=(const hash_set&amp;);
      allocator_type get_allocator() const;

      // size and capacity
      bool empty() const;
      size_type size() const;
      size_type max_size() const;

      // iterators
      iterator       begin();
      const_iterator begin() const;
      iterator       end();
      const_iterator end() const;

      // modifiers
      std::pair&lt;iterator, bool&gt; insert(const value_type&amp; obj);
      iterator insert(const_iterator hint, const value_type&amp; obj);
      template &lt;class InputIterator&gt;
        void insert(InputIterator first, InputIterator last);

      void erase(const_iterator position);
      size_type erase(const key_type&amp; k);
      void erase(const_iterator first, const_iterator last);
      void clear();
      void swap(hash_set&amp;);

      // observers
      hasher hash_funct() const;
      key_equal key_eq() const;

      // lookup
      iterator       find(const key_type&amp; k);
      const_iterator find(const key_type&amp; k) const;
      size_type count(const key_type&amp; k) const;
      std::pair&lt;iterator, iterator&gt; 
        equal_range(const key_type&amp; k);
      std::pair&lt;const_iterator, const_iterator&gt;
        equal_range(const key_type&amp; k) const;

      // bucket interface
      size_type bucket_count() const;
      size_type max_bucket_count() const;
      size_type bucket_size(size_type n);
      size_type bucket(const key_type&amp; k);
      local_iterator begin(size_type n);
      const_local_iterator begin(size_type n) const;
      local_iterator end(size_type n);
      const_local_iterator end(size_type n) const;

      // hash policy
      double load_factor() const;
      double max_load_factor() const;
      void set_max_load_factor(double z);
      void rehash(size_type n);
    };

    template &lt;class Value, class Hash, class Pred, class Alloc&gt;
    bool operator==(const hash_set&lt;Value, Hash, Pred, Alloc&gt;&amp; x,
                    const hash_set&lt;Value, Hash, Pred, Alloc&gt;&amp; y);

    template &lt;class Value, class Hash, class Pred, class Alloc&gt;
    bool operator!=(const hash_set&lt;Value, Hash, Pred, Alloc&gt;&amp; x,
                    const hash_set&lt;Value, Hash, Pred, Alloc&gt;&amp; y);

    template &lt;class Value, class Hash, class Pred, class Alloc&gt;
      void swap(const hash_set&lt;Value, Hash, Pred, Alloc&gt;&amp; x,
                const hash_set&lt;Value, Hash, Pred, Alloc&gt;&amp; y); }</pre>

<H4><FONT COLOR="#000080">a. hash_set constructors</FONT></H4>

<pre>
      explicit hash_set(size_type n = <b>implementation defined</b>,
                        const hasher&amp; hf = hasher(),
                        const key_equal&amp; eql = key_equal(),
                        const allocator_type&amp; a = allocator_type());</pre>

<p><b>Effects:</b> Constructs an empty <b>hash_set</b> using the specified hash function, key equality function, and allocator, and using at least <b><i>n</i></b> buckets. If <b><i>n</i></b> is not provided, the number of buckets is implementation defined.</p>

<p><b>Complexity:</b> Constant. </p>

<p><b>Note:</b> The maximum load factor is initially 1.0.</p>

<pre>
      template &lt;class InputIterator&gt;
        hash_set(InputIterator f, InputIterator l,
                 size_type n = <b>implementation defined</b>,
                 const hasher&amp; hf = hasher(),
                 const key_equal&amp; eql = key_equal(),
                 const allocator_type&amp; a = allocator_type());</pre>

<p><b>Effects:</b> Constructs an empty <b>hash_set</b> using the specified hash function, key equality function, and allocator, and using at least <b><i>n</i></b> buckets. (If <b><i>n</i></b> is not provided, the number of buckets is implementation defined.) Then inserts elements from the range <b><i>[first, last)</i></b>.</p>
<p><b>Complexity:</b> Average case linear; worst case quadratic.</p>

<p><b>Note: </b>The maximum load factor is initially 1.0.</p>

<H4><FONT COLOR="#000080">b. hash_set swap</FONT></H4>

<pre>
      template &lt;class Value, class Hash, class Pred, class Alloc&gt;
        void swap(const hash_set&lt;Value, Hash, Pred, Alloc&gt;&amp; x,
                  const hash_set&lt;Value, Hash, Pred, Alloc&gt;&amp; y);</pre>

<p><b>Effects:</b></p>

<pre>
          x.swap(y);
</pre>

<H4><FONT COLOR="#000080">4. Class template hash_map</FONT></H4>

<p>A <b>hash_map</b> is a kind of hashed associative container that supports unique keys (a <b>hash_map</b> contains at most one of each key value) and that associates values of another type <b>mapped_type</b> with the keys.</p>
<p>A <b>hash_map</b> satisfies all of the requirements of a container and of a hashed associative container. It provides the operations described in the preceding requirements table for unique keys; that is, a <b>hash_map</b> supports the <b>a_uniq</b> operations in that table, not the <b>a_eq</b> operations. For a <b>hash_map</b><b>&lt;Key, T&gt;</b> the <b>key type</b> is <b>Key</b>, the mapped type is <b>T</b>, and the value type is <b>std::pair&lt;const Key, T&gt;</b>. </p> 
<p>This section only describes operations on <b>hash_map</b> that are not described in one of the requirement tables, or for which there is additional semantic information.</p>

<pre>
 namespace std {
    template &lt;class Key,
              class T,
              class Hash = hash&lt;Key&gt;,
              class Pred = std::equal_to&lt;Key&gt;,
              class Alloc = std::allocator&lt;std::pair&lt;const Key, T&gt; &gt; &gt;
    class hash_map
    {
    public:
      // types
      typedef Key                                      key_type;
      typedef std::pair&lt;const Key, T&gt;                  value_type;
      typedef T                                        mapped_type;
      typedef Hash                                     hasher;
      typedef Pred                                     key_equal;
      typedef Alloc                                    allocator_type;
      typedef typename allocator_type::pointer         pointer;
      typedef typename allocator_type::const_pointer   const_pointer;
      typedef typename allocator_type::reference       reference;
      typedef typename allocator_type::const_reference const_reference;
      typedef <b>implementation defined</b>                   size_type;
      typedef <b>implementation defined</b>                   difference_type;

      typedef <b>implementation defined</b>                   iterator;
      typedef <b>implementation defined</b>                   const_iterator;

      typedef <b>implementation defined</b>
              local_iterator;
      typedef <b>implementation defined</b>
              const_local_iterator;

      // construct/destroy/copy
      explicit hash_map(size_type n = <b>implementation defined</b>,
                        const hasher&amp; hf = hasher(),
                        const key_equal&amp; eql = key_equal(),
                        const allocator_type&amp; a = allocator_type());

      template &lt;class InputIterator&gt;
        hash_map(InputIterator f, InputIterator l,
                 size_type n = <b>implementation defined</b>,
                 const hasher&amp; hf = hasher(),
                 const key_equal&amp; eql = key_equal(),
                 const allocator_type&amp; a = allocator_type());
      hash_map(const hash_map&amp;);
      ~hash_map();
      hash_map&amp; operator=(const hash_map&amp;);
      allocator_type get_allocator() const;

      // size and capacity
      bool empty() const;
      size_type size() const;
      size_type max_size() const;

      // iterators
      iterator       begin();
      const_iterator begin() const;
      iterator       end();
      const_iterator end() const;

      // modifiers
      std::pair&lt;iterator, bool&gt; insert(const value_type&amp; obj);
      iterator insert(const_iterator hint, const value_type&amp; obj);
      template &lt;class InputIterator&gt;
        void insert(InputIterator first, InputIterator last);

      void erase(const_iterator position);
      size_type erase(const key_type&amp; k);
      void erase(const_iterator first, const_iterator last);
      void clear();

      void swap(hash_map&amp;);

      // observers
      hasher hash_funct() const;
      key_equal key_eq() const;

      // lookup
      iterator       find(const key_type&amp; k);
      const_iterator find(const key_type&amp; k) const;
      size_type count(const key_type&amp; k) const;
      std::pair&lt;iterator, iterator&gt; 
        equal_range(const key_type&amp; k);
      std::pair&lt;const_iterator, const_iterator&gt;
        equal_range(const key_type&amp; k) const;

      mapped_type&amp; operator[](const key_type&amp; k);

      // bucket interface
      size_type bucket_count() const;
      size_type max_bucket_count() const;
      size_type bucket_size(size_type n);
      size_type bucket(const key_type&amp; k);
      local_iterator begin(size_type n);
      const_local_iterator begin(size_type n) const;
      local_iterator end(size_type n);
      const_local_iterator end(size_type n) const;

       // hash policy
      double load_factor() const;
      double max_load_factor() const;
      void set_max_load_factor(double z);
      void rehash(size_type n);
    };

    template &lt;class Key, class T, class Hash, class Pred, class Alloc&gt;
    bool operator==(const hash_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp; x,
                    const hash_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp; y);

    template &lt;class Key, class T, class Hash, class Pred, class Alloc&gt;
    bool operator!=(const hash_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp; x,
                    const hash_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp; y);

    template &lt;class Key, class T, class Hash, class Pred, class Alloc&gt;
      void swap(const hash_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp; x,
                const hash_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp; y); }</pre>

<H4><FONT COLOR="#000080">a. hash_map constructors</FONT></H4>

<pre>
      explicit hash_map(size_type n = <b>implementation defined</b>,
                        const hasher&amp; hf = hasher(),
                        const key_equal&amp; eql = key_equal(),
                        const allocator_type&amp; a = allocator_type());</pre>

<p><b>Effects:</b> Constructs an empty <b>hash_map</b> using the specified hash function, key equality function, and allocator, and using at least <b><i>n</i></b> buckets. If <b><i>n</i></b> is not provided, the number of buckets is implementation defined.</p>
<p><b>Complexity:</b> Constant. </p>
<p><b>Note: </b>The maximum load factor is initially 1.0.</p>

<pre>
      template &lt;class InputIterator&gt;
        hash_map(InputIterator f, InputIterator l,
                 size_type n = <b>implementation defined</b>,
                 const hasher&amp; hf = hasher(),
                 const key_equal&amp; eql = key_equal(),
                 const allocator_type&amp; a = allocator_type());</pre>

<p><b>Effects:</b> Constructs an empty <b>hash_map</b> using the specified hash function, key equality function, and allocator, and using at least <b><i>n</i></b> buckets. (If <b><i>n</i></b> is not provided, the number of buckets is implementation defined.) Then inserts elements from the range <b>[<i>first</i>, <i>last</i>)</b>.</p>
<p><b>Complexity:</b> Average case linear; worst case quadratic.</p>

<p><b>Note:</b>The maximum load factor is initially 1.0.</p>

<H4><FONT COLOR="#000080">b. hash_map element access</FONT></H4>

<pre>
      mapped_type&amp; operator[](const key_type&amp; k);</pre>

<p><b>Effects:</b> If the <b>hash_map</b> does not already contain an element whose key is equivalent to <i><b>k</b></i>, inserts <b>std::pair&lt;const key_type, mapped_type&gt;(k, mapped_type())</b>.</p> 
<p><b>Returns:</b> A reference to <b>x.second</b>, where <b>x</b> is the (unique) element whose key is equivalent to <b><i>k</i></b>. </p>

<H4><FONT COLOR="#000080">c. hash_map swap</FONT></H4>

<pre>
      template &lt;class Value, class Hash, class Pred, class Alloc&gt;
        void swap(const hash_map&lt;Value, Hash, Pred, Alloc&gt;&amp; x,
                  const hash_map&lt;Value, Hash, Pred, Alloc&gt;&amp; y);</pre>

<p><b>Effects:</b></p>

<pre>
          x.swap(y);
</pre>

<H4><FONT COLOR="#000080">5. Class template hash_multiset</FONT></H4>

<p>A <b>hash_multiset</b> is a kind of hashed associative container that supports equivalent keys (a <b>hash_multiset</b> may contain multiple copies of the same key value) and in which the elements' keys are the elements themselves.</p>
<p>A <b>hash_multiset</b> satisfies all of the requirements of a container and of a hashed associative container. It provides the operations described in the preceding requirements table for equivalent keys; that is, a <b>hash_multiset</b> supports the <b>a_eq</b> operations in that table, not the <b>a_uniq</b> operations. For a <b>hash_multiset</b><b>&lt;Value&gt;</b> the <b>key type</b> and the value type are both <b>Value</b>. The <b>iterator</b> and <b>const_iterator</b> types are both const iterator types. It is unspecified whether or not they are the same type.</p> 
<p>This section only describes operations on <b>hash_multiset</b> that are not described in one of the requirement tables, or for which there is additional semantic information.</p>

<pre>
 namespace std {
    template &lt;class Value, 
              class Hash = hash&lt;Value&gt;,
              class Pred = std::equal_to&lt;Value&gt;,
              class Alloc = std::allocator&lt;Value&gt; &gt;
    class hash_multiset
    {
    public:
      // types
      typedef Value                                    key_type;
      typedef Value                                    value_type;
      typedef Hash                                     hasher;
      typedef Pred                                     key_equal;
      typedef Alloc                                    allocator_type;
      typedef typename allocator_type::pointer         pointer;
      typedef typename allocator_type::const_pointer   const_pointer;
      typedef typename allocator_type::reference       reference;
      typedef typename allocator_type::const_reference const_reference;
      typedef <b>implementation defined</b>                   size_type;
      typedef <b>implementation defined</b>                   difference_type;

      typedef <b>implementation defined</b>                   iterator;
      typedef <b>implementation defined</b>                   const_iterator;

      typedef <b>implementation defined</b>
              local_iterator;
      typedef <b>implementation defined</b>
              const_local_iterator;

      // construct/destroy/copy
      explicit hash_multiset(size_type n = <b>implementation defined</b>,
                             const hasher&amp; hf = hasher(),
                             const key_equal&amp; eql = key_equal(),
                             const allocator_type&amp; a = allocator_type());
      template &lt;class InputIterator&gt;
        hash_multiset(InputIterator f, InputIterator l,
                 size_type n = <b>implementation defined</b>,
                 const hasher&amp; hf = hasher(),
                 const key_equal&amp; eql = key_equal(),
                 const allocator_type&amp; a = allocator_type());
      hash_multiset(const hash_multiset&amp;);
      ~hash_multiset();
      hash_multiset&amp; operator=(const hash_multiset&amp;);
      allocator_type get_allocator() const;

      // size and capacity
      bool empty() const;
      size_type size() const;
      size_type max_size() const;

      // iterators
      iterator       begin();
      const_iterator begin() const;
      iterator       end();
      const_iterator end() const;

      // modifiers
      iterator insert(const value_type&amp; obj);
      iterator insert(const_iterator hint, const value_type&amp; obj);
      template &lt;class InputIterator&gt;
        void insert(InputIterator first, InputIterator last);

      void erase(const_iterator position);
      size_type erase(const key_type&amp; k);
      void erase(const_iterator first, const_iterator last);
      void clear();

      void swap(hash_multiset&amp;);

      // observers
      hasher hash_funct() const;
      key_equal key_eq() const;

      // lookup
      iterator       find(const key_type&amp; k);
      const_iterator find(const key_type&amp; k) const;
      size_type count(const key_type&amp; k) const;
      std::pair&lt;iterator, iterator&gt; 
        equal_range(const key_type&amp; k);
      std::pair&lt;const_iterator, const_iterator&gt;
        equal_range(const key_type&amp; k) const;

      // bucket interface
      size_type bucket_count() const;
      size_type max_bucket_count() const;
      size_type bucket_size(size_type n);
      size_type bucket(const key_type&amp; k);
      local_iterator begin(size_type n);
      const_local_iterator begin(size_type n) const;
      local_iterator end(size_type n);
      const_local_iterator end(size_type n) const;

      // hash policy
      double load_factor() const;
      double max_load_factor() const;
      void set_max_load_factor(double z);
      void rehash(size_type n);
    };

    template &lt;class Value, class Hash, class Pred, class Alloc&gt;
    bool operator==(const hash_multiset&lt;Value, Hash, Pred, Alloc&gt;&amp; x,
                    const hash_multiset&lt;Value, Hash, Pred, Alloc&gt;&amp; y);

    template &lt;class Value, class Hash, class Pred, class Alloc&gt;
    bool operator!=(const hash_multiset&lt;Value, Hash, Pred, Alloc&gt;&amp; x,
                    const hash_multiset&lt;Value, Hash, Pred, Alloc&gt;&amp; y);

    template &lt;class Value, class Hash, class Pred, class Alloc&gt;
      void swap(const hash_multiset&lt;Value, Hash, Pred, Alloc&gt;&amp; x,
                const hash_multiset&lt;Value, Hash, Pred, Alloc&gt;&amp; y); }</pre>

<H4><FONT COLOR="#000080">a. hash_multiset constructors</FONT></H4>

<pre>
      explicit hash_multiset(size_type n = <b>implementation defined</b>,
                             const hasher&amp; hf = hasher(),
                             const key_equal&amp; eql = key_equal(),
                             const allocator_type&amp; a
                                = allocator_type());</pre>

<p><b>Effects:</b> Constructs an empty <b>hash_multiset</b> using the specified hash function, key equality function, and allocator, and using at least <b><i>n</i></b> buckets. If <b><i>n</i></b> is not provided, the number of buckets is implementation defined.</p>
<p><b>Complexity:</b> Constant. </p>
<p><b>Note: </b>The maximum load factor is initially 1.0.</p>

<pre>
      template &lt;class InputIterator&gt;
        hash_multiset(InputIterator f, InputIterator l,
                      size_type n = <b>implementation defined</b>,
                      const hasher&amp; hf = hasher(),
                      const key_equal&amp; eql = key_equal(),
                      const allocator_type&amp; a = allocator_type());</pre>

<p><b>Effects:</b> Constructs an empty <b>hash_multiset</b> using the specified hash function, key equality function, and allocator, and using at least <b><i>n</i></b> buckets. (If <b><i>n</i></b> is not provided, the number of buckets is implementation defined.) Then inserts elements from the range <b>[<i>first</i>, <i>last</i>)</b>.</p>
<p><b>Complexity:</b> Average case linear; worst case quadratic.</p>
<p><b>Note: </b>The maximum load factor is initially 1.0.</p>

<H4><FONT COLOR="#000080">b. hash_multiset swap</FONT></H4>

<pre>
      template &lt;class Value, class Hash, class Pred, class Alloc&gt;
        void swap(const hash_multiset&lt;Value, Hash, Pred, Alloc&gt;&amp; x,
                  const hash_multiset&lt;Value, Hash, Pred, Alloc&gt;&amp; y);</pre>

<p><b>Effects:</b></p>

<pre>
          x.swap(y);</pre>


<H4><FONT COLOR="#000080">6. Class template hash_multimap</FONT></H4>

<p>A <b>hash_multimap</b> is a kind of hashed associative container that supports equivalent keys (a <b>hash_multimap</b> may contain multiple copies of each key value) and that associates values of another type <b>mapped_type</b> with the keys.</p> 
<p>A <b>hash_multimap</b> satisfies all of the requirements of a container and of a hashed associative container. It provides the operations described in the preceding requirements table for equivalent keys; that is, a <b>hash_multimap</b> supports the <b>a_eq</b> operations in that table, not the <b>a_uniq</b> operations. For a <b>hash_multimap</b><b>&lt;Key, T&gt;</b> the <b>key type</b> is <b>Key</b>, the mapped type is <b>T</b>, and the value type is <b>std::pair&lt;const Key, T&gt;</b>. </p>
<p>This section only describes operations on <b>hash_multimap</b> that are not described in one of the requirement tables, or for which there is additional semantic information.</p>

<pre>
 namespace std {
    template &lt;class Key,
              class T,
              class Hash = hash&lt;Key&gt;,
              class Pred = std::equal_to&lt;Key&gt;,
              class Alloc = std::allocator&lt;std::pair&lt;const Key, T&gt; &gt; &gt;
    class hash_multimap
    {
    public:
      // types
      typedef Key                                      key_type;
      typedef std::pair&lt;const Key, T&gt;            value_type;
      typedef T                                        mapped_type;
      typedef Hash                                     hasher;
      typedef Pred                                     key_equal;
      typedef Alloc                                    allocator_type;
      typedef typename allocator_type::pointer         pointer;
      typedef typename allocator_type::const_pointer   const_pointer;
      typedef typename allocator_type::reference       reference;
      typedef typename allocator_type::const_reference const_reference;
      typedef <b>implementation defined</b>                   size_type;
      typedef <b>implementation defined</b>                   difference_type;

      typedef <b>implementation defined</b>                   iterator;
      typedef <b>implementation defined</b>                   const_iterator;

      typedef <b>implementation defined</b>
              local_iterator;
      typedef <b>implementation defined</b>
              const_local_iterator;

      // construct/destroy/copy
      explicit hash_multimap(size_type n = <b>implementation defined</b>,
                             const hasher&amp; hf = hasher(),
                             const key_equal&amp; eql = key_equal(),
                             const allocator_type&amp; a = allocator_type());
      template &lt;class InputIterator&gt;
        hash_multimap(InputIterator f, InputIterator l,
                      size_type n = <b>implementation defined</b>,
                      const hasher&amp; hf = hasher(),
                      const key_equal&amp; eql = key_equal(),
                      const allocator_type&amp; a = allocator_type());
      hash_multimap(const hash_multimap&amp;);
      ~hash_multimap();
      hash_multimap&amp; operator=(const hash_multimap&amp;);
      allocator_type get_allocator() const;

      // size and capacity
      bool empty() const;
      size_type size() const;
      size_type max_size() const;

      // iterators
      iterator       begin();
      const_iterator begin() const;
      iterator       end();
      const_iterator end() const;

      // modifiers
      iterator insert(const value_type&amp; obj);
      iterator insert(const_iterator hint, const value_type&amp; obj);
      template &lt;class InputIterator&gt;
        void insert(InputIterator first, InputIterator last);

      void erase(const_iterator position);
      size_type erase(const key_type&amp; k);
      void erase(const_iterator first, const_iterator last);
      void clear();

      void swap(hash_multimap&amp;);

      // observers
      hasher hash_funct() const;
      key_equal key_eq() const;

      // lookup
      iterator       find(const key_type&amp; k);
      const_iterator find(const key_type&amp; k) const;
      size_type count(const key_type&amp; k) const;
      std::pair&lt;iterator, iterator&gt; 
        equal_range(const key_type&amp; k);
      std::pair&lt;const_iterator, const_iterator&gt;
        equal_range(const key_type&amp; k) const;

      mapped_type&amp; operator[](const key_type&amp; k);

      // bucket interface
      size_type bucket_count() const;
      size_type max_bucket_count() const;
      size_type bucket_size(size_type n);
      size_type bucket(const key_type&amp; k);
      local_iterator begin(size_type n);
      const_local_iterator begin(size_type n) const;
      local_iterator end(size_type n);
      const_local_iterator end(size_type n) const;

      // hash policy
      double load_factor() const;
      double max_load_factor() const;
      void set_max_load_factor(double z);
      void rehash(size_type n);
    };

    template &lt;class Key, class T, class Hash, class Pred, class Alloc&gt;
    bool operator==(const hash_multimap&lt;Key, T, Hash, Pred, Alloc&gt;&amp; x,
                    const hash_multimap&lt;Key, T, Hash, Pred, Alloc&gt;&amp; y);

    template &lt;class Key, class T, class Hash, class Pred, class Alloc&gt;
    bool operator!=(const hash_multimap&lt;Key, T, Hash, Pred, Alloc&gt;&amp; x,
                    const hash_multimap&lt;Key, T, Hash, Pred, Alloc&gt;&amp; y);

    template &lt;class Key, class T, class Hash, class Pred, class Alloc&gt;
      void swap(const hash_multimap&lt;Key, T, Hash, Pred, Alloc&gt;&amp; x,
                const hash_multimap&lt;Key, T, Hash, Pred, Alloc&gt;&amp; y); }</pre>

<H4><FONT COLOR="#000080">a. hash_multimap constructors</FONT></H4>

<pre>
      explicit hash_multimap(size_type n = <b>implementation defined</b>,
                             const hasher&amp; hf = hasher(),
                             const key_equal&amp; eql = key_equal(),
                             const allocator_type&amp; a 
                               = allocator_type());</pre>

<p><b>Effects:</b> Constructs an empty <b>hash_multimap</b> using the specified hash function, key equality function, and allocator, and using at least <b><i>n</i></b> buckets. If <b><i>n</i></b> is not provided, the number of buckets is implementation defined.</p>
<p><b>Complexity:</b> Constant. </p>
<p><b>Note: </b>The maximum load factor is initially 1.0.</p>

<pre>
      template &lt;class InputIterator&gt;
        hash_multimap(InputIterator f, InputIterator l,
                      size_type n = <b>implementation defined</b>,
                      const hasher&amp; hf = hasher(),
                      const key_equal&amp; eql = key_equal(),
                      const allocator_type&amp; a = allocator_type());</pre>

<p><b>Effects:</b> Constructs an empty <b>hash_multimap</b> using the specified hash function, key equality function, and allocator, and using at least <b><i>n</i></b> buckets. (If <b><i>n</i></b> is not provided, the number of buckets is implementation defined.) Then inserts elements from the range <b>[<i>first</i>, <i>last</i>)</b>.</p>
<p><b>Complexity:</b> Average case linear; worst case quadratic.</p>
<p><b>Note: </b>The maximum load factor is initially 1.0.</p>
<H4><FONT COLOR="#000080">b. hash_multimap swap</FONT></H4>

<pre>
      template &lt;class Value, class Hash, class Pred, class Alloc&gt;
        void swap(const hash_multimap&lt;Value, Hash, Pred, Alloc&gt;&amp; x,
                  const hash_multimap&lt;Value, Hash, Pred, Alloc&gt;&amp; y);
</pre>

<p><b>Effects:</b></p>

<pre>
          x.swap(y);
</pre>

</blockquote>
</body>
</html>
