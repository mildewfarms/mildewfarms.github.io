<HTML>   
     <HEAD>
<TITLE>October 2002/STL &amp; Generic Programming</TITLE></HEAD>
<BODY BACKGROUND="" BGCOLOR="#FFFFFF" TEXT="#000000">
<H2><A HREF="../tococt.htm"></A><FONT COLOR="#FF0000">   C/C++ Contributing Editors</FONT></H2>

<HR>

<H2 ALIGN="center"><FONT COLOR="#800000">STL &amp; Generic Programming: More on C++ Metaprogramming</FONT></H2>
<H3 ALIGN="center"><FONT COLOR="#800000">Thomas Becker</FONT></H3>

<BLOCKQUOTE>
<p>Towards readable metaprograms: Literate Template Metaprogramming. (You heard it here first!)</p>
</BLOCKQUOTE>

<HR>
<BLOCKQUOTE>

<H3><FONT COLOR="#000080">Introduction</FONT></H3>

<p>In my last column, I introduced you to C++ template metaprogramming. In this column, I&#146;ll continue this discussion with some more simple examples designed to show you the relevance of template metaprogramming in everyday software development. Remember that your primary source for advanced C++ design techniques in general and template metaprogramming techniques in particular is Andrei Alexandrescu&#146;s book <a href="#1">[1]</a>.</p>

<H3><FONT COLOR="#000080">C++ Template Metaprogramming</FONT></H3>

<p>So what is this C++ template metaprogramming business all about? In my last column, I explained that C++ has a built-in mechanism to write programs that are executed entirely at compile time. The input to such a metaprogram is in the C++ code that you write, and its output is injected into that code. Here&#146;s the first example again that I gave you in my last column:</p>

<pre>
template&lt;int n&gt;
class META_FACTORIAL
{
public:
  enum{
    RET = n * META_FACTORIAL&lt;n-1&gt;::RET
  };
};

template&lt;&gt;
class META_FACTORIAL&lt;0&gt;
{
public:
  enum{ RET = 1 };
};

int main()
{
  std::cout &lt;&lt; META_FACTORIAL&lt;5&gt;::RET
            &lt;&lt; std::flush;
  return 0;
}
</pre>

<p>When the compiler encounters the expression <B>META_FACTORIAL&lt;5&gt;::RET</B> in the first line of <B>main</B>, it instantiates the class template <B>META_FACTORIAL</B> with the template parameter <B>n</B> set to <B>5</B>. This in turn will kick off recursive instantiations with <B>n</B> set to <B>4</B>, <B>3</B>, <B>2</B>, <B>1</B>, and <B>0</B>, respectively. The recursion ends when <B>n</B> equals <B>0</B>, because we have provided an explicit specialization of <B>META_FACTORIAL</B> for this case, and this explicit specialization does not contain any further nested occurrences of <B>META_FACTORIAL</B>. The net effect of this recursive instantiation process is that the expression <B>META_FACTORIAL&lt;5&gt;::RET</B> evaluates to <B>120</B> at compile time. The remarkable thing here is that in the executable code generated by the compiler, no trace remains of the way in which <B>5!</B> was calculated. The executable code that is generated is bit-by-bit identical to the one that is generated from the following source code:</p>

<pre>
int main()
{
  std::cout &lt;&lt; 120 &lt;&lt; std::flush;
  return 0;
}
</pre>

<p>In other words, our class template <B>META_FACTORIAL</B> can be viewed as a function, which, at compile time, calculates the factorial of a natural number in the exact same way as the following ordinary C++ function would:</p>

<pre>
int factorial(int n)
{
  if(0 == n)
   return 1;
  return n * factorial(n-1);
}
</pre>

<p>The metafunction <B>META_FACTORIAL</B> uses nested template instantiations to implement the recursion, and it uses explicit template specialization to implement the if construct. It is therefore fair to say that C++ has a built-in metalanguage that allows us to write programs that will be executed at compile time. In my last column, I christened this metalanguage MetaC++. MetaC++ is a rather clunky language in practice, but that does not reflect poorly on its designers, because there are none. Template metaprogramming was not conciously and deliberately built into C++. It was discovered after the fact that C++ templates could be used for the purpose of writing metaprograms.</p>

<H3><FONT COLOR="#000080">Template Metaprogramming with Types</FONT></H3>

<p>It&#146;s certainly cute to calculate the factorial of a natural number at compile time, but the relevance of this for day-to-day software development is rather limited, to put it mildly. What makes C++ template programming so useful in practice is the fact that MetaC++ functions can operate not only on integers, but also on types. To illustrate this, I will now dig a little deeper into an example that I used in my last column, namely, the infamous reference-to-reference problem. Consider the following class template:</p>

<pre>
template&lt;typename Func&gt;
class X
{
  typedef typename Func::first_argument_type
    first_arg;
public:
  X(const first_arg&amp; theFirstArg) :
    m_theFirstArg(theFirstArg) {}
private:
  first_arg m_theFirstArg;
};
</pre>

<p>This class template expects its template argument to be an adaptable binary functor (i.e., a functor that, among other things, provides a <B>typedef</B> named <B>first_argument_type</B>). Objects of type <B>X</B> store an element of type <B>Func::first_argument_type</B>, and the value to be stored is provided to the constructor of <B>X</B> as a <B>const</B> reference. Perhaps you have already guessed where I stole this code snippet. One of the most useful utilities in the STL is the function adapter <B>binder1st</B>. This adapter takes an adaptable binary functor and turns it into a new functor that behaves much like the original functor, except that the first argument is now bound to a fixed value. This fixed value is supplied to <B>binder1st</B> upon construction, together with the function object that is being adapted. Even without looking at the details of the implementation, it is quite obvious that an object of type <B>binder1st</B> must store two things: the original functor that is being adapted, and the value that is to be substituted for the original functor&#146;s first argument. My class template <B>X</B> above is nothing but a shameless excerpt from the definition of <B>binder1st</B>.</p>
<p>Chances are that in the STL implementation you are using <B>binder1st</B>&#146;s handling of the first-argument caboodle looks exactly like my class template <B>X</B> above, and it therefore has the exact same problem: if the type <B>Func::first_argument_type</B> happens to be a reference type, which is quite likely to be the case in practice, then the constructor signature:</p>

<pre>
X(const first_arg&amp; theFirstArg);
</pre>

<p>will cause a compilation error, because the compiler is looking at a reference to reference, which it rightfully refuses to deal with. And even if you could get past that point somehow, the member <B>m_theFirstArg</B> would now be stored as a <B>const</B> reference. In the special case of STL&#146;s <B>binder1st</B>, that&#146;s probably exactly what you want, but, in other situations, you may well want to store a value copy. This whole mess is one of those problems that keeps biting you if you use the STL consistently, as you should, and it is one of the main reasons why we need our compilers to support partial template specialization. For those of you who have the good fortune to be working with a compiler that already supports partial template specialization, the good news is: C++ template metaprogramming saves. We&#146;ll write two MetaC++ functions that each take a type as their argument and return a type. The first one, called <B>NONCONST</B>, strips the <B>const</B> qualifier, if any, from its type argument. The second one, called <B>NONREF</B>, strips the reference, if any, from its type argument.</p>

<pre>
template&lt;typename U&gt;
class NONCONST
{
public:
  typedef U RET;
};

template&lt;typename U&gt;
class NONCONST&lt;const U&gt;
{
public:
  typedef U RET;
};

template&lt;typename U&gt;
class NONREF
{
public:
  typedef U RET;
};

template&lt;typename U&gt;
class NONREF&lt;U&amp;&gt;
{
public:
  typedef U RET;
};
</pre>

<p>Now if we apply the composition of <B>NONREF</B> and <B>NONCONST</B> to the type <B>first_arg</B> in the declaration of class <B>X</B> above, then we&#146;ll get to the &#147;raw&#148; underlying type, stripped of the reference, if any, and the <B>const</B> qualifier, if any. We can then let the constructor take a <B>const</B> reference to that raw type, and we can declare <B>m_theFirstArg</B> to be of that raw type:</p>

<pre>
template&lt;typename Func&gt;
class X
{
  typedef Func::first_argument_type first_arg;
  typedef NONCONST&lt;NONREF&lt;first_arg&gt;::RET&gt;::RET
    raw_first_arg;
public:
  X( const raw_first_arg&amp; theFirstArg) :
    m_theFirstArg(theFirstArg){}
  
private:
  raw_first_arg m_theFirstArg;
};
</pre>

<p><a href="list1.htm">Listing 1</a> shows an extended version of the example above, where the various class templates and their partial specializations that make up the MetaC++ functions <B>NONCONST</B> and <B>NONREF</B> have been given static member function <B>trace</B>. The constructor of <B>X</B> calls the <B>trace</B> functions of <B>NONCONST</B> and <B>NONREF</B> to show you exactly how these two MetaC++ functions go about producing the type <B>raw_first_arg</B> from the given type <B>first_arg</B>. The <B>main</B> function in <a href="list1.htm">Listing 1</a> shows what happens in the four cases where <B>first_arg</B> is <B>int</B>, <B>const int</B>, <B>int&amp;</B>, and <B>const int&amp;</B>. The output of <B>main</B> is:</p>

<pre>
Default NONREF&lt;U&gt;
Default NONCONST&lt;U&gt;

Default NONREF&lt;U&gt;
NONCONST&lt;const U&gt;

NONREF&lt;U&amp;&gt;
Default NONCONST&lt;U&gt;

NONREF&lt;U&amp;&gt;
NONCONST&lt;const U&gt;
</pre>

<p>One thing I need to say here is that you should not write MetaC++ functions like <B>NONREF</B> and <B>NONCONST</B> yourself. Check out Andrei Alexandrescu&#146;s <B>type_traits</B>, which are part of his Loki library (see <a href="#1">[1]</a> for details), or Boost&#146;s <B>type_traits</B> <a href="#3">[3]</a> for some amazing techniques to get information about types and transform types at compile time. Boost&#146;s <B>call_traits</B> <a href="#4">[4]</a> also solve the reference-to-reference problem, although they don&#146;t give you a way to &#147;strip&#148; qualifiers, like the <B>NONCONST</B> and <B>NONREF</B> above do. One of the reasons why I&#146;m harping on examples of this kind is because I want you to get excited enough so that you go and download libraries like Loki <a href="#1">[1]</a> and Boost <a href="#2">[2]</a>. And if your compiler does not yet support partial template specialization, go and get the Boost stuff anyway. There are lots of things in there that you can start using right away. For example, did you know that they have a regular expression library now? All the neat stuff you could only do in perl, awk, sed, Emacs Lisp, or Python is now available to you in C++, ready to use with a nifty STL-style interface on top of it. You can give your productivity an enormous, well, boost, by putting all that good stuff to work for you. Did I mention that it&#146;s not only open source, carefully tested, peer-reviewed, and maintained by its authors, but also absolutely free?</p>

<H3><FONT COLOR="#000080">Literate Programming in MetaC++</FONT></H3>

<p>Let us look at the pseudocode for the MetaC++ function <B>NONREF</B>:</p>

<pre>
type NONREF(type U)
{
  if( U is a reference type )
    return (the type referenced by U);
  else
    return U;
}
</pre>

<p>If you compare this to the actual MetaC++ implementations of this function above, you&#146;ll see that there is little visible trace of the simple logical structure seen in the pseudocode. This is of course due to the fact that C++ template metaprogramming is not something that was designed as a programming language. It is, and I hope I&#146;m not offending anybody by saying this, a kludge that harnesses a C++ language feature that was meant for a different purpose. Therefore, template metaprogramming code is notoriously unpleasant to read. As soon as it gets a little more complex than our simple examples, you typically have to work your way through complicated partial template specializations before you can see the basic logical structure behind the whole thing. However, it is possible to improve this situation by making an effort to write template metaprograms in a somewhat literate way. It is true that MetaC++ is never going to look pretty, and there are people who say that trying to make it pretty is a quixotic effort to begin with. Let&#146;s give it a try anyway. If nothing else, you can view the following discussion as a little exercise in template metaprogramming, which actually illustrates some rather important points.</p>
<p>First off, it is possible to make the if-else branching more visible by defining a MetaC++ function <B>IF</B>. <B>IF</B> takes three template parameters, a <B>bool</B> and two types. It returns the first type if the Boolean parameter is true, and the second type otherwise:</p>

<pre>
template&lt;
  bool cond,
  typename Then,
  typename Else
  &gt;
class IF;

template&lt;typename Then, typename Else&gt;
class IF&lt;true, Then, Else&gt;
{
public:
  typedef Then RET;
};
 
template&lt;typename Then, typename Else&gt;
class IF&lt;false, Then, Else&gt;
{
public:
  typedef Else RET;
};
</pre>

<p>Notice how I&#146;m using the fact that a C++ class template does not require a default implementation. It is possible to give just a forward declaration and one or more specializations, partial or explicit, as the case may be. In this particular case, the two partial specializations are exhaustive, so it would be possible to make one of them the default, like this:</p>

<pre>
template&lt;
  bool cond,
  typename Then,
  typename Else
  &gt;
class IF
{
public:
  typedef Then RET;
};
 
template&lt;typename Then, typename Else&gt;
class IF&lt;false, Then, Else&gt;
{
public:
  typedef Else RET;
};
</pre>

<p>However, in my opinion, the first version with the two specializations is more literate, so we&#146;ll go with that. Next, we write a MetaC++ function that implements the condition that the MetaC++ function <B>NONREF</B> needs to test, namely, whether a given type is a reference type:</p>

<pre>
template&lt;typename U&gt;
class ISREF
{
public:
  enum{ RET=false };
};

template&lt;typename U&gt;
class ISREF&lt;U&amp;&gt;
{
public:
  enum{ RET=true };
};
</pre>

<p>Finally, we need a MetaC++ function that strips the reference from a reference type:</p>

<pre>
template&lt;typename U&gt;
class UNREF;

template&lt;typename U&gt;
class UNREF&lt;U&amp;&gt;
{ typedef U RET; };
</pre>

<p>Again, I am using the fact that C++ class templates do not require a default implementation. <B>UNREF</B> is defined only for reference types. We can now take a shot at re-implementing <B>NONREF</B> in a more literate way:</p>

<pre>
template&lt;typename U&gt;
class NONREF
{
public:
  typedef
    IF&lt;
      ISREF&lt;U&gt;::RET,
      UNREF&lt;U&gt;::RET,
      U
      &gt;::RET RET;
};
</pre>

<p>Unfortunately, this isn&#146;t going to work quite yet. If we use <B>NONREF</B> as defined above on a reference type, as in:</p>

<pre>
NONREF&lt;int&amp;&gt; i;
</pre>

<p>then all is well. We have just declared a plain integer variable named <B>i</B>. However, if we try to use <B>NONREF</B> on a non-reference type, as in:</p>

<pre>
NONREF&lt;int&gt; i;
</pre>

<p>then this won&#146;t compile. The compiler complains that the expression <B>UNREF&lt;U&gt;::RET</B>, which occurs in the if branch in the definition of <B>NONREF</B>, is not defined when <B>U</B> is <B>int</B>. That&#146;s true, because <B>UNREF</B>, being true to its name, is defined only for reference types. But that&#146;s not a problem, you might exclaim, because we&#146;re in the else case, and therefore, we don&#146;t need <B>UNREF&lt;int&gt;::RET</B>. We need <B>int</B> itself, like it says in the else case. And yet, the compiler&#146;s complaint is legitimate. The problem is, and I did actually mention this in my last column, that when template metaprograms are executed, there isn&#146;t the kind of laziness that we are accustomed to from working with ordinary languages. When an if-else construct is encountered at run time and the if condition is false, then whatever is in the if branch doesn&#146;t get executed. Not so at compile time. When the compiler encounters:</p>

<pre>
IF&lt;
 ISREF&lt;U&gt;::RET,
 UNREF&lt;U&gt;::RET,
 U
 &gt;::RET;
</pre>

<p>with <B>U</B> set to <B>int</B>, then it must instantiate <B>IF</B> with the three given types, one of which is <B>UNREF&lt;int&gt;::RET</B>, which does not exist. The fact that <B>ISREF&lt;int&gt;::RET</B> evaluates to false, and therefore <B>UNREF&lt;int&gt;::RET</B> is never really needed, is of no concern to the compiler. From a MetaC++ point of view, the function in the if branch gets called even if the if condition evaluates to false.</p>
<p>Here&#146;s a simple trick to work around this problem, and you should make a note of this because it is quite likely the kind of thing that will bite you in your own MetaC++ programs. We need to make it so that the class template <B>IF</B> can be instantiated without having to get <B>UNREF&lt;int&gt;::RET</B>. To this end, we first define a MetaC++ function ID, which simply returns its argument:</p>

<pre>
template&lt;typename U&gt;
class ID
{
public:
  typedef U RET;
};
</pre>

<p>Then we rewrite <B>NONREF</B> like this:</p>

<pre>
template&lt;typename U&gt;
class NONREF
{
public:
  typedef
    IF&lt;
      ISREF&lt;U&gt;::RET, UNREF&lt;U&gt;,ID&lt;U&gt; &gt;::RET::RET RET;
};
</pre>

<p>The net effect of this is the same: <B>IF</B> will now return either <B>UNREF&lt;U&gt;</B> or <B>ID&lt;U&gt;</B>, as the case may be, and taking <B>RET</B> on this takes us to what we want <B>NONREF</B> to return. Moreover, <B>NONREF&lt;U&gt;</B> will now compile (or shall we say run?) successfully for any type <B>U</B>. Of course, when we write:</p>

<pre>
NONREF&lt;int&gt; i;
</pre>

<p>then the expression <B>UNREF&lt;int&gt;</B>, for which there is no definition, will still occur inside <B>NONREF&lt;int&gt;</B>. But since we no longer have the <B>::RET</B> attached to it, as was the case before, nothing is needed from the template instantiation <B>UNREF&lt;int&gt;</B>. And lo and behold, the C++ Standard stipulates that in this situation, the compiler is required to be lazy and not even look for a definition of <B>UNREF&lt;int&gt;</B>. In other words, there is just enough laziness at compile time to let us get away with this use of the undefined template instantiation <B>UNREF&lt;int&gt;</B>.</p>
<p>In conclusion, is our new definition of <B>NONREF</B> with the <B>IF</B>, the <B>ISREF</B>, and the <B>UNREF</B> prettier than the original one with the two specializations? Maybe not; I don&#146;t know. But I insist that it is more literate, for what it&#146;s worth. Also, we have some reusable components now, like <B>ISREF</B>, and more importantly, <B>IF</B>. (A comprehensive discussion of MetaC++ control structures can be found in Czarnecki&#146;s and Eisenecker&#146;s book <a href="#5">[5]</a>). Moreover, this discussion gave me the opportunity to remind you of two aspects of C++ that are important for template metaprogramming. Number one, class templates don&#146;t need a default implementation. Number two, C++ template instantiation is lazy in the sense that you may use an instantiation for which there is no definition, as long as you don&#146;t do anything that would force the compiler to go look for a definition.</p>

<H3><FONT COLOR="#000080">References</FONT></H3>

<p><a name="1"></a>[1]  Andrei Alexandrescu. <I>Modern C++ Design</I> (Addison-Wesley, 2001).</p>
<p><a name="2"></a>[2]  &lt;www.boost.org&gt;</p>
<p><a name="3"></a>[3]  &lt;www.boost.org/libs/type_traits&gt;</p>
<p><a name="4"></a>[4]   &lt;www.boost.org/libs/utility/call_traits.htm&gt;</p>
<p><a name="5"></a>[5]  Krzystof Czarnecki and Ulrich W. Eisenecker. <I>Generative Programming, Methods, Tools, and Applications</I> (Addision Wesley, 2000).</p>

<p><i><b>Thomas Becker</B> works as a senior software engineer for Zephyr Associates, Inc. in Zephyr Cove, Lake Tahoe. He can be reached at <B>thomas@styleadvisor.com</B>.</i></p>

<h4><a href="../../../source/2002/oct02/becker.zip"></a></h4>

</blockquote></body></html>
