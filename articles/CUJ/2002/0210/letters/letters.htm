<HTML>   
     <HEAD>
<TITLE>October 2002/We Have Mail</TITLE></HEAD>
<BODY BACKGROUND="" BGCOLOR="#FFFFFF" TEXT="#000000">
<H2><A HREF="../tococt.htm"></A><FONT COLOR="#FF0000">   Departments</FONT></H2>

<HR>

<H2 ALIGN="center"><FONT COLOR="#800000">We Have Mail</FONT></H2>

<HR>
<BLOCKQUOTE>
<p><I>Letters to the editor may be sent via email to </I>cujed@cmp.com<I>, or via the postal service to Letters to the Editor, </I>C/C++ Users Journal<I>, 1601 W. 23rd St., Ste 200, Lawrence, KS 66046-2700.</I></p>
<hr><p>Hi Guys,</p>
<p>First I would like to say thanks for the fantastic magazine. The information you provide is invaluable. I&#146;ve only started reading it recently, but the number of times I&#146;ve found myself reading an article and thinking &#147;Aha!&#148; or &#147;of course, it is so simple when you think about it that way&#148; is already too many to remember. Well done. Please keep up the great work.</p>
<p>Okay, now back to the point at hand. Is it just me, or does the use of typelists as described in Andrei Alexandrescu&#146;s &#147;Generic&lt;Programming&gt;: Typelists and Applications&#148; (<I>C++ Experts Forum</I>, February 2002, &lt;www.cuj.com/experts/2002/alexandr.htm&gt;) result in very long compile times (due to the large amounts of template instantiations)? While this I can live with, a larger problem is the template instantiation depth.</p>
<p>In the article, Alexandrescu suggests techniques for using typelists of up to 50 elements; however this seems to breach the ANSI/ISO maximum template instantiation depth limit of 17 (or at least when I try to use them in my code).</p>
<p>Am I missing something? Are there techniques to decrease compilation time and reduce the template instantiation depth? Was there a reason why these issues where not mentioned in the article (possibly because they are problems I&#146;m having and not specific to typelists)?</p>
<p>Regards,</p>
<p>Tom Howard</p>

<p><I>Tom,</I></p>
<p><I>Thank you very much for your kind words and for the excellent questions.</I></p>
<p><I>First, it should be pointed out that there is no replacement technique for recursion when dealing with features such as scalable typelists. This is because the template engine is &#147;pure functional&#148; &#151; it doesn&#146;t support assignment and therefore iteration.</I></p>
<p><I>On the template instantiation depth issue, indeed the theoretical limit is 17. If this looks like an artificial and odd limit to you, that makes two of us. Fortunately, all compiler implementers that I know of either allow command-line parameters to control this limit, or naturally allow template instantiation depth limited only by the available memory. In other words, 17 is a problem, but one that tends not to appear in practice; and as your other questions suggest, we have bigger fish to fry.</I></p>
<p><I>On the compilation speed when using recursive templates, that is largely dependent of the compiler architecture. Modern implementations of functional languages such as Haskell or ML &#151; which do at run time what the C++ template engine does at compile time &#151; prove that efficient implementation is possible. Now, if compiler implementers believe recursive templates are regularly used, they will put more effort into an efficient implementation. Fortunately, this is the current trend, and I have positive experience with the Metrowerks compiler. So there is more that compiler implementers can do, rather than what we can do in user-level code.</I></p>
<p><I>Andrei Alexandrescu</I></p>

<hr><p>Dear <I>CUJ</I>,</p>
<p>I was surprised to see the article &#147;A Multiple Substring Search Algorithm,&#148; by Moishe Halibard and Moshe Rubin (June 2002). They give a <I>O(n log n)</I> average time algorithm to search a set of substrings from a given long string, where <I>n</I> is the length of the input. That algorithm runs in <I>O(nm)</I> worst case time, where <I>m</I> is the length of the longest substring.</p>
<p>This is an old and well-studied problem, the first optimal algorithm in the worst case was published in 1979 <a href="#1">[1]</a>. This algorithm runs in <I>O(n+t)</I> time, where <I>n</I> is the length of the input, and <I>t</I> is the number of occurrences reported. Several other algorithms have been proposed since then, improving this result. An optimal average case algorithm can be found for example in <a href="#2">[2]</a>, which runs in <I>O(n/m log(r))</I> expected time, and in <I>O(n+t)</I> worst case time, where <I>m</I> is the shortest substring, and <I>r</I> is the total length of the substrings. By using this algorithm and the well known &#147;pattern partitioning&#148; technique, one can achieve <I>O(n/m k log(r))</I> expected time for <I>k = O(m/log(r))</I>.</p>
<p>Reinventing the wheel can be very educational, but a literature search could save a lot of time and give the readers of <I>CUJ</I> more up-to-date information.</p>
<p>Regards,</p>
<p>Kimmo Fredriksson<br>
Department of Computer Science<br>
University of Helsinki<br>
Finland</p>

<hr><p>I would like to point out that fast (linear-time) algorithms for multiple substring searches are well-known <a href="#1">[1]</a>. Algorithms that work faster on average have also been developed. The authors might have saved some time designing and implementing their program if they had known of the GNU tool <B>fgrep</B>, which implements the Aho-Corasick algorithm.</p>
<p>Arvind Sankar<br>
Department of Math<br>
Massachusetts Institute of Technology</p>

<p><I>We&#146;d like to thank the readers who pointed out that the first algorithm for multiple string search was first published in the open literature by Aho and Corasick <a href="#1">[1]</a>. When attempting to solve our programming problem, we searched the Internet for an appropriate algorithm, but failed to find one. Our search was obviously not thorough enough. We fully agree that authors should do everything possible to avoid reinventing the wheel (and making them somewhat square in the process!). A timely posting to the appropriate newsgroup would verify whether a proposed algorithm is novel or not.</I></p>
<p><I>What is gratifying is the number of responses we received from readers thanking us for presenting our algorithm for solving the proposed problem. After a slight detour, they are ready to tackle the seminal article by Aho and Corasick.</I></p>
<p><I>The link in reference one in our article has since been removed from the Internet. Fortunately, we have since found that Christian Charras and others have reopened a newer and very impressive site: &lt;www-igm.univ-mlv.fr/~lecroq/string/index.html&gt;. This site not only carries all the content of the previous one, but each algorithm now has a Java applet that shows the algorithm in action. We&#146;re convinced you will find the site very informative.</I></p>
<p><I>See <a href="#3">[3]</a> for a taxonomy of articles related to multiple string searching.</I></p>
<p><I>Moshe Rubin</I></p>
<p><B><I>References</B></I></p>
<p><I><a name="1"></a>[1]  A. V. Aho and M. J. Corasick. &#147;Efficient String Matching: An Aid to Bibliographic Search,&#148; Communications of ACM, June 1975, pp. 333-340, &lt;www.win.tue.nl/~watson/2R080/opdracht/p333-aho-corasick.pdf&gt;.</I></p>
<p><I><a name="2"></a>[2]  M. Crochemore, et al. &#147;Fast Practical Multi-Pattern Matching,&#148; Information Processing Letters 71, 1999, pp. 107-113.</I></p>
<p><I><a name="3"></a>[3]  B.W. Watson and G. Zwaan. &#147;A Taxonomy of Sublinear Multiple Keyword Pattern Matching Algorithms,&#148; Science of Computer Programming, 27(2), pp. 85-118,&lt;http://citeseer.nj.nec.com/watson95taxonomy.html.&gt;</I></p>

<hr><p>Hi!</p>
<p>In reference to the article &#147;Using Constructed Types in C++ Unions&#148; by Kevin T. Manley (August 2002), I just wanted to point out that it is missing a very important consideration: alignment. In fact, I&#146;m really surprised he didn&#146;t even mention it.</p>
<p>Basically, the problem is that, when any of the &#147;constructed types&#148; has any specific alignment restriction, the solution he proposes might either be slower than it should, or it might not work altogether, depending on the platform the program runs on.</p>
<p>The example he showed works on Microsoft Visual C++ 6.0 because the <B>i</B> member of the <B>U</B> union already enforces enough alignment for the rest (four bytes). And, even if it weren&#146;t there, the <B>currtype</B> member of the <B>MYUNION</B> structure would also enforce the same alignment because its size and alignment are four bytes, too. (Note that other compilers might implement short-range <B>enum</B>s using less bytes and less alignment, which would also make it align the union members incorrectly.) So the solution presented might work under certain conditions, but it&#146;s neither portable nor robust.</p>
<p>One partial simple solution would be to move the <B>currtype</B> member to the end of the structure (to save space and to help with the alignment of the union by putting it as the first data member), and having the programmer add a dummy POD to the union to ensure correct alignment for the emulated union members. This would require a moderate knowledge of the particular platform&#146;s alignment requirements, and of the internals of the emulated union members, but it would fix the problem.</p>
<p>I should point out, too, that all these considerations have been discussed at length by Andrei Alexandrescu in his latest columns about discriminated unions in <I>CUJ</I>&#146;s own <I>C++ Experts Forum</I>. He also proposes a much more sophisticated solution than the one I described above.</p>
<p>Salutations,</p>
<p>Juan Carlos Arevalo-Baeza<br>
<B>jcab@roningames.com</B></p>

<p><I>Editor&#146;s Note: We received several letters from readers &#151; including a letter from </I>CUJ <I>Expert&#146;s Forum columnist Andrei Alexandrescu &#151; mentioning the possible alignment problem associated with the solution outlined in Kevin Manley&#146;s article &#147;Using Constructed Types in C++ Unions.&#148; The author&#146;s response to Alexandrescu&#146;s comments follows.</I></p>
<p><I>Andrei,</I></p>
<p><I>Thanks for taking the time to read and send feedback on my article. I recently bought your book </I>Modern C++ Design<I> and I&#146;ve been learning a lot from it.</I></p>
<p><I>Of course, you are correct about the alignment issue; I should have mentioned this in the article. While this is difficult to solve portably, I believe it can be solved satisfactorily for a given compiler/platform, so I don&#146;t know that the issue completely invalidates my approach.</I></p>
<p><I>An advantage of the approach I discussed is its simplicity. The variant class you present requires a significant amount of supporting code (~80KB) and an advanced knowledge of C++ templates. It also takes three articles to explain instead of one!</I></p>
<p><I>Performance is another consideration. Herb Sutter wrote to me with concerns similar to yours and proposed the Boost </I><B>any</B><I> class as an alternative. However the </I><B>any</B><I> class uses dynamic memory allocation and performs poorly in comparison. (I sent him a VC++ project demonstrating this). I wanted to try your variant class and profile its performance, but I don&#146;t have access to a compiler that can compile it.</I></p>
<p><I>I agree with you that I should have addressed portability and conformance to the C++ Standard in the article. However, as you know, working programmers have many concerns, and portability and conformance are not always at the top of the list (though perhaps they should be.) In evaluating a solution one might also consider compatibility with current compilers, readability, maintainability, dependencies/coupling, run-time performance, etc.</I></p>
<p><I>Perhaps we can agree there&#146;s a need for a portable way to get the alignment information essential for using </I><B>placement new</B><I> with a static buffer. That would help us both.</I></p>
<p><I>Best regards,</I></p>
<p><I>Kevin T. Manley</I></p>

<p><I>Editor&#146;s Note: Andrei Alexandrescu responded that he still considers the solution dangerous and expressed the concern that it might cause undefined behavior. For further study of this matter of C++ unions, see Alexandrescu&#146;s series on &#147;Discriminated Unions&#148; at the </I>CUJ<I> website: &lt;www.cuj.com/experts/author_index.htm&gt;.</I></p>

<hr><p>RE: C and C++: A Case for Compatibility</p>
<p>I gather by the tone of the article that Mr. Stroustrup doesn&#146;t like the recent changes that have driven C and C++ apart. I completely agree. C++ was originally presented to me as the C language with the addition of object-oriented constructs. The idea was to write C code that was object oriented. Since there is nothing in C that contradicts object-oriented design, it seemed natural to move to using C++.</p>
<p>I think that there are numerous advantages to keeping C a subset of C++:</p>
<OL><LI>Anything that is useful in C is useful in C++. There was a recent addition to C of a new numeric type. Proponents of separation say that C++ allows users to create their own types, so they don&#146;t need it. This is hogwash. If the type is so important that it becomes part of a language, then enough users must need it that it should be in both languages. Making C++ users all implement their own type just because they can is time consuming and error prone.</LI>
<LI>More jobs. Yes, it is selfish, but I like the idea of being able to go from a C++ programming job to a C programming job without a learning curve. It makes me more marketable and will save my butt if the C++ work dries up in my area.</LI>
<LI>I won&#146;t have to buy two compilers. This could happen if the languages separate enough. There really only needs to be one compiler with switches to tell it to allow C++ constructs. Actually, the only reason to even tell the compiler that the code is C code is to reduce the extra code that might get generated. The compiler could easily decide the best way to generate the code.</LI></OL>
<p>So going with that last comment, I think that C should become obsolete, and C programmers should just program in C using C++. That&#146;s right: one language, one compiler! I write C programs often, but I don&#146;t bother to use a different file extension to tell the compiler to act differently, I just write non-object-oriented code without C++ features. Who&#146;s to say that the C language should not have overloading? It&#146;s not an object-oriented construct, and it might be meaningful to anyone using C also. C was originally a subset of C++, so there was never a reason to make them separate. A few different words and an accent doesn&#146;t really make American English a different language from UK English, does it?</p>
<p>Thanks,</p>
<p>David Rector<br>
Senior Software Engineer<br>
TimeLogic Corporation<br>
<b>davidr@timelogic.com</b></p>
</blockquote></body></html>
