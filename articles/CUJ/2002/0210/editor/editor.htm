<HTML>   
     <HEAD>
<TITLE>October 2002/Editor's Forum</TITLE></HEAD>
<BODY BACKGROUND="" BGCOLOR="#FFFFFF" TEXT="#000000">
<H2><A HREF="../tococt.htm"></A><FONT COLOR="#FF0000">   Departments</FONT></H2>

<HR>

<H2 ALIGN="center"><FONT COLOR="#800000">Editor's Forum</FONT></H2>

<HR>
<BLOCKQUOTE>

<H3><FONT COLOR="#000080">Euclid Alone</FONT></H3>

<p>I find it interesting that I learned more about clear technical writing from a math class I took in 1977 than from all of the English classes I ever took combined. Dr. Douglas Campbell not only taught Lebesgue Measure and Integration in BYU&#146;s Math 641; he taught and demanded succinct, to-the-point exposition. I recall an assignment where I had fallen back on low-level, undergraduate techniques to solve a particular problem. Dr. Campbell handed it back with this message: &#147;Yes, technically you&#146;ve &#145;solved&#146; the problem, but you have not used the power of the Dominated Convergence Theorem. Do it over, and in less than half the space.&#148; It was not acceptable to just &#147;get by&#148;; we were expected to use all the high-level abstractions available to us to solve problems in the simplest way possible.</p>
<p>At about the same time, a couple of distinguished gentlemen from AT&amp;T wrote a book on how to write good programs <a href="#1">[1]</a>. In those days, developers tended to spend more time reviewing hard copies than using terminals and would mark up their code with red pencils, rather than use a software tool, such as an intelligent editor or pattern-matcher, to find text and make changes. Note this excerpt from the text: &#147;Far too many programmers are red pencillers. Some are literal red pencillers who do things by hand that should be done by machine. Others are figurative red pencillers whose use of the machine is so clumsy and awkward that it might as well be manual.&#148;</p>
<p>A year or so later another book <a href="#2">[2]</a> from some AT&amp;T folks introduced a language named, tersely enough, &#147;C,&#148; described as &#147;a general-purpose programming language, which features economy of expression, modern control flow and data structures, and a rich set of operators... its absence of restrictions and its generality make it more convenient and effective for many tasks than supposedly more powerful languages.&#148; Talk about an understatement.</p>
<p>Nowadays programmers routinely use software libraries and hide new complexity inside new abstractions. Or do they? Do they use all the power available to them, or are they &#147;red pencillers?&#148; Do they employ &#147;economy of expression&#148; or do they just churn out code and think later? Does it even matter?</p>
<p>It matters. In 1990 I joined a project that attempted to &#147;reuse&#148; some C code that was written by data processing &#147;veterans&#148; who didn&#146;t bother to learn anything from the standard library beyond <B>getc()</B> and <B>printf()</B>. Not only was it unfit for reuse, it was barely fit for &#147;use&#148; and thoroughly unreadable. When a consultant was brought on board to help us out, he took all of three minutes to conclude, &#147;I&#146;m sorry, I just can&#146;t work with this code.&#148; As an exercise I rewrote one (multi-page) function from that code using my knowledge of the library. It came out one-seventh the original size and an order of magnitude more readable (at least).</p>
<p>A scientific description of &#147;good code&#148; may elude us, but it leaves the experienced programmer with that &#147;good feeling&#148; <a href="#3">[3]</a>. The terms simplicity, clarity, and generality have recently been used to describe it <a href="#4">[4]</a>. Consider the now-trite &#147;word count&#148; program that uses a map data structure to keep track of the number of instances of each word in a document. In Java, a language not known for its economy of expression, you&#146;ll need code something like the following to process a word:</p>

<pre>
if (!myMap.containsKey(key))
    myMap.put(key, new Integer(1));
else {
    Integer count = (Integer) myMap.get(key);
    int icount = count.intValue();
    myMap.put(key, new Integer(++icount));
}
</pre>

<p>whereas in C++ it is simply:</p>

<pre>
myMap[key]++;
</pre>

<p>More expressive power begets higher-level programming, which in turn leads to elegant, readable code.</p>
<p>Perhaps it was the power of uncluttered logical expression that caused Edna St. Vincent Millay to claim that the mathematician &#147;Euclid alone has looked on Beauty bare.&#148; Elegance matters because it addresses the human side of programming. Code that comes out clean, that traffics in well-defined abstractions without repeating low-level details, and that communicates with programmers as well as the machine is code that is likely to serve its purpose throughout a long and healthy life. Such well-tended software also saves time and money over the proverbial Long Haul. Let&#146;s not leave Euclid lonely.</p>

<p>Chuck Allison</p>
<p><a name="1"></a>[1]  Kernighan and Plauger. <I>Software Tools</I> (Addison-Wesley, 1976).</p>
<p><a name="2"></a>[2]  Kernighan and Ritchie. <I>The C Programming Language</I> (Addison-Wesley, 1978).</p>
<p><a name="3"></a>[3]  Or if you prefer, the &#147;quality without a name.&#148; See Alexander&#146;s <I>A Timeless Way of Building</I> (Oxford University Press, 1979).</p>
<p><a name="4"></a>[4]  Kernighan and Pike. <I>The Practice of Programming</I> (Addison-Wesley, 1999). </p>

</blockquote></body></html>
