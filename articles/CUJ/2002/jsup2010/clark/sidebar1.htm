<html><HEAD>
<TITLE>Java Solutions October 2002/Dynamically Binding EJBs Using the Java Reflection API/Sidebar</TITLE></HEAD>
<BODY BACKGROUND="" BGCOLOR="#FFFFFF" TEXT="#000000">

<H3 align=center><FONT COLOR="#000080">Implementing and Deploying a Session Bean</FONT></H3>

<HR>

<BLOCKQUOTE>
<p>For a comprehensive introduction to EJBs, I highly recommend Richard Monson-Haefel&#146;s book <a href="clark.htm#1">[1]</a>. This sidebar describes the overall process for implementing and deploying a stateless session bean that exposes a remote interface to its clients.</p>
<p>You may download the example application and its source code from &lt;www.cuj.com/java/code.htm&gt;. In order to use the example, you will need a J2EE application server that implements the EJB Specification v2.0 <a href="clark.htm#2">[2]</a>. I used the J2EE v1.3.1 reference implementation freely available from Sun Microsystems. To compile the application&#146;s source code, I employed Ant v1.4.1 from the Apache Software Foundation&#146;s Jakarta Project and the JDK v1.3.1_03 from Sun Microsystems.</p>
<p>Session Beans are frequently used to implement workflow within an application. They come in two flavors: stateful and stateless. The distinction is simple. From a client object&#146;s perspective, a stateful session bean maintains a consistent state across the set of method calls the client makes to it. A stateless session bean does not guarantee this conversational consistency. As a result, stateless session beans are lightweight and cheap to employ (in terms of both relative resource consumption and performance).</p>
<p>Imagine an application in which a stateless session bean called <B>StaticLiaisonBean</B> enlists a second stateless session bean called <B>UpperCaseConverterBean</B> to perform some unit of work. <B>StaticLiaisonBean</B> exposes a method called <B>forward</B> to its clients that accepts a character string and returns the string in a modified form. In order to modify this string, <B>StaticLiaisonBean</B> calls <B>UpperCaseConverterBean</B>&#146;s exposed <B>process</B> method. This method also accepts a character string and returns one. As you can guess, this bean merely converts the given string to all uppercase. To create this application, I performed three activities: bean development, component and application assembly, and application deployment. I also wrote a trivial client to exercise the application.</p>
<p>To create a session bean, I must write the implementing class as well as a home interface and a proxy interface. These two interfaces allow client objects to acquire and interact with the bean. (The deployment tools associated with a specific application server take these two interfaces and automatically generate implementing classes.)</p>
<p>For a session bean such as <B>StaticLiaisonBean</B>, the implementing class (<a href="list1.htm">Listing 1</a>) must implement the interface <B>javax.ejb.SessionBean</B>. This interface contains the callback methods that the application server will use to manage this bean. Since this interface includes a number of methods that are superfluous to a stateless session bean, I have employed an adaptor class <a href="clark.htm#3">[3]</a> (<a href="list2.htm">Listing 2</a>) to minimize clutter in the bean&#146;s class. In fact, the only callback needed in this example is <B>ejbCreate</B>, which is analogous to a constructor in the conventional Java world. In <B>ejbCreate</B>, the bean acquires a reference to its assistant, <B>UpperCaseConverterBean</B>. I will discuss this acquisition process in more detail in the main article. The bean class must also define the <B>forward</B> business method it exposes to its clients. In this case, the method just displays evidence that it was invoked and passes the given string on to its assisting bean.</p>
<p>The proxy interface (<a href="list3.htm">Listing 3</a>) contains the set of business methods that a bean exposes to its clients. In this application, the proxy interface for both beans extends the <B>javax.ejb.EJBObject</B> interface. The home interface (<a href="list4.htm">Listing 4</a>) contains the set of bean lifecycle methods that clients may use to acquire and release instances of a bean. In this application, the home interface exposes a simple <B>create</B> method that accepts no arguments and returns a reference to the bean&#146;s proxy interface.</p>
<p>Once the class and interface files compile, I turn to component and application assembly. A component is simply a set of beans and their associated supporting classes. Each component is deployed in its own jar file. After I marshal each bean into its component jar file, I write the component&#146;s deployment descriptor. Once the components are assembled, I marshal their jar files into the application ear file and write the application deployment descriptor.</p>
<p>Component deployment descriptors (<a href="list5.htm">Listing 5</a>) contain metadata for each bean in the component. Bean metadata includes the bean&#146;s name and class, values for its environment variables (<B>env-entry</B> stanzas), and a list of every enterprise bean with which it may interact (<B>ejb-ref</B> stanzas). The application metadata (unique to each application server) captured in its deployment descriptor (<a href="list6.htm">Listing 6</a>) includes the set of JNDI (Java Naming and Directory Interface) namespace entries (<B>jndi-name</B> stanzas) that need to be bound to the application server&#146;s namespace upon deployment of the application. In EJB 2.0, a deployment descriptor is a series of nested XML stanzas stored in a file. The DTD (document type definition) that defines a valid deployment descriptor is in the EJB Specification.</p>
<p>The J2EE reference implementation has a helpful GUI deployment tool that makes component and application assembly a fairly straightforward process. If you have it available, you may open this application&#146;s ear file and view all of the metadata. Otherwise, you may employ the jar utility to unpack the ear file and its contained jar files to view the metadata in XML form.</p>
<p>Application deployment is an automated process in which the vendor&#146;s deployment tool generates a class that implements the remote interface and another that implements the remote home interface for each bean. The deployment tool also generates a set of helper classes to complete each bean&#146;s integration with the target application server. Finally, the deployment tool packages all of these new files into the appropriate component jar file and then adds application-server-specific deployment descriptors to the application&#146;s ear file.</p>
</blockquote></body></html>
