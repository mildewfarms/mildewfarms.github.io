<HTML>   
     <HEAD>
<TITLE>July 2002 C++ Experts Forum/The (B)Leading Edge</TITLE></HEAD>
<BODY BACKGROUND="" BGCOLOR="#FFFFFF" TEXT="#000000">
<H2><A HREF="../../20.07/tocjul.htm"></A><FONT COLOR="#FF0000">   C++ Experts Forum</FONT></H2>

<HR>

<H2 ALIGN="center"><FONT COLOR="#800000">The (B)Leading Edge: Building an Indexed File Using XDRStream, Part 3</FONT></H2>
<H3 ALIGN="center"><FONT COLOR="#800000">by Jack W. Reeves</FONT></H3>

<HR>
<BLOCKQUOTE>

<H3><FONT COLOR="#000080">Introduction</FONT></H3>

<p>In this installment of &quot;The (B)Leading Edge,&quot; I am (finally) going to start walking through the implementation of the <b>IndexedFile</b> class that I have designed. This is going to take several installments; I am sure most of you probably look forward to a code walkthrough with much the same enthusiasm as you do a visit to the dentist. Nevertheless, I want to do this for a couple of reasons: first there is a lot of C++ here and that is what this column is all about. Actually, most of the code here is pretty much classical C++ &#151; with the obvious exception of the templates. Also, a lot of this code is built around the STL and uses some seldom seen functions of the standard library, so it is possibly new to a lot of readers. There are also a few patterns used here, and I think that is important. In any case, the code gives me the opportunity to show how various features of C++, both old and new, work together in a fairly complicated design. Secondly, walking through the design in detail gives me a chance to explain and discuss several trade-offs that I had to make. I mentioned a few of these in my last column, but actually seeing what impact they have on the code (or could have) should make things a lot clearer. These trade-offs are what makes software design difficult. They are also what makes it interesting. As it is, I do not intend to go through all of the code, just the important parts. Unfortunately, when you get right down to it, there is usually no such thing as un-important code. </p>

<H3><FONT COLOR="#000080">BtreeIndex Overview</FONT></H3>

<p><a href="list1.htm">Listing 1</a> <a href="#1">[1]</a> contains the definition of the class <b>IndexedFile</b> and its associated classes.</p>
<p>The following classes are defined in the <b>IndexedFile</b> header. The nesting applies to the classes definitions as well.</p>

<pre>
XDR_Traits
BtreeIndex
    Iterator
    StreamPosProxy
    Page
    RootPage
    PageCache
    XIODataStreambuf
    XInDataBuf
    XOutDataBuf
    KeyInfo
IndexedFile
    ItemProxy
    Iterator
</pre>

<p>In this column, I am going to concentrate on the internal <b>BtreeIndex</b> classes <b>Page</b>, <b>RootPage</b>, <b>XInDataBuf</b>, and <b>XOutDataBuf</b>. </p>
<p>The heart of <b>IndexedFile</b> is its use of a B-tree as the index. While B-trees (devised by Bayer &amp; McCreight) are described in a number of books, my reference is Sedgewick <a href="#2">[2]</a>. Fundamentally, a B-tree consists of <i>nodes </i>that are stored externally in fixed-size <i>pages</i>. (I will simply refer to <i>pages</i> from now on.) Each page contains several keys plus links to other pages. <a href="fig1.htm">Figure 1</a> shows a simple depiction of a B-tree that uses integers for keys. Typically, when keys are fixed size, each page can hold <i>M</i> keys. The requirement for a B-tree is that every page (except the root) must contain at least <i>M/2</i> keys. As the tree grows, this requirement is maintained by splitting a page when it is full. When the tree shrinks, meeting this requirement requires shuffling keys between pages to ensure that each has at least <i>M/2</i> keys, and/or consolidating pages whenever two adjacent pages contain less than <i>M</i> keys between them. As I discussed in my introduction to <b>IndexedFile</b> <a href="#3">[3]</a>, it is often useful to relax the requirement for having at least <i>M/2</i> keys in a page to simplify the process of removing an entry from the B-tree.</p> 
<p>The above description is for a classical B-tree, but, in my implementation, keys are not required to be fixed-size. The only requirement is that it be possible to store the key in an <b>XDRStream</b>. So I have made the following changes to B-tree requirements. In class <b>BtreeIndex</b>, an internal page (node) is stored externally as a fixed-size page that is encoded using XDR. Internally, a page must be able to hold at least two keys (actually key/link pairs). Stated another way, the encoded representation of a key must take up less than half the available space in a page. A page is split whenever adding another key to it would cause the encoded length of the page to exceed the specified <b>PageSize</b>. Splitting a page involves finding the key in the page where encoding the keys up to that point would use more than half the available space and then moving all the rest of the keys to a new page. </p>
<p>With these changes, I can no longer say that a page will hold exactly <i>M</i> keys when full, or that every page will contain at least <i>M/2</i> keys, but on average the requirements still hold.</p>

<H3><FONT COLOR="#000080">Encoding a Page</FONT></H3>

<p>Since a page is the heart of a B-tree, let us start with that. Again, let me emphasize that a page has both an internal and an external representation. Externally, a page is fixed size, and its XDR encoding is described like this:</p>

<pre>
Page {
    unsigned int      num_keys;
    unsigned int      prev_page;
    unsigned int      next_page;
    unsigned int      dummy;      // always 0
    opaque            data[PageSize - 16];
};
</pre>

<p>Remember this is XDR notation here, not C, even though it looks pretty much the same. The <b>PageSize</b> constant is the fixed size of a page (in bytes) as specified by the template argument. The data portion of the page &#151; the part that actually contains the keys &#151; is treated as an opaque array whose length is the <b>PageSize</b> minus the encoded lengths of the previous members. Those members indicate the number of keys actually encoded in the data area, and the page reference IDs of this page's siblings in the B-tree. A page's ID is the same as its <b>XDRStream</b> offset. A page ID of -1 is considered invalid and indicates that there is no such page. Note that if the page is empty &#151; which means it has had all the keys it once contained removed &#151; it will be placed on a linked list of similar pages. In this case, <b>next_page</b> references the next empty page on the list. The dummy member will be explained below. </p>
<p>In addition to regular pages, there is certain information about the B-tree index as a whole that needs to be stored externally. I decided to store that information in the root page. The XDR encoding of the root page is shown here:</p>

<pre>
RootPage {
    unsigned int      depth_page_size;
    unsigned int      total_keys;
    unsigned int      num_keys;
    unsigned int      free_page;
    opaque            data[PageSize - 16];
};
</pre>

<p>This is just a little trickier. The first element is actually a combination of the <b>depth</b> of the tree and the <b>page_size</b>. I assume that an ordinary short <b>int</b> (C++ type) is sufficient to represent either of these values, so I encode them together into a single unsigned integer (XDR type). The next value (<b>total_keys</b>) is the total number of keys currently held in the <b>BtreeIndex</b>. The <b>num_keys</b> member is the same as for a regular page &#151; the number of keys in the data portion. Finally, the <b>free_page</b> member is the page ID of the first empty page on the free list. If this member is -1, there are no free pages in the index. Although it was not strictly necessary, I added a dummy member to the <b>Page</b> structure so that the data portion of both <b>Page</b> and <b>RootPage</b> would have the same length.</p>
<p>Finally, for completeness sake, I note that the data portion of either page can be thought of as an encoded <b>XDRStream</b> containing zero or more of the following:</p>

<pre>
KeyInfo {
    Key                key;
    unsigned int       offset;
};
</pre>

<p>In this case, <b>Key</b> is the template argument, and it is encoded/decoded using the functions supplied in the <b>XDR_Traits</b> template argument. The offset member is a stream position expressed in terms of <b>XDR_Chars</b>. If the page is an internal node in the <b>BtreeIndex</b>, then the offset represents the page ID of another page in the index. If the page represents a leaf node in the tree, then the offset is the location in the data file of the actual item for that key.</p> 
<p>Now, let us look at class <b>Page</b> itself. Internally, a <b>Page</b> contains the following data members:</p>

<UL><LI><b>_pageId</b> &#151; Represents the offset to this page in the index.</LI>
<LI><b>_dataLen</b> &#151; The length of the encoded <b>KeyInfo</b> collection.</LI>
<LI><b>_prevPage</b> &#151; The sibling page with keys less than those on this page.</LI>
<LI><b>_nextPage</b> &#151; The sibling page with keys greater than those on this page.</LI>
<LI><b>_dirty</b> &#151; A boolean flag that indicates that the page has been changed and not yet saved externally.</LI></UL>

<p>Finally, a <b>Page</b> contains a <b>_keyList</b> member, which is a collection of <b>KeyInfo</b> objects. </p>
<p>The <b>KeyInfo</b> <b>struct</b> is internal to <b>Page</b> and contains the expected <b>Key</b> object and the link to either another page or the data. In addition, <b>KeyInfo</b> contains a data member that holds the length of the object when it is encoded.</p>
<p>Choosing the <b>KeyList</b> container involved the first of several trade-offs that I mentioned above. The obvious implementation would use a <b>vector</b> for the container. Unfortunately, a <b>vector </b>also has some obvious drawbacks: specifically whenever a new key is added to the index or a key is removed, then an <b>insert</b> or a <b>delete</b> has to be performed on the <b>vector</b>. As everyone knows, inserting or removing an element from a <b>vector</b> (anywhere except the end) is an expensive (<i>O(n)</i>) operation. This is even truer when a page has to be split or consolidated since that would involve copying a number of elements to a new <b>vector</b> and then erasing the same elements in the original <b>vector</b>. The expense of all this copying depends upon how expensive it is to copy a <b>Key</b> object &#151; which is a user supplied type that I have no control over. As a result, I decided to use a <b>list</b> container instead of a <b>vector</b>. Besides not having to make any copies when an element is inserted or deleted from the container, the standard <b>list</b> container provides several <b>splice</b> functions, which take the elements from one list and move them to another list by simply updating internal pointers. This eliminates the need to copy elements between containers at all.</p> 
<p>The downside of using a <b>list</b> is that my <b>BtreeIndex</b> iterators carry a slot number representing the actual <b>KeyInfo</b> item within a page. It is necessary to use this index instead of something like an iterator (or pointer) because the latter could be invalidated if a <b>Page</b> is flushed out of the cache. This means looking up an item involves scanning through the list to find the correct slot. This is not an especially complex or time-consuming operation, but it is more complex and time consuming (<i>O(n)</i>) than the constant time (<i>O(1)</i>) access a <b>vector</b> provides. Nevertheless, I decided to accept this extra overhead because it is an overhead that is relatively well controlled. Yes, it will vary somewhat by the number of items in a page, which in turn can vary by the <b>PageSize</b> specified by the user, but I figured that was much less likely to cause major fluctuations in performance than what might otherwise happen when trying to copy large numbers of <b>Key</b> objects.</p> 
<p>Having said all that, I note two things: first, all this depends upon pages being in memory. If a page is not in the cache, it has to be fetched from the external store, and it is assumed that this operation completely dominates all other performance considerations. Secondly, I will admit that I designed the <b>Page</b> from the outset to use a <b>list</b> primarily because I thought it was cool to use the <b>splice</b> functions. Only later, when I switched (briefly) to using a <b>vector,</b> did I come up with the rationalizations above. I mention this because it also is part of the reality of software design &#151; sometimes you get things right, but for the wrong reasons. It never hurts to check out the alternatives just to be sure, however.</p>

<H3><FONT COLOR="#000080">Member Functions</FONT></H3>

<p>For member functions, <b>Page</b> contains the usual suspects of constructor, destructor, member access functions, and a few member update functions. In addition it contains the following special operations: </p>

<pre>
bool          must_split() const;
size_t        add_key(BtreeIndex&amp;,
                  const std::pair&lt;const Key, size_t&gt;&amp;);
bool          remove_key(int slot);
void          update_key(size_t slot, size_t link);
void          insert_page_link(KeyList::iterator kit, Page* p);
void          update_page_link(Page* p);
bool          remove_page_link(Page* p);

// virtual functions
virtual Page*              split(BtreeIndex&amp;); 
virtual Page*              consolidate(BtreeIndex&amp;);
virtual Page*              shuffle(BtreeIndex&amp;); 
virtual oXDR_Stream&amp;   encode(oXDR_Stream&amp;);
virtual iXDR_Stream&amp;   decode(iXDR_Stream&amp;);
</pre>

<p>I will go through each of these (and the constructor) below.</p>

<H3><FONT COLOR="#000080">Page Constructor</FONT></H3>

<p>The constructor is shown below. It takes one argument and just initializes the member variables. You will note that the member <b>_pageId</b> is marked as a <b>const</b> member, so it has to be initialized by the constructor. The <b>pageId</b> is the link between the internal page structure and the location of the external page and can never change. You will also note that the copy constructor and copy assignment operator are declared private and not implemented. This is the typical C++ idiom to prevent copying of an object. It doesn't make any sense to have more than one internal representation of a single external object floating around, so I disallowed copying.</p> 

<pre>
BtreeIndex&lt;Key,Compare,KeyTraits,PageSize&gt;::Page::Page(
    size_t pid)
 : _pageId(pid),
    _dataLen(0),
    _prevPage(-1),
    _nextPage(-1),
    _dirty(false),
    _keyList()
{
       // empty
}
</pre>

<H3><FONT COLOR="#000080">Encode/Decode</FONT></H3>

<p>Encoding and decoding a page provide the connection between the internal representation and the externally stored version. In a sense, the <b>Page::decode</b> member function is the real constructor. So let me get these two functions out of the way. They are both shown below:</p>

<pre>
oXDR_Stream&amp;
BtreeIndex&lt;Key,Compare,KeyTraits,PageSize&gt;::Page::encode(
    oXDR_Stream&amp; xstrm)
{
    xstrm.seekp(_pageId);

    xstrm &lt;&lt; _keyList.size();
    xstrm &lt;&lt; _prevPage;
    xstrm &lt;&lt; _nextPage;
    xstrm &lt;&lt; 0;

    char data[PageSize - HeaderSize];
    XOutDataBuf xdatastrm(xstrm, data, sizeof(data));

    KeyList::iterator it = _keyList.begin(); 
    for (; it != _keyList.end(); ++it) {
        KeyTraits::encode(xdatastrm, (*it).key) &lt;&lt; (*it).link;
    }
    xstrm.put_opaque(data, sizeof(data));

    _dirty = false;
    return xstrm;
}


iXDR_Stream&amp;
BtreeIndex&lt;Key,Compare,KeyTraits,PageSize&gt;::Page::decode
    (iXDR_Stream&amp; xstrm)
{
    xstrm.seekg(_pageId);

    unsigned int numKeys;
    unsigned int dummy;
    xstrm &gt;&gt; numKeys;
    xstrm &gt;&gt; _prevPage;
    xstrm &gt;&gt; _nextPage;
    xstrm &gt;&gt; dummy;

    char data[PageSize - HeaderSize];
    xstrm.get_opaque(data, sizeof(data));

    XInDataBuf xdatastrm(xstrm, data, sizeof(data));

    _dataLen = 0;
    _keyList.clear();
    while (numKeys-- &gt; 0) {
        KeyInfo info;
        info.xlen = short(xdatastrm.tellg()); // the start
        KeyTraits::decode(xdatastrm, info.key);
        xdatastrm &gt;&gt; info.link;
        info.xlen = short(xdatastrm.tellg()) - info.xlen;
        _dataLen += info.xlen;
        _keyList.push_back(info);
    }
    return xstrm;
}
</pre>

<p>There is nothing too special about either of these functions, but a couple of points should be noted. First, they both begin with a seek to position the stream to the correct offset for this page. Second, the external representation stores the number of <b>KeyInfo</b> items in the data area, but I let the container handle that information in the internal version. On the other hand, the internal version keeps track of the total encoded length of the data area, but I do not actually encode that information. Finally, note that <b>encode</b> clears the dirty flag as its last operation. This indicates that the page no longer has changes that have not been stored externally.</p>
<p>The major aspect of both functions is the use of classes <b>XOutDataBuf</b> and <b>XInDataBuf</b> to actually encode/decode the <b>KeyInfo</b> objects. I will concentrate on the <b>decode</b> function since it is slightly more complicated. </p>
<p>After decoding the header information from an external page, the function then reads the <b>KeyInfo</b> data into a buffer using the <b>get_opaque</b> function. Recall that this is an <b>XDRStream</b> function that simply reads octets without any interpretation. This information is read into a fixed-sized array that is declared to be the size of a page minus the header information. At this point, all that is left is to decode the key/link information from the buffer. Unfortunately, it is at this point that some more of those design trade-offs crop up.</p>
<p>On the one hand, a <b>BtreeIndex</b> is not an <b>XDRStream</b> &#151; in the classical OO design sense of inheriting from class <b>XDR_Stream</b>. On the other hand, I require the client to provide <b>XDR_Stream</b> <b>encode</b> and <b>decode</b> functions for a <b>Key</b>. From the client's standpoint, or at least from the standpoint of encoding/decoding a <b>Key</b>, a <b>BtreeIndex</b> must be an <b>XDR_Stream</b>. There are certain <b>XDR_Stream</b> functions that the <b>Key</b> <b>encode</b>/<b>decode</b> functions have access to that may need to be set externally by the client in order for the functions to work correctly. (If we were talking about regular IOStream operations, what I mean is something like the client being able to set the locale for the stream before certain <b>insert</b>/<b>extract</b> operations will work correctly.) Likewise, there are functions such as <b>xalloc</b>, <b>iword</b>, and <b>pword</b>, which the <b>encode</b>/<b>decode</b> functions might use and expect to act as if they came from the same stream each time. You will note that the <b>XInDataBuf</b> constructor takes as an argument the current <b>XDRStream</b> object. This is precisely so that I can make a copy of all the pertinent information when the <b>XInDataBuf</b> stream is created. I will discuss <b>XInDataBuf</b> (and <b>XOutDataBuf</b>) below, but for now let me address some higher-level questions. </p> 
<p>The first question is &quot;why not inherit <b>BtreeIndex</b> from <b>XDR_Stream</b>&quot; and be done with it. More specifically, why not have <b>BtreeIndex</b> be an <b>XDRStream</b> and just use it as such whenever needed? The simple answer is that I do not consider a <b>BtreeIndex</b> as a substitute for an <b>XDRStream</b>. To me, this an example of the classic OO design problem of whether you can inherit class <b>Square</b> from class <b>Rectangle</b>. Is a <b>Square</b> a <b>Rectangle</b>? Yes, mathematically, but not (necessarily) in a software design sense. The <b>BtreeIndex</b> &quot;is-a&quot; <b>XDRStream</b> question is complicated considerably by the fact that the external representation of a <b>BtreeIndex</b> is a file that is (deliberately) an XDR data stream. Likewise, there are a number of <b>XDRStream</b> functions that <b>BtreeIndex</b> has to provide (not to mention ordinary IOStream functions like <b>open</b>), so why shouldn't the internal representation reflect this commonality. I will try to answer this question from a couple of different perspectives. </p> 
<p>The first is that <b>XDRStream</b> does not care about the data in the stream, as long as it meets the minimum criteria of being an integral number of <b>XDR_Chars</b> in length. <b>BtreeIndex</b> does care about the data in the stream. It requires that the stream contain stored <b>Page</b> objects, with the additional requirements that the first <b>Page</b> has to be a stored <b>RootPage</b>, and that every file representing a <b>BtreeIndex</b> has to have at least the <b>RootPage</b> stored in it. There are other criteria about how the pages relate to each other, but the point is that <b>BtreeIndex</b> is a higher-level abstraction than <b>XDRStream</b>; it is not simply a special form of <b>XDRStream</b>. </p>
<p>Another way of looking at it is to ask, &quot;If I use a <b>BtreeIndex</b> somewhere an <b>XDR_Stream</b> is expected, can <b>XDR_Stream</b> operations destroy the integrity of my <b>BtreeIndex</b>?&quot; Again, the answer is complicated by the fact that we must consider both internal and external representations. Obviously, if we treat a <b>BtreeIndex</b> as an ordinary <b>XDR_Stream</b>, we can do things to the file that will destroy the index, but is this relevant to the design of the internal objects? Could I invalidate my <b>BtreeIndex</b> object by applying <b>XDR_Stream</b> operations to it? To me, the internal (object) representation of a <b>BtreeIndex</b> and its external (XDR file stream) representation are linked, and as such it should not be possible to use the internal object is such a way that it would destroy the integrity of the external file. Having said all that, I will admit that it is still something of a judgment call.</p> 
<p>So, if I choose to not inherit <b>BtreeIndex</b> from <b>XDR_Stream</b>, I still have the question of why use a separate stream (<b>XInDataBuf</b>) to decode the <b>KeyInfo</b> objects instead of just reading them using the main <b>XDR_Stream</b> member object? The answer to this is simpler. Whenever a new key is added to the index, I have to figure out how long its encoded form will be. Rather than write it to the external file, it seems much better to just encode it into a string and then ask how long the string is. I had an <b>XIOStringStream</b> class type already created that works much like the standard <b>stringstream</b> class, but I realized that I needed both more functionality than <b>XIOStringStream</b> provided, and less. So I originally created a <b>XIODataBuf</b> class to use whenever I needed to encode a key to find out its encoded length. Once I had the class (or at least its <b>XIODataStreambuf</b>), I figured that I might as well use it for other things. I ended up with two <b>BtreeIndex</b> internal classes: <b>XInDataBuf</b> and <b>XOutDataBuf</b>. These two classes, along with their <b>XIODataStreambuf</b> class, are also declared in header <b>IndexedFile</b> (<a href="list1.htm">Listing 1</a>). Their definitions are shown in <a href="list2.htm">Listing 2</a>. Let me describe them here.</p> 

<H3><FONT COLOR="#000080">XIODataStreambuf</FONT></H3>

<p>The class <b>XIODataStreambuf</b> wraps an <b>XDR_Streambuf</b> around an existing data buffer. The key point is that it does not do any buffer management of its own. The constructor takes three parameters: the buffer pointer, the size of the buffer, and the length of the currently used portion of the buffer. It uses these values to set up the <b>get</b> and <b>put</b> areas in the base class. Once the base class has been initialized, the default implementations of all the <b>XDR_Streambuf</b> functions are acceptable &#151; except for the two seek functions. By default, <b>XDR_Streambuf</b> does not implement the seek functions; they have to be provided by derived classes. Since the seek functions are used by certain public <b>XDRStream</b> functions like <b>seekg</b> and <b>tellp</b>, I have to provide them. </p> 
<p>As you can see, the definitions for <b>XInDataBuf</b> and <b>XOutDataBuf</b> are even simpler than <b>XIODataStreambuf</b>. The important thing to note in their case, however, is that the constructors take as a first argument a reference to another <b>XDRStream</b> object. The constructor and destructor for <b>XInDataBuf</b> (used in <b>decode</b>) are shown below.</p> 

<pre>
BtreeIndex&lt;Key,Compare,KeyTraits,
    PageSize&gt;::XInDataBuf::XInDataBuf(
    iXDR_Stream&amp; xstrm,
    char* buf, 
    size_t len)
  : _refstrm(xstrm),
    _xstreambuf(buf, len, len)
{
    // Initialize the base class
    init(&amp;_xstreambuf);

    // Copy the formating, and polymorphic 
    // support information
    copyfmt(xstrm);
    id2obj()  = xstrm.id2obj();
    id2type() = xstrm.id2type();
}

BtreeIndex&lt;Key,Compare,KeyTraits,
    PageSize&gt;::XInDataBuf::~XInDataBuf()
{
    // copy the formating data back
    _refstrm.copyfmt(*this);
    _refstrm.id2obj() = id2obj();
     _refstrm.id2type() = id2type();
}
</pre>

<p>The constructor saves the <b>iXDR_Stream</b> reference that is passed to it for later use by the destructor. Then it initializes the <b>XIODataStreambuf</b> object. In the constructor body proper, it first calls the base class <b>init</b> function to establish the <b>streambuf</b>. Then it copies the formatting information from the reference <b>XDRStream</b> object into this one. This involves invoking the <b>copyfmt</b> member function in the base class (I'll bet you haven't seen that one used very often before) and then directly copying the <b>IdToObj</b> and <b>IdToType</b> objects that are part of an <b>iXDR_Stream</b> class. The destructor of <b>XInDataBuf</b> copies the same information back to the reference stream. This permits the client-defined <b>decode</b> operation for <b>Key</b> to have access to any client-defined formatting data that is stored in the main <b>BtreeIndex</b> stream. Copying it back in the destructor means that any changes made to the formatting data is persistent across different instantiations of <b>XInDataBuf</b> objects.</p> 
<p>Obviously, <b>XOutDataBuf</b>'s constructor and destructor do similar things, the only difference being that they copy <b>ObjToId</b> and <b>TypeToId</b> objects.</p>
<p>These two classes reveal a shortcoming in my existing <b>XDRStream</b> classes. Since the <b>iXDR_Stream</b> and <b>oXDR_Stream</b> classes provide the internal data structures to allow clients to store certain information in the stream for use by client-defined functions, then it also makes sense that they should provide a means to copy this information. In other words, <b>oXDR_Stream</b>, <b>iXDR_Stream</b>, and <b>XDR_Stream</b> need their own versions of the <b>basic_ios::copyfmt</b> function. I will make this change to <b>XDRStream</b> in a later version.</p> 
<p>One final note about <b>copyfmt</b> seems appropriate. This copying is done whenever a new version of <b>XInDataBuf</b> or <b>XOutDataBuf</b> is created or destroyed. <b>XInDataBuf</b> is used only in the <b>Page::decode</b> function, but <b>XOutDataBuf</b> is used both in <b>Page::encode</b> and by the <b>Page::add_key</b> function (to get the encoded length of a new <b>KeyInfo</b> object). The last is of some concern since it means that a <b>copyfmt</b> operation is done (twice) whenever a new key is added to the index. Most of the time, there will be nothing in the structures being copied, so it can be assumed that the copying will be a very quick operation. The question arises about what happens in the special case where there is some complex formatting information stored in the stream. In particular, the base class <b>copyfmt</b> operation will invoke any registered callback functions as part of its operation, and these can do just about anything they want.</p> 
<p>I speculated for a while about ways to avoid doing these copies all the time. The obvious thing is to have a <b>XIODataBuf</b> object be a member of <b>BtreeIndex</b> and just reuse it as needed. I have put that on my &quot;things to do in the next version&quot; list, but the current implementation probably works just fine for 99 percent of the cases.</p> 
<p><a href="list2.htm">Listing 2</a> contains the code for all the internal XDR stream functions. </p>
<p>Now that we understand what <b>XInDataBuf</b> is all about, we can finish our examination of <b>Page::decode</b>. After we have read the <b>KeyInfo</b> information into a buffer using <b>get_opaque</b>, we wrap a <b>XInDataBuf</b> stream around it and decode the individual <b>KeyInfo</b> objects. Since we store only the <b>Key</b> and link information in the stream, we have to compute the encoded length from information provided by the stream. As you will see, this information is used later if we have to split a page.</p> 
<p>The <b>Page::encode</b> function is the dual of <b>Page::decode</b>, but is simpler since it does not have to calculate the encoded length for each <b>KeyInfo</b> object. Note that <b>Page::encode</b> does no checking to make sure that the encoded page fits within the <b>PageSize</b> limit. It is assumed that higher levels have checked this. I will admit that this is one area where a little more paranoia might be a good idea. An exception here would quickly reveal a logic error somewhere else in the implementation. Of course, like ever other programmer, I am reluctant to add code that tests for conditions that &quot;should never happen.&quot; </p>

<H3><FONT COLOR="#000080">Page add_key/remove_key/update_key</FONT></H3>

<p>Now let me turn to the three main functions that maintain the <b>KeyInfo</b> in a <b>Page</b>. <b>Page::add_key</b> is called whenever a new key is inserted into the <b>BtreeIndex</b>. <b>remove_key</b> is invoked whenever a key is deleted. <b>update_key</b> is used to change the link value associated with a key. It is invoked when a client updates the link through the iterator.</p> 
<p>None of these functions are virtual, so they work equally well on either the root page or any other page.  As a final note, these three functions are only applied to leaf pages of the index. Internal pages of the index hold links to other index pages. The keys on these pages are manipulated by the page-link functions described later. </p>
<p><b>add_key</b> is shown below:</p>

<pre>
size_t
BtreeIndex&lt;Key,Compare,KeyTraits,PageSize&gt;::Page::add_key(
    BtreeIndex&amp; btree,
    const std::pair&lt;const Key, size_t&gt;&amp; x)
{
    // Encode the &lt;key,link&gt; to see how long it is
    char buf[ (PageSize - HeaderSize) / 2 ];
    XOutDataBuf xstrm(btree._xstream, buf, sizeof(buf));

    KeyTraits::encode(xstrm, x.first) &lt;&lt; x.second;
    if (xstrm.fail()) 
        throw std::ios_base::failure(&quot;Key too large&quot;);

    KeyInfo info(x.first, x.second, short(xstrm.tellp()));
    
    // Now put the KeyInfo object into the right
    // place in the list
    int slot = 0;
    KeyList::iterator kit = _keyList.begin();
    for (; kit != _keyList.end(); ++kit) {
        if ( btree-&gt;_comp(x.first, (*kit).key) ) break;
        ++slot;
    }
    kit = _keyList.insert(kit, info);
    _dataLen += info.xlen;
    _dirty = true;
    return slot;
}
</pre>

<p>Conceptually there are two sections. First, encode the <b>&lt;key,link&gt;</b> into a buffer to see how long the encoded form is. Note that we require an encoded key to take up less than half of the available <b>PageSize</b>. Stated another way, we require that <b>PageSize</b> be large enough to hold at least two keys in the worst case. This may seem like an arbitrary restriction &#151; and perhaps it is. I do it because it simplifies certain other routines as we will see below.</p> 
<p>After the encoded length of the <b>&lt;key,link&gt;</b> pair is determined, we create the actual <b>KeyInfo</b> object. Then we figure out where to insert it in the <b>KeyList</b>. To do this, we apply the <b>Compare</b> functor repeatedly until we find a key in the list that is greater than the new key. In the process, we keep track of the index position in the list. After inserting the new key in its correct place, we add its encoded length to the overall length of the data portion of the page, mark the page as &quot;dirty,&quot; and return the index position where the new key is located. The later is used to create the <b>BtreeIndex::Iterator</b> that refers to this newly inserted key.</p> 

<p><b>remove_key</b> is simpler:</p>

<pre>
bool
BtreeIndex&lt;Key,Compare,KeyTraits,PageSize&gt;::Page::remove_key(
    int slot)
{
    if (size_t(slot) &gt;= _keyList.size()) 
        throw std::ios_base::failure(&quot;Invalid slot for erase&quot;);
    bool rtn = _dataLen &lt; (PageSize - HeaderSize) / 2;
    // Find the slot
    KeyList::iterator kit = _keyList.begin();
    while (slot &gt; 0) {
        ++kit;
        --slot;
    }
    _keyList.erase(kit);
    _dataLen -= (*kit).xlen;
    _dirty = true;
    return rtn;
}
</pre>

<p>Note first that it is based on slot number. This is what is carried in a <b>BtreeIndex::Iterator</b>. First we validate the slot number. I could have just ignored this test with the usual caveat about &quot;undefined behavior&quot; if the slot number is invalid. Since the test is simple, however, I go ahead and do it. </p> 
<p>The next statement needs a little explanation. One of the &quot;requirements&quot; for a B-tree is that all pages (except root) be at least half full. To fulfill this requirement, when a key is deleted and a page becomes less than half full, we might have to move a key from a sibling page or even consolidate two pages. Since our <b>BtreeIndex</b> allows variable length keys, the trick is to determine when a page is actually less than half full. We check the total encoded length of the keys against the available space, but we do it before we actually remove the key. This way, if the page was more than half full before we remove the key, we think of it as being at least half full after we remove the key. If the page was less than half full before we remove the key, then we know it is really less than half full afterward. The result of the test is the function return value. This signals higher-level routines to handle any necessary key shuffling or page consolidation. You will note that the restriction of a key to a maximum length less than half the available buffer size facilitates this test.</p> 
<p>Finally, we locate the key by its slot number and then erase it. </p>

<p><b>update_key</b> is the simplest of all:</p>

<pre>void
BtreeIndex&lt;Key,Compare,KeyTraits,PageSize&gt;::Page::update_key(
    size_t slot, 
    size_t link)
{
    if (slot &gt;= _keyList.size()) 
        throw std::ios_base::failure(&quot;Invalid slot for update&quot;);
    // Find the slot
    KeyList::iterator kit = _keyList.begin();
    while (slot &gt; 0) {
        ++kit;
        --slot;
    }
    (*kit).link = link;
    _dirty = true;
    return;
}
</pre>

<p>Again, I test the slot index for validity. After that, we just find the key and then change its link field.</p>

<H3><FONT COLOR="#000080">Page insert_page_link/update_page_link/remove_page_link</FONT></H3>

<p>Whereas the three functions described above are used when the target page is a leaf page, these three functions perform analogous operations on internal pages. <b>insert_page_link</b> is called whenever a new page has been created as the result of a page split. <b>remove_page_link</b> is invoked when a page is removed because it is empty. <b>update_page_link</b> is used when the first key on a page is changed. This can happen when a new key is inserted in the index that is less than all the already existing keys, when a key is deleted, or when we shuffle keys between pages to keep them all more or less half full. When the first key on a page changes, the key that links to that page at a higher level in the index has to be changed to correctly reflect what key values are available on the lower-level page.</p> 
<p>Now, since all pages &#151; even the root &#151; hold <b>&lt;key,link&gt;</b> pairs where the link is just the <b>XDRStream</b> offset, you might wonder why the previous three functions cannot handle all the functionality that these functions provide. The simple answer is that they could, but that would have required more work by higher-level routines. In a sense, the <b>xxx_page_link</b> functions are utilities that take advantage of certain internal knowledge. Let me dive into <b>insert_page_link</b> and explain what I mean:</p> 

<pre>
void
BtreeIndex&lt;Key,Compare,KeyTraits,
    PageSize&gt;::Page::insert_page_link(
    KeyList::iterator kit, 
    Page* p)
{
    // Build a KeyInfo object from the link page
    KeyInfo info = p-&gt;key_list().front();
    info.link = p-&gt;page_id();
    _dataLen += info.xlen;
    _keyList.insert(kit, info);
     _dirty = true;
}
</pre>

<p><b>insert_page_link</b> is called whenever a lower-level page is split and creates a new page. You will have noted above that the <b>add_key</b> function did not test whether it should split itself. This test in performed by the <b>BtreeIndex</b> function that actually calls <b>add_key</b> (and some other places). </p>
<p>I will go into this in more detail when I show the code for <b>BtreeIndex</b> itself, but for now it suffices to know that most operations in <b>BtreeIndex</b> are recursive. Each takes a pointer to the page that it is to operate upon and either finds the next lower page and invokes itself or stops when it reaches a leaf page. This process effectively defines the path from the root to a specific key in the index. As the call stack unwinds, any operations that need to propagate up the tree are performed. This includes (amongst other things) putting references to new pages into the parent page. <b>insert_page_link</b> is therefore invoked by a <b>BtreeIndex</b> function that has first located a lower-level page, invoked an operation on said lower-level page, and then split that lower-level page. The <b>BtreeIndex</b> function has both a pointer to the lower-level page and to that page's parent. </p> 
<p>You may have also noticed that <b>Page</b> does not have a <b>find_key</b> function. Instead, it provides a <b>key_list</b> function that allows clients direct access to the <b>KeyInfo</b> container. This allows clients of <b>Page</b> to search the container themselves and to actually update the container. Obviously this violates data hiding and encapsulation rules, and I am not real happy about it. Since <b>Page</b> is an internal type, I have decided I can live with it for now, but just barely. In this case, the <b>BtreeIndex</b> function holds the <b>KeyList::iterator</b> that linked to the page that was just split. This makes it easy to tell the parent page where to insert the new link. This is important because <b>insert_page_link</b> can be necessary under circumstances where the page itself would have difficulty determining the proper place to insert the new link. </p> 
<p>The function takes advantage of certain information already in the tree. Unlike <b>add_key</b> above, it does not have to encode the key to determine its length. The key for a new page is always the same as the first key on the page, so this function just copies that <b>KeyInfo</b> object (which already contains the encoded length) and updates the link member (which doesn't change its encoded length). It then inserts the new <b>KeyInfo</b> object at the point where it has been instructed, updates the overall data length, and marks the page as dirty.</p> 

<p><b>remove_page_link</b> is slightly more complex than <b>insert_page_link</b>. It is shown here:</p>

<pre>
bool
BtreeIndex&lt;Key,Compare,KeyTraits,
    PageSize&gt;::Page::remove_page_link(Page* p)
{
    bool rtn = _dataLen &gt; (PageSize - HeaderSize) / 2;
    // Find the page reference
    KeyList::iterator kit = _keyList.begin();
    for (; kit != _keyList.end(); ++kit) {
        if ((*kit).link == p-&gt;page_id()) break;
    }
    if (kit == _keyList.end()) 
        throw std::ios_base::failure(&quot;Invalid page&quot;);
    // Remove it
    _dataLen -= (*kit).xlen;
    _keyList.erase(kit);
    _dirty = true;
    return rtn;
}
</pre>

<p>This function is obviously used whenever a descendent page is removed from the index. Like the <b>remove_key</b> function above, it first tests itself to see if it is half full. It then locates the key with the page reference to be removed. Remember that a page's ID is the same as its offset in the index file, and that this is the value held in the link portion of the <b>KeyInfo</b> object. Since <b>remove_page_link</b> is an internally invoked function, we should never encounter the error condition that I test for, but in this case I was cautious. </p> 

<p><b>update_page_link</b> is shown below:</p>

<pre>
void
BtreeIndex&lt;Key,Compare,KeyTraits,
    PageSize&gt;::Page::update_page_link(Page* p)
{
    // Find the page reference
    KeyList::iterator kit = _keyList.begin();
    for (; kit != _keyList.end(); ++kit) {
        if ((*kit).link == p-&gt;page_id()) break;
    }
    if (kit == _keyList.end()) 
        throw std::ios_base::failure(&quot;Invalid page&quot;);
    // Carefully replace the keyinfo at this slot
    _dataLen -= (*kit).xlen;
    (*kit) = p-&gt;key_list().front();
    (*kit).link = p-&gt;page_id();
    _dataLen += (*kit).xlen;
    _dirty = true;
}
</pre>

<p>As noted above, this function is necessary whenever the first key on a page changes. The tricky thing about this function is that even though the number of keys on the page is not changing, the encoded length of the page may very well change. So, we have to treat the length as if we first removed the existing key and then inserted the new one. We simply copy the actual key from the lower-level page and then change the link.</p> 

<H3><FONT COLOR="#000080">Page must_split</FONT></H3>

<p>The final non-virtual function in <b>Page</b> is the <b>must_split</b> function. This simply tests whether the combined encoded length of the keys held by the page exceeds the space available to actually encode them. It is a one-line function and probably could be inlined, but I didn't bother.</p> 

<pre>
bool
BtreeIndex&lt;Key,Compare,KeyTraits,
    PageSize&gt;::Page::must_split() const
{
    return _dataLen &gt; (PageSize - HeaderSize);
}
</pre>

<H3><FONT COLOR="#000080">Page Virtual Functions</FONT></H3>

<p>The seven functions described above apply to all pages. The <b>encode</b>/<b>decode</b> functions are virtual since the root page contains different information in its header. Because of the trivial differences, I will not show the <b>RootPage</b> <b>encode</b> and <b>decode</b> functions. This leaves three other virtual functions defined by <b>Page</b>: <b>split</b>, <b>consolidate</b>, and <b>shuffle</b>. I will show both the <b>Page</b> and the <b>RootPage</b> versions of these below, but first a few general comments. You will note that each of these functions returns a pointer-to-<b>Page</b>. For <b>split</b>, the reference is the new page that needs to be added to the parent. For <b>consolidate</b>, it is the page that needs to be removed from the parent. Finally, for <b>shuffle</b>, it is the page that has had its first key changed and thus needs to have its key updated in the parent. Naturally, the <b>RootPage</b> versions of the functions do not need to return anything since root has no parent but the signatures remain the same. (<b>shuffle</b> is meaningless for the root, so it does not really need to be a virtual function of <b>Page</b>. I may fix this in the next version.)</p> 

<H3><FONT COLOR="#000080">Page split</FONT></H3>

<pre>
BtreeIndex&lt;Key,Compare,KeyTraits,PageSize&gt;::Page*
BtreeIndex&lt;Key,Compare,KeyTraits,PageSize&gt;::Page::split(
    BtreeIndex&amp; btree)
{
    // Go through the page and find where to split it
    KeyList::iterator kit = _keyList.begin();
    size_t len = 0;
    while (len &lt; (PageSize - HeaderSize) / 2) {
        len += (*kit).xlen;
        ++kit;
    }
    
    // Now move the rest of the elements to a new page
    Page* newp = btree.get_free_page();
    KeyList&amp; kl = newp-&gt;_keyList;
    kl.splice(kl.end(), _keyList, kit, _keyList.end());
    newp-&gt;_dataLen = _dataLen - len;
    _dataLen = len;

    // link the page in after this one
    newp-&gt;next_page(_nextPage);
    newp-&gt;prev_page(_pageId);
    if (Page* nextp = btree.get_page(_nextPage))
        nextp-&gt;prev_page(newp-&gt;page_id());
    _nextPage = newp-&gt;page_id();

    // make sure both pages get flushed
    _dirty = newp-&gt;_dirty = true;

    // Return the new page
    return newp;
}
</pre>

<p>Splitting a regular page involves first figuring out where to split it. Since keys can vary in size, we need to do something slightly more intelligent than just dividing the number of keys on the page by two. My criteria is to go through the keys and add their encoded lengths until the result is greater than half the available space. This means that after the split the original page will be more than half full, and the new page will be what we define as exactly half full. You will note that because we require that the encoded <b>&lt;key,link&gt;</b> length be no greater than half the available space, we are always assured that we can split a page into just two pages. Without the restriction on encoded key length, we run the risk of a pathological case that would require we split a single page into three pages. </p> 
<p>The next step is to get a new page. As I described in my last column <a href="#4">[4]</a>, this involves more than just a call to <b>new</b>. Empty index pages are linked together through a member of the root page. Whenever a new page is needed, this linked list is first checked. If an empty page is available, it is reused. If not, a new page is created. In either case, the page is added to the page cache. All this is handled by the <b>BtreeIndex::get_free_page</b> function. A reference to the <b>BtreeIndex</b> itself is passed to the function partially to allow for this.</p> 
<p>Once we have a new page, the necessary keys have to be moved to it. This is done using the <b>splice</b> function of the standard <b>list</b> container. <b>splice</b> is a little like <b>insert</b> &#151; it takes an iterator where the splice is to be done &#151; but it takes another <b>list</b> container and two iterators as its additional arguments. The other container has to be of the same type. The function then moves (not copies) the range represented by the iterators from their original list into the new one by changing pointer links. No data copies are made. After calling <b>splice</b> to move the keys, we just have to update the <b>_dataLen</b> member in both pages.</p> 
<p>After getting the keys moved, we link the new page into the double linked list of sibling pages that is maintained at each level in the index. These links will be discussed more when I describe the <b>BtreeIndex</b> functions. For now, we have to fetch the page that was the <b>next</b> page (if it exists) so that we can update its <b>prev</b> page link. </p> 
<p>Finally, after updating everything, both pages are marked as dirty so that the cache will flush them when it should. The pointer to the new page is returned.</p>
<p>The <b>RootPage</b> version of <b>split</b> is similar. </p> 

<pre>
BtreeIndex&lt;Key,Compare,KeyTraits,PageSize&gt;::Page*
BtreeIndex&lt;Key,Compare,KeyTraits,PageSize&gt;::RootPage::split(
    BtreeIndex&amp; btree)
{
    // Find where to split the page
    KeyList::iterator kit = _keyList.begin();
    size_t len = 0;
    while (len &lt; (PageSize - HeaderSize) / 2) {
        len += (*kit).xlen;
        ++kit;
    }
    // Spliting the root page means creating two new pages
    Page* newp1 = btree.get_free_page();
    Page* newp2 = btree.get_free_page();

    // move the first part to new page 1
    KeyList&amp; kl1 = newp1-&gt;key_list();
    kl1.splice(kl1.end(), _keyList, _keyList.begin(), kit);
    newp1-&gt;data_len(len);

    // move whats left to the second new page
    KeyList&amp; kl2 = newp2-&gt;key_list();
    kl2.splice(kl2.end(), _keyList);
    newp2-&gt;data_len(_dataLen - len);
    _dataLen = 0;

    // link the two pages together
    newp1-&gt;next_page(newp2-&gt;page_id());
    newp2-&gt;prev_page(newp1-&gt;page_id());

    // put the page links into the now empty root page
    insert_page_link(_keyList.end(), newp1);
    insert_page_link(_keyList.end(), newp2);
    _depth += 1;
    _dirty = true;
    return 0;
}
</pre>

<p>Like before, we start by figuring out where to split the page. Splitting the root page involves creating a new root page and increasing the depth of the index tree. Since the root page is a different kind of page object, I don't bother to create a new one; I simply create two new internal pages and move all the keys into them. Using the <b>list</b> <b>splice</b> function makes this very easy. The second form of <b>splice</b> here takes only another container. It moves all the elements from that container into the specified one at the requested insertion point. Once we have moved all the keys to the lower-level pages, we link them together (they are currently the only two pages at that level of the tree), and then we update the root page with the new links. In this case, the root page updates itself &#151; it is the parent.</p> 

<H3><FONT COLOR="#000080">Page consolidate</FONT></H3>

<p>Consolidation is effectively the opposite of splitting. Whereas the test of whether a page should be split was factored into a separate function, the <b>consolidate</b> function actually determines whether any consolidation is possible. (This is a slight design inconsistency that I may go back and clean up at some point &#151; by putting the <b>must_split</b> test into the <b>split</b> function). In this case, consolidation is possible if a page is now less than half full and one of its siblings is no more than half full. Now you see why the functions that remove keys from a page return a boolean indicating that they are less than half full so that their invoking functions can decide whether to call <b>consolidate</b> or not to bother. Note that functions such as <b>remove_key</b> do not themselves call <b>consolidate</b> because deciding to attempt consolidation is a strategy function of the <b>BtreeIndex</b> as a whole. So, functions like <b>remove_key</b> return an indication of whether consolidation might be possible, and higher-level functions then determine whether or not it should be attempted. </p> 
<p>The functions themselves are fairly straightforward. <b>Page::consolidate</b> is shown here:</p>

<pre>
BtreeIndex&lt;Key,Compare,KeyTraits,PageSize&gt;::Page*
BtreeIndex&lt;Key,Compare,KeyTraits,PageSize&gt;::Page::consolidate(
    BtreeIndex&amp; btree)
{
    // Get the prev and next pages - we will need them both
    Page* prevp = btree.get_page(_prevPage);
    Page* nextp = btree.get_page(_nextPage);

    // See if we can consolidate with the prev page
    // consolidate
    if (prevp and prevp-&gt;_dataLen + _dataLen &lt;= (
        PageSize - HeaderSize)) {
        KeyList&amp; kl = prevp-&gt;_keyList;
        kl.splice(kl.end(), _keyList);
        prevp-&gt;_dataLen += _dataLen;

        // make the current page free
        prevp-&gt;next_page(_nextPage);
        if (nextp)
            nextp-&gt;prev_page(_prevPage);
        btree.add_free_page(this);
        return this;
    }

    // See if we can consolidate with the next page
    if (nextp and nextp-&gt;_dataLen + _dataLen &lt;= (
        PageSize - HeaderSize)) {
        KeyList&amp; kl = nextp-&gt;_keyList;
        _keyList.splice(_keyList.end(), kl);
        _dataLen += nextp-&gt;_dataLen;

        // free the next page
        Page* p = btree.get_page(nextp-&gt;_nextPage);
        if (p) {
            p-&gt;prev_page(_pageId);
            next_page(p-&gt;_pageId);
        }
        btree.add_free_page(nextp);
        return nextp;
    }
     
    // No consolodation possible
    return null;
}
</pre>

<p>The function first checks whether the current page can be consolidated into the previous sibling page (assuming it exists). If so, the keys are spliced into that page, the data length is updated, and the current page moved to the free page list. A pointer to the freed page is returned.</p> 
<p>If consolidation with the previous sibling is not possible, the next sibling is checked. You will note that consolidation always involves adding keys to the end of the previous page. This means that the higher-level <b>BtreeIndex</b> function just has to remove the empty page link from the parent page &#151; no other keys have to be updated.</p> 
<p>The consolidation function for <b>RootPage</b> is shown below. It is actually much simpler.</p>

<pre>
BtreeIndex&lt;Key,Compare,KeyTraits,PageSize&gt;::Page*
BtreeIndex&lt;Key,Compare,KeyTraits,PageSize&gt;::RootPage::consolidate(
    BtreeIndex&amp; btree)
{
    // consolidating the root page means eliminating
    // the lower level page
    Page* oldp = btree.get_page(_keyList.front().link);
    _keyList.clear();

    // move the keys from the lower level page
    _keyList.swap(oldp-&gt;key_list());
    _dataLen = oldp-&gt;data_len();
       
    btree.add_free_page(oldp);
    _depth -= 1;
    _dirty = true;
    return oldp;
}
</pre>

<p>The root page can only be consolidated when it contains a single <b>&lt;key,link&gt;</b> element. Furthermore, the depth of the tree must be greater than one. These tests are done by the higher-level <b>BtreeIndex</b> function and are not repeated in the actual <b>RootPage::consolidate</b> function. We just move all of the single lower-level page's keys into the root and then free that page. We also decrement the depth of the tree by one.</p> 
<p>Finally, there is the <b>shuffle</b> function. This function is invoked when a page has become less than half full, and consolidation with a sibling page is not possible. In order to keep the current page as close to half full as possible, we need to move a key from one of the sibling pages. While actually moving the key is not hard (yeah for <b>splice</b>), one page is going to have its first key value changed. (This may not actually be true if we have duplicate keys, but we don't check for that case.) This means that the link to that page in its parent has to be changed. This makes things complicated for the <b>BtreeIndex</b> as a whole, but fortunately, shuffle is easy.</p> 

<pre>
BtreeIndex&lt;Key,Compare,KeyTraits,PageSize&gt;::Page*
BtreeIndex&lt;Key,Compare,KeyTraits,PageSize&gt;::Page::shuffle(
    BtreeIndex&amp; btree)
{
    // See if we can get a key from the previous page
    Page* prevp = btree.get_page(_prevPage);
    if (prevp) {
        KeyList&amp; k1 = prevp-&gt;_keyList;
        _keyList.splice(_keyList.begin(), k1, --k1.end());
        prevp-&gt;_dataLen -= _keyList.front().xlen;
        _dataLen += _keyList.front().xlen;
        return this;
    }

    // Otherwise see if we can get a key from the next page
    Page* nextp = btree.get_page(_nextPage);
    if (nextp) {
        KeyList&amp; kl = nextp-&gt;_keyList;
        _keyList.splice(_keyList.end(), kl, kl.begin());
        nextp-&gt;_dataLen -= _keyList.back().xlen;
        _dataLen += _keyList.back().xlen;
        return nextp;
    }
       
    // No shuffle possible
    return 0;
}
</pre>

<p>Note that here we see the third and final version of <b>splice</b> used. This version just moves one element from one list to another.</p>
<p>Since the root page does not have any siblings, there is no <b>shuffle</b> function defined for it.</p>
<p>That wraps up the look at <b>BtreeIndex::Page</b> and <b>BtreeIndex::RootPage</b> plus some associated classes. Next time I will review the <b>PageCache</b> class, and (hopefully) the rest of <b>BtreeIndex</b> functions.</p> 

<H3><FONT COLOR="#000080">Source Code</FONT></H3>

<p>All of the <b>IndexedFile</b> source code, along with the necessary <b>XDRStream</b> source code, is included in <a href="../../../source/2002/jul02/reeves.zip">reeves.zip</a>. This code differs from that shown in this column somewhat. In order to facilitate testing on compilers that are less than friendly to nested classes defined within template classes, I moved all the nested class definitions to the main file level. The functionality remains exactly the same. What I have shown in this column is how the code should look (in my opinion) if developed with a truly Standard C++ compiler. </p> 

<H3><FONT COLOR="#000080">Notes</FONT></H3>

<p><a name="1"></a>[1] The code shown in <a href="list1.htm">Listing 1</a> is how I think it should look. The subordinate classes of <b>BtreeIndex</b> are declared as nested classes. The code available for download from the <i>CUJ</i> website (<a href="../../../source/2002/jul02/reeves.zip">reeves.zip</a>) has the same functionality, but has been reorganized to make it friendlier for certain compilers. </p>
<p><a name="2"></a>[2] Robert Sedgewick. <i>Algorithms in C++, Third Edition, Parts 1-4</i> (Addison-Wesley, 1998).</p>
<p><a name="3"></a>[3] Jack Reeves. &quot;The (B)Leading Edge: Building an <b>IndexedFile</b> Class using <b>XDR_Stream</b>,&quot; <i>C/C++ Users Journal C++ Experts Forum</i>, March 2002, &lt;www.cuj.com/experts/2003/reeves.htm&gt;. </p>
<p><a name="4"></a>[4] Jack Reeves. &quot;The (B)Leading Edge: Musings on the <b>IndexedFile</b> Design&quot;, <i>C/C++ Users Journal C++ Experts Forum</i>, May 2002, &lt;www.cuj.com/experts/2005/reeves.htm&gt;.</p>

<p><i><B>Jack W. Reeves</b> is an engineer and consultant specializing in object-oriented software design and implementation. His background includes Space Shuttle simulators, military CCCI systems, medical imaging systems, financial data systems, and numerous middleware and low-level libraries. He currently is living and working in Europe and can be contacted via <b>jack_reeves@bleading-edge.com</b>.</i></p>

<h4><a href="../../../source/2002/jul02/reeves.zip"></a></h4>


</BLOCKQUOTE></BODY></HTML>
