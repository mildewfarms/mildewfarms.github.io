<html><HEAD>
<TITLE>August 2002/Adaptable Dialog Boxes for Cross-Platform Programming/Sidebar</TITLE></HEAD>
<BODY BACKGROUND="" BGCOLOR="#FFFFFF" TEXT="#000000">

<H3 align=center><FONT COLOR="#000080">Creating Dynamic Dialog Boxes</FONT></H3>

<HR>

<BLOCKQUOTE>
<p>A programmer typically creates a dialog box from resources, using <B>GetNewDialog</B> on the Mac or <B>DialogBox</B> on Windows. However, for this technique, I want to build the dialog boxes at run time. The example code available at &lt;www.cuj.com/code&gt; does this (see <B>DialogMac.cpp</B> and <B>DialogWin.cpp</B>), but here&#146;s a brief overview of the steps.</p>
<p>On Windows, use the <B>DialogBoxIndirect</B> call to create the dialog box. The main difference between this call and <B>DialogBox</B> is that <B>DialogBox</B> takes a resource identifier, while <B>DialogBoxIndirect</B> uses a dialog template from memory.</p>
<p>The format of the dialog box template is documented in the MSDN library or can be found online. However, the templates have changed over time, and I&#146;ve been unable to locate one that correctly specifies controls with extended styles. It&#146;s possible to derive the format from trial and error, but this code is very difficult to debug &#151; failing to get the template byte-for-byte correct will usually cause a crash, with no context information to work from.</p>
<p>Luckily, there&#146;s an easier way: create a template <I>just</I> for the dialog header and specify zero controls for it. This makes an &#147;empty&#148; dialog. Then, in the dialog control procedure, wait for a <B>WM_INITDIALOG</B> message. When the message appears, just create the controls you want (in the desired tabbing order) using <B>CreateWindowEx</B>. In the example code, the dialog is created in <B>DialogWin.cpp</B>. Fill in the controls using the control-creation routines in <B>ControlsWin.cpp</B>. Because <B>WM_INITDIALOG</B> is delivered before the dialog is actually shown, but after its window has been created, you have a &#147;last chance&#148; opportunity to populate the dialog.</p>
<p>In the bad old days, Macintosh used to be similar. Using the Dialog Manager, it&#146;s possible to build a DITL resource in memory and use it to create the dialog using <B>NewDialog</B>. If you&#146;ve got an older code base, this may still be necessary. You can find examples of it on Apple&#146;s developer website.</p>
<p>The newer Carbon Event model makes this a lot easier, as demonstrated in the accompanying code: create a window using <B>CreateNewWindow</B>, passing the <B>kMovableModalWindowClass</B> constant to get a window that &#147;looks&#148; like a modal dialog. Install any Carbon Event handlers you want on it (in the code, this is done in <B>WindowMac.cpp</B>&#146;s <B>CreatePlatformDialog</B> routine). On OS 9, it&#146;s necessary to create a root control for the window using <B>CreateRootControl</B>; this is unnecessary but harmless on OS X. Then populate the new window with controls in the same basic fashion as Windows (using the routines in <B>ControlsMac.cpp</B>), and call <B>ShowWindow</B> followed by <B>RunAppModalLoopForWindow</B>. This is done in <B>DialogMac.cpp</B> in the example code.</p>
<p>That&#146;s it. Both platforms provide routines for things such as highlighting, selecting, and specifying default controls; look at <B>Controls.h</B> for some examples.</p></blockquote></body></html>
