<HTML>   
     <HEAD>
<TITLE>August 2002/Adaptable Dialog Boxes for Cross-Platform Programming</TITLE></HEAD>
<BODY BACKGROUND="" BGCOLOR="#FFFFFF" TEXT="#000000">
<H2><A HREF="../tocaug.htm"></A><FONT COLOR="#FF0000">   Graphics</FONT></H2>

<HR>

<H2 ALIGN="center"><FONT COLOR="#800000">Adaptable Dialog Boxes for Cross-Platform Programming</FONT></H2>
<H3 ALIGN="center"><FONT COLOR="#800000">Christopher Kempke</FONT></H3>

<BLOCKQUOTE>
<p>Finally, key technologies converge to make for more portable user interfaces.</p>
</BLOCKQUOTE>

<HR>
<BLOCKQUOTE>

<p>In this article, I present a framework for building dialog boxes that adapt to the look and feel of their platform. This method also helps with a few related problems: specifying cross-platform resources and handling dialog size changes due to localization. I&#146;ll use a combination of XML, automatic layout, and run-time dialog creation to give you most of the benefits of platform-specific resources, without the associated pain. Source code with an implementation of the layout engine for Mac OS 9.1 (&#147;Carbon&#148;), Mac OS X, and Microsoft Windows can be downloaded from the CUJ website at &lt;www.cuj.com/code&gt;. You can use this code as is, or as a starting point for your own more complete implementation.</p>

<H3><FONT COLOR="#000080">Look and Feel</FONT></H3>

<p>Given any two GUI-based computer systems, it&#146;s likely that dialogs and windows displayed on them have a different look and feel. Dialogs vary in the size, type, and spacing of controls, as well as the position of those controls within the dialog. It is often important to make your program feel &#147;native&#148; on the platform in question. The Apple Macintosh, in particular, has a user community that is particularly sensitive to UI compliance &#151; enough that violating the expected appearance can affect a program&#146;s commercial success.</p>
<p>Platforms are continuing to diverge in their layout styles; each vendor wants to differentiate its interface. This is most visible on the Macintosh, where Mac OS X and the &#147;Classic&#148; Mac OS have dramatically different layout styles. It&#146;s also visible in Windows XP&#146;s new thematic interfaces versus the older Windows models (and the still older Windows 3.1 guidelines). For this article, I will call the Mac OS X interface by its proper name, &#147;Aqua.&#148; The older Macintosh interface is called &#147;Platinum.&#148;</p>
<p><a href="fig1.htm">Figures 1</a>, <a href="fig2.htm">2</a>, and <a href="fig3.htm">3</a> show the same dialog on Windows XP, Platinum, and Aqua, respectively. Note the subtle (background patterning, button roundness, and 3-D effects) and not-so-subtle (size, spacing, color) differences between them. You can&#146;t see it on paper, but the blue Aqua button slowly pulses blue to clear to indicate that it&#146;s the default.</p>

<H3><FONT COLOR="#000080">Resources: Pro and Con</FONT></H3>

<p>The customary way to define a dialog box&#146;s layout is to define a resource, usually using a visual tool. Resources have a number of advantages: they&#146;re simpler than C/C++ code, there are tools to generate them, and they can be created separately from the application code. On the Mac, they are easily modified after linking the executable. This is important; the person who designs the dialogs may not be a programmer. In the case of localization (which usually requires dialog layout to change), the localizer is almost never the original system programmer.</p>
<p>The problem with platform-specific resources is typically just that: they&#146;re specific to a platform. The Mac, Windows, and X Window System resource formats are all different, despite superficial similarities. Windows uses a different base metric for dialog layout (the DLU, or Dialog Layout Unit, whose size is based on the current system font) than the others (which use pixels). But most problematically, resources specify the exact location and size of each dialog element or control.</p>
<p>This size and spacing information, which I&#146;ll call &#147;metrics,&#148; is a significant impediment to cross-platform use in several ways: platforms differ in the size of standard controls, their location or alignment with respect to the dialog, even the spacing between them. Dialogs tend to be laid out for English, which is a fairly compact language. When localizing for other languages (particularly German and Scandinavian languages), controls often must be enlarged to prevent clipping of the text, even for the original platform.</p>

<H3><FONT COLOR="#000080">Solutions: Theory and Background</FONT></H3>

<p>There are three basic systems to implement: specification (specifying the contents of the dialog to the application), metrics (determining the size of controls and the spaces between them), and layout (turning the specification plus metrics into an actual dialog.)</p>
<p>Specification isn&#146;t too hard. All of the platforms I&#146;ve mentioned allow you to create a dialog dynamically at run time (i.e., using code instead of resources). The method I will use involves creating my own (cross-platform) resource format, which is then implemented in terms of the dynamic routines (see <a href="sidebar1.htm">sidebar</a>). This allows me to maintain most of the benefits of resources.</p>
<p>Specification, therefore, becomes a problem of just picking a data format and parsing it. Historically, this has been done dozens of times, resulting in such things as UIL (User Interface Language) and the text resource formats for Mac and Windows. Today, there is a standard &#147;universal data format&#148; in the form of XML. The code provided with this article doesn&#146;t require an XML parser, but you&#146;ll probably want to locate one if you&#146;re going to use this technique; a little time writing a parser for XML-based dialog descriptions will save a significant amount of dialog-specific code (reducing several dozen lines of code per dialog to just three). There are a number of commercial, open-source, and freeware parsers available.</p>
<p>Most interfaces, including Platinum, Aqua, and the Microsoft Windows family, publish layout guidelines, which specify the minimum dimensions and spacing for controls, windows, and dialogs on that platform. These will provide a starting point for solving the metrics problem. Note that some hand tuning will be necessary. On most platforms, the &#147;real world&#148; has standardized on metrics somewhat different from the documented ones. I have created a few metrics member functions (part of the <B>Layout</B> class described below), which can be queried for sizes and relationships between controls. These member functions will embody the layout guidelines &#151; either from the documentation, experience, or personal preference. You may like your controls a little looser or tighter.</p>
<p>Layout is the real challenge. Since the sizes and positions of controls will need to vary between platforms, I can&#146;t specify exact pixel or DLU locations for controls. What I want to specify is the &#147;spirit&#148; of the dialog: which controls should be grouped together and overall visual flow (e.g., which control groups should be above or below each other).</p>
<p>HTML does this. The author specifies the content and general flow, but the actual appearance of the document depends on the browser, window size, user-specified fonts, and a myriad of other factors. The document-formatting language TeX takes this even further; it allows you to specify the layout of text and graphics to an extremely detailed level. TeX offers two concepts that I&#146;ll steal for my implementation: boxes and fills.</p>
<p>You can describe most common layouts as a hierarchy of nested boxes. Boxes come in two sorts, the vertical box (whose children are stacked vertically), and the horizontal box (whose children are horizontal). As TeX does, I&#146;ll shorten vertical box to vbox and horizontal box to hbox. <a href="fig4.htm">Figure 4</a> shows a relatively simple dialog broken down into boxes, blue for vboxes, red for hboxes.</p>
<p>By requiring that my layouts be constructed of nested boxes, I give up a little bit of flexibility. But I&#146;ve rarely encountered dialogs that aren&#146;t easily described this way; the exceptions don&#146;t often occur in real layout design.</p>
<p>The second concept I&#146;ll steal from TeX is the idea of a fill. Fills are pseudo controls that expand to consume empty space in a box. Fills expand in the direction of their parent box. That is, vbox fills expand vertically; hbox fills expand horizontally. If there are multiple fills in a box, they split the empty space equally.</p>
<p>Fills are used for alignment. For example, placing a fill on the left side of a control forces that control to the right. A fill on each side of a control will center that control. Horizontal fills are equivalent to &#147;quad leaders&#148; in high-end typesetting (gaps or lines that expand to evenly space portions of a line of text). In <a href="fig4.htm">Figure 4</a>, the fill in the bottom hbox forces the buttons to their proper Windows position, on the right.</p>
<p>In <a href="fig5.htm">Figure 5</a>, I show the same dialog laid out for Mac OS X&#146;s Aqua. (The centered buttons are a giveaway.) The fill labeled &#147;Fill (Aqua)&#148; does the centering. You will often want to &#147;tag&#148; a control or fill with a platform in your XML resources &#151; the parser can then ignore non-current platform items. This is easy to add as an attribute on the fill in XML.</p>
<p>The last thing needed for simple layout is the ability to leave a hard (non-expanding, non-contracting) space. This leaves an empty area of predictable size in the layout. You might do this for aesthetic purposes, or because your application will draw into the empty region at a later time.</p>

<H3><FONT COLOR="#000080">Solutions: Implementation</FONT></H3>

<p>To implement this, you pick a convenient, cross-platform format (such as XML), and define your dialog layout in that. For example, consider the shirt sizes dialog in <a href="fig1.htm">Figures 1</a>, <a href="fig2.htm">2</a>, and <a href="fig3.htm">3</a>. <a href="list1.htm">Listing 1</a> shows a possible XML layout for this dialog.</p>
<p>I create this XML as an external file, but I don&#146;t want to ship it that way. Both Macintosh and Windows allow you to create a &#147;custom resource&#148; from an external file with a syntax similar to an <B>#include</B> directive. Even though the sample code doesn&#146;t do XML parsing, I&#146;ve included some of these layout definitions and built them into resources as an example in the project provided at &lt;www.cuj.com/code&gt;. See the <B>.rc</B> file for Windows, and the <B>.r</B> file for the Mac code.</p>
<p>For the provided code, the metric functions are built into the <B>Layout</B> object, as the two member functions <B>GetControlTypeMetrics</B> (for sizes) and <B>GetDialogSpacing</B> (for inter-control spacing information). Both are just large switch statements, implemented in <B>LayoutMac.cpp</B> or <B>LayoutWin.cpp</B> as appropriate for the platform. Depending on your needs, this could be made much more elaborate (see &#147;Closing Notes&#148; below). <B>GetDialogSpacing</B> returns a horizontal and vertical measurement for the specified type of gap, but <B>GetControlTypeMetrics</B> is more interesting. It returns an <B>AOControlMetrics</B> structure.</p>
<p><a href="list2.htm">Listing 2</a> shows <B>struct AOControlMetrics</B>. A few of these members require explanation. <B>usesLabel</B> indicates whether or not the text applied to the control (if any) affects its size. This is true for most controls with labels. <B>minWidth</B> is a minimum width, regardless of the label size, primarily for aesthetics. <B>widthExtra</B> indicates the native size of the control with a zero-length label; for checkboxes and radio groups, it&#146;s the size of the square or circle on the control, plus any margin. Finally, <B>spacingHeight</B> is the amount of height added for each additional text line in a control whose text wraps to multiple lines. You can modify these values to achieve a look you like.</p>
<p>The next step is to build an internal format for the dialog control information. This information is in two parts. The actual controls are in <B>LayoutControlList</B>. <B>PortDialogInfo</B> contains layout information as a tree of nodes that correspond to the XML tags.</p>
<p><B>LayoutControlList</B> is a vector of the dialog&#146;s controls. For layout purposes, the relevant fields are here. (The <B>i</B> stands for &#147;instance variable,&#148; which dates me to the ancient object Pascal days.)</p>
<p><a href="list3.htm">Listing 3</a> shows <B>struct LayoutControl</B>. The type is the type of the control. (There&#146;s a set of constants in <B>Layout.h</B>). The command ID is the code that maps the particular dialog item to its corresponding entry in the layout. The title and or text value are used to determine the size of the control, and <B>iFixedWidth</B> and <B>iFixedHeight</B> are booleans, which indicate whether the control can be resized by the layout process. You would set <B>iFixedWidth</B> for controls such as edit text, where the size of the control itself is independent of its contents or title. For fixed width or height controls, the <B>iRect</B> structure contains the initial size; it&#146;s ignored for non-fixed size controls. The layout process will change the <B>iRect</B> to reflect the control&#146;s actual coordinates. The other fields in this object are relevant to dialog control, not layout.</p>
<p><B>PortDialogInfo</B> is simpler, as shown in <a href="list4.htm">Listing 4</a>. This determines the title, height, and width of a dialog as a whole. <B>iLayoutInfo</B> contains a tree of layout nodes, and <B>iWidth</B> and <B>iHeight</B> will be set by the dialog after layout of the controls.</p>
<p>Finally, let&#146;s look at <B>LayoutNode</B> itself. <a href="list5.htm">Listing 5</a> shows <B>struct LayoutNode</B>. The control member here either contains a command ID that maps back to the command ID in the control list or else contains one of a number of <B>kLayout&lt;xxx&gt;</B> constants defined in <B>Layout.h</B>. <B>x</B> and <B>y</B> are the position of the element; <B>width</B> and <B>height</B> are its dimensions. They&#146;re stored separately here, rather than in a rectangle, because they&#146;re accessed independently by the layout code. <B>framed</B> and <B>label</B> apply only to group boxes (those thin lines that group various controls in a dialog together). Finally, <B>children</B> is a list of the node&#146;s children. The last three are only applicable if the node is one of the box types (<B>kLayoutHBox</B> or <B>kLayoutVBox</B>).</p>
<p>The demo application provides some helper functions to build layout nodes and control lists by hand; but in a real application, you would build these directly from the XML resources discussed above. I&#146;ve built them by hand for the demo. Don&#146;t be dismayed by the amount of code in the <B>BuildDialogX</B> functions. With a resource-based loader, the code for loading and displaying a simple dialog reduces to three lines.</p>
<p><a href="list6.htm">Listing 6</a> shows the code fragment necessary to display a simple dialog.</p>

<H3><FONT COLOR="#000080">The Actual Layout Process</FONT></H3>

<p>After all this setup, the layout process itself is relatively simple. The top node of a layout is always an hbox or a vbox, because they&#146;re the only nodes with children.</p>
<p>The layout code itself is in <B>Layout::LayoutControls</B> in <B>LayoutAll.cpp</B>. This happens in two steps.</p>
<p>First, <B>MeasureAllControls</B> measures all the fixed controls. This effectively sets the height and width fields of the control, but not the position. For each control, you call the <B>metrics</B> object to determine the size of the control, taking into account platform measurements and the text of the control, if any.</p>
<p>The only notable issue is long static text controls. It&#146;s not desirable for the dialog to expand horizontally to fit very long text. Instead, it&#146;s better to specify the control as a fixed width and grow vertically by adding additional lines. <B>Layout::GetControlTypeSize</B> does this; it&#146;s implemented separately for each platform because of the messy platform-specific device contexts needed for text measurements.</p>
<p>The second step is more interesting. Layout now has correct sizes for all of the fixed controls in the dialog. Dialogs minimize space; the code will push the controls as tightly together as the platform metrics allow, wrap boxes around them as tightly as possible, and so on, to get the smallest dialog that follows the layout specified.</p>
<p>The traversal itself (in <B>Layout::LayoutBox</B>) happens in three parts. First, it recursively calls <B>LayoutBox</B> on all child controls. From the resulting list of children&#146;s heights and widths, <B>LayoutBox</B> can determine the height and width of this box. For vertical boxes, you add up all the heights of your children, plus the spacing around and between them, to determine the total height of the box. The width is just the largest child&#146;s width, plus any spacing around that control. Horizontal boxes use the same algorithm in the opposite dimensions.</p>
<p>At this point, <B>LayoutBox</B> knows the box&#146;s height and width. Since it&#146;s likely that some of the box&#146;s children are smaller than the box itself, it calls <B>ExpandFills</B> on all of its children. <B>ExpandFills</B> just computes the amount of empty space in a given box and divides it amongst the fills.</p>
<p>All this is done assuming that all controls and boxes are at the origin. The last step is to move each child into its proper position. <B>MoveChild</B> is recursive, so previously laid out child boxes get moved as a unit.</p>
<p>Overall, the flow looks like this:</p>

<pre>
for all children
   recursively lay out boxes;
compute height and width to contain 
   children;
let immediate children expand their 
   fills, if any;
move children to their new relative 
   locations
</pre>

<H3><FONT COLOR="#000080">Windows</FONT></H3>

<p>The source code is designed for laying out dialog boxes, but I believe that with some additional work it could be used for the layout of resizable elements such as windows, as well. Remember that for the dialog box, the layout code compresses everything together as much as possible, before building the next outer box.</p>
<p>Contrast this approach with laying out a user-resizable window. There, the space has been determined by the user&#146;s manipulation of the window, and the metrics are specifying minimum distances rather than actual ones. Implementation-wise, this would happen at the <B>ExpandFills</B> step of <B>Layout::LayoutBox</B>. Instead of passing in the tight-packed height and width of the controls, you&#146;d instead pass in the height and width of the window itself. Then, the fills would expand to take up the extra space. This would likely require a second recursive traversal of the tree so that extra space was divided among fills at different levels of the layout, a situation which does not arise for dialogs.</p>

<H3><FONT COLOR="#000080">Closing Notes</FONT></H3>
<p>I&#146;ve been using a variation of this code for about a year and a half. Aside from the various influences I&#146;ve talked about, I developed the code in a vacuum &#151; I write a cross-platform framework, and maintaining resources on all platforms was becoming tedious. In the last few months, I&#146;ve encountered several others who have independently developed roughly the same technique, in roughly the same time frame. I find it interesting that the conjunction of XML as a standard data formatting language and an emphasis on cross-platform/multilingual application development has caused the same solution to be reinvented multiple times. The similarity of these solutions lends me a certain confidence in the model.</p>
<p>It&#146;s unusual to consider dialog layout in a vacuum, separate from its behavior and implementation &#151; and I didn&#146;t. The source code on the <I>CUJ</I> website (&lt;www.cuj.com/code&gt;) is derived from a larger application framework. It gives you a little extra support for displaying and controlling the created dialogs, instead of just laying them out. This extra support code may or may not be useful in your own applications.</p>

<p><i><B>Christopher Kempke</B> has been working with C++ for ten years. He holds a Master&#146;s degree in Computer Science from Oregon State University. For the last seven years, he&#146;s been developing publishing and page-layout software in C++ for Multi-Ad Services, Inc. He also publishes an independent, C++ cross-platform application framework called CroPL, which supports single-source Windows, &#147;Classic&#148; Mac OS, and Mac OS X software development. He can be reached for comment at <B>ckempke@mac.com</B>.</i></p>

<h4><a href="../../../source/2002/aug02/kempke.zip"></a></h4>
</blockquote></body></html>

