<html><HEAD>
<TITLE>August 2002/C and C++: A Case for Compatibility/Sidebar</TITLE></HEAD>
<BODY BACKGROUND="" BGCOLOR="#FFFFFF" TEXT="#000000">

<H3 align=center><FONT COLOR="#000080">Benefits of Incompatibility?</FONT></H3>

<HR>

<BLOCKQUOTE>
<p>C and C++ are closely related, but distinct languages. What benefits are there from keeping them separate? The fundamental argument must be that each could be smaller, simpler, and truer to its own principles if released from the shackles of compatibility. However, despite the popularity of this idea in parts of the C and C++ communities, it is difficult to apply this argument to C and C++ for the following reasons:</p>
<UL><LI>   History (and the need for backwards compatibility) gets in the way of any serious simplification of either language.</LI>
<LI>   C++ was specifically designed to serve the same application domains as C, and in essentially the same ways.</LI>
<LI>   The future evolution of C and C++ is constrained by the need for compatibility and the importance of the C/C++ community.</LI></UL>

<p>For C++ programmers, the benefits of incompatibility are largely hypothetical, beyond the simple advantage of not having to know the incompatible aspects of the C variant and not having to know about the C99 extensions. It is possible to imagine improvements in type safety, but compatibility with current C++ makes significant improvements in that direction difficult. The unchecked nature of arrays is not &#147;just a C problem.&#148; I suspect that the best people arguing for 100-percent type safety can hope for is a dialect (subset) that eliminates unsafe constructs. However, such a subset would not be C++; it would just be a subset of C++ used by the subset of the community that is in a position to benefit from it.</p>
<p>For C programmers, not having to learn C++ is an advantage (as far as ignorance of a closely related language can ever be an advantage). In an environment where all resources can be spent on C, compilers and other tools could be smaller and cheaper to build. In particular, a C compiler front end is inherently smaller and potentially faster than a C++ front end. However, that compile-time advantage is often offset by the need to run more compilations because fewer errors are caught by the compiler. Also, environments where ISO Standard C exists alone are few and not characteristic of C programming environments and communities.</p>
<p>Assuming C/C++ compatibility can be disregarded, designers such as tool builders and the C standards committee benefit from a simpler decision process. In theory, at least, this can translate into advantages for the C-only community. By ignoring C++, C could be extended or modified in a direction deliberately different from C++, eliminating the possibility of C/C++ compatibility and fracturing the C/C++ community. This could possibly benefit some C-only programmers but would impose a burden on the larger C/C++ community. Where C and C++ provide distinct language or library solutions to similar problems, that burden becomes significant.</p>
<p>In theory, at least, and sometimes in practice, the C community values stability more highly than the C++ community. Ignoring C++ for the further evolution of C could therefore be a benefit. However, with C++ standardized and many millions of lines of production code to protect, the attitude to backwards compatibility in the C++ community is approaching that of C. Only by essentially stopping the evolution of C would this benefit become significant.</p>
</blockquote></body></html>
