<HTML>   
     <HEAD>
<TITLE>August 2002/C and C++: A Case for Compatibility</TITLE></HEAD>
<BODY BACKGROUND="" BGCOLOR="#FFFFFF" TEXT="#000000">
<H2><A HREF="../tocaug.htm"></A><FONT COLOR="#FF0000">   Features</FONT></H2>

<HR>

<H2 ALIGN="center"><FONT COLOR="#800000">C and C++: A Case for Compatibility</FONT></H2>
<H3 ALIGN="center"><FONT COLOR="#800000">Bjarne Stroustrup</FONT></H3>

<BLOCKQUOTE>
<p>Bjarne identifies some non-issues as he continues his case for compatibility between C and C++.</p>
</BLOCKQUOTE>

<HR>
<BLOCKQUOTE>
<p>Modern C [<a href="#1">1</a>, <a href="#2">2</a>] and C++ <a href="#3">[3]</a> are sibling languages [<a href="#4">4</a>, <a href="#5">5</a>] descended from Classic C <a href="#6">[6]</a>. In many people&#146;s minds, they are (wrongly, but understandably) fused into the mythical C/C++ programming language. There is no C/C++ language, but there is a C/C++ community. In last month&#146;s <I>CUJ</I>, I described some of the incompatibilities that complicate the work of developers within that C/C++ community. In this article, I&#146;ll discuss some of the underlying myths that help perpetuate these incompatibilities. I&#146;ll also show why more compatibility (ideally, full compatibility) is in the best interest of the C/C++ community. Next month, I&#146;ll present some examples of how the incompatibilities in C and C++ might be resolved.</p>

<H3><FONT COLOR="#000080">Red Herrings</FONT></H3>

<p>Given the shared history of C and C++ and the many similarities between the languages, one might wonder why C and C++ are not fully compatible now. There are some good (though, ultimately, answerable) arguments for incompatibility (see <a href="sidebar1.htm">sidebar</a>), but the debate is often clouded by a few popular misconceptions about the differences between C and C++. These red herring arguments confound and inflame debates about C/C++ compatibility. What these arguments have in common is that they subtly and indirectly mischaracterize one or both of the languages, thus diverting the debate from compatibility to a discussion about the value of some aspect of one of the languages. These red herrings are divisive and often irrelevant because compatibility is valuable even if some individual language features are undesirable.</p>
<p>The ten red herrings of C/C++ compatibility are:</p>

<OL><LI><I>C++ is object-oriented, I don&#146;t like object-oriented programming, so I have no use for C++.</I> This statement ignores the fact that large parts of C++ are not there to support OOP. (In this context, OOP is most often interpreted as programming using class hierarchies.) Other parts of C++ focus on features such as stronger type checking, <B>const</B> in constant expressions, <B>new</B> and <B>delete</B>, function overloading, and templates. C++ supports OOP, but it makes no attempts to impose that style. A significant part of C++&#146;s success comes from not abandoning traditional C styles of programming where they are considered appropriate. In particular, suggesting the greatest possible degree of C/C++ compatibility is (emphatically) not suggesting that every program should be structured as a set of class hierarchies.</LI>
<LI><I>I don&#146;t do low-level programming, so I have no use for C.</I> This would have been a strong argument had C++ been consistently used as a high-level language only. However, most major C++ programs have components that simply couldn&#146;t be written in C++ had C++ not supported efficient close-to-the-hardware programming. Many of these facilities are similar to or identical to what C offers. After all, C++ was deliberately designed to support C-style low-level programming.</LI>
<LI><I>I just need a simple language.</I> We all do. However, we need a language that is simple for what we do. Different people have significantly different needs and significantly different opinions on what makes a language simple. Neither C nor C++ can be considered simple without fairly contorted explanations and apologetic references to history. Simplicity in any abstract or absolute sense is not among the reasons for the success of C and C++, and neither C nor C++ will become any simpler in the future. The real question is whether C and C++ users have to deal with convergent or divergent evolution of these languages. Some people use &#147;a simple language&#148; to mean C, which is clearly a simpler language than C++. However, there is no reason to believe that the simplest expression of a given problem will use all the facilities of C. Nor is there any reason to believe that the set of facilities providing the simplest, most elegant, and most efficient solution will come from C only. One result of C++ being a larger language is that we can often express a simpler solution for a given problem using C++ than is possible using C only.</LI>
<LI><I>But we don&#146;t need those features.</I> This argument is often heard from both C and C++ proponents. Typical examples of features mentioned as &#147;not wanted&#148; are casts and virtual functions. No individual programmer needs every feature of C or C++ every day or in every project. However, the set of features needed by an organization or by a programmer over the time span of a few years starts to approach the set of features provided. For C++, this is particularly true when you take into account the facilities used by developers of sophisticated libraries. Also, essentially all programmers wish for &#147;just one little extension, well, maybe two&#148; and often have good reasons.</LI>
<LI><I>C++ is too slow.</I> There are C++ libraries that are slow and/or take up too much space. However, this is not an inherent property of the C++ language or of the current implementations of C++. You have slow and bloated libraries in any language, including C. When I hear the &#147;efficiency&#148; argument, I confidently suggest measurements. Generally, C++ is fast enough for high-level features to be used in applications demanding high performance (such as classes and templates in matrix applications competing with Fortran [<a href="#7">7</a>, <a href="#8">8</a>, <a href="#9">9</a>]). When the high-level features are not fast enough or not flexible enough, we can always do as well in C++ as we could in C by using the low-level feature shared with C.</LI>
<LI><I>C and C++ are fundamentally different languages.</I> This argument is either a troll or a statement from someone with a very narrow notion of &#147;fundamentally different.&#148; The differences in the parts of the languages supporting traditional C programming are minor and arose from historical accident [<a href="#4">4</a>, <a href="#5">5</a>]. For a really different language, have a look at just about any language that isn&#146;t C or C++, such as ML, Python, Smalltalk, Ada, Prolog, or Scheme.</LI>
<LI><I>C++ would be much better if it weren&#146;t for C compatibility.</I> Some improvements could probably be made to C++ if C compatibility wasn&#146;t an issue: C-style casts, narrowing conversions, and the structure tag namespace spring to mind. However, even if C and C++ each goes its own way, there already exists so much C++ code that a thorough cleanup is impossible. And anyway, the highest degree of C/C++ compatibility that doesn&#146;t interfere with C++&#146;s abstraction mechanisms is a design aim. The opposite claim: &#147;C would be much better if it wasn&#146;t for C++ compatibility&#148; has been made, but far less frequently. After all, the parts of C borrowed from C++ are far fewer and less central to C than the C parts are to C++.</LI>
<LI><I>C is simpler than C++, so C compilers are better than C++ compilers.</I> This is no longer true for the major C++ suppliers. Their C and C++ compilers are different options on the same compiler, relying on the same optimizers, linkers, etc. This &#147;simpler compiler&#148; argument can be valid only in markets where no C++ compiler exists. With high-quality commercial and free C++ front ends available and back ends largely language neutral, this is less of a concern than it once was.</LI>
<LI><I>C is small and understandable; C++ isn&#146;t.</I> C is smaller than C++ and easier to learn if by learning you mean gaining an understanding of most language features. However C is not small; old-timers tend to forget their initial efforts and to seriously underestimate how much has been added. The C99 Standard is 550 pages long. Few people understand all of C. Fortunately, with C as with C++, few people need to understand the whole language. What takes extra time learning C++ compared to learning C is primarily learning new programming techniques. If you know object-oriented programming or generic programming, learning the C++ facilities is relatively easy. If not, learning those new programming techniques using C++ can decrease the total learning time compared to using C. It is relatively easy to learn a useful amount of C++, even compared to learning sufficient C to complete similar tasks <a href="#10">[10]</a>. C is not the ideal subset of C++ from a teaching/learning perspective, nor from a utility or efficiency point of view. Only a lack of compatibility stops people from choosing more ideal subsets.</LI>
<LI><I>If you want C++ features, just use C++.</I> For many programmers, this misses the point. They can&#146;t just pick and choose among languages based on the need of a feature or two. Usually a language is chosen for a project, and most often that language isn&#146;t changed out of fear of real and imagined conversion problems. One of the key problems with incompatibilities &#151; even incompatibilities that don&#146;t reflect differences in basic functionality &#151; is that they provide a barrier to experimentation and to the evolution of programs. Often, a language is chosen for a project based on little knowledge of the future task, mostly on a couple of programmers&#146; previous experiences, and on what happens to be available. However, because of incompatibilities, that choice is still binding for different programmers years later after all the tools and even the language standards have changed.</LI></OL>

<H3><FONT COLOR="#000080">Benefits of C/C++ Compatibility</FONT></H3>

<p>In the absence of specific arguments against, compatibility is obviously preferable to incompatibility. Logically, it is the task of whoever proposes an incompatibility to demonstrate its value. However, we don&#146;t have a clean slate. C is now about 28 years old, and C++ about 18 years. History is important, and increasing the degree of compatibility implies cost and so requires argument. Therefore, it is worth stating the benefits of compatibility as they are today.</p>
<p>The basic argument for compatibility is that it maximizes the community of contributors. Each dialect and incompatibility limits:</p>

<UL><LI>   The size of the market for vendors/suppliers/builders.</LI>
<LI>   The set of available libraries and tools for users.</LI>
<LI>   The set of possible collaborators (suitable employees, students, consultants, experts, etc.) for projects.</LI></UL>

<p>A larger community is a disproportionate advantage. For example, a community of size <I>N</I> provides more than twice the benefits of a community of size <I>N/2</I>. The reason is better communication &#151; and less replicated work.</p>
<p>C and C++ are clearly closely related historically, but why should we look to C/C++ compatibility for benefits? After all, we don&#146;t worry about C/Fortran compatibility or C++/Java compatibility. The difference is that C and C++ have a huge common subset, and there exists a C/C++ community, sharing:</p>

<UL><LI>   Fundamental concepts and constructs leading to shared teaching and learning.</LI>
<LI>   Libraries based on common declarations and data layout.</LI>
<LI>   Tools, including compilers.</LI></UL>

<p>Once you know C or C++, you know a significant part of the other language. With a few exceptions, the statement and expression syntax, the basic types, the semantics, and the ways of composing programs out of functions and translation units are shared, so are many basic programming techniques. This commonality is more than skin deep; it is not just a syntactic similarity hiding major underlying differences. If something looks the same, it usually means the same thing, has the same basic performance characteristics, and can be used unchanged in or from the other language. Features that are similar, but different, in each language (such as <B>void*</B>, <B>bool</B>, and enumerations <a href="#5">[5]</a>) are a burden for teachers and students. For novices, the differences magnify as obstacles to understanding and give rise to myths about their origins and purposes.</p>
<p>These problems persist beyond the initial learning. There are many C++ programmers who have never compiled a C source file, but how many C++ programs don&#146;t call a C library? If a C library is used directly, the programmer must understand the constructs appearing in its header files. Even if C code is used only indirectly, some aspects of C must often be taken into account, such as C&#146;s use of <B>malloc</B> rather than <B>new</B>, the use of arrays rather than C++ Standard library containers, and the absence of exception handling. You&#146;ll certainly find C programmers who have never used C++, especially embedded systems programmers who work on platforms for which a C++ compiler does not exist. But there are relatively fewer programmers for such platforms than there used to be. Many C programmers occasionally use C++ directly, and many rely on C++ libraries (accessed through C interfaces, of course).</p>
<p>For maintenance programmers, each incompatibility is yet another thing for the programmer to keep in mind and a source of errors. For library builders, differences require decisions about which language and dialect should be used for implementation and create a need for multiple interfaces (or a common interface using minimal features only) to support several languages and dialects. For tools builders, including compiler writers, each incompatible feature forces a special case in the implementation and often a compiler option for its control.</p>
<p>The advantage of compatibility is the absence of such problems. Each incompatibility adds a burden and decreases sharing. For individuals and for organizations, compatibility offers a larger universe for experimentation and for the selection of tools, language facilities, libraries, literature, and techniques.</p>
<p>Who benefits? Some programmers take the view that compatibility is at best a nuisance because it does not benefit the working programmer. Naturally, this view is most common among &#147;C-only programmers&#148; and &#147;C++-only programmers&#148; and rare among programmers who regularly use both C and C++. There are benefits from C/C++ compatibility for C programmers who rarely or even never use C++:</p>

<UL><LI>   Being part of a larger community implies that more resources are available for tools, compilers, magazines, textbooks, etc. For example, C and C++ compilers typically share optimizers. By serving the union of C and C++ programmers on a given platform, a compiler group can afford to provide more advanced optimizations, better debuggers, etc.</LI>
<LI>   The C/C++ community has a larger &#147;mind share&#148; than C alone. This implies that C is taken more serious in planning and teaching than it would have been in the absence of C++. The larger community also adds to the richness of the intellectual climate.</LI>
<LI>   On most major platforms, C programs can and usually do benefit from being able to call libraries written in C++ (without additional call overhead or data layout conversion).</LI></UL>

<p>The argument applies to C++ programmers who rarely or even never use C.</p>
<p>On the other hand, C/C++ incompatibilities impose a burden on tools and on library implementers, who, without actually using C++, want to benefit from users in the C++ community. To allow a library to be used in both C and C++ programs, an implementer needs to know what constructs can be safely used in interfaces. (For example, don&#146;t use a C++ keyword, such as <B>new</B> as a <B>struct</B> member, and don&#146;t use a name from a Standard C99 header, such as <B>csin</B> as a global name.) To allow an implementation to be compiled as either C or C++, even more care needs to be taken, such as remembering to cast the result of <B>malloc</B> to the appropriate type.</p>
<p>There are people who believe that, if C++ would just go away, all the C++ programmers would become C programmers and the C++ libraries would become C libraries so that C++ won&#146;t add to the size of the C/C++ community. Some people hold similarly unrealistic views on C from the C++ perspective. Neither of the two languages will go away, and the shared community is a source of strength to both languages.</p>

<H3><FONT COLOR="#000080">What Should Be Done?</FONT></H3>

<p>What can be done about the C/C++ incompatibilities? What should be done? I hear four basic answers:</p>

<OL><LI><I>Nothing, the incompatibilities are good for you.</I> I simply don&#146;t believe that, having never seen a piece of code that benefited from an incompatibility in any fundamental way. However, if enough people are of that opinion, the C and C++ Standard committees will proceed to reduce the area of compatibility and to provide competing incompatible additions. That would destroy the C/C++ community. Programmers would increasingly face a choice between a language rich in built-in facilities and a language rich in abstraction facilities. Naturally, both language communities would be busy compensating for their weaknesses by providing libraries, which in turn would further increase the areas of incompatibility. The primary beneficiaries of this would be languages outside the C/C++ family.</LI>
<LI><I>Nothing, it&#146;s too late.</I> Given that I consider the current level of C/C++ incompatibility a major problem with no technical or philosophical foundation, I&#146;m most reluctant to accept that nothing can be done. However, it is possible that changes really are infeasible today. In that case, we can strive to minimize future incompatibilities and to remove incompatibilities where opportunity arises. More likely, people will draw the conclusion that compatibility is already lost, so compatibility concerns should not be allowed to complicate the design of new language features and libraries. In particular, there will be pressure for each language to provide competing, incompatible versions of popular facilities.</LI>
<LI><I>Remove all incompatibilities.</I> This is my ideal. I believe it is in the long-term best interest of the C/C++ community to remove all incompatibilities between C and C++. We ought to try for that. Clearly, removing incompatibilities would involve changes to both languages and compromises would have to be crafted to minimize the impact on users of both languages. Silent changes &#151; that is, changes that are not easily diagnosed by a compiler &#151; should be minimized. Wherever possible, the compromises should be crafted to increase the consistency of the resulting set of features and to simplify the language rules. It will be difficult to remove all incompatibilities. However, the amount of work required from the C/C++ community to reach compatibility will be far less than that required from it to live with increasingly incompatible languages.</LI>
<LI><I>Remove most of the incompatibilities; removing all is impossible.</I> Unfortunately, we can&#146;t always get all we want. In that case, we should figure out which incompatibilities can be removed and get rid of those. We should also consider ways of improving interoperability, especially among libraries, in cases where source-code compatibility is deemed infeasible. After that exercise, maybe the remaining incompatibilities won&#146;t look so impossible to remove or to live with, and maybe the exercise would discourage the growth of new incompatibilities.</LI></OL>

<p>I clearly value C/C++ compatibility highly. Many, many years ago, John Bentley suggested that C and C++ be gradually merged and that each year the size of the ++ in C++ should be reduced slightly until only the C was left. That was a good idea, but it didn&#146;t happen. However, we are now at a stage in the development of C and C++ where the long-standing semi-official C++ policy of &#147;as close to C and possible, but no closer&#148; could become a policy of full compatibility provided the C and C++ communities so decided. If this opportunity is missed, the languages will embark on divergent evolutions, and the C/C++ community will fracture into many parts.</p>
<p>What would be the result of a systematic process of increasing compatibility? A single language called C or C++? Possibly, but I consider it more likely that the result would be a language called C++ with a precisely specified subset called C. I&#146;m no fan of language subsetting, but I do respect the people who insist that something smaller than C++ is important in some application areas and in some communities. If nothing else, that approach would avoid an emotional discussion about naming.</p>
<p>The next article in this series will make some concrete suggestions as to how C and C++ might be changed to approach full compatibility.</p>

<H3><FONT COLOR="#000080">References</FONT></H3>

<p><a name="1"></a>[1]  ISO/IEC 9899:1990, Programming Languages C.</p>
<p><a name="2"></a>[2]  ISO/IEIC 9899:1999, Programming Languages C.</p>
<p><a name="3"></a>[3]  ISO/IEC 14882, Standard for the C++ Language.</p>
<p><a name="4"></a>[4]  Bjarne Stroustrup. <I>Sibling Rivalry: C and C++</I>, AT&amp;T Labs &#151; Research Technical Report TD-54MQZY, January 2002, &lt;www.research.att.com/~bs/sibling_rivalry.pdf&gt;.</p>
<p><a name="5"></a>[5]  Bjarne Stroustrup. &#147;C and C++: Siblings,&#148; <I>C/C++ Users Journal</I>, July 2002.</p>
<p><a name="6"></a>[6]  Brian Kernighan and Dennis Ritchie. <I>The C Programming Language</I> (Prentice-Hall, 1978).</p>
<p><a name="7"></a>[7]  &lt;http://oonumerics.org/blitz/&gt;</p>
<p><a name="8"></a>[8]  &lt;www.osl.iu.edu/research/mtl&gt;</p>
<p><a name="9"></a>[9]  &lt;www.acl.lanl.gov/Pooma&gt;</p>
<p><a name="10"></a>[10]  Bjarne Stroustrup. &#147;Learning Standard C++ as a New Language,&#148; <I>C/C++ Users Journal</I>, May 1999. Also available in <I>CVU</I>, Vol. 12, No. 1, January 2000. </p>

<p><i><B>Bjarne Stroustrup</B> is the designer and original implementer of C++. He has been a member of the C/C++ community since he first used C in 1975. For 17 years, he worked in Bell Labs&#146; Computer Science Research Center alongside people such as Dennis Ritchie and Brian Kernighan. In the early 1980s, he participated in the internal Bell Labs standardization of C. He is the author of <I>The C++ Programming Language</I> and <I>The Design and Evolution of C++</I>. His research interests include distributed systems, operating systems, simulation, design, and programming. He is an AT&amp;T Fellow and heads AT&amp;T Lab&#146;s Large-scale Programming Research department. He is actively involved in the ANSI/ISO standardization of C++. He received the 1993 ACM Grace Murray Hopper award and is an ACM fellow.</i></p>

</blockquote></body></html>
