<HTML>   
     <HEAD>
<TITLE>November 2002/Sutter&#146;s Mill</TITLE></HEAD>
<BODY BACKGROUND="" BGCOLOR="#FFFFFF" TEXT="#000000">
<H2><A HREF="../tocnov.htm"></A><FONT COLOR="#FF0000">   C/C++ Contributing Editors</FONT></H2>

<HR>

<H2 ALIGN="center"><FONT COLOR="#800000">Sutter&#146;s Mill: &#147;Export&#148; Restrictions, Part 2</FONT></H2>
<H3 ALIGN="center"><FONT COLOR="#800000">Herb Sutter</FONT></H3>

<BLOCKQUOTE>
<p>Until further notice: the tariffs on export are too high for everyday use.</p>
</BLOCKQUOTE>

<HR>
<BLOCKQUOTE>

<p>This is the second of a two-part miniseries. In the previous column, I covered the following <a href="#1">[1]</a>:</p>

<UL><LI>   What <B>export</B> is, and how it&#146;s intended to be used. We looked at an analysis of the similarities and differences between the &#147;inclusion&#148; and &#147;export&#148; template source-code organization models, and why they&#146;re not parallel to the differences between inline and separately compiled functions.</LI>
<LI>   The problems <B>export</B> is widely assumed to address, and why it does not in fact address them the way most people think.</LI></UL>

<p>Widespread expectations notwithstanding, <B>export</B> is not about truly &#147;separate&#148; compilation for templates in the same way we have true separate compilation for non-templates. Many people expect that <B>export</B> means that template libraries can be shipped without full source-code definitions (or their direct equivalent), and/or that build speeds will be faster. Neither outcome is promised by <B>export</B>. </p>
<p>The community&#146;s most informed experience to date is that full source or its direct equivalent must still be shipped, and that build speeds are expected to be the same or slower in most cases. Why? Principally this is because dependencies, though masked, still exist, and the compiler still has to do at least the same amount of work in common cases. In short, it&#146;s a mistake (albeit a natural one) to think that <B>export</B> gives true separate compilation for templates in the sense that the template author need only ship declaration headers and object code. Rather, what is exported is similar to Java libraries where the bytecode can be reversed to reveal something very like the source; it is not traditional object code.</p>
<p>This time, I&#146;ll cover:</p>

<UL><LI>   The current state of <B>export</B>, including what our implementation experience to date has been.</LI>
<LI>   The (often non-obvious) ways that <B>export</B> changes the fundamental meaning of other apparently unrelated parts of the C++ language.</LI>
<LI>   Some meager advice on using <B>export</B> effectively if and when you do happen to acquire an <B>export</B>-capable compiler.</LI></UL>

<p>But first, consider a little history.</p>

<H3><FONT COLOR="#000080">Historical Perspective: 1988-1996</FONT></H3>

<p>Given that there are some valid criticisms of <B>export</B>, it might be tempting to start casting derisive stones and sharp remarks at the people who came up with what we might view as a misfeature. It would also be ungracious, unkind, and could possibly smack of armchair quarterbacking. This part of the article exists for balance.</p>
<p>If <B>export</B> doesn&#146;t deliver the advantages that many people expect, then why does it exist? The reason is quite simple: in the mid-1990s, a majority of the committee believed that shipping a standard that did not have separate compilation for templates, as C already did for functions, would be incomplete and embarrassing. In short, <B>export</B> was retained in the then-draft Standard on principle.</p>
<p>Principle is very often a good thing. It should never be disparaged, especially by armchair quarterbacks like ourselves (I didn&#146;t start attending committee meetings till the following year), looking back with the benefit of six years&#146; worth of hindsight.</p>
<p>Remember that, in 1995-1996, templates themselves were still pretty new:</p>

<UL><LI>   The first presentation of the initial C++ template design was made by Bjarne Stroustrup in October 1988 <a href="#2">[2]</a>.</LI>
<LI>   In 1990, Margaret Ellis and Bjarne Stroustrup published <I>The Annotated C++ Reference Manual</I> (the ARM) <a href="#3">[3]</a>. The same year, the ISO/ANSI C++ standards committee got going and selected the ARM as its &#147;starting point&#148; base document. The ARM was the first C++ reference to include a description of templates, and they weren&#146;t templates as we know them today; the entire specification and description of these simple templates was only 10 pages long.</LI></UL>

<p>At that time, the focus was entirely on enabling parameterized types and functions, the given examples being a <B>List</B> container that could hold different types of objects and a <B>sort</B> that could sort different types of sequences. Even in these early days, however, templates were conceived with the desire for a separate compilation model in mind. Cfront (Stroustrup&#146;s C++ compiler) had support for a form of &#147;separate&#148; template compilation for these simple templates, although its approach was not scalable; see the note in the previous article.</p>

<UL><LI>   During 1990-1996, C++ compiler vendors flourished and took different routes with their template implementations, and at the same time the standards committee greatly enhanced (and complexified) templates. In the latest editions of Stroustrup&#146;s <I>The C++ Programming Language</I> <a href="#4">[4]</a>, the specification and description of templates occupies 44 (somewhat larger-than-ARM) pages: 27 pages in the body of the book, and 17 pages in the appendices.</LI></UL>

<p>In the early and mid-1990s, the committee was principally trying to make templates more robust and practical to support the intended basic uses. Few suspected the enormously flexible and slightly monstrous wonder they had created &#151; it was known that templates were a Turing-complete metalanguage allowing programs of arbitrary complexity to be written that could execute entirely at compile time. But all the modern template metaprogramming and advanced library design that&#146;s in vogue today were largely unanticipated by the people who gave us the very templates that make it possible in the first place, and the techniques were largely unknown during 1990-1996. Remember, it wasn&#146;t until late 1994 that Stepanov made his first presentation of the STL to the committee, which adopted it in 1995 as a groundbreaking achievement &#151; and by today&#146;s standards the STL was &#147;just&#148; a container and algorithm library. Groundbreaking to be sure in 1995, and a powerful differentiator of C++ from other languages still today, but it was nonetheless just the first testing of the template waters by today&#146;s standards.</p>
<p>This is why I say that, &#147;in 1995-1996, templates themselves were still pretty new.&#148; Modern templates in their (mostly) final form existed, but even the people who invented them didn&#146;t fully realize what they were capable of. The global C++ community was much smaller than it is today, few compilers supported more than ARM templates, and most compilers&#146; template support of any kind was poor or essentially useless. Around that time, only Cfront could cope with the initial STL, for example.</p>
<p>So it was that the community in general and the standards committee in particular still had a comparatively short record of real-world experience with even the simpler ARM templates that existed. The climate in 1996 was no longer quite embryonic, but it was young and still growing and forming.</p>
<p>And it was in this formative climate, with that limited experience, that the standards committee was forced to decide whether to keep exported templates in the then-draft Standard.</p>

<H3><FONT COLOR="#000080">1996</FONT></H3>

<p>In 1996, even with the little information that was available, enough was known that <B>export</B> made a lot of experts nervous. In particular, it made all of the compiler vendors nervous. Even supporters of <B>export</B> viewed it as a necessary compromise, while still disliking <B>export</B> as a source of complexity; some would have preferred general separate compilation with no special keyword.</p>
<p>In July 1996, there was a large coordinated push within the committee against <B>export</B>. In particular, it was argued, the <B>export</B> model had never been implemented, and the committee had no idea whether it would actually work as intended. Several C++ vendors had implemented various forms of template source organization models, but <B>export</B> followed none of them; <B>export</B> was a completely new and experimental beast with no implementation experience behind it. In fact, there were papers presented at that time &#151; papers that in retrospect could be called insightful bordering on prescient &#151; that detailed some of the major potential shortcomings of the <B>export</B> model as described in the draft Standard.</p>
<p>In particular, all of the compiler implementers unanimously opposed <B>export</B> on the grounds that it was too early to know if they were doing the right thing. They had serious unanswered concerns about the existing <B>export</B> formulation, and they didn&#146;t feel they had enough experience yet to come up with a fully baked alternative (not to mention insufficient time; the Standard was being stabilized and would be set in stone the following year, 1997). For those reasons, the compiler vendors unanimously didn&#146;t want to rush a separation model into the first standard (C++98). Rather, they wanted to take time to design it right and do it in the next standard. They favored the idea of separate template compilation in principle, but felt that <B>export</B> wasn&#146;t fully baked, and they still didn&#146;t know enough to do it right.</p>
<p>They lost, narrowly, and <B>export</B> stayed in the Standard <a href="#5">[5]</a>. It would be armchair quarterbacking at best to be unduly critical about this outcome, however. As I summarized earlier, a (slim) majority of the committee believed that shipping a standard that did not have some form of &#147;separate&#148; compilation for templates, as C already did for functions, would be incomplete and embarrassing. Several compilers had already been experimenting with forms of &#147;separate&#148; template compilation, and it seemed to be a good idea in principle. In short, <B>export</B> was retained in the then-draft Standard on principle. And it&#146;s a good principle, not to be disparaged.</p>
<p>To emphasize, note that the world&#146;s compiler vendors opposed <B>export</B> in particular and did not oppose the principle of separate template compilation. They just felt they needed more time to be confident that the Standard would get it right. Although some of the world-class experts who in 1996 voted in favor of retaining <B>export</B> now see it as a mistake, the intent and motivation was good. And there is still hope that <B>export</B> will deliver some benefits &#151; if not all the big ones that were initially hoped for &#151; as we gain experience with the first shipping compiler to implement <B>export</B> (Comeau 4.3.0.1 released in August 2002).</p>

<H3><FONT COLOR="#000080">Our Export Experience to Date: EDG</FONT></H3>

<p>As noted last time, the only implementation of export in the world was recently completed by EDG (Edison Design Group) <a href="#6">[6]</a>, a company of three people who happen to be three of the most respected C++ language implementers on the planet. EDG doesn&#146;t sell C++ compilers; its customers are C++ compiler vendors who integrate the EDG language implementation into their own products. In August 2002, Comeau released the world&#146;s first shipping  <B>export</B>-enabled compiler <a href="#7">[7]</a>.</p>
<p>We can gain much learning from EDG&#146;s experience. EDG reports that, in their experience, <B>export</B> is as difficult to implement as any three other major C++ language features they&#146;ve done (such as namespaces or member templates). The <B>export</B> feature alone took more than three person-years to code and test (not including design); by comparison, implementing the entire Java language took the same three people only two person-years.</p>
<p>Why is <B>export</B> so difficult to implement, and so complex? EDG cites the following major reasons:</p>

<OL><LI><B>export</B> relies on Koenig lookup. Most compilers still get Koenig lookup wrong even within a single translation unit. (Informally, this means a source file.) <B>export</B> requires performing Koenig lookup across translation units.</LI>
<LI><B>export</B> requires dealing simultaneously with many symbol tables. Instantiating an exported template can trigger cascaded instantiations in other translation units. Each must be able to refer to entities that existed (or &#147;sort of existed&#148;) when the template definition was parsed. In C++, dealing with one symbol table is complicated enough. With <B>export</B>, at least conceptually you need to simultaneously deal with an arbitrary number of symbol tables.</LI></OL>

<p>Along the way, EDG has found and reported numerous places where the C++ Standard does not specify how other C++ features are supposed to work in the presence of <B>export</B>; we&#146;ll consider some examples of these now.</p>

<H3><FONT COLOR="#000080">Ch-ch-ch-changes: Export&#146;s Shadow Falls on Existing Language Features</FONT></H3>

<p>export</B> has a few surprising effects on existing language features. Many of these real effects of <B>export</B> are not mentioned or addressed in the Standard. In particular, <B>export</B> &#147;exports&#148; more than its template:</p>

<UL><LI>   Some functions and objects in unnamed namespaces must now be accessible and callable across translation units, if they are used in exported templates. Similarly, some file-<B>static</B> functions and objects must now have external linkage, or at least behave as though they did, if they are used in exported templates. This is counter to the intent of unnamed namespaces and namespace-scope <B>static</B>, which was to make those names strictly internal to their original translation unit. (File-<B>static</B> functions and objects are deprecated, and you should use the unnamed namespace instead, but they&#146;re still part of Standard C++.)</LI>
<LI>   Overload resolution must also be able to resolve names from an arbitrary number of different translation units &#151; including, amusingly, overloading names from an arbitrary number of unnamed namespaces. A major benefit of putting internal functions into the unnamed namespace (and the deprecated file <B>static</B>) was to &#147;privatize&#148; those functions so you could give them simple names without worrying about name conflicts and overloading effects across source files. Now, because part of the protection is being removed and they can and do participate in overload resolution with each other via exported templates, it&#146;s (alas) a good idea to obfuscate their names again if you use such functions or objects in an exported template, even if the function is in an unnamed namespace or file <B>static</B>, so as to avoid silent changes of meaning.</LI>
<LI>   There are new ambiguities and potential ODR (One Definition Rule) violations. For example, a class may have multiple befriending entities in different translation units, and declarations of that class from those different translation units may all be participating in an instantiation. If so, which set of access rules should be applied? These issues may seem minor and many of the errors may be innocuous, but on some popular platforms ODR violations are increasingly important (see <a href="#8">[8]</a> for one example).</LI></UL>

<p>Incidentally, because <B>export</B> is underspecified in these and other issues not addressed in the Standard, EDG had to make decisions on questions with unspecified answers. There is a potential danger that if there are more implementations they will not be perfectly compatible with EDG&#146;s and each other&#146;s semantics.</p>

<H3><FONT COLOR="#000080">Export Can Be Difficult to Use Correctly</FONT></H3>

<p>export</B> will probably be somewhat more difficult to use correctly than normal templates. Here are three examples to illustrate why this is so.</p>
<p><I>Example 1: It is easier than before for programmers to write programs that have hard-to-predict meaning.</I> Like an inclusion-model template, an exported template commonly has different paths by which it could be instantiated, and each path commonly has a different context. For those who might say, &#147;But we already have that problem with functions defined in header files (e.g., <B>inline</B>),&#148; note that this template problem is already greater than that because there are more opportunities for names to change meaning, in particular because templates use a wider set of names than closed functions do. Templates use <I>dependent names</I>, names that are dependent on (and therefore vary with) the template arguments. So for each instantiation of the template with the very same template arguments, the template&#146;s user must be careful to provide exactly the same context (e.g., overloaded functions that operate on that template argument type) to prevent the instantiation from inadvertently having a different meaning in different files, which would be a classic ODR violation. Why is this expected to be somewhat worse under the <B>export</B> model than for inclusion-model templates? The big thing about <B>export</B> is the fact that, in addition to the above, there are names from multiple translation units available to name lookup, which is not true in any other context in Standard C++.</p>
<p><I>Example 2: It is harder for the compiler to generate high-quality diagnostics to aid programmers.</I> Template error messages are already notoriously hard to understand because of long and verbose names, but besides that, what&#146;s less obvious to programmers is that it&#146;s already harder for compiler writers to give good error messages for templates because templates can generate multiple and cascading instantiations. With <B>export</B>, there is now the additional dimension of multiple translation units &#151; a message like &#147;error on line X, caused by the instantiation of this function, caused by the instantiation of this function, caused by the instantiation of this function...&#148; must now add which translation unit it was in when it happened, and each line in the traceback could be from a different translation unit. Detecting ODR violations for exported templates is a challenging problem in itself, but detecting what was really meant so as to provide &#147;did you mean&#148; guidance is even harder. Many of us would be happy just to have our compiler emit readable error messages for plain old templates.</p>
<p><I>Example 3: </I><B>export</B><I> puts new constraints on the build environment.</I> The build environment does not consist of just <B>.cpp</B> and <B>.h</B> files any more, and many of today&#146;s tools don&#146;t understand how to handle apparently circular dependencies when the linker can go back and change <B>.obj</B> (or <B>.o</B>) files. As noted in the previous article, if you change an exported template file, you need to recompile that, but you also need to recompile all the instantiations. That is, <B>export</B> really does not separate dependencies; it just hides them. As also noted in the previous article, for EDG&#146;s implementation at least there&#146;s also a reverse dependency. Even experts find it hard to accept that <B>export</B> really is like this, but it is.</p>
<p>As the world&#146;s top template guru, John Spicer of EDG, notes: &#147;<B>export</B> is intricate in nature and it takes a lot of work to understand the consequences. <I>It&#146;s hard to make up simple usage guidelines that will keep users out of trouble.</I>&#148; [Emphasis mine.]</p>

<H3><FONT COLOR="#000080">Potential Benefits of Export</FONT></H3>

<p>Now that an implementation of <B>export</B> is finally available, for the first time ever, the time is ripe for the early adopters in the C++ community to start kicking the tires and see how it runs in the field. Here are two actual and potential values of <B>export</B> that some early adopters hope to achieve:</p>

<OL><LI><I>Build speed (still).</I> Although EDG&#146;s expectation is that <B>export</B> will give the same or poorer build speed in most cases, many people still hope that this fear will turn out to be unfounded, or at least that <B>export</B> may improve build speed in certain cases. Exploration in this area will let us discover how common those cases are and how easy or difficult those cases are to construct. In particular, it is hoped that translation units that use exported templates will be less sensitive to (i.e., less costly to rebuild when there are) changes in the template&#146;s definition.</LI>
<p><I> Caveats to #1:</I> For reasons why being able to break dependencies may not be the case and why dependencies still exist, see the previous article. Also, note that EDG says that, in their implementation of templates, this potential advantage is available equally to both inclusion and <B>export</B> source organization models &#151; which would mean that for EDG at least (which is the only available <B>export</B> implementation today) <B>export</B> would have no benefit over inclusion-model templates.</p>
<LI><I>Macro leakage.</I> Macros leak across traditional inclusion-model header files. Because the inclusion-model source code is entirely available in each translation unit, outside macros pulled in from elsewhere earlier in that translation unit can affect the template&#146;s definition. With <B>export</B>, macros don&#146;t leak across translation units, and this will help the template author to maintain better control over his template definitions (which are off in a separate file) and prevent outside macros from as easily interfering with his template definitions&#146; internals.</LI>
<p><I> Caveat to #2:</I> Note, however, that within the C++ standards committee&#146;s early work on the next Standard (C++0x), the Evolution Working Group is already pursuing better and more general solutions to the macro problem in all contexts, such as Stroustrup&#146;s work on potential new <B>#scope</B> and <B>#endscope</B> preprocessor extensions. If such a solution is adopted, it would eliminate entirely this advantage of <B>export</B>, because the preprocessor scope control solution would deliver all the macro-protection benefits of <B>export</B>, and many more, in a better way.</p></OL>

<p>In summary, it remains to be seen in the coming months and years how much benefit <B>export</B> gives over normal &#147;include all the code in the header&#148; templates, but I&#146;d like to strongly encourage the people who run those tests to also report the results of organizing their code to take full advantage of EDG&#146;s non-export capabilities and see whether any advantages to export actually remain.</p>

<H3><FONT COLOR="#000080">Morals</FONT></H3>

<p>So should you use <B>export</B>, and if so, how can you use it safely?</p>
<p>Well, for the next year or more, only a fraction of C++ programmers will be using an <B>export</B>-capable compiler that they can experiment with. For most C++ programmers, then, the question of whether to use <B>export</B> is moot: they can&#146;t, not anytime soon, so they won&#146;t. </p>
<p>What if you&#146;re using one of those up-and-coming newfangled <B>export</B>-capable compilers? Ah, now we can finally come up with an initial guideline:</p>
<p><I>Guideline:</I> For portable code, don&#146;t use <B>export</B>.</p>
<p><B>export</B> certainly can&#146;t be used for portable code, because given today&#146;s meager compiler support any code that uses <B>export</B> is not portable in practice today and will not be portable for some time to come. Even if and when other non-EDG-based implementations eventually become available, they might not be fully source compatible with EDG&#146;s implementation because EDG had to make decisions somewhat on the fly about how <B>export</B> should behave in areas where the Standard was silent. (Many of these are under consideration for inclusion in the Standard, however, as EDG has reported the issues and their own decisions. If those clarifications are included in the Standard, it would help to mitigate this danger.)</p>
<p>What if you don&#146;t need portable code, have <B>export</B>, and are tempted to use it? Then caveat emptor: be aware that <B>export</B> is still experimental, that it does not necessarily deliver the benefits people expect, and that it adds some new operational wrinkles to existing C++ language features. Be aware that exported templates can also be trickier to write for the reasons mentioned in these two articles and summarized again below.</p>
<p>My best advice today would be that, even if you just use one compiler and it has <B>export</B> today, in general you should try to avoid <B>export</B> for now in production code because it is still an experimental design. Let someone else be the guinea pig as we spend the next year or two trying it out and learning about what <B>export</B> will really give us.</p>
<p><I>Guideline (For Now):</I> Avoid <B>export</B>.</p>
<p>But, if you do decide to be one of the early-adopter experimenters, here are some things we already know you can do to make life safer and less stressful.</p>
<p><I>Guidelines:</I> If you do choose to use <B>export</B> selectively for some templates, then:</p>

<UL><LI>   Don&#146;t expect that <B>export</B> means you don&#146;t have to ship source code (or its equivalent) anyway. You still do, and this will not change.</LI>
<LI>   Don&#146;t expect that <B>export</B> means your builds will be earth-shatteringly faster. Initial experience is inconclusive, but your builds could well be slower.</LI>
<LI>   Check that your tools and environment can handle the new build requirements and dependencies (e.g., make sure all your tools understand that the linker can change its input <B>.obj</B>/<B>.o</B> files).</LI>
<LI>   If your exported template uses any functions or objects that are in an unnamed namespace or file <B>static</B>:</LI>
<UL><LI>   Understand that those functions/objects will behave as though they were <B>extern</B>, and that the functions are liable to participate in overload resolution with an arbitrary number of functions in other unnamed namespaces from an arbitrary number of source files.</LI>
<LI>   Always obfuscate (uglify) the names of those functions so as to prevent unintended semantic changes. (This is a pity because the unnamed namespace and file <B>static</B> are supposed to protect you from this so you don&#146;t have to obfuscate the names, but if you use <B>export</B> you can too easily silently lose this protection and should obfuscate them again.)</LI></UL>
<LI>   Do understand that this is not a complete list and that you will probably encounter some other issues beyond the ones we already know about for today&#146;s normal template uses. As Spicer put it: &#147;It&#146;s hard to make up simple guidelines that will keep users out of trouble.&#148; Do understand that <B>export</B> is still somewhat experimental, and that as a community we haven&#146;t yet had a chance to learn how to use <B>export</B>, so we don&#146;t have a complete set of good safety and usage guidelines yet. This will likely change in the future.</LI></UL>

<p>It&#146;s too early too tell whether the &#147;avoid <B>export</B>&#148; guideline will turn into permanent advice or not. Time and experimentation will tell. As vendors slowly begin to adopt and support <B>export</B> in the coming years, and the community gets a chance to finally try it out, we&#146;ll know much more about how and when to use it &#151; or not.</p>

<H3><FONT COLOR="#000080">Acknowledgments</FONT></H3>

<p>Many thanks to Bjarne Stroustrup, Steve Adamczyk, John Spicer, and Daveed Vandevoorde for their comments on drafts of this material.</p>

<H3><FONT COLOR="#000080">References</FONT></H3>

<p><a name="1"></a>[1]  H. Sutter. &#147;Sutter&#146;s Mill: &#145;Export&#146; Restrictions, Part 1,&#148; <I>C/C++ Users Journal</I>, September 2002.</p>
<p><a name="2"></a>[2]  B. Stroustrup. &#147;Parameterized Types for C++,&#148; <I>Proc. USENIX Conference</I>, Denver, October 1988.</p>
<p><a name="3"></a>[3]  M. Ellis and B. Stroustrup. <I>The Annotated C++ Reference Manual</I> (Addison-Wesley, 1990).</p>
<p><a name="4"></a>[4]  B. Stroustrup. <I>The C++ Programming Language</I>, 3rd ed. and special ed. (Addison-Wesley, 1997 and 2000).</p>
<p><a name="5"></a>[5]  Things were quite turbulent and support seesawed back and forth, balanced on a fulcrum. At the March 1996 meeting, the straw vote was two-to-one against separate template compilation. At the July 1996 meeting where the <B>export</B> keyword was introduced, the vote was two-to-one in favor of <B>export</B>.</p>
<p><a name="6"></a>[6]   See &lt;www.edg.com&gt;.</p>
<p><a name="7"></a>[7]  See &lt;www.comeaucomputing.com&gt;.</p>
<p><a name="8"></a>[8]  H. Sutter. &#147;Standard C++ Meets Managed C++,&#148; <I>C/C++ Users Journal</I>, <I>C++ .NET Solutions Supplement</I>, September 2002.</p>

<p><i><B>Herb Sutter</B> (&lt;www.gotw.ca&gt;) is convener of the ISO C++ standards committee, author of the acclaimed books <I>Exceptional C++</I> and <I>More Exceptional C++</I>, and one of the instructors of The C++ Seminar (&lt;www.gotw.ca/cpp_seminar&gt;). In addition to his independent writing and consulting, he is also C++ community liaison for Microsoft.</i></p>

</blockquote></body></html>
