<HTML>   
     <HEAD>
<TITLE>April 2002/We Have Mail</TITLE></HEAD>
<BODY BACKGROUND="" BGCOLOR="#FFFFFF" TEXT="#000000">
<H2><A HREF="../tocapr.htm"></A><FONT COLOR="#FF0000">   Departments</FONT></H2>

<HR>

<H2 ALIGN="center"><FONT COLOR="#800000">We Have Mail</FONT></H2>

<HR>
<BLOCKQUOTE>
<p><i>Letters to the editor may be sent via email to </I>cujed@cmp.com<I>, or via the postal service to Letters to the Editor, </I>C/C++ Users Journal<I>, 1601 W. 23rd St., Ste 200, Lawrence, KS 66046-2700.</i></p>

<hr><p>Mr. Allison:</p>
<p>I&#146;m sending this email in response to your request for feedback to the December 2001 <I>CUJ</I> Editor&#146;s Forum entitled &#147;What Every Programmer Should Know.&#148; I&#146;m currently a software engineer at a large aerospace company, but I spent a majority of the last fifteen years of my career in high-tech startups, medical systems development, &#147;the phone company,&#148; a software testing firm, and a defunct middleware company. My educational credentials include a BA in Mathematics (C.S. option), a Masters in Computer Information Systems, and a soon to be completed MS in Space Systems Operations Management.</p>
<p>I&#146;d like to suggest that &#147;Computer Science&#148; knowledge isn&#146;t the weak part of a new CS grad&#146;s skills. New grads are great at producing the required mass of code. The real weakness is in what I will call &#147;production skills.&#148; I&#146;ve observed that the things that you really need to be successful are software configuration management &#147;Philosophy,&#148; makefile &#147;engineering,&#148; unit/system test procedure creation/implementation, software development process (CMM &amp; ISO), and documentation development skills. A healthy dose of requirements analysis, systems analysis, and design using UML or similar methodology would also be really beneficial. Project management knowledge is also very valuable. Even if a programmer has no intention of leading a software development project, it is very useful to be able to understand such terms as &#147;critical path&#148; and &#147;predecessor task&#148; in order to understand what must be done and when to do it. It can also be extremely helpful in prioritizing the many tasks each developer faces on a daily basis. I&#146;m in total agreement with your requirement for communication skills. This list is based on my observation of the skills the &#147;really good programmers&#148; I&#146;ve worked with possess.</p>
<p>I&#146;ve observed that new grads can create extremely complex data structure handling routines, utilize very obscure STL features, and write an SQL query that reads like a novel. The problem is that coding is only one (small at that) aspect of the software system creation process. I liken coding and &#147;computer science&#148; skills to fine cooking skills. There are many fine chefs in the world, but it seems very few of them have all the necessary skills to open and run a successful world-class restaurant. It takes more than just cooking skills to do this, and it takes more than just bit-manipulation knowledge to produce &#147;industrial-strength&#148; software.</p>
<p>I look forward to reading the feedback to your December column and thanks for listening.</p>
<p>Martin Sagara</p>
<p><I>I pretty much closed the book on running responses to that forum, but this one was too good to let go. Thank you, Martin!</I></p>

<hr><p>Dear <I>CUJ</I>,</p>
<p>I got my first issue from you, it was the January issue, and found this incredibly good Perl stream class from Robert Y. Seward. Unfortunately, the source does not work in a Borland environment, because the compiler does not support nested classes the same way VC++ does.</p>
<p>I wanted to contact the author somehow, but there is no contact address and I could not find any contact either for addressing such problems.</p>
<p>Thank you very much</p>
<p>Christian</p>

<p><I>Robert Seward responds:</I></p>
<p><I>I don&#146;t know much about the Borland environment, but I may be able to help out. Are you saying that Borland does not handle nested classes at all? If that is the case, I may be able to help you out, as I wrote an earlier version without nested classes. Let me know exactly what your problem was, and we can go from there.</I></p>
<p><I>Robert</I></p>
<p><I>[Borland most certainly supports nested classes, but there always seem to be minor differences among compilers, so trying the non-nested version is good advice. &#151; cda]</I></p>

<hr><p>Hi,</p>
<p>I recently fell into this trap and thought that others might be interested.</p>
<p>In the case of large classes, it&#146;s not uncommon to see developers list their class methods and data members in alphabetical order to ease finding them. Take the following code:</p>

<pre>
class A
{
  public:
    A();
    .
    .
  private:
    B        aB;
    BManager aBM;
};

A::A() : aBM(), aB(aBM) {}
</pre>

<p>In my scenario, what I wanted was the <B>BManager</B> object to be created first because it was then passed to the <B>B</B> object so that the <B>B</B> object could register itself with the <B>BManager</B> object. I was most confused when this compiled and built, but kept producing segmentation faults caused by the object&#146;s constructor.</p>
<p>Turns out that what I had done wrong was assume that the order of the member initialization was controlled by the order of the initialization list, in the above case, <B>aBM</B> followed by <B>aB</B>. As stated in <I>The C++ Programming Language</I> (Bjarne Stroustrup, Section 10.4.6, Special Edition, Addison Wesley, 2000):</p>
<UL><p>The members&#146; constructors are called before the body of the containing class&#146; own constructor is executed. The constructors are called in the order in which the members are declared in the class rather that the order in which the members appear in the initializer list.</p></UL>
<p>Easily fixed in a multitude of ways (one shown below), but I wonder how many others have been caught out? The compiler I was using (yes, I&#146;ll admit it was written in house) didn&#146;t spot it, but do any of the more common ones spot it?</p>
<p>Regards,</p>
<p>Ashley Williams</p>

<p><I>Yep, it&#146;s just one of those things you have to keep in mind. Most books on C++ style mention as a rule of thumb that you should always list items in an initializer list in the same order as they appear in the class definition. If you have dependencies in the order of initialization (a dubious practice in general), then you must reorder the original declarations. No compiler I know compares the order of initializers to the declared order. &#151; cda</I></p>

<hr><p>Dear <I>CUJ</I>:</p>
<p>There are so many errors, including unbalanced parentheses, unbalanced brackets, and inaccessible data members, that the code in Mr. Hicks reply to Mr. Marooney&#146;s letter to <I>CUJ</I> in the September 2001 issue is incomprehensible, much less capable of being compiled. The king of the mountain is the line:</p>

<pre>
set&lt;unsigned int, &gt; indexedthings(f);
</pre>

<p>It goes without saying that <B>Thing::operator()( int x, int y )</B> having been defined at great and error-crammed length is never called.</p>
<p>Would someone, perhaps Mr. Hicks himself, try to make some sense of the example code given?</p>
<p>Charles Elliott</p>

<p><I>Dear Mr. Elliott,</I></p>
<p><I>I&#146;ve included the syntactically correct and compiled code (<a href="list1.htm">Listing 1</a>) along with output (<a href="fig1.htm">Figure 1</a>). I apologize for allowing the mistakes to appear in the pages of the </I>C/C++ Users Journal<I>.</I></p>
<p><I>I will try to explain myself more clearly. Mr. Marooney&#146;s code copied the value, paired it with an index, and stored them in a </I><B>multimap</B><I>. Since the original problem specified that we did not want to copy values, I provided a solution similar in spirit to Mr. Marooney&#146;s, but which only stores the index in a </I><B>set</B><I> and uses a functor to provide indirect access to the data.</I></p>
<p><I>The indirect access and the non-standard compare are combined in the functor&#146;s </I><B>operator</B><I> since there is thought to be little chance of reusability. That&#146;s why it is called </I><B>disposable_ftr</B><I>.</I></p>
<p><I>As for the rest of the letter, I stand corrected about the nature of a priority queue.</I></p>
<p><I>Mr. Marooney also asked whether a heap would have any advantages over </I><B>set</B><I> and noted that </I><B>set</B><I> has logarithmic insertion and deletion times. I mentioned that heap insertion from the bottom looks like it has </I><B>O(1)</B><I> time on average. The editor pointed out that it is still </I><B>O(log N)</B><I> worst case. While this is true, the average case can very important. It makes little difference if all elements are going to be deleted since then the </I><B>O(long N)</B><I> deletion time will become dominant anyway, but if only some of the values (e.g., less than </I><B>N/log(N)</B><I> elements) are ever going to be extracted, then an average </I><B>O(1)</B><I> insertion time would make the total average operation time </I><B>O(N)</B><I> (i.e., linear).</I></p>
<p><I>Respectfully Yours,</I></p>
<p><I>Craig Hicks</I></p>
<p><I>KGK Tokyo</I></p>

<p><I>CUJ</I>,</p>
<p>I am an email subscriber to <I>CUJ</I> (<B>vishu_iyer@hotmail.com</B>). I wanted to know whatever happened to R++ &#151; the rules implementation for C++. Is any implementation available at all according to the specification at &lt;www.research.att.com/sw/tools/r++&gt;?</p>

<p><I>Bjarne Stroustrup replies:</I></p>
<p><I>Unfortunately R++ is &#151; as far as I know &#151; inactive and unused. I don&#146;t think that there are any funds for developing or maintaining it at AT&amp;T or Lucent.</I></p>
<p><I>Bjarne</I></p>
</blockquote></body></html>
