<HTML>   
     <HEAD>
<TITLE>April 2002/An Efficient and Flexible Tracing Technique</TITLE></HEAD>
<BODY BACKGROUND="" BGCOLOR="#FFFFFF" TEXT="#000000">
<H2><A HREF="../tocapr.htm"></A><FONT COLOR="#FF0000">   Testing &amp; Debugging</FONT></H2>

<HR>

<H2 ALIGN="center"><FONT COLOR="#800000">An Efficient and Flexible Tracing Technique</FONT></H2>
<H3 ALIGN="center"><FONT COLOR="#800000">Dmitri Leman</FONT></H3>

<BLOCKQUOTE>
<p>This extensible tracing framework tames the dreaded multithreaded debugging demon.</p>
</BLOCKQUOTE>

<HR>
<BLOCKQUOTE></p>
<p>Suppose you need to track down a problem in a multithreaded or event-driven application. An interactive debugger is of little help, since it shows only a snapshot of your process where it stopped on a breakpoint. Single stepping is of no help either since other threads continue to work and distort the picture. The usual approach then is to sprinkle the program with trace operators and record a log of program execution prior to the problem. There is no shortage of different tracing implementations ranging from simple <B>printf</B> to complicated frameworks capable of collecting traces from multiple applications and computers. Often disappointment awaits the developer when, after the insertion of enough trace operators into the program, the bug disappears. This is especially common in debugging thread-synchronization problems since most tracing routines use thread synchronization inside. For a discussion of debugging multithreaded applications, see <a href="#1">[1]</a>.</p>
<p>This article presents a utility that uses a circular memory buffer for efficient trace recording. It uses the Pentium interlocked <B>XADD</B> (Exchange and Add) instruction to synchronize access to the buffer without the overhead of critical sections. Originally it was written in C++ for Win32 and used memory-mapped files to collect traces from several applications. Later I ported it to Windows NT kernel mode to debug applications and drivers working together. The version included with this article also was ported to Linux and provides a Java JNI interface, which helps in debugging Java as well as C++ applications. The JNI tracing is not as efficient as C++, however. I also include an application for viewing the trace buffer without affecting the debuggee.</p>

<H3><FONT COLOR="#000080">Design</FONT></H3>

<p>There are two major ways to trace programs: you can manually insert trace statements in the source code, or you can use automated instrumentation of source or binary code. For quick exploration of a program when source code is unavailable or unfamiliar, the second way works best. However, the first method works best when trace statements are written and maintained along with the code. The tracer presented in this article will implement the first approach and provide macros, which should be inserted in the application source code. These macros are similar to <B>printf</B> and trace statements from other tracing frameworks. It should be easy to convert <B>printf</B> or trace statements in existing source files.</p>
<p>Many programmers stop using trace when an application becomes large and too many trace operators cause too much noise and reduce performance. Frequent commenting of <B>printf</B> operators in and out is a common practice, but it is too tiresome. Many other tracing facilities (such as <B>syslog</B> on Unix) use a trace level as the first parameter of trace statements to help reduce output volume. Unfortunately, during debugging, it is usually necessary to increase the trace level to maximum, which causes noise to hide the important data. The tracer presented here will use a bit mask or a keyword to achieve finer selectivity of filtering than a simple trace level. The trace statements should be divided into groups according to their membership in different functional components, such as message loops, networking, drivers, error messages, etc. (A similar technique is presented in <a href="#5">[5]</a>.) Up to 32 group constants may be defined in <B>enum TraceGroups</B> in <B>htrace.h</B>, each having a single bit set on one of 32 positions. For larger programs, 32 groups are insufficient. In these cases, string keywords should be given as the first parameter of <B>HTRACEK</B> statements. This allows creation of any number of groups, but causes larger overhead for string comparison on the first call to each trace statement. Other approaches for noise reduction are proposed in <a href="#2">[2]</a>, <a href="#3">[3]</a>, and <a href="#4">[4]</a>.</p>
<p>This article focuses on using a memory buffer to collect trace messages, but the tracer also includes routines for other types of trace output such as debug monitor, file, console, event log, and message box. All have some advantages and cannot be replaced by any single kind of output. <a href="tab1.htm">Table 1</a> lists some common output methods and their approximate overhead. I&#146;ve seen programs that called several tracing routines like <B>printf</B> and <B>fprintf</B> one after another. To avoid such a mess, the tracer assigns a 32-bit mask or a keyword to each trace output at run time. A <B>TRACE</B> statement is printed to all outputs that has a mask matching the trace group. For <B>HTRACEK</B> statements, a keyword search is performed on the first call after starting or after a keyword change.</p>
<p>To help simultaneously debug several applications and drivers, the tracer should allow the collecting of all trace messages in a single shared memory buffer. To achieve this, it should have routines for managing shared memory and for communicating with a driver. <a href="fig1.htm">Figure 1</a> shows a component diagram with several C++ and Java applications and drivers. This is an extreme case, however. Most of the time, I use the tracer in a single application.</p>

<H3><FONT COLOR="#000080">Implementation</FONT></H3>

<p>The tracer implementation consists of two files: <B>htrace.h</B> and <B>htrace.cpp</B>. The format of the memory buffer is declared in <B>GlobalTraceBufferHeader</B> and <B>GlobalTraceBufferFooter</B> found in <B>htrace.h</B> (see <a href="fig2.htm">Figure 2</a>). The buffer is divided into header, footer, and text areas. The header contains a 4-byte signature and the 12-byte size of the text area in string format. The signature allows identifying the trace buffer in memory and on disk. The size string should be converted to an integer to determine the size of the text area and location of the footer. The reason for keeping the size in a string form is to allow text editors to open and view the trace buffer file as text. In earlier versions, I kept the size as an integer, which caused some text editors to open the file in binary format. Therefore, I moved all other integers to the footer.</p>
<p>The first field of the footer keeps the total number of bytes written to the buffer. This number is updated by using the Pentium atomic <B>XADD</B> instruction, which requires the field to be a 4-byte integer aligned on a 4-byte boundary. Since the buffer is circular, the number of written bytes may exceed the size of the text area. Therefore, the index of a byte next to the last written byte is equal to the total number of bytes written modulo the text area size.</p>
<p>The purpose of the next field, &#147;Stop after threshold,&#148; is to discard all new traces after the total number of bytes written reaches that threshold. This lets a program freeze the trace buffer when enough information before and after an error occurrence is recorded. The third field is an indication that the buffer is already frozen. The last three fields of the footer are used to filter the trace output by mask or keyword as described in the &#147;Usage&#148; section below.</p>
<p>At the heart of memory buffer tracing implementation is <B>AddToTraceBuffer</B> (see <a href="list1.htm">Listing 1</a>). It expects two parameters: a pointer to a string and a string length. In the beginning, this routine retrieves a pointer to the memory buffer and its size and verifies that the given string fits into the buffer. Then it calls <B>InterlockedExchangeAdd</B> to increase the &#147;Total number bytes written&#148; field by the length of the string and to get the original value. This reserves a space in the buffer for the new string. This operation is atomic: even if a thread switch occurs or another processor executes this function at the same time, each thread will reserve a separate space. If the reserved space is beyond the &#147;Stop after threshold&#148; value, the function returns. In order to translate the reserved space into an index in the circular text area, its modulus is taken by the size of the text area. Then the routine checks whether the given space wraps around the end of the buffer. If it does not, it simply copies the trace string into the text area. Otherwise, two <B>memcpy</B> calls are needed.</p>
<p><B>AddToTraceBuffer</B> does not protect its whole body with a critical section or a spin lock unlike other similar techniques (i.e., <B>printk</B> on Linux). Unlike a critical section, the Pentium <B>XADD</B> instruction is very efficient and cannot block the calling thread. Absence of thread synchronization calls also allows tracing drivers and OS internals even at interrupt time. For an example of tracing Windows NT kernel API calls, interrupts, and port accesses, see <a href="#6">[6]</a>. A problem with this approach arises from a possible thread switch after the space is already reserved, but before (or during) the <B>memcpy</B>. Eventually the first thread will resume and will finish writing to the reserved space. But if other threads produce a large volume of output before the first thread resumes, they may fill the buffer, wrap around, and start filling the space reserved by the first thread. When the first thread resumes, it will garble the output. To work around this problem, it usually suffices to allocate a large enough buffer to keep at least a few dozen seconds of output without wrapping around. Of course, if the first thread has a low priority, it can be suspended for a very long time and still garble the buffer.</p>
<p>Other routines in <B>htrace.cpp</B> provide several ways of allocating and sharing the trace buffer between applications and drivers. The simplest and most portable way is to use <B>malloc</B>. A buffer allocated by <B>malloc</B> cannot be shared with other applications on Windows or Linux, and it will vanish and take the valuable trace with it in the case of an application crash. But it is a good choice for an embedded environment with shared application memory. <B>htrace.cpp</B> includes a function to print a circular memory buffer to a file. On Windows and Linux, I usually use memory-mapped files instead of <B>malloc</B>. They can be shared between applications, survive an application crash, and can be viewed at run time by a simple text editor or a dynamic viewer utility (available for download from the <I>CUJ</I> website at &lt;www.cuj.com/code&gt;). Occasionally, I have needed to debug applications and drivers together on Windows NT. To support this, I have added routines to allocate memory from non-paged kernel mode space and then have mapped it to the application space. After the first driver allocates a buffer, several applications and drivers can use IOCTL calls to retrieve a pointer to the buffer and produce a combined trace output.</p>

<H3><FONT COLOR="#000080">Usage</FONT></H3>

<p>Like many of the other tracing methods, <B>htrace.h</B> defines macros <B>HTRACE</B> and <B>HTRACEK</B>, which receive a formatting string and a list of parameters like <B>printf</B>. <B>HTRACE</B> expects a trace group constant (usually declared in <B>enum TraceGroups</B> in <B>htrace.h</B>) as the first argument, while <B>HTRACEK</B> needs a string keyword constant. Compilation of these macros, as well as the rest of the tracing engine, is controlled by the <B>TRACE_</B> compiler definition. Normally <B>TRACE_</B> should not be defined in a program&#146;s release version, and the compiler will exclude these macros from the resulting code. But the trace support is not restricted to the debug version of a program: if necessary <B>TRACE</B> can be enabled in a release version if a problem is not reproducible in the debug build. (See <a href="#7">[7]</a> for another tracing approach for release builds.)</p>
<p>If a program already has a lot of trace statements like MFC<B> TRACE</B> or <B>syslog</B>, it may be possible to redefine them in a header file to use <B>HtraceImpl</B>, which is the workhorse of the tracing engine. The only significant difference is that <B>syslog</B> uses a priority as the first parameter, while <B>Htrace</B> uses bit masks or keywords.</p>
<p>To use the trace, an application should call <B>TraceInitialize</B> at the beginning and call <B>TraceUnInitialize</B> before termination. The second step is to redirect different trace groups to various output streams. <B>TraceAssignGroupsToStream</B> allows turning on and off individual group flags defined in <B>enum TraceGroups</B> for each trace output specified by constants in <B>enumTraceOutputs</B>. <B>TraceAssignGroupKeyWordToStream</B> is used to assign group keywords to output streams. <a href="fig3.htm">Figure 3</a> shows an example of trace initialization, as well as <B>HTRACE</B> and <B>HTRACEK</B> macros. <B>htrace.h</B> contains a detailed description of all tracing routines.</p>
<p>Several routines are provided for managing the trace memory buffer. <B>TraceAllocateBuffer</B> uses <B>malloc</B> or another platform-specific API to allocate a local buffer. <B>TraceDumpBufferToFile</B> prints a circular trace buffer to a file. <B>TraceUseMemMapFileBuffer</B> creates a memory-mapped file to share the trace buffer among several applications. <B>TraceSetExternalBuffer</B> and <B>pGetTraceBuffer</B> conveniently let one application or driver use a buffer allocated by another. <B>TraceAttachToNTDriverBuffer</B> works only on Windows NT and uses IOCTL calls to retrieve the buffer from a driver. <B>TraceFreezeBufferAfter</B> allows freezing the trace buffer after a certain amount of data (measured in a percentage of the buffer size) has been added from the moment of the call. It is valuable to make sure that the traces immediately preceding or following a bug report will not be lost. For example, calling <B>TraceFreezeBufferAfter (50)</B> ensures that the last trace will be in the middle of the trace buffer after the freeze. Calling <B>TraceFreezeBufferAfter (100)</B> at the beginning of execution effectively transforms a circular buffer into a linear one. A linear buffer is better than circular one when debugging early stages of system initialization because it prevents the very first traces from being overwritten.</p>

<H3><FONT COLOR="#000080">Portability</FONT></H3>

<p>htrace.cpp</B> requires a C++ compiler. I used Visual C++ 6.0 for Win32 and Windows NT kernel mode and g++ version egcs-2.91 for Red Hat Linux 6.1. <B>htrace.h</B> can be included by C modules as well as C++. Java support is provided using JNI 1.1. <B>htrace.cpp</B> includes JNI routines, which are declared in <B>hTrace.java</B>.</p>
<p>Memory buffer tracing routines are probably the most easily portable. The minimal solution includes <B>AddToTraceBuffer</B> and <B>TraceAllocateBuffer</B>. <B>AddToTraceBuffer</B> uses <B>InterlockedExchangeAdd</B> available on Win32 and Windows NT kernel mode. When porting to Linux, I implemented <B>InterlockedExchangeAdd</B> using the Pentium <B>XADD</B> instruction. There should be no problem with compiling it on other operating systems running on Pentium.</p>
<p>To port to other processors, I suggest first looking into the OS API for interlocked or atomic routines. If found, it is necessary to make sure that the API does not use any critical sections, semaphores, or other synchronization objects inside. If nothing is found, I would look for an appropriate instruction in the processor manual. Modern processors usually have some support for atomic operations. It may be a single instruction (like on Pentium) or a well-defined sequence (like on Alpha &#151; see &#147;Atomic Update of a Single Datum&#148; in <I>Alpha Architecture Handbook</I>). Extra care should be taken with multiprocessor systems. On Pentium, for example, it is necessary to add the <B>LOCK</B> prefix before the <B>XADD</B> instruction.</p>
<p>Recently I needed to port the trace to the StrongArm processor and didn&#146;t find any support for atomic updates except for a simple exchange instruction. So far, I have simply used a non-atomic update, which requires at least three instructions to load, update, and store the variable. Since there is only one processor, there is a small risk of a thread switch between these instructions, which will cause one or more missing trace strings. If this will be a problem, I may try to disable interrupts for the duration of these instructions. Disabling interrupts is a common practice in simple embedded environments where all code executes with administrative privileges.</p>
<p><B>TraceAllocateBuffer</B> requires support for <B>malloc</B>, which is not available on some platforms. For example in Windows NT kernel mode, I used <B>ExAllocatePool</B> instead. Memory-mapped file support routines are more difficult to port. I ported them to Linux using the <B>mmap</B> API. The biggest difficulty was to count how many processes use the file to ensure that only the first process performs initialization of the buffer. The solution was to use a counting semaphore.</p>
<p><B>htrace.cpp</B> has a lot of other platform-specific routines to provide trace to the console, debugger, file, etc. Most of them have some kind of analog on different platforms. For example, <B>OutputDebugMonitor</B> is implemented as <B>OutputDebugString</B> on Win32, as <B>DbgPrint</B> in the Windows NT kernel API, and as <B>syslog</B> on Linux.</p>
<p>When porting to a new environment, I first find a platform-specific compiler definition, such as <B>WIN32</B> or <B>__linux__</B>. If nothing unique is defined, I declare my own (i.e., <B>TRACER_NTDRIVER_</B>) in the compiler settings. It is also necessary to define <B>TRACE_</B> to enable the trace. Then I add the most common platform-specific headers under <B>#ifdef</B> at the top of <B>htrace.cpp</B>, such as <B>windows</B> on Windows or <B>"unistd.h"</B> on Linux. From the beginning, it may not be clear which other more specific headers, such as <B>sys/mman.h</B>, to add. I will do it later when adding support for a particular trace output. Next I try to compile to make sure that the common trace initialization and formatting routines, such as <B>HtraceImpl</B> and <B>TraceAssignGroupsToStream</B>, can compile and link. I had the most trouble with the <B>vsnprintf</B> C library routine, which is called differently on Linux and Windows and not implemented on other operating systems. A quick solution is to use <B>vsprintf</B> instead and remember to never print a single trace statement larger than the temporary buffer inside <B>HtraceImpl</B> (512 bytes). Unlike <B>vsnprintf</B>, <B>vsprintf</B> does not check for buffer overwrites. Then I port a minimal set of output routines. The usual candidates are <B>AddToTraceBuffer</B>, <B>TraceAllocateBuffer</B>, <B>WriteCircularBufferToFile</B>, and <B>OutputConsole</B>. The initial porting usually takes a few hours to enable the trace and start adding <B>HTRACE</B> macros to a program.</p>
<p>The tracing framework allows easy addition of new output streams. For example, a requirement may be to dump all errors and warnings into a database, send them by email, or redirect to another computer. If the application already has trace statements with appropriate group constants, it is necessary only to add an output constant to <B>enum TraceOutputs</B>, write an output routine to <B>htrace.cpp</B>, and add a line to array <B>s_Outputs</B>. Then the selected trace groups may be redirected to the new output by changing appropriate masks, which are usually stored in an <B>.ini</B> file or the registry.</p>

<H3><FONT COLOR="#000080">Tracing Thread Context Switches</FONT></H3>

<p>To show an example of using the trace with applications and drivers, I wrote a small Windows NT kernel-mode driver, which traces thread switches. Seeing the exact moment in the trace file when the thread switch happens may help to find some thread-related bugs. The driver places a hardware-assisted breakpoint in the location <B>fs:[0x124]</B>, which holds a pointer to the current thread in all versions of Windows NT 4.0 and 2000. This technique is not perfect. The tracing may stop if some other application or debugger modifies the debug breakpoint register. The machine may crash if a system-level debugger installs an interrupt handler while the tracer driver is working. Other methods of thread switch tracing are discussed in <a href="#8">[8]</a>.</p>
<p>The example also includes a simple application <B>BankAcct</B> that implements a common &#147;bank account&#148; routine, which modifies the account value. When called from multiple threads without proper synchronization of the account, it will, sooner or later, corrupt the account value, which will drop below zero. Similar examples are often used to illustrate thread-related bugs. With the trace, it is possible to see exactly when the thread switch happened that caused the corruption. An excerpt from the trace file is shown in <a href="fig4.htm">Figure 4</a>. For details about running this sample see <B>readme.txt</B> included with the source code.</p>

<H3><FONT COLOR="#000080">Conclusion</FONT></H3>

<p>Many programmers avoid using trace because it is too tiresome to add <B>printf</B> operators and then comment them out. Also the large volume of output may slow down the application. I found that having a flexible and efficient tracing framework in place made it easy to start adding trace statements during the initial program development. As complexity of the system grows, additional traces may be added and trace groups refined, which allows more detailed views of the system behavior. It is very rarely necessary to remove or comment out trace statements, since overhead is negligible and no output is produced unless the corresponding group is enabled. Trace improves visibility of the inner working of applications and drivers and helps locate the toughest bugs.</p>

<H3><FONT COLOR="#000080">Source Code</FONT></H3>

<p>The complete source code along with the example application is available for download from the <I>CUJ</I> website at &lt;www.cuj.com/code&gt;.</p>

<H3><FONT COLOR="#000080">Notes</FONT></H3>

<p><a name="1"></a>[1]  Peter Horwood, Shlomo Wygodny, and Martin Zardecki. &#147;Debugging Multithreaded Applications,&#148; <I>Dr. Dobbs Journal</I>, March 2000.</p>
<p><a name="2"></a>[2]  John Robbins. &#147;Bugslayer,&#148; <I>Microsoft Systems Journal</I>, December 1997.</p>
<p><a name="3"></a>[3]  John Robbins. &#147;Bugslayer,&#148; <I>Microsoft Systems Journal</I>, June 1999.</p>
<p><a name="4"></a>[4]  Rainer Storn. &#147;A Debug/Trace Tool,&#148; <I>Dr. Dobbs Journal</I>, February 1997.</p>
<p><a name="5"></a>[5]  Daniel Pilat. &#147;An Improved TRACE() Macro,&#148; <I>Windows Developers Journal</I>, July 1999.</p>
<p><a name="6"></a>[6]  Dmitri Leman. &#147;Tracing Kernel API Functions,&#148; <I>Windows Developers Journal</I>, April 2000.</p>
<p><a name="7"></a>[7]  Boris Bromberg. &#147;Tracing an Application in Release Configuration&#148;, <I>C/C++ Users Journal</I>. September 2000.</p>
<p><a name="8"></a>[8]  Jacob R.Lorch and Alan Jay Smith. &#147;The Vtrace Tool,&#148; <I>MSDN Magazine</I>, October 2000. </p>

<p><i><B>Dmitri Leman</B> is a software engineer in Silicon Valley. He has been developing Windows, DOS, and Linux applications, and device drivers for 10 years. He can be reached at <B>DmitriL@Forwardlab.com</B>.</i></p>

<h4><a href="../../../source/2002/apr02/leman.zip"></a></h4>
</blockquote></body></html>
