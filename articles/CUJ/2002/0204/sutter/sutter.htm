<HTML>   
     <HEAD>
<TITLE>April 2002/Modern C++ Design</TITLE></HEAD>
<BODY BACKGROUND="" BGCOLOR="#FFFFFF" TEXT="#000000">
<H2><A HREF="../tocapr.htm"></A><FONT COLOR="#FF0000">   Book Review</FONT></H2>

<HR>

<H2 ALIGN="center"><FONT COLOR="#800000"><i>Modern C++ Design</i></FONT></H2>
<H3 ALIGN="center"><FONT COLOR="#800000">reviewed by Herb Sutter</FONT></H3>


<HR>
<BLOCKQUOTE>

<table>
<tr><td><b>Title:</b></td><td><I>Modern C++ Design</I></td></tr>
<tr><td><b>Author:</b></td><td>Andrei Alexandrescu</td></tr>
<tr><td><b>Publisher:</b></td><td>Addison Wesley Professional, 2001</td></tr>
<tr><td><b>Pages:</b></td><td>352</td></tr>
<tr><td><b>ISBN:</b></td><td>0201704315</td></tr>
<tr><td><b>Price:</b></td><td>$39.95</td></tr>
</table>

<p>Anyone who thinks they&#146;ve seen it all in C++, or that there&#146;s nothing new left to be said, obviously hasn&#146;t read <I>Modern C++ Design</I>.</p>
<p><I>Modern C++ Design</I> is an important book. Fundamentally, it demonstrates how to create reusable design pattern implementations in C++ &#151; a new way to combine templates and patterns that you may never have dreamt was possible, but is. <I>Modern C++ Design</I> is not for novices. There are a lot of advanced techniques here, but it&#146;s a testament to Alexandrescu&#146;s skill that he teaches advanced and useful design techniques in a way that&#146;s easy to understand, assimilate, and put into practice on your next project. Better still, you can reuse the code in the book&#146;s Loki library to solve real-world problems right away &#151; with a few caveats that are due, not to Loki itself, but just to limitations in some of today&#146;s compilers.</p>

<H3><FONT COLOR="#000080">The Book</FONT></H3>

<p>If your work involves production C++ design and coding, you should read this book. Even if you only read the first two chapters, you will come away with important ideas about how to design for extensibility in C++ and many useful supporting techniques based mainly on templates. But fair warning: if you do read the first two chapters, you&#146;ll probably be hooked and won&#146;t be able to stop until you reach the back cover. That&#146;s a good thing, because although the first couple of chapters are cool and interesting, the real meat and value of the book comes later on.</p>
<p>We&#146;ve probably all written Singleton and Visitor in our code. What&#146;s more, the ugly truth is that we&#146;ve all done it many times. This is because, as the patterns community is quick to remind us, design patterns are not code. Patterns, they are equally quick to elaborate, merely document recurring styles and idioms that crop up in the design process, which then only later eventually manifest as code. The pattern description tells you what the pattern looks like, but then it&#146;s up to you to go write new code every time you want to apply it.</p>
<p>Wouldn&#146;t it be nice if, instead, patterns could be made available as reusable chunks of code you could call directly from your program, like <B>std::list</B> or <B>std::sort</B>? Aren&#146;t you tired yet of writing Singleton and Visitor over and over? (If not, why not?) And so the main value and meat of <I>Modern C++ Design</I> lies in its techniques for creating just that: reusable implementations of design patterns, actual nuts-and-bolts code libraries than <I>can</I> be reused directly without hand-implementing them every time. Such &#147;generic patterns,&#148; or &#147;pattern templates&#148; as I think of them, are a powerful new way of creating extensible designs in C++. To demonstrate, Alexandrescu provides walkthroughs for several specific generic pattern implementations, devoting one chapter each to Abstract Factory, Multimethod, Smart Pointer, Singleton, and Visitor.</p>
<p>&#147;But wait,&#148; I can hear someone object, &#147;that&#146;s not how it works in practice! In the real world, there&#146;s no one Singleton; there&#146;s no one Visitor. We implement those patterns in different ways in different places even in the same program, depending on the exact requirements in each place they&#146;re needed! I just don&#146;t believe that there can be any useful one-size-fits-all solution.&#148; (For example, consider the classic and thorny question of when a Singleton should be destroyed; the answer may be different for different Singletons in your program.)</p>
<p>That objection is perfectly valid, and I can imagine Alexandrescu smiling and rubbing his hands gleefully and responding: &#147;Yup. And I&#146;m glad you raised that question, because I was just getting to that part....&#148; Such variability, as it turns out, is no barrier to Alexandrescu&#146;s approach: he simply writes <I>all</I> (well, all right then, <I>many</I>) of the versions of Singleton you&#146;ll ever need. You then instantiate the reusable Singleton implementation with policies that make it work the way you need in that particular place in your code and instantiate it with different policies in other places. What if none of the default policies does quite what you want? Chances are you can write or specialize your own policy that will, thus writing the minimum code once, and only once, to extend and customize just that part of the pattern implementation&#146;s behavior to account for the new requirement. The point is that the implementation of Singleton really is done once up front and then reused many times, instead of being implemented by hand in every place. No fuss, no muss.</p>
<p>Indeed, let me put it more succinctly still: implementation variability is not a barrier to Alexandrescu&#146;s approach; it&#146;s the very reason his approach is important.</p>
<p>Oh, and he does the same with smart pointers. And Visitor. And Multimethods. Natty stuff.</p>
<p>An obligatory but minor caveat: the first printing of <I>Modern C++ Design</I> unfortunately contained numerous (literally hundreds of) typographical errors. I hasten to stress that these are not the author&#146;s fault, but simply unfortunate production problems, and the typos are mostly obvious and don&#146;t affect the quality of the material in the book. I also hasten to stress that this is probably of historical interest only, because by the time you read this review, you&#146;ll almost certainly be buying the second or later printing, which pretty much have fixed these errors wholesale.</p>

<H3><FONT COLOR="#000080">The Loki Library</FONT></H3>

<p><I>Modern C++ Design</I> describes the techniques and facilities available as the Loki library, which is freely available, downloadable, and pretty much ready to use. If you want to try out some or all of Loki&#146;s facilities, including Singleton, Visitor, and others, you can do it today.</p>
<p>One of the things I&#146;ve noticed that makes Loki so interesting is that &#147;can compiler <I>XYZ</I> compile Loki?&#148; is becoming something of an unofficial benchmark in compiler-writer circles. Don&#146;t get me wrong, Loki is written entirely in normal Standard-conforming C++ &#151; only more standard and more conforming, it turns out, than some compilers are yet quite ready to digest. Loki is one of the most technically advanced C++ libraries available, which is a polite way of saying that it uses templates so widely and heavily that it tears the tar and stresses the stuffing out of some current compilers. In fact, at the time the book was released, no commercially available compiler could compile <I>all</I> of Loki correctly, despite notes to the contrary in the book&#146;s Preface about compilers that could compile <I>most</I> of Loki. But progress is being made: recently, Loki has been ported to the Gnu g++ platform, with only minor tweaks to work around miscellaneous spots of compiler indigestion.</p>
<p>It&#146;s a bit ironic that Loki is deliberately named after the Norse god of wit and mischief. The name was designed to highlight the playful flexibility of the library. It has an unintentional second application: Loki wreaks more mischief with today&#146;s compilers than does any other popular library.</p>

<H3><FONT COLOR="#000080">Summary</FONT></H3>

<p>Although this book is definitely not for novices, it&#146;s hard to overestimate the impact of Andrei Alexandrescu&#146;s <I>Modern C++ Design</I>. Indeed, if Jim Coplien hadn&#146;t already written an influential book called <I>Advanced C++ Programming Styles and Idioms</I>, I&#146;m sure that&#146;s what the title for Alexandrescu&#146;s book could easily &#151; and correctly &#151; have been. I highly recommend this book for the serious C++ practitioner.</p>

<p><i><B>Herb Sutter</B> (&lt;www.gotw.ca&gt;) is an independent consultant and one of the instructors of The C++ Seminar (&lt;www.gotw.ca/cpp_seminar&gt;). He is also secretary of the ISO/ANSI C++ standards committee and author of the acclaimed books </I>Exceptional C++<I> and </I>More Exceptional C++<I>.</i></p>

</blockquote></body></html>
