<HTML>   
     <HEAD>
<TITLE>April 2002/Editor's Forum</TITLE></HEAD>
<BODY BACKGROUND="" BGCOLOR="#FFFFFF" TEXT="#000000">
<H2><A HREF="../tocapr.htm"></A><FONT COLOR="#FF0000">   Departments</FONT></H2>

<HR>

<H2 ALIGN="center"><FONT COLOR="#800000">Editor's Forum</FONT></H2>

<HR>
<BLOCKQUOTE>

<H3><FONT COLOR="#000080">Good Stuff</FONT></H3>
<p>Robert Sedgewick, evangelizer of Quicksort and other fun fare, once said, &#147;Algorithms are the Stuff of Computer Science.&#148; Nowadays I suppose he would have quite a fight on his hands to convert the teeming hordes that claim that objects are the Right Stuff. I&#146;m an ardent believer and proselytizer for objects, but I must confess that I find great satisfaction in facing the intellectual intrigue of finding just the right algorithm for a particular task, or of squeezing a bit more performance out of procedures in existing code.</p>
<p>To wit, just the other day I ran across a curious algorithm that claims to break the <B>O(n log n)</B> barrier for general-purpose sorting. It&#146;s a quirky sort of function, hard to follow at first. Nonetheless, I ran it through those proverbial Hoops and found it to live up to its claims. Here is a table representing the number of comparisons it took to sort random sequences of large strings, for various sequence sizes (<B>n</B>). (For want of a better name, I call it QuirkSort.)</p>

<table cellspacing="6">
<tr><td align="right"><b>N</b></td>
<td align="right"><b>QuickSort</b></td>
<td align="right"><b>MergeSort</b></td>
<td align="right"><b>QuirkSort</b></td></tr>
<tr><td align="right">1,000</td>
<td align="right">3,162</td>
<td align="right">3,047</td>
<td align="right">2,019</td></tr>
<tr><td align="right">100,000</td>
<td align="right">512,340</td>
<td align="right">622,501</td>
<td align="right">99,532<td align="right" cellspacing="6"></tr>
<tr><td align="right">100,000,000</td>
<td align="right">811,587,042</td>
<td align="right">889,602,117</td>
<td align="right">123,456,789</td></tr>
</table>

<p>Amazing, isn&#146;t it? Unfortunately, there is not enough room left on this page to give a suitable explanation of this algorithm, so I&#146;ll leave that to another time.</p>
<p>On a lighter note, I just got wind that the Rogue Knave Poet is at it again. Herewith is the latest contribution of H. P. Typecraft (not his/her real name, of course).</p>

<H4><FONT COLOR="#000080">Not the JVM (with apologies to Bob Dylan)</FONT></H4>

<p>How many languages must a programmer try<br>
Before you call him a man?<br>
How many versions can vendors create<br>
And claim that a standard is planned?<br>
How many times must hype marketing fly<br>
Before it&#146;s forever banned?<br>
The answer, my friend, is not the JVM<br>
The answer is not the JVM<br>
<br>
How many years can a program exist<br>
Before it abuses the heap?<br>
How many years can some objects exist<br>
Before they&#146;re allowed to be freed?<br>
How many times can a man write his code<br>
And pretend that he just doesn&#146;t C?<br>
The answer, my friend, is not the JVM<br>
The answer is not the JVM<br>
<br>
How many docs must a man look up<br>
A consistent answer to find?<br>
How many tools must one manager have<br>
Before his developers cry?<br>
How many crashes will it take till he knows<br>
That too many servers have died?<br>
The answer, my friend, is not the JVM<br>
The answer is not the JVM<br>
<B>&#151; H. P. Typecraft</B></p>

<p>Chuck Allison<br>
Senior Editor<br>
<B>cda@freshsources.com</B></p>
</blockquote></body></html>
