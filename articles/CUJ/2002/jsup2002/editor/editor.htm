<HTML>   
     <HEAD>
<TITLE>Java Solutions February 2002/Editor's Forum</TITLE></HEAD>
<BODY BACKGROUND="" BGCOLOR="#FFFFFF" TEXT="#000000">
<H2><A HREF="../tocjfeb.htm"></A><FONT COLOR="#FF0000">   Java Solutions</FONT></H2>

<HR>

<H2 ALIGN="center"><FONT COLOR="#800000">Editor's Forum</FONT></H2>

<HR>
<BLOCKQUOTE>

<H3><FONT COLOR="#000080">Adopting OO</FONT></H3>
<p>I&#146;m writing this editorial in Ottawa, where I&#146;m teaching a week-long OO-design workshop. (After some preliminaries, we spend three days actually taking a real design from requirements gathering through the UML-modeling stage). It&#146;s a great way to learn the subject since you get hands-on experience actually doing it. This time, as is more than often the case, someone brought up the adoption issue: &#147;This stuff is great, I really understand how doing all this will make me more productive, but how can I get my manager to go along?&#148; This question is a tough one to answer in the general case, but I&#146;ll give it a try.</p>
<p>In her <I>Succeeding With Objects</I>, Adel Goldberg says &#147;Many people tell the story of the CEO of a company who bragged that his project was object oriented because it was written in C++. Many people don&#146;t realize that this is a joke.&#148; Simply writing a program in Java doesn&#146;t make the program object oriented, though many managers don&#146;t know it. (&#147;Real programmers can write FORTRAN in any language.&#148;) The fact is that OO is largely language independent. I&#146;ve written OO systems in C (and once in assembly language). The ANSI C <B>FILE</B> is a perfectly good object, complete with constructor (<B>fopen</B>), destructor (<B>fclose</B>), and a set of methods (<B>fread</B>, <B>fwrite</B>, etc.). The internal implementation of the <B>FILE</B> class is completely hidden from the end user. OO languages such as Java make it easier to write OO systems simply because they support primitives that do a lot of work in the background that would otherwise have to be done by hand. You are simply not leveraging the power of Java if you are not using it to implement an OO design.</p>
<p>The only efficient way that I know to write an OO program is to go through a formal (or informal) process that includes the following activities: learning the problem domain, creating a problem definition in English by working collaboratively with an end user, identifying use cases and scenarios within those use cases and building an activity (or some form of workflow) diagram, building a dynamic model that shows the flow of messages through the system while some task is being performed, capturing information about the dynamic model in a static model, and then, at the end of all, coding. All of these activities can be done sequentially or concurrently, depending on your methodology of choice.</p>
<p>The design process is a lot of work (though it&#146;s fun). I spend roughly 50% of a project in design, roughly 30% in coding and debugging, and the rest in miscellaneous tasks. Nonetheless, when compared to working procedurally, I get the program written in about half the time I used to, the program has dramatically fewer bugs, and the program is very usable. This reduction of both development time and bugs is commonplace when you &#147;do it right.&#148;</p>
<p>Let&#146;s get back to our hapless manager, who equates productivity with lines of code produced per day. When you say that you need four to six months in design before, hapless managers will typically make two enormous mistakes: they will assume that the design process isn&#146;t &#147;work,&#148; and they will mentally add the time spent in design to the time required to do the last project.</p>
<p>My experience, however, is that every hour I spend in design saves me three to four hours of coding/debugging. The time spent in design is more than made up by the time saved in coding. The real mental estimate when you mix design into the equation is that, compared to the prior projects, well-done OO systems will be developed in roughly half the time as the prior projects, and it will have at least half the bugs, coming out of the gate.</p>
<p>But how do you get this notion across? Simply teaching the programmers OO is in itself not sufficient, because of the learning curve. The first OO project or two will go more slowly than they should because you don&#146;t know what you&#146;re doing yet. Design is as hard to learn as programming. If you leap from training into an OO pilot project, you won&#146;t prove your point &#151; that the projects take less time and are less buggy &#151; because the first project or two won&#146;t be either.</p>
<p>I recommend two approaches. (I&#146;ve done both at one point or another.) The less efficient way is to hire an expert designer to mentor a group through the process. The main difficulty with this approach is buy-in. It&#146;s hard to convince many programmers that the design process is worthwhile until they see how much easier it is to write the code.</p>
<p>The better approach, in my mind, is to hire a good architect to do the design for you. (Several people, including myself, do this on a consulting basis.) Then have the architect come in, explain UML and how to implement from a design to the team, and then have the team develop the app under the architect&#146;s supervision. This way, the first experience that the programmers have with OO is a good one: they see how easy it is to code when they have a design in front of them. Now they&#146;re motivated to learn how to do the design work itself, and it&#146;s at this point that you start the design training. I have worked in just this way (as the architect/mentor), so I know that it works.</p>
<p>The real issue, though, is that if you don&#146;t adopt an OO-design process, you&#146;re using Java on two cylinders. To get all eight cylinders, you need the design first. </p>
<p>Allen Holub<br>
Senior Editor</p></blockquote></body></html>
