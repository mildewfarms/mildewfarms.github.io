<HTML>   
     <HEAD>
<TITLE>February 2002 C++ Experts Forum/From Mechanism to Method</TITLE></HEAD>
<BODY BACKGROUND="" BGCOLOR="#FFFFFF" TEXT="#000000">
<H2><A HREF="../../20.02/tocfeb.htm"></A><FONT COLOR="#FF0000">   C++ Experts Forum</FONT></H2>

<HR>

<H2 ALIGN="center"><FONT COLOR="#800000">From Mechanism to Method: The Safe Stacking of Cats</FONT></H2>
<H3 ALIGN="center"><FONT COLOR="#800000">Kevlin Henney</FONT></H3>

<HR>
<BLOCKQUOTE>      
        <P>In spite of some obvious differences &#151; and the similarity that 
              neither can be considered a normal practice &#151; curling and throwing 
              have something in common: curling is a bizarre sport played on 
              ice; throwing in C++ is often played on thin ice. It is the thin 
              ice that has most often caused consternation, and the balanced art 
              of not falling through that has attracted much attention.</P>
              <P>By coincidence, curling is also something in which cats both 
              indulge and excel, putting the <I>pro</I> into 
              <I>procrastination</I>. But more on cats later.</P>
              <H3><FONT color=#000080>Taking Exception</FONT></H3>
              <P>Exceptions are disruptive but modular. The common appeal to 
              consider them as related to the <B>goto</B> is more than a little 
              misleading ("considering <B>goto</B>" considered harmful, if you 
              like). That they are both discontinuous is one of the few features 
              they share. It is an observation that although true is not 
              necessarily useful: <B>break</B>, <B>continue</B>, and 
              <B>return</B> also share this description of behavior. A quick 
              dissection exposes the differences:</P>
              <UL>
                <LI><I>Transferred information</I>: a <B>goto</B> can associate 
                only with a label whereas a <B>throw</B> communicates with 
                respect to both type and any information contained in the type 
                instance. In this sense, the <B>throw</B> acts more like a 
                <B>return</B>, communicating an exceptional rather than a normal 
                result. 
                <LI><I>Locality</I>: a <B>goto</B> has meaning only within a 
                function, labels being the only C++ entity with function scope. 
                By contrast, exception handling is primarily about transferring 
                control out of a function. It shares this with <B>return</B>, 
                but potentially has the whole of the call stack rather than just 
                the immediate caller within its reach. It also shares with 
                <B>break</B> and <B>continue</B> a relationship with an 
                enclosing control flow primitive, so exception handling can also 
                be used simply at the block level. 
                <LI><I>Destination coupling</I>: the target of a <B>goto</B> is 
                fixed, hardwired at compile time. There is no way to express 
                "the following has happened, so whoever can sort it out, please 
                sort it out." Exceptions are independent of lexical scope and do 
                not nominate their handlers explicitly. Instead, nomination is 
                dynamic and by requirement &#151; "the first one that can handle one 
                of these gets to sort it out." Exceptions can be handled or 
                ignored at different call levels without intervention from any 
                of the levels in between. In many ways, the <B>try catch</B> 
                mechanism resembles an advanced selection control structure &#151; an 
                <B>if else</B> with extreme attitude. 
                <LI><I>Block structure</I>: <I>Taligent's Guide to Designing 
                Programs</I> pulls no punches in stating that "a <B>goto</B> 
                completely invalidates the high-level structure of the code" <a href="#1">[1]</a>. 
                Far from being merely a provocative statement, this is a concise 
                summary of fact. C++ is essentially block structured: exceptions 
                respect and work within this structure, whereas <B>goto</B>s 
                largely ignore and disrespect it.</LI></UL>
              <P>The differences are thrown (sic) into sharp relief when you 
              attempt to refactor code. Say that you wish to factor a block out 
              as a function (the Extract Method refactoring <a href="#2">[2]</a>); 
              it is trivial to factor out the data flow: looking at the data 
              that's used and affected in the block tells you what arguments and 
              results you need to pass and how. With control flow, unless you 
              flow off the bottom of a block or <B>throw</B>, you cannot factor 
              the code simply. Traditional discontinuous control flow is 
              non-modular and requires additional restructuring to communicate 
              to the caller that a <B>break</B>, <B>return</B>, <B>continue</B>, 
              or <B>goto</B> (especially) must be effected. This is not the case 
              with <B>throw</B>: both the overall structure and the fine-grained 
              detail remain unchanged.</P>
              <H4><FONT color=#000080>State Corruption</FONT></H4>
              <P>This all sounds straightforward &#151; or straight backward if you 
              take the call stack's perspective &#151; because we know about 
              modularity, both structured programming and object-oriented 
              programming are built on that foundation. However, there is still 
              that one small matter of "disruption." When an exception is 
              thrown, the only thing you want disrupted is the control flow, not 
              the integrity of the program.</P>
              <P>Any block of code may be characterized with respect to the 
              program's stability in the event of an exception. We can guarantee 
              different levels of safety, of which three are commonly recognized 
              <a href="#3">[3]</A>, 
              plus the (literally) degenerate case:</P>
              <UL>
                <LI><I>No guarantee of exception safety</I>: ensures disruption, 
                corruption, and chaos. Code written without exceptions in mind 
                often falls into this category, leaking memory or leaving 
                dangling pointers in the event of a thrown exception &#151; 
                converting the exceptional into the unacceptable. In short, all 
                bets are off. 
                <LI><I>Basic guarantee of exception safety</I>: ensures that the 
                thrower will not leak or corrupt resources. Objects involved in 
                the execution will be in a stable and usable, albeit not 
                necessarily predictable, state. 
                <LI><I>Strong guarantee of exception safety</I>: ensures that a 
                program's state remains unchanged in the presence of exceptions. 
                In other words, commit-rollback semantics. 
                <LI><I>No-throw guarantee of exception safety</I>: ensures that 
                exceptions are never thrown, hence the question of how program 
                state is affected in the presence of an exception need never be 
                answered because it is purely hypothetical.</LI></UL>
              <P>The stroke of midnight separates the first, degenerate category 
              of exception unsafety from the last, Zen-like guarantee of benign 
              order through the simple absence of disruption. Code written to 
              achieve these guarantees may have the same structure, but will 
              differ in the not-so-small detail of whether or not exceptions 
              occur anywhere in their flow.</P>
              <P>These guarantees apply to any unit of code from a statement to 
              a function, but are most commonly applied to member functions 
              called on objects. A point that is not often made relates 
              exception safety to encapsulation: not so much that exception 
              safety can be improved by better encapsulation, but that exception 
              safety is one measure of encapsulation. Prominent OO propaganda 
              holds that encapsulation is concerned with making object data 
              private. Whilst this view is not strictly false, it misses some 
              important truths.</P>
              <P>Encapsulation is neither a language feature nor a practice; 
              rather it is a non-functional property of code, and something that 
              you can have more or less of. Encapsulation describes the degree 
              to which something is self-contained, the degree to which its 
              insides affect its outsides, the degree to which internal 
              representation affects external usage. Encapsulation is about 
              usability, about not imposing on the user. Language features and 
              idiomatic design practices can be used to improve encapsulation, 
              but of themselves they are not encapsulation. Thinking back to 
              exceptions, you can see that without even thinking about internal 
              representation, an object that offers the strong guarantee on a 
              member function is more encapsulated than one that offers no 
              guarantee.</P>
              <H4><FONT color=#000080>Incorruptible Style</FONT></H4>
              <P>It is one thing to have a guarantee, but quite another to 
              fulfill it. What is the style and mechanism of the code that 
              allows a thrown exception to propagate out of a block in a safe 
              manner? Including the degenerate case, there are essentially four 
              approaches to achieving exception safety:</P>
              <UL>
                <LI><I>Exception-unaware code</I>: code that is not written with 
                exceptions in mind is as easy to read as it is dangerous &#151; going 
                wrong with confidence. 
                <LI><I>Exception-aware code</I>: code may be scaffolded 
                explicitly with <B>try</B>, <B>catch</B>, and <B>throw</B> to 
                ensure that the appropriate stabilizing action is taken in the 
                event of a thrown exception. Alas, it is not always obvious that 
                exception-aware code is safe: such code is rarely clear and 
                concise. 
                <LI><I>Exception-neutral code</I>: code that works in the 
                presence of exceptions, but does not require any explicit 
                exception-handling apparatus to do so (i.e., no explicit <B>try 
                catch</B> code). Not only is exception-neutral code briefer and 
                clearer than exception-aware code, but it is also typically 
                shorter than exception unaware code. So, exception safety and 
                seamless exception propagation aside, such minimalism offers 
                another strong motivation for reworking code in this style. 
                <LI><I>Exception-free code</I>: code that generates no 
                exceptions offers the most transparent fulfillment of exception 
                safety.</LI></UL>
              <H3><FONT color=#000080>When Cats Turn Bad</FONT></H3>
              <P>There is a tradition &#151; from Schrödinger to Stroustrup &#151; of 
              employing cats for demonstration purposes, and I see no reason to 
              stand in the way of tradition. There appears to be sufficient 
              prior art in the stacking of cats <a href="#4">[4]</a> 
              that I will also adopt that practice. Of course, we are only 
              dealing with abstractions &#151; if you are concerned for the poor cat, 
              keep in mind that unless we set it in concrete no act of cruelty 
              actually occurs.</P>
              <P>Assuming that we have an appropriate <B>cat</B> class 
              definition, the following fragment demonstrates exception-unaware 
              code:</P><PRE>{
  cat *marshall = new cat;
  .... // play with marshall
  delete marshall;
}
</PRE>
              <P>If an exception occurs during play, there will be a memory 
              leak: you will forget about your scoped cat. The following 
              fragment demonstrates exception-aware code:</P><PRE>{
  cat *marshall = new cat;
  try
  {
    .... // play with marshall
  }
  catch(...)
  {
    delete marshall;
    throw;
  }
  delete marshall;
}
</PRE>
              <P>Safe? Yes. Unreadable? Certainly. What it lacks in elegance it 
              more than makes up for in verbosity. The code may be safe, but it 
              is not obviously so <a href="#5">[5]</A>. 
              The following fragment demonstrates exception-neutral code:</P><PRE>{
  std::auto_ptr&lt;cat&gt; marshall(new cat);
  .... // play with marshall
}
</PRE>
              <P>For all its faults (and they are many), this is one job that 
              <B>std::auto_ptr</B> does do well. If we know that default 
              <B>cat</B> constructors do not throw exceptions, and we recognize 
              that <B>marshall</B> is always bounded by scope, the following 
              fragment demonstrates exception-free code:</P><PRE>{
  cat marshall;
  .... // play with marshall
}
</PRE>
              <P>Clearly, for demo purposes, we are taking some liberties with 
              the common understanding of cats and their care, treating them as 
              disposable commodities. Taking further license with feline 
              appreciation and object design, let us also assume that they are 
              value-based rather than entity-based objects. This means that they 
              support copying through construction and assignment, are generally 
              not heap based, and are typically not deeply involved in class 
              hierarchies.</P>
              <P>Modern cloning technology is imperfect, so cat copy 
              constructors are not always guaranteed to work. On failure they 
              throw an exception, but they are well behaved enough to avoid 
              resource leakage and to not corrupt the program's state.</P>
              <H4><FONT color=#000080>Throwing Gauntlets</FONT></H4>
              <P>In 1994 Tom Cargill laid down a challenge &#151; or extended an 
              invitation to solution, depending on your point of view &#151; 
              concerning exception safety <a href="#6">[6]</A>. 
              The challenge was based on a fairly typical stack class template. 
              There were a number of elements to the challenge; the one I want 
              to focus on here is how to write the <B>pop</B> member 
              function.</P>
              <P>Here is some code that demonstrates the challenge:</P><PRE>template&lt;typename value_type&gt;
class stack
{
public:
  void push(const value_type &amp;new_top)
  {
    data.push_back(new_top);
  }
  value_type pop()
  {
    value_type old_top = data.back();
    data.pop_back();
    return old_top;
  }
  std::size_t size() const
  {
    return data.size();
  }
  ....
private:
  std::vector&lt;value_type&gt; data;
};
</PRE>
              <P>I have used <B>std::vector</B> for brevity (performing manual 
              memory management does nothing to make the problem clearer) and I 
              am skipping issues related to assignment &#151; I would recommend 
              looking at Herb Sutter's thorough coverage of the challenge to see 
              how this is addressed <a href="#3">[3]</a>.</P>
              <P>We can now recruit our favorite cat to demonstrate the issue. 
              First of all, pushing cats is not problematic:</P><PRE>stack&lt;cat&gt; stacked;
stacked.push(marshall);
std::cout &lt;&lt; "number of stacked cats == "
          &lt;&lt; stacked.size() &lt;&lt; std::endl;
</PRE>
              <P>The issue arises when we pop cats:</P><PRE>try
{
  cat fender = stacked.pop();
  .... // play with fender
}
catch(...)
{
  std::cout &lt;&lt; "number of stacked cats == "
            &lt;&lt; stacked.size() &lt;&lt; std::endl;
}
</PRE>
              <P>If the copy made in <B>pop</B>'s return statement fails, we 
              have lost the top cat: the cat has been removed from <B>data</B> 
              and size is one less than before. <B>pop</B>, therefore, cannot 
              satisfy the strong guarantee of exception safety, because that 
              requires everything to be left as it was before the exception was 
              thrown. The stack is still usable and its resulting state is 
              predictable, which means that we can promise marginally more than 
              the basic guarantee ... but we've still got a missing cat.</P>
              <P>Before setting about any solution, it is important to remember 
              that designs &#151; and therefore design problems &#151; do not exist in a 
              vacuum. Design is intimately bound up with purpose and context, 
              and without understanding these we risk either solving the wrong 
              problem or, as we so often do, solving the solution. Design is 
              about balancing goals &#151; as well as cats.</P>
              <H4><FONT color=#000080>Unasking the Question</FONT></H4>
              <P>Looking at the class interface, we might ask why two actions 
              are combined into one: Why does <B>pop</B> both return a queried 
              value and modify the target object? We know that such a return 
              causes an exception-safety problem, and we also know that it is 
              potentially wasteful. What if you do not plan to use the return 
              value? Even if you ignore it, the work that goes into copying and 
              returning the value still happens. You are potentially paying both 
              a cost and a penalty for something you didn't use.</P>
              <P>The Command-Query Separation pattern <a href="#7">[7]</a> 
              &#151; sometimes referred to as a <I>principle</I> rather than a 
              <I>pattern</I> <a href="#8">[8]</a> 
              &#151; resolves our concerns by making a separation with respect to 
              qualification:</P><PRE>template&lt;typename value_type&gt;
class stack
{
public:
  ....
  void pop()
  {
    data.pop_back();
  }
  value_type &amp;top()
  {
    return data.back();
  }
  const value_type &amp;top() const
  {
    return data.back();
  }
  ....
private:
  std::vector&lt;value_type&gt; data;
};
</PRE>
              <P>The separation of modifier from query operations ensures that 
              we cannot make a change and lose the result. This separated 
              interface also supports a slightly different usage model:</P><PRE>cat fender = stacked.top();
stacked.pop();
.... // play with fender
</PRE>
              <P>No copying exception can arise within the stack, so there is no 
              need to deal with it. This separation of concerns (and member 
              functions) can be seen in the design of the STL sequences and 
              sequence adaptors.</P>
              <H4><FONT color=#000080>Rephrasing the Question</FONT></H4>
              <P>It would seem that the problem is solved, except for one thing: 
              we never fully established the context of execution. It is 
              entirely possible that the basic guarantee of the original code 
              was satisfactory for our purposes, so there was no problem &#151; from 
              our perspective &#151; to be solved. Either we accept the loss of a cat 
              or, more commonly, the element type of the stack has 
              exception-free copying, which would be the case for built-in types 
              as well as a number of user-defined types. So under some 
              circumstances, the stack offers us the strong guarantee. If these 
              are your circumstances, the original code does not strictly 
              speaking need to be fixed. If they are not, there is indeed a 
              problem to be fixed, and Command-Query Separation offers one 
              solution.</P>
              <P>But there are others. Command-Query Separation is attractive 
              because it clarifies the role of interface functions. It could be 
              said to offer better encapsulation and cohesion. However, such a 
              statement is not universally true, and understanding why will 
              demonstrate why we must consider Command-Query Separation a 
              pattern (a design solution with consequences and a context) and 
              not a principle (an idea that expresses a universal truth).</P>
              <P>Consider a clarification in design context: the stack is to be 
              shared between multiple threads. Ideally we would like to 
              encapsulate synchronization detail within the stack, ensuring that 
              primitives such as mutexes are used safely and correctly. Focusing 
              just on the <B>push</B> member, an exception-unaware 
              implementation would be as follows:</P><PRE>template&lt;typename value_type&gt;
class stack
{
public:
  ....
  void push(const value_type &amp;new_top)
  {
    guard.lock();
    data.push_back(new_top);
    guard.unlock();
  }
  ....
private:
  mutable mutex monitor;
  std::vector&lt;value_type&gt; data;
};
</PRE>
              <P>The exception-neutral approach is both shorter and safer:</P><PRE>template&lt;typename value_type&gt;
class stack
{
public:
  ....
  void push(const value_type &amp;new_top)
  {
    locker&lt;mutex&gt; guard(monitor);
    data.push_back(new_top);
  }
  ....
private:
  mutable mutex monitor;
  std::vector&lt;value_type&gt; data;
};
</PRE>
              <P>Where <B>locker</B> is a helper class template responsible for 
              abstracting control flow <a href="#9">[9]</a>:</P><PRE>template&lt;typename locked_type&gt;
class locker
{
public:
  explicit locker(locked_type &amp;lockee)
    : lockee(lockee)
  {
    lockee.lock();
  }
  ~locker()
  {
    lockee.unlock();
  }
private:
  locker(const locker &amp;); // no copying
  locked_type &amp;lockee;
};</PRE>
              <P>Making each public member function of <B>stack</B> self-locking 
              would appear to preserve encapsulation. However, this works only 
              for usage scenarios that are based on single function calls. For 
              the Command-Query Separation solution, this would introduce a 
              couple of subtle bugs:</P><PRE>cat fender = stacked.top();
stacked.pop();
.... // play with fender
</PRE>
              <P>First of all, <B>top</B> returns a reference. Consider the 
              following simple action in another concurrent thread:</P><PRE>stacked.pop();
</PRE>
              <P>Assuming that all of the member functions we are talking about 
              are self-locking, what is the problem? Imagine that the second 
              thread executes <B>pop</B> just after the first thread completes 
              the call to <B>top</B>: the reference result from <B>top</B> is 
              now dangling, referring to a non-existent element. Undefined 
              behavior. Oops. Poor <B>fender</B> gets a very bad start in 
              life.</P>
              <P>Returning references to value objects from thread-shared 
              objects is a bad idea, so let's fix <B>stack</B>:</P><PRE>template&lt;typename value_type&gt;
class stack
{
public:
  ....
  value_type top() const
  {
    locker&lt;mutex&gt; guard(monitor);
    return data.back();
  }
  ....
private:
  mutable mutex monitor;
  std::vector&lt;value_type&gt; data;
};
</PRE>
              <P>This solves the problem of undefined behavior, but leads us 
              straight into the jaws of the second problem, which is that of 
              "surprising" behavior. Idiomatically, we treat the following as a 
              single unit:</P><PRE>cat fender = stacked.top();
stacked.pop();
.... // play with fender
</PRE>
              <P>However, this usage is not cohesive in its execution. It can be 
              interrupted by another thread:</P><PRE>cat peavey;
stacked.push(peavey);
</PRE>
              <P>so that the <B>push</B> in the second thread occurs between the 
              initialization of <B>fender</B> and the <B>pop</B> in the first 
              thread. This means that the wrong element is popped from the 
              stack. Oops, again.</P>
              <P>We could expose the <B>lock</B> and <B>unlock</B> features in 
              <B>stack</B> and let the user sort it all out:</P><PRE>template&lt;typename value_type&gt;
class stack
{
public:
  void lock()
  {
    monitor.lock();
  }
  void unlock()
  {
    monitor.unlock();
  }
  ....
private:
  mutex monitor;
  std::vector&lt;value_type&gt; data;
};
</PRE>
              <P>Giving rise to the following somewhat clunky usage:</P><PRE>cat fender;
{
  locker&lt; stack&lt;cat&gt; &gt; guard(stacked);
  fender = stacked.top();
  stacked.pop();
}
.... // play with fender
</PRE>
              <P>Let's compare this with the original usage:</P><PRE>cat fender = stacked.pop();
.... // play with fender
</PRE>
              <P>There's now more to write and more to remember &#151; and therefore 
              more to forget. In addition to being more tedious and error prone, 
              it is easy to make the code pessimistic by forgetting to enclose 
              the <B>locker</B> in the narrowest scope possible, leaving waiting 
              threads locked out of <B>stacked</B> for far longer than 
              necessary.</P>
              <P>Remember that the original design's only safety shortcoming was 
              that it offered only the basic &#151; rather than the strong &#151; 
              guarantee of exception safety. It would take a leap of orthodoxy 
              to say, hand on heart, that Command-Query Separation has produced 
              a more cohesive and encapsulated solution &#151; the opposite is true 
              in this context.</P>
              <P>The Combined Method pattern <a href="#7">[7]</a> 
              is one that sometimes finds itself in tension with Command-Query 
              Separation, combining separate actions into a single, 
              transactional whole for the benefit of simplicity and correctness 
              in, principally, multithreaded environments. The original 
              <B>pop</B> was an example of this tactical pattern, but suffered 
              from weakened exception safety. An alternative realization that 
              achieves strong exception safety in an exception-neutral style is 
              to overload the pure <B>pop</B> function with a Combined Method 
              that takes a result argument:</P><PRE>template&lt;typename value_type&gt;
class stack
{
public:
  ....
  void pop()
  {
    locker&lt;mutex&gt; guard(monitor);
    data.pop_back();
  }
  void pop(value_type &amp;old_top)
  {
    locker&lt;mutex&gt; guard(monitor);
    old_top = data.back();
    data.pop_back();
  }
  ....
private:
  mutable mutex monitor;
  std::vector&lt;value_type&gt; data;
};
</PRE>
              <P>This design tightens the screws a little on the element type 
              requirements, additionally requiring assignability as well as copy 
              constructibility. In practice this often means that we also demand 
              default constructibility of the target because the overloaded 
              <B>pop</B> cannot be used in an assignment:</P><PRE>cat fender;
stacked.pop(fender);
.... // play with fender
</PRE>
              <P>Another consequence of the assignment-based approach is that 
              the result variable must be an exact type match for the element 
              type (i.e., it cannot rely on implicit conversions that would have 
              worked if <B>pop</B>'s result had been returned by value).</P>
              <H4><FONT color=#000080>A Transactional Approach</FONT></H4>
              <P>Staying with Combined Method, but for brevity leaving aside the 
              code for thread synchronization, it turns out that it is possible 
              to write an exception-neutral version of <B>pop</B> that preserves 
              the original value-returning interface and satisfies the strong 
              guarantee of exception safety in slightly different circumstances 
              to the original:</P><PRE>template&lt;typename value_type&gt;
class stack
{
public:
  ....
  value_type pop()
  {
    popper karl(data);
    return data.back();
  }
  ....
private:
  class popper
  {
  public:
    popper(std::vector&lt;value_type&gt; &amp;data)
      : data(data)
    {
    }
    ~popper()
    {
      if(!std::uncaught_exception())
        data.pop_back();
    }
  private:
    popper(const popper &amp;);
    std::vector&lt;value_type&gt; &amp;data;
  };
  std::vector&lt;value_type&gt; data;
};
</PRE>
              <P>Here a small helper object, <B>karl</B>, is created to commit a 
              <B>pop</B> action if the copying of the return value is 
              successful. The <B>popper</B> object is passed the representation 
              of the surrounding stack, and on destruction, it will cause a 
              <B>pop_back</B> to be executed. If the copy is unsuccessful, the 
              <B>popper</B> destructor will not commit the intended change, 
              skipping the <B>pop_back</B>.</P>
              <P>This approach has the benefit of preserving the signature 
              interface and typically reducing the number of temporaries 
              involved in copying. However, there is an important precondition 
              that must be publicized and satisfied for <B>popper</B> to work as 
              expected: <B>pop</B> should not be called from the destructor of 
              another object. Why? What if the destructor is being called 
              because the stack is being unwound by an exception? The call to 
              <B>std::uncaught_exception</B> in <B>popper</B>'s destructor will 
              return <B>true</B> even if the copy is successful.</P>
              <P>How you respond to this scenario is a matter of context-driven 
              requirement. Either you state that the behavior of a <B>stack</B> 
              is undefined in these circumstances or you define behavior for it. 
              One definition of behavior is shown above &#151; in the presence of 
              existing exceptions, don't pop &#151; but could be considered 
              unsatisfactory because of its pessimism. An alternative, more 
              optimistic approach is to say that our <B>pop</B> offers a strong 
              guarantee of exception safety if there is no unhandled exception 
              present when it is executed, but only the basic guarantee 
              otherwise:</P><PRE>template&lt;typename value_type&gt;
class stack
{
  ....
  class popper
  {
  public:
    popper(std::vector&lt;value_type&gt; &amp;data)
      : data(data), unwinding(std::uncaught_exception())
    {
    }
    ~popper()
    {
      if(unwinding || !std::uncaught_exception())
        data.pop_back();
    }
  private:
    popper(const popper &amp;);
    std::vector&lt;value_type&gt; &amp;data;
    const bool unwinding;
  };
  ....
};
</PRE>
              <P><B>std::uncaught_exception</B> is a function that is generally 
              not as useful as it first appears. It often leads to false 
              confidence in code <a href="#10">[10]</a>, 
              but with an understanding of its limitations, there are a few 
              situations in which we can press it into useful service.</P>
              <H4><FONT color=#000080>A Lazy Approach</FONT></H4>
              <P>It is possible to take the transactional idea a step further 
              using a technique that I first saw Angelika Langer present at 
              <I>C++ World</I> in 1999:</P><PRE>template&lt;typename value_type&gt;
class stack
{
public:
  ....
  value_type pop()
  {
    try
    {
      --length;
      return data[length];
    }
    catch(...)
    {
      ++length;
      throw;
    }
  }
  ....
private:
  std::size_t length;
  std::vector&lt;value_type&gt; data;
};
</PRE>
              <P>Here the size of the stack is tracked in a separate variable 
              that is incremented and decremented accordingly. It uses an 
              exception-aware style to implement commit-rollback semantics, 
              bumping the length count back up again if the copy from the last 
              element fails with an exception.</P>
              <P>The obvious benefit of this approach is that it will work 
              independently of whether or not the stack is already unwinding 
              because of an exception. However, the disadvantage with this 
              approach is not so much with the extra piece of state that has 
              been introduced but that popped elements are never actually 
              popped. They continue to exist in the <B>data</B> member long 
              after they have been popped: at least up until another 
              modification operation requires rationalization of <B>data</B> 
              with <B>length</B>, such as a <B>push</B>. A couple of minor 
              refinements address this issue by introducing a deferred but 
              amortized commit operation:</P><PRE>template&lt;typename value_type&gt;
class stack
{
public:
  stack()
    : uncommitted(false)
  {
  }
  void push(const value_type &amp;new_top)
  {
    commit();
    data.push_back(new_top);
  }
  value_type pop()
  {
    commit();
    try
    {
      uncommitted = true;
      return data.back();
    }
    catch(...)
    {
      uncommitted = false;
      throw;
    }
  }
  std::size_t size() const
  {
    commit();
    return data.size();
  }
  ....
private:
  void commit() const
  {
    if(uncommitted)
    {
      data.pop_back();
      uncommitted = false;
    }
  }
  mutable bool uncommitted;
  mutable std::vector&lt;value_type&gt; data;
};
</PRE>
              <P>Internally the committed state will be at most one element 
              different from the uncommitted state, but externally any attempt 
              to determine the state by calling an operation will ensure that 
              the books are kept balanced. This constraint requires that all 
              public functions call the <B>commit</B> function as their first 
              act, which requires that the object's state to be qualified as 
              <B>mutable</B> to permit updates in query functions. Thus, this 
              design affects all member functions and imposes a little more on 
              the class developer. The class user is, however, unaffected.</P>
              <H3><FONT color=#000080>Conclusion</FONT></H3>
              <P>It is time to declare a moratorium on these exceptional 
              experiments on abstracted cats. They have served to demonstrate 
              that no design can be perfect, and that encapsulation is related 
              to usability; it is not just a matter of data hiding. Although we 
              may strive for absolute recommendations, there are times when only 
              relative ones can be made with confidence (and caveats). Design is 
              about compromise and about context, and therefore it is about 
              understanding consequences. Weigh up the benefits and liabilities 
              for a particular usage and then make your decision &#151; what is 
              workable in one context may be unworkable in another, and so what 
              is "good" in one situation may be "bad" in another.</P>
              <P>On the compromise of design in other fields I will leave you 
              with this quote from David Pye <a href="#11">[11]</A>:</P>
              <BLOCKQUOTE>
                <P>It follows that all designs for use are arbitrary. The 
                designer or his client has to choose in what degree and where 
                there shall be failure. Thus the shape of all design things is 
                the product of arbitrary choice. If you vary the terms of your 
                compromise&#151;say, more speed, more heat, less safety, more 
                discomfort, lower first cost&#151;then you vary the shape of the 
                thing designed. It is quite impossible for any design to be "the 
                logical outcome of the requirements" simply because, the 
                requirements being in conflict, their logical outcome is an 
                impossibility.</P></BLOCKQUOTE>
              <H3><FONT color=#000080>References</FONT></H3>
              <P><A name=1></A>[1] <I>Taligent's Guide to Designing Programs: 
              Well-Mannered Object-Oriented Design in C++</I>, (Addison-Wesley, 
              1994), &lt;http://pcroot.cern.ch/TaligentDocs/TaligentOnline/DocumentRoot/1.0/Docs/books/WM/WM_1.html&gt;.</P>
              <P><A name=2></A>[2] Martin Fowler. <I>Refactoring: Improving the 
              Design of Existing Code</I> (Addison-Wesley, 1999), &lt;www.refactoring.com&gt;.</P>
              <P><A name=3></A>[3] Herb Sutter. <I>Exceptional C++</I> 
              (Addison-Wesley, 2000).</P>
              <P><A name=4></A>[4] Bjarne Stroustrup. "Sixteen Ways to Stack a 
              Cat," <I>C++ Report</I>, October 1990, &lt;www.research.att.com/~bs&gt;.</P>
              <P><A name=5></A>[5] To quote C. A. R. Hoare: "There are two ways 
              of constructing a software design. One way is to make it so simple 
              that there are obviously no deficiencies. And the other way is to 
              make it so complicated that there are no obvious 
deficiencies."</P>
              <P><A name=6></A>[6] Tom Cargill. "Exception Handling: A False 
              Sense of Security," <I>C++ Report</I>, November-December 1994.</P>
              <P><A name=7></A>[7] Kevlin Henney. "A Tale of Two Patterns," 
              <I>Java Report</I>, December 2000, &lt;www.curbralan.com&gt;.</P>
              <P><A name=8></A>[8] Bertrand Meyer. <I>Object-Oriented Software 
              Construction</I>, 2nd Edition (Prentice Hall, 1997).</P>
              <P><A name=9></A>[9] Kevlin Henney. "C++ Patterns: Executing 
              Around Sequences," <I>EuroPLoP 2000</I>, July 2000, &lt;www.curbralan.com&gt;.</P>
              <P><A name=10></A>[10] Herb Sutter. <I>More Exceptional C++</I> 
              (Addison-Wesley, 2002).</P>
              <P><A name=11></A>[11]</B> Henry Petroski. <I>To Engineer is 
              Human: The Role of Failure in Successful Design</I> (Vintage, 
              1992).</P>

              <P><i><B>Kevlin Henney</B> is an independent consultant and trainer 
              specializing in C++, Java, OO design, patterns, and software 
              architecture. He can be reached at <b>kevlin@curbralan.com</b>.</i></P></BLOCKQUOTE></BODY></HTML>
