<HTML>   
     <HEAD>
<TITLE>July 2002/Uncaught Exceptions</TITLE></HEAD>
<BODY BACKGROUND="" BGCOLOR="#FFFFFF" TEXT="#000000">
<H2><A HREF="../tocjul.htm"></A><FONT COLOR="#FF0000">   C/C++ Contributing Editors</FONT></H2>

<HR>

<H2 ALIGN="center"><FONT COLOR="#800000">Uncaught Exceptions: The Spiral Dance</FONT></H2>
<H3 ALIGN="center"><FONT COLOR="#800000">Bobby Schmidt</FONT></H3>

<BLOCKQUOTE>
<p>A New Hope: C++Ox is coming, and the Empire seems to be listening.</p>
</BLOCKQUOTE>

<HR>
<BLOCKQUOTE>
<p>Copyright &copy; 2002 Robert H. Schmidt</p>
<p>In my January column, I lamented the premature death of my Microsoft C# project and portended the resulting end of my Microsoft writing career. I also hinted that I might bail on my <I>CUJ</I> career as well.</p>
<p>Immediately after finishing that column I spent four weeks alone, driving through deserts and mountains and along the sea. As I indicated in that column, I had hoped the trip would bring much needed clarity. Well I got that clarity, and more: several transcendent experiences, one of which bordered on X-Files reality <a href="#1">[1]</a>.</p>
<p>I returned to find positive change within Microsoft, change that has reinvigorated my commitment to the company and resurrected my writing career all around. Although I could consume an entire column with this topic, I will but summarize here:</p>

<UL><LI>   While looking for a new job, I interviewed for the Visual C++ group&#146;s new community liaison position. While I didn&#146;t get the job, I did learn heaps about the group, their ambitions, and their challenges. In particular, I learned that Microsoft finally has religion around Standard C++.</LI>
<LI>   Shortly afterward Herb got the job I didn&#146;t get. I can think of nobody better for that job, especially given the emphasis on Standard C++.</LI>
<LI>   Around this same time, MSDN hired a new head manager, Sara Williams, whom I have known since her first days at Microsoft <a href="#2">[2]</a>. I again can think of nobody better for the job.</LI>
<LI>   Impressed by the Visual C++ team&#146;s plans and inspired by Sara&#146;s reinvigoration of MSDN&#146;s writing culture, I decided to stay in MSDN and give writing one more shot.</LI></UL>

<p>To that end I am resurrecting my MSDN column &#147;Deep C++,&#148; which has lain dormant since late 2000. By the time you read this, I should have been back on the air for at least a couple of months <a href="#3">[3]</a>. I&#146;ll split my topics between Microsoft-specific extensions to C++ &#151; especially those related to managed code in the .NET Framework &#151; and the new Standard-conformance features.</p>

<H3><FONT COLOR="#000080">Concerning the Latter...</FONT></H3>

<p>Many &#147;Uncaught Exceptions&#148; items are really Visual C++ problems masquerading as Standard C++ problems. Such items fall into a clich&eacute;d pattern:</p>

<H4><FONT COLOR="#000080">Q</FONT></H4>
<p> When I try the following code from (take your pick: my column, a book, a class, Usenet, Dr. Meyers&#146; latest harangue), I get the following error from Visual C++...</p>

<H4><FONT COLOR="#000080">A</FONT></H4>
<p> Your sample should work according to both my interpretation of the C++ Standard and the results of my non-Microsoft translators in their Standard-conformance mode. The behavior you see is either &#147;standard&#148; Visual C++ and intentional, or a non-conformance bug. Here is what I think is happening plus some possible solutions...</p>
<p>As have many of you, I long ago dismissed Visual C++ as a serious Standard C++ compiler. I reckoned that Visual C++ was a mostly proprietary dialect of real C++, and that deep down Microsoft didn&#146;t really care about conformance, regardless of public posture.</p>
<p>All of that is about to change.</p>
<p>In my recent dealings with the Visual C++ team, I&#146;ve come to know their new and genuine commitments:</p>

<UL><LI>   100-percent conformance to the current Standard (C++98).</LI>
<LI>   Active leadership in developing the next Standard (C++0X).</LI></UL>

<p>I invite doubters to read Herb&#146;s first significant interview as C++ community liaison <a href="#4">[4]</a>. I also invite you to check out the first installments of my resurrected &#147;Deep C++&#148; column, where I plan to discuss the upcoming conformance changes in more detail. Once these changes appear in a publicly available compiler, I&#146;ll start writing about them in <I>CUJ</I> as well.</p>
<p>Oh yeah, one more thing: I&#146;m not leaving <I>CUJ</I>. Well, not completely &#151; I&#146;ve cut back to every other month, which I find a happier and more sustainable pace.</p>

<H3><FONT COLOR="#000080">Competitive EDGe</FONT></H3>

<H4><FONT COLOR="#000080">Q</FONT></H4>
<p>Bobby,</p>
<p>I was going through a <I>CUJ</I> article by you from October 2001. In the section called &#147;Circular Breathing,&#148; you mention running code through the Edison Design Group C++ front end to validate it. I checked out their website, and it makes no mention of any end-user products. Is there a way you know of to get just the front end for code analysis?</p>
<p>I&#146;m on a project to apply some sort of objective quality metric to two-three million lines (depending on how you count) of Windows code. Evidently the contractors walked out in mid-project. Is EDG something that would be useful? Or would something else be more appropriate?</p>
<p>Thanks &#151; Ed Fisher</p>

<H4><FONT COLOR="#000080">A</FONT></H4>
<p> I&#146;ve long written about EDG&#146;s C++ front-end translator without specifying what that translator is and how to get it. Thanks for prodding me to address my chronic vagueness.</p>
<p>EDG doesn&#146;t sell an end-user commercial C++ product as such. They instead license their C++ front end to compiler vendors and other resellers. You can find a list of such resellers on their website <a href="#5">[5]</a>.</p>
<p>The front end I use is what EDG calls a &#147;demo&#148; version. Its capabilities, while constrained, are enough to test and validate Standard conformance. The particular demo version I use runs only in Windows, generates intermediate C code, and requires that intermediate code to be built by Visual C++.</p>
<p>The demo doesn&#146;t ship with a complete run-time library. When I&#146;ve tried to use the Dinkumware library that ships with Visual C++, I&#146;ve met mixed success &#151; hardly surprising, given that the library is tuned to Microsoft&#146;s implementation of C++, not EDG&#146;s. Fortunately Dinkumware also sells a library tuned to the EDG implementation. P.J. Plauger has graciously provided me with what he calls a &#147;writer&#146;s copy&#148; of that library <a href="#6">[6]</a>.</p>
<p>I use the EDG translator to validate two things:</p>
<UL><LI>   My understanding of the C and C++ Standards.</LI>
<LI>   The standard conformance (or lack thereof) in code problems submitted by readers.</LI></UL>

<p>If you are looking to see how conformant your mega lines of code are, a compiler based on the EDG front end will help. But if you define your quality metric as something other than conformance, I don&#146;t know that the front end will tell you much.</p>

<H3><FONT COLOR="#000080">It&#146;s a long long long long World</FONT></H3>

<H4><FONT COLOR="#000080">Q</FONT></H4>

<p> Hello Bobby,</p>
<p>I understand the C language was recently re-standardized. When is the next time C++ will be re-standardized?</p>
<p>In my opinion, the naming convention for C++ intrinsic data types is somewhat limiting, and as platforms get bigger (requiring larger data types) the C++ intrinsic names get more obscure.</p>
<p>For example:</p>

<UL><LI>   <B>long</B> is widely accepted as 32 bits.</LI>
<LI>   <B>__int64</B> is 64 bits for Microsoft.</LI>
<LI>   <B>long long</B> is also accepted as 64 bits by some compilers.</LI>
<LI>   <B>long long long</B> is not accepted by any compilers I use. It sure looks obscure to me.</LI></UL>

<p>I&#146;m currently working on a game for Playstation 2, where a common intrinsic data type is <B>__int128</B>.</p>
<p>The point I&#146;m trying to make is that (in my opinion) C++ is in desperate need of a better naming convention for intrinsic data types. Also, the naming convention needs to support new data types for new (bigger) CPUs.</p>
<p>For portability, the team I&#146;m working with has <B>typedef</B>ed all the intrinsic data types with the following convention:</p>

<UL><LI>   <B>s8</B> = signed 8 bits</LI>
<LI>   <B>u8</B> = unsigned 8 bits</LI></UL>

<p>and so on through <B>s256</B> and <B>u256</B>.</p>
<p>Sincerely &#151; Tony Clifton</p>

<H4><FONT COLOR="#000080">A</FONT></H4>
<p> C++ is being &#147;re-standardized&#148; now, in the sense that the committee is entertaining changes and extensions. I believe the Standard is frozen for five years after its 1998 adoption, which means next year is the earliest that any changes can actually occur. Since we optimistically assume the next version will see life before 2010, we call this version C++0X. (This is the same shorthand we used for C99, which we called C9X before its adoption.)</p>
<p>I agree that the current naming scheme for C and C++ fundamental types does not scale well. That we are now resorting to names such as <B>long long</B> and <B>long double</B> betrays the stress we&#146;re placing on that scheme.</p>
<p>If there is to be a solution, I believe it will lie in the library rather than the language. The C99 Standard library offers a model in <B>&lt;stdint.h&gt;</B> with <B>typedef</B>s of the form:</p>
<UL><LI>   <B>[u]intN_t</B></LI>
<LI>   <B>[u]int_fastN_t</B></LI>
<LI>   <B>[u]int_leastN_t</B></LI></UL>

<p>where <B>N</B> is the number of bits. The header also defines collateral symbolic constants:</p>

<UL><LI>   <B>[U]INTN_MAX</B></LI>
<LI>   <B>[U]INT_FASTN_MAX</B></LI>
<LI>   <B>[U]INT_LEASTN_MAX</B></LI></UL>

<p>along with their signed <B>_MIN</B> partners.</p>
<p>I expect these types, or close variants, to appear in the <B>std</B> namespace for C++0X. I&#146;m not alone in this expectation: in his online <I>CUJ</I> column describing the &#147;new&#148; C++, Herb Sutter discusses the likely inclusion of <B>&lt;stdint.h&gt;</B> <a href="#7">[7]</a>.</p>
<p>Even if we&#146;re right, the solution will be incomplete, as it doesn&#146;t cover character and floating-point types. Whether this limitation even matters is something the committee members will have to sort out. People I&#146;ve seen devising similar schemes apparently care only about <B>int</B> types, so perhaps <B>&lt;stdint.h&gt;</B> is good enough.</p>

<H3><FONT COLOR="#000080">Choosing Friends Wisely</FONT></H3>
<H4><FONT COLOR="#000080">Q</FONT></H4>
<p> Hello,</p>
<p>I was recently asked to port some code from HP/UX to AIX. When compiling the enclosed sample on AIX with the IBM VisualAge 5.0 compiler, I get a puzzling error:</p>

<pre>
The "private" member "X::f()" cannot be accessed.
</pre>

<p>I searched for this error message on the support groups and found an answer from IBM technical support. They claim the behavior is correct according to the C++ Standard. They quoted Subclause 11.4/7:</p>
<UL><p>&#147;A name nominated by a friend declaration shall be accessible in the scope of the class containing the friend declaration&#148;</p>
</UL>
<p>claiming that was consistent with the definition of access control in Subclause 11/1:</p>

<UL><p>&#147;A member of a class can be private; that is, its name can be used only by members and friends of the class in which it is declared&#148;</p>
</UL>

<p>Earlier versions of the IBM compiler, HP/UX&#146;s native compiler, Visual C++, and gcc all have no problem with this code fragment. This made me curious as to the other compilers&#146; interpretation of the Standard. Is IBM being unfairly strict? Was this an intended interpretation of the Standard? (I&#146;m restricted to the fragments IBM quoted, as I don&#146;t have a copy.)</p>
<p>It seems odd to me that I should need to promote a private method into a class&#146;s public interface for the sole purpose of having its symbol made visible to a friend nomination. The <B>friend</B> statement in my class <B>Y</B> is not attempting to access the symbol <B>f</B>, but is instead attempting to nominate <B>f</B> as a friend.</p>
<p>I guess I&#146;m just looking for your take on this.</p>
<p>Thanks &#151; Ron Hume</p>

<H4><FONT COLOR="#000080">A</FONT></H4>
<p> My version of your code sample is:</p>

<pre>
class X
    {
private:
    void f();
    };

class Y
    {
    friend void X::f(); // error here
    };
</pre>

<p>Of the three compilers I have installed:</p>

<UL><LI>   Metrowerks CodeWarrior Pro v7 compiles the sample.</LI>
<LI>   Microsoft Visual C++ v7 compiles the sample.</LI>
<LI>   EDG Front End v3 (beta) does not compile the sample, but instead makes the same complaint your IBM compiler does.</LI></UL>

<p>My normal temptation is to believe EDG and press on. Their interpretation and IBM&#146;s support a simple rule: the names of a class&#146;s private members are available only to other members and friends of that class, regardless of what you do with those names.</p>
<p>But that rule does seem harsh in light of what you want to do with the name: grant the name&#146;s correlative entity friendship. That doesn&#146;t harm the friend, or otherwise give you access to the friend. If anything, it potentially harms you if the friend misbehaves.</p>
<p>Within the C++ Standard Committee, the Council of Language Elders (a.k.a. the Core Language Working Group) pondered this very problem <a href="#8">[8]</a>. Their conclusion: the verbiage in 11.4/7 is defective and does not reflect the committee&#146;s intent. They voted to remove the sentence IBM cites (&#147;A name nominated...&#148;).</p>
<p>Or so they thought.</p>
<p>Upon further deliberation, the Elders uncovered a dark truth: removing this sentence would cause a cascade reaction through other passages requiring clarification or deletion, thereby risking destruction of the entire Death Star, er, Standard.</p>
<p>Consider the variation:</p>

<pre>
class X
    {
private:
    struct S; // new
    S f();    // changed
    };

class Y
    {
    friend X::S X::f(); // Well?
    };
</pre>

<p>which accesses both the private function <B>f</B> and the private type <B>S</B>. Should this work? Is <B>S</B> implicitly given friendship?</p>
<p>Or worse, consider:</p>

<pre>
class X
    {
private:
    struct S;
    friend void f(); // changed
    };

class Y
    {
    friend void f()
        {
        X::S *p; // er, um...
        }
    };
</pre>

<p>The <B>friend</B> declaration in <B>X</B> gives global function <B>f</B> access to <B>X</B>&#146;s private pieces, including <B>S</B>. The <B>friend</B> declaration in <B>Y</B> is for the same global <B>f</B>. That second declaration also defines <B>f</B>.</p>
<p>Should the private pieces of <B>X</B> be accessible in the body of <B>f</B> when that body appears in <B>Y</B>? Would your answer change if <B>Y</B> were also a friend of <B>X</B>?</p>
<p>Unable to contain the defect report&#146;s terrible power, the Elders finally cast it into the fires of Mordor. From their rationale:</p>

<UL><p>&#147;Ultimately it was decided that the original perceived defect was not sufficiently serious as to warrant the degree of complexity required to resolve it satisfactorily and the issue was consequently declared not to be a defect.&#148;</p></UL>

<p>(&#147;One Standard to rule them all...&#148;)</p>
<p>So there you have the official ruling: Not a Defect by Reason of Inexplicability. The Elders apparently wanted to make private <B>friend</B>s work, but couldn&#146;t figure out how to articulate that in the Standard without breaking something else. (Hmm, sounds just like a software project.)</p>
<p>One side effect is that all of our compilers are right:</p>

<UL><LI>   IBM and EDG implement the committee&#146;s reality.</LI>
<LI>   The other compilers implement the committee&#146;s ideal.</LI></UL>

<p>Inaccessible and overly private <B>friend</B>s are a nuisance, in real life and elsewhere. If you care about portability, I suggest you avoid the whole ruckus: don&#146;t grant friendship to private entities, regardless of which &#147;right&#148; behavior your compiler supports. If you simply can&#146;t help yourself, then grant friendship to the class containing the private entity:</p>

<pre>
class X
    {
private:
    void f();
    };

class Y
    {
    friend class X;
    };
</pre>

<p>Now the private <B>f</B> can mess around with the internals of <B>Y</B>, as you originally intended.</p>

<H3><FONT COLOR="#000080">Accepting Excepting</FONT></H3>
<H4><FONT COLOR="#000080">Q</FONT></H4>
<p> Hello,</p>
<p>How do I declare pointers to functions throwing exceptions?</p>
<p>Thank you and good day. &#151; &#147;sathya tn&#148;</p>

<H4><FONT COLOR="#000080">A</FONT></H4>
<p> Based on other parts of your email, I&#146;m assuming what you&#146;re really after is how to preserve an exception specification as part of a function pointer.</p>
<p>In the simple case of:</p>

<pre>
void f() throw(int);
</pre>

<p>you can declare a pointer to <B>f</B> via:</p>

<pre>
void (*pe)() throw(int);
pe = f; // OK
</pre>

<p>Mysteriously, the language rules won&#146;t let you tidy this up with a <B>typedef</B>:</p>

<pre>
        void (*pe)() throw(int); // OK, but...
typedef void (*PE)() throw(int); // error
typedef void (*P) ()           ; // OK
</pre>

<p>And no, I don&#146;t know why this is. Maybe the <B>typedef</B> grammar can&#146;t be precisely extended this way. (See fires of Mordor, above.)</p>
<p>In this context, exception specifications are like <B>const</B> qualifiers in reverse. With <B>const</B> qualification, you can convert from less restrictive to more, but not visa versa:</p>

<pre>
void *p;
void const *pc;

pc = p; // OK,    gains restriction
p = pc; // error, loses restriction
</pre>

<p>With exception specifications, the reverse is true:</p>

<pre>
void (*p)();
void (*pe)() throw(int);

pe = p; // error, gains restriction
p = pe; // OK,    loses restriction
</pre>

<p>This conversion rule implies that you could store the address of <B>f</B> in a pointer lacking an exception specification:</p>

<pre>
void f() throw(int);

void (*p)();
void (*pe)() throw(int);

p = f;  // OK, loses restriction
pe = f; // OK, same  restriction
</pre>

<p>If <B>f</B> were declared without a specification, the results would change:</p>

<pre>
void f(); // no specification

...

p = f;  // OK,    same  restriction
pe = f; // error, gains restriction
</pre>

<p>I suspect that many of you have never before seen exception specifications on pointer declarations or were even aware such things are possible. They could also be new to your compiler vendor. Of my compilers:</p>

<UL><LI>   Metrowerks&#146; and EDG&#146;s understand the specifications and appear to honor their rules.</LI>
<LI>   Microsoft&#146;s Visual C++ v7 accepts the specifications syntactically, but mostly ignores them semantically. According to the compiler&#146;s warning message, exception specifications are ignored except to imply a function is not <B>__declspec(nothrow)</B>. This is consistent with the compiler ignoring specifications at run time <a href="#9">[9]</a>.</UL>

<H3><FONT COLOR="#000080">Notes</FONT></H3>

<p><a name="1"></a>[1]  No, I won&#146;t tell you what it was, so don&#146;t ask! All I&#146;ll say is that it came in the desert outside Blythe, CA, near where I set up for the spectacular Leonid meteor storm.</p>
<p><a name="2"></a>[2]  I was Sara&#146;s new-hire mentor when she first joined Microsoft&#146;s Developer Support.</p>
<p><a name="3"></a>[3]  &lt;http://MSDN.Microsoft.com/columns/DeepC.asp&gt;</p>
<p><a name="4"></a>[4]  &lt;http://www.CodeProject.com/interview/HerbSutter3032002.asp&gt;</p>
<p><a name="5"></a>[5]  &lt;www.EDG.com/resellers.html&gt;</p>
<p><a name="6"></a>[6]  I don&#146;t know that the Visual C++ library cannot or ought not work. It could well be that it does work, but I&#146;m missing some secret. Admittedly I haven&#146;t tried too hard, since Dinkumware&#146;s other library version suffices.</p>
<p><a name="7"></a>[7]  &lt;www.cuj.com/experts/2004/sutter.htm&gt;</p>
<p><a name="8"></a>[8]  &lt;http://anubis.dkuug.dk/jtc1/sc22/wg21/docs/cwg_closed.html#209&gt;</p>
<p><a name="9"></a>[9]  Sad but true: the Visual C++ v7 compiler still doesn&#146;t call <B>std::unexpected</B> or enter an <B>unexpected_handler</B> when a function violates its specification. See my column preamble for future hope.</p>

<p><i>Although <B>Bobby Schmidt</B> makes most of his living as a writer and content strategist for the Microsoft Developer Network (MSDN), he runs only Apple Macintoshes at home. In previous career incarnations, Bobby has been a pool hall operator, radio DJ, private investigator, and astronomer. You may summon him on the Internet via <B>BobbySchmidt@mac.com</B>.</i></p>

</blockquote></body></html>
