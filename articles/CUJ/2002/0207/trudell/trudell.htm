<HTML>   
     <HEAD>
<TITLE>July 2002/The Application Watchman Class</TITLE></HEAD>
<BODY BACKGROUND="" BGCOLOR="#FFFFFF" TEXT="#000000">
<H2><A HREF="../tocjul.htm"></A><FONT COLOR="#FF0000">   Software Tools</FONT></H2>

<HR>

<H2 ALIGN="center"><FONT COLOR="#800000">The Application Watchman Class</FONT></H2>
<H3 ALIGN="center"><FONT COLOR="#800000">Bill Trudell</FONT></H3>

<BLOCKQUOTE>
<p>A convenient First Line of Defense against memory misuse.</p>
</BLOCKQUOTE>

<HR>
<BLOCKQUOTE>

<H3><FONT COLOR="#000080">Introduction</FONT></H3>

<p>Finding memory leaks in C++ can be hard. Therefore, checking for leaks throughout development is important. Many developers are willing to tolerate small or infrequent leaks during the development phase &#151; just as drivers will sometimes drive on a slowly leaking tire. However, it&#146;s important to quantify a leaking application so you can make an intelligent decision about how long you can wait before fixing it.</p>
<p>Detecting heap corruption in C++ is even harder than finding memory leaks. It is therefore even more important to check for heap corruption errors during development. Win32 does a good job of checking for heap overruns in the debug configuration, but a release build does not do this kind of checking.</p>
<p>This article introduces an Application Watchman class that encapsulates some of the Win32 CRTL (C Run-Time Library) extensions for heap state reporting. The class is an application of the Fa&ccedil;ade pattern, which is intended to &#147;provide a unified interface to a set of interfaces in a subsystem&#148; <a href="#1">[1]</a>.</p>
<p>This class, <B>AppWatchMan</B>, takes snapshots of the memory state at any point in the program. <B>AppWatchMan</B> also computes the differences of these memory states in order to determine potential leaks. <B>AppWatchMan</B> works as a first line of defense to prove or disprove that an application is leaking memory. You can also use <B>AppWatchMan</B> to generate a static profile of how much memory is being used at any one time, before or after significant events. <B>AppWatchMan</B> is intended to be lightweight and easily integrated into an application. The class is probably not a substitute for fully featured commercial products like NuMega&#146;s BoundsChecker or Rational&#146;s Purify or readily available freeware <a href="#2">[2]</a>. However, you can use <B>AppWatchMan</B> to reveal a deeper need for a more comprehensive tool.</p>

<H3><FONT COLOR="#000080">Win32 C Run-Time Extensions</FONT></H3>

<p>The Win32 environment extends the CRTL by adding many useful functions to help debug C and C++ programs. The sidebar, <a href="sidebar.htm">&#147;Heap State Reporting Functions,&#148;</a> summarizes the heap state reporting functions, as taken from the MSDN (Microsoft Developer Network) Library <a href="#3">[3]</a>. The last two functions allow clients to provide hook functions for enhancing the output of the allocation statistics. The hook functions, explained in the MSDN, are beyond the scope of this article.</p>
<p>The functions shown in the <a href="sidebar.htm">sidebar</a> are only available when <B>_DEBUG</B> is defined, and therefor are compiled out for release configurations. Clients access the functions by including the file <B>&lt;crtdbg.h&gt;</B>. The import library varies and usually gets pulled in through the kernel32 import library by way of dependencies. The <B>_CrtMemState</B> structure (described in the <a href="sidebar.htm">sidebar</a>) is defined in this header file.</p>
<p>The debug heap allocates blocks by type. These types include normal program allocations, allocations made by the CRTL, special client-allocated blocks, and two other lesser-used types <a href="#4">[4]</a>. Special allocation functions are required for applications to force their blocks to be allocated as <B>_CLIENT_BLOCK</B>s. Most application allocations will occur as <B>_NORMAL_BLOCK</B>s or as <B>_CRT_BLOCK</B>s. Using these special functions would either require the client to litter their application with these functions or use another class or set of functions that override allocations; it&#146;s not trivial, and it is also beyond the scope of this article.</p>

<H3><FONT COLOR="#000080">AppWatchMan Class Interface</FONT></H3>

<p>The CRTL heap state reporting functions are very handy. However, the limitation of a simple C API is that the client usually maintains the state. For example, the <B>_CrtMemCheckpoint</B> function takes a pointer to a <B>_CrtMemState</B> structure that the client must allocate and manage. Another disadvantage is that the client needs to know how to make the different calls; in this case, there are five functions. Placing these calls throughout a client application could become messy, especially when two or three might be needed at any one point.</p>
<p>In C++, it&#146;s pretty easy to resolve some of these issues, encapsulating and abstracting the CRTL heap reporting functions, reducing the client&#146;s implementation effort with a tradeoff of flexibility. <a href="fig1.htm">Figure 1</a> shows a UML class diagram for the <B>AppWatchMan</B> class that provides these capabilities. The class declaration is shown in <a href="list1.htm">Listing 1</a>.</p>
<p>The class encapsulates the first, previous, and last check-pointed memory states using the <B>_CrtMemState</B> structure. An alternative might have been to store readings in a circular buffer or list; for this demonstration, it did not seem necessary. A function <B>DoRounds</B> allows clients to request <B>AppWatchMan</B> to perform certain activities defined by the <B>FLAGS</B> enumeration. There are two levels of operations that can be performed. One level is a finer granularity, like asking <B>AppWatchMan</B> to check the heap for corruption. The other level is based on scenarios and is an OR&#146;ing of the lower-level flags to make it convenient for the client. The scenarios will be discussed in later sections. A form of <B>ostream</B> is held privately and used for logging program output. Finally, a static class variable <B>m_bOnDuty</B>, which mirrors the <B>_DEBUG</B> pragma value, is held privately for tests at run time.</p>

<H3><FONT COLOR="#000080">AppWatchMan Class Implementation</FONT></H3>

<p>The source for this class appears in <a href="list2.htm">Listing 2</a>. The constructor and <B>DoRounds</B> function each have an <B>if</B> statement block in which the memory checking functions are called if <B>m_bOnDuty</B> is <B>true</B>. The memory checking functions are compiled out in a release build. Therefore, <B>m_bOnDuty</B> is set to <B>false</B> so that the context in which they are called is also skipped. An alternative to the <B>if</B> statement would have been to use the preprocessor to conditionally compile the code using the <B>_DEBUG</B> pragma. I felt that using the pragma made the code more difficult to read, and the run-time check really doesn&#146;t add much overhead. Other than that, I don&#146;t have a compelling argument for using either the <B>if</B> statement or the <B>_DEBUG</B> pragma.</p>
<p>The constructor initializes an instance variable <B>m_pStrLog</B>, of type <B>ostream_withassign</B>, with the address of <B>cout</B>. The CRTL heap reporting functions are limited to using <B>stdio</B>. I did not want to bother the client with all the issues of file I/O and sharing file handles, so I did not allow them to change the log destination. This would have been more flexible, but also more work. The constructor executes <B>ios::sync_with_stdio</B> to synchronize the use of iostreams with <B>stdio</B>. The report mode and report file functions are set to send all warnings, errors, and assertions to <B>stdout</B>. However, I can still use stream operations using <B>m_pStrLog</B> to write special trace comments, which are more convenient than the Win32 special <B>_RPT</B> report functions. I should also mention that the report mode can be set to a pop-up window when an error occurs. This could be handy because you can start debugging, and you&#146;ll have an active call stack. I did not allow the client to specify this option to keep things simple.</p>
<p>The constructor calls <B>_CrtCheckMemory</B> to look for heap corruption. By doing this before <B>AppWatchMan</B> ever does the rounds, the current state of the heap will be well known and serve as a reference point for further observations. It&#146;s like the night watchman seeing the prior shift log and knowing not to phone in an abandoned car that was already reported. The constructor then calls <B>_CrtMemCheckpoint</B>, saving the data as the first snapshot, and dumps the data by calling <B>_CrtMemDumpStatistics</B>.</p>
<p>The function <B>DoRounds</B> is where most of the client-directed work is done. The client calls this function passing a comment and a <B>FLAGS</B> value. There are seven fine-grained values that are used for checking heap corruption, taking heap snapshots, dumping statistics, comparing snapshots, and performing leak detection. The <B>FLAGS</B> enumeration defines the values with an implied hierarchy where <B>CHECK_HEAP</B> is done first and <B>LEAKS_FROM_START</B> is done last. I have also made three higher-level <B>FLAGS</B> values for some typical scenarios that I think will be very useful.</p>

<H3><FONT COLOR="#000080">AppWatchMan Scenarios and Examples</FONT></H3>

<p>The first scenario is a Confidence Check. The calls to <B>DoRounds</B> are intended to be placed close to the beginning of the program, near <B>main</B>, and as close to the end of the program, near <B>main</B>&#146;s return. The client calls <B>DoRounds</B> with a <B>FLAGS</B> value of <B>BEGIN_CONF_CHECK</B>. <B>DoRounds</B> first checks the heap for corruption, then takes a snapshot of the heap statistics, and dumps them. The client then executes the rest of the program. At the end, the client calls <B>DoRounds</B> with a <B>FLAGS</B> value of <B>END_CONF_CHECK</B>. <B>DoRounds</B> again checks the heap for any corruption and takes and dumps a snapshot of the heap statistics. Finally it checks for any leaks since the start of the program and dumps all the leaking objects. This scenario is illustrated in <a href="fig2.htm">Figure 2</a>.</p>
<p>A sample program for the Confidence Check scenario is shown in <a href="list3.htm">Listing 3</a> and the output is shown in <a href="fig3.htm">Figure 3</a>. An intentional leak was introduced by omitting <B>delete</B>. <B>DoRounds</B> calls <B>_CrtDumpMemoryLeaks</B> to dump all leaks since the start of the program. The heap memory allocated in function <B>IntroduceLeak</B> was the 32nd block allocated, its address was <B>0x00790DA0</B>, and its length was 12 bytes long. The data string <B>"Hello World"</B> is dumped in ASCII. String data may be obvious, but other data will be harder to identify. I would suggest integrating with a memory manager that provides <B>new</B> and <B>delete</B> functions that keep track of allocations, which functions did them, and where they were done. A search on the Internet will produce quite a few to choose from.</p>
<p>The second scenario is a Leak Test. The calls to <B>DoRounds</B> should be placed immediately before and after the code to be tested, or where a leak is suspected. The client calls <B>DoRounds</B> with a <B>FLAGS</B> value of <B>BEGIN_LEAK_TEST</B> that just takes a snapshot of the heap. After the client executes the test code, it calls <B>DoRounds</B> with a <B>FLAGS</B> value of <B>END_LEAK_TEST</B> that results in another snapshot being taken. A difference is computed between the two memory states; if there are any differences, any leaks since the previous snapshot are dumped.</p>
<p>A sample function for the Leak Test scenario is shown in <a href="list4.htm">Listing 4</a> and the output is shown in <a href="fig4.htm">Figure 4</a>. The leak introduced is the same as the one in <a href="list3.htm">Listing 3</a>. This time the error was found by taking before and after snapshots and executing <B>_CrtMemDifference</B>. If a difference is found, function <B>_CrtMemDumpAllObjectsSince</B> is called with the previous <B>_CrtMemState</B>. The results in <a href="fig4.htm">Figure 4</a> agree with those in <a href="fig3.htm">Figure 3</a>.</p>
<p>The last scenario is a Profile Test. The calls to <B>DoRounds</B> are placed around a specific section of code in which the heap statistics are to be profiled. The client calls <B>DoRounds</B> with a <B>FLAGS</B> value of <B>BEGIN_PROFILE_TEST</B> that takes a snapshot and dumps the data. After the client executes the code to be profiled, it calls <B>DoRounds</B> with a <B>FLAGS</B> value of <B>END_PROFILE_TEST</B>. A snapshot is taken and dumped, and a difference with the last snapshot is made and dumped. There is quite a bit of valuable data in these statistics.</p>
<p>A sample function for the Profile Test scenario is shown in <a href="list5.htm">Listing 5</a> and the output is shown in <a href="fig5.htm">Figure 5</a>. Snapshots are taken before and after the profiled code. A difference is computed and dumped. The memory allocated is our old friend, the string <B>"Hello World"</B>, which including the null terminator is 12 bytes long. The statistics for the number of blocks are all zero; this means there were no leaks between the two snapshots. You can also see that the largest number of bytes used, which is the high water mark, and the total allocation bytes both increased by 12 bytes. Now you can have solid numbers for making decisions and assessments rather than guessing.</p>
<p>A sample function for corrupting the heap is shown in <a href="list6.htm">Listing 6</a> and the output is shown in <a href="fig6.htm">Figure 6</a>. A variation for using the Confidence Check is when you suspect that the heap is being corrupted. One of the more common errors is writing past the end of a character array. In debug mode, the Win32 Memory Manager places guard blocks with values of <B>0xFD</B> at the end of the allocated memory. In the example, the client writes an exclamation point in the space reserved for the null terminator. The null terminator is written into the guard block. When the client deletes the memory, the Win32 Memory Manager checks the guard block for corruption and generates an error, which is the first one listed in <a href="fig6.htm">Figure 6</a>. The second error in the example code is also an overrun when writing the string <B>"Goodbye!"</B>. In this case, the block is intentionally not returned, but the damage is already done. When the client calls <B>DoRounds</B> at the end of the Confidence Check scenario, a call to <B>_CrtCheckMemory</B> is made revealing the error and dumping relevant statistics. The last error in <a href="fig6.htm">Figure 6</a> is the end of the Confidence Check scenario where function <B>_CrtDumpMemoryLeaks</B> is called to show all blocks that have not been returned.</p>

<H3><FONT COLOR="#000080">Discussion</FONT></H3>

<p>Executing the Leak Test scenario answers the question &#147;Are there any leaks?&#148; You should be able to answer the question confidently with a simple yes or no response. For more information on finding leaks, consult <a href="#5">[5]</a>. To learn more about troubleshooting, read <I>Debugging Applications</I> by John Robbins <a href="#6">[6]</a>. This excellent book covers the debugging details for the Win32 environment.</p>
<p>The after-market heap corruption checkers do a better job of catching heap corruption. Some products even check for overruns on the stack. The dilemma is deciding if you need those products. You can think of the <B>AppWatchMan</B> Confidence Check scenario as a first line of defense for determining if further heap corruption checking is necessary.</p>
<p>There are several areas worth exploring. One would be creating a static <B>AppWatchMan</B> as an attempt to get it called even before <B>main</B> is executed. It would also be interesting to see when or if its destructor would get called. I&#146;d also like to know if Linux or Unix has extensions to the CRTL like Win32. I know there are products that are made for Linux to detect leaks; one example is Insure++ by Parasoft. There are also lots of freeware and public license implementations; I&#146;m just not sure if the OS supports a set of C functions like Win32 does.</p>
<p>Several enhancements would be beneficial to <B>AppWatchMan</B>. One improvement would allow the client to specify the name and location of a log file that is totally managed and encapsulated by <B>AppWatchMan</B>. Another enhancement would be to allow the client to specify that the report mode generates a Win32 <B>MessageBox</B> on all errors. The pop-up gives you the option of just-in-time debugging only when necessary on a debug version.</p>

<H3><FONT COLOR="#000080">Conclusion</FONT></H3>

<p><B>AppWatchMan</B> is a lightweight class that can help catch memory allocation errors and heap corruption in your programs early in the development cycle. <B>AppWatchMan</B> will provide peace of mind and concrete information on heap usage. One tradeoff is the &#147;buy versus build&#148; argument. <B>AppWatchMan</B> is very lean and can&#146;t be compared to a more full featured product like NuMega&#146;s BoundsChecker. However, if you can&#146;t afford the commercial products, you can afford <B>AppWatchMan</B>. One thing is for sure: you can&#146;t afford to be uninformed about your application&#146;s use or misuse of the heap. <B>AppWatchMan</B> should be your first line of defense!</p>

<H3><FONT COLOR="#000080">Notes</FONT></H3>

<p><a name="1"></a>[1]  Erich Gamma, et al. <I>Design Patterns</I> (Addison-Wesley, 1995), page 185.</p>
<p><a name="2"></a>[2]  While editing this article, I came across a controversial opinion written by Randy Charles Morin on one of the more popular commercial heap checking tools. His paper appears at &lt;www.kbcafe.com/articles/memory.leaks.html&gt;. Randy also developed a class similar to mine; however, it does all the work in the constructor and destructor. I was not comfortable doing that because the intent of the constructor and destructor are initialization and clean up. My class aggregates functionality and is scenario based.</p>
<p><a name="3"></a>[3]  &#147;Heap State Reporting Functions,&#148; MSDN Library, &lt;http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vsdebug/html/_core_heap_state_reporting_functions.asp&gt;.</p>
<p><a name="4"></a>[4]  &#147;Types of Blocks on the Debug Heap,&#148; MSDN Library, &lt;http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vsdebug/html/_core_types_of_blocks_on_the_debug_heap.asp&gt;.</p>
<p><a name="5"></a>[5]  Edward Wright. &#147;Detecting and Isolating Memory Leaks Using Microsoft Visual C++,&#148; MDSN Library, &lt;http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dnvc60/html/memleaks.asp&gt;.</p>
<p><a name="6"></a>[6]  John Robbins. <I>Debugging Applications</I> (Microsoft Press, 2000). </p>

<p><i><B>Bill Trudell</B> is a senior developer with Capital One where he uses C++ to implement middleware solutions for their Call Center applications. His articles have appeared in the <I>Journal of Object Oriented Programming</I>, <I>Dr. Dobbs Journal</I>, and <I>Embedded Systems Programming</I>. His interests include his wife and children, racquetball, and woodworking. He can be reached at <B>billtrudell@yahoo.com</B>.</i></p>

<h4><a href="../../../source/2002/jul02/trudell.zip"></a></h4>

</blockquote></body></html>
