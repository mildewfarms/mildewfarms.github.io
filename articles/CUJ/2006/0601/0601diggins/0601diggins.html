<html><head><title>January, 2006: Building More Flexible Types  With Mixins</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; C/C++ Users Journal--><p><i>C/C++ Users Journal</i>, January 2006</p><h1>Building More Flexible Types  With Mixins</h1><h2>Applying the Curiously Recurring Template Pattern</h2><h3>By Christopher Diggins</h3><I>Christopher Diggins is a freelance consultant and developer of the Heron programming language. He is a coauthor of the C++ Cookbook (O'Reilly, 2005) and can be reached at http://www.cdiggins.com/.</I><hr><p>In C++, the Curiously Recurring Template Pattern (CRTP) [1] is a common name given to the technique of inheriting from a template parameter. Outside of the C++ community, this technique is known more widely as a mixin [2]. Mixins are described in the literature to be a powerful tool for expressing abstractions, but CRTP is often viewed as a somewhat exotic technique, and somewhat under utilized. In this article, I plan on showing how it can be used in a rather pedestrian manner to create simple designs that are significantly more flexible.</p><p>What many programmers realize, through observing Java and other languages, is that hierarchical layers of abstraction in our designs can reduce the amount of code we have to write and maintain. Furthermore, they can isolate the ripple effect of changes when refactoring, making such designs more appropriate for agile development.</p><p>Unfortunately, traditional OOP techniques for expressing abstractions, such as using abstract base classes, are not often used in C++ code. One of the big reasons for this is that it is incompatible with generic programming techniques such as those used by the STL. However, the advantages of OO designs can be achieved, even in generic designs, by using mixin-based composition of classes through simple application of the CRTP pattern.</p><p>Let's start by looking at a simple example, my favorite abstract data type (ADT), the stack. A stack ADT can be expressed minimally in C++ as an abstract base class (ABC), as shown in <a href="0601digginsl1.html" target="_BLANK">Listing 1</a>.</p><p>A very trivial, yet effective, implementation of the <b>AbstractStack</b> is shown in <a href="0601digginsl2.html" target="_BLANK">Listing 2</a>.</p><p>In and of itself, the <b>ConcreteStack</b> is not particularly useful in any real-world scenario because it is severely lacking in functionality. It could be augmented easily through the introduction of several utility functions such as: <b>PushCopy()</b>, <b>MultiPop()</b>, <b>Clear()</b>, <b>Duplicate()</b>, <b>Exchange()</b>, <b>Top()</b>, <b>Reverse()</b>, and so on. These functions can be added directly to <b>ConcreteStack</b>, but if I do that, what happens if I need a new implementation of <b>AbstractStack</b>? Consider the perfectly reasonable alternative implementation of <b>FixedStack</b>, which inherits <b>AbstractStack</b> in <a href="0601digginsl3.html" target="_BLANK">Listing 3</a>.</p><p>All of the utility functions would have to be more or less cut and pasted into this new implementation. This violates a principle rule of programming: reduce redundancy. The obvious object-oriented solution, then, is to place the extra member functions directly in <b>AbstractStack</b> itself, or better yet, in a separate class that inherits from <b>AbstractStack</b>, such as <b>AbstractStackExtension</b> in <a href="0601digginsl4.html" target="_BLANK">Listing 4</a>.</p><p>The approach of extending ADTs in this manner is very useful until you try to apply it to a container designed using generic-programming techniques, and wish to extend a concept in a similar manner. Consider the <b>IterableConcept</b> (expressed in pseudocode) in <a href="0601digginsl5.html" target="_BLANK">Listing 5</a>.</p><p>You can't express a concept as an abstract type because the dependent member types (e.g., <b>Iterator</b>) are specific to (dependent on) the concrete implementation. This doesn't mean you can't still express an extension as a separate abstraction.</p><p>Let's say you want to introduce a set of utility member functions, <b>ForEach()</b>, <b>IsEmpty()</b>, and <b>Count()</b>, which can be used with any class that models a particular concept. Using the CRTP, this can be done as a separate layer of abstraction, for instance in <a href="0601digginsl6.html" target="_BLANK">Listing 6</a>.</p><p>In order to use the extension class in conjunction with a class that models the concept being extended, you need to create a third class that glues the extension class to the implementation class through inheritance. This is demonstrated in <a href="0601digginsl7.html" target="_BLANK">Listing 7</a>.</p><p>The biggest drawback of the CRTP technique is that constructors aren't inherited. This means that if you use an initializing constructor in your implementation class, every extension will have to have an appropriate initializing constructor. This causes the extensions to be more restricted and, as such, less useful. </p><p>Clearly, the CRTP is a very expressive technique. Furthermore, it is more efficient than the more traditional OO approach because there is no abstraction penalty paid. Now we just have to wait and see if C++ will enable constructor initialization in the future.</p><h3>Acknowledgments</h3><p>Much thanks to Max Lybbert for reviewing and commenting on this article.</p><h3>References</h3><ol>  <li>Coplien, J. "Curiously Recurring Template Patterns," <i>C++ Report</i>,     February 1995, pp. 24-27.</li>  <li>Yannis Smaragdakis and Don Batory. Mixin-Based Programming in C++, 2000;     http://citeseer.ist.psu.edu/smaragdakis00mixinbased.html. </li></ol><p><b>CUJ</b></p></body></html>