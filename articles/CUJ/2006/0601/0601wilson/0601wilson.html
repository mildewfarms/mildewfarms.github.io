<html><head><title>January, 2006: A View to a String: Part I</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; C/C++ Users Journal--><p><i>C/C++ Users Journal</i>, January 2006</p><h1>A View to a String: Part I</h1><h2>Design and Definition</h2><h3>By Matthew Wilson</h3><I>Matthew Wilson is a software-development consultant for Synesis Software, creator of the STLSoft libraries, and author of Imperfect C++ (Addison-Wesley, 2004) and Extended STL (Addison-Wesley, 2006). He can be contacted at http://imperfectcplusplus.com/.</I><hr><p>[This month's column is, in part, an extract from Matthew's forthcoming book on STL extension, called <i>Extended STL</i>, which will be published by Addison-Wesley in 2006.]</p><p>This month I'm continuing the theme of how other languages may influence the idioms of C++. Where the last installment examined how Ruby's flexible subscripting might be emulated in C++, in this installment and the next I'm going to be considering how D's [1] notion of a slice can be applied in C++, in particular to strings. I'll be discussing, briefly, the "view" concept and its refined concept&#151;the slice view. I'll then introduce the STLSoft <b>basic_string_view</b> class template, and discuss its implementation and contracts. Finally, I'll discuss the contexts in which the use of string views is appropriate, along with those where it's not.</p><h3>The View Concept</h3><p>The concept of a view is best known from the field of relational databases, where a view is an alternative way of looking at data from one or more tables, with the following characteristics:</p><ol>  <li>A view is not a copy of the data from the source tables; indeed creation of a view does not involve creation of any data whatsoever.</li>  <li>Changes to the data in the underlying table are reflected in the data apparent in the view.</li>  <li>Where mutating access is allowed, changes to view data are concurrently reflected in the underlying table.</li></ol><p>The three primary purposes of such views are:</p><ol>  <li>To present the information from two or more tables as if from a single table: Amalgamation.</li>  <li>To restrict the available information; that is, to hide the contents of a particular table's column: filtering.</li>  <li>To effect changes in the view into the underlying table, and vice versa: (logical) coherency.</li></ol><p>There has been much interest in adapting the view concept to C++, including the work of Jon Seymour [2], the View Template Library (VTL) by Gary Powell and Martin Weiser [3], and the work of Maciej Sobczak [4]. My own work on views inhabits a lower level; its primary purpose is the <i>raison d'etre</i> of C++: efficiency. The additional purposes of views in C++ are legion, including:</p><ul>  <li>To present the collection and/or the data as a different type: Type Adaptation.</li>  <li>To modify the values in the data as presented: Transformation.</li>  <li>To present the data in a different order: Reordering.</li>  <li>To avoid unnecessary copies while presenting a different perspective onto the data: (physical) coherency.</li></ul><p>Views can have a bewildering variety of forms and functions, including aggregating, filtering, linearizing, polymorphic, sorting, reversing, restructuring, and transforming, to name but a few. For these two installments, I'm going to focus on only the slice view.</p><h3>Slices in D (and in C/C++)</h3><p>In D, a slice provides a view onto a section of an array. Consider the following code:</p><pre>import std.stdio;void main(){  char[]  s   =      "This is a null-terminated string".dup;  char[]  sl  =   s [0 .. 4];  writef("[%s]\n", sl);   	// Prints "[This]"  s[2 .. 4] = "at";  writef("[%s]\n", sl);   	// Prints "[That]"}</pre><p>A slice is declared as <b>type[]</b>, and is internally represented as a length plus a pointer. Hence, the creation of the slice <b>sl</b> does not involve a copy of the source string <b>s</b>, it merely "remembers" the pointer to the start of the literal string (<b>&amp;s[0]</b>) and the length 4. When the contents of <b>s</b> are changed in the assignment of the string <b>"at"</b>, the changes are reflected in any subsequent use of the slice <b>sl</b>. (Note that <b>s</b> is a duplicate of the literal string, which, as in C++, is read-only. An attempt to write to a [slice of a] literal will result in an access violation.) The C++ equivalent of a D slice is:</p><pre>template &lt;typename T&gt;struct slice{  size_t  len;  T       *ptr;};</pre><p>(A slice could also be represented as a pair of pointers. Although I've dallied with such a representation&#151;in the recls libraries&#151;I consider it to be an inferior representation to a length+pointer. This is because one tends to want to know the size more often than the "end" position. The adopted way also affords direct compatibility with D, and makes writing extensions for Ruby and other languages a little bit easier.)</p><p>Obviously, the previous template isn't exactly bristling with functionality, nor does it facilitate nonmutating (that is, <b>const</b>) access; something that the D language avoids by not supporting <b>const</b> as we know it.</p><h3>Slice Views</h3><p>To make such a type useful for C++ would require adding methods, such as constructors, assignment operators, and accessors; and providing support for iteration. Such a type exists in the STLSoft libraries, in the form of the <b>array_view</b> class template, which presents a (nonmutating) <b>std::vector</b>-like interface. There is also a more complex class template, <b>basic_string_view</b>, which provides more functionality to support a (nonmutating) <b>std::basic_string</b>-like interface, and which is the subject of this month's and next month's columns.</p><p>Slice views can be very simple. They consist of constructors, <b>begin()</b> and <b>end()</b>, <b>rbegin()</b> and <b>rend()</b>, a subscript operator, <b>size()</b>, and, importantly, <b>base()</b>, which returns the slice view's base pointer.</p><h3>Slice View Advantages</h3><p>The two main advantages of slice views are logical coherency and physical coherency. Logical coherency means that views always reflect the up-to-date contents of the underlying collection. </p><p>The latter advantage, physical coherency, translates into greater efficiency. It has two aspects: First, there is a reduction in memory usage because there are fewer, if any, copies made. Second, because slices don't do deep copies, the cost of copying slice instances is very low. We'll see demonstrations of these efficiency advantages in several different contexts in the second installment.</p><p>Further to these main advantages, the view-class templates, by virtue of their emulation of standard interfaces, also provide collection type adaptation. In other words, using <b>basic_string_view</b> allows slices of character arrays to be used in place of <b>std::basic_string</b>.</p><p>The slice view (also known as array view) is the only view concept that guarantees (and relies on) contiguous storage. This is analogous to the situation with <b>std::vector</b>, which is the only standard container that guarantees contiguous storage. As a consequence, slice views (and vectors) are compatible with C APIs.</p><h3>Views Are Not Value Types</h3><p>The fact that slice views are always up to date with respect to their underlying storage is, as we will see in the next installment, a great boon, but it also carries risks, and imposes limitations on their use. Simply put, a slice view, unlike the standard library containers (including <b>basic_string</b>), is not a value type. In <i>Imperfect C++</i> [5] I define a value type as including these aspects:</p><ul>  <li>"Instances can be created as, or later made to be, copies of another instance."</li>  <li>"Change[s] to the logical state of one instance does not result in a change to the logical state of [any of its copies]."</li>  </ul><p>Slice views fulfill the first of these criteria, but not the second, because if one view is made as a copy of another, and the underlying storage changes, then the logical states (that is, the contents) of both views are affected: They are not independent.</p><p>Thus, one must be careful with views to not use them when the link to their underlying storage is, or could be, broken. For example, if one takes a string view onto the contents of a mutable container, such as a <b>std::string</b>, the view can be invalidated by mutating members in just the same way that an iterator can be:</p><pre>std::string           s("Short string");stlsoft::string_view  sv(s.data(), s.size());std::string::iterator it = s.begin();s = "Longer string"; // sv and it both invalidated</pre><p>Obviously, holding a view onto a string after that string is deleted is pretty fatal. Therefore, string views are best used in contexts where their view nature is irrelevant (temporaries/single expressions) or in contexts where their nature is overt (split functions). We'll investigate these contexts in the next installment. Not being a value type also has implications for the string-view semantics, so let's now look at the definition of the class.</p><h3>STLSoft's basic_string_view</h3><p>The STLSoft <b>basic_string_view</b> class template provides an interface that corresponds to the standard <b>basic_string</b> to a significant degree, as shown in <a href="0601wilsonl1.html" target="_BLANK">Listing 1</a>. The notable features of <b>basic_string_view</b> are:</p><ul>  <li>It has a nonmutating (<b>const</b>) interface, except for copy assignment, <b>clear()</b>, and <b>swap()</b>.</li>  <li>It supports a rich set of constructors, &agrave; la <b>basic_string</b>, except for the range template constructors (because it must always be pointing to contiguous storage).</li>  <li>It supports the rich set of comparison operators offered by <b>basic_string</b>.</li>  <li>It provides all the usual <b>basic_string</b> element access, size, and iteration methods.</li>  <li>It does not support the myriad search methods of <b>basic_string</b>.</li></ul><p>As well as the length (<b>m_length</b>) and pointer (<b>m_base</b>) member variables that constitute the slice, there is a third member, <b>m_cstr</b>. This is for the implementation of the <b>c_str()</b> method, which will be discussed shortly. Given the simplicity of the slice view concept, the bulk of the implementation of the class is very straightforward, and I won't belabor you with the details: The constructors, copy assignment operator, <b>swap()</b>, <b>size()</b>, <b>max_size()</b>, <b>length()</b>, <b>compare()</b>, <b>front()</b>, <b>back()</b>, <b>begin()</b>, <b>end()</b>, <b>rbegin()</b>, <b>rend()</b>, and <b>copy() </b>methods all have exactly the same semantics as they do in <b>basic_string</b>. The seven constructors are all eminently straightforward: The default constructor sets the slice members <b>m_length</b> to 0 and <b>m_base</b> to NULL; the other constructors initialize the members as appropriate to their arguments. The <b>m_cstr</b> member is set to NULL in all cases. The destructor need do nothing with the slice members, but releases any memory buffer pointed to by <b>m_cstr</b>.</p><p>Because slice views, by definition, present information that they do not themselves manage, they sit somewhat uncomfortably on the border of the value-type domain. Hence, the other methods have interesting, and sometimes surprising, semantics: The implementations of <b>capacity()</b>, <b>clear()</b>, <b>refresh()</b>, <b>equal()</b>, <b>c_str()</b>, <b>base()</b>, <b>data()</b>, <b>is_valid()</b>, and <b>empty_string_()</b> will be examined in the remainder of the article, including an examination of the contract programming aspects of the class.</p><h3>capacity()</h3><p><b>capacity()</b> returns the same values as <b>size()</b> and <b>length()</b>. This means that code that might test <b>capacity()</b> against <b>length()</b> will (always) receive a meaningful result of 0 of the spare capacity in the string instance.</p><h3>clear() and refresh()</h3><p>The <b>clear()</b> and <b>refresh()</b> methods are closely related. Several standard containers provide the <b>clear()</b> method, which means "empty out all contained elements." For the string view, this means setting the pointer to NULL and the length to 0. But it also means deallocating any memory used. The <b>refresh()</b> method leaves the logical state of the string view untouched, and performs only the latter action: resetting the pointer. We'll see why this is so shortly.</p><h3>equal()</h3><p><b>equal()</b> is provided as an optimization because it can immediately return <b>true</b> if the internal pointers and lengths are identical, or immediately return <b>false</b> if the lengths differ.</p><h3>base()</h3><p><b>base()</b> is a method from the slice view concept&#151;that returns the pointer part of the slice. Unless modified by <b>clear()</b>, <b>swap()</b>, or <b>operator =()</b>, whatever was passed to the constructor will be returned by this method.</p><h3>c_str()</h3><p>Because the string view may look onto a slice that does not end in a null terminator, it's obvious that <b>c_str()</b> cannot simply return <b>m_base</b>. Further, even if, at the time of construction, the element of the source string at <b>m_base</b> + <b>m_length</b> is a null terminator&#151;which we can't test for anyway, because it might be in an uncommitted page of memory!&#151;the underlying storage can change at any time, without notification of the string view(s) mapping to it.</p><p>So, if we are to provide <b>c_str()</b>, we must allocate a buffer of length <b>1 + m_length</b> (into <b>m_cstr</b>), and copy in the contents and add a null terminator. Naturally, once we've done this, it's possible that the underlying storage will change and render the allocated copy out of date. There are six options to handle this:</p><ol>  <li>Don't provide <b>c_str()</b>. Several of my reviewers commented firmly that this is the best (indeed the only sensible) option. But, while many of the uses to which the string views are most suited do not need <b>c_str()</b>, this is a nonstarter: There's simply too much code requiring C-style (that is, null terminated) strings for it to be practicable. I know; I've tried.</li>  <li>Create the copy during construction, which persists for the lifetime of the string-view instance. Doing this would have drastic performance implications: It would likely be slower than using <b>basic_string</b>, or another full value-type string type. It would also mean that the copy, once stale, remains in that state.</li>  <li>Create the copy the first time <b>c_str()</b> is called, which persists for the lifetime of the string view instance. This pays the cost only when necessary, but still risks stale data.</li>  <li>(Re)create the copy each time <b>c_str()</b> is called. This means that the contents of the buffer are fresh, but it would have unacceptable semantics. Consider the code in <a href="0601wilsonl2.html" target="_BLANK">Listing 2</a>. This is a strong, but hidden, break from the semantics of <b>basic_string</b>. Too strong. Clause 21.3.6;2 of the Standard stipulates that "The program shall not...treat the returned value as a valid pointer after any subsequent call to a non<b>const</b> member function," and a string view's <b>c_str()</b> should offer similar guarantees.</li>  <li>Create the copy the first time <b>c_str()</b> is called, and then update the contents of the (same) buffer with each subsequent call. This is especially suitable because string views have a fixed size&#151;except when reset with <b>operator =()</b>, <b>clear()</b>, and <b>swap()</b>. However, it would lead to situations in which <a href="0601wilsonl3.html" target="_BLANK">Listing 3</a> might not hold to be true.</li>  <li>Allocate the copy the first time <b>c_str()</b> is called and provide a method&#151;<b>refresh()</b>&#151;to reset the <b>m_cstr</b> member so that the next time <b>c_str()</b> is called the copy is made afresh. This avoids hidden semantic gotchas, without enforcing staleness of data. It's not perfect, but I believe it is the best mix of performance, usability, and sensible semantics, and is the approach I've used in <b>basic_ string_view</b>. <a href="0601wilsonl4.html" target="_BLANK">Listing 4</a> shows the implementation of the <b>c_str()</b>, <b>operator =()</b>, <b>refresh()</b>, and <b>empty_string_()</b> methods. <b>empty_string_()</b> is a private static method that is used to provide an empty string for the given character type without needing a separate implementation file. <b>c_str()</b> returns either <b>m_cstr</b> (if previously allocated) or <b>empty_string_()</b> (if the instance is empty), or allocates a copy into <b>m_cstr</b> and returns it.</li>  </ol><p>Unlike <b>std::basic_string</b>, there are no <b>assign()</b> methods. Only two methods exist for modifying a view after its construction: copy assignment via the copy-assignment operator, and swapping via <b>swap()</b>. It would be easy to implement a nearly full-complement of efficient assignment functions in terms of the constructors, but I deliberately did not do this; as it stands, the interface limits the ease with which the user can forget that string views are not value types.</p><h3>base() and data()  And the String/View Tension</h3><p>Although it might not seem obvious, <b>data()</b> is one of the most important methods of the string view. The Standard prescribes, for <b>basic_string</b>, that <b>data()</b> return a nonNULL pointer to the first character in an array representing the contents of the string. Note that the pointer returned by <b>data()</b> does not have to be null terminated; this is, unlike <b>c_str()</b>, which must return a nonNULL pointer to a null terminated array.</p><p>The obvious implementation for <b>data()</b> would be simply to return <b>m_base</b>, but there are two reasons why we can't do this. First, it's common for functions that take length and pointer to ignore the pointer if the length is 0. Similarly, the behavior of the string-view constructor is well defined if the pointer is NULL. One appealing implementation option would be to initialize <b>m_base</b> to be the <b>empty_string_()</b> in the case where the size specified to a constructor is 0. However, slice views need to be able to provide, via <b>base()</b> and <b>size()</b>, the same description of the slice passed to the constructor, supporting cases (a) and (b) in <a href="0601wilsonf1.html" target="_BLANK">Figure 1</a>. By assigning <b>m_base</b> to <b>empty_string_()</b> when size is 0&#151;case (c) in <a href="0601wilsonf1.html" target="_BLANK">Figure 1</a>&#151;the required slice semantics would not be supported. Thus, the implementation of <b>basic_string_view::data()</b> is as shown in <a href="0601wilsonl5.html" target="_BLANK">Listing 5</a>.</p><p>This represents a slight performance cost for each access, but cannot be avoided, given the semantic constraints already outlined. If you don't care about NULL or are confident you won't receive it for a given string view instance, call <b>base()</b> instead.</p><h3>is_valid()</h3><p>Due to their somewhat schizophrenic nature, the specification of contracts for view classes must be subject to very careful consideration, to account for the fact that their logical contents are subject to external change. Interestingly, with a string view, this factor leads to very simple contracts. The invariant for the class&#151;realized, as is my wont [5] in the <b>is_valid()</b> method (<a href="0601wilsonl6.html" target="_BLANK">Listing 6</a>)&#151;stipulates two obvious relationships: that the <b>m_base</b> pointer must be valid if length is non-0; and that the <b>m_cstr</b> member (used to implement <b>c_str()</b>) must be NULL if the length is 0.</p><p>What may be surprising, however, is that there is no association between the length and the contents of the underlying array. There are two reasons. First, just as with <b>std::basic_string</b>, we wish to allow strings with embedded NULL (<b>'\0'</b>) characters. Second, because it's a view, it's eminently possible (and sometimes expressly desired) that the contents of the underlying array will change. It would be both dissuasively inefficient and logically flawed to police the view contents; hence, the invariant is so simple.</p><h3>Example Uses of String Views</h3><p>As mentioned earlier, a slice view instance is not valid outside the lifetime of its underlying array. String views are no exception, but because they are small, and look (and for the most part smell) like strings that are value types, one must be careful when using them to avoid the dead reference problem. Despite this, there are several excellent uses for them.</p><p>One such use is with the Open-RJ library, which uses <b>stlsoft::basic_string_view&lt;char&gt;</b> as its string type. Because an Open-RJ database is a single, immutable block of memory, within which reside the names and values of all fields in the database records, it would be wasteful indeed to take copies of these strings (for example, in the form of <b>std::string</b>) when slices will safely suffice. All such slices will be valid as long as the database is loaded, irrespective of the lifetime of the record and/or field objects from which they are elicited.</p><p>Another scenario in which the dead-reference problem is moot, and in which string views are a flat-out winner, is when manipulating collections of strings with algorithms, as in the definition of <b>has_token_string()</b> (whose performance will be featured in next month's column):</p><pre>bool has_token_string(char const *str, char delim, 				  char const *token){  typedef stlsoft::string_view        string_t;  typedef stlsoft::string_tokenizer&lt;string_t, char&gt;                                     tokenizer_t;  tokenizer_t tokens(str, delim);  return tokens.end() != std::find( tokens.begin(),                                      tokens.end(), token);}</pre><p>When <b>string_t</b> is <b>std::string</b> (or <b>stlsoft::simple_string</b>), there is one visit to the heap for the copy of <b>str</b>, and one for each tokenized element in <b>str</b>; for example, if <b>str</b> is "cpp;c;java;;pl;;" (and delim is the semicolon) there would be five allocations. However, when <b>string_t</b> is <b>stlsoft::string_view</b> (a typedef for <b>stlsoft::basic_string_view&lt;char&gt;</b>), there are 0 allocations, regardless of the contents of <b>str</b>! Tests show that this function works between 2 and 10 times faster than with either <b>std::string</b> or <b>stlsoft::simple_string</b>.</p><p>Another example, which will be performance tested next time, is in combination with memory mapping, to present a text file as a string object:</p><pre>platformstl::memory_mapped_file mmf("mmf.cpp");stlsoft::string_view  contents 		(static_cast&lt;char*&gt;(mmf.contents()),                                       mmf.size());. . . code that uses whole file as string 'contents'</pre><h3>Coming in Part II</h3><p>Next time, I'll look at some other safe, but occasionally exotic, uses of string views, including in the implementation of Basic-like slice functions. I'll also discuss a number of performance tests that demonstrate the significant gains to be had by the appropriate use of string views.</p><h3>Acknowledgments</h3><p>Thanks to Bjorn Karlsson, Christopher Diggins, Garth Lancaster, Nevin Liber, Pablo Aguilar, and Walter Bright for their insights into the article.</p><h3>References</h3><ol>  <li>The D Programming Language, Digital Mars; http://www.digitalmars .com/d/.   </li>  <li>Views&#151;a C++ Standard Template Library extension, Jon Seymour, 1995-6;     http://www.zeta.org.au/~jon/STL/views/doc/ views.html.</li>  <li>View Template Library, Gary Powell and Martin Weiser, 2000. http://www.zib.de/weiser/vtl/.</li>  <li>Sobzcak, Maciej. "STL Sequences &amp; the View Concept," <i>C/C++ Users     Journal</i>, April 2004.</li>  <li>Wilson, Matthew. <i>Imperfect C++</i>, Addison-Wesley, 2005. </li></ol><p><b>CUJ</b></p></body></html>