<html><head><title>January, 2006: Hotter Events</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; C/C++ Users Journal--><p><i>C/C++ Users Journal</i>, January 2006</p><h1>Hotter Events</h1><h2>Define and send your own custom events</h2><h3>By John Torjo</h3><I>John Torjo is a freelancer and consultant who specializes in C++, generic programming, and streams. He can be reached at john@torjo.com.</I><hr><p>Handling events is pretty easy&#151;if you know what you want to handle (<a href="0601torjol1.html" target="_BLANK">Listing 1</a>). However, creating your own events and filtering events is still quite hard, and error prone. In this article, I'll show you new ways to create/filter events that are easy to use and as error-free as possible.</p><h3>Dynamic Events</h3><p>This is something many of you have asked for, and it's finally here: The ability to create your own events in an easy and error-free manner. Until now, <a href="0601torjol2.html" target="_BLANK">Listing 2</a> would have been the way you created your own events. This required you to know the exact match between the arguments you pass to the event (WPARAM and LPARAM), and how the arguments are processed in the event-handler function. This is time consuming and prone to error. You could also get into trouble if some other event has the same ID as yours; thus, someone else could send that event expecting a different outcome. </p><p>Now, you can define a dynamic event quite easily:</p><pre>struct tri_click :     dynamic_event&lt;tri_click&gt; {  // ...};</pre><p>Every event needs to be uniquely identified. This way, when an event happens, the dispatcher knows which event happened, and can correctly dispatch it [1].</p><p>The same goes for dynamic events. Therefore, you'll need to define the following:</p><pre>static event_id_type event_id();</pre><p>This needs to return the ID of the dynamic event, and it must return the same ID every time the function is called (you are not allowed to return different IDs at different times).</p><p>To ease the above, I've provided two helpers: <b>unique_event</b> and <b>registered_msg</b> (for the Win32 platform).</p><ul>  </ul><p>Usually, you'll prefer the <b>unique_event</b> class. Its usage is simple and straightforward:</p><pre>struct tri_click :     unique_event&lt;tri_click&gt; {  ...};</pre><p>That's it! The <b>event_id</b> is automatically computed for you. However, its biggest advantage could be its biggest disadvantage as well. You cannot control the unique ID that gets assigned to it. This is okay most of the time, but it could be a problem when you want to send/receive events to/from other applications. If so, use the <b>registered_msg</b> class.</p><p>The <b>registered_msg</b> uses a string to generate a unique ID for this event. The same string will always return the same ID (even across different applications); different strings will always generate different IDs. In particular, internally, it uses the <b>::RegisterWindowMessage</b> Win32 function.</p><p>Use <b>registered_msg</b> like this:</p><pre>struct tri_click :     registered_msg&lt;tri_click&gt; {  ...};</pre><p>You specify the string to generate the unique ID, like this:</p><pre>static std::string event_str() { ... }</pre><p>For example:</p><pre>static std::string event_str() {return "internal_command"; }</pre><p>Use this to communicate with other applications and/or instances of your application. However, make sure the event doesn't have any arguments [2]. </p><h3>Sending Events</h3><p>First of all, differentiate between internal and external events. In other words, an internal event is useful only for a specific event handler internally. More to the point, you'll usually use internal events to communicate between a window class and its event handler. <a href="0601torjol3.html" target="_BLANK">Listing 3</a> shows a simple example of using an internal <b>event&#151;wm_set_bitmap</b> is used to communicate from <b>bitmap_button</b> to its event handler (<b>bitmap_button_handler</b>).</p><p>On the other hand, if your window class has defined some external events, you'll be able to send an event to an instance of your window class, anywhere in your program. Same goes for listening to events (being notified when an event occurred).</p><p>Once you've defined an event, sending it to a window is easy:</p><pre>wnd&lt;&gt; w = ...;w-&gt;send_event( evt_class( [args]));w-&gt;post_event( evt_class( [args]));</pre><p><b>evt_class</b>, in this case, is the name of your event class, and the optional <b>args</b> are the arguments you can pass to its constructor.</p><p>If you use <b>send_event</b>, the event will be sent to the window, it will be processed, and the eventual result will be returned synchronously (that is, after the call ends, the event has been processed).</p><p>If you use <b>post_event</b>, it will be pushed into the window's queue and processed asynchronously (that is, after the call ends, the event is not guaranteed to have been processed).</p><p><a href="0601torjol4.html" target="_BLANK">Listing 4</a> shows you some examples of using <b>send_event</b> and <b>post_event</b>.</p><p>When you define your event class, you can specify some constraints: If the event can be sent and/or posted (by default, it can be both sent and posted). Sometimes, it doesn't make sense for an event to be sent or posted&#151;you can express that in code. For instance, you could have an event that returns the number of items in your window. If so, it's very likely you need this result now, so posting an event is completely useless (and semantically wrong). To indicate if your event can be sent and/or posted, you set:</p><ul>  <li><b>can_be_posted</b>: can be <b>true</b> (default) or <b>false</b>.</li>  <li><b>can_be_sent</b>: can be <b>true</b> (default) or <b>false</b>.</li></ul><p>For example:</p><pre>struct tri_click : ... {  enum {    can_be_posted = false  };};</pre><p>In this case, you've specified that the <b>tri_click</b> event can't be posted.</p><h3>Event Arguments</h3><p>When you create an event, you'll typically need some event arguments as well. When defining an event class, you can specify as many arguments as you wish, and hold them as data members&#151;as you would for any class (<a href="0601torjol5.html" target="_BLANK">Listing 5</a>). The library will make sure that the arguments are marshaled correctly.</p><h3>Listening to Events</h3><p>Once you've defined an event class, you can easily listen to it. There are two types of events:</p><ol>  <li>Events, which are sent to the window itself.</li>  <li>Notifications, which are sent to the window's parent.</li></ol><p>Assuming <b>tri_click</b> is an event, <a href="0601torjol6.html" target="_BLANK">Listing 6</a>(a) shows you how you'll listen to it. In case it's a notification, check out <a href="0601torjol6.html" target="_BLANK">Listing 6</a>(b).</p><p>Take another look at <a href="0601torjol6.html" target="_BLANK">Listing 6</a>(a)&#151;you'll notice the argument: <b>wm::tri_click::arg</b>. From a usability point of view, you can consider <b>wm::tri_click::arg</b> as a typedef for <b>'wm::tri_click *'</b>. Say <b>tri_click</b> looks like this:</p><pre>struct tri_click : ... {  ...  point pos;  time_t at;};</pre><p>In your event handler function, you can say:</p><pre>time_t t = a-&gt;at;point p = a-&gt;pos;</pre><p>And, you'll always know the window that generated this event:</p><pre>// note: I'm using a dot!wnd&lt;&gt; w = a.src_wnd();</pre><p>You'll notice that I've preserved existing practice&#151;the convention is the same as for the existing Win32 events/notifications.</p><p>Also, in case your event is a notification, you'll specify that in your class definition:</p><pre>struct tri_click : ... {  enum {    is_notification = true  };};</pre><p>In this case, <b>tri_click</b> is a notification.</p><p>Finally, note that usually, an event of the first type is an internal event (it doesn't need to be made available to clients of your class). You could consider making it an external event, if you plan to extend from your window class, and the derived class might want to send and/or listen to the event as well.</p><p>And now, for the hard part: Defining the external events, so that clients of your class can listen to them in a straightforward manner. To preserve existing practice (Listings 6(a) and 6(b)), you need to have some discipline. In your class's header, after you define your class, you'll define the events and/or notifications:</p><ul>  <li>You define events in the <b>wm</b> namespace.</li>  <li>You define notifications in the <b>ev</b> namespace, in the <b>template&lt;event_id_type id&gt;</b> struct <b>your_class_name</b> class.</li>  <li>You'll create a link between your class and your events: </li></ul><pre>template&lt;int ctrl_id&gt; struct                  events_for_class&lt;ctrl_id,your_class_name&gt; :                  public ev::your_class_name&lt;ctrl_id&gt; {};</pre><p><a href="0601torjol7.html" target="_BLANK">Listing 7</a> is an example to get you started.</p><h3>Event Filters</h3><p>There are times when you want to listen to multiple related events at once. You can always do it the old fashioned way, but it's error prone and not reusable; see <a href="0601torjol8.html" target="_BLANK">Listing 8</a>.</p><p>Therefore, I've improved this process&#151;you can now define event filters. Here's how:</p><pre>struct mouse_events :   event_filter&lt;mouse_events&gt; {    ...};</pre><p>You then override this function:</p><pre>bool operator()(const win32_enhanced_msg &amp; msg) const;</pre><p>If an event matches your filter, you should return <b>true</b>. Otherwise, <b>false</b>.</p><p>To simply check if one or more events match, use the <b>in()</b> function:</p><pre>return msg.in(  wm::mouse::left_down,  wm::mouse::right_down,  ...);</pre><p>This will check if the event is either <b>left_down</b> or <b>right_down</b>, and so on. To allow for this syntax, every event/notification has overloaded the comma (<b>,</b>) operator.</p><p>You can test for notifications coming from your child controls:</p><pre>return msg.in(   m_ok_::ev::clicked,  m_cancel_::ev::clicked);</pre><p>This will return <b>true</b> if the "OK" or "Cancel" buttons were clicked.</p><p>You can test for notifications coming from any child control of a given type:</p><pre>return msg.in(  ev::edit&lt;any_&gt;::kill_focus,  ev::list_box&lt;any_&gt;::kill_focus,  ev::combo_box&lt;any_&gt;::kill_focus,  ...);</pre><p>This will return <b>true</b> if there was a <b>kill_focus</b> notification coming from any child control.</p><p>Listing 9 (available online at http://www.cuj.com/code/) shows how to filter all mouse events, all keyboard events, and all <b>kill_focus</b> notifications (from existing win32gui controls).</p><p>Once you've created an event filter, you can listen to it, just like you would listen to a regular event. The beauty is that this is totally transparent to you, the programmer.</p><pre>handle_event mouse() { ...  return event_ex&lt;any_mouse&gt;()    .HANDLED_BY(&amp;me::mouse);}</pre><p>You'll find this useful on many occasions:</p><ol>  <li>When you want to respond in the same way to a group of events (all mouse events, all keyboard events, all painting events, and the like). For example, say you have a small application that usually runs in the background and is shown in the tray. If there is neither mouse movement nor keyboard movement for two minutes, you can decide to minimize.</li>  <li>When you want to emulate an event that does not exist on a platform or for a given control. For instance, say that the "double click" event does not exist for your platform. You could implement it as shown in Listing 10 (available online). Other examples: "selection changed" for list controls, <b>on_timer_X</b>&#151;which is to be called only for a specific timer ID (not for all <b>wm::timer</b> events).</li></ol><h3>Conclusion</h3><p>I started win32gui thinking that I'd go for only one platform (Win32). But after a few months, I've realized that a lot of the concepts I was implementing are platform independent. So, I've changed my focus&#151;and most of the features I've added could be easily ported to other platforms. Win32 is pretty mature now, and my focus now is to:</p><ul>  <li>Test using surfaces.</li>  <li>Port win32gui to other platforms (especially GTK).</li>  <li>Create utility applications that help create/maintain win32gui applications.</li>  <li>Enhance documentation.</li></ul><p>For that, I'll need all the volunteers I can get, so if you want to help, just drop me an e-mail and welcome aboard!</p><p>In the future, this column will change its focus: I will delve into other libraries that deal with GUIs and also analyze other platforms, such as Longhorn/Avalon.</p><h3>References</h3><ol>  <li>For the Win32 platform, this unique ID is an integer. However, for other     platforms, it might not be so.</li>  <li>Note that there's no marshaling of arguments from one application to the     other. Thus, in case the event has some arguments but the receiver application     can't access the sender application's memory, an Access Violation could occur.     In case you have such an event, I highly recommend that it doesn't have any     arguments. </li></ol><p><b>CUJ</b></p></body></html>