<html><head><title>January, 2006: TinC</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; C/C++ Users Journal--><p><i>C/C++ Users Journal</i>, January 2006</p><h1>TinC</h1><h2>Porting the Tiny compiler from Pascal to C</h2><h3>By Pete Gray</h3><I>Pete Gray is a programmer who specializes in embedded-systems development. He can be contacted at petegray@ieee.org.</I><hr><p>Several years ago, Jack W. Crenshaw wrote a series of articles entitled "Let's Build a Compiler"&#151;an introduction to compiler construction culminating in the Tiny compiler and language, coded in Pascal [1]. In this article, I describe how I ported, enhanced, and extended the Tiny compiler to make it a C-based pcode-generating, target-neutral compiler called "TinC." The complete source code for TinC is available from <i>CUJ</i> [2] and from my site [3].</p><p>Actually, rewriting Tiny 1.1 wasn't too difficult, mainly because it was originally written using crisp, clean code developed using the "keep it simple" principle. Another reason for the simplicity of the rewrite is that, in general, Pascal ports to C quite easily. (For that matter, there are also both free and commercial Pascal-to-C translators.)</p><p>Once ported, I began stripping the assembly-language generation out of the various compiler functions, replacing it with pcode-generating routine calls. To demonstrate a functioning compiler used with a specific target, Jack's original compiler necessarily generated assembly language directly from many levels and branches of the compiler's execution tree. As an example of pcode replacement, the routine performing the compiler function <b>push</b> <b>primary</b> was changed from:</p><pre>EmitLn("MOVE D0,-(SP)");</pre><p>to:</p><pre>Stage (PC_PUSH_PRIMARY,"","","");</pre><p>The use of pcodes as an intermediary language is a simple way of separating the high-level language being processed from the low-level language being generated. The high- and low-level languages become loosely coupled, but remain highly cohesive.</p><p>Another advantage of pcode generation is that instead of using the pcodes to immediately generate assembly language for the required target, they can be written to a staging buffer. Basically, the staging buffer is a big array full of pcodes sequenced in the order they were generated by the compiler. The population of a staging buffer also lets the pcodes be processed (optimized, for example) prior to assembly-language generation.</p><p>The original compiler was also interactive, which is good because you can see the generated code, and test enhancements on screen as you type in high-level source code. The new compiler processes either interactively or from an input file (if one is specified). I did this via a simple change to the <b>GetChar</b> routine. However, the introduction of the pcodes and staging buffer presented a slightly more complex problem, particularly when you consider pcode changes due to the addition of an optimizer. I resolved this issue by generating two output files&#151;one with the original pcodes and their generic descriptions, and the other that would be generated following the optimization and containing target-specific assembly language. This had the additional benefit of allowing the examination of pre- and postoptimization code to aid optimizer development. Interactively, the compiler first displays the preoptimized code, then the optimized code. I added line numbers for compilation error reporting, which are required for noninteractive processing. Finally, the addition of a compiler "smart trace," where the compiler shows its execution path among routines (indented, according to the call level), helped me understand the compiler operation, and assisted in compiler development. The trace information is automatically written to a third output file called "trace.txt."</p><h3>pcode Testing </h3><p>A set of test programs verified the correct operation of the compiler, staging mechanism, preoptimization pcode generation, and compiler trace. For example, the high-level code:</p><pre>result = 123</pre><p>produced the preoptimized pcodes with these descriptions: </p><pre>Move constant 123 to PrimaryMove Primary to global variable result</pre><p>and this output to the compiler trace file:</p><pre>+Assignment [result]   +Next     +GetOp     -GetOp [=]   -Next   +Next     +GetNum     -GetNum [123]   -Next</pre><h3>Tidying Up</h3><p>To finish off the initial port, I then split out the definitions into a header file, added new definitions representing such things as the maximum symbol size, keyword tokens, and so on, and renamed a few of the important variables. Most of the compiler routines I kept as-is to make it easy to reference from Jack's original text.</p><p>Nonglobal variables&#151;for example, variables that are declared for private use in a routine and have local scope&#151;are typically allocated space in a stack frame and referenced by the compiler via an offset using a Base Pointer. The Base Pointer is typically a register loaded with the Stack Pointer after local variables have been allowed for. However, this is complicated by various factors; for instance, depending on the target architecture, the natural growth of the stack may be either toward or away from memory location 0. The new compiler makes no assumption about stack orientation when generating pcodes. It simply calculates how much space is required for local variables, and passes this to the staging buffer as a pcode that says "Grow stack X units." Likewise, when the compiler encounters a local variable assignment, it passes the offset of the variable within the frame to the staging buffer. It's the back end of the compiler&#151;the assembly language generated by the pcodes&#151;that is written to make allowances for stack orientation and offsets.</p><h3>Data Types</h3><p>Data types are tricky, and more so when you allow for multiple (potentially different) target architectures. For example, take the classic <b>char</b> and <b>int</b> data types, typically represented internally by 1 and 2 bytes, respectively. Now, take an (imaginary) byte-oriented and word-oriented architecture, and compare. Make it easy, and say that a <b>char</b> occupies a word in the word-oriented architecture. <a href="0601grayt1.html" target="_BLANK">Table 1</a> lists the space required for declaring local variables.</p><p>For this example, both of the architecture's <b>PUSH/POP</b> mechanisms adjust the Stack Pointer by 1. It becomes obvious from <a href="0601grayt1.html" target="_BLANK">Table 1</a> that if you don't take the target architecture into account, the stack-frame/offset mechanism breaks. To allow for this, I defined <b>SIZEOFCHAR</b> and <b>SIZEOFINT</b>, and created the <b>SizeOfType() </b>function, which is used by the compiler when calculating storage-space allocation and stack-frame offsets. This lets you retarget the compiler between different architectures simply by changing definitions, rather than recoding the allocation and frame-offset routines.</p><h3>The Next Chapter: Arrays</h3><p>Arrays are where things got really interesting. Consider what this reference actually means:</p><pre>arrayname[element]</pre><p>It could be described as "the contents of the address specified by <b>arrayname</b>, modified by offset element." In fact, that's how I got the compiler to process it. Recognizing a global or local array declaration was simply a matter of having the declaration routines intercept the <b>[</b> and <b>]</b>, and adjusting memory allocation accordingly. To get the compiler to process array usage correctly, I had to consider the BNF (Backus-Naur Form) associated with assignments:</p><pre>&lt;assignment&gt;   ::= &lt;ident&gt; = &lt;expression&gt;&lt;expression&gt;   ::= &lt;first term&gt; ( &lt;addop&gt; &lt;term&gt; )*&lt;first term&gt;   ::= &lt;first factor&gt; &lt;rest&gt;&lt;term&gt;         ::= &lt;factor&gt; &lt;rest&gt;&lt;rest&gt;         ::= ( &lt;mulop&gt; &lt;factor&gt; )*</pre><p>Clearly then, when an assignment of the form:</p><pre>result = arrayname[element]</pre><p>is encountered, it should be treated as a factor. Due to the smart naming convention used in the original compiler, <b>Factor()</b> is the name of the function where arrays need to be intercepted. When an array reference is found, <b>Factor()</b> needs to process <b>element</b>. At the highest level, <b>element</b> should be regarded as a Boolean expression, which is kind of convenient because the compiler already contains a function, <b>BoolExpression()</b>, which leaves the result in the primary register. Given this collective knowledge, it would seem that in order for <b>Factor()</b> to process an array, it would need to:</p><ol>  <li>Call <b>BoolExpression()</b> to get the element.</li>  <li>Save the result to a secondary register.</li>  <li>Place the address of the array into the primary register.</li>  <li>Add the primary to the secondary.</li>  <li>Move [secondary] to the primary.</li></ol><p>However, this process could be problematic. It doesn't allow for the fact that you may be accessing an element of an array whose data type isn't aligned with the target architecture; for example, a word array on a byte-oriented target, which would cause the element calculation to be incorrect. Allowing for this, the enhancement to <b>Factor()</b> to allow for arrays looks like this:</p><pre>if (Token == '[') {        // an array element...  Next();  BoolExpression();        // evaluate element  MovePrimSec();           // save element to secondary  MatchString("]");  LoadAddrVar(SavedValue);  // load address of array to primary  AdjustSec(SavedValue);    // adjust secondary by array's 		         // data type  AddPrimSec();           // add primary to secondary  MoveSecIPrim();         // move [secondary] to primary  return;}</pre><p>That pretty much takes care of array use as a source, so I'll move on to when an array is a destination. This turns out to be similar, the main difference being that interception must happen within the compiler's <b>Assignment()</b> routine:</p><pre>if (Token == '[') {   // an array element...  Next();  BoolExpression();   // evaluate element  MovePrimSec();      // save element to secondary  MatchString("]");		  LoadAddrVar(Name);  // load address of array to primary  AdjustSec(Name);    // adjust element by array's data type  AddPrimSec();       // add primary to secondary  MatchString("=");  PushSec();          // push LHS (an address)  BoolExpression();   // process RHS  PopSec();           // pop LHS (an address) to secondary  MovePrimSecI();     // move primary to [secondary]  }</pre><p><b>LHS</b> and <b>RHS</b> refer to the left and right side of the assignment, respectively. Note that the secondary is now pushed before (and popped after) the <b>Assignment</b> routine processes the <b>RHS</b> by calling <b>BoolExpression</b>. This is to allow for the situation where you have arrays referenced on both sides of the assignment; for example:</p><pre>destination[this_element] = source[that_element]</pre><p>because the <b>BoolExpression</b> call to process the <b>RHS</b> will, eventually, call<b> Factor()</b> to process <b>that_element</b>, and <b>Factor()</b> uses the secondary register when an array is processed. Without the <b>PushSec</b> and <b>PopSec</b>, the address generated by the <b>LHS</b> would be overwritten when the <b>RHS</b> was processed.</p><p>Now consider the tricky cases of array usage; for example:</p><pre>result = array1 [ array2 [9] ]</pre><p>Not a problem&#151;the compiler already copes with it. Why? Because when <b>Factor</b> processes<b> array1[element]</b>, it calls <b>BoolExpression</b>, which calls <b>Factor</b> to process <b>array2[element]</b>, and so on. The <b>Factor</b> routine has, for want of a better term, become indirectly recursive. Just to verify, look at the generic output from the compiler, generated from the aforementioned case (number column added for descriptive purposes):</p><pre>1. Move constant 9 to Primary.   Move Primary to Secondary.   Move address of global variable array2 to Primary.   Add Primary to Secondary.2. Move [Secondary] to Primary.   Move Primary to Secondary.   Move address of global variable array1 to Primary.   Add Primary to Secondary.   Move [Secondary] to Primary.3. Move Primary to global variable result.</pre><p>Starting at Step 1, you see the offset (<b>9</b>) being loaded to primary and moved to <b>secondary</b>. <b>Primary</b> is then loaded with the address of <b>array2</b>, and added to <b>secondary</b>. This gives you the address of the value to be used as the offset into <b>array2</b>. At Step 2, the process starts again, but this time the offset is the current contents of the secondary; for example, <b>array2[9]</b>, and the base is <b>array1</b>. At Step 3, the final result is stored. As a side-note, observe how the first two pcodes are prime candidates for optimization (they become "Move constant <b>9</b> to Secondary").</p><p>I do need to clarify one thing regarding the use of the secondary register. You'll notice how I had to perform a push/pop operation  in the <b>Assignment</b> routine, due to the fact that the <b>Factor</b> routine, via <b>BoolExpression</b>, uses <b>secondary</b>. Well, as compiler development continues, you'll probably find that the frequency of secondary register usage increases&#151;particularly if you delve into the other realms of indirection, such as pointers. As this occurs, it will no longer be satisfactory for the <b>Factor</b> routine, for example, to simply use the secondary register and rely on the fact that other routines will save and restore the register at the appropriate time. The <b>Factor</b> routine itself, and any other routine requiring the secondary register, will need to save and restore the secondary before and after use. A suitable and more efficient control mechanism might be for the compiler to set an internal flag at the point where the secondary is used, and unset it when freed&#151;then other routines would "know" if they needed to push/pop the secondary before/after using it, simply by testing this "secondary in use" flag. The point being, of course, that regardless of which solution is used, this control mechanism must be implemented for the compiler to function properly.</p><h3>Conclusion</h3><p>Performing this port and enhancements clearly demonstrates the tight binding between the BNF and compiler structure. Because of the design of the original compiler, and the application of the simplicity principle, I was able to add array processing to the Tiny language using only a few dozen lines of code. Jack's Tiny compiler was&#151;and still is&#151;an excellent learning tool. I hope that porting it to C as a target-neutral, pcode-generating compiler with a few new bells and whistles is the first step of an ongoing evolutionary process. In the true spirit of the original&#151;and with Jack's blessing&#151;the new compiler is released as open source.</p><h3>References</h3><ol>  <li>http://compilers.iecc.com/crenshaw/.</li>  <li>http://www.cuj.com/code/. </li>  <li>http://home.comcast.net/~pete.gray/. </li></ol><p><b>CUJ</b></p></body></html>