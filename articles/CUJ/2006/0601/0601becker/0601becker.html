<html><head><title>January, 2006: STL and TR1: Part II</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; C/C++ Users Journal--><p><i>C/C++ Users Journal</i>, January 2006</p><h1>STL and TR1: Part II</h1><h2>The template class array</h2><h3>By Pete Becker</h3><I>Pete Becker is a software developer at Dinkumware Ltd., where he works on standard library implementation and documentation for C, C++, and Java. He is Project Editor for the C++ Standard, and for several years wrote a column for C/C++ Users Journal. He is currently writing a book about TR1. He can be contacted at petebecker@acm.org.</I><hr><p>Last month, we looked at iterators and algorithms, the fundamental abstractions that underlie the Standard Template Library. The TR1 Library doesn't add anything to either of these. It does, however, add several call wrapper types and five new containers. This month, we'll start looking at the new containers with the header<b>&lt;array&gt;</b>, and next month we'll look at the headers <b>&lt;unordered_set&gt;</b> and <b>&lt;unordered_map&gt;</b>.</p><p>As you can see from <a href="0601beckerl1.html" target="_BLANK">Listing 1</a>, the header <b>&lt;array&gt;</b> defines the template class <b></b><b>array</b>. It also defines the usual six comparison functions and a <b></b><b>swap</b> function to exchange the contents of two <b></b><b>array</b> objects. And, finally, it defines two template functions named <b></b> <b>get</b> and specializations of the two template classes<b></b><b>tuple_size</b> and <b></b><b>tuple_element</b>.</p><p>The details of the template class <b></b><b>array</b> are in <a href="0601beckerl2.html" target="_BLANK">Listing 2</a>. The template takes two arguments. The first is the type of the elements that the object will hold, and the second is the number of elements. Thus, like a C-style array, an <b></b><b>array</b> object holds a fixed-size array of objects. The similarity goes further, though: An <b></b><b>array</b> object can be initialized with an aggregate initializer, just like a C-style array [1]. <a href="0601beckerl3.html" target="_BLANK">Listing 3</a> shows this similarity. Note that the initializer for each of the arrays has fewer elements than the array being initialized; if you compile and run this program, you'll see that the extra elements in both arrays are initialized to 0.</p><p>Of course, you can also create <b></b><b>array</b> objects that hold elements of class types, and use aggregate initialization to construct the individual elements. When you do this, the values in the aggregate initializer are passed to the constructors of the individual elements. This is illustrated in <a href="0601beckerl4.html" target="_BLANK">Listing 4</a>.</p><p>According to the language definition, aggregate initialization only works for aggregate types. An array or class type is not an aggregate if it has any user-declared constructors, any private or protected nonstatic data members, any base classes, or any virtual functions. For the<i> <b></b></i><b>array</b><i> </i>template, this means that its only constructors are the two that the compiler generates: the default constructor and the copy constructor. Thus, you cannot, for example, initialize an<i> <b></b></i><b>array</b><i> </i>object from a sequence designated by a pair of iterators. In addition, since the size of an<i> <b></b></i><b>array</b><i> </i>object can't be changed, it can't have the commonly used container member functions<i> <b></b></i><b>insert</b><i>, <b></b></i><b>append</b><i>,</i> or<i> <b></b></i><b>erase</b><i>.</i> Despite all that, an<i> <b></b></i><b>array</b><i> </i>is a proper STL container, provided you apply the right definition of "container."</p><h3>The Template Class array as An STL Container</h3><p>The most basic form of a container is specified in a table with the title "Container requirements" in the C++ Standard. Every container must meet these requirements, and<i> <b>array</b></i><i> </i>does just that. The typedefs listed under the heading "Nested Types" in <a href="0601beckerl2.html" target="_BLANK">Listing 2</a>, other than<i> <b>reverse_iterator</b></i><i> </i>and<i> <b>const_reverse_ iterator</b></i><i>,</i> are the ones required for a container [2]. A container must also have a default constructor, a copy constructor, a destructor that destroys all of its elements, and an assignment operator that copies all of the elements from one object to another. For<i> <b>array</b></i><i>,</i> the compiler-generated versions of these functions do just what's needed. A container must also have the member functions<i> <b>begin</b></i><i> </i>and<i> <b>end</b></i><i>,</i> with each overloaded for<i> <b>const</b></i><i> </i>and non<b>const</b> containers. As you can see, they're in<i> <b>array</b></i><i>.</i> A container must also support all six comparison functions; they're in the header<i> <b>&lt;array&gt;</b></i><i>.</i> And finally, a container must provide the member functions<i> <b>swap</b></i><i>, <b>size</b></i><i>, <b>max_size</b></i><i>,</i> and<i> <b>empty</b></i> [3].</p><p>The Standard also has a table with the title "Reversible container requirements" that defines, obviously, a reversible container. A reversible container meets all of the requirements for a container, and it supplies two typedefs,<i> <b>reverse_iterator</b></i><i> </i>and<i> <b></b></i><b>const_reverse_iterator</b><i>,</i> as well as two member functions named<i> <b></b></i><b>rbegin</b><i> </i>and<i> <b></b></i><b>rend</b><i>,</i> with each overloaded for<i> <b></b></i><b>const</b><i> </i>and non<b>const</b> containers. As you can see from <a href="0601beckerl2.html" target="_BLANK">Listing 2</a>,<i> <b>array</b></i><i> </i>meets these requirements, too.</p><p>The requirements that<i> <b></b></i><b>array</b><i> </i>fails to meet are those set out in the table with the title "Sequence requirements." The requirements for a sequence container involve operations that change the size of the container; because an<i> <b></b></i><b>array</b><i> </i>type has a fixed size, it cannot satisfy these requirements. So it does not have a constructor that takes the desired size and an argument value; it does not have a constructor that takes a sequence designated by a pair of iterators; it doesn't have member functions<i> <b></b></i><b>insert</b><i>, <b></b></i><b>erase</b><i>,</i> or <b>clear</b>; and the only<i> <b>assign</b></i><i> </i>member function it has takes a single argument that is a reference to the element type, and copies that value into each of the elements.</p><p>In short,<i> <b></b></i><b>array</b><i> </i>is a reversible container, but not a sequence container.</p><h3>More Details</h3><p>As we've seen, you can initialize an<i> <b></b></i><b>array</b><i> </i>object with an aggregate initializer, and you can get at individual elements with<i> <b></b></i><b>operator[]</b><i>.</i> When called on a<i> <b></b></i><b>const array</b><i> </i>object, this operator returns a<i> <b></b></i><b>const</b><i> </i>reference to the element at the given index; when called on a non<b>const</b> object, it returns a non<b>const</b> reference. For a C-style array and for a TR1<i> <b>array</b></i><i> </i>object, using the index operator with an index value that's out of range produces undefined behavior. Just as with<i> <b></b></i><b>vector</b><i>,</i> though, if you want range-checked access to an<i> <b></b></i><b>array</b><i> </i>object, you can use the member function<i> <b></b></i><b>at</b><i>.</i> Of course, you can also do your own range checking, using the member function<i> <b></b></i><b>size</b><i>,</i> as shown in <a href="0601beckerl5.html" target="_BLANK">Listing 5</a>.</p><p>The member function<i> <b>assign</b></i><i> </i>takes a single argument whose type is a reference to the element type of the<i> <b>array</b></i><i> </i>type. It copies that argument into each element of the<i> <b>array</b></i><i> </i>object. <a href="0601beckerl6.html" target="_BLANK">Listing 6</a> demonstrates this, along with the<i> <b>swap</b></i><i> </i>member function. It also uses the<i> <b>begin</b></i><i> </i>and<i> <b>end</b></i><i> </i>member functions to get iterators to the beginning and the end of the<i> <b>array</b></i><i> </i>object's controlled sequence, and the member function<i> <b>rbegin</b></i><i> </i>and<i> <b>rend</b></i><i> </i>to get iterators that move through the sequence in reverse order.</p><p>Sometimes you need to get a pointer to the contents of an<i> <b>array</b></i><i> </i>object. For a C-style array this is easy: In most contexts, the name of an array decays into a pointer to its first element. For a TR1<i> <b>array</b></i><i> </i>object, the member function<i> <b>data</b></i><i> </i>gives you a suitable pointer [4]. You can use that pointer in the same way as the address of the first element of a C array, with the same restrictions. In particular, if you pass the pointer into a function that needs to know how many elements are in the array, you also have to pass the element count. <a href="0601beckerl7.html" target="_BLANK">Listing 7</a> illustrates this.</p><p>Unlike C-style arrays,<i> <b>array</b></i><i> </i>objects can be assigned. Of course, there's a trick to make C-style arrays assignable: Wrap the array inside a struct. That's what the template class<i> <b></b></i><b>array</b><i> </i>actually does, so being able to assign<i> <b></b></i><b>array</b><i> </i>objects simply falls out of their definition; see <a href="0601beckerl8.html" target="_BLANK">Listing 8</a>.</p><p>Finally, the member functions<i> <b></b></i><b>front</b><i> </i>and<i> <b></b></i><b>back</b><i> </i>return references to the first and the last elements in the<i> <b></b></i><b>array</b><i> </i>object, respectively. For a<i> <b></b></i><b>const array</b><i> </i>object, they return<i> <b></b></i><b>const</b><i> </i>references.</p><h3>Differences Between array Objects and C-Style Arrays</h3><p>Most of the things we've looked at so far can be done with<i> <b></b></i><b>array</b><i> </i>objects and with C-style arrays. The main benefit of using<i> <b></b></i><b>array</b><i> </i>objects for these things is the simpler syntax. In particular, since the number of elements in an<i> <b></b></i><b>array</b><i> </i>object is part of the object's type, we don't have to resort to macro tricks or global constants when we need to know how many elements to process. In addition, having the number of elements as part of an<i> <b></b></i><b>array</b><i> </i>object's type makes it much harder to accidentally intermix<i> <b></b></i><b>array</b><i> </i>objects with different numbers of elements. That's good if it prevents you from copying a large<i> <b></b></i><b>array</b><i> </i>object onto a smaller one, but it's bad if you need to write a function that takes arrays of arbitrary sizes. Of course, in the latter case, you can call the member function<i> <b></b></i><b>data()</b><i> </i>to get the raw array [5].</p><p>There's one fairly important thing you can do with C-style arrays that you can't do with<i> <b></b></i><b>array</b><i> </i>objects. You can't use the initializer alone to set the size of the array. With C-style arrays, you can do this:</p><pre>int carray[] = { 1, 1, 2, 3, 5 };</pre><p>and the result will be an array of five <b>int</b>s. With an<i> <b>array</b></i><i> </i>object, the size is a template parameter, so you must write it as part of the definition of the object. This makes it a little harder to ensure that an<i> <b></b></i><b>array</b><i> </i>has the same size as its initializer&#151;when you change the initializer you must also change the size argument.</p><p>There are two things you can do with<i> <b></b></i><b>array</b><i> </i>objects that you can't do with C-style arrays: You can create zero-sized objects, and you can treat them like<i> <b></b></i><b>tuple</b><i> </i>objects.</p><h3>Zero-Sized array Objects</h3><p>Unlike a C-style array, an<i> <b></b></i><b>array</b><i> </i>object can hold zero elements. You can define an<i> <b></b></i><b>array</b><i> </i>object that holds zero elements in the obvious way: Just pass 0 as the size argument.</p><p>Arrays of zero elements might not sound very useful, but as with loops that execute zero times, it's usually easier to write a single block of code that handles edge cases correctly than to deal with edge cases separately. Of course, code that uses<i> <b>array</b></i><i> </i>objects has to be written a bit more carefully if it can be called with a zero-sized object. In particular, indexing won't work (and the member function<i> <b>at</b></i><i> </i>will throw an exception whenever it's called), and<i> <b>front</b></i><i> </i>and<i> <b>back</b></i><i> </i>should not be called because their behavior is undefined. You can still use<i> <b>begin</b></i><i>, <b>end</b></i><i>, <b>rbegin</b>,</i><i> </i>and<i> <b>rend</b></i><i> </i>to get iterators to the controlled sequence. The STL algorithms that take iterator pairs will work correctly because they're designed to handle empty sequences correctly. And you can call<i> <b>data</b></i><i> </i>and pass the returned pointer to a function that takes a size argument and uses it correctly; see <a href="0601beckerl9.html" target="_BLANK">Listing 9</a>.</p><h3>The tuple-Like Interface to array</h3><p>Back in July 2005, we looked at the new TR1 template class<i> <b>tuple</b></i><i>,</i> which is a generalization of the Standard Library template class<i> <b></b></i><b>pair</b><i>.</i> An object of type<i> <b></b></i><b>array&lt;Ty, N&gt;</b><i> </i>is similar to an object of type<i> <b></b></i><b>tuple&lt;Ty, Ty, ...&gt;</b><i> </i>with<i> <b></b></i><b>N</b><i> </i>template arguments of type<i> <b></b></i><b>Ty</b><i>.</i> To exploit this similarity, TR1 provides specializations of the external accessors for<i> <b></b></i><b>tuple</b><i> </i>that can be used with<i> <b></b></i><b>array</b><i> </i>types. To get a reference to the<i> <b></b></i><b>n</b>th<i> </i>element of an<i> <b></b></i><b>array</b><i> </i>object at compile time, you can use the template function<i> <b></b></i><b>get&lt;n&gt;</b><i>.</i> To get the type of the<i> <b></b></i><b>n</b>th<i> </i>element of an<i> <b></b></i><b>array</b><i> </i>object, you can use the template<i> <b></b></i><b>tuple_element</b><i>,</i> and to get the size of an<i> <b></b></i><b>array</b><i> </i>object, you can use the template<i> <b></b></i><b>tuple_size</b><i>.</i> This is shown in <a href="0601beckerl10.html" target="_BLANK">Listing 10</a>.</p><h3>Summary</h3><p>The TR1 template class<i> <b>array</b></i><i> </i>holds a fixed-size array of objects of the same type. It can be used wherever a Reversible Container is needed, and it can stand in for a C-style array with simpler syntax and greater safety. There's very little reason to use C-style arrays anymore.</p><h3>Next Time</h3><p>Next time, we'll look at the four new container templates<i> </i><b>unordered_set</b><i>,   </i><b>unordered_multiset</b><i>, </i><b>unordered_map</b><i>,</i> and<i> </i><b>unordered_multimap</b><i>.</i>   They use hash tables to implement the interfaces required for<i> </i><b>set</b><i>,   </i><b>multiset</b><i>, </i><b>map</b><i>,</i> and<i> </i><b>multimap</b><i>.</i></p><h3>References</h3><ol>  <li>And unlike the rest of the STL containers.</li>  <li>Actually,<i> <b>pointer</b></i><i> </i>and<i> <b></b></i><b>const_pointer</b><i>     </i>aren't listed in the container requirements, but this looks like an oversight.</li>  <li> If you're reading the actual requirements from the C++ Standard and you     think it requires<i> <b>swap</b></i><i> </i>to execute in constant time (that     is, the time needed to swap the contents of two<i> <b>array</b></i><i> </i>objects     does not depend on the number of elements in the objects), you've been caught     by a subtlety of Standards language. The Standard says that<i> <b>swap</b></i><i>     </i>"should have constant complexity." That means it's recommended, but not     required. If it was required, the proper wording is "shall have constant complexity."</li>  <li> You might be tempted to use <b>&amp;arr[0]</b>, and in most cases that     will work. But, as we'll see later, an<i> <b>array</b></i><i> </i>object can     hold zero objects, and in that case there is no element at 0, so taking its     address won't work.</li>  <li> It's hardly ever appropriate to write a template function to do element-by-element     operations on<i> <b>array</b></i><i> </i>objects of different sizes. A function     that takes a pointer to the data and an element count is much simpler and     doesn't generate as much code. </li></ol><P><b>CUJ</b></p></body></html>