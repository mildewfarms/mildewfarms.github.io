<html><head><title>January, 2006: C++/CLI Serialization</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; C/C++ Users Journal--><p><i>C/C++ Users Journal</i>, January 2006</p><h1>C++/CLI Serialization</h1><h2>Converting objects to a form that can persist on disk or be transmitted to other processes</h2><h3>By Rex Jaeschke</h3><I>Rex Jaeschke is an independent consultant, author, and seminar leader. He serves as editor of the Standards for C++/CLI, CLI, and C#. Rex can be reached at http://www.RexJaeschke.com/.</I><hr><p>Most useful applications depend on information of a more permanent nature than that generated during a single execution. For example, applications that access an inventory typically query (and possibly update) one or more related data files. The lives of such "master files" transcend that of the execution of any of the applications that use them. Other applications involve the communication of messages between separate programs, often referred to as client and server. While the life of a message is often much shorter than that of a database record, the creation of both involves the use of some data format external to the applications that manipulate them.</p><p>This month, we'll see how objects can be converted into some external form suitable for use in file storage or for transmission during interapplication communication. The process of converting to some external form is known as "serialization," while that of converting back again is known as "deserialization." </p><h3>Introduction</h3><p>Consider the example in <a href="0601jaeschkel1.html" target="_BLANK">Listing 1</a>, which writes a number of values of a variety of object types to a new disk file, closes that file, and then reads those values back into memory again.</p><p>In case 1, we define a variable of type <b>BinaryFormatter</b>. Objects of this type allow the serialization and deserialization of any object or an entire graph of connected objects in some binary format. (We'll later see how alternate formats can be used.)</p><p>In case 2, we create a new file having the name shown. The suffix ".ser" has no special meaning; it's simply a local convention that signifies a serialized data file. Each of the cases 3a-3h results in an object being serialized to that file. In the case of the string, each character is written. In the case of the arrays, all elements are written. In the case of the <b>DateTime</b>, all data contained within that type and any associated dependencies are written. In the case of the primitive type values, they are first boxed and the corresponding objects are written. As such, <b>Serialize</b> need only be defined to accept an argument of type <b>Object^</b>.</p><p>We retrieve the serialized data by calling the function <b>Deserialize</b>, as shown in case 6a. Because that function returns a value of type <b>Object^</b>, we need to convert that to the appropriate type, which we do via a cast.</p><p>When executed on the date and time shown, the output in <a href="0601jaeschkef1.html" target="_BLANK">Figure 1</a> is produced.</p><h3>Serializing Objects  That Contain References</h3><p>In the previous example, we wrote and read relatively simple types. How is an object that contains numerous handles to other objects handled? Consider a dictionary of 20,000+ words, stored in a collection such that entries can be retrieved by key. The Standard Library provides such a collection class called <b>Hashtable</b>, which is used in the example shown in <a href="0601jaeschkel2.html" target="_BLANK">Listing 2</a>.</p><p>In case 1, we preallocate the <b>Hashtable</b> with an initial capacity of 21,000 entries. (This simply speeds up the process, as it does not require reallocation during the addition of a large number of entries.) Then we read in words, one per line, from a text file, and add each word to the <b>Hashtable</b> in case 2. The file "dictionary.txt" is available at http://www .cuj.com/code/. Note that, by definition, each entry in a <b>Hashtable</b> is composed of a key/value pair. However, because our key is the value, we use <b>nullptr</b> as the second argument.</p><p>Note that <b>Hashtable</b> key values must be unique, and that the type of any object being added must override <b>System::Object</b>'s <b>GetHashCode</b> function (<b>String</b> does).</p><p>Once all of the words have been read-in and added to the <b>Hashtable</b>, that <b>Hashtable</b> can be written out with one simple call to <b>Serialize</b>, as shown in case 4. In a separate application (see <a href="0601jaeschkel3.html" target="_BLANK">Listing 3</a>), we read in this dictionary and perform lookups on it for each word provided by the user. An example of some input and the corresponding output from this application is shown in <a href="0601jaeschkef2.html" target="_BLANK">Figure 2</a>.</p><p>The important lesson here is that we can serialize and deserialize an object of arbitrary size and complexity in a single function call.</p><h3>Dealing with  Multiple Handles</h3><p>It seems obvious that when we pass a handle to an object to <b>Serialize,</b> a copy of the underlying object is written; however, is that what is really happening? What if we write out an object that contains multiple handles to some other object, or we call <b>Serialize</b> twice, each time giving it a handle to the same object? Do we really want multiple copies of the same object to be written? The application shown in <a href="0601jaeschkel4.html" target="_BLANK">Listing 4</a> demonstrates this process.</p><p>In this example, we wish to serialize objects of type <b>Employee</b>, a user-defined type defined in case 1. For this to work, we must attach the attribute <b>Serializable</b> to that type, as shown. If we attempt to serialize an object of a class type that is not marked with this attribute, an exception of type <b>System::Runtime::Serialization::SerializationException</b> is thrown. The output produced before serialization is shown in <a href="0601jaeschkef3.html" target="_BLANK">Figure 3</a>.</p><p>Four graphs are serialized, one per call to <b>Serialize</b>. The first two graphs represent two different <b>Employee</b> objects while the third is really a reference to the second. The fourth graph is an array containing two elements, both of which refer to the first <b>Employee</b> object. The output shows these relationships. The output produced after deserialization is shown in <a href="0601jaeschkef4.html" target="_BLANK">Figure 4</a>.</p><p>Note how the third <b>Employee</b> handle is no longer a handle to the second; instead of two <b>Employee</b> objects represented by three graphs, we have three <b>Employee</b>s. Similarly, although <b>list[0]</b> and <b>list[1]</b> both refer to the same <b>Employee</b> object, that object is not the first one we got back.</p><p>We see then that when multiple graphs are serialized separately and they are interrelated, those relationships are not restored when those graphs are deserialized. However, relationships within any given graph are maintained.</p><h3>Customized Serialization</h3><p>By default, when an object is serialized, all nonstatic instance fields are written out and subsequently read back in during deserialization; however, for classes containing static fields, this can present a problem.</p><p>The example in <a href="0601jaeschkel5.html" target="_BLANK">Listing 5</a> uses class <b>Point</b>, which not only contains instance variables to track each <b>Point</b>'s <b>x</b>- and <b>y</b>-coordinates, but also keeps track of the number of <b>Point</b>s that have been created during this application's execution, in a static variable. This count is accessible via the property <b>PointCount</b>. For example, in <a href="0601jaeschkel5.html" target="_BLANK">Listing 5</a>, four <b>Point</b>s are created via explicit constructor calls, and then serialized to a disk file. When they are deserialized, four new <b>Point</b>s are created, so the total point count is now eight, as shown by the output in <a href="0601jaeschkef5.html" target="_BLANK">Figure 5</a>.</p><p>The output produced confirms that the point count field is being incremented correctly during deserialization. Now let's look at the <b>Point</b> class itself (see Listing 6, available online at http://www .cuj.com/code/).</p><p>Whenever a new <b>Point</b> is constructed using either of these public constructors, the point count field is incremented. A problem arises when we deserialize one or more <b>Point</b>s, however. A call to <b>Deserialize</b> for a <b>Point</b> effectively creates a new <b>Point</b> object, but it does not cause either of these constructors to be called for that object. Specifically, <b>PointCount</b> will not be incremented automatically, even though the number of new <b>Point</b>s has increased by 1. We can override the default serialization and/or deserialization behavior by implementing the interface <b>ISerializable</b> (from <b>System::Runtime::Serialization</b>), as in case 1. This interface requires us to define a function called <b>GetObjectData</b> having a specific signature, and that function allows us to override the serialization process.</p><p>The purpose of the function <b>GetObjectData</b> is to populate a <b>SerializationInfo</b> object with the data needed to serialize an object of the parent type&#151;in this case, <b>Point</b>. The name, value, and type information is provided to the function <b>AddValue</b>, which has overloads for all simple types and has <b>object</b> as the second argument. The name string can be arbitrary, so long as it is distinct for each value being serialized in this type. (If a duplicate name is used, a <b>SerializationException</b> is thrown.)</p><p>The <b>StreamingContext</b> parameter is ignored in this example; it need only be used in special circumstances, and is not discussed further here.</p><p>To override the deserialization process, we must define another constructor, also with a particular signature. Note that this constructor is private. Because it is only ever called by the deserialization machinery, there is no need to make it more accessible.</p><p>In cases 8a and 8b, we call <b>GetInt32</b> to restore the <b>x</b>- and <b>y</b>-coordinate values, respectively. (There is a <b>Get*</b> function for each primitive type as well as for type <b>String</b>.) In cases 9a and 9b, we call <b>GetValue</b> to restore the <b>y</b>- and <b>x</b>-coordinate values, respectively, again by name, by simply using an alternate approach. Finally, in case 10, we increment the counter for the <b>Point</b> being deserialized.</p><p>We've done all this work, just to increment one counter. Is all that work necessary? Yes! We need the special constructor so we can replicate the code that is executed when the other "normal" constructors are called (in this case, the incrementing of the counter). However, this special constructor is not called unless the interface <b>ISerializable</b> is referenced, and once we do that, we have to provide a definition for <b>GetObjectData</b> as well.</p><p>Another example of augmenting the serialization and deserialization process involves the calculation of checksums. When the object is written out, extra checksum information can be appended to the output stream and then read back in later to test the integrity of the data.</p><p>An example of replacement involves the use of encryption. Instead of writing a field's value out directly, that value is first encrypted, with the decryption being applied when the value is read back in.</p><h3>Identifying the  Fields to be Serialized</h3><p>The default serialization process causes all nonstatic fields to be written out and read back in; however, what if our class contains one or more fields whose values are of a temporary nature, with no utility beyond the current execution? How can we ensure that such a field's value will not be serialized? We achieve this via the attribute <b>NonSerialized</b> (see Listings 7 and 8, available online), which overrides the <b>Serializable</b> attribute that has been applied to the class as a whole. The output produced is shown in <a href="0601jaeschkef6.html" target="_BLANK">Figure 6</a>.</p><p>The fields <b>count</b> and <b>description</b> are serialized, while <b>temp1</b> and <b>temp2</b> are not. When an object is restored via default deserialization, all fields having the <b>NonSerialized</b> attribute take on their default values, such as <b>zero</b>, <b>false</b>, or <b>nullptr</b>, depending on their type.</p><h3>Serialization Format</h3><p>In all the examples of serialization thus far, we've used the type <b>BinaryFormatter</b>, which stores the data in some unspecified format that is compact and that can be processed efficiently. However, other formats are possible. For example, a SOAP formatter can be used. SOAP (Simple Object Access Protocol) is "a simple, XML-based protocol for exchanging structured and type information on the Web. The protocol contains no application or transport semantics, which makes it highly modular and extensible." Other custom formatters can also be created.</p><h3>Exercises</h3><p>To reinforce the material we've covered, perform the following activities:</p><ol>  <li>Using Listing 7 (available online) as the basis, implement <b>Pair</b> without using the <b>NonSerialized</b> attribute, by overriding the serialization and deserialization processes instead.</li>  <li>Listing 9 (available online) contains a generic vector class and application. The application serializes and deserializes <b>Vector</b>s of various types using the default process. Modify class <b>Vector</b>'s definition such that elements containing the default value are never saved during serialization, by overriding the serialization and deserialization processes. For example, a <b>Vector</b> of 10,000 <b>int</b>s, most of whose values are zero, should take much less space when stored in some sort of compressed format. Experiment with arrays having varying levels of sparseness and element count, comparing the size of the resulting serialized file. Make sure you consider the possibility of a function serializing multiple <b>Vector</b>s, possibly with other object and/or fundamental types in between. </li></ol><p><b>CUJ</b></p></body></html>