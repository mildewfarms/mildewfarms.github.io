


<html>
<head>
<title>February, 2006: STL and TR1: Part III</title>
</head>

<body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000">
<!--Copyright &#169; C/C++ Users Journal-->






<h4>Listing 5</h4>
<pre>
// synopsis of template class multimap

template &lt;class Key, class Ty,
  class Pr = std::less&lt;Key&gt;,
  class Alloc = std::allocator&lt;std::pair&lt;const Key, Ty&gt; &gt; &gt;
class multimap { // ordered container holding (Key, Ty) pairs
public:
    // NESTED TYPES
    typedef Key key_type;
    typedef Ty mapped_type;
    typedef Pr key_compare;
    typedef Alloc allocator_type;
    typedef std::pair&lt;const Key, Ty&gt; value_type;
    class value_compare;
    typedef Alloc::pointer pointer;
    typedef Alloc::const_pointer const_pointer;
    typedef Alloc::reference reference;
    typedef Alloc::const_reference const_reference;
    typedef T0 size_type;
    typedef T1 difference_type;
    typedef T2 iterator;
    typedef T3 const_iterator;
    typedef std::reverse_iterator&lt;iterator&gt; reverse_iterator;
    typedef std::reverse_iterator&lt;const_iterator&gt; const_reverse_iterator;

    // CONSTRUCTORS
    multimap();
    explicit multimap(const Pr&amp; pr);
    multimap(const Pr&amp; pr, const Alloc&amp; al);
    multimap(const multimap&amp; right);
    template &lt;class InIt&gt;
    multimap(InIt first, InIt last);
    template &lt;class InIt&gt;
    multimap(InIt first, InIt last, const Pr&amp; pr);
    template &lt;class InIt&gt;
    multimap(InIt first, InIt last, const Pr&amp; pr, const Alloc&amp; al);

    // MODIFICATION
    iterator insert(const value_type&amp; val);
    iterator insert(iterator hint, const value_type&amp; val);
    template &lt;class InIt&gt;
    void insert(InIt first, InIt last);

    iterator erase(iterator pos);
    iterator erase(iterator first, iterator last);
    iterator erase(cosnt Key&amp; key);
    void clear();

    void swap(multimap&amp; right);
  
    // CONTAINER ITERATORS
    iterator begin();
    const_iterator begin() const;
    iterator end();
    const_iterator end() const;
    reverse_iterator rbegin();
    const_reverse_iterator rbegin() const;
    reverse_iterator rend();
    const_reverse_iterator rend() const;

    // ELEMENT ACCESS
    iterator find(const Key&amp; key);
    const_iterator find(const Key&amp; key) const;
    size_type count(const Key&amp; key) const;
    iterator lower_bound(const Key&amp; key);
    const_iterator lower_bound(const Key&amp; key) const;
    iterator upper_bound(const Key&amp; key);
    const_iterator upper_bound(const Key&amp; key) const;
    pair&lt;iterator, iterator&gt; equal_range(const Key&amp; key);
    pair&lt;const_iterator, const_iterator&gt; equal_range(const Key&amp; key) const;

    // QUERIES
    size_type size() const;
    size_type max_size() const;
    bool empty() const;
    Alloc get_allocator() const;
    key_compare key_comp() const;
    value_compare value_comp() const;
};

template &lt;class Key, class Ty, class Pr, class Alloc&gt;
bool operator==(
  const multimap&lt;Key, Ty, Pr, Alloc&gt;&amp;,
  const multimap&lt;Key, Ty, Pr, Alloc&gt;&amp;);
/* analogous template functions for !=, &lt;, &lt;=, &gt;, and &gt;= */

template &lt;class Key, class Ty, class Pr, class Alloc&gt;
void swap(
  const multimap&lt;Key, Ty, Pr, Alloc&gt;&amp;,
  const multimap&lt;Key, Ty, Pr, Alloc&gt;&amp;);
</pre>



</body>
</html>
