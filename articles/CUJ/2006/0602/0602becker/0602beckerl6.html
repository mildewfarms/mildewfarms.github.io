


<html>
<head>
<title>February, 2006: STL and TR1: Part III</title>
</head>

<body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000">
<!--Copyright &#169; C/C++ Users Journal-->






<h4>Listing 6</h4>
<pre>
// synopsis of template class unordered_multimap

template &lt;class Key, class Ty,
  class Hash = std::tr1::hash&lt;Key&gt;,
  class Pred = std::equal_to&lt;Key&gt;,
  class Alloc = std::allocator&lt;Key&gt; &gt;
class unordered_multimap { // unordered container holding (Key, Ty) pairs
public:
    // NESTED TYPES
    typedef Key key_type;
    typedef Ty mapped_type;
    typedef std::pair&lt;const Key, Ty&gt; value_type;
    typedef Hash hasher;
    typedef Pr key_equal;
    typedef Alloc allocator_type;

    typedef Alloc::pointer pointer;
    typedef Alloc::const_pointer const_pointer;
    typedef Alloc::reference reference;
    typedef Alloc::const_reference const_reference;

    typedef T0 size_type;
    typedef T1 difference_type;
    typedef T2 iterator;
    typedef T3 const_iterator;
    typedef T4 local_iterator;
    typedef T5 const_local_iterator;

    // CONSTRUCTORS
    unordered_multimap(size_type nbuckets = N0,
        const Hash&amp; hfn = Hash(),
        const Pred&amp; pr = Pred(),
        const Alloc&amp; al = Alloc());
    template &lt;class InIt&gt;
    unordered_multimap(InIt first, InIt last,
        size_type nbuckets = N0,
        const Hash&amp; hfn = Hash(),
        const Pred&amp; pr = Pred(),
        const Alloc&amp; al = Alloc());
    unordered_multimap(const unordered_multimap&amp; right);

    // MODIFICATION
    iterator insert(const value_type&amp; val);
    iterator insert(iterator pos, const value_type&amp; val);
    template &lt;class InIt&gt;
        void insert(InIt first, InIt last);

    iterator erase(iterator pos);
    iterator erase(iterator first, iterator last);
    size_type erase(const key_type&amp; key);
    void clar();

    void swap(unordered_multimap&amp; right);

    // CONTAINER ITERATORS
    iterator begin();
    const_iterator begin() const;
    iterator end();
    const_iterator end() const;

    // ELEMENT ACCESS
    const_iterator find(const key_type&amp; key) const;
    size_type count(const key_type&amp; key) const;
    std::pair&lt;iterator, iterator&gt;
        equal_range(const key_type&amp; key);
    std::pair&lt;const_iterator, const_iterator&gt;
        equal_range(const key_type&amp; key) const;

    // QUERIES
    size_type size() const;
    size_type max_size() const;
    bool empty() const;

    allocator_type get_allocator() const;
    key_type key_eq() const;
    hasher hash_function() const;

    // TUNING
    local_iterator begin(size_type nbucket);
    const_local_iterator begin(size_type nbucket) const;
    local_iterator end(size_type nbucket);
    const_local_iterator end(size_type nbucket) const;

    size_type bucket_count() const;
    size_type max_bucket_count() const;
    size_type bucket_size(size_type nbucket) const;
    size_type bucket(const key_type&amp; key) const;

    float load_factor() const;
    float max_load_factor() const;
    float max_load_factor(float f);
    void rehash(size_type nbuckets);
};
</pre>



</body>
</html>
