


<html>
<head>
<title>April, 2005: Class Hierarchy Graphs, Function Devirtualization,  &amp; RTTI</title>
</head>

<body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000">
<!--Copyright &#169; C/C++ Users Journal-->

<h1>Class Hierarchy Graphs, Function Devirtualization,  &amp; RTTI</h1>
<p><i>C/C++ Users Journal</i> April, 2005</p>
<h2>A new approach to compiler optimization</h2>


<h3>By Dibyendu Das</h3>


<I>Dibyendu Das is a member of the C/C++ compiler back-end team at Hewlett-Packard for PA-RISC. He can be contacted at dibyend@ india.hp.com.</I>

<hr>





<p>Function devirtualization is a well-known compiler optimization technique for C++ code. This optimization replaces a call to a virtual method by a call to a particular method of a class, thus eliminating the overheads of accessing a virtual method via virtual table(s). In addition, the direct call may be inlined, leading to higher performance. Class Hierarchy Analysis (CHA) is one of the well-known techniques that are applied to find out whether a virtual call is devirtualizable. CHA is based on constructing the Class Hierarchy Graph (CHG) that encapsulates the base-class-derived class relationship among the classes that use virtual methods.</p>

<p>In this article, I present a new method of constructing the CHG that uses information generated by the C++ compiler for Run-Time Type Identification (RTTI). There are several advantages of this method over existing ones. For one thing, the C++ compiler front end need not emit any additional information for constructing the CHG in the optimizer. (Note that virtual methods in a class in one file may be overridden by a derived class in another file.) Information generated for RTTI is reused for this purpose. Because RTTI support is mandated by most C++ compilers, this method provides a universal mechanism for constructing the CHG. Also, the mechanism can be adopted by postlink-time optimizers or tools that inspect object code, enabling such tools or optimizers to carry out devirtualization at a very late phase.</p>
<h3>What Is Function Call Devirtualization?</h3>

<p>In <a href="0504dasl1.html" target="_BLANK">Listing 1</a>, the call to <b>get_val()</b> in <b>foo()</b> actually calls the function <b>get_val()</b> of class <b>A</b>. Normally, such virtual function calls are executed by using the virtual table pointers. These not only add overhead to the calling mechanism, but also block any form of inlining possible at the call point. The call to <b>get_val()</b> can be replaced by a direct call to <b>get_val()</b> of class <b>A</b> in the following manner:</p>

<pre>
return bp-&gt;A::get_val();

</pre>

<p>Automatic devirtualization in a compiler at static time requires knowledge of class hierarchy (knowing which subclasses have virtual functions that override those declared in their superclasses/base classes). For example, the call to <b>get_val()</b> can be rerouted to a call to <b>A::get_val() </b>by noting that class <b>B</b> does not override the virtual method named <b>get_val()</b> defined in class <b>A</b> (its base class). This analysis is termed the "Class Hierarchy Analysis" (CHA).</p>
<h3>Building the Class Hierarchy Graph</h3>

<p>The building block of CHA is the Class Hierarchy Graph (CHG). The CHG contains nodes, each of which represents a class; and edges, each of which represents a superclass-subclass relationship. For instance, if an edge points from node <b>x</b> to node <b>y</b>, then <b>x</b> is the superclass and <b>y</b> is the subclass. In addition, each node has a list of virtual functions defined in the class. <a href="0504dasf1.html" target="_BLANK">Figure 1</a> is the CHG for <a href="0504dasl1.html" target="_BLANK">Listing 1</a>. Both <b>A</b> and <b>B </b>access the same <b>get_val</b> function&#151;<b>A::get_val</b>. As defined in class <b>A</b>, <b>get_val()</b> is not overridden in class <b>B</b>.</p>

<p>Building the CHG is straightforward when all the class definitions are visible (in a single file, for instance). The situation is more complicated when the derived classes and the base classes are in different files, and the CHG needs to be constructed. In such cases, the compiler usually depends on a feature whereby all the compilation units are visible (for example, under the option <b>-ipo</b> for Intel and HP compilers or <b>+O4</b> or <b>+Owhole_program_mode</b> for a host of others). <a href="0504dasl2.html" target="_BLANK">Listing 2</a> illustrates this point. Class <b>A</b> is defined in file f1.H, while the derived class <b>B</b> is in f2.C. In addition, f1.C defines a function <b>DoSomething()</b> that takes a parameter that is a pointer to an object of type <b>A</b>.</p>

<p>Class <b>B</b> in file f2.C overrides the function <b>get_val()</b> defined in class <b>A</b> of f1.C. Hence, the CHG of <a href="0504dasf1.html" target="_BLANK">Figure 1</a> would change to that in <a href="0504dasf2.html" target="_BLANK">Figure 2</a>. It would now be impossible (statically) to infer from the CHG that the call to <b>pa-&gt;get_val()</b> in <b>DoSomething()</b> can be replaced by <b>pa-&gt;A::get_val()</b>. Why? Because a call to <b>DoSomething()</b> in some file can pass either objects of type <b>A</b> or of type <b>B</b> to the function as actual parameters. If an object of type <b>B</b> is passed, replacing the virtual call by a call to <b>A::get_val()</b> results in incorrect code. Such virtual method invocations can still be devirtualized by a technique known as "dynamic devirtualization," but that is beyond the scope of this discussion.</p>
<h3>Reusing RTTI Information</h3>

<p>In general, a C++ front end does not generate any specific information to encode the class hierarchy. However, most C++ compilers support RTTI. To aid RTTI, a C++ front end generates the type structure of the classes that make use of virtual function calls. This information is encoded in the intermediate code generated by the C++ compiler. When the optimizer examines the intermediate code, it deciphers and constructs the CHG from the type structure emitted to aid RTTI. </p>

<p>Vtable pointers are the first fields of objects that use virtual functions. They point to static vtable structures created for each class (there may be multiple vtable static structures for multiple/virtual inheritance). For class <b>A</b> of the example, there is a static structure named, say, <b>&lt;Vtable_A&gt;</b> that is created. One of its fields is a pointer that points to the <b>typeid</b> structure. One of the fields of the vtable also points to the virtual function <b>get_val()</b>. </p>

<p>By checking the vtable static variables (of the kind <b>&lt;Vtable_A&gt;</b>) that are created, the names of the classes and the virtual functions that are accessible from the virtual table can be inferred. Hence, the nodes as defined in <a href="0504dasf1.html" target="_BLANK">Figure 1</a> and the lists of virtual functions that are accessible can be constructed. But the edges between the nodes cannot be inserted by inspecting the vtable static variables. This is because the superclass-subclass information is absent in the vtable directly. For this purpose, the <b>typeid</b> structures that are created for each class (and which the respective vtables point to) need to be inspected.</p>

<p>The <b>typeid</b> structure encapsulates the type information of the class and is used for C++ calls such as <b>dynamic_cast</b>, <b>typeid</b>, and the like. This can be exploited to extract the superclass-subclass hierarchy. The interesting part of the <b>typeid</b> structure is a field that points to the base-class table. The base-class table is an array of pointers pointing to the <b>typeid</b> structures of the superclasses (base classes) of the class in question. <a href="0504dasf3.html" target="_BLANK">Figure 3</a> illustrates the vtable, <b>typeid</b>, and base-class structure for <a href="0504dasl1.html" target="_BLANK">Listing 1</a>.</p>

<p>From <a href="0504dasf3.html" target="_BLANK">Figure 3</a>, it is apparent that vtables (via <b>typeid</b> and <b>BaseClassTables</b>) encode the class hierarchy information. The base-class table of class <b>B</b> points to the <b>typeid</b> structure of class <b>A</b>, implying that <b>A</b> is the base class/superclass of <b>B</b>. The base-class table of <b>A</b> is empty, as it does not derive itself from any other class. The edge between node <b>A</b> and node <b>B</b> (in <a href="0504dasf1.html" target="_BLANK">Figure 1</a>) can now be constructed based on this information.</p>

<p>The algorithm (see <a href="0504dase1.html" target="_BLANK">Example 1</a>) becomes slightly more complicated in the presence of multiple/virtual inheritance, as multiple vtables are created for the same class. For these cases, the algorithm needs to be modified to merge all the nodes created for the same class to a single node and maintain the edge relationships accordingly. <a href="0504dasf4.html" target="_BLANK">Figure 4</a> illustrates the multiple-inheritance example in <a href="0504dasl3.html" target="_BLANK">Listing 3</a>.</p>

<p>There are two virtual tables&#151;<b>&lt;Vtable_C_1&gt;</b> and <b>&lt;Vtable_C_2&gt;</b>&#151;created for class <b>C</b>. Also, the <b>typeid</b> structure (<b>&lt;typeid_C&gt;</b>) is shared by both these vtables. This implies that if a node is created for each vtable following the <b>BuildCHG()</b> algorithm, then the CHG is represented as in <a href="0504dasf5.html" target="_BLANK">Figure 5</a>.</p>

<p>The representation in <a href="0504dasf5.html" target="_BLANK">Figure 5</a> is wasteful because <b>&lt;Vtable_C_1&gt;</b> and <b>&lt;Vtable_C_2&gt;</b> carry similar information. Therefore, it is advisable to merge these nodes to create a single node for class <b>C</b>. </p>
<h3>When RTTI Is Disabled</h3>

<p>Some compilers (such as g++) support options (<b>-fno-rtti</b>, for instance) to disable RTTI information for code that is known not to use RTTI functionality. In such cases, compilers can still generate the RTTI information for the optimizer. However, the concluding passes of the optimizer can throw away the RTTI information after devirtualization has been put into effect. The final executable will not contain the RTTI information as expected from a <b>-fno-rtti</b>. </p>
<h3>Conclusion</h3>

<p>I've shown here how the CHG can be built from the information generated to aid RTTI by a C++ front end. The method presented can also be tailored to extract the CHG from the executable/object files easily without depending on any additional information. Also, the method is generic enough to be adopted by other compilers.</p>
<h3>References</h3>

<ol>
  <li>Bacon, D.F. and P.F. Sweeney. "Fast Static Analysis of C++ Virtual Function Calls," OOPSLA 1996.</li>
  <li>Aigner, G. and U. Holzle. "Eliminating Virtual Function Calls in C++ Programs," ECOOP 1996.</li>
  <li>Dean, J., D. Grove, and C. Chambers. "Optimization of Object-Oriented Programs Using Static Class Hierarchy Analysis," Tech Report, Dept. of CSE, University of Washington, 1994.</li>
  <li>Porat, S., D. Bernstein, Y. Fedorov, J. Rodrigue, and E. Yahav. "Compiler Optimization of C++ Virtual Function Calls," Usenix 1996.</li>
  <li>Bacon, D.F. "Fast and Effective Optimization of Statically Typed Object-Oriented Languages," Ph.D. Thesis, UC Berkeley, 1997. </li></ol>






</body>
</html>