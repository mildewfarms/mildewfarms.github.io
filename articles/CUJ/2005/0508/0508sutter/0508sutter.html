


<html>
<head>
<title>August, 2005: Trip Report:  April 2005</title>
</head>

<body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000">
<!--Copyright &#169; C/C++ Users Journal-->

<h1>Trip Report:  April 2005</h1>
<p><i>C/C++ Users Journal</i> August, 2005</p>
<p>
<i>News and views from the Spring 2005 C and C++ Standards meetings. The big news: The C++ evolution working group has set this fall as the deadline for new proposals, after which we'll be heads-down trying to finish most of the technical work next ISO C++ Standard by 2007 so that the new Standard can be published in 2009. </i>
</p>


<h3>By Herb Sutter</h3>


<I>Herb Sutter (http://www.gotw.ca/) chairs the ISO C++ Standard committee and is a software architect in Microsoft's Developer Division. His most recent books are Exceptional C++ Style and C++ Coding Standards.</I>

<hr>





<p>The Spring 2005 ISO C and C++ Standards meetings were held in Lillehammer, Norway from April 17-22, 2005; the minutes are available at [1]. Both committees continue to meet twice a year; the next meetings will be in sunny Mont Tremblant, Quebec, Canada on September 26 through October 8, 2005. (See my previous trip report [2] for details about the previous meeting, held in fall 2004 in not-as-sunny-at-the-time Redmond, WA, USA.)</p>

<p>The ISO C [3] meeting focused primarily on completing most of the technical work on the Safe C++ Technical Report (TR) [4], which is a document that provides safer replacements for unsafe C standard library functions (for example, <b>strcpy_s</b> instead of <b>strcpy</b>). C and C++ are continuing to coordinate parts of their work, most recently on preprocessor (macro) extensions and on decimal floating-point types.</p>

<p>For the rest of this article, I go into more detail about the ISO C++ [5] meeting, where we focused on completing the first round of Standard Library extensions, and set a date for the new C++0x Standard itself. I'll start with the latter.</p>
<h3>Big News in C++:  assert( "C++0x" &amp;&amp; x == 9 );</h3>

<p>The big news at this ISO C++ meeting is that "C++0x" intends to be "C++09," meaning that we do intend to ship a new standard this decade. </p>

<p>That may seem a long way off, but it's really pretty aggressive. Because of ISO balloting procedures, that means that the work needs to be pretty much technically complete by the end of 2007. This aggressive schedule leaves only five meetings to complete the bulk of the technical work. If we make that target, then 2008 will be spent on the first round of international balloting and review, and the committee will spend its two meetings that year doing the resulting cleanup and refinement work to produce the (hopefully) final text of the Standard by the end of 2008. Assuming that the result is acceptable to all of the national bodies and addresses any comments they sent, then we can spend 2009 on the second round of international balloting to approve the text and publish the Standard. </p>

<p>If we keep to this schedule, then by the end of 2007, you'll know what features will be in the next Standard and have a good idea of the details of how they'll work, and by the end of 2008 even the details will be fully nailed down. (Caveat: The C++ committee has slipped its schedule before. On the bright side, if we miss that date and publish the Standard in 2010 or 2011, we can always claim it's still "C++0x" but that "x" just turned out to be a hex digit.)</p>

<p>One consequence is that this year, the C++ committee is going to close the door on new suggestions for this revision of the Standard. Now that we've been actively soliciting submissions for three years, and we've received and reviewed in detail at least scores (and possibly hundreds) of proposals, we've set the deadline for new proposals for the fall 2005 C++ meeting to be held on October 2-8. Note that the premeeting mailing deadline is usually set for six weeks before the meeting, so if you're sitting on a secret proposal you've never shown the outside world but that you think is thoroughly baked and you want to see in C++0x, know that that's when papers are due (and you'd be best of getting feedback on the comp.std.c++ newsgroup first, because a fair number of proposals turn out to be repeats of things that have already been considered in depth and rejected, often numerous times). After the fall 2005 meeting, the committee will, of course, still be generating and considering new papers that refine and progress existing work that is already in the pipeline, but the chances are slim that a brand-new proposal will get traction. You never know, but coming in with anything after that isn't an advisable bet.</p>
<h3>C++ Library Evolution</h3>

<p>While working on the next Standard, we've also been doing off-to-the-side work on a new batch of Standard Library extensions that we'll be delivering before the next Standard. In fact, we're delivering them now: At this meeting, we completed all technical work on this first set of Standard Library extensions (also known as "Library Extensions Technical Report 1," or "Library TR1," or just "TR1"). See [6] for the latest draft as of this writing, which was the draft going into the Lillehammer meeting; at the meeting we voted in some tweaks and will soon produce the document to go out for final ISO balloting (which might be in progress already when you read this). </p>

<p>If you're interested in details about TR1, definitely check out Pete Becker's column in the June and July 2005 issues of <i>CUJ</i>. He's several installments into a column about TR1, and he's also writing a whole book about it. It's sure to be recommended reading. This batch of extensions includes support for new smart pointers (<b>shared_ptr</b>), hash-based containers (for example, <b>unordered_set</b>), type traits, random-number generators, regular expressions, <b>tuple</b> types, a generalized <b>function</b> wrapper, and other stuff including a slew of mathematical functions. I've already written about many of these (see [7], including articles like the one on Generalized Observer), and Pete will write about more.</p>

<p>But just because TR1 is done doesn't mean there won't be further library extensions. Far from it. And, to encourage people, we have issued a call for further library extension proposals [8]. The introduction says it so well that I'll quote it directly:</p>

<blockquote>
The C++ standardization committee is now soliciting proposals for a second technical report on standard library extensions, "TR2." The committee will consider both proposals that address entirely new domains, and proposals to modify the existing standard library.<br>
The committee especially welcomes proposals in the following areas: <br>
<br>
&#8226;	Unicode <br>
&#8226;	XML and HTML <br>
&#8226;	Networking <br>
&#8226;	Usability for novices and occasional programmers <br>
<br>

<pre>
     Although each proposal will be evaluated on its own merits, the committee is more interested in high-level libraries that solve day-to-day problems of application programmers than in low-level infrastructure.

</pre>

</blockquote>

<p>Again, these library TRs are batches of extensions being done "off to the side," not (yet) in the next draft standard. So what do TR1 and TR2 mean for C++0x? Clearly they're extensions that people are serious about, and particularly for TR1 they're extensions that are likely to be on a path to get into the next Standard, but nothing is a slam dunk and some parts might not go in and some might be changed based on feedback from the field (one of the advantages of doing a TR). Here is the current provisional schedule for the library working group, showing the plan for making decisions about adopting TR1 components into the next Standard as well as for TR2 work:</p>

<ul>
    <li>October 2005: Cutoff date for new proposals to C++0x. </li>
  <li>October 2006: Decision on the adoption of components from TR1 for C++0x. </li>
  <li>October 2006: Cutoff date for initial proposals to TR2. </li>
  <li>April 2007: Cutoff date for clean-up papers for C++0x.</li>
  </ul>

<p>We can fairly confidently expect at least large parts of TR1 to become standard. As for TR2, depending on how quickly its proposals progress and how quickly C++0x itself is going, it might be possible to adopt part of TR2 into C++0x, or even roll TR2 into C++0x. For now, we're keeping the TR2 library work in a separate bucket to better manage the scope of C++0x and enable us to easily ship C++0x on time and ship TR2 out-of-band as a separate deliverable if it turns out that that's more convenient.</p>
<h3>C++ Language Evolution and C++0x:  What a Concept!</h3>

<p>If you haven't yet read Stroustrup's article "The Design of C++0x"  in the June 2005 issue of this magazine, please run&#151;don't walk&#151;and read it [9].</p>

<p>Concretely, in Lillehammer we adopted the first two major additions to the C++ language; this marks the first time since 1997 that the core (draft) Standard language itself has changed. The two items we voted in were C99's <b>long long </b>and the <b>static_assert</b> facility. Modest additions, to be sure, but they're just the start.</p>

<p>     C99 <b>long long </b>is just what it appears to be: <b>long long </b>is now (draft) Standard C++. I could (and did) make the usual jokes, such as that we talked about this issue for a <b>long long </b>time (which happens to actually be true; it's been discussed during at least the past three C++ meetings).</p>

<p><b>static_assert </b>is described in [10]. The basic idea is to have compile-time assertions without today's hacking around the lack of language support in current ISO C++.</p>

<p>There's a lot of other, and much bigger, work underway. A notable example is concepts [11, 12], which are completely complementary to <b>static_assert</b>. The idea of concepts is to be able to declare flexible and powerful constraints on templates that will vastly improve the quality of template error messages and overall template usability and type safety. For example, type in this program and compile it under your favorite compiler:</p>

<pre>
#include &lt;algorithm&gt;
int main() {
  int i = 0, j = 2;
  std::sort( i, j );
}

</pre>

<p>Of course this program shouldn't work, and it won't because <b>std::sort</b> expects two iterators, and <b>i</b> and <b>j</b> are integers, not iterators. Here the idea of an "iterator" is an example of a concept: It's a type that you can do certain things with, including dereference using unary <b>* </b>and get a certain type as the result. Clearly, an <b>int</b> isn't something you can dereference, but the best of today's compilers won't say so and instead give you an unduly hard time about it.</p>

<p>For the aforementioned program, some compilers spew back only a half-screen of error messages; others give you multiple screens. Today's templates are only fully checked at the point where they are actually used, or instantiated. Clearly, we'd prefer to get a single message that tells us exactly what the problem is and how to fix it, something like, "Hey, stupid, <b>i</b> and <b>j</b> aren't iterators," but today's compilers don't give warnings like that. (Even better, we'd like to easily provide overloads of the same algorithm that each apply only to a given category of iterators.)</p>

<p>This is where concepts come in. Instead of the standard definition:</p>

<pre>
template&lt;class RandomAccessIterator&gt;
void sort(RandomAccessIterator first, RandomAccessIterator last);

</pre>

<p>we'd like to make a concept called <b>RandomAccessIterator</b>, for example (this is speculative syntax):</p>

<pre>
concept RandomAccessIterator&lt;class T&gt; {
  ... definition of what a RandomAccessIterator&lt;T&gt; should be able to do,
  such as increment, dereference, etc. ...
};

</pre>

<p>and then define <b>sort</b> as:</p>

<pre>
template&lt;class T&gt;
void sort(RandomAccessIterator&lt;T&gt; first,
         RandomAccessIterator&lt;T&gt; last);

</pre>

<p>This would enable us to write mistakes like:</p>

<pre>
int i = 0, j = 2;
std::sort( i, j );	// line 7

</pre>

<p>and get decent errors like:</p>

<pre>
error (line 7): hey, stupid, i and j aren't
                   RandomAccessIterators

</pre>

<p>instead of screenfuls of errors. It would also enable authors of templates like <b>sort</b> to easily overload based on iterator category, without bending over backwards through idiomatic tagging machinery like we do today:</p>

<pre>
// overload on the iterator category

template&lt;class T&gt;
void sort(RandomAccessIterator&lt;T&gt; first, 
         RandomAccessIterator&lt;T&gt; last);

</pre>

<p><b></b></p>

<pre>
template&lt;class T&gt;
void sort(BidirectionalIterator&lt;T&gt; first, 	BidirectionalIterator&lt;T&gt; last);

</pre>

<p>Even just considering iterators, you can quickly see the benefits of having first-class support for expressing declarative constraints on template parameters. The alternative is what we do today for iterator categories: They are currently specified, not in the language, but in documentation in the form of tables of "should work like this" in the standard. Compilers have a hard time enforcing English documentation. They have a much better time enforcing abstractions with nailed-down definitions supported right in the language.</p>

<p>That's just a quick sketch of concepts. Expect many more articles on this in the coming year as the concept proposals get baked and refined.</p>
<h3>Summary</h3>

<p>C++ is vibrant and alive. ISO C++ v2 is well underway and could be done in as soon as two years. There's a lot to be happy about, and to write and learn about, in these and other pages as the world gets further glimpses into the first 21st-century Standard C++.</p>
<h3>References</h3>

<ol>
  <li>[1]	R. Klarer. "Minutes of J16 Meeting No. 40/WG21 Meeting No. 34, April 11-15, 2005" (ISO C++ committee paper ISO/IEC JTC1/SC22/WG21/N1789, April 2005). This document is available online at http://www.open-std.org/jtc1/sc22/wg21/docs/ papers/2005/n1789.html.</li>
  <li>[2]	H. Sutter. "Trip Report: October 2004" (<i>C/C++ Users Journal</i>, 23(1), January 2005).</li>
  <li>[3]	The official web site for the ISO C committee is http://www.open-std.org/jtc1/sc22/wg14/.</li>
  <li>[4]	R. Meyers, ed. "Working Draft of Security Technical Report" (ISO C committee working document ISO/IEC JTC1/SC22/WG14/N1078, September 2004). This document is available online at http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1078.pdf.</li>
  <li>[5]	The official web site for the ISO C++ committee is http://www.open-std.org/jtc1/sc22/wg21/.</li>
  <li>[6]	M. Austern, ed. "Proposed Draft Technical Report on Standard Library Extensions" (ISO C++ committee working document ISO/IEC JTC1/SC22/WG21/N1745, January 2005). This document is available online at http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1745.pdf.</li>
  <li>[7]	http://www.gotw.ca/publications</li>
  <li>[8]	H. Hinnant, B. Dawes, and M. Austern. "Library Extension TR2 Call for Proposals" (ISO C++ committee paper ISO/IEC JTC1/SC22/WG21/N1810, April 2005). This document is available online at http://www.open-std.org/jtc1/sc22/wg21/docs/ papers/2005/n1810.html.</li>
  <li>[9]	B. Stroustrup. "The Design of C++0x" (<i>C/C++ Users Journal</i>, 23(6), June 2005).</li>
  <li>[10]	R. Klarer, J. Maddock, B. Dawes, and H. Hinnant. "Proposal to Add Static Assertions to the Core Language (Revision 3)" (ISO C++ committee paper ISO/IEC JTC1/SC22/WG21/N1720, October 2004). This document is available online at http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1720.html.</li>
  <li>[11]	B. Stroustrup and G. Dos Reis. "A concept design (rev. 1)" (ISO C++ committee paper ISO/IEC JTC1/SC22/WG21/N1782, April 2005). This document is available online at http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1782.pdf.</li>
  <li>[12]	J. Siek, D. Gregor, R. Garcia, J. Willcock, J. Jdrvi, and A. Lumsdaine. "Concepts for C++0x" (ISO C++ committee paper ISO/IEC JTC1/SC22/WG21/N1758, January 2005). This document is available online at http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1758.pdf. </li></ol>






</body>
</html>