


<html>
<head>
<title>December, 2005: Adapting  Interface-Incomplete Types At Compile Time</title>
</head>

<body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000">
<!--Copyright &#169; C/C++ Users Journal-->






<h4>Example 5: Definition of the <i>has_value_type</i> used for detecting whether a class has a <i>value_type member</i> type.</h4>
<pre>
typedef struct { char ar[1]; }    one_t;
typedef struct { char ar[2]; }    two_t;

template &lt;typename T&gt;
one_t has_value_type_function(...);

template &lt;typename T&gt;
two_t has_value_type_function(typename T::value_type const volatile *);

template &lt;typename T&gt;
struct has_value_type
{
  enum { value = sizeof(has_value_type_function&lt;T&gt;(0)) == sizeof(two_t) };
};
template&lt;&gt;
struct has_value_type&lt;void&gt;
{
  enum { value = 0 };
};
</pre>



</body>
</html>
