


<html>
<head>
<title>October, 2005: Event Dispatching  &amp; the GED Library</title>
</head>

<body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000">
<!--Copyright &#169; C/C++ Users Journal-->

<h1>Event Dispatching  &amp; the GED Library</h1>
<p><i>C/C++ Users Journal</i> October, 2005</p>
<h2>A generic library for event-driven development</h2>


<h3>By Bo Xu</h3>


<I>Bo Xu is a software developer for Reuters and can be contacted at bo.xu.ca@gmail.com.</I>

<hr>





<p>With event-driven programs, event dispatchers act as central control agents that poll for events from event sources, invoking event handlers as necessary. Generally, there are different types of event sources, each with its own mechanism for generating events:</p>



<ul>
  <li>I/O event sources (sockets), which are common in networked applications.</li>
  <li>Timer event sources, in which operating-system timers are used to activate certain tasks of the applications.</li>
  <li>Signal event sources, including interruptions such as the UNIX <b>signal</b> generated by Ctrl-C. Some applications need to handle such signals.</li>
  <li>UI event sources, such as those in GUI environments (Windows and X-Windows, for instance) in which key strokes and mouse clicks generate events.</li>
  <li>Third-party messaging APIs that applications have to deal with. </li>
</ul>



<p>In general, each application or application platform has its own way of dispatching events. While similar, these dispatchers aren't quite the same. Moreover, many existing event dispatchers are difficult (if not impossible) to extend at the event-source level. By design, Windows and X-Windows are UI oriented, making it awkward to plug in support of third-party messaging events. In many instances, a software-development organization keeps event-dispatching routines in a library that is shared by different projects across the organization. Supported event sources are then hard-coded in the library, making it impossible to add new event sources without modifying the library code. Finally, there appears to be a lack of generic event-dispatching mechanisms that might address some of these problems.</p>

<p>In this article, I present just such a generic event dispatcher (GED) library that:</p>



<ul>
  <li>Captures the commonalities found in event dispatching of normal event-driven applications.</li>
  <li>Is extendible at event-source level, letting you add new event sources without changing the library's code.</li>
  <li>Describes events, event sources, event dispatchers, and their relationships in C++ so that extending a new event source is straightforward.</li>
</ul>



<p>The complete source code for the GED library is available at http://www.cuj.com/code/.</p>
<h3>Top-Level Design</h3>

<p>There are three kinds of objects: dispatchers, event sources, and events. The dispatcher class has the following functionality and characteristics:</p>



<ul>
  <li>There is only one global object in this class&#151;a singleton class.</li>
  <li>It works with event objects polymorphously in the way that it interacts with an abstract class that represents various, real event objects.</li>
  <li>It maintains a priority queue of triggered events. This priority is ordered by some kind of time stamp when an event is fired. This is to ensure synchronization of event processing, which is critical in stateful applications.</li>
  <li>It has a main loop for polling each event source in a nonmultithreading environment or for block-waiting in a multithreading environment.</li>
  </ul>

<p>How the dispatcher class interacts with event-source classes depends on whether the platform is multithreading. In nonmultithreading environments, the dispatcher must poll each event source so that event-source objects are visible to the dispatcher. In other words, an event-source object needs to register itself to the dispatcher. Nevertheless, with multithreading, it falls into a consumer-producer model. The dispatcher consumes fired events by calling event handlers regardless of their sources, while each event-source object produces (fires) events on its own thread. This makes event-source objects transparent to dispatchers. The design I implement in this article is based on a nonmultithreading environment, so the dispatcher maintains a queue for working with registered event-source objects polymorphously.</p>

<p><a href="0510xul1.html" target="_BLANK">Listing 1</a> includes the classes <b>EventDispatcher</b>, <b>EventSourceProxy</b>, and <b>EventProxy</b>. The <b>EventDispatcher</b> class is a concrete <b>Singleton</b> class. The single object can only be accessed by calling the friend function <b>theDispatcher()</b> [1]. In the <b>loop()</b> method, the dispatcher calls the polling function of each registered event source, while in the <b>pollEvent()</b> method of an event source, the event-source object puts fired events (if any) to the dispatching queue. Afterwards, the dispatcher invokes the <b>eventProcess()</b> of each event in the dispatching queue in the order of priority.</p>

<p>The constructor of the <b>EventSourceProxy</b> class calls the <b>eventSourceRegister()</b> method of the dispatcher to register itself. This is a so-called "self registration" [2], which facilitates automatic runtime binding of an event source to the dispatcher.</p>

<p>The <b>EventProxy</b> class provides a set of common interfaces of an abstract event object. The <b>eventProcess()</b> method is the interface for the dispatcher. It has a timestamp data member and <b>operator &gt;</b> for ordering event objects in the dispatcher's priority queue. An event object may self-destruct at the end of its lifetime. To enable this, the design only allows an event object to be created on the free storage (the heap) with the <b>new</b> operator. Consequently, I purposely put the virtual destructor in the protected access mode [1]. The member data, <b>m_restore</b>, indicates whether the object is self-destructive or not.</p>
<h3>Concrete Event-Source Class  And Concrete Event Classes</h3>

<p>Given a concrete event source and events, say timer, should the timer event-source class be derived from <b>EventSourceProxy</b> and the timer event class from <b>EventProxy</b> directly? Before answering, note that there is something missing. The proxy classes are mainly interfaces to the dispatcher. They do not depict the relationship between event sources and events. For example, a timer event source can only fire timer events. On the other hand, a timer event can only be triggered by a timer event source. It is more challenging in C++ to specify relationships between objects than to describe the object itself. My method is to add another layer of abstraction to the class hierarchy. In <a href="0510xul2.html" target="_BLANK">Listing 2</a>, I introduce two class templates: <b>EventSource&lt;T_EVENT&gt;</b> and <b>Event&lt;T_SRC&gt;</b> (for readability, I change in <a href="0510xul2.html" target="_BLANK">Listing 2</a> the formal name <b>&lt;T&gt;</b> to <b>&lt;T_EVENT&gt;</b> or <b>&lt;T_SRC&gt;</b> in its proper context). Any concrete event source class is to be derived from <b>EventSource&lt;T_EVENT&gt;</b> and any concrete event class from <b>Event&lt;T_SRC&gt;</b>. </p>

<p>For class template <b>EventSource&lt;T_EVENT&gt;</b>:</p>



<ul>
  <li>Any specification of <b>EventSource&lt;T_EVENT&gt;</b> is a derivation of <b>EventSourceProxy</b> that has an interface with the dispatcher.</li>
  <li>The template parameter <b>T_EVENT</b> cannot be an arbitrary class as generalized programming usually intends. It has to be a subclass of <b>EventProxy</b>, as indicated in the method <b>pollEvent()</b>: A pointer to <b>T_EVENT</b> is cast to a pointer to <b>EventProxy</b> with the operator <b>static_cast&lt;&gt;</b>. Or, to be precise, <b>T_EVENT</b> is a concrete event class derived from <b>Event&lt;T_SRC&gt;</b>, which, in turn, is derived from <b>EventProxy</b>.</li>
  <li><b>EventSource&lt;T_EVENT&gt;</b> maintains an array of pointers of class <b>T_EVENT</b>. These pointers point to active event objects that are to be fired by the event source. Since maintaining a group of active event objects is one of the commonalities for every event-source object, one might question why the array of event objects is not defined in the base class <b>EventSourceProxy</b>. The answer is that a specific event source has to work with specific event objects to avoid downcast when certain methods of the specific event objects are invoked within the event-source class. The appearance of any downcast, using <b>dynamic_cast&lt;&gt;</b> or RTTI, normally indicates a design flaw and causes programmers to add some unnatural error-handling code.</li>
</ul>



<p>With the class template <b>Event&lt;T_SRC&gt;</b>, any specification of <b>Event&lt;T_SRC&gt;</b> is a derivation of <b>EventProxy</b> that has an interface with the dispatcher and its own event-source class. Also, the template parameter <b>T_SRC</b> has to be a concrete event-source class derived from <b>EventSource&lt;T_EVENT&gt;</b>. The static member, <b>theEventSource</b>, of type <b>T_SRC</b>, binds all objects of a concrete event class to the event source <b>T_SRC</b>.</p>

<p>It seems that there is a looping reference between a concrete event class and the corresponding concrete event-source class. For example, for the timer event, you have the class <b>TimeEvent</b> and class <b>TimeEventSource</b>. <b>TimeEvent</b> is derived from <b>Event&lt;TimeEventSource&gt;</b>, and <b>TimeEventSource</b> is based on <b>EventSource&lt;TimeEvent&gt;</b>. They reference each other in their declarations! Is this a problem? Actually, it isn't. Using forward declaration and observing that in class <b>TimeEventSource</b> only pointers of <b>TimeEvent</b> are directly referred, the compiler yields what is intended.</p>

<p>The following classes complete the GED library:</p>



<ul>
  <li><b>EventDispatcher</b></li>
  <li><b>EventSrcProxy</b></li>
  <li><b>EventProxy</b> </li>
  <li><b>EventSrc&lt;T_EVENT&gt;</b></li>
  <li><b>Event&lt;T_SRC&gt;</b></li>
</ul>

<p>To declare and define concrete event classes and event source classes, first specify the class template <b>Event&lt;T_SRC&gt;</b> with the concrete event-source class and specify the class template <b>EventSrc&lt;T_EVENT&gt;</b> with the concrete event class. Then, derive the concrete event class from the specification of <b>Event&lt;T_SRC&gt;</b>, and the concrete event-source class from the specification of <b>EventSrc&lt;T_EVENT&gt;</b>, respectively.</p>
<h3>A Timer Event Example</h3>

<p>The timer event illustrates how a concrete event class, along with its source class, is derived and implemented (<a href="0510xul3.html" target="_BLANK">Listing 3</a>). Each object has its own callback routine, which is called by the method <b>eventProcess()</b>. This callback routine seems to be kind of common and it would be defined in some base class. However, it has to be specific to the concrete class because the callback routine always has its own particular signature (type of an argument, number of arguments) appropriate to the concrete class.</p>

<p>In the method <b>TimeEvent::activateEvent()</b>, the statement <b>theEventSource.addEvent(this)</b> is mandatory for the purpose of putting this event object onto the polling queue maintained by its event-source class, <b>TimeEventSrc</b>. However, this common behavior cannot be specified in a base class, for the polling queue contains pointers of objects of type <b>TimeEvent</b>, not their base type. By doing this, you avoid a possible downcast.</p>

<p>Another common behavior pattern is found in the method <b>eventProcess()</b>. As shown in the <b>TimerEvent</b> class, regardless of what concrete event class it is, this method always does the same routine&#151;check if there is callback specified. If so, call it; check if this object is to be restored. If so, restore it; otherwise, do self deletion. Again, since the callback is only known by the concrete event class, the implementation of <b>eventProcess()</b> cannot be put in a base class.</p>
<h3>A Windows Event Example</h3>

<p>In a Windows application, dispatching events via the GED library turns out to be just an extension. The classes <b>WinEvent</b> and <b>WinEventSource</b> (<a href="0510xul4.html" target="_BLANK">Listing 4</a>) are derived from <b>Event&lt;WinEventSource&gt; </b>and <b>EventSrc&lt;WinEvent&gt;</b>, respectively. As the design is on a single-threaded platform, the Windows <b>PeekMessage()</b> API call is used instead of another commonly used API call, <b>GetMessage()</b>. This is because the former is polling for Windows events while the latter is block-waiting. In <b>eventProcess()</b>, a Windows event is relayed to the Windows standard event-dispatching API calls, <b>TranslateMessage()</b> and <b>DispatchMessage()</b>. </p>

<p>It is worth noting that:</p>



<ul>
  <li>In Windows applications, only a single object of class <b>WinEvent</b> is needed to relay all the Windows events to standard Windows event-dispatching function calls.</li>
  <li>Since it always calls Windows standard event-dispatching functions, the object of <b>WinEvent</b> does not need a customized call-back routine.</li>
  <li>The object of <b>WinEvent</b> is always restored after being processed, so the method <b>setRestore(true)</b> is called in the constructor.</li>
</ul>



<p>The GED library makes Windows standard event dispatching a secondary level of dispatching, so it is necessary to make some changes in the main code. Normally, the following code is found in the main function (namely, <b>WinMain</b>):</p>

<pre>
 ... //initialization
while (GetMessage(&amp;msg, NULL, 0, 0)) 
{	if (!TranslateAccelerator(msg.hwnd,
		       hAccelTable, &amp;msg)) 
	{	TranslateMessage(&amp;msg);
		DispatchMessage(&amp;msg);
	}
}

</pre>

<p>However, this code is substituted with:</p>

<pre>
 ... //initialization
WinEvent *wEvent = new WinEvent
		       (hAccelTable);
theDispatcher().Loop();
delete wEvent;

</pre>

<p>With this change, Windows applications can support other event sources (such as third-party messaging events). The companion source code (http://www.cuj.com/code/) shows how the timer event source described here can be added to a typical Windows application.</p>
<h3>Conclusion</h3>

<p>To implement a concrete event class and its companion event source class with the generic event dispatcher (GED) library, the process is as follows:</p>

<ul>
  <li>Name the concrete event class and the concrete event-source class.</li>
  <li>Derive the concrete event class from the specialization of class template <b>Event&lt;T&gt;</b> of the concrete event-source class.</li>
  <li>Derive the concrete event-source class from the specialization of class template <b>EventSrc&lt;T&gt;</b> of the concrete event class.</li>
  <li>In the implementation of the method <b>activateEvent()</b>, make the call of <b>theEventSource.addEvent(this)</b>.</li>
  <li>In the implementation of the method <b>eventProcess()</b>, check whether there is a callback associated with this object; if so, call it. Then, check whether this object is to be restored; if so, restore it. Otherwise, do self-deletion. If the events are to be relayed to secondary level dispatching, such as <b>WinEvent</b>, standard processing may be needed rather than a callback, and the object is always restored.</li>
</ul>



<p>The <b>main</b> function in <a href="0510xul5.html" target="_BLANK">Listing 5</a> shows the usage of the timer event class. Note that the object <b>timeTerm</b> is self-destructive and so there is no need to delete it explicitly.</p>

<p>In the accompanying source code, the implementation of the signal event class and its event-source class is available for interested readers. The source code has been built and tested on Windows XP with Visual Studio 7 (VC++ 7) and on Solaris with Sun CC 6.</p>
<h3>References</h3>

<ol>
  <li>[1]	Meyers, Scott. <i>Effective C++</i>, Addison-Wesley, 1996.</li>
  <li>[2]	Beveridge, Jim. "Self-Registering Objects in C++," <i>Dr. Dobb's Journal</i>, August 1998. </li></ol>
<h5><b>CUJ</h5></b)





</body>
</html>