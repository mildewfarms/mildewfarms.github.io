


<html>
<head>
<title>February, 2005: C++/CLI: Headers, Inline Functions, Arrays, and Generics</title>
</head>

<body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000">
<!--Copyright &#169; C/C++ Users Journal-->

<p><i>C/C++ Users Journal</i> February, 2005</p>
<h1>C++/CLI: Headers, Inline Functions, Arrays, and Generics</h1>
<h2>Expanding on the Point class</h2>


<h3>By Rex Jaeschke</h3>


<I>Rex Jaeschke is an independent consultant, author, and seminar leader. He serves as editor of the Standards for C++/CLI, CLI, and C#. Rex can be reached at <a href="mailto:rex@RexJaeschke.com">rex@RexJaeschke.com</a>.</I>

<hr>

<p>Last month I introduced a reasonably complete and useful <b>ref</b> class called <b>Point</b>, which models a two-dimensional point. This month, I expand on various aspects of that type's implementation, and look at some new topics.</p>
<h3>Headers and Function Declarations</h3>

<p>In traditional C++ design and implementation, you define each type being modeled, in its own header, with that header containing the type's name, its members' names and types, and the inline definition of relatively trivial member functions. </p>

<p>Rather than having separately compiled source files share information via a header, in C++/CLI such information is shared via an assembly. As with the <b>Point</b> class, it was compiled on its own, resulting in an assembly called "Point.dll." Any application needing that type's definition must be compiled and linked against that type's assembly. This requires that that type's definition be at least complete enough for it to be compiled and linked to DLL form. As such, all functions declared in that type must also be defined; otherwise, linker errors result. </p>

<p>You can declare the member function <b>GetHashCode</b>, for example, inside the class <b>Point</b> and define it outside that class, but in the same source file (see <a href="0502jaeschkel1.html" target="_BLANK">Listing 1</a>). However, placing that member function's definition in a separate source file is not an option, even if that source file were compiled at the same time as that for Point.cpp, as input to the same assembly. To compile such a file requires access to the assembly Point.dll, yet that is precisely the assembly being generated by this compilation! (Note the absence of inline on the function's definition; I'll discuss that later.)</p>

<p>The implication of not using headers is that to compile and link any assembly, all of the type assemblies on which that assembly depends must already have been compiled and linked.</p>
<h3>Inline Functions</h3>

<p>In <b>Point</b>, the definition of every member function is written inline, and this is no accident. Apart from having the flexibility to define them out-of-line, but later in the same source file, member functions cannot be defined in source files separate from the type definition itself.</p>

<p>The traditional model of code inlining is that the declaration of a function as <b>inline</b> is a hint to the compiler to actually inline it as it sees fit, possibly trading program size for speed. However, such optimizations are limited to that compilation, yet exploit having such inline function definitions defined in a header. When class <b>Point</b> is compiled, inlining can be applied by the compiler on calls to member functions from within that type. For example, all gets and sets of the <b>X</b> and <b>Y</b> properties within the definition of <b>Point</b> itself can be inlined.</p>

<p>What about code that uses <b>Point</b> from a different assembly? Can its calls to <b>Point</b>'s member functions also be inlined? In theory, yes. After all, to compile application code, the compiler needs access to <b>Point</b>'s assembly so it could see exactly how any given member function was implemented, allowing references to that function to be optimized. </p>

<p>Consider the case of <b>GetHashCode</b>. Given its simple content, it is a likely candidate for inlining. Assume calls to it from an application assembly are inlined, then later that function is reimplemented using a different algorithm. If the application assembly were not rebuilt, it would continue to use the hashcode algorithm inlined inside it rather than the new version. Since this is almost certainly not the desired behavior, inlining across assembly boundaries is a bad idea. But then, so is not inlining gets and sets of the trivially implemented <b>X</b> and <b>Y</b> properties.</p>

<p>Fortunately, optimization is possible at other than compile time. For example, in the simplest execution model, each time a program is run, its CIL instructions are executed. However, a Just-in-Time (JIT) compiler can recognize certain code patterns, and perform various optimizations, such as code inlining. Large, complex programs can be installed such that they are compiled to native code once per installation. That way, the optimizations don't need to be done each time the program is executed.</p>

<p>The out-of-line definition of <b>GetHashCode</b> was not declared inline. If this approach were used in a header, multiple includes of that header would result in multiple definitions of the same name, giving rise to linker errors, at least on some systems. However, since this approach is in an assembly rather than a header, no such error occurs; there is only ever one definition of this function. Ordinarily, you can use <b>inline</b> in this context, but it isn't necessary. In fact, in this particular case, it isn't allowed since any function declared to be an override cannot also be marked inline.</p>
<h3>CLS Compliance</h3>

<p>Last month, I pointed out that while a property's getter and setter can have different accessibilities, doing so can hinder language interoperability. One of the goals of CLI is to promote such interoperability, without requiring it. It does this by defining a Common Language Specification (CLS) [1] and a set of CLS rules. For example, Rule 25 states, "The accessibility of a property's accessors shall be identical."</p>

<p>When implementing a type for use in a CLI environment, you need to consider the way in which you export various aspects of that type, such as member function signatures. For example, not all CLI-based languages support unsigned integer or pointer types, and few of them understand <b>const</b>- and <b>volatile</b>-qualified types.</p>

<p>The CLS requires that languages not supporting certain features can still access them via function-call syntax. It is for this reason that the getter and setter for a property called <b>X</b> are really called <b>get_X</b> and <b>set_X</b>, respectively, in the metadata. Similarly, there are metadata names for operator functions, so they can be called from languages having no notion of operator overloading.</p>
<h3>Equals versus operator==</h3>

<p>For a <b>ref</b> class, equality is implemented via a function called <b>Equals</b>, rather than by overloading <b>operator==</b>. However, it is possible to override that operator (see <a href="0502jaeschkel2.html" target="_BLANK">Listing 2</a>).</p>

<p>In case 1, you reject null-valued handles. However, if you had used <b>p1</b> and <b>p2</b> instead of <b>o1</b> and <b>o2</b>, you'd have been calling yourself recursively; hence the implicit conversions to <b>Object^</b>. By making this function static, it becomes CLS compliant. (Nonstatic operator functions are not CLS compliant.)</p>

<p>Except for the handle notation, this operator function's signature looks much like the corresponding version written in traditional C++. However, the big difference comes when you use this operator. Consider if (<b>p == q</b>), where <b>p</b> and <b>q</b> both have type <b>Point^</b>. The problem is that the reader is likely to think that two handles are being compared when, in fact, it's the two <b>Point</b>s those handles refer to that are being compared. To actually compare the handles, you need to write something like:</p>

<pre>
if (static_cast&lt;Object^&gt;(p1) == static_cast&lt;Object^&gt;(p2))

</pre>

<p>Although you can provide this operator function for class <b>Point</b>, you still need to provide <b>Equals</b>. If you don't, anyone calling <b>Equals</b> on a <b>Point</b> will get the version in <b>System::Object</b>, and that version tests for referential equality not value equality. That is, it returns <b>true</b> if the specified instance of <b>Object</b> and the current instance are the same instance; otherwise, it returns <b>false</b>.</p>
<h3>CLI Arrays</h3>

<p>As they exist in Standard C++, arrays are just like those in C, so they have the same advantages and disadvantages. Namely, they are allocated space at compile time, they have a fixed size, and array-bounds checking is not required. There is no such thing as a multidimensional array; instead, you can have an array of array, of array, and so on. I refer to such arrays as "native arrays."</p>

<p>In the CLI world, arrays are objects and are allocated on the garbage-collected heap. Their size need not be known at compile time, array-bounds checking is automatically done at runtime, and true multidimensional arrays are supported. As such, you need new syntax to express such CLI arrays. </p>

<p>Consider <a href="0502jaeschkel3.html" target="_BLANK">Listing 3</a>. Like instances of <b>ref</b> classes, CLI array objects have no name, per se; rather, they are accessed via handles to them. As we can see in cases 1, 2, 3, and 4, an array type is written using template-like notation, as in <b>array&lt;int&gt;</b> and <b>array&lt;Point^&gt;</b>. (In earlier implementations of C++/CLI, it was necessary to have a using directive for namespace <b>cli::language</b> for the compiler to understand this notation. This is no longer necessary.) Note carefully that in cases 1 and 2, I am defining handles to arrays, not arrays, and that in case 2, the array type is "array of handles to Point," not "array of Point." </p>

<p>By default, automatic handles take on the value <b>nullptr</b>; however, in both these cases, I have initialized the handle to a block of memory allocated via <b>gcnew</b>. This operator is followed by the type of the array, an optional parenthesized element count, and an optional brace-delimited initializer list. If the initializer list is omitted, the elements take on their default value. If the element count (along with its delimiting parentheses) is omitted, the number allocated is the number of expressions in the initializer list. If the specified count is greater than the number in the list, the remaining elements take on their default value. (For example, <b>numbers[4]</b> is zero.) The count and initializer cannot both be omitted. The count and initializer expressions need not be constants. An element count can be zero, and an initializer list can be empty; both indicate an array of zero elements, which is quite different than having no array at all.</p>

<p>Note that in case 2, the element count is omitted. If it were specified as 3, for example, and the same initializer list were used, the third element would be initialized to <b>nullptr</b>, not to a handle to a <b>Point</b> constructed with the default constructor, as you might think or want.</p>

<p>In case 3, I set the <b>int</b> array handle numbers to a new location&#151;one that contains an array of three <b>int</b>s. That results in one less handle to the array of five <b>int</b>s, and if that was the only handle to that space, it will eventually be recovered by the garbage collector. So although an array has a fixed size, a handle to an array of some dimension can be made to refer to any array of that type and dimension, regardless of its element count (which is maintained by the system).</p>

<p>As you can see in cases 5a, 5b, and 5c, a one-dimensional CLI array can be subscripted in the expected manner.</p>

<p>The <b>Display1DArray</b> function displays the text given as its first argument, followed by the number of elements in the array designated by the second argument, and the value of each of those elements (if any). Here is the output produced:</p>

<pre>
numbers  5: 10 20 30 40 0
points   2: (3,4) (5,7)
numbers  3: 55 66 77
numbers  0:
points[0] is (2,5)

</pre>

<p><a href="0502jaeschkel4.html" target="_BLANK">Listing 4</a> is the source for <b>Display1DArray</b>. (For now, treat the keyword <b>generic</b> as if it were <b>template</b>.)</p>

<p>Clearly, the parameter <b>ary</b> is a handle to a CLI array of type <b>T</b>; however, not only can <b>ary</b> be given a handle to such an array, but that handle could have the value <b>nullptr</b>. So in case 6, you guard against that.</p>

<p>In case 7, I display the text passed in, along with the number of elements in the array. You obtain the latter from the read-only property <b>Length</b>, which all arrays have. (All CLI arrays are implicitly derived from class <b>System::Array</b>, which has this property.)</p>

<p>You then proceed to cycle through the array in case 8, displaying each element on the same line as you go, terminating that line with a newline in case 9. Rather than using <b>for</b> to vary an integer index from zero to <b>ary-&gt;Length</b> <b>-</b> <b>1</b>, you use the new loop statement, <b>for</b> <b>each</b>. (Together, these two tokens make up a keyword.) This construct allows the elements of a collection to be enumerated. I won't go into the details here of how this works, but suffice it to say that a CLI array is a CLI collection, so its elements can be traversed using this construct. Using this approach, however, you cannot get access to each element's index as you go. The reason for this is that not all collections are linear (for example, a binary tree), in which case, indexing makes no sense.</p>

<p>When you subscript a CLI array, you are not using <b>operator[]</b> on that array; instead, you are using an indexed property called <b>Item</b>, defined on <b>System::Array</b>. While a scalar property has a single value, an indexed property can have many values, with each one being accessed via subscript notation. </p>

<p>To make <b>Display1DArray</b> be array-type agnostic, it makes perfect sense to make it a template function. However, template use is a compile-time operation, resulting in one copy of the function generated for each array type used in the program. In V2, the CLI has added support for generics, a template-like facility that uses a single copy of code at runtime. <b>generic</b> is a context-dependent identifier. (As you might expect, you can also have generic types.)</p>

<p>C++/CLI supports true multidimensional arrays (see <a href="0502jaeschkel5.html" target="_BLANK">Listing 5</a>).</p>

<p>The pseudotemplate <b>array</b> takes an optional second argument, which is the rank (that is, the number of dimensions) of the array. This defaults to 1. As such, in the previous example, <b>array&lt;int&gt;</b> could have been written as <b>array&lt;int,1&gt;</b>. (Like all nontype arguments to templates, this one has to be a compile-time constant.)</p>

<p>In case 2, I define a handle to a two-dimensional array of handles to <b>String</b>, but I don't mention the number of rows or columns. I then allocate memory for a 2&times;3 array of that type and initialize the six elements with the five strings shown, plus a <b>nullptr</b>. Here is the output: </p>

<pre>
names has 6 elements
names has 2 dimensions
names[0,0] is John
names has 35 elements

</pre>

<p>The <b>Length</b> property gives the total number of elements, while the <b>Rank</b> property gives the number of dimensions. </p>

<p>Note carefully in case 4 that accessing an element in a multidimensional array involves only one set of brackets, which contains a comma-separated list of indexes. In this context, the comma behaves as a punctuator rather than an operator.</p>

<p>You can make <b>names</b> refer to any two-dimensional array of <b>String^</b>. For example, in case 5, I make it refer to a 5&times;7 array whose elements' values are all <b>nullptr</b>. </p>
<h3>Parameter Arrays</h3>

<p>Last month, I introduced the following overload of <b>String::Concat</b>:</p>

<pre>
static String^ Concat(... array&lt;Object^&gt;^ list);

</pre>

<p>The ellipses notation at the beginning of the final (in this case, the only) parameter declaration (which must have a CLI array type) indicates that this parameter accepts an arbitrary number of arguments of the given element type.</p>

<p><a href="0502jaeschkel6.html" target="_BLANK">Listing 6</a> presents a function that takes a variable number of <b>Point</b> handles as arguments and returns the left-most <b>X</b> coordinate. (Of course, this function could be made a static member function of class <b>Point</b>.)</p>

<p>The output produced is as follows:</p>

<pre>
LeftMostX is 1
LeftMostX is -5

</pre>

<p>In case 2, I call <b>LeftMostX</b>, passing it three <b>Point</b> handles. However, behind the scenes, that function really only takes one argument&#151;a handle to an array of "handle to Point." As such, the compiler marshals the three <b>Point</b> handles passed into an array, and passes a handle to that. You can take advantage of this knowledge by passing a handle to an array of <b>Point</b>s directly, as in case 3.</p>

<p>The only thing new in the definition of <b>LeftMostX</b> is case 4. Each of the primitive C++ types maps to a corresponding implementation-defined type in the CLI library. For example, in the Microsoft implementation, <b>short</b> maps to <b>System::Int16</b>, <b>int</b> maps to <b>System::Int32</b>, and <b>long</b> <b>long</b> maps to <b>System::Int64</b>. Each of these types is a value class type, instances of which are allocated on the stack rather than on the garbage-collected heap.</p>

<p><b>MaxValue</b> is a public static field in type <b>Int32</b> that has the value 2,147,483,647, the largest value for a signed 32-bit twos-complement integer. (Strictly speaking, <b>MaxValue</b> is a literal field.)</p>
<h3>Exercises</h3>

<p>To reinforce the material covered, you might want to perform the following:</p>



<ol>
  <li>Using <b>ildasm</b> on Point.dll, find out the metadata name for the <b>operator==</b> function. By experiment or by referring to the CLI Standard, Partition I, find out the names of some other operator functions.</li>
  <li>What happens if a handle with value <b>nullptr</b> is used with <b>-&gt;</b>?</li>
  <li>Look at the documentation for class <b>System::Array</b>, paying particular attention to the scalar property <b>Length</b> and the indexed property <b>Item</b>.</li>
  <li>Given that the runtime knows the number of elements in any array, bounds checking is possible. What happens when an out-of-bounds access is detected?</li>
  <li>Function <b>System::Array::CreateInstance</b> lets you create a CLI array whose number of dimensions, size of each dimension, and element type are not known until runtime. Write a program that requests the user to input the number of dimensions and their size and creates a CLI array of <b>int</b> of that size. (Hint: To obtain the <b>Type</b> object for <b>int</b>, use <b>int::typeid</b>.)</li>
  <li>Define a CLI array having four elements, each of which is a CLI array of a differing number of <b>int</b>s. That is, define a jagged array. (Hint: Think "array of array.")</li>
  <li>Look at the documentation for the value class types to which the primitive types map. These types are <b>Boolean</b>, <b>Sbyte</b>, <b>Byte</b>, <b>Int16</b>, <b>UInt16</b>, <b>Int32</b>, <b>UInt32</b>, <b>Int64</b>, <b>Uint64</b>, <b>Single</b>, <b>Double</b>, and <b>Char</b>, all in namespace <b>System</b>.</li>
  <li>Given that <b>i</b> is an <b>int</b> with value 100, what does <b>i.GetHashCode()</b> do? What about <b>(100).GetHashCode()</b>? Why are the parentheses significant? What does <b>Int32::Parse("1234")</b> do?</li>
</ol>
<h3>References</h3>

  <p>[1]	See the CLI Standard, Partition I, Clauses 7 and 10 (<a href="http://www.ecma-international.org/publications/index.html">http://www.ecma-international.org/publications/index.html</a>). 






</body>
</html>