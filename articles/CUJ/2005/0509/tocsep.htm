<HTML>
<HEAD>
<TITLE>September 2005</TITLE></HEAD>     <BODY BACKGROUND="" BGCOLOR="#FFFFFF" TEXT="#000000">
          <BLOCKQUOTE> <IMG SRC="../logo.gif" ALT="{logo}" WIDTH="310" HEIGHT="100">
               
               <H3><FONT COLOR="#000080">September 2005<BR>
                Volume 23 Number 9</FONT></H3>
               

<H3><FONT COLOR="#FF0000">FEATURES</FONT></H3>

<H4><A HREF="0509aitkenhead/0509aitkenhead.html">The Ordersort Algorithm</A></H4>
<p><b>Matthew Aitkenhead and Mark Richards</b><br>
<i>Ordersort is a list-sorting algorithm that's simple to implement in C++, and that sorts lists faster than the Quicksort and Bubblesort algorithms.
</i></p>


<H4><A HREF="0509mattethat/0509mattethat.html">Implementing Splay Trees in C++ </A></H4>
<p><b>Ralf Mattethat</b><br>
<i>Splay trees are self-adjusting binary search trees that are typically used in caches, memory allocators, routers, garbage collectors, data compression, and the like.
</i></p>


<H4><A HREF="0509palshikar/0509palshikar.html">Satisfying the Satisfiability Problem</A></H4>
<p><b>Girish Keshav Palshikar</b><br>
<i>Girish surveys—and implements in C—algorithms for the "satisfiable" problem, including the Davis-Putnam algorithm, GSAT algorithm, and simulated annealing algorithms.
</i></p>


<H4><A HREF="0509jones/0509jones.html">Determinant Algorithm Generation with Numlists</A></H4>
<p><b>Michael A. Jones</b><br>
<i>Numlists provide the compile-time index list structures that allow processing to happen in place. The compile-time nature of template recursion is key to coding this algorithm.
</i></p>


<H4><A HREF="0509banks/0509banks.html">The Embedded C Extension to C: Part II</A></H4>
<p><b>Marcel Beemster, Hans van Someren, Willem Wakker, and Walter Banks</b><br>
<i>In this installment of this two-part article, our authors present an example use of the Embedded C language extensions.
</i></p>


<H4><A HREF="0509jaeschke/0509jaeschke.html">C++/CLI: Cloning</A></H4>
<p><b>Rex Jaeschke</b><br>
<i>C++/CLI "cloning" capabilities let you make copies of heap-based objects.
</i></p>




<H3><FONT COLOR="#FF0000">COLUMNS</FONT></H3>

<H4><A HREF="0509becker/0509becker.html">The New C++</A></H4>
<p><b>Pete Becker</b><br>
<i>If you've never had to track down a program failure caused by a bad pointer, well, you're in for some treats.
</i></p>


<H4><A HREF="0509wilson/0509wilson.html">Positive Integration</A></H4>
<p><b>Matthew Wilson</b><br>
<i>In his previous installment, Matthew focused on code bloat in source code. This month, he looks at object code size.
</i></p>


<H4><A HREF="0509torjo/0509torjo.html">Win32 GUI Generics</A></H4>
<p><b>John Torjo</b><br>
<i>Windows should only implement their logic, while surfaces implement the drawing of the UI.
</i></p>


<H4><A HREF="0509diggins/0509diggins.html">Agile C++ </A></H4>
<p><b>Christopher Diggins</b><br>
<i>Christopher introduces some specialized deletable unsmart pointer class templates.
</i></p>



<H3><FONT COLOR="#FF0000">DEPARTMENTS</FONT></H3>

<H4><A HREF="0509edit/0509edit.html">Editor's Forum</A></H4>
<H4><A HREF="0509newprod/0509newprod.html">New Products</A></H4>

</blockquote>
</body>
</html>
