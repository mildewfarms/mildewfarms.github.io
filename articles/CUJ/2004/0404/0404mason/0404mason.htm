<html><head><title>April 04: </title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; C/C++ Users Journal--><p><i>C/C++ Users Journal </i> April 2004</p><h1>A Finite State Machine Framework</h1><h2>A simple, yet reusable, framework for building FSMs</h2><h3>By P. Dale Mason</h3><p>In many software-design methodologies, we use state transition diagrams to model the behavior of subsystems (processes) or objects with a set of finite states and transitions. In some cases, it becomes obvious that these translate into software implementations beyond the model. The state transition diagram, better known as a finite state machine (FSM) in software implementation, is one of the most popular methods for invoking control-oriented systems. This is particularly true in real-time software applications. </p><p>There are a number of techniques for developing finite state machines in software, with one of the more popular being the use of nested <b>switch-case</b> statements [1]. The drawback to this approach is that as the state machine grows, so does the logic &#151; and in C++ this is not an attractive approach to true object-oriented development. There are many methods that have been discussed in development state machines in C++, but none of them has truly drawn a conclusive framework that can be ported from implementation to implementation. Many state machines are written in software straight from their state pattern(s) modeled in some design methodology, such as UML. </p><p>In the past, I developed FSMs using basic ANSI C. <A HREF="0404masonl1.htm" target="_BLANK">Listing 1</A> is the traditional C-style approach, which avoids the overuse of the <b>switch-case</b> construct. Recently, with embedded real time moving into C++ as a target language, I have ported this scheme to a simple, yet reusable, framework. Even though the target of such a framework implies embedded real time, it is not limited to it. Think of all those GUI-based applications that pass messages from one window to the next. These are highly qualified state machine candidates.</p><h3>The Framework</h3><p>The new framework must provide a lightweight and portable approach to implementing finite state machines in C++. Traditionally, from what I have read, most take the approach as follows: Given a state machine, a class, <b>T</b>, extends the base state machine class. In this approach, <b>T</b> implies an is-a relationship to the state machine. While there is nothing wrong with this scheme and in itself provides a solid framework, it suffers from exposing the public nature of <b>T</b>. Therefore, <b>T</b> can either be invoked via its own public implementation or via its parent class, the state machine. </p><p>Since state machines are applied in situations where control dictates the operation of a piece of software, it would seem best to hide <b>T</b> behind the state machine. In other words, you have a state machine of <b>T</b> instead of the other way around. Not only does it hide details about <b>T</b>, but provides communication to <b>T</b> only through the state machine, thus implying the control logic driven by events or messages.</p><p>I have taken two paths, via a compile-time option, of how <b>T</b> is implemented as a state machine. The first extends <b>T</b> privately (that is, private inheritance). This approach guarantees that an instance of <b>StateMachine&lt;&gt;</b> hides the implementation of <b>T</b> at the constructor and the state machine cannot be cast as a T-pointer except by its own members and friends [2]. The downside is that a <b>T</b> will always require a default constructor and force the developer to initialize <b>T</b> with default parameters or obtain them through some other means, which could be an issue for multiple state machine instances of <b>T</b>.</p><p>The second approach is to contain <b>T</b> as an aggregate association; that is, a private member of <b>StateMachine&lt;&gt;</b>. This allows an instance of <b>T</b> to be constructed prior to the state machine creation with the necessary parameters required to initialize it. The drawback to this method is that although <b>T</b> is a hidden member of the state machine, its creation could have been done prior to state machine creation. This provides a dilemma as to whether you allow the state machine to destroy <b>T</b> on its destruction, or whether it is the responsibility of the original creator? I have decided that the state machine will destroy the instance of <b>T</b> upon its destructor being invoked. One way to easily work around who owns T at its creation is solved:</p><pre>StateMachine&lt;T,EV,CMP&gt; myStateMachine ( new T(_), initState );</pre><p>For this article, I use </b><b>T</b> through inheritance for the sake of illustration and example. In either case, the state machine plays the surrogate to dispatching control to <b>T</b>. <A HREF="0404masonl2.htm" target="_BLANK">Listing 2</A> presents the base state machine classes.</p><h3>The Event</h3><p>There are four parts to the state-machine framework: </p><ul>  <li>Event.  <li>State.  <li>Transition.  <li>Action.</ul>  <p>Event (EV) is the catalyst that causes the state machine to run; in other words, transition from state to state. Events can also be messages, as they are commonly called in GUI-based applications. Events are internal or external to the system in which the state machine is running. The origin of the event is not of concern to the state machine, at least from this framework's point of view. Pre- and postprocessing of events are not the responsibility of the state machine, since this detracts from the generalization of the framework, which makes it portable.  <p>The state machine I present offers one API for processing events, <b>PostEvent</b>. Notice I did not say "handling," because in this framework the state machine does not handle the event. How could it and still be reusable, since events are handled specifically to the environment in which they are invoked? The state machine knows nothing about its environment. So as far as it is concerned, the event is only a key that is used to help the state machine transition from one state to the next. The actual handling of the event, which may require system interaction prior to and/or after the event, has been passed to the state machine.   <p><A HREF="0404masonf1.htm" target="_BLANK">Figure 1</A> shows how you might integrate FSMs into their solution. I have purposely put an event handler as the interface to the system and not the state machine. Again, the FSM is not responsible for system-level interactions, so it knows nothing about handling of events &#151; which is why the framework is portable. In this scenario, it is the responsibility of end developers to do the pre- and postprocessing of the events when calling the state machine as well as provide all synchronization.  <p>Input/output data to/from events may be encapsulated within event wrappers. For example:<pre>class MyEvent {   int hEvent;   CRITICAL_SECTION hLock;   ... // Other specific information to Event Wrapperspublic:   MyEvent( const int ev ) : hEvent(ev) {...}   ... // Other initialization and member functionspublic:   char* inbuffer;   mutable char* outbuffer;   ... // other member functions and constructors not shown};</pre><p>Since the event is passed as a </b><b>const</b> reference, any data to be manipulated by event handlers should be a mutable type. In this example, only the output buffer has this attribute.</p><h3>States and Transition Tables</h3><p>The condition of an FSM at any instance is known as the "state." The state in <A HREF="0404masonl3.htm" target="_BLANK">Listing 3</A> contains information pertinent to how the state machine behaves when an event is received. One of the things that may or may not appear intuitive from the class diagram is how loosely coupled the states are from the state machine. The state machine is only concerned with the current state. At construction, a start state is passed in, implying that the states are created prior to the state machine (which makes sense if you think about it). Navigation from state to state occurs through the transaction table that is contained within each state.</p><p>The state transaction table (STT) is a sorted associative container (STL <b>map</b>) where the event (EV) is the key and an instance of a transition is the data. As events are passed into the state machine, the transition is retrieved from the transition table, if the event is valid for this state. The STL <b>map</b> was an obvious choice because events associate with transitions to the next state and are portable in the C++ Standard Library. </p><p>I initially considered the hash version of STL's <b>map</b> (<b>hash_map</b>) because the order of the event-transition pairs was not important. The worst-case complexity of most operations in a hashed associative container is linear in the size of the container, but the average time complexity is constant [3]. This is ideal for a situation in which information is simply stored and retrieved without regard to ordering. The drawback, though, is that <b>hash_map</b>s are not Standard Library entities from an ANSI perspective and could create portability problems for our state-machine framework. Since the number of transitions from a given state is typically not large, the time difference appears to be minimal at best, considering that events are typically integral values.</p><h3>Action Handling</h3><p>Transition from state to state has little merit, other than behavior modeling, unless something is performed on object <b>T</b>. In this framework, you hide <b>T</b>, but how <b>T</b> is accessed is left to the action handlers. While the state machine manages the behavior of <b>T</b>, the action objects manipulate the data and attributes of that object during transition. It is only through the action objects that the state machine can alter the data within <b>T</b>. In other words, the state machine resembles a container class that manages behavior.</p><p>Actions are typically invoked when an event occurs forcing a state transition. You may recall Mealy and Moore machines from your college textbooks. The handling of the output or action, in this case, is based on what model of state machine we use. In the framework presented, actions are associated with both transitions and states, so does this make us a Mealy-Moore Machine? (Okay, just a little Automata Theory humor.)</p><p>For each transition there is an action handler. By default, if no action is to be performed on it, and in some cases this can very well happen, then the default action handler is imposed (more on this in a bit). There are also action handlers for states: on <b>Entry</b> and on <b>Exit</b>. As with transitions these are optional as well, but provide this added flexibility (in which you will also find doing UML modeling) for the developer.</p><p>Now comes an interesting situation that I am sure will draw fire from C++ purists. As mentioned, a default action handler (which does nothing) is used when no action by <b>T</b> is required for a given transition or state entry/exit. I am not a big fan of using conditionals, especially in real time when an alternate, faster solution presents itself &#151; especially one that seems more object oriented. In the case of a default handler, I don't want to query the <b>State</b> or <b>Transition</b> if it has a valid handler, as that is left to those objects. However, action handlers take a <b>this</b> pointer of type <b>T</b> and store a member function pointer into <b>T</b>, <b>T::*fp</b>.</p><p>Because of this, I could not find a clean way of forcing <b>T</b> to have a default null handler, and had to create a scheme in which the function <b>operator ()</b>, was overridden. The function operator requires a pointer to <b>T</b> to invoke the action, but in situations where no action was required and to avoid conditional event processing, I ended up making <b>operator ()</b> virtual and created an abstract base template class for <b>Action&lt;&gt;</b>, as in <A HREF="0404masonl4.htm" target="_BLANK">Listing 4</A>. So let the tomato throwing begin! Of course, it's not like I am the first to do both dynamic and static binding of an object in a language that supports it.</p><p>A first approach was not letting the <b>T</b> parameter propagate any further than the <b>StateMachine&lt;&gt;</b> class to avoid code bloating. This initially worked, but required a pointer to <b>T</b> in the action objects and the bloating occurred in the many instances of action objects of the many instances of <b>T</b> (admittedly, this can be confusing). As this framework matures, I am sure there will be a better implementation that saves both execution time and space.</p><h3>Putting It All Together</h3><p>So when do you use an FSM during software development? The heuristic I tend to follow is this straightforward: If you are developing a subsystem or object that runs in its own context or thread that is control oriented in its implementation, then a state machine is a candidate for managing it.</p><p><A HREF="0404masonf2.htm" target="_BLANK">Figure 2</A> is a state transition diagram (STD) of a phoneline. This is not a fully functional phoneline, but suffices for demonstration purposes. The source code for this implementation, available at <a href="http://www.cuj.com/code/">http://www.cuj.com/code/</a>, uses both versions of the framework. </p><p>In the included software I have three important member functions: <b>start</b>, <b>halt</b>, and <b>reset</b>. Even though the state machine does not provide synchronization in form of semaphores or mutexes, it does require itself to be running prior to accepting input. In this, the state machine itself has its own state transition diagram consisting of just two states: <b>running</b> and <b>stopped</b>. Only in the <b>running</b> state can events be processed. Resetting the state machine allows a restart mechanism, which is why during object creation the initial start state is stored.</p><h3>Synchronization</h3><p>The most obvious weakness to the framework is synchronization of entry into the state machine. The whole intent for this framework was to work in the context of its own thread, and (as Microsoft did originally with COM) leave the handling of synchronizing threads to you. State machines are invoked on a first-come/first-served basis, so entry into it should be handled in a critical section. One way of doing this is to protect each call in the state machine, by inserting an entry and exit in each method that is public to users. </p><p>A better solution is to have a single entry point via dispatchers &#151; the obvious choice would be the event handler (<A HREF="0404masonf2.htm" target="_BLANK">Figure 2</A>). Recall I said that events are not handled in the state machine; they are only routed and used to invoke a response. The biggest reason for separating the event handling from the event processing is that event handlers typically use system synchronization and FIFOs or queues.</p><h3>Conclusion</h3><p>This approach is by no means a silver bullet to writing state machines. One drawback in the approach with either version of the state machine is the chicken and egg problem. Since the states are not tightly coupled to the state machine, except via the current state, initialization becomes a problem. You will note in the example software that the states, actions, and state machines are created dynamically, and in the case of using aggregation, object <b>T</b>. This could be perceived as a flaw in the framework, since it should support both static and dynamic implementations. In fact it does, but not to the fullest extent.</p><p>I can see room for improvement, but I feel I am on the right path. No software is always the most correct solution. As software engineers and architects, we often find ourselves refining, tuning, and in some cases, rewriting our designs over time. It's like buying a computer at times. Either you want to wait until the prices are just right or you are waiting for that new technology. This can be a perpetual nightmare until you finally tell yourself, just buy it and realize it will be obsolete the minute you unpack it. I guess the same can be said about software design.</p><h3>References</h3><p>[1]	Martin, Robert C. "UML Tutorial: Finite State Machines," <i>C++ Report</i> (June 1998).</p><p>[2]	Stroustrup, Bjarne. <i>The C++ Programming Language</i>, Special Edition, Addison-Wesley 1997.</p><p>[3]	Musser, David R. <i>STL Tutorial and Reference Guide: C++ Programming with the Standard Template Library</i>, Second Edition, Addison-Wesley 2001. </p><hr><I><b>P. Dale Mason</b> has focused on embedded real-time and desktop application software development for over 15 years. He holds a Masters in Computer Science Engineering and Mathematics from the University of Louisville and is presently working with Visual Studio.NET and C++. Dale can be contacted at <a href="Philip.Mason@cingular.com">Philip.Mason@cingular.com</a>.</I><hr></body></html>