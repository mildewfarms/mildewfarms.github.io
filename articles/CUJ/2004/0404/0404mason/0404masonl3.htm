<html><head><title>April 04: </title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; C/C++ Users Journal--><h4>Listing 3:	<i>The state.</i></h4><pre>template &lt;class T, class EV, class CMP&gt;class Transition{    friend State&lt;T,EV,CMP&gt;;public:    State&lt;T,EV,CMP&gt;* operator()( const T&amp; _T, const EV&amp; ev ) throw() {         (*m_evAction)(_T,ev);        return m_stNext;    }protected:    Transition( const State&lt;T,EV,CMP&gt;&amp; stNext, Action&lt;T,EV&gt;* evAction ) :     m_stNext(const_cast&lt;State&lt;T,EV,CMP&gt;*&gt;(&amp;stNext)), m_evAction(evAction) {  }    ... // Other member information};template &lt;class T, class EV, class CMP = std::less&lt;EV&gt; &gt;class State{    // State Transition Table Type    typedef std::map&lt;const EV,const Transition&lt;T,EV,CMP&gt;*,CMP&gt;        TransitionTable;public:    typedef State&lt;T,EV,CMP&gt; state_type;    typedef EventAction&lt;T,EV&gt;::HANDLE HANDLE;public:    State( HANDLE hEnter = 0, HANDLE hExit = 0 ); {        if ( hEnter == 0 ) {            m_evEnter = new NoAction&lt;T,EV&gt;;        }        else { m_evEnter = new EventAction&lt;T,EV&gt;(hEnter); }        if ( hExit == 0 ) {            m_evExit = new NoAction&lt;T,EV&gt;;        }        else { m_evExit = new EventAction&lt;T,EV&gt;(hExit); }    }    ~State() {        TransitionTable::iterator iter;        for ( iter = m_stTable.begin(); iter != m_stTable.end(); iter++ ) {            delete const_cast&lt;Transition&lt;T,EV,CMP&gt;*&gt;( iter-&gt;second );        }        delete m_evEnter;  delete m_evExit;    }    ... // other API functions not shownprivate:    TransitionTable m_stTable;    Action&lt;T,EV&gt;* m_evEnter;    Action&lt;T,EV&gt;* m_evExit;};</body></html>