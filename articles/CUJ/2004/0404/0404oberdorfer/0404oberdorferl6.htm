<html><head><title>April 04: </title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; C/C++ Users Journal--><h4>Listing 6:	<i>Complete CxC program.</i></h4><pre>// pi.cxc : calculates the number PI using numerical // integration of the function SUM( 4/ (1 + i*i) ) * width////////////////// controller and unit //////////////////////define NUM_PPUS 1000define CONST_A   0.5controller ZeroToOne    // 1000 intervals between 0 and 1 {   double Interval; // result for each interval   unit IntervalUnit[NUM_PPUS]; // 1000 PPU - one for each interval }controller ComputePI    // Controller for result unit {   unit PIUnit[1];  // Unit where PI value is computed }//////////// topology /////////////////////////////////topology IntervalLink       // link to each IntervalUnit to {                  // to PIUnit  PIUnit[0] -&gt; IntervalUnit[*]; }/////////// programs /////////////////////////////////main PI {   ////////////////////////////////////////////////////////////   // ZeroToOne: compute value for sub-interval   ////////////////////////////////////////////////////////////   program ZeroToOne    {     const long NumOfIntervals = NUM_PPUS;     double x;      // temporary variable     // compute value for my part of the interval     x = (id() + CONST_A) / NumOfIntervals;       Interval = (4.0 / (1.0 + x * x));     // wait until all ZeroToOne ppu have finished     barrier;     }   ////////////////////////////////////////////////////////////   // ComputePI: distibute sub-intervals to ZeroToOne ppus   //            gather sub-results and compute PI   ////////////////////////////////////////////////////////////   program ComputePI    {     const long NumOfIntervals = NUM_PPUS;     // compute the sub-values in 1000 parallel processors barrier;      // retrieve the results from the ZeroToOne PPUs     Val.fanin( Interval );     println("PI Result: " , sum(Val)/NumOfIntervals );    } }</body></html>