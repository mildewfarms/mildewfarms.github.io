<html><head><title>April 04: </title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; C/C++ Users Journal--><p><i>C/C++ Users Journal </i>April 2004</p><h1>C# &amp; Electronic Test Instruments</h1><h2> Programming test instruments doesn't need to be difficult</h2><h3>Andy Purcell</h3><p>Although normally associated with enterprise application development, C# can also be used in the lab, on the factory floor, and in similar environments that involve electronic test and measurement instrument control. In fact, with C# and I/O libraries compliant with the Virtual Instrument Software Architecture (VISA) specification (<a href="http://www.vxipnp.org/">http://www.vxipnp.org/</a>), you can create test and measurement applications, complete with GUIs. VISA is a specification developed by the VXIplug&amp;play Systems Alliance, which identifies a common I/O API for communicating over a variety of bus interfaces, including GPIB, VXI, USB, and Ethernet. A number of vendors have tools that support this specification, including Agilent (the company I work for). In this article, I'll use C# and VISA-compliant software to develop test programs. Then I'll improve the test program by using software compliant with the Interchangeable Virtual Instrument (IVI) specification. The IVI spec was developed by the IVI Foundation (<a href="http://www.ivifoundation.org/">http://www.ivifoundation.org/</a>) to promote specifications for programming test instruments.</p><p>While test program applications are traditionally written in C, C++, and Visual Basic, C# provides several benefits when compared to these languages [1]. With C#, for instance, C/C++ programmers can easily create applications with a GUI and not have to learn MFC or Visual Basic. You can develop programs immune to memory leaks. You can also use arrays and automatically detect any out-of-bound array accesses. And with C#, you can write programs free of assignment mistakes (<b>if (a=3) {...}</b> instead of <b>if (a==3) {...}</b>). And since C# applications are compiled (not interpreted), they offer faster execution times than Visual Basic programs. </p><p>While learning any new programming language can be daunting, learning C# does not have to be &#151; especially for experienced C/C++ programmers. It supports the familiar <b>bool</b>, <b>int</b>, <b>float</b>, and <b>double</b> types and multidimensional arrays of types. The syntax for declarations (<b>int a;</b>) and expressions (<b>a=3;</b>) is very much like C and C++. C# has the familiar operators, such as <b>+</b>, <b>-</b>, <b>!</b>, <b>~</b>, <b>*</b>, <b>/</b>, <b>++</b>, <b> &#151; </b>, <b>&lt;=</b>, <b>==</b>, and the like. C# has <b>if-else</b>, <b>switch</b>, <b>continue</b>, <b>break</b>, <b>goto</b>, and the <b>for</b>, <b>while</b>, and <b>do-while</b> looping constructs to control program execution. Enumerated types and <b>struct</b>s can be defined. You can create C# classes with private, protected, and public variables and methods. Classes can inherit from base classes, and base classes can have virtual members. All in all, this is very much like C++.</p><p>But as you might expect, there are some new types in C#. The <b>string</b> type, for instance, contains an immutable set of Unicode characters. Here is an example of how straightforward it is to declare and manipulate strings in C#:</p><pre>string s = "What";s = s + " a beautiful morning.";s = s.ToLower();s = s.Insert(0,"Oh,");</pre><p>After all of this, </b><b>s = "Oh, what a beautiful morning.</b>"</p><p>There are many other programming tasks that C# makes easy. Creating GUIs in C# is as easy as in Visual Basic. All you need to do is drag the Label, Button, GroupBox, CheckBox, and like items from the Toolbox onto a Windows Form. Tooltip help, tabbing, and pull-down menus are also easy to set up. </p><p>Another simple task is creating a distributed application that consists of a server application running on one computer and a client program running on a different one. When both computers are connected on the network, the client can call methods on the server (a process referred to as "remoting"). </p><p>Moreover, it is just as easy to create an application that remembers state information; for example, a UI setting. This is done using the <b>DynamicProperties</b> of an object. Once a <b>DynamicProperty</b> for an object has been set up, the IDE creates an XML app.config file that stores the state information. The next time the application starts, the state information reads from app.config.   </p><p>C# provides <b>get</b> and <b>set</b> accessors to read and write object properties (member variables). These are naturally grouped together, as shown in <A HREF="0404purcelll1.htm" target="_BLANK">Listing 1</A>(a) and <A HREF="0404purcelll1.htm" target="_BLANK">Listing 1</A>(b).</p><p>Of course, there are things that are commonly done in C/C++ that are more difficult in C# &#151; the use of pointers, for instance. Pointers for memory manipulation must be done inside unsafe code blocks and the <b>fixed</b> keyword must pin the object the pointer is pointing to so that it won't be moved by the garbage collector.</p><pre>fixed ( byte *pSource = &amp;myDataSinkBuf[idx1] )fixed ( byte *pDest = &amp;myDataSourceBuf[idx2] ){    *pDest = *pSource;}</pre><p>Pointer arithmetic is disallowed:</p><pre>fixed ( byte *pSource = &amp;myDataSinkBuf[idx1] )fixed ( byte *pDest = &amp;myDataSourceBuf[idx2] ){   *pDest++ = *pSource++;   // won't compile}</pre><p>Multiple inheritance is something else you can do in C/C++ that you can't do in C#. There is no multiple inheritance in C#, although a C# class can implement multiple interface classes. This may cause concern for some programmers, but over the years I've only once used multiple inheritance in C++.</p><h3>Building a Test/Measurement Application</h3><p>The sample application I present here is a test and measurement system that communicates with a function generator. The application includes a GUI that lets users control the sine wave frequency. </p><p>To start, you need the correct software and equipment installed on a development PC: </p><ul>  <li>Visual Studio .NET. The programs I present were developed with Development Environment 2003 and Microsoft .NET Framework 1.1.  <li>Agilent I/O Library (VISA) Software.  <li>Agilent 33220A Function Generator.  <li>USB cable.</ul>  <p>The concepts and programming details I provide here are applicable even if other test equipment is used, and much of the detail presented here pertains to any C# application.  <p></b><b>  <p>Step 1: Creating the Skeleton Application.</b> Start the Visual Studio .NET IDE and select New Project. In the dialog box that pops up, select Visual C#, Windows Application, and an appropriate directory and project name. I used "functionGenerator_1" as the project name. The IDE then automatically creates several files; see <A HREF="0404purcellt1.htm" target="_BLANK">Table 1</A>.<b>  <p>Step 2: Creating the User Interface.</b> To let users control the frequency, add a GUI TrackBar item onto Form1. If Form1.cs [design]* is not currently visible, make it visible by finding the Solution Explorer window, right-clicking on Form1.cs, and selecting View Designer. Move the mouse over the Toolbox area on the left, then drag a TrackBar onto Form1. <A HREF="0404purcellf1.htm" target="_BLANK">Figure 1</A> shows the TrackBar about to be added to Form1. The Toolbox contains many familiar GUI controls, ready to add to the GUI just by dragging onto Form1.  <p>After adding the TrackBar GUI item, add three Label items from the Toolbox and set the Text properties equal to: Frequency, 1 Hz, and 30 KHz. After selecting Build|Build Solution and Debug|Start, the skeleton app should run and display <A HREF="0404purcellf2.htm" target="_BLANK">Figure 2</A>. Naturally, your results will vary, depending on your placement of the Label boxes and the TrackBar properties; I set TrackBar minimum to 1, TrackBar maximum to 30,000.  <p>At this point, I haven't manually typed in any C# code, yet I already have the beginnings of a GUI for the application.<b>  <p>Step 3: Adding VISA Initialization Calls.</b> Here's where you add C# code to initialize the VISA software. The VISA software is a DLL, and for each DLL function a C# application calls, a <b>DllImport</b> (or <b>DllImportAttribute</b>) statement must be added so that the C# compiler knows how to insert code to call the function. Agilent (the company I work for) ships a visa32.cs file that contains all of the necessary <b>DllImport</b> functions for the VISA API so you don't have to actually type in a single <b>DllImport</b> statement &#151; all you have to do is add the visa32.cs file to the project. For example, a <b>DllImport</b> statement for <b>viOpenDefaultRM()</b> is:<pre>[DllImport("VISA32.DLL")] public     static extern int     viOpenDefaultRM(out int sesn);</pre><p>To begin using the VISA software (but before sending any program messages to a device), two VISA API calls must be made:</p><ul>  <li></b><b>viOpenDefaultRM</b>(<b>ViSession sesn</b>). The <b>sesn</b> parameter is an output parameter and a session to the VISA default resource manager.  <li><b>viOpen(ViSession sesn</b>, <b>ViRsrc rsrcName</b>, <b>ViAccessMode accessMode</b>, <b>ViUInt32 timeout</b>, <b>ViSession vi</b>). <b>viOpen()</b> returns a session handle (<b>vi</b>) to the resource described in <b>rsrcName</b>.</ul><p><A HREF="0404purcelll2.htm" target="_BLANK">Listing 2</A>, for example, is inserted into the Form1 constructor in the Form1.cs file. The italic text represents code that has been manually added. For brevity, I've omitted error checking. Notice that the VISA <b>viOpenDefaultRM()</b> and <b>viOpen()</b> are done just after <b>InitializeComponent()</b>, after the <b>TODO:</b> comment that was automatically generated. <b>viOpen()</b> uses the <b>rsrcName</b> string <b>functionGenerator</b>, which is an alias set up by users when the function generator is first attached via USB.</p><p>Next, add the Form1 class variables in <A HREF="0404purcelll3.htm" target="_BLANK">Listing 3</A>. The <b>programMessage</b> byte array is used as a buffer when calling <b>viWrite()</b>. <b></p><p>Step 4: Adding VISA Calls to Change the Frequency. </b>The IDE automatically adds additional skeleton code that executes when users change the TrackBar slider position. To see this, make Form1.cs [Design]* visible in the IDE, then double left-click on the TrackBar. The IDE generates a skeleton event handler, switches the view to the Form1.cs code view, and prompts you to enter in code. <A HREF="0404purcelll4.htm" target="_BLANK">Listing 4</A> is event-handler code that changes the function generator frequency.</p><p>Before compiling, add:</p><pre><i>using System.Text;</i></pre><p>near the top of Form1.cs, just after the existing using statements. This uses the types in the </b><b>System.Text</b> namespace, allowing <b>Encoding.ASCII.GetBytes()</b> to compile successfully. <b>Encoding.ASCII.GetBytes()</b> serves to convert a stream of Unicode characters into ASCII bytes and pack them into the <b>programMessage</b> byte array.</p><p>So after writing just 10 or so lines of C# code, you have a simple program &#151; complete with a GUI &#151; which can be used to control the frequency of a function generator.</p><h3>C# and IVI Software</h3><p>Admittedly, the program I've just presented has a limitation. The program message string syntax to change the frequency is hard-coded, and may need to change if a different function generator is used. This is because the syntax to change frequency may not be universally understood. IVI software, developed within the IVI Foundation (<a href="http://www.ivifoundation.org/">http://www.ivifoundation.org/</a>), works around this problem by defining common APIs for function generators, digital multimeters (voltmeters), oscilloscopes, and other such instruments. If an application uses IVI software and only calls the specification-required functions, there should be no need to change the application code if a different instrument is used. </p><p>Since Agilent has IVI software available for the 33220 function generator, I'll use it to develop a second application that also sets the frequency. I use IVI-COM software because C# has built-in support for COM. This requires the installation of Agilent's IVI components and 33220 IVI-COM Driver (both available at <a href="http://adn.tm.agilent.com/">http://adn.tm.agilent.com/</a>).</p><p>After installing the software, go ahead and create a new project, but this time call it functionGenerator_IVI_1. Again, the IDE creates a skeleton application with a Form1.cs file. To use COM objects in C#, you must add a reference to the COM object. In the Solution Explorer window, add a reference by right-clicking on References, then select Add Reference, then select the COM tab. As in <A HREF="0404purcellf3.htm" target="_BLANK">Figure 3</A>, scroll down to the IVI Agilent 33220 (Agilent Technologies) 1.0 Type Library entry, then add it in using Select|OK. This is the only COM object reference that has to be manually added; the other necessary references are added automatically. The Solution Explorer window in <A HREF="0404purcellf4.htm" target="_BLANK">Figure 4</A> should then appear. Next, with the IDE view of Form1.cs [design]*, drag the TrackBar and Label GUI items onto Form1, as in the first example. Switch to view the code in Form1.cs and add a Form1 class variable for the function generator IVI-COM object, <b>fgen</b>; see <A HREF="0404purcelll5.htm" target="_BLANK">Listing 5</A>.</p><p>In the <b>Form1()</b> constructor (after <b>InitializeComponent()</b>), the <b>fgen </b>object is instantiated (<A HREF="0404purcelll6.htm" target="_BLANK">Listing 6</A>). Again as in the first example, double left-click on the TrackBar in the Form1.cs [design]* window, and the IDE automatically adds a skeleton <b>trackBar1_Scroll()</b> function, and prompts you to enter code. The code I added was:</p><pre>private void trackBar1_Scroll(object sender, System.EventArgs e){   fgen.Output.Frequency = trackBar1.Value;}</pre><p>The application is now complete and fully functional &#151; and after manually adding only four lines of code. These examples show how easy it is to use C# to communicate to electronic test instruments. They also illustrate how easy it is to use C# to call functions in existing DLLs and call COM object methods. </p><h3>References</h3><p>[1] Hill, Keith. "C#: A More Productive Alternative to C/C++ for T&amp;M Software Development," Agilent Developer Network whitepaper (<a href="http://www.agilent.com/find/adn/">http://www.agilent.com/find/adn/</a>), January 2003. </b></p><hr><I><b>Andy Purcell</b> is an R&amp;D engineer for instrumentation at Agilent Technologies (<a href="http://www.agilent.com/">http://www.agilent.com/</a>). Andy can be contacted at <a href="mailto:andy_purcell@agilent.com">andy_purcell@agilent.com</a>.</I><hr></body></html>