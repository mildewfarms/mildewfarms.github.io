<html>
<head>
<title>November, 2004: Asynchronous Delegates  &amp; C++</title>
</head>

<body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000">
<!--Copyright &#169; C/C++ Users Journal-->

<h1>Asynchronous Delegates  &amp; C++</h1>
<p><i>C/C++ Users Journal</i> November, 2004</p>
<h2>.NET-style calls implemented in C++</h2>


<h3>By Drazen Dotlic</h3>


<I>Drazen Dotlic is a Windows C++ software architect who lives in France. He can be contacted at http://drazen.dotlic.name.</I>

<hr>





<p>Operations such as loading web pages, fetching data from databases, or crunching numbers are usually performed in the background, so as not to disturb the responsiveness of running applications. This is typically done by creating a separate thread. However, if you have many operations throughout the execution of your application, you should consider using asynchronous function calls. Asynchronous calls return immediately (usually giving back handle-like call identifiers), execute on a thread separate from all other threads, and deliver results to your callback function once they're done. The .NET Framework supports asynchronous programming via delegates&#151;type-safe function wrappers. </p>

<p><a href="0411dotlicl1.html" target="_BLANK">Listing 1</a> illustrates an asynchronous delegate in C#. Every call consists of two phases&#151;initiating the call and getting the result value. <b>BeginInvoke</b> initiates the call, immediately returning <b>IAsyncResult</b>. Its signature is identical to the signature of the target function, plus two more parameters. The first references the <b>AsyncCallback</b> delegate receiving the result value, and the second references the object with additional state information, also saved as <b>IAsyncResult.AsyncState </b>(both can be null). <b>EndInvoke</b> returns the result value, using <b>IAsyncResult</b> to identify the call. One delegate can be invoked several times, and the order of execution of these calls is not guaranteed to be the same as the invocation order.</p>

<p>Calls 1-3 block waiting for the result value, either by calling delegates <b>EndInvoke</b> and <b>IAsyncResult.WaitOne()</b>, or by looping on the <b>IAsyncResult.IsCompleted</b> flag. Call 4 provides <b>ResultCallback</b> to get the result value, and <b>delegate</b> itself as <b>AsyncState</b>. All calls execute on a thread from a thread pool separate from any of your threads, including a call to <b>ResultCallback</b>. It is up to you to ensure that your shared data is thread-safe. For calls 1-3, I could have opted to ignore the result completely, which is useful for fire-and-forget scenarios.</p>
<h3>C++ Implementation</h3>

<p>Instead of inventing a unique mechanism for asynchronous call support in C++, I decided to mimic .NET delegates. My goal was to have a portable, pure C++ solution with the syntax and behavior as close as possible to the .NET approach. It turns out this is not too difficult, thanks to Boost (http://www.boost.org/). My code depends on Boost 1.31, the version available at the time of this writing. Since there are no other dependencies, my implementation should be quite portable, and I've successfully tested it under GCC 3.3.1 and Microsoft Visual C++ 7.1. The complete source is available at http://www.cuj.com/code/.</p>

<p>At the outset, I decided not to sacrifice type safety just to adhere to .NET's approach. Consequently, my first departure was not to use (synchronous) delegates for result callbacks&#151;good old-fashioned pointers to objects implementing an interface is good enough. (For a discussion of delegates with synchronous call semantics in C++, see [1].) Besides, I wanted to focus on the asynchronous aspects of delegates.</p>

<p>The second difference in my implementation is that the last parameter of <b>BeginInvoke</b> (<b>AsyncState</b>) ends up being used mainly to send the delegate itself to the result callback, but only so that you can access the result value. Therefore, I removed <b>AsyncState</b> and modified the result callback signature to accept the result value directly.</p>
<h3>C++ Use</h3>

<p>In <a href="0411dotlicl2.html" target="_BLANK">Listing 2</a>, which shows my C++ <b>delegate</b> class in action, a <b>typedef </b>resembles the .NET <b>delegate</b> declaration. Since you can't have pointers to member functions of an object in C++, <b>delegate</b> accepts the pointer to the object and a pointer to the member function of a class of that object. The rest of <a href="0411dotlicl2.html" target="_BLANK">Listing 2</a> demonstrates the same features as <a href="0411dotlicl1.html" target="_BLANK">Listing 1</a>.</p>

<p><a href="0411dotlicf1.html" target="_BLANK">Figure 1</a> provides an overview of the participating objects. When <b>delegate</b> is invoked, an instance of one call is created using an internal factory. <b>Delegate</b> stores a call pointer in an asynchronous result and queues it in a work queue&#151;a thread-safe container for calls. The thread pool pulls calls from the work queue one by one and invokes them on private threads. In turn, this invokes the function wrapped by the call. Meanwhile, the asynchronous result is returned from <b>delegate</b> and can be used to track the progress of execution or to wait for the result value.</p>
<h3>Supporting Classes</h3>

<p>Like the .NET approach, my implementation uses a separate thread pool for asynchronous execution; see the <b>thread_pool</b> class in <a href="0411dotlicl3.html" target="_BLANK">Listing 3</a>. In the constructor, based on a sole input parameter (<b>threads</b>), the number of threads is created and kept in <b>boost::thread_group</b>. A thread function for all these threads (<b>thread_func</b>) loops, getting items from a <b>work_queue</b> (which is where pending asynchronous calls are kept) and executes (invokes) them. To avoid a rogue function's exception thrown to crash a thread from the pool, all exceptions are caught and ignored. Normally, when there is no work, <b>thread_func</b> expects calling <b>work_queue::dequeue_item</b> to (efficiently) block. To tell pool threads to shutdown, fake asynchronous calls in the destructor of <b>thread_pool</b> are queued (as many <b>last_call</b> objects as there are threads executing), whose only purpose is to return <b>false</b> when invoked&#151;a signal to stop processing. After that, I call <b>boost::thread_group::join_all</b>, which blocks until all threads of a group finish executing. The call queue is FIFO and the pool does not destruct until all previously scheduled calls are executed.</p>

<p>The call queue is implemented in the <b>work_queue</b> class (<a href="0411dotlicl4.html" target="_BLANK">Listing 4</a>), and demonstrates a simple form of the Monitor pattern (http:// www.boost.org/libs/thread/doc/bibliography.html). It is also a Singleton with only two public methods&#151;one for adding and another for removing items from the queue (represented by <b>std::list</b>). To avoid unnecessary copying, only <b>boost::shared_ptr</b> pointers to calls in the list are kept, with a goal to allocate calls only once. <b>boost::shared_ptr</b> is a reference-counted smart pointer. It is safe to keep in containers, and similar to <b>std::auto_ptr</b>&#151;it deletes owned objects once the reference count reaches zero. Both public methods of <b>work_queue</b> are made thread-safe by using (internal) <b>boost::mutex </b>wrapped with <b>boost::mutex::scoped_lock</b>, which releases the lock after execution leaves the scope. However, <b>dequeue_item</b> needs to block when there are no items in the queue. That's what <b>boost::condition</b> is used for&#151;it is a thread primitive that accepts any lock (in this case, <b>scoped_lock</b>) and functor (<b>not_empty</b>, which returns <b>true</b> when the queue is not empty). When constructed, condition releases the lock it was given and waits (efficiently blocking the current thread) for the signal to continue. This signal should come from another thread in the form of a <b>notify_one</b>/<b>notify_all</b> member function&#151;the former resumes execution of one waiting condition (blocking on some other thread), and the latter resumes all. In this case, <b>notify_one</b> is called from <b>queue_item</b> immediately after the new item (call) has been added, signaling that it can be dequeued. If there is no thread waiting on the condition, calling <b>notify_one</b>/<b>notify_all</b> does not have any effect. Functor protects from corner cases to ensure that the condition should continue. <b>work_queue</b> does not do any processing on its own&#151;it is just a thread-safe container for pending asynchronous calls.</p>

<p>Both <b>thread_pool</b> and <b>work_queue</b> work with <b>simple_call</b> objects (<a href="0411dotlicl5.html" target="_BLANK">Listing 5</a>). This is a simplified representation of a pending call, stripped of any kind of concrete parameters or return value of the underlying call. Its members are mostly self explanatory&#151;<b>invoke</b> executes the target function, <b>is_completed</b> is <b>true</b> after the execution, and <b>wait_completion</b> blocks until execution is completed. The last two members work together&#151;<b>clone</b> is called to make a copy of any object that implements <b>make_clone</b>. This lets you clone objects derived from <b>simple_call</b> using only a <b>clone</b> (static) method&#151;a technique identical to (and borrowed from) Loki Functor cloning [2]. None of the code up to now deals with delegates, and it is indeed possible to use <b>thread_pool</b> and <b>work_queue</b> to work with any other class that implements <b>simple_call</b>.</p>
<h3>Delegate Implementation</h3>

<p>An asynchronous delegate is essentially a generalized functor with delayed execution that optionally delivers a result value through a callback. Delivery of the result value is the duty of the dispatcher template derived from <b>simple_call</b>. Its only template parameter is the type of the return value. It declares a pure virtual method called <b>result </b>that returns the result value, and defines the method <b>deliver_to</b> that stores a pointer to the implementation of <b>async_callback</b>. If you want to get a result value through the callback, just derive from <b>async_callback</b> and implement its only method <b>accept_result</b>. Furthermore, the generalized functor aspect is implemented with the <b>callable</b> interface. The design is, again, strongly influenced by the Loki Functor. The target function signature, consisting of a return value and parameters, is modeled on a template with two type parameters&#151;the return value type and the type list for parameter types (type lists manipulation uses <b>boost::mpl</b>, a powerful library that allows compile-time operations on a container of types as if it was an <b>std::list </b>of types). The template is then specialized for the number of parameters: 0, 1, 2... Each specialization has a (pure virtual) <b>operator()</b> with exactly the same parameters (and in the same order) as in the parameter type list. This is identical to the order and parameters of the target function. <b>callable</b> derives from <b>dispatcher</b>, templated by the (known at this point) return value type.</p>

<p>Delayed execution is handled by <b>delegate_impl</b> (<a href="0411dotlicl6.html" target="_BLANK">Listing 6</a>), templated by the <b>delegate</b>, the pointer to the object and the pointer to the member function of a class of the same object. It forwards a return value type and a parameter type list to <b>callable</b> (from which it derives), expecting these types to be inner <b>typedef</b>s of a <b>delegate</b>. The constructor expects a concrete pointer to the object and member functions of a class, storing them internally. Every <b>operator()</b> from all specializations of <b>callable</b> is implemented here, but this will not lead to a call bloat&#151;only one "correct" member is instantiated, the one matching parameter type list. It is in <b>operator()</b> that everything fits together&#151;parameter values, return value types, and member functions of an object are bound using <b>boost::bind</b> (similar to <b>std::bind</b>, only providing generalized binding with more than two parameters). <b>boost::bind </b>returns an unspecified class that behaves like a function with no parameters that, when called, forwards the call to an embedded (in this case) member function of an object with bound parameters. This is further wrapped in another generalized functor, <b>boost::function</b> (forwarder) with no parameters and a return type identical to target function result value type. This makes delayed calling both possible and simple. There are other (pure) virtual methods of inherited classes to implement, starting with <b>simple_call</b>:</p>



<ul>
  <li><b>make_clone</b> returns a copy with the same pointer to an object and member function of a class. This makes any <b>delegate_impl</b>-specific class a factory of itself.</li>
  <li><b>invoke</b> calls through forwarder, stores a return value to <b>internal _result</b> and, using <b>scoped_lock</b> on internal <b>mutex</b>, blocks code in other threads until execution is finished. This function is called exclusively in the context of one of the threads in the thread pool, and declares the execution as finished by setting the internal Boolean flag (<b>_done</b>) to <b>true</b>. Then, internal <b>condition _completed</b> is signaled (using <b>notify_all</b> because you might wait for completion in more than one thread) and if a pointer to <b>async_callback</b> was provided, the return value is delivered through it.</li>
  <li><b>is_completed</b> returns <b>_done</b>, signifying finished execution.</li>
  <li><b>wait_completion</b> is using <b>scoped_lock</b> on the same internal mutex as invoke, making sure to block until execution is finished; if <b>lock</b> was acquired and <b>_done</b> is <b>true</b>, it returns immediately; otherwise, it blocks on <b>_completed</b> (which will be eventually signaled by <b>invoke</b>).</li>
  <li><b>result</b> just returns the return value.</li>
</ul>



<p><b>delegate_impl</b> ultimately represents one call. Also, I make assumptions without which the code won't work correctly&#151;<b>invoke </b>and <b>wait_completion</b> should execute on different threads, <b>result</b> should not be called until <b>invoke</b> has finished, and <b>invoke</b> should be called after <b>operator()</b> has been called. All of this is orchestrated in <b>delegate</b>, a class that is exposed to you.</p>

<p>All that is left is to implement the delegate. It is a template with two type parameters&#151;a return value type and a type list for parameter types (<a href="0411dotlicl7.html" target="_BLANK">Listing 7</a>). Each parameter from the parameter type list is extracted using the metafunction <b>at_v</b> (essentially a compile-time <b>if</b>). For each position (1,2,3...), types <b>p1</b>, <b>p2</b>, and <b>p3</b> are generated. I could have put return value type in the same list with parameters, but this way it resembles a function signature better. The constructor of <b>delegate</b> is templated by a pointer to an object (<b>ptr_obj</b>) and a member function of a class of that same object (<b>mem_fun</b>). It is this member function that is eventually called, and its signature must match what delegate's template parameters say. The only thing that happens here is that an instance of <b>delegate_impl</b>, called <b>_impl_factory</b>, is created. This object will produce other <b>delegate_impl</b> objects with the same <b>ptr_obj</b> and <b>mem_fun</b> as passed in the constructor. There are two reasons for this: Type information on <b>ptr_obj</b> and <b>mem_fun</b> is lost after the constructor is executed. Another reason for a factory is that the same <b>delegate</b> can be called multiple times, so for each of the calls we need to produce one instance of <b>delegate_impl</b>.</p>

<p>The only two public members of <b>delegate</b> are <b>begin_invoke</b> and <b>end_invoke</b>. Similar to <b>delegate_impl</b>, there is one <b>begin_invoke</b> for 0,1,2... parameters. Again, this might look like a code bloat, but because delegate is a template, only one (the "right") <b>begin_invoke</b> gets instantiated for each call (or if there is no match, you get a compilation error). Along with the parameters for a target function, <b>begin_invoke</b> optionally accepts a pointer to the object that implements the <b>async_callback</b> interface. Every <b>begin_invoke</b> does three things. First, a new <b>delegate_impl</b> is created (from now on referred to simply as a call), using the previously mentioned cloning technique with <b>_impl_factory</b>. If a pointer to the <b>async_callback</b> was provided, it is stored in the call using <b>deliver_to</b>. Result is further cast to callable so that <b>operator()</b> can be called, and binding is performed. A new item is queued up and stored internally in a list of calls and <b>async_result</b>, which wraps the newly created call, is returned. Mostly, <b>async_result</b> only delegates work to a wrapped call&#151;<b>is_completed</b> forwards to <b>delegate_ impl::is_completed</b> and wait forwards to <b>delegate_impl::wait_ completion</b>. Also, <b>async_result</b> befriends delegate so that it can return a wrapped call through the private member <b>get_call</b>. It is in the<b> end_invoke</b> that everything fits together. The call is taken from <b>async_result</b> and checked if it is on the list of items generated from this <b>delegate</b>; if not, <b>bad_async_result</b> is thrown. If the call is owned, <b>wait_completion</b> is called and, when finished, the return value is provided through <b>result</b>. So, the delegate public interface, meant to be called from your threads, satisfies all assumptions about <b>delegate_impl</b> usage. On the other hand, <b>invoke</b> gets called only from thread pool threads, exactly as needed. </p>
<h3>Improvements and Discussion</h3>

<p>An unexpected result of my approach is that if some of the parameters for the target function are references, then the value, if changed in your target function, will not be changed through the referenced variable. Due to the forwarding problem (http://std.dkuug.dk/jtc1/ sc22/wg21/docs/papers/2002/n1385.htm), there is no perfect way to bind the arguments (that are references) correctly in all circumstances. Consequently, I let <b>boost::bind</b> do its default&#151;make a copy of all arguments passed. If you want changes to parameters in the target function to persist, use a pointer. </p>

<p>Another complicated problem is catching exceptions thrown by target functions, and possibly forwarding them into the context of your threads by storing and delivering them to you along with the return value in <b>accept_result</b>. Thus, the thread pool ends up catching all exceptions, including access violations (null pointer usage, for example), but the alternative ("advanced") solution would obscure the point of the article too much.</p>

<p>You might also tweak <b>thread_pool</b> to increase/decrease the number of worker threads based on the number of pending calls/busy threads, but this also was left out for simplicity.</p>

<p>Finally, you might want to wrap calls to free functions, or even other functors, and not just the member function of an object. This would require changing <b>delegate</b> and <b>delegate_impl</b> a bit, but it should not be too complicated.</p>
<h3>References</h3>

<ol>
  <li>[1]	Smith, Daniel J. "Inside .NET's Delegates and Events Using C++," <i>CUJ</i>, September 2002. </li>
  <li>[2]	http://sf.net/projects/loki-lib, from <i>Modern C++ Design</i>, by Andrei Alexandrescu, Addison-Wesley, 2001. </li></ol>






</body>
</html>