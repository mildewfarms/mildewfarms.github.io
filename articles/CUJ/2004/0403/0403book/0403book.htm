<html><head><title>March 04: Programmer's Book Review</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; C/C++ Users Journal--><p><i>C/C++ Users Journal </i> March 2004</p><h1>Programmer's Book Review</h1><h3>By Jack J. Woehr</h3><br><b><i>C++ GUI Programming with Qt 3</b><br>Jasmin Blanchette and  Mark Summerfield</i><br>Addison-Wesley/Prentice Hall PTR, 2004<br>448 pp., $44.99<br>ISBN 0131240722<b><br><br>OpenGL Programming Guide: The Official Guide to Learning OpenGL, Version 1.4, Fourth Edition</b><i><br>Dave Shreiner, Mason Woo, Jackie Neider, and Tom Davis</i><br>Addison-Wesley Professional, 2004<br>800 pp., $59.99<br>ISBN 0321173481<b><br><br>Parallel and Distributed Programming Using C++</b><i><br>Cameron Hughes and Tracey Hughes</i><br>Addison-Wesley Professional, 2004<br>600 pp., $54.99<br>ISBN 0131013769<br><b><br>J2EE Open Source Toolkit: Building an Enterprise Platform with Open Source Tools</b><i><br>John T. Bell, James T. Lambros, and Stanford Ng</i><br>John Wiley &amp; Sons, 2003<br>612 pp., $50.00<br>ISBN 0471444359<br></h4><p>Qt from Trolltech is an open-source C++ library roughly comparable to a wide swath of the Java JDK in completeness and quality of implementation. Qt covers everything from GUI programming &agrave; la Swing to network communications and SQL. If it had a transaction processing layer, merely C++ plus STL plus Qt3 would together nearly rival Java right up to JSEE. Qt also underlies the KDE desktop (<a href="http://kde.org/">http://kde.org/</a>).</p><p>I love Jasmin Blanchette and Mark Summerfield's <i>C++ GUI Programming with Qt 3</i>. Seeing what a classically simple tutorial the authors have written (it could be Commodore Amiga "Intuition" documentation, so little have the stylistic requirements of good GUI library books changed in 20 years) finally motivated me to do more than download Qt3 and to actually start working with it. And how sublime Qt itself is, charmingly unsurprising to Java/Swing programmers who also understand STL. The book is written by Trolltech coders and officially approved by Trolltech (<a href="http://www.trolltech.com/">http://www.trolltech.com/</a>). It's suitable both for self-tutorial and classroom work.</p><p>The accompanying CD-ROM includes:</p><ul>  <li>Qt 3.2.1 noncommercial edition for Windows.  <li>Qt 3.2.1 free edition for X11.  <li>Qt 3.2.1 free edition for Mac OS X.  <li>Borland C++ Builder 5 noncommercial edition.  <li>Borland C++ Builder 6 trial edition.  <li>Source code for the book's examples.</ul><p>The Qt distribution includes the Qt library and standard Qt toolset, including qmake, Qt Designer, Qt Linguist, Qt Assistant, and the like.</p><p>The Qt Designer tool accompanying the book is not a full IDE, just a nice widget designer and minor-league code generator, though it does exhibit some buglets.<i></p><p>C++ GUI Programming with Qt 3</i> was written at Qt 3.2.1 level, but I built Qt 3.2.3 on Solaris 9 using GCC 2.95.3 and compiled and ran the book's applicable examples (three minor examples are either Windows or Mac specific) just fine. Just for the record, since I spent many hours building and rebuilding Qt3 itself, on Solaris 9 with GCC 2.95.3 I found the most congenial configuration command to be:</p><pre><b>$QTDIR/configure -qt-gif -thread -platform solaris-g++ </b></p></pre><p>The book's web site is <a href="http://vig.prenhall.com/catalog/academic/product/0,4096,0131240722,00.html">http://vig.prenhall.com/catalog/academic/product/0,4096,0131240722,00.html</a>, which includes a link for requesting instructor exam copies.</p><p>One thing leads to another. Qt3 contains support for OpenGL. My Solaris 9 installation sports OpenGL. Just as I finished reviewing the Qt3 book, the <i>OpenGL Programming Guide: The Official Guide to Learning OpenGL, Version 1.4, Fourth Edition</i>, by Dave Shreiner, Mason Woo, Jackie Neider, and Tom Davis, showed up on my desk. Serendipity! Or, almost serendipity: I'd actually opted out of installing OpenGL at Solaris 9 installation time, so I had to fish out the "Solaris 9 Software Supplement" CD, install OpenGL and rebuild Qt3, whose configuration discovered OpenGL's presence automatically without any special config switches.</p><p>OpenGL (<a href="http://www.opengl.org/">http://www.opengl.org/</a>) is the 3D graphics library that coalesced from Silicon Graphics' (<a href="http://www.sgi.com/">http://www.sgi.com/</a>) work on the Iris and other graphics workstations. The programming interface is free, while the implementors of the libraries themselves on various platforms pay licensing. Back in the 1980s, I remember watching with awe the SGI Iris demo of a candlestick rotating in a moving starfield, its gyrations controlled by the mouse. Such real-time manipulation was beyond the reach of most desktop computers in those days, even the mighty Amiga, but nowadays OpenGL is for the masses.</p><p>Fourth Edition or not, any book is a new book until you've read it, as I had not done yet. The Fourth Edition describes OpenGL 1.4. It's authoritative and complete, since it's prepared by the OpenGL Architecture Review Board. Fortunately, it's written like a self-tutorial rather than a manual, with all the skill and style of a first-class programming book. It helps to have some matrix math, trigonometry, and calculus to get the most out of this book: Luckily, I've found the math I picked up the hard way on various projects such as rotary machine control and OS/2 PM printer transformations and my stellar "B" in Calculus 101/102 30 years ago to be sufficient.</p><p>There's not much more to say about this book other than it's great and all sorts of good fun, especially the nifty demo code. If you want to do 3D real time and ray tracing, you might as well use OpenGL, since it's good, clean, and present on nearly every platform. And if you want to do OpenGL and haven't gotten very far yet, this is the book you want.</p><p>Errata for the <i>OpenGL Programming Guide</i> are at <a href="http://www.opengl-redbook.com/errata/">http://www.opengl-redbook.com/errata/</a>, though at the moment the errata are for the Third Edition. The source for this edition of the book is up, though, as well as its predecessors, and is posted at <a href="ftp://ftp.sgi.com/opengl">ftp://ftp.sgi.com/opengl</a>. The Addison-Wesley Professional page for the Fourth Edition is not yet up as of this writing at <a href="http://awprofessional.com/">http://awprofessional.com/</a>, which still lists the earlier edition for OpenGL 1.2.</p><p>Most of us don't have much use for parallelism beyond using that which we mistakenly call "symmetrical multiprocessing" (SMP, in practice utterly asymmetrical) to run concurrent processes and threads. That's certainly covered in <i>Parallel and Distributed Programming Using C++</i>, by Cameron Hughes and Tracey Hughes, but as long as we're going to pretend to be computer scientists, we shouldn't forget that scientific applications have use for other forms of parallelism for handling huge data and/or time-consuming but partitionable algorithms. The dominance of the SMP model in personal and business computers is an artifact of how hard it is in practice to parallelize computation. Concerns about efficient parallel algorithms peaked in the 1980s, when processor architecture was still in flux, design was not utterly dominated by the personal computer, and multiprocessors were expensive. Interest in theory receded somewhat in the 1990s with the throw-hardware-at-it philosophy born of the consumer economy of scale, which drove down prices. The problems of parallelism are coming to the fore again as we approach an era of quantum computing, which presents a more esoteric challenge to our ability to come up with useful algorithms.<i></p><p>Parallel and Distributed Programming Using C++</i> explores the most common techniques of parallelism appearing today in C++ programming in some detail. The work can reasonably serve as a personal or classroom introduction to best current practice, with which the authors exhibit a broad familiarity. The approach is straightforward and standard. The code is simple and clear and the concepts are easily assimilated. It is not, however, an adequate introduction to parallel algorithms per se. If it were music, this book would be jazz rather than classical. It's interesting to look back at <i>The Characteristics of Parallel Algorithms</i> (MIT Press, 1987; ISBN 0-262-10036-3) and consider the way people write about the more exotic aspects of computing has changed. Certainly in academia there has been a shift in emphasis from purity of theoretical model to turning out competent practical programmers.</p><p>Now for some nitpicking.</p><p>First, the theory in medicine that staring at computers can inculcate dyslexia finds anecdotal support in this book, where the page headings for section 13.5 "Implementing the Blackboard Using CORBA Objects" are transmuted for the next 17 pages into "COBRA Objects." This does not bode well for the quality of proofreading.</p><p>Second, I find Appendix B to be dangerously close to shovelware, consisting of POSIX specs for certain system calls. It's warm fuzzy feelings to have this info close at hand, but it is easy to find on the Web, and better to read directly from your OS provider, due to great flexibility in POSIX wording and wide variation in implementation and compliance. One hundred and twenty four pages of this stuff in a 692 page book is a bit like finding 17 percent sawdust in your sausage.</p><p>Finally, the authors compose page-long paragraphs as if they Read The Flamin' Manual all day. Good technical writing discretely exhibits literary merit. I find the discussion in <i>Parallel and Distributed Programming Using C++</i> substantial but congested, and often prescriptive rather than descriptive.</p><p>Author biographies, book description, table of contents, and sample chapters are found by searching <a href="http://awprofessional.com/">http://awprofessional.com/</a> for "0-13-101376-9".</p><p>Okay, <i>J2EE Open Source Toolkit: Building an Enterprise Platform with Open Source Tools</i>, by John T. Bell, James T. Lambros, and Stanford Ng, isn't about C++, but I found it interesting. Apparently the authors spent the past few professional years doing what I was doing during the same time frame: Developing a honking huge J2EE-based web service and building it on top of open-source software.</p><p>The advantage of using open-source software is that it is open, though not necessarily cheaper, as the back cover blurbs misleadingly suggest. The challenge of using open-source software is that there is no vendor to give you the whole vertical application stack in a box. You have to mix and match. It's very experimental: You may kiss a lot of frogs before you find your prince(ss). You're going to do in-house a lot of the integration work that a vendor would do for you. (Otherwise, you wouldn't need this book, right?) And if you're serious, you'll almost inevitably find yourself contributing patches to the open-source software you are leveraging to make sure you don't have to merge your changes into each subsequent release. After all, that's precisely how open source is supposed to work.<i></p><p>J2EE Open Source Toolkit</i> is an important book for you to read if you are dreaming of using open source to provide Java-based web services in a big way but are just starting down that particular yellow brick road. Bell et al., have covered in great breadth open-source software, Jakarta, Apache, Tomcat, JBoss, J2EE, JMS, various open-source databases, and the like, apparently because the authors have, of necessity, barked up every tree at one time or another. You go as far as you can with the easier-to-adopt tool until you hit some kind of wall and must adopt the next-most-difficult tool.</p><p>Thus far talented dilettantes could have gone. The internal evidence that the authors are not just playing around is their appreciation of scaling issues. Open-source software for web services has not to this date adequately addressed scaling, the problem of taking that nice model web service you designed in J2EE and distributing it so that a few hundred thousand users can access it per hour instead of a few hundred. Whereas commercial offerings tend to defer fun features in favor of delivering performance, no similar development philosophy has informed the open-source community until recently. JBoss, for example, is changing rapidly but at my last code freeze was not yet enterprise strength. JBoss 3 supports clustering, a topic only brushed up against lightly in the appendices to <i>J2EE Open Source Toolki</i>t, unsurprisingly since it's so new and probably still possessing what we in the open-source community call "issues."</p><p>The author's web site for the book is <a href="http://www.wiley.com/legacy/compbooks/bell/">http://www.wiley.com/legacy/compbooks/bell/</a>, which features the source code, contact info, and, interestingly and usefully, live links for all the links referenced in the book, by chapter. The Wiley web site with the free downloadable excerpt from the book is <a href="http://www.wiley.com/WileyCDA/WileyTitle/productCd-0471444359.html">http://www.wiley.com/WileyCDA/WileyTitle/productCd-0471444359.html</a>. </p><hr><I><b>Jack Woehr </b>is an independent consultant in Colorado. He can be contacted at <a href="http://www.softwoehr.com/">http://www.softwoehr.com/</a>.</I><hr></body></html>