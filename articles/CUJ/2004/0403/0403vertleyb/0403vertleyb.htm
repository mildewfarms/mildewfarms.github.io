<html><head><title>March 04: </title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; C/C++ Users Journal--><p><i>C/C++ Users Journal </i> March 2004</p><h1>RTL: The Relational Template Library</h1><h2>Adding relational algebra to your programming toolkit</h2><h3>By Arkadiy Vertleyb and Dmitriy Arapov</h3> <p>Although relational algebra is available to C++ programmers via relational database systems (RDBMS), the overhead of RDBMS prevents us from using relational algebra where it otherwise might have been attractive to do so. Moreover, the ODBC/SQL interface is such that C++ programmers cannot enforce compile-time type safety nor compile-time checks. Consequently, you only find out at runtime if (for example) a wrong column or table name is passed. Finally, the typical RDBMS only supports a limited number of types.</p><p>With this in mind, we developed RTL, a library that implements relational algebra while retaining the spirit of C++'s type safety and compile-time checks. (The complete source code for RTL is available at <a href="http://www.cuj.com/code/">http://www.cuj.com/code/</a>.) Our "relational table" looks similar to an STL container in that it provides an iterator to go through its items (tuples). A tuple can hold fields of any type, which satisfies the same requirements as for an STL container, and lets you set/access these fields in a type-safe manner. This is possible with the help of template meta-programming.</p><h3>Columns and Tuples</h3><p>How do you represent a relational table in C++? The closest approximation would be a vector of structures:</p><pre><b>struct employee{</p><p></b><b>  std::string name;</p><p>  int salary;</p><p>};</p><p></b><b>std::vector&lt;employee&gt; employees;</b></pre><p>However, the problem with this representation is its inability to create new tuple types based on given ones. For example, projection might require returning only salaries. That means you would need to define a structure containing only salaries, create a vector of such structures, and copy salaries from one vector to another. This looks impossible without the client code doing the entire job.</p><p>To design a relational table that would not have this problem, consider this class template:</p><pre></b><b>template&lt;class T&gt; struct column{</p><p></b><b>  typedef T type;</p><p>  T value_;</p><p></b><b>};</b></pre><p>An instantiation of this template with any given type (either built-in or user defined) is a class whose instances are capable of storing values of this type. The client code can now define new columns like this:</p><pre></b><b>struct name : column&lt;std::string&gt;</p><p></b><b>{};</p><p>struct salary : column&lt;int&gt;</p><p></b><b>{};</b></pre><p>The next thing to do is to combine columns in a tuple. You can use multiple inheritance for this:</p><pre></b><b>struct employee : public name, public salary{};</b></pre><p>Once the tuple is defined like this, you can use </b><b>static_cast</b> to set/access individual fields: </p><pre><b>employee emp;</p><p></b><b>static_cast&lt;name&gt;(emp).value_ = "Bill";</b></pre><p>Note how a class name (</b><b>name</b>, <b>salary</b>) plays the role of a column name. In other words, to define a new column, you have to define a new class, then use this class to reference the column.</p><p>So far so good, but you still have no way to manipulate the tuple type. What you are trying to do is gain not only the ability to access fields by name (which is provided by a C++ structure), but also the ability to treat fields in a regular way, like array items &#151; access them by index, enumerate, concatenate tuples, and so on.</p><p>Template meta-programming helps. You can start by combining columns in a typelist:</p><pre><b>typedef</p><p></b><b>  list&lt;name,</p><p></b><b>  list&lt;salary&gt; &gt; field_list;</b></pre><p>then derive the tuple from every column in the typelist. We wrote a template meta-function, </b><b>derive_from_all</b>, which is a simplified version of <b>GenScatterHierarchy</b>, described by Andrei Alexandrescu in <i>Modern</i> <i>C++ Design</i> (Addison-Wesley, 2001), and defined our tuple class as in <A HREF="0403vertleybl1.htm" target="_BLANK">Listing 1</A>. We also added access methods to avoid explicit use of <b>static_cast</b> in the client code. Now you can write something like this:</p><pre><b>tuple&lt;field_list&gt; emp;</p><p></b><b>emp[name()] = "Bill";</b></pre><p>As a result, we kept readable notation and gained an important benefit &#151; the ability to manipulate types of tuples at compile time. In <A HREF="0403vertleybl6.htm" target="_BLANK">Listing 6</A>, we concatenate arguments' </b><b>field_lists</b> to determine the type of the cross-product's tuple.</p><p>This approach does have a drawback. Every time a field is accessed, a temporary object has to be default-constructed to be passed as the parameter. This parameter is never used, but compilers do need it to properly deduce the template parameter of the member function. The cost of such construction may or may not be significant, depending on the field type. One option would be to pass a pointer rather than a reference, but this makes the notation much worse:</p><pre><b>emp[(name*)0] = "Bill";</b></pre><p>The solution we chose was to split the column class into two &#151; one containing the value itself (</b><b>column</b>), and another used to denote the column, without any data members (<b>column_name</b>). The cost of construction of an instance of such a class is negligible. After all these refinements, you can define columns like this:</p><pre><b>struct name : column_name&lt;</p><p></b><b>  column&lt;name, std::string&gt;</p><p></b><b>&gt;{};</b></p></pre><p>or, if you prefer using macros:</p><pre><b>COLUMN(name, std::string);</b></pre><h3>run_for_each</h3><p>It's often necessary to perform an operation on a given list of columns in a tuple. For example, projection requires you to copy explicitly listed columns from one relation to another. A column is identified by a type, so the task is to apply a given template function to every type in a given typelist.</p><p>Consider the </b><b>std::for_each</b> algorithm, which applies a given functor to each item in a container. In a similar fashion, our <b>run_for_each</b> (<A HREF="0403vertleybl2.htm" target="_BLANK">Listing 2</A>) applies a functor to each type in a typelist. For this to make sense, the function call operator of the functor has to be templated:</p><pre><b>template&lt;class T&gt;</p><p></b><b>  void operator()(T*);</b></pre><p>When you copy fields, it makes sense to copy all of them. However, if you compare fields, you have to stop comparison once you encounter the first pair with different values. To address this difference, </b><b>run_for_each</b> distinguishes between two types of function call operators. If the return type is void, it unconditionally proceeds until all the types in the typelist are processed. If it is Boolean, <b>run_for_each</b> stops once False is returned.</p><h3>Relations</h3><p>RTL is all about relations. Relations behave like STL collections of tuples. It is possible to iterate over relations.</p><p>Relations are either tables (which hold data) or relational operators. Operators don't store their tuples; instead, they hold references to their arguments. Operators produce tuples on-the-fly, as iterators are dereferenced. Since the arguments are, in turn, relations, the structure presents an expression tree, whose leaves are tables.</p><p>Examples of unary operators include <b>selection</b>, <b>projection</b>, and <b>groupby</b>, which take one relation as the argument. Binary operators, such as <b>intersection</b> or <b>cross_product</b>, take two relational parameters. Relations form compile-time composite patterns; tables serve as leaves. Relational operators calculate the type of their tuple at compile time. This is the main idea of RTL, which trades the flexibility of the traditional approach, based on SQL queries that are interpreted at runtime, for efficiency and strict type safety of native C++ code.</p><p>All relations are coded as pairs of template classes: a collection class and associated with it a bidirectional <b>const_iterator</b> class. The collection class provides begin and end methods, which construct and return <b>const_iterators</b>. It also contains range methods: <b>lower_bound</b>, <b>upper_bound</b>, and <b>equal_range</b>, which allow fast queries when the relation is ordered in a proper way.</p><p>Each relation publishes the type of tuple (<b>value_type</b>) and associated <b>const_iterator</b>.</p><p>Unlike in pure relational theory, RTL relations are sorted. Sort order is defined by <b>sort_list</b>, which is a typelist of columns. For each element of <b>sort_list</b>, the less functor must be valid. We compare tuples using lexicographic order, and order of field comparisons is coded by <b>sort_list</b>. Two tuples are equivalent (with respect to a given <b>sort_list</b>) if each pair of the fields listed in this <b>sort_list</b> is equivalent. If the <b>sort_list</b> is empty, then the relation is unsorted. If the relation cannot contain two equivalent tuples, we say that it is fully sorted and call the <b>sort_list</b> a key.</p><p>To distinguish whether <b>sort_list</b> of a relation is a key, each relation provides <b>is_distinct</b>, a compile-time Boolean:</p><pre><b>enum {is_distinct = ...};</b></pre><p>Tables get the </b><b>is_distinct</b> value as a template parameter, while operators calculate it based on <b>is_distinct</b> values of their arguments. Its value is True if we can state that there are no equivalent tuples in the relation.</p><h3>Tables</h3><p>Tables are the only relations that actually store data (see <A HREF="0403vertleybl3.htm" target="_BLANK">Listing 3</A>). The only mandatory template parameter is the tuple type. The second parameter is a typelist of columns of the table and defines the sort order. The third parameter lets users choose the table implementation. The fourth parameter says whether the <b>sort_list</b> of the table is a key. In applications, tables can have different implementations such as sorted vector, set, or B-tree. We deliberately keep table implementations out of the scope of the library, but do provide an in-stock, sorted vector-based implementation.</p><h3>Relational Operators</h3><p>Unlike tables, relational operators do not take the tuple type as a template parameter &#151; they calculate this type themselves at compile time. Also unlike tables, relational operators do not store tuples. They keep only pointers to the relations they are based on. This way the memory overhead associated with relational operators is minimized.</p><p>Iterators store position in terms of iterators of the base relations. They also store pointer to the relation they belong. In this way, several iterators operating on a single relation can share common, position-independent, data.</p><h3>Selection</h3><p>We use selection as our first example. Selection is a relation, which selects those tuples from another relation that satisfy a given predicate. The predicate has to provide:</p><pre><b>bool operator()(const T&amp; t) const;</b></pre><p>where </b><b>T</b> is the tuple type of the argument. We store the predicate inside the selection object to let all iterators share it (see <A HREF="0403vertleybl4.htm" target="_BLANK">Listing 4</A>).</p><p>Compile-time computations for selection are trivial: The resulting relation has the same type of tuple and same <b>sort_list</b> as base relation. Runtime operations are also trivial, except increment and decrement operators of the <b>selection_iterator</b>. The <b>selection</b> template function is used to construct <b>selection_t </b>objects in a similar fashion, and for the same purpose that <b>std::make_pair</b> or <b>std::bind1st</b> are used in STL.</p><h3>Example</h3><p><A HREF="0403vertleybl5.htm" target="_BLANK">Listing 5</A> is a complete example. Assume you have a table with three columns &#151; <b>ssn, name, </b>and <b>year</b> &#151; and you need to print all tuples with the <b>year &lt;= 1965</b>. The function <b>print</b> is a template function that works with all possible types of relations and is implemented with the help of <b>run_for_each</b>.</p><p>The library also provides a few predefined predicates, so in many cases users don't have to define one. The client code:</p><pre><b>print(selection(staff,</p><p></b><b>  and(</p><p>    ge&lt;year&gt;(1963),</p><p></b><b>    le&lt;year&gt;(1965))));</b></p></pre><p>prints the tuples where the year is between "1963" and "1965", without defining any predicate. </p><h3>cross_product</h3><p>The <b>cross_product</b> of two relations contains all possible concatenations of tuples of the first relation with tuples that belong to the second relation. <b>cross_product</b> exploits advantages of compile-time type calculations (<A HREF="0403vertleybl6.htm" target="_BLANK">Listing 6</A>). The tuple of the resulting relation contains all fields from each of the base relations. While it is easy to calculate <b>field_list</b> and <b>value_type</b>, a <b>sort_list</b> of the result is not so evident. It depends on whether the <b>sort_list</b> of the first argument is a key. If the first argument is fully sorted, then <b>sort_list</b> is concatenation of <b>sort_lists</b> of arguments; otherwise, it is simply <b>sort_list</b> of the first argument.</p><h3>Are Tuples Distinct?</h3><p>Our implementation does not require tuples to be distinct; however, we have two relations that handle this. The first relational operator that does this scans the base relation, skipping duplicates:</p><pre><b>template&lt;class Table&gt;</p><p></b><b>  class distinct {</p><p>    enum {is_distinct = IsDistinct};</p><p>    ...</p><p></b><b>};</b></pre><p>The other relational operator is:</p><pre></b><b>template&lt;class Table,</p><p></b><b>  bool IsDistinct&gt;</p><p>  class declare_distinct</p><p>{</p><p>  enum {is_distinct = IsDistinct};</p><p>  ...</p><p></b><b>};</b></pre><p>This relation does nothing in runtime, instead forwarding all operations to its base relation. Why do we need it? In some situations, users know that a relation is fully sorted, but RTL can't deduce this from the relation's arguments. </b><b>declare_distinct</b> lets users make the hint.</p><h3>Using the Sort Order</h3><p>Ordinary selection scans the whole base relation. However, if a predicate is a simple comparison based on a column and the table is sorted on this column, it is possible to figure out the result much faster. Sorted vectors (which are our model implementation of tables) let you find a range of tuples making <b>O(ln(n))</b> comparisons, where <b>n</b> is the number of rows in the table. Join relations, based on such predicates, can also benefit from the sort order on tuples.</p><p>Simple comparisons based on a column or list of columns have one common property &#151; they produce a contiguous range of tuples. RTL's <b>range_t</b> relation describes this contiguous range. The <b>range_t</b> constructor takes two iterators pointing into the same relation &#151; the first marks the beginning of the range, and the second its end.</p><p>We name methods to resemble their counterparts in STL, but unlike in STL, <b>equal_range</b> does not return <b>std::pair</b> of iterators, but rather a new relation, <b>range_t</b>. All three methods are template methods that take as a parameter any subtuple that forms a prefix of the <b>sort_list</b>. </p><p><A HREF="0403vertleybl7.htm" target="_BLANK">Listing 7</A> implements of <b>equal_range</b> for <b>selection_t</b>. First, we create the range on the base relation. Then we construct a new selection, which is based on this range rather than on the whole base relation. This selection contains the same tuples as the desired result. The last two lines form the correct iterators and return the result. This technique (with minor changes) was used for all relational operators. The implementation of <b>lower_bound</b> and <b>upper_bound</b> is similar. Sort order is heavily used by join relations and fast selection functions; see <A HREF="0403vertleybl8.htm" target="_BLANK">Listing 8</A>.</p><h3>Indexes</h3><p>The sort order plays a significant role in relational computations. However, each relation has only one sort order. To deal with this limitation, RTL provides function invert and two relational operators. The template function invert is defined as:</p><pre><b>template&lt;</p><p></b><b>  class SortList, class Strategy,</p><p>  bool  IsDistinct, class Table</p><P>&gt;</p><p>table&lt;typename Table::value_type,</p><p>SortList, Strategy, IsDistinct&gt;</p><p>invert(const Table&amp; t,</p><p>  const SortList* s = 0,</p><p></b><b>  const Strategy* p = 0) {...}</b></p></pre><p>It takes a relation and materializes it with a given sort order. Inverted tables are good techniques when the number of columns is small and attributes do not require much memory. Otherwise, it may be better to use indexes. An index is a relation that mimics its base relation in all aspects except the sort order.</p><p>There are two index classes: <b>interator_index_t</b> and <b>key_index_t</b>.</p><pre><b>template&lt;class Table,</p><p></b><b>  class SortList,</p><p>  class Strategy&gt;</p><p>class iterator_index_t {...};</p><p>template&lt;class Table,</p><p>  class SortList,</p><p>  class Strategy&gt;</p><p></b><b>class key_index_t {...};</b></pre><p>Both classes take three template parameters: base relation, a new </b><b>SortList</b>, and <b>Strategy</b>. The last parameter tells RTL how to implement internally used tables. These tables keep only fields from <b>SortList</b>, plus information that lets you find a whole tuple in the base relation. Basic difference between two indexes is the way they store this information. <b>iterator_index</b> stores iterators, which mark positions in the base relation. <b>key_index</b> stores a key from the base relation. It is possible to create <b>key_index</b> only when the base relation is fully sorted; for example, when <b>Table::is_distinct</b> is True. </p><hr><I><b>Arkadiy Vertleyb</b> and <b>Dmitriy Arapov</b> have been programming in C++ for more than 10 years. They can be contacted at <a href="mailto:vertleyb@hotmail.com">vertleyb@hotmail.com</a> and <a href="mailto:dmitriy_arapov@hotmail.com">dmitriy_arapov@hotmail.com</a>, respectively.</I><hr></body></html>