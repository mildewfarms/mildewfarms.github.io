<html><head><title>March 04: </title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; C/C++ Users Journal--><p><i>C/C++ Users Journal </i> March 2004</p><h1>A C++ Template Wrapper for the XML SAX API</h1><h2>Decoupling processing, eliminating duplication, and hiding the details of SAX</h2><h3>By Yingjun Zhang</h3><p>Two common techniques are often used to parse XML documents &#151; the Simple API for XML (SAX) and the Document Object Model (DOM). When used to manipulate XML files, the DOM reads a file, breaks it into individual objects (such as elements, attributes, and comments), and creates a tree structure of the document in memory. You can reference and manipulate each object or node easily. However, because it reads the entire file into memory, DOM consumes significant memory when the document is large. </p><p>Unlike DOM, SAX parsing is event based. It reads a section of an XML document, generates events as it finds specific symbols in the XML document, and then moves on to the next section. By processing documents in this serial fashion, SAX uses much less memory than DOM and is better for processing large documents. The straightforward way to use SAX is to create different functions to respond to those events. Those functions generally contain multiple if-else-if blocks to process different elements found in the XML document. This leads to extensive code duplication in multischema environments and presents a high degree of coupling between parsing code and business logic. In this article, I present a mechanism to decouple processing, eliminate duplication, and further simplify the development interface by hiding the details of SAX. The complete code for this is available at <a href="http://www.cuj.com/code/">http://www.cuj.com/code/</a>.</p><p>SAX models the information set through a set of abstract programmatic interfaces including <b>ContentHandler</b>, <b>DTDHandler</b>, <b>LexicalHandler</b>, <b>ErrorHandler</b>, and the like. Each interface models the information set as an ordered sequence of method calls. For example, consider this simple document:</p><pre><b><p>&lt;code&gt;</p><p>&lt;?xml version="1."?&gt;</p><p>&lt;BookedOrder&gt;</p><p>&lt;OrderID&gt;1000&lt;/OrderID&gt;</p><p>&lt;/BookedOrder&gt;</p><p>&lt;text&gt;</b></p></pre><p>As the SAX parser processes this document, it generates a sequence of events such as this:</p><pre><b><p>&lt;code&gt;</p><p>StartDocument();</p><p>StartElement("BookedOrder")</p><p>StartElement("OrderID")</p><p>Characters("1000")</p><p>EndElement("OrderID"")</p><p>EndElement("BookedOrder")</p><p>EndDocument()</p><p>&lt;text&gt;</b></p></pre><p>These methods are the main components of the <b>ContentHandler</b> interface, which is also the primary interface of SAX. Here I focus on <b>ContentHandler</b>'s implementation and use. <b>ISAXContentHandler</b> is Microsoft's implementation of this interface. All code presented in this article centers around this interface. For details on <b>ISAX</b><b>ContentHandler</b> and Microsoft's XML Parser (MSXML), refer to the MSDN library [1]. </p><h3>The Brute-Force Way</h3><p>Typical examples for using the SAX API rely upon brute force: You create different functions to respond to those events and do relevant processing in each function after comparing element names. <A HREF="0403zhangf1.htm" target="_BLANK">Figure 1</A> is a sample XML document with some simplified customer orders. <A HREF="0403zhangl1.htm" target="_BLANK">Listing 1</A> is an implementation of <b>ISAXContentHandler</b> named as <b>CustomerOrderHandler</b>. In the member function <b>startElement()</b>, it simply records the name of the element currently being parsed into the member variable <b>m_CurrentTag</b>. This variable is later used in the <b>characters()</b> function to decide the proper conversion for each element by comparing it with <b>pwchLocalName</b>, which is the tag name associated with the element content. In the <b>endElement()</b> event, the entire customer order is processed after the <b>CustomerOrder</b> element is ended. In this example, I just print it out. </p><p>While this approach is straightforward, it has two disadvantages. First, not only is the parsing of different elements mixed together, but the business-processing code is also tightly coupled with the parsing code. This violates a basic object-oriented principle &#151; the separation of concerns &#151; and leads to potential maintenance headaches. Second, in most enterprise applications you would need to parse multiple XML documents with different schemas. For example, other than customer order, you may also need to parse XML documents for replenishment order, purchase order, and so on. As with <b>CustomerOrderHandler</b>, you would need to write a <b>ReplenishmentOrderHandler</b> for replenishment orders, <b>PurchaseOrderHandler</b> for purchase orders, and so on. The list could be long, depending on the number of XML schemas you need to deal with. Furthermore, you would also find that these handlers are similar and that you're writing similar multiple if-else-if blocks for those events of <b>ContentHandler</b> over and over again. As the number of XML schemas grows, it then becomes tedious and, as copy-and-paste would most likely be used, can lead to subtle bugs that are hard to locate. </p><h3>The Template Wrapper</h3><p>Design patterns are proven solutions for reoccurring problems. When facing a design issue, I always resort to applicable design patterns first, if any. To address the design concerns of the brute-force technique, first take a look at some characteristics of XML documents. XML documents could often be represented as a tree structure (remember, DOM always does this). In this tree, the root would be a document-level element composed of multiple composite elements. Those composite elements could further be composed of other composite elements and/or atomic elements. These elements would be the nodes and leaves of the tree. Applying the divide-and-conquer mechanism, parsing an XML document could be accomplished by fully parsing all its component elements. Accordingly, the parsing of a composite element could be accomplished by fully parsing all of its child elements. On the other hand, you'd like to treat all elements uniformly so that you don't need to write similar code multiple times. These characteristics make it a good candidate for the composite pattern. </p><p>Using the terms defined in the book <i>Design Patterns</i> [2], it is fairly easy to get the major participants for this instance of the composite pattern &#151; the <b>Document</b>, <b>Composite</b>, and <b>Leaf</b> elements. Since my main concern is the <b>ContentHandler</b> interface, I got <b>DocumentContentHandler</b>, <b>CompositeContentHandler</b>, and <b>LeafContentHandler</b>, which all implement the <b>ISAXContentHandler</b> interface. <A HREF="0403zhangf2.htm" target="_BLANK">Figure 2</A> shows a typical mapping from an XML document to this composite structure. Clients use <b>ISAXContentHandler</b> to interact with elements in this composite structure. If the element is <b>Leaf</b>, its content is converted directly. If the element is <b>Composite</b>, it delegates the processing to its child components with the possibility of performing additional processing before and/or after the delegation. The processing for each element will be well encapsulated into its own content handler. It could minimize the ripple effect if XML schemas are changed. You would only need to modify/add/remove the relevant handler without touching other elements. Decoupling the parsing for different elements helps to alleviate some design concerns, but still does not reduce the code duplication that may occur when implementing <b>Document</b>/<b>Composite</b>/<b>Leaf</b> content handlers.</p><p>A C++ template would be a natural choice to make the code generic. In this case, you need to see if you can determine the appropriate template type. Typically, the data contained in an XML document represents some abstract business information set that can often be mapped to a business class. Those <b>Leaf</b> elements could usually be mapped to a primitive type variable, such as an integer, string, and so on, which would be the member variable of the relevant business class. By using the business class mapped from the XML data as the template type, the parsing of different XML documents would simply become defining different business classes. Application developers need not worry about the details of XML parsing any more since it has been wrapped in those template handler classes. Obviously, it would be much easier for you to deal with the business class rather than angles and brackets in XML documents. Furthermore, since most business logic centers around the business class, you can define a functor that processes the relevant business objects and use this functor as another template type. Now the business logic is nicely decoupled from the parsing. If you need additional business logic for this business data, you just need to define another functor. In this way, application programmers can then focus on the business logic. </p><p><A HREF="0403zhangl2.htm" target="_BLANK">Listing 2</A> shows the major functions of the <b>DocumentContentHandler&lt;Data, Functor&gt;</b> class. The template type <b>Data</b> is the business class related to the composite elements described in the XML document, and <b>Functor</b> is a class that provides the following function:</p><pre><b><p>&lt;code&gt;</p><p> class Functor</p><p> {</p><p>     //......</p><p>     void operator() (const Data&amp; data);</p><p>     // .....</p><p> };</p><p>&lt;text&gt;</b></p></pre><p>Of course, <b>Functor</b> could be a template class as well. </p><p>The main responsibility of <b>DocumentContentHandler</b> is to provide the entrance point of parsing, member function <b>Parse()</b>, and maintain two member variables defined as following:</p><pre><b><p>&lt;code&gt;</p><p>map&lt;XmlString, BaseContentHandler*&gt;  m_AllHandlers;</p><p>stack&lt;BaseContentHandler*&gt;           m_ActiveHandlers;</p><p>&lt;text&gt;</b></p></pre><p>All relevant content handlers are stored in the map <b>m_AllHandlers</b>. Instead of being used for multibranch if-else-if statements, those element names are now used as search keys for <b>m_AllHandlers</b>. Whenever an element is being parsed, the content handler defined just for that element is going to be found within <b>m_AllHandlers</b> based on its name, set as the active handler, and used for the appropriate processing. Since the parsing for a composite element will not be finished until the parsing for all its child components is finished, there could be multiple active handlers. To be able to go back to the composite element handler to do possible post-processing, the stack variable <b>m_ActiveHandlers</b> is used to keep track of all handlers currently being used. The content handler will be found and pushed into this stack by the <b>startElement()</b> function and popped out by the <b>endElement()</b> function. The first-in-last-out (FILO) feature of this stack-based mechanism [3] fits right into the way those elements need to be parsed, which is that the parsing for a composite element would be started before its child elements and ended after its child elements. Jim Beveridge [3] presents a similar stack-based SAX parsing mechanism that only decouples the parsing among different XML elements.</p><p>The content of the map <b>m_AllHandlers</b> is created in the constructor of <b>DocumentContentHandler</b> by using the binding information provided by the instantiating <b>Data</b> class. </p><p><A HREF="0403zhangl3.htm" target="_BLANK">Listing 3</A> presents the major functions of class <b>CompositeContentHandler&lt;Data, Functor&gt;</b>. The template types <b>Data</b> and <b>Functor</b> are the same types passed from the <b>DocumentContentHandler</b> class. Take a look at the following three member variables first:</p><pre><b><p>&lt;code&gt;</p><p> vector&lt;ContentHandlerPtr&gt;  m_ChildHandlers; </p><p> Functor*                   m_pFunctor; </p><p> Data                       m_Data;</p><p>&lt;text&gt;</b></p></pre><p>The container <b>m_ChildHandlers</b> stores all <b>LeafContentHandlers</b> for all child elements. The business logic is performed by the functor specified by <b>m_pFunctor</b> against the data<b> m_Data</b> in the function <b>endElement</b>. As you can see in <b>endElement</b>, after the parsing for all child elements is completed, the <b>CompositeContentHandler </b>collects the data from its child handlers, transfers them into the embedded business object <b>m_Data</b>, and then dispatches the object to the prehooked functor <b>m_pFunctor</b>. Another important effect is that <b>m_pFunctor</b> keeps receiving the business object until the entire document is parsed. A loop is not necessary. This enables the business processor to work closely with parsing logic while remaining decoupled.  </p><p>Like <b>m_pAllHandlers</b> in <b>DocumentContentHandler</b>, the content of the vector <b>m_ContainedHanlders</b> is created in the constructor. </p><p>The following code shows the main functionality of class <b>LeafContentHandler&lt;T&gt;</b>, where <b>T</b> is expected to be some primitive type such as an integer, double, or string. </p><pre><b><p>&lt;code&gt;</p><p>template &lt;typename T&gt;</p><p>class LeafContentHandler : public BaseContentHandler</p><p>{</p><p>// ....</p><p> T      m_Data;</p><p>public:</p><p>// ....</p><p> virtual HRESULT STDMETHODCALLTYPE characters(</p><p>            /* [in] */ wchar_t __RPC_FAR *pwchChars,</p><p>            /* [in] */ int cchChars)</p><p> {</p><p>  XmlString strTemp(pwchChars, cchChars);</p><p>  m_Data = xmlstring_cast&lt;T&gt;(strTemp);</p><p>  return S_OK;</p><p> }</p><p>};</p><p>&lt;text&gt;</b></p></pre><p>The major responsibility of <b>LeafContentHandler</b> is to convert the element content from string format to the expected data type and store it in the variable <b>m_Data</b>, which is later retrieved by its <b>CompositeContentHandler</b>. In the function <b>characters()</b>, the template function <b>xmlstring_cast()</b> would convert the content into the value of template type <b>T</b>.</p><p>Although these template classes hide all SAX details, it is still tedious to manually define every handler and make sure to instantiate those template classes with the correct types. Simulating Recordset binding entries and relevant macros such as BEGIN_ADO_ENTRY in Visual C++'s extension to ADO, similar data structure <b>XmlBindingEntry</b> and macros are defined as:</p><pre><b><p>&lt;code&gt;</p><p>struct XmlBindingEntry</p><p>{</p><p> XmlDataType  eDataType;</p><p> unsigned long ulBufferOffset;</p><p>};</p><p>#define BEGIN_XML_BINDING(ElementTag, Class) public: \</p><p>typedef Class XMLElementClass; \</p><p>static XmlString GetClassName() { return XmlString(ElementTag);        } \</p><p>const XmlBindingEntry* GetXmlBindingEntries() { \</p><p>static const XmlBindingEntry rgXMLBindingEntries[] = { </p><p>#define XML_ELEMENT(TagName, DataType, Buffer)\</p><p> { TagName, \</p><p> DataType, \</p><p> offsetof(XMLElementClass, Buffer) \</p><p> },</p><p>#define END_XML_BINDING()   {L"", eXML_EMPTY, 0}};\</p><p> return rgXMLBindingEntries;}</p><p>&lt;text&gt;</b></p></pre><p>The macros BEGIN_XML_BINDING, XML_ELEMENT, and END_XML_BINDING are used to describe the XML schema in the format of <b>XmlBindingEntry</b> and build the binding entry array <b>rgXMLBindingEntries</b> for each associated business class. The <b>DocumentContentHandler</b> and <b>CompositeContentHandler</b> read the binding information from their instantiating business class, create the relevant handlers, and insert them into the map <b>m_AllHandlers</b> and vector <b>m_ContainedHandlers</b>, respectively.  </p><h3>An Example </h3><p>Here's how the sample XML file in <A HREF="0403zhangf1.htm" target="_BLANK">Figure 1</A> could be parsed through this wrapper step-by-step:</p><p>Step 1. Create the business class that maps to the data defined in the XML data and use the macros to describe its schema. <A HREF="0403zhangl4.htm" target="_BLANK">Listing 4</A> shows the class <b>CustomerOrder</b>. </p><p>Step 2. Create the functor to process the business object defined by Step 1. <A HREF="0403zhangl5.htm" target="_BLANK">Listing 5</A> shows the functor <b>CustomerOrderProcessor</b>. For simplicity, the functor only prints the content of the object to the screen. In reality, you can put the desired processing in this class, such as transforming them into another format, writing them into database, and so on. You can also define different functors for different processing and hook the right one with the wrapper classes either statically or dynamically.</p><p>Step 3. Instantiate the wrapper class with the class and functor defined in the former steps and start to parse the specified XML document, as in <A HREF="0403zhangl6.htm" target="_BLANK">Listing 6</A>, which results in this output:</p><pre><b><p>&lt;code&gt;</p><p>Order 1000 from XYZ Inc.: Steel 2.8 Tons has been processed.</p><p>Order 1001 from ABC Inc.: Plastic 30.5 Rolls has been processed.</p><p>All Customer Order Processing Has Been Finished.</p><p>&lt;text&gt;</b></p></pre><p>No multibranch if-else-if statements, no complicated-looking SAX API, and no duplicate code. More importantly, you can focus on the business class and its logic. </p><h3>Conclusion</h3><p>Applying design patterns and the power of C++ templates not only hides the details of the SAX API, but also decouples the parsing logic and business logic. Therefore, you can spend more time on business logic than dealing with the XML parsing API. An obvious expansion on this idea would be moving past simple formed data and into other events of <b>ContentHandler</b> as well as other SAX interfaces. </p><h3>Acknowledgments</h3><p>Thanks to Jeffrey Burch of AOL and Mike Wayne of InterEnable Corp. for providing technical review. </p><h3>References</h3><p>[1] <i>Microsoft XML 3.0: SAX2 Developer's Guide</i>, Microsoft MSDN Library, October 2001.</p><p>[2] Gamma, Erich, et al. <i>Design Patterns</i>, Addison-Wesley,1995.</p><p>[3] Beveridge, Jim. "Transporting Data with XML: The C++ Problem." <i>XML Magazine</i>, Summer 2000. </p><hr><I><b>Yingjun Zhang</b> is a lead software engineer at Preston Aviation Solutions, a Boeing company. His main interests are software architecture and generic and object-oriented programming in C++. He can be reached at <a href="mailto:zhang_yingjun@ hotmail.com">zhang_yingjun@ hotmail.com</a>.</I><hr></body></html>