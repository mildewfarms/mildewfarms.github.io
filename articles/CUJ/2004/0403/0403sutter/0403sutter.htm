<html><head><title>March 04: Im-Paired Programming)</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; C/C++ Users Journal--><p><i>C/C++ Users Journal </i> March 2004</p><h1>Im-Paired Programming)</h1><h2>std::pair can make your life easier. But as with many things,  moderation is the key; excessive use can lead to unmanageable code</h2><h3>By Herb Sutter and Jim Hyslop</h3><p>"Um, you got a minute?" Kerry's quiet voice broke through my concentration. I sat back for a moment, disengaging my brain from the task at hand.</p><p>"Of course, young apprent..." I swung around. Seeing the look on Kerry's face, I changed my tone. "Aw, heck, the Guru's not around right now, there's no point in carrying on the shtick. 'Sup, Kerry?"</p><p>"Well, I'm having trouble following this function," he called up the source code he was working on:</p><pre><b>// $Author: Bob$void f( const vector&lt; T &gt; &amp; timers ){  vector &lt; pair&lt; string,           pair&lt; long,            pair&lt; long,            pair&lt; long,           pair&lt; bool,           pair&lt; bool, bool&gt; &gt; &gt; &gt; &gt; &gt; &gt;  infoReceived;  for (int outputCount = 0;        outputCount &lt; timers.size();       ++outputCount)   {    pair&lt; string,      pair&lt; long,      pair&lt; long,      pair&lt; long,      pair&lt; bool,       pair&lt; bool, bool&gt; &gt; &gt; &gt; &gt; &gt;    newInfo;    newInfo.first =       timers[ outputCount ].id_;    newInfo.second.first =       timers[ outputCount ].hour_;    newInfo.second.second.first =       timers[ outputCount ].minute_;    newInfo.second.second.second      .first =       timers[ outputCount ].second_;    newInfo.second.second.second      .second.first =      timers[ outputCount ].state_;    newInfo.second.second.second      .second.second.first =      timers[ outputCount ].direction_;    newInfo.second.second.second      .second.second.second =     timers[ outputCount ].showTimeSinceEvent_;     infoReceived.push_back ( newInfo);  }</b></pre><p>"Whooeee, </b><i>Bahb</i>'s really outdone himself this time," I muttered, loud enough to ensure that Wendy could hear me.</p><p>"Now what," she called over the cubicle wall.</p><p>"C'mon over, and I'll show you." When Wendy pulled up beside us, I pointed at the code.</p><p>"Oh, my," Wendy gasped after examining the screen, "that's gotta be a record for the worst use of a <b>pair</b> that I've ever seen." </p><p>"Wanna see the best part?" I didn't wait for her answer, but scrolled down to the second half of the function:</p><pre><b>  for (int timerCount = 0;        timerCount &lt; infoReceived.size();       ++timerCount)   {    TimerInfo info;    info.id_ =       infoReceived[ timerCount ]      .first;    info.hour_ =      infoReceived[ timerCount ]      .second.first;    info.minute_ =      infoReceived[ timerCount ]      .second.second.first;    info.second_ =      infoReceived[ timerCount ]      .second.second.second.first;    info.isRunning_ =      infoReceived[ timerCount ]      .second.second.second.second      .first;    info.isCountingUp_ =     infoReceived[ timerCount ]      .second.second.second.second      .second.first;    info.showTimeSinceEvent_ =       infoReceived[ timerCount ]      .second.second.second.second      .second.second;    ProcessTimer( info );  }</p>} // end of f()</b></pre><p>"Um...I don't see..." Wendy paused a moment. "Hey, wait a second &#151; the only reason he's creating and filling in the </b><b>infoReceived vector</b> is to iterate through it and pull out everything he just put in it &#151; then he tosses the whole darn <b>vector</b> away."</p><p>"You got it," I crowed. "Not only is that mess of nested <b>pairs </b>horrendously ugly, but it is redundant to boot."</p><p>"Why is it so ugly?" Kerry put in.</p><p>"Well, look at how much trouble you had reading it," I pointed out. "Not to mention the brittleness of it. Look at that last line &#151; six <b>.second </b>statements in a row. You have to keep very careful track of how many levels down you're going in the nest &#151; one too few and you're wasted. Boom!"</p><p>"And," Wendy interjected, "there's also the code communication that the Guru's always harping on. Look at the declaration of <b>infoReceived</b>:"</p><pre<b>  vector &lt; pair&lt; string,           pair&lt; long,            pair&lt; long,            pair&lt; long,           pair&lt; bool,           pair&lt; bool, bool&gt; &gt; &gt; &gt; &gt; &gt; &gt;  infoReceived;</b></pre><p>"All we know about the items stored in this vector is that it takes a string, three longs, and three bools. But what are they? What do they represent?"</p><p>"I, um, was wondering," Kerry interrupted, "about the declaration of the </b><b>newInfo</b> nested <b>pairs</b>, inside the <b>for</b> loop:"</p><pre><b>   pair&lt; string,        pair&lt; long,        pair&lt; long,        pair&lt; long,        pair&lt; bool,         pair&lt; bool, bool&gt; &gt; &gt; &gt; &gt; &gt;    newInfo;</b></pre><p>"It looks a lot like the nested </b><b>pairs</b> that go into the <b>infoReceived vector</b>, so I thought maybe a <b>typedef</b> would help here?"</p><p>"Very good, young apprentice," the Guru's voice sounded behind us, as she closed her tome with her customary snap. The three of us jumped to varying degrees. "That would indeed be a good place to use a <b>typedef</b>, if indeed the monstrosity of these nested <b>pairs</b> were required in the first place. Let us ignore the redundancy of the second half of the function for a moment," she reached over and scrolled back to the top of the function, "and consider how to eliminate these nested <b>pairs</b>."</p><p>"Um..." Kerry faltered under the Guru's direct stare. "Could we maybe create a structure?"</p><p>"Excellent idea, apprentice. Please demonstrate." I slid aside, to let Kerry at the keyboard. After a few minutes, he typed:</p><pre><b>void f( const vector&lt; T &gt; &amp; timers ){  struct IncomingTimeInfo  {    string id_;    int hour_;    int minute_;    int second_;    bool state_;    bool direction_;    bool showTimeSinceEvent_;  };  vector &lt; IncomingTimeInfo &gt;    infoReceived;  for (int outputCount = 0;        outputCount &lt; timers.size();       ++outputCount)   {    IncomingTimeInfo newInfo;    newInfo.id_ =       timers[ outputCount ].id_;</b></pre><p>"And so on, filling in the members as we iterate through," Kerry said as he turned back to us.</p><p>"Very good, apprentice. In general, I find that nesting </b><b>pairs</b> more than two or three levels deep becomes quickly unreadable and unmaintainable. It is wiser to create a structure to hold the values you need. I also preach that it is frequently wise to use a <b>typedef</b> for your containers." She reached across and modified Kerry's code slightly:</p><pre><b>typedef vector &lt; IncomingTimeInfo &gt;    IncomingTimes;IncomingTimes infoReceived;</b></pre><p>"The benefit is most pronounced when you need to declare an iterator for the container, as in:"</p><pre><b>IncomingTimes::iterator timer;</b></pre><p>"Now, as you have observed, the new </b><b>IncomingTimeInfo</b> struct is quite similar to the existing <b>TimeInfo</b> struct, and if we use it instead, we can eliminate the redundant, second loop and the local structure. Please revise the code accordingly, my young apprentice, and show me your writings." She turned and silently glided away.</p><p>Later that day, when I updated my code from the repository, I saw Kerry's revised function:</p><pre><b>void f( const vector&lt; T &gt; &amp; timers ){  for (int outputCount = 0;        outputCount &lt; timers.size();       ++outputCount)   {    TimerInfo info;    info.id_ =       timers[ outputCount ].id_;    info.hour_ =      timers[ outputCount ].hour_;    info.minute_ =      timers[ outputCount ].minute_;    info.second_ =      timers[ outputCount ].second_;    info.isRunning_ =      timers[ outputCount ].state_;    info.isCountingUp_ =       timers[ outputCount ].direction_;    info.showTimeSinceEvent_ =      timers[ outputCount ].showTimeSinceEvent_;    ProcessTimer( info );  }} // end of f() </b></pre><hr><I><b>Herb Sutter</b> (<a href="http://www.gotw.ca/">http://www.gotw.ca/</a>) is convener of the ISO C++ Standards committee, author of </i>Exceptional C++ and More Exceptional C++<i>, and Visual C++ architect for Microsoft. <b>Jim Hyslop</b> is a senior software designer for Leitch Technology International. He can be reached at <a href="mailto:jhyslop@ieee.org">jhyslop@ieee.org</a>.</I><hr></body></html>