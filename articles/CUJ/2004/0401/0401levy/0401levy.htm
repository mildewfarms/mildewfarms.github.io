<html><head><title>January 04: </title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; C/C++ Users Journal--><p><i>C/C++ Users Journal </i> January 2004</p><h1>Wrapping C with C++ in .NET</h1><h2> Coding assemblies in any .NET language &amp; using them with any other .NET language</h2><h3>By George Levy</h3> <p>A common software requirement is for code written in one computer language to be used by software developed in a different computer language. For instance, it may be necessary to access C functions from a .NET or Java application. In this article, I show how existing C software can be wrapped in C++ and thus made easily accessible from .NET languages such as C# and VB.NET. Although I use the NAG C library from the Numerical Algorithms Group (<a href="http://www.nag.co.uk/">http://www.nag.co.uk/</a>) as an example, the method is general and can be applied to other C software. In particular, I illustrate the technique by considering four NAG C library numeric routines, which have applications in computational finance:</p><ul>  <li>NAG function <b>s15abc</b>, the cumulative normal distribution that is used in analytic option pricing formulae, such as the Black-Scholes equation [1].  <li>NAG function <b>f02aac</b>, the eigenvalue computation. This has applications in multifactor models, including interest-rate models and time series [2], [3].  <li>NAG function <b>d01ajc</b>, numerical integration, which has applications in risk analysis [4].   <li>NAG function <b>e04dgc</b>, numerical optimization. This can be used to compute optimal portfolios [5].</ul><h3>COM, .NET Assemblies, and Managed C++</h3><p>Microsoft COM already enables the creation of numeric components that can be used by the complete range of Windows programming languages. In fact, COM objects can be used within .NET. However, from a programmer's point of view, wrapping C code in COM C++ classes has the disadvantage that there is visible Microsoft COM baggage that needs to be carried around. This has the effect of obscuring the code and also making it difficult to implement the C++ classes on UNIX platforms. Another limitation is that the classes contained within a COM object cannot be used to create other derived classes.</p><p>.NET assemblies have improved this situation. In a nutshell, the classes in an assembly can be coded in any .NET language, then used by any other .NET language. Thus, it is possible to create assemblies in managed C++ that provide class wrappers for C routines, then use these from C# and VB.NET software [6]. </p><p><A HREF="0401levyl1.htm" target="_BLANK">Listing 1</A> shows the ANSI function prototypes of four NAG C functions. <A HREF="0401levyl2.htm" target="_BLANK">Listing 2</A> is the managed C++ code used to create an assembly that wraps the C functions. I call this assembly "naglib," and it defines the namespace <b>NAGLIB</b> and the managed class <b>NAG_FUNCTIONS,</b> which provides functions to access native C routines contained within the DLL "nagc." <A HREF="0401levyl2.htm" target="_BLANK">Listing 2</A> is meant for illustrative purposes and not intended to be a statement of good programming practice. However, I have included some useful features, such as flagging errors and setting default parameter values via the constructor <b>NAG_FUNCTIONS()</b>.</p><p>As you can see, the code is almost standard C++ and (in contrast to the equivalent COM approach) could easily be ported to UNIX platforms. I now examine each nonstandard C++ (that is, Microsoft-specific) feature. </p><p>The NAG C library routines used are contained in a DLL called "nagc." Here, each function is imported into the C++ project by name. For instance:</p><pre>[DllImport(</b>"<b>nagc</b>"<b>)]extern </b>"<b>C</b>"<b> Double s15abc(Double x);</pre><p>is used to import the function </b><b>s15abc</b>, which computes the cumulative normal distribution. </p><p>The directive <b>gc</b> indicates that the code is managed and memory is allocated on the garbage collected (GC) heap; unmanaged code is indicated by <b>nogc</b>. </p><p>In <A HREF="0401levyl2.htm" target="_BLANK">Listing 2</A>, the .NET data types <b>Double</b> and <b>Int32</b> have been used so that the assembly can be accessed by both C# and VB.NET code. All managed .NET code written in VB.NET, C#, and C++ is compiled to the same intermediate language (IL) code. To permit interoperability within .NET, there is a common type system (CTS) that standardizes the basic data types across all languages. <A HREF="0401levyt1.htm" target="_BLANK">Table 1</A> provides a summary of the .NET data types corresponding to the C++ types <b>double</b> and <b>long</b>. </p><p>In the case of numerical integration and optimization, user-defined functions (or call-back functions) need to be passed as parameters to the NAG C library routine. This is done in .NET by declaring a delegate with the same signature (that is, return type and parameter types) as the callback function. For example:</p><pre>public __delegate double INTEGRAND_FUN_TYPE(Double x);</pre><p>declares the delegate </b><b>INTEGRAND_FUN_TYPE</b> with a signature corresponding to functions that return a <b>Double</b> and have a single <b>Double</b> parameter passed by value. This delegate is used by the numerical integration routine <b>d01ajc</b> for defining the integrand. The declaration of a delegate is similar to the declaration of a function prototype with the additional words <b>public</b> (or <b>private</b>) and <b>delegate</b>. Also, the declaration and use of delegates in <A HREF="0401levyl2.htm" target="_BLANK">Listing 2</A> has similarities with the declaration and use of function pointers in <A HREF="0401levyl1.htm" target="_BLANK">Listing 1</A>.</p><p>A more complicated delegate example is:</p><pre>public __delegate void OBJ_FUN_TYPE (Int32 n, double *x, double * objf, double *g, Int32 comm);</pre><p>which declares the delegate <b>OBJ_FUN_TYPE.</b> This is done with a signature that applies to subroutines (that is, functions that return <b>void</b>) with parameters of type <b>Int32</b> and<b> double *</b>. As you can see, I had to use <b>double * </b>instead of the more general <b>Double *</b>. This delegate is used by the numerical optimization routine <b>e04dgc</b> for specifying the objective function to be minimized.  </p><h3>Accessing the Naglib Assembly from C#</h3><p>The C# code in <A HREF="0401levyl3.htm" target="_BLANK">Listing 3</A> (and project screen in <A HREF="0401levyf1.htm" target="_BLANK">Figure 1</A>) illustrate how the assembly naglib can be accessed from a C# console project created using Visual Studio .NET. You can see that the C# code defines the classes <b>DCLASS</b> and <b>RUNIT</b>. <b>DCLASS</b> is derived from the class <b>NAG_FUNCTIONS</b> and supplies definitions for the callback functions used by the member functions <b>OPTIMIZE</b> and <b>QUADRATURE</b>.</p><p>The class <b>RUNIT</b> only contains the member function <b>Main</b>. This function is run by the example console application, and all the computations are performed by a single numeric object (<b>tt</b>) of type <b>DCLASS</b>.</p><p>The assembly containing the namespace <b>NAGLIB</b> is accessed with the statement using <b>NAGLIB</b>, which occurs on the third line of <A HREF="0401levyl3.htm" target="_BLANK">Listing 3</A>. (See <A HREF="0401levyl4.htm" target="_BLANK">Listing 4</A> for the output from Listing 3.) I use <b>Math.PI </b>to return the value of <IMG SRC="pi14.gif">, <b>Math.Sin(x) </b>to<b> </b>compute<b> sin(x)</b>, and <b>Math.Exp(x)</b> to evaluate <b>exp(x)</b>. These functions are members of the class <b>Math</b>, which is contained in the namespace <b>System</b>.</p><p>This directive is necessary because C# does not really support pointers. The keyword <b>unsafe</b> lets you use pointers and thus easily pass scalars and arrays by reference to the managed C++ class <b>NAG_FUNCTIONS</b> contained in the namespace <b>NAGLIB</b>.</p><p>The statement <b>DCLASS tt = new DCLASS()</b> creates a numeric object <b>tt</b> with the type of the derived class <b>DCLASS</b>. Since <b>DCLASS</b> was derived from <b>NAG_FUNCTIONS</b>, it allows access not only to the public member functions <b>objfun</b> and <b>the_integrand_c</b>, but also the public member functions of <b>NAG_FUNCTIONS</b>: <b>CUM_NORM</b>, <b>OPTIMIZE</b>, <b>QUADRATURE</b>, and <b>REAL</b>_<b>SYMM_EIGEN</b>. This means that I can compute the cumulative normal distribution and perform eigenvalue computations by using statements of the form: </p><pre>the_answer = tt.CUM_NORM(x);flag = 0;// first rowa[0,0] = 0.5;a[0,1] = 0.0; ...// fourth rowa[3,0] = -2.6;a[3,1] = -0.7;a[3,2] = 0.0;a[3,3] = 0.5;tt.REAL_SYMM_EIGEN(n, ref a[0,0], tda, ref r[0], ref flag);</pre><p>Note that the keyword <b>ref</b> is used to pass the address of <b>a[0,0]</b>, <b>r[0]</b>, and <b>flag</b> to the member function <b>REAL_SYMM_EIGEN</b>.</p><h3>Using Numeric Objects with Member Functions Requiring Delegates</h3><p>We will now consider how to call the numerical integration function <b>QUADRATURE</b>. This is achieved using the following C# statement: </p><pre>INTEGRAND_FUN_TYPE myfun_c = new INTEGRAND_FUN_TYPE (tt.the_integrand_c);</pre><P>to declare (and also define) the delegate<b> myfun_c</b>, of type <b>INTEGRAND_FUN_TYPE</b>, which corresponds to the user-defined function <b>the_integrand_c</b> contained in the derived class <b>DCLASS</b>. The next step is to pass the appropriate parameters to the function <b>tt.QUADRATURE</b>. For example:</p><pre>a1 = 0.0;b1 = Math.PI*2.0;flag = 0;the_answer = 0.0;tt.QUADRATURE(a1, b1, ref the_answer, ref abserr, ref flag, myfun_c);</pre><p>The method for calling the numerical optimization member function is similar. For instance, in the example code, we use:</p><pre>OBJ_FUN_TYPE myobjfun = new OBJ_FUN_TYPE (tt.objfun);x2[0] = -1.0;x2[1] = 1.0;n2 = 2;flag = 0;tt.OPTIMIZE(n2, ref x2[0], ref g[0], ref objf, ref flag, myobjfun);</pre><p>The initial parameter estimates and computed optimal values are contained in the array <b>x2</b>. The estimated gradient at the solution point is returned in the array <b>g</b>, and the parameter <b>objf</b> contains the value of the minimized objective function. </p><h3>Accessing the Naglib Assembly from VB.NET</h3><p>The assembly naglib can be used from VB.NET in a similar manner to that described for C#; see <A HREF="0401levyl5.htm" target="_BLANK">Listing 5</A>.</p><h3>Conclusion</h3><p>A major benefit of the approach presented here over COM is that the managed C++ wrapper code can, with little effort, be used on UNIX platforms. In addition, unlike COM, you can create C# or VB.NET derived classes from the managed C++ (base) classes. As more software supports .NET (as, for example, Excel 2003 will), the future of object-oriented numerics in .NET looks promising.</p><h3>References </h3><p>[1]	Black, F. and M. Scholes. "The Pricing of Corporate Liabilities," <i>Journal of Political Economy</i>, 1973.</p><p>[2]	Rebonato, R.<i> Interest-rate Option Models</i>, Second Edition, John Wiley, 1998.</p><p>[3]	Levy, G.F. <i>Computational Finance, Numerical Methods for Pricing Financial Instruments,</i> Heinemann Press, 2003.</p><p>[4]	Hull, J.C. <i>Options Futures and Other Derivatives</i>, Prentice Hall, 1997.</p><p>[5]	Markowitz, H.M. "The General Mean-Variance Portfolio Selection Problem," <i>Phil. Trans. R. Soc. Lond.</i> 1994.</p><p>[6]	Challa, S. and A. Laksberg. <i>Essential Guide to Managed Extensions for C++</i>, Apress, 2002. </p><hr><I><b>George Levy</b>, who holds a doctorate in mathematical physics from Oxford University, is a consulting software engineer and author of the upcoming  book <i>Computational Finance: Numerical Methods for Pricing Financial Instruments.</i> He can be contacted at <a href="mailto:compukalc.com@ntlworld.com">compukalc.com@ntlworld.com</a>.</I><hr></body></html>