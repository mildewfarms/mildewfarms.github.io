<html><head><title>January 04:  Of Many Things std::string, magic numbers,  and constness in references</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; C/C++ Users Journal--><p><i>C/C++ Users Journal </i> January 2004</p><h1> Of Many Things</h1><h2> std::string, magic numbers,  and constness in references</h2><p>"Well," I sighed to nobody in particular, "<i>Bahb's</i> been at it again."</p><p>"What this time?" Wendy's voice floated over the cubicle wall.</p><p>"Well, there's a few things. Fortunately, a couple of them are minor. One of them, though...C'mon over and I'll show you his latest abominations," I said in my best Guru imitation. As Wendy came over, I slid aside to let her view the code:</p><pre>class T{  int id_;public:  void printValue(FILE * stream);  void test(int testValue) const;  // 'tors, etc.  static const int invalidID_=-1;};// Note: FILE passed in via a C API// wrappervoid T::printValue(FILE * stream){  char buff[20];  itoa( id_, buff, 10 );  string value = string( buff );  fputs( "\"ID=\"", stream );  fputs( value.c_str(), stream );}</pre><p>"First, the string here is completely unnecessary. I think Bob was just trying to score brownie points with Pete," I said, referring to our somewhat clueless manager, "for using the STL."</p><p>"Indeed, my apprentice." I don't know what startled me more, the Guru's sudden voice, or the fact that she did not snap closed the tome she customarily carried. "A string is quite overmuch in this situation. The buffer could have been passed directly to the <b>fputs</b> function. Standard strings shine the best when manipulating strings &#151; concatenating them, extracting subsets of them, and so on."</p><p>"I don't get why he's even using <b>fputs</b> here," Wendy jumped in. "The whole function can be replaced with a single statement." She took over the keyboard:</p><pre>void T::printValue(FILE * stream){  fprintf( stream,          "\"ID=%d\"", id_ );}</pre><p>"Very good, child," the Guru said. "Let us assume for the moment, though, that there is a valid reason for using</b><b> fputs</b> &#151; an optimization, perhaps, that has been properly profiled." Wendy and I rolled our eyes at each other. The likelihood of Bob properly profiling the program was...well, let's just say I'd bet more money on the lottery than on Bob. A lot more. "What next, apprentice?"</p><p>"Ah," I said, "the next one's a little worse." I scrolled to the next function:</p><pre>void T::test( int testID ) const{  if ( id_ &gt; 0 || testID &gt; 0 )  // do something}</pre><p>"Here, he's comparing the IDs against a literal zero. He's overlooked a couple of things. First, the constant indicating an invalid ID is -1. Zero is a valid ID. If an ID of 0 is passed in, the test will fail. Second, he's assuming that the ID will never wrap into negative values. The test will fail for half the valid ID range."</p><p>"A most unlikely occurrence, given the problem domain," the Guru answered, "but still worth noting."</p><p>"There's another problem, too," Wendy added. "He seems to have forgotten that zero is a magic number."</p><p>"Magic number?" I had visions of Bob surrounded by numerology charts and calculations. </p><p>"You know," Wendy gave me a withering glare, "a number hard-coded into the program instead of using a </b><b>const int</b>."</p><p>"How would you correct this?" the Guru interrupted.</p><p>"Well, by testing for inequality, not greater than," I said as I modified the function:</p><pre>void T::test( int testID ) const{  if ( id_ != invalidID_ ||        testID != invalidID_ )  // do something}</pre><p>"What else did you find, apprentice?"</p><p>"Well, this one's really serious," I said. "I think he's taking advantage of a compiler bug here." I opened another file:</p><pre>struct U{  int &amp; i_;  u();};void f( const U &amp; u ){  u.i_ = 43;}</pre><p>"He's modifying a member inside a function where the object is <b>const</b>. He should be at least using a <b>const_cast</b>, or something like that." I looked up at the Guru, who was smiling enigmatically. Suddenly, I wasn't so sure.</p><p>"What makes you think it's a compiler bug, apprentice?" The Guru stared at me.</p><p>"Uh, well, it's gotta be wrong, because it's modifying a member of a constant object."</p><p>"Have you checked the Holy Standard, apprentice?" I quickly turned to my keyboard and looked up the appropriate section in the Standard. "Well, I'll be..." I trailed off as I read aloud:</p><p>"'Each nonstatic, nonmutable, nonreference data member of a <b>const-qualified</b> class object is <b>const-qualified</b>...'[1] What the hay &#151; why would that be?"</p><p>"Well, my child, remember that a reference is somewhat equivalent to a constant pointer to an object &#151; not to be confused with a pointer to a constant object," [2] she said as she began writing on my whiteboard:</p><pre>struct T{  int * const i1_;  int &amp; i2_;  int * i3_;};</pre><p>"The first two </b><b>int</b> members are roughly equivalent, for the purposes of this discussion. When working with a nonconstant <b>T</b> object, we can modify the value pointed to by <b>i1_</b>, but we cannot change which integer <b>i1_</b> points to. Similarly, we can modify the integer referred to by <b>i2_</b>, but we cannot change which integer it refers to."</p><pre>void f( T &amp; t ){  *t.i1_ = 4; // OK  t.i1_ = NULL; // Error  t.i2_ = 5; // OK  t.i3_ = new int; // OK  *t.i3_ = 43; // OK}</pre><p>"When working with a constant </b><b>T</b> object, the member <b>i3_</b> behaves as if you had declared the class thusly,"</p><pre>(const) struct T{  int * const i1_;  int &amp; i2_;  int * const i3_; // NOTE change};</pre><p>"The member </b><b>i1_</b> is already <b>const-qualified</b>, so it changes not. And, since <b>i2_</b> is effectively the same as <b>i1_</b>, that means we are still free to modify the integer being referred to. The only change is that now we may not reseat <b>i3_</b>,"</p><pre>void f1( T &amp; t ){  *t.i1_ = 4; // Still OK  t.i1_ = NULL; // Still error  t.i2_ = 5; // Still OK  t.i3_ = new int; // Error now  *t.i3_ = 43; // Still OK}</pre><p>"Huh," I huh-ed. "So...would it be fair to say that, because the object being referred to is not a member of the class, the </b><b>const</b>ness of the class doesn't affect it?"</p><p>"That would be a simpler, although less comprehensive answer &#151; consider the case where the pointer or reference points to a member of the class itself. The same rules still apply,"</p><pre>struct U{  int i_;  int &amp; iref_;  U() : iref_( i_ ) {}};void f( const U &amp; u ){  u.iref_ = 43; // changes u.i_}</pre><p>"In this situation, you must be careful not to pass in an object that was originally declared <b>const</b>, as that would lead to the dark path of undefined behavior,"</p><pre>extern const U u;void g(){  f( u ); // this is Very Bad}</pre><p>"Looks like Bob's got one up on you, pardner," Wendy punched me in the arm as the Guru silently glided away.</p><p>"Yeah, well, he's still going overboard with his use of strings, and he blew the 'zero is a magic number' rule, so I'm still ahead of him," I grinned.</p><h3>References</h3><p>[1]	ISO/IEC 14882:1998(E), (C++ Standard) clause 3.9.3.</p><p>[2]	Thanks to Bryan Ross for providing the pointer analogy to help explain this.</p><p></b><b>Authors' note: </b>This column dealt with three separate, unrelated items, none of which was large enough to deserve an article in its own right. We hope the distinction between the three topics was clear. </p><hr><I><b>Herb Sutter</b> (<a href="http://www.gotw.ca/">http://www.gotw.ca/</a>) is convener of the ISO C++ Standards committee, author of <i>Exceptional C++</i> and<i> More Exceptional C++</i>, and C++ program manager for Microsoft.<b>Jim Hyslop </b>is a senior software designer with over 10 years of programming experience in C and C++. Jim works at Leitch Technology International Inc. where he deals with a variety of applications ranging from embedded apps to Windows programs. He can be reached at <a href="mailto:jhyslop@ieee.org">jhyslop@ieee.org</a>.</I><hr></body></html>