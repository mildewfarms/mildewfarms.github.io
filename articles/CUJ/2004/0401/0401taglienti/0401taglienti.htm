<html><head><title>January 04: </title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; C/C++ Users Journal--><p><i>C/C++ Users Journal </i> January 2004</p><h1>STL Member Function Adaptors</h1><h2>Replacing error-prone loop logic</h2><h3>By Claudio Taglienti</h3>  <p>Have you ever wished that STL member function adaptors such as <b>mem_fun</b> or <b>mem_fun_ref</b> would let you invoke a method of a class of your choice, instead of invoking methods of objects held in an STL container? The <b>External</b> member function adaptor lets you call a member function through a pointer to an instance of a class of your choice. Unlike the <b>mem_fun</b> family of member function adaptors, the pointer to the object being accessed is not stored in the STL container. Either the <b>mem_fun</b> or <b>mem_fun_ref</b> member function adaptors use the pointer or reference to each separate object held in an STL container to gain access to the desired member function of all the different objects in the container. The precondition for using the <b>mem_fun</b> family of function adaptors is the existence of objects in containers with public methods that can be invoked. </p><p>The <b>External</b> member function adaptor, on the other hand, makes no assumptions about the type of items stored in the STL container. The item in the STL container could be a primitive data type such as an integer, or a more complex data type such as a class. Upon creation, the <b>External</b> member function adaptor is provided a pointer to the method to be invoked, as well as a pointer to the object that implements the method. STL algorithms such as <b>for_each</b> and <b>find_if</b> can use this adaptor to invoke the method of this object passing each item stored in the STL container being processed.</p><h3>The Problem</h3><p>Consider <A HREF="0401taglientif1.htm" target="_BLANK">Figure 1</A>, in which a window uses a layout manager to arrange different shapes on the visible part of the window based on the following:</p><ul>  <li>Position of other shapes already displayed on the window.  <li>Layout policy that determines placement and size of the shape shown.</ul>  <p>The window notifies the Layout Manager to display the shapes by invoking the <b>ArrangeShapes</b> method. This routine needs to invoke the draw method of each shape in the list with the appropriate position (x,y coordinates and width, height) parameter.  <p>You cannot iterate over the list using <b>for_each</b> and <b>use mem_fun</b> to bind a position as a parameter since the position changes for each shape. You could iterate over the list using a <b>for</b> loop, compute the new position for each shape, call each shape to draw itself with the appropriate position value, and then update the <b>ShapesAlreadyShown</b> variable. This solution works, but using a <b>for</b> loop to iterate over an STL container has several drawbacks (see Scott Meyers's <i>Effective STL</i>, Item 43). In general, hard-coded loops have the following disadvantages:<ul>  <li>You must study the body of the loop to understand its purpose, instead of using a <b>for_each</b> algorithm. The name of the function passed to the <b>for_each</b> indicates the purpose of the operation.  <li>They're error prone. For instance, deleting elements from a container from within a loop is tricky, requiring you to take into account the rules each container has for invalidating iterators. Using a <b>find</b> or <b>find_if</b> algorithm to point to the element to be deleted and then erasing the element from the container always works and is safer.  <li>They do not take advantage of the inherent storage and traversal optimizations implemented by certain containers and are accessible via the <b>find</b> method of the container itself.  <li>Each time you hard code a loop you duplicate the looping logic.</ul>  <p>So what about using a function object? A function object lets you make use of STL algorithms such as <b>for_each</b> and <b>find_if</b>. This function object needs to have access to the Layout Manager's private data. In particular, this object is passed in as a parameter to the layout policy and needs to modify the <b>ShapesAlreadyShown</b> variable; see <A HREF="0401taglientil1.htm" target="_BLANK">Listing 1</A>. It isn't good practice to have objects know about their containers and (more importantly) modify data owned by the container. Function objects, when used as parameters to STL algorithms such as <b>for_each</b>, tend to lead to code bloat. In addition, because function objects are separate classes, it is difficult to determine where they should reside. Function objects often end up nested inside the class that owns them, thus cluttering the interface of the class.<h3>The Solution</h3><p>Using a member function of the class that owns the STL container is the most natural solution. In the previous example, the <b>ArrangeShape</b>s method could iterate over all the shapes (using <b>for_each</b>), invoking the <b>ShowNextShape</b> method and passing as a parameter a pointer to each shape.</p><pre>bool LayoutManager:: ArrangeShapes(){   ...   for_each(shapes.begin(),shapes.end(),      extern_mem_fun_(&amp;LayoutManager::ShowNextShape,this));   ...}bool LayoutManager:: ShowNextShape(shape* s){  ...  //Compute new position based on layout policy  s-&gt;draw(position);  // Update ShapesAlreadyShown}</pre><p>The </b><b>extern_mem_fun</b> is a member function adaptor that lets algorithms such as <b>for_each</b> and <b>find_if</b> process the elements in a container by invoking a method of a class of your choice and passing each element in the container as a parameter. These member functions have full access to all the data owned by the instance of that class. Contrast the use of <b>extern_mem_fun</b> with the use of function objects. In <A HREF="0401taglientil1.htm" target="_BLANK">Listing 1</A>, the function object <b>ShowNextShape</b> needs to be passed as a parameter, the <b>LayoutPolicy</b> by value, and the <b>ShapesAlreadyShown</b> by reference so that this variable can be modified.</p><h3>Examining Extern_mem_fun in Detail</h3><p>The <b>extern_mem_fun</b> in <A HREF="0401taglientil2.htm" target="_BLANK">Listing 2</A> is a template function that creates the template function object <b>extern_mem_fun_t</b>. The implementation of <b>extern_mem_fun</b> mimics the standard implementation of <b>mem_fun</b>, which invokes the template function object <b>mem_fun_t</b>. The difference between the two is the additional parameter <b>ClassType*</b> passed to <b>extern_ mem_fun</b>. This parameter is a pointer to an arbitrary object (external to an STL container) that invokes the member function specified in the first parameter. <b>mem_fun</b>, on the other hand, invokes the member function of each object stored inside the STL container. The elegant technique employed by STL uses template functions to deduce the template arguments for a call as opposed to exposing the template function object <b>extern_mem_fun_t</b> directly. Doing so forces users to specify all the template parameters for the function object. This is a detail that users should not have to worry about.</p><p>The <b>extern_mem_fun_t</b> in <A HREF="0401taglientil3.htm" target="_BLANK">Listing 3</A> is a template function object that implements the functionality of the external member function adaptor. While the implementation of <b>extern_mem_fun_t</b> might seem similar to that of STL's <b>mem_fun_t</b>, there are some important differences. A snippet of the implementation of <b>mem_fun_t</b> is:</p><pre>...(1)    ReturnType(ContainerItemType* pm)(); ... (2)    ReturnType operator()                (ContainerItemType* p){       return((p-&gt;*pm)());}</pre><p>Algorithms such as </b><b>for_each</b>, <b>find_if</b>, and others using the <b>mem_fun</b> function invoke the same member function over each element of an STL container. The pointer to each element in the container is passed into the <b>operator()</b> member function as a parameter. This code assumes that the container stores pointers to objects that implement the member function with the aforementioned signature in <b>(1)</b>. Contrast this with the implementation of <b>operator()</b> in <b>extern_mem_fun_t</b> in <A HREF="0401taglientil3.htm" target="_BLANK">Listing 3</A>. No assumptions are made about the type of the argument passed into <b>operator()</b>. Algorithms like <b>for_each</b> and <b>find_if</b>, using the <b>extern_mem_fun</b> function, iterate over the elements of the STL container invoking the <b>operator()</b> method and passing each element of the STL container as a parameter. <A HREF="0401taglientif2.htm" target="_BLANK">Figure 2</A> shows how <b>mem_fun</b> is directly responsible for accessing each item in the STL container. In this case, the responsibility for processing the item rests with <b>mem_fun</b>. <A HREF="0401taglientif3.htm" target="_BLANK">Figure 3</A>, on the other hand, shows that it is the User Class that is responsible for processing the item. <b>extern_mem_fun</b> delegates this responsibility to this class by invoking the <b>ProcessItem</b> method. In this case, the User Class acts as a mediator that keeps the member function adaptor from explicitly referencing the item in the container, thus promoting a more loosely coupled design. The User Class encapsulates any additional logic needed to process the item stored in the STL container.</p><p>The <b>extern_mem_fun_t</b> member function adaptor is particularly useful during the refactoring of classes that overuse loop logic to process elements of STL containers, as well as classes that overuse function objects &#151; especially ones with side effects (function objects that try to access elements of the User Class). <b>extern_mem_fun_t</b> encourages the creation of private/protected member functions to process items stored in the STL container. </p><p>In <A HREF="0401taglientil3.htm" target="_BLANK">Listing 3</A>, <b>operator -&gt;*</b> is used to invoke a member function through a pointer. To do this, both a pointer to the object that owns the member function and the pointer to the member function itself need to be passed to the <b>extern_mem_fun_t</b> constructor.</p><p>Also, the class <b>extern_mem_fun_t</b> inherits from <b>unary_function. </b>This is necessary if you want to make your <b>extern_mem_fun_t</b> adaptable &#151; that is, usable with the function adapters <b>not1</b>, <b>not2</b>, <b>bind1st</b>, and <b>bind2nd</b>. Finally, note that the return type of the member function passed to <b>extern_mem_fun</b> must be nonvoid if you are using Visual C++. </p><p>What if you want to pass an additional parameter to the member function that processes items stored in the STL container? The answer is <b>extern_mem_fun1</b>, as shown in <A HREF="0401taglientil4.htm" target="_BLANK">Listing 4</A>. </p><p>Returning to <A HREF="0401taglientif3.htm" target="_BLANK">Figure 3</A>, assume that the method <b>ProcessItem</b> requires an additional parameter (an <b>int</b>) to be passed in so that its signature would look like: </p><pre>ProcessItem(Item I, int value);</pre><p>Now you could invoke this method using </b><b>for_each</b> like this:</p><pre>for_each(shapes.begin(), shapes.end(),  bind2nd(extern_mem_fun1(&amp;UserClass::ProcessItem,this), 10)        );</pre><p>The extra parameter passed to </b><b>ProcessItem</b> cannot be a reference type. Defining a reference type parameter causes a reference-to-reference compiler error. This is not a shortcoming of <b>extern_mem_fun1</b>; rather, it happens because <b>bind2nd</b> takes as a parameter a reference data type. The call to <b>bind2nd</b> creates a <b>binder2nd</b> that the Standard defines as follows: </p><pre>template &lt;class Operation&gt;class binder2nd    : public unary_function                     &lt;typename Operation::first_argument_type,                            typename Operation::result_type&gt; { ...public: binder2nd(const Operation&amp; x,         const typename Operation::second_argument_type&amp; y);  ...</pre><p>If </b><b>ProcessItem</b>'s <b>second_argument_type</b> were a reference type, then the type of <b>y</b> in the constructor would be <b>&amp;&amp;</b>. Because a reference to a reference is illegal in C++, you get a compilation error. The Boost <b>call_traits</b> library (<a href="http://www.boost.org/">http://www.boost.org/</a>) avoids this problem by using the Boost <b>call_traits</b> templates. </p><h3>Conclusion</h3><p>STL algorithms such as <b>for_each</b> and <b>find_if</b> can be used with <b>extern_mem_fun</b> and <b>extern_mem_fun1</b> to replace error-prone loop logic, as well as eliminate the proliferation of function objects that try to replace the functionality that should be implemented by methods of the class. The <b>extern_mem_fun</b> member function adaptor promotes the natural paradigm where private, protected, and public methods of a class process the private data of the class. The <b>extern_mem_fun</b> class accomplishes this by delegating the responsibility of processing elements in an STL container to a member function of a class that owns the container. The listings presented here, which are downloadable from the <i>CUJ</i> web site (<a href="http://www.cuj.com/code/">http://www.cuj.com/code/</a>), were compiled using Visual C++ 6.0. </p><p>It is important to note that there are binder libraries that offer the functionality of <b>extern_mem_fun</b>, and much more. For example, using <b>Boost::bind</b>, the equivalent (of the example) of <b>extern_mem_fun </b>is:</p><pre>for_each(shapes.begin(),shapes.end(),   bind(bind(&amp;LayoutManager::ShowNextShape,   this,_1),_1));</pre><p><b>Boost::bind</b> is a generalization of the standard functions <b>std::bind1st</b> and <b>std::bind2nd</b>. It supports different arity (number of arguments), arbitrary function objects, functions, function pointers, and member function pointers, and is able to bind any argument to a specific value or route input arguments into arbitrary positions. <b>bind </b>does not place any requirements on the function object; in particular, it does not need the <b>result_type</b>, <b>first_argument_type</b>, and <b>second_argument_type</b> standard typedefs. </p><hr><I><b>Claudio Taglienti</b> is a wireless data architect at U.S. Cellular. He can be contacted at <a href="mailto:ctaglienti@ameritech.net">ctaglienti@ameritech.net</a>.</I><hr></body></html>