<html><head><title>January 04: </title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; C/C++ Users Journal--><p><i>C/C++ Users Journal </i> January 2004</p><h1>Mixed-Language Development &amp; SWIG</h1><h2>Mixing up Ruby &amp; C++</h2><h3>By Phil Tomson</h3> <a name="rs1"><a href="0401tomsons1.htm">"Wrapping" with SWIG</a><hr><p>There is generally an inverse relationship between speed of development and speed of execution. Code developed in C/C++ tends to execute much faster than code written in scripting languages such as Ruby, Perl, or Python &#151; languages I like to refer to as "agile languages." In many instances, it takes much less time to develop applications in agile languages. Often, a mixed-language approach makes sense: Develop the parts of the application where execution speed is an issue in C/C++, and develop other parts of the application in a scripting language where speed of development is important. The agile languages really shine when it comes to string manipulation (most include support for regular expressions), file manipulation, parsing, and rapid GUI development &#151; areas where developing in C/C++ can be cumbersome.</p><p>I recently worked on a project to create a computational geometry engine in C++. One of the main requirements was speed &#151; we had millions of polygons to check for intersection and overlap. As is often the case, the schedule for developing the application was aggressive. There were also quality concerns that led us to consider unit testing all of our classes to ensure that the various methods on those classes did the right thing. I began to investigate unit testing frameworks for C++. I tried out one of the frameworks, but didn't have much success and, after about an hour, I decided to try a different approach &#151; I used SWIG (<a href="http://www.swig.org/">http://www.swig.org/</a>) to wrap our C++ classes so that they were available from Ruby (<a href="http://www.ruby-lang.org/">http://www.ruby-lang.org/</a>), then used Ruby's unit testing framework, <b>Test::Unit</b>, for unit testing. Our application code was written in C++, but we were now writing our unit tests in Ruby.</p><p>SWIG is an interface generator that connects C/C++ programs with scripting languages such as Perl, Python, Ruby, and Tcl. SWIG uses C/C++ header file declarations to generate the wrapper code that scripting languages need to access C/C++ code. (For more information, see "Rapid Prototyping with SWIG," by Daniel Blezek, <i>CUJ</i>, November 1998.)</p><p>As the project progressed, we needed to be able to parse polygon description files and instantiate polygon objects based on information in these files. These files essentially contained a label for a polygon followed by a list of points that made up the vertices of the polygon. Using lex and yacc to write a parser for these files would have been overkill, but writing a parser in C++ didn't seem like a good option either. We decided that, since we already had all of our C++ classes wrapped with SWIG, we would go ahead and write the parser in Ruby (see the sidebar "Wrapping' with SWIG"). This saved a significant amount of time and required much less effort than it would have taken to write the equivalent parser in C++. In Ruby, the parser was less than 20 lines of code; it would have taken much more code in C++.</p><p>Earlier in the project, it was suggested that embedding a scripting language into our C++ application would be a nice feature to have because it would let users of our application script it. As time pressures increased, the chances that we would implement this particular feature became unlikely. However, after we began to do our file parsing in Ruby, it became clear that we could look at the application from the other direction: Instead of embedding a scripting language into our application, we were now using a scripting language (Ruby) to tie together our C++ components. The scripting language was now our "main" and we could expose this to the users of the application so they could customize the application by writing Ruby code.</p><h3>Example: Creating an Extension with SWIG</h3><p>Say you have C++ classes that represent geometrical objects (points and lines, for example), and suppose you would like to initially do unit testing of those classes using a scripting language. I use Ruby in this example, but any language that SWIG targets could be used. <A HREF="0401tomsonl1.htm" target="_BLANK">Listing 1</A> is the <b>Point</b> class in C++.</p><p>The <b>Point</b> class is simple; it has two attributes to represent the <i>x</i> and <i>y</i> location of the point, a constructor, and accessors. </p><p>The <b>Line</b> class (<A HREF="0401tomsonl2.htm" target="_BLANK">Listing 2</A>) defines accessors as well as methods to determine the slope, <i>y</i>-intercept of the line, and whether the line is parallel to another line. The intersection method is a stub for now as it returns <b>NULL</b>.</p><p>To wrap these two classes so that you can access them from a scripting language, you need to create an interface file; see <A HREF="0401tomsonl3.htm" target="_BLANK">Listing 3</A>. The interface file gives SWIG information about the C++ header files to wrap and the namespace they will appear in when accessed from the scripting language. The <b>%module</b> declaration, in this case, defines the namespace <b>GEO</b> in the target language. In Ruby, this would be equivalent to defining a module named<b> </b>"<b>Geo</b>": All classes, functions, and variables defined in C++ will appear to be in the <b>Geo</b> module on the Ruby side. Of special note are the two <b>%predicate</b> directives; these directives are intended for use only when Ruby is the target language. Ruby allows method names to contain a trailing "<b>?</b>" character; by convention, methods ending in "<b>?</b>" test for a condition and return either <b>true</b> or <b>false</b>. Since C++ does not allow the trailing "<b>?</b>" in method names, the <b>%predicate</b> directive tells SWIG to generate the wrapper such that the methods <b>is_vertical</b> and <b>is_horizontal</b> will appear as<b> is_vertical?</b> and <b>is_horizontal?</b> in Ruby. This is a simple interface file; details on creating SWIG interface files can be found in the SWIG documentation.</p><p>To build the Geo extension for Ruby, you run <b>make</b> on the makefile in <A HREF="0401tomsonl4.htm" target="_BLANK">Listing 4</A>. SWIG is run with the<b> -c++</b> option, indicating that the source language is C++, and the <b>-ruby</b> option, which indicates that Ruby is the target language. Running SWIG creates an output C++ file named "Geo_wrap.cxx." This file contains all the code necessary to wrap the classes defined in line.h and point.h. It's often helpful to examine this generated file if SWIG reports problems.</p><h3>Unit Testing C++ Code with Ruby</h3><p>Once you've created the shared library Geo.so, you can access the C++ components from within Ruby simply by requiring the Geo.so file at the beginning of the Ruby code (<b>require 'Geo.so'</b>). <A HREF="0401tomsonl5.htm" target="_BLANK">Listing 5</A> is a simple unit test for the <b>Point</b> class using Ruby's <b>Test::Unit</b> unit testing package. It instantiates a <b>Point</b> object at <b>x=5.0</b> and <b>y=25.0</b>, then checks the accessor methods to ensure they return the correct values (<b>assert_equal</b> flags an error if both values passed to it are not equal). Similar unit tests could be written for the <b>Line</b> class.</p><h3>Mixed-Language Prototyping</h3><p>In Ruby, classes are always open, meaning that methods can be added to classes at any time (including runtime). The implication here is that you can define a class in C++ and, later on, add methods to that class on the Ruby side. It also means that you can redefine C++-defined methods in Ruby.</p><p>Notice the <b>intersection</b> method in the <b>Line</b> class defined in <A HREF="0401tomsonl2.htm" target="_BLANK">Listing 2</A>; the algorithm has not been implemented, it just returns a <b>NULL</b> pointer. Testing for an intersection between two lines can be tricky because there are some special cases to handle. Why not implement the algorithm in Ruby first? Then, after it has been tested and found correct, it could be reimplemented in C++. Since Ruby needs no compile/link cycle, it's easier for doing iterative development to try an idea, then modify it until the algorithm works correctly. Ruby also has an interactive shell (irb), which lets you type in code and see results immediately.</p><p><A HREF="0401tomsonl6.htm" target="_BLANK">Listing 6</A> is the first attempt at an <b>intersection</b> method for the <b>Line</b> class, and <A HREF="0401tomsonl7.htm" target="_BLANK">Listing 7</A> shows the unit tests for the method. When you try running these unit tests, you encounter a problem &#151; vertical lines have infinite slope. You realize that you need to check for vertical lines and handle them specially. You also realize that you need to consider the case of parallel lines that will never intersect. After making some adjustments to the Ruby code to handle these cases and performing some more tests, you can then translate this code to C++ and move it into the C++ <b>Line</b> class. The same unit tests can then be used to ensure that this translation was done correctly.</p><p>You could also apply this methodology for prototyping whole classes. For example, if the project needs a <b>Polygon</b> class, you can implement the <b>Polygon</b> class in Ruby along with unit tests. After some iterative development where you run tests and make adjustments to code as needed, you could then translate the <b>Polygon</b> class into C++ for better performance.</p><h3>Conclusion</h3><p>Doing mixed-language development with C++ and Ruby offers several benefits. There seems to be a good synergy between the two languages because they are both object oriented (Python offers similar advantages). The fact that Ruby classes are always open allows for some interesting possibilities where parts of a class are implemented in C++ and other parts of the same class are implemented in Ruby. Since Ruby is not a compiled language, it's easier to do iterative development in Ruby because there is no compile/link cycle. After testing the Ruby implementation to ensure correctness, the code can be translated to C++ in cases where performance is an issue. The same unit tests can be used to ensure that this translation was correct.</p><p>It is important to note that C++ supports multiple inheritance, while Ruby supports single inheritance. However, Ruby has support for <b>mixin</b>s, meaning that modules of code can be mixed into a class &#151; thus making the methods defined in those modules available to the class. Any number of modules can be mixed into a class. Future releases of SWIG after 1.3.20 will support this mechanism for simulating multiple inheritance in Ruby by treating some parent classes as modules that will be mixed into the resulting Ruby class. This wasn't an issue in this project because I avoided multiple inheritance in C++, even prior to using Ruby in the project. </p><hr><I><b>Phil Tomson</b> is currently a graduate student in Electrical and Computer Engineering at Portland State University. He can be contacted at <a href="mailto:philt@odin.pdx.edu">philt@odin.pdx.edu</a>.</I><hr></body></html>