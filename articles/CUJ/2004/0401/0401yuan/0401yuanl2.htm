<html><head><title>January 04: </title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; C/C++ Users Journal--><h4>Listing 2: 	Production::operator()().</h4> <pre>template &lt; typename _Tp,  typename _ChannelTp = Channel&lt;_Tp&gt;,   typename _ProducerTp = Producer&lt;_Tp, _ChannelTp&gt;,   typename _ConsumerTp = Consumer&lt;_Tp, _ChannelTp&gt; &gt;class Production {  ...public:  void operator()()  {    _ChannelTp chan(queueLen_);    Latch theLatch, noLatch(true);    _ProducerTp* producer = new _ProducerTp(chan, noLatch);    _ConsumerTp* consumer = new _ConsumerTp(chan, syncStart_ ?                                                      theLatch : noLatch);    std::auto_ptr&lt;_ProducerTp&gt; prodClean(producer);    std::auto_ptr&lt;_ConsumerTp&gt; consClean(consumer);    consumer-&gt;mayStop(false);    // callback function for derived classes...    pcModelCreated(*producer, *consumer);    try {      boost::thread_group pthreads, cthreads;      int i;      for (i = 0; i &lt; nProducers_; ++i)        pthreads.create_thread(*producer);      for (i = 0; i &lt; nConsumers_; ++i)        cthreads.create_thread(*consumer);      theLatch.release();      beforeJoin();      pthreads.join_all();      while(chan.size() &gt; 0) sleep(0, 10);      // producers are done, consumers *may* stop...      consumer-&gt;mayStop(true);       cthreads.join_all();      afterJoin();    } catch (boost::lock_error&amp; err) {      Logger::log(err.what());    } catch (std::exception&amp; err) {       Logger::log(err.what());    } catch (...) {      Logger::log("catched...");    }  }  ...};</body></html>