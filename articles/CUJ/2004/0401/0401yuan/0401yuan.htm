<html><head><title>January 04: </title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; C/C++ Users Journal--><p><i>C/C++ Users Journal </i> January 2004</p><h1>A C++ Producer-Consumer Concurrency Template Library</h1><h2>Abstracting the algorithm and adopting for other applications</h2><h3>By Ted Yuan</h3><p>Producer-consumer is a well-known C++ concurrency pattern that's been applied to applications ranging from scientific simulations (where multitasked computations are accomplished by using a pool of worker processes and a managing process that maintains the pace of progress) to image processing (where raster image data sets are filtered through multithreaded mask algorithms). It's also been applied to distributed parallel computing, where a concurrent network server responds to client requests with a pool of request handler threads. Existing implementations of the producer-consumer model (also referred to as the master-slave model) tend to be either narrowed to certain applications or bound to specific OS platforms (because of platform-specific threading and synchronization techniques). In this article, I present a C++ template-based and multithreaded producer-consumer implementation that's based on the C++ Standard Template Library (STL) and Boost::Threads library [1]. The complete source code for the implementation is available at <a href="http://www.cuj.com/code/">http://www.cuj.com/code/</a>.</p><p>My goal in developing this implementation was to abstract the producer-consumer algorithm, making it easier for other applications to adopt [2]. For instance, imagine a web server scenario in which a listening server accepts client connection requests, then processes the requests once connections are made. To be more responsive, the server may hand over an accepted client connection to a pool of worker threads by assigning the socket to a task list. The server then returns without blocking its listening mode and waits for new network connection requests. A worker thread removes the socket later from the list for further processing.</p><p>A producer-consumer pattern is chainable, making it useful in layered or multitier systems. In other words, consumers of a prior producer-consumer (PC) process (say, "production") can be the producers of a subsequent production. To extend the web server example, the worker threads that process the connections perhaps merely read the request content, then relay the requests immediately to a back-end database request queue. The subsequent database queries can be done by another PC process, where a pool of database access threads at the other end of the database-request queue pick up the query requests and fulfill the actual query tasks.</p><p>Generally, there can be multiple task schedulers (producers) that create task objects. Matching the number of producers to the number of consumers is often a runtime performance tuning requirement. The separation of producer and consumer in the PC model meets the requirement. A task holding and delivery queue is necessary for implementing a PC model. To summarize, producers in a PC model create and place tasks onto a predefined task-delivery queue without waiting for them to be processed. Consumers (task handlers) at the other end of the delivery queue retrieve the tasks and process them later. <A HREF="0401yuanf1.htm" target="_BLANK">Figure 1</A> illustrates the PC workflow and lists the requirements.</p><p>A PC model does not dictate how consumers return results back to producers. In general, they may not. In multithreaded implementations of PC workflows, the delivery queue has to be accessed in a thread-safe manner. Finer delivery-queue tuning in terms of writer or reader access is outside the scope of the article.</p><p>The consumer pool and thread pool, two variations of the PC model, are also widely used. In a consumer pool case, there is no active producer &#151; the task queue is created and prefilled before consumers start. In a thread pool, a simple producer and a linear task queue are the usual characteristics. </p><h3>Implementation</h3><p>The bulk of my work resides in two header files, ProCon.h and ThreadPool.h. To achieve reusability, I used a C++ template technique that separates a producer-consumer workflow from application-specific logics. STL's container classes are used as base collection structures for task-delivery queues that connect producers with consumers. Portability of the library to OS platforms other than Windows and Linux is assured by the STL and Boost libraries. There are four classes that make up the main portion of my PC implementation &#151; <b>Channel</b>, <b>Producer</b>, <b>Consumer</b>, and <b>Production</b>.</p><p>The <b>Channel</b> class (see <A HREF="0401yuanl1.htm" target="_BLANK">Listing 1</A>) provides thread-safe access to an underlying STL container; it implements a delivery queue. <b>Channel</b> is declared as:</p><pre>template &lt; typename _Tp, typename _queueTp &gt; class Channel;</pre><p>The first template parameter, </b><b>_Tp</b>, is a user-defined task data structure. The second template parameter, <b>_queueTp</b>, represents an STL container. By default, <b>_queueTp</b> is <b>std::deque&lt;_Tp&gt;</b>, which is preferred over other container types in our case of frequent insertions at both ends of a queue. Normally, task-delivery queues are FIFOs. <b>Channel</b> can be overwriten to make task retrieval prioritized according to application needs.</p><p>STL containers are value semantic. When a task object is added to an STL container, the task object's allocator and copy constructor are called to clone the original. Similarly, when a task object is removed from an STL container, the task object's deallocator is called to delete the copy. The value semantics may be a performance concern, especially if producers and consumers frequently add tasks to and remove tasks from a queue. To workaround the issue, I suggest you use task pointers rather than task objects unless the tasks can be described with a primitive type or the task objects are reference counted and properly scoped. (See my <b>ThreadPool</b> implementation as an example).</p><p>The <b>Producer</b>, <b>Consumer</b>, and <b>Production</b> classes implement the PC model in their <b>operator()()</b> methods. Consequently, they can be run by Boost::Threads directly. Part of what classes <b>Producer</b> and <b>Consumer</b> do in their <b>operator()()</b> methods (see <A HREF="0401yuanl2.htm" target="_BLANK">Listing 2</A>) is looping on writing to or reading task objects from a task queue. Their threads may be blocked briefly if the queue is temporarily full (for producers) or empty (for consumers). A derived class of <b>Producer</b> overwrites its <b>produce()</b> method, which is called to create tasks. Subclasses of <b>Consumer</b> overwrite the <b>consume(...)</b> method that processes a task request. </p><p>There are two cases worth mentioning. First, it may be important to have the producers started before the consumers. This is an issue if consumers are started early but cannot decide whether they can exit if they are facing an empty queue for a period of time. I solved it in the <b>Production</b> class with a <b>latch</b> object to initially block the consumers from running; the latch also facilitates the synchronized releases of consumers when ready. Second, since there is no direct communication between producers and consumers, <b>Production</b> sets a stop flag to notify consumers after producers are gone. It lets consumer threads finish under a predefined stop condition; for example, when the task queue becomes empty. A derived class of <b>Consumer</b> may overwrite the <b>cancel()</b> method to implement a rigorous stop condition specific to an application. In short, a consumer thread may exit only after the <b>bMayStop_</b> flag is set and its <b>cancel()</b> method returns <b>true</b>.</p><p>The <b>Takable</b> and <b>Puttable</b> classes are access interfaces of a task queue for consumers and producers, respectively. They provide an extra layer of indirection to access an underlying task queue. In most cases, you can ignore their existence. <b>Producer</b> and <b>Consumer</b> both have two constructors, one that accepts a task queue and another accepts a <b>Takable</b> or <b>Puttable</b> object. If you do not supply customized <b>Takable</b> and <b>Puttable</b> classes, the implementation creates defaults.</p><p>In short, users are expected to: </p><ul>  <li>Provide application-specific task data structures.   <li>Add application logic to their derived classes of <b>Producer</b> and <b>Consumer</b> by implementing <b>Producer::produce()</b> and <b>Consumer::consume(...)</b> methods.  <li>Customize <b>Production</b> if necessary.</ul><p>In addition, <b>Consuming</b> and <b>ThreadPool</b> are built on top of <b>Producer</b> and <b>Consumer</b> classes, and they represent two variant workflows of the PC model. <b>Consuming</b> maintains a pool of consumers that work against a static task queue<b>. Consuming</b>'s task queue is expected to be prefilled with tasks that may not change during execution. In contrast, <b>ThreadPool</b>'s<b> execute(_Runnable*&amp; runObj)</b> function allows for dynamically submitting new <b>Runnable</b> tasks to its queue. <b>ThreadPool</b>'s consumers retrieve pointers from the <b>_Runnable</b> tasks and invoke the<b> _Runnable</b>'s<b> operator()() </b>method.</p><h3>Examples</h3><p>To demonstrate how you can use the classes, my first example is that of an application of computation-intensive matrix multiplication. In this case, I use <b>Production</b> and its consumer pool variant <b>Consuming</b> classes. The second example illustrates a generic network server skeleton, where I use <b>ThreadPool</b> to launch worker threads that process network client connection requests. Both examples run on Windows and Linux platforms.</p><p>The result of an <b>n</b> rows by <b>m</b> columns matrix <b>A</b> times a<b> m</b> rows by <b>p</b> columns matrix <b>B</b>, is an <b>n</b> rows by <b>p</b> columns matrix <b>C</b>. Since the products of the <b>i</b>th row of matrix <b>A</b> with elements of matrix <b>B</b> determine the<b> i</b>th row of matrix <b>C</b> exclusively, I choose to create tasks according to the row index (<b>slice_i</b> in the program) of matrix <b>A</b>. As such, there should be a total of <b>n</b> tasks to be created and processed. Class <b>Convoluter</b> derives from <b>Consumer</b> and implements <b>consume(...)</b>, which computes the <b>i</b>th row of matrix <b>C</b>. <b>Scheduler</b> is a subclass of <b>Producer</b> that returns the next row index when its <b>produce()</b> method is called. The row index values are the task objects that get delivered from the producers (<b>Scheduler</b>) to the consumers (<b>Convoluter</b>). In the first approach, I derived <b>Convolution2</b> from <b>Production</b> to manage the computation. There is one producer thread and a maximum of <b>nConsumers</b> consumer threads. The consumer pool approach is simpler: <b>Convolution</b> sets up the row index values in the task queue prior to the start of the consumer threads; producer is not involved in this case. On a 500-MHz Pentium machine running Windows 2000, benchmark runs show both approaches are about 10-30 percent slower than a single-threaded approach for matrices with sizes in the hundreds.</p><p>In my second example, I use <b>ThreadPool</b> to build a generic network server called <b>NetworkService</b> (see <A HREF="0401yuanl3.htm" target="_BLANK">Listing 3</A>)<b>.NetworkService</b> can easily be integrated into an existing application by implementing its <b>ServiceHandler(int socket) </b>method, which processes a network socket request, and closes the client socket when finished. I built a simple HTTP web server with <b>NetworkService</b>. Upon request, the web server outputs "Hello World" and a visitor count in HTML format. It can be tested using any web browser by sending a request to <b>http://localhost:1234</b>. The gist of the example is the encapsulation of the network server logic and its threaded approach from the actual request handling.</p><h3>Conclusion</h3><p>C++ is a powerful and versatile language that promotes layered and object-oriented programming through class derivation. For example, the web server example contains software layers as STL, Boost::Threads, producer-consumer threading pool, network service encapsulation, and the web server on top. Developers working on each layer will constantly improve each component, whereas enhancement changes at the lower layers are hidden and ready to be incorporated into higher level components over time. Imagine how complex it would be (not to mention the on-going maintenance) if I had to write the web server in a procedural way with cross-platform threading ability and customizable function signatures.</p><h3>Notes and References</h3><p>[1]	Boost libraries can be found at <a href="http://www.boost.org/">http://www.boost.org/</a>. My producer-consumer implementation depends only on the Boost::Threads library.</p><p>[2]	Lea, Doug. <i>Concurrent Programming in Java</i>, Second Edition (Addison-Wesley, 1999). Several key classes described in the article are inspired by Doug's util.concurrent Java package, which can be found at <a href="http://gee.cs.oswego.edu/dl/">http://gee.cs.oswego.edu/dl/</a>. </p><hr><I><b>Ted Yuan</b> received his Ph.D. in Physics from Northeastern University and he is currently a professional software developer with Spoke Software. He can be contacted via <a href="taoyuan@bayimage.com">taoyuan@bayimage.com</a> or <a href="mailto:tedyuan@yahoo.com">tedyuan@yahoo.com</a>.</I><hr></body></html>