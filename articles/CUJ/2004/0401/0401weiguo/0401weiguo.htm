<html><head><title>January 04: </title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; C/C++ Users Journal--><p><i>C/C++ Users Journal </i> January 2004</p><h1>C++, Fortran, &amp; Shared Libraries</h1><h2>Calling Fortran functions from C++ by means of shared libraries</h2><h3>By Dong Weiguo</h3><p>Even though C++ is the programming language of choice for systems and business applications, Fortran still has a strong presence in scientific and engineering computation. In practice, programming in C++ and Fortran lets you make use of existing Fortran code bases, which are valuable resources and may significantly accelerate development.</p><p>While it is possible to call Fortran functions from C++, C++ (unlike C) provides features that support passing by reference as arguments, complex data types, and the like. By using proper definitions of Fortran data types and functions in C++, you can compile and link Fortran functions with C++ code using C++ compilers. This technique has been discussed by Carsten Arnholm (<a href="http://home.online.no/~arnholm/cppf77.htm">http://home.online.no/~arnholm/cppf77.htm</a>). </p><p>In this article, I present another way to call Fortran functions in C++. This approach is to compile Fortran functions separately into shared libraries, then explicitly call them in C++ from the shared libraries. Of course, this method is not 100-percent portable &#151; shared libraries compiled on one platform may not be used in another one. However, it is still portable because Linux and other operating systems support shared libraries, and there are system API functions available to make use of the shared libraries. The major advantage of this method is that Fortran code can be separated from C++ code, letting C++ developers use native C++ data types to call Fortran functions. And since there is no need for you to include additional header files, development and maintenance can also be separated. This increases the code modularity and reusability. Source code that implements this technique for both Windows and Linux is available at <a href="http://www.cuj.com/code/">http://www.cuj.com/code/</a>.</p><h3>About the Data Types</h3><p>Fortran has a long history in scientific computation. Hitherto now, there exist several Fortran standards, known as Fortran 66/77/90/95/2000. Since most of the existing Fortran codes comply with Fortran 77 (F77) Standard, I'll only address calling of the F77 functions in C++ via shared libraries.</p><p>Basically, there are six data types in F77 Standard, namely, <b>INTEGER</b>, <b>REAL</b>, <b>DOUBLE PRECISION</b>, <b>COMPLEX</b>, <b>LOGICAL</b>, <b>CHARACTER [*n]</b>, where <b>n</b> is the optional string length (in the range 1 to 32767). Most of these data types have their direct counterparts in basic C++ data types, except for <b>COMPLEX</b> and <b>CHARACTER</b>.</p><p>In C++, complex numbers are supported in the Standard Library rather than the core language. C++'s complex number class can be directly passed to F77 functions. Returning complex values from F77 functions may be different, since this is compiler-dependent behavior. (Here, I use GNU g77 as the F77 compiler.) However, C++'s complex class can also be directly used to hold the returned complex values from F77 functions.</p><p>Because of the different ways of handling string lengths in F77 and C++, as well as the different ways of passing strings as function parameters, <b>CHARACTER</b> is another special data type. The C++ <b>CHARACTER</b> class can also be directly passed to F77 functions. However, returning <b>CHARACTER</b> values from F77 functions is not supported by the method I present here. </p><p>Fortran supports multidimensional arrays. Passing one-dimensional arrays is easy, and C++ pointers can be directly passed to Fortran functions. Multidimensional arrays, however, need special attention because Fortran stores array elements in a "column-first" fashion, while C++ uses "row-first" convention. Carsten Arnholm refers to a class called <b>FMATRIX</b>, which can be used to convert a C++ matrix (two-dimensional array) to an F77 matrix. However, it also does not work in the method I present here. Instead, I treat multidimensional arrays as one-dimensional arrays; that is, one-dimensional C++ arrays are used and data of multidimensional arrays are rearranged to conform with the column-first rule. Then, the corresponding C++ pointers to the one-dimensional arrays are passed to call the F77 functions.</p><p>Function pointers are another useful type of function arguments. This is particularly important in scientific and engineering computations. For instance, a function pointer is useful in the numerical integration routines where the algorithm can be implemented in a function, which takes the integrand and boundaries as the arguments. This is better than hard-coding the function with the algorithm. In F77, a function or subroutine can take another external function's name as an argument, and call that external function inside of itself. In C++, this can be done by using function pointers. It has been found that C++ function pointers can be directly passed to F77 functions.</p><h3>DLLs and Shared Libraries</h3><p>Libraries are collections of object files, which can be statically or dynamically linked with the executable files. Dynamically linked libraries (DLLs) are one of the most important aspects of Windows. Shared libraries (or shared objects), on the other hand, are used in Linux and other UNIX-like operating systems. Neither DLLs nor shared libraries are native to C++ or F77--they are system-dependent techniques.</p><p>There are basically two ways to link DLLs or shared libraries with executable files &#151; implicit and explicit linking. Implicit linking is like static linking of libraries, except that implicit linking of shared libraries loads code upon startup. Explicit linking loads code while the program is running.</p><p>With explicit linking, programs do not need to know the name of the library upon startup, giving the program more flexibility. In this article, I'll show how to explicitly link F77 shared libraries in C++ programs.</p><p>Explicit linking of DLLs on Windows can be performed by using the Windows API functions <b>LoadLibrary()</b>, <b>GetProcAddress()</b>, and <b>CloseLibrary{}</b>. On Linux or Solaris (or perhaps other UNIX systems), explicit linking can be done via the API functions <b>dlopen()</b>, <b>dlsym()</b>, and <b>dlclose()</b>. </p><p>In the following examples, I use the GNU Fortran g77 compiler to compile F77 files into shared libraries. On Windows XP Pro, I use g77 in MingW 2.0. The DLL <b>foo.dll</b> is created from <b>foo.for</b> using the commands:</p><pre>g77 -fno-f2c -shared -s -o foo.dll foo.for</p></pre><p>On Red Hat Linux 8.0, I use g77 in GCC 3.2 to create the shared libraries by using the same command options:</p><pre>g77 -fno-f2c -shared -s -o foo.so foo.for</p></pre><p>C++ programs can then dynamically load the shared libraries. In the following examples, I use the freely available Borland command-line C++ compiler and g++ to compile the C++ programs on Windows and Linux, respectively.</p><h3>Examples</h3><p>My first example illustrates how to pass a single argument to an F77 function. <A HREF="0401weiguol1.htm" target="_BLANK">Listing 1</A> (ex1.for) is F77 code that defines a function with a <b>REAL</b> type input (<b>x</b>) and returns the value of <b>2*x</b>. <A HREF="0401weiguol2.htm" target="_BLANK">Listing 2</A> is the C++ test file on Windows. The <b>LoadLibrary()</b> function dynamically loads ex1.dll, which was compiled from the F77 code. ex1.dll can be in the same directory as the C++ program, or any directory defined by the <b>PATH</b> environmental variable. Then <b>GetProcAddress()</b> finds the function to be run in the ex1.dll. Because of "name decoration," g77 adds an underscore after the name of the function in the shared library. Also, F77 function arguments are passed by reference; therefore, in ex1win.cpp (<A HREF="0401weiguol2.htm" target="_BLANK">Listing 2</A>) the float type argument is passed by reference to the function <b>foo_()</b>. After getting the address of the function, one can call the function as you would a normal function. Finally, <b>FreeLibrary()</b> unloads the DLL from the address space of the calling process.</p><p><A HREF="0401weiguol3.htm" target="_BLANK">Listing 3</A> (ex1lnx.cpp) is the C++ file in <A HREF="0401weiguol2.htm" target="_BLANK">Listing 2</A> on Linux. You can create a shared library ex1.so from the F77 file ex1.for and put ex1.so in the same path as the C++ file (ex1.so can also be in a path defined by <b>LD_LIBRARY_PATH</b>). On Linux, you use the different API functions to dynamically load the function. The functions I use here are defined in dlfcn.h file. In this program, <b>dlopen()</b> opens ex1.so. <b>dlsym()</b> retrieves function's address, and <b>dlclose()</b> unloads the library. When ex1lnx.cpp (<A HREF="0401weiguol3.htm" target="_BLANK">Listing 3</A>) is compiled, it should be linked with DLL; for example:</p><pre>g++ -o ex1lnx ex1lnx.cpp -ldl</p></pre><p>Otherwise, there will be undefined references errors.</p><p>The second example is about complex numbers. <A HREF="0401weiguol4.htm" target="_BLANK">Listing 4</A> shows the F77 function, which takes one <b>COMPLEX</b> input, <b>x</b>, and returns a <b>COMPLEX</b> result of <b>2*x</b>. The DLL and shared library are ex2.dll on Windows and ex2.so on Linux. <A HREF="0401weiguol5.htm" target="_BLANK">Listing 5</A> (ex2win.cpp) is the C++ file of <A HREF="0401weiguol2.htm" target="_BLANK">Listing 2</A> on Windows, and <A HREF="0401weiguol6.htm" target="_BLANK">Listing 6</A> (ex2lnx.cpp) is the C++ file on Linux. You can see that in C++, the complex class can be used almost as easily as other data types such as <b>double</b> or <b>float</b>. Just like the first example, the C++ complex variable should also be passed by reference into the F77 function.</p><p><A HREF="0401weiguol7.htm" target="_BLANK">Listing 7</A> is the F77 subroutine, which calculates the dot product of two arrays, and saves the result in another array. The shared libraries are ex3.dll on Windows and ex3.so on Linux. <A HREF="0401weiguol8.htm" target="_BLANK">Listing 8</A> (ex3win.cpp) is the C++ file on Windows, and <A HREF="0401weiguol9.htm" target="_BLANK">Listing 9</A> (ex3lnx.cpp) is the C++ file on Linux. In this case, C++ pointers are passed for F77 arrays.</p><p>The fourth example deals with function pointers that are useful in scientific computations. The F77 function in <A HREF="0401weiguol10.htm" target="_BLANK">Listing 10</A> has two arguments: one is an external function name, the other a <b>REAL</b> type. The function evaluates the external function at the given argument and returns the result.</p><p>The shared libraries are ex4.dll on Windows and ex4.so on Linux. <A HREF="0401weiguol11.htm" target="_BLANK">Listings 11</A> (ex4win.cpp) and <A HREF="0401weiguol12.htm" target="_BLANK">12</A> (ex4lnx.cpp) are the C++ files on Windows and Linux, respectively. In this case, a C++ function pointer can be directly passed for an F77 function name. The C++ function to be evaluated in the F77 function should be defined in such a way that it takes references of data.</p><p>The last example is about Muller's method and demonstrates this calling method. This method can be used to find any number of roots (real and/or complex) of an arbitrary function. The source code was written in F77 and can be found at <a href="http://www.netlib.org/">http://www.netlib.org/</a>. The definition of the function <b>muller()</b> is:</p><pre>subroutine muller (f,eps,nsig,kn,nguess,n,x,itmax,infer,ier)implicit double precision (a-h,o-z)dimension x(1),infer(1)</pre><p>In the argument list, <b>f</b> is an external function whose roots will be saved in <b>x</b>.</p><p>The shared libraries are muller.dll on Windows and muller.so on Linux. <A HREF="0401weiguol13.htm" target="_BLANK">Listings 13</A> (ex5win.cpp) and <A HREF="0401weiguol14.htm" target="_BLANK">14</A> (ex5lnx.cpp) show the C++ files on Windows and Linux, respectively. In C++ files, the same function <b>myFunc()</b> is defined, which is simply a polynomial in <b>x</b>, made by the tenth power of <b>(x-1)</b>. Therefore, the actual roots of this functions are ten 1s. Don't be surprised if the results differ from the analytical ones &#151; it is a tough numerical problem to find roots of such a polynomial. In fact, Muller's method does a good job. To call the <b>muller_()</b> function in the shared libraries, a function pointer should be defined in the C++ files, just like the previous examples. In C++ files, pointers can be passed to F77 arrays, and single variables must be passed by references.</p><h3>Conclusion</h3><p>The technique I've presented here for calling Fortran functions from C++ via shared libraries is not completely portable on different operating systems. The major advantage of this method is that the source codes of Fortran and C++ can be separated. As demonstrated in the examples, you can use the native data types in C++ when dynamically calling the F77 functions, giving you much more flexibility. </p><hr><I><b>Dong Weiguo</b> is a member of the technical staff at DSO National Laboratories in Singapore. He can be reached at <a href="mailto:dweiguo@dso.org.sg">dweiguo@dso.org.sg</a>.</I><hr></body></html>