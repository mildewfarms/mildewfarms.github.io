<html><head><title>January 04: </title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; C/C++ Users Journal--><p><i>C/C++ Users Journal </i> January 2004</p><h1>Concurrent  Access Control &amp; C++</h1><h2>Implementing the monitor facility in C++</h2><h3>By Haifeng Li and Keshu Zhang</h3><p>In multithreaded environments, several components often access shared resources concurrently. When multiple threads read and write to them without proper synchronization, the shared resources will be in an inconsistent state. For this reason, concurrent access control has been studied extensively in various languages and systems. A preliminary solution is to bracket each critical section in a proper acquire-lock-or-wait and release-lock pair. For example:</p><pre>mutex lock;lock.do_lock();  do something;lock.do_unlock();</pre><p>This solves the problem of race condition, but it is tedious and error prone. Monitor [1] is a simple and efficient solution that automatically wraps a critical section in an acquire-lock-or-wait and release-lock pair. Many languages provide the implementations of monitor, including Java's </b><b>synchronized</b> [2], Modula-3's <b>LOCK</b> [3], and Mesa's <b>MONITOR</b> [4]. For example: </p><pre>Object lock;synchronized(lock){   // do something}</pre><p>Unfortunately, C++ has no such facility because Standard C++ is silent on the subject of threads. In this article, we show that Standard C++ does let you implement the monitor facility efficiently in only 50 simple lines &#151; and without any extensions to Standard C++. </p><h3>The Basic Idea</h3><p>Looking at the acquire-lock-or-wait and release-lock pair again, anyone familiar with C++ immediately realizes that lock is a resource and you should use the "resource acquisition is initialization" idiom [5] and leverage destructors for automatic resource deallocation. For each critical section, there is a corresponding object. The constructor of that object tries to acquire the lock-or-wait and the destructor releases the lock. For example:</p><pre>class auto_lock{public:    auto_lock(Lock&amp; lock)        : _lock(&amp;lock) 		{ _lock-&gt;do_lock(); }    ~auto_lock()        { _lock-&gt;do_unlock(); }private:    Lock* _lock;};</pre><p>where </b><b>Lock</b> is some existing <b>Mutex</b> class or something similar that supports <b>do_lock()</b> and <b>do_unlock()</b> operations. The implicitly generated copy constructor can easily lead to errors: The destructors of the copied-to and copied-from objects perform too many<b> do_unlock() </b>operations. Generally, you may declare private copy constructors and assignment operators to ensure that the lock is released exactly once. But we won't do it here. The reason will be clear later.</p><p>To serialize the access to a shared resource, you must declare an <b>auto_lock</b> object before any other statements at the beginning of a critical section: </p><pre>Mutex lock;{   auto_lock lock(&amp;lock);   // do something}</pre><p>Since </b><b>auto_lock</b> releases lock only in the destructor, the lock is held in the entire lifetime of <b>auto_lock</b>. Thus, a critical section must be included in a proper block in which <b>auto_lock</b> is declared as <b>auto</b> variable at the first statement. When the block is finished, <b>auto_lock</b> is automatically destroyed, then the lock is also released.</p><p>This approach works fine, but in the real world, it isn't very neat. The problems with the "resource acquisition is initialization" technique in this context are:</p><ul>  <li>Users must explicitly declare <b>auto_lock</b> objects.  <li>Users must control the lifetime of the <b>auto_lock</b> objects the same way they would control the critical sections.</ul><h3>A Real-World Approach</h3><p>When you have to handle a race condition in the real world, you may not want to explicitly declare an object and worry about its lifetime. This can be easily solved. Recall that if you declare an object in an <b>if</b> statement, C++ automatically frees it from the stack when the <b>if</b> block is done. Consequently, you can define this simple macro:</p><pre>#define synchronized(lock) \  if (const auto_lock lock_##__LINE__(lock))</pre><p>where you declare the lock object as </b><b>lock_##__LINE__</b> to handle the potential name conflict in case of nested synchronized statements. </p><p>You also need to extend <b>auto_lock</b> with an explicit type conversion operator <b>bool()</b> that always returns <b>true</b>:</p><pre>class auto_lock{public:   // ...  operator bool() const    { return true; }  // ...};</pre><p>Now you can tackle a race condition in C++ the same way as you would in Java:</p><pre>Mutex lock;synchronized(lock){   // do something}</pre><h3>Generic&lt;Programming&gt;::Monitor</h3><p>It seems that the monitor has been well implemented. However, you still have a lot of work to do if you want to write a template version of </b><b>auto_lock</b>. Application programmers use different locks (such as spin lock, mutex, semaphore, read-write lock, and so on) for different situations. </p><p>You can obtain a template version of the aforementioned <b>auto_lock</b> immediately:</p><pre>template &lt; typename Lock_T &gt;class auto_lock{public:    auto_lock(Lock_T&amp; lock)        : _lock(&amp;lock) 		{ _lock-&gt;do_lock(); }    ~auto_lock()        { _lock-&gt;do_unlock(); }    operator bool() const        { return true; }private:    Lock_T * _lock;};</pre><p>where you still assume that the type <b>Lock_T</b> provides the operations <b>do_lock()</b> and <b>do_unlock()</b>. It is easy to drop this requirement with the help of some adapter classes. You just need to modify the definition of <b>synchronized</b>:</p><pre>#define synchronized(Lock_T, lock) \   if (const auto_lock&lt;Lock_T&gt;lock_##__LINE__(lock))</pre><p>This new awkward definition requires users to provide one more parameter &#151; the type of lock:</p><pre>Mutex mlock;Spin_lock slock;synchronized(Mutex, mlock){    // do something}synchronized(Spin_lock, slock){    // do something}</pre><p>If users want to change the type of a lock, they need to modify all the <b>synchronized</b> statements besides the declaration of the lock. Again, this is a tedious and error-prone process. To make it easy to use <b>synchronized</b>, we present a helper function that creates and returns an <b>auto_lock</b> object (recall that we do not prevent copying <b>auto_lock</b> objects, so we can return an <b>auto_lock</b> that causes an implicit object copy):</p><pre>template &lt; typename Lock_T &gt;inline auto_lock&lt;lock_T&gt;make_lock(const Lock_T&amp; lock){   return auto_lock&lt;Lock_T&gt;(lock);}</pre><p>where </b><b>auto_lock</b> is dervived from <b>lock_block</b>:</p><pre>class lock_block{public:    operator bool() const        { return true; }};template &lt; typename Lock_T &gt;class auto_lock : public lock_block{public:    auto_lock(Lock_T&amp; lock)        : _lock(&amp;lock) 		{ _lock-&gt;do_lock(); }    ~auto_lock()        { _lock-&gt;do_unlock(); }private:    Lock_T * _lock;};</pre><p>By virtue of the C++ compiler, which deduces template arguments for template functions, we do not need to specify template arguments for <b>make_lock()</b> to create an <b>auto_lock</b> object. <b>lock_block</b> is a general class and does not need any type parameters. Thus, you may have a better definition of <b>synchronized</b>:</p><pre>#define synchronized(lock) \   if (const lock_block&amp; lock_##__LINE__ = \      make_lock(lock))</pre><p>Things are looking better, but someone may claim that there is a bug in the aforementioned definition. They might argue that we need to declare a virtual destructor for </b><b>lock_block</b>. They might also point out that we declare a <b>lock_block</b> object that actually refers to an <b>auto_lock</b> object. Without the virtual destructor, the lock is not released when the object is destroyed because the destructor of <b>lock_block</b> instead of <b>auto_lock</b> is called.</p><p>This may seem like a serious problem: but we do not need to worry about it because we can achieve polymorphic behavior of the destructor without a virtual destructor! According to the C++ Standard, a <b>const</b> reference initialized with a temporary value makes that temporary value live for the lifetime of the reference itself. If you write:</p><pre>Mutex lock;const lock_block&amp; magic_lock = make_lock(lock);</pre><p>where </b><b>make_lock</b> creates a temporary <b>auto_lock</b> object. This temporary object is assigned to the const reference <b>magic_lock</b>. The language rule &#151; that the temporary value lives at least as long as the reference &#151; ensures that the correct destructor is called when the temporary value is destroyed. In turn, the destructor releases the lock. We also achieve high efficiency because there is no virtual call involved. This trick was first used in Andrei Alexandrescu and Petru Marginean's "Generic &lt;Programming&gt;" column (<i>CUJ</i>, December 2000) [6] for exception safety.</p><p>At this point, we have implemented a powerful monitor to control concurrent accesses. </p><h3>ACID Transactions</h3><p>Based on the same idea, we can also solve another important problem &#151; ACID transactions. In the context of database transactions, ACID is short for "Atomic, Consistent, Isolation, and Durable." Transactions provide a simple model of success or failure. A transaction either commits (that is, all its actions happen) or aborts (all its actions are undone). This all-or-nothing quality makes for a simple programming model.</p><p>When applying the monitor idea to transactions, you need be more careful because you now have two choices if the transaction is over &#151; either commit or abort. Consequently, we extend the <b>lock_block</b> to a <b>trans_block</b> that has the Boolean variable <b>_abort</b> to track whether a transaction finishes or aborts:</p><pre>class trans_block{public:    trans_block()        : _abort(true) { }    operator bool() const        { return _abort; }    void finish() const        { _abort = false; }protected:    mutable bool _abort;};</pre><p>Derived from <b>trans_block</b>, class <b>auto_trans</b> starts a transaction in the constructor and rolls back or commits it in the destructor depending on whether it aborts:</p><pre>template &lt; typename Trans_T &gt;class auto_trans : public trans_block{public:    auto_trans(Trans_T&amp; trans)        : _trans(&amp;trans) { _trans-&gt;start(); }    ~auto_trans()    {        if (_abort) _trans-&gt;rollback();        else _trans-&gt;commit();    }private:    Trans_T* _trans;};</pre><p>You can now define the counterpart of </b><b>synchronized</b>, the macro transaction:</p><pre>#define transaction(trans) \  for (const trans_block&amp; auto_trans_##__LINE__ \             = make_trans(trans); \       auto_trans_##__LINE__; \       auto_trans_##__LINE__.finish())</pre><p>where <b>make_trans()</b> creates and returns an <b>auto_trans</b> object. To understand how the macro transaction works, examine this example:</p><pre>database_session dbs;transaction(dbs){    // do something    if ( something is wrong )        break;    // do something    if ( something is wrong )        throw string("error");    // do something}</pre><p>where <b>transaction(dbs)</b> is actually a <b>for</b> statement whose initial part creates an <b>auto_trans</b> object with member variable <b>_abort</b> initialized to <b>true</b>. If everything goes well, the <b>for</b> statement finishes the first time loop, and the method<b> finish()</b>, which assigns <b>false</b> to <b>_abort</b>, is called. Then the second (test) part (that is, the type conversion operator <b>bool()</b> of <b>auto_trans</b>) is executed. Since operator <b>bool()</b> returns the value of <b>_abort</b>, which is now <b>false</b>, the <b>for</b> loop is not executed again, and the <b>auto_trans</b> object is destroyed. In the destructor of <b>auto_trans</b>, the transaction is committed because the variable <b>_abort</b> is <b>false</b>.</p><p>If something is wrong, you can stop executing the rest of the transaction with a <b>break</b> statement. In this case, the <b>for</b> loop is over and the <b>finish()</b> method is not called. Thus, <b>_abort</b> is still <b>true</b>. Consequently, the transaction rolls back when the <b>auto_trans</b> object is destroyed. You can also throw an exception. In this case, the <b>auto_trans</b> object is destroyed during the stack-unwinding process and, for the same reason, the transaction rolls back. </p><h3>Efficiency</h3><p>We've presented a flexible, general, and convenient monitor to control concurrent access. However, it would be useless if it has a serious impact on efficiency. To estimate this impact, we measured the runtime to synchronize a critical section 10 million times, by the monitor or the preliminary lock approach:</p><pre>for ( size_t i = 0; i &lt; 10*1000*1000; ){  // Monitor Approach  synchronized(lock) {      ++i;   }  // or Preliminary Lock Approach  lock.do_lock();  ++i;  lock.do_unlock();}</pre><p>Thus, the measurements show the overhead of the monitor compared to the preliminary lock approach. To consider the impact of the compiler and machine architecture, we ran the tests on five different machine architectures. On all five machines, we used g++ (four different versions) without any optimization. We ran the tests 100 times. <A HREF="0401zhangt1.htm" target="_BLANK">Table 1</A> lists the average runtimes (in seconds) and standard deviations.</p><p>The results show that our implementation is about two times slower than the preliminary lock approach. However, for nontrivial C++ code, the most obvious difference was between runs using different levels of optimization [7]. Recall that we declare every function inline and use a trick to avoid virtual calls. Besides, operator <b>bool()</b> always returns the constant value <b>true</b>. So, you can expect that a good optimizer will eliminate all overhead and the monitor should not actually perform any more computation than the preliminary lock. After turning on the optimization option (-O3), we ran the test again and obtained the improved results shown in <A HREF="0401zhangt2.htm" target="_BLANK">Table 2</A>.</p><p>Clearly, there are no significant differences between the cost of the preliminary lock and the cost of the monitor on all five machines. (We did not compare the runtimes on different machines because they are totally different hardware.) In short, our implementation seems quite efficient.</p><h3>References</h3><p>[1]	Hoare, C.A.R. "Monitors: An Operating System Structuring Concept," <i>Communications of the ACM</i>, 1974.</p><p>[2]	Lea, Douglas. <i>Concurrent Programming in Java</i>, Addison-Wesley, 1997.</p><p>[3]	Nelson, G. (editor). <i>Systems Programming with Modula-3</i>, Prentice Hall, 1991.</p><p>[4]	Mitchell, J.G., W. Maybury, and R. Sweet. <i>Mesa Language Manual.</i> XEROX PARC, 1979.</p><p>[5]	Stroustrup, Bjarne.<i> The C++ Programming Language</i>, Third Edition, Addison-Wesley, 1997.</p><p>[6]	Alexandrescu, A. and P. Marginean. "Change the Way You Write Exception-Safe Code &#151; Forever," <i>C/C++ Users Journal</i>, December 2000.</p><p>[7]	Stroustrup, Bjarne. "Wrapping C++ Member Function Calls," <i>The C++ Report</i>, June 2000. </p><hr><I><b>Haifeng Li</b> is a Ph.D. candidate in the department of computer science and engineering, University of California, Riverside. <b>Keshu Zhang </b>is a Ph.D. candidate in the department of elecrical engineering at the University of New Orleans. They can be contacted at <a href="mailto:hli@cs.ucr.edu">hli@cs.ucr.edu</a> and <a href="mailto:kzhang1@uno.edu">kzhang1@uno.edu</a>, respectively.</I><hr></body></html>