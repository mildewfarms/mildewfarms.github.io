<html><head><title>January 04: Programmer's Book Review</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; C/C++ Users Journal--><p><i>C/C++ Users Journal </i> January 2004</p><h1>Programmer's Book Review</h1><h3>By Jack J. Woehr and Gregory V. Wilson </h3><br><b><i>Linux and the UNIX Philosophy</b><br>Mike Gancarz</i><br>Digital Press, 2003<br>200 pp., $39.99<br>ISBN 1555582737<br><b><br><i>Automating UNIX and Linux Administration</b><br>Kirk Bauer</i><br>Apress, 2003<br>592 pp., $49.99<br>ISBN 1590592123<br><b><br><i>Amazon Hacks: 100 Industrial-Strength Tips &amp; Tools</b><br>Paul Bausch </i><br>O'Reilly &amp; Associates, 2003<br>280 pp., $24.95<br>ISBN 0596005423<br><b><br><i>Google Hacks: 100 Industrial-Strength Tips &amp; Tools</b><br>Tara Calishain and Rael Dornfest</i><br>O'Reilly &amp; Associates, 2003<br>329 pp., $24.95<br>ISBN 0596004478<br><b><br><i>Code Generation in Action</b><br>Jack Herrington</i> <br>Manning, 2003<br>342 pp., $44.95<br>ISBN 1930110979<br><b><br><i>Web Bloopers: 60 Common  Web Design Mistakes and How to Avoid Them</b><br>Jeff Johnson</i><br>Morgan Kaufmann, 2003<br>329 pp., $49.95<br>ISBN 1558608400<br><b><br><i>eBay Hacks: 100 Industrial-Strength Tips &amp; Tools</b><br>David A. Karp</i> <br>O'Reilly &amp; Associates, 2003<br>360 pp., $24.95<br>ISBN 0596005644<br><p>In 1995, Digital Press published Mike Gancarz's The UNIX Philosophy. Gancarz has followed up in the new millennium with a greatly revised, essentially new work: Linux and the UNIX Philosophy. As Gancarz explains in the preface: </p><blockquote><p>[I]t finally dawned on me. [My book] as a description of the UNIX way of thinking was a "first system." It was now being drawn into becoming a "second system," a...fuller, more developed, more relevant edition of the first. </p></blockquote><p>Sounds deep. Actually, it is.</p><p>Linux and the UNIX Philosophy is a book that conceivably could have an impact on the young computer scientist of today comparable to the impact that a book like <i>Thinking Forth </i>(Prentice Hall, 1984, ISBN 0-13-917568-7) had on us then-young computer scientists back in 1980s. Gancarz explores the philosophical basis of UNIX and ends up expounding the computer-science equivalent of what Huxley, Watts, and Isherwood called in the humanities the "perennial philosophy." Simplicity is a virtue. Directness is a virtue. If you keep it clean enough, even users can be taught to use it. We've all spent hours, days, and man-months struggling with managers and team members who couldn't grasp those simple principles!</p><p>On another level, this book is painful to read: The pain is nostalgia. "Yes, yes," I want to shout along with the text, "Tell them how it happened so they don't forget. We were there!" Actually, that's pretty much the gist of the "Foreword" by Jon "maddog" Hall. I found the cascade of memories triggered by Gancarz's insightful recital overwhelming &#151; memories of decisions made, of paths taken, of paths not taken, ideas good and ideas not so good succeeding or failing according to merit or whims of fate, as our craft, our industry, our art and world usage of the Linux/UNIX operating system(s) blossomed and grew to gargantuan proportions. </p><p>Yet, it's more than just a nostalgic trip. Linux and the UNIX Philosophy is a useful book because it recounts, with charming brevity, how an immense corpus of business-mission-critical software emerged in conjunction with the then-industry-novel business model of community-shared intellectual property as represented by GNU/Free Software/Berkeley/Open Source. The inference is that there is some sort of platonic ideal that unites the evolution of the design philosophy of UNIX itself with the advent of the social philosophy of open software.</p><p>Not that Gancarz idealizes the operating system itself, as this excerpt from section 7.9 ("Worse is Better") shows:</p><blockquote><p>[T]here is the right way, the wrong way, and the military way.The "UNIX way" is akin to the military way. If you listen to the purists, UNIX should have withered and died 20 years ago. Yet, here it is in its entire parasitic splendor, feeding off the criticisms leveled at it...and growing stronger every day.</p></blockquote><p>This book is not just a windy newsgroup rant: Linux and the UNIX Philosohpy is a first-class folk-history of UNIX and Linux. Many of us might tell the story differently, or may have already told the story differently, drawing at the same time somewhat different conclusions based on our individual roles. But if you're willing to listen to a lover of software coding and design tell the story concisely and engagingly, you couldn't ask for better than this book.</p><p>Descending from the ideal to the workaday, Kirk Bauer has delivered a worthwhile volume in <i>Automating UNIX and Linux Administration</i>. In a literary style resembling a rich series of workshops/lectures, Bauer takes you through admin automation starting at the right place &#151; secure shells, of course, to zip and zap your commands around the network &#151; and ending in the realm of automated backups and restores and the user interfaces for them. Sounds very basic, but maybe you've noticed that:</p><ul>  <li>When you suddenly decide you need to automate admin tasks, it can take weeks if not months to get right.  <li>If it's so basic, why do all the packaged toolchains for these purposes give such magnificent headaches?</ul><p>Uh-huh. Now you're getting it. It's not a question of whether you are interested in what Bauer is selling. It's a question of whether you need it explained to you how this stuff is done. In my experience, the answer is, "Yes, the majority of Linux and UNIX sysadmins in the industry need this refresher." Now, this sort of exposition can be done well or done ill. Bauer does it well. His only visible ideological commitment is to the simple, practical, and inexpensive. So in the end, perhaps this book could be said to manifest the same platonic ideal as Linux and the UNIX Philosophy where the rubber meets the road. The book exhibits good writing, good production values, several quick starts (cvs, for instance), and a good deal of mostly reusable code.</p><p align="right"> &#151; J.J.W.</p><p></p><p>One of the most sought-after prizes in marketing is to make your company's name synonymous with a particular product. In the United States, people talk about "xeroxing" documents; in the United Kingdom, they speak of "hoovering" the floor. And all around the world, every second, someone is "googling" for something. <i>InfoWorld</i> columnist Jon Udell even talks about a "Google address," which is the combination of terms you type in to get someone, or something, as the first result of a search.</p><p>It is, therefore, hardly surprising to find O'Reilly &amp; Associates releasing a book devoted entirely to Google, along with companion volumes on Amazon, eBay, and other dot-success stories. What is surprising is how useful these books are, even to hardcore developers who know what "quoting rules" and "short-circuit evaluation of Boolean expressions" mean. Take Tara Calishain and Rael Dornfest's <i>Google Hacks</i>, for example. The first three dozen or so entries (out of one hundred) explain how to search for material by date, how to find technical definitions, and so on. The authors then cover third-party services built around Google (including a few things that violate Google's terms of service).</p><p>Tips 50 through 85 cover the Google API, which lets programs written in Perl, Python, Java, and other languages use Google as an online service. Want to run a popularity contest? Or compare Google's results with those of other search engines? The code you need is right here, along with a lucid explanation of how it works. There are even sections on "Google Pranks and Games" and "The Webmaster Side of Google."</p><p>Paul Bausch's <i>Amazon Hacks</i> and David Karp's <i>eBay Hacks</i> have similar structure and content. My copies are already full of yellow sticky notes, and I have copied a fair bit of code from them for use in the courses I teach. (What better way to introduce students to web services than to show them how to program something they use every day?) While all of the material in these books is available online, the authors have done us all a service by collecting and organizing it &#151; rather like Google itself does for the Web, when you think about it.</p><p>Jeff Johnson's <i>Web Bloopers</i> is just as useful a book as these, though in a very different way. I also suspect that Johnson's content will outlast that of the <i>Hacks</i> books. His first book, <i>GUI Bloopers</i>, taught GUI design by critiquing several well-known programs, and showing what their designers should have done instead. In <i>Web Bloopers</i>, Johnson applies that approach to web sites. Each section puts a name to a common mistake, gives several real-world examples of its occurrence, and then explains what the site's designers should have done instead.</p><p>For my money, this approach is much more practical than the "top-down" style of many web-design books (particularly for people with technical backgrounds, like me). As you read the book, you can almost hear Johnson patiently saying, "Okay, let's see...You've repeated information here and here, and these links all lead back to the same place. Perhaps we could reorganize it like this..." A lot of what he says is common sense, but 30 seconds on the Web shows you how uncommon good design still is in practice. If you're interested in fixing that, this book is a great place to start.</p><p>Last on my list is Jack Herrington's <i>Code Generation in Action</i>. As the preface says:</p><blockquote><p>The two main constants in software engineering are:</p><p></p><ul><li>Programmers' time is valuable.</p><li>Programmers don't like repetitive, boring tasks.</p></ul></blockquote><p>Over the course of 13 chapters, and a handful of appendices, Herrington shows you how to build tools that generate software. Chapter 1 gives a simple case study, an overview of what code generation is, and how to tell if it's the right solution for a specific problem. Chapter 2 then outlines different kinds of code generators, and (importantly) looks at why many developers resist the idea of computer-generated code and how their objections can be answered. The rest of the book then fills in the details of this larger picture and shows how to create code for user interfaces, database layers, unit testing, and so on. Examples are given in a variety of languages (or mixes of languages), along with illustrations to clarify various difficult points.</p><p>I liked this book a lot. The simple-minded GUI wizards built into early IDEs may have given code generation a bad name, but when properly used, they are an effective way to manage the masses of boilerplate code in today's distributed multitier systems. If you're a skeptic, this book may convince you; once you're convinced, you will almost certainly find that it makes some part of your working life easier.</p><p align="right"> &#151; G.V.W. </p><hr><I><b>Jack Woehr </b>is an independent consultant in Colorado. He can be contacted at <a href="http://www.softwoehr.com/">http://www.softwoehr.com/</a>.<b>Greg Wilson</b> develops software for Hewlett-Packard. His is also a contributing editor for <i>Dr. Dobb's Journal</i>, and an adjunct professor at the University of Toronto. He can be contacted at <a href="gvwilson@ddj.com">gvwilson@ddj.com</a>.</I><hr></body></html>