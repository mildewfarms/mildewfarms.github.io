<html>
<head>
<title>June, 2004: Lint Metrics &amp; ALOA</title>
</head>

<body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000">
<!--Copyright &#169; C/C++ Users Journal-->

<h1>Lint Metrics &amp; ALOA</h1>
<p><i>C/C++ Users Journal</i> June, 2004</p>
<h2>  Making a powerful tool even more powerful</h2>


<h3>By Ralf Holly</h3>


<I>Ralf Holly is the principal of PERA Software Solutions and can be contacted at rholly pera-software.com.</I>

<hr>





<p>Almost every seasoned C/C++ developer knows about Lint and the fact that it can help to greatly improve software quality. Lint statically analyzes your source code and generates detailed lists of warnings about potential bugs, classic mistakes, and portability pitfalls. By going through the list of Lint warnings (known as "Lint issues"), you can not only correct the problems Lint complains about, but by reviewing your own code, quite often find unrelated defects. This is yet more proof of the value of code reviews, even if they are "only" conducted by Lint and the author of the code. </p>

<p>Lint aims at finding bugs early in the development cycle, before testing starts. Bugs found at this stage are typically 5-10 times cheaper to fix than bugs found during system testing [1]. If used from the outset, a tool such as Lint would ideally help you achieve a constant warning count of 0. However, in most cases, Lint is introduced into ongoing projects, in which case, you can easily get drowned in a deluge of Lint warnings.</p>

<p>In such settings, project managers usually do not have enough resources to clean up all modules, nor do they want to risk making code changes late in the process [2]. In ongoing projects, project managers would normally rather get a Lint quality overview of the project&#151;a compilation of the most frequently encountered Lint warnings, a sorted list of the most troublesome modules, and an overall "Lint score" that allows easy tracking of the code quality between builds. This is where ALOA comes into play.</p>
<h3>Hawaiian Linting</h3>

<p>ALOA (short for A Lint Output Analyzer) is a tool that processes output generated by PC-lint (Gimpel Software's Lint implementation; see http://www.gimpel.com/) and computes various useful metrics that give a quick overview of the internal quality of any C/C++ project. Furthermore, it shows which kind of Lint issues are most frequently encountered and highlights issue-laden modules. The metrics produced by ALOA are useful for tracking a project's Lint compliance and for fine-tuning Lint policies. The source code and related files for ALOA are available at http://www.cuj.com/code/.</p>

<p>ALOA takes the output from a project-wide Lint session and computes statistics and metrics like:</p>



<ul>
  <li>Overall Lint score. This is a weighted sum of the severity of all Lint issues encountered [3]. This metric is particularly useful for monitoring how the Lint quality changes between builds.</li>
  <li>File list. A list of modules, sorted by the weighted severity sum of the Lint issues contained. The main purpose of this list is to highlight troublesome modules. Modules from the top of the list are typically reviewed and cleaned up first.</li>
  <li>Issue list. This list shows which Lint issues are encountered most frequently in a project. It is a great tool for fine tuning the Lint policy because it shows which programming constructs/styles are typical for a project and, hence, may be suppressed globally by disabling the corresponding warnings in the Lint policy file.</li>
</ul>

<p>ALOA is free software, licensed under the terms of the GPL [4], and assumes that you have a PC-lint license. PC-lint is a powerful commercial version of Lint; however, I suppose that it is not too difficult to adapt ALOA to support other Lint implementations.</p>

<p>True to Microsoft's "eat your own dog food" approach, ALOA has been used on itself. <a href="0406hollyf1.html" target="_BLANK">Figure 1</a> is output from an earlier version. Today, of course, ALOA is free of Lint warnings at warning level 3. </p>
<h3>Using ALOA </h3>

<p>Again, ALOA needs the output from a project-wide Lint session as input. This multistaged process&#151;step 1, obtaining project settings; step 2, running Lint; step 3, running ALOA&#151;is driven by a batch file called "dsplinter.bat," which I wrote for Visual C++ projects (see <a href="0406hollyf2.html" target="_BLANK">Figure 2</a>).</p>

<p>In the first step, dsplinter forwards a user-provided Visual C++ project file (.dsp) to PC-lint (lint-nt.exe). The output from this stage is a PC-lint indirect file (_project.lnt) that contains a list of all files that belong to this project as well as predefined preprocessor symbols, and includes path settings in a format that is recognized by PC-lint.</p>

<p>Next, _project.lnt is fed to PC-lint again, together with another indirect file called "aloa.lnt." aloa.lnt contains output formatting settings that ensure that PC-lint generates messages in a format that is understood by ALOA. aloa.lnt includes the project policy (policy.lnt) by reference. The project policy determines the PC-lint warning level; that is, it defines which warnings are reported and which warnings are suppressed. dsplinter assumes that the project policy is located in the same directory as the Visual C++ .dsp file. During the project-wide Lint session, all output is collected in a file named "_aloa.xml." </p>

<p>At step 3 (running ALOA), _aloa.xml is passed to ALOA, which generates the Lint metrics and prints them to <b>stdout</b>. Typically, the output is redirected to a file on the command line, such that the results can be put under revision control and compared with results from previous runs.</p>

<p>The command-line interface of dsplinter looks like this:</p>

<pre>
dsplinter &lt;dspfile&gt; (&lt;config&gt; | -default) [&lt;file&gt; | -aloa]

</pre>

<p>The first parameter is the fully qualified filename of the Visual C++ project that you want to Lint. Next comes the actual configuration within your .dsp file. You can either select a particular configuration (for example, "myproject - Win32 Release") or pass <b>-default</b> to select the default configuration. The third parameter specifies the mode of operation. If omitted, the whole project gets Linted and all original PC-lint messages go to <b>stdout</b>. If you pass a fully qualified name of a project member file instead, only this module gets Linted [5]. To run dsplinter in ALOA mode (the focus of this article), you have to pass <b>-aloa</b>.</p>

<p>The biggest benefit of using dsplinter to drive the process is that it extracts the Visual C++ project settings on the fly (step 1; obtaining project settings). Therefore, you don't need to maintain a separate _project.lnt manually in parallel to your .dsp file. This is possibly because PC-lint directly supports .dsp to .lnt conversion for Visual C++ projects. But even if you are not using PC-lint or you are not working on Visual C++ projects, it shouldn't be too difficult to write a Perl script that extracts project parameters from your IDE vendor's project file.</p>
<h3>Implementation</h3>

<p>ALOA's code was developed under Visual C++ 6.0 and comprises only 400 lines of uncommented source code. This leanness is possible because on the one hand ALOA doesn't come with a fancy GUI and on the other hand, STL offers most of what ALOA needs. </p>

<p>ALOA's prebuilt executable, the Visual C++ project file and source code, as well as dsplinter can be downloaded from http://www .pera-software.com/aloa.htm.</p>

<p>Two classes, <b>File</b> and <b>Issue</b>, are essential for understanding ALOA's design. <b>File</b> encapsulates a source-code module that has been Linted. <b>File</b>'s attributes are <b>m_filename</b> (the name of the file), <b>m_severityScore</b> (the weighted severity sum of this file), and <b>m_severestIssueNumber</b> (the issue number of the severest issue in this file).</p>

<p>As its name suggests, <b>Issue</b> represents a Lint issue. An <b>Issue</b> has an issue number (<b>m_number</b>), a severity value (<b>m_severity</b>), and a counter that tallies how many times this particular issue number has been encountered in the whole project.</p>

<p>Both the <b>File</b> and <b>Issue</b> classes maintain a vector of pointers to each other. This cross referencing makes it fairly easy to answer questions such as, "What <b>Issues</b> are encountered in this <b>File</b>?" or "Which <b>Files</b> contain this <b>Issue</b>?" later on when generating metrics. <a href="0406hollyl1.html" target="_BLANK">Listing 1</a> is the definition of <b>File</b> and <b>Issue</b>.</p>

<p>Even though dsplinter (or, more precisely, aloa.lnt) instructs PC-lint to produce well-formed XML output that can be viewed with any XML viewer like XMLSpy, ALOA doesn't use a full-fledged XML parser. For simplicity, ALOA comes with a primitive, though efficient, parser that is only capable of extracting XML attribute values. Don't be surprised if you discover that it doesn't support DTDs, validation, XML comments, and the like.</p>

<p>After <b>main</b> (see <a href="0406hollyl2.html" target="_BLANK">Listing 2</a>) has validated the command-line arguments, it invokes the parser and registers a callback function (<b>onNewIssueHandler</b>; see <a href="0406hollyl2.html" target="_BLANK">Listing 2</a>). <b>onNewIssueHandler</b> is called back by the parser every time a new Lint issue is encountered. The arguments of <b>onNewIssueHandler</b> are the name of the file where the issue was found and the issue number.</p>

<p>The main job of <b>onNewIssueHandler</b> is to maintain an <b>std::map</b> of <b>File</b> objects (<b>gFileMap</b>) and an <b>std::map</b> of <b>Issue</b> objects (<b>gIssueMap</b>). The former uses the filename of the source-code module as a key, whereas the latter uses the Lint issue number:</p>

<pre>
typedef std::map&lt;std::string, File*&gt; FILE_MAP;
extern FILE_MAP gFileMap;

typedef std::map&lt;int, Issue*&gt; ISSUE_MAP;
extern ISSUE_MAP gIssueMap;

</pre>

<p>The first thing <b>onNewIssueHandler</b> does is update global information such as the project's total number of issues (<b>gIssuesCount</b>) and the total severity score (<b>gSeverityScore</b>). </p>

<p>Next, <b>onNewIssueHandler</b> checks whether this particular filename has already been registered with <b>gFileMap</b>. If "yes," the corresponding <b>File</b> object is retrieved from the map; otherwise, a new <b>File</b> object is created. The same thing happens with <b>Issue</b> objects. First they are checked as to whether a Lint <b>Issue</b> with the given issue number already exists in <b>gIssueMap</b>; if not, a new <b>Issue</b> object is created and stored in the map.</p>

<p>The last thing <b>onNewIssueHandler</b> does is cross-registration of <b>File</b> and <b>Issue</b> objects by calling <b>File::addIssue</b> and <b>Issue::addFile</b>, respectively. This happens regardless of how the <b>File</b> and <b>Issue</b> objects were obtained (either by creating them from scratch or by looking up existing objects in the maps).</p>
<h3>Obtaining Metrics</h3>

<p>Once the parsing phase is over, <b>main</b> invokes a function called <b>buildMetricsLists</b> (see <a href="0406hollyl2.html" target="_BLANK">Listing 2</a>). Since most of the metrics have already been computed on the fly during the parsing phase, the only task left for this function is to create sorted lists of all <b>Files</b> and <b>Issues</b> encountered in the project. </p>

<p>Since it is not possible to sort the <b>std::maps</b> directly (they have their own key-dependent ordering), the contained <b>File</b> and <b>Issue</b> objects are first copied to dedicated <b>std::vectors</b> (<b>gFileList</b> and <b>gIssueList</b>) before calling <b>std::sort</b>. To be able to use <b>sort</b>, two global versions of <b>operator&lt;()</b> need to be defined:</p>

<pre>
inline bool operator&lt;(const File&amp; lhs, const File&amp;  rhs) {
    // Sort by severity score, then filename
    if (lhs.m_severityScore == rhs.m_severityScore)
        return lhs.m_filename &lt; rhs.m_filename;
    return lhs.m_severityScore &gt; rhs.m_severityScore;
}

inline bool operator&lt;(const Issue&amp; lhs, const Issue&amp; rhs) {
    // Sort by count, then by severity
    if (lhs.m_count == rhs.m_count)
        return lhs.m_severity &gt; rhs.m_severity;
    return lhs.m_count &gt; rhs.m_count;
}

</pre>

<p>After the lists have been built up in memory, the only job left to do is present the metrics to the user. This is done by invoking <b>reportMetrics</b>. </p>
<h3>Conclusion</h3>

<p>ALOA is a simple yet powerful tool, particularly for introducing PC-lint to ongoing C/C++ projects. It quickly gives an overview of all encountered Lint issues, helps monitor a project's Lint quality over the course of time, and pinpoints troublesome modules.</p>

<p>I have successfully used ALOA on various projects, ranging from extremely resource-constrained embedded systems to GUI-based desktop systems. In all cases, PC-lint and ALOA have jointly helped reducing development costs. </p>

<p>It is impossible for me to quantify the benefits of using ALOA, but I'm convinced it is another&#151;rather lightweight and inexpensive&#151;step towards better software quality. </p>
<h3>Acknowledgment</h3>

<p>I would like to thank Peter Most for his support in reviewing this article and source code.</p>
<h3>References</h3>

<ol>
  <li>[1]	McConnell, Steve. <i>Code Complete</i>, Microsoft Press, 1993.</li>
  <li>[2]	Obviously, most of what Lint warns about are not really bugs. Rather, Lint acts like a mentor and asks the developer questions such as, "Are you really sure about what you are doing?"</li>
  <li>[3]	Not all Lint issues are considered equally bad. For instance, ALOA differentiates between Lint fatal errors (999 severity points), syntax errors (4 severity points), warnings (3 severity points), informational messages (2 severity points), and elective notes (1 severity point).  </li>
  <li>[4]	http://www.gnu.org/licenses/gpl.html/.</li>
  <li>[5]	With the help of dsplinter, you can easily integrate PC-lint with Visual Studio. This lets you Lint single modules from within Visual Studio and to quickly navigate between Lint messages. Refer to ALOA's readme file for details. </li></ol>






</body>
</html>