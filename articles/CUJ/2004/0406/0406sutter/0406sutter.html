<html>
<head>
<title>June, 2004: Trip Report:  March 2004</title>
</head>

<body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000">
<!--Copyright &#169; C/C++ Users Journal-->

<h1>Trip Report:  March 2004</h1>
<p><i>C/C++ Users Journal</i> June, 2004</p>
<h2>This month, an update on the most C++ Standards meeting, and the progress on the C++0x Standard language and Library</h2>


<h3>By Herb Sutter</h3>


<I>Herb Sutter (http://www.gotw.ca/) is convener of the ISO C++ Standards committee, author of <i>Exceptional C++ and More Exceptional C++</i>, and Visual C++ architect for Microsoft. </I>

<hr>





<p>The C++ Standards committee continues to meet twice a year. This time, I want to report on the Spring 2004 meeting which was held in Sydney, Australia, on March 21-26, 2004. </p>
<h3>Highlights</h3>

<p>Here are the highlights of this meeting:</p>



<ul>
  <li><i>Library innovation continues and solidifies</i>. We now think we're one meeting away from finishing up the first round of library extensions, which means they should be technically complete by the end of this year. At this meeting, we also decided to kick off a second round of extensions to continue the flow of new library facilities. See below for more details.</li>
  <li><i>Language innovation continues</i>. At this meeting, we considered more and better-baked language extension proposals for C++0x than ever before; some of them are detailed below. Many of them are nearly ready to be added to the C++0x draft Standard itself.</li>
  <li><i>Acceleration</i>. The committee also hopes to accelerate its work by doing more work between meetings. Over the coming months, we'll be experimenting with electronic review processes and other techniques for improving both the quantity and quality of the work of extending and evolving C++.</li>
  <li><i>C and C++ cooperation and harmonization continue</i>. At the Fall 2003 meeting, C and C++ already decided to adopt large parts of each other's work and to work jointly on some new additions. As expected, at this Spring 2004 meeting, the C++ committee decided to adopt the C99 library extensions that were not already in Standard C++. Interestingly, the C++ committee also explicitly decided to review the remaining C99 language extensions and miscellaneous differences to minimize source-level incompatibilities for programmers who are working in the (liberal) intersection of C and C++. This doesn't mean C++ is going to just airlift in the C99 language extensions wholesale; rather, it means that C++ intends to specifically review C99's extensions, adopting what makes sense, and then possibly in a different form because C++ is often able to add extensions in the form of library facilities that could only be language extensions in C (for example, an existing case in point is <b>complex</b>).</li>
</ul>



<p>Now let's drill down a little. To make this a self-contained article, I'll recap some of the preexisting status as we go, but focus on the current news and updates from this meeting. For more detailed information about some of the things that I've already covered in the past, see the references that I'll include to those other articles.</p>
<h3>What We're Doing, Part 1:  Library Extensions Update</h3>

<p>Why should you care about the work the Standards committee is doing?</p>

<p>In the short term, you might care because we're working on extensions to the C++ Standard Library, many of which are commercially available today or will be available soon from multiple community and vendor implementations. The first round of these library extensions, known as Library Extensions Technical Report 1 (Library TR1), is expected to be complete later this year. In recent articles, I've already written extensively about several of these new facilities, including:</p>



<ul>
  <li>Smart pointers (<b>shared_ptr</b> and <b>weak_ptr</b>). [2]</li>
  <li>Tuple types (<b>tuple</b>). [3]</li>
  <li>Generalized function pointers (<b>function</b>). [4,5]</li>
</ul>



<p>Others that I haven't covered yet, but intend to cover in future columns, include:</p>

<ul>
  <li>(New) Nearly complete C99 library compatibility. At this meeting, we officially voted to adopt essentially all the C99 Standard Library extensions that are not already part of ISO C++.</li>
  <li>Hash-based containers (<b>unordered_set</b>, <b>unordered_map</b>, <b>unordered_multiset</b>, <b>unordered_multimap</b>) that can offer substantially better performance, particularly better worst-case performance, than the current standard tree-based containers.</li>
  <li>Type traits (<b>alignment_of</b>, <b>has_nothrow_copy</b>, <b>has_virtual_destructor</b>, <b>is_base_of</b>, <b>is_ const</b>, <b>is_convertible</b>, for example) that let you easily query information about the capabilities of a type and about the relationships between types, and make compile-time decisions based on the answers.</li>
  <li>Regular expressions (<b>basic_regex</b>) that offer powerful expression matching (and not just for strings, either).</li>
  <li>Random-number generation (such as <b>random_device</b> and <b>poisson_distribution</b>) suitable for requirements as diverse as cryptography, gaming, and mathematical analysis.</li>
</ul>



<p>There are a few more facilities in this first batch of Standard Library extensions, including a bountiful bevy of beautifully brilliant mathematical special functions, but the ones I've listed are the ones that are most likely to be of wide interest out of the batch that's due to be technically complete later this year.</p>

<p>But wait, there's more: Although this first set of extensions is nearly done, at this meeting the committee formally decided to embark on a second round of extensions. This means that the aforementioned is the beginning, not the end&#151;the steady flow of such additions to the Standard Library will continue for the foreseeable future, starting with an advanced iterator facility that didn't quite gel in time to be part of the first batch.</p>
<h3>What We're Doing, Part 2:  Language Extensions Update</h3>

<p>Another reason to care about what the committee is doing is that we're also working on the next evolution of the C++ Standard. It's colloquially known as "C++0x" because we plan to complete work on it in this decade.</p>

<p>In my April 2004 column [1], I reported on the goings-on at the Fall 2003 meeting, as well as news from related meetings of the C and C++/CLI committees and how their work is being coordinated with C++. At this year's Spring meeting, we find the Evolution Working Group continuing to make progress sifting through language extension proposals. About two dozen specific proposals had papers, were discussed in detail, and will be further refined; some are very close to ready to vote into the draft Standard. Here are some highlights of concrete proposals that are in pretty solid form and enjoyed particularly strong support, so that they're among the most likely language extensions to be part of C++0x in some form; several of them also bear on collaboration with other Standards bodies (C and C++/CLI).</p>



<ul>
  <li><i>C99 harmonization</i>. Besides the general resolution to review C99's language extensions and harmonize where possible, there were two specific proposals in this area: One proposed that we adopt C99's <b>long long</b> type, and another proposed that we adopt C99's preprocessor extensions. Together with these, we also considered a draft paper from Bjarne Stroustrup proposing a <b>#scope</b>/<b>#endscope</b> mechanism that would give programmers a standard way to control macro pollution and protect their code from unwanted macros; Stroustrup's proposal was then also passed along to the C committee, who met the week after C++ in the same location, with C++'s recommendation that they consider something like this for C and that the two groups work together on it to minimize the chance of standardizing something that wasn't quite the same.</li>
  <li><i>Delegating constructors</i>. Francis Glassborow and I wrote a proposal to allow constructor work to be factored, including the initialization list work. This feature was independently proposed last year by Glassborow in the C++ committee and my C++/CLI work. The committee added a minor but significant tweak, and this proposal is now ready for us to draft some standardese wording and move forward.</li>
  <li><i>Static (compile-time) assertions</i>. Wouldn't it be nice if you could <b>assert()</b> at compile time, and emit a custom error message straight into the compiler output just like <b>#error</b> does? We think so too, and that's what this proposal is all about.</li>
  <li><i>Explicit conversion operators</i>. Implicit conversions can be useful, but they can also bite when they get used unexpectedly. Today, we can write <b>explicit</b> on converting constructors so that they are never triggered implicitly. Alas, we can't write the same on conversion operators, which, after all, are pretty much just the other side of the same coin. This is a frequently proposed extension, and was specifically considered in Sydney. It has much sympathy in the committee.</li>
  <li><i>nullptr</i>. I presented a refined version of a proposal coauthored by myself and Bjarne Stroustrup on <b>nullptr</b>, an explicit null pointer constant; this feature was described in detail in last month's column. [6] This is a feature that came directly from the C++/CLI work and directly overlaps with the ISO C++ evolution, so everyone wanted to be sure to check with the EWG to minimize the potential for divergence of similar features in C++/CLI and ISO C++ itself. The core of the proposal is still as described in [6], and this time the main change request was to simplify the design surrounding the type of <b>nullptr</b>.</li>
  <li>	  Aside: Permit me to editorialize briefly here about why I think this is good progress. Now, you might recall that the main change request for <b>nullptr</b> at the previous meeting was in some ways the inverse of the direction just discussed, namely that we should add to the design in this same area. That's not inconsistent, it's just par for the course; sometimes there's backtracking as alternatives are explored and either liked or rejected, and as a proposal author, you just have to be ready for that and expect that you're going to be directed to write up several versions of your proposal, some of which may roll back to essentially previous versions. That's not (necessarily) inconsistent feedback from the group from one meeting to another; it's more a case of everyone gradually getting the chance to get as familiar with your feature as you already are, and it's a good thing because it means people are taking the proposal seriously. Proposal authors should not, and generally do not, get frustrated with this or view it as wasted work and rework. I really believe it isn't that at all; rather, it's a necessary part of getting a group consensus, which is the essential thing in the standardization process. Patience is necessary, and it's generally rewarded.)</li>
  <li><i>Strongly typed enums</i>. The fact that <b>enum</b>s aren't scoped, implicitly convert to their underlying type, and have an unspecifiable underlying type are all serious portability problems, and sometimes they lead to subtle correctness problems, too. David Miller and I proposed a strongly typed <b>enum</b> type, building on Miller's work on this in the C++ committee last year and my independent work on this in the context of C++/CLI that came up with essentially the identical semantics, just different syntax. For more details on why this is a good idea and what particular problems current <b>enum</b>s can cause, see my article in last month's issue. [7]</li>
</ul>

<p>     </p>

<p>I hope to cover several of these features in upcoming installments of this or another column.</p>
<h3>Summary</h3>

<p>C++ library extensions are in full swing, and C++ language extensions are moving well. C++ and C++/CLI continue to actively collaborate well to respect C++ evolution and craft the highest possible quality of C++ language extensions for modern environments. C and C++ are continuing to work in good faith to iron out the source-level incompatibilities between the two languages, notably the language extensions introduced in the C99 Standard. This can only benefit programmers everywhere, especially those who use both languages, or even just use compilers that support both languages.</p>

<p>What's not to like? It's been quite a good year.</p>
<h3>References</h3>

<ol>
  <li>[1]	H. Sutter. "Trips Report: October-December 2003," <i>C/C++ Users Journal</i>, 22(4), April 2004.</li>
  <li>[2]	H. Sutter. "Smart(er) Pointers," <i>C/C++ Users Journal</i>, 20(8), August 2002. http://www.cuj.com/documents/s=7980/cujcexp2008sutter/.</li>
  <li>[3]	H. Sutter. "Tuples," <i>C/C++ Users Journal</i>, 21(6), June 2003. http://www.cuj.com/documents/s=8250/cujcexp2106sutter/.</li>
  <li>[4]	H. Sutter. "Generalized Function Pointers," <i>C/C++ Users Journal</i>, 21(8), August 2003. http://www.cuj.com/documents/s=8250/ cujcexp2106sutter/.</li>
  <li>[5]	H. Sutter. "Generalizing Observer," <i>C/C++ Users Journal</i>, 21(9), September 2003. http://www.cuj.com/documents/s=8840/cujexp0309sutter/.</li>
  <li>[6]	H. Sutter. "Much Ado About Nothing: A (True) Null Pointer Value for C++," <i>C/C++ Users Journal</i>, 22(5), May 2004.</li>
  <li>[7]	H. Sutter and J. Hyslop. "Enumerations," <i>C/C++ Users Journal</i>, 22(5), May 2004. </li></ol>






</body>
</html>