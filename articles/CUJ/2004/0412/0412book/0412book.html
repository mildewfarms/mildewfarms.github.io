<html>
<head>
<title>December, 2004: Programmer's Book Review</title>
</head>

<body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000">
<!--Copyright &#169; C/C++ Users Journal-->

<h1>Programmer's Book Review</h1>
<p><i>C/C++ Users Journal</i> December, 2004</p>
<h2></h2>


<h3>By Paul Martz</h3>


<I>Paul Martz is a software engineer specializing in 3D computer graphics and the OpenGL graphics standard. He can be contacted at pmartz@frii.com.</I>

<hr>


<p><b></b><br>
<i>GPUGems: Programming  Techniques, Tips, and Tricks for Real-Time Graphics</i><br>
Randima Fernando (editor)<br>
Addison-Wesley, 2004<br>
765 pp., $59.99<br>
ISBN 0321228324<br></p>


<p>For old-school graphics programmers, maybe the future arrived too soon. Just when you've become comfortable with multitexturing and the stencil buffer, the programmable Graphics Processing Unit (GPU) came along yanking the fixed-function pipeline from under your feet and sending you tumbling into an infinitely configurable world. To regain your footing, maybe you've tried rendering the "hello, world" of programmable graphics&#151;a few polygons with procedural textures&#151;and now wonder what else this new technology is capable of.</p>

<p><i>GPU Gems</i> is a collection of papers by industry experts on how to render a broad range of computer graphics effects in real time using the GPU. The book contains 42 chapters grouped into six sections, and is full color throughout its 765 pages. Subject areas include natural effects such as fire and skin, volume rendering, lighting and shadows, materials, image processing, shader tools, and performance. The book comes with a CD-ROM containing example code, movie files, and precompiled examples.</p>

<p><i>GPU Gems</i> is not for beginners. You should know C/C++ and the OpenGL or Direct3D graphics interfaces. You should know the basics of vertex- and fragment-shaders (how to store values in uniforms, fetch texels, write pixel color values, and so on), and be familiar with at least one shader language.</p>

<p>As in any <i>Gems</i>-style book, multiple authors contribute to an overall lack of consistency. However, thanks to excellent editing, <i>GPU Gems</i> is better than most in this department. The lack of consistency is most apparent in the source code and CD. Only about half the chapters have content on the CD, build environments differ from one example to the next, and the code is a mix of Cg, HLSL, and OpenGL vertex- and fragment-shader language.</p>

<p>Typically, only a small fraction of the material in a <i>Gems</i>-style book will apply to your current project. This is less of an issue with <i>GPU Gems</i> due to its narrow focus&#151;developing real-time software for state-of-the-art programmable graphics hardware. While specific rendering problems in <i>GPU Gems</i> might not pertain to your work, their solutions often apply globally across GPU programming. In addition, the examples of effective GPU programming found throughout <i>GPU Gems</i> should help transition fixed-function graphics programmers to the programmable GPU model.</p>

<p>This book can help experienced GPU developers think out of the box and take greater advantage of the GPU. The concept of using GPUs to offload nongraphic computation from the CPU is as old as GPUs themselves, but only recently has the GPU's increased horsepower made this a practical option. Two chapters discuss strategies and requirements for nongraphic GPU programming with example code for numerical reduction, sort and search, and fluid dynamics. Nongraphic computation on the GPU presents a problem: How to express an algorithm in terms of rendered primitives? The contributors present elegant and efficient solutions to fit this programming model.</p>

<p><i>GPU Gems</i> also shines in its treatment of performance. Several contributors discuss vertex- and pixel-shader performance issues. In addition, a full chapter is devoted to this subject alone, which contains an explanation of pipeline bottlenecks, how to identify where they are, and what to do about them.</p>

<p>As an example, you might suspect that your program's performance is throttled by texture memory bandwidth. In contributor Cem Cebenoyan's chapter on performance, he suggests increasing texture mipmap bias to dramatically reduce the texture level of detail, therefore reducing the number of texture memory fetches. If this change increases performance significantly, you've identified a texture memory bandwidth bottleneck. Cebenoyan's suggestions for addressing this bottleneck include reconsidering texture size requirements, using texture compression, avoiding high-precision texture formats, and more extensive use of mipmapping, all of which should reduce texture memory fetches and improve texture cache coherency.</p>

<p>Too often in many graphics programming books, performance receives inadequate treatment. Editor Randima Fernando has ensured that <i>GPU Gems</i> gives it the attention it deserves.</p>

<p>While the value of this book is undeniable, there is room for improvement. With the adoption of the OpenGL Shading Language in OpenGL 2.0, this book risks appearing outdated unless it's revised to include OpenGL Shading Language code examples.</p>

<p>The book also has a clear bias towards NVIDIA hardware. Since the editor is employed by NVIDIA, this is understandable. However, since all of the concepts in the book apply to programmable graphics hardware from any vendor, removing corporate bias in a future revision could expand the book's reader audience.</p>

<p>The shift of graphics hardware from expensive fixed functionality to open and affordable programmability is clearly the most dramatic change in the history of computer graphics. This technology represents the future of graphics programming, and all graphics developers should master it to stay employable. <i>GPU Gems</i> is a thorough exploration of programmable graphics hardware and a valuable resource for today's graphics developers. </p>





</body>
</html>