<html><head><title>February 04: Input Iterators</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; C/C++ Users Journal--><h2>Input Iterators</h2><p>An input iterator has many expected qualities &#151; comparable, dereferenceable, incrementable &#151; that are commonly associated with iterators. The important distinction that is often missed is that an input iterator may support only single-pass algorithms. SGI (<a href="http://www.sgi.com/tech/stl/InputIterator.html">http://www.sgi.com/tech/stl/InputIterator.html</a>) states that "after executing <b>++i</b>, it is not required that copies of the old value of <b>i</b> be dereferenceable or that they be in the domain of operator <b>==()</b>" and "it is not guaranteed that it is possible to pass through the same input iterator twice." It is this single-pass nature that is an artifact of the technique described here. Therefore, conducting an inner iteration within the outer would lead to unintended behavior, as in:</p><pre><b>container::iterator begin(c.begin());container::iterator end(c.end());for(; begin != end; ++begin){  if(xyz(*begin))  {    container::iterator it = find_if(begin, end, . . .);    ...  }}</b></pre><p>The <b>find_if()</b> loop would cause the outer iteration to be advanced, thereby failing to do the search in the desired manner.</p><a href="0402wilson.htm#rs1">Back to Article</a></body></html>