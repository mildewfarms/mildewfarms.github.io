<html><head><title>February 04: </title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; C/C++ Users Journal--><p><i>C/C++ Users Journal </i> February 2004</p><h1>C/C++ Compilers for Linux</h1><h2>In theory, specialized compiler providers should have an advantage</h2><h3>By Moshe Bar</h3> <p>At first look, there's not even a question &#151; GNU C/C++ rules on the Linux platform. Given that the kernel, libraries, and all of the tools are compiled with this compiler, and given that the compiler comes standard in every Linux distribution out there, it is easy to understand its dominance. </p><p>Still, there are other compilers available for Linux on the Intel architecture (IA32) platform. Why would you want to use them and what are their pros and cons? </p><p>One reason to use other C/C++ compilers is the quality of code generated. The Linux crowd tends to believe nothing can ever beat the GNU tools. It is indeed true that most of the GNU tools are far better than proprietary, commercial offerings. For example, there is little doubt that GNU's make is superior to those provided by development suites from HP, Sun, or IBM AIX. (One developer I know at Sun uses GNU tools, instead of Sun's, whenever he can.) </p><p>Nevertheless, compilers are indeed one of GNU's weakest spots. Why is that? One reason is certainly focus, or the lack thereof, when it comes to one platform or one architecture. A new GNU C/C++ release has to work &#151; or is expected to &#151; equally well on more than 20 platforms and architectures and combinations thereof. Making GNU C/C++ perform well on all these platform is, in some cases, a contrast in terms. This is especially true for the optimizer, which can't always keep up with aggressive new CPU optimizations such as branch predictions, pipelining, and prefetching. In this area, specialized, targeted compiler providers should have an advantage. In theory. </p><p>In the Linux space, not counting the ubiquitous GNU C/C++, the most widely used compiler suites are:</p><ul>  <li>C++ Compiler for Linux (<a href="http://www.intel.com/software/products/compilers/clin/">http://www.intel.com/software/products/compilers/clin/</a>). The Intel compilers have advanced optimization features for the Pentium 3, 4, Xeon, and new M CPUs. The Intel compilers also provide threaded application development and optimization through Intel's support of the OpenMP 2.0 Standard and Auto-Parallelism feature. The Intel C++ compiler is mostly source and object-code compatible with GNU C, thereby allowing you to preserve code integrity and development investment. The Intel C++ compiler is C++ ABI conforming, which allows for stronger compatibility with GCC version 3.2.  <li>Portland Group (<a href="http://www.pgroup.com/products/workpgcc.htm">http://www.pgroup.com/products/workpgcc.htm</a>). The PGCC Workstation 5.1 includes The Portland Group's native parallelizing/optimizing OpenMP C++ and ANSI C compilers for Intel Pentium II/3/4/Xeon, AMD Athlon/AthlonXP, and AMD Opteron workstations (C++ is Linux-only). The Linux C++ compiler closely tracks the proposed ANSI Standard and is compatible with cfront versions 2 and 3. The PGCC Workstation compilers are native parallelizing Linux C++ and ANSI C compilers. All C++ functions are compatible with Fortran and C functions, so you can compose programs from components written in all three languages. (Intel acquired Portland Group two years ago.)</ul>  <p>To test the performance of the different compilers, I used a Monte Carlo routine obtained from <a href="http://caboy.uchc.edu/sleipnir/Software/GSL/gsl-ref_14.html">http://caboy.uchc.edu/sleipnir/Software/GSL/gsl-ref_14.html</a>. I ran the test with the same data set and tuning parameters on a Pentium Xeon 2.4-GHz with 512K cache. <A HREF="0402bart1.htm" target="_BLANK">Table 1</A> shows the results I obtained.   <p>From <A HREF="0402bart1.htm" target="_BLANK">Table 1</A>, it looks like nothing can beat Intel's optimizer for number-crunching applications. After all, nobody knows the various Pentiums as well as Intel. In fact, working with commercial compilers for high-performance computing applications makes sense &#151; especially if you also need clustering capabilities like OpenMP, which are built into the Portland compiler. The longer the jobs run &#151; and in high-performance computing, some run for weeks or months &#151; the better the effect of a good compiler. <h3>Linux Kernel with Intel Compilers</h3><p>Some time ago, Intel reported on the Internet that the Linux kernel, once compiled with Intel compilers, achieved speed-ups of up to 70 percent. How true is this claim? To answer this question, I began by compiling the kernel with the latest edition of Intel's compiler. </p><p>The Linux kernel is written specifically for the GNU C compiler, using some of its extensions. You'd expect that using the Intel compiler would generate many errors and warnings, though this is far from the truth. I did have minor issues with some drivers (especially e1000.h and ftape-bsm.h). However, some of the errors I encountered are due to wrongly coded <b>typedef</b> structures like this:</p><pre><b>typedef struct bar_16 {   char xxx[3];   short yyy; } bar_16_t __attribute__ ((aligned (16))); </b></pre><p>Instead, you are supposed to write:</p><pre><b>typedef struct bar_16 {      char xxx[3];      short yyy; } __attribute__ ((aligned (16))) bar_16_t; </b></pre><p>The <b>attribute((packed))</b> is probably nonoperational anyway, as the <b>struct</b>s are already packed according to the default rules, but you should fix them in any event. The core kernel compiles without problems but with some warnings that, after inspection, proved to be innocuous. The first indication of compiler quality is the size of the executable. With the GNU C compiler, the kernel configuration resulted in a kernel size of 1,523,441, whereas with the Intel compiler, the same configuration yielded a kernel size of only 1,398,289. That's an efficiency difference of 8.9 percent.</p><h3>Kernel Compilers Benchmark</h3><p><A HREF="0402bart2.htm" target="_BLANK">Table 2</A> presents some benchmark results of the same kernel compiled with GNU C compiler versions and the Intel Pro 7.0 C compiler. (The kernels built by GCC 3.2 were not stable on the Pentium 4, so I used GCC version 3.1.)</p><p>As a customary warning/notice for every benchmark I publish, be informed that the benchmark is neither scientific nor audited. You may achieve slightly different results in your environment. The results are an indication rather than an absolute judgment of the quality of any of the compilers used. As usual, your mileage may vary. </p><p>In the benchmark, I clocked several key kernel operations. </p><ul>  <li><b>Signal</b> measures the time for the kernel to deliver a signal to a process.   <li><b>Fork</b> measures the time for the kernel to create an ex novo process and all the related address space structures.   <li>The <b>Context Switch</b> time is a measurement of the microseconds it takes to switch from user space to kernel space upon hardware interrupts.   <li>The fourth measurement, <b>VM Page Delete</b>, indicates how long it takes the virtual memory manager of the kernel to remove a page table entry and all depending kernel lists.   <li>Finally, <b>Pipe Create</b> measures the time to build a pipe connection between two processes. </ul>  <p>The benchmark was executed on a 2.4-GHz uniprocessor Pentium. All time measurements are in microseconds.   <p>From <A HREF="0402bart2.htm" target="_BLANK">Table 2</A>, it is clear that there is indeed some performance advantage in using the Intel compiler. On the other hand, this advantage is nowhere near the 70 percent performance increase as rumored on various web sites. Moreover, the speed difference is too little to make a real impact on everyday tasks such as browsing, OpenOffice, and the like. Considering the admittedly minor problems in compiling the Linux kernel with the Intel compiler, it's probably not worth the effort. <hr><I><b>Moshe Bar</b> is an operating-system researcher and has an M.Sc. and a Ph.D. in computer science. He can be contacted at <a href="mailto:moshe@moelabs.com">moshe@moelabs.com</a>.</I><hr></body></html>