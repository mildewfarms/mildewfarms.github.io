<html><head><title>February 04: Smart Pointers Reloaded (III): Construction Trackingsmart_ptr initialization</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; C/C++ Users Journal--><h4>Listing 1:	 <i>The original smart_ptr initialization mechanism.</i></h4><pre>ref_counted::ref_counted() {   pCount_ = <b>static_cast&lt;unsigned int</b>*&gt;(      SmallObject&lt;&gt;::<b>operator new</b>(<b>sizeof</b>(<b>unsigned int</b>)));   assert(pCount_);   *pCount_ = 1;}<b>bool</b> ref_counted::release(<b>const</b> P&amp;) {   <b>if</b> (!--*pCount_) {      SmallObject&lt;&gt;::<b>operator delete</b>(pCount_, <b>sizeof</b>(<b>unsigned int</b>));      <b>return true</b>;   }   <b>return false</b>;}<b>class</b> smart_ptr   : <b>public</b> storage_policy&lt;T&gt;   , <b>public</b> ownership_policy&lt;<b>typename</b> storage_policy&lt;T&gt;::PointerType&gt;   , <b>public</b> checking_policy&lt;<b>typename</b> storage_policy&lt;T&gt;::stored_type&gt;   , <b>public</b> conversion_policy{ ... };smart_ptr::smart_ptr(<b>const</b> stored_type&amp; p) : SP(p){ KP::OnInit(GetImpl(*<b>this</b>)); }smart_ptr::~smart_ptr() {   <b>if</b> (OP::release(GetImpl(*<b>static_cast</b>&lt;SP*&gt;(this)))) {      SP::Destroy();   }}</body></html>