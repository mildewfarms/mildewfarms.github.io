<html><head><title>February 04: A Close Look at a Simple ProblemSometimes even the smallest programs can be the biggest problem</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; C/C++ Users Journal--><p><i>C/C++ Users Journal </i> February 2004</p><h1>A Close Look at a Simple Problem</h1><h2>Sometimes even the smallest programs can be the biggest problem</h2><h3>By Andrew Koenig and Barbara Moo</h3><p>Recently, one of us (Andy) went to a short workshop on guitar technique in which the instructor gave a particularly interesting exercise: Pick a random spot on the fretboard and play, by ear, a tune that you know well, starting at that spot. The kicker was that, although you could play as slowly as you liked, you had to play the tune perfectly on the first try &#151; one mistake and you had failed. This exercise is harder than it looks: Several friends, whom we consider to be excellent musicians, either failed or declined to try.</p><p>Consider an analogous exercise in the programming domain: Pick a simple problem and solve it, with the stipulation that the solution must work correctly the first time. How many of us can confidently say that we can solve even a nearly trivial problem correctly without testing? The best we can do is to write our programs in such a way that it is difficult for them to fail.</p><h3>The Problem</h3><p>To illustrate how to go about writing a program that we are confident will work, here is a problem: How many decimal digits are in a given unsigned integer? In other words, we are to write a function:</p><pre><b>unsigned ndigits(long unsigned n){   // the function body}</b></pre><p>that will tell us how many digits are in the decimal representation of </b><b>n</b>. We shall assume that 0 has one digit, noting that we could assume equally well that 0 has no digits &#151; an assumption that would yield a different program.</p><p>For the purpose of this problem, we are not allowed to use any library functions &#151; particularly library functions that convert integers to strings &#151; because then we would be using someone else's solution to the problem instead of solving it ourselves. Moreover, we must not use any floating-point arithmetic, because of the intrinsic difficulty in understanding the rounding problems that might come up.</p><p>If we were to set out to solve this problem naively, we would probably start by writing something like this:</p><pre><b>// Naive solution &#151; can it be made to work?unsigned ndigits(long unsigned n){     unsigned count = 0;     while (<i>condition</i>) {          ++count;          n /= 10;     }     return count;}</b></pre><p>and then go looking for an appropriate <i><b>condition</i></b> to make the code work.</p><p>An obvious choice for a condition for such a loop is to compare <b>n</b> to 0. It should be clear that <b>n &gt;= 0</b> and <b>n &lt; 0</b> will not do as choices: Because <b>n</b> is unsigned, the first condition is always true and the second is always false. Similarly, <b>n == 0</b> and <b>n &lt;= 0</b> are useless because unless <b>n</b> is zero, the loop won't be executed at all, thereby yielding the same number of digits for all numbers greater than zero.</p><p>Therefore, if zero is involved in the condition, it must be <b>n != 0</b> or, equivalently, <b>n &gt; 0</b>. However, this condition also doesn't work, because it will inevitably claim that 0 and 1 have a different number of digits &#151; a claim that contradicts the requirements of our problem.</p><p>This line of reasoning should convince you that comparing <b>n</b> to zero cannot yield a correct program. Rather than trying other conditions until we find one that works, we intend to approach the problem from the other end, starting with two observations:</p><ol><li>An unsigned integer less than 10 has one digit.</p><li>If <b>n³10</b>, then <b>n</b> has at least two digits, and <b>n/10</b> (truncated to the next lower integer, as C++ unsigned integer division does) is one digit shorter than <b>n</b>.</p></ol><p>In effect, these observations define the meaning of "decimal digits." For a program we write to be correct, it will have to be consistent with these observations.</p><p>In the rest of this column, we start from these observations and use them to develop three different solutions to our problem. Because these solutions grow directly out of the observations, we expect that we shall be more confident in their correctness than if we just used our intuition to write them.</p><h3>Direct Recursion</h3><p>The simplest way to translate our two observations into code is to write a piece of code that directly implements each observation. The resulting program is recursive:</p><pre><b>unsigned ndigits(long unsigned n){     if (n &lt; 10)          return 1;     return ndigits(n/10) + 1;}</b></pre><p>The </b><b>if</b> statement implements Observation 1: If <b>n</b> is less than 10, the result of the function is 1. The <b>return</b> statement implements Observation 2: If <b>n</b> is not less than 10 (which we know, because otherwise we wouldn't be here), we determine the number of digits in <b>n/10</b> and return one more than that value.</p><p>It is hard to imagine a more direct solution to our problem, and equally hard to imagine that the solution might not be correct. There is only one difficulty: The program is recursive, and some people find recursion hard to understand. Well, that's not the only problem with recursion: Another problem, which is important in contexts such as embedded systems, is that recursive functions consume an amount of memory that is proportional to the number of instances of the function that are active at one time. Some kinds of embedded systems have fixed memory requirements to guarantee that no matter what happens, the system will not run out of memory.</p><p>For these reasons, and to broaden the exercise, we would like to solve the problem without recursion. We shall do so in two different ways: first, by constructing an iterative program directly, and then by transforming the recursive program that we just wrote into an iterative program.</p><h3>Direct Iteration</h3><p>An important way of thinking about iterative programs is in terms of loop invariants. For those of you who have not read the discussion of invariants in <i>Accelerated C++</i>, here's a summary.</p><p>A loop invariant is a claim about the state of the program that is always true each time through a particular loop. Before the loop begins, the program must ensure that the invariant is true. In the body of the loop, the program can assume that the invariant is true at the beginning, in exchange for which it must ensure that the invariant is true again at the end of the loop body.</p><p>If the program takes care to maintain the invariant in this way, the invariant will still be true after the loop terminates. Moreover, the condition that controls termination will also be true. If we can arrange the condition and invariant so that their simultaneous truth solves our problem, we are done.</p><p>This discussion is awfully abstract. To make it more concrete, let's apply it to our problem. We said earlier that a naive solution would include a loop such as:</p><pre><b>while (<i>condition</i>) {   ++count;   n /= 10;</b></pre><p>If a loop of this form can be made to work, we should be able to find an appropriate invariant. That invariant dictates the condition that we need, and the condition and invariant together will let us write the rest of the program.</p><p>Each trip through the loop increases </b><b>count</b> and reduces the number of digits in <b>n</b> by one. This fact suggests that the invariant might say something about the sum of <b>count</b> and the number of digits in <b>n</b>.</p><p>Suppose we define <b>x</b> as the number of digits in the <i>original</i> value of <b>n</b>; that is, the value that we wish ultimately to compute. For convenience, let's also use <b>#(n)</b> to refer to the number of digits in the <i>current</i> value of <b>n</b>, even though we won't always know what that value is. Then a plausible loop invariant is <b>x=count+#(n)</b>, where "<b>=</b>" represents mathematical equality, not C++ assignment. To see why, look again at our naive loop:</p><pre><b>// Assume that x=count+#(n) is true herewhile (condition) {     ++count;     n /= 10;}</b></pre><p>As already noted, the body of the loop increases </b><b>count</b> by one and decreases <b>#(n)</b> by one. Therefore, if <b>x=count+#(n)</b> is true at the beginning of the loop body, it will again be true at the end.</p><p>What about the condition? When the loop finishes, we know that <b>x=count+#(n)</b> is still true. To choose the condition, then, it suffices to find one that makes the value of <b>#(n)</b> known. By Observation 1, that condition is <b>n &gt;= 10</b>; when that condition is false, we know that <b>#(n)</b> is 1.</p><p>Once we have reduced <b>n</b> to a value less than 10, thereby making <b>#(n)</b> equal to 1, we know from the invariant that <b>x</b> is <b>count + 1</b>. Accordingly, we can return <b>count + 1</b> from the program. To be confident that our program is correct, all that remains is to give <b>count</b> an initial value that makes the invariant true.</p><p>We know that before the loop starts, <b>#(n)</b> is equal to <b>x</b>, even though we don't know the value of <b>#(n)</b> or <b>x</b>. Accordingly, we can make the invariant true by setting <b>count</b> to zero.</p><p>The result is this program:</p><pre><b>unsigned ndigits(long unsigned n){     unsigned count = 0;     <i>// Invariant: x=count+#(n)</i>     while (n &gt;= 10) {          ++count;          n /= 10;     }     <i>// At this point, #(n) must be 1</i>     return count + 1;}</b></pre><p>Suppose that we would like to return <b>count</b> instead of <b>count + 1</b>. We know now that when our loop ends, <b>#(n)</b> is 1. If we wish it also to be true that <b>count=x</b>, then we must change our invariant. How about changing it to <b>count+#(n)=x+1</b>? Then when we have reduced <b>#(n)</b> to 1, <b>count</b> will have the value of <b>x</b>.</p><p>If we are going to change our invariant, we shall have to change the initial value of <b>count</b> to 1. The rest of the program can remain unchanged:</p><pre><b>unsigned ndigits(long unsigned n){     unsigned count = 1;     <i>// Invariant: x+1=count+#(n)</i>     while (n &gt;= 10) {          ++count;          n /= 10;     }     <i>// At this point, #(n) must be 1</i>     return count;}</pre><h3>Indirect Iteration</h3><p>There is another way to solve this problem without recursion: Take the recursive solution and rewrite it into iterative form.</p><p>One way to approach such a rewrite is to begin by changing the program so that each recursive call is a tail call &#151; a call that is the very last thing that happens in the function. The call</p><pre></b><b>return ndigits(n/10) + 1;</p></pre><p>is not a tail call because after the recursive call, we add 1 to the result.</p><p>It is not always easy to turn recursive calls into tail calls because not all recursion is easy to eliminate. When it is possible, it is often possible by </b><i>generalizing</i> the problem to be solved. For example, the trick to removing the recursion from this specific function is to change it so that instead of returning the number of digits in <b>n</b>, the function returns a secondary value <b>k</b> added to the number of digits in <b>n</b>.</p><p>Because we're changing what the function does, we shall change its name: <b>ndigitsk(n, k)</b> will return <b>k</b> plus the number of digits in <b>n</b>. It is useful to change what our function does, because doing so will let us change</p><pre><b>return ndigits(n/10) + 1;</pre><p>to</p><pre></b><b>return ndigitsk(n/10, k + 1);</p></pre><p>which is a tail call:</p><pre></b><b>unsigned ndigitsk(long unsigned n, unsigned k){     if (n &lt; 10)          return k + 1;     return ndigitsk(n/10, k + 1);}</b></pre><p>We can rewrite our original </b><b>ndigits</b> function into one that calls <b>ndigitsk</b> appropriately:</p><pre><b>unsigned ndigits(long unsigned n){     return ndigitsk(n, 0);}</b></pre><p>We can now eliminate the tail call in </b><b>ndigitsk</b> by putting a label at the beginning of the function body and turning the tail call into two assignments and a <b>goto</b>:</p><pre><b>unsigned ndigitsk(long unsigned n, unsigned k){loop:     if (n &lt; 10)          return k + 1;     ++k;     n /= 10;     goto loop;}</b></pre><p>Now that we've seen the resulting structure, it should be easy to see that we can turn the </b><b>goto</b> loop back into a <b>while</b>:</p><pre><b>unsigned ndigitsk(long unsigned n, unsigned k){     while (n &gt;= 10) {          ++k;          n /= 10;     }     return k + 1;}</b></pre><p>Finally, we can merge </b><b>ndigitsk</b> back into <b>ndigits</b> by copying the body of <b>ndigitsk</b> into <b>ndigits</b> after initializing <b>k</b> appropriately:</p><pre><b>unsigned ndigits(long unsigned n){     unsigned k = 0;     while (n &gt;= 10) {          ++k;          n /= 10;     }     return k + 1;}</b></pre><p>To our delight, this version of </b><b>ndigits</b> is identical to the first one that we constructed using loop invariants, except that the variable <b>count</b> changed its name to <b>k</b>.</p><h3>Discussion</h3><p>It may seem silly to spend this much time looking at such a simple piece of code. However, experience shows that a surprising number of programmers wind up making mistakes even in simple programs. Such mistakes often take the form of off-by-one errors, which are notoriously hard to trace and tend to cause security vulnerabilities.</p><p>One way to learn to avoid such errors in large programs is first to learn to avoid them in small programs. You would think that it would be trivial to write a program that correctly counts the number of digits in an integer &#151; but you would also think that it would be trivial to pick out a simple tune on a guitar without making a mistake. In both cases, the task requires a certain way of thinking, and in both cases, you can learn to think that way by practicing small problems before going on to larger ones.</p><p>The fact is that writing programs that work is just plain hard, and one important way of making it easier is to think rigorously about what the programs are doing.</p><h3>Exercise</h3><p>In case you're still not convinced that tiny programs can be tricky, you might try writing a version of this program that deals with signed long integers rather than unsigned ones. To do so, you must decide whether the number of digits in a negative number is the number of digits in its absolute value, or whether it is the number of characters the number would occupy if printed.</p><p>Once you have made that decision, you still face an implementation problem: If <b>n</b> is negative, there is no guarantee of being able to evaluate <b>-n</b> because in 2's-complement arithmetic, there will always be one negative value with no corresponding positive value. Moreover, for negative <b>n</b>, the implementation is permitted to truncate the value of <b>n/10</b> either up or down. Accordingly, the value of <b>(-99)/10</b> might be either <b>-9</b> or <b>-10</b>, which means that dividing a negative integer by 10 does not necessarily decrease the number of digits.</p><p>The next time you try to solve a complicated problem, remember how hard it was to solve this simple one. </p><hr><i><b>Andrew Koenig</b> is a former AT&amp;T researcher and programmer for more than 35 years. He is author of </i>C Traps and Pitfalls<i> and, with Barbara, coauthor of </i>Ruminations on C++ and Accelerated C++<i>. <b>Barbara Moo</b> is an independent consultant with 20 years of experience in the software field. </I><hr></body></html>