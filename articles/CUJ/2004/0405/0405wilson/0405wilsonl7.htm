<html><head><title>May 04: Mapping recls to COM Collections Delving into the Component Object Model</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; C/C++ Users Journal--><h4>Listing 7:	DirectoryPartsCollection <i>class.</i></h4><pre>struct dirparts_proxy_traits{  static CComVariant make_value(const recls_strptrs_t &amp;ptr);};typedef stlsoft::proxy_sequence &lt; const recls_strptrs_t, CComVariant                      , dirparts_proxy_traits&gt; directory_parts_type;typedef CComEnumOnSTL           &lt; IEnumVARIANT, &amp;IID_IEnumVARIANT, VARIANT,                                _Copy&lt;VARIANT&gt;, directory_parts_type&gt;                                       Enumerator_t;typedef ICollectionOnSTLImpl    &lt; IDirectoryPartsCollection,                                 directory_parts_type, VARIANT, _Copy&lt;VARIANT&gt;,                                Enumerator_t&gt;                                     Collection_t;class ATL_NO_VTABLE DirectoryPartsCollection  : public CComObjectRootEx&lt;CComMultiThreadModelNoCS&gt;  , public IDispatchImpl&lt;Collection_t,            &amp;IID_IDirectoryPartsCollection, &amp;LIBID_RECLS_COMLib&gt;  , public atlstl::SupportErrorInfoImpl&lt;&amp;IID_IDirectoryPartsCollection&gt;{public:  DirectoryPartsCollection()    : m_punkOwner(NULL)  {}  ~DirectoryPartsCollection();  HRESULT Init(LPUNKNOWN punkOwner, directory_parts_type &amp;parts)  {    m_punkOwner = punkOwner;    if(NULL != m_punkOwner)    {      m_punkOwner-&gt;AddRef();    }    m_coll = parts; // Copy STL collection    return S_OK;  }DECLARE_PROTECT_FINAL_CONSTRUCT()BEGIN_COM_MAP(DirectoryPartsCollection)  COM_INTERFACE_ENTRY(IDirectoryPartsCollection)  COM_INTERFACE_ENTRY(IDispatch)  COM_INTERFACE_ENTRY(ISupportErrorInfo)END_COM_MAP()// Membersprivate:  LPUNKNOWN m_punkOwner;};</body></html>