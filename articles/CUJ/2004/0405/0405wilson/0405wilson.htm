<html><head><title>May 04: Mapping recls to COM Collections Delving into the Component Object Model</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; C/C++ Users Journal--><p><i>C/C++ Users Journal </i> May 2004</p><h1>Mapping recls to COM Collections</h1><h2> Delving into the Component Object Model</h2><h3>By Matthew Wilson</h3><p>In previous columns, I introduced you to recls &#151; a platform-independent library that provides recursive filesystem searching &#151; and demonstrated techniques for integrating C/C++ libraries with C++ ("normal" classes, and STL sequences), C#, D, and Java by implementing recls mappings for those languages. The source for all the versions of the libraries and the mappings are available from <a href="http://www.cuj.com/code/">http://www.cuj.com/code/</a> and <a href="http://recls.org/downloads.html">http://recls.org/downloads.html</a>. This month, I focus on mapping the library to COM. </p><p>There are four changes to recls for this round: </p><ul>  <li>First, it now fully supports Unicode as well as ANSI, in the form of a compile-time preprocessor selection. If the preprocessor symbol <b>UNICODE</b> is defined and the symbol <b>RECLS_NO_UNICODE</b> is not defined, then the recls library is built using Unicode APIs, and the character types <b>recls_char_t</b> are defined to be <b>wchar_t</b> rather than <b>char</b>. At the moment, this is only supported for Win32; Unicode on UNIX is not supported.  <li>Second, passing a null pointer for the pattern causes it to default to the given platform's search-all string; for instance, "*" on UNIX and "*.*" on Win32. It's a minor change, but helps simplify client code, which no longer needs to care about how to express this on a platform-specific basis.   <li>Third, Comeau 4.3.3 and Intel 8.0 are now supported, and the next version will probably also support Open Watcom.  <li>Finally, the recls C API calling convention is now cdecl on Windows, rather than stdcall. The C# and D mappings have been adjusted accordingly.</ul>  <p>This month's developments correspond to Version 1.3(.1) or later of recls. It requires either STLSoft 1.7.1 or later (<a href="http://stlsoft.org/">http://stlsoft.org/</a>). (It actually relies on v1.7.1 Beta 4.)<h3>COM Enumerators and Collections</h3><p>In the STL world, the Container concept describes the things that hold collections of a given type, and the Iterator concept describes the mechanisms by which we access the elements within a collection. In the COM world, the containers are known as COM Collections, or just Collections, and the iterators are known as COM Enumerators, or just Enumerators.</p><p>A COM Enumerator implements a COM enumeration interface, which provides four methods:</p><pre>interface IEnumTHING{  HRESULT Next( unsigned long n     , THING         *pElements     , unsigned long *pFetched);  HRESULT Skip(unsigned long n);  HRESULT Reset();  HRESULT Close(IEnumTHING **ppEnThing);};</pre><p>For our fictional </b><b>THING</b> type, <b>IEnumTHING</b> provides access to a number of <b>THING</b> instances via the <b>Next()</b> method. You specify the number of elements you require, <b>n</b>, along with a pointer to an array of elements, <b>pElements</b>, of at least length <b>n</b>, that receives the elements. You also specify a pointer to an integer, <b>pFetched</b>, which receives the number of elements retrieved. In this way, the return of fewer than the requested number is facilitated.</p><p>The <b>Skip()</b> method moves the enumeration point on by the given number of elements. <b>Reset()</b> sets the enumeration point back to the start. <b>Clone()</b> provides a new enumerator to the same collection of elements, whose initial enumeration point is the same as the enumerator on which it is called.</p><p>The COM Collection model requires an object to support some or all of the following methods/properties: <b>Count</b>, <b>Item</b>, <b>_NewEnum</b>, <b>Add</b>, <b>Remove</b>, and <b>Clear</b>. The first three are used to elicit information from the collection; the latter three effect changes on the collection. Since the recls mappings provide read-only information about the filesystem contents, we are not concerned with <b>Add</b>, <b>Remove</b>, and <b>Clear</b>.</p><p>The <b>Count</b> property returns the number of elements in the collection. The <b>Item</b> property is an indexed property by which one can retrieve an element by index and/or by name. The <b>_NewEnum</b> property provides access to the COM Enumerator for the collection; it's like <b>begin()</b> and <b>end()</b> rolled into one.</p><h3>The Implementation</h3><p>I used ATL for the implementation of the COM objects. Although it has some flaws, ATL is an easy framework with which to create most kinds of COM implementations, and is suitable for in-process servers (implemented in a dynamic library), which is what we're using here.</p><p>The COM objects in the recls COM mapping are lightweight wrappers over the recls API and its internal implementation, which are pretty lightweight themselves.</p><p>I won't go into detail about COM's threading models here; that's way too much information to fit into this column. If you want to learn about that, check the MSDN documentation, or <i>ATL Internals</i>, by Brent Rector and Chris Sells (Addison-Wesley, 1999) or <i>Essential COM</i>, by Don Box (Addison-Wesley, 1997). Thankfully, the recls library makes our choices very simple.</p><p>The <b>FileSearch</b> class has no state, and its <b>Search()</b> method effectively acts as a static method. The <b>FileEntry</b> class maintains a single recls entry handle of type <b>recls_info_t</b> and has no other member variables. recls does not change the data associated with an entry handle once it is created. Furthermore, retrieving information from entries, and even closing entry handles, is guaranteed threadsafe by recls. Therefore, there are no problems with different threads making simultaneous calls on the same <b>FileEntry</b> instance, and the mechanics of COM reference counting handles the final release of the entry handle back to recls. There's no need to manage multithreaded access to member state, so both these COM classes follow the "Both" model &#151; which means that they support both free threading and apartment models &#151; and they use the <b>CComMultiThreadModelNoCS</b> ATL threading policy class in their definitions. Essentially, this ensures that the reference counting is done in a threadsafe manner (via <b>InterlockedIncrement()</b>/<b>InterlockedDecrement()</b>), but the access to member data does not use a synchronization object (a Win32 <b>CRITICAL_SECTION</b>).</p><h3>FileSearch</h3><p>The <b>FileSearch</b> class is the entry point into the library, and provides the single method <b>Search()</b>, defined by the <b>IFileSearch</b> interface:</p><pre>interface IFileSearch  : IDispatch{   HRESULT Search( [in] BSTR searchRoot     , [in] BSTR pattern     , [in] long flags     , [out, retval] IUnknown **_srch);};</pre><p>In other words, the caller specifies a search directory, a search pattern, and search flags, and receives an object that corresponds to those parameters. The object is returned via the generic </b><b>IUnknown</b> interface. The object returned, an instance of <b>SearchCollection</b>, must support the COM Collection model.</p><p><A HREF="0405wilsonl1.htm" target="_BLANK">Listing 1</A> is the implementation of <b>FileSearch::Search()</b>. The important feature of this method is that it starts a search before creating a <b>FileSearch</b> instance. This is because it would be possible for a search to fail (for reasons other than that no matching entries were found). In such a case, you want the <b>Search()</b> method to fail and deal with it there, rather than have some weird error reported as you start to enumerate through the collection at some later point.</p><p>The other main point to note is that the code is written to work correctly whether you are compiling for Unicode (<b>RECLS_CHAR_TYPE_IS_WCHAR</b> is defined) or ANSI (<b>RECLS_CHAR_TYPE_IS_WCHAR</b> is defined). This facilitates our working with the ATL Wizard-provided project options of Unicode and ANSI releases. Also note that the ANSI version uses the WinSTL (the STLSoft subproject for the Win32 API; <a href="http://winstl.org/">http://winstl.org/</a>) <b>w2a()</b> Unicode to ANSI function, which acts as a conversion shim (see my article "Generalized String Manipulation: Access Shims and Type Tunneling," <i>CUJ</i>, August 2003; <a href="http://www.cuj.com/documents/s=8681/cuj0308wilson/">http://www.cuj.com/documents/s=8681/cuj0308wilson/</a>). The normal way to do such conversion in ATL is to use the <b>W2CA()</b>, <b>A2T()</b>, and associated macros, but I avoid them for three reasons:</p><ul>  <li>Do not work with null pointers, which rules them out for this particular case.   <li>Rely on <b>alloca()</b>, which I personally prefer to avoid (for the reasons outlined in my article "Efficient Variable Automatic Buffers," <i>CUJ</i>, December 2003).   <li>Require that the string to be converted is null terminated. </ul><p>The WinSTL components suffer from none of these problems, though they do have the conversion shim return-value lifetime restrictions.</p><p>Assuming that the call to <b>Recls_Search()</b> results in a valid search, or fails only for having no matching items, then an instance of the <b>SearchCollection</b> is created and passes a <b>SearchInfo</b> instance containing the attributes of the current search.</p><h3>SearchCollection</h3><p>Since a recls search has no means to know ahead of time the number of elements that will be found, the <b>Count</b> method is not provided on the collection. Similarly, we cannot index the items because they are enumerated sequentially, nor can we access them by name, so the <b>Item</b> property is not supported either. We're just left with <b>_NewEnum</b>. The <b>SearchCollection</b> class embodies the COM Collection for the recls mapping, and derives from the <b>ISearchCollection</b> interface:</p><pre>interface ISearchCollection  : IDispatch{   [propget, id(DISPID_NEWENUM), restricted, hidden]    HRESULT _NewEnum([out,retval] IUnknown** pVal);};</pre><p>Its definition is straightforward, since it merely implements the </b><b>get__NewEnum()</b> method and stores an instance of <b>SearchInfo</b> to record details of the search. The <b>SearchInfo</b> class is defined as:</p><pre>struct SearchInfo{  hrecls_t  hSrch;  CComBSTR  searchRoot;  CComBSTR  pattern;  long      flags;  bool      bEmpty;  SearchInfo()    : hSrch(NULL)    , bEmpty(false)  {}};</pre><p>The reason you need to record the search parameters is that there are several points at which a search may need to be (re)initiated. One of these is within the </b><b>SearchCollection</b> class itself. When client code calls <b>get__NewEnum()</b>, the current search (perhaps the one started in the <b>FileSearch::Search()</b> method) is given over to the object that represents the COM Enumerator for the collection, an instance of the <b>EnumEntry</b> class (which we'll meet shortly). An example of this is found in one of the accompanying test programs, the imaginatively titled VBClient, which provides an almost identical version of the C# client we saw in the second installment. <A HREF="0405wilsonl2.htm" target="_BLANK">Listing 2</A>, from the search button handler, demonstrates the use of the collection. The <b>For Each </b>statement in Visual Basic causes the given object to be treated as a collection and queried for its enumerator via the <b>_NewEnum</b> property. In fact, it uses the stock <b>DISPID_NEWENUM</b> dispatch ID (<b>DISPID</b>) to identify the property, so you could give it any name. (You use the standard name so that C++ clients can use it directly, rather than having to use <b>IDispatch::Invoke()</b>.)</p><p>Since there's nothing to stop any client code doing multiple enumerations through the collection's contents, we need to be able to support additional enumerations. Because the recls API has a single pass semantic, you retain the details and then start a new search if you are requested to do so. You might suggest that this is all needless complexity and that searches should only be initiated at the last minute; there's some merit in that position, but I chose this way since it provides more obvious behavior to the client code.</p><p><A HREF="0405wilsonl3.htm" target="_BLANK">Listing 3</A> presents the implementation of <b>SearchCollection::get__NewEnum()</b>. Note that, as is the way with ATL, the COM objects must be initialized after construction. You just have to accept this; trying to buck the system will only bring you grief.</p><h3>EnumEntry</h3><p>The <b>EnumEntry</b> class embodies the COM Enumerator for the recls mapping. Because all this stuff's not complicated enough, I've added an extra twist. For Visual Basic (and other automation languages) clients, the collection must be in the form of an <b>IEnumVARIANT</b>; in other words, the items enumerated by the collection are <b>VARIANT</b>s. However, since the items are always instances implementing the <b>IFileEntry</b> interface (see <A HREF="0405wilsonl4.htm" target="_BLANK">Listing 4</A>), I've implemented the <b>EnumEntry</b> to provide both <b>IEnumVARIANT</b> and <b>IEnumFileEntry</b> interfaces. This means that C++ clients don't have to go through the tedious extra step of eliciting the interface from the <b>VARIANT</b> (which, to be correct, involves checking that the variant type is <b>VT_UNKNOWN</b> or <b>VT_DISPATCH</b>, then querying for <b>IFileEntry</b>).</p><p><A HREF="0405wilsonl5.htm" target="_BLANK">Listing 5</A> is the definition of <b>EnumEntry</b>. The rules of COM dictate that once an object has responded positively to a request for an interface, it must always appear to support that interface. The way <b>EnumEntry </b>works, therefore, is that it maintains two members to monitor which interface, if any, it has provided. Once either <b>IEnumEntry</b> or <b>IEnumVARIANT</b> has been returned, the other interface cannot be made available.</p><p>This is accomplished in the <b>QueryFunc()</b> static method, which checks the status of the instance with respect to the two interfaces and accepts or rejects the interface request accordingly. (Some of the code is rather grisly, but it is correct; if you want to look at it, check out the implementation available in this month's code archive, or online at <a href="http://recls.org/downloads.html">http://recls.org/downloads.html</a>.) The lesser known <b>INTERFACE_MAP</b> entries catch the requests for <b>IEnumVARIANT</b>/<b>IEnumFileEntry</b>, and also ensure that queries for <b>IUnknown</b> always succeed, as they must by the rules of COM.</p><p>The other methods in the class are there to define and implement the enumeration interfaces. Since the two interfaces have identical signatures for the <b>Skip()</b> and <b>Reset()</b> methods, they share a single implementation in the class. This is fine in this particular case because the class will only ever support one enumeration interface and, therefore, only one enumerated type: either <b>VARIANT</b> or <b>IFileEntry</b>.</p><p>The <b>Next()</b> methods are logically identical, in that they enumerate the entries in the search represented by the <b>hSrch</b> field of the <b>m_info </b>member. The only difference is that one converts to <b>IFileEntry</b>, in the form of a <b>FileEntry</b> instance, whereas the other takes the further step of wrapping that up in a <b>VARIANT</b>. <b></p><p>Clone()</b> is not supported for either interface and returns <b>E_NOTIMPL</b>. Since recls is single pass, there's no guaranteed way to <b>Clone()</b> an enumerator; the rationale for this was discussed in the first installment of the series. <b></p><p>Skip()</b> is implemented by simply calling <b>Recls_GetNext()</b> the requisite number of times. The remaining method, <b>Reset()</b>, is the most interesting of the four (or six). Because the recls API provides single pass enumeration, resetting is implemented as closing the current search and starting a new one. This is the other reason (along with multiple enumerations of the <b>SearchCollection</b>) that we need to record the search criteria. After a call to <b>Reset()</b>, the appropriate <b>Next()</b> method can be called to retrieve the entries of the newly initiated search.</p><h3>FileEntry</h3><p>The search entries are represented by the <b>FileEntry</b> class, whose class definition is mostly simple. It implements the <b>IFileEntry</b> interface in <A HREF="0405wilsonl4.htm" target="_BLANK">Listing 4</A>, and maintains a single <b>recls_info_t</b> member, which it passes to the recls API to retrieve the entry's characteristics.</p><p>The only notable aspects of this are the helper methods <b>GetStringProperty_()</b> and <b>GetTimeProperty_()</b>. </p><pre>HRESULT GetStringProperty_(    size_t (*)(recls_info_t, recls_char_t *, size_t)   , BSTR *pVal);HRESULT GetTimeProperty_( recls_time_t recls_fileinfo_t::*pm                        , DATE *pVal);</pre><p>They encapsulate all the boilerplate COM for </b><b>string</b> and <b>time </b>property retrieval and use pointers to recls API functions or structure members. Hence, all such <b>property</b> methods have extremely simple implementations, as in:</p><pre>STDMETHODIMP FileEntry::get_Path(BSTR *pVal){  return GetStringProperty_(Recls_GetPathProperty, pVal);}STDMETHODIMP FileEntry::get_CreationTime(DATE *pVal){  return GetTimeProperty_(&amp;recls_fileinfo_t::creationTime, pVal);}</pre><h3>DirectoryPartsCollection</h3><p>The only complexity in the <b>FileEntry</b> class involves the <b>get_DirectoryParts()</b> method (<A HREF="0405wilsonl6.htm" target="_BLANK">Listing 6</A>), which creates and returns a COM Collection in the form of the <b>DirectoryPartsCollection</b> class (<A HREF="0405wilsonl7.htm" target="_BLANK">Listing 7</A>). This derives from a parameterization of the ATL <b>ICollectionOnSTLImpl</b> template, which implements the semantics of a COM Collection using an STL container. A full discussion of this template is outside the scope of this article, but there are good sources on the matter, including some of the COM references I gave earlier.</p><p>The important point to note is that the STL container used by <b>ICollectionOnSTLImpl</b> is a parameterization of STLSoft's <b>proxy_sequence</b> template, which I mentioned in an earlier installment when I mapped recls to STL sequences. Here, it is used in combination with the <b>dirparts_proxy_traits</b> traits type to create a proxy sequence over the directory parts pointers for a search entry whose value type is <b>CComVariant</b>. In this way, you avoid any unnecessary copying of data from the entry inside the recls API until it is actually needed during an enumeration of the <b>DirectoryPartsCollection</b> by client code. This efficiency is bought for the almost negligible cost of ensuring that the <b>FileEntry</b> instance is kept "alive" for the duration of the <b>DirectoryPartsCollection</b> instance; this is simply and cheaply accomplished by taking a pointer to the owner in the <b>Init()</b> method (<A HREF="0405wilsonl7.htm" target="_BLANK">Listing 7</A>).</p><p>The implementation of <b>dirparts_proxy_traits::make_value()</b> revealed an interesting quirk (bug) within ATL. The original implementation was:</p><pre>CComVariant make_value(const recls_strptrs_t &amp;ptr){  return CComVariant( CComBSTR( ptr.end - ptr.begin                              , ptr.begin));}</pre><p>Unfortunately, there is a bug in </b><b>CComBSTR</b>, or rather, in the helper function that it calls &#151; <b>A2WBSTR()</b> &#151; which assumes that the string is null terminated even when we're passing in a length. The actual implementation (<A HREF="0405wilsonl8.htm" target="_BLANK">Listing 8</A>) instantiates the <b>VARIANT</b> directly, using the <b>SysAllocStringLen()</b> API function.</p><h3>Unicode versus ANSI</h3><p>As I mentioned in the previous installment, I don't hold with the (Unicode) Release MinDependency versus (Unicode) Release MinSize complexity, so I tend to edit projects to produce just two flavors of release &#151; ANSI and Unicode. In general, I like to go even further and ensure that there is a single version that works optimally on both Windows 9x/NT systems. Unfortunately, time was not my friend this month, so this has not been done. Hence, to use the COM mapping in its current guise, you should select between the ANSI and Unicode forms, and build and install the one suitable to your needs: If you only wish to use the recls COM mapping on NT family systems, you should use the Unicode version; otherwise, choose the ANSI version.</p><p>Later on, I will look at a way to obviate this hassle and just build a single library that will work optimally on all Win32 platforms.</p><h3>Next Steps</h3><p>I've included with this month's archive two test programs for the COM mapping. There's a Visual Basic 6 GUI client, similar to the C# GUI client from earlier in the series, and a C++ command-line client with similar behavior to the other command-line clients we've seen (for C, C++, D, Java, and STL test programs).</p><p>I haven't yet decided what language or technology to map recls to for next time, so it'll be a surprise to all of us &#151; probably either Perl or Python. There are a few other changes I'd like to make as well, such as providing a single binary version to work optimally on both Windows 9x/NT, and the API function name rationalization that I've been promising since the first column. Time will tell.</p><p>Feel free to write to me (or post a FAQ at http://recls.org/faq.html) and suggest other languages/technologies for which you'd like to see a recls mapping. recls has already been adopted into the D Standard Library (as the <b>std.recls</b> module), and I'm open to any similar possibilities with other languages. </p><hr><I><b>Matthew Wilson</b> is a software development consultant for Synesis Software, creator of the STLSoft libraries, and author of the forthcoming </i>Imperfect C++<i> (Addison-Wesley, 2004). He can be contacted at <a href="http://stlsoft.org/">http://stlsoft.org/</a>.</I><hr></body></html>