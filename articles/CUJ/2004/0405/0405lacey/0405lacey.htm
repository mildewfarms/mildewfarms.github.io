<html><head><title>May 04: </title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; C/C++ Users Journal--><p><i>C/C++ Users Journal </i> May 2004</p><h1>Web Services &amp;  Existing Server Applications</h2><h2>Extending the reach of existing systems</h2><h3>By Peter Lacey</h3><p>There is an argument to be made that using web services as a portable, Internet-enabled Remote Procedure Call mechanism is a na&iuml;ve approach. However, web- services toolkits are geared towards just that. Furthermore, as a mechanism for creating a universal API, web services have proven themselves. It is far better &#151; and easier &#151; to SOAP-enable existing server applications than it is to create C/C++ APIs (for Windows, Solaris, Linux, and so on), Java APIs, or .NET assemblies. </p><p>In this article, I'll examine how to add web services to existing server applications that already present a network interface to the outside world. In this case, the existing application is written in C, while the SOAP framework is Systinet's WASP (developed in C++). Admittedly, the application is only a single-threaded, socket-based server that accepts a connection and immediately returns the current date and time. Still, the underlying principles are the same as existing servers that are more useful and robust.</p><p>WASP is available as a free download from Systinet (<a href="http://www.systinet.com/">http://www.systinet.com/</a>), although a license is required for deployment on multiCPU hardware. The UNIX/Linux binaries are getting a bit stale (for instance, it's hard to find a compatible version of GCC), but Systinet does make the source code available for a fee. The source generally compiles on any UNIX-like OS using GCC or the OS's native compiler. The application I present here, for instance, was created on Mac OS X 10.3.2 using GCC 3.3, though OS X is not officially supported.</p><h3>Ground Rules</h3><p>The <b>main()</b> function in <A HREF="0405laceyl1.htm" target="_BLANK">Listing 1</A> (server.c) does little more than establish some signal handlers and call the <b>startSocketServer()</b> function, which never returns. The signal handlers catch <b>SIGINT</b> and <b>SIGTERM</b> and direct program flow to <b>cleanExit()</b>, which does nothing much at this point (though it should). The socket-handling code in SocketServer (<A HREF="0405laceyl2.htm" target="_BLANK">Listings 2</A> and <A HREF="0405laceyl3.htm" target="_BLANK">3</A>) is equally simple. Of interest is that the calls to <b>accept()</b> and <b>write()</b> are in an infinite loop, so that the server can handle one request after another, though only one at a time. The server's "business logic" consists of the call to <b>getCurrentDateTime()</b> in TimeUtils (<A HREF="0405laceyl4.htm" target="_BLANK">Listings 4</A> and <A HREF="0405laceyl5.htm" target="_BLANK">5</A>) and the formatting call that follows. This functionality is intentionally forced. The intent is that <b>getCurrentDateTime()</b> represents existing functionality that is useful to all clients, and that the call to <b>strftime()</b> represents functionality needed for a particular type of client. When the SOAP functionality is added, it reuses the <b>getCurrentDateTime()</b> function, but formats the results differently before returning to the caller. Only that particular <b>getCurrentDateTime()</b> uses the reentrant version of <b>localtime()</b>, acknowledging that this is a multithreaded application. The server can be built using the makefile in <A HREF="0405laceyl6.htm" target="_BLANK">Listing 6</A>. I won't bother writing a client because you can test this server using Telnet:</p><pre>$ ./server &amp;Starting socket server on port 6069$ telnet localhost 6069Trying 127.0.0.1...Connected to localhost.Escape character is '^]'.Feb 23, 2004 19:31:37Connection closed by foreign host.</pre><h3>Generating the  Source Code</h3><p>Systinet's WASP server for C++ assumes that all development begins with a WSDL document. A WASP utility, wsdlc, compiles the WSDL into C++ code &#151; skeletons, stubs, and data structures. The first step in the process is to create a WSDL document. While you can use whichever method you like, I elected to create a Java interface file and use Systinet's java2wsdl utility to create the WSDL document. Here's the interface I used, along with my use of java2wsdl.  </p><pre>public interface DateServer {   java.util.Date getCurrentDateTimeWS();}</pre><p>This file must be saved as DateServer.java. When converted to a WSDL document, the default is to name the base service the same as the class, </b><b>DateServer</b>, and to create an operation called <b>getCurrentDateTimeWS</b> (the <b>WS</b> suffix is arbitrary) that takes no inputs and returns an XML Schema <b>dateTime</b> type. Compile it like this:</p><pre>$ javac DateServer.java</pre><p>Then convert it to a WSDL document:</p><pre>$ java2wsdl   --class-mapping DateServer=http://localhost:6070/DateTimeService  --no-java-mapping-extension   DateServer</pre><p>The </b><b>--class-mapping</b> flag instructs WASP regarding which URL to use in the WSDL file's <b>&lt;service&gt;</b> section. I specified port 6070 because that is WASP C++'s default. The <b>--no-java-mapping-extension</b> keeps WASP from annotating the WSDL document with hints meaningful to Systinet's Java SOAP stack. <b>DateServer</b> is, of course, the compiled Java interface. By default the WSDL file is called "Definitions.wsdl." </p><p>With the WSDL file in hand, you can generate the needed source.</p><pre>$ wsdlc Definitions.wsdl DateTime</pre><p></b><b>wsdlc</b> is in the WASPC_HOME/bin directory, taking as arguments a minimum of the WSDL filename and a string to use when naming the output files. In this case, the resulting files are the client stubs DateTime.cpp and DateTime.h, server skeletons DateTimeImpl.cpp and DateTimeImple.h, and shared data DateTimeStructs.cpp and DateTimeStructs.h (available at <a href="http://www.cuj.com/code/">http://www.cuj.com/code/</a>).</p><h3>Creating the Service</h3><p>To create the service, you need only write an ordinary C++ class file that extends the service declared in DateTimeImpl.h, called <b>DateServerImpl</b> (remember, the WSDL file says the service is called "DateServer") that has a single public virtual method <b>getCurrentDateTimeWS()</b>. <A HREF="0405laceyl7.htm" target="_BLANK">Listings 7</A> and <A HREF="0405laceyl8.htm" target="_BLANK">8</A> are the header and class definition.</p><p>While straightforward, the class is notable in a number of ways. First, there's nothing very "SOAPy" about it. All of the XML serialization/deserialization, transport connectivity, and SOAP processing are taken care of by WASP. Second, the use of a pointer to a <b>WASP_DateTime</b> type as the return value is one of many WASP types that are used when serializing between XML and C++. Finally, the call to <b>getCurrentDateTime()</b> represents the existing business logic. The empty constructor for <b>WASP_DateTime()</b> defaults to the current date and time.</p><h3>Creating the Server</h3><p>With the service complete, you can create the server itself. Typically, a WASP server behaves much like this socket server &#151; once started it blocks forever while servicing requests. Your challenge is to get the WASP server and the socket server to coexist in the same executable.</p><p>Fortunately, Systinet has made available a nonblocking version of its server. Using it requires only a few simple changes to the typical way of doing things: </p><ul>  <li>The <b>serverInitialize()</b> call has to be changed to just <b>initialize()</b>.  <li>The <b>serverStart()</b> call has to be broken into two separate calls, one to load the configuration file and one to start the server.  <li><b>serverTerminate()</b> has to be essentially reimplemented manually.</ul>  <p><A HREF="0405laceyl9.htm" target="_BLANK">Listings 9</A> and <A HREF="0405laceyl10.htm" target="_BLANK">10</A> present the SOAP server. The function <b>startSOAPServer()</b> is called from <b>main()</b>. The code includes three mandatory WASP header files, and the header file for the service just created. To register the service with WASP, it uses the <b>WASP_FACTORY_DEFINE</b> macro to create the definitions of the service as a class factory. In the body of <b>startSOAPServer()</b>, it populates an array of these factories with the help of a few more macros. In this case, there is just one service, but as more services are created, they can simply be added to this list.  <p>Next, WASP initializes all of the WASP infrastructure with the <b>initialize()</b> call, and registers the array of service factories with what's called the "WASP super-factory" via the <b>registerFactory()</b> call. Finally, <b>load()</b> is called to retrieve the (as yet unmentioned) configuration file, and <b>start()</b> is called to begin accepting requests.  <h3>Mixing C and C++</h3><p>The <b>load()</b> and <b>start()</b> functions are wrapped in exception-handling code. You can treat this as boilerplate, but witness how a C++ exception is caught and changed into a simple return value for the use of the C code that calls the exception. I have also implemented a <b>stopSOAPServer()</b> function. Typically, WASP takes care of shutting down cleanly, but in nonblocking mode, this is your responsibility.  </p><p>Also, because I am linking C and C++ code, the function declarations are wrapped up with a check for whether a C++ preprocessor is working on it; if so, a call to <b>extern "C"</b> is inserted to keep name mangling from occurring. This same functionality had to be added to TimeUtils.h so that it could be called from the C-based socket code and C++ SOAP code (<A HREF="0405laceyl11.htm" target="_BLANK">Listing 11</A>).</p><h3>Configuring the Server</h3><p>The configuration file that <b>load()</b> reads in can be used to configure many aspects of a server. Generally, the defaults are acceptable. However, for each service you create, you need to specify in the configuration file which URL is mapped to which service, which class implements the service, and the WSDL code to return when asked.</p><p>The configuration file (see <A HREF="0405laceyl12.htm" target="_BLANK">Listing 12</A>) initially contains some (boilerplate) namespace declarations and server configuration elements. These are followed by the service endpoint configuration. Of the components in the <b>&lt;serviceEndpoint&gt;</b> attribute list, the important ones are the <b>wsdl</b> and <b>url</b> attributes. The <b>wsdl</b> attribute describes the path to the service's WSDL document relative to the location of the configuration file, and the <b>url</b> attribute specifies the URL of the service relative to the root of the HTTP server. The <b>wsdl</b> attribute is preceded by the <b>cppa</b> namespace, not the <b>sep</b> namespace.</p><p>The <b>&lt;cppa:instance&gt;</b> tag names this service endpoint configuration so that it can later be associated with a service instance, <b>&lt;svci:serviceInstance&gt;</b>. The class attribute is the name of the real C++ service class; in this case, <b>DateTimeService</b>.  </p><h3>Updating Client and Server</h3><p>With the SOAP server in place, you can update the <b>main()</b> function to start it up (<A HREF="0405laceyl13.htm" target="_BLANK">Listing 13</A>). I also create a client to exercise the SOAP server (<A HREF="0405laceyl14.htm" target="_BLANK">Listing 14</A>). The client is straightforward even if you aren't familiar with WASP. After the SOAP infrastructure is initialized via the <b>clientstart()</b> call, the client instantiates a local proxy of the remote <b>DateServer</b>. It then sets up a pointer to a <b>WASP_DateTime</b> to hold the return value of the operation. Finally, it calls the remote operation just as if it were local to the client. Of course, under the covers, WASP is creating SOAP messages, transporting them back and forth, and serializing and deserializing the data.</p><p>A peculiarity of WASP is that string data is kept in UTF format. To get a <b>char *</b> reference to it, you must call the <b>WASP_String transcode()</b> method. <b>Transcode()</b> allocates a buffer that you must remove. Of course, you must also dispose of the <b>WASP_DateTime</b> when you're done with it, too.</p><p>You can build the entire system with the makefile (available at <a href="http://www.cuj.com/code/">http://www.cuj.com/code/</a>). The original C code is still using GCC as the compiler, but the WASP code uses g++. The server now uses g++ as the linker, not GCC. Finally, the <b>dylib</b> extension on the WASP libraries is the way OS X names shared object libraries.</p><p>Running the server and the client results in the following:</p><pre>$ ./server &amp;[1] 302Starting WASP Server on port 6070Starting socket server on port 6069$ telnet localhost 6069Trying 127.0.0.1...Connected to localhost.Escape character is '^]'.Feb 25, 2004 19:13:39Connection closed by foreign host.$ ./clientThe current date &amp; time is   2004-02-25T19:13:43-05:00$ kill 302Shutting down ...SOAP Server shutdown</pre><h3>Conclusion</h3><p>If you are an enterprise developer with existing servers written in C or C++, you can extend the reach of those servers by adding web services and doing a little code refactoring. This technique should be equally compelling if you are an ISV, since you can now set aside all of the client-side APIs you have created and offer a single server-side interface to your customers. </b></p><hr><I><b>Peter Lacey</b> is an independent contractor doing web-services development for financial organizations. He has held engineering positions at Systinet, Cisco Systems, and Netscape Communications. Peter can be contacted at <a href="mailto:placey@wanderingbarque.com">placey@wanderingbarque.com</a>.</I><hr></body></html>