<html><head><title>May 04: </title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; C/C++ Users Journal--><p><i>C/C++ Users Journal </i> 0 2004</p><h1>XMLParam: An XML-Based Parameter and Setting I/O Framework</h1><h2>Distributing and aggregating I/O among objects is the key</h2><h3>By Adi Shavit and Arnaud Brejeon</h3><P><a name="rs1"><a href="0405shavits1.htm">Automatic Dialog Generation  For User Interaction</a><P><a name="rs2"><a href="0405shavits2.htm">Parsing the XML Stream</a><hr><p>Reading and writing program parameters and settings is a common task in many applications. However, despite being so pervasive, this task is often implemented in an ad-hoc manner using a combination of formats and styles. There are always more important things to do, and besides, you can never know the final file format, so why put in too much effort now, right? Even when these files would need to be changed by users, typical solutions use the (Windows-like) flat .INI file format with <b>field=value</b> lines. Though seemingly much easier to parse, such solutions suffer from several serious drawbacks:</p><ul>  <li>They are hard to maintain, especially across application versions and during development cycles.   <li>They can be difficult to change and/or update. Field name collisions may create unseen havoc when many parameters for different parts of the program exist in the same file.  <li>They require specialized handling of type conversion (<b>itoa</b>, <b>atoi</b>, and so on) and may have to be changed to account for new types. We have seen implementations that use huge tables of strings, data types, and function pointers.  <li>They require a centrally managed I/O facility to pass the values to/from the variables/file. This central facility may need to know the field names for the whole program. Any change to various modules in the program (such as adding a new parameter) also requires changing this central I/O facility.</ul>  <p>Additionally, allowing application users to change these setting values at runtime requires customized dialog boxes that must be changed with every change and/or addition of new parameters (see the sidebar entitled, "Automatic Dialog Generation for User Interaction").  <p>Having dealt with all these issues over and over, we wrote a general library to help overcome problems such as these. The library we propose is stable and we have been using it for over three years. (Previous versions were posted on the Web [1] and used and reviewed by CodeProject members.) This library, which we call XMLParam, is a portable, ANSI C++-compatible, STL-based class library that uses simple XML documents for the following:<ul>  <li>Writing and reading settings of any class and/or module in a decentralized manner (&agrave; la <b>operator&lt;&lt;/&gt;&gt;</b> style). Each object can do its own I/O. This allows easy aggregation of writing/reading. Objects can ask any of their member objects to write themselves.  <li>Automatic type conversions using templates and <b>operator &lt;&lt;/&gt;&gt;</b>, thus allowing new types to be read/written without any changes to the external code. This also allows updating new values directly into the relevant member variables.   <li>A hierarchical file structure, natural for XML, allowing multiple modules to save the data to the same file while keeping the data properly separated and the file readable (and easily editable).   <li>The hierarchical structure also allows multiple (unlimited) versions in the same file.   <li>Since XML is a text file, it can be viewed (and changed) conveniently using any text editor. Other popular tools, such as Internet Explorer, display the data nicely.   <li>Many other tools and languages can read and parse these files if necessary.  <li>Support for both absolute and relative paths to hide the overall file structure and paths from the internal modules.   <li>Built-in support for default values. This is useful when files are missing, old, outdated, or from previous versions.   <li>Tree and subtree comparisons for change detection.</ul>  <p>But the best thing is that most of the work is done by the library. The only thing left to do is to specify the path/value names and actual values. In fact, users only have to implement two functions (<b>read</b> and <b>write</b>) to benefit from all of these features.  <p>Since the goal was not to parse an XML file, but to give an easy way to read and write the data, our code is based on David Hubbard's STL-based XML parser [2]. </ul><h3>Getting Down to Business</h3><p>Assume you have an object in an application that shows some colored text on the screen (a demo project and full resources that implement it are available at <a href="http://www.cuj.com/code/">http://www.cuj.com/code/</a>). The parameters of your application will be the text string itself (one <b>std::string</b>), and the color (three <b>int</b> RGB values). You want to be able to save those parameters to a file and reload them later. <A HREF="0405shavite1.htm" target="_BLANK">Example 1</A> is a sample XML file containing these values.</p><p>Assuming we have member variables, as in <A HREF="0405shavite2.htm" target="_BLANK">Example 2</A>(a), this code snippet shows the basics of how to write this data:</p><pre>// ParamIO outXml; // received as an argument outXml.write("PARAMS:TEXT", _text); outXml.write("PARAMS:COLOR:RED", _red, "the red part");  outXml.write("PARAMS:COLOR:GREEN", _green);outXml.write("PARAMS:COLOR:BLUE", _blue);</pre><p>In </b><b>outXML.write()</b>, the first argument is the XML path inside the file and the second argument is the member variable whose value we'd like to write. The third (optional) argument lets you specify a comment to improve the readability of the created file. <b>ParamIO::write()</b> is a member template function of <b>ParamIO</b>, which is instantiated by the type of the second argument; in this case, <b>std::string</b> and <b>int</b>. This lets <b>ParamIO</b> use each member's streaming operator internally.</p><p>When the values belong to different XML paths of the tree, the actual writing order is not important. Within the same XML path, the order is the same as in the source code. The tag path names are case sensitive.</p><p>We'll now add two new members to the <b>ColoredText</b> class &#151; the font name and the font size; see <A HREF="0405shavite2.htm" target="_BLANK">Example 2</A>(b). The code to read the previous XML snippet, giving default values for (potentially) missing parameters is as follows:</p><pre>//ParamIO inXml; received as an argumentinXml.read("PARAMS:TEXT", _text, string("Hello world"));inXml.read("PARAMS:COLOR:RED",   _red,   0);inXml.read("PARAMS:COLOR:GREEN", _green, 0);inXml.read("PARAMS:COLOR:BLUE",  _blue,  0);inXml.read("PARAMS:FONT:NAME", _fontName, string("Arial"));_fontSize = 12;inXml.read("PARAMS:FONT:SIZE", _fontSize, _fontSize);</pre><p>Reading the XML values into our members is as straightforward as writing them. </b><b>ParamIO::read()</b> is also a template member function, and it, too, is instantiated by the type of the second argument. <b>ParamIO::read()</b> has a third argument &#151; the default value to be used in case the requested parameter does not appear in the XML tree. When reading the XML in <A HREF="0405shavite1.htm" target="_BLANK">Example 1</A>, since it does not contain the font info, the default values will be used. </p><p>This example shows two possible forms of using the default values:</p><ul>  <li>The default font will be Arial; this is explicitly stated.   <li>The default font size will be whatever value <b>_fontSize</b> was before (12 in this example). This assumes prior initialization of <b>_fontSize</b>. This second form is useful when you do not want to have multiple or duplicate default initialization values in the code. For example, we could initialize all the member values in the class constructor's initialization list and use the second form to keep the original default (or previous) value.</ul><h3>ParamIO Who?</h3><p>By now, you may be wondering where this <b>ParamIO</b> comes from, since it is not declared locally in the aforementioned samples. Also, we have not shown where to name the file into which the data will be saved. All the internal workings of the class are inside the XMLParam library. To make an object <b>ParamIO</b> aware, publicly derive it from the abstract utility class <b>XMLBase</b>. This class (see <A HREF="0405shavitl1.htm" target="_BLANK">Listing 1</A>) has two pure virtual methods &#151; <b>writeXML()</b> and <b>readXML()</b> &#151; which you will override and implement as previously described. The other two nonvirtual functions &#151; <b>writeXMLFile()</b> and <b>readXMLFile()</b> &#151; contain the machinery to write/read the XML streams to files (see the sidebar "Parsing the XML Stream" for more details). These nonvirtual functions call the <b>XMLBase</b> virtual functions <b>read</b> and <b>write</b>. Since your class is publicly derived from <b>XMLBase</b>, you must implement the virtual methods <b>writeXML()</b> and <b>readXML()</b>; otherwise, the code will not compile. These methods will be automatically called at runtime by <b>writeXMLFile()</b> and <b>readXMLFile()</b>, respectively, due to the virtual method mechanism. This is the same idea as [4]. <A HREF="0405shavitl2.htm" target="_BLANK">Listings 2</A> and <A HREF="0405shavitl3.htm" target="_BLANK">3</A> show the complete implementation of the <b>ColoredText</b> class.</p><p>The optional absolute path argument lets you easily aggregate the file structure with each object seeing only its own subtree while the complete file view is hidden from it. </p><h3>More Advanced Uses</h3><p>The class <b>MultiLineText</b> shows several interesting and useful uses of the library, namely aggregation and dynamic vector/array I/O. <b>MultiLineText</b> holds a vector of <b>ColoredText</b> objects (<A HREF="0405shavitl4.htm" target="_BLANK">Listing 4</A>). When performing XML I/O, it first reads/writes the number of rows in the text, then delegates the actual reading/writing to its elements. <A HREF="0405shavitl5.htm" target="_BLANK">Listing 5</A> shows how the XML tree elements are created at runtime according to the runtime size of the vector. The actual <b>ColoredText</b> data is written by each entry without any explicit access by the <b>MultiLineText</b> object.</p><p><A HREF="0405shavite3.htm" target="_BLANK">Example 3</A> shows how two <b>ParamIO</b> XML trees can be compared to detect changes. <b>ParamIO</b> supports operators <b>==</b>, <b>!=</b> for full tree comparisons, and also the <b>compare()</b> method, which allows comparing a subtree with the same path of both trees. <A HREF="0405shavite3.htm" target="_BLANK">Example 3</A> also demonstrates how to work directly with <b>ParamIO</b> without using the <b>XMLBase</b> class API.</p><p>If XML text files are too big or verbose for your taste, simple extensions can add compression and decompression and/or encryption and decryption layers between the file I/O and the XML parsing. In fact, do both if it suits you. The code also contains an implementation that writes/reads zipped XML files. This implementation uses XZip [5] to read/write standard ZIP compressed files. A similar approach can be used to provide encrypted XML files. </p><p>Since the <b>ParamIO</b> object can interact directly with standard <b>iostreams</b> (see ZippedXML.cpp), any pre- or postprocessing can be done on these streams after they are written/read. You can use your own <b>iostream</b>-processing modules to suit your own needs, the possibilities are endless; for example, encryption, checksums and error correction data, network I/O, pipes and so on. </p><h3>Conclusion</h3><p>Our framework can be implemented using many other XML subcomponents and syntaxes. The interesting idea here is the pattern &#151; distributing/aggregating the I/O among the objects themselves while keeping the separated hierarchical ordering. We've used this library on Windows, Linux, and Solaris, and it can be easily ported to any platform that supports Standard C++ and the STL. </p><h3>References</h3><p>[1]	"Read and Write Application Parameters in XML," Arnaud Brejeon, <a href="http://www.codeproject.com/soap/paramio.asp/">http://www.codeproject.com/soap/paramio.asp/</a>.</p><p>[2]	"A Simple STL Based XML Parser," David Hubbard, <a href="http://www.codeproject.com/cpp/stlxmlparser.asp/">http://www.codeproject.com/cpp/stlxmlparser.asp/</a>. We would really like to thank David for his parser; he did a tremendous job. Moreover, it saved us a lot of time, even if a few modifications to his original code were made to fulfill our goals. </p><p>[3]	"Easy Navigation Through an Editable List View," Lee Nowotny, <a href="http://www.codeproject.com/listctrl/listeditor.asp/">http://www.codeproject.com/listctrl/listeditor.asp/</a>.</p><p>[4]	This is similar to the idiom of having a nonvirtual <b>operator &gt;&gt;()</b> in a base class of a hierarchy that calls a virtual <b>print()</b> method implemented by its derived classes.</p><p>[5]	"XZip and XUnzip: Add zip and/or unzip to your app with no extra .lib or .dll," Hans Dietrich, <a href="http://www.codeproject.com/cpp/xzipunzip.asp/">http://www.codeproject.com/cpp/xzipunzip.asp/</a>. </p><hr><I><b>Adi Shavit</b> develops real-time image and video analysis applications for Gentech and heads Gentech's R&amp;D Branch. He can be reached at <a href="mailto:adish@gentech.co.il">adish@gentech.co.il</a>. <b>Arnaud Brejeon</b> works in the fields of image processing and mobile phones. He can be reached at <a href="mailto:arnaud.brejeon@laposte.net">arnaud.brejeon@laposte.net</a>.</I><hr></body></html>