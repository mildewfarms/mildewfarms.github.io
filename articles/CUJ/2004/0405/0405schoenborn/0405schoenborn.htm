<html><head><title>May 04: </title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; C/C++ Users Journal--><p><i>C/C++ Users Journal </i> May 2004</p><h1>Strict Ownership, STL Containers, &amp; the NoPtr Library</h1><h2>Here's how it works</h2><h3>By Oliver Schoenborn</h3><p>In the article "Strict Ownership in STL Containers: The NoPtr Library" (<i>CUJ</i>, March 2004), I discussed the concept of ownership of dynamically allocated objects in C++. In particular, I stressed how important it is for you to establish a clear ownership policy for each dynamically allocated object (DAO) you create. </p><p>In the process, I distinguished two types of ownership &#151; strict and shared &#151; and suggested that strict ownership leads to clearer resource lifetime, which greatly reduces the likelihood of cyclical dependencies. This led to the conclusion that it is better to use strict ownership unless the design really requires sharing resources (see Copy-On-Write [1] and the Flyweight pattern [2]). I then presented the NoPtr library [3] classes that support strict ownership, before wrapping up with an example of how the main class &#151; called <b>DynObj&lt;T&gt;</b> for a DAO of type <b>T</b> &#151; could be used even inside an STL container. Design-wise, this was a major challenge since strict ownership is at odds with STL's requirements for copy constructibility and assignability.</p><p>In this article, I discuss how <b>DynObj&lt;T&gt;</b> was designed to allow strict ownership of a DAO within value-based containers like the STL containers. </p><h3>The Problem</h3><p>A bare-bones <b>DynObj&lt;T&gt;</b> would provide strict ownership of a DAO of type <b>T</b> and nothing more (such as support for conversions, polymorphism, and so on, all included in the actual NoPtr library). The header would be something like <A HREF="0405schoenbornl1.htm" target="_BLANK">Listing 1</A>. However, the problem is that in <A HREF="0405schoenbornl1.htm" target="_BLANK">Listing 1</A>, <b>DynObj&lt;T&gt;</b> does not satisfy the copy-constructibility and assignability (CCA) requirements that any element type of an STL container must satisfy [4]. If you consider making this <b>DynObj&lt;T&gt;</b> CCA-compliant, and you want it to have reference semantics (in fact, that's often the whole point of using a container of DAOs), then you are forced to use shallow copying of the <b>_dao</b> data member. But shallow copying implies shared ownership, which violates the class invariant of <b>DynObj&lt;T&gt;</b>.</p><p>If <b>DynObj&lt;T&gt;</b> is to be stored in a container, something must be changed. For instance, you might want changes that: </p><ul>  <li>Pose as few demands on users (you) as possible.  <li>Do not affect the performance when <b>DynObj&lt;T&gt;</b> is not inside a container.  <li>Preserve strict ownership semantics.</ul>  <p>There is a way around this problem if you make two assumptions about DAOs stored in STL containers:<ul>  <li>Assumption #1. Copy construction and assignment in STL containers are only transient phenomena. They are used while inserting an element into a container or while swapping two elements of a container. For instance, once the element is inside the container or once the swap is over, only one copy exists.   <li>Assumption #2. While more than one copy exists, none of the methods or operators of the element's copies get called, other than copy construction or assignment (if at all).</ul>  <p>Assumption #1 is concerned with temporaries. Any temporaries created are needed only for the operation, so once the operation is over, a good implementation gets rid of them. Assumption #2 is concerned with the nature of containers &#151; they just contain, they don't affect the state of what they contain. Any reasonably sensible implementation of STL containers could be expected to satisfy both assumptions without problem.  <p>How does this help? The class invariant for <b>DynObj&lt;T&gt;</b> is that, at most, one <b>DynObj&lt;T&gt;</b> has a given DAO of type <b>T</b> at any given time (strict ownership). An invariant just gives a guarantee that is true by the end of construction, before entry to member functions and after returning from them. These two assumptions allow the <b>DynObj&lt;T&gt;</b> class invariant to be upheld before and after insertion into a container, or swapping two <b>DynObj</b> in the container(s), while relaxing it during certain operations.  <p>With these assumptions, it is sufficient to add to <b>DynObj</b> the following capabilities:<ul>  <li>Copy-constructable and assignable, but only when inside a container.   <li>Tracks how many transient shared copies exist so only the last one destroyed (if at all) destroys the DAO.   <li>Verifies Assumption #2 via assertions.</ul>  <p>How can copy-construction and assignment be allowed only when the <b>DynObj</b> is being inserted or moved around within or between two containers? Clearly, <b>DynObj&lt;T&gt;</b> must know which context it is used in &#151; if it is "free" (that is, not in an STL container). When free, it must disallow CCA. On the other hand, when used in a value-based container, then it must add the aforementioned three capabilities that, with the two starting assumptions, maintain the class invariant.  <p>Unfortunately, the context of use of an object can't be added after the fact, not while remaining portable, anyway. Therefore, it's up to you to tell the compiler when to allow CCA. Furthermore, the context information changes the class, which implies that a second class definition is needed. Yet, I don't want the coder to think in terms of a different class for <b>DynObj</b> inside a container. To keep a handle on maintainability, I use the technique of adding an extra template parameter &#151; the <b>Context</b> &#151; with a default value; see <A HREF="0405schoenbornl2.htm" target="_BLANK">Listing 2</A>. This lets you declare "free" instances of <b>DynObj&lt;T&gt;</b> as simply <b>DynObj&lt;T&gt;</b>, but to declare instances inside containers as <b>DynObj&lt;T, InValueContainer&gt;</b> or <b>DynObj&lt;T&gt;::InValueContainer</b>. With the latter notation, you may find it easier to think of the element type of the container as a <b>DynObj&lt;T&gt;</b> with the context explicitly specified.  <p>The <b>Context</b> is inherited privately (instead of being a data member) to take advantage of the empty base optimization that <b>FreeDefaultContext</b> allows. This means there is no cost to the "feature" if it is not used. The context class <b>InValueContainer</b> will be substantially more complex than <b>FreeDefaultContext</b> because it must keep track of the transient shared ownership, and provide a <b>soleOwner()</b> that returns <b>true</b> only if there is one owner left.<h3>Implementing InValueContainer</h3><p>There are many ways for <b>InValueContainer</b> to keep track of ownership. The most straightforward is probably reference counting. A rough implementation of the <b>InValueContainer</b> context might be like <A HREF="0405schoenbornl3.htm" target="_BLANK">Listing 3</A>. Also, it is easy for <b>DynObj</b> to test Assumption #2 by using <b>assert(soleOwner())</b> in every one of its methods.</p><p>This implementation leads to well-defined compile- and runtime behavior. When you use <b>DynObj&lt;T&gt;</b> in the "free" context, attempting to instantiate it by copy construction, or attempting to assign to it, causes a compile error about private members of <b>FreeDefaultContext</b> being inaccessible. For example, declaring <b>std::list&lt;DynObj&lt;T&gt; &gt; </b>and inserting <b>DynObj&lt;T&gt;</b> into it causes such a compile-time error. Furthermore, any interaction between <b>DynObj&lt;T&gt;</b>s requires explicit transfer of ownership (directly or, via <b>DynTmp&lt;T&gt;</b>, indirectly) via a member function call. Together these ensure that the strict ownership invariant for <b>DynObj&lt;T&gt;</b> is maintained in the free context.</p><p>On the other hand, when the <b>std::list</b> is declared with element type <b>DynObj&lt;T&gt;::InValueContainer</b> (see <A HREF="0405schoenbornl5.htm" target="_BLANK">Listing 5</A> in [3]), inserting items into the container, reordering the list, or moving elements from one list to another, works as expected. The <b>Context</b> member of the <b>DynObj </b>elements take care of the shared transients during those operations and, via <b>Context::soleOwner()</b>, let <b>DynObj </b>methods assert Assumption #2 and determine if the DAO owned should be deleted upon destruction.</p><p>There are a few caveats to be aware of. First, the class invariant is enforceable only if you use the right context at the right time. Given the simple definition of the context here (either free or in a value-based container), getting this wrong is unlikely. Actually, declaring an STL container with a <b>DynObj&lt;T&gt;</b> element cannot lead to any problem, just possibly some compiler errors depending on what is done to the container. Therefore, the danger is really with instantiating <b>DynObj&lt;T&gt;::InValueContainer</b>, which should never be done since the context is then wrong. This mistake is made less likely by making the context name verbose so it stands out in the code, and so it is extra work to write, using the lazy-programmer principle (the C++ <b>*_cast</b> functions, for example).</p><p>Another caveat to watch for is a shallow copy of a container. Indeed, once you tell <b>DynObj</b> that it is going to be used in a value-based container, it is possible to copy it, so the container can be copied. Since this is not a transient operation and involves a shallow copy, the invariant is violated, and as soon as you try to do anything with any of the elements that were copied, the assertion that verifies Assumption #2 causes the bug to be clearly visible.</p><p>There is a pseudocaveat &#151; the possibility to assign <b>DynObj&lt;T&gt;</b> to an element of the container. For example:</p><pre>std::list&lt; DynObj&lt;T&gt;::InValueContainer &gt; list;list.push_back(dynTmp(0));      // null DynObjDynObj&lt;T&gt; otherT(new T);list.first() = otherT;</pre><p>The last line leads to a compile error because the CCA is allowed only for the same context. However, this does not prevent interactions between free </b><b>DynObj&lt;T&gt;</b> and <b>DynObj&lt;T&gt;</b> inside a container. See <A HREF="0405schoenbornl4.htm" target="_BLANK">Listing 4</A>, where a free <b>DynObj</b> is giving up ownership of two DAOs to a <b>DynObj</b> inside the container.</p><p>One important caveat of this solution is that many checks are only possible at runtime in a debug build via <b>assert()</b>, though in principle they are available at compile time. For instance, in swapping two elements of a container the standard way (<b>tmp=a</b>, <b>a=b</b>, <b>b=tmp</b>), you know at compile time that by the end, the ownership is not shared because <b>tmp</b> is destroyed, but I haven't found a way of encoding this.</p><h3>Other InValueContainer Implementations </h3><p>Again, there are many possible implementations for the <b>InValueContainer</b> context. Reference counting is foolproof, but slow due to the call to <b>new</b> that must be done for every <b>DynObj&lt;T&gt;</b> in the container. A much faster implementation is to replace the reference count with a pointer to another <b>Context</b>; see <A HREF="0405schoenbornl5.htm" target="_BLANK">Listing 5</A>. This works if there is at most one transient owner created at any given time. Whether this is the case depends on the STL implementation and the compiler, but again if it happens not to be true, you know by a failed assertion on the line commented by "line 1" in <A HREF="0405schoenbornl5.htm" target="_BLANK">Listing 5</A>. It is sufficient surprisingly often, at least with the two STL implementations I have tried.</p><p>Other alternative implementations are possible; for instance, a chain topology that has a slightly larger memory footprint than the reference count method, but is faster, again due to the lack of dynamic memory allocation for the reference count. This technique requires only two pointers to be stored in the context class.</p><p>The typical scenario would therefore be to use the <b>InValueContainer</b> context when in an STL container, but use one of the optimized ones available in the NoPtr library if you are certain the speed gain is worth it and to test it in a debug mode. The various implementations never need to interact directly so they can be freely mixed within a program.</p><p>It is interesting to note that the performance cost of using NoPtr rather than raw pointers is on the order of 10 percent. Since this is larger than the difference in performance between compilers and platforms, it is for all practical purposes negligible. One exception, however, is sorting a container of <b>DynObj&lt;T&gt;</b>, which takes about nine times what it would to sort the same container of raw pointers, the same as for <b>boost::shared_ptr</b>. This factor goes down to seven or eight when you use one of the optimized implementations of the <b>InValueContainer</b> context class. Not surprisingly, strict ownership, in the form of <b>DynObj&lt;T&gt;</b> and <b>DynTmp&lt;T&gt;</b>, is up to twice as fast as ownership as implemented by <b>boost::shared_ptr&lt;T&gt;</b>. For actual numbers, refer to the performance section at the NoPtr web site [5].</p><h3>Conclusion</h3><p>If you need strict ownership of dynamically allocated objects, usable even in STL containers, the NoPtr library provides three classes to support this:</p><ul>  <li><b>DynObj&lt;T&gt;</b>: Strict ownership and access of a DAO as an object.  <li><b>DynTmp&lt;T&gt;</b>: Pure strict ownership of a DAO (see [OS1]).  <li><b>RRef&lt;T&gt;</b>: Pure access to a DAO (see [OS1]).</ul><p>NoPtr makes this possible by defining a <b>Context</b> that you specify only when you declare your container of <b>DynObj&lt;T&gt;</b> objects. This parameter is, in fact, a class that prevents copy construction and assignment by default, but allows it inside STL containers, and only under the two assumptions mentioned in the text. </p><p>This strict ownership library is on the order of 10 percent slower than if the smart references are replaced by raw pointers, a small price to pay for all the benefits of clear strict ownership semantics, automated lifetime control, and automated verification of existence of a DAO before access.</p><p>Compared to shared ownership, strict ownership requires more attention to the owner; i.e., you still have to worry about existence upon access, but the NoPtr classes automate this verification in a debug build. Also, it is equal or up to twice as fast, depending on the operation, as <b>boost::shared_ptr</b>, and greatly diminishes the likelihood of circular dependencies.</p><p>That said, the choice between raw pointers, shared ownership smart pointers, and NoPtr should be guided primarily by safety and design: Do you need the safety of automated lifetime management of DAOs? If so, via strict or shared ownership? If you don't care or don't need dynamically created resources to be shared, use strict ownership, unless you need capabilities of other smart pointers that are not currently available in NoPtr.</p><p>There are many things that could be improved, including adding multithread safety, supporting customized destruction, providing some smart-pointer equivalents to the smart references that NoPtr provides, and making the runtime checks into compile-time checks. Some of these will be added as the need arises.</p><h3>Acknowledgments</h3><p>Thanks to Sam Saariste and Terje Sletteb&ouml;. Any mistakes are my own.</p><h3>References</h3><p>[1]	See C++PL and C++FAQ, sections 28, 28.7, and 28.8 (<a href="http://www.faqs.org/faqs/C++-faq/part1/">http://www.faqs.org/faqs/C++-faq/part1/</a>).</p><p>[2]	Gamma, Erich, et al. <i>Design Patterns, Elements of Reusable Object-Oriented Software</i>, Addison-Wesley, 1995.</p><p>[3]	<a href="http://noptrlib.sourceforge.net/">http://noptrlib.sourceforge.net/</a>.</p><p>[4]	ISO/IEC 14882:1998(E), "Programming Languages &#151; C++."</p><p>[5]	<a href="http://noptrlib.sourceforge.net/page_performance.html">http://noptrlib.sourceforge.net/page_performance.html</a>. </p><hr><I><b>Oliver Schoenborn</b> is a researcher for the National Research Council of Canada doing R&amp;D in simulation systems for engineering applications in virtual reality. He can be contacted at <a href="mailto:oliver.schoenborn@nrc.gc.ca">oliver.schoenborn@nrc.gc.ca</a>.</I><hr></body></html>