<html><head><title>May 04: Much Ado About Nothing:  A (True) Null Pointer Value for C++</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; C/C++ Users Journal--><p><i>C/C++ Users Journal </i> May 2004</p><h1>Much Ado About Nothing:  A (True) Null Pointer Value for C++</h1><h2>What is the type of 0? In C and C++, there is more than  one answer. And that's a problem because it means that  when you want to point to nothing, sometimes plain old  0 and NULL just won't do...</h2><h3>By Herb Sutter</h3><p>This column is about (pointing to) nothing. More seriously, it's about why we need a better null value for pointers than C [1] or C++ [2] currently provide.</p><p>Last fall, Bjarne Stroustrup and I proposed the <b>nullptr</b> keyword and feature to the ISO C++ Standards committee as a feature we ought to include in C++0x, the next version of the C++ Standard (see my trip report in last month's issue [3]). This proposal was based on work we had already done as part of C++/CLI, the C++ extensions for ISO CLI (the standardized subset of .NET) [4]. The C++ evolution working group liked the initial proposal, asked for a few changes, and we updated our proposal for the Spring 2004 C++ Standards meeting; this article is based on the updated proposal [5]. (Thanks to the editorial lead time of magazines, I'm writing this article before the Standards meeting, but by the time you read this, the meeting will have already occurred. I'll include any updates in my next trip report column, which should appear in the June or July issue of this magazine.)</p><p>First, let's recap what C and C++ say today about null pointers, see what the issues are, and then look at the solution that we are contemplating for C++0x.</p><h3>Null Pointers in Today's C and C++: 0 and NULL</h3><p>The key question is this: What is the type of the expression 0 (zero)?</p><p>The key problem is that, in C and C++, there is more than one answer. Bear with me as we take a quick look at what the language Standards actually say about it, then we'll see what that means for real code.</p><p>Both languages have a special rule that says that 0 is both an integer constant and a null pointer constant. Here's what the C Standard has to say about it:</p><blockquote><p>An integer constant expression with the value 0, or such an expression cast to type void *, is called a null pointer constant...If a null pointer constant is converted to a pointer type, the resulting pointer, called a null pointer, is guaranteed to compare unequal to a pointer to any object or function. </p><p align="right">                              [1], 6.3.2.3</p></blockquote><p>The C++ Standard's take is similar, but closer to the original K&amp;R C definition. The main difference is that a zero cast to <b>void*</b> is not considered a null pointer constant:</p><blockquote><p>A null pointer constant is an integral constant expression (expr.const) value of integer type that evaluates to zero. A null pointer constant can be converted to a pointer type; the result is the null pointer value of that type and is distinguishable from every other value of pointer to object or pointer to function type.</p><p align="right">                                     [2], 4.10</p></blockquote><p>Both C and C++ also provide the standard macro <b>NULL</b>, which expands to "an implementation-defined null pointer constant." (For those keeping score at home, see [1] 7.17 and [2] 18.1.)</p><p>This is one of the few cases where the answer to "What is the type of <b>X</b>?" gets a little blurry. That's unfortunate because, in a strongly typed language, it's a Bad Thing for the type system to have blurry answers to such basic type questions. When type answers get confused, then the language rules get confused.</p><p>And, ultimately, programmers get confused, too.</p><p>Let's consider some of the problems that stem from having a null pointer constant that behaves as though it had an ambiguous type. Some of these affect both C and C++ programs, but from now on, I'm going to focus on C++ only; it matters more in C++ because it interacts (poorly) with C++'s more type-sensitive features &#151; notably, overloading.</p><h3>Problem 1: Overloading And (Lack of) Ambiguity</h3><p>This use of the value <b>0</b> to mean different things (a pointer constant and an <b>int</b>) has caused problems since at least 1985 in teaching, learning, and using C++. Here's an example first published in 1993's <i>Effective C++</i> Item 25 [6] (and retained with slight changes in its second edition [7]):</p><pre>// Example 1: Taken from Item 25 of [6]//void f(int x);void f(char* ps);<P>f(0);    // calls f(int) or f(char*)?</pre><p>You might think the call is ambiguous, because </b><b>0</b> is, after all, both a pointer and an <b>int</b> &#151; right? And that is also what many programmers would want to have happen here.</p><p>Instead, what happens is that <b>f(int)</b> gets selected unambiguously. Why? Well, <b>0</b>'s type is, after all, both <b>int</b> and pointer, but when push comes to shove, it's an <b>int</b> first and foremost. Thus, Meyers adds the wry note:</p><blockquote><p>This is a situation unique in the world of C++: a place where people think a call should be ambiguous, but compilers do not.</p><p align="right">                              [7], Item 25</p></blockquote><p>So, with this in mind, how should you best answer the question, "What's the type of <b>0</b>"? Informally: <b>0</b> is always both an integer constant and a null pointer constant &#151; except when it's not.</p><p>Before leaving this first problem, consider one last aspect: What if you want to call <b>f(char*)</b> with a null pointer? How do you write it? After all, if the overload <b>f(int)</b> wasn't hanging around, we'd just happily write <b>f(0)</b>...but with an <b>f(int)</b> in the mix, that doesn't work because <b>0</b> matches <b>int</b> better than it matches <b>char*</b>. So you have to be explicit:</p><pre>f( (char*)0 );	// option 1: explicitly cast to char*<P>char* nil = 0;	// option 2: used a named variablef( nil );       // of type char*</pre><p>Is that asking a lot? Well, probably not. But it is unfortunate that we have no better way to utter a simple request to "pass in the null pointer value."</p><p>By the bye, the previous code option with its cute little </b><b>nil</b> variable gives us a nice segue to the second problem...</p><h3>Problem 2: A Name for the Null</h3><p>The second major problem is that the null pointer ought to have a name. And, no, <b>NULL</b> doesn't count.</p><p>Names are important. In particular, as Meyers laments:</p><blockquote><p>It would be nice if you could somehow tiptoe around this problem by use of a symbolic name, say, NULL for null pointers, but that turns out to be a lot tougher than you might imagine.</p><p align="right">                               [7], Item 25</p></blockquote><p>Providing a convenient name is, indeed, one reason why the standard macro <b>NULL</b> exists, although that macro is insufficient for the reasons Meyers goes on to demonstrate. In a nutshell, the difficulty with the standard <b>NULL</b> macro is that it's no better than the type-ambiguous "null pointer constant," because that's exactly what it has to expand out to. No matter how you dress up a <b>0</b>, it's still a <b>0</b> in the end. (<b>NULL</b> doesn't have to be spelled exactly "<b>0</b>", but the few alternatives are no better; see [7] for more gory details.)</p><p>If the null pointer constant had a type-safe name, that would also solve the previous problem: You could easily distinguish it from the integer <b>0</b> for overload resolution by simply writing, say, <b>f( nullptr );</b>.</p><p>Did I say "<b>nullptr</b>"? This brings up a key naming question, to wit...</p><h3>Interlude: What Should It Be Called?</h3><p>The null pointer constant should be called <b>nullptr</b>. That says what it is; for example, it's not a null reference.</p><p>Of all the names we might choose for this little beast, <b>nullptr</b> is the one that's least likely to conflict with existing programs. For example, a Google search for "nullptr cpp" returns a total of merely 150 hits, only one of which appears to use <b>nullptr</b> in a C++ program. That's the lowest Google result of any of the other alternatives to follow.</p><p>We certainly can't use <b>NULL</b> because that's already a standard macro in C and C++. Even if C++ defined <b>NULL</b> to be a keyword, it would still be replaced by macros lurking in older code. Also, there might be code "out there" that (unwisely) depended on <b>NULL</b> being <b>0</b>. Finally, using such a name would go against the usual convention that identifiers in all caps are macro names (and, for example, testable by <b>#ifdef</b>), which this one isn't.</p><p>Similarly, we can't use <b>null</b>. That's appealingly simple and tantalizingly natural, but alas, it's nearly as bad as <b>NULL</b> because <b>null</b> is also commonly used in existing programs as an identifier name and (worse) as a macro name. If we took <b>null</b> as a reserved word, we'd break the many programs that already use that common word as an identifier, and we'd be stomped on by programs that already use it as a macro.</p><p>What's left? Not much. We also can't spell it <b>0P</b> or <b>0p</b>, where we'd be adding the letter as a constant type suffix. This alternative overlaps with a C extension that already uses <b>P</b> or <b>p</b> in a constant to write the binary exponent part of a hexadecimal floating-point constant (see [1] 6.4.4.2). For example, <b>0P</b> occurs as a part of the constant <b>0x0P2</b>. Although using <b>0P</b> or <b>0p</b> would not be ambiguous today (the C99 <b>P</b> or <b>p</b> must be preceded by <b>0x</b> and a hex number and must be followed by a decimal number), it seems imprudent to reuse a constant type suffix already used for another type of constant. Also, using an obscure notation, such as <b>0P</b>, would encourage people to rely on a <b>NULL</b> macro.</p><p>Our informal polling suggests that people seem to like <b>nullptr</b>. If nothing else, it is the spelling that has elicited the fewest strong objections to date in our experience. The evolution working group liked it, too, so that's what we've proposed.</p><h3>A Workaround: The Best You Can Do In Today's C++</h3><p>But does <b>nullptr</b> really require a language extension? C++ is a powerful language already; couldn't we somehow write <b>nullptr</b> as a library facility?</p><p>In short: Yes, we could, but it would be a poorer solution (the practical argument), and a concept this fundamental belongs in the language (the clean-design argument).</p><p>Meyers continued his treatise by presenting several unsuccessful attempts to simulate a true null pointer in the language, which successfully divorces the notions of "zero integer value" and "null pointer value." Here is a slightly edited version of the final attempt he presents in Item 25 of [7]:</p><pre>// Example 2: Adapted from Item 25 of [7]//const                    // this is a const object...class {public:  template&lt;class T&gt;      // convertible to any type    operator T*() const  // of null non-member    { return 0; }        // pointer...  template&lt;class C, class T&gt;  // or any type of null    operator T C::*() const   // member pointer...    { return 0; }private:  void operator&amp;() const;  // whose address can't be taken} nullptr = {};            // and whose name is nullptr</pre><p>Note what he's doing: <b>nullptr</b> is a const object, the only object of an unnamed class that can be converted to any pointer or pointer-to-member type and whose address can't be taken.</p><p>There's one real advantage to this workaround: It doesn't make <b>nullptr</b> a reserved word. (Of course, the whole point of having such a null pointer constant is that it actually be used widely and pervasively, so, in practice, the name is still effectively a reserved word for most purposes.) This means that it won't affect the meaning of existing programs that might use <b>nullptr</b> as an identifier. On the other hand, though, it also means that its name can be hidden by such an existing identifier.</p><p>There's one seeming advantage that we believe isn't an advantage in practice: It provides <b>nullptr</b> as a library extension, rather than a special value baked into the language and known to the compiler. We think this is a red herring because compiler implementations would likely bake in special knowledge of it anyway. Why? To produce quality warnings and errors. To see what I mean, try this experiment on whatever compiler(s) you're using today: Type in the aforementioned library implementation of <b>nullptr</b> and try writing code that uses it that should produce an error (for example, assigning <b>nullptr</b> to an <b>int</b>, or passing it to a template parameter of type <b>int</b>, or comparing it to an <b>int</b>, all of which shouldn't be allowed). My experiments with several popular compilers show that this library template implementation of <b>nullptr</b> generates poor and/or misleading error messages for common mistakes, including:</p><ul>  <li>No conversion from <b>const</b> to <b>int</b>.  <li>No suitable conversion function from <b>const class &lt;unnamed&gt;</b> to <b>int</b> exists.  <li>A template argument may not reference an unnamed type.  <li>No <b>operator ==</b> matches these operands, operand types are: <b>int == const class &lt;unnamed&gt;</b>.</ul>  <p>Not a word about "you can't do that with a null pointer" anywhere in sight. These diagnostics clearly aren't good enough for such a fundamental concept and such simple programming mistakes, so we believe that even if this approach were standardized (and it won't be), compilers would still need to add special knowledge of <b>nullptr</b> in order to provide quality error messages for common use cases. In short: Even if <b>nullptr</b> weren't technically a language extension, it might as well be.  <p>That's the best we can do with a library-based solution, so it's time to consider what might become C++0x's first language extension.<h3>Introducing nullptr</h3><p>In draft Standard C++/CLI [4], and possibly soon in draft Standard C++0x [2], <b>nullptr</b> is a reserved word that designates a strongly typed null pointer constant that you can use in all the previously contexts mentioned that are good, and in none of the ones that are evil.</p><p><b>nullptr</b> converts implicitly to any pointer or pointer-to-member type, but not to an integer type (it will have nothing to do with the <b>int</b>s, thank you very much just the same, we've just had far too many problems with that clan before). That means that if you have overloaded functions like these:</p><pre>void f(int);void f(char*);</pre><p>then you can easily call the second with a null pointer by writing just:</p><pre>f( nullptr );</pre><p>You can <b>throw nullptr</b>; and compute <b>sizeof(nullptr)</b>. But you can't do stuff that leads to trouble: You can't take <b>nullptr</b>'s address, convert it to an integer, assign it to an integer variable, or compare it to an integer variable.</p><p>Here are a few examples to illustrate the kinds of things you can and can't do with <b>0</b> and <b>nullptr</b>, and in which cases <b>nullptr</b> is better:</p><pre>// initialization and assignmentchar* ch = nullptr;  // ch has the null pointer valuechar* ch2 = 0;       // ch2 has the null pointer valueint n = nullptr;     // errorint n2 = 0;          // n2 is zero// comparison</p>if( ch == 0 );        // evaluates to trueif( ch == nullptr );  // evaluates to trueif( ch );             // evaluates to falseif( n2 == 0 );        // evaluates to trueif( n2 == nullptr );  // errorif( nullptr );        // errorif( nullptr == 0 );   // error// arithmeticnullptr = 0;         // error, nullptr is not an lvaluenullptr + 2;         // error</pre><p>In particular, note that <b>0</b> can still be assigned to a pointer and compared with pointers. This is essential for compatibility. The <b>nullptr </b>proposal deliberately proposes no change to the existing meanings of <b>0</b> and <b>NULL</b>. Granted, it could be tempting to define the Standard Library macro <b>NULL</b> to <b>nullptr</b> "while we're at it," but doing that would break some people's existing code (even though, in many cases, it would be code that deserves to be broken because it treats the <b>NULL</b> pointer like an <b>int</b>). Rather, the current thinking is that it's better to preserve backward compatibility for current code, while strongly encouraging new code to use the cleaner and safer <b>nullptr</b>.</p><h3>Summary and Perspective</h3><p>We need a type-safe and named null pointer, and the front-running candidate is the <b>nullptr</b> described here, which is part of the C++/CLI draft Standard [4] and may soon be part of the new draft Standard C++.</p><p>Having a distinct type for <b>nullptr</b> also turns out to be useful for library writers. In particular, while the <b>nullptr</b> proposal was being discussed, the library folks noticed that having a <b>nullptr</b> with a specific known type would be useful for several of the facilities in the new Standard Library extensions currently being added to C++ [8].</p><p>For example, the <b>tr1::function</b> facility generalizes the notion of a function or function object; it can bind (well, point) to anything function-like (see [9] and [10] for more on <b>tr1::function</b> and just how nifty and useful it is). Because it can be made to point to objects, it has to be able to deal with being made to point to nothing. Today, <b>tr1::function</b> relies on special tests to determine whether it is being given a null or nonnull pointer. If <b>nullptr</b> had a distinct type, <b>tr1::function</b> could instead add overloaded constructors and assignment operators that could take special action, specifically when a <b>nullptr</b> argument is passed, rather that relying on manual in-function checks.<b></p><p>nullptr</b> takes one small step toward making the world (or, at least, the world's C++ code) a little more safe, pleasant, and friendly. Better still, it's not just some theoretical extension, but one that's practical today: It's being standardized in C++/CLI and possibly C++0x, and it's currently being implemented by several C++ compiler vendors, so you can expect to start seeing it soon in some compilers near you. Check your local stations for delivery times, and enjoy.</p><h3>Acknowledgments</h3><p>Thanks to Bjarne Stroustrup (of Texas A&amp;M University), P.J. Plauger (of Dinkumware), Steve Adamczyk, John Spicer, and Daveed Vandevoorde (all of Edison Design Group), Tom Plum (of Plum Hall), and Brandon Bray, Jonathan Caves, Mark Hall, and Jeff Peil (all of Microsoft) for their collaboration and feedback on the C++/CLI language design in general, and on the <b>nullptr</b> design in particular.</p><h3>References</h3><p>[1]	ISO/IEC 9899:1999(E), <i>Programming Languages &#151; C</i>.</p><p>[2]	ISO/IEC 14882:2003(E), <i>Programming Languages &#151; C++</i>.</p><p>[3]	H. Sutter. "Trips Report: October-December 2003," <i>C/C++ Users Journal</i>, 22(4), April 2004. </p><p>[4]	<i>C++/CLI Language Specification Candidate Base Document</i>, Microsoft, November 2003. This document has already been improved by Ecma committee TG5 (C++/CLI) over the course of the last few months, and another public draft should be available soon, but as of this writing, the November 1993 base document is the most current publicly available working draft. You can get at it online via a link on my web page <a href="http://www.gotw.ca/microsoft/">http://www.gotw.ca/microsoft/</a>.</p><p>[5]	H. Sutter and B. Stroustrup. "A name for the null pointer: nullptr (revision 2)," ISO C++ committee paper ISO/IEC JTC1/SC22/WG21/N1601, February 2004. Available online at http://std.dkuug.dk/jtc1/sc22/wg21/ docs/papers/2004/n1601.pdf.</p><p>[6]	S. Meyers. <i>Effective C++</i>, Addison-Wesley, 1993.</p><p>[7]	S. Meyers. <i>Effective C++</i>, Second Edition, Addison-Wesley, 1997.</p><p>[8]	<i>(Draft) Technical Report on Standard Library Extensions</i>, C++ Standards Committee Document, ISO/IEC JTC1/SC22/WG21/N1596, February 2004. Available online at <a href="http://std.dkuug.dk/jtc1/sc22/wg21/docs/papers/2004/n1596.pdf">http://std.dkuug.dk/jtc1/sc22/wg21/docs/papers/2004/n1596.pdf</a>.</p><p>[9]	H. Sutter. "Generalized Function Pointers," <i>C/C++ Users Journal</i>, 21(8), August 2003. Available online at <a href="http://www.cuj.com/documents/s=8464/cujcexp0308sutter/">http://www.cuj.com/documents/s=8464/cujcexp0308sutter/</a>.</p><p>[10] H. Sutter. "Generalizing Observer," <i>C/C++ Users Journal</i>, 21(9), September 2003. Available online at <a href="http://www.cuj.com/documents/s=8840/cujexp0309sutter/">http://www.cuj.com/documents/s=8840/cujexp0309sutter/</a>. </p><hr><I><b>Herb Sutter</b> (<a href="http://www.gotw.ca/">http://www.gotw.ca/</a>) is convener of the ISO C++ Standards committee, author of <i>Exceptional C++ and More Exceptional C++</i>, and Visual C++ architect for Microsoft. </I><hr></body></html>