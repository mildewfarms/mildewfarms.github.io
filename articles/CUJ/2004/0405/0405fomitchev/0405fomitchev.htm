<html><head><title>May 04: </title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; C/C++ Users Journal--><p><i>C/C++ Users Journal </i> May 2004</p><h1>Wrapping C++ COM Components as XML Web Services</h1><h2>Developing XML web-service wrappers using ATL Servers</h2><h3>By Max I. Fomitchev</h3><p>In my article "Integrating XML Web Services with VB6 Applications" (<i>Dr. Dobb's Journal</i>, February 2004), I examined how you can consume XML web services in legacy applications by means of the Microsoft SOAP Toolkit. While the SOAP Toolkit is suitable for wrapping most existing COM components as XML web services, in some cases you may have to modify the original COM component to make such wrapping possible and the resulting XML web service usable to the extent close to that of the original COM component. Therefore, in some cases, it may be feasible to write a custom XML web-service wrapper for a COM component that allows full control over state management and data type conversion. In this article, I present a streamlined approach for wrapping C++ COM components as XML web services by means of ATL Server web-service projects.</p><p>When implementing custom XML web-service wrappers for COM components, you must take into consideration the following important issues:</p><ul>  <li>Persistence. COM object persistence is usually taken for granted. The same, unfortunately, is not true of XML web services. Typically, it is your responsibility to persist and retrieve the relevant XML web-service state when needed. Therefore, you must provide a mechanism for retrieving the web-service state at the beginning of each web-method call and storing the state at the end of each web-method call or as required. While the most popular persistence mechanism in connection with web development is session state (and it can be employed relatively easily), additional code is likely to be required to enable the COM component serialization and deserialization from the underlying session-state storage.  <li>Properties. XML web services do not support properties in the COM sense. While, technically, it is possible to mimic COM interface properties as SOAP header elements, the necessity to transmit/receive SOAP headers with each web-method call may have serious effects on overall performance and network traffic when the amount of data assigned to SOAP headers is substantial. Therefore, COM interface properties should be replaced with corresponding <b>get</b>/<b>set</b> methods in XML web services.  <li>Error reporting. COM errors can be reported as SOAP faults.  <li>Data types. Standard COM data types cannot be directly mapped into standard XML data types. For instance, the COM <b>DATE</b> data type is represented by a floating-point number of days elapsed since December 30, 1899, the corresponding XML <b>dateTime</b> data type is expressed as text corresponding to a nondelimited concatenation of date and time constituents.</ul><p>     </p><p>These considerations must be applied not only to the XML web-service wrapper, but also to the COM component itself when the situation permits modifying the underlying COM interface. In fact, when the source COM component can be modified, it is possible to arrive at an interface that can be used effectively both by COM and web-service clients with the latter being facilitated by the XML web-service wrapper that you are about to write.</p><p>The approach I present in this article involves developing an XML web-service wrapper using the ATL Server project. In this case, the source COM component is presumed mutable, and the following modifications are effected by the object's interface:</p><ul>  <li>Properties are explicitly replaced with <b>get</b>/<b>set</b> methods to allow for maximum code similarity between COM and web-service consumers.  <li>Methods are modified to the extent possible to operate on simple types, UDTs, and arrays of simple types or UDTs.  <li>Serialization and deserialization methods are added to the COM interface (the actual serialization/deserialization mechanism does not matter and it can be text, XML, or a pure binary representation as long as the object can be serialized/deserialized consistently and reliably).  <li><b>DATE</b> data types in UDTs are replaced with BSTR data types to avoid arduous type conversion in web-method calls.</ul>  <p>To illustrate this approach, consider that, in <A HREF="0405fomitchevl1.htm" target="_BLANK">Listing 1</A>, the interface originally contained a read-only <b>ReleaseDate</b> property, which was replaced with the <b>GetReleaseDate()</b> method. The <b>DATE</b> data type is preserved in the method because it will be possible to implement an efficient and seamless conversion in the web-service wrapper code (which is not the case for methods operating on arrays of UDTs with <b>DATE</b> fields). Also, the <b>ToString()</b> and <b>InitFromString()</b> hidden methods are added to the interface to support serialization and deserialization of the object state to/from character data.  <p>The actual COM object implementing the interface supports the COM error interface <b>ISupportErrorInfo</b> by means of the <b>support_error_info</b> attribute (<A HREF="0405fomitchevl2.htm" target="_BLANK">Listing 2</A>). Once the <b>support_error_info</b> attribute is applied to the class definition, you can call the <b>CComCoClass::Error()</b> method to provide meaningful error information (<A HREF="0405fomitchevl3.htm" target="_BLANK">Listing 3</A>). It is the task of the web-service wrapper to query the <b>IErrorInfo</b> interface to extract error information when COM component method calls fail (for example, return <b>E_FAIL</b> error code).  <p>The next step is to create a C++ ATL Server web-service project. You should check the Generate Combined DLL box on the Project Settings page of the ATL Project Wizard dialog to generate a Web Service DLL combining ATL Server and ISAPI extension functionality in the same file. Also, check the Sessions Service box on the Server Options page to enable support for session storage. You can use either OLEDB or memory-backed session storage. While memory-backed session storage is more efficient performance wise, OLEDB-backed session storage can provide permanent persistence and seamless support for load balancing. When multiple instances of the web service are hosted on multiple web servers, all of them can access shared OLEDB session storage and it would not matter which physical web server answers a particular web-method request. The same cannot be easily achieved with memory-backed session storage as it is local and private to each particular web server.  <p>Once you have created an ATL Server web-service project, you should extend the web-service interface to mimic your COM component interface as closely as possible. For example, for the <b>IUltraMax</b> interface, the web-service interface in <A HREF="0405fomitchevl4.htm" target="_BLANK">Listing 4</A> is proper. Note the difference in declaration for the <b>GetSongs()</b> method returning the array of UDTs, which, in the COM interface case, is defined as:<pre>HRESULT GetSongs([out] LONG* Size,          [out, retval, size_is(, *Size)] SongInfo** Songs);</pre>  <p>and in the case of the web service interface is defined as:<pre>HRESULT GetSongs([out] LONG* Size,	   [out, retval, size_is(*Size)] SongInfo** Songs);</pre><p>Also, the <b>GetReleaseDate()</b> method in the web-service interface now employs the <b>BSTR</b> data type rather than the COM <b>DATE</b> data type for date representation. In the web-service wrapper, it is necessary to replace the <b>DATE</b> data type in all web methods with <b>BSTR</b> data types to ensure smooth date conversion between XML and COM for the reasons just outlined. Lastly, <b>ToString()</b> and <b>InitFromString()</b> COM interface methods are internal, and need not be exposed in the web-service interface.</p><p><A HREF="0405fomitchevl5.htm" target="_BLANK">Listing 5</A> is the corresponding class implementing the web-service interface. The <b>InitializeHandler()</b> method was injected by the Application Wizard, however, the session-handling code required uncommenting.</p><p>Besides injected code, the web-service class contains these custom methods and properties:</p><ul>  <li><b>m_pUltraMax</b> member encapsulating the <b>IUltraMax</b> COM interface, for which the corresponding <b>#import &lt;UltraMax.dll&gt;</b> statement had to be included in the web-service header file.  <li><b>m_Header</b> property of type <b>MyHeader</b> corresponding to the SOAP header needed to store session ID information for session state support:<pre>	struct MyHeader {	   BSTR m_SessionID;	};</pre>  <p>Although you may be inclined to define </b><b>m_Header</b> as <b>BSTR</b> rather than UDT, this approach will prove futile when consuming the resulting web service in .NET clients such as C# or VB.NET. It turns out that the .NET web-service client interface represented by the .NET Framework <b>SoapHttpClientProtocol</b> class always expect SOAP headers to be represented by a complex type (such as UDT) and will throw an exception when the SOAP header is represented by a primitive type such as an XML string (COM <b>BSTR</b>). Also notice that the <b>m_Header</b> member appears in the <b>soap_header</b> attribute applied to each web method to ensure that the session ID information is transmitted with each web-method call. Naturally, the <b>LogOn()</b> method does not require session ID information on input because the main purpose of the method is to create a new session for authenticated users. Therefore, the required parameter of the <b>soap_header</b> attribute applied to the <b>LogOn()</b> method is set to False while all other web methods require the SOAP header information to succeed.  <li><b>EnsureSession()</b> method intended to create new session information when none exists or lookup an existing session-state info using the <b>m_SessionID</b> value supplied in the SOAP header; see <A HREF="0405fomitchevl6.htm" target="_BLANK">Listing 6</A>.  <li><b>Prolog()</b> method for instantiating the COM component being wrapped and retrieving its state from the session storage using the component's <b>InitFromString()</b> method; see <A HREF="0405fomitchevl7.htm" target="_BLANK">Listing 7</A>.  <li><b>Epilog()</b> method for retrieving COM component error information (if any) by querying the component's <b>IErrorInfo</b> interface and for writing back the component's state to session storage using the component's <b>ToString()</b> method; see <A HREF="0405fomitchevl8.htm" target="_BLANK">Listing 8</A>.  <li><b>GenerateAppError()</b> overridden method for reporting error information extracted from COM as SOAP faults with the error description placed in the SOAP fault <b>&lt;detail&gt;</b> field by means of the <b>CSoapHandler::SoapFault()</b> method; see <A HREF="0405fomitchevl9.htm" target="_BLANK">Listing 9</A>.</ul><p>Now the groundwork for the web service is laid and the only thing that remains is to implement web methods corresponding to the wrapped component COM interface methods. To streamline the process of repetitious duplication of COM interface method calls, I have defined the following macro:</p><pre>#define COM_CALL(obj_method)    \   HRESULT hr = Prolog();       \   if ( FAILED(hr) ) return hr;	\   hr = obj_method;             \   return Epilog(hr);           \</pre><p>With the help of the </b><b>COM_CALL</b> macro, you can wrap a COM method call in a single line of code; for instance: </p><pre>HRESULT CUltraMaxService::LogOn(BSTR sLoginID, BSTR sPassword){   COM_CALL(m_pUltraMax-&gt;raw_LogOn(sLoginID, sPassword));}</pre><p>With the </b><b>COM_CALL</b> macro, the majority of wrapped COM methods have a simple and clean appearance with the exception of methods that require data type conversion, such as COM <b>DATE</b> to XML <b>dateTime</b> conversion; see <A HREF="0405fomitchevl10.htm" target="_BLANK">Listing 10</A>. The <b>GetReleaseDate()</b> web-method code performs such conversion relying on the ATL <b>COleDateTime</b> class to perform <b>dateTime</b> parsing and formatting to ensure smooth integration with .NET web-service consumers.</p><p>Now the web-service wrapper code is complete and the resulting web service can be consumed in legacy applications (with the help of the SOAP Toolkit) or in managed .NET clients.</p><p>There are two tricks worth mentioning that should be applied to the generated Web Reference classes when consuming the resulting web-service wrapper in managed .NET clients:</p><ul>  <li>The default declaration of the SOAP header type must be modified to match the name of the actual SOAP header variable defined in the ATL Server web service. In <A HREF="0405fomitchevl11.htm" target="_BLANK">Listing 11</A>, the modified C# code where the <b>typeName</b> parameter of the <b>SoapTypAttribute</b> (that is, the first argument to the <b>SoapTypAttribute</b> constructor) applied to the SOAP header class was modified from the type name <b>MyHeader</b> injected by the Web Reference wizard with the name of the actual SOAP header variable employed in the ATL web-service code.  <li>Another trick is to replace string data types in web methods that originally intended to operate on <b>dateTime</b> data types with <b>dateTime</b> data types. Thus, the <b>GetReleaseDate()</b> method should be defined in C# as:<pre>void GetReleaseDate([SoapElement(DataType = "date")] ref DateTime CurrentDate)</pre></ul>    <p>The </b><b>SoapElement(DataType="date")</b> attribute is applied to the <b>CurrentDate</b> parameter to ensure that only the date portion of the <b>CurrentDate</b> parameter is formatted and parsed as an XML <b>date</b> data type rather than <b>dateTime</b>, which is critical for correct date parsing and formatting in the web-service wrapper code (which relies on the ATL <b>COleDateTime</b> class for this purpose). In this way, the web method definition in the web-service client code matches the original COM interface method definition in the sense that the actual native date data types are employed in both places. The only place where the date representation is temporarily textual is in web-service wrapper code, which, in the case of C++ ATL Server projects, does not support XML <b>date/dateTime</b> data types directly and has to resort to manual date conversion between SOAP/XML and COM.  <p>Now, the Web Reference class is ready for using in managed code. Keep in mind that you should be catching <b>SoapExceptions</b> as those may contain error information returned by the underlying COM component.<h3>Conclusion</h3></blockquote><p>The approach I've presented here provides a straightforward mechanism for exposing existing C++ COM components for managed and unmanaged web-service consumers while providing maximum usability of the original COM component and requiring little change to the original COM interface. The complete code samples illustrating this approach are available at <a href="http://www.cuj.com/code/">http://www.cuj.com/code/</a>. </p><hr><i><b>Max Fomitchev</b> is the author of </i>.NET Programming with Visual C++<i> and can be contacted at <a href="mailto:fomitchev@adelphia.net">fomitchev@adelphia.net</a>.</I><hr></body></html>