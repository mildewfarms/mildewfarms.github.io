<html><head><title>May 04: </title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; C/C++ Users Journal--><p><i>C/C++ Users Journal </i> May 2004</p><h1>Optional Storage</h1><h2>Every byte counts &#151; especially with large-scale systems</h2><h3>By Craig Henderson</h3><p>In a recent project, I was designing a data structure that required the storage of additional data depending on information that was available at compile time, but unknown at design and implementation. As an example of the problem, consider an unrelated system to store people's personal details. A subset of the information could be a list of forenames, surnames, maiden names, and children's names. Forenames and a surname are applicable to all people, but a maiden name and children's names are each only applicable to a subset of people. With this in mind, there were three design goals I aimed to achieve:</p><ul>  <li>Compile-time safety of ensuring the optional data was not accessed when it shouldn't be.  <li>Avoid conditional heap allocation and runtime checks.  <li>Minimize the allocation space to hold redundant data.</ul>  <p>Here's a structure that could store all the information:<pre>template&lt;typename Char&gt;struct personal_details{    typedef    enum { male, female }    gender_t;    gender_t                                   gender_;    std::vector&lt;        std::basic_string&lt;Char&gt; &gt;  forenames_;    std::basic_string&lt;Char&gt;             surname_;    std::basic_string&lt;Char&gt;         maiden_name_;    std::vector&lt;        std::basic_string&lt;Char&gt; &gt;   children_;};</pre><p>This structure fails to meet any of the three design goals, of course. Perhaps the most significant point of interest here is the memory allocation required in storing the </b><b>maiden_name_</b> and <b>children_</b> variables that may never be used. The actual size depends on the STL implementation in use. <A HREF="0405hendersont1.htm" target="_BLANK">Table 1</A> shows the size with three compiler/STL combinations.</p><p>An obvious solution to this problem is to allocate the optional variables on the heap at runtime and store pointers in the <b>personal_details</b> structure. However, this only meets the third design goal, failing on the first two. So perhaps using a class hierarchy could be an answer? I could build a hierarchy to use a base class for forenames and surnames and derived classes for parents and married people. <A HREF="0405hendersonl1.htm" target="_BLANK">Listing 1</A> is an example hierarchy, and shows how this solution can quickly become unwieldy and difficult to maintain. With respect to the design goals, the first and second are met, but this solution is very inefficient in terms of space allocation. <A HREF="0405hendersont2.htm" target="_BLANK">Table 2</A> shows the sizes of these classes. The results are considerably variable for different compiler/STL configurations, with size for the structure to represent the details of a married female parent ranging from 44 bytes with GCC 3.2 to 100 bytes with Microsoft Visual C 7 (VC7). </p><p>Consequently, I set out to design a structure that can &#151; under specific compile-time conditions &#151; occupy minimal storage, and under other conditions can store a data-type object and has the same semantics as the data type itself. There must, however, be no storage overhead in using the optional storage structure itself.</p><pre>template&lt;typename Type, bool store&gt;struct optional_storage;</pre><p>The structure </b><b>optional_storage</b> has two template parameters: The first is the data type that could be stored, and the second is a Boolean value to determine whether storage should be allocated or not. For the case of no storage, you simply define a structure with an empty type:</p><pre>template&lt;typename Type&gt;struct optional_storage&lt;Type, false&gt;{   typedef struct { } type;};</pre><p>Now to the trickier case of allocating storage. The easiest way to achieve the goal of data-type semantics is to derive the </b><b>optional_storage </b>class (available at <a href="http://www.cuj.com/code/">http://www.cuj.com/code/</a>) from the data type itself. A type is implicitly convertible to its base, so deriving will solve all the problems. Well, it would do, but for a small problem in that a structure cannot derive from a fundamental type (integrals and floating point), only from a class or another structure. To overcome this, you can create a structure that wraps the basic data type and provides operators to convert to and from the basic data type. I call it <b>mandatory</b>, as it stores data when the <b>optional_storage</b> structure becomes mandatory; see <A HREF="0405hendersonl2.htm" target="_BLANK">Listing 2</A>. You can now derive from a mandatory structure that wraps the data type; see <A HREF="0405hendersonl3.htm" target="_BLANK">Listing 3</A>.</p><p>And there you have it &#151; a structure that "auto-magically" reduces to the minimum size allocation allowed by the language for the given data type, or no data, dependent on a compile-time expression. The minimum size allowed by the language depends on its use. As a member of a class or structure, it must be at least 1 byte in size, and its actual size will depend on the compiler's alignment settings. As a base class, there are no restrictions, and the compiler is allowed (but not required) to optimize away this space. This is a technique known as "Empty Base Optimization," and means that a class that derives from an empty base class can be the same size as if it were deriving from nothing.</p><p>Returning to the <b>personal_details</b> example, you can now define the structure, as in <A HREF="0405hendersonl4.htm" target="_BLANK">Listing 4</A>. Here, the only compulsory members are <b>gender_</b>, <b>forenames_</b>, and <b>surnames_</b>. All the others are optional based on one &#151; or a combination of &#151; template parameter values. <A HREF="0405hendersont3.htm" target="_BLANK">Table 3</A> shows the size of the structure with each combination of template parameter values.</p><p>Take a closer look at the definition of <b>maiden_name_</b>. For married women, you want to store their premarital name in a string type, and for all other people, a maiden name is inappropriate. You already have a type defined to store names, <b>name_t</b>, so you can declare <b>maiden_name_t</b> like this:</p><pre>optional_storage&lt;   name_t,   G == female  &amp;&amp;  M == married&gt;      maiden_name_;</pre><p>The expression </b><b>G == female &amp;&amp; M == married</b> is evaluated to a Boolean constant at compile time, based upon the values of <b>G</b> and <b>M</b>, which are themselves template parameters to <b>personal_details</b>. It is this use of a Boolean constant as a template parameter that is key to <b>optimal_storage</b> working. This static constant is used in the selection of a type, and the type will contain, or not contain, storage for the data. Because this type selection is performed during compilation, the generated types are subject to optimization and normal error conditions. For example, consider:</p><pre>personal_details&lt;male, single, true&gt;   male_single_parent;</pre><p>where </b><b>male_single_parent</b> is instantiated as a <b>personal_details</b> structure that can optimally represent an unmarried male with children, according to the rules we've defined. This is now a concrete type, so attempting to access the maiden name of this person yields a compilation error:</p><pre>male_single_parent.maiden_name_ = "Smith";</pre><h3>Optimizing struct mandatory&lt;&gt;</h3><p>Although the mandatory structure presented here works, I wasn't happy that it always wrapped the real data type that I wanted to store. The conversion operators are implemented inline and have no overhead in production code with modern compilers, but they are fussy and get in the way in development (debug) code.</p><p>So I set about to improve the situation. The structure would remain the same for a data type from which derivation is illegal. However, in all other cases, it could be optimized in code terms, even if not in performance.</p><p>First, I needed a way of determining whether a type is fundamental; that is, is the type an integral type or a floating-point type? I defined a simple structure, which I can specialize for types that are fundamental. The default (unknown) case is False.</p><pre>template&lt;typename T&gt; struct is_fundamental{ enum { value = false }; };</pre><p>Now I could easily specialize this structure for all types I know to be fundamental, and I can use the value member of the structure at compile time to determine if any given type is fundamental. Now, every type, in every combination of signed/unsigned and cv-qualifiers, must be accounted for, so I created some macros &#151; one for types that can be signed/unsigned (<A HREF="0405hendersonl5.htm" target="_BLANK">Listing 5</A>) and one for those that can't (<A HREF="0405hendersonl6.htm" target="_BLANK">Listing 6</A>). I could then use these macros to define a complete set of fundamental types (<A HREF="0405hendersonl7.htm" target="_BLANK">Listing 7</A>).</p><p>Okay, so now that I know at compile time if a type is fundamental or not, I can reinvent the </b><b>mandatory</b> structure to encapsulate fundamental types and derive from everything else. I define the structure with two template parameters. The first is the data type, as it always was. The second is a Boolean value that determines whether the data type is encapsulated (True) or derived (False). This second template parameter has a default value using the aforementioned <b>is_fundamental </b>structure, and will never need to be supplied by users of the structure.</p><pre>template&lt;typename Type,   bool IsFundamental=detail::     is_fundamental&lt;Type&gt;::value==true&gt;struct mandatory;</pre><p>I now partially specialize the structure using the second parameter. If the parameter is True, then the structure is unchanged:</p><pre>template&lt;typename Type&gt;struct mandatory&lt;Type, true&gt;{    // ... as above}</pre><p>However, if the parameter is False, I know I can derive from the data type and provide three simple constructors.</p><pre>template&lt;typename Type&gt;struct mandatory&lt;Type, false&gt; : public Type{    typedef Type type;    mandatory();    mandatory(const type &amp;other);    mandatory(const mandatory &amp;other);};</pre><p>Microsoft Visual C++, up to and including VC++.NET 2002 (VC7), does not support partial template specialization. For this compiler, the </b><b>optimal_storage</b> structure always wraps the data and never inherits from nonfundamental types.</p><h3>Conclusion</h3><p>The <b>optional_storage</b> structure provides an easy-to-use interface for optimizing the storage requirements of any <b>CopyConstructible</b> data type. Wrapping a data type within an <b>optional_storage</b> structure is mostly transparent, although there is a small caveat. If the contained data type has a conversion operator to another type, it will not be invoked because one implicit conversion has already been performed. In such a situation, an explicit conversion, or intermediate assignment to <b>const Type&amp;</b>,will be necessary. </p><p>The three original design goals have all been met, and there is no storage overhead in using the <b>optional_storage</b> structure itself. This can be seen easily by comparing the bottom line in <A HREF="0405hendersont1.htm" target="_BLANK">Table 1</A> &#151; the starting point &#151; and <A HREF="0405hendersont3.htm" target="_BLANK">Table 3</A> &#151; the <b>optional_storage</b> implementation. For each compiler/STL configuration, the fully populated structure using <b>optional_storage</b> is exactly the same size as the original fully populated structure. The real benefit comes when the optional parts of the structure are eliminated; for example, a structure to represent a single male without children now occupies 52 bytes, 32 bytes, and 24 bytes on VC7.0, VC7.0/STLPort, and GCC3.2, respectively. This is down from 92 bytes, 52 bytes, and 36 bytes on the same compilers, saving 40 bytes, 20 bytes, and 12 bytes. This can add up to a massive savings in a large system storing many of these structures simultaneously. </p><hr><I><b>Craig Henderson</b> has been a professional software engineer for more than 11 years, and is currently studying for a Ph.D. in medical imaging. Craig can be contacted at <a href="mailto:craig2.henderson@uwe.ac.uk">craig2.henderson@uwe.ac.uk</a>.</I><hr></body></html>