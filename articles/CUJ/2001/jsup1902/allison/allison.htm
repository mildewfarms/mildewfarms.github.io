<HTML>   
     <HEAD>
<TITLE>February 2001 Java Solutions/import java.*</TITLE></HEAD>
<BODY BACKGROUND="" BGCOLOR="#FFFFFF" TEXT="#000000">
<H2><A HREF="../tocjfeb.htm"></A><FONT COLOR="#FF0000">   Java</FONT></H2>

<HR>

<H2 ALIGN="center"><FONT COLOR="#800000">import java.*: File Processing</FONT></H2>
<H3 ALIGN="center"><FONT COLOR="#800000">Chuck Allison</FONT></H3>

<BLOCKQUOTE>
<p>Java provides much of the support for file I/O that you&#146;re used to in C/C++, albeit with a little more typing.</p>
</BLOCKQUOTE>

<HR>
<BLOCKQUOTE>

<p>In the previous installment of this column (<I>C/C++ Users Journal,</I> November 2000) I illustrated the classes in <B>java.lang.io</B> that provide basic byte and character stream I/O. A distinguishing feature of many of these classes is their tiered relationship, implemented via the Decorator pattern. For example, a low-level class such as <B>FileReader</B> opens a file. To add line-oriented I/O capability, you can wrap the <B>FileReader</B> object in a <B>BufferedReader</B>, like this:</p>

<pre>
FileReader f =
   new FileReader("file.txt");
BufferedReader b =
   new BufferedReader(f);
</pre>

<p>The basic classes discussed last time all extend an input or output superclass, either <B>InputStream</B> and <B>OutputStream</B>, for byte streams; or <B>Reader</B> and <B>Writer</B> for character streams. One thing I didn&#146;t mention last time was that the file output classes have an overloaded constructor with a second <B>boolean</B> argument for appending data to files. The program in <a href="list1.htm">Listing 1</a> uses such a <B>FileWriter</B> to implement file logging. Often when writing to a log file it is necessary to open and close the file each time you access it. Although certainly more costly than keeping the file open continuously, it is often the only way to guarantee that all the log data gets written. For this reason the <B>LogFile</B> constructor just stores the name of the log file.</p>
<p>The <B>log</B> method opens a <B>FileWriter</B> in append mode by using the two-arg constructor with a second argument of <B>true</B>. If the file doesn&#146;t exist already, it is created. I decorate that <B>FileWriter</B> with a <B>BufferedWriter</B>, not for buffering (I really don&#146;t want any!), but for its <B>newline</B> method. You might be tempted to just use a <B>FileWriter</B> and write a <B>&#146;\n&#146;</B> to it to terminate a line, but not all platforms use that character as a new line terminator. The technique in <a href="list1.htm">Listing 1</a> ports nicely because <B>newline</B> queries the system property <B>line.separator</B> for the correct character(s) to push onto the output stream. The test program in <a href="list2.htm">Listing 2</a> uses both <B>LogFile</B> methods to write to a log file.</p>
<p>So much for the basics. I&#146;ll now cover the &#147;rest of the story&#148; for file I/O in Java 2.</p>

<H3><FONT COLOR="#000080">Random Access Files</FONT></H3>

<p>You&#146;ve probably noticed by now that there is no basic stream class that provides both input and output capability simultaneously, like <B>iostream</B> does in C++. C++ can do this because it has multiple inheritance (although <B>iostream</B> also requires virtual inheritance, one of the most confusing features in the C++ language &#151; count your blessings, Java people!). What Java does offer is <B>RandomAccessFile</B>, a class that supports both input and output as well as file positioning. A <B>RandomAccessFile</B> traffics in bytes, not characters, so it provides methods for reading and writing single bytes and byte arrays, although it also can read and write strings (converting to and from bytes, of course). <B>RandomAccessFile</B> also implements the <B>DataInput</B> and <B>DataOutput</B> interfaces, so you can also work with primitive types.</p>
<p>A traditional application for random access files processes fixed-length data records, so you can access particular records directly with file positioning. (Database systems used this technique in days of yore). The program in <a href="list3.htm">Listing 3</a> defines a fixed-size <B>Employee</B> class with the following layout:</p>

<pre>
Employee no.  1 int (4 bytes)
Last name    15 characters (30 bytes)
First name   15 characters (30 bytes)
</pre>

<p>For the convenience of users of the <B>Employee</B> class, it stores the name fields as <B>String</B> objects, but when it comes time to read or write <B>Employee</B> objects, these fields need to be treated as byte arrays. Furthermore, strings over 15 characters must be truncated and shorter ones need to be filled out. (I chose a fill byte of <B>0xFF</B>, something that wouldn&#146;t occur in user data.) You can see this technique illustrated in the <B>stringToBytes</B> method. To write an <B>Employee</B> record to a <B>RandomAccessFile</B>, function <B>Employee.write</B> calls <B>stringsToBytes</B>, which builds a buffer large enough for both name fields and calls <B>stringToBytes</B> to fill them, after which it writes the employee number. To read a record back in, <B>Employee.read</B> calls <B>RandomAccessFile.readFully</B>, which fills the fixed-length byte array with the name data. To correctly build each name field string I have to search for the first occurrence of <B>fillByte</B> to determine its length.</p>
<p>As you can see in the test program in <a href="list4.htm">Listing 4</a>, to open a <B>RandomAccessFile</B> for both reading and writing, you need to specify a second argument of <B>"rw"</B> in the constructor. After writing a couple of <B>Employee</B> records to the file I move the file pointer between record boundaries by calling <B>RandomAccessFile.seek</B> with the size of the record as an argument. (Seek positions are always relative to the beginning of the file.) This particular example writes two employee records and then swaps them in memory by reading them backwards.</p>
<p>Although this is the first month that this column appears in this <I>Java Solutions</I> supplement, and therefore I am not obliged to mention C++ at all, I still can&#146;t resist showing how to do the above in C++ for comparison. The program in <a href="list5.htm">Listing 5</a> accomplishes the same thing as <a href="list3.htm">Listings 3</a> and <a href="list4.htm">4</a>, but in 50 lines instead of 152! In fairness to the Java, however, I must admit a lot of safety is inherent in the Java version. For example, there is no danger of overflowing a <B>String</B> or even an array in Java, but if I make an error in my array access in C++, I&#146;m dog meat! The C++ version also lacks the advantages of object-orientation, and if I had implemented a C++ <B>Employee</B> class, then more lines would have resulted as well. Nonetheless, if you&#146;re coming from the C world, one of the first things you notice about Java is its verbosity. Like it or lump it.</p>
<p>The complement to the <B>seek</B> method is <B>RandomAccessFile.getFilePointer</B>, which returns the offset of the current file position as a <B>long</B> <a href="#1">[1]</a>. As a final example of the file positioning methods, the program in <a href="list6.htm">Listings 6</a>, <a href="list7.htm">7</a>, and <a href="list8.htm">8</a> illustrate a file viewer &#151; an application that scrolls through a file a screen at a time, both forward and backward <a href="#2">[2]</a>. The <B>FileViewer</B> class in <a href="list6.htm">Listing 6</a> uses a read-only <B>RandomAccessFile</B> so it can move around, and a stack to keep track of where it&#146;s been so it can scroll backwards. The constructor opens the file and displays the first screen. The <B>topPos</B> field keeps track of the file position of the first line currently in the display. To scroll down, the <B>next</B> method pushes <B>topPos</B> on the stack and then displays the next screen, while <B>previous</B> undoes that operation.</p>
<p>You might think it strange that I bother to separate the read and display operations, storing the current screen&#146;s lines in an <B>ArrayList</B> (which is like a <B>Vector</B>), instead of just displaying the lines immediately. The reason I do so is to support the <B>last</B> method, which scrolls immediately to the end of the file. I need to read sequentially, stacking each screen as I go, so I can scroll backwards once I reach the end, but I certainly don&#146;t need to display as I go.</p>
<p>The program in <a href="list7.htm">Listing 7</a> provides a simple command-line interface for viewing a file with <B>FileViewer</B>. Just to be useful it allows redundant commands for each operation (such as <B>'n'</B> and <B>'d'</B> (down) for viewing the next screen). I must admit that I like the way Java forces me to design in a higher-level, object-oriented fashion. The C version of this program I wrote years ago, while shorter, doesn&#146;t separate the file positioning from the viewing, like the <B>FileViewer</B> and <B>ViewFile</B> classes do. It just came automatically now that I&#146;ve been using Java for a number of years.</p>
<p>In <a href="list8.htm">Listing 8</a> you can see that I implemented a stack with Java 2&#146;s <B>LinkedList</B> class. For more on <B>LinkedList</B>, <B>ArrayList</B>, and other collections, see the September 2000 issue of this column in <I>CUJ.</I></p>

<H3><FONT COLOR="#000080">Exploring the File System</FONT></H3>

<p>Working with files is often more than just doing input and output. Sometimes you need to know what files are in a directory, or whether a certain file exists at all, or you may need to delete a file. All this and more is possible with the methods of the <B>File</B> class. A <B>File</B> object represents a path, not a file stream. In fact, the corresponding file doesn&#146;t even have to exist, although subsequent operations may fail if that is the case. <B>File</B> objects are based on hierarchical directory structures such as are found in Unix and DOS/Windows <a href="#3">[3]</a>. Since Unix uses a forward slash to separate components of a path, and Windows uses a backslash, you can determine these characters at run time via the <B>file.separator</B> system property. The program in <a href="list9.htm">Listing 9</a> shows the properties of interest for file processing; the output is for a Windows 2000 system.</p>
<p>A <B>File</B> object can represent either a directory name or a file name, since both are valid path names. You can query which is the case with the <B>isDirectory</B> and <B>isFile</B> methods respectively. You can retrieve the name of the path in two basic forms: <I>absolute</I> and <I>relative</I>. The absolute name of a path is the full path name from its root (e.g., <B>C:\</B>), and the relative name is the last component of the absolute name (such as <B>PropTest.java</B>). An alternate form of absolute name, called the <I>canonical path,</I> is a system-dependent rendition of an absolute path name. Most of the time it is just the same as the absolute path, but on Unix systems, if the absolute path has file system links, then the canonical path will resolve those links to give the true physical path. In other words, a canonical path is more &quot;real&quot; than an absolute path.</p>
<p>The <B>File</B> class has methods for listing the contents of a directory, deleting and renaming files, requesting file attributes such as size, time last modified, and a user&#146;s read and write permissions, and for navigating directories. The program in <a href="list10.htm">Listing 10</a> lists the names of the entries in an entire subdirectory tree. If you don&#146;t specify a starting directory, it uses the current user directory. The <B>File.listFiles</B> method returns an array of <B>File</B> objects representing the contents of the given directory; <B>getName</B> returns the relative pathname of an entry. If the entry is a directory, I call the <B>list</B> method recursively. This particular example shows the files that form this article, and a subdirectory named <B>"temp"</B>.</p>
<p><a href="list11.htm">Listing 11</a> shows how you can control which files come back from a call to <B>listFiles</B>. The nested class <B>SuffixFilter</B> implements the <B>FilenameFilter</B> interface, which has a single method: <B>accept(File dir, String name)</B>. When you call the overloaded version of <B>listFiles</B> that takes a <B>FilenameFilter</B>, it calls <B>accept</B> for each entry and returns only those for which your <B>accept</B> method returns <B>true</B>. This example reads a suffix from the command line, stores it in the static field <B>ListSomeFiles.suffix</B>, and displays only the matching files from the current directory.</p>
<p>The <B>ListFiles</B> class in <a href="list12.htm">Listing 12</a> illustrates the informational methods in the <B>File</B> class. It is basically a traditional directory lister that displays directory information in fixed-length columns. If you&#146;re a little rusty on the format classes in <B>java.text</B>, see my article, &quot;Formatted Text and Locales,&quot; in the July 2000 issue of this column (in <I>CUJ</I>). The program in <a href="list13.htm">Listing 13</a> shows how easy it is to find a file in a subdirectory tree by applying <B>listFiles</B> recursively. It uses <B>File.getCanonicalPath</B> to print the full pathname of the file.</p>

<H3><FONT COLOR="#000080">Summary</FONT></H3>

<p>Java gives you as much control over files and the file system as a &#147;write once run anywhere&#148; language can claim. Although not necessarily fit for implementing a DBMS, the <B>RandomAccessFile</B> class gives you simultaneous input and output on a file of bytes (more or less the equivalent of an expandable byte array on disk), which can be useful. The <B>File</B> class gives you almost everything you need for navigating and tweaking your file system. It&#146;s not POSIX, but it&#146;s close. Magazine real estate won&#146;t allow me to explore it in this issue, but Java does supply classes that support zip and jar <a href="#4">[4]</a> files. Just as a teaser, the program in <a href="list14.htm">Listing 14</a> displays information for each entry in a zip file.</p>

<H3><FONT COLOR="#000080">Notes</FONT></H3>

<p><a name="1"></a>[1]  C/C++ programmers: remember that a <B>long</B> in Java is potentially much larger than in most C/C++ environments (64 bits!), so there is no practical need for a special type like <B>filepos_t</B> as provided in C.</p>
<p><a name="2"></a>[2]  Yes, I know it&#146;s an antiquated command-line style example, but it&#146;s fun, so bear with me.</p>
<p><a name="3"></a>[3]  Much of <B>File</B>&#146;s functionality is a no-op on the MacIntosh.</p>
<p><a name="4"></a>[4]  Jar files are zip files that also contain manifest information. See the September 1999 installment of this column, &quot;Packaging Your Objects,&quot; in <I>CUJ </I>for more information on JAR files.</p>

<p><i><B>Chuck Allison</B> is a long-time columnist with </I>CUJ<I>. During the day he does Internet-related development in Java and C++ as a Software Engineering Senior in the Custom Development Department at Novell, Inc. in Provo, Utah. He was a contributing member of the C++ standards committee for most of the 1990&#146;s and authored the book <I>C &amp; C++ Codes Capsules: A Guide for Practitioners</I> (Prentice-Hall, 1998). He has taught mathematics and computer science at six western colleges and universities and at many corporations throughout the U.S. You can email Chuck at <B>cda@freshsources.com</B>.</i></p>

<h4><a href="../../../source/2001/jfeb01/allison.zip"></a></h4>
</blockquote></body></html>
