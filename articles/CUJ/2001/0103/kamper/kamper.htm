<HTML>   
     <HEAD>
<TITLE>March 2001/Core C++ -- A Software Engineering Approach</TITLE></HEAD>
<BODY BACKGROUND="" BGCOLOR="#FFFFFF" TEXT="#000000">
<H2><A HREF="../tocmar.htm"></A><FONT COLOR="#FF0000">   Book Reviews</FONT></H2>

<HR>

<H2 ALIGN="center"><FONT COLOR="#800000">Core C++ &#151; A Software Engineering Approach</FONT></H2>
<H3 ALIGN="center"><FONT COLOR="#800000">reviewed by Stephan K&auml;mper</FONT></H3>

<HR>
<BLOCKQUOTE>

<table align=center>
<tr><td colspan=2 align=center><IMG SRC="book.gif" width=150></td></tr>
<tr><td><B>Title:</B></td><td><I>Core C++ &#151; A Software Engineering Approach</I></td></tr>
<tr><td><B>Author:</B></td><td>Victor Shtern</td></tr>
<tr><td><B>Publisher:</B></td><td>Prentice Hall PTR, 2000</td></tr>
<tr><td><B>Pages:</B></td><td>1,237 pages, soft cover</td></tr>
<tr><td><B>ISBN:</B></td><td>0-13-085729-7</td></tr>
<tr><td><B>Price:</B></td><td>$49.99</td></tr>
</table>

<H3><FONT COLOR="#000080">Introduction</FONT></H3>

<p>The main theme of <I>Core C++</I> is the engineering of code that is both easily maintainable and reusable. In this book communication between the designer of the code and the maintainence programmer is considered significant; it is important that the designer&#146;s knowledge is transferred to the maintainer.</p>
<p>This book addresses experienced programmers in languages other than C++ as well as novices learning C++ as a first programming language. If you know C++ reasonably well, but feel that maintaining your programs is harder than it should be, this book is for you, too.</p>
<p>One of the book&#146;s pluses is Shtern&#146;s step-by-step technique: he avoids &quot;forwarding references&quot; that would allow him to use constructs discussed later in the book. This is significant, since C++ is a complex language and not easy for a beginner to learn. Shtern&#146;s approach makes life easier for the novice, allowing the reader to take one piece of the cake at a time and not have to deal with the whole cake at once. To give further guidance and orientation the book provides special hints variously entitled &quot;notes,&quot; &quot;alerts,&quot; and &quot;tips.&quot; These hints help a reader figure out what&#146;s really important among the vast amounts of information to remember, especially for programmers new to C++.</p>
<p>Shtern shows a considerable number of examples &#151; and he doesn&#146;t hesitate to present bad code, either. That is valuable, because you can only deal with &quot;bad code&quot; if you know what bad code is. Having presented the bad, Shtern then discusses better solutions. The rationale is that you&#146;ll remember &quot;good solutions&quot; more easily if you know why they are preferable to other ways of accomplishing the same thing.</p>

<H3><FONT COLOR="#000080">What&#146;s in the Book</FONT></H3>

<p>The book is divided into four parts:</p>
<p>1)  Introduction to programming with C++</p>
<p>2)  Object-oriented programming with C++</p>
<p>3)  Object-oriented programming with Aggregation and Inheritance</p>
<p>4)  Advanced Uses of C++</p>
<p>Part 1 introduces both the problems encountered when dealing with large programs and the basic C++ features. The chapter about the &quot;software crisis&quot; deals with known problems in software development: cost overruns, late or cancelled projects, incomplete system functionality, and software errors. At this point it becomes clear what the book really is: an introduction to software engineering with C++, with a strong focus on the development of large programs &#151; that is, programs large enough to make development by a team a necessity, not an option. Therefore the book also discusses less technical topics, such as the communication between team members, as well as how information flows from the program designer/developer to the maintenance programmer.</p>
<p>The next chapters introduce the basic parts of the language used in nearly every C++ program: preprocessor directives, comments, statements, functions, loop constructs, arrays, and header files, to name a few. The last chapter in this part discusses memory management and file I/O. Since no material presented in later chapters is used earlier, the book&#146;s explanation of <B>operator new</B> here is a bit misleading, albeit correct for older compilers: the explanation states that <B>new</B> returns a null pointer if there&#146;s not enough memory available. A standard conforming compiler would throw a <B>bad_alloc</B> exception. In the (hopefully rare) case that a novice encounters a <B>bad_alloc</B> in one of the example programs, a hint on things to come might be useful. A reference to Chapter 18 would do. There the author gives the proper description of how <B>new</B> behaves upon memory allocation failure. Although I agree with the author that the whole truth is too much for a beginner at times, I feel that the description given and the code presented should be in agreement with one another. In this case, using <B>new(std::nothrow)</B> instead of <B>new</B> would accomplish the desired behavior.</p>
<p>The book devotes considerable focus to examples. These are presented as full-fledged compilable programs in the form of &quot;listings.&quot; For example, Chapter 2 alone presents 15 complete programs. Additionally, there are lots of &quot;code snippets&quot; to think about in the text. Note that there are no exercises to be found in the book. Any serious reader will be busy experimenting with changes to the given code, thus there is no lack of exercise.</p>
<p>Object-oriented programming is the main theme of the second part. The starting point is a chapter on functions as a modularization tool. A special focus here is on the use of <B>const</B>. This seems appropriate, as &quot;const correctness&quot; is not just a practice for the overly conscientious; it is something all programmers should strive for at all times. In my opinion Chapter 8 is one of the most important, as it explains the central ideas of software engineering in more detail: cohesion, coupling, data encapsulation, and information hiding, the latter two being distinguished from one another. Let me briefly discuss this distinction Shtern introduces.</p>
<p>The book states that data encapsulation is more about readability and independence of program components than about protection from unauthorized changes. For example, consider a class with accessors and mutators for all its data elements (which are private, of course), but no other member functions. Data is encapsulated, but by calling an accessor function it is still possible to change data in erroneous ways. The lesson is that data encapsulation does not necessarily protect against erroneous data changes. In this sense encapsulation does not help much (apart from allowing access to data elements without knowing their names). Furthermore, the information is not hidden. If a more complex operation is necessary, it is the client code that must accomplish the task. If we had a member function for this task, we would have hidden the information on how to accomplish it. Thus, according to <I>Core C++,</I> information hiding is accomplished if the application domain is separated from the data design. In that case the client code states what is done, the server code defines how it is done.</p>
<p>This chapter contains something else that other books often hide away from the novices eye: useless, if not bad, code &#151; to make sure a beginner will be able to tell good style from bad. In the following chapters classes and operator functions are discussed as well as &quot;special&quot; member functions such as constructors and their complementary functions, destructors.</p>
<p>The third part shows how to combine and extend existing classes, in other words, how class aggregation and inheritance work. You&#146;ll also find information on data members with special properties, such as constant and reference members. Chapter 12 shows how to create a class that holds a reference to an object of its own type as a data member <a href="#1">[1]</a>. This is one of the examples of detailed description not often found in most programming texts.</p>
<p>This chapter also emphasizes that there&#146;s more to object-oriented programming than using inheritance and polymorphism. In fact, at times class aggregation is the more appropriate way to express a relationship between classes; though it may not be obvious, aggregating classes is undoubtedly an object-oriented approach. This part closes with a chapter on code reuse and a brief introduction to UML. The UML part is just a very brief introduction but nonetheless useful: you&#146;ll understand basic UML diagrams when you encounter them later. And you&#146;re pretty likely to do so sooner or later, if you&#146;re following the software engineering path.</p>
<p>The last part is entitled &quot;Advanced uses of C++.&quot; Virtual functions are presented as well as templates, exceptions, and multiple inheritance. The chapter on advanced operator overloading gives information on I/O operators and how to use them with user-defined classes. The introduction to exceptions in this part of the book introduces only basic information about them.</p>
<p>Compared to the rest of the book, this part leaves some points to be desired: whereas other chapters are generous with do&#146;s and don&#146;ts, this one keeps a bit quiet. A paragraph or two on exception safe and exception neutral code would come in handy. I could well imagine an &quot;alert box&quot; stating that an exception must never ever be allowed to leave a destructor <a href="#2">[2]</a>. The last and final chapter summarizes &quot;What We Have Learned&quot; &#151; which turns out to be quite a lot. The book closes with a comparison of C++ and other languages: COBOL, PL/1, &quot;Virtual Basic&quot; <a href="#3">[3]</a>, C &#151; and of course, Java.</p>

<H3><FONT COLOR="#000080">Conclusion</FONT></H3>

<p>In summary, the book introduces readers to software engineering as well as C++. Reading it is a pleasure. <I>Core C++</I> comprehensively covers the discussed material and also presents material that is not always explained in books intended for beginners.</p>
<p>The informal style makes reading Shtern&#146;s book quite a bit of fun. But note that I am not claiming it is an &quot;easy reader,&quot; as the covered material is complex at times. And working through this material is the price to pay for a thorough understanding of C++. <I>Core C++</I> is worthwhile reading for beginning, intermediate, and advanced programmers. If I had to recommend a single book to students learning C++, it would certainly be <I>Core C++</I>.</p>

<H3><FONT COLOR="#000080">Notes</FONT></H3>

<p><a name="1"></a>[1]  The book also recommends not using this feature unless you absolutely have to.</p>
<p><a name="2"></a>[2]  Herb Sutter. <I>Exceptional C++</I> (Addison-Wesley, 2000). Lecture 16 (in the German translation).</p>
<p><a name="3"></a>[3]  I really like that typo!</p>

<p><i><B>Stephan K&auml;mper</B> started programming some 17 years ago, using C++ intensively since 1997. He studied physics in Bonn and received a diploma in physics from the University of Osnabrck. He has worked in the fields of holography and oceanography and will be working on software quality assurance in the future. He can be reached at <B>Stephan.Kaemper@t-online.de</B>.</i></p>

</blockquote></body></html>
