<html><HEAD>
<TITLE>March 2001/Using Template Functions to Customize Library Behavior/Sidebar</TITLE></HEAD>
<BODY BACKGROUND="" BGCOLOR="#FFFFFF" TEXT="#000000">

<H3 align=center><FONT COLOR="#000080">Understanding Function Template Selection</FONT></H3>

<HR>

<BLOCKQUOTE>
<p>In C++, a more specialized version of a class template is called a <I>partial specialization.</I> While the syntax for specialized function templates is the same as for partial specializations, the behavior can be somewhat different. Hence, the term &quot;partial specialization&quot; is not used with regard to functions. While class templates are partially specialized, functions are simply overloaded. The function template overload a compiler chooses in response to a particular call depends on the concept of which one is &quot;more specialized&quot; than the others. The process is similar to selecting one candidate over the other if and only if the set of all functions possibly generated from the selectee is a proper subset of another.</p>
<p>For example, consider these two function templates:</p>

<pre>
template&lt;class T&gt;
void foo(T t);
 
template&lt;class T&gt;
void foo(std::vector&lt;T&gt; t);
</pre>

<p>Of these two, the second would be considered more specialized than the first. When considering the first function template, the compiler could generate a function with distinct types starting out like this:</p>

<pre>
void foo(int t);
void foo(float t);
void foo(std::string t);
...
</pre>

<p>For the second, the compiler could generate:</p>

<pre>
void foo(std::vector&lt;int&gt; t);
void foo(std::vector&lt;float&gt; t);
void foo(std::vector&lt;std::string&gt; t);
...
</pre>

<p>Both of these lists could go on forever; they are unbounded sets. In the first list, the parameter can be any distinct type, but in the second, the parameter must be the <B>vector</B> class specialized on a type. Any element in the second list could be used in the first, while the reverse is not true. This makes the second list a proper subset of the first.</p>
<p>Using function templates as described here is intuitive and useful. The subset discussion is a simplification, however, since the criterion for whether a function generated by one template function could be used by another is whether it is considered a match. A &quot;match&quot; means the function parameters arrived at by argument deduction are an exact match, with no implicit conversions. The process by which one function template is preferred over another is called <I>partial ordering.</I> Of course, there are additional rules and special cases for both partial ordering and argument deduction.</p>
<p>There are also areas where the writers of compilers, programs, and standards don&#146;t always agree. It is a good idea to stay away from these areas. For example, consider these two function templates:</p>

<pre>
template&lt;class T&gt;
int foo(T t);

template&lt;class T&gt;
int foo(const T&amp; t);
</pre>

<p>Given a call to these functions, such as the following:</p>

<pre>
MyClass mc;
foo(mc);
</pre>

<p>some compilers will report that the call <B>foo(mc)</B> is ambiguous. Others will compile just fine and pick the second function for execution.</p>
<p>Here is another example:</p>

<pre>
template&lt;class T&gt;
int foo(T*);

template&lt;class T&gt;
int foo(T&amp;);
</pre>

<p>Given this call:</p>

<pre>
MyClass * mc = new MyClass();
foo(mc);
</pre>

<p>different compilers will report that <B>foo(mc)</B> is ambiguous, or compile but disagree with each other about which function actually gets called. Staying away from these fringe areas will make you a happier engineer. For a more precise description of the rules on how function templates are selected, see the C++ Standard under &quot;Partial Ordering of Function Templates&quot; (Chapter 14, Section 5.5.2) and &quot;Template Argument Deduction&quot; (Chapter 14, Section8.2).</p></blockquote></body></html>
