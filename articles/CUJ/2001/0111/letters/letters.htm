<HTML>   
     <HEAD>
<TITLE>November 2001/We Have Mail</TITLE></HEAD>
<BODY BACKGROUND="" BGCOLOR="#FFFFFF" TEXT="#000000">
<H2><A HREF="../tocnov.htm"></A><FONT COLOR="#FF0000">   Departments</FONT></H2>

<HR>

<H2 ALIGN="center"><FONT COLOR="#800000">We Have Mail</FONT></H2>

<HR>
<BLOCKQUOTE>
<p><I>Letters to the editor may be sent via email to </I><B>cujed@cmp.com</B><I>, or via the postal service to Letters to the Editor, </I>C/C++ Users Journal<I>, 1601 W. 23rd St., Ste 200, Lawrence, KS 66046-2700.</I></p>

<hr><p>Dear <I>CUJ</I>,</p>
<p>First of all, I would like to thank you and the <I>CUJ</I> team for creating such a wonderful publication. I look forward to receiving it every month and immediately devour every single word.</p>
<p>Secondly, I would like to plead with you to not go the way of <I>VCDJ</I>. I used to have a subscription to <I>VCDJ</I>, but they slowly moved to C#, COM, etc. The past few issues I received, I could not find a single article I found interesting or remotely practical. So I canceled my subscription.</p>
<p>I consider myself a well-versed developer, but a practical one as well: C/C++, SQL, Perl, PHP, Java, etc. However, I avoid platform-specific technologies, since I find them to be too limiting in most cases.</p>
<p>I can only hope that the C# article was not foreshadowing a slow decline into the dark and dreary realm of <I>VCDJ</I>.</p>
<p>Thanks,</p>
<p>Justin Kirby</p>

<p><I>We appreciate the praise and the warning. </I>CUJ<I> will continue to be primarily concerned with C and C++. Since C# is a language related in some way to both, we will occasionally run articles about it, like we have Java in the past (which now appear mainly in our </I>Java Solutions<I> supplement). But don&#146;t worry, we keep our eyes on the mainstream. Thanks again. &#151;cda</I></p>

<hr><p>Hello,</p>
<p>In the May 2001 issue there was an article about sockets (&#147;Two Classes for Simple Socket Programming&#148; by Richard Smereka). I downloaded the code from &lt;www.cuj.com&gt; from the archives just today, and I noticed an error in the file <B>flsocket.h</B>. Instead of <B>#define NO_FLAGS 0</B>, you have <B>#define NO_FLAG 0</B>. This is a small error, but stops the sockets from being compiled.</p>
<p>Thanks,</p>
Jordan Wilberding</p>

<p><I>Jordan,</I></p>
<p><I>This error was noticed too late to be corrected in the magazine article. You are correct. </I><B>NO_FLAG</B><I> should be changed to </I><B>NO_FLAGS</B><I> in the header </I><B>flsocket.h</B><I>.</I></p>
<p><I>Rick Smereka</I></p>

<hr><p>Mr. Chuck Allison,</p>
<p>I have read your article, &#147;import java.*: Threads 101&#148; in the <I>Java Solutions</I> supplement to <I>C/C++ Users Journal</I> (June 2001). You mention &#147;communication through callbacks&#148; in the summary.</p>
<p>I don&#146;t know the meaning of &#147;communication through callbacks&#148; with threads.</p>
<p>Please let me know where I can find the materials concerning callbacks with threads, and in addition, the concept of thread pooling.</p>
<p>Thanks in advance.</p>
<p>Koji Kotaki</p>

<p><I>A very good explanation is in the Threading chapter of Elliotte Rusty Harold&#146;s book, </I>Java Network Programing<I> (O&#146;Reilly &amp; Associates, 2000). Also, see the books </I>Java Threads<I> by Oaks (O&#146;Reilly &amp; Associates, 1999), and </I>Concurrent Programming in Java<I>, Second Edition, by Lea (Addison-Wesley, 1999). &#151; cda</I></p>

<hr><p>Dear Mr. Allison,</p>
<p>Regarding your editorial complaint of August 2001 (about the &#147;misuse&#148; of functor), I think you are forgetting that youth changes the language. What was once a bundle of sticks became a derogatory term for person of the same sex persuasion. So to what was once a transformation that mapped a function to a function has become a class with an <B>operator</B>, which has as it&#146;s sole purpose been a replacement for a free standing function with local memory, functor.</p>
<p>Language changes over time and old timers cringe, such it has always been. No amount of complaint will stem the tide.</p>
<p>Sincerely,</p>
<p>Gary Powell</p>

<hr><p>Dear <I>CUJ</I>,</p>
<p>In the August 2001 issue of <I>CUJ</I>, I see that things like &#147;realator&#148; make you cringe. Then I see in the August 2001 <I>Java Solutions</I> a guy named Chuck Allison crowing that Allen Holub (good choice, btw) &#147;...will take the reigns as editor....&#148; Does this imply that Allen has a split personality, or that he will succeed himself concurrently, or some other, trickier route? (See &lt;www.dictionary.com/cgi-bin/dict.pl?term=reign&gt;.)</p>
<p>I can see how the editor might think of himself as the exerciser of sovereign power at times (bit of a circular definition that), but plural? Maybe you meant &lt;www.dictionary.com/cgi-bin/dict.pl?term=rein&gt;. Two of which are commonly used to steer a horse?</p>
<p>Hoist by your own petard (French for spell checker), so to speak?</p>
<p>David Callaway</p>

<p><I>Good eye! You got me good!</I></p>
<p><I>The cringing was not so much against human error (&#147;realator&#148;) as much as it was against muddying the waters of technical terminology (&#147;functor&#148;). But thanks for the zinger! &#151; cda</I></p>

<hr><p>Chuck,</p>
<p>Your otherwise excellent article &#147;import java.*: Threads 101&#148; in the June 2001 issue of <I>Java Solutions</I> was flawed by the mention of the pronunciation of the word &#147;daemon&#148; as being &#147;DAY-mun.&#148; Check your dictionary &#151; the word is a variation of &#147;demon&#148; and is pronounced &#147;DEE-mun.&#148; (See the online Merriam-Webster dictionary &lt;www.m-w.com/cgi-bin/dictionary?book=Dictionary&amp;va=demon&gt;.) It uses the rare &#147;ae&#148; vowel combination, as do the words &#147;Caesar,&#148; &#147;antennae,&#148; &#147;florae,&#148; &#147;aeon,&#148; &#147;aegis,&#148; and many other words derived from Latin. The &#147;ae&#148; in all of these words is pronounced &#147;ee,&#148; not &#147;ay.&#148;</p>
<p>The inventors of daemon processes, going back to the early history of CTSS, chose the word to specify a special class of processes that ran continuously in the background, such as print spoolers and communication gateways. I suppose they preferred the more archaic looking &#147;daemon&#148; over the more modern &#147;demon&#148; probably thinking the former would have less negative connotations. They pronounced it &#147;DEE-mon,&#148; by the way.</p>
<p>I&#146;ve often heard &#147;daemon&#148; mispronounced, and I&#146;ve done my best to correct the speaker at the time. Please don&#146;t promote this particular illiteracy any further.</p>
<p>Other links:</p>
<p>&lt;www.ctrl-c.liu.se/~ingvar/jargon/d.html#daemon&gt;</p>
<p>&lt;www.tuxedo.org/~esr/jargon/jargon.html#daemon&gt;</p>
<p>&lt;www.funet.fi/pub/mirrors/wombat.doc.ic.ac.uk/foldoc/Dictionary&gt;</p>
<p>David R Tribble</p>

<p><I>Guilty as charged. I succumbed to trusting a certain book, when in fact I had pronounced it correctly way back in my Unix days. As another reader suggested, &#147;the Devil made me do it!&#148; Thanks for setting me (and hopefully others) straight. &#151; cda</I></p>

<hr><p>Dear Chuck,</p>
<p>First, I would like to congratulate you as being named Senior Editor of <I>C/C++ Users Journal</I>. I&#146;ve been subscribing to the journal since 1994, and I&#146;ve also enjoyed attending your seminars at the SD conferences over the past four years.</p>
<p>I facilitate a Java Users Group here in New Jersey (please visit &lt;www.redlich.net/javasig/&gt; for more info), and I was asked an interesting question at the last meeting. It had to do with the use of the <B>this</B> &#147;function&#148; call in the default constructor versus using setter methods with default values. Here is a snippet of what I mean:</p>

<pre>
class Rational
  {
  ...

  // default constructor
  public Rational()
    {
    this(0,0);
    // setNumerator(0);
    // setDenominator(0);
    // setResult(0);
    }

  // primary constructor
  public Rational(int numerator,
    int denominator)
    {
    setNumerator(numerator);
    setDenominator(denominator);
    setResult(numerator,
      denominator);
    }
  ...
  }
</pre>

<p>Is there really any difference using <B>this(0,0)</B> in the default constructor over just calling the setter methods? The only thing I can think of is an additional function call because <B>this(0,0)</B> will call the primary constructor, which calls the three setter methods there.</p>
<p>Thanks in advance for your help.</p>
<p>Regards,</p>
<p>Mike Redlich</p>

<p><I>I don&#146;t see a noticeable difference. You might generate the byte code and inspect it just for fun. I assume you know that all primitive members are zero-initialized anyway, so the no-arg constructor is not necessary at all. If that is not to your liking, you can always use an anonymous, non-static constructor block as a shared constructor. See my July 1999 </I>CUJ<I> column, &#147;import java.*: Thinking in Objects&#148; (&lt;www.cuj.com/java/allison/july99.htm?topic=java&gt;). Cheers &#151; cda</I></p>

<hr><p>Hello,</p>
<p>I read you editorial in the August 2001 issue of <I>Java Solutions</I> and your request for reader&#146;s thoughts on productivity in Java. Truthfully I was shocked that no one had responded to Marc&#146;s original inquiry, so I decided I should throw my two cents in. </p>
<p>My time at work is split (almost evenly) between writing in Java and C++. Personally I would rather work full time in C++ (better development tools, the language is more versatile, etc.), but I certainly don&#146;t mind working in Java.</p>
<p>The library support in Java makes life much easier when it comes to certain types of programming. Internet/socket programming immediately comes to mind. Although there are libraries in C/C++ to accomplish the same tasks, the Java libraries are standard, and that makes it easier to look at code examples that use it, because it will be implemented pretty much the same from programmer to programmer. Also, a lot of thought was put into Java&#146;s I/O mechanisms, and the socket libraries show this by how well the fit together.</p>
<p>Granted, the Java libraries are cumbersome and hard to get used to, but a wealth of documentation exists on the Web, and it is usually pretty easy to find the information you are looking for.</p>
<p>My only real complaint about Java is the garbage collector. I understand and appreciate the concept of trying to keep the developer from leaking memory, but it really makes me uncomfortable to just &#147;trust the JVM.&#148; I suppose I will have a similar feeling once I begin working in C#.</p>
<p>The most common complaint I hear (and I used to say also) about Java is its performance compared to compiled languages. I still feel this is a valid argument, but every day it loses some steam. Advances in JVMs have brought great speed increases, but the greatest improvement is the time spent in Java. Like most languages/CPUs/APIs, when there is a new widget on the market, it takes a while to learn about it and its intricacies. People used to (and still do to some extent) slam C++ for being a bloated, inefficient C. As time has marched on, this argument has lost it potency. The same holds true with Java. As developers learn the ins and outs of Java (like don&#146;t use <B>Vector</B> where you can use <B>ArrayList</B>), we will see Java gain more acceptance. </p>
<p>Nick Loadholtes</p>

<hr><p>This is in regards to Table 1 on page 62 of the article by Andrew Koenig and Barbara E. Moo (&#147;C++ Made Easier: Which Container Should I Use?&#148;, <I>CUJ</I>, August 2001) about the STL sequential containers.</p>
<p>The table states that the space overhead for a deque is &#147;fixed per container.&#148; The table states that the space overhead for a vector is &#147;usually a constant multiple of the container size.&#148; Given even my limited exposure to implementation details for those containers, I believe those table entries are incorrect and should be reversed.</p>
<p>Could this belief either be confirmed or denied?</p>
<p>Brian F. Seaberg</p>

<p><I>I believe that the table is correct, but perhaps we don&#146;t have the same understanding about what it means.</I></p>
<p><I>Suppose </I><B>c</B><I> is an empty container, and we execute </I><B>c.push_back(x)</B><I> some number of times. The question is how much memory the container reserves for elements that might be appended to the container in the figure, but haven&#146;t been yet.</I></p>
<p><I>For a vector, that answer is a multiple of the number of elements already in the vector. The multiple may be less than one, but it&#146;s still a multiple. The reason is that each time the vector grows, it does so by allocating a multiple of the number of elements already in the container.</I></p>
<p><I>For a deque, the typical implementation is to use fixed-sized blocks. The wastage is therefore only the unused portion of the first and last block, which is bounded by a constant regardless of how many elements are in the container.</I></p>
<p><I>That is the sense in which we intended the table to be interpreted.</I></p>
<p><I>Regards,</I></p>
<p><I>Andrew Koenig</I></p>

<hr><p>Cristian,</p>
<p>There&#146;s an error in your article, &#147;Generalizing the Concepts Behind <B>auto_ptr</B>,&#148; (<I>CUJ</I>, August 2001) that I leave to you to generalize. Basically, the problem is that:</p>

<pre>
fclose(0);
</pre>

<p>crashes &#151; don&#146;t remember about Unix, but definitely on Win32.</p>
<p>Here&#146;s your code from pp.38-39 plus <B>crashHere</B> plus <B>main</B> that compiles (and explodes) under Microsoft Visual C++ 6.0:</p>

<pre>
// &#151;&#151;- crash_test.cpp
#include &lt;stdio.h&gt;

// &#151;&#151; your part:
template&lt;class H&gt; struct handle_traits {
 static void dispose(H) throw();
 static H null_value();
};
template&lt;&gt; void
handle_traits&lt;FILE*&gt;::dispose
 (FILE* fp) throw() {
 fclose(fp);
}
template&lt;&gt; FILE*
 handle_traits&lt;FILE*&gt;::null_value() {
 return 0;
};
template&lt;class H,
 class T = handle_traits&lt;H&gt; &gt;
class auto_handle {
public:
 explicit auto_handle
  (const H&amp; h = T::null_value()) throw() :
handle_(h) {}
 ~auto_handle() throw() {
  T::dispose(handle_);
 }
 H get() const throw() {
  return handle_;
 }
private:
 H handle_;
};

// &#151;&#151; my part:
void crashHere() {
 // zeroed in ctor, fclosed in dtor ???
 auto_handle&lt;FILE*&gt; hF;  
}

void main() {
 crashHere();
}
// &#151;&#151; end of crash_test.cpp
</pre>

<p>A safe destructor should be</p>

<pre>
template&lt;&gt; void
handle_traits&lt;FILE*&gt;::dispose
 (FILE* fp) throw() {
 if(fp !=
  handle_traits&lt;FILE*&gt;::null_value())
  fclose(fp);
}
</pre>

<p>Thanks for a <I>very</I> interesting article, anyway. The <B>ref(42)</B> trick is brilliant.</p>
<p>Alex Shvedov</p>

<p><I>Good catch, Alex!</I></p>
<p><I>Indeed, the safe (and correct) specialization for </I><B>handle_traits&lt;FILE*&gt;::dispose</B><I> needs to check for the </I><B>null_value</B><I>. This is a notable difference between </I><B>auto_ptr</B><I> and </I><B>auto_handle</B><I>. Since invoking delete on a null pointer has no effect, </I><B>~auto_ptr</B><I> doesn&#146;t have to worry about checking for a null pointer.</I></p>
<p><I>I also checked on MSDN for </I><B>DeleteObject</B><I> and was happy to find out that my </I><B>HBRUSH</B><I> example is not plagued by the same bug. The deletion of the GDI object will just silently fail: &#147;If the specified handle is not valid or is currently selected into a DC, the return value is zero.&#148;</I></p>
<p><I>Just out of curiosity, I tried </I><B>fclose(0)</B><I> on Linux, where it crashes with a segmentation fault, and on a DEC machine running OSF/1 where it nicely returned a </I><B>-1</B><I>, and </I><B>errno</B><I> was set to </I><B>EBADF</B><I> (indicating that the file descriptor underlying the stream parameter is not valid).</I></p>
<p><I>I apologize for my email address missing from the bio info. (I thought I put it there, but it looks like for some reason it got omitted).</I></p>
<p><I>Thanks for your appreciation and for taking the time to bring the bug to my attention.</I></p>
<p><I>Cristian Vlasceanu</I></p>
</blockquote></body></html>
