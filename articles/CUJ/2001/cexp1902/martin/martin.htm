<HTML>   
     <HEAD>
<TITLE>February 2001 C++ Experts Forum/Engineering Notebook</TITLE></HEAD>
<BODY BACKGROUND="" BGCOLOR="#FFFFFF" TEXT="#000000">
<H2><A HREF="../../19.02/tocfeb.htm"></A><FONT COLOR="#FF0000">   C++ Experts Forum</FONT></H2>

<HR>

<H2 ALIGN="center"><FONT COLOR="#800000">Engineering Notebook: An Extreme Programming Episode</FONT></H2>
<H3 ALIGN="center"><FONT COLOR="#800000">Robert C. Martin and Robert S. Koss</FONT></H3>

<HR>
<BLOCKQUOTE>


<P><B>This article is derived from a chapter of the forthcoming book <I>Advanced Principles, Patterns and Process of Software Development</I>, Robert C. Martin, Prentice Hall, 2001. Copyright &copy; 2000 by Robert C. Martin, all rights reserved.</B></P>
<P><i>Design and programming are human activities; forget that and all is lost.</i><br>
Bjarne Stroustrup, 1991</P>
<P>In order to demonstrate XP (eXtreme Programming) practices, Bob Koss (RSK) and Bob Martin (RCM) will pair program a simple application while you watch like a fly on the wall. We will use test first design and a lot of refactoring to create our application. What follows is a faithful re-enactment of a programming episode that the two Bob's actually did.</P>
<P><B>RCM:</B> "Will you help me write a little application that calculates bowling scores?"</P>
<P><B>RSK:</B> (Reflects to himself: The XP practice of pair programming says that I can't say no, when asked to help. I suppose that's especially true when it is your boss who is asking.) "Sure Bob, I'd be glad to help."</P>
<P><B>RCM:</B> "OK, Great. What I'd like to do is write an application that keeps track of a bowling league. It needs to record all the games, determine the ranks of the teams, determine the winners and losers of each weekly match, and accurately score each game."</P>
<P><B>RSK:</B> "Cool. I used to be a pretty good bowler. This will be fun. You rattled off several user stories, which one would you like to start with."</P>
<P><B>RCM:</B> "Let's begin with scoring a single game."</P>
<P><B>RSK:</B> "Okay. What does that mean? What are the inputs and outputs for this story?"</P>
<P><B>RCM:</B> "It seems to me that the inputs are simply a sequence of throws. A throw is just an integer that tells how many pins were knocked down by the ball. The output is the data on a standard bowling score card, a set of frames populated with the pins knocked down by each throw, and marks denoting spares and strikes. The most important number in each frame is the current game score."</P>
<P><B>RSK: </B>"Let me sketch out a little picture of this score card to give us a visual reminder of the requirements." (See <a href="fig1.htm">Figure 1</a>.)</P>
<P><B>RCM: </B>"That guy is pretty erratic."</P>
<P><B>RSK: </B>"Or drunk, but it will serve as a decent acceptance test."</P>
<P><B>RCM: </B>"We'll need others, but let's deal with that later. How should we start? Shall we come up with a design for the system?"</P>
<P><B>RSK: </B>"Well, don't hate me, but I wouldn't mind a UML diagram showing the problem domain concepts that we might see from the score card. That will give us some candidate objects that we can explore further in code."</P>
<P><B>RCM: </B>(Putting on his powerful object designer hat) "OK, clearly a game object consists of a sequence of ten frames. Each frame object contains one, two, or three throws."</P>
<P><B>RSK: </B>"Great minds. That was exactly what I was thinking. Let me quickly draw that, but if you tell Kent, I'll deny it." (See <a href="fig2.htm">Figure 2</a>.)</P>
<B><P>Kent:</B> <I>"I'm always watching."</I></P>
<P><B>RSK: </B>"Well, pick a class ... any class. Shall we start at the end of the dependency chain and work backwards? That will make testing easier."</P>
<P><B>RCM: </B>"Sure, why not. Let's create a test case for the <B>Throw</B> class."</P>
<P><B>RSK: </B>(Starts typing)</P>

<pre>
<b>//TestThrow.java---------------------------------
import junit.framework.*; 

public class TestThrow extends TestCase
{
  public TestThrow(String name)
  {
    super(name);
  }
// public void test????
}</b>
</pre>

<P><B>RSK: </B>"Do you have a clue what the behavior of a <B>Throw</B> object should be?"</P>
<P><B>RCM: </B>"It holds the number of pins knocked down by the player."</P>
<P><B>RSK: </B>"Okay, you just said in not so many words that it doesn't really do anything. Maybe we should come back to it and focus on an object that actually has behavior, instead of one that's just a data store."</P>
<P><B>RCM: </B>"Hmm. You mean the <B>Throw</B> class might not really exist?"</P>
<P><B>RSK: </B>(Starts to sweat. This is my boss I'm working with.) "Well, if it doesn't have any behavior, how important can it be? I don't know if it exists or not yet. I'd just feel more productive if we were working on an object that had more than setters and getters for methods. But if you want to drive..." (slides the keyboard to RCM).</P>
<P><B>RCM: </B>"Well, let's move up the dependency chain to <B>Frame</B> and see if there are any test cases we can write that will force us to finish <B>Throw</B>." (Pushes the keyboard back to RSK.)</P>
<P><B>RSK: </B>(Wondering if RCM is leading me down a blind alley to educate me or if he is really agreeing with me) "Okay, new file, new test case."</P>

<pre>
<b>//TestFrame.java------------------------------------
import junit.framework.*;

public class TestFrame extends TestCase
{
  public TestFrame( String name )
  {
    super( name );
  }

  //public void test???
}</b> 
</pre>


<P><B>RCM: </B>"OK, that's the second time we've typed that. Now, can you think of any interesting test cases for <B>Frame</B>?"</P>
<P><B>RSK: </B>"A frame might provide its score, the number of pins on each throw, whether there was a strike or a spare..."</P>
<P><B>RCM: </B>"Too much talk, not enough code. Type!"</P>
<P><B>RSK: </B>(types)</P>

<pre>
//TestFrame.java---------------------------------
import junit.framework.*;

public class TestFrame extends TestCase
{
  public TestFrame( String name )
  {
    super( name );
  }

<b>  public void testScoreNoThrows()
  {
    Frame f = new Frame();
    assertEquals( 0, f.getScore() );
  }</b>
} 

<b>//Frame.java---------------------------------------
public class Frame
{
  public int getScore() 
  {
    return 0;
  }
}</b>
</pre>

<P><B>RCM: </B>"OK, the test case passes. But <B>Score</B> is a really stupid function. It will fail if we add a throw to the frame. So let's write the test case that adds some throws and then checks the score."</P>

<pre>
//TestFrame.java---------------------------------

<b>public void testAddOneThrow()
{
  Frame f = new Frame();
  f.add(5);
  assertEquals(5, f.getScore());
}</b>
</pre>

<P><B>RCM: </B>"That doesn't compile. There's no <B>add</B> method in <B>Frame</B>."</P>
<P><B>RSK: </B>"I'll bet if you define the method it will compile."</P>
<P><B>RCM:</B></P>

<pre>
//Frame.java---------------------------------------
public class Frame
{
  public int getScore()
  {
    return 0;
  }

<b>  public void add(Throw t)
  {
  }</b>
}
</pre>

<P><B>RCM:</B> (Thinking out loud) "This doesn't compile because we haven't written the <B>Throw</B> class."</P>
<P><B>RSK: </B>"Talk to me, Bob. The test is passing an integer, and the method expects a <B>Throw</B> object. You can't have it both ways. Before we go down the <B>Throw</B> path again, can you describe its behavior?"</P>
<P><B>RCM: </B>"Wow! I didn't even notice that I had written <b>f.add(5)</b>. I should have written <b>f.add(new Throw(5))</b>, but that's ugly as hell. What I <I>really</I> want to write is <b>f.add(5)</b>."</P>
<P><B>RSK: </B>"Ugly or not, let's leave aesthetics out of it for the time being. Can you describe any behavior of a <B>Throw</B> object &#151; binary response, Bob?"</P>
<P><B>RCM: </B>"101101011010100101. I don't know if there is any behavior in <B>Throw</B>; I'm beginning to think a <B>Throw</B> is just an <B>int</B>. However, we don't need to consider that yet, since we can write <B>Frame.add</B> to take an <B>int</B>."</P>
<P><B>RSK: </B>"Then I think we should do that for no other reason than it's simple. When we feel pain, we can do something more sophisticated."</P>
<P><B>RCM: </B>"Agreed."</P>

<pre>
//Frame.java---------------------------------------
public class Frame
{
  public int getScore()
  {
    return 0;
  }

  public void add(<b>int pins</b>)
  {
  }
}
</pre>

<P><B>RCM: </B>"OK, this compiles and fails the test. Now, let's make the test pass."</P>

<pre>
//Frame.java---------------------------------------
public class Frame
{
  public int getScore()
  {
    <b>return itsScore;</b>
  }

  public void add(int pins)
  {
    <b>itsScore += pins;</b>
  }
  <b>private int itsScore = 0;</b>
}
</pre>

<P><B>RCM: </B>"This compiles and passes the tests. But it's clearly simplistic. What's the next test case?"</P>
<P><B>RSK: </B>"Can we take a break first?"</P>

<hr>

<P><B>RCM: </B>"That's better. <B>Frame.add</B> is a fragile function. What if you call it with an 11?"</P>
<P><B>RSK: </B>"It can throw an exception if that happens. But who is calling it? Is this going to be an application framework that thousands of people will use and we have to protect against such things, or is this going to be used by you and only you? If the latter, just don't call it with an 11" (chuckle).</P>
<P><B>RCM: </B>"Good point, the tests in the rest of the system will catch an invalid argument. If we run into trouble, we can put the check in later. So, the add function doesn't currently handle strikes or spares. Let's write a test case that expresses that."</P>
<P><B>RSK: </B>"Hmmmm... if we call <B>add(10)</B> to represent a strike, what should <B>getScore</B> return? I don't know how to write the assertion, so maybe we're asking the wrong question. Or we're asking the right question to the wrong object."</P>
<P><B>RCM: </B>"When you call <B>add(10)</B>, or <B>add(3)</B> followed by <B>add(7)</B>, then calling <B>getScore</B> on the <B>Fram</B>e is meaningless. The frame would have to look ahead at later frames to calculate its score. If those later frames don't exist, then it would have to return something ugly like -1. I don't want to return -1."</P>
<P><B>RSK: </B>"Yeah, I hate the -1 idea too. You've introduced the idea of frames knowing about other frames. Who is holding these different frame objects?"</P>
<P><B>RCM: </B>"The <B>Game</B> object."</P>
<P><B>RSK: </B>"So <B>Game</B> depends on <B>Frame</B>, and <B>Frame</B> in turn depends on <B>Game</B>. I hate that."</P>
<P><B>RCM: </B>"<B>Frame</B>s don't have to depend upon <B>Game</B>; they could be arranged in a linked list. Each frame could hold pointers to its next and previous frames. To get the score from a frame, the frame would look backwards to get the score of the previous frame and look forwards for any spare or strike balls it needs."</P>
<P><B>RSK: </B>"Okay, I'm feeling kind of dumb because I can't visualize this. Show me some code, boss."</P>
<P><B>RCM: </B>"Right. So, we need a test case first."</P>
<P><B>RSK: </B>"For <B>Game</B> or another test for <B>Frame</B>?"</P>
<P><B>RCM: </B>"I think we need one for <B>Game</B>, since it's <B>Game</B> that will build the frames and hook them up to each other."</P>
<P><B>RSK: </B>"Do you want to stop what we're doing on <B>Frame</B> and do a mental long jump to <B>Game</B>, or do you just want to have a <B>MockGame</B> object that does just what we need to get <B>Frame</B> working?"</P>
<P><B>RCM: </B>"No, let's stop working on <B>Frame</B> and start working on <B>Game</B>. The test cases in <B>Game</B> should prove that we need the linked list of <B>Frame</B>s."</P>
<P><B>RSK: </B>"I'm not sure how they'll show the need for the list. I need code."</P>
<P><B>RCM:</B></P>
<pre>
<b>//TestGame.java------------------------------------------
import junit.framework.*;

public class TestGame extends TestCase
{
  public TestGame(String name)
  {
    super(name);
  }

  public void testOneThrow()
  {
    Game g = new Game();
    g.add(5);
    assertEquals(5, g.score());
  }
}</b>
</pre>

<P><B>RCM: </B>"Does that look reasonable?"</P>
<P><B>RSK: </B>"Sure, but I'm still looking for proof for this list of <B>Frame</B>s."</P>
<P><B>RCM: </B>"Me too. Let's keep following these test cases and see where they lead."</P>

<pre>
<b>//Game.java----------------------------------
public class Game
{
  public int score()
  {
    return 0;
  }
  
  public void add(int pins)
  {
  }
}</b>
</pre>

<P><B>RCM: </B>"OK, this compiles and fails the test. Now let's make it pass."</P>

<pre>
//Game.java----------------------------------
public class Game
{
  public int score()
  {
    <b>return itsScore;</b>
  }

  public void add(int pins)
  {
    <b>itsScore += pins;</b>
  }
  <b>private int itsScore = 0;</b>
}
</pre>

<P><B>RCM: </B>"This passes. Good."</P>
<P><B>RSK: </B>"I can't disagree with it. But I'm still looking for this great proof of the need for a linked list of frame objects. That's what led us to <B>Game</B> in the first place."</P>
<P><B>RCM: </B>"Yeah, that's what I'm looking for too. I fully expect that once we start injecting spare and strike test cases, we'll have to build frames and tie them together in a linked list. But I don't want to build that until the code forces us to."</P>
<P><B>RSK: </B>"Good point. Let's keep going in small steps on <B>Game</B>. What about another test that tests two throws but with no spare?"</P>
<P><B>RCM: </B>"OK, that should pass right now. Let's try it."</P>

<pre>
//TestGame.java------------------------------------------

<b>public void testTwoThrowsNoMark()
  {
    Game g = new Game();
    g.add(5);
    g.add(4);
    assertEquals(9, g.score());
}</b>
</pre>

<P><B>RCM: </B>"Yep, that one passes. Now let's try four balls, with no marks."</P>
<P><B>RSK: </B>"Well, that will pass too. I didn't expect this. We can keep adding throws, and we don't ever even need a <B>Frame</B>. But we haven't done a spare or a strike yet. Maybe that's when we'll have to make one."</P>
<P><B>RCM: </B>"That's what I'm counting on. However, consider this test case:"</P>

<pre>
//TestGame.java------------------------------------------
<b>public void testFourThrowsNoMark()
  {
    Game g = new Game();
    g.add(5);
    g.add(4);
    g.add(7);
    g.add(2);
    assertEquals(18, g.score());
    assertEquals(9, g.scoreForFrame(1));
    assertEquals(18, g.scoreForFrame(2));
  }</b>
  </pre>

<P><B>RCM: </B>"Does this look reasonable?"</P>
<P><B>RSK: </B>"It sure does. I forgot that we have to be able to show the score in each frame. Ah, our sketch of the score card was serving as a coaster for my Diet Coke. Yeah, that's why I forgot."</P>
<P><B>RCM: </B>(Sigh) "OK, first let's make this test case fail by adding the <B>scoreForFrame</B> method to <B>Game</B>."</P>

<pre>
//Game.java----------------------------------

<b>public int scoreForFrame(int frame)
{
  return 0;
}</b>
</pre>

<P><B>RCM: </B>"Great, this compiles and fails. Now, how do we make it pass?"</P>
<P><B>RSK: </B>"We can start making frame objects. But is that the simplest thing that will get the test to pass?"</P>
<P><B>RCM: </B>"No, actually, we could just create an array of integers in <B>Game</B>. Each call to <B>add</B> would append a new integer onto the array. Each call to <B>scoreForFrame</B> will just work forward through the array and calculate the score."</P>

<pre>
//Game.java----------------------------------
public class Game
{
  public int score()
  {
    return itsScore;
  }

  public void add(int pins)
    {
      <b>itsThrows[itsCurrentThrow++]=pins;</b>
      itsScore += pins;
    }

  public int scoreForFrame(int frame)
    {
    <b>int score = 0;
    for ( int ball = 0; 
      frame &gt; 0 &amp;&amp; (ball &lt; itsCurrentThrow); 
      ball+=2, frame--)
    {
      score += itsThrows[ball] + itsThrows[ball+1];
    }
    return score;</b>
  }
  private int itsScore = 0;
  <b>private int[] itsThrows = new int[21];
  private int itsCurrentThrow = 0;</b>
}
</pre>

<P><B>RCM: </B>(Very satisfied with himself) "There, that works."</P>
<P><B>RSK: </B>"Why the magic number 21?"</P>
<P><B>RCM: </B>"That's the maximum possible number of throws in a game."</P>
<P><B>RSK: </B>"Yuck. Let me guess, in your youth you were a Unix hacker and prided yourself on writing an entire application in one statement that nobody else could decipher.</P>
<P>"<B>scoreForFrame</B> needs to be refactored to be more communicative. But before we consider refactoring, let me ask another question: Is <B>Game</B> the best place for this method? In my mind, <B>Game</B> is violating Bertrand Meyer's SRP (Single Responsibility Principle) <a href="#1">[1]</a>. It is accepting throws <I>and</I> it knows how to score for each frame. What would you think about a <B>Scorer</B> object?"</P>
<P><B>RCM: </B>(Makes a rude oscillating gesture with his hand) "I don't know where the functions live now; right now I'm interested in getting the scoring stuff to work. Once we've got that all in place, <I>then</I> we can debate the values of the SRP.</P>
<P>"However, I see your point about the Unix hacker stuff; let's try to simplify that loop."</P>

<pre>
public int scoreForFrame(int theFrame)
{
  int ball = 0;
  int score=0;
  <b>for (int currentFrame = 0; 
       currentFrame &lt; theFrame; 
       currentFrame++)</b>
  {
    <b>score += itsThrows[ball++] + itsThrows[ball++];</b>
  }

  return score;
}
</pre>

<P><B>RCM: </B>"That's a little better, but there are side-effects in the <B>score+=</B> expression. They don't matter here because it doesn't matter which order the two <B>addend</B> expressions are evaluated in." (Or does it? It's possible that the two increments could be done before either array operations.)</P>
<P><B>RSK: </B>"I suppose we could do an experiment to verify that there aren't any side-effects, but that function isn't going to work with spares and strikes. Should we keep trying to make it more readable or should we push further on its functionality?"</P>
<P><B>RCM: </B>"The experiment would only have meaning on certain compilers. Other compilers might use different evaluation orders. Let's get rid of the order dependency and then push on with more test cases."</P>

<pre>
public int scoreForFrame(int theFrame)
{
  int ball = 0;
  int score=0;
  for (int currentFrame = 0; 
       currentFrame &lt; theFrame; 
       currentFrame++)
  {
    <b>int firstThrow = itsThrows[ball++];
    int secondThrow = itsThrows[ball++];
    score += firstThrow + secondThrow;</b>
  }
  
  return score;
}
</pre>

<P><B>RCM: </B>"OK, next test case. Let's try a spare."</P>

<pre>
<b>public void testSimpleSpare()
{
  Game g = new Game();
}</b>
</pre>

<P><B>RCM: </B>"I'm tired of writing this. Let's refactor the test and put the creation of the game in a <B>setUp</B> function."</P>

<pre>
//TestGame.java------------------------------------------
import junit.framework.*;

public class TestGame extends TestCase
{
  public TestGame(String name)
  {
    super(name);
  }

  <b>private Game g;

  public void setUp()
  {
    g = new Game();
  }</b>

  public void testOneThrow()
  {
    g.add(5);
    assertEquals(5, g.score());
  }

  public void testTwoThrowsNoMark()
  {
    g.add(5);
    g.add(4);
    assertEquals(9, g.score());
  }

  public void testFourThrowsNoMark()
  {
    g.add(5);
    g.add(4);
    g.add(7);
    g.add(2);
    assertEquals(18, g.score());
    assertEquals(9, g.scoreForFrame(1));
    assertEquals(18, g.scoreForFrame(2));
  }

  public void testSimpleSpare()
  {
  }
}
</pre>

<P><B>RCM: </B>"That's better, now let's write the spare test case."</P>
<P><B>RSK: </B>"I'll drive."</P>

<pre>
public int scoreForFrame(int theFrame)
{
  int ball = 0;
  int score=0;
  for (int currentFrame = 0; 
       currentFrame &lt; theFrame; 
       currentFrame++)
  {
    int firstThrow = itsThrows[ball++];
    int secondThrow = itsThrows[ball++];

    int frameScore = firstThrow + secondThrow;
    <b>// spare needs next frames first throw
    if ( frameScore == 10 ) 
      score += frameScore + itsThrows[ball++];
    else
      score += frameScore;</b>
  }

  return score;
}
</pre>

<P><B>RCM: </B>(Grabbing the keyboard) "OK, but I think the increment of ball in the <B>frameScore==10</B> case shouldn't be there. Here's a test case that proves my point."</P>

<pre>
<b>public void testSimpleFrameAfterSpare()
{
  g.add(3);
  g.add(7);
  g.add(3);
  g.add(2);
  assertEquals(13, g.scoreForFrame(1));
  assertEquals(18, g.score());
}</b>
</pre>

<P><B>RCM: </B>"Ha! See, that fails. Now if we just take out that pesky extra increment..."</P>

<pre>
  if ( frameScore == 10 ) 
    score += frameScore + itsThrows[<b>ball</b>];
	</pre>

<P><B>RCM: </B>"Uh, it still fails.... Could it be that the <b>score</b> method is wrong? I'll test that by changing the test case to use <B>scoreForFrame(2)</B>."</P>

<pre>
public void testSimpleFrameAfterSpare()
{
  g.add(3);
  g.add(7);
  g.add(3);
  g.add(2);
  assertEquals(13, g.scoreForFrame(1));
  <b>assertEquals(18, g.scoreForFrame(2));</b>
}
</pre>

<P><B>RCM: </B>"Hmmmm.... That passes. The <B>score</B> method must be messed up. Let's look at it."</P>

<pre>
public int score()
{
  return itsScore;
}

public void add(int pins)
{
  itsThrows[itsCurrentThrow++]=pins;
  itsScore += pins;
}
</pre>

<P><B>RCM: </B>"Yeah, that's wrong. The <b>score</b> method is just returning the sum of the pins, not the proper score. What we need <b>score</B> to do is call <b>scoreForFrame</b> with the current frame."</P>
<P><B>RSK: </B>"We don't know what the current frame is. Let's add that message to each of our current tests, one at a time, of course."</P>
<P><B>RCM: </B>"Right."</P>

<pre>
//TestGame.java------------------------------------------
  public void testOneThrow()
  {
    g.add(5);
    assertEquals(5, g.score());
    <b>assertEquals(1, g.getCurrentFrame());</b>
    }

//Game.java----------------------------------
  <b>public int getCurrentFrame()
  {
    return 1;
  }</b>
  </pre>

<P><B>RCM: </B>"OK, that works. But it's stupid. Let's do the next test case."</P>

<pre>
public void testTwoThrowsNoMark()
{
  g.add(5);
  g.add(4);
  assertEquals(9, g.score());
  <b>assertEquals(1, g.getCurrentFrame());</b>
}
</pre>

<P><B>RCM: </B>"That one's uninteresting; let's try the next."</P>

<pre>
public void testFourThrowsNoMark()
{
  g.add(5);
  g.add(4);
  g.add(7);
  g.add(2);
  assertEquals(18, g.score());
  assertEquals(9, g.scoreForFrame(1));
  assertEquals(18, g.scoreForFrame(2));
  <b>assertEquals(2, g.getCurrentFrame());</b>
}
</pre>

<P><B>RCM: </B>"This one fails. Now let's make it pass."</P>
<P><B>RSK: </B>"I think the algorithm is trivial. Just divide the number of throws by two, since there are two throws per frame. Unless we have a strike ... but we don't have strikes yet, so let's ignore them here too."</P>
<P><B>RCM: </B>(Flails around adding and subtracting one until it works)</P>

<pre>
public int getCurrentFrame()
{
  <b>return 1 + (itsCurrentThrow-1)/2;</b>
}
</pre>

<P><B>RCM: </B>"That isn't very satisfying."</P>
<P><B>RSK: </B>"What if we don't calculate it each time? What if we adjust a <B>currentFrame</B> member variable after each throw?"</P>
<P><B>RCM: </B>"OK, let's try that."</P>

<pre>
//Game.java----------------------------------
  public int getCurrentFrame()
  {
    <b>return itsCurrentFrame;</b>
  }

  public void add(int pins)
  {
    itsThrows[itsCurrentThrow++]=pins;
    itsScore += pins;
    <b>if (firstThrow == true)
    {
      firstThrow = false;
      itsCurrentFrame++;
    }
    else
    {
      firstThrow=true;;
    }</b>
  }

  <b>private int itsCurrentFrame = 0;
  private boolean firstThrow = true;</b>
}
</pre>

<P><B>RCM: </B>"OK, this works. But it also implies that the current frame is the frame of the last ball thrown, not the frame that the next ball will be thrown into. As long as we remember that, we'll be fine."</P>
<P><B>RSK: </B>"I don't have that good of a memory, so let's make it more readable. But before we go screwing around with it some more, let's pull that code out of <B>add</B> and put it in a private member function called <b>adjustCurrentFrame</b> or something."</P>
<P><B>RCM: </B>"OK, that sounds good"</P>

<pre>
  public void add(int pins)
  {
    itsThrows[itsCurrentThrow++]=pins;
    itsScore += pins;
    <b>adjustCurrentFrame();</b>
  }

  <b>private void adjustCurrentFrame()
  {</b>
    if (firstThrow == true)
    {
      firstThrow = false;
      itsCurrentFrame++;
    }
    else
    {
      firstThrow=true;;
    }
  <b>}</b>
</pre>

<P><B>RCM: </B>"Now let's change the variable and function names to be more clear. What should we call <b>itsCurrentFrame</b>?"</P>
<P><B>RSK: </B>"I kind of like that name. I don't think we're incrementing it in the right place though. The current frame, to me, is the frame number that I'm throwing in. So it should get incremented right after the last throw in a frame."</P>
<P><B>RCM: </B>"I agree. Let's change the test cases to reflect that; then we'll fix <b>adjustCurrentFrame</b>."</P>

<pre>
//TestGame.java------------------------------------------
  public void testTwoThrowsNoMark()
  {
    g.add(5);
    g.add(4);
    assertEquals(9, g.score());
    <b>assertEquals(2, g.getCurrentFrame());</b>
  }

  public void testFourThrowsNoMark()
  {
    g.add(5);
    g.add(4);
    g.add(7);
    g.add(2);
    assertEquals(18, g.score());
    assertEquals(9, g.scoreForFrame(1));
    assertEquals(18, g.scoreForFrame(2));
    <b>assertEquals(3, g.getCurrentFrame());</b>
  }
//TestGame.java------------------------------------------
  private void adjustCurrentFrame()
  {
    if (firstThrow == true)
    {
      firstThrow = false;
    }
    else
    {
      firstThrow=true;
      <b>itsCurrentFrame++;</b>
    }
  }

  <b>private int itsCurrentFrame = 1;</b>
}
</pre>

<P><B>RCM: </B>"OK, that's working. Now let's test <B>getCurrentFrame</B> in the two spare cases."</P>

<pre>
  public void testSimpleSpare()
  {
    g.add(3);
    g.add(7);
    g.add(3);
    assertEquals(13, g.scoreForFrame(1));
    <b>assertEquals(2, g.getCurrentFrame());</b>
  }

  public void testSimpleFrameAfterSpare()
  {
    g.add(3);
    g.add(7);
    g.add(3);
    g.add(2);
    assertEquals(13, g.scoreForFrame(1));
    assertEquals(18, g.scoreForFrame(2));
    <b>assertEquals(3, g.getCurrentFrame());</b>
  }
  </pre>

<P><B>RCM: </B>"This works. Now, back to the original problem. We need <b>score</b> to work. We can now write <b>score</b> to call <b>scoreForFrame(getCurrentFrame()-1)</b>.</P>

<pre>
  public void testSimpleFrameAfterSpare()
  {
    g.add(3);
    g.add(7);
    g.add(3);
    g.add(2);
    assertEquals(13, g.scoreForFrame(1));
    assertEquals(18, g.scoreForFrame(2));
    <b>assertEquals(18, g.score());</b>
    assertEquals(3, g.getCurrentFrame());
  }

//Game.java----------------------------------
  public int score()
  <b>{
    return scoreForFrame(getCurrentFrame()-1);</b>
  }
  </pre>

<P><B>RCM: </B>"This fails the <b>TestOneThrow</b> test case. Let's look at it."</P>

<pre>
  public void testOneThrow()
  {
    g.add(5);
    assertEquals(5, g.score());
    assertEquals(1, g.getCurrentFrame());
  }
  </pre>

<P><B>RCM: </B>"With only one throw, the first frame is incomplete. The <b>score</b> method is calling <b>scoreForFrame(0)</b>. This is yucky."</P>
<P><B>RSK: </B>"Maybe, maybe not. Who are we writing this program for, and who is going to be calling <b>score</b>? Is it reasonable to assume that it won't get called on an incomplete frame?"</P>
<P><B>RCM: </B>"Yeah. But it bothers me. To get around this, we have take the <b>score</b> out of the <b>testOneThrow</b> test case. Is that what we want to do?"</P>
<P><B>RSK:</B> "We could. We could even eliminate the entire <b>testOneThrow</b> test case. It was used to ramp us up to the test cases of interest. Does it really serve a useful purpose now? We still have coverage in all of the other test cases."</P>
<P><B>RCM: </B>"Yeah, I see your point. OK, out it goes." (Edits code, runs test, and gets green bar.) "Ahhh, that's better.</P>
<P>"Now, we'd better work on the strike test case. After all, we want to see all those <b>Frame</b> objects built into a linked list, don't we?" (snicker).</P>

<pre>
  public void testSimpleStrike()
  {
    g.add(10);
    g.add(3);
    g.add(6);
    assertEquals(19, g.scoreForFrame(1));
    assertEquals(28, g.score());
    assertEquals(3, g.getCurrentFrame());
  }
  </pre>

<P><B>RCM: </B>"OK, this compiles and fails as predicted. Now we need to make it pass."</P>

<pre>
//Game.java----------------------------------
public class Game
{
  public void add(int pins)
  {
    itsThrows[itsCurrentThrow++]=pins;
    itsScore += pins;
    adjustCurrentFrame(<B>pins</B>);
  }

  private void adjustCurrentFrame(<B>int pins</B>)
  {
    if (firstThrow == true)
    {
      <b>if( pins == 10 ) // strike
        itsCurrentFrame++;
      else</b>
        firstThrow = false;
    }
    else
    {
      firstThrow=true;
      itsCurrentFrame++;
    }
  }

  public int scoreForFrame(int theFrame)
  {
    int ball = 0;
    int score=0;
    for (int currentFrame = 0; 
         currentFrame &lt; theFrame; 
         currentFrame++)
    {
      int firstThrow = itsThrows[ball++];
      <b>if (firstThrow == 10)
      {
        score += 10 + itsThrows[ball] + itsThrows[ball+1];
      }
      else
      {</b>
        int secondThrow = itsThrows[ball++];

        int frameScore = firstThrow + secondThrow;
        // spare needs next frames first throw
        if ( frameScore == 10 )
          score += frameScore + itsThrows[ball];
        else
        score += frameScore;
      <b>}</b> 
    
    }

    return score;
  }
  private int itsScore = 0;
  private int[] itsThrows = new int[21];
  private int itsCurrentThrow = 0;
  private int itsCurrentFrame = 1;
  private boolean firstThrow = true;
}
</pre>

<P><B>RCM: </B>"OK, that wasn't too hard. Let's see if it can score a perfect game."</P>

<pre>
  <b>public void testPerfectGame()
  {
    for (int i=0; i&lt;12; i++)
    {
      g.add(10);
    }
    assertEquals(300, g.score());
    assertEquals(10, g.getCurrentFrame());
  }</b>
  </pre>

<P><B>RCM: </B>"Urg, it's saying the score is 330. Why would that be?"</P>
<P><B>RSK: </B>"Because the current frame is getting incremented all the way to 12."</P>
<P><B>RCM: </B>"Oh! We need to limit it to 10."</P>

<pre>
  private void adjustCurrentFrame(int pins)
  {
    if (firstThrow == true)
    {
      if( pins == 10 ) // strike
        itsCurrentFrame++;
      else
        firstThrow = false;
    }
    else
    {
      firstThrow=true;
      itsCurrentFrame++;
    }
    <b>itsCurrentFrame = Math.min(10, itsCurrentFrame);</b>
  }
</pre>

<B>RCM: </B>"Damn, now it's saying that the score is 270. What's going on?"</P>
<P><B>RSK: </B>"Bob, the <b>score</b> function is subtracting one from <b>getCurrentFrame</b>, so it's giving you the score for frame 9, not 10."</P>
<P><B>RCM: </B>What? You mean I should limit the current frame to 11 not 10? I'll try it.</P>

<pre>
itsCurrentFrame = Math.min(<b>11</b>, itsCurrentFrame);
</pre>

<P><B>RCM: </B>"OK, so now it gets the score correct, but fails because the current frame is 11 and not 10. Ick! this current frame thing is a pain in the butt. We want the current frame to be the frame the player is throwing into, but what does that mean at the end of the game?"</P>
<P><B>RSK: </B>"Maybe we should go back to the idea that the current frame is the frame of the last ball thrown."</P>
<P><B>RCM: </B>"Or maybe we need to come up with the concept of the last <I>completed</I> frame? After all, the score of the game at any point in time is the score in the last completed frame."</P>
<P><B>RSK: </B>"A completed frame is a frame that you can write the score into, right?"</P>
<P><B>RCM: </B>"Yes, a frame with a spare in it completes after the next ball. A frame with a strike in it completes after the next two balls. A frame with no mark completes after the second ball in the frame.</P>
<P>"Wait a minute.... We are trying to get the <b>score</b> method to work, right? All we need to do is force <b>score</b> to call <b>scoreForFrame(10)</b> if the game is complete."</P>
<P><B>RSK: </B>"How do we know if the game is complete?"</P>
<P><B>RCM: </B>"If <b>adjustCurrentFrame</b> ever tries to increment <b>itsCurrentFrame</b> past the 10th frame, then the game is complete."</P>
<P><B>RSK: </B>"Wait. All you are saying is that if <b>getCurrentFrame</b> returns 11, the game is complete; that's the way the code works now!"</P>
<P><B>RCM: </B>"Hmm. You mean we should change the test case to match the code?"</P>

<pre>
  public void testPerfectGame()
  {
    for (int i=0; i&lt;12; i++)
    {
      g.add(10);
    }
    assertEquals(300, g.score());
    assertEquals(<B>11</B>, g.getCurrentFrame());
  }
  </pre>

<P><B>RCM: </B>"Well, that works. I suppose it's no worse than <b>getMonth</b> returning zero for January, but I still feel uneasy about it."</P>
<P><B>RSK: </B>"Maybe something will occurr to us later. Right now, I think I see a bug. May I?" (Grabs keyboard.)</P>

<pre>
  <b>public void testEndOfArray()
  {
    for (int i=0; i&lt;9; i++)
    {
      g.add(0);
      g.add(0);
    }
    g.add(2);
    g.add(8); // 10th frame spare
    g.add(10); // Strike in last position of array.
    assertEquals(20, g.score());
  }</b>
  </pre>

<P><B>RSK: </B>"Hmm. That doesn't fail. I thought since the 21st position of the array was a strike, the scorer would try to add the 22nd and 23rd positions to the score. But I guess not."</P>
<P><B>RCM: </B>"Hmm, you are still thinking about that <b>scorer</b> object, aren't you? Anyway, I see what you were getting at, but since <b>score</b> never calls <b>scoreForFrame</b> with a number larger than 10, the last strike is not actually counted as a strike. It's just counted at a 10 to complete the last spare. We never walk beyond the end of the array."</P>
<P><B>RSK: </B>"OK, let's pump our original score card into the program."</P>

<pre>
  public void testSampleGame()
  {
    g.add(1);
    g.add(4);
    g.add(4);
    g.add(5);
    g.add(6);
    g.add(4);
    g.add(5);
    g.add(5);
    g.add(10);
    g.add(0);
    g.add(1);
    g.add(7);
    g.add(3);
    g.add(6);
    g.add(4);
    g.add(10);
    g.add(2);
    g.add(8);
    g.add(6);
    assertEquals(133, g.score());
  }
  </pre>

<P><B>RSK: </B>"Well, that works. Are there any other test cases that you can think of?"</P>
<P><B>RCM: </B>"Yeah, let's test a few more boundary conditions. How about the poor schmuck who throws 11 strikes and then a final 9."</P>

<pre>
  public void testHeartBreak()
  {
    for (int i=0; i&lt;11; i++)
      g.add(10);
    g.add(9); 
    assertEquals(299, g.score());
  }
  </pre>

<P><B>RCM: </B>"That works. OK, how about a 10th frame spare?"</P>

<pre>
  public void testTenthFrameSpare()
  {
    for (int i=0; i&lt;9; i++)
      g.add(10);
    g.add(9);
    g.add(1);
    g.add(1); 
    assertEquals(270, g.score());
  }
}
</pre>

<P><B>RCM: </B>(Staring happily at the green bar) "That works too. I can't think of any more, can you."</P>
<P><B>RSK: </B>"No, I think we've covered them all. Besides I really want to refactor this mess. I still see the <b>scorer</b> object in there somewhere."</P>
<P><B>RCM: </B>"OK, well, the <b>scoreForFrame</b> function is pretty messy. Let's consider it."</P>

<pre>
  public int scoreForFrame(int theFrame)
  {
    int ball = 0;
    int score=0;
    for (int currentFrame = 0; 
         currentFrame &lt; theFrame; 
         currentFrame++)
    {
      int firstThrow = itsThrows[ball++];
      if (firstThrow == 10)
      {
        score += 10 + itsThrows[ball] + itsThrows[ball+1];
      }
      else
      {
        int secondThrow = itsThrows[ball++];
  
        int frameScore = firstThrow + secondThrow;
        // spare needs next frames first throw
        if ( frameScore == 10 )
          score += frameScore + itsThrows[ball];
        else
          score += frameScore;
      } 

    }

    return score;
  }
  </pre>

<P><B>RCM: </B>"I'd really like to extract the body of that else clause into a seperate function named <b>handleSecondThrow</b>, but I can't because it uses <b>ball</b>, <b>firstThrow</b>, and <b>secondThrow</b> local variables."</P>
<P><B>RSK: </B>"We could turn those locals into member variables."</P>
<P><B>RCM: </B>"Yeah, that kind of reinforces your notion that we'll be able to pull the scoring out into its own <b>scorer</b> object. OK, let's give that a try."</P>
<P><B>RSK: </B>(Grabs keyboard.)</P>

<pre>
  private void adjustCurrentFrame(int pins)
  {
    if (<b>firstThrowInFrame</b> == true)
    {
      if( pins == 10 ) // strike
        <b>itsCurrentFrame</b>++;
      else
        firstThrowInFrame = false;
    }
    else
    {
      <b>firstThrowInFrame</b>=true;
      itsCurrentFrame++;
    }
    itsCurrentFrame = Math.min(11, itsCurrentFrame);
  }

  public int scoreForFrame(int theFrame)
  {
    <b>ball = 0;</b>
    int score=0;
    for (int currentFrame = 0; 
         currentFrame &lt; theFrame; 
         currentFrame++)
    {
      <b>firstThrow = itsThrows[ball++];</b>
      if (firstThrow == 10)
      {
        score += 10 + itsThrows[ball] + itsThrows[ball+1];
      }
      else
      {
        <b>secondThrow = itsThrows[ball++];</b>

        int frameScore = firstThrow + secondThrow;
        // spare needs next frames first throw
        if ( frameScore == 10 )
          score += frameScore + itsThrows[ball];
        else
          score += frameScore;
      } 
    }

    return score;
  }
  <b>private int ball;
  private int firstThrow;
  private int secondThrow;</b>

  private int itsScore = 0;
  private int[] itsThrows = new int[21];
  private int itsCurrentThrow = 0;
  private int itsCurrentFrame = 1;
  <b>private boolean firstThrowInFrame = true;</b>
  </pre>


<P><B>RSK: </B>"I hadn't expected the name collision. We already had an instance variable named <b>firstThrow</b>. But it is better named <b>firstThrowInFrame</b>. Anyway, this works now. So we can pull the else clause out into its own function."</P>

<pre>
  public int scoreForFrame(int theFrame)
  {
    ball = 0;
    int score=0;
    for (int currentFrame = 0; 
         currentFrame &lt; theFrame; 
         currentFrame++)
    {
      firstThrow = itsThrows[ball++];
      if (firstThrow == 10)
      {
        score += 10 + itsThrows[ball] + itsThrows[ball+1];
      }
      else
      {
        <b>score += handleSecondThrow();</b>
      } 
    }

    return score;
  }

  private int handleSecondThrow()
  {
    <b>int score = 0;</b>
    secondThrow = itsThrows[ball++];

    int frameScore = firstThrow + secondThrow;
    // spare needs next frames first throw
    if ( frameScore == 10 )
      score += frameScore + itsThrows[ball];
    else
      score += frameScore;
    <b>return score;</b>
  }
</pre>

<P><B>RCM: </B>"Look at the structure of <b>scoreForFrame</b>! In pseudocode, it looks something like this:"</P>

<pre>
if strike
  score += 10 + nextTwoBalls();
else
  handleSecondThrow.
</pre>

<P><B>RCM: </B>"What if we changed it to:"</P>

<pre>
if strike
  score += 10 + nextTwoBalls();
else if spare
  score += 10 + nextBall();
else
  score += twoBallsInFrame()
</pre>

<P><B>RSK: </B>"Geez! That's pretty much the rules for scoring bowling isn't it? OK, let's see if we can get that structure in the real function. First let's change the way the <b>ball</b> variable is being incremented so that the three cases manipulate it independently."</P>

<pre>
  public int scoreForFrame(int theFrame)
  {
    ball = 0;
    int score=0;
    for (int currentFrame = 0; 
         currentFrame &lt; theFrame; 
         currentFrame++)
    {
      firstThrow = itsThrows[<b>ball</b>];
      if (firstThrow == 10)
      {
        <b>ball++;</b>
        score += 10 + itsThrows[ball] + itsThrows[ball+1];
      }
      else
      {
        score += handleSecondThrow();
      } 
    }

    return score;
  }

  private int handleSecondThrow()
  {
    int score = 0;
    secondThrow = itsThrows[<b>ball+1</b>];

    int frameScore = firstThrow + secondThrow;
    // spare needs next frames first throw
    if ( frameScore == 10 )
    {
      <b>ball+=2;</b>
      score += frameScore + itsThrows[ball];
    }
    else
    {
      <b>ball+=2;</b>
      score += frameScore;
    }
    return score; 
  }
  </pre>

<P><B>RCM:</B> (Grabs keyboard.) "OK, now let's get rid of the <b>firstThrow</b> and <b>secondThrow</b> variables and replace them with appropriate functions."</P>

<pre>
  public int scoreForFrame(int theFrame)
  {
    ball = 0;
    int score=0;
    for (int currentFrame = 0; 
         currentFrame &lt; theFrame; 
         currentFrame++)
    {
      firstThrow = itsThrows[ball];
      <b>if (strike())</b>
      {
        ball++;
        score += 10 + <b>nextTwoBalls();</b>
      }
      else
      {
        score += handleSecondThrow();
      } 
    }

    return score;
  }
  
  <b>private boolean strike()
  {
    return itsThrows[ball] == 10;
  }

  private int nextTwoBalls()
  {
    return itsThrows[ball] + itsThrows[ball+1];
  }</b>
  </pre>

<P><B>RCM: </B>"That step works; let's keep going."</P>

<pre>
  private int handleSecondThrow()
  {
    int score = 0;
    secondThrow = itsThrows[ball+1];

    int frameScore = firstThrow + secondThrow;
    // spare needs next frames first throw
    <b>if ( spare() )</b>
    {
      ball+=2;
      <b>score += 10 + nextBall();</b>
    }
    else
    {
      ball+=2;
      score += frameScore;
    }
    return score; 
  }

  <b>private boolean spare()
  {
    return (itsThrows[ball] + itsThrows[ball+1]) == 10;
  }

  private int nextBall()
  {
    return itsThrows[ball];
  }</b>
</pre>

<P><B>RCM: </B>"OK, that works too. Now let's deal with <b>frameScore</b>."</P>

<pre>
  private int handleSecondThrow()
  {
    int score = 0;
    secondThrow = itsThrows[ball+1];

    int frameScore = firstThrow + secondThrow;
    // spare needs next frames first throw
    if ( spare() )
    {
      ball+=2;
      score += 10 + nextBall();
    }
    else
    {
      <b>score += twoBallsInFrame();
      ball+=2;</b>
    }
    return score; 
  }

  <b>private int twoBallsInFrame()
  {
    return itsThrows[ball] + itsThrows[ball+1];
  }</b>
  </pre>

<P><B>RSK: </B>"Bob, you aren't incrementing <b>ball</b> in a consistent manner. In the spare and strike case, you increment before you calculate the score. In the <b>twoBallsInFrame</b> case, you increment <I>after</I> you calculate the score. And the code <I>depends</I> upon this order! What's up?"</P>
<P><B>RCM: </B>"Sorry, I should have explained. I'm planning on moving the increments into <b>strike</b>, <b>spare</b>, and <b>twoBallsInFrame</b>. That way they'll disappear from the <b>scoreForFrame</b> function, and the function will look just like our pseudocode."</P>
<P><B>RSK: </B>"OK, I'll trust you for a few more steps, but remember, I'm watching."</P>
<P><B>Kent:</B> <I>"So am I."</I></P>
<P><B>RCM: </B>"OK, now since nobody uses <b>firstThrow</b>, <b>secondThrow</b>, and <b>frameScore</b> anymore, we can get rid of them."</P>

<pre>
  public int scoreForFrame(int theFrame)
  {
    ball = 0;
    int score=0;
    for (int currentFrame = 0; 
         currentFrame &lt; theFrame; 
         currentFrame++)
    {
      if (strike())
      {
        ball++;
        score += 10 + nextTwoBalls();
      }
      else
      {
        score += handleSecondThrow();
      } 
    }

    return score;
  }

  private int handleSecondThrow()
  {
    int score = 0;
    // spare needs next frames first throw
    if ( spare() )
    {
      ball+=2;
      score += 10 + nextBall();
    }
    else
    {
      score += twoBallsInFrame();
      ball+=2;
    }
    return score; 
  }
  </pre>

<P><B>RCM: </B>(The sparkle in his eyes is a reflection of the green bar.) "Now, since the only variable that couples the three cases is <b>ball</b>, and since <b>ball</b> is dealt with independently in each case, we can merge the three cases together."</P>

<pre>
  public int scoreForFrame(int theFrame)
  {
    ball = 0;
    int score=0;
    for (int currentFrame = 0; 
         currentFrame &lt; theFrame; 
         currentFrame++)
    {
      if (strike())
      {
        ball++;
        score += 10 + nextTwoBalls();
      }
      <b>else</b> if ( spare() )
      {
        ball+=2;
        score += 10 + nextBall();
      }
      else
      {
        score += twoBallsInFrame();
        ball+=2;
      }
    }

    return score;
  }
  </pre>

<P><B>RSK: </B>(Peter Lorrie Gasp) "Master... Master... Let me do it. <I>Please</I>, let me do it."</P>
<P><B>RCM: </B>"Ah, Igor, you would like to move the increments?"</P>
<P><B>RSK: </B>"Yes, master. Oh <I>yes</I> master." (Grabs keyboard.)</P>

<pre>
  public int scoreForFrame(int theFrame)
  {
    ball = 0;
    int score=0;
    for (int currentFrame = 0; 
         currentFrame &lt; theFrame; 
         currentFrame++)
    {
      <b>if (strike())
        score += 10 + nextTwoBalls();
      else if (spare())
        score += 10 + nextBall();
      else
        score += twoBallsInFrame();</b>
    }

    return score;
  }

  private boolean strike()
  {
    <b>if (itsThrows[ball] == 10)
    {
      ball++;
      return true;
    }
    return false;</b>
  }

  private boolean spare()
  {
    <b>if ((itsThrows[ball] + itsThrows[ball+1]) == 10)
    {
      ball += 2;
      return true;
    }
    return false;</b>
  }

  private int nextTwoBalls()
  {
    return itsThrows[ball] + itsThrows[ball+1];
  }

  private int nextBall()
  {
    return itsThrows[ball];
  }

  private int twoBallsInFrame()
  {
    <b>return itsThrows[ball++] + itsThrows[ball++];</b>
  }
</pre>

<P><B>RCM: </B>"Well <I>done</I> Igor!"</P>
<P><B>RSK: </B>"Thank you master."</P>
<P><B>RCM: </B>"Look at that <b>scoreForFrame</b> function. That's the rules of bowling stated about as succinctly as possible."</P>
<P><B>RSK: </B>"But, Bob, what happened to the linked list of <b>Frame</b> objects?" (snicker, snicker)</P>
<P><B>RCM: </B>(Sigh) "We were bedevilled by the daemons of diagramatic overdesign. My God, three little boxes drawn on the back of a napkin, <b>Game</b>, <b>Frame</b>, and <b>Throw</b>, and it was still too complicated and just plain wrong."</P>
<P><B>RSK: </B>"We made a mistake starting with the <b>Throw</b> class. We should have started with the <b>Game</b> class first!"</P>
<P><B>RCM: </B>"Indeed! So, next time let's try starting at the highest level and work down."</P>
<P><B>RSK: </B>(Gasp) "Top Down Design!??!?! Could DeMarco have been right all along?"</P>
<P><B>RCM: </B>"Correction: Top Down <I>Test First </I>Design. Frankly, I don't know if this is a good rule or not. It's just what would have helped us in this case. So next time, I'm going to try it and see what happens."</P>
<P><B>RSK: </B>"Yeah, OK. Anyway we still have some refactoring to do. The <b>ball</b> variable is just a private iterator for <b>scoreForFrame</b> and its minions. They should all be moved into a different object."</P>
<P><B>RCM: </B>"Oh, yes, your <b>Scorer</b> object. You were right after all. Let's do it."</P>
<P><B>RSK: </B>(Grabs keyboard and takes several small steps punctuated by tests to create the following.)</P>

<pre>
//Game.java----------------------------------
public class Game
{
  public int score()
  {
    return scoreForFrame(getCurrentFrame()-1);
  }

  public int getCurrentFrame()
  {
    return itsCurrentFrame;
  }

  public void add(int pins)
  {
    itsScorer.addThrow(pins);
    itsScore += pins;
    adjustCurrentFrame(pins);
  }

  private void adjustCurrentFrame(int pins)
  {
    if (firstThrowInFrame == true)
    {
      if( pins == 10 ) // strike
        itsCurrentFrame++;
      else
        firstThrowInFrame = false;
    }
    else
    {
      firstThrowInFrame=true;
      itsCurrentFrame++;
    }
    itsCurrentFrame = Math.min(11, itsCurrentFrame);
  }
  
  public int scoreForFrame(int theFrame)
  {
    return itsScorer.scoreForFrame(theFrame);
  }

  private int itsScore = 0;
  private int itsCurrentFrame = 1;
  private boolean firstThrowInFrame = true;
  private Scorer itsScorer = new Scorer();
}

//Scorer.java-----------------------------------
public class Scorer
{
  public void addThrow(int pins)
  {
    itsThrows[itsCurrentThrow++] = pins;
  }

  public int scoreForFrame(int theFrame)
  {
    ball = 0;
    int score=0;
    for (int currentFrame = 0; 
         currentFrame &lt; theFrame; 
         currentFrame++)
    {
      if (strike())
        score += 10 + nextTwoBalls();
      else if (spare())
        score += 10 + nextBall();
      else
        score += twoBallsInFrame();
    }

    return score;
  }

  private boolean strike()
  {
    if (itsThrows[ball] == 10)
    {
      ball++;
      return true;
    }
    return false;
  }

  private boolean spare()
  {
    if ((itsThrows[ball] + itsThrows[ball+1]) == 10)
    {
      ball += 2;
      return true;
    }
    return false;
  }

  private int nextTwoBalls()
  {
    return itsThrows[ball] + itsThrows[ball+1];
  }

  private int nextBall()
  {
    return itsThrows[ball];
  }

  private int twoBallsInFrame()
  {
    return itsThrows[ball++] + itsThrows[ball++];
  }

  private int ball;
  private int[] itsThrows = new int[21];
  private int itsCurrentThrow = 0;

}
</pre>

<P><B>RSK: </B>"That's much better. Now <b>Game</b> just keeps track of frames, and <b>Scorer</b> just calculates the score. The SRP rocks!"</P>
<P><B>RCM: </B>"Whatever. But it is better. Did you notice that the <b>itsScore</b> variable is not being used anymore?" </P>
<P><B>RSK: </B>"Ha! You're right. Let's kill it." (Gleefully starts erasing things.)</P>

<pre>
  public void add(int pins)
  {
    itsScorer.addThrow(pins);
    adjustCurrentFrame(pins);
  }
  </pre>

<P><B>RSK: </B>"Not bad. Now should we clean up the <b>adjustCurrentFrame</b> stuff?"</P>
<P><B>RCM: </B>"OK, let's look at it."</P>

<pre>
  private void adjustCurrentFrame(int pins)
  {
    if (firstThrowInFrame == true)
    {
      if( pins == 10 ) // strike
        itsCurrentFrame++;
      else
        firstThrowInFrame = false;
    }
    else
    {
      firstThrowInFrame=true;
      itsCurrentFrame++;
    }
    itsCurrentFrame = Math.min(11, itsCurrentFrame);
  }
  </pre>

<P><B>RCM: </B>"OK, first let's extract the increments into a single function that also restricts the frame to 11. (Brrrr. I still don't like that 11.)"</P>
<P><B>RSK: </B>"Bob, 11 means end of game."</P>
<P><B>RCM: </B>"Yeah. Brrrr." (Grabs keyboard, makes a couple of changes punctuated by tests.)</P>

<pre>
  private void adjustCurrentFrame(int pins)
  {
    if (firstThrowInFrame == true)
    {
      if( pins == 10 ) // strike
        <B>advanceFrame</B>();
      else
        firstThrowInFrame = false;
    }
    else
    {
      firstThrowInFrame=true;
      <b>advanceFrame</b>();
    }
  }

  <b>private void advanceFrame()
  {
    itsCurrentFrame = Math.min(11, itsCurrentFrame + 1);
  }</b>
  </pre>

<P><B>RCM: </B>"OK, that's a little better. Now let's break out the strike case into its own function." (Takes a few small steps and runs tests between each.)</P>

<pre>
  private void adjustCurrentFrame(int pins)
  {
    if (firstThrowInFrame == true)
    {
      <b>if (adjustFrameForStrike(pins) == false)</b>
        firstThrowInFrame = false;
    }  
    else
    {
      firstThrowInFrame=true;
      advanceFrame();
    }
  }

  <b>private boolean adjustFrameForStrike(int pins)
  {</b>
    if (pins == 10)
    {
      advanceFrame();
      <b>return true;</b>
    }
    <b>return false;
  }</b>
  </pre>

<P><B>RCM: </B>"That's pretty good. Now, about that 11."</P>
<P><B>RSK: </B>"You really hate that don't you."</P>
<P><B>RCM: </B>"Yeah, look at the <b>score</b> function:"</P>

<pre>
  public int score()
  {
    return scoreForFrame(getCurrentFrame()-1);
  }
  </pre>

<P><B>RCM: </B>"That -1 is odd. It's the only place we truly use <b>getCurrentFrame</b>, and yet we need to adjust what it returns."</P>
<P><B>RSK: </B>"Damn, you're right. How many times have we reversed ourselves on this?"</P>
<P><B>RCM: </B>"Too many. But there it is. The code wants <b>itsCurrentFrame</b> to represent the frame of the last thrown ball, not the frame we are about to throw into."</P>
<P><B>RSK: </B>"Sheesh, that's going to break lots of tests cases."</P>
<P><B>RCM: </B>"Actually, I think we should remove <b>getCurrentFrame</b> from all the test cases and remove the <b>getCurrentFrame</b> function itself. Nobody really uses it."</P>
<P><B>RSK: </B>"OK, I get your point. I'll do it. It'll be like putting a lame horse out of its misery." (Grabs keyboard.)</P>

<pre>
//Game.java----------------------------------
  public int score()
  {
    <b>return scoreForFrame(itsCurrentFrame);</b>
  }

  private void advanceFrame()
  {
    itsCurrentFrame = Math.min(<b>10</b>, itsCurrentFrame + 1);
  }
  </pre>

<P><B>RCM: </B>"Oh for crying out loud. You mean to tell me that we were fretting over <I>that</I>. All we did was change the limit from 11 to 10 and remove the -1. Cripe."<P>
<P><B>RSK: </B>"Yeah, Uncle Bob, it really wasn't worth all the angst we gave it."<P>
<P><B>RCM: </B>"OK, looks like we are done. Let's just read through the whole program and see if it's as simple and communicative as it can be."<P>

<pre>
//Game.java----------------------------------
public class Game
{
  public int score()
  {
    return scoreForFrame(itsCurrentFrame);
  }

  public void add(int pins)
  {
    itsScorer.addThrow(pins);
    adjustCurrentFrame(pins);
  }

  private void adjustCurrentFrame(int pins)
  {
    if (firstThrowInFrame == true)
    {
      if (adjustFrameForStrike(pins) == false)
        firstThrowInFrame = false;
    }
    else
    {
      firstThrowInFrame=true;
      advanceFrame();
    }
  }

  private boolean adjustFrameForStrike(int pins)
  {
    if (pins == 10)
    {
      advanceFrame();
      return true;
    }
    return false;
  }  

  private void advanceFrame()
  {
    itsCurrentFrame = Math.min(10, itsCurrentFrame + 1);
  }

  public int scoreForFrame(int theFrame)
  {
    return itsScorer.scoreForFrame(theFrame);
  }

  private int itsCurrentFrame = 0;
  private boolean firstThrowInFrame = true;
  private Scorer itsScorer = new Scorer();
}

//Scorer.java-----------------------------------
public class Scorer
{
  public void addThrow(int pins)
  {
    itsThrows[itsCurrentThrow++] = pins;
  }

  public int scoreForFrame(int theFrame)
  {
    ball = 0;
    int score=0;
    for (int currentFrame = 0; 
         currentFrame &lt; theFrame; 
         currentFrame++)
    {
      if (strike())
        score += 10 + nextTwoBalls();
      else if (spare())
        score += 10 + nextBall();
      else
        score += twoBallsInFrame();
    }

    return score;
  }

  private boolean strike()
  {
    if (itsThrows[ball] == 10)
    {
      ball++;
      return true;
    }
    return false;
  }

  private boolean spare()
  {
    if ((itsThrows[ball] + itsThrows[ball+1]) == 10)
    {
      ball += 2;
      return true;
    }
    return false;
  }

  private int nextTwoBalls()
  {
    return itsThrows[ball] + itsThrows[ball+1];
  }

  private int nextBall()
  {
    return itsThrows[ball];
  }

  private int twoBallsInFrame()
  {
    return itsThrows[ball++] + itsThrows[ball++];
  }

  private int ball;
  private int[] itsThrows = new int[21];
  private int itsCurrentThrow = 0;
}
</pre>

<P><B>RCM: </B>"OK, that looks pretty good. I can't think of anything else to do."<P>
<P><B>RSK: </B>"Yeah, it's pretty. Let's look over the tests for good measure."<P>

<pre>
//TestGame.java------------------------------------------
import junit.framework.*;

public class TestGame extends TestCase
{
  public TestGame(String name)
  {
    super(name);
  }

  private Game g;

  public void setUp()
  {
    g = new Game();
  }

  public void testTwoThrowsNoMark()
  {
    g.add(5);
    g.add(4);
    assertEquals(9, g.score());
  }

  public void testFourThrowsNoMark()
  {
    g.add(5);
    g.add(4);
    g.add(7);
    g.add(2);
    assertEquals(18, g.score());
    assertEquals(9, g.scoreForFrame(1));
    assertEquals(18, g.scoreForFrame(2));
  }

  public void testSimpleSpare()
  {
    g.add(3);
    g.add(7);
    g.add(3);
    assertEquals(13, g.scoreForFrame(1));
  }

  public void testSimpleFrameAfterSpare()
  {
    g.add(3);
    g.add(7);
    g.add(3);
    g.add(2);
    assertEquals(13, g.scoreForFrame(1));
    assertEquals(18, g.scoreForFrame(2));
    assertEquals(18, g.score());
  }

  public void testSimpleStrike()
  {
    g.add(10);
    g.add(3);
    g.add(6);
    assertEquals(19, g.scoreForFrame(1));
    assertEquals(28, g.score());
  }

  public void testPerfectGame()
  {
    for (int i=0; i&lt;12; i++)
    {
      g.add(10);
    }
    assertEquals(300, g.score());
  }

  public void testEndOfArray()
  {
    for (int i=0; i&lt;9; i++)
    {
      g.add(0);
      g.add(0);
    }
    g.add(2);
    g.add(8); // 10th frame spare
    g.add(10); // Strike in last position of array.
    assertEquals(20, g.score());
   }

  public void testSampleGame()
  {
    g.add(1);
    g.add(4);
    g.add(4);
    g.add(5);
    g.add(6);
    g.add(4);
    g.add(5);
    g.add(5);
    g.add(10);
    g.add(0);
    g.add(1);
    g.add(7);
    g.add(3);
    g.add(6);
    g.add(4);
    g.add(10);
    g.add(2);
    g.add(8);
    g.add(6);
    assertEquals(133, g.score());
  }

  public void testHeartBreak()
  {
    for (int i=0; i&lt;11; i++)
      g.add(10);
    g.add(9); 
    assertEquals(299, g.score());
  }

  public void testTenthFrameSpare()
  {
    for (int i=0; i&lt;9; i++)
      g.add(10);
    g.add(9);
    g.add(1);
    g.add(1); 
    assertEquals(270, g.score());
  }
}
</pre>

<P><B>RSK: </B>"That pretty much covers it. Can you think of any more meaningful test cases?"<P>
<P><B>RCM: </B>"No, I think that's the set. There aren't any there that I'd be comfortable removing at this point."<P>
<P><B>RSK: </B>"Then we're done."<P>
<P><B>RCM: </B>"I'd say so. Thanks a lot for you help."<P>
<P><B>RSK: </B>"No problem, it was fun."<P>

<H3><FONT COLOR="#000080">Note</FONT></H3>
<P><a name="1"></a>[1] Bertrand Meyer. <i>Object-Oriented Software Construction</i> (Prentice Hall, 1999).<P>

<p><i><b>Robert C. Martin</b> has been a software professional since 1970. He is president of Object Mentor Inc., a firm of highly experienced
experts that offers high level object-oriented software design consulting, training, and development services to major corporations
around the world. In 1995, he authored the best-selling book: </i>Designing Object Oriented C++ Applications using the Booch
Method<i>, published by Prentice Hall. In 1997, he was chief editor of the book: </i>Pattern Languages of Program Design 3<i>, published
by Addison Wesley. In 2000, he was editor of the book </i>More C++ Gems<i>, published by Cambridge Press. From 1996 to 1998, he
was the editor-in-chief of the C++ Report. He has published dozens of articles in various trade journals and is a regular speaker at
international conferences and trade shows. He is currently working in the area of lightweight productive processes and is a strong
advocate and supporter of Extreme Programming.</i></p>

<p><i><b>Dr. Robert S Koss</b> has been programming since 1973, starting in Fortran, migrating to C, 
then to C++, and lately to Java, Smalltalk, and Python. He has been a senior consultant at Object Mentor Inc. 
for the last two years, where his duties include writing and teaching courses, mentoring clients, 
and participating in the development of projects that are outsourced to the company. He has developed 
many systems in a variety of areas, from real-time embedded controllers to large database systems. He 
is also a strong proponent of lightweight processes and a very vocal advocate of Extreme Programming.</i></p>

</blockquote></body></html>



