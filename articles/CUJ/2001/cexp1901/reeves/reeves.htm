<HTML>   
     <HEAD>
<TITLE>January 2001 Experts Forum/The (B)Leading Edge</TITLE></HEAD>
<BODY BACKGROUND="" BGCOLOR="#FFFFFF" TEXT="#000000">
<H2><A HREF="../../19.01/tocjan.htm"></A><FONT COLOR="#FF0000">   C++ Experts Forum</FONT></H2>

<HR>

<H2 ALIGN="center"><FONT COLOR="#800000">The (B)Leading Edge: Using IOStreams, Part I</FONT></H2>
<H3 ALIGN="center"><FONT COLOR="#800000">Jack W. Reeves</FONT></H3>

<HR>

<BLOCKQUOTE>

<H3><FONT COLOR="#000080">Introduction</FONT></H3>

<P>Welcome to the new version of "The (B)leading Edge." I would like to take the opportunity to thank  the editors and publisher of <i>C/C++ User's Journal</i> for the opportunity to continue writing "The (B)Leading Edge." If you are a regular reader of this column, I hope you will continue to find it interesting and useful. If you are a new reader, I hope you will be glad you found it.</P>
<P>Before I jump into IOStreams, I need to acknowledge some feedback. After my column on object-oriented design <a href="#1">[1]</a>, reader Robert Allan Schwartz took me to task for claiming that Java was a "pure object-oriented language. " As he says </P>
<P><I>"Any language that contains types like <B>boolean</B>, <B>char</B>, <B>byte</B>, <B>short</B>, <B>int</B>, <B>long</B>, <B>float</B>, and <B>double</B> (none of which are classes) is not "pure"-ly object oriented.</I></P>
<P><I>Just because Java does not support non-member data and non-member functions does not mean 'anything written in Java is automatically object-oriented by definition.'"</I></P>
<P>He is absolutely correct. I replied that I didn't subscribe to the idea that Java was a pure object-oriented language myself, but that I had simply passed along a common assertion. Furthermore, my intention in doing so was to actually take a little tongue-in-cheek poke at those who do subscribe to this belief, and who may unconsciously also believe that code written in Java is somehow "purer," and hence better, than code written in C++. Stated so baldly, this assumption is pretty clearly nonsense. Nevertheless, I concede that Schwartz is correct &#151; if I am going to write this column, I owe it to my readers to debunk nonsense, not promulgate it. So let me now make the following assertion: Java is not a "pure" object -oriented programming language. Rather, I consider Java to be a "practical" object-oriented programming language. Just like C++. </P>
<P>With this column, I am going to kick off a fairly in-depth look at the Standard IOStream library. As always, my approach will be based upon my own real-world experiences (or what passes for it in my case).  First let me provide a little background. As you probably know, the IOStream library has been part of the C++ library for a long time. Certainly, it was available when I first started to use C++ in 1990. </P>
<P>When I encountered the IOStream library, I was immediately a fan. Here was an extensible, type-safe, I/O mechanism that was built as an ordinary library and did not depend upon some special support by the compiler. At the same time, it was an efficient and compact notation. It was possible to write</P>

<pre>
os &lt;&lt; "X=" &lt;&lt; x &lt;&lt; endl;
</pre>

<P>and leave it up to the compiler to know what type <B>x</B> really was and leave it up to <B>x</B> to know how to output itself. This was what object-oriented programming was suppose to be all about.  So, I immediately stopped using the old C <B>stdio</B> library and began to exclusively use IOStreams. The more I used the library, and in particular the more I studied the library, the more impressed I became. I can honestly say that I learned a lot about how to do good design in C++ by studying the IOStream library. Here are a few examples of some of the things I found impressive about the IOStreams library even back in the early 1990s. (I will use the past tense to refer to the pre-Standard version of the IOStreams library and the present tense for referring to the Standard-compliant IOStreams. Most remarks will apply to both unless I specifically note otherwise, but I will try to avoid constant usage of the phrase "is/was" .)</P>
<P>Abstraction &#151; having a base class that provides an abstraction, and derived classes that provide different implementations, is a fundamental part of object-oriented design. It is easy to overlook just how good the IOStreams design was in that respect. About the only time I ever had to care about the actual type of IOStream that I was using was when I found it necessary to explicitly add an <B>ends</B> manipulator to a <B>strstream</B>. These days I use a <B>stringstream</B> (see <a href="sidebar1.htm">sidebar</a>, "<B>strstream</B> vs. <B>stringstream</B>") and even that distinction has disappeared. While the Standard IOStreams library comes with file-based streams and memory-based streams, lots of people have added implementations for other types of streams. We will be adding a few ourselves before this column is over (and many more before I am through).</P>
<P>Multiple layers of abstraction &#151; the IOStreams library was built on multiple levels of abstraction. This is just plain good design. I repeatedly see high-level abstractions that are implemented in C for all practical purposes. Decomposing a problem into smaller pieces makes just as much sense for object-oriented design as it ever did before. In the object-oriented sense, the "smaller" pieces should themselves be good abstractions. As IOStreams shows, those lower-level abstractions can significantly simplify the implementation and often turn out to be extremely useful in their own right.</P>
<P>Multiple inheritance &#151; the IOStreams library was one of the first good examples of the use multiple inheritance that I encountered. It remains one of the best examples to this day. </P>
<P>Useful idioms &#151; the IOStreams library contains a number of useful idioms that are applicable to a lot of other class designs. One of my favorites is the automatic conversion <I>operators</I> that allow the status of an IOStream object to be tested directly:</P>

<pre>
if (istrm) . . . // ok to use it
</pre>

<P>I use this idiom repeatedly in my own classes, and I wonder why it is not more commonly used.</P>
<P>It is the extensibility of the IOStreams library that is probably its best known aspect, however. In fact, the IOStreams library might just as well be called "the extensible IOStreams library." This extensibility comes is many different forms: </P>

<UL>
<LI>The simplest form is the ability to define input and output operators externally to the IOStreams library itself. This is so common that most of us do not even think about it when we write a new <B>operator&lt;&lt;</B> for some class. Nevertheless, this doesn't "just happen" to work. It works because it was designed that way.</LI>
<LI>Besides the ability to add new operators to the IOStreams library without having to change the library itself, the library provides mechanisms to allow extensible formatting information on a per-class basis, again without having to change the library itself. I will explore this mechanism in a future column.</LI>
<LI>The IOStreams library can be extended by derivation. Again, this doesn't "just happen." There is far more to designing a good base class than just making some of the functions <B>virtual</B>. I have often maintained that designing the <I>protected</I> part of a class' interface is the hardest part of doing a good abstraction.  The <I>protected</I> part is the abstraction that is exposed to derived classes, but not to ordinary clients. Many class designs abdicate on this part by just declaring all the data as protected, (or providing protected accessors and mutators for all the data elements). This is effectively no abstraction at all since it means that any changes to the base class' default implementation cause ripple changes to any derived classes. Alternatively, many classes just provide a "pure interface" with no data, no default implementations, and all functions declared <B>virtual</B>. This just transfers the full burden of implementation to every derived class <a href="#2">[2]</a>. The IOStreams library takes a middle approach. It provides a <B>protected</B> interface that is actually an abstraction, but lower level (and less safe) than the client abstraction. Then it provides a default implementation for all parts of this abstraction. This is one of the areas where the Standard version of IOStreams improves upon its predecessor.</LI>
<LI>Finally, the Standard IOStreams library is template based. This provides another dimension of extensibility that was not present in prior versions. In a future column, I will be taking advantage of this extensibility.
</UL>

<P>This column is intended as an introduction to IOStreams design, not a tutorial on IOStreams usage. To set the stage, I am going to jump right into the very heart of IOStreams by providing a fairly detailed example of creating a derived stream class. I have found that in spite of the fact that IOStreams is designed to be extended, many programmers seem to feel that extending IOStreams is too complex or too much work. There is no better way to get past this aversion than to dive right in.</P>
<P>What I want is an IOStream class to replace some of the functionality of the deprecated <B>strstream</B> class that is not available with the new <B>stringstream</B> class. A little background: once upon a time, I created a class called <B>substring</B> <a href="#3">[3]</a>. This class was created specifically to allow me to efficiently parse input strings. Naturally, one of the things I needed to parse out of the strings were numbers. When I had created <B>substring</B>, I ran into a problem: there was no Standard library routine that could be used to extract a number from a <B>substring</B>. The Standard C library provided some algorithms that did what I wanted (declared in <B>stdlib.h</B>), but they expected to receive a null-terminated character array as input. In order to create such from a <B>substring</B>, I would have to make a copy of the data. The new <B>stringstream</B> class would parse a number, but it required a <B>string</B> object as input, and again that would require making a copy of the <B>substring</B>'s data. Finally, the <B>strstream</B> stream came close to providing what I needed, but not exactly. Besides, it was deprecated and I did not want to use it for that reason alone.</P>
<P>Eventually, I created my own <B>strtoint </B>and <B>strtodouble</B> algorithms. Their interface was modeled after the other STL algorithms (i.e., they operated on character sequences defined by a pair of iterators). This worked fine, but I was never really happy about it. There are a couple of areas where you expect your standard library implementation to be really tailored to a specific platform. One of these areas is <B>memcpy </B>and its cousins. Another area is numeric-to-string conversions. A lot of processors provide low-level instructions that perform these operations much more efficiently than is possible with generic C/C++ code. A good library implementation will take advantage of these low-level operations. This means that it is always prudent to route such operations through the standard library, if possible. Even if the library is a generic implementation, you haven't lost anything by using it. If it is tailored for the specific processor/platform there can be considerable gain.</P>
<P>Another reason for wanting to use the Standard IOStreams mechanism for parsing numbers is the <I>locales</I> facility. Some locales use ',' instead of '.' for fractions. Some represent money differently, and so on. Ideally, I wanted my input parser to be able to handle different locales automatically. In Standard C++, numeric conversions are actually part of the <I>locales</I> library. The typical way to access these functions is via an IOStream. What I really wanted was not an algorithm that converted a string to a number, but a way to invoke an IOStream operation on a <B>substring</B>. In other words, I wanted to be able to create an IOStream from a <B>substring</B>. </P>
<P>In order to get what I wanted, I created a template <B>String_stream&lt;&gt;</B> that would wrap an IOStream interface around any class that provided the appropriate subset of the standard <B>string</B> interface. I propose to go through the reasoning and the variations I went through in creating <B>String_stream</B> as a way of demonstrating what is involved in creating a derived IOStream class.</P>

<H3><FONT COLOR="#000080">A String_stream Template (Version 1)</FONT></H3>

<P>The first step in creating any new IOStream class is to create the appropriate <B>streambuf</B> derived class. Readers who are familiar with the organization of the Standard IOStreams library will know that <B>streambuf</B> is actually a synonym for <B>basic_streambuf&lt;char&gt;.</B> In order to keep the discussion more readable, I will limit my descriptions to the <B>char</B>-based IOStreams. Extending things to support different character types is a fairly easy process.</P>
<P>There are twelve virtual functions provided by the <B>streambuf</B> interface that can be overriden by a derived class. For completeness sake, I list these functions here:</P>

<pre>
imbue
setbuf
seekoff
seekpos
sync
showmanyc    (pronounced es-how-many-see)
xsgetn
underflow
uflow
pbackfail
xsputn
overflow
</pre>

<P>The first version of <B>String_streambuf</B> I created is shown in <a href="list1.htm">Listing 1</a>. Note that each of these functions returns an <b>int_typ</b>. By convention, most functions in <b>streambuf</b> return the <b>EOF</b> character to indicate a failure, and some valid character to indicate success. For the first version, I just wanted to transfer characters directly to and from the string object. In <B>streambuf</B> terms, this was to be "unbuffered I/O." In other words, I was moving characters directly to/from the source/destination without any intermediate buffering in the <B>streambuf</B> object. In order to do this, the minimum functions that I needed to implement were: <B>underflow</B>, <B>uflow</B>, <B>pbackfail</B>, and <B>overflow</B>. The first three are related to input, and <B>overflow</B> handles output. Note that each of these functions returns an <b>int_typ</b>. By convention, most functions in <b>streambuf</b> return the <b>EOF</b> character to indicate a failure, and some valid character to indicate success.  Because the latter is simpler, I will discuss it first.</P>
<P>A <B>streambuf</B> is allowed to impose a number of restrictions on the character sequence that it manages. Alternatively you could say that a managed character sequence can have certain restrictions that the <B>streambuf</B> can enforce with relation to any IOStream that uses the <B>streambuf</B>. In this case, I decided arbitrarily that output would always append to the string (assuming the string was writable and had space available). This made the <B>overflow</B> function trivial. The <B>overflow</B> function is called when the output buffer is full or does not exist. Since this version of <B>String_streambuf</B> has no output buffer, <B>overflow</B> is called for every character written to the stream. Note that each of these functions returns an <b><b>int_type</b></b>. By convention, most functions in <b>streambuf</b> return the <b>EOF<</b> character to indicate a failure and some valid character to indicate success. </P>
<P>You will note that <b>overflow</b> takes an input argument of <b>int_type</b> rather than <b>char</b>. This means that <b>overflow</b> can be called with an argument of <b>EOF</b>. It is not clear to me under what circumstances this will actually happen. Nevertheless, I have decided (again arbitrarily) that any <b>EOF</b> "characters" that do arrive will be silently ignored. This requires that <b>overflow</b> return something other than the character it received if it does receive an <b>EOF</b>. </P>
<P>The input side is only slightly more complicated. Since I did not want to actually remove characters from the string as they were read, I needed a member variable to keep track of the read position within the string. The functions <B>underflow </B>and <B>uflow </B>are called by the public interface of <B>streambuf</B> when the input buffer is empty, or it does not exist. Again, in this version of <B>String_streambuf</B>, one or the other of <B>underflow</B> or <B>uflow</B> will be called for every character that is read from the stream. The functions assure that the read position hasn't reached the end of the string and then return the character at that position. As you can see, the only difference between the two functions is that <B>uflow</B> increments the read position, but <B>underflow</B> does not.</P>
<P>The <B>pbackfail</B> function handles an attempt to push a character back into the input after it has been read.  (The name comes from the fact that it is called if the public <B>sputbackc </B>function can not push the character back into the input buffer. Since this version of <B>String_streambuf</B> has no input buffer, <B>pbackfail </B>is called on every attempt to push back a character). Again, I decided that the function would not change the underlying string. This was necessary since I expected to often use a <B>String_stream</B> with a <B>const string</B>. <B>pbackfail </B>backs up the input position only if it is not already at the beginning of the string and provided the character being put back is actually the character at that position.</P>
<P>I am not sure that I actually needed to implement the function <B>setbuf</B>. The Standard is not clear (to me anyway) what the default behavior for <B>setbuf </B>is if there is no input buffer assigned. Just to be on the safe side, I provided a version of <B>setbuf</B> that does nothing. It would probably be more appropriate for <B>setbuf</B> to throw an exception, but doing nothing mimics the default behavior of <B>setbuf</B>.</P>
<P>For all other functions, I accepted the default behavior. In particular, I did not implement the two seek functions. Their default behavior is simply to report failure. By design, seeking the output position is not supported &#151; output is always appended to the string, and I decided to ignore attempts to seek the input position because I was lazy. Other functions have default implementations in terms of the functions above, or they do nothing and return an appropriate indication. For example, the <B>sync</B> function does nothing (there is nothing to synchronize in this case), but its return value indicates success. Likewise, the <B>showmanyc</B> function returns zero. This is basically a "don't know" value, not a failure indication. This is what I meant when I talked about how IOStreams has a well-designed <I>protected</I> interface.</P>
<P>The one function to note in this implementation is the <B>uflow</B> function. This is a new function in the Standard version of IOStreams that was not available in classic IOStreams. As you can see from the implementation, <B>underflow </B>returns, but does not consume a character. This is because <B>underflow </B>is called by the public <B>getc</B> function, which does not consume the character in the buffer. But a call to the public function <B>snextc</B> should return the next character available and consume it. In a classic IOStream implementation, this meant that a derived <B>streambuf </B>class had to provide an input buffer of at least one character to hold the value returned by <B>underflow</B> so that it could be processed correctly by either <B>getc</B> or <B>snextc</B>. Obviously, it was typical to provide a much larger buffer, but there was really no such thing as <I>unbuffered</I> input. The addition of the <B>uflow</B> function corrects this.  </P>
<P>As you can see, the various <B>String_stream</B> classes are basically trivial. Their only task is to initialize the <B>String_streambuf</B> and then make the <B>String_streambuf</B> available to their base classes. There is one thing to note: each <B>String_stream</B> class has to initialize its base class with a pointer to the <B>String_streambuf</B>. Because of the order in which C++ constructs base classes and member variables, a <B>String_stream</B> has to initialize its base class before it has a chance to initialize the <B>String_streambuf</B> member. The Standard specifically says that if you initialize a stream class with a pointer to a <B>streambuf</B> that has not been properly initialized the behavior is undefined. One way around this is to allocate the <B>String_streambuf</B> from the free store as part of the initialization of the <B>String_stream</B> base class (e.g. <B>inherited(new Sting_streambuf&lt;StringT&gt;(str))</B> ). This complicates the destructor however, so I just provide a null pointer to initialize the <B>String_stream</B> base class and then call the <B>init </B>function from within the constructor &#151; after the <B>String_streambuf</B> member has been initialized.</P>

<H3><FONT COLOR="#000080">A String_stream Template (Version 2)</FONT></H3>

<P><a href="list2.htm">Listing 2</a> shows my second version of <B>String_stream.</B> The first version of <B>String_streambuf</B> uses a very minimal part of the <B>string</B> interface: the <B>size</B>, <B>operator+=,</B> and <B>operator[] </B>functions<B>.</B> Since every type of string that I could envision using provided these functions, everything was fine, so far. The only problem was that reading data out of a string involved a virtual function call for every character read. Virtual function calls are not expensive, but the whole point of <B>String_stream</B> was to be able to efficiently parse input strings in place. If I could get rid of the virtual function calls, it would be better. All of the string types that I wanted to use also provided a <B>data</B> function. Since the <B>streambuf </B>base class was designed to manipulate a buffer, it seemed reasonable to use the <B>string::data </B>function to provide such a buffer. This led to my second version of <B>String_stream</B> (<a href="list2.htm">Listing 2</a>). You will note that all of the changes are in the <B>String_streambuf</B> class. (This is usually the case.)</P>
<P>By using the internal buffer of a string provided by the <B>data </B>function, the resulting <B>String_streambuf</B> reduces to a very minimalist version. It provides only the <B>overflow </B>function to add characters to the string. Since the buffer always provides access to all the characters currently available, the <B>underflow </B>and <B>uflow </B>functions revert to their default behavior, which is just to report failure (i.e., end-of-file). Likewise the default behavior of <B>pbackfail </B>and <B>setbuf </B>is appropriate &#151; the former does nothing and reports failure; overflow just does nothing.</P>
<P>Unfortunately, while the input side of <B>String_streambuf</B> has been simplified considerably, the output side has paid the price. When you modify a string object, it is possible that all existing references into the string are made invalid. This includes iterators and the pointers returned by the <B>data </B>and <B>c_str </B>functions. Since you do not know when the references will become invalid, you have to program as though every modification invalidates them <a href="#4">[4]</a>. That means that <B>overflow </B>has to reestablish the <B>get</B> buffer area on every call. Note that in order to accomplish this correctly, it has to preserve the value of the current <B>get</B> position in the buffer.</P>

<H3><FONT COLOR="#000080">A String_stream Template (Version 3)</FONT></H3>

<P><a href="list3.htm">Listing 3</a> shows my third version of <B>String_stream</B>. Since I expected to be using a <B>String_stream</B> primarily to read strings and seldom to write them, I was tempted to just leave version 2 alone &#151; but not quite tempted enough. In order to avoid the overhead of having to reset the <B>get</B> area on every call to <B>overflow</B>, I could do one of two things (at least that I thought of immediately). Both ideas depend on the fact that typically you either write or read, but seldom intermix both. In approach one, a flag could be set to indicate that a <B>get</B> buffer was valid. If a call to <B>overflow </B>occurred when the flag was set, it would disable the <B>get</B> buffer by setting the pointers to null and clear the flag before appending the character to the string. Future calls to <B>overflow </B>would find the <B>get</B> buffer marked as invalid and be able to append characters without concern. If the stream switched to input, the invalid <B>get</B> buffer would trigger a call to <B>underflow</B>, which would reset the <B>get</B> buffer.</P>
<P>This approach struck me as having one big disadvantage. It required an <B>underflow </B>function that would have to deal with two situations: an invalid <B>get</B> buffer and no more characters in the string. Not a particularly complicated problem, but like I said before, I am lazy.  So I choose to go with solution two, which was to provide a small buffer to allow output to accumulate before a call to <B>overflow</B> has to update the string and reset the input buffer area.</P>
<P>Now, besides <B>overflow</B>, I have to provide a <B>sync</B> function. This is called (indirectly) whenever the stream is flushed. Note that once I provide <B>sync</B>, <B>overflow</B> does not actually update the string. Instead, it calls <B>sync</B> to append the characters in the buffer into the string and then puts the character it received (the overflow character) back into the buffer. This is perfectly legitimate &#151; <B>overflow</B>'s real job is not to update the string, but just to make some room available in the output buffer. This means that <B>sync</B> is the function responsible for updating the string, so it has to update the <B>get</B> buffer also.</P>
<P>You will note that there is no <B>underflow</B> function. This means that a read can fail, even though there might be characters in the output buffer area that have not yet been transferred to the string. This is what typically happens if you don't call <B>flush</B> between switching from writing to reading the same stream. I could have created a version of <B>overflow</B> that would have checked this situation and called <B>sync</B> if needed, but I decided that it wasn't worth the effort. </P>
<P>Again, the default behavior of the rest of the interface is acceptable. Readers who wish to explore further might consider which, if any, of the other functions listed in the introduction it makes sense to implement. You need to be careful to understand the circumstances under which each of these virtual functions is called, and for that you really need access to a copy of the Standard. As a simple example, the <B>showmanyc</B> function is called by the public <B>is_avail</B> function only when there are no more characters in the input buffer. If there are characters available in the input buffer, <B>is_avail</B> returns that number. This means that the only reasonable implementation for a version of <B>showmanyc</B> is to return the number of characters that are in the output buffer, but not yet in the string.  It doesn't make sense for <B>showmanyc</B> to return the <B>size</B> of the string &#151; that doesn't take into account the number of characters that have already been read. Likewise, if <B>showmanyc</B> returns the <B>size</B> of the string minus the number of characters that have been read, it will always return zero because of the way it is called. Since that is the default behavior, why bother.</P>
<P>I hope that this little example has convinced you that developing a custom version of an IOStream class is not an arcane art. There are some issues that you need to be aware of, and as a result you do need either the Standard or a good reference (e.g., <a href="#5">[5]</a>), but with just a little practice you will find that the vast majority of cases quickly boil down to something like version 3. You can usually get by with a <B>streambuf</B> class that provides an <B>underflow</B>, <B>overflow</B>, and <B>sync</B> function. The actual stream classes are usually just a constructor, with occasionally some additional functions to query the status of the underlying source/sync.</P>
<P>The Standard IOStream library is an excellent abstraction for all sorts of I/O situations. Once you start thinking in terms of a customized IOStream as your source or <B>sync</B> instead of some specialized, one-off, API, you will quickly discover a great deal of synergy with your existing code base. </P>
<P>If you are interested in IOStream bugs, see the <a href="sidebar2.htm">Sidebar</a> "Stupid IOStream Bugs."</P>
<P>Next time, we will look at some other ways to extend the IOStreams library.</P>

<H3><FONT COLOR="#000080">Notes and References</FONT></H3>

<P><a name="1"></a>[1] Jack Reeves. "The (B)Leading Edge: Object Oriented Design and C++," <I>C++ Report</I>, May 2000.</P>
<P><a name="2"></a>[2] Obviously, this is the approach taken by Java <B>interfaces</B>. In C++, it is possible to have both pure <I>interfaces</I> and default implementations by using multiple inheritance. This paradigm is being advocated more and more often as the way to design base class abstractions: provide a pure interface in one class and a default implementation in a separate class. This approach has distinct advantages, but in the meantime IOStreams serves as an excellent example of the more traditional approach.</P>
<P><a name="3"></a>[3] Jack Reeves. "The (B)Leading Edge: More 'string' Utilities," <I>C++ Report</I>, June/July 1999.</P>
<P><a name="4"></a>[4] Some readers might consider the possibility of checking whether <B>str.size()</b> <b>< str.capacity()</b> before appending the character. In many string implementations, if this holds you can be sure that the pointer to the data buffer will not be invalidated. There are string implementations where <b>size()</b> always equals <b>capacity()</b> however. For such strings, we will still need to reset the <b>get</b> buffer after every character. The real solution to this problem is the third version of <b>String_stream</b>.   
<P><a name="5"></a>[5] Angelika Langer and Klaus Kreft. <I>Standard C++ IOStreams and Locales</I> (Addison-Wesley, 2000).</P>

<p><i><b>Jack W. Reeves</b> is an engineer and consultant specializing in object-oriented software design and implementation. His background includes Space Shuttle simulators, military CCCI systems, medical imaging systems, financial data systems, and numerous middleware and low-level libraries. He currently is living and working in Europe and can be contacted via <b>jack_reeves@bleading-edge.com</b>.</i></p>

<h4><a href="../../../source/2001/jan01/reeves.zip"></a></h4>

</blockquote></body></html>
