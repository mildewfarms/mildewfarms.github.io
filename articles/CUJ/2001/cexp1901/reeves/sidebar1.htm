<HTML><HEAD>
<TITLE>January 2001 C++ Experts Forum/The (B)Leading Edge/Sidebar 1</TITLE></HEAD>
<BODY BACKGROUND="" BGCOLOR="#FFFFFF" TEXT="#000000">

<H3 align=center><FONT COLOR="#000080">strstream vs. stringstream</FONT></H3>

<HR>

<BLOCKQUOTE>

<P>I have noticed lately that a lot of C++ programmers are still using <B>strstream</B> instead of <B>stringstream</B>. I am sure that this is partially a consequence of the fact that many of the versions of C++ libraries out there still do not support the new Standard <I>IOStreams</I> model &#151; including <B>stringstream</B>. Unfortunately, I also suspect that it is plain old laziness on the part of a lot of programmers. After all, even though <B>strstream</B> is deprecated in the Standard, that just means that it may be taken out sometime in the distant future, but is still guaranteed to be there in the near future, so why not continue to use it?. This is not a good idea. There are some good reasons that <B>strstream</B> is deprecated in the Standard and <B>stringstream</B> is the preferred mechanism if you need to do in-memory I/O. </P>
<P>Ideally, you could just switch from including <B>&lt;strstream.h&gt;</B> (or <B>&lt;strstream&gt;) </B>to including <B>&lt;sstream&gt;</B> and recompile, but there a few differences between <B>strstream</B> and <B>stringstream</B>, some minor, some major. One of the minor differences is that <B>stringstream::str</B> returns a string object whereas <B>strstream::str </B>returns a <B>const char*</B>.<B> </B>It is the user's responsibility to ensure that the character array returned by <B>strstream</B> is null terminated. This is usually accomplished with the <b>ends</b> manipulator, as in the following</P>

<pre>strstrm &lt;&lt; &quot;...&quot; &lt;&lt; ends;</pre>

<P>Since <B>stringstream</B> returns a <B>string</B> object, this is not only unnecessary, but will result in putting a null character in the <B>string</B>, causing it to be one longer than expected. </P>
<P>The most important difference between <B>strstream</B> and <B>stringstream</B> is that <b>str</b> called on a <b>strstream</b> "freezes" the internal buffer. This makes it the user's responsibility to delete the memory reference returned by <B>str</B>.  Unfortunately, you can not just automatically call <B>delete[]</B> on this pointer. A <B>strstream</B> can be passed a buffer to use instead of allocating an internal buffer. This may be a local buffer not allocated from the free store. Therefore, after a call to <B>str</B>, you have to know how the <B>strstream</B> was constructed before you can correctly decide what to do with the buffer. In practice, <B>strstream</B> is a fertile source of memory leaks (as I can attest from annoying personal experience). I would say this is the primary reason that <B>strstream</B> was deprecated in favor of <B>stringstream</B>. </P>
<P>While <B>stringstream</B> is both more convenient and safer to use than <B>strstream</B>, it does have one drawback. Anyone who knows almost anything about how the IOStreams library is organized knows that it consists of two layers: the formatting layer and the buffering layer. <B>stringstream</B> is no exception. Given this little knowledge, it is easy to assume that the <B>stringbuf</B> component would accept the nomination of a user-supplied <B>string</B> as the source or destination buffer. This is not the case, however. An <B>ostringstream</B> constructor does exist that takes a <B>string</B> as an argument, but if you look at the constructor's signature, you will see that it actually takes a <B>const string&amp;.</B> The contents of any provided string are simply used to initialize the internal buffer. This means that <B>stringstream</B>, or more precisely <B>stringbuf</B>, always manages an internal buffer. This, plus the fact that the <B>stringstream</B>::<B>str </B>function returns a <B>string</B> object, means that <B>stringstream</B> doesn't leak memory. On the other hand, it also means that whenever you use a <B>stringstream</B> to parse some existing <B>string</B> of data, you will probably pay the overhead of a memory allocation and copying of the data itself. Likewise, if you have an existing buffer that you would just like to format some data into, you will also pay for an extra allocation and copy.</P>
<P>So, especially when it comes to parsing some existing <B>string</B>, <B>strstream</B> actually looks like a better choice than <B>stringstream</B>. Unfortunately, <B>strstream</B> does not work very well for the opposite case of formatting data directly into an existing <B>string</B>. Finally <B>strstream</B> <I>is</I> deprecated, and when developing new code there is no excuse for using deprecated features (provided the compiler and library in use support the newer alternatives, of course). By creating my own <B>String_stream</B>&lt;&gt; template, I have solved the dilemma. If I need a stream that manages its own buffer, I use the Standard <B>stringstream</B>. If I have a string that I want to parse in place, or when I want to avoid the overhead of extra memory allocations and data copying, I use my <B>String_stream</B> template. In both cases, the responsibility for memory management in clearly defined: <B>stringstream</B> does its own, and <B>String_stream</B> depends entirely upon the instantiating string type. And once again, the Standard Library proves itself to be a well designed framework for extensions, even if it doesn't provide the optimal solution for every problem.</P>
</BLOCKQUOTE>
</BODY>
</HTML>
