<HTML>   
     <HEAD>
<TITLE>January 2001/Working with SOAP, the Simple Object Access Protocol</TITLE></HEAD>
<BODY BACKGROUND="" BGCOLOR="#FFFFFF" TEXT="#000000">
<H2><A HREF="../tocjan.htm"></A><FONT COLOR="#FF0000">   Mixed-Language Programming</FONT></H2>

<HR>

<H2 ALIGN="center"><FONT COLOR="#800000">Working with SOAP, the Simple Object Access Protocol</FONT></H2>
<H3 ALIGN="center"><FONT COLOR="#800000">Chris Dix</FONT></H3>

<BLOCKQUOTE>
<p>SOAP makes distributed computing possible in a multiplicity of forms, with XML as a communication medium. Little wonder it&#146;s generating so much excitement.</p>
</BLOCKQUOTE>

<HR>
<BLOCKQUOTE>

<p>Note: This article assumes that you are familiar with XML. For a refresher on XML syntax, see the sidebar, <a href="sidebar1.htm">&quot;The Components of XML.&quot;</a></p>

<H3><FONT COLOR="#000080">Introduction</FONT></H3>

<p>SOAP (Simple Object Access Protocol) is a communication protocol based on XML that simplifies the complexities of cross-platform and cross-language interaction. It is one of the cornerstones of Microsoft&#146;s .NET strategy, but it is a standard that is also being supported by IBM and the Apache Software Foundation. The SOAP specification, currently on version 1.1, was originally created by developers at DevelopMentor, Microsoft, and UserLand Software. It has now been submitted to the W3C (World Wide Web Consortium) to allow the protocol to evolve as a standard. SOAP defines a message format, a set of rules for encoding data, a transport binding for HTTP, and a definition for representing RPC (remote procedure calls) using SOAP.</p>
<p>SOAP is likely to become the standard infrastructure for distributed applications because, as the name suggests, it keeps things simple. The authors of the SOAP specification have taken a practical approach to solving the difficulties that developers face when implementing distributed solutions. It does not impose any particular platform, language, library, or object technology on developers; SOAP implementations can be layered on top of any of these. It does not dictate a transport mechanism or what should be done after a message is processed. In this article, I will describe the fundamental aspects of SOAP and how it can be applied as a tool in a C++ application.</p>

<H3><FONT COLOR="#000080">XML As Messages</FONT></H3>

<p>SOAP messages are XML documents. In the SOAP model, these documents are transmitted to an endpoint for processing. The specification defines how this can be done using HTTP in a request-response pattern, but this is only one possible combination. For example, a SOAP message could be transmitted by SMTP to a server which would process it and then broadcast the response message to any number of other SOAP endpoints. SOAP messages can also be routed through a chain of endpoints for processing. This open model allows developers to choose transport protocols and communication patterns that best fit their requirements. As you might expect, SOAP messages are larger because they are XML, and this adds the overhead of parsing to the message processing. These are the disadvantages that come with using XML, but I believe that they are more than compensated for by the open and descriptive nature of the messages.</p>
<p>Unfortuntately, descriptive messages increase the likelihood that name collisions will occur. For example, your organization might define a SOAP message that passes employee information. When you are later called on to integrate your application with another organization using SOAP, you may find that you each have <B>getEmployee</B> messages that have little or nothing in common. This is a problem that has already been solved for XML, and the solution is namespaces <a href="#1">[1]</a>. Namespaces in XML serve the same function that they do in C++: they help resolve ambiguities in names.</p>
<p>In XML, namespaces are declared using attributes. Attributes that are named either <B>xmlns</B> or have <B>xmlns:</B> as a prefix are namespace declarations, and they associate an element (and its children) or a namespace prefix with a URI (Uniform Resource Identifier) <a href="#2">[2]</a>. It is the URI and not the prefix that is important. The attribute <B>xmlns='some-uri'</B> indicates that the default namespace of the element is <B>'some-uri'</B>, while the <B>xmlns:x='some-uri'</B> attribute indicates that any elements prefixed with <B>x:</B> are associated with the <B>'some-uri'</B> namespace. The SOAP message format uses namespaces to identify and version elements, and it is good practice to use namespaces in your application-specific content as well in order to avoid ambiguities.</p>

<H3><FONT COLOR="#000080">SOAP Message Format</FONT></H3>

<p>The specification describes the format of a SOAP message in detail <a href="#3">[3]</a>. The text in <a href="list1.htm">Listing 1</a> shows an example of a SOAP message. There are three elements that make up a SOAP message: the Envelope, Header, and Body. The Envelope and the Body are both mandatory elements of a SOAP message, while the Header is optional.</p>
<p>The Envelope must be the first element of the message. Because the remainder of the message is wrapped by the Envelope, it is used to provide information about the version and serialization rules of the message. The version of SOAP being used is indicated by the namespace of the Envelope element. If you want your messages to be compliant with the current specification, the namespace URI of the Envelope must be <B>'http://schemas.xmlsoap.org/soap/envelope/'</B>. If the Envelope has any other namespace URI, then a server application has to reject it. The serialization rules, or encoding style, of the message is indicated by the <B>encodingStyle</B> attribute of the Envelope. These are the rules that describe how types and values will be represented in the message. The rules defined in the specification are represented by the namespace URI <B>'http://schemas.xmlsoap.org/soap/encoding/'</B>. If you need to follow some other standard for formatting data, you can use a different style. You can even elect to declare no style at all by providing a blank value for the attribute. Based on my experience, I believe that the encoding style that the specification defines will satisfy the needs of most developers because it was designed for RPC and thus uses familiar conventions.</p>
<p>The SOAP Header is optional and serves as a means of extending the SOAP message format. Elements can be placed in the Header to define additional valuable features such as encryption, transaction processing, or authentication; or you can add a Header element that meets the needs of your application. There are two attributes that define how applications must process an element in the Header. The first, <B>actor</B>, indicates the endpoint that the Header element is intended for. This allows messages to be passed through a chain of processing endpoints, each working only with the portion of the message that they need. The second, <B>mustUnderstand</B>, indicates that the processing of a Header element is mandatory. For example, a Header element containing a transaction ID might be marked as <B>mustUnderstand</B> to ensure that endpoints processing the message will consider it part of a transaction or reject it outright.</p>
<p>The Body element contains the actual contents of the message, and this is where you can place the data that your application needs to exchange. In the example in <a href="list1.htm">Listing 1</a> the Body contains a child element that describes a remote procedure call, but it could have contained any number of XML elements that the application required. When using SOAP messages as remote procedure calls, the specification defines how the Body should represent the call and response. A function call and response are each mapped to an element, and the children of that element are the parameters. The call element must be named just as the call itself is named, and the name of the response element is ignored. Parameter elements are named to correspond with the parameters. Only inbound parameters appear in the call, and only outbound parameters appear in the response. The specification also defines that the first child element of the response is the return value of the function. In <a href="list1.htm">Listing 1</a>, the message is calling a function that maps to the C++ syntax below:</p>

<pre>
string DoCreditCheck( string ssn );
</pre>

<p>The Body in <a href="list1.htm">Listing 1</a> shows an example of how a namespace declaration can be used to better identify elements in the message. The prefix <B>m:</B> that appears on the <B>DoCreditCheck</B> element is there to indicate that this element is associated with the namespace URI <B>'http://no-duh.com/credit/'</B>. This URI could have been any valid URI, but it is convenient to choose identifiers based on the URL of the service or schema. This lets the recipient of the message know that not only does this message contain a <B>DoCreditCheck</B> invocation, but it is the <B>DoCreditCheck</B> defined by <B>no-duh.com</B>. It is the responsibility of the SOAP endpoint to validate that the messages it receives correspond to the namespace that it expects.</p>
<p>There is one other case in which the structure of the Body is currently defined, and this is when the Body contains a Fault. The Fault element is the method defined by the specficiation for transmitting error information in a SOAP message, and it should appear only in messages that communicate error or status information. In the example request, the <B>ssn</B> parameter was invalid, so the server response contains a Fault describing the error. <a href="list2.htm">Listing 2</a> shows an example of such a response. The Fault element contains information about who generated the error, what type of error occurred, and the details of the error.</p>

<H3><FONT COLOR="#000080">Binding SOAP to a Transport Protocol</FONT></H3>

<p>Once you have composed a SOAP message, what do you do? Well, that sort of depends on the situation. SOAP messages can be transmitted in any fashion that the application requires. As long as the client and server have agreed upon a method, they can exchange SOAP messages. The specification only describes a single protocol binding, and that is for HTTP.</p>
<p><a href="list3.htm">Listing 3</a> shows an example of a SOAP message sent using HTTP. The specification defines that requests should be sent using an HTTP POST. (The HTTP Extension Framework&#146;s M-POST may also be used <a href="#4">[4]</a>). In the POST, the <B>Content-Type</B> header must be set to <B>'text/xml'</B> to indicate that you are posting an XML document. There is also one special header for a SOAP HTTP POST: the <B>SOAPAction</B> header. The <B>SOAPAction</B> header is defined by the specification as a tool to help filter SOAP requests using firewalls. As of the 1.1 specification, this header is mandatory, but it can be blank if the address of the request is enough to identify the purpose of the message. With normal HTTP, the common pattern for message exchange is request-response, and it is no different for SOAP over HTTP. An example of an HTTP response to the previous request is provided in <a href="list4.htm">Listing 4</a>.</p>

<H3><FONT COLOR="#000080">Namespaces Revisited</FONT></H3>

<p>I think it is useful to point out the differences in how namespaces are used in the example messages. Notice that the prefix for the namespace of the Envelope changes from <B>'SOAP'</B> in <a href="list1.htm">Listing 1</a> to <B>'SOAP-ENV'</B> in <a href="list3.htm">Listing 3</a>. The prefix is irrelevant; it just needs to be consistent within the message; but the URI is important. After reading the specification, some people not familiar with namespaces might think that <B>'SOAP-ENV'</B> is the required namespace prefix just because it is used throughout the document. Also, the namespace used by the Body contents appears on the Body element in <a href="list3.htm">Listing 3</a>, while in <a href="list1.htm">Listing 1</a>, the namespace is declared on the Envelope. Both of these are legal because namespace declarations apply to the element they appear on as well as its child elements. If you are using an XML parser to process your SOAP messages, these issues will probably be handled for you, but if you are parsing the message yourself, you should be aware of these types of issues.</p>

<H3><FONT COLOR="#000080">Misconceptions</FONT></H3>

<p>Since I began working with SOAP, I have found a couple of common misconceptions. First, SOAP is not XML-based remote procedure calls. Part of the specification deals specifically with how SOAP can be used to perform remote procedure calls, and the fact that SOAP shares a common history with XML-RPC clearly indicates that SOAP was built with this in mind <a href="#5">[5]</a>. While SOAP does work very well as a vehicle for RPC, the specification has grown beyond that. The format of the SOAP message is not inherently procedural. The latest version of the BizTalk Framework, Microsoft&#146;s initiative for standardizing XML exchange for electronic commerce, uses SOAP messages to exchange business documents <a href="#6">[6]</a>.</p>
<p>Second, SOAP is often described as being coupled with HTTP. It is true that the specification does describe how SOAP can be used with HTTP as the underlying transport protocol, but SOAP is not linked to any particular transport. SOAP is a higher level protocol than HTTP, more comparable to CORBA&#146;s IIOP, and can use any number of transport protocols to transfer messages. Some work has been done in defining an SMTP binding for SOAP, and likely candidates for additional bindings include MSMQ (Microsoft Message Queue). The transport mechanism could even be as simple as writing a SOAP message to a file and dropping it into an &quot;inbox&quot; directory for processing.</p>

<H3><FONT COLOR="#000080">Building a SOAP Client in C++</FONT></H3>

<p>Now that I have mentioned what I believe are the common misconceptions, I can admit that much of the excitement surrounding SOAP is due to its ability to make RPC over HTTP simple. I have written a simple C++ client application that uses HTTP to exchange RPC messages with two different servers. Each time the application is executed it requests a stock quote from an example SOAP endpoint provided by Microsoft, and the results are sent to an endpoint at the SOAP-Web Services Resource Center. In order to view the results of the exchange, you can view the modified page at <B>http://www.soap-wrc.com/webservices/defaultdemo.asp</B>. The site requires a login for registered users, but for the purposes of the example I created a dummy user with a login of &quot;cuj&quot; and a password of &quot;stroustrup&quot;. You can tell which items you generate because the text of those items will contain the host name of the machine the application was executed on.</p>
<p>The application uses some utility classes that I have written to simplify sending the SOAP message over HTTP. <B>SimpleSoapRpcMessage</B> is a class that builds a SOAP RPC message based on a given method name and parameter values. <B>SoapHttpPostTransfer</B> handles the details of SOAP message exchange for the HTTP protocol binding. An example of how these classes can be used is printed as <a href="list5.htm">Listing 5</a>. These classes handle only simple XML (no <B>CDATA</B> sections or entity references). <B>SimpleSoapRpcMessage</B> can parse the return value from an RPC response message, but it cannot handle any out parameters other than the return value. The example messages in <a href="list3.htm">Listings 3</a> and <a href="list4.htm">4</a> show the format of the request and response messages exchanged with the Microsoft endpoint.</p>
<p>In this example, we knew everything about the client, servers, and the messages they would exchange because we hardcoded it all. The classes I have written for this article can handle this simple XML without a parser, but in reality, most applications won&#146;t always be receiving simple XML. I chose not to use an XML parser for this example in order to avoid a discussion on how to use a particular parser, but there are several free parsers available, including James Clark&#146;s expat, the Microsoft MSXML parser, and Apache&#146;s Xerces. Do not try to build a real C++ SOAP application without a parser. They are free, and they will make your life much easier.</p>

<H3><FONT COLOR="#000080">Next Steps</FONT></H3>

<p>SOAP is a relatively new technology, and there is room for it to grow. For instance, SOAP does not address several key areas of distributed systems, such as garbage collection and passing references to objects. SOAP as described by the 1.1 specification is a stateless protocol, so persistent object references are not possible without additional work. There are no facilities for transaction processing and no security beyond what the transport binding can provide. These are the types of services that really add value to a distributed architecture such as CORBA or DCOM. The specification provides a placeholder for these services in the SOAP Header element, and a standard format for these types of headers will hopefully be defined as vendors begin adding SOAP support to their tools. Because of the layer at which SOAP operates, DCOM or CORBA could possibly be built on top of SOAP and give developers the best of both worlds.</p>
<p>The SOAP specification does not define how servers will describe their services or how clients will discover those descriptions. For robust client and server implementations to be built, some sort of definition language and discovery method for SOAP services must be decided upon.</p>
<p>Recently there has been an attempt to resolve the issue of service description. WSDL (Web Services Description Language) is a joint proposal from Microsoft, IBM, and Ariba. It is a combination of the best of two earlier proposals (Microsoft&#146;s SDL, the Service Description Language, and IBM&#146;s NASSL, the Network Accessible Service Specification Language), and it provides an XML syntax for describing any number of Web Services, including those based on SOAP. The creation of WSDL is a very encouraging step for developers using SOAP because it will allow us to write tools and processes that can automatically determine the functionality a SOAP endpoint. WSDL syntax allows developers to define one or more SOAP message formats using schemas. Messages are then bound to one or more addresses that are SOAP endpoints. WSDL also allows these types of descriptions to be defined for protocols other than SOAP, such as standard HTTP POST. You can find the full WSDL specification at <B>http://msdn.microsoft.com/xml/general/wsdl.asp</B>. For additional SOAP resources, see the sidebar, <a href="sidebar2.htm">&#147;SOAP Resources.&#148;</a> </p>
<p>Finally, the SOAP reference implementations will continue to improve. Currently there are known issues with trying to make the Microsoft and IBM toolkits cooperate. These are not issues with the SOAP specification, just simple bugs that will get fleshed out over time. I mentioned earlier that SOAP applications are trivial when you know who your client and server are. Building generic, flexible SOAP clients and servers is far more complex, and it is important that Microsoft, IBM, Apache, and others collaborate when it comes to testing and to extending the protocol.</p>

<H3><FONT COLOR="#000080">Conclusion</FONT></H3>
<p>SOAP is a new technology that is going to help ease the burdens of distributed computing. It is likely that SOAP functionality will be built into the plumbing of every development tool, application server, and ORB in the near future. I have spent some time building tools to simplify SOAP development, and my experiences have convinced me that SOAP can be incorporated into applications today. Even though you may someday reap the benefits of SOAP without ever touching XML, it is still important to understand the core components and how you can use SOAP to solve problems today. Most developers have experienced the frustration of trying to find and debug problems with wizard-generated code. For many of us, SOAP-enabling wizards are right around the corner, and if we don&#146;t understand the plumbing, we won&#146;t be able to fix the leaks.</p>

<H3><FONT COLOR="#000080">Acknowlegdements</FONT></H3>

<p>I would like to thank both James Snell and Microsoft for providing the SOAP endpoints that I used in the example application. I would also like to thank Dave Winer, who answered several questions for me while I was working on this article.</p>

<H3><FONT COLOR="#000080">References</FONT></H3>

<p><a name="1"></a>[1]  Various authors. &quot;Namespaces in XML Recommendation,&quot; January 1999, <B>http://www.w3.org/TR/REC-xml-names</B>.</p>
<p><a name="2"></a>[2]  Don Box, Aaron Skonnard, and John Lam. <I>Essential XML: Beyond Markup</I> (Addison-Wesley, 2000).</p>
<p><a name="3"></a>[3]  Don Box et. al. &quot;Simple Object Access Protocol (SOAP) 1.1,&quot; May 2000, <B>http://www.w3.org/TR/SOAP/</B>.</p>
<p><a name="4"></a>[4]  H. Neilsen et. al. &quot;HTTP Extension Framework,&quot; September 1999, <B>http://www.w3.org/Protocols/HTTP/ietf-http-ext/draft-frystyk-http-extensions-03</B>.</p>
<p><a name="5"></a>[5]  Dave Winer, The XML-RPC Specification, <B>http://www.xml-rpc.com/spec</B>.</p>
<p><a name="6"></a>[6]  Microsoft Corporation. &quot;BizTalk Framework Specification 2.0,&quot; June 2000, <B>http://msdn.microsoft.com/xml/articles/biztalk/biztalkfwv2draft.asp</B>.</p>

<p><i><B>Chris Dix</B> is a senior software developer for FMStrategies, a division of Little and Associates Architects. He has developed applications for Windows platforms using C++ for the past seven years, and he is currently building SOAP functionality into everything he can get his hands on. When he does have spare time, he spends it with his wife and two sons. He can be reached at <B>soap4vb@carolina.rr.com</B>.</i></p>

<h4><a href="../../../source/2001/jan01/dix.zip"></a></h4>

</blockquote></body></html>
