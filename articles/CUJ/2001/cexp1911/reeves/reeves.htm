<HTML>   
     <HEAD>
<TITLE>November 2001 C++ Experts Forum/The (B)Leading Edge</TITLE></HEAD>
<BODY BACKGROUND="" BGCOLOR="#FFFFFF" TEXT="#000000">
<H2><A HREF="../../19.11/tocnov.htm"></A><FONT COLOR="#FF0000">   C++ Experts Forum</FONT></H2>

<HR>

<H2 ALIGN="center"><FONT COLOR="#800000">The (B)Leading Edge: Using the XDR_Stream Class, Part II</FONT></H2>
<H3 ALIGN="center"><FONT COLOR="#800000">Jack W. Reeves</FONT></H3>

<HR>
<BLOCKQUOTE>


<H3><FONT COLOR="#000080">Backtracking</FONT></H3>
   
<p>In this installment of &quot;The Bleading Edge,&quot; I had intended to continue the examination of my new <b>XDR_Stream</b> class and look at some of the other enhancements I found useful to add to the <b>XDR_Stream</b> library. Before I can do that, I have to make a confession. The code in the previous column is <i>wrong</i>. It is not just a little wrong either &#151; it is so wrong that absolutely nothing should work. Unfortunately (and I use that term advisedly), it does work &#151; and not just on one platform, but on all the platforms where I could get it to compile <a href="#1">[1]</a>. In fact, I was growing quite pleased with how well it seemed to be working. At this point, a little explanation is probably in order, especially since I think this is a fairly important point.</p>
<p>When I first created <b>XDR_Stream</b>, my <b>XDR_Char</b> was a POD (plain old data) <a href="#2">[2]</a> <b>struct</b>. This meant it had no constructors, destructors, virtual functions, etc. As such, it met the requirements for a &quot;character&quot; type that could be used to specialize the templates in the IOStreams library. When I first tried to compile a test program of my <b>XDR_Stream</b> class, I got a compile error deep inside the IOStream library. The error was located in a function named <b>widen</b>. I checked and <b>widen</b> is a member function of <b>basic_ios</b>. It was being used to initialize the &quot;fill&quot;<b> </b>character that is maintained by <b>basic_ios</b>. This initialization was part of the <b>init</b> function invoked by an <b>XDR_Stream</b> constructor. The compiler was complaining that there was no way to convert the regular default fill character (a blank) into an <b>XDR_Char</b>.</p>
<p>Since <b>XDR_Stream</b> I/O operations never make any use of the fill character, I didn't really care how it got initialized (or even whether it was initialized or not), so I just looked for a quick way to get rid of the compile error. There was a bold hint in the library code where the error occurred that my <b>XDR_Char</b> type needed a converting constructor that would take a regular <b>char</b>. With the hint staring me in the face, I added two constructors to <b>XDR_Char</b>, the necessary converting constructor and a default constructor. I was not too happy about doing this since it meant that my <b>XDR_Char</b> type no longer qualified as a POD <b>struct</b>, which in turn meant that my <b>basic_ios</b> specialization was now into the realm of &quot;undefined behavior.&quot; On the other hand, my code now compiled, and I figured I knew enough about the real requirements for a character type used to specialize an IOStreams template that I could get away with a little undefined behavior. Soon, I was too busy with other issues to worry about it.</p> 
<p>About the time I finished the last column, release 3.0 of the GNU Compiler Collection became available. I was really looking forward to this since release 3.0 has the new Standard C++ library. (The previous release had still been using a non-templatized version of IOStreams, so I had not been able to try my <b>XDR_Stream</b> library with it.) Shortly after I sent in the column, I sat down to try my <b>XDR_Stream</b> library out with the new G++ compiler. First off, my code compiled without even a warning. I was quite pleased by this. Then I tried to run my first test program, and it blew up in my face &#151; segmentation fault. After spending some time with the debugger, I determined that the fault was occurring in the <b>basic_ios::init</b> function when it was trying to initialize the <b>fill</b> data member.</p>
<p>Now, I am much too paranoid to assume it was just coincidence that two different Standard C++ libraries would both give me problems at basically the same place. I figured there was something wrong with my code, no matter how well it seemed to work on two other platforms &#151; two platforms that I now realized both used the same standard library. So I first went to the source, the ISO C++ Standard, to see if I could figure out what exactly should be happening. The Standard clearly states that <b>init</b> will initialize the <b>fill</b> member to <b>widen(' ')</b>. I knew that much already. So I looked at the definition of <b>widen</b>. Unfortunately, it says:</p> 

<BLOCKQUOTE>
<p>Returns: <b>use_facet&lt; ctype&lt;char_type&gt; &gt;(getloc()).widen(c);</b></p>
</BLOCKQUOTE>

<p>I was disgusted. I didn't have to check (although I did) to know that <b>use_facet</b> should throw an exception if the requested facet is not in the specified locale. Since I had figured that <b>XDR_Stream</b> did not need any locale-specific information in order to do its formatting, I had not bothered to create a <b>ctype</b> facet for <b>XDR_Char</b>. Much to my chagrin, I was just now discovering that I needed one. </p>
<p>My first reaction was to be triply upset. First I was upset with the C++ Standard that it would require something like this special facet just to initialize the <b>basic_ios</b> class. If it needed to be something that could be customized, why not have the <b>widen</b> (and <b>narrow</b>) functions be part of the character traits type that has to be provided for any character type used to specialize <b>basic_ios</b> anyway. I quickly got over this pique &#151; how you convert one character type to another depends not only on the data types involved, but also on the actual character set in use. Providing this information is what locales are for. </p>
<p>Next, I was upset with both libraries. Both of them are incorrect. The first actually works with incorrect code, while the second gets a segmentation fault instead of throwing the required exception. Armed with the knowledge of what should be happening, I was quickly able to find the bugs in both libraries. I couldn't get too upset about the first library, however. After all, its bug allowed my code to work. I suspect that the library's implementers may have felt the same way I did about the uselessness of having to create and install a special facet just to be able to initialize <b>basic_ios</b>. Whatever the reason, they just bypassed the call to <b>use_facet</b> in the <b>basic_ios</b>::<b>init </b>function and invoked the default behavior of the <b>ctype </b>template's <b>widen</b> function directly.</p>
<p>The second library was slightly more annoying. My incorrect code would not run using that library, which overall is more correct, but getting a segmentation fault instead of the correct exception is still annoying. </p>
<p>In any case, I couldn't get too upset at either library. This is not in the &quot;lots of people use it every day, so why wasn't it tested properly&quot; category. In fact, it is pretty far out on the bleeding edge. (There is a reason this column has the name that it does.) Besides, my own code was also wrong. This left me primarily upset at myself for not having thoroughly investigated the requirements for specializing <b>basic_ios</b>. I was especially annoyed that there had been at least one compiler generated hint, which I had ignored. </p>
<p>I have gone into this explanation because it provides a good object lesson about something that I (and many other writers) harp about &#151; the need to ensure your code does not exhibit undefined behavior. In this case, I think the code should have had well-defined behavior &#151; an exception &#151; but that just makes the point more valid. It is easy to assume that undefined behavior will always lead to something like a segmentation fault, but it doesn't have to. As this example clearly shows, undefined behavior can interact with other bugs or other code that also has undefined behavior to result in something that appears to work just fine. Unfortunately, as is also shown by this example, it may work just fine on only one platform or with only one particular version of the library, or even with only a specific set of compiler options. When the code gets ported later, its behavior may change. Since ports are often done by people other than the original developer, figuring out what is wrong can turn into a major debugging effort.</p> 
<p>You may be thinking "If Jack can make this kind of mistake, and both libraries also got it wrong, what hope do I have?" First, let's admit that the ordinary programmer probably isn't going to be doing stuff like this. But that is beside the point. People like me spend time creating libraries like <b>XDR_Stream</b> in an attempt to make other people's programming easier. If we do our jobs right, then ordinary programmers do not have to worry about such details, but there will always be details that have to be worried about. The real point of my baring my soul like this is to emphasize the need to be aware of the problem. Programmers dance with undefined behavior every day. Practically every API in existence has some requirements that have to be met but are not checked. (The STL has a lot of examples.) The only real defense is to actually know what you are doing, and that means study and practice. Obviously, your risks go up when you are doing something new. This is the time to take it slow and make sure you understand the details. A little extra effort in getting it right can pay big dividends down the road.</p> 
<p>In order to get my code to work correctly, I had to move it back into the realm of defined behavior and work around the bugs in the two libraries. To do this, I first made my <b>XDR_Char</b> a synonym for a built-in type &#151; <b>uint32</b>. This makes it a POD type as required by the Standard. It also works around the bug in the first library since the compiler will now accept a statement of the form:</p>

<pre>
XDR_Char(c)
</pre>

<p>as a request to cast <b>c</b> to be an <b>XDR_Char</b> <a href="#3">[3]</a>. Bypassing the bug in the second library just involved fixing the code in general. This meant specializing the <b>ctype</b> facet for <b>XDR_Char</b> and installing it into the global locale. The latter is handled by the <b>XDR_Stream</b> constructor. It uses <b>has_facet&lt; ctype&lt;XDR_Char&gt; &gt;(getloc())</b> to see if the facet has already been installed. If not, it creates and installs the facet. After this, the <b>basic_ios init</b> function should now be able to correctly initialize its <b>fill</b> data element.</p>

<H3><FONT COLOR="#000080">Reader feedback</FONT></H3>
   
<p>This leads me to a similar topic. One reader emailed me a question about why I decided to create <b>XDR_Stream</b> as a class directly instead of explicitly specializing <b>basic_iostream</b> and its siblings. His reasoning was that if I did the latter, then such things as file-based and memory-based XDR streams would come along for free by just instantiating the templates for <b>basic_fstream</b>, <b>basic_stringstream</b>, etc. The simple answer is that while I originally considered specializing <b>basic_istream</b>, <b>basic_ostream</b>, and <b>basic_iostream</b>, I did not think it through. This is another example of the need to explore and understand all the options when venturing into new territory. </p>
<p>Having now explored it more thoroughly, I am not sure it will work.</p> 

<pre>
template&lt;class charT&gt; struct char_traits;
</pre>

<p>has to be available to support explicit specialization. In addition, the two explicit specializations:</p>

<pre>
template&lt;&gt; struct char_traits&lt;char&gt;;
template&lt;&gt; struct har_traits&lt;wchar_t&gt;;
</pre>

<p>have to be provided. Beyond that, the Standard only specifies the <i>requirements</i> for the members of <b>struct char_traits</b>. My interpretation of this has always been that an implementation is not required to provide an actual definition of <b>struct char_traits</b> that can be instantiated. This means that every other character type that needs to specialize <b>char_traits</b> has to have an explicit specialization provided by the user. Nevertheless, every standard library implementation that I currently use does provide a definition of <b>template struct char_traits</b>. This means that such things as <b>basic_string&lt;unsigned char&gt;</b> will actually compile and work on these platforms without having to provide an explicit specialization of <b>char_traits&lt;unsigned char&gt;,</b> but I think this falls into the undefined behavior category. Library vendors can and do provide facilities in their libraries that go beyond what the Standard requires. Furthermore, the Standard is clear that library vendors are free to provide an implementation in any manner that meets the required behavior. The Standard says nothing about any protected interface in the definition of <b>basic_iostream&lt;&gt;</b> and its relatives; it only defines the public interface. Nor does it place any restrictions on how a class specified as a derived class in the Standard can use facilities provided by its base class. An implementation can add protected member functions to a base class such as <b>basic_iostream</b>. Naturally, the implementation of derived classes such as <b>basic_fstream</b> can use the implementation-defined extensions. Since <b>basic_iostream&lt;XDR_Char&gt;</b> would be an explicit specialization, it would not even be providing all of the same public member functions of <b>template class basic_iostream</b>, let alone support any implementation-defined extensions. Therefore, I am forced to reluctantly conclude that if I provide <b>XDR_Stream</b> as an explicit specialization of <b>basic_iostream&lt;XDR_Char&gt;</b>, then behavior of any Standard classes derived from that explicit specialization would be undefined. If <b>basic_fstream&lt;XDR_Char&gt;</b> and <b>basic_stringstream&lt;XDR_Char&gt;</b> happen to work, that's nice, but not something I can depend upon being portable. </p>
<p>My latest definition of the <b>XDR_Stream</b> classes is shown in <a href="list1.htm">Listing 1</a> (<b>XDRStream.h</b>). The implementations of these classes are contained in several different files not shown here.  All source code is available for download from the <i>CUJ</i> website. The source code also contains a file <b>XIOStream.h</b> that defines the classes <b>XIOStreambuf</b>, <b>iXIOStream</b>, <b>oXIOStream</b>, and <b>XIOStream</b>. These are concrete classes derived from the appropriate classes in <b>XDRStream.h</b>. The <b>XIOStreambuf</b> class provides a wrapper around an existing <b>Streambuf</b>. This way, you can create an <b>XIOStream</b> out of any other existing stream.</p>
<p>To summarize the developments up to this point:</p>

<UL>
<LI>I wanted to create a facility that would encode and decode data using the XDR protocol. Specifically, I wanted to create an object-oriented interface that could be used in place of the standard, low-level <b>xdr_foo</b> library functions. </LI> 
<LI>I decided that I wanted this new XDR protocol class to be modeled on the IOStreams library. </LI>
<LI>I wanted to use as much functionality from the IOStreams library as I could. I hoped that the fact that the Standard IOStreams was template based and could be specialized on the type of character the stream was suppose to read/write would help</LI>
<LI>I created an <b>XDR_Char</b> type and proceeded to specialize the <b>basic_streambuf</b> template using that new character type.</LI>
<LI>I created <b>iXDR_Stream</b>, <b>oXDR_Stream</b>, and <b>XDR_Stream</b>, which provide the functions that would encode/decode the basic data types specified by the XDR protocol.</LI>
</UL>

<p>All of this was described in <a href="#4">[4]</a>. </p>
<p>Next I started using my new <b>XDR_Stream</b> class and promptly started refining it in several ways.</p>

<UL>
<LI>I cleaned up the interface and renamed some of member functions to make their usage more intuitive.</LI>
<LI>I added several new functions to the interface to provide better support for data that was accessed via pointers. In particular, I added better support for arrays that were variable length and needed to be allocated from the free store, and for cases where pointers were used to indicate that the corresponding data elements were optional.</LI></UL>

<p>This was described in <a href="#5">[5]</a>.</p>
<p>Finally, I mentioned that one of my goals with <b>XDR_Stream</b> was to create not only a mechanism that made it easier to use XDR as a communications protocol, but also to provide some facilities to support a simple object persistence mechanism. Up to this point, everything I have described, and all the refinements that I have made, have been equally applicable to both the communications and the persistence domains. What I am going to present in the rest of this column are a couple of enhancements that are primarily added to support the object persistence role. </p> 
<p>To repeat my summary from the last column, pointers are often used for four reasons:</p>

<OL>
<LI>when array data has variable lengths that can only be determined at run time</LI>
<LI>when data is optional</LI>
<LI>when reference semantics (instead of value semantics) are required</LI>
<LI>when polymorphism is required</LI></OL>

<p>In the last column I discussed enhancements to <b>XDR_Stream</b> for the first two cases. The rest of this column discusses the last two cases. I will continue with the same example that I was using in the previous column: a simple contact database. Please see <a href="#5">[5]</a> for more details.</p>

<H3><FONT COLOR="#000080">Reference Semantics</FONT></H3>
   
<p>Sometimes pointers are used because reference semantics are required. This is true for a lot of complex data structures such as trees. It can also be the case that it is simply desirable that all references to a value to be to a single copy of that value. In our example, let us suppose that many of the <b>Contact</b>s have the same <b>City</b> and <b>State</b> as part of their address. To save space, that part of <b>Address</b> is changed to use reference semantics:</p> 

<pre>
struct Address {
    std::string    street1;    
    std::string    street2;    
    CityState*     cityState;    
    char           zip[5];    
};
</pre>


<p>Now things start to get a little interesting. There are lots of different ways that reference semantics can be encoded. A linked list can just serialize the value portion of the data in order and reconstruct the links when the data is read back. Arbitrarily complex networks are only slightly more difficult. </p>
<p>Conversely, for something like the above, it might be reasonable just to treat the reference as a value and serialize the <b>CityState</b> object as part of every <b>Address</b>. When the objects are decoded, the <b>CityState</b> pair can be checked to see if it is a duplicate and eliminated if so.</p> 
<p>There is obviously no single solution for dealing with reference semantics. Nevertheless, I decided that it might be useful for <b>XDR_Stream</b> to provide some basic capabilities to support common situations. The most common situation (that I could think of) involves substituting a unique object ID for the pointer. Somewhere else, an association between the object ID and its value has to be established. </p> 
<p>I decided to add a dictionary to the <b>oXDR_Stream</b>. This is class <b>ObjToIdMap</b>. This map can be accessed via the member function:</p>

<pre>
obj2id
</pre>

<p>It provides three operations:</p>

<pre>
long find(const void* obj)
</pre>

<p>takes a pointer to an object, looks it up in the map, and returns the ID for that object. Zero is an invalid ID and is returned if the object pointer is not in the map.</p>

<pre>
pair&lt;long, bool&gt; insert(const void* obj);
</pre>

<p>inserts an object pointer in the map, assigning it the next sequential ID. The return value is the ID assigned to that object and a flag to indicate whether the ID was newly assigned or not (duplicate object pointers are not allowed).</p>

<pre>
long operator[](const void* obj);
</pre>

<p>The index operator will return the object ID for the pointer, inserting a new one into the map if necessary.</p>

<p>This map provides a way of associating objects with unique IDs on a per stream basis. In a simple case, when a new object ID is created, both the object ID and the object value can be encoded into the stream. Thereafter, when a reference to the same object is seen again, only its ID is encoded into the stream. Using our example, I might have</p>

<pre>
oXDR_Stream&amp; operator&lt;&lt;(oXDR_Stream&amp; oxs, const Address&amp; addr) {
  oxs &lt;&lt; addr.street1 &lt;&lt; addr.street2;
  pair&lt;long,bool&gt; rtn = oxs.obj2id().insert(addr.cityState);
  oxs &lt;&lt; rtn.first;
  if (rtn.second) oxs &lt;&lt; *addr.cityState;
  oxs.vput_string(addr.zip, sizeof(addr.zip));
  return oxs;
}
</pre>

<p>Obviously, I must have an <b>operator&lt;&lt;</b> function that can encode the contents of a <b>CityState</b> object.</p>
<p>On the input side, I have a corresponding <b>IdToObjMap</b> (and the <b>id2obj</b> accessor function). It provides similar functions.</p>

<pre>
void* find(long id);    
</pre>

<p>takes an object ID and returns the pointer to that object, if one exists. A null pointer is returned if the object ID has no corresponding object.</p>

<pre>
pair&lt;void*, bool&gt; insert(long id, void* obj);
</pre>
  
<p>will insert the object ID into the map along with the pointer. The pointer can be null at this point. The return value is the pointer associated with the object ID, and a flag that indicates whether the object ID was already in the map (the standard STL convention is followed: a true indicates that <b>insert</b> succeeded in adding a new ID to the map).</p>

<pre>
void*&amp; operator[](long id);
</pre>

<p>The index operator will lookup the ID, inserting it if necessary, and return an reference to the pointer that is associated with the object ID. Since a reference is returned, this function can be used to change the pointer associated with an object ID.</p>
<p>If I have the encode function above, my corresponding decode function might look something like the following:</p>

<pre>
iXDR_Stream&amp; operator&gt;&gt;(iXDR_Stream&amp; ixs, Address&amp; addr) {
  ixs &gt;&gt; addr.street1 &gt;&gt; addr.street2;
  long id;
  ixs &gt;&gt; id;
  pair&lt;void*,bool&gt; rtn = ixs.id2obj().insert(id, 0);
  if (not rtn.second) {
    addr.cityState = static_cast&lt;CityState*&gt;(rtn.first);
  } else {
    addr.cityState = new CityState;
    ixs &gt;&gt; *addr.cityState;
    ixs.id2obj()[id] = addr.cityState;
  }
  ixs.vget_string(addr.zip, sizeof(addr.zip));
  return ixs;
}
</pre>

<p>Again after some contemplation, I decided that I could simplify things by adding a little bit of capability to the <b>XDR_Stream</b> itself. In particular, I wanted to hide the use of the <b>ObjToId</b> and <b>IdToObj</b> maps. So, on the <b>oXDR_Stream</b> side I added the function:</p> 

<pre>
bool put_objId(oXDR_Stream&amp;, const void* obj);
</pre>

<p>This looks up the pointer, gets the object ID, and encodes it in the stream. The return value indicates whether the object ID is new. With this function, my first example can be reduced to:</p>

<pre>
oXDR_Stream&amp; operator&lt;&lt;(oXDR_Stream&amp; oxs, const Address&amp; addr) {
  oxs &lt;&lt; addr.street1 &lt;&lt; addr.street2;
  bool isNew = put_objId(oxs, addr.cityState);
  if (isNew) oxs &lt;&lt; *addr.cityState;
  oxs.vput_string(addr.zip sizeof(addr.zip));
  return oxs;
}
</pre>

<p>On the input side, I had to add two functions: </p>

<pre>
void* get_objId(iXDR_Stream&amp;, long&amp; id);    
iXDR_Stream&amp; map_objId(iXDR_Stream&amp;, long id, void* obj);
</pre>

<p>The first reads the object ID from the stream, looks it up in the <b>id2obj</b> map &#151; inserting it if necessary &#151; and returns the resulting object pointer. It also returns the object ID for additional use. The second function will assign the object pointer to the ID. With these two functions, I can now write my <b>CityState</b> decoder as follows:</p> 

<pre>
iXDR_Stream&amp; operator&gt;&gt;(iXDR_Stream&amp; ixs, Address&amp; addr) {
  ixs &gt;&gt; addr.street1 &gt;&gt; addr.street2;  
  long id;
  addr.cityState = reinterpret_cast&lt;CityState*&gt;(get_objId(ixs,id));
  if (not addr.cityState) {    
    addr.cityState = new CityState;    
    ixs &gt;&gt; *addr.cityState;    
    map_objId(ixs, id, addr.cityState);    
  }
  ixs.vget_string(addr.zip, sizeof(addr.zip));
  return ixs;    
}
</pre>

<p>I am still a little concerned about the fact that the user has to remember to register the object and its ID back with the stream. I toyed briefly with the idea of using a version of the <b>iXDR_Stream</b>::<b>Sentry</b> to hold a reference to the object pointer and automatically update the <b>id2obj</b> map upon destruction, but I decided that was too obscure. </p> 
<p>One thing I have to note is that by adding this capability I stepped outside the realm of XDR's notation, and hence the intended use of XDR as a communications protocol. The encoding of <b>Address</b> has now become:</p>

<pre>
struct Address {    
  string    street1;    
  string    street2;    
  int       cityStateId;    
            ????    
  char      zip[5];    
};
</pre>

<p><b>????</b> indicates that I do not know how to describe the optionally encoded <b>CityState</b> object. In some sense, this is a discriminated union, where the object ID is the discriminate. This might be shown as:</p>

<pre>
union switch (int objId) {    
case ????:    
  CityState    cityState;    
default:    
  void;    
};
</pre>
    
<p>But, as you can see, there is still the question of what discriminate value results in the <b>CityState</b> object being encoded in the stream. The answer is, &quot;a new object ID (one that has not been used in the stream before this),&quot; but that requires programming logic and cannot be expressed in a simple data description notation.</p>
 
<p>At this point I stopped and thought about what I had so far. My intent was to use XDR as a binary representation for building a simple object persistence mechanism. If I couldn't describe what I was doing using XDR notation, then I wondered if things were getting too complicated. In a lot of cases where reference semantics are used, it is usually possible to simply substitute the object ID for the pointer. In fact, it probably makes more sense (most of the time) to encode all the objects like <b>CityState</b> together elsewhere in the stream (or in another stream) and not encode them inline at all. </p> 

<p>It is also possible to describe (and encode) recursive data structures, such as linked lists, using the XDR notation. Unfortunately, in the real world, data references can be circular. When this happens, you have to break the chain somewhere, or you cannot encode the structure. Besides, if reference semantics take us outside the normal XDR notation, then polymorphic objects really mess things up. </p> 

<H3><FONT COLOR="#000080">Polymorphic Objects</FONT></H3>

<p>The final use of pointers in C++ is to refer to polymorphic objects. In other words, we have a pointer to a base class, but the actual object probably is of a derived type. This is where it really gets interesting.</p>

<p>Encoding a polymorphic object into an XDR stream is not difficult. It is straightforward to write a stream insertion operator that acts like a virtual function &#151; it just has to dispatch to a virtual encode function implemented in the derived class. Likewise, a pseudo virtual stream extraction function can be written. Of course, the problem with the latter is that you have to have created an object of the correct derived type (i.e., the same actual type as the object that encoded itself into the stream) before you can extract the value of the object from the stream. In some cases this may be possible, but in general the user of a base class does not have any idea what the actual type of the object is. Therefore, solving the general case means that the object has to somehow encode its type into the stream along with its state. The extraction function has to be able to decode the type, create the correct type of object, and finally read its state from the stream. </p> 

<p>Again, one size does not fit all, so I did not try to come up with a totally general solution. As above, I added some support for the general case to the <b>XDR_Stream</b>, but I leave it up to individual clients to use the support if it makes sense, or to solve the problem in some other way if that is more appropriate.</p> 

<p>On the output side, the need is to encode the object type into the stream. My approach is very similar to what I used above. I added a <b>TypeToId</b> map to the <b>oXDR_Stream</b>. This has a find function:</p>


<pre>
long find(const string&amp; type);
</pre>

<p>which takes a string representing a type name and returns a unique ID for it. The insert and index functions look as you have come to expect:</p>

<pre>
pair&lt;long, bool&gt; insert(const string&amp; type);
long operator[](const string&amp; type);
</pre>

<p>On the input side, there is the corresponding <b>IdToTypename</b> map.</p>
<p>As with the reference semantics, I added three functions to the <b>XDR_Stream</b> interface to make things easier on the user:</p>

<pre>
bool   put_typeId(oXDR_Stream&amp;, const string&amp; type_name);
string get_typeId(iXDR_Stream&amp;, long&amp; id);
void   map_typeId(iXDR_Stream&amp;, long id, const string&amp; type);
</pre>

<p>The first takes a string representing a type name and looks up its ID in the <b>type2id</b> map. It inserts the string in the map with a new ID if necessary. It then encodes the ID into the stream.</p>

<p>The other functions perform the opposite operations an on input stream. The second reads a type ID from the stream, looks up the corresponding string in the <b>id2type</b> map, and returns it. If the ID is not in the map, a new one is inserted along with an empty string. The third function creates an association between a type name and its ID.</p>

<p>For an example of how this gets used, let's assume that our <b>Contact</b> list can have different types of <b>Address</b>es. Perhaps there is a <b>USAddress</b>, a <b>UKAddress</b>, and so on. Our inserter for <b>Contact</b> has not changed much at all:</p>

<pre>
oXDR_Stream&amp; operator&lt;&lt;(oXDR_Stream oxs, const Contact&amp; obj) {    
  return oxs &lt;&lt; obj.name &lt;&lt; obj.addr &lt;&lt; obj.phone;    
}    
</pre>

<p>Note however that even though <b>addr</b> is a pointer to <b>Address</b>, I do not dereference it. In this case, the inserter function for <b>Address</b> takes the pointer instead of a reference to the object.</p>

<pre>
oXDR_Stream&amp; operator&lt;&lt;(oXDR_Stream&amp; oxs, const Address* obj) {    
  string type = FactoryCollection&lt;Address&gt;::find(typeid(*obj));    
  bool isNew = put_typeId(oxs, type);    
  if (isNew) oxs &lt;&lt; type;
  obj-&gt;encode(oxs);    
  return oxs;    
}
</pre>

<p>I will explain the <b>FactoryCollection</b> template in a moment. For now, just accept that its <b>find</b> function takes a reference to a <b>type_info</b> object and returns a string that identifies that type. In the above, the <b>put_typeId</b> call converts that string to an ID unique to the stream and encodes that ID in the stream. If the ID was new, the type name is also encoded into the string. The next line dispatches to the derived class the responsibility for encoding its state into the stream.</p> 
<p>On input, things are almost the direct inverse:</p>

<pre>
iXDR_Stream&amp; operator&gt;&gt;(iXDR_Stream&amp; ixs, Contact&amp; obj) {    
  return ixs &gt;&gt; obj.name &gt;&gt; obj.addr &gt;&gt; obj.phone;    
}
</pre>

<p>And the real interesting stuff is here:</p>

<pre>
iXDR_Stream&amp; operator&gt;&gt;(iXDR_Stream&amp; ixs, Address*&amp; obj) {    
  long id;
  string type = get_typeId(ixs, id);  
  if (type.empty()) {
    ixs &gt;&gt; type;  
  obj = FactoryCollection&lt;Address&gt;::find(type).make();    
  obj-&gt;decode(ixs);    
  return ixs;    
}
</pre>

<p>Here, the <b>get_typeId</b> function reads the ID from the stream and looks up the corresponding string. If the ID is a new one, the string is also read from the stream and both are inserted into the <b>id2type</b> map. Next, the string is passed to the <b>find</b> function of the <b>FactoryCollection</b>. This returns a reference to a factory object. That object in turn has a <b>make</b> function that creates an object of an <b>Address</b>-derived class, the one corresponding to the type-name string. Once an object of the correct type has been created, the code dispatches to that object to extract its state from the stream.</p> 
<p>All in all, this is not exactly trivial, but it is not too complicated either. It does help to understand some basic software patterns <a href="#7">[7]</a> such as Factory, Abstract Factory, and Prototype, however.</p>

<H3><FONT COLOR="#000080">Factory Collection</FONT></H3>

<p>The heart of the functionality above is the <b>FactoryCollection</b> template, and it is not really specific to <b>XDR_Stream</b>. The problem of how to turn a type name into an object is a general one, so I came up with a general solution some time back. Most such solutions are variants of the Prototype pattern, and so is this &#151; I just find it more general purpose than the basic Prototype pattern.</p> 
<p>First off, <b>FactoryCollection</b> is itself a mono-state <a href="#7">[7]</a> object. This means that all of its data and members are static. This is a variation on the Singleton pattern <a href="#6">[6]</a>, but again simpler. <b>FactoryCollection</b> is a template that has to be instantiated with the type of a base class. As you would deduce from the name, it then is expected to contain factory methods for the derived classes of the base. There are three member functions of <b>FactoryCollection</b>:</p> 

<pre>
string find(const type_info&amp;);    
FactoryCollection::Factory&amp; find(const string&amp; type);    
template&lt;typename Derived&gt; register_type(const string&amp; type);    
</pre>

<p>The first function you saw used above in <b>operator&lt;&lt;</b>. It looks up a type and returns a <b>string</b>. At this point you might wonder if I want a <b>string</b> from a type why not just use the <b>name</b> member function of the Standard class <b>type_info</b>. The simple reason is that the string that is returned by <b>type_info::name</b> is implementation defined. This means that it is not portable across platforms. Furthermore, that name reflects the compiler's view of the type. It includes all the namespaces, template arguments, etc. that make up the full type name. If you change something in the slightest, then that string will change. I have found it is much more useful for the application to assign appropriate names to the types.</p> 
<p>The <b>find</b> function throws an exception (<b>invalid_argument</b>) if the <b>type_info</b> object has not been registered. (There is a version <b>find(const type_info&amp;, nothrow)</b> that just returns an empty string, for use when exceptions are not appropriate.)</p> 
<p>The second function you also saw above. It takes the string representing the derived type name and looks up and returns a reference to the appropriate factory object. This function will likewise throw an exception if the argument has not been registered. (There is a <b>nothrow</b> version of this that returns a null pointer if the factory object does not exist.)</p> 
<p>The final function puts strings and the appropriate factory functions into the collection. Because it is a template that does not have the template argument as one of the function arguments, it has to be invoked with the derived type explicitly specified. In our <b>Address</b> example, we might expect to find code like the following somewhere at the beginning of the application:</p> 

<pre>
typedef FactoryCollection&lt;Address&gt; Addresses;    
Addresses::register_type&lt;USAddress&gt;("USAddress");    
Addresses::register_type&lt;UKAddress&gt;("UKAddress");    
// and so on
</pre>

<p>That is the basics, and I hope they make reasonable sense (or that the code makes things clearer). I want to point out that <b>FactoryCollection</b> can be specialized in some useful ways.</p>

<p><b>FactoryCollection</b> contains two nested types: <b>Factory</b> and <b>TFactory</b>. The first is the base class for all the factory objects that are put into a collection. It provides a virtual <b>make</b> function that has to be overridden by derived classes. The <b>TFactory</b> class is a template that derives from <b>Factory</b>. It provides a concrete <b>make</b> method that allocates an object of the type it is instantiated with. This is fine as far as it goes. The problem is that the default version of <b>TFactory</b> must be used with classes that have a default constructor. This is usually true, but not always. As one final example, suppose that our <b>Address</b> class hierarchy had derived classes with a constructor that took an <b>iXDR_Stream</b> object as an argument. This way we could construct and load the object in one statement. In order to use this constructor, we have to explicitly specialize <b>FactoryCollection::Factory</b> and <b>FactoryCollection::TFactory</b> like so:</p> 

<pre>
template&lt;&gt;    
struct FactoryCollection&lt;Address&gt;::Factory {    
virtual Address* make(iXDR_Stream&amp;) = 0;    
};    

template&lt;&gt;    
template&lt;typename T&gt;    
struct FactoryCollection&lt;Address&gt;::TFactory {    
virtual Address* make(iXDR_Stream&amp;);    
};
</pre>

<p>And we provide the following implementations:</p>

<pre>
template&lt;&gt;    
FactoryCollection&lt;Address&gt;::Factory::~Factory()    
{} 

template&lt;&gt;    
template&lt;typename T&gt;    
Address* FactoryCollection&lt;Address&gt;::TFactory::make(iXDR_Stream&amp; ixs)    
{ return new T(ixs); }
</pre>

<p>With this specialization, we can write our <b>Address</b> extractor as:</p>

<pre>   
iXDR_Stream&amp; operator&gt;&gt;(iXDR_Stream&amp; ixs, Address*&amp; obj) {    
  string type = get_typeId(ixs);    
  obj = FactoryCollection&lt;Address&gt;::find(type).make(ixs);    
  return ixs;    
}
</pre>

<p>In the simple case of <b>Address</b> above, this probably is not necessary. When an object contains pointers to other polymorphic objects that it needs to create as part of its own creation, then this type of thing can be essential.</p> 
<p>Well, there are the basics. I have them in place, and I am starting to use them. I will let you know how things work out in practice. In particular, in the next column, I hope to show a fairly major application of <b>XDR_Stream</b>. I feel that I must add the warning that although I am pleased with how <b>XDR_Stream</b> is working in my testing so far, I do not think that it is &quot;ready for prime time&quot; yet. In particular, I am concerned about the error handling &#151; or the lack thereof &#151; in the implementation. I shall also have more to say about that in the next column.</p>

<H3><FONT COLOR="#000080">Notes and References</FONT></H3>

<p><a name="1">[1]</a> Of the four platforms that I currently have access to, two still have old IOStream library implementations that are not template based. As a result, I cannot even attempt to compile the <b>XDR_Stream</b> on those platforms. The other two have more Standard-compliant libraries.</p>
<p><a name="2">[2]</a> The official Standard term for C-compatible data types.</p>
<p><a name="3">[3]</a> This is still not correct since the first library ignores any custom <b>ctype</b> facet that might actually be provided. It suffices to initialize the <b>basic_ios&lt;&gt;::fill</b> member to <i>some</i> value, however, and that is sufficient for <b>XDR_Stream</b>.</p>
<p><a name="4">[4]</a> Jack Reeves. &quot;The (B)Leading Edge: Using IOStreams &#151; Creating a Whole New Stream Class,&quot; <i>C/C++ User's Journal Experts Forum</i>, July 2001, &lt;www.cuj.com/experts/1907/reeves.htm&gt;.</p>
<p><a name="5">[5]</a> Jack Reeves. &quot;The (B)Leading Edge: Using the <b>XDR_Stream</b> Class,&quot; <i>C/C++ User's Journal Experts Forum</i>, September 2001, &lt;www.cuj.com/experts/1909/reeves.htm&gt;.</p>
<p><a name="6">[6]</a> Erich Gamma, et. al. <i>Design Patterns</i> (Addison Wesley Longman, 1995).</p>
<p><a name="7">[7]</a> Neil Harrison, et. al. <i>Pattern Languages of Program Design 4</i> (Addison-Wesley, 1999).</p>

<p><i><b>Jack W. Reeves</b> is an engineer and consultant specializing in object-oriented software design and implementation. His background includes Space Shuttle simulators, military CCCI systems, medical imaging systems, financial data systems, and numerous middleware and low-level libraries. He currently is living and working in Europe and can be contacted via <b>jack_reeves@bleading-edge.com</b>.</i></p>

<h4><a href="../../../source/2001/nov01/reeves.zip"></a></h4>

</BLOCKQUOTE></BODY></HTML>
