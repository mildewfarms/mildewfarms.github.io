<HTML>   
     <HEAD>
<TITLE>Java Solutions December 2001/Editor's Forum</TITLE></HEAD>
<BODY BACKGROUND="" BGCOLOR="#FFFFFF" TEXT="#000000">
<H2><A HREF="../tocjdec.htm"></A><FONT COLOR="#FF0000">   Java Solutions</FONT></H2>

<HR>

<H2 ALIGN="center"><FONT COLOR="#800000">Editor's Forum</FONT></H2>

<HR>
<BLOCKQUOTE>

<H3><FONT COLOR="#000080">Is There Anything to Javabeans but Gas?</FONT></H3>
<p>I, personally, believe in the maxim that a program or system should be exactly as complex and flexible as it needs to be. No more. No less. Too much flexibility extends development time and makes maintenance difficult. Too little makes it too difficult to modify the program as business requirements change. A good programmer walks a fine line, indeed. One of the draws of OO is that both the theory (building designs around real user needs, designs that model the real world) and tools (interfaces, design patterns, etc.) make it easier to walk this fine line.</p>
<p>Which brings me to the issue of EJB and Bandwagon-Oriented Programming&#153;. I&#146;m not much of a fan of EJB. EJB often ends up being nothing but a (considerably) expensive bottleneck that adds little or no value to an overall architecture. When you factor in the cost of the hardware and programming (including maintenance) effort, the value of EJB seems even more questionable.</p>
<p>The technology is vastly too complex for most applications that use it, and EJB adds much more flexibility to those applications than they actually need. Virtually nobody uses EJB features like RMI-to-CORBA translation. Container-managed persistence doesn&#146;t work all that well &#151; a BEA rep once advised me to limit my use of EJB to stateless session beans and do the persistence by hand. People haven&#146;t even figured out what it means for a method to be a transactional unit, much less how to roll it back.</p>
<p>From a design perspective, the separation of the session and entity beans violates the most fundamental OO precept of all: implementation encapsulation. Moreover, it&#146;s rare that a good object model will map directly to a good database schema, so even the creation of the entity bean can be problematic. To make matters worse, I&#146;ve seen some programs that actually ship the entity beans around by value using RMI, thereby yielding the world&#146;s least-efficient query mechanism, which returns a single row from a complex join. Lately, I&#146;ve seen things made even more ridiculous by wrapping the entity-bean data in XML and shipping that around. What are we trying to do here &#151; build the slowest system imaginable? To make things worse, trying to splice an OO architecture onto a fundamentally procedural architecture like EJB is difficult at best and also adds unnecessary complications to the program.</p>
<p>EJB, then, is a perfect example of Bandwagon-Oriented Programming&#153;. Too many people just don&#146;t seem to think. They install a &#147;standard&#148; architecture (JSP web server/EJB app server/Relational database) because the prevailing wisdom (whatever <I>that</I> is) says: &#147;Yea, it is good.&#148; They then just build on top of that architecture without first considering whether the architecture is all that good for the actual application they&#146;re building. For example, if you&#146;re using EJB to get failover, you can do the same thing in the router, in the database, and by using a message-oriented middleware encapsulated by JMS. In many scenarios, these alternatives will all do the job better than EJB, but they&#146;re rarely considered. Another example: if you&#146;re using bean-managed persistence and stateless sessions beans, you&#146;re just using the app server as a complicated RMI platform. You can simplify considerably by using straight RMI and a simple naming service &#151; an RMI-accessed <B>HashMap</B> might work just fine.</p>
<p>Of course, most shops don&#146;t do any real up-front design work at all, so I suppose this behavior isn&#146;t all that surprising. The real question then, is one of education. How do you convince panicked get-it-to-market-first companies that relaxing for a few moments and thinking about what they&#146;re about to do is a good idea? This question is actually a more complex question than you might imagine. Someone once told me: &#147;When you ask a really good programmer about their technical abilities, they&#146;ll tell you how good they are. Unfortunately, when you ask a really bad programmer the same question, they&#146;ll also tell you how good they are.&#148; Many management decisions are based on trust, especially if the CEO is non-technical, and unfortunately, people in positions of authority and trust who have courage and technical savvy (or even the ability to ask when they don&#146;t know something) to jump off the bandwagon and take a risk are few and far between. I&#146;m convinced that this lack is one of the big reasons for the dot-com failures: their technical infrastructure was a couple orders of magnitude too flexible for what it actually did, and the correspondingly inflated cost was insupportable. My main hope it that we&#146;ll all learn some lesson from this, though I&#146;m not quite sure what the lesson will be. Maybe you can tell me.</p>
<p>Allen Holub<br>
Senior Editor</p>
</blockquote></body></html>
