<HTML>   
     <HEAD>
<TITLE>March 2001 C++ Experts Forum/The (B)Leading Edge</TITLE></HEAD>
<BODY BACKGROUND="" BGCOLOR="#FFFFFF" TEXT="#000000">
<H2><A HREF="../../19.03/tocmar.htm"></A><FONT COLOR="#FF0000">   C++ Experts Forum</FONT></H2>

<HR>

<H2 ALIGN="center"><FONT COLOR="#800000">The (B)Leading Edge: Using IOStreams &#151; Part II</FONT></H2>
<H3 ALIGN="center"><FONT COLOR="#800000">Jack W. Reeves</FONT></H3>

<HR>
<BLOCKQUOTE>


<H3><FONT COLOR="#000080">Introduction</FONT></H3>

<P>Suppose you have an object of type <B>Temperature</B> (see the <a href="sidebar.htm">sidebar</a> for some reasons why you might want to have a class such as <B>Temperature</B>). Now suppose you want to output it. That should be as simple as</P>

<pre>
os &lt;&lt; t;
</pre>

<P>But what scale is used to print out the value of <B>t</B>? If you look at the header for class <B>Temperature</B> in <a href="list1.htm">Listing 1</a>, you will see that I have been reasonably careful to hide the actual scale used internally by a <B>Temperature</B> object. If a client wants to extract <B>Temperature</B>, they have to explicitly specify the scale. You could generate the output this way:</P>

<pre>os &lt;&lt; t.inF();
</pre>

<P>but this means that the output is always going to be Fahrenheit. What if the user wants something else? What if the user wants to change things &quot;on the fly&quot;? This column is about how to use some of the more advanced features of the IOStreams library to provide this type of flexibility.</P>
<P>This column is another tutorial. Ordinarily I try to leave tutorials to others and concentrate on real-world examples, but I think that this topic needs the exposure. What I am going to talk about here is that part of the IOStreams library that is often known as the <B>iword</B>/<B>pword</B> facility. I can say with some assurance that this is one of the most underutilized facilities of the IOStreams library. Just in case you have never heard of iword/pword, let me point out that this is not new to Standard C++, but was part of classical IOStreams as well. I first tried to use the facility on a project in 1995. When I did, I ran into a bug in the library implementation that I was using. Then I discovered that the reference I was using, (Steve Teales' <I>Iostream Handbook </I> <a href="#1">[1]</a>) actually mentions the bug I ran into. Here was a C++ library from a major vendor that had contained a bug in the implementation for so long that it was documented in a popular book, and several years after the publication of the book, I still found the same bug. Obviously this was not a heavily used facility. Nevertheless, the facility is part of the Standard IOStream library, and I think it is both necessary and useful. This column attempts to explain why I think so by showing you some simple examples of how to use the facility.</P>
<P>First, let me mention some of the other information that is out there about this facility. Bjarne Stroustrup <a href="#2">[2]</a> mentions the facility just briefly (a couple of paragraphs). He concludes with the statement &quot;This storage and callback mechanism is fairly obscure. Use it only when you absolutely need to extend the low-level formatting facilities.&quot; Nicolai M. Josuttis devotes about two-and-a-half pages to the subject in his <I>C++ Standard Library: Tutorial and Reference </I><a href="#3">[3]</a>. So far, the most in-depth tutorial that I have actually read is in Angelika Langer and Klaus Kreft's <I>Standard C++ Iostreams and Locales</I> <a href="#4">[4]</a>, which has to be considered a rather specialized reference. </P>
<P>I can not argue that the facility has its obscure points, especially when the callback mechanism is used. Unfortunately this is true about many aspects of C++ and its library. Like the vast majority of C++, however, you do not have to worry about the complexity unless you actually need to use the facility. Furthermore, the complexity is only of concern to the class developer. Provided he or she does their job correctly, the clients of the facility do not have to even know it exists. On the whole, I think a little thought and some experimentation are sufficient to figure out most of the obscurities. With that said, I still have to recommend that you get one of the last two references mentioned above (I assume you already have the first), just to avoid having to learn everything the hard way.</P>
<P>I think that more class designers should look into the <B>iword</B>/<B>pword</B> facility. I come across classes all the time that could use a little extra control of their output facility. This is true even if the only reason they have an <B>operator&lt;&lt;</B> function is to display values for debugging. More often, I see classes that generate output in some required format that could use a different format for generating debugging output. The ability to set a single boolean flag in the <B>ostream</B><I> </I>would be a nice addition to the usability of such classes. As I hopefully will show, it isn't that hard.</P>
<P>I first discovered the <B>iword</B>/<B>pword</B><I> </I>facility because I went looking for it. I had written a class which I wanted to be able to format the output in different ways (not surprisingly it was a Date class). IOStreams provides facilities to control the formatting of built-in types, as well as <I>manipulators</I> to facilitate the use of those facilities. The information used by these facilities is stored as part of the <I>stream</I>. I reasoned that IOStreams had to provide some way to allow formatting information to be added to the <I>stream</I> for user-defined types. This was just in keeping with C++'s philosophy of being able to add user-defined types to the language that behaved exactly like the built-in types. Knowing it had to be there and what I wanted to do with it allowed me to quickly figure out how the <B>iword</B>/<B>pword</B> facility worked.</P>
<P>To provide a quick summary (which the examples will hopefully make clear), each iostream conceptually has two arrays, one of type <B>long</B> and the other of type <B>void*</B>. The IOStreams library provides (in <B>ios_base</B>) two functions: <B>iword(int)</B> and <B>pword(int)</B>. These take an index and return a reference to the corresponding <B>long </B>or <B>void*</B>. That part is simple. The next question is &quot;where does the index come from?&quot; A little thought will tell you that the index obviously needs to be unique to the class. One obvious place to get a unique identifier for a class is via the Run-Time-Type-Identification mechanism that is now part of Standard C++. The operator <B>typeid </B>returns a reference to a <B>typeinfo</B> object. This reference could be used to index a map or hash table. This is not the way it actually works in IOStreams, but I mention it to get you to think about the problem. Once you do so, you will more easily understand the actual mechanism. </P>
<P>Since IOStreams predates the RTTI mechanism in Standard C++, it provides its own facility for generating a unique identifier for any class that wishes to have one. This is the static function <B>ios_base::xalloc</B>. Each call to this function returns a new index. So, a class that wishes to use the <B>iword</B>/<B>pword</B><I> </I>facility needs to call this function once and store the result someplace specific to the class. The obvious candidate is a class static variable that is initialized by a call to <B>xalloc</B>. Once you have an index that is unique to the class, you can use it to access the same <B>iword</B> or <B>pword</B><I> </I>location in every <B>iostream</B>. </P>
<P>You now have two locations in every <B>iostream</B> that can be used to store class-specific formatting information. The actual interpretation of the information is up to the class &#151; or more specifically its <B>operator&lt;&lt;</B> and <B>operator&gt;&gt;</B> functions. Again the obvious candidates are to use the <B>long(iword) </B>to store flags or other simple information, and the <B>void*(pword)</B> can be used to reference anything more complicated that is desired. Most people immediately think of sticking a reference to a string or other structure containing advanced formatting information into the <B>pword</B> location, but that is not the only possibility. Allow me to continue my <B>Temperature</B> example.</P>

<H3><FONT COLOR="#000080">User-Defined Class Output Formatting</FONT></H3>

<P>We have a class <B>Temperature</B>, and we want to be able to output its value using one of three common temperature scales: Fahrenheit, Celsius, or Kelvin. Additionally, we would like to be able to optionally add the scale identifier. I had the additional requirement that I wanted to be able to derive a new class from <B>Temperature</B> to use a different scale and to be able to extend the user formatting functionality to support that new scale. The approach that I used is shown in <a href="list1.htm">Listing 1</a> (<B>Temperature.h</B>) and <a href="list2.htm">Listing 2</a> (<B>Temperature.cpp</B>). I will explain the <B>iostreams</B> section. </P>
<P>First, <B>Temperature</B> provides a static member <B>strm_index</B> of type <B>const int</B> to hold the index returned by <B>xalloc</B>. Next are the declarations for the manipulators. I am going to assume that you have at least a passing familiarity with manipulators, at least the standard ones such as <B>flush</B> and <B>endl</B>. These are just the same, except they are in class scope. Next come the declarations of the actual output functions. You can think of these as extended helper functions for <B>operator&lt;&lt;.</B> They are declared private since they are never called directly. The rest of <B>Temperature.h</B> is straightforward C++.</P>
<P>Since everything except the I/O facilities of class <B>Temperature</B> are provided as inline functions, the implementation file <B>Temperature.cpp</B> is entirely devoted to the <B>iostreams</B> functions. </P>
<P>First, we define <B>strm_index</B> and initialize it. </P>
<P>Next come the bodies of the manipulators. The first three are functionally similar: they just put the pointer to the associated output function into the <B>pword </B>location for the class. The next two handle the <B>show_scale</B> flag. I use the low order bit in <B>iword</B> as a <B>bool</B> to indicate whether to show the scale or not. Since this is the only flag I am using in class <B>Temperature</B>, I could have just used the entire <B>iword</B> value, but I show the general form where other flags may be present. This allows derived classes to add their own flags. </P>
<P>Next, I implement the output helper classes. These simply output the temperature value in the scale requested. You will see that I query the width value set for the field and make room for the scale character if one is expected. Other than that, the functions are almost trivial.</P>
<P>Finally, I provide the body of the <B>operator&lt;&lt;</B> function for class <B>Temperature</B>. It is fundamentally simple: it gets the pointer from <B>pword</B> (casting it from <B>void*</B> to the type required) and then checks to see if it is null. If there is no format function specified, the function fails. If there is a format function specified, then it is invoked.</P>
<P>I have concentrated on using the <B>iword</B>/<B>pword</B><I> </I>facility to generate custom output formatting. Obviously, the same mechanism could be used on the input side as well. In this example, I have an extractor function that expects the scale to be specified (e.g., 100C) and fails if it is not. A more general purpose scheme would provide input helper functions and manipulators to set them, which would read a temperature in a given scale. But I will leave that as an exercise for the reader.</P>

<H3><FONT COLOR="#000080">Summary</FONT></H3>

<P>In this column, I have shown how to use the <B>iword</B>/<B>pword</B> facility of IOStreams to provide some simple custom formatting information for a user-defined class. I think you will agree that up to this point it hasn't been all that difficult. I will admit that this example avoids the need to use the <B>register_callback</B> capability of IOStreams, which helps keep it simple. (In a future column, I will show an example of callback usage.) </P>
<P>One nice aspect of this design is that it is extensible. If a class is derived from <B>Temperature</B> (<a href="sidebar.htm">see Sidebar</a>), it can provide its own output helper function and the manipulator to set it, and the <B>operator&lt;&lt;</B> function for <B>Temperature</B> will use the new functionality. In fact, you don't even have to have a derived class: the user can add almost any desired functionality they want by simply creating the function to provide it.</P>
<P>As always, there are a number of details that might have alternate implementations. You will notice in <B>operator&lt;&lt;</B> that if there is no format specified, the stream state is set to <B>ios::failbit,</B> and the function returns without doing anything. This can be questioned. Forgetting to specify a format can be considered a programming logic error, not a problem with the stream. An alternative would be to throw an exception. This might happen when the stream state is set to failed, but it might not. By default, it will not throw. I have chosen to indicate the failure in the stream state because technically it is the stream that is missing the format information and hence is not usable for this object. Your design might prefer some other choice. In a future column, I will explore how to specify a default value for the formatting so that <B>operator&lt;&lt;</B> will not have an excuse to fail.</P>
<P>Another detail to be aware of is that if the iostream <B>copyfmt</B> function is called, the information in <B>iword</B>/<B>pword</B> is copied. Again, this seems correct to me, but an alternative would be to reset the values to their defaults. Doing this would require registering a callback function to be invoked whenever the <B>copyfmt</B> function was called.</P>
<P>All in all, the capabilities of the <B>iword</B>/<B>pword</B> facility strike me as another example of IOStreams extensible design.</P>

<H3><FONT COLOR="#000080">References</FONT></H3>
<P><a name="1"></a>[1] Steve Teale. <I>C++ Iostreams Handbook</I> (Addison-Wesley, 1993).</P>
<P><a name="2"></a>[2] Bjarne Stroustrup. <I>The C++ Programming Language Special Edition</I> (Addison-Wesley, 2000).</P>
<P><a name="3"></a>[3] Nicolai M. Josuttis. <I>The C++ Standard Library: A Tutorial and Reference</I> (Addison-Wesley, 1999).</P>
<P><a name="4"></a>[4] Angelika Langer and Klaus Kreft. <I>Standard C++ Iostreams and Locales: Advanced Programmer's Guide and Reference</I> (Addison-Wesley, 2000).</P>
<P><a name="5"></a>[5] Jack Reeves. &quot;The (B)Leading Edge: Low Overhead Class Design,&quot; <I>C++ Report</I>, February 1998.</P>


<p><i><B>Jack W. Reeves</b> is an engineer and consultant specializing in object-oriented software design and implementation. His background includes Space Shuttle simulators, military CCCI systems, medical imaging systems, financial data systems, and numerous middleware and low-level libraries. He currently is living and working in Europe and can be contacted via <b>jack_reeves@bleading-edge.com</b>.</i></p>
</blockquote></body></html>


