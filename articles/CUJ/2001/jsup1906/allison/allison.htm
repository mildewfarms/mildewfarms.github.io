<HTML>   
     <HEAD>
<TITLE>Java Solutions June 2001/import java.*</TITLE></HEAD>
<BODY BACKGROUND="" BGCOLOR="#FFFFFF" TEXT="#000000">
<H2><A HREF="../tocjjun.htm"></A><FONT COLOR="#FF0000">   Java Solutions</FONT></H2>

<HR>

<H2 ALIGN="center"><FONT COLOR="#800000">import java.*: Threads 101</FONT></H2>
<H3 ALIGN="center"><FONT COLOR="#800000">Chuck Allison</FONT></H3>

<BLOCKQUOTE>
<p>Using multiple threads can make your programs more responsive and your code cleaner, but getting them to work correctly can be tricky. Java makes the task (pun intended) as easy as possible and is the first language to offer portable threading support.</p>
</BLOCKQUOTE>

<HR>
<BLOCKQUOTE>

<p>Concurrent programming techniques have been around for many years, but have not seen widespread use until recently for a number of reasons. Traditional concurrent programs used multiple processes that required expensive IPC (interprocess communication) mechanisms and were severely platform dependent. If you could <B>fork</B> with the best of them on Unix, that wouldn&#146;t get you anywhere on VAX/VMS. Furthermore, creating processes on Unix was enough of a performance hit, but on many other operating systems it was abysmally slow and to be avoided whenever possible. Operating system designers got the message and invented lightweight processes, which evolved into what we know as threads today.</p>
<p>A thread is an execution path through a program, and there can be many threads active in a single process, all sharing the same process space. Using threads solved the performance hit of creating and managing separate processes every time concurrency was called for, but there remained the portability issue. The solution was of course to make threads part of the programming language, instead of leaving the job to the operating system or competing library vendors. This is what Java has achieved with a large degree of success.</p>
<p>Threaded programming is a complex affair. In this article, I&#146;ll scratch enough of the surface to make you comfortable managing independent tasks and shared resources concurrently in Java.</p>

<H3><FONT COLOR="#000080">The Benefits of Concurrency</FONT></H3>

<p>The motivation for the concurrent programmer is simple: better throughput. For example, separating the tasks of computation and presentation into distinct threads makes for a more responsive interactive program, because users can still press buttons and fill in text fields while awaiting the result of a pending request. On systems with multiple processors, separate threads can be scheduled to run simultaneously. Even on single processor systems, good thread scheduling algorithms make separate tasks appear to run concurrently to the human eye. A web server, for example, spawns separate threads to process incoming HTTP requests so one request doesn&#146;t have to wait for an unrelated one to finish before it gets a response. A web browser can use separate threads to display different parts of a web page.</p>
<p>Programmers like threads because they &#147;simplify&#148; code. That may sound a bit contradictory in light of the first sentence two paragraphs above. A language that supports concurrency shifts the bulk of the details of managing locks and inter-thread communication from your code to your platform, so all you need to do is to define your tasks, along with a minimal amount infrastructure. Getting the glue between threads to work is the tricky part, but the code comes out clean.</p>
<p>The program in <a href="list1.htm">Listing 1</a> shows one way to create and launch separate threads, which is to extend the <B>Thread</B> class and override the <B>run</B> method. The <B>MyThread</B> constructor expects a message and a count representing how many times to display it. The <B>Thread</B> class has a constructor that accepts an optional thread name. This feature isn&#146;t used much in practice, but I use it here to hold the message each thread is supposed to repeatedly print to the console screen. My <B>run</B> method just displays that message <B>count</B> times. To launch a thread, I call <B>Thread.start</B>, which in turn invokes <B>MyThread.run</B> automatically. As you can see, all but one of the repetitions of &#147;<B>DessertTopping</B>&#148; appear before the &#147;<B>FloorWax</B>&#148; thread gets a chance to execute. Your output may vary and is a function of the thread-scheduling algorithm used on your Java platform.</p>
<p>Sometimes you may want a thread to explicitly give other threads a chance to run, instead of hogging all the processor time it possibly can. You can do such cooperative multitasking with the <B>Thread.yield</B> static method, as illustrated in <a href="list2.htm">Listing 2</a>. The net effect here is that each thread just takes its turn displaying a single instance of its message.</p>
<p>Another way to let threads share processor time is to pause them for a period of time. The static method <B>Thread.sleep</B> suspends the thread for at least the number of milliseconds specified by its argument so other threads can run (see <a href="list3.htm">Listing 3</a>). <B>Thread.sleep</B> can throw an <B>InterruptedException</B> (explained below), but it won&#146;t happen in this example, so I just ignore it. This time the interleaving of the output appears more random than in the previous examples.</p>
<p>How many threads do you suppose are active at any one time in the examples above? The answer is one, two, or three (not zero, one, or two). When you start the virtual machine with the command</p>

<pre>
java Independent
</pre>

<p>the <B>main</B> method executes in an initial thread, called the <I>main thread</I>. <a href="list4.htm">Listing 4</a> illustrates this by displaying information about each thread. After <B>t1</B> starts, there are two threads active, and finally three after <B>t2</B> begins. To determine all the threads in a program requires access to their thread groups. All threads belong to a thread group <a href="#1">[1]</a>. Since I didn&#146;t explicitly create any thread groups, all threads belong to the default thread group (named &#147;<B>main</B>&#148;). The method <B>ThreadGroup.activeCount</B> returns the total number of threads in the group that haven&#146;t yet terminated, and <B>ThreadGroup.enumerate</B> fills an array with the all the threads currently running and returns the count of the same. <B>Thread.join</B> waits until its thread completes, if necessary, before returning. The <B>ThreadGroup.toString</B> method displays a thread&#146;s name, priority <a href="#2">[2]</a>, and thread group.</p>
<p>Another way to define a thread is to first define a task to implement the <B>Runnable</B> interface, which defines a single <B>run</B> method, and then to pass that task to an alternate <B>Thread</B> constructor, as shown in <a href="list5.htm">Listing 5</a>. This approach is attractive for a couple of reasons. From a conceptual point of view, it makes sense to separate a task from the thread that runs it. From a more pragmatic perspective, you need this technique if your task class extends another class, since Java only supports single inheritance.</p>

<H3><FONT COLOR="#000080">Thread States</FONT></H3>

<p>You might be wondering how the output in the previous examples came out the way it did. Why didn&#146;t the characters of the individual lines get interleaved? The reason is that many methods in <B>java.lang.io</B> cause a thread to <I>block</I>, which means the thread is put on hold until the call is complete. If you were to rewrite <a href="list3.htm">Listing 3</a> to print the characters individually using <B>print</B> instead of <B>println</B>, then such interleaving does occur (see <a href="list6.htm">Listing 6</a>).</p>
<p>Being blocked is just one of the several states a thread can be in. As <a href="fig1.htm">Figure 1</a> illustrates, when a thread is started, it enters the Runnable (or Ready) state, which means it is eligible to be chosen to execute by the JVM&#146;s thread scheduler. If the thread calls a blocking method, it enters the Blocked state until the blocking operation is complete, after which it is eligible to be rescheduled. Similarly, when a thread&#146;s code encounters a call to <B>Thread.sleep</B>, it enters the Sleeping state for the specified amount of time, and then becomes Runnable. When the scheduler suspends a thread so another can run, the first thread moves from the Running to the Runnable state. Only Runnable threads can be scheduled for execution. A thread is considered dead when its <B>run</B> method returns. Once dead, a thread cannot be restarted, although its associated <B>Thread</B> object is still available until it is garbage-collected.</p>
<p>The acceptable way to stop a thread is to politely ask it to stop itself. A typical situation where you need to stop a thread prematurely is in interactive applications. For example, if a database query is taking too long and you want to abort, you need to be able to press a Cancel button and have the query stop. The program in <a href="list7.htm">Listing 7</a> contains a first attempt to stop a thread. The main thread spawns a worker thread that displays a count every second and then waits for the user to press Enter. The <B>Counter</B> class has a <B>cancel</B> method that sets the boolean field <B>cancelled</B>. The loop in <B>Counter.run</B> checks <B>cancelled</B> before printing on each iteration so it knows when to exit. I&#146;ll explain shortly why this is not a generally safe technique for stopping a thread.</p>
<p>Did you notice that the main thread terminated before the worker thread did in <a href="list7.htm">Listing 7</a>? The application keeps running as long as any threads are still active. Well, almost any thread. There are two types of threads in Java: user threads and daemon (pronounced &#147;DAY-mun&#148;) threads. The threads I&#146;ve shown you so far are user threads. The difference between the two thread types is that if there are only daemon threads active, the application can terminate. You make a daemon thread by simply calling <B>setDaemon(true)</B> on an existing thread. By making the <B>Counter</B> thread in the previous example a daemon thread, I can halt the application without the canceling mechanism (see <a href="list8.htm">Listing 8</a>).</p>
<p>A very common technique for stopping a thread is to use <B>Thread.interrupt</B>, which is an official way of getting a thread&#146;s attention. When you interrupt a thread, it doesn&#146;t really stop &#151; it just causes a call to <B>Thread.interrupted</B> to return <B>true</B> when invoked in that thread <a href="#3">[3]</a>. The program in <a href="list9.htm">Listing 9</a> uses this feature to kill the <B>Counter</B> loop. This program clarifies why <B>Thread.sleep</B> may throw an <B>InterruptedException</B>, and what to do about it. If a thread is sleeping, it can&#146;t be directly interrupted, since it isn&#146;t running. Instead, it moves to the Runnable state and waits its turn to execute. When it runs, execution resumes in the <B>InterruptedException</B> handler associated with the pending call to <B>Thread.sleep</B>. The usual thing to do is to call <B>interrupt</B> again, since the initial call gave way to the exception. The loop will then complete on its next iteration and <B>run</B> will return <a href="#4">[4]</a>.</p>

<H3><FONT COLOR="#000080">Thread Safety</FONT></H3>

<p>One of the most difficult concepts to grasp in concurrent programming is how to share resources among separate tasks. Whenever two or more threads access the same object, you need to ensure that those threads take turns; otherwise your data can end up in an inconsistent state. Code that guards against this phenomenon is said to be <I>thread safe</I>. To illustrate, consider a <B>Book</B> object in a program that supports a public library. Suppose each book has title, author, and borrower fields. If two threads try to check out the same book at the same time, there&#146;s no telling what could happen. Perhaps the thread that executed last would win the privilege of being recorded as the borrower, but both threads would think they completed the transaction successfully. Bad news.</p>
<p>The Java threading model uses <I>monitors</I> to prevent threads from accessing shared data simultaneously. A monitor is a mechanism that establishes what are known as <I>critical sections</I> in code. Only one thread is allowed in a critical section at a time. A monitor is always associated with an object. The monitor for an object protects all the critical sections in the code associated with that object as a unit (so one thread can&#146;t be in one critical section while another thread is in another section). You declare critical sections with the <B>synchronized</B> keyword. Synchronization is expensive (four to six times more than non-synchronized methods, they say), so you should use it sparingly.</p>
<p>The only thread-sensitive data in <a href="list10.htm">Listing 10</a> is the <B>borrower</B> field. The other two fields are read-only and are therefore inherently thread-safe. To protect access to <B>borrower</B>, I do two important things:</p>
<p>1.  declare it to be <B>private</B> (otherwise there is no protection whatever!), and</p>
<p>2.  declare all methods that use it to be <B>synchronized</B> &#151; including the <B>accessor</B> method <B>getBorrower</B> (otherwise it would be possible for one thread to get the borrower right before another thread changes it, making the data invalid).</p>
<p>To execute one of these methods, a thread must obtain a lock on the associated object. (All Java objects have a hidden lock field). If another thread has the lock, the requesting thread waits until it becomes available. Once a thread has the lock (which is called being &#147;in the monitor&#148;), no other thread can execute any synchronized code. The thread in the monitor has exclusive access to the synchronized block until it leaves it and releases the lock. This is why <B>checkout</B> and <B>checkIn</B> can call <B>isAvailable</B> without any problems.</p>
<p>Since it is always a good idea to keep critical sections as small as possible, you should declare an entire method synchronized only when absolutely necessary. The program in <a href="list11.htm">Listing 11</a> shows how to declare a synchronized block, while at the same time fixing the problem with stopping a thread via the <B>cancel</B> method in <a href="list7.htm">Listing 7</a>. Since multiple threads executing <B>Counter</B> objects could conceivably be running at the same time, then the data fields need to be protected. Since <B>cancel</B> is a one-line method, there is no problem declaring it synchronized, but <B>run</B> must not be synchronized. Since it has an infinite loop, it would never be interrupted if it ran in the monitor. For this reason, I place only the two statements that require protection in a synchronized block on the current object. (Remember, a monitor always requires an object to lock.)</p>
<p>It is possible to declare code in static methods as a critical section. The associated monitor simply obtains a lock on the class object. <a href="list12.htm">Listing 12</a> illustrates this by fixing the interleaved output problem shown in <a href="list7.htm">Listing 7</a>. There is no shared data in this case, so no non-static synchronized methods are necessary. Instead, I just make the static method <B>display</B> synchronized. When <B>MyThread.run</B> calls <B>MyThread.display</B>, the thread obtains a lock on the object <B>MyThread.class()</B>, so the output proceeds uninterrupted. If I were to make display non-static, it would not prevent the interleaving, because the locks would be on two unrelated objects (<B>t1</B> and <B>t2</B>).</p>

<H3><FONT COLOR="#000080">Communication between Threads</FONT></H3>

<p>Synchronization keeps threads from getting in each other&#146;s way, but it doesn&#146;t allow threads to talk to each other. Sometimes a thread needs to wait on a condition brought about by another thread. Such is the case in typical producer-consumer scenarios, like real-time queuing systems. The program in <a href="list13.htm">Listing 13</a> uses a <B>Queue</B> to store messages created by Producer threads. Consumer threads wait until something is available in the queue to process. In this case, for simplicity, I just traffic in <B>Integer</B> objects, but the <B>Queue</B> class, which uses the Java 2 <B>LinkedList</B> collection class, doesn&#146;t need to change <a href="#5">[5]</a>.</p>
<p>In order to protect the queue, each thread synchronizes its own access to it. A consumer thread first checks to see if there is something to consume. If there isn&#146;t, it waits until there is. The <B>wait</B> method (defined in the <B>Object</B> class), which for thread safety must itself execute in a monitor, atomically releases its lock and blocks until it is notified by another thread <a href="#6">[6]</a>. After a producer inserts an entry in the queue, it calls <B>notify</B>, which causes it to block, and the thread scheduler wakes up another arbitrarily chosen thread that is in a wait state for the same monitor. If the newly awakened thread is a consumer, then its <B>while</B> loop completes so it can consume an <B>Integer</B>. If not, another producer will insert another entry into the queue and do another <B>notify</B>. Eventually a consumer thread will get notified. It is not possible to wake up a specific thread. If you want to notify multiple threads, then call <B>notifyAll</B> instead of <B>notify</B>. That would be counterproductive in this example because only one consumer can process a queue entry.</p>
<p>The program in <a href="list13.htm">Listing 13</a> of course doesn&#146;t halt. (I pressed Control-C to abort it.) You could use the interrupt/interrupted technique mentioned earlier to halt from the main program, but <a href="list14.htm">Listing 14</a> proposes a better solution <a href="#7">[7]</a>. I use a counter to track how many producer threads are active, so when they all finish the consumers can end gracefully. When the queue is empty, each consumer checks to see if there are any producers left running. If not, their <B>run</B> method simply returns and the application ends. Since there are now two conditions that the consumer threads are waiting for (either a new queue entry or zero producers remaining), I need to notify on both conditions. A call to <B>notifyAll</B> after a producer decrements its counter ensures that both threads are alerted when all the producers have terminated.</p>
<p>Some things to remember:</p>
<p>1)  <B>wait</B> and <B>notify</B> must always be called in a monitor.</p>
<p>2)  You must execute <B>wait</B> and <B>notify</B> on the same object you synchronize on.</p>
<p>3)  Both methods cause their threads to block (to allow other threads to run) and to enter the monitor&#146;s wait list. If no threads are waiting, <B>notify</B> simply returns. The original threads reacquire their locks when they resume.</p>
<p>4)  In general you should test for a wait condition in a loop. (The condition may have changed between the time the thread was awakened and the time you re-test.)</p>

<H3><FONT COLOR="#000080">Summary</FONT></H3>

<p>Threads allow you to improve perceived throughput of your programs, as well as divide your code into cleanly defined tasks, but crafting thread-safe code can be tricky. There isn&#146;t room here to talk about other issues such as communication through callbacks, deadlock, and thread-local storage. I hope, however, that this article has helped you understand how threads work, and why you should care.</p>

<H3><FONT COLOR="#000080">Notes</FONT></H3>

<p><a name="1"></a>[1]  <B>ThreadGroup</B>s can contain other <B>ThreadGroup</B>s, forming a tree with the default group as root.</p>
<p><a name="2"></a>[2]  Priorities are integers in the range <B>[Thread.MIN_PRIORITY, Thread.MAX_PRIORITY]</B>. What these priorities actually mean depends on your platform. Using <I>native threads</I>, where the JVM uses the underlying operating systems threading facilities for concurrency, the number of priorities may differ, so two priority numbers can be mapped to the same native priority. The only assumption you can really make is that threads with higher priority may be executed in preference to threads with lower priority.</p>
<p><a name="3"></a>[3]  <B>Thread.interrupted</B> is static and works on the current thread. There is a non-static <B>isInterrupted</B> method also.</p>
<p><a name="4"></a>[4]  Notice in this example that I reverted to extending <B>Counter</B> from <B>Thread</B>. If you use the <B>Runnable</B> approach, just call <B>Thread.getCurrentThread().interrupt()</B>.</p>
<p><a name="5"></a>[5]  For more on Java 2 Collections, see the September 2000 installment of &#147;import java.*.&#148; I wanted to use a synchronized wrapper for the queue, but it only supports the <B>List</B> interface, so the <B>LinkedList</B> functions aren&#146;t available.</p>
<p><a name="6"></a>[6]  There are overloads for <B>wait</B> that allow you to specify a timeout value.</p>
<p><a name="7"></a>[7]  I&#146;d like to thank Michael Seaver of Novell for help with this solution.</p>

<p><i><B>Chuck Allison</B> is a long-time columnist with </I>CUJ<I>. During the day he does Internet-related development in Java and C++ as a Software Engineering Senior in the Custom Development Department at Novell, Inc. in Provo, Utah. He was a contributing member of the C++ standards committee for most of the 1990&#146;s and authored the book </I>C &amp; C++ Codes Capsules: A Guide for Practitioners<I> (Prentice-Hall, 1998). He has taught mathematics and computer science at six western colleges and universities and at many corporations throughout the U.S. You can email Chuck at <B>cda@freshsources.com</B>.</i></p>

<h4><a href="../../../source/2001/jjun01/allison.zip"></a></h4>

</blockquote></body></html>
