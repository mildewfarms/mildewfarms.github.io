<HTML>   
     <HEAD>
<TITLE>August 2001/A Cookie Manager Class for Web Applications</TITLE></HEAD>
<BODY BACKGROUND="" BGCOLOR="#FFFFFF" TEXT="#000000">
<H2><A HREF="../tocaug.htm"></A><FONT COLOR="#FF0000">   Client/Server</FONT></H2>

<HR>

<H2 ALIGN="center"><FONT COLOR="#800000">A Cookie Manager Class for Web Applications</FONT></H2>
<H3 ALIGN="center"><FONT COLOR="#800000">Babu George Padamadan</FONT></H3>

<BLOCKQUOTE>
<p>Padamadan&#146;s classes make managing state in a client-server environment a sweet experience.</p>
</BLOCKQUOTE>

<HR>
<BLOCKQUOTE>

<H3><FONT COLOR="#000080">Introduction</FONT></H3>

<p>When a web browser requests information from a web server, the server may send a piece of state information along with its response. This state object is called a cookie. Web servers use cookies to store information on the client&#146;s system; the next time the client contacts the server, it will send the cookies back to the server, enabling the server to retrieve the information stored. Users can configure the browser settings to ignore or accept the cookies. In order to maintain the state information between sessions, the client should send the cookies back to the server.</p>
<p>A web browser extracts the cookie information from the server responses. Internet Explorer uses the WinInet SDK <a href="#1">[1]</a> calls to retrieve the cookie header information. A custom browser can use either the WinInet SDK API or TCP/IP socket functionality to extract the cookie headers from server responses.</p>
<p>There are a several aspects to cookies that make them potentially difficult to manage: there are several different kinds of cookies, they may contain varying amounts of data, and they may or may not have an expiration date. In this article, I&#146;ll present two classes: a <B>CookieManager</B> class, which manages cookies for a specific domain or web server, and the <B>Cookie</B> class, which encapsulates most of the features of the original Netscape specification as well as RFC 2109-based cookies. I will also compare the original Netscape specification (the Version 0 specification) and the new RFC 2109 (Version 1 or later) and discuss how these versions are managed in those classes.</p>
<p>I tested the <B>CookieManager</B> and <B>Cookie</B> classes against cookies of both specifications using a Windows Console application. The sample application with the source code is available for download from the <I>CUJ</I> website. I compiled the source code using Visual C++ 6.0. The typical users of the classes presented here would be custom browser applications, which directly talk to the web servers for specific information.</p>

<H3><FONT COLOR="#000080">Kinds of Cookies</FONT></H3>
<H4><FONT COLOR="#000080">Persistent Cookies vs. Per-Session Cookies</FONT></H4>

<p>Cookies with an expiry time associated with them, set by the web server, are known as <I>persistent cookies</I>. The browser client discards the cookies once the cookies expire. The state information set by the web server resides on the browser until the cookies expire. Web servers may send cookies without an expiry time and may later set an expiry time for those cookies through new responses.</p>
<p>If there is no expiry time associated with a cookie, it&#146;s a <I>session cookie</I>. Browser clients use session cookies until the Internet session between the browser and the server ends. Browser clients keep these cookies in cache and discard them as soon as the user closes the browser.</p>

<H4><FONT COLOR="#000080">Client-Side vs. Server-Side Cookies</FONT></H4>

<p>Cookies generated on web servers are called <I>server-side cookies</I>. Server-side cookies are generally used to store the state information of the server on the client side, whereas client-side cookies, generated by the scripts on the client side, store the user-interface-related information for the client. The scripts on the browser client may let the user customize look-and-feel of the HTML pages as per the user&#146;s choice and keep them in the cache. Next time the user visits the same site, the user will get the same look-and-feel of the pages that the user opted for before. Client-side cookies do not generally affect the business logic of the server-side applications. Client-side and server-side cookies can be of the session or the persistent nature.</p>

<H3><FONT COLOR="#000080">Specifications for Cookies</FONT></H3>

<p>Web servers and the browser clients should follow certain specifications for the cookies to work well. Netscape Communications introduced the first specification for cookies <a href="#2">[2]</a>. Most of the current browsers and web servers support the cookies as specified by the original Netscape specification. The W3 Consortium has proposed a new cookie specification <a href="#3">[3]</a>, called RFC 2109, for the HTTP/1.1 protocol. These cookies are considered to be Version 1 or later, and the original Netscape specification cookies are Version 0 cookies. Cookies based on the new proposal will have the version information in them so that they won&#146;t interfere with the old specification cookies. Browser clients should be able to interpret the cookies of both versions and act accordingly.</p>

<H3><FONT COLOR="#000080">How Cookies Are Used</FONT></H3>

<p>Web servers send cookies to browser clients by including a <B>Set-Cookie</B> header as part of their HTTP response to an HTML request from the browser. Below is an example of a response header, which contains a <B>Set-Cookie</B> header (lines broken to fit column).</p>
<p>Original Netscape (Version 0) specification:</p>

<pre>
HTTP /1.1 200 OK
Server:  XYZ Webserver 1.0
Date: Fri, 20 Oct 2000 18:45:52 GMT
Content-type: text/html
Set-Cookie: PRDUCTID=7387AD1212; 
    domain=.acme.com; path=/;
    expires=Thu, 19-Oct-2000 00:00:00 GMT
Set-Cookie: POSITION1232=5445ADS
Set-Cookie: TRACK=&lt;121232&gt;;
    domain=.acme.com
Set-Cookie: Redirect=none; path=/; 
    secure
Location=/start/Menu
</pre>

<p>RFC 2109 (Version 1 or later) specification:</p>

<pre>
HTTP /1.1 200 OK
Server:  XYZ Webserver 1.0
Date: Fri, 20 Oct 2000 18:45:52 GMT
Content-type: text/html
Set-Cookie: PRDUCTID="7387AD1212"; 
    domain=".acme.com"; 
    path="/"; Max-Age="3000"; 
    Version="1"
Set-Cookie: POSITION1232="5445ADS"; 
    Version="1"
Set-Cookie: TRACK="&lt;121232&gt;"; 
    Version="1"; domain=".acme.com"
Set-Cookie: Redirect="none"; path="/"; 
    Version="1"; secure
Location=/start/Menu
</pre>

<p>When the client requests a URL from an HTTP server, the server includes the cookies it received from the web browser in previous requests. (The client sends them with a <B>"Cookie"</B> header as described below.) The web server may send the same cookies again to the browser clients with different attribute values. It&#146;s the responsibility of the browser clients to update the values of the cookies in the cache. The following is a typical HTTP request sent by a browser (lines broken to fit column).</p>
<p>Version 0 specification:</p>

<pre>
GET /start/moredata.html HTTP/1.1
Cookie: POSITION1232=5445ADS; 
    TRACK=&lt;121232&gt;;  Redirect=none
</pre>

<p>RFC 2109 specification:</p>

<pre>
GET /start/moredata.html HTTP/1.1
Cookie:  $Version="1"; 
    POSITION1232="5445ADS"; 
    TRACK="&lt;121232&gt;"; 
    $Domain=".acme.com";
TRACK="&lt;121232&gt;"; Redirect="none"; 
    $Path="/"
</pre>

<H3><FONT COLOR="#000080">Parts of a Cookie</FONT></H3>

<p>The <B>Set-Cookie</B> HTTP Response Header as per the Netscape specification contains one required cookie-name/value pair followed by a set of optional attribute-name/value pairs and a flag:</p>

<pre>
Set-Cookie:
    &lt;cookie name&gt;=&lt;value&gt; 
    [; &lt;attribute name&gt;=&lt;value&gt;] ...
[; expires=&lt;date in GMT format&gt;]
    [; domain=&lt;name&gt;]
[; path=&lt;path_value&gt;]
[;  secure]
</pre>

<p>Here the <B>&lt;cookie name&gt;=&lt;value&gt;</B> pair specifies the cookie name and the value assigned to it. The other name/value pairs are <I>attributes</I> of the cookie just named. The braces (<B>[</B> and <B>]</B>) in the snippet above indicate optional attributes. (The <B>secure</B> flag is really an attribute as well, but its <B>&lt;value&gt;</B> part is optional and is usually omitted.) The header may contain one or more <B>&lt;cookie name&gt;=&lt;value&gt;</B> pairs. Since the Netscape specification lists just four possible attribute names (<B>domain</B>, <B>path</B>, <B>secure</B>, and <B>expires</B>), a name/value pair that doesn&#146;t start with one of these four represents another cookie.</p>
<p>The <B>expires</B> flag, if present, specifies when the cookie will expire in GMT (Greenwich Mean Time) format so that the browsers can discard it once its expiry time passes. <B>path</B> specifies the subset of URLs in a domain for which the cookie is valid. The <B>domain</B> attribute specifies the Internet domain name of the host from which the URL is fetched. If the <B>secure</B> flag is present, it means that the client should send this cookie back only over HTTPS (Hypertext Transfer Protocol over Secure Sockets Layer).</p>
<p>RFC 2109 specifies the following <BR>

<p><B>Set-Cookie</B> syntax:</p>

<pre>
Set-Cookie:  &lt;cookie name&gt;=&lt;value&gt; 
    [; Comment="&lt;value&gt;" ]
[; Domain="&lt;value&gt;" ]
    [; Max-Age="&lt;value in seconds&gt;"]
[; Path="&lt;path_value&gt;"] [; secure]
[; Version="&lt;a single digit&gt;"]
</pre>

<p>Here <B>&lt;cookie name&gt;=&lt;value&gt;</B> and <B>Version="&lt;a single digit&gt;"</B> are the only required name/value pairs. <B>Max-Age</B> defines the lifetime of the cookie in seconds. All other attributes have the same meaning as in the Version 0 specification. As in the Version 0 specification, an RFC 2109 <B>Set-Cookie</B> header can contain more than one cookie. A cookie name is easily recognized as not being one of the attribute names <B>Domain</B>, <B>Path</B>, <B>Secure</B>, <B>Max_age</B>, <B>Comment</B>, or <B>Version</B>.</p>
<p>Once the <B>Max-Age</B> seconds elapse, the client should discard the cookie. I&#146;ll discuss the attributes in detail while explaining the <B>Cookie</B> class.</p>

<H3><FONT COLOR="#000080">Using a Cookie Class</FONT></H3>

<p>A cookie contains a group of name-value pairs. The <B>Cookie</B> class uses an STL <B>map</B> object to store all the name-value pairs. The <B>map</B> takes care of not allowing more than one name-value pair with the same name attribute for the same cookie.</p>
<p>The <B>Cookie</B> class (<a href="list1.htm">Listing 1</a>) accepts the cookies of both the specifications mentioned above. The <B>Cookie</B> class uses its private member function <B>constructNameValueMap</B> to separate the name-value pairs from the cookie string and map each attribute name to its corresponding value by inserting them into the <B>map</B> object. <B>Cookie::getCookieString</B> converts the <B>map</B> object back to a cookie string to be sent back to the server.</p>
<p>If the <B>Version</B> attribute is present in the cookie string and its value is greater than or equal to one, it is an RFC 2109-based cookie. Any action on the cookie name-value pair is taken based on the version information. As per the RFC 2109 specification, the <B>Version</B> attribute can appear anywhere in the cookie string after the cookie-name/value pair. There is some potential for ambiguity here. Note that <B>Version</B> is not one of the attributes specified for Version 0 cookies. So it could appear as a valid cookie-name as the first name/value pair of a Version 0 cookie. <B>constructNameValueMap</B> searches for <B>Version="1"</B> right after the first cookie name-value pair. If the web server sends a header of the form <B>Set-Cookie: ID=2; Version=1; Path=.foo.com</B>, the cookie class interprets it as an RFC 2109-based cookie named &#147;ID&#148;. (However, it would be possible to interpret this header as defining two Version 0 cookies: one named &#147;ID&#148; and one named &#147;Version&#148;.) It is important to realize this, because even though the new cookie specification is meant to work with the HTTP/1.1 protocol, most of the websites using HTTP/1.1 have not started supporting the RFC 2109 specification.</p>
<p>You can query the <B>Cookie</B> object to get the state of the cookie. It&#146;s an invalid cookie if there are no name-value pairs, or if the domain name it contains is not the domain that the URL was requested from. As per the specifications, the domain string of the (as of this writing) seven top-level domains (<B>.com</B>, <B>.edu</B>, <B>.net</B>, <B>.org</B>, <B>.gov</B>, <B>.mil</B>, and <B>.int</B>) should have at least two periods in it. Thus <B>domain=foo.com</B> is invalid whereas <B>domain=.foo.com</B> is a valid attribute pair. Any other domain requires at least three dots (i.e., <B>domain=.abc.va.us</B>). RFC 2109 specifically states that all domain values should start with a dot. The old specification does not insist on this. <B>isDomainValid</B> checks if the value part of the domain attribute is per the specifications. The <B>doesDomainTailMatch(const string&amp; strReqDomain)</B> method verifies if the domain the <B>CookieManager</B> object was instantiated with matches the domain name in the cookie.</p>
<p>If the cookie does not have a domain name attribute, it&#146;s treated as a valid cookie for the default domain. As per the Version 0 specification, a domain attribute of <B>acme.com</B> would match host names <B>anvil.acme.com</B> as well as <B>shipping.crate.acme.com</B>. RFC 2109 is more stringent. If the fully qualified domain name of the server ends with the value of the domain attribute, then the beginning part of the fully qualified domain name must not contain any dots. For example, a cookie containing the attribute <B>Domain=.foo.com</B> sent by a server at <B>y.x.foo.com</B> would be rejected, because the beginning part of the fully qualified domain name is <B>y.x</B>, which contains a dot. <B>doesDomainTailMatch</B> implements these rules.</p>
<p>After a cookie passes the domain validation, a client-side application should perform another check. It should ensure that the path the cookie was received from matches the path to which it will be sent. If the path is not specified, the application should assume it is the same path as the document&#146;s path, whose header contains the cookie. The browser application should not forward a cookie if its <B>path</B> value is not a prefix of the request URI (Uniform Resource Identifier). For example, a URI containing <B>/foo/base</B> would match the <B>path</B> value <B>/foo</B>, because <B>/foo</B> is a prefix of <B>/foo/base</B>. Thus all cookies having the <B>path</B> value <B>/foo</B> would be forwarded to <B>/foo/base</B> as well by the application.</p>
<p>Further, if a client packages more than one cookie in a request header, the name-value pair for the cookie having the more specific <B>path</B> attribute <B>/foo/base</B> should come before <B>/foo</B> when a request is sent to the server. Both specifications allow the same cookie names to appear more than once in the cookie header to be sent to the server. This is because a cookie name, path name, and the domain name form a unique string. <B>doesPathMatch(const string&amp; path)</B> matches the cookies as per the path rules.</p>
<p>Let&#146;s say the client received the following cookies during a session:</p>

<pre>
Set-Cookie: PRODUCT=CAR; Path=/foo/start
Set-Cookie: PRODUCTID=2343; Path=/
Set-Cookie: SALESID=3222; Path=/home
Set-Cookie:CUSTID=3453; path=/foo/
</pre>

<p>If the client then requests the file <B>/foo/Start/update.html</B>, the client&#146;s request header will contain the following cookie:</p>

<pre>
Cookie: PRODUCT=CAR; CUSTID=3453; PRODUCTID=2343
</pre>

<p>The <B>Cookie</B> object can tell you if the cookie is a session-based or persistent cookie. It basically checks for the existence of the <B>Expires</B> or the <B>Max-Age</B> attribute based on the version. The <B>Expires</B> attribute represents the time when the cookie expires in the GMT format. But RFC 2109 cookies do not have an <B>Expires</B> attribute. Instead, RFC 2109 recommends a <B>Max-Age</B> attribute, which specifies the expiry time of the cookie in seconds. The <B>hasExpired</B> method of <B>Cookie</B> class returns true if the cookie is expired. It validates the value of <B>Expires</B> or the <B>Max-Age</B> attribute based on the cookie version.</p>
<p>The <B>Cookie</B> class uses the WinInet API time functionality to manipulate the expiry and <B>Max-Age</B> values. This is the only place where Windows-specific calls are used. All other methods are generic and portable to any operating system. A client-side application should discard all the session cookies when an Internet session with a particular domain ends. The <B>Cookie</B> class supports <B>isSessionCookie</B> and <B>isPersistentCookie</B> methods for this purpose.</p>
<p>The <B>Cookie::isSecure</B> method verifies whether the cookie contains the flag <B>secure</B> or not. Applications should send secure cookies only through HTTPS (HTTP over SSL - Secure Socket Layer) protocol. The <B>CookieManager</B> class (described below) uses this method of <B>Cookie</B> class to decide whether to send a cookie to the web server or not, based on the protocol it&#146;s using.</p>
<p>The <B>Cookie</B> class supports two forms of comparison between <B>Cookie</B> objects. The implementation of <B>operator==</B> checks that each object has the same <B>domain</B> and <B>path</B> attributes. It also checks that all name-value pairs that aren&#146;t predefined (such as <B>Expires</B>) match. The <B>isEqual</B> method compares the objects for the domain and path values and the names of the cookies. If both the objects are of the same domain and path, and if the cookie names are equal, they represent the same cookie. The <B>CookieManager</B> class uses <B>isEqual</B> to update the cookies in the cache with the new values received from the server.</p>

<H3><FONT COLOR="#000080">Cookies in a Client Request</FONT></H3>

<p>Browser clients send cookies to web servers along with their URL requests with the syntax shown below.</p>
<p>Cookie syntax as per Version 0 specification:</p>

<pre>
Cookie: NAME1=value; NAME2=value...
</pre>

<p>Here the browser returns only cookie name and values to the server. I&#146;ve noticed that even if you add the path and the domain information along with each cookie, most of the web servers accept the cookies. However, I encountered some issues when I added the expiry and the <B>secure</B> flags to the cookies sent to the server.</p>
<p>Cookie syntax as per RFC 2109:</p>

<pre>
Cookie: $Version="&lt;1 or greater&gt;"; NAME1="value"; 
    NAME2="value";
$Path="value";  $Domain="value"
</pre>

<p>The only required item as per the old (Version 0) specification is the name-value pair. But RFC 2109 requires the <B>Version</B> attribute as well along with the cookie name-value pair. Even though comma separators are also allowed instead of semicolon separators per RFC 2109, it&#146;s recommended using a semicolon for backward compatibility. <B>Max-Age</B>, <B>Secure</B>, and <B>Comment</B> attributes are ignored here. Even if you send more than one cookie in the URL request, there should be only one <B>Version</B> attribute, and it should appear as the first name-value pair in the cookie header. Further, cookie names should not use &#147;$&#148; as the first character. It is reserved as the first character of attribute names.</p>
<p>The browser clients should send only non-expired cookies that originated from the request host, relevant to the request URL. These rules for the <B>cookie:</B> header as per the old and the new specifications are taken care of in the <B>Cookie</B> and <B>CookieManager</B> classes.</p>

<H3><FONT COLOR="#000080">Managing Cookies with CookieManager</FONT></H3>

<p>The <B>CookieManager</B> class (<a href="list2.htm">Listing 2</a>) uses the <B>Cookie</B> class to decompose cookies sent by web servers. The browser application should instantiate a <B>CookieManager</B> object with the domain name the application is going to send requests to. The application instantiates a <B>CookieManager</B> object per domain. That way, the application would not a send a cookie that originated from an <B>a.foo.com</B> web server to a <B>b.foo.com</B> web server or vice versa.</p>
<p>The <B>CookieManager</B> class maintains a list of <B>Cookie</B> class objects in the form of an STL list. A cookie string can have more than one cookie name-value in it. A web server can send a cookie of the form <B>"Set-Cookie: Product=1; Volume=50; Path=/start;"</B> in response to a URL request and later can tell the browser client to discard one of these cookies by setting an expiry time with the following cookie: <B>"set-cookie: Volume=50; expires=Friday, 27-Oct-2000 00:00:00 GMT;"</B>. Here the <B>"Volume=50"</B> cookie has an expiry time associated with it, but the <B>"Product=1"</B> cookie does not have an expiry time attached.</p>
<p>For handling these kinds of cookies, the <B>CookieManager</B> class instantiates a <B>Cookie</B> object with the cookie string, separates the cookie name-values into individual cookies using <B>updateCookieList(const Cookie&amp;)</B>, and updates the cookie list. The <B>Cookie</B> class has a method <B>getCookieNames(NAME_MAP&amp;)</B> to retrieve only the cookie name-values without those reserved attribute name-value pairs. If a cookie is expired, the <B>CookieManager</B> removes it from the list. If the cookie is not relevant to the current domain, the <B>CookieManager</B> rejects it. To add cookies to the <B>CookieManager</B>&#146;s cookie list, a client application can use <B>addCookie(const string&amp;)</B>.</p>
<p>A client application can use the <B>getCookieString(...)</B> of <B>CookieManager</B> to convert the entire cookie list into a cookie string ready to be sent to a specified server and specified path.</p>
<p>Browser clients can use the <B>clearSession</B> method of <B>CookieManger</B> to clear the session cookies pertinent to a session. This method also removes the expired and the invalid cookies from the cookie list. The <B>CookieManager</B> class does not serialize the cookies in the list to a disk drive. Implementation can be easily changed to save and restore the persistent cookies from a disk drive.</p>
<p><a href="list3.htm">Listing 3</a> shows how to use the <B>CookieManager</B> class in an application. It uses the test cases given in the specifications. The listing shows the output of the test cases as well.</p>

<H3><FONT COLOR="#000080">Conclusion</FONT></H3>
<p>The cookie specifications specify some limits for the number of cookies that can be kept on the client system. These limits can be enforced at the application level. <B>CookieManager</B> and <B>Cookie</B> implement most of the rules of the current specifications. However, as the RFC 2109 is still in the development stage, the syntax and attributes may change at any time. Please refer to the URLs mentioned below for the latest updates.</p>

<H3><FONT COLOR="#000080">References</FONT></H3>
<p><a name="1"></a>[1]  WinInet SDK on Microsoft Developers Network (MSDN), &lt;http://msdn.microsoft.com&gt;.</p>
<p><a name="2"></a>[2]  Netscape Specification, &lt;http://www.netscape.com/newsref/std/cookie_spec.html&gt;.</p>
<p><a name="3"></a>[3]  RFC 2109, &lt;http://www.w3.org/Protocols/rfc2109/rfc2109&gt; or &lt;http://www.cis.ohio-state.edu/htbin/rfc/rfc2109.html&gt;.</p>

<p><i><B>Babu George Padamadan</B> is a technical manager with IT Solutions Pvt. Ltd., Bangalore, India. He specializes in C++/COM+. He has a B Tech in Computer Science. He can be reached at <B>babu.george@itsindia.com</B> or <B>babu_george@hotmail.com</B>.</i></p>

<h4><a href="../../../source/2001/aug01/padamada.zip"></a></h4>
</blockquote></body></html>
