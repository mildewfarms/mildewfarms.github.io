<HTML>   
     <HEAD>
<TITLE>August 2001/Generalizing the Concepts Behind auto_ptr</TITLE></HEAD>
<BODY BACKGROUND="" BGCOLOR="#FFFFFF" TEXT="#000000">
<H2><A HREF="../tocaug.htm"></A><FONT COLOR="#FF0000">   Features</FONT></H2>

<HR>

<H2 ALIGN="center"><FONT COLOR="#800000">Generalizing the Concepts Behind auto_ptr</FONT></H2>
<H3 ALIGN="center"><FONT COLOR="#800000">Cristian Vlasceanu</FONT></H3>

<BLOCKQUOTE>
<p>The C++ auto_ptr template can plug a memory leak &#151; too bad that&#146;s not the only possible &#147;leak.&#148; Here&#146;s a template that can close files, release Windows handles, and anything else you tell it how to do.</p>
</BLOCKQUOTE>

<HR>
<BLOCKQUOTE>
<p><i><b>In my father&#146;s memory.</b></i></p>

<H3><FONT COLOR="#000080">Introduction</FONT></H3>

<p>The utility <B>auto_ptr</B> class in the Standard C++ library was designed to encourage programmers to use the &#147;resource acquisition is initialization&#148; <a href="#1">[1]</a> technique. The technique basically consists of using automatic (or implicit) ownership of resources rather than explicitly acquiring and releasing them. The owner of a resource is the entity responsible for releasing it.</p>
<p>Whenever the programmer writes <B>delete</B> statements, memory ownership is explicit. By wrapping up plain (naked) pointers into <B>auto_ptrs</B>, the ownership becomes implicit. An <B>auto_ptr</B> declared on the stack is destroyed when the scope of its declaration is exited, and the destructor of <B>auto_ptr</B> automatically calls <B>delete</B> on the owned pointer. The programmer does not write explicit <B>delete</B> statements.</p>
<p>Memory is often used as a prominent example when the term &#147;resource&#148; is brought up, while other types of resources are often overlooked. These include file handles, kernel objects, graphical artifacts (such as found in the Windows GDI), and more. Although the handles <a href="#2">[2]</a> to these resources are often in fact pointers, this is not always the case. Even if they are pointers, they may be acquired and released using specific API calls (e.g. <B>CreateWidget</B>, <B>DestroyWidget</B>) rather than by using the <B>new</B> and <B>delete</B> operators. Therefore, <B>auto_ptr</B> cannot be used with generic resource handles.</p>
<p>This article shows the design and implementation of <B>auto_handle</B>, a template class that generalizes the ideas behind <B>auto_ptr</B>. Since it contains no hard-coded call of the <B>delete</B> operator, <B>auto_handle</B> can be used with opaque handles as well as with pointers; hence it can be used with a broader category of resources than just memory. This class is named <B>auto_handle</B> because it deals with the general concept of &#147;handle to resource.&#148;</p>

<H3><FONT COLOR="#000080">Intended Use</FONT></H3>

<p>In the following example, the <B>FILE</B> pointer cannot be wrapped in an <B>auto_ptr</B>.</p>

<pre>
// returns the length of a file
long int file_len(const string&amp; fname)
{
    FILE* fp = fopen(fname.c_str(), "r");
    if (!fp)
    {
        throw "could not open file";
    }
    if (fseek(fp, 0, SEEK_END) == -1)
    {

        // a leak occurs here: the FILE 
        // object is never closed
        throw "fseek error";
    }
    long int len(ftell(fp));
    fclose(fp);
    return len;
}
</pre>

<p>The programmer has nothing but his own discipline to rely upon in order to make sure that all open files are closed when no longer needed. Unfortunately, a missing <B>fclose</B> call cannot be detected or generated by means of compiler wizardry.</p>
<p>It would be nice to have an <B>auto_handle</B> class, modeled after <B>auto_ptr</B>, that would automatically take care of closing the <B>FILE *</B>. With such a class the <B>file_len</B> function could be rewritten as follows:</p>

<pre>
long int file_len(const string&amp; fname)
{
    auto_handle&lt;FILE*&gt; fp
        (fopen(fname.c_str(), "r"));
    if (!fp)
    {
        throw "could not open file";
    }
    if (fseek
        (fp.get(), 0, SEEK_END) == -1)
    {
        // no leak: fp goes out of scope
        // and the destructor closes the
        // FILE
        throw "fseek error";
    }
    return ftell(fp.get());
}
</pre>

<p>The <B>auto_handle</B> class presented here enables just this sort of usage. Using <B>auto_handle</B>, the programmer can now concentrate on the big picture and not worry about the details of matching all <B>fopen</B> calls with <B>fclose</B> calls. Such housekeeping details are automatically taken care of; when <B>file_len</B> returns, <B>auto_handle</B> goes out of scope and its destructor closes the file. (An explanation of how the <B>auto_handle</B> destructor is &#147;programmed&#148; to close the file is given later.)</p>

<H3><FONT COLOR="#000080">Copy Construction and Assignment Issues</FONT></H3>

<p>The <B>auto_handle</B> class does not impose a specific behavior for copy construction or assignment <a href="#3">[3]</a>. Possible behaviors include (but are not limited to):</p>

<UL><LI>   exclusive ownership as in <B>auto_ptr</B> </LI>
<LI>   reference counting </LI>
<LI>   cloning of resources </LI>
<LI>   forbidding copy construction and assignment altogether</LI></UL>

<p>The simplest way to deal with copy construction and assignment is to forbid them altogether by declaring both operators private. This works fairly well and saves design and coding effort when there is no need for using <B>auto_handle</B> with, say, standard containers. A serious shortcoming of such an implementation is the impossibility of returning <B>auto_handle</B>s from functions.</p>

<H4><FONT COLOR="#000080">Return by Value</FONT></H4>

<p>There are workarounds for this shortcoming, and the class below demonstrates the mechanism used by <B>auto_handle</B> to support return by value. It does not require a public copy constructor.</p>

<pre>
class non_copyable
{
public:
    non_copyable() {}
    
    struct ref
    { explicit ref(int){} };

    non_copyable(const ref&amp;) {}
 
    // conversion operator   
    operator ref() const
    { return ref(42); }
private:
    // non-const reference on purpose
    non_copyable(/*const*/ non_copyable&amp;);
};

non_copyable func()
{
    return non_copyable();
}

int main()
{
    non_copyable a;

    // does not compile, illegal
    // access to private ctor:

    // non_copyable b(a);

    // does compile!
    non_copyable c(func());

    return 0;
}
</pre>

<p>The copy constructor (disabled) takes a non-constant reference. Because the function <B>func</B> returns a temporary variable, the compiler does not employ the copy constructor (since the temporary variable needs to be bound to a const reference). Instead, the compiler uses the constructor that takes a const reference to a <B>ref</B> class, and the code compiles just fine, thanks to the conversion operator <a href="#4">[4]</a>. The <B>auto_handle</B> class employs this technique to support returning <B>auto_handle</B>s by value from functions.</p>

<H3><FONT COLOR="#000080">Implementing auto_handle</FONT></H3>

<p>Looking at the version of <B>file_len</B> written with <B>auto_handle</B>, you can see that the concrete type of the resource (<B>FILE*</B>) is used as a template argument. Although it isn&#146;t obvious, you may have deduced that how the resource is released (via <B>fclose</B>) also depends on the resource type. That is, the compiler should be able to determine what function to call in the destructor of <B>auto_handle</B> from the type of the template argument. The following code demonstrates how traits are used in order to help the compiler make the determination.</p>

<pre>
template&lt;class H&gt;
struct handle_traits
{
    static void dispose(H) throw();
};

template&lt;class H,
    class T = handle_traits&lt;H&gt; &gt;
class auto_handle
{
public:
    // 20.4.5.1 construct/copy/destroy     
    // ctors snipped out...

    ~auto_handle() throw()
    {
        T::dispose(handle_);
    }
    // more code removed...

private:
    H handle_;
};
</pre>

<p>The <B>auto_handle</B> template class has a second (default) parameter that associates a disposal method with a concrete handle type. (Note that the <B>dispose</B> method must not throw exceptions because it is called from a destructor.)</p>
<p>The following specialization is needed to make the <B>file_len</B> function work:</p>

<pre>
template&lt;&gt; void
handle_traits&lt;FILE*&gt;::dispose(FILE* fp) throw()
{
    fclose(fp);
}
</pre>

<p>The constructor of <B>auto_ptr</B>, as specified by section 20.4.5.1 of the C++ Standard, takes a null pointer as its default parameter. Following the same model, <B>auto_handle</B> should have a constructor that takes a null handle as default parameter. What is a null handle? The correct answer, of course, is &#147;it depends.&#148; It can be zero, but not necessarily. It could be <B>0xffffffff</B> as well. The natural place for specifying this dependency is in the <B>handle_traits</B> template:</p>

<pre>
template&lt;class H&gt;
struct handle_traits
{
    static void dispose(H) throw();
    static H null_value();
};

template&lt;class H, class T = handle_traits&lt;H&gt; &gt;
class auto_handle
{
public:
    // 20.4.5.1 construct/copy/destroy
    explicit auto_handle(
        const H&amp; h = T::null_value()) throw()
    : handle_(h) {}    

    ~auto_handle() throw()
    {
        T::dispose(handle_);
    }
    
    // 20.4.5.2 members
    H get() const throw()
    { return handle_; }
    
    // more code removed...

private:
    H handle_;
};
</pre>

<p>The program containing the <B>file_len</B> function example needs one more specialization in order to link:</p>

<pre>
template&lt;&gt; FILE*
handle_traits&lt;FILE*&gt;::null_value()
{
    return 0;
}
</pre>

<H3><FONT COLOR="#000080">Copy Construction and Assignment, Part Two</FONT></H3>

<p>There are enough building blocks so far for a working, minimal implementation of <B>auto_handle</B>. Such a minimal version would not allow copying and assignment. Returning <B>auto_handle</B>s from functions can be arranged as described earlier.</p>
<p>It would be nice, however, to have support for copy construction and assignment, if needed. The handle traits introduced a level of flexibility regarding the means for releasing resources. The copy-assignment behavior should not depend on the traits. If it did, then the <B>dispose</B> method would have to be written again and again (most likely unchanged) every time a new copy behavior was needed.</p>
<p>In order for the copy behavior to be orthogonal to the handle traits, I add a third template argument, and have <B>auto_handle</B> inherit from it:</p>

<pre>
template&lt;class H,
    class T = handle_traits&lt;H&gt;,
    class B = base_handle&gt;
class auto_handle : private B
{
    // ...
};
</pre>

<p>To simplify usage of <B>auto_handle</B>, the third template argument has a default value, which implements the simplest copy assignment money can buy &#151; that is, no copy, no assignment. (There&#146;s no free lunch, remember?)</p>

<pre>
// default auto_handle base class:
// copy ctor is disabled
class base_handle
{
public:
    base_handle() {}
private:
    // non-const ref on purpose
    base_handle(base_handle&amp;);
    base_handle&amp; operator=(
        base_handle&amp;);
};
</pre>

<p>In the following sections I describe several possible implementations for copy constructor/assignment behavior &#151; reference counting, exclusive ownership, and cloning.</p>

<H3><FONT COLOR="#000080">Reference Counting</FONT></H3>

<p>In the straw man <B>auto_handle</B> class shown above, the destructor calls the <B>dispose</B> method of the <B>handle_traits</B> template. To implement reference counting, an extra level of indirection is needed because destruction of the <B>auto_handle</B> does not necessarily imply destruction of the resource. This can be achieved by making <B>auto_handle</B>&#146;s destructor call a <B>dispose</B> method in the base class (the third template argument). The default <B>base_handle</B> class supports this as follows:</p>

<pre>
// default auto_handle base class
// copy ctor is disabled
template&lt;class H, class T&gt;
class base_handle
{
public:
    base_handle() {}

    // default disposal: forward to
    // handle_traits
    static void dispose(H h) throw()
    { T::dispose(h); }

    // place holder, in case we need
    // to implement copy construction
    static H copy(H&amp; h) throw()
    { return h; }

private:
    // non-const references, so that
    // return by value can be implemented
    base_handle(base_handle&amp;);
    base_handle&amp; operator=(
        base_handle&amp;);
};
</pre>

<p>To implement reference counting, an alternative base class needs to be defined as follows:</p>

<pre>
// A reference counted class,
// can be used as alternate base
// of auto_handle (instead of
// base_handle)
template&lt;class H, class T = handle_traits&lt;H&gt; &gt;
class ref_counted
{
public:
    ref_counted()
        : pCount_(new unsigned int(1))
    {}
    ref_counted(const ref_counted&amp; that)
        : pCount_(that.pCount_)
    { ++*pCount_; }
    ~ref_counted()
    {
        if (--*pCount_ == 0)
            delete pCount_;
    }

    // disposes the handle if this is
    // the only instance left that owns it
    void dispose(H h) throw()
    {
        if (*pCount_ == 1)
            T::dispose(h);
    }
    // some code removed...
private:
    unsigned int* pCount_;
};
</pre>

<p>The implementation of <B>ref_counted</B> shows why the <B>auto_handle</B> destructor does not directly call <B>traits::dispose</B>.</p>
<p>Clients can now define a reference counted <B>auto_handle</B> type as follows:</p>

<pre>
typedef auto_handle&lt;handle_type, handle_traits,
    ref_counted&lt;handle_type, handle_traits&gt; &gt; refcnt_handle;
</pre>

<H3><FONT COLOR="#000080">Exclusive Ownership</FONT></H3>

<p>Since <B>auto_handle</B> was introduced as a generalized <B>auto_ptr</B>, you would expect to be able to implement <B>auto_ptr</B> in terms of <B>auto_handle</B>. The code below implements a base class that provides exclusive ownership:</p>

<pre>
// avoid name clashing
namespace nonstd
{
// custom base class for auto_handle
template&lt;class H, class T = handle_traits&lt;H&gt; &gt;
class exclusive_owner
{
public:
    exclusive_owner() {}
    exclusive_owner(exclusive_owner&amp;) {}
    
    static void dispose(H h) throw()
    { T::dispose(h); }

    // transfers the handle
    static H copy(H&amp; h)
    {
        H handle(h);

        h = T::null_value();
        return handle;
    }
};
</pre>

<p>Notice that the <B>copy</B> method transfers ownership of the resource rather than just copying it. In order for this <B>copy</B> method to be called, the copy constructor for <B>auto_handle</B> must be written as follows:</p>

<pre>
auto_handle(auto_handle&amp; that) throw()
        : B(that),
        handle_(B::copy(that.handle_)) {}
</pre>

<p>The rest of the code necessary to support <B>auto_ptr</B> is shown here:</p>

<pre>
template&lt;class T&gt;
struct ptr_traits
{
    static T* null_value()
    { return 0; }
    
    static void dispose(T* pt)
    { delete pt; }
};

template&lt;class T&gt;
class auto_ptr : private auto_handle&lt;
    T*, ptr_traits&lt;T&gt;,
    exclusive_owner&lt;T*, ptr_traits&lt;T&gt; &gt; &gt;
{
typedef auto_handle&lt;T*, ptr_traits&lt;T&gt;,
    exclusive_owner&lt;T*, ptr_traits&lt;T&gt; &gt; &gt;
    base_type;

public:
    using base_type::get;

    explicit auto_ptr(T* pt = 0)
    : base_type(pt) {}

    auto_ptr(auto_ptr&amp; that)
    : base_type(that) {}

    // return-by-value support:
    auto_ptr(const
        auto_handle_ref&lt;T*&gt;&amp; pt)
    : base_type(pt) {}

    operator auto_handle_ref&lt;T*&gt; ()
    { return base_type::
        operator auto_handle_ref&lt;T*&gt;(); }

    T* operator-&gt;() { return get(); }
    T operator*() { return *get(); }
    
    const T* operator-&gt;() const
    { return get(); }
    
    T operator*() const
    { return *get(); }
};
} // namespace nonstd
</pre>

<H3><FONT COLOR="#000080">Cloning</FONT></H3>

<p>Some clients may require that the underlying resource be duplicated when an <B>auto_handle</B> is copied. This is called &#147;cloning.&#148; For this purpose I have added a &#147;clone&#148; method to the <B>handle_traits</B> class introduced earlier. It supports the implementation of copy constructors that rely on specific APIs to duplicate a resource. The following Windows-specific example demonstrates the cloning mechanism. The <B>DuplicateHandle</B> function from the Windows SDK (Software Development Kit) duplicates an object handle (in this case, an actual Windows &#147;handle,&#148; in the Windows meaning of the term &#151; it is the &#147;resource&#148; controlled by the <B>auto_handle</B>). The duplicate Windows handle refers to the same object as the original handle.</p>

<pre>
template&lt;&gt; HANDLE
handle_traits&lt;HANDLE&gt;::null_value()
{
    return INVALID_HANDLE_VALUE;
}

template&lt;&gt; void
handle_traits&lt;HANDLE&gt;::dispose(HANDLE h)
{
    ::CloseHandle(h);
}

// duplicates a HANDLE in the space
// of the current Win32 process
template&lt;&gt; HANDLE
handle_traits&lt;HANDLE&gt;::clone(HANDLE h)
{
    HANDLE hProc(::GetCurrentProcess());
    HANDLE hDup(h);

    if (!::DuplicateHandle(hProc, h,
        hProc, &amp;hDup, 0, false,
        DUPLICATE_SAME_ACCESS))
    {
        // do error handling
    }
    return hDup;
}
</pre>

<p>A class called <B>cloner</B> can be used as a base class for <B>auto_handle</B>, as follows:</p>

<pre>
template&lt;class H,
    class T = handle_traits&lt;H&gt; &gt;
class cloner
{
public:
    cloner() {}
    cloner(const cloner&amp;) {}
    
    static void dispose(H h) throw()
    { T::dispose(h); }

    static H copy(H h)
    { return T::clone(h); }
};

typedef auto_handle&lt;HANDLE,
    handle_traits&lt;HANDLE&gt;,
    cloner&lt;HANDLE&gt; &gt; clonable_handle;
</pre>

<p><B>clonable_handle</B> implements the &#147;resource acquisition is initalization&#148; idiom, as advertised. The destructor calls the <B>dispose</B> method of <B>cloner</B>, which in turn calls the specialized <B>handle_traits dispose</B> method, which closes the Windows handle.</p>
<p>Copying is allowed, and is based on the operating system&#146;s capability for duplicating Windows handles. It is worth noting that the support for cloning is provided by the <B>cloner</B> class, and is <I>independent</I> of the <B>handle_traits</B> template.</p>

<H3><FONT COLOR="#000080">Examples: Using auto_handle with the Windows GDI</FONT></H3>

<p>The following example shows possible uses of <B>auto_handle</B> with the Windows GDI (a subsystem which is very sensitive to resource leaks). In the first example the handle traits are implemented as a non-template class, because <B>HGDIOBJ</B> is defined as pointer to <B>void</B>, as is the Windows <B>HANDLE</B> type:</p>

<pre>
struct gdi_traits
{
    // Specializing the handle_traits template
    // for HGDIOBJ won&#146;t work. Both HANDLE and
    // HGDIOBJ are defined as pointers to void
    static HGDIOBJ null_value()
    // GDI functions return NULL when they fail
    { return 0; }
    
    static void dispose(HGDIOBJ hObj)
    { ::DeleteObject(hObj); }
};

typedef auto_handle&lt;HGDIOBJ,
    gdi_traits&gt; gdi_handle;
</pre>

<p>In the second example, the <B>handle_traits</B> template can be safely specialized for <B>HBRUSH</B> when strict type definitions are enforced at compile time:</p>

<pre>
#ifdef STRICT
template&lt;&gt; inline HBRUSH
handle_traits&lt;HBRUSH&gt;::null_value()
{ return 0; }

template&lt;&gt; inline void
handle_traits&lt;HBRUSH&gt;::dispose(HBRUSH h)
{ ::DeleteObject(h); }

template&lt;&gt; inline HBRUSH
handle_traits&lt;HBRUSH&gt;::clone(HBRUSH h)
{
    LOGBRUSH lb;
    
    if (!::GetObject(h, sizeof lb, &amp;lb))
    {
        return 0;
    }
    return ::CreateBrushIndirect(&amp;lb);
}

typedef auto_handle&lt;HBRUSH,
    handle_traits&lt;HBRUSH&gt;,
    cloner&lt;HBRUSH&gt; &gt; auto_brush;
#endif // STRICT
</pre>

<p>The moral is that the concrete data type of the &#147;handle&#148; needs to be carefully examined before specializing <B>auto_handle</B>.</p>

<H3><FONT COLOR="#000080">Implementation</FONT></H3>

<p>The complete <B>auto_handle</B> implementation is shown in <a href="list1.htm">Listing 1</a>. Comments indicate what sections of the Standard (describing <B>auto_ptr</B>) were used as guides.</p>
<p>The implementation of the <B>auto_handle</B> class does not use template members (unlike the <B>auto_ptr</B> specs) because template members in template classes are not widely supported by existing compilers.</p>
<p>The code was developed with MSVC 6.3 (partially) and Code Warrior Pro 5.0.</p>

<H3><FONT COLOR="#000080">Conclusion</FONT></H3>

<p>auto_handle</B> is a powerful utility class that can be used with broad categories of resources, such as system handlers, graphical resources, and plain pointers.</p>

<H3><FONT COLOR="#000080">Acknowledgments</FONT></H3>

<p>Thanks to Andrew Koenig, Herb Sutter, and Andrei Alexandrescu for their insightful comments and suggestions. Last but not least, many thanks to Bob Archer for reviewing, correcting the code, and encouraging me to put this paper together.</p>

<H3><FONT COLOR="#000080">Notes and References</FONT></H3>

<p><a name="1"></a>[1]  Bjarne Stroustrup. <I>The C++ Programming Language,</I> Third Edition (Addison-Wesley, 1997), Chapter 14.4. Also at &lt;http://www.research.att.com/~bs/3rd.html&gt;.</p>
<p><a name="2"></a>[2]  The term handle as used here does not refer to the Windows <B>HANDLE</B> data type.</p>
<p><a name="3"></a>[3]  Copy and assignment can be treated together, since a very elegant and exception-safe way of implementing assignment is in terms of the copy constructor. See Herb Sutter, <I>Exceptional C++, 47 Engineering Puzzles, Programming Problems, and Solutions</I> (Addison-Wesley, 1999), p. 47.</p>
<p><a name="4"></a>[4]  The code fails to compile with MSVC 6.0 SP3 due to insufficient compiler support.</p>
<p><a name="5"></a>[5]  Scott Meyers. &#147;<B>auto_ptr</B> update,&#148; &lt;http://www.awl.com/cseng/titles/0-201-63371-X/auto_ptr.html&gt;.</p>

<p><i><B>Cristian Vlasceanu</B> is a C++ programmer with Amazon.com in Seattle. Previously, he worked at RealNetworks, Inc. where he was responsible for developing software for portable MP3 players. His interests include generic programming and cross-platform development.</i></p>

<h4><a href="../../../source/2001/aug01/vlascean.zip"></a></h4>
</blockquote></body></html>
