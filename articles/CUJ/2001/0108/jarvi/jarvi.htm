<HTML>   
     <HEAD>
<TITLE>August 2001/Tuple Types and Multiple Return Values</TITLE></HEAD>
<BODY BACKGROUND="" BGCOLOR="#FFFFFF" TEXT="#000000">
<H2><A HREF="../tocaug.htm"></A><FONT COLOR="#FF0000">   Features</FONT></H2>

<HR>

<H2 ALIGN="center"><FONT COLOR="#800000">Tuple Types and Multiple Return Values</FONT></H2>
<H3 ALIGN="center"><FONT COLOR="#800000">Jaakko J&auml;rvi</FONT></H3>

<BLOCKQUOTE>
<p>There are several ways to return multiple values from a function in C++. Here is an elegant way that will give your template-grokking brain a real workout.</p>
</BLOCKQUOTE>

<HR>
<BLOCKQUOTE>

<H3><FONT COLOR="#000080">Introduction</FONT></H3>

<p>In most common programming languages, including C++, functions can return only a single value. This is a reasonable restriction, but often there is a need to pass several related values from a function to the caller. For example, what if one or more status codes need to be returned in addition to the actual result? Or what if the result itself has several components? A common example of multiple return values is the use of the <B>std::pair</B> template with STL <B>map</B>s.</p>
<p>There are two common approaches to circumventing the restriction of returning only a single value. First, you can use extra reference or pointer parameters to pass more data out of the functions. With this approach, the distinction between input and output parameters is not always obvious, and extra comment lines may be needed just for clarifying this. (Although disciplined usage of common idioms, such as using non-const pointers and references only for output parameters, does help.) Alternatively, you can define a separate class to group the return values into a single returned object. This second approach is conceptually better because there are no multiple return values; instead, there is just a single value that happens to be a composition of several related values. All the parameters are input parameters and the return value is the sole output.</p>
<p>I&#146;m going to take an example from the numerical domain and use it throughout the article. The SVD (singular value decomposition) is a common matrix decomposition operation. It takes a matrix (A) and decomposes it into two matrices (U, V) and a vector (S): SVD(A) = U S VH. Thus, the operation produces three result values.</p>
<p>Using the first approach, a typical function prototype and invocation might be:</p>

<pre>
void SVD(const Matrix* A, Matrix* U,
         Vector* S, Matrix* V);
...
Matrix *A, *U, *V; Vector *S;
...
SVD(A, U, S, V);
</pre>

<p>These lines of code leave open questions: which arguments are for input and which for output? Should the client initialize the output arguments <B>U, S</B>, and <B>V</B> in some way?</p>
<p>In the second approach, these questions are not relevant:</p>

<pre>
struct SVD_result {
  Matrix U, V;  
  Vector S;   
 // a constructor etc.
};
SVD_result SVD(const Matrix&amp; A);
</pre>

<p>The distinction between input and output values is now clear. However, it&#146;s a lot of work to write small classes just to serve as a collection of return values of individual functions. New unnecessary names are added to the namespace. Furthermore, in addition to memorizing the name and prototype of a function, the programmer must also remember the return class and its behavior. Note that for a straightforward <B>Matrix</B> and <B>Vector</B> implementation, copying such a return class might be considerably less efficient than using pointer parameters. Here I assume <B>Matrix</B> and <B>Vector</B> to be handle classes with inexpensive copy operations.</p>
<p><I>Tuples</I> provide a third approach. They allow a natural way to define the return value class on-the-fly as part of the function prototype, while avoiding the problems described above.</p>

<H3><FONT COLOR="#000080">Tuples</FONT></H3>

<p>A tuple type is the <I>cartesian product</I> of its element types; that is, a tuple type represents the set of ordered, fixed-size lists of objects, where the <I>i</I>th object in the list can have any value of the <I>i</I>th element type. More concretely, a tuple object contains a fixed number of other objects as elements, and these element objects can be of different types. Consequently, a tuple object contains a fixed number of other objects as elements. These element objects may be of different types. Some programming languages, such as Python <a href="#1">[1]</a> and ML <a href="#2">[2]</a>, are equipped with tuple constructs. There is also an ongoing effort to include tuples in Eiffel <a href="#3">[3]</a>. Tuples provide a concise means for defining multiple return values: the return type of a function can simply be defined as a tuple, for example:</p>

<pre>
(Matrix, Vector, Matrix) SVD(Matrix); // pseudo code
</pre>

<p>The intent of the declaration is instantly clear and there is no need to specify an artificial wrapper class for the result. Furthermore, with an appropriately defined assignment operation, tuples make the call sites clearer as well. For example, consider the following function calls written in Python and ML:</p>

<pre>
(U, S, V) = SVD(A);     #Python
val(U, S, V) = SVD(A);  (* ML *)
</pre>

<p>In these expressions, the returned tuple is <I>unpacked;</I> the components are assigned, or bound, to variables <B>U</B>, <B>S</B>, and <B>V</B>.</p>
<p>C++ has no direct support for tuples. However, the generic features of the language offer potential solutions for implementing them. The <B>pair</B> template in the standard library implements 2-tuples, though in a restricted form. For example, a prototype of a function returning two values can be defined as:</p>

<pre>
// Namespace std is assumed
// LU is another matrix decomposition
pair&lt;Matrix, Matrix&gt; LU(Matrix);
</pre>

<p>However, the assignment semantics of <B>pair</B>s does not allow the element unpacking described above.</p>
<p>This article presents a template library that implements a tuple abstraction for C++. The library has the following properties:</p>
<p>1)  The abstraction is typesafe and efficient.</p>
<p>2)  The semantics of the abstraction is natural and fits well with other language features. The abstraction is more or less a generalized standard <B>pair</B> template.</p>
<p>3)  The library allows objects of practically any C++ type to be used as tuple elements. This includes class objects, built-in types, pointers, references, arrays, and even other tuples.</p>
<p>4)  The number of elements in a tuple can be arbitrary. This is true up to some limit defined by the number of template specializations provided.</p>
<p>5)  An element can be accessed based on its index with no run-time overhead.</p>
<p>6)  Tuples can be copied and assigned; even the unpacking assignment semantics described above are supported. </p>
<p>Before focusing on how to implement these properties, let&#146;s take another look at the SVD example to introduce how the tuple library works. Omitting all code unrelated to tuples, the SVD function could be defined as follows:</p>

<pre>
tuple&lt;Matrix, Vector, Matrix&gt; SVD(const Matrix&amp; A) {
  ...
  Matrix U, V; Vector S;
  ...
  return make_tuple(U, S, V);
};
</pre>

<p>The above use is analogous to standard <B>pair</B>s. When the function is called, there are two ways to access the results. First, you can store the result to a tuple object and access the elements with special access functions (<B>get</B>):</p>

<pre>
Matrix A, U, V; Vector S;
...
tuple&lt;Matrix, Vector, Matrix&gt; result =
  SVD(A);
U = get&lt;1&gt;(result); S = get&lt;2&gt;(result);
  V = get&lt;3&gt;(result);
</pre>

<p>Alternatively, you can assign the tuple elements directly to the variables <B>U</B>, <B>S</B>, and <B>V</B> with the unpacking assignment construct:</p>

<pre>
tie(U, S, V) = SVD(A);
</pre>

<H3><FONT COLOR="#000080">Implementation of the Tuple Template</FONT></H3>

<p>To start with, a tuple template must be able to store an arbitrary number of elements of arbitrary types. A template having this capability is surprisingly simple:</p>

<pre>
struct nil {};

template&lt;class HT, class TT&gt;
struct cons { HT head; TT tail; };

template&lt;class HT&gt;
struct cons&lt;HT, nil&gt; { HT head; };
</pre>

<p>As the name <B>cons</B> suggests, the definition corresponds to LISP-style lists. Instantiating <B>TT</B> with a struct <B>cons</B> recursively leads to a list structure (see <a href="#4">[4]</a> for a more detailed description of such compile-time lists). For example, the instantiation representing the tuple type <B>(Matrix, Vector, Matrix)</B> is</p>

<pre>
cons&lt;Matrix, cons&lt;Vector, cons&lt;Matrix, nil&gt; &gt; &gt;
</pre>

<p>This instantiation defines a nested structure of classes, containing the tuple elements as member variables of these classes. The elements can be accessed with the usual syntax (e.g., <B>aTuple.tail.tail.head</B> refers to the third element). The <B>nil</B> class is an empty class acting as the end mark of the list.</p>
<p>Even though the <B>cons</B> template is sufficient for representing the structure of tuples, the syntax is not usable. Defining tuples with the <B>cons</B> template directly would be awkward. Instead, we&#146;d like to be able to write type declarations like:</p>

<pre>
tuple&lt;int&gt;
tuple&lt;float, double, A&gt;
</pre>

<p>Since the number of template parameters of a generic class can not vary, and it&#146;s impossible to define several templates with the same name, the solution is to use default values for template parameters:</p>

<pre>
template &lt;class T1, class T2=nil, class T3=nil, class T4=nil&gt;
struct tuple ...
</pre>

<p>Now this definition allows between one and four template arguments. The unspecified arguments are of type <B>nil</B>. As pointed out above, there is an upper limit for the number of elements in any tuple. This is set by the number of template arguments in the template definition. To make the code sections short, the limit of four elements is used here. It is, however, straightforward to extend the tuple to allow more elements. Currently, I&#146;ve coded up to ten-element tuples.</p>
<p>Now the tuple template provides the desired interface, whereas the <B>cons</B> template implements the underlying structure of tuples. The interface and implementation can be connected via inheritance: a tuple inherits a suitable instantiation of the <B>cons</B> template. As an example,</p>

<pre>
tuple&lt;float, int, A, nil&gt;
</pre>

<p>inherits</p>

<pre>
cons&lt;float, cons&lt;int, cons&lt;A, nil&gt; &gt; &gt;.
</pre>

<p>It is reasonable to assume that a tuple only stores its non-<B>nil</B> elements, hence <B>nil</B> classes are excluded from the <B>cons</B> instantiation. To be able to implement this inheritance relation, the type to be inherited must be expressed with the template parameters of the tuple.</p>

<H3><FONT COLOR="#000080">Mapping Tuple Types</FONT></H3>

<p>A recursive <I>traits</I> class (for more on traits, see [<a href="#5">5</a>, <a href="#6">6</a>, <a href="#7">7</a>]) provides a typedef that defines the mapping from tuple parameters to the corresponding <B>cons</B> instantiation:</p>

<pre>
template &lt;class T1, class T2, class T3, class T4&gt;
struct tuple_to_cons {
  typedef
    cons&lt;T1, typename tuple_to_cons&lt;T2, T3, T4, nil&gt;::type &gt;
    type;
};

template &lt;class T1&gt;
struct tuple_to_cons&lt;T1, nil, nil, nil&gt;
{
  typedef cons&lt;T1, nil&gt; type;
};
</pre>

<p>The <B>type</B> typedef defines a list, where the head type is the first template parameter <B>T1</B> and the tail type is defined recursively by instantiating the <B>tuple_to_cons</B> template again, with <B>T1</B> dropped from and <B>nil</B> added to the parameter list. The partial specialization of <B>tuple_to_cons</B> ends the recursion.</p>
<p>As an example, consider <B>tuple&lt;float, int, A, nil&gt;</B>. To resolve the underlying type of the typedef <B>tuple_to_cons&lt;float, int, A, nil&gt;::type</B>, the following chain of instantiations occurs:</p>

<pre>
tuple_to_cons&lt;float, int, A, nil&gt;::type
= cons&lt;float, tuple_to_cons&lt;int, A, nil, nil&gt;::type&gt;
= cons&lt;float, cons&lt;int, tuple_to_cons&lt;A,nil,nil,nil&gt;::type&gt; &gt;
= cons&lt;float, cons&lt;int, cons&lt;A, nil&gt; &gt; &gt;
</pre>

<p>Finally, with this type mapping machinery, we can define the <B>tuple</B> class itself as:</p>

<pre>
template &lt;class T1, class T2=nil, class T3=nil, class T4=nil&gt;
struct tuple : public tuple_to_cons&lt;T1, T2, T3, T4&gt;::type {
  ...
};
</pre>

<p>Public inheritance lets us treat tuples as <B>cons</B> lists as well, which is needed for the element access functions. Furthermore, since these functions allow a direct access to the individual elements (see Accessing Tuple Elements), there is no reason to restrict the access here.</p>

<H3><FONT COLOR="#000080">Tuples Are Generalized Pairs</FONT></H3>

<p>So far, the templates define just the structure of tuple types. For tuples to be usable, we also need convenient ways to construct, copy, and assign tuples and access their elements. I introduced these mechanisms in the introductory section with the SVD example. This section describes the mechanism and their implementation in more detail.</p>
<p>Basically, tuples generalize the semantics of the standard <B>pair</B> template:</p>

<pre>
template&lt;class T1, class T2&gt; struct pair {

  T1 first; T2 second;

  pair() : first(T1()) , second(T2()) {}
  pair(const T1&amp; x, const T2&amp; y) : first(x), second(y) {}

  template&lt;class U, class V&gt;
  pair(const pair&lt;U, V&gt;&amp; p)
    : first(p.first), second(p.second) {}
};
</pre>

<p>The default <B>pair</B> constructor initializes its elements to the default values of its element types. The elements may also be given explicitly in the constructor call. The member template is a kind of a &#145;copy constructor,&#146; which allows type conversions between elements. The <B>tuple</B> template has similar construction semantics. Furthermore, element access for <B>tuple</B> is almost as straightforward as for <B>pair</B> (<B>p.first</B>, <B>p.second</B>, etc.); <B>tuple</B> element access is accomplished just by index number <B>N</B>, via an overloaded function called <B>get&lt;N&gt;</B>.</p>

<H4><FONT COLOR="#000080">Constructors</FONT></H4>

<p>The <B>tuple</B> template above allows up to four elements, so it&#146;s obvious that the <B>tuple</B> constructor should have four parameters. But tuples can also be shorter. For an <I>n</I>-tuple, there should be a constructor taking <I>n</I> parameters. To avoid writing a separate constructor for each different length, I use default arguments. The definition of the <B>tuple</B> template becomes:</p>

<pre>
template &lt;class T1, class T2=nil, class T3=nil, class T4=nil&gt;
struct tuple : public tuple_to_cons&lt;T1, T2, T3, T4&gt;::type {
  tuple(typename convert&lt;T1&gt;::plain_to_cref t1 = def&lt;T1&gt;::f(),
        typename convert&lt;T2&gt;::plain_to_cref t2 = def&lt;T2&gt;::f(),
        typename convert&lt;T3&gt;::plain_to_cref t3 = def&lt;T3&gt;::f(),
        typename convert&lt;T4&gt;::plain_to_cref t4 = def&lt;T4&gt;::f())
    : tuple_to_cons&lt;T1, T2, T3, T4&gt;::type(t1, t2, t3, t4) {}
};
</pre>

<p>The constructor has a distinct parameter for each element to be stored. The parameters are passed directly to the inherited <B>cons</B> template instantiation. I have not yet defined any constructors for the <B>cons</B> templates, so just assume for now that the <B>cons</B> constructors work reasonably. Let me first explain the parameter types and default arguments expressions.</p>

<H4><FONT COLOR="#000080">Parameter Types</FONT></H4>

<p>The standard library <B>pair</B> constructor takes its arguments as references to const. This prevents the use of a reference as an element of a pair. In such a case the constructor parameter would be of type reference to reference, which is an invalid type. (This may change in the future revisions of the C++ Standard.) In order to allow elements of reference types, the tuple constructor parameter types are mapped through the expression <B>convert&lt;T&gt;::plain_to_cref</B>. The <B>convert</B> template is a traits class which maps any non-reference type <B>T</B> to reference to const type <B>const T&amp;</B>, but leaves reference types as such. This is an easy way to avoid reference to reference situations. The <B>convert</B> template can be written as follows (the <B>plain_to_ref</B> typedefs are needed later and thus defined here for convenience; they define a similar mapping to non-const reference types):</p>

<pre>
template&lt;class T&gt; struct convert {
  typedef const T&amp; plain_to_cref;
  typedef T&amp; plain_to_ref;
};
template&lt;class T&gt; struct convert&lt;T&amp;&gt; {
  typedef T&amp; plain_to_cref;
  typedef T&amp; plain_to_ref;
};
</pre>

<H4><FONT COLOR="#000080">Default Arguments</FONT></H4>

<p>Each parameter in the constructor is given a default value. Though looking somewhat odd, the default arguments are expressions that merely create and return a new default object of the current element type. Given this definition, a constructor for an <I>n</I>-element tuple can be called with 0 to <I>n</I> parameters. The elements that are left unspecified are constructed using their default constructors. Particularly, the unused <B>nil</B> objects are constructed by the default argument expressions, hiding their existence entirely from the user of the <B>tuple</B> template.</p>
<p>Why not just use <B>T()</B> instead of <B>def&lt;T&gt;::f()</B> as the default argument? Suppose <B>A</B> is a class with no public default constructor. Then the constructor of the <B>tuple&lt;A&gt;</B> instantiation would be <B>tuple&lt;A&gt;(const A&amp; t1 = A(), ...)</B>. This would result in a compile-time error, since the constructor call <B>A()</B> is invalid. Hence a type without a default constructor would not be allowed as an element type of a tuple, even if the default argument, and thus the default constructor, were never used. To eliminate this restriction, the call to the default constructor is wrapped inside a function template.</p>

<pre>
template &lt;class T&gt; struct def {
  static T f() { return T(); }
};
</pre>

<p>Now the constructor of <B>tuple&lt;A&gt;</B> becomes <B>tuple&lt;A&gt;(const A&amp; t1 = def::f&lt;A&gt;(), ...)</B>. If the first parameter is always supplied, the <B>def::f&lt;A&gt;</B> template is never instantiated. The compiler only checks the semantic constraints of the default argument and finds out that <B>def&lt;A&gt;::f()</B> is indeed a valid expression. Only if the default argument is really used may the compiler instantiate the body of the <B>f</B> function in the <B>def</B> template (and flag the error if there is no default constructor for the type in question) [<a href="#8">8</a>, Section 14.7.1].</p>
<p>Furthermore, reference parameters should obviously not have default values. A specialization for reference types takes care of this:</p>

<pre>
template &lt;class T&gt; struct def&lt;T&amp;&gt; {
  static T&amp; f() 
    { return error&lt;T&amp;&gt;::no_default_for_references; }
};
</pre>

<p>The <B>error</B> template does not have the requested member, so the instantiation intentionally results in a compile-time error.</p>

<H4><FONT COLOR="#000080">Constructing cons Objects</FONT></H4>

<p>The <B>tuple</B> constructor passes all four parameters to the constructor of the inherited <B>cons</B> instantiation. This constructor is a member template whose template arguments are to be deduced. Each of the <B>cons</B> templates needs a constructor:</p>

<pre>
template&lt;class HT, class TT&gt; struct cons {
  ...
  template &lt;class T1, class T2, 
    class T3, class T4&gt;
  cons(T1&amp; t1, T2&amp; t2, T3&amp; t3, T4&amp; t4)
    : head (t1) , tail (t2, t3, t4, 
      the_nil) {}
};

// specialization to end the recursion
template &lt;class HT&gt; struct cons&lt;HT, nil&gt; {
  ...
  template&lt;class T1&gt;
  cons(T1&amp; t1, const nil&amp;, const nil&amp;, 
    const nil&amp;)
    : head (t1) {}
};
</pre>

<p>The constructor initializes the head with the first parameter and passes the remaining parameters to the tail&#146;s constructor recursively, until all parameters but the first are <B>nil</B>. At each level, one element is initialized and one <B>nil</B> object (<B>the_nil</B>) is added to the end of the parameter list. Even though the parameter types are deduced and in that sense unconstrained, the construction is typesafe; if the constructor is called with an argument of invalid type, the initialization of the head at some recursion level results in a compile-time error.</p>
<p>As an example of the construction mechanism, let&#146;s step through the effect of the constructor call <B>tuple&lt;Matrix, Vector, Matrix&gt;(U,S,V)</B> in detail. First, the <B>tuple</B> template is instantiated: the default value is first substituted for the missing fourth template argument and the complete instantiated type becomes <B>tuple&lt;Matrix, Vector, Matrix, nil&gt;</B>. The <B>tuple_to_cons</B> traits class computes the list type <B>cons&lt;Matrix, cons&lt;Vector, cons&lt;Matrix, nil&gt; &gt; &gt;</B>, from which the tuple inherits. Next, the <B>tuple</B> constructor is called with arguments <B>U</B>, <B>S</B>, and <B>V</B>. The fourth parameter is not given, so the default argument is applied: the invocation <B>def::f&lt;nil&gt;()</B> returns an object of type <B>nil</B>. Now the <B>cons</B> constructor is called with arguments <B>U</B>, <B>S</B>, <B>V</B>, and the temporary <B>nil</B> object. Finally, the constructor recursively initializes the elements of the list with <B>U</B>, <B>S</B>, and <B>V</B>.</p>

<H4><FONT COLOR="#000080">Copy and Assignment</FONT></H4>

<p>The constructors corresponding to <B>pair</B>&#146;s templated constructors are still to be defined. The intent is to allow copy construction from another tuple with different element types, provided that there is an implicit conversion between the types of the corresponding elements. For example, <B>tuple&lt;int, double, int&gt;</B> could be initialized with an object of type <B>tuple&lt;char, int, int&gt;</B>. To attain this functionality, an additional member template constructor is required in the <B>tuple</B> template:</p>

<pre>
template &lt;class T1, class T2, class T3, 
  class T4&gt;
struct tuple ... {
  ...  
  template&lt;class U1, class U2&gt;
  tuple(const cons&lt;U1, U2&gt;&amp; p)
    : tuple_to_cons&lt;T1,T2,T3,T4&gt;::type(p) 
    {}
  ...
};
</pre>

<p>A new constructor is needed in both <B>cons</B> templates (primary and specialization) as well:</p>

<pre>
template&lt;class HT, class TT&gt; struct cons {
  ...
  template &lt;class HT2, class TT2&gt;
  cons(const cons&lt;HT2, TT2&gt;&amp; u)
    : head(u.head), tail(u.tail) {}
  ...
};

template &lt;class HT&gt; struct&lt;cons&lt;HT, nil&gt; &gt; {
  ...
  template &lt;class HT2&gt;  
  cons(const cons&lt;HT2, nil&gt;&amp; u) : 
    head(u.head) {}
  ...
};
</pre>

<p>The <B>tuple</B> constructor merely delegates the copying work to the base class. In the base class, the copy constructor of each member is called along the recursion. Hence, the converting copy is allowed if and only if the types are element-wise compatible. Otherwise a compile-time error results.</p>
<p>The implementation of the assignment operation is structurally identical and thus not shown.</p>

<H4><FONT COLOR="#000080">Accessing Tuple Elements</FONT></H4>

<p>With the definitions described so far, element access is still tedious. For example, to refer to the fifth element of a tuple <B>x</B>, you would have to write <B>x.tail.tail.tail.tail.head</B>. This section describes the template definitions that let you refer to the <B>N</B>th element by writing <B>get&lt;N&gt;(x)</B>. (See note <a href="#9">[9]</a>.)</p>
<p>The implementation of the access mechanism is based on recursive template definitions: the <I>n</I>th element of a list is the (<I>n</I>-1)th element of the tail of the list. The implementation consists of three components: the <B>get</B> function template provides the interface; the actual access functions are defined as member templates of the <B>tuple_element</B> class templates; and the traits class <B>tuple_element_type</B> resolves the type of the element to be accessed.</p>
<p>Let&#146;s start with the last component. The traits class is recursive: the type of the <I>n</I>th element of a list equals the type of the (<I>n</I>-1)th element of the tail of the list. With this definition in mind, we can now write the templates:</p>

<pre>
template &lt;int N, class T&gt; struct tuple_element_type;

template &lt;int N, class HT, class TT&gt;
struct tuple_element_type&lt;N, cons&lt;HT, TT&gt; &gt; {
  typedef typename tuple_element_type&lt;N-1, TT&gt;::type type;
};

template&lt;class HT, class TT&gt;
struct tuple_element_type&lt;1, cons&lt;HT, TT&gt; &gt; {
  typedef HT type;
};
</pre>

<p>The type of the <B>N</B>th element of some list type <B>T</B> can be written as <B>tuple_element_type&lt;N, T&gt;::type</B>. For example, the type of <B>tuple_element_type&lt;2, cons&lt;int, cons&lt;float, nil&gt; &gt; &gt;::type</B> is <B>float</B>.</p>
<p>Next, consider the access functions. They are not defined as ordinary function templates, but rather as static member function templates, because the index parameter <B>N</B> is not deducible and must therefore be explicitly specified. It is not possible to define a specialization with respect to such template parameter, so I made the index <B>N</B> a template parameter of the class template, which allows the specialization that ends the recursion.</p>

<pre>
template&lt;int N&gt; struct tuple_element {
  template&lt;class RET, class HT, class TT&gt;
  inline static RET get(cons&lt;HT, TT&gt;&amp; t) {
    return tuple_element&lt;N-1&gt;::template get&lt;RET&gt;(t.tail);
  }
};

template&lt;&gt; struct tuple_element&lt;1&gt; {
  template&lt;class RET, class HT, class TT&gt;
  inline static RET get(cons&lt;HT, TT&gt;&amp; t) {
    return t.head;
  }
};
</pre>

<p>The invocation <B>tuple_element&lt;N&gt;::template get&lt;RET&gt;(x)</B> <a href="#10">[10]</a> returns the <B>N</B>th element of the object <B>x</B> and converts the result to type <B>RET</B>. What should be the value of this template parameter? The access functions should obviously return a reference to the accessed element. Suppose the element is of some non-reference type <B>T</B>. Then <B>RET</B> should equal to <B>T&amp;</B>. If the element itself is a reference, say of type <B>T&amp;</B>, then <B>RET</B> should obviously be <B>T&amp;</B> as well. It is the task of the interface function template to instantiate the access template functions with an appropriate value for <B>RET</B>. The same value is the return type of the interface function as well:</p>

<pre>
template&lt;int N, class HT, class TT&gt;
typename
convert&lt;typename
   tuple_element_type&lt;N,cons&lt;HT, TT&gt; &gt;
   ::type&gt;::plain_to_ref
inline get(cons&lt;HT, TT&gt;&amp; c) {
   typedef typename
   convert&lt;typename
      tuple_element_type&lt;N,
                         cons&lt;HT, TT&gt; &gt;
      ::type&gt;::plain_to_ref RET;
   return tuple_element&lt;N&gt;::template
      get&lt;RET&gt;(c);
}
</pre>

<p>The return type is specified with two traits classes. First, the type of the accessed element is resolved with the <B>tuple_element_type</B> traits and then converted with the <B>convert</B> templates to a reference type, if it is not that already. The resulting type is then used as the <B>RET</B> template parameter in the call to the access function <a href="#11">[11]</a>. The tuple library implements the interface and access functions for const tuples as well. They are analogous and not shown here.</p>
<p>As an example of element access, consider the definition:</p>

<pre>
tuple&lt;Matrix, Vector, Matrix&gt; x(U,S,V);
</pre>

<p>The invocation <B>get&lt;3&gt;(x)</B> first triggers the instantiation</p>

<pre>
get&lt;3, Matrix, cons&lt;Vector, cons&lt;Matrix, nil&gt; &gt; &gt;(x).
</pre>

<p>which instantiates</p>

<pre>
tuple_element_type&lt;3,
  cons&lt;Matrix, cons&lt;Vector, cons&lt;Matrix, nil&gt; &gt; &gt; &gt;::type
</pre>

<p>which resolves to the type <B>Matrix</B>, the type of the third element of <B>x</B>. The instantiation <B>convert&lt;Matrix&gt;::plain_to_ref</B> maps this type to <B>Matrix&amp;</B>. Then the following instantiations are performed:</p>

<pre>
tuple_element&lt;3&gt;::get&lt;Matrix&amp;, Matrix,
                      cons&lt;Vector, cons&lt;Matrix, nil&gt; &gt; &gt;(x)
tuple_element&lt;2&gt;::get&lt;Matrix&amp;, Vector,
                      cons&lt;Matrix, nil&gt; &gt;(x.tail)
tuple_element&lt;1&gt;::get&lt;Matrix&amp;, Matrix, nil&gt;(x.tail.tail)
</pre>

<p>The last instantiation is the specialization for <B>N=1</B>, which returns the head of <B>x.tail.tail</B>, which is the matrix <B>V</B>. Note that the access mechanism is safe with respect to the index parameter. An index to a non-existing element leads to a compile-time error (no matching templates exist).</p>

<H3><FONT COLOR="#000080">make_tuple</FONT></H3>

<p>For easy construction of <B>pair</B>s, the C++ Standard library contains the <B>make_pair</B> function template:</p>

<pre>
template&lt;class T1, class T2&gt;
pair&lt;T1, T2&gt; make_pair(const T1&amp; a, const T2&amp; b) {
  return pair&lt;T1, T2&gt;(a, b);
}
</pre>

<p>It is somewhat problematic to provide the same functionality for tuples. A <B>make_tuple</B> function which would be generic with respect to the number of arguments in the tuple cannot be defined. Consequently, a separate function template must be written for each allowed tuple length. While not very elegant, this is perfectly feasible since the maximum number of elements in tuples is not very high. As functions with very long parameter lists tend to be error-prone and impractical, the same is true for very long tuples as return values. For example, the two-argument <B>make_tuple</B> function template can be defined as:</p>

<pre>
template&lt;class T1, class T2&gt;
tuple&lt;typename mt_convert&lt;T1&gt;::type,
      typename mt_convert&lt;T2&gt;::type&gt;
make_tuple(const T1&amp; a, const T2&amp; b) {
  return tuple&lt;typename mt_convert&lt;T1&gt;::type,
               typename mt_convert&lt;T2&gt;::type&gt;(a, b);
}
</pre>

<p>The template is similar to <B>make_pair</B>, except for the <B>mt_convert</B> type mappings which exist to make the template more generally applicable. The standard <B>make_pair</B> template cannot be used with array types, including string literals. For example, <B>make_pair("doesn't", "work")</B> tries to construct an object of type <B>pair&lt;char[8], char[5]&gt;</B>, which fails in the element initialization. The foremost task of the <B>mt_convert</B> templates is to circumvent this restriction:</p>

<pre>
template&lt;class T&gt;
struct mt_convert {
  typedef T type;
};
template&lt;class T, int n&gt; struct mt_convert&lt;T[n]&gt; {
  typedef const T (&amp;type)[n];
};
</pre>

<p>The primary template provides an identity mapping, but the specialization for arrays instructs the tuple to store arrays as references. With these definitions, <B>make_tuple("does", "work")</B> does work. In addition, the library defines specializations and helper templates that give the programmer more control over the tuple creation. For example, <B>ref</B> and <B>cref</B> are template functions which can be used to explicitly state that the tuple should store a reference to the argument, instead of copying it (<B>ref</B> stands for reference to non-const, <B>cref</B> for reference to const):</p>

<pre>
int i, j;
make_tuple(i, j);            // creates tuple&lt;int, int&gt;
make_tuple(ref(i), cref(j)); // creates tuple&lt;int&amp;, const int&amp;&gt;
</pre>

<H3><FONT COLOR="#000080">The Unpacking Assignment</FONT></H3>

<p>I showed the expression <B>tie(U, S, V) = SVD(A)</B> in the introduction. The effect of this expression is to assign the elements of the tuple returned by <B>SVD(A)</B> to variables <B>U</B>, <B>S</B>, and <B>V</B>. The evaluation of the expression comprises the following steps (with the order of steps 1 and 2 being implementation dependent):</p>

<OL><LI>The function call <B>SVD(A)</B> returns a tuple object of type <B>tuple&lt;Matrix, Vector, Matrix&gt;</B>.</LI>
<LI><B>tie(U, S, V)</B> constructs a tuple of type <B>tuple&lt;Matrix&amp;, Vector&amp;, Matrix&amp;&gt;</B>. The elements of this tuple are references to variables <B>U</B>, <B>S</B>, and <B>V</B>.</LI>
<LI>The assignment operation performs the element-wise assignment from the right-hand side tuple to the left-hand side tuple. Since the elements of the left-hand side tuple are references, the actual destinations of the assignments are the variables <B>U</B>, <B>S</B>, and <B>V</B>.</LI>
<LI>The tuple objects constructed in steps 1 and 2 are destroyed.</LI></OL>

<p>The ability to store references as tuple elements gives us the unpacking assignment semantics almost for free. All that is needed is a set of <B>tie</B> function templates that make the definition of tuples with reference elements convenient. The definitions of the <B>tie</B> function templates are analogous to the <B>make_tuple</B> templates, where a separate template is needed for each allowed tuple length. Here is the two-argument case as an example:</p>

<pre>
template&lt;class T1, class T2&gt;
tuple&lt;T1&amp;, T2&amp;&gt; inline tie(T1&amp; t1, T2&amp; t2) {
 return tuple&lt;T1&amp;, T2&amp;&gt; (t1, t2);
}
</pre>

<p>I chose the name <I>tie</I> because the templates are <I>tying</I> or <I>binding</I> a set of variables to the tuple elements. I didn&#146;t use <I>bind</I> because that name already has an established meaning in the standard library. (To be precise, the same is true of <B>tie</B>. It&#146;s a <B>basic_ios</B> member function for tying an <B>istream</B> and <B>ostream</B> together.)</p>
<p>As a small additional example of the unpacking assignment operation, we can swap the values of two variables, say <B>a</B> and <B>b</B>, with the expression:</p>

<pre>
tie(a, b) = make_tuple(b, a);
</pre>

<p>I&#146;ve also coded an assignment operator from <B>pair</B>s to tuples. This lets us use the unpacking assignment with functions returning standard <B>pair</B>s as well. <a href="#12">[12]</a></p>

<H3><FONT COLOR="#000080">Efficiency</FONT></H3>

<p>Tuple is a basic utility that&#146;s intended to be widely used, so its efficiency is important. The template definitions do not seem like they would be very efficient, however: to construct tuples and access their elements requires several nested function calls. For example, to access the <I>n</I>th element of a tuple requires <I>n</I>+1 function calls. The functions, however, are all inlined &#145;one-liners&#146; and so inline expansion can eliminate the overhead of calling these functions. For example, a call such as <B>get&lt;N&gt;(aTuple)</B> can reduce to the address of the <B>N</B>th element, producing no extra code at all.</p>
<p>The same efficiency is true of construction. Even though in the construction of an <I>n</I>-tuple, <I>n</I> nested classes are constructed, each constructor only effectively constructs its head and passes the remaining parameters forward. As the inline expansion is performed, the result is just the code performing the construction of the individual elements. The <B>nil</B> objects can be optimized away entirely.</p>
<p>The obvious alternative for using the tuple template is to explicitly write a struct containing an equivalent member variable for each tuple element. With an optimizing C++ compiler, constructing, copying, and assigning tuples is just as efficient as constructing, copying, and assigning the corresponding explicitly written structs. The same is true for element access. This behavior was validated by experiments with the gcc and KAI C++ compilers. As an extreme example, I even constructed a 256-tuple; The gcc C++ compiler eliminated the 257 nested function calls of the invocation <B>get&lt;256&gt;(aTuple)</B> and resolved the address of the 256th element at compile time. See <a href="#13">[13]</a> for detailed descriptions of the experiments.</p>
<p>The unpacking assignment, on the other hand, does have a small performance penalty compared to passing the return values as non-const pointer or reference parameters. Consider our SVD example <B>tie(U, S, V) = SVD(A);</B>. The <B>tie</B> function call creates a set of references, while the <B>SVD(A)</B> returns a temporary tuple object. It is unrealistic to expect that the compiler could avoid the creation of the temporary and assign the results directly to <B>U</B>, <B>S</B>, and <B>V</B> by performing some kind of return value optimization. After all, <B>U</B>, <B>S</B>, and <B>V</B> may reside anywhere in the memory space. Therefore, the cost arising from the tying mechanism is the cost of creating one reference variable and performing one assignment operation for each element of the tuple. The details are obviously dependent on the compiler, but this is more or less the behavior we would expect from an optimizing C++ compiler.</p>

<H3><FONT COLOR="#000080">Effect on Compilation Time</FONT></H3>

<p>Due to the excessive template instantiations, it is inherently slower to compile tuples than corresponding explicitly written structs. See [<a href="#13">13</a>, <a href="#14">14</a>] for detailed results of compile time comparisons between different ways of returning multiple return values with different compilers. These tests show that a tuple can be an order of magnitude slower to compile than the corresponding conventional explicitly written construct. However, as tuple instantiations comprise only a small part of any real C++ program, the effect on the overall compilation time is not significant.</p>
<p>To validate this, I created a test program, which I considered to represent extensive but realistic use of tuples. The characteristics of the test program were as follows: 20% of functions returned tuples, with the number of elements ranging from 2 to 8; and 20% of function calls used <B>tie</B> templates and the unpacking assignment expressions. The increase in compilation time compared to a conventional program was between 5 and 11 percent, depending on the compiler. Memory consumption increased more, between 22 and 27 percent.</p>

<H3><FONT COLOR="#000080">Conclusions</FONT></H3>

<p>This article describes a generic tuple library for C++ &#151; basically a generalized pair with a lot of extra features. At a general level, a tuple is a <I>typesafe</I> container for objects of arbitrary, and potentially different, types. I emphasized the use of tuples as return values, but this is not their only usage. They provide a means to pass a varying number of arguments <I>into</I> a template function as well. More generally, wherever you would need a template with a varying number of parameters, tuples may be part of the solution.</p>
<p>The library source code can be downloaded from the <I>CUJ&#146;</I>s source code archive (see &lt;www.cuj.com/code&gt;). The current implementation supports tuples up to ten elements.</p>

<H3><FONT COLOR="#000080">Acknowledgement</FONT></H3>

<p>Many thanks to Gary Powell and Herb Sutter for their comments on the draft version of this paper.</p>

<H3><FONT COLOR="#000080">References</FONT></H3>

<p><a name="1"></a>[1]  The Python home page: &lt;http://www.python.org&gt;.</p>
<p><a name="2"></a>[2]  Lawrence C. Paulson. <I>ML for the Working Programmer</I> (Cambridge University Press, 1991).</p>
<p><a name="3"></a>[3]  &#147;Tuples, Routine Objects and Iterators,&#148; a draft proposal to NICE, &lt;http://eiffel.com&gt; (link Papers).</p>
<p><a name="4"></a>[4]  Jaakko J&auml;rvi. &#147;Compile Time Recursive Objects in C++,&#148; <I>Proceedings</I> of the TOOLS-27 conference, Beijing, September 1998 (IEEE Computer Society Press), pp. 66-77.</p>
<p><a name="5"></a>[5]  Nathan C. Myers. &#147;A New and Useful Template Technique: Traits,&#148; <I>C++ Report,</I> 7(5): 32-35, 1995.</p>
<p><a name="6"></a>[6]  Andrei Alexandrescu. &#147;Traits: the Else-If-Then of Types,&#148; <I>C++ Report,</I> 12(4), 2000.</p>
<p><a name="7"></a>[7]  Andrei Alexandrescu. &#147;Traits on Steroids,&#148;<I>C++ Report,</I> 12(6), 2000.</p>
<p><a name="8"></a>[8]  <I>International Standard, Programming Languages &#151; C++,</I> ISO/IEC:14882, 1998.</p>
<p><a name="9"></a>[9]  Note that it is also possible to define the access function template as a member of the <B>tuple</B> class. The syntax becomes then <B>x.get&lt;N&gt;()</B>. The current implementation implements both types of access functions.</p>
<p><a name="10"></a>[10]  The template parameter is explicitly specified, hence the additional <B>template</B> keyword in the call <B>element&lt;N-1&gt;::template get&lt;RET&gt;</B>.</p>
<p><a name="11"></a>[11]  It is possible to drop the <B>RET</B> parameter and resolve the return type similarly in the <B>element&lt;N&gt;::get</B> functions as well. However, resolving the type only once and not at every recursive instantiation alleviates the task of the compiler considerably.</p>
<p><a name="12"></a>[12]  Ian McCulloch presented this idea of using a class with reference members for unpacking the elements of a pair in a Usenet article, 1998.</p>
<p><a name="13"></a>[13]  Jaakko J&auml;rvi. &#147;Tuples and Multiple Return Values in C++,&#148; <I>Technical Report 249, 1999,</I> Turku Centre for Computer Science, &lt;www.tucs.fi/publications&gt;.</p>
<p><a name="14"></a>[14]  Jaakko J&auml;rvi. &#147;ML-Style Tuple Assignment in Standard C++ &#151; Extending the Multiple Return Value Formalism,&#148; <I>Technical Report 267, 1999</I>, Turku Centre for Computer Science, &lt;www.tucs.fi/publications&gt;.</p>

<p><i><B>Jaakko J&auml;rvi</B> is a researcher at Turku Centre for Computer Science. He has a Ph.D. in Computer Science from University of Turku, Finland. He can be reached at <B>jaakko.jarvi@cs.utu.fi</B>.</i></p>

<h4><a href="../../../source/2001/aug01/jarvi.zip"></a></h4>
</blockquote></body></html>
