<html><head><title>Nov02: Turning HTML into an RSS Feed</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; The Perl Journal--><h1>Turning HTML into an RSS Feed</h1><p><i>The Perl Journal</i> November 2002</p><h3>By Sean M. Burke</h3><I>Sean is a long-time contributor to CPAN, and is the author of </I>Perl &amp; LWP<I> from O'Reilly &amp; Associates. He can be contacted at sburke@cpan.org.</I><hr><p>In the September 2002 issue of <i>The Perl Journal</i>, Derek Valada's article "Parsing RSS Files with XML::RSS" sang the praises of RSS feeds, and showed how even if you don't have any RSS client programs or don't use a web site that aggregates them for you, it takes just a bit of Perl to write your own little utility for viewing the RSS content in your web browser. I can testify that once you get used to having RSS feeds from a few sites, you want all your favorite sites to have them. This article is about what to do when a site doesn't have an RSS feed: Make one for yourself by writing a little Perl tool to get content from the site's HTML.</p><h3>Sites Without RSS Feeds</h3><p>Some wonderful web sites provide RSS feeds that make it easy for us to find out when there's something interesting at their site, without actually having to go to that web site first. But some web sites just haven't gotten around to providing an RSS feed. Sometimes this is just because the site's programmers (if there are any!) just happen not to have heard about RSS yet. Or sometimes it's just that the people maintaining the site don't know that so many people actually use RSS and would appreciate an RSS feedthe main sysadmin of one of the Internet's larger web-logging sites recently told me, "I've considered it a bit but haven't found any real compelling reason yet, and no one else has seemed very interested in it"</p><p>Hopefully, all the larger sites will come around to providing RSS feeds; but I bet there will always be routinely updated content on the Web that lacks them. In that case, we have to make our own.</p><p>The first step in making an RSS feed for a remote site is checking that they don't already have one. Unlike a <i>/robots.txt</i> file, the RSS feed for a site doesn't have a predictable name, nor is there even any one place on a site where it's customary to mention the URL of the RSS feed. Some sites mention the URL in their FAQ, and recently some sites have started mentioning the URL in an HTML <i>link</i> element in the site's HTML, like so:</p><PRE>&lt;link rel="alternate" type="application/rss+xml"   href="http://that_rss_url" &gt;</PRE><p>If you can't find an RSS feed that way, search Google for "sitename RSS" or "sitename RDF"you'd be surprised how effective that is. And if that doesn't get you anywhere, e-mail the site's webmaster and ask for the URL of their RSS. If they get enough such messages, they'll make a point of more clearly stating the RSS feed's URL if they have one, or setting one up if they don't.</p><p>But if absolutely none of these things work out, then it's time to roll up your sleeves and write an RSS generator that extracts content from the site's HTML.</p><h3>Scanning HTML</h3><p>Processing HTML to find the bits of content that you want is one of the black arts of modern programming. Not only is each web page different, but as its content varies from day to day, it may exhibit unexpected changes in its template, which your program is hopefully robust enough to deal with. In fact, most of my book <i>Perl &amp; LWP</i> is an explanation of the bag of tricks that you should learn to use for writing really robust HTML-scanner programs. You also need a bit of practice, but if you don't have any experience at scanning HTML, then doing so to write an RSS is a great place to start. In this article, I'll stick to just using regular expressions instead of more advanced approaches involving HTML::TokeParser or HTML::TreeBuilder.</p><p>The basic approach is this:</p><PRE>use LWP::Simple;my $content_url = 'http://whatever.url.to/get/from.html';my $content = get($content_url);die "Can't get $content_url" unless defined $content;  <I>...then extract things from $content...</I></PRE><p>So, for example, consider http://freshair.npr.org/, the web site for National Public Radio's interview program <i>Fresh Air</i>. One page on the site has the listings for the current program, with HTML like this:</p><PRE>&lt;A HREF="http://www.npr.org/ramfiles/fa/20020920.fa.01.ram"&gt;Listen to   &lt;FONT FACE="Verdana, Charcoal, Sans Serif" 	COLOR="#ffffff" SIZE="3"&gt;   &lt;B&gt; John Lasseter            &lt;/B&gt; &lt;/FONT&gt;&lt;/A&gt; ...&lt;A HREF="http://www.npr.org/ramfiles/fa/20020920     .fa.02.ram"&gt;Listen to   &lt;FONT FACE="Verdana, Charcoal, Sans Serif" 	COLOR="#ffffff" SIZE="3"&gt;   &lt;B&gt; Singer and guitarist Jon Langford    &lt;/B&gt;&lt;/FONT&gt;&lt;/A&gt; <I>... plus any other segments ...</I></PRE><p>The parts that we want to extract are:</p><PRE>http://www.npr.org/ramfiles/fa/20020920.fa.01.ramJohn Lasseterhttp://www.npr.org/ramfiles/fa/20020920.fa.02.ramSinger and guitarist Jon Langford</PRE><p>We can get the page and match the content with <A NAME="rl1"><A HREF="#l1">Listing 1</A>, whose regular expression we arrive at through a bit of trial-and-error. When run, this happily produces the following output, showing that it's properly matching the three segments in that page (at time of writing):</p><PRE>url: {http://www.npr.org/ramfiles/fa/20020920.fa.01.ram}title: {John Lasseter}url: {http://www.npr.org/ramfiles/fa/20020920.fa.02.ram}title: {Singer and guitarist Jon Langford}url: {http://www.npr.org/ramfiles/fa/20020920.fa.03.ram}title: {Film critic David Edelstein}</PRE><p>We can later comment out that print statement and add some code to write <I>@items</I> to an RSS file.</p><p>Now consider this similar case, where we're scanning the HTML in the <i>Guardian</i></i>'s web page for breaking news:</p><PRE>... &lt;A HREF="/worldlatest/story/0,1280,-2035841,00.html"&gt;    UnsolvedCrimes Vex Afghanistan&lt;/A&gt;&lt;BR&gt;&lt;B&gt;6:50 am&lt;/B&gt;    &lt;P&gt;&lt;A HREF="/worldlatest/story/0,1280,-2035838,00    .html"&gt;Christians Show Support For Israel&lt;/A&gt;&lt;BR&gt;&lt;B&gt;    6:40am&lt;/B&gt;&lt;P&gt;&lt;A HREF="/worldlatest/story/0,1280,-203    5794,00.html"&gt;Schroe der's Party Wins 2nd Term&lt;/A&gt;    &lt;BR&gt;&lt;B&gt;5:30 am&lt;/B&gt;&lt;P&gt;...</PRE><p>It's a great big bunch of unbroken HTML (which I've put newlines into just for readability), but look at it a bit and you'll see that each item in it reads like this:</p><PRE>&lt;A HREF="<i>url</i>"&gt;<i>headline</i>&lt;/A&gt;&lt;BR&gt;&lt;B&gt;<i>time</i>&lt;/B&gt;&lt;P&gt;</PRE><p>You'll also note that items follow each other, one after another, with no intervening "&lt;/p&gt;&lt;p&gt;" tags or newlines.</p><p>So we cook up that pattern into a regular expression and put it into our aforementioned code template, as shown in <A NAME="rl2"><A HREF="#l2">Listing 2</A>. When we run that, the code correctly produces this list of items:</p><PRE>url: {/worldlatest/story/0,1280,-2035841,00.html}title: {Unsolved Crimes Vex Afghanistan}url: {/worldlatest/story/0,1280,-2035838,00.html}title: {Christians Show Support For Israel}url: {/worldlatest/story/0,1280,-2035794,00.html}title: {Schroeder's Party Wins 2nd Term} <I>...and a dozen more items...</I></PRE><p>We're ready to make both of these programs write their <i>@item</i>s to an RSS feedexcept for one thing: URLs in an RSS feed should really be absolute (starting with "http://..."), and not relative URLs like the "/worldlatest/story/0,1280,-2035794,00.html" we got from the Guardian page. Luckily, the URI.pm class provides a simple way to turn a relative URL to an absolute one, given a base URL:</p><PRE>URI-&gt;new_abs($rel_url =&gt; $base_url)-&gt;as_string</PRE><p>We can use this by adding a <i>use URI;</i> to the start of our program, and changing the end of our <i>while</i> loop to read like so:</p><PRE>$url = URI-&gt;new_abs($url =&gt; $content_url)-&gt;as_string;    print "url: {$url}\ntitle: {$title}\n\n";    push @items, $title, $url;  }</PRE><p>With that change made, our program emits absolute URLs, such as these:</p><PRE>url: {http://www.guardian.co.uk/worldlatest/story/0,1280,-2035841,00.html}title: {Unsolved Crimes Vex Afghanistan}url: {http://www.guardian.co.uk/worldlatest/story/0,1280,-2035838,00.html}title: {Christians Show Support For Israel}url: {http://www.guardian.co.uk/worldlatest/story/0,1280,-2035794,00.html}title: {Schroeder's Party Wins 2nd Term} <I>...and a dozen more items...</I></PRE><h3>Basic RSS Syntax</h3><p>An RSS file is a kind of XML file that expresses some data about the site in general, and then lists the details of each story item at that feed. While RSS actually has many more features than I'll discuss here (especially in later versions than the 0.91 version here), a minimal RSS file starts with an XML header, an appropriate doctype, and some metadata elements, like this:</p><PRE>&lt;?xml version="1.0"?&gt;&lt;!DOCTYPE rss PUBLIC "-//Netscape Communications//DTDRSS 0.91//EN"  "http://my.netscape.com/publish/formats/rss-0.91.dtd"&gt;&lt;rss version="0.91"&gt;&lt;channel&gt;  &lt;title&gt; title of the site &lt;/title&gt;  &lt;description&gt; description of the site 	&lt;/description&gt;  &lt;link&gt; URL of the site &lt;/link&gt;  &lt;language&gt; the RFC 3166 language tag for this 		feed's content &lt;/language&gt;</PRE><p>Then there are a number of <i>item</i> elements like this:</p><PRE>&lt;item&gt;&lt;title&gt;...headline...&lt;/title&gt;&lt;link&gt;...url.. 	&lt;/link&gt;&lt;/item&gt;</PRE><p>And then the document ends like this:</p><PRE>&lt;/channel&gt;&lt;/rss&gt;</PRE><p>So the RSS file that we would produce with our <i>Fresh Air</i> HTML scanner would look like <A NAME="rf1"><A HREF="0211cf1.htm">Figure 1</A> (shown with with a bit of helpful indenting).</p><p>We can break <A NAME="rf1"><A HREF="0211cf1.htm">Figure 1</A> down to three main pieces of code: one for all the stuff before the first item, one for taking our <i>@item</i>s and spitting out the series of &lt;item&gt;...&lt;/item&gt; elements, and then one to complete the XML by outputting &lt;/channel&gt;&lt;/rss&gt;. But first there's one considerationwe can't really just take the code we pulled out of the HTML and dump it into XML. The reason for this is that XML is much less forgiving than HTML, notably with &amp;foo; codes, or "character entity references," as they're called. That is, the HTML could have this:</p><PRE>&lt;a href="..."&gt;Proctor &amp; Gamble to merge with H&amp;R 		Block&lt;/a&gt;</PRE><p>That's acceptable (if not proper) HTMLbut it's strictly forbidden in XML, and will cause any XML parser to reject that document. In XML, if there's an <i>&amp;</i>, it must be the start of a character entity reference, and if you mean a literal "&amp;", it must be expressed as with just such a <i>&amp;foo;</i> codetypically as &amp;amp;, but also possibly as &amp;#38; or &amp;#x26;.</p><p>Moreover, just because something is a legal HTML &amp;foo; code doesn't mean it's legal in an RSS file. For the sake of compatibility, the RSS 0.91 DTD (at the URL you see in the &lt;!DOCTYPE...&gt; declaration) defined the same &amp;foo; codes as HTMLbut that was the HTML of several years ago, back when there were just codes for the Latin-1 characters 160 to 255. This gets you codes like &amp;eacute;, but if you try using more recent additions like &amp;euro; or &amp;mdash;, the RSS parser will fail to parse the document.</p><p>So just to be on the safe side, we should decode all the <i>&amp;foo;</i> codes in the HTML, and then reencode everything, except using numeric codes (like &amp;#123;), since those are always acceptable to XML parsers. And while we're at it, we should kill any tags inside that HTML, in case the HTML that we captured happens to contain some &lt;br&gt;s, which would become malformed as XML. To do the <i>&amp;foo;</i> decoding, we can use the ever-useful HTML::Entities module (available in CPAN as part of the HTML-Parser distribution). Then we do a little cleanup and use a simple regexp to replace each unsafe character (like &amp; or &eacute;) with a <i>&amp;#number;</i> code. The eminently reuseable routine for doing this looks like <A NAME="rl3"><A HREF="#l3">Listing 3</A>.</p><h3>Hooking It All Together</h3><p>Once we've got the xml_string routine as previously defined, we can then use it in a routine that takes the contents of our <i>@item</i>s (alternating title and URL), and returns XML as a series of &lt;item&gt;...&lt;/item&gt; elements, as in <A NAME="rl4"><A HREF="#l4">Listing 4</A>.</p><p>We can test that routine by doing this:</p><PRE>print rss_body("Bogodyne rockets &gt; 250&amp;frac12;/share!","http://test");</PRE><p>Its output is this:</p><p>&lt;item&gt;</p><p>     &lt;title&gt;Bogodyne rockets &amp;#62; 250&amp;#189;/ 	   share!&lt;/title&gt;</p><p>     &lt;link&gt;http://test&lt;/link&gt;</p><p>&lt;/item&gt;</p><p>This is correct, since &amp;#62; is XMLese for "a literal &gt; character," and &amp;#189; is for "a literal 1/2 character." Since this is all working happily, we can make another routine for the start of the XML document, as shown in <A NAME="rl5"><A HREF="#l5">Listing 5</A>. Then spitting out the bare-<sub>bones RSS XML that we're after is just a matter of making the call shown in <A NAME="rl6"><A HREF="#l6">Listing 6</A>.</p><p>Run the program, and it indeed spits out the valid XML shown in <A NAME="rf2"><A HREF="0211cf2.htm">Figure 2</A>. To do the same for our Fresh Air program, we just append the same code, changing the parameters to rss_start, as in <A NAME="rl7"><A HREF="#l7">Listing 7</A>. Running that program returns the RSS expression of our <i>@item</sub></i>s as shown in <A NAME="rf3"><A HREF="0211cf3.htm">Figure 3</A>.</p><p>And because we put everything through our xml_escape routine, the XML text is always properly escaped, even if our original HTML scanner regexp happens to trap an HTML tag or malformed <i>&amp;foo;</i> code.</p><p>That's all there is to making a basic RSS generator program. The only question left is how to have it run.</p><h3>Running via CGI or via Cron</h3><p>There are two main ways to use an RSS generator programit should either run as a CGI and send output to the browser on demand, or it should be run periodically via cron, and save output to a file that can be accessed at some URL.</p><p>The mechanics are simple. If the program is to run as a CGI, just start its output out with a MIME header like so:</p><PRE>print "Content-type: application/rss+xml\n\n",  rss_start(  ... and the rest, as before ...</PRE><p>If you want to save the output to a file, instead do this:</p><PRE>my $outfile = '/home/jschmo/public_html/freshair.rss';open(OUTXML, "&gt;$outfile")  || die "Can't write-open $ouffile: $!\nAborting";print OUTXML  rss_start(  ... and the rest, as before ...</PRE><p>The more complex issue is: Under what conditions would you want to do it one way or the other way? If the program runs as a CGI, it will connect to the remote server to get the HTML as many times as there are requests for the RSS feed. If this is an RSS feed that only you know about, and you access it only a few times a day at most, then having it run as a CGI is just fine.</p><p>But if the RSS feed might be accessed often, then it would be more efficient for your server, as well as for the remote server, if you have the RSS updater run periodically via cron, as with a crontab line like this:</p><PRE>13 6-17 * * 1-5 /home/jschmo/make_fresh_air_rss</PRE><p>That will run the program at 13 minutes past the hour between 6:13am and 5:13pm, Monday through Fridayand those are the only times that it will request the HTML from the server, no matter how many times the resulting RSS file gets hit. Implicit in those crontab settings is the assumption that we don't really need absolutely up-to-the-minute information (or else we'd set it to run more often, or just go back to using the CGI approach) and that there's no point in accessing the RSS data outside of those hours. Since <i>Fresh Air</i> is produced only once every weekday, I've judged that it's very unlikely that their HTML listings page will change outside of those hours.</p><p>You should always be considerate of the remote web server, so you should request its HTML only as often as necessary. Not only does this approach go easy on the remote server, it also goes easy on your server (which is running the RSS generator). This is fitting, considering that the whole point of an RSS file is to bring people to the content they're interested in, as efficiently as possible, from the points of view of the people and of the web servers involved.</p><p>TPJ</p><H4><A NAME="l1">Listing 1</H4><pre>use LWP::Simple;   my $content_url = 'http://freshair.npr.org/dayFA.cfm?todayDate=current';   my $content = get($content_url);   die "Can't get $content_url" unless defined $content;   $content =~ s/(\cm\cj|\cj|\cm)/\n/g; # nativize newlines    my @items;   while($content =~ m{   \s+&lt;A HREF="([^"\s]+)"&gt;Listen to   \s+&lt;FONT FACE="Verdana, Charcoal, Sans Serif" COLOR="#ffffff" SIZE="3"&gt;   \s+&lt;B&gt;(.*?)&lt;/B&gt;   }g) {     my($url, $title) = ($1,$2);     print "url: {$url}\ntitle: {$title}\n\n";     push @items, $title, $url;   }</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing 2</H4><pre>use LWP::Simple;   my $content_url = 'http://www.guardian.co.uk/worldlatest/';   my $content = get($content_url);   die "Can't get $content_url" unless defined $content;   $content =~ s/(\cm\cj|\cj|\cm)/\n/g; # nativize newlines      my @items;   while($content =~     m{&lt;A HREF="(/worldlatest/.*?)"&gt;(.*?)&lt;/A&gt;&lt;BR&gt;&lt;B&gt;.*?&lt;/B&gt;&lt;P&gt;}g   ) {     my($url, $title) = ($1,$2);     print "url: {$url}\ntitle: {$title}\n\n";     push @items, $title, $url;   }</pre><P><A HREF="#rl2">Back to Article</A></P><H4><A NAME="l3">Listing 3</H4><pre>use HTML::Entities qw(decode_entities);    sub xml_string {     # Take an HTML string and return it as an XML text string          local $_ = $_[0];     # Collapse and trim whitespace     s/\s+/ /g;  s/^ //s;  s/ $//s;          # Delete any stray HTML tags     s/&lt;.*?&gt;//g;      decode_entities($_);          # Substitute or strike out forbidden MSWin characters!     tr/\x91-\x97/''""*\x2D/;     tr/\x7F-\x9F/?/;          # &amp;-escape every potentially unsafe character     s/([^ !#\$%\x28-\x3B=\x3F-\x7E])/'&amp;#'.(ord($1)).';'/seg;      return $_;   }</pre><P><A HREF="#rl3">Back to Article</A></P><H4><A NAME="l4">Listing 4</H4><pre>sub rss_body {     my $out = '';     while(@_) {       $out .= sprintf        "  &lt;item&gt;\n\t&lt;title&gt;%s&lt;/title&gt;\n\t&lt;link&gt;%s&lt;/link&gt;\n  &lt;/item&gt;\n",        map xml_string($_),            splice(@_,0,2); # get the first two each time     }     return $out;   }</pre><P><A HREF="#rl4">Back to Article</A></P><H4><A NAME="l5">Listing 5</H4><pre>sub rss_start {     return sprintf q[&lt;?xml version="1.0"?&gt;   &lt;!DOCTYPE rss PUBLIC "-//Netscape Communications//DTD RSS 0.91//EN"     "http://my.netscape.com/publish/formats/rss-0.91.dtd"&gt;   &lt;rss version="0.91"&gt;&lt;channel&gt;     &lt;title&gt;%s&lt;/title&gt;     &lt;description&gt;%s&lt;/description&gt;     &lt;link&gt;%s&lt;/link&gt;     &lt;language&gt;%s&lt;/language&gt;   ],     map xml_string($_),       @_[0,1,2,3];  # Call with: title, desc, URL, language!   }...and for the end:  sub rss_end {     return '&lt;/channel&gt;&lt;/rss&gt;';   }</pre><P><A HREF="#rl5">Back to Article</A></P><H4><A NAME="l6">Listing 6</H4><pre>print    rss_start(      "Guardian World Latest",      "Latest Headlines from the Guardian",      $content_url,      'en-GB',  # language tag for UK English    ),    rss_body(@items),    rss_end()   ;</pre><P><A HREF="#rl6">Back to Article</A></P><H4><A NAME="l7">Listing 7</H4><pre>print    rss_start(      "Fresh Air",      "Terry Gross's interview show on National Public Radio",      $content_url,      'en-US',  # language tag for US English    ),    rss_body(@items),    rss_end()   ;TPJ</pre><P><A HREF="#rl7">Back to Article</A></P></body></html>