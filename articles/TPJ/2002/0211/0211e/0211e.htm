<html><head><title>Nov02: Really Lazy Persistence</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; The Perl Journal--><h1>Really Lazy Persistence</h1><p><i>The Perl Journal</i> November 2002</p><h3>By Simon Cozens</h3><I>Simon is a freelance programmer and author, whose titles include Beginning Perl and Extending and Embedding Perl. He's the creator of over 30 CPAN modules, a former Parrot pumpking, and an obsessive player of the Japanese game of Go. Simon can be reached at simon@simon-cozens.org.</I><hr><p>It comes up fantastically often&#151;you've got some piece of data stored in a variable; maybe a cache or a hash full of CGI session data. You want the data in the variable to be available next time you run your Perl program. This is the well-known "data persistence problem."</p><p>Thankfully, the data persistence problem has a huge number of solutions; if you want to make lots and lots of data persistent, you can look at SQL backended object databases or Perl modules such as <i>Tangram</i>, <i>Alzabo</i>, <i>Pixie</i>, <i>DBIx::SearchBuilder,</i> and the like. Or for the much more common small cases where you don't need a full-blown RDBMS to store your data, you can use one of the DBM libraries.</p><DDJADVERTISEMENT INLINE><p>DBM is an ancient UNIX database file format, which stores key-value pairs, much like hashes. There are a bunch of libraries around that implement DBM: The Berkeley database from Sleepycat, <i>DB_File</i>, is the most flexible and reliable, but <i>NDBM</i> and <i>GDBM</i> are two others.</p><p>So, we get out <i>DB_File</i>, choose some filenames, tie the variables we need tied, and that's it, right? Problem solved.</p><p>Well, not exactly, because not everyone has <i>DB_File</i> installed; so there's a proxy module called "AnyDBM_File" that tests to see which DBM libraries are actually available. Great.</p><p>Actually, there's another snag. One limitation of the DBM format is that it doesn't understand complex data structures&#151;it only stores keys and values as strings. No big deal&#151;the multilevel DBM (<i>MLDBM</i>) Perl module sits between Perl and the DBM library, and automatically serializes and unserializes references, making it possible for you to use data structures in your persistent variables.</p><h3>The Real Problem</h3><p>Although we've found a workable solution, the upshot of all this is that in order to get a hash to persist, we need to think up a filename, find a safe place to put the file, load the <i>AnyDBM_File</i> library, load <i>MLDBM</i>, remember the syntax to <i>tie</i>, and so on; you end up with code looking like this:</p><PRE>use AnyDBM_File;use MLDBM qw(AnyDBM_File);use File::Spec::Functions qw(catdir tmpdir);@AnyDBM_File::ISA = qw(DB_File NDBM GDBM);# Prefer DB_Filemy (%hash, @array);# Must remember to make sure nobody else is using# these file names!my $hash_file = catdir(tmpdir(), "hashdatabase");my $array_file = catdir(tmpdir(), "arraydatabase");tie %hash, "MLDBM", $hash_file;tie @array, "MLDBM", $array_file;</PRE><p>That's nine lines of real code just to make two variables persist; and we still have to make sure that no other application decides to choose the same names for its database files. What happened to making easy things easy and hard things possible?</p><p>This is the <i>real</i> data persistence problem: We have a solution, but it forces us to do a lot of work, and we'd rather be lazy.</p><h3>The Solution</h3><p>Enter <i><i>Attribute::Persistent</i></i>. Here's the same code as above, written to use <i>Attribute::Persistent</i>.</p><PRE>     use Attribute::Persistent;     my (%hash, @array) :persistent;</PRE><p>As if that wasn't enough, you get an additional guarantee that no other application will corrupt your files. Isn't that more like what we should expect from Perl?</p><p>So, you're probably wondering how this works and what it really does. We'll start by looking at Perl's attributes system, where we'll find a story that reflects the "real" data persistence problem.</p><h3>A Bit About Attributes</h3><p>Attributes appeared in Perl 5.005 via the now-deprecated <i>attrs</i> module. These let you specify attributes on a subroutine, although they were restricted to "locked," which put an exclusive lock around the <i>sub</i> in threaded Perl, and "method." Perl 5.005 attributes also had the following ugly syntax:</p><PRE>sub blast {    use attrs qw(locked method);    ...}</PRE><p>5.6 tidied this up a little, to the now-familiar syntax:</p><PRE>sub blast :locked :method {}</PRE><p>and added user-definable attributes and the ability to apply attributes to variables as well as subroutines.</p><p>Unfortunately, the mechanism for doing anything with attributes is rather obscure. If you say</p><PRE>my $pencil :color(blue);</PRE><p>then a call is made to a class method called <i>MODIFY_SCALAR_ATTRIBUTES</i> in the current package. This method receives a reference to the variable or subroutine that is having a method applied, and then all the attribute names in full; it's then expected to return the names of the attributes it couldn't do anything with.</p><p>So you ended up with something like</p><PRE>sub UNIVERSAL::MODIFY_SCALAR_ATTRIBUTES {     my ($self, $ref, @attribs) = @_;    for (@attribs) {        if (/color\(\w+\)/) {            tie $$ref, "String::Colored", $1;        } else {            push @unknown, $_;    }            return @unknown;}</PRE><p>This is OK, but it's not very friendly; it's also especially problematic if you want to handle more than one attribute name in your class&#151;or indeed, if you wanted several modules to each be able to chip in a bunch of attributes they could handle.</p><p>So Damian Conway produced a module called <i>Attribute::Handlers</i>, which makes the process a little more transparent. Now all you need to do is create a subroutine with the same name as the attribute you're trying to define, and declare that this is an attribute handler. How do you declare that? With an attribute, naturally!</p><PRE>use Attribute::Handlers;sub color :ATTR(SCALAR) {    my ($self, $symbol, $referent, $attr, $data, 		$phase) = @_;    tie $$referent, "String::Colored", $data;}</PRE><p>As you can see, this is much easier to deal with, and you also get a lot more information about the attribute: the symbol table entry (typeglob) and the reference that are having the attribute applied; the attribute name, any data ("<i>blue</i>" in our example) passed to the attribute, and at what stage of Perl's parsing of the program the attribute was applied.</p><p>Since we have a typeglob, we can even get at the variable's name, using a little-known typeglob trick:</p><PRE>my $varname = *{$symbol}{NAME};</PRE><p>Of course, in this code, the idea of using an attribute to tie a variable is not an uncommon one, and so <i>Attribute::Handlers</i> gets even friendlier:</p><PRE>use Attribute::Handlers autotie =&gt; { color =&gt; "String::Colored" };</PRE><p>All this infrastructure has made it very easy to implement a load of cool, attribute-based modules: <i>Attribute::Memoize</i>, <i>Attribute::Types</i>, and <i>Attribute::Util</i> being the most interesting three.</p><p>But not <i>Attribute::Persistent</i>; that had yet another problem. I wanted <i>Attribute::Persistent</i> to choose names for the databases that were related to the name of the variable being made persistent. Unfortunately, even though <i>Attribute::Handlers</i> provides a lot of information to developers, it can't provide the variable name for lexical variables&#151;they don't live in a symbol table, so we can't use the <i>*glob{NAME}</i> trick on the symbol table entry to find the variable name.</p><p>To get around this obstacle, I used another Damian module&#151;<i>Attribute::Handlers::Prospective</i>. This used a source filter to pass on more information about the attribute, including&#151;thankfully for me&#151;even the name of lexicals.</p><h3>The Finished Product</h3><p>So now we can take a peek inside <i>Attribute::Persistent</i> and see how it was done.</p><p>The first few lines should not be any surprise to anyone.</p><PRE>package Attribute::Persistent;use strict;our $VERSION = "1.0";</PRE><p>Now we needed a means to identify the user's program uniquely, so that other programs on the same system using <i>Attribute::Persistent</i> don't stomp over its databases. We call this the key.</p><PRE>my $key;</PRE><p>You might think that we should generate this from the filename; I thought that too, but then I realized that it wasn't very unlikely to have two different <i>foo.pl</i>s lying around. So if possible, we take an MD5 sum of the source file, which reduces chances of a collision to 1 in 10<sup>155</sup>; if MD5 collides, we have bigger problems anyway.</p><PRE>require Digest::MD5;local *IN;if (-e $0 and open IN, $0) {    local $/;    my $x = &lt;IN&gt;;    $key = Digest::MD5::md5_hex($x);    close IN;} else {    $key = "Persistent$0";}1;</PRE><p>This means, of course, that when you change the source code to a program, the MD5 sum changes, and now you can't find your old data any more. Just think of it as a way of automatically flushing the cache when you update your code...</p><p>And that's all we do in the <i>Attribute::Handlers</i><i> </i>package. Because we want this attribute to be available to all packages, we have to put the real meat into the <i>UNIVERSAL</i> package.</p><PRE>package UNIVERSAL;use Attribute::Handlers::Prospective;Now comes all that rubbish you saw before when handling the DBM file:use File::Spec::Functions (':ALL');BEGIN { @AnyDBM_File::ISA = qw(DB_File GDBM_File 		NDBM_File) }use AnyDBM_File;use MLDBM qw(AnyDBM_File);no strict; # Attributes do evil thingsAnd finally, we can define the attribute:sub persistent :ATTR(RAWDATA) {</PRE><p>The first thing we want to do is find the name of the variable we've been passed. We also demand that this is a lexical:</p><PRE>    *{$_[1]}{NAME} =~ /LEXICAL\((.*)\)/ or do {        require Carp;        croak("Can only define :persistent on 		lexicals");    };</PRE><p>And now we have the variable name, complete with sigil, in <i>$1</i>. We need to use this in two ways: We need to keep the original name, for reporting errors, and we need to munge it into something suitable for use as part of a filename:</p><PRE>    my $name = $1;    my $origname = $name;</PRE><p>We need to know what type the variable is, so that we can dereference its reference correctly; this also helps us set up the filename so that <i>%foo</i> comes out as <i>H-foo</i> and <i>@foo</i> comes out as <i>A-foo</i>. This way, we can have two different persistent <i>foo</i> variables and they'll be kept separate:</p><PRE>$name =~ s/^\%/H-/ and $type = '%';$name =~ s/^\@/A-/ and $type = '@';</PRE><p>However, we also allow the user to explicitly give their own name to a variable as an argument to the <i>:persistent</i> attribute, which we'll use as part of the filename:</p><PRE>if ($_[4] ne "undef") { $name = $_[4]; }</PRE><p>Now we make it filesystem-safe and put it in the temporary directory:</p><PRE>$name =~ s/\W+/-/g;my $filename = catdir(tmpdir(),"$key-$_[0]-$name");</PRE><p>Finally, we can do the tie by correctly dereferencing the reference we were passed:</p><PRE>tie (($type eq "%" ? %{$_[2]} : @{$_[2]}), "MLDBM", $filename)or do {require Carp; croak("Couldn't tie $origname to 	$filename - $!")}; </PRE><p>And that, essentially, is all of <i>Attribute::Persistent</i>.</p><h3>Philosophical Aside</h3><p>We've seen two stories here: the story of <i>Attribute::Persistent</i>, and the story of attributes in Perl. There's a way in which these two stories are very similar: We started off with a great idea that got implemented a long time ago, but that suffered from having an interface that didn't allow us to be as lazy as we'd like. So, someone bit the bullet and wrote higher level modules to simplify the interface and make things either more powerful or less cluttered for the end programmer.</p><p>In the case of attributes themselves, the basic functionality lay unused for quite a while due to the clumsiness of the interface. However, once Damian produced <i>Attribute::Handlers</i> and did most of the work, an explosion of impressive uses for the feature sprung into being soon afterwards.</p><p>If you look at other parts of Perl, you'll see the same story; source filters, for instance, were a "little known feature" back in 1996. Paul Marquess's <i>Filter::Util::Call</i> module did a great job of exposing the C interface to source filters, but still the feature languished in obscurity. Then Damian again came up with a higher level module, <i>Filter::Simple</i>, which truly was simple, and suddenly a wealth of filter-based modules appeared. This happens again and again&#151;with pluggable optimizers, the iThreads system, XS versus <i>Inline</i>, and so on.</p><p>What can we learn from this? First, interface design is much more important than you might think in terms of "selling" an advanced feature. It may be fantastically powerful, but even though you're writing for other programmers, if nobody's interested in getting their heads around the interface, it'll be largely ignored. Laziness is a Perl virtue, and if you do something clever with Perl, it's important to take the time to allow other people to be lazy with it.</p><p>Second, we can learn that there are a bunch of very interesting things going on in Perl or in Perl modules that nobody knows about. Source filters were in Perl for over four years before they became vogue. Take a look around, and you too may be able to create a "middle man" module that does the hard work, allowing others to be lazy in playing around with the next great feature.</p><p>Third, we can be thankful that there are people like Damian Conway who are willing to do the hard work of putting obscure and powerful features into easy-to-use packages. As we saw with the history of using DBMs, there's a trend towards more and more abstractions making the end-programmer's life easier. Writing the abstraction code that does the heavy work so another programmer doesn't have to is unglamorous and generally thankless, but it means you'll be doing the biggest favor possible to your fellow developers&#151;you'll be saving them time.</p><p><b>TPJ</b></p></body></html>