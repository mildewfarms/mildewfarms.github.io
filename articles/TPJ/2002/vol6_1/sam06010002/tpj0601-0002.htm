<html><head><title>Resource Locking with Semaphore Files</title></head><body bgcolor="ffffff"><h1>Resource Locking with Semaphore Files</h1><p><b>Sean M. Burke</b><br>  <span class="date">Spring, 2002</span></p>  <p>"When is it for?"<P>-- Brain Eno and Peter Schmidt, <I>Oblique Strategies</I><P>The worst kinds of bugs are the ones that don't appear during development, but then randomly appear only in real use. In the case of a complicated program running on several different platforms, such problems are not too surprising; but the first time I ran into such a problem was in a very simple program that ran on the same machine I developed it on. It was a simple SSI counter for a Web page, and it looked like this:<P><pre>open COUNTER, "&lt;counter.dat" or die "Can't read-open: $!";my $hits = &lt;COUNTER&gt;;close(COUNTER);++$hits;print "Hits on this page: $hits\n";open COUNTER, "&gt;counter.dat" or die "Can't write-open: $!";print COUNTER $hits;close(COUNTER);</pre>I got it going, and everything seemed to work fine:<P><pre>% perl -cw counter.plcounter.pl syntax OK% echo 0 &gt; counter.dat ; chmod a+rw counter.dat% perl -w counter.plHits on this page: 1% perl -w counter.plHits on this page: 2% perl -w counter.plHits on this page: 3</pre>I tested it in an <I>.shtml</I> Web page and, in the browser, it merrily displayed "Hits on this page: 4", then on reloading displayed "Hits on this page: 5", and so on. When the Web page was put on a public site, it dutifully started reporting "Hits on this page: 249", and I'd check back later and see "Hits on this page: 634", and everything seemed fine. But then I'd look back later and see "Hits on this page: 45". Something was clearly amiss, but I could see absolutely nothing wrong with the tiny counter program. So, I sought the advice of others, and they pointed out to me the problem that I will now explain to you.<P>We as programmers are used to putting ourselves in the shoes of our program, and relating to it as an individual: "What file should <I>I</I> open now? What do <I>I</I> do if I can't open that file? What do <I>I</I> do if that other program went and deleted that file?" and so on. But this handy metaphor breaks down when we need to imagine other <I>simultaneous</I> instances of our program following the same set of instructions. And that's just how the above counter program was getting into trouble. In testing, I never had two instances of the program running at once; but once the counter was on a publicly visible Web page, there were eventually two instances of the counter running at once, with various unfortunate results.<P><B>Problems with Simultaneous Instances</B><P>Imagine that two people, at about the same instant, are accessing the Web page with the counter discussed above. This leads the Web server to start up an instance of <I>counter.pl</I> for each user, at slightly different times. Let's suppose that the content of <I>counter.dat</I> at the beginning is the number "1000" and trace what each instance does.<P><pre>Instance 1                               Instance 2-----------------                        -----------------open COUNTER, "&lt;counter.dat" or die "Can't read-open: $!";my $hits = &lt;COUNTER&gt;;close(COUNTER);</pre>So instance 1 has read "1000" into <B>$hits</B>. Then:<P><pre>                              open COUNTER, "&lt;counter.dat"                               or die "Can't read-open: $!";                              my $hits = &lt;COUNTER&gt;;                              close(COUNTER);</pre>Instance 2 has read "1000" into <B>$hits</B>. Then:<P><pre>++$hits;print "Hits on this page: $hits\n";                              ++$hits;                              print "Hits on this page: $hits\n";</pre>Each instance increments its <B>$hits</B> and each gets 1001, and each displays that figure to its respective user. Then:<P></pre>open COUNTER, "&gt;counter.dat" or die "Can't write-open: $!";print COUNTER $hits;close(COUNTER);</pre>Instance 1 has updated <I>counter.dat</I> to 1001, and then ends. Then finally:<P><pre>                              open COUNTER, "&gt;counter.dat"                               or die "Can't write-open: $!";                              print COUNTER $hits;                              close(COUNTER);</pre>Instance 2 has updated <I>counter.dat</I> to 1001. The problem is that this is incorrect; even though we served the page twice, the counter ends up only 1 hit greater. That's beside the fact that we just told two different users that they were both the 1001st viewer of this page, whereas one was really the 1002nd.<P>Here's a more drastic case: imagine that the two instances are slightly more out of phase. Suppose instance 1 is writing the value "1501" to <I>counter.dat</I> as instance 2 is starting up and reading it:<P><pre>Instance 1                          Instance 2-----------------                   -----------------open COUNTER, "&gt;counter.dat" or die "Can't write-open: $!";                                   open COUNTER, "&lt;counter.dat"                                    or die "Can't read-open: $!";                                   my $hits = &lt;COUNTER&gt;;print COUNTER $hits;close(COUNTER);</pre>There, instance 1 overwrites <I>counter.dat</I> (with a zero-length file), but just as it's about to write the new value of its <B>$hits</B>, instance 2 opens that 0-length file and reads from it into its <B>$hits</B>. Reading from a 0-length file is just like reading from the end of any file: it returns undef. Then, instance 1 writes "1501" to <I>counter.dat</I> and ends. But instance 2 is still working:<P><pre>                              ++$hits;                              print "Hits on this page: $hits\n";                              open COUNTER, "&gt;counter.dat"                               or die "Can't write-open: $!";                              print COUNTER $hits;                              close(COUNTER);</pre>It has incremented <B>$hits</B>, and incrementing an undef value gives you 1. It then tells the user "Hits on this page: 1", and updates the <I>counter.dat</I> with a new value: 1. Our counter just went from 1501 to 1!<P>Each program was perfectly following its own instructions, but together they managed to be wrong. I had tacitly assumed that this case, where two instances coincide, would never happen; but I never actually put anything in place to stop it from happening. Or maybe I'd assumed it <I>could</I> happen, but that the chances were astronomical. After all, "it's just a stupid Web page counter anyway". But anything worth doing, is worth doing right, and what needed doing here was to make sure that the above scenarios couldn't happen. Moreover, the way to keep this counter program from losing its count is also the way we keep more important data from being lost in other programs: file locking, a UNIX OS feature that's meant to help in just these sorts of cases.<P>A first hack at using file locking would change the program to read like this:<P><pre>use Fcntl ':flock';  # import LOCK_* constantsopen COUNTER, "&lt;counter.dat" or die "Can't read-open: $!";<B>flock COUNTER, LOCK_EX;</B>  # So only one instance gets to access this at a time!my $hits = &lt;COUNTER&gt;;close(COUNTER);++$hits;print "Hits on this page: $hits\n";open COUNTER, "&gt;counter.dat" or die "Can't write-open: $!";<B>flock COUNTER, LOCK_EX;</B>  # So only one instance gets to access this at a time!print COUNTER $hits;close(COUNTER);</pre>So, when a given program instance calls "<B>flock FH, LOCK_EX</B>" on a given filehandle, it is signaling, via the operating system, that it wants exclusive access to that file; and if some other process has just called "<B>flock FH, LOCK_EX</B>" first, then our instance will wait around until it's done. And similarly, once we get a lock on this file, if any other process calls "<B>flock FH, LOCK_EX</B>", the OS will make it wait until we're done. The way the above program signals that it's done, is by calling <B>close</B> on the filehandle.<P>Although it could have called <B>flock COUNTER, LOCK_UN</B>, it's enough to just close it, because of these important facts about locking in the basic UNIX file model:<P><P><ul><li>  You can't lock a file until you've already opened it.<li>  When you close a file, you give up any lock you have on it.<li>  If a process ends while it has a file open, the file gets closed.<li>  So the only way a file can be locked at any moment is if a process had opened it, and then locked it, and hasn't yet closed it (either specifically, or by ending).</ul><P>Unfortunately, this means trouble for our <B>flock</B>-using code. Notably, there can still be a problem with instances being out of phase -- since we can't lock a file without already having opened it, things can still happen in that brief moment between opening the file and locking it. Consider when one instance is updating <I>counter.dat</I> just as another new instance is about to read it:<P><pre>Instance 1                         Instance 2-----------------                   -----------------open COUNTER, "&gt;counter.dat" or die "Can't write-open: $!";                                   open COUNTER, "&lt;counter.dat"                                    or die "Can't read-open: $!";                                   flock COUNTER, LOCK_EX;                                   my $hits = &lt;COUNTER&gt;;                                   close(COUNTER);flock COUNTER, LOCK_EX;</pre>There, the OS dutifully kept two instances at once from having an exclusive lock on the file. But the locking is too late, because instance 1, just by opening the file, has already overwritten <I>counter.dat</I> with a zero-length file, just as instance 2 was about to read it. So we're back to the same problem that existed before we had any <B>flock</B> calls at all: two processes accessing a file that we wish only one process at a time could access.<P><B>Semaphore Files</B><P>There are various special solutions to problems like the above, but the most general one involves semaphore files. The line of reasoning behind them goes like this: Since you can't lock a file until you've already opened it, any content you have in locked files still isn't safe. So just don't have any content at all in a locked file. However, we <I>do</I> have content we need to protect, namely the data in <I>counter.dat</I>. But that just means we can't use that as the file we go locking. Instead, we'll use some other file, never with any content of interest, whose only purpose will be to be a thing that different instances can lock for as long as they want access to <I>counter.dat</I>. The file that we lock but never store anything in, we call a semaphore file.<P>The way we actually use a semaphore file is by opening it and locking it before we access some other real resource (like a counter file), and then not closing the semaphore file until we're done with the real resource. So, we can go back to our original program and make it safe by just adding code at the beginning to open a semaphore file, and one line at the end to close it:<P><pre>use Fcntl ':flock';  # import LOCK_* constantsopen SEM, "&gt;counter.sem" or die "Can't write-open counter.sem: $!";flock SEM, LOCK_EX;open COUNTER, "&lt;counter.dat" or die "Can't read-open counter.dat: $!";my $hits = &lt;COUNTER&gt;;close(COUNTER);++$hits;print "Hits on this page: $hits\n";open COUNTER, "&gt;counter.dat" or die "Can't write-open counter.dat: $!";print COUNTER $hits;close(COUNTER);close(SEM);</pre>This avoids all the problems we saw earlier. Because the above program doesn't do anything with <I>counter.dat</I> until it has an exclusive lock on <I>counter.sem</I>, and doesn't give up that lock until it's done, there can be only one instance of the above program accessing <I>counter.dat</I> at a time.<P>It can still happen that some other program alters <I>counter.dat</I> without first locking <I>counter.sem</I> -- so don't do that! As long as every process locks the appropriate semaphore file while it's working on a given resource, all is well. All that you need to do is settle on some correspondence between file(s), and the semaphore file that controls access for them. It's a purely arbitrary choice, but when naming a semaphore file for a resource <I>file.ext</I>, I tend to name the semaphore file <I>file.sem</I>, <I>file.ext.sem</I>, or <I>file.ext_S</I>. As with any arbitrary decision, I advise picking one style and sticking with it -- clearly the whole purpose of this is defeated if one program looks to <I>counter.sem</I> as the semaphore file, while another looks to <I>counter.dat_S</I>.<P><B>Semaphore Objects</B><P>With our simple counter program, our simplistic but effective approach was just to bracket our program with this code:<P><pre>  use Fcntl ':flock';  # import LOCK_* constants  open SEM, "&gt;counter.sem"   or die "Can't write-open counter.sem: $!";  flock SEM, LOCK_EX;   ...do things...   close(SEM);   ...do anything else that doesn't involve counter.sem...</pre>That works quite well when our program is simple and involves just one semaphore file -- all we need to do is <B>close(SEM)</B> once we're done with <B>counter.sem</B> or whatever resource the SEM filehandle denotes a lock for. However, when a given program involves a lot of different files (which each requires its own semaphore file, and which are being locked and unlocked in arbitrary orders) then you can't just have them all in one global filehandle object called "SEM". You can use lexical filehandles using the Perl 5.6 <B>open my $fh,...</B> syntax, as here:<P><pre>  {    use Fcntl ':flock';  # import LOCK_* constants    open my $sem, "&gt;dodad.sem"      or die "Can't write-open dodad.sem: $!";    flock $sem, LOCK_EX;        ...things dealing with the resource that dodad.sem denotes     a lock on...         close($sem);  }</pre>In fact, the <B>close($sem)</B> command there isn't particularly necessary -- assuming you haven't copied the object from <B>$sem</B> into any other variable in memory, then when the program hits the end of the block where <B>my $sem</B> was declared, Perl will delete that variable's value from memory. Then, seeing that that is the only copy of that filehandle object, it will implicitly close the file, releasing the lock.<P>The benefit of using <B>my</B>'d filehandles instead of globals is that this method prevents namespace collisions; you could have other <B>my $sem</B> variables defined in other scopes in this program, and they wouldn't interfere with this. But, creating each semaphore object would still require the same repetitive <B>open</B> and <B>flock</B> calls, and needless repetition is no friend of programmers. We might as well wrap it up in a function:<P><pre>sub sem {  my $filespec = shift(@_) || die "What filespec?";  open my $fh, "&gt;", $filespec   or die "Can't open semaphore file $filespec: $!";  chmod 0666, $filespec; # assuming you want it a+rw  use Fcntl 'LOCK_EX';  flock $fh, LOCK_EX;  return $fh;}</pre>Then, whenever you want a semaphore lock on a file, you need only call:<P><pre>my $sem = sem('/wherever/locks/thing.sem');</pre>All you would then do with that object in <B>$sem</B> is keep it around as long as you need the lock on that semaphore file; or you could explicitly release the lock with just a <B>close($sem)</B>.<P>If you were an OOP fan, you could even wrap this up in a proper class, an object of which denotes an exclusive lock on a given semaphore file. A minimal class would look like this:<P><pre>package Sem;sub new {  my $class = shift(@_);  use Carp ();  my $filespec = shift(@_) || Carp::croak("What filespec?");  open my $fh, "&gt;", $filespec   or Carp::croak("Can't open semaphore file $filespec: $!"");  chmod 0666, $filespec; # assuming you want it a+rw  use Fcntl 'LOCK_EX';  flock $fh, LOCK_EX;  return bless {'fh' =&gt; $fh}, ref($class) || $class;}sub unlock {  close(delete $_[0]{'fh'} or return 0);  return 1;}1; # End of module</pre>Then you need only create the proper semaphore objects, like so:<P><pre>use Sem;my $sem = Sem-&gt;new('/wherever/locks/thing.sem');...later...$sem-&gt;unlock;</pre><B>Conclusion</B><P>If you've got a data file that's only ever manipulated by one program, and you're sure you'll never run multiple simultaneous instances of that program, then you don't need semaphore files. But you need semaphore files in all other cases, that is, where you have a file or other resource that is accessed by potentially simultaneous processes (whether different programs, or instances of the same program) and that resource could suffer from uncontrolled simultaneous access.<P>In this article, I've assumed that the programs for which you need semaphore files are all running on the same machine, that that machine runs UNIX (or something with the same basic locking semantics), and that the filesystem you're putting the semaphore files on is not NFS (which often doesn't implement locking properly). In my next <I>The Perl Journal</I> article, I'll discuss what to do if you need semaphore files, but either you're not under UNIX, or the processes you need to coordinate are running on several different machines.<P><I>Sean M. Burke (<B>sburke@cpan.org</B>) lives in New Mexico, where he mostly does data-munging for Native language preservation projects.</I><HR></body></html>