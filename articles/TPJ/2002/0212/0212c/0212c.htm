<html><head><title>Dec02: Perl & Rapid Database Prototyping</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Perl &amp; Rapid Database Prototyping</h1><p><i>The Perl Journal</i> December 2002</p><h3>By Tim Kientzle</h3><I>Tim is a freelance software developer and consultant. He can be reached at kientzle@acm.org.</I><hr><p>Even though the bulk of my production development is in C, Java, and assembly language, I often turn to Perl to quickly prototype new ideas. That's especially true with database applications. Perl's DBI module for database access provides convenient access to the most popular relational databases, and its strong text-processing abilities make it easy to synthesize complex queries.</p><p>Over the last several years, I've refined a simple framework that handles most routine database access automatically and significantly accelerates the development of simple database applications. This framework takes advantage of Perl's advanced object-oriented features to pack a lot of power into a small package.</p><DDJADVERTISEMENT INLINE><h3>Accessors</h3><p>Accessor functions are the easiest way to abstract database access. By convention, accessors in Perl are subroutines that can either set or return a value, depending on how they are called. <A NAME="rl1"><A HREF="#l1">Listing 1</A> illustrates a simple accessor function. The accessor always returns the old value; if a new value is specified, the function also sets the value.</p><h3>The Class-Per-Table Pattern</h3><p>Accessors are a natural way to manipulate database data. A simple object-oriented design pattern uses a single class for each table in your database. An object of such a class represents a single row, and you use accessor methods to read or change individual fields. Such a system could be used as in <A NAME="rl2"><A HREF="#l2">Listing 2</A>. The details of the data storage are completely hidden; this design makes it easy to change the details of the low-level storage without any impact on the higher level application code.</p><h3>Exploiting <i>AUTOLOAD</i></h3><p>The class-per-table pattern can involve a lot of highly repetitive code. For each column in the database, you need a method that can read/write that column. Often, programmers build simple code generators to create reams of code for such classes.</p><p>Perl's <i>AUTOLOAD</i> capability lets you eliminate almost all of the explicit accessor methods. If there is no "phone" method defined, then an expression such as<i> $e-&gt;phone</i> invokes the <i>AUTOLOAD</i> method instead. The special<i> $AUTOLOAD</i> variable contains the full name (including package name) of the method that was requested. Using this, the <i>AUTOLOAD</i> method can load the requested method from a disk or database or simply emulate the call directly.</p><p>My database access framework uses <i>AUTOLOAD</i> to provide a default accessor method for any column of a database. I simply use the name of the column as the name of the accessor. For example, if there is no explicit implementation of the phone method,<i> $e-&gt;phone('555-5555')</i> invokes <i>AUTOLOAD</i> to store the specified value into the phone column. This gives you convenient access to any database column without having to write any code.</p><h3>Packaging It Up</h3><p>Since real-world projects have lots of tables, I've created a single <i>DBTable</i> class that contains the <i>AUTOLOAD</i> method just described and a number of other convenient methods. The per-table classes simply inherit most of their functionality from <i>DBTable</i>. You only need to write one or more constructors that let you access rows in your tables.</p><p>To illustrate, consider the schema in <A NAME="rl3"><A HREF="#l3">Listing 3</A>. <A NAME="rl4"><A HREF="#l4">Listing 4</A> is the complete Perl code needed to use this schema. In particular, note that I've defined no accessors; the <i>AUTOLOAD</i> method in <i>DBTable</i> will handle them automatically.</p><p>Defining New Tables</p><p>The first three lines of <A NAME="rl4"><A HREF="#l4">Listing 4</A> are just standard boilerplate for any Perl class. The only interesting part is the <i>byName</i> constructor. The <i>_fetchOrCreate</i> method accepts a hash that identifies this row and returns a hash with the values of one or more columns. If the row doesn't exist, it is created.</p><p>The <i>DBTable</i> methods rely on the <i>TABLE</i> and <i>KEY</i> entries in the hash. The <i>TABLE</i> entry specifies the name of the database table. The <i>KEY</i> entry is a hash providing a primary key that identifies the particular row. In <A NAME="rl3"><A HREF="#l3">Listing 3</A>, the primary key is the value of the <i>employee_id</i> field. The first argument to the<i> _fetchOrCreate </i>method specifies a condition for identifying or creating the necessary row; the second argument is the column whose value is to be returned.</p><p>If you now look carefully at <A NAME="rl2"><A HREF="#l2">Listing 2</A>, you can see how the entire system works. The <i>$e</i> variable in that example contains everything needed to identify a particular row in a certain table. The call <i>$e-&gt;phone('555-5555')</i> invokes the <i>AUTOLOAD</i> method in the <i>DBTable</i> class, which can use the table name (from the <i>TABLE</i> key), the primary key (from the <i>KEY</i> key), and the column name (from the method name) to access the database.</p><h3>Inside <i>DBTable</i></h3><p>The full implementation of <i>DBTable</i> is shown in <A NAME="rl8"><A HREF="#l8">Listings 8</A> and 9, available in the Source Code Appendix, pages 24-26. There are only four places where SQL statements are actually constructed:<i> _fetch</i> reads one or more columns from a row,<i> _create</i> creates a new row,<i> _set</i> sets the values of columns, and<i> _columns </i>obtains the names of the columns in this table. The string manipulations that convert hashes into SQL statements are admittedly a bit convoluted, but they are hidden inside just a couple of small functions. Also available electronically is an example program that uses this code. You can use this as a starting point for your own database applications.</p><h3>Advanced Techniques</h3><p>Sometimes you will want accessors that return objects rather than raw database fields. <A NAME="rl5"><A HREF="#l5">Listing 5</A> is a <i>manager</i> method that returns an object. With this addition, you can refer to <i>$e-&gt;manager_id </i>to obtain the numerical ID for the <i>manager</i>, or <i>$e-&gt;manager</i> to obtain an object. Such methods are especially useful when you have complex schemas with many interrelated tables. In like fashion, you can define methods that simulate nonexistent database fields (by transparently accessing joined tables, for instance).</p><p>The <i>byID</i> constructor in <A NAME="rl5"><A HREF="#l5">Listing 5</A> could have simply used<i> $self-&gt;{'KEY'} = {'employee_id'=&gt;$id}</i> to set the <i>KEY</i> without any database access. Although that would be faster, it doesn't provide any guarantees that the requested row actually exists.</p><p>Finally, remember that <i>$e-&gt;dbHandle </i>returns the underlying DBI database handle to your application so that you can use SQL statements directly if necessary.</p><h3>Performance</h3><p>This framework makes it easy to prototype database applications. You simply define a package for each table in your schema, and those packages need only contain one or two simple constructors each. You can then begin to build your application, accessing database columns through accessor functions.</p><p>Of course, such applications are going to be slow. Every time you read or write a field, at least one database access is going to occur. As your application evolves, you can improve performance by overriding specific accessors. For example, if you access the primary key fields frequently, you can override them using code like that in <A NAME="rl6"><A HREF="#l6">Listing 6</A>.</p><p><A NAME="rl7"><A HREF="#l7">Listing 7</A> takes this idea a step further by modifying the constructor to store the entire row in memory, and overrides the <i>_fetch</i> and <i>_set</i> methods to read and update the in-memory versions, dramatically reducing database traffic. Such optimizations are not always appropriate, however, and are generally best delayed until you understand your application better.</p><h3>Future Directions</h3><p>Currently, <i>DBTable</i> stores the DBI database handle in a global variable, which limits you to a single database handle at a time. Applications that must access multiple databases will need to find a way to address this.</p><p>Right now, the <i>_columns </i>method is rather wasteful. It generates a full database query once for every object. It would be more efficient to do so only once for every table. Worse, it stores a list of valid columns in every object rather than once for each table, which could become a significant memory problem.</p><h3>Conclusion</h3><p>This framework has helped me to very rapidly build new database applications. In some cases, performance is not a serious issue, and such code can even be used in production. However, even when performance is an issue, this design is still a good place to start. You should generally be able to build functioning applications using this interface and then upgrade the underlying data access to improve performance without having to extensively modify your application.</p><p></p><p>TPJ</p><H4><A NAME="l1">Listing 1</H4><pre># Simple accessorsub foo {   my $a=$FOO;   ($FOO)=@_ if @_;   return $a;}# Using accessorsfoo(4);  # foo = 4print foo(5); # Print 4, set foo=5print foo(); # Print 5</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing 2</H4><pre># Access a row$e = Employee-&gt;byName('Doe', 'John');# Get phone numberprint $e-&gt;phone();# Set phone number$e-&gt;phone('555-5555');</pre><P><A HREF="#rl2">Back to Article</A></P><H4><A NAME="l3">Listing 3</H4><pre>CREATE TABLE employee(   employee_id  INT PRIMARY KEY,   first        CHAR(80),   last         CHAR(80),   phone        CHAR(80),   manager_id   INT);</pre><P><A HREF="#rl3">Back to Article</A></P><H4><A NAME="l4">Listing 4</H4><pre>package Employeeuse vars qw(@ISA);@ISA = qw(DBTable);sub byName {  my($class,$last,$first) = @_;  my $self = bless {'TABLE'=&gt;'employee'},$class;  # _fetchOrCreate returns a hash  # { 'employee_id' =&gt; &lt;number&gt; }  $self-&gt;{'KEY'} = $self-&gt;_fetchOrCreate(       {'last' =&gt; $last,'first' =&gt; $first}, 'employee_id' );  return $self;}</pre><P><A HREF="#rl4">Back to Article</A></P><H4><A NAME="l5">Listing 5</H4><pre># An accessor returning an objectsub manager {    my($self) = @_;    return Employee-&gt;byId($self-&gt;manager_id);}# Another constructorsub byID {    my($class,$id) = @_;    my $self = bless {},$class;    $self-&gt;{'TABLE'} = 'employee';    $self-&gt;{'KEY'} = $self-&gt;_fetchOrCreate                     ({'employee_id' =&gt; $id}, 'employee_id' );    return $self;}</pre><P><A HREF="#rl5">Back to Article</A></P><H4><A NAME="l6">Listing 6</H4><pre># An optimized employee_id accessorsub employee_id {  my $self = shift;  $self-&gt;{'KEY'}-&gt;{'employee_id'};}</pre><P><A HREF="#rl6">Back to Article</A></P><H4><A NAME="l7">Listing 7</H4><pre># An optimized Employee classpackage Employeeuse vars qw(@ISA);@ISA = qw(DBTable);sub byName {    my($class,$last,$first) = @_;    my $self = bless {},$class;    my $cols = $self-&gt;_columns;    $self-&gt;{'TABLE'} = 'employee';    # Read and cache all of the columns    $self-&gt;{'FIELDS'} = $self-&gt;_fetchOrCreate                  ({'last' =&gt; lc $last, 'first' =&gt; lc $first}, keys %$cols);    $self-&gt;{'KEY'} =        { 'employee_id' =&gt; $self-&gt;{'FIELDS'}-&gt;{'employee_id'} };    return $self;}# Override _fetch to just pull the value from memorysub _fetch {    my ($self, $key, $col) = @_;    return { $col =&gt; $self-&gt;{'FIELDS'}-&gt;{$col} };}# Override _set to modify the in-memory valuesub _set {    my($self,$key,$set) = @_;    $self-&gt;SUPER::_set($key,$set); # Set fields in DB    foreach $k (keys %$set) {       $self-&gt;{'FIELDS'}-&gt;{$k} = $set-&gt;{$k};       # Remember to update the value in 'KEY', if it's there       if(exists $self-&gt;{'KEY'}-&gt;{$k}) {          $self-&gt;{'KEY'}-&gt;{$k} = $set-&gt;{$k};       }    }}TPJ</pre><P><A HREF="#rl7">Back to Article</A></P></body></html>