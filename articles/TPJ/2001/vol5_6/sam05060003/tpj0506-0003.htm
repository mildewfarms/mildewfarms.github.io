<html><head><title>Helping the Disabled with Perl/Tk</title></head><body bgcolor="ffffff"><p><h1>Helping the Disabled with Perl/Tk</h1><p><b>Dan Brian with Jon Bjornstadr</b><br>  <span class="date">Winter, 2001</span></p><div align="center"><table width="350" border="1" cellspacing="0" cellpadding="5">	<tr><td bgcolor="#cccc99" align="middle"><b>Packages Used</b>  </td></tr>  <tr>    <td>	Tk Tk::JPEG<br>	Win32::Sound Win32::OLE<br>	AnyDBM_File, SDBM_File	</td>  </tr></table></div><p>Jon Bjornstad recently presented a "Lightning Talk" at the 2001 O'Reilly   Open Source Convention. He discussed a program that he had written for his friend,   Sue Simpson. She is a mute quadriplegic, and Jon's program allows her to   "speak", read online texts, and browse photos. The program is remarkably   clever in its use of Perl/Tk to overcome various obstacles in the creation of   an accessible GUI.<P>This program wasn't Jon's first volunteer effort; he earlier developed a complete administration program for a school and a Web store for a community project. A long-time C programmer, Jon found Perl five years ago and hasn't gone back since. Given the rapid development and assorted features he needed for Sue's program, it's a decision he has never regretted.<P> Jon met Sue in 1986 through a mailing list request to help her install software,   and they became friends. For years he helped configure and program a device   called the Express 3, a rectangular array of LEDs to which Sue could point with   a light pen attached to her glasses. As that device became obsolete, newer devices   were found to be too expensive, and other options did not seem to fit her needs.   Jon began writing a program specifically tailored for Sue that would allow her   to easily type and communicate. Since then, the program has continued to evolve   into a full user environment. See<a href="../sam05060003/tpj0506-0003_f1.htm">   Figure 1</a>.<P><B>A Text Interface for Speaking</B><P> The first feature Jon created was an online keyboard (<a href="../sam05060003/tpj0506-0003_f2.htm">Figure   2</a>) to allow Sue to input data. Because she cannot click a mouse button,   the ability to select onscreen elements with movement presented an initial challenge.   Jon employed the rarely used <B>Enter</B> and <B>Leave</B> motion callbacks   for a <B>Label</B>, in combination with a timer functionality. The following   simplified program illustrates this functionality and is shown in <a href="../sam05060003/tpj0506-0003_f3.htm">Figure   3</a>. First, a window (the <B>MainWindow</B> object class) and a label to contain   the value of variable <B>$msg</B> are created:<P><pre>use Tk;my $mw = MainWindow-&gt;new(-bg =&gt; "white");my $msg = "";$mw-&gt;Label(    -textvariable =&gt; \$msg,    -font         =&gt; "Arial 18 bold",    -width        =&gt; 30,    -bg           =&gt; "skyblue",    -anchor       =&gt; 'w',    -relief       =&gt; 'ridge',)-&gt;pack;</pre>Next, a subroutine <B>show</B> is defined, which will later serve as a callback function. The action here is dependent on the first parameter to this function, stored as <B>$let</B>:<P><pre>sub show {    my $let = shift;    if ($let eq "Quit") {        exit;    } elsif ($let eq "Clear") {        $msg = "";    } elsif ($let eq "Del") {        chop $msg;    } else {        $msg .= $let;    }}</pre>Having defined the necessary elements and callback, we can populate the window with labels. Note that we are detecting the <B>Enter</B> and <B>Leave</B> events for each, and binding them to a subroutine reference, which in turn calls the <B>show()</B> callback:<P><pre>my ($lab, $timer);for my $let (qw(A B C D E Del Clear Quit)) {    $lab = $mw-&gt;Label(        -text   =&gt; " $let ",        -font   =&gt; 'Arial 18 bold',        -bg     =&gt; length($let) &gt; 1? 'violet': 'lightgreen',        -relief =&gt; 'ridge',    )-&gt;pack;    $lab-&gt;bind("&lt;Enter&gt;", sub {        if ($let eq "Del") {            $timer = $mw-&gt;repeat(500, [ \&amp;show, $let ]);        } else {            $timer = $mw-&gt;after( 500, [ \&amp;show, $let ])        }    });    $lab-&gt;bind("&lt;Leave&gt;", sub {        $timer-&gt;cancel;    });}</pre>After looping to create the buttons (labels), the timers are implemented with the <B>MainWindow</B> method calls. When the mouse hovers over any label other than "Del", a timer <B>after()</B> function is called, which will delay the selection of that label. Once the time has passed, <B>show()</B> is called, and the action appropriate for the value of <B>$let</B> will execute.<P>This final piece of code starts the main Tk code loop:<P><pre>MainLoop;</pre>Using code similar to this, Sue is able to select any screen elements by hovering over them for an interval with no required mouse buttons. In practice, Sue uses a "head mouse" (<B>http://www.orin.com/access/headmouse/phm.htm</B>) fixed to her glasses, rather than the mouse.<P><B>Word Prediction</B><P> Typing an entire word can be time-consuming and laborious. For this reason,   most text-input interfaces of this type perform a word prediction (<a href="../sam05060003/tpj0506-0003_f4.htm">Figure   4</a>). As the letters are selected, the list shortens to reflect the matching   words. Consider that the letters "esp" prefix 48 words in an unabridged   dictionary, but the only ones commonly used are:<P><pre>ESPespeciallyEsperantoespionageespousalespressoesprit</pre>By displaying the list after each letter is selected, Sue can select the word she wants after entering only a few letters. Jon decided to implement this feature with words Sue had typed previously, ordering the list according to the number of times she had used them. With the following excerpt, the list is read from or written to a plain text file rather than a DBM file (to facilitate manual editing):<P><pre>my %times;      # key is the word               # value is number of times it had been usedsub read_words {    my ($word, $freq);    open IN, "words.txt" or die "cannot open words.txt\n";    while (&lt;IN&gt;) {        chop;        ($word, $freq) = split;        $times{uc $word} = $freq;    }    close IN;}sub by_freq {    $times{$b} &lt;=&gt; $times{$a} or    $a cmp $b;}sub write_words {    open OUT, "&gt;words.txt" or die "cannot open words.txt\n";    for my $w (sort by_freq keys %times) {        print OUT "$w\t$times{$w}\n";    }    close OUT;}</pre>The program can then search the list for words. For example, to search for words beginning with a prefix:<P><pre>my (@words);my $maxwords = 10;        # actually 11 in allfor my $i (0 .. $maxwords) {    $words[$i] = "";    $mw-&gt;Label(        -textvariable =&gt; \($words[$i]),        # ... all other attributes    )-&gt;pack;    # ... Enter and Leave callbacks as above}sub clear_words {       for my $w (@words) {               $w = "";       }}sub fill_words {    clear_words;    my $prefix = Msg-&gt;last_word;    my $n = 0;    for my $w  (sort by_freq               grep { /^$prefix/ and \                     $times{$_} &gt; 1 }               keys %times) {        $words[$n] = $w;        return if ++$n &gt; $maxwords;    }}</pre>The labels here are created with a <B>textvariable</B> attribute pointing to one of the elements in the <B>@words</B> array. The function <B>fill_words()</B> is called after each letter is added to the message window. <B>Msg-&gt;last_word</B> returns the last blank-separated word in the message window, and this word is then used as a prefix to search for subsequent matching words. Note that all the keys in the <B>%times</B> hash are considered, but only those matching the prefix are included:<P><pre>grep { /^$prefix/ and $times{$_} &gt; 1 }</pre>A further restriction is to include only words that have been used more than once, which helps eliminate typos and misspellings. The resulting list is sorted by frequency, so the words near the top will be the ones most often selected. As a word is used more frequently, it will "rise" in the list to be more readily chosen.<P>All these features combine to allow Sue to quickly input words to form sentences. Once a sentence is entered, the program is able to speak it with a text-to-speech synthesizer. The synthesizer is a freely downloadable Microsoft program, which interfaces easily with Perl.<P><B>Texts and the Dictionary</B><P> Another feature of Sue's program is the ability to read online texts   downloaded from the Gutenberg project (<B>http://www.gutenberg.org</B>). She   can browse the texts as a hierarchy, jump quickly to sections, and bookmark   pages. See <a href="../sam05060003/tpj0506-0003_f5.htm">Figure   5</a>.<P>Soon after Jon created this functionality, Sue came across this passage while reading <I>The Adventures of Tom Sawyer</I> by Mark Twain,:<P>"... he uncovered an ambuscade, in the person of his aunt;<P>... her resolution became adamantine in its firmness."<P> She turned to her daughter and asked, "Do you think Jon could get a dictionary   into this thing?" Jon accepted the challenge and devised a solution whereby   pausing over words in the text would pop up the dictionary definitions (<a href="../sam05060003/tpj0506-0003_f6.htm">Figure   6</a>). Starting with the 1913 Webster's Dictionary (also from the Gutenberg   project), and then using the <B> href="http://www.mso.anu.edu.au/~ralph/OPTED"&gt;OPTED   project</B> (which formats the text in consistent HTML, one word per line),   Jon converted the dictionary into a DBM file for quick access. An excerpt from   the dictionary looks like this:<P><pre>&lt;P&gt;&lt;B&gt;Abacus&lt;/B&gt; (&lt;I&gt;n.&lt;/I&gt;) A table or tray strewn    with sand, anciently used for drawing, calculating, etc.&lt;/P&gt;&lt;P&gt;&lt;B&gt;Abacus&lt;/B&gt; (&lt;I&gt;n.&lt;/I&gt;) A calculating table or frame;    an instrument for performing arithmetical calculations by    balls sliding on wires, or counters in grooves,    the lowest line representing units, the second line,    tens, etc. It is still employed in China.&lt;/P&gt;&lt;P&gt;&lt;B&gt;Abada&lt;/B&gt; (&lt;I&gt;n.&lt;/I&gt;) The rhinoceros.&lt;/P&gt;&lt;P&gt;&lt;B&gt;Abaddon&lt;/B&gt; (&lt;I&gt;n.&lt;/I&gt;) The destroyer, or angel of the    bottomless pit; -- the same as Apollyon and Asmodeus.&lt;/P&gt;</pre>To index the 17 MB of data with DBM files, the following snippet was used:<P><pre>use strict;my (%dict, $last, $word);unlink &lt;*_dict.*&gt;;      # tidy up any old onesfor my $let ('a' .. 'z') {    dbmopen %dict, "${let}_dict", 0777;    open IN, "wb1913_$let.html" or        die "cannot open wb1913_$let.html\n";    $last = "";    while (&lt;IN&gt;) {        next unless ($word) = m#^<B>(.*)</B>#;        next if $word eq $last;        $dict{$word} .= (tell(IN)-(length)-1) . " ";                                   # -1 because of ^M at the end                                   # of the lines        $last = $word;    }    close IN;    dbmclose %dict;}</pre>This creates a separate DBM file (<B>.pag</B> and <B>.dir</B>) for each letter of the alphabet, with the key as the word and the value as the concatenation of the seek addresses within the <B>.html</B> file containing the word's definitions. With the DBM files in place, it is easy to quickly provide a <B>define()</B> subroutine to display the definition for <B>$word</B>.<P><pre>my %dict;$word = ucfirst lc $word;my $fl = lc substr($word, 0, 1);dbmopen %dict, "dictionary/${fl}_dict", 0666    or die "cannot dmbopen ${fl}_dict: $!\n";open IN, "dictionary/wb1913_$fl.html" or    die "could not open dictionary/wb1913: $!\n";my $addrs = $dict{$word};           # the seek addressesreturn unless $addrs;insert("$word\n");                  # insert into a text widgetfor my $a (split /\s+/, $addrs) {    seek(IN, $a, 0) or die "cannot seek to $a in dict for $word $!\n";    while (defined($line = &lt;IN&gt;) and           $line =~ m%               ^&lt;P&gt;&lt;B&gt;<B>$w</B>&lt;/B&gt;\     # must match the word               \((.*)\)\     # part of speech into $1               (.*)&lt;/P&gt;$%x) {  # the definition into $2        insert("\n  $1");        my $def = $2;        my $i;        while (length($def) &gt; 50) {        # wrap lines at 50 chars            $i = rindex($def, ' ', 50);            insert("\t  " . substr($def, 0, $i) . "\n");            $def = substr($def, $i+1);        }        insert("\t  $def");    }}close IN;dbmclose %dict;</pre>With the above, it is simple to truncate suffixes and add definitions for the resultant root word:<P><pre>my $w;for my $suffix (qw(s ly ed ing es ness)) {    $w = $word;        # restore the original    define($w) if $w =~ s/$suffix$//;}</pre>The final step of the dictionary feature was to make it convenient for Sue to simply point the cursor at a word within the text and have the definition of that word appear. The tricky part was determining which word was under the cursor at any given moment. A careful perusal of the book,<I> Learning Perl/Tk</I> by Nancy Walsh gave several suggestions. Jon began by creating a <B>Define</B> Tk label, which executes the following code when activated:<P><pre>$lastw = "";$firstTime = 0;$mw-&gt;bind("&lt;Motion&gt;", \&amp;show);$readwin-&gt;configure(-cursor =&gt; "question_arrow");</pre>Binding <B>&lt;Motion&gt;</B> events in this way should be the exception since they are activated by any mouse motion, causing many invocations of <B>show()</B>. Note that above, <B>$readwin</B> is the text widget containing the words we are reading. When the program switches to this "definition mode", the cursor for <B>$readwin</B> is changed to a little question mark. This cursor is used to pass over words in order to select the word to define.<P>Next, the <B>show</B> callback:<P><pre>sub show {    my $e = $readwin-&gt;XEvent;    return unless $e;    my ($x, $y, $time) = ($e-&gt;x, $e-&gt;y, $e-&gt;t);    my $p = "\@$x,$y";    my $w = $readwin-&gt;get("$p wordstart", "$p wordend");    return unless length($w) &gt; 3;    if ($w ne $lastw) {        $lastw = $w;        $firstTime = $time;    } elsif ($time - $firstTime &gt; 1000) {        $mw-&gt;bind("&lt;Motion&gt;", undef);        $readwin-&gt;configure(-cursor =&gt; "arrow");        Dict-&gt;define($w);    }}</pre>The fancy footwork with XEvent gives us the exact (x,y) coordinate of the cursor and the time (in milliseconds) it passed over that spot. The <B>get()</B> method of the Text widget tells us what text is under a specific spot. With the <B>wordstart</B> and <B>wordend</B> modifiers, we can isolate the precise word under the cursor.<P>A few "catch" rules were used to prevent unintended words from being defined, which included ignoring all words of three characters or less and using <B>$lastw</B> and <B>$firstTime</B> to keep track of how long a word is hovered over before activating the pop-up definition.<P><B>The (Not So) Final Program</B><P>The complete program also gives Sue the ability to change display colors and browse photo albums of family and friends. Jon plans to add more features, including an X10 interface so that Sue can control her lights and television from within the program.<P>Jon's program is a good example of the flexibility of Perl. Because it's Perl-based, the program runs equally well on UNIX and Win32. Development was rapid, with the base functionality taking only a week of Jon's spare time. Updates are simple, and the program is easy to extend and maintain. Programming knowledge and creativity can go a long way, especially with tools as powerful as Perl.<P>The entire program is now available on Jon's Web site at: <B>http://www.icogitate.com/~perl/sue/</B>.<P><I>Dan Brian is a software engineer at Verio, Inc. He likes cake. <P>Jon Bjornstad is a certified Perl hacker, an amateur pianist, and tries to cultivate a quiet and open mind.</I><HR><p></p></BODY></html>