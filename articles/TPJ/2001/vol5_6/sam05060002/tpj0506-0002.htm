<html><head><title>Unidecode!</title></head><body bgcolor="ffffff"><b><p></b><h1>Uni<i>de</i>code!   <p></h1><p><b>Sean M. Burke</b><br>  <span class="date">Winter, 2001</span></p><div align="center"><table width="350" border="1" cellspacing="0" cellpadding="5">	<tr><td bgcolor="#cccc99" align="middle"><b>Modules Used</b>  </td></tr>  <tr>    <td>	Text::Unidecode	</td>  </tr></table></div><p>I'm holding out but not getting an answer.<BR>I want to do right by you.<BR>But I'm finding out that cheating gets it faster.<P>-- Jimmy Eat World, "Get It Faster"<P>Back in the days, the Latin-1 character set was the de facto standard for the Internet. It was just Latin letters plus a few accents, and that was enough for most of the Western European languages, but it left a whole lot of other languages out in the cold to try to make do with mutually incompatible encodings. Now we have Unicode, a single character set that can encode all the world's languages, whether they're written in accented Latin letters, like Icelandic or Vietnamese or Navajo, or in some quite different script, like Greek, Armenian, Chinese, Cherokee, or Hindi, to name a few.<P>In an ideal world, all computers, applications, operating systems, and protocols would have all the fonts and support for turning Unicode data into correctly formatted text on the screen. But the real world is stubbornly less than ideal, and for a very long time we will still have to deal with some systems that can't reliably show much more than US-ASCII. To cope with that fact, I wrote a Perl module called Text::Unidecode, which takes Unicode text using any writing system, and tries to convey it using just US-ASCII. This article is about how complicated that task can be, how it should have taken me years -- and how I actually managed it in just a few days.<P><B>Basics of Different Scripts</B><P>To explain why I made Text::Unidecode work the way it does, I need to describe some basic principles of world writing systems. Dealing with all the writing systems in Unicode has made me appreciate that while they are all superficially quite different, they are mostly just variations on a few basic themes.<P>Most writing systems basically work on this plan:<P><P><B>1.  Figure out the sounds in what you're trying to express.</B><P><P>This sometimes involves some arbitrary decisions -- such as what to do when a word's pronunciation can change freely (like the fact that "heat" has a "t" sound its own, but put an unstressed vowel after it as in "heat up a bagel" and it sounds like "heed"). Most writing systems, however, end up settling on these points without much bother and often without any conscious thought.<P><P><B>2.  Possibly toss out distinctions that aren't crucial.</B><P><P>Here, written English tosses out the distinction between stressed and unstressed syllables (so you can't see the difference between a cold <I>com</I>-press, and having to com-<I>press</I> data). Written Latin tossed out all distinctions between stressed and unstressed vowels, and between short and long. And Hebrew just usually tosses out its vowels altogether. And if you're Cherokee, you toss out all the information about what tones you have in a word, and also toss out some sound distinctions, like between /k/'s and /g/'s.<P><P><B>3.  Group sounds according to some consistent scheme.</B><P><P>This might mean just breaking between the words, or it might consider where the syllables stop and start, or it might mean both these things.<P><P><B>4.  Write that out.</B><P><P>This might mean going from a sound to a symbol one at a time and without appeal to context. Or it might involve some context, as with Spanish, where you have to figure in Spanish, "well, I want a /k/ sound, and I'd normally write that <I>c</I>, but it's going before an /i/ sound here, so I need to write it as <I>qu</I> instead" (as in "Quito", the city). Or it might mean figuring (as with Japanese kana and Cherokee syllabics) "this whole syllable is /ki/" and looking up the way to write that syllable, in the chart of all possible whole syllables.<P><P><B>5.  Have the computer encode it.</B><P><P>Since we're talking about computer text, we also have an additional step: when you "write out" what you mean, by moving your fingers over the keyboard, the computer eventually saves it to disk in some encoding. Surprisingly, the same character on the screen could be represented in fundamentally different ways, in different encodings.<P><P>A good example of this process, in a non-Western writing system and its encoding, is Divehi, the language spoken (and written) in the Maldives, an archipelago southwest of India. Divehi is written right-to-left, with vowels written as marks over or under the consonants. The word "divehi" itself (the Divehi word for "Divehi"!) illustrates how this works.<P><P><B>1.  Figure out the sounds of what we're writing.</B><P><P>The word we've expressed is represented phonetically as /divehi/.<P><P><B>2.  Possibly toss out distinctions that aren't crucial.</B><P><P>Divehi writing doesn't distinguish stressed syllables from unstressed syllables. But it does happen to distinguish 10 different vowels.<P><P><B>3.  Group the sounds together.</B><P><P>We note word breaks, since we'll represent those as whitespace later. But more importantly, we group the word's sounds into syllables. /divehi/ becomes three syllables, /di/ /ve/ /hi/.<P><P><B>4.  Write that out.</B><P><P> We write right-to-left, writing each consonant on the baseline, and each vowel   as a symbol above it or below it:<pre><img src="../sam05060002/tpj0506-0002_f1.gif" width="61" height="40">      e  H   V   D  i       i</pre>For example, note that the sound /e/ is represented by a mark that looks like a little "c", and which goes over the consonant that starts that syllable. This works fine for syllables that are just a consonant and a vowel, but what about consonants and vowels elsewhere? The word for "that" is just /e/, and how is it written? Divehi wisely uses a placeholder here: a letter that stands for the <I>lack</I> of a preceding consonant. <P> <pre><img src="../sam05060002/tpj0506-0002_f2.gif" width="29" height="38">  e  X</pre>(Here we represent the placeholder consonant in our ad hoc romanization as <I>X</I>.)<P>When a consonant doesn't begin a syllable (as with the /n/ in /ran/, the word for "gold"), it's given a placeholder vowel, which appropriately looks like a little zero:<P><pre><img src="../sam05060002/tpj0506-0002_f3.gif" width="49" height="34">  0   a  N   R</pre>You can even get words where every syllable has a placeholder of some sort, as in /ain/ (meaning "a school of fish"): it's broken into /a/, /i/, and an extra /n/; the first two each get a placeholder consonants, and the last bit gets a placeholder vowel:<P><pre><img src="../sam05060002/tpj0506-0002_f4.gif" width="68" height="43">  0       a  N   X   X      i</pre>5. Encoded as new characters.<P><P>Now, there are 10 vowels in the language plus the placeholder <I>0</I> for null vowel; and there are 23 consonants plus the placeholder <I>X</I> for null consonant. So in the above system, there's a maximum of 11 * 24, or 264 possible written syllables. We could make an encoding based on 264 codepoints (i.e., slots in the character set), where we encode each whole syllable at once. This way makes sense because that's how they're drawn on the screen, so when you want to draw the <I>di</I> in the word <I>divehi</I>, the <I>di</I> is encoded as just a single codepoint, and you fetch the font character for that.<P>An alternative is to save each element (as <I>d</I> is, and as <I>i</I> is) as a character on its own, in a character <I>code</I> of its own. This is useful in that it reflects how you type, a letter at a time; and if you want to change an element, you shouldn't have to re-key the whole syllable, but should be able to just hit delete and change one element.<P>It so happens that Unicode's representation of Divehi (in the character codes 0x0780 to 0x07B0) is the latter: <I>divehi</I> is represented not as a character <I>di</I>, a character <I>ve</I>, and a character <I>hi</I>; but as six characters:<P><pre>0x078B = Divehi letter "d"0x07A8 = Divehi letter "i"0x0788 = Divehi letter "v"0x07AC = Divehi letter "e"0x0780 = Divehi letter "h"0x07A8 = Divehi letter "i"</pre>Don't let the issue of writing direction here confuse you: a file consisting just of the word "divehi" would start with the byte sequence for "d" and end with the byte sequence for "i". The fact that Divehi is written "backwards" is just a matter for display on the screen; Unicode doesn't make an issue of this, and encodes things "in logical order", as it's called. (The reader is invited to consider whether all alternatives are illogical orders.)<P>So if someone emails you in Divehi saying simply "ran!" ("gold!" -- maybe it's a grizzled prospector staking claim there in the Indian Ocean), that would be encoded as five characters:<P><pre>0x0783 = Divehi letter "r"0x07A6 = Divehi letter "a"0x0782 = Divehi letter "n"0x07B0 = Divehi letter null vowel0x0021 = Exclamation mark</pre>In an ideal world, you'd get that email, and when it made its way to your mail program and to your screen, it would look like this:<P><img src="../sam05060002/tpj0506-0002_f5.gif" width="47" height="29"> <P><P> <p>But unless your mail program (and its OS) knows how to deal with Divehi -- which includes having the fonts, knowing how to compose the vowels over/under the consonants, as well as going right to left, then you're more likely to see this:<P><P><I>????</I>!<P><P>If that's all we can see, we're left wondering what on Earth is meant by email consisting of an inscrutable four-character word and an exclamation point. Or, maybe the programmer of the mail program was clever, and he has his program show undisplayable characters using their character codes:<P><P><B>[0783][07A6][0782][07B0]!</B><P><P>While this doesn't exactly lose any information, it doesn't really blaze with significance either, unless we have a Unicode character chart on hand. I do have a Unicode character chart -- but since it's the size and weight of a large <I>Encyclopedia Britannica</I> volume, it's a bit hard to imagine keeping it "on hand" wherever you go.<P>If we're using a system that can't handle all of Unicode, that maybe can't be trusted with anything but US-ASCII, it'd be nice if instead of "????!" or "[0783][07A6][0782][07B0]!", we could just see the Divehi word expressed in Latin letters, as plain old "ran!". That's what I wanted Text::Unidecode to do. And if all the world's scripts were as simple as Divehi seems so far, then writing Text::Unidecode would have been barely a few day's work. But it turns out that not even Divehi is really as simple as that.<P><B>When the Going Gets Messy, the Messy Turn Pro</B><P>Writing a program to "parse" Divehi characters and spit out Roman letters (what we in the biz call "transliteration") seems merrily simple so far. But it gets stranger.<P>Previously, I said that there are 264 possible written syllables in Divehi, 11 * 24, 11 for the 10 vowels plus the null vowel, and 24 for 23 consonants plus the null consonant. The astute reader might have realized that this includes the possibility of a syllable consisting of a null consonant and a null vowel. And, a syllable consisting entirely of a placeholder consonant for a placeholder vowel seems the sort of thing that could never actually happen. Sometimes, however, things that don't actually occur are allowed to exist in code tables so that there aren't any gaps in the lookup grid that says "this consonant plus this vowel makes this displayable pair". But the shocking truth is that the Divehi written syllable consisting of null consonant plus null vowel <I>actually does occur</I> -- in fact it has <I>two</I> meanings. This is where things get messy.<P>The first meaning of this null syllable is to express a sound that has no letter of its own: the glottal stop sound. English has this sound between the two vowels in the interjection "uh-oh!"; but in Divehi it occurs in normal words, like "bo'", which means "frog", or "hurih&acirc;kame'" which means "everything" -- although it may seem ironic that the word for everything ends in a double nothing:<P><pre><img src="../sam05060002/tpj0506-0002_f6.gif" width="118" height="38">  0 e a &acirc;   u  X M K H R H          i</pre>The second meaning of the null syllable, is to make the following consonant last longer. Long consonants ("geminates" in linguistic jargon) are pretty rare in English; the closest we come is the double-t sound in "cat tail". But they're common in many languages (Italian, Finnish), and come up plenty in Divehi, in words like "ba-ppa" ("father") or "ta-yy&acirc;-ru" ("ready"):<P><pre><img src="../sam05060002/tpj0506-0002_f7.gif" width="93" height="30">u &acirc; 0 aR Y X T</pre>Now, a program that reads the Unicode encoding of this (<I>taX0y&acirc;ru</I>) should presumably turn it into something like "ta-yy&acirc;-ru", doubling the following consonant (here, a "y"). And where the <I>X0</I> syllable occurs at word-end, it should be replaced by some good symbol for the glottal stop sound. The apostrophe will do for that, since it's not otherwise in use in Divehi script.<P>Another way to express this idea, is that <I>X0</I> and a consonant should turn into two of that consonant (<I>X0y</I> to <I>yy); other X0</I>s should turn into an apostrophe; and otherwise <I>X</I> and <I>0</I> just delete. This is a snap for regexps:<P><pre>  s/X0(\w)/$1$1/g;  s/X0/'/g;  s/(\w)/$Divehi2roman{$1}/g;</pre>...except that we can go use the real Unicode characters:<P><pre>  # \x{0787}\x{07b0} is "X0", the null syllable  # \p{InThaana} is \w for just Divehi characters  #   ("Thaana" is the official name of the Divehi script)  # See perldoc perlre for more about \p{...}    s/ \x{0787}       # the null consonant     \x{07b0}       # the null vowel    (\p{InThaana})   # and some letter   /$1$1/gx;    s/\x{0787}\x{07b0}/'/g;    s/(\p{InThaana})/$Divehi2roman{$1}/g;</pre>Then we just make sure we've filled out <B>%Divehi2roman</B> with things like:<P><pre>  ...  "\x{0786}" =&gt; "k",  # Divehi "k" =&gt; Roman "r"  "\x{0787}" =&gt; "",   # Divehi null consonant =&gt; nullstring  "\x{0788}" =&gt; "v",  # Divehi "v" =&gt; Roman "v"  "\x{0789}" =&gt; "m",  # Divehi "m" =&gt; Roman "m"  ...  "\x{07A6}" =&gt; "a",  # Divehi short a =&gt; Roman "a"  "\x{07A7}" =&gt; "A",  # Divehi long a =&gt; Roman "A"  "\x{07A8}" =&gt; "i",  # Divehi short i =&gt; Roman "i"  "\x{07A9}" =&gt; "I",  # Divehi short I =&gt; Roman "I"  ...  "\x{07b0}" =&gt; "",   # Divehi no-vowel =&gt; nullstring</pre>This constitutes a full working transliterator program, built from three regexps and one hash1, which does a fine job of turning Unicode text in Divehi into US-ASCII. The fact that the Divehi, in proper script, would have been written right to left, with vowels superimposed on the preceding consonants, doesn't show up in the Unicode representation, so our program doesn't need to deal with it.<P>As we consider doing the same for the dozens of other scripts in Unicode, we face the unpleasant news that Divehi, for all this strangeness with null syllables, is uncommonly <I>straightforward</I> as writing systems go. What took three regexps for Divehi (after a bit of research), could take a dozen for Hindi (which is partly like Divehi, but partly not). As for Thai, the transliterator would have to guess at syllable and word boundaries, since Thai doesn't normally mark them (yesitallrunstogether!). However, you need to know where they are in order to know which way to transliterate some characters.<P>And it gets worse. My Library of Congress <I>ALA-LC Romanization Tables</I> reference for Arabic goes on for pages and pages. It notes, for example, that one character (Unicode 0x0629, called "teh marbuta", which looks oddly like a "&ouml;") is to be transliterated as "h" when it's on nouns that are indefinite or preceded by a definite article, or as "t" when it is on construct state nouns, or as "tan" when it's an adverb suffix. I have not the faintest idea what the "construct state" is or how to identify it, or how to tell an indefinite noun or an adverb from any other kind of word in Arabic. I am rather sure, however, that it <I>cannot be done with a mere regular expression</I>, and that is not something I say lightly!<P>In short, it was looking as if producing a system that could take Unicode text and spit out US-ASCII romanization, was going to involve phenomenal amounts of work. Some scripts are simpler than Divehi, but many are much more complicated. The situation I was facing is exactly the sort of thing that programmers have in mind when they talk about the "eighty-twenty rule".<P><B>The Eighty-Twenty Rule</B><P>With writing systems and computer encodings of them, things are pretty straightforward most of the time, but still manage to get a bit messy some of the time, and very messy every now and then. Most of the problem can be treated with a cheap hack or two, but to deal with the rest of the problem, you have to write code that is longer and introduces whole new levels of complexity into your program. In other words, to pick some favorite arbitrary numbers, you can deal with 80% of the problem by writing only about 20% of the code (or expending 20% of the time or effort) that it would take to treat the whole problem.<P>A non-linguistic example of this is parsing addresses out of "From:" lines in email headers. This is a notoriously and pointlessly hard task to do "by the book" (where "the book" is RFC 2822). However, a quick look at my mail spool file shows that you get 57% of the addresses parsed correctly if you just look for lines matching the pattern <B>From: Their Name &lt;user@host&gt;</B>, with a fairly constrained idea of what can be in <I>user</I> or <I>host</I>. There can be no spaces, no parens, no backslashes, no quotes, no <B>\@</B>'s or anything else that actually <I>is</I> RFC2822-legal. Add quotes to that pattern, as in <B>From: "Their Name" &lt;user@host&gt;</B>, and you get another 25%. Another 11% is gained by <B>From: user@host</B>, and it's sharply diminishing returns from there. <B>From: user@host (Their Name)</B> is another few percent, and after that it's off into hard-to-parse and mercifully rare things like <B>From: Pete(A wonderful \) chap) &lt;pete(his account)@silly.test(his host)&gt;</B>.<P>So, if you can make do without total coverage, your time is probably better spent with just a simple regexp to match the most common formats. Although generally, your time is <I>best</I> spent skimming CPAN and the Perl FAQ first, to see whether someone's done all the work for you already. For problems where that method doesn't turn up anything, you must decide whether you can get away with a quick hack that does most of the work. Doing something by the book is almost always the right thing to do for keeping the code maintainable, extensible, and debuggable. But if doing the right thing means the job will take impossibly long, then it may be time to look into doing the <I>wrong</I> thing.<P>This is exactly the situation I faced when writing Text::Unidecode; I figured out that many scripts (like Cherokee, Amharic, Greek, Coptic, Cyrillic, Armenian, Georgian, Yi, and Korean hangul, to name a few) were almost no problem at all, and could be translated a character at a time by looking in a hash that said that thus-and-such Cyrillic character is to be represented by "b", thus-and-such Cherokee glyph is to be represented everywhere by "la", and so on. Some scripts, like Divehi and the dozen Indic scripts (Hindi, Bengali, Telugu, Burmese, etc.), could <I>probably</I> be tackled by a few regexps, with some recourse to advanced regexp features such as lookahead assertions. But it gets tricky -- as the Indic scripts get odder, I probably would be able to learn enough of the language to make sense of its writing system in just a few days. But it would take a serious investment of time, for each of these languages, to learn the language well enough to know whether my transliteration algorithm was doing something wrong.<P>As I considered going toward harder scripts like Thai and Chinese, and then on to really hard (but also really important) writing systems like Japanese, Hebrew, and Arabic, it looked as though each would require at least months (and probably years) of effort. I like writing open source software, and I like learning languages, but any project that would require me to become literate in Arabic, Hebrew, and all the major languages of Asia clearly needed some scaling back. If nothing else, by the time I finished this (i.e., in the distant future), Unicode would probably finally be well supported, at which point few people would need anything like Text::Unidecode.<P>One way to tackle this would be to do what I could with the more straightforward writing systems (Cyrillic, etc.), then look for existing algorithms for the harder languages (e.g., using some of the great work that's already been done toward automatic analysis of Japanese), and encourage friends and friends-of-friends to write algorithms for the languages they personally know well. (This alone would cover a good six or seven main languages of India.) But this would still leave great big gaps; I would run into a good number of languages (probably including Georgian, Syriac, Coptic, and Mongolian Old Script) where I would find no one to advise me <I>and</I> no texts in Unicode to test my transliterator against. In short, doing the right thing either alone or collaboratively would either take a long time, or still be shoddy, or both.<P>So, I decided that what was feasible was a (relatively) quick hack -- a transliteration algorithm whose view of things was inherently <I>too</I> simple to work right, but which would still work well <I>enough</I> most of the time, and which could still be done in a reasonable amount of time. That would mean that I'd have time to cover all of Unicode. People could (and will!) still produce smart transliterators for any language that they wanted done properly, but Text::Unidecode could take up the slack.<P><B>Internals of Text::Unidecode, and Surveying the Damage</B><P>I decided that Text::Unidecode should be just a wrapper around this one operation:<P><pre>  s/([^\x00-\x7f])/$Unicode2Ascii{$1}/g;</pre>This simply replaces every character above 0x007F with <B>$Unicode2Ascii{that character}</B>, without <I>any</I> regard to the context. This approach kept Text::Unidecode from being about complex rules formalized as dozens of regexps, and made it just about considering each Unicode glyph and guessing the <I>one</I> best way to transliterate it. That worked just fine for "straightforward" scripts (Greek, Cherokee, Cyrillic, etc.), but let's consider how that works for Divehi.<P>We figured out the null consonant <I>X</I> and the null vowel <I>0</I> are, by themselves, basically just placeholders, and the only reason they're needed is because in written Divehi you can't have a vowel on its own or a consonant on its own. That would make us want to say that the <B>%Unicode2Ascii</B> entry for each should just be "", an empty string. But then the special pair <I>X0</I> (meaning glottal stop, or meaning to double the next consonant) would disappear without a trace, and <I>baX0pa</I>, <I>boX0</I>, and <I>taX0y&acirc;ru</I> would come out as "bapa", "bo", and "tayAru"; whereas we'd prefer something more like "ba<B>p</B>pa", "bo<B>'</B>", and "ta<B>y</B>yAru".<P>After much consideration, I decided that the way to do this, for context-insensitive Text::Unidecode, would be to have the null vowel <I>0</I> just delete, but have the null consonant <I>X</I> be replaced with an apostrophe. To illustrate:<P><P><pre>	<b>Input in Divehi letters	Unidecode output</B>	divehi	<I>divehi</I>	ranX	<I>ran</I>	baX0pa	<I>ba'pa</I>	boX0	<I>bo'</I>	taX0y&#130;ru	<I>ta'yAru</I>	Xe	<I>'e</I>	XiXa	<I>'i'a</I></pre>My criterion here was that I tried to imagine not whether someone who knew no Divehi could make sense of a single word in this transcription, but whether someone who <I>did</I> know Divehi could make sense of <I>several sentences</I> of this. I figured that while the above system produces the completely superfluous apostrophes in "'e" and "'i'a", people will not see any clear meaning for them. They will see that if you ignore those apostrophes, the word ("e" or "ia") makes sense in context. In cases where the apostrophe is what's left of an <I>X0</I> as in "bo'" and "ba'pa", people should be able to infer its function(s) from context. And after a line or two, it will probably dawn on the Divehi reader that the apostrophe is just a stand-in for the Divehi letter for null consonant.<P>This means people may have a bit of work to do the first time they see Text::Unidecode output, but it's always work to read text in an alphabet that you're not used to reading it in. In cases where the output actually gets a bit mangled, people will have a harder time, but people are generally pretty good at figuring out what things mean from context, even if it's distorted. In any case, it's <I>always</I> better than the entire message being visible only as "???? ??? ???? ?????? ?? ???? ????" or as hex character codes.<P>Indic scripts are a good example of how something a bit more complex still generally survives the mayhem of Text::Unidecode's algorithm. Indic scripts are basically (in the encoding) like Divehi, except that vowels don't need a null consonant, and you don't bother writing the short "a" vowel. So, if you have a consonant that has no vowel (or no null-vowel!) after it, it must have an "inherent" (implicit) short /a/. So, for example, in the Mal&acirc;yalam script, the word "mal&acirc;yalam" is encoded, as <I>mly&acirc;lm0</I>. (The final <I>0</I> null vowel, really character 0x0D4D, is there to keep the final <I>m</I> from being read as "ma".) A context-sensitive algorithm could insert "a" characters as appropriate, but my Text::Unidecode one-context-fits-all approach has to have one representation for the Indic <I>m</I> codepoint, in spite of the fact that sometimes it means "m" and sometimes it means "ma".<P>I observed that most of the time, Indic script <I>m</I> means just "m", not "ma", suggesting that I should transliterate it as "m". For the cases where it really did mean "ma", people would usually be able to infer that something was missing, and then be able to imagine what it was. So, if you spoke Mal&acirc;yalam and you saw a word like "mlyaalm" in Roman script, you would know that "mly" wasn't a possible way to start a word in your language, and you'd infer that something was missing. Context, or even the barest knowledge of the normal written form of the language, would lead you to infer that it's an "a".<P>Conversely, if I had decided that Indic script <I>m</I> should be represented as "ma", <I>mly&acirc;lm0</I> would come out as "malayaaalama". That's only slightly strange, but it's very bad for syllables with different vowels. For example, the personal name Abhij&icirc;t is encoded as <I>aBij&icirc;t0</I>. If we assume every consonant has no "inherent a" (so <I>m</I> is "m", not "ma"), then that comes out "abhijiit", or "aBijiit", depending on how we decide to Romanize the "special <I>b</I>" -- as "B" or as "bh" (I settled on the latter, since it's more standard). But if we decide that every consonant <I>did</I> have an "inherent a" (so <I>m</I> is "ma" not "m"), <I>aBij&icirc;t0</I> comes out as "abhaijaiita", which is far afield of how anyone thinks of it or pronounces it. The grand lesson here is tht if y lv lttrs ot, ppl cn stll make sense of it, but ifa yaou gao araounada inasaeratainaga laetataerasa, the result is pretty confusing. This rule bodes well for Text::Unidecode output for Arabic and Hebrew, where the normal written form of the language is missing vowels.<P><B>The Special Chinese Problem</B><P>Most of what I've written so far assumes that each Unicode symbol has pretty much one or two closely related pronunciations, which we then pick from based on context. This assumption falls apart when we get to Korean, Japanese, and Chinese -- the languages that use Chinese characters (or "Han" characters, in Unicode jargon). Consider, for example, this character, Unicode 0x4E0B:<P><p><p><img src="../sam05060002/tpj0506-0002_f8.gif" width="40" height="41"> <p><p>If the text is in Korean, this character will be pronounced "ha", and should probably be transliterated as such. If it appears in Chinese text, a Mandarin speaker will pronounce it "xia", and a Cantonese speaker will pronounce it "ha". If that character is in a Japanese text, it will be pronounced as "shita", "shimo", "moto", "ka", or "ge" -- and which it is, depends on complex contextual factors.<P>In Text::Unidecode's table of what transliterates as what, there is no allowance for any kind of context, even contextual guesses about what language the text is in. I had on hand the "Unihan database" that says what the pronunciations are for most of the Chinese characters in Unicode, for all the languages that use each particular character -- but I could pick only one pronunciation per character. Somebody had to lose. These are the things I considered:<P><P><ul><li>  More people speak Chinese than Japanese.<li>  More people speak Japanese than Korean.<li>  Of people who speak Chinese, most can understand Mandarin pronunciations, as it's the national standard dialect of mainland China.<li>  The Korean and Japanese pronunciations are often derived from the Chinese pronunciations. It rarely if ever went the other way.<li>  A Japanese or Korean person is more likely to have studied Chinese (meaning modern spoken Mandarin), than a Chinese person is to have studied Japanese or Korean.<li>  If the Japanese, Korean, and Mandarin pronunciations are rather different, there is a small chance that a Japanese or Korean reader will be able to understand the Mandarin pronunciation, but nearly no chance that a Chinese person will be able to understand the Korean or Japanese pronunciations.<li>  Most importantly, if you take the Mandarin pronunciations as the standard, then context-insensitive transliteration of Chinese text works almost perfectly. Japanese needs more context sensitivity, and if you take the most common Japanese pronunciation as the standard, context-insensitive transliteration of Japanese text doesn't work very well.</ul><P>In other words, if I took Mandarin as the canonical pronunciation for Chinese/Japanese/Korean Unicode characters, it'd do pretty well for a whole lot of text for a whole lot of people. If I chose Japanese as the canonical pronunciation, it'd work less well, and would be good for fewer people. While Text::Unidecode is not necessarily a majoritarian project, I do like to please the most people while frustrating the fewest.<P>So, that's why when you enter this:<P><pre>  use Text::Unidecode;  print unidecode(    "\x{5317}\x{4EB0}"     # Those are the Chinese characters for the     # name of the capital city of mainland China.  );</pre>You get this Mandarin Romanization:<P><pre>  Bei Jing</pre>Instead of Japanese or Korean attempts at transliterations of those characters' pronunciations ("Kita Miyako" and "Pwuk Kyeng", respectively).<P><B>Future Developments</B><P>I don't think of Text::Unidecode as being the last word on the subject of transliteration -- <I>not by a long shot</I>. It's a cheap hack whose coverage of world languages is very broad but very <I>very</I> thin. It does pretty well with most alphabets, is so-so with Indic scripts, and its solution to Chinese/Japanese/Korean isn't good, but is the least bad. I hope people will write smart transliterators for the Indic scripts, Thai, Japanese, and whatever else they feel a need for; and I hope they'll put them in CPAN. But for whatever languages are left over, you can always fall back on Text::Unidecode.<P><B>References</B><P><B>perldoc perlunicode</b> [part of the standard Perl distribution]<P>Bruce D. Cain and James W. Gair. 2000. <I>Dhivehi (Maldivian)</I>. Lincom Europa (Munich).<P>Randall K. Barry (editor). 1997. <I>ALA-LC Romanization Tables: Transliteration Schemes for Non-Roman Scripts</I>. Library of Congress.<P>Jimmy Eat World. 2001. "Get It Faster", <I>Bleed American</I> [Album]. http://www.jimmyeatworld.net<P>Nara Institute of Science and Technology, Computational Linguistics Laboratory. 1997. <I>ChaSen v1.0</I> [a morphological analyzer for Japanese]. http://chasen.aist-nara.ac.jp/<P>Peter W. Resnick [editor]. 2001. <I>RFC 2822: Internet Message Format</I>. http://www.rfc-editor.org/rfc/rfc2822.txt. [Obsoletes RFC 822.]<P>Geoffrey Sampson. 1990. <I>Writing Systems: A Linguistic Introduction.</I> Stanford University Press. [A must-read -- SMB]<P>Rupert Snell. 2000. <I>Beginner's Hindi Script (Teach Yourself Books).</I> McGraw Hill NTC.<P>The Unicode Consortium. 2000. <I>The Unicode Standard 3.0.</I> Addison-Wesley.<P>The Unicode Consortium. 2001. <I>The Unihan Database v1.1.</I>, Unihan.txt in http://www.unicode.org/Public/UNIDATA/.<P>1.  Incidentally, you may have noticed that while I've been representing long a's as "&acirc;", as in "hurih&acirc;kame'", the above part of a <B>%Divehi2roman</B> would give us a capital instead, as in "hurihAkame'". Since Text::Unidecode is, apparently, for use in systems that lack full Unicode support, I decided to play it safe and assume that they don't even have Latin-1 support either -- so I use only US-ASCII characters, involving no Latin-1 characters like "&acirc;". In this case, since there's no uppercase/lowercase distinction in Divehi script, nothing on input will give us an "A", so we're free to use that character for long a's.<P><I>Sean M. Burke has a Master's in linguistics from Northwestern University.</I></p></body></html>