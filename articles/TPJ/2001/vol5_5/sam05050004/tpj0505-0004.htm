<html><head><title>Finance::Quotelets</title></head><body bgcolor="ffffff"><h1>Finance::Quotelets </h1><p><i></i><b>Paul Fenwick</b><br>  <span class="date">October 2001</span> <p>If you've read the article on Finance::Quote in <i>TPJ</i> #19,   then you may have downloaded the module and played with it. You may also have   found it useful in keeping track of stocks you're interested in. Wouldn't   it be nice if it could do also keep track of that managed fund you invested   in, or tell you how much the gold bullion you've been hoarding in that   sock is worth? Perhaps you're thinking of investing in camels, and want   to know the market price? Maybe you'd even like to know the ping time to   your favorite quake server to determine whether you should be day-trading or   fragging? Unfortunately, Finance::Quote can't do those things, or can it?<p>Finance::Quote provides a mechanism for loading custom data-source modules at run-time. These Quotelets allow you to add arbitrary data look-up methods to Finance::Quote at run-time, which means you can keep track of all these extra things using your existing Finance::Quote applications. (Thanks go to Nathan Torkington for coining the term "Quotelet". It sounds much better than "pluggable Finance::Quote module", which I was using earlier.)<p> If you're not already familiar with Finance::Quote, then you might want   to read the excellent introduction in <i>TPJ</i> #19, or alternatively hop on   over to the Finance::Quote Web site (<a href="http://finance-quote.sourceforge.net/" target="_blank">http://finance-quote.sourceforge.net/</a>)   and follow the Documentation links from there.<p><b>What is a Quotelet?</b><p>A Quotelet is a special module that can be loaded by Finance::Quote at run-time to provide access to extra data sources. Quotelets are just like other Perl modules, although they follow a few specific conventions that allow the Finance::Quote framework to load and use them.<p>If you're going to be writing your own Quotelet, you'll need to make sure you follow these requirements if you want them to work properly.<p>In no particular order, these requirements are:<p><ul><li>  The module must be in the Finance::Quote namespace, for example: Finance::Quote::MyModule. The framework relies upon this when looking for modules to load.<p><li>  The module must define a function called "methods". This registers which data sources the module provides, and the functions that provide them.<p><li>  All functions registered by the "methods" function must conform to the standards described later in the section "Getting down to business".<p><li>  The module must define a function called "labels". This returns information about which labels are returned. These labels are used to determine whether your Quotelet can supply specific information requested by the user.</ul><p>Quotelets can do more than is required of them, including providing extra functions that are not used by Finance::Quote. This makes it possible to write modules that can also be used in different environments, or even as standalone libraries.<p><b>Requirements in Detail<p>The Package Name</b><p>All Quotelets must exist in the Finance::Quote namespace. Therefore, a module that fetches information from "Perl Securities" might be called "Finance::Quote::PerlSec".<p>The package name doesn't need to be at the top of the Finance::Quote namespace. For example, "Finance::Quote::Asia::HongKong" is a perfectly acceptable package name.<p>When you're developing your package, you may wish to place it in the "Finance::Quote::Quotelet::" namespace, which is guaranteed not to be used by the official Finance::Quote distribution. This makes it possible to upgrade your version of Finance::Quote without having to worry about namespace clashes.<p><b>Explaining the Methods</b><p>All Finance::Quote modules need to define a methods subroutine, which registers which methods your module provides, and how to access them. The methods subroutine takes no arguments, and returns a list of market and subroutine-ref pairs. Typically, your subroutine would look something like this:<pre>  package Finance::Quote::Quotelet::MyModule; sub methods { return (myfunds =&gt; \&amp;funds, myloans =&gt; \&amp;loans); }</pre><p>When your module is loaded, Finance::Quote calls this function and remembers   the result. In this case, it knows that "myfunds" can be accessed by calling   the <code>funds()</code> subroutine, and "myloans" can be accessed by calling   the <code>loans</code> subroutine.<p>Depending upon the market you're dealing with, there may be a standard name that you should use for your function. These standard market names are used by the failover mechanism, so an alternative method can be used if the preferred method fails.<p>Current standard market names include:<p><b>Method-Name	Source</b><p>australia	Australian Stocks<p>canada	Canadian Stocks<p>dwsfunds	Deutsche Bank Gruppe<p>europe	European Stocks<p>fidelity	Fidelity Investments<p>nasdaq	NASDAQ<p>nyse	New York Stock Exchange<p>tiaacref	TIAA-CREF<p>troweprice	T. Rowe. Price<p>usa	USA Stocks<p>uk_unit_trusts	UK Unit Trusts<p>vwd	Vereinigte Wirtschaftsdienste GmbH<p> If your market or source does not exist in the list above, then you can always   post a message to <b>finance-quote-devel@lists.sourceforge.net</b> and ask whether   a standard name has been assigned.<p>Method names must be all lower case, consist of alphanumeric characters (including underscore) and begin with a letter. Although this is not enforced, future versions of Finance::Quote may rely upon it.<p>Sometimes it would be nice to access specific look up functions directly, bypassing any failover mechanisms, rather than just specifying the market from which you want to obtain information. To this end, it is strongly recommended that you provide a unique name in addition to any standard names for accessing your functions.<p><pre># "australia" is the standard name for# looking up stocks in Australia.  However# people can also access our function directly# by using the unique name of "skippy".sub methods { return (skippy =&gt; \&amp;funds,             australia=&gt; \&amp;funds); }</pre><b>Describing the Information Returned</b> <p>One of the features that Finance::Quote provides is the ability for a programmer to require certain information which they want returned, without having to worry about which specific modules are called to obtain that. To facilitate this, each Quotelet needs to register which labels it will attempt to provide. A list of common labels is provided in the sidebar.<p>The syntax for this is simple. Each Quotelet needs to have a function that returns a list of (method, listref of labels) pairs, like this:<p><pre>sub labels {    return (myfunds =&gt; [date,yield,price,currency],            myloans =&gt; [date,price,currency]);}</pre><p>Often, you'll find that you're returning the same list of labels. A useful shortcut for this is:<p><pre>sub labels {    my @labels = qw/date yield price name currency/;    return (myfunds =&gt; \@labels, myloans =&gt;\@labels);}</pre><p>The list of labels should be those that your Quotelet can be reasonably sure of obtaining from a successful lookup, as this is a way of your module promising that it will return that information if it's available and meaningful to do so. It's okay if your Quotelet doesn't return a label if it doesn't make sense for a given stock (e.g., some quotes don't return dividends), but you should not list a label here that you will never return.<p>There are a few conventions that are good to conform to here. All Quotelets should return a label called "price", which is traditionally the most interesting value for a given symbol. For shares, it's usually the last traded price; for funds, it's usually the yield; for indexes, it's the index value; and for loans, it's the interest rate. By having a "price" label, stock-tickers and other software can track worth without worrying about the nature of the underlying symbol.<p>It's also polite to return a "method" label, indicating which method returned the information. This is useful if different sites place different licenses on their information, and the calling program wants to know what it can and cannot do. It's also useful in failover situations where many different modules may have attempted to retrieve information, and you want to know which one succeeded. The value of the "method" label should be the same as the unique method-name that set it.<p><b>Changing Currencies</b><p>The Finance::Quote framework can arrange for automatic conversion between currencies. To do this, it needs to know the currency returned by your Quotelet.<p>If your Quotelet is returning information that is in a specific currency, it should ensure that it sets the "currency" label to a ISO 3-letter currency code. For example, if you were dealing with Australian dollars you'd use "AUD". If the given symbol does not have a currency (for example, an index such as the Dow Jones), then this label should remain blank.<p>Finance::Quote uses a default list of labels that are usually returned in a currency format. This works under most circumstances. However, you can explicitly set which labels have contents that should undergo currency conversion. You do this by defining a "currency_fields" sub-routine. This should return a list of labels that have a currency associated with them:<p><pre>sub currency_fields {       return qw/price nav high low bid/;}</pre><p>Typically, you'll want to make use of the default list, but maybe add one or two of your own. The currency_fields function is always passed a valid Finance::Quote object as its first argument, and the defaults list can be accessed by calling the default_currency_fields() method. As such, your currency_fields might look like this:<p><pre>sub currency_fields {        my $q = shift;      return ($q-&gt;default_currency_fields,             qw/commission interest/);}</pre><p>It's perfectly acceptable to return label names from currency_fields that your Quotelet will never return -- in this case they just won't be used. Likewise, it's okay to return a label twice, so you don't have to worry about some of your labels overlapping with those in the default list.<p>The currency conversion in Finance::Quote is pretty intelligent. It can handle not only straight integer and floating point numbers, but also fields like "53.5 - 98.4", or "5.3M". One thing to remember is that Finance::Quote has trouble using a decimal point other than a period and doesn't handle numbers with thousand separators such as "2,345".<p><b>Getting Down to Business</b><p>The functions referenced by the <code>methods()</code> subroutine are usually   the ones that will do all the hard work, and these will be called by Finance::Quote   when the information that your Quotelet can provide is needed. The following   discussion applies to each function referenced by the <code>methods()</code>   subroutine.<p>The first argument to your function will be a Finance::Quote object. This will be followed by a list of zero or more symbol names. This means most of your functions will probably start like this:<p><pre>sub myloans {     my ($quoter, @symbols) = @_;     # Remainder of function...}</pre><p>The Finance::Quote object that your function is passed provides a number of   useful methods that you may find useful. By far the most used method is <code>user_agent</code>,   which returns a preconfigured LWP::UserAgent that's set up with the user's proxy,   timeout, and other settings. For this reason, if you need to make a Web, FTP,   gopher, or other request that an LWP::UserAgent object can handle, you should   make use of the one supplied by the Finance::Quote object:<pre>  sub myloans { my ($quoter, @symbols) = @_; my $ua = $quoter-&gt;user_agent;  # Fetch symbols from somewhere...  my $response = $ua-&gt;request(GET $someurl); }</pre><p> Changing the settings on the user-agent will also change them for the rest of Finance::Quote, so don't do that. In most cases, there should not be a reason for you to change any settings.<p> The Finance::Quote object also provides a <code>parse_csv</code> function,   which takes a string of comma-separated values and returns them as a list, and   <code>scale_field()</code>, which takes a string and a number by which to scale,   and multiplies the two in an intelligent fashion. This is the same function   that gets used when we're doing currency conversion, so it does the sensible   thing with fields like "103.5 - 105.1".<p>Your function should return a "two-dimensional hash", of the style you would normally expect to get from Finance::Quote. For example:<p><pre>$hash{$symbol,"last"} = $last_price;$hash{$symbol,"name"} = $stock_name;</pre><p>It is mandatory for you to set the "success" label to a true value if your lookup for that symbol succeeded, or a false value if it failed. It is also polite to set the "errormsg" label if a particular symbol look-up failed.<p>Finally, you need to check whether Finance::Quote wants to have returned a hash or a hash-reference. This is almost always done like this:<p> <pre> return wantarray() ? %hash : \%hash;</pre><p><b>Putting It Together </b>--<b> An Example</b><p>Let's look at a simple example. The code below shows the essential parts of a Finance::Quote module:<p><pre>#!/usr/bin/perl -w use strict;  package Finance::Quote::Quotelet::Example; use HTTP::Request::Common;  # The "methods" function registers two modes, "australia" and # "my_example". Both of these call the function &amp;myfunc.  sub methods {return (australia =&gt; \&amp;myfunc, my_example =&gt; \&amp;myfunc)}  # These are the labels my Quotelet guarantees to return.  my @labels = qw/name last volume price method/;  sub labels { return (australia =&gt; \@labels, my_example =&gt; \@labels); } # Here's the function that does all the hard work.  sub myfunc { my $quoter = shift; # F::Q object. my @stocks = @_; my %info; # Stock info goes in this hash.  my $EXAMPLE_URL = "http://www.example.oz.au/info.csv?";  # Fetch my information. In this case, our pretend # source wants the symbols appended to the end # of the URL.  my $ua = $quoter-&gt;user_agent; my $response = $ua-&gt;request(GET $EXAMPLE_URL.join("+",@stocks));  # If there's an error, return an appropriate hash # with all failures. unless ($response-&gt;is_success) { foreach my $stock (@stocks) { $info{$stock,"success"} = 0; $info{$stock,"errormsg"} = "HTTP failure"; } return wantarray() ? %info : \%info; }  # Parse our CSV file that's been returned, and load # into the hash. We'll split lines up on CRLF or # just LF. The first element is the stock symbol.  foreach my $line (split('\015?\012',$response-&gt;content)) { my @data = $quoter-&gt;parse_csv($line); my $stock = $data[0];  # Set the success flag. If this is unset then # data may not be returned. $info{$stock,"success"} = 1;  $info{$stock,"name"} = $data[1]; $info{$stock,"last"} = $data[2]; $info{$stock,"volume"} = $data[3];  # Our "price" is the same as the last # price for the stock. $info{$stock,"price"} = $info{$stock,"last"};  # Method is always our own unique name. $info{$stock,"method"} = "my_example"; }  # All done. Return the array with data loaded in it.  return wantarray ? %info : \%info; }  __END__</pre><p><b>Putting It Together </b>--<b> A Real-Life Example<p>Using HTML::TableExtract</b><p>A lot of information appears on Web sites, and many Web sites use tables to present that information. While it is possible to extract this data using some clever regular expressions or HTML parsing, a module already exists which does most of the hard work for you. Matt Sisk's HTML::TableExtract lets you specify the headings in a table that you're looking for, and it will do the rest.<p>HTML::TableExtract is described in more detail in TPJ #19, and is available from your local CPAN store.<p><b>BT Funds</b><p>Some friends of mine have investments with "BT Australia". BT provides   information on their unit prices on their Web site at: http://btfunds.com.au/<p>The actual page containing the information is accessible via the rather lengthy URL:  http://online.btfunds.com.au/btonline/default.asp?request=MFUnitPriceHistory&amp;FundType=RETAIL<p> The page uses tables to present the information, so we'll make use of HTML::TableExtract.   See Listing 1 for the Quotelet code.<p>For this Quotelet, the symbols we will pass are the full name of the funds we're interested in, so when we fetch data from "btfunds" it will probably look like this:<pre>  my $q = Finance::Quote-&gt;new(qw/-defaults Quotelet::BTAust/); my %funds = $q-&gt;fetch("btfunds","BT Cash Management Trust", "BT Future Goals");</pre><p> Using Your New Quotelet<p>To use your new Quotelet in code, simply pass its name (without the "Finance::Quote prefix) to the new method of Finance::Quote, like this:<p><pre>my $quoter = Finance::Quote-&gt;new("Quotelet::BTAust");</pre><p>This arranges for Finance::Quote to load and register your module. In most   cases, you probably want to load the default modules as well. This is done by   passing "<code>-defaults</code>" as the first argument to new:<p> <pre>my $quoter = Finance::Quote-&gt;new("-defaults","Quotelet::BTAust");</pre><p>If you have an existing Finance::Quote application that does not allow you to pass in extra modules at startup, then it's also possible to set the "FQ_LOAD_QUOTELET" to a space-separated list of modules to load. If the application creates a new Finance::Quote object without passing any arguments, this environment variable will be used. This feature exists in Finance::Quote version 1.05 and later.<p> <pre>export FQ_LOAD_QUOTELET="-defaults Quotelet::BTAust";</pre><p><b> Other Uses of Quotelets</b><p>While the Finance::Quote framework was written to obtain information about financial information in a robust manner, there is no reason why it cannot be used to obtain other sorts of information as well. For example, you might define a Quotelet which interprets its symbols as hostnames and returns ping-times. Alternatively, you may have a Quotelet that uses the symbols as geographical locations and returns weather information. While this is a little odd, it means that you could display both your portfolio, beach conditions, and the ping-time to your favorite Quake server all using the same ticker.<p><b>Conclusion</b><p>Now that I've explained the requirements to write your own Quotelets, I hope you feel filled with the knowledge required to add arbitrary data sources to your favorite Finance::Quote tickers and programs.<p>If you need help in developing your Quotelet, or just want to hang around other Finance::Quote developers, there is a link from the Finance::Quote Web page to support forums, mailing lists, bug-tracking systems, and other useful things. Most of these can be found at:<a href="http://sourceforge.net/projects/finance-quote/" target="_blank"> http://sourceforge.net/projects/finance-quote/</a><p>If you do write your own module and think that others may find it useful, then I urge you to consider submitting it for inclusion in the Finance::Quote standard distribution. Send mail to: <b>finance-quote-devel@lists.sourceforge.net</b> if you have a Quotelet you'd like to make available.<p>Until then, you can enjoy knowing the value of that gold in your sock, the temperature outside, the price of camels, and most importantly, whether it's a good day for frags.<p> <i>Paul Fenwick is a senior consultant with the Obsidian Consulting group.   He has interests in cycling, homebrew, edible plants, and permaculture. He's   also available for hire, and with the Australian dollar as it is, he's even   quite affordable. He can be contacted at: </i><a href="mailto:pjf@obsidian.com">pjf@obsidian.com</a><i>.</i></body></html>