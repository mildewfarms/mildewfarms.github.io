<html><head><title>Constants in Perl</title></head><body bgcolor="ffffff"><p><h1>Constants in Perl</h1><p><i><b>Sean M. Burke</b><br>  </i> <span class="date">October 2001</span></p><div align="center"><table width="350" border="1" cellspacing="0" cellpadding="5">	<tr><td bgcolor="#cccc99" align="middle"><b>Modules Used</b>  </td></tr>  <tr>    <td>	constant in Perl 5.004 and later<br>	B::Deparse in Perl 5.00502 and later	</td>  </tr></table></div><p><i>Wherein our protagonist explains how constants will clarify your source   code, and also make your programs run ever so quickly.</i> </p><p><i> </i><b>Ex Libr&icirc;s Pascalat&ocirc;rium</b><p>In a used bookstore not too long ago, I happened on a book from 1979, about   coding practices. It had the verbosely Victorian-sounding title of <i>PASCAL   with Style: Programming Proverbs: Principles of Good Programming with Numerous   Examples to Improve Programming Style and Proficiency</i>. I bought it and read   it, and saw that it had common sense advice like this (translated into Perl   terms):<p> <ul>  <li> Use clear spelled-out symbol names -- "$hours" or "count_lines()" instead     of "$h" or "ctls()".    <p>   <li> Use named constants -- i.e., instead of "$cycles * 29.53", say "$cycles     * <b>LUNATION_DAYS</b>".    <p>   <li> Don't make your code convoluted in order to get microscopic (and possibly     non-existent) gains in efficiency. The microsecond that you think you'll save     isn't worth the hour that I know it'll take me to make sense of your contorted     code.</ul><p> Each bit of advice was explained it detail, and there was lots of example   code in Pascal. But after finishing the book, I said to myself "well, this is   all just obvious!", and I put the book away and expected to never think of it   again.<p> But weeks later, I was having to debug a program that was misbehaving strangely   (with no guess as to how or why), and as I read thought the source code, I came   upon this line:<p> <p> $diff = abs($stamp - $stamp_mirror) / 86400;<p> <p> Now, I can hazard a guess about what this does: $stamp and $stamp_mirror are   timestamps from two different files, and abs(x-y) is how we get the always positive   difference between their timestamps. And, in the way of such things, those timestamps   are in days, not seconds, so we use the conversion factor of 86,400, which is   the normal number of seconds in a day. <i>Or is it?</i> If the program were   behaving correctly, I wouldn't give that line a second thought, but since <i>something</i>   is wrong and I don't know what, my well-practiced code-auditing paranoia kicks   in, and I blaze through this line of thought:<p> I can neither mentally calculate nor remember offhand what the right figure   is for seconds in a day, so I'm free to obsess: if 86,400 <i>weren't actually</i>   the right number, I'd never know it just by looking at it! Maybe the programmer   typed this from memory, but got a digit wrong. Maybe the real figure is 86,500,   and the above code is bad. Or maybe 86,400 is the number of seconds in a twenty-<i>three</i>   hour day (such as occurs once a year, if/when we go onto Daylight Savings Time).   But somehow that's the right thing to do in this case, because if we assumed   all days were 24 hours long, then something we do later with <b>$diff</b> would   cause some dazzling catastrophe on the DST change day.<p> Or maybe 86,400 isn't even supposed to be the number of seconds in a day,   but instead is some other conversion factor of obscure significance:<p> <ul>  <li> Four pi times the number of sidereal days in a sunspot cycle?    <p>   <li> The number of inches in a nautical mile?    <p>   <li> The kilocalories in a gross of Abba-Zabas?</ul><p> By this time I'm just dizzy with anxiety, Abba-Zabas, and astronomy, so I   just have to go and figure out what that number is:<p> <pre> % perl -e "print 60*60*24"  86400</pre>So yes, 86,400 <i>is</i> the number of seconds in a normal day. <p> And that means that my little fugue state was apparently all for nothing:   the line in question does exactly what I thought it did (but worried that it   didn't!), and so it <i>isn't</i> interesting. The whole episode has distracted   me from the task of finding why the larger program is misbehaving -- and it   so exhausted me that I can't bear to read the next line of code (something about   <code>($&lt; % 3 and exec 'cat')||dump</code>, whatever <i>that</i> does!).   And as I blearily give up bug-swatting for the day, I suddenly remember the   22-year-old Pascal book that I'd read, and I wish that the person who wrote   "86400" had instead followed the Pascallers' advice to use a named constant! <p> <b>Constant Symbols in Perl</b><p>The first attempt at improving that code could be in replacing the conversion   factor 86,400 with some sort of named entity:<p> <pre>$diff = abs($stamp - $stamp_mirror) / <b>$seconds_per_day</b>;</pre>By having given the conversion factor a name, specifically the symbol "$seconds_per_day", then at least I know what it's supposed to actually denote. Of course, somewhere higher up in the program code, there will have to be a line defining that variable:<p> <pre>my $seconds_per_day = 86400;</pre><p> This, however, only feeds The Fear, because the next time I read the source,   I have to repeat the whole episode with making sure that 60 * 60 * 24 <i>is</i>   86,400 and <i>not</i> 84,600 or 85,400 or other likely suspects. Moreover, maybe   somewhere else in the code we accidentally <i>alter</i> the value of $seconds_in_day!   Maybe somewhere the programmer means to evaluate $seconds_per_day * 7 but accidentally   types "$seconds_per_day *= 7", which does in fact give you seven times $seconds_per_day,   but also then stores that larger number back into $seconds_per_day! That's the   problem with wanting a constant symbol but using a <i>vari</i>able -- it could   <i>vary</i>, which is the last thing we'd want a constant to do. But if we want   a named constant, we can get it, using the relatively underappreciated <b>constant</b>   pragma: <pre> use constant SECONDS_PER_DAY =&gt; 86400;</pre><p> This tells the "constant" module to make you a constant in the current package,   calling the constant "SECONDS_PER_DAY". (It's conventional for constant names   to be in all uppercase.) Once you've defined that constant, you can use the   symbol "SECONDS_PER_DAY" (with no leading "$") to mean the value 86400, as in: <pre>  $diff = abs($stamp - $stamp_mirror) / SECONDS_PER_DAY;</pre><p> The best part about this, is that if we try altering the value of the constant,   as in:<p> <pre>  $foo = (SECONDS_PER_DAY <b>*=</b> 7);</pre><p> then Perl refuses to even compile this. (The error message you get depends   on the version of Perl you're using; under the version I have on hand, I get   the somewhat cryptic message "Can't modify non-lvalue subroutine call in multiplication   (*)".) Also, if you've got "use strict" at the top of your program (which you   really really should), then if you try using that constant but get the name   wrong, Perl catches that:<p> <pre>  use strict;  use constant SECONDS<b>_PER_DAY</b> =&gt; 86400;  ...  $foo = SECONDS<b>_IN_A_DAY</b> * 7;</pre>That dies in compilation, with the error "Bareword 'SECONDS_IN_A_DAY' not allowed while 'strict subs' in use...".<p> <p> However, I'm back again to worrying whether the number of seconds in a day   <i>really</i> is 86,400. So I'd prefer that the constant be declared this way: <pre> use constant SECONDS_PER_DAY =&gt; 60 * 60 * 24;</pre><p> The work of figuring out 60 * 60 * 24 is done just once, when we call constant.pm   to get it to put that value into a new constant symbol called "SECONDS_PER_DAY".<p> <b>Deparsing</b><p>It makes you wonder -- what is Perl actually doing when I use a constant symbol   like "SECONDS_PER_DAY" here, as in this line:<p> <pre>$diff = abs($stamp - $stamp_mirror) / SECONDS_PER_DAY;</pre><p> Is it doing the same thing as if I had a $seconds_per_day -- i.e., does it   have to look up a symbol's value every time it evaluates that line?<p> It used to be that to find out anything about Perl internals, one would have   to read the Perl source, which is no small task. But one can now glean a lot   of information about how Perl parses programs by using the B::Deparse module,   which takes the in-memory compiled form of your program, and re-expresses it   as Perl source. The compiled form is what actually gets run by the Perl interpreter,   not your source code.<p> Suppose we have a simple program, sec1.pl, that prints how many days have   passed since the epoch:<p> <pre>% cat sec1.pluse constant SECONDS_IN_DAY =&gt; 60 * 60 * 24;print "There have been ", int(time() / SECONDS<b>_IN_DAY</b>), " days since the epoch.\n"; % perl sec1.plThere have been 11458 days since the epoch.<b>% perl -MO=Deparse sec1.pl</b>sub SECONDS_IN_DAY () {    package constant;    $scalar;}print 'There have been ', <b>int time / 86400</b>, " days since the epoch.\n";sec1.pl syntax OK</pre>The "sub SECONDS_IN_DAY" thing is a bit of a distraction here, but the interesting and important part is that we had "int(time() / SECONDS_IN_DAY)" in source, but B::Deparse tells us that Perl took this to mean something which it reiterates as "int time / 86400". In other words, where we had a constant symbol, Perl substituted <i>the value itself</i>, before it even ran the program.<p> <b>Constants, Literal Constants, and Constant Symbols</b><p>So far I've been using the term "constant" in its most common sense, meaning   a "constant symbol" (AKA a "named constant"), i.e., a symbol that refers to   a slot in memory that can't change. But to keep things straight from here on   out, we need to distinguish constant symbols from literal constants. <p> You already know what a literal is, although you might not know that word   for it. Literals are the 24 in <code>$x = 24</code><b>;</b>, or the "stuff"   in <code>print "stuff"</code>. When Perl parses those statements, it needs to   put the value 24 or "stuff" someplace in memory so that if/when it has to run   those commands, it will have someplace from which to copy a value into $x, or   someplace from which to send a value to <code>print</code>. So Perl simply allocates   a piece of memory for each of those, and it marks each value as a constant,   just to keep programmers from changing them -- even if they try using roundabout   syntax: <p> <pre>my $x = \"foo";  # reference to a constant$$x .= "bar";</pre>That dies with "Modification of a read-only value attempted", because all literal constants are read-only values. (Again, they wouldn't be very good constants if you could go changing them!) A constant symbol is just a symbol (currently implemented as a parameterless subroutine) declared by "use constant <i>symbolname</i> =&gt; <i>value</i>". And as we saw with B::Deparse, whenever Perl sees a constant symbol actually used, it compiles it <i>as if</i> you had used a literal constant instead, so that these turn into exactly the same thing in memory:<p> <pre>use constant SECONDS_IN_DAY =&gt; 60 * 60 * 24;print "File $f is ", <b>SECONDS_IN_DAY</b> * -M $f, "s old!\n"; # -M returns the age in days.print "File $f is ", <b>86400</b> * -M $f, "s old!\n";</pre><b>Constant Folding</b><p>Now, some would say that we should all avoid having <i>any</i> numeric constant   literals in programs, since when one sees:<p> <pre>  $size = $h * $w * 4;</pre><p> one always has to wonder: why <i>four</i>? Whereas if one says:<p> <pre>  use constant BYTES_PER_PIXEL =&gt; 4;  $byte_size = $pixels_high * $pixels_wide            * BYTES_PER_PIXEL;</pre><p> then things are rather clearer.<p> However, that policy does bloat the code a bit, and if that's the only place   you use a 4 with that meaning, then I figure a comment will do just fine, to   explain the literal constant's meaning:<p> <pre> $byte_size = $pixels_high * $pixels_wide           * 4; # it takes four bytes to store a pixel</pre>And similarly, instead of:<p> <pre>  use constant SECONDS_IN_DAY =&gt; 60 * 60 * 24;  print "File $f is ", SECONDS_IN_DAY * -M $f, "s old!\n";</pre>I am usually happy writing just this:<p> <pre>  print "File $f is ",  <b>60 * 60 * 24  # seconds in a day</b>   * -M $f, "s old!\n";</pre><p> especially if I'm unlikely to be using the seconds-per-day conversion factor   anywhere else in the program. As to the "60 * 60 * 24" bit, I used to presume   that Perl had to figure out <code>60 * 60 * 24</code> every time it evaluated   that line. In the scheme of things, that would be no big deal, since having   to evaluate <code>-M $f</code> (age of the file $f, in days) is going to take   much longer than a bit of simple math. But I once happened to have a line like   that in a program which I run through B::Deparse for some other reason. And   much to my surprise, I saw this: <p> <pre>  % cat bim_skalabim.pl  ...stuff...  print "File $f is ",  <b>60 * 60 * 24</b>  # seconds in a day   * -M $f, "s old!\n";  ...stuff...  % perl -MO=Deparse bim_skalabim.pl  ...stuff...  print "File $f is ", <b>86400</b> * -M($f), "s old!\n";  ...stuff...</pre>I had "60 * 60 * 24 * -M $f", and through some magic, Perl <i>compiled</i> that as 86400.<p> I tried experimenting a bit to see how this all worked:<p> <pre>  % perl -MO=Deparse -e "print 2 * 3 * 5 * 7 * $x"  print 210 * $x;  % perl -MO=Deparse -e "print 2 * 3 + 5 * 7 * $x"  print 6 + 35 * $x;  % perl -MO=Deparse -e "print $x / 2 ** 9"  print $x / 512;</pre>So whatever magic is happening, we see that it applies to all the simple arithmetic operators...<p> <pre>  % perl -MO=Deparse -e "print $x / 2 ** (9 + sin(3))"  print $x / 564.613575929232;  % perl -MO=Deparse -e "print 4 * atan2(1,1)"  print(3.14159265358979);</pre>...and apparently also applies to the more complicated cases of "**" (exponentiation) and the trig operators. And it applies even to some string operations:<p> <pre>  % perl -MO=Deparse -e "print 'foo'.'bar'"  print 'foobar';  % perl -MO=Deparse -e "print 'foo'.'bar' . $x"  print 'foobar' . $x;  % perl -MO=Deparse -e "print sprintf('%d is %s',12,lc('TWELVE')). $x"  print '12 is twelve' . $x;</pre>But of course, not all operations <i>can</i> be dealt with this way:<p> <pre>  % perl -MO=Deparse -e "print rand(123)"  print rand 123;</pre>That is, even though the input to the <code>rand</code> operator is constant, that doesn't mean you can figure out its value once and for all -- while addition and <code>sin</code> and string concatenation are the kind of operations that give constant output for constant input, <code>rand</code> isn't like that. <p> It turns out that this "magic" optimization that I'd stumbled on, is not some   occult phenomenon at work, but something well-known to people who go making   compilers:<p> "If the value of all operands of an operation are known at compile-time, and   cannot change at execution-time, then the operation can be performed by the   compiler and the result insterted in place of the code to perform the operation   in the object code. Such operations are known as <i>compile-time arithmetic</i>,   a very common optimization strategy. This particular strategy is called <i>constant   folding</i>."<p> -- Pyster's <i>Compiler Design and Construction</i>, p 163<p> In other words, when you have an operation that you know gives constant output   when given constant input, <i>and</i> you observe that all its inputs are constants,   then you can figure out its value right there and pretend that you had simply   been given that value directly. So when Perl sees source that says (2 * 3 +   5 * 7) * $x, it will parse it into an operations tree that looks like this:<p> <pre>      *     / \    +   $x   / \  *   * /\   /\2  3 5  7</pre>It's simple, then, for Perl to look at the tree, see that there's a "constantable" operation "*" that takes two constant values as input, 2 and 3 -- and that means we can figure out 2 * 3 right there and <i>fold</i> that part of the tree up into just one node:<p> <pre>    *   / \  +   $x / \<b>6</b>   *    /\   5  7</pre>And then we can do the same thing for the "*" node with the constantable operation "*" with its constant operands 5 and 7, folding that treelet up into a singe node of constant value 35. And then, moving up the tree, we see that that leaves us with a "+" operation with two constant operands 6 and 35. That can be folded into 41:<p> <pre>  * / \41 $x</pre>And that leaves us with a constant-foldable operation "*". But we can't fold any more, because not all the operands are constants; $x is a variable. So we're left with 41 * $x in the code tree -- and that's exactly what Deparse shows us:<p> <pre>  % perl -MO=Deparse -e "print( (2 * 3 + 5 * 7) * $x )"  print 41 * $x;</pre><b>When We Can Fold, But Don't</b> A bit more experimentation shows that constant folding doesn't currently apply in every case where it could apply: <pre>  % perl -MO=Deparse -e "print 2 * 3 * $x * 5 * 7"  print 6 * $x * 5 * 7;</pre>Now, <i>I</i> know that 2 * 3 * $x * 5 * 7 is the same as $x * (2 * 3 * 5 * 7), so why doesn't Perl fold that into $x * 210? The -p switch to B::Deparse is handy here: it just makes it so that when Perl dumps the op tree as Perl source, it'll provide parens almost everywhere it can (whereas without the -p, we'll get parens only where necessary). So consider:<p> <pre>  % perl -MO=Deparse,-p -e "print $w * $x * $y * $z"  print(((($w * $x) * $y) * $z));</pre>Or, drawn as a tree...<p> <pre>      *     / \    *   $z   / \  *   $y / \$w  $x</pre>So 2 * 3 * $x * 5 * 7 must originally parse as this:<p> <pre>        *       / \      *   7     / \    *   5   / \  *   $x / \2   3</pre>Now, remember how we applied our simple constant folding: just take a constant-foldable operation (like "*"), all of whose operands are constant values, and fold that, and then keep doing that until you can't do it anymore. Starting out, we see the lowest "*", with operands 2 and 3, is foldable, so we do that:<p> <pre>      *     / \    *   7   / \  *   5 / \ 6  $x</pre>However, once that's done, there are no other foldable operations in the tree -- even though all the operations in the tree are constant-foldable operations (all instances of "*"), none of them have constants as both operands, so our constant-folding stops. And the tree as drawn above, is exactly what Deparse tells us it's left with:<p> <pre>  % perl -MO=Deparse,-p -e "print 2 * 3 * $x * 5 * 7"  print((((6 * $x) * 5) * 7));</pre>Now, we could try teaching Perl to use a knowledge of algebra to rearrange the expression to try to group constants together. This, however, is a relatively expensive opertation to have the compiler try, and in real workaday code, it rarely pays off. In short, if you want to be as sure as possible that your constants fold, group them together as much as possible, and maybe even put parens around them, to try to force them to be evaluated as a single group (and hence a separate, all-constant-foldable sub-branch in the tree). And when in doubt, deparse it!<p> <pre>  % perl -MO=Deparse -e "print $x * (2 * 3 * 5 * 7)"  print $x * 210;</pre>Incidentally, not all operations are like "*" in that $w <i>op</i> $x <i>op</i> $y <i>op</i> $z parses as ((($w <i>op</i> $x) <i>op</i> $y) <i>op</i> $z), i.e., producing a <i>left</i>-leaning tree. Yes, "*" is that way, and so it's called "left-associative", but there are right-associative operators, i.e., where $w <i>op</i> $x <i>op</i> $y <i>op</i> $z parses as ($w <i>op</i> ($x <i>op</i> ($y <i>op</i> $z))), forming a right-leaning tree. Exponentiation, "**" is an example:<p> <pre>  % perl -MO=Deparse,-p -e "print $w ** $x ** $y ** $z"  print(($w ** ($x ** ($y ** $z))));</pre>And the "=" (assignment) operator is an example, too:<p> <pre>  % perl -MO=Deparse,-p -e "$w = $x = $y = $z"  ($w = ($x = ($y = $z)));</pre>That is, copy $z's value into $y, $x, and $w.<p> My favorite right-associative operator (and one that constant-folds, in an   interesting new way) is the much under-appreciated "condition ? x : y" operator,   which means: evaluate <i>condition</i>, and if it's true, then evaluate and   return <i>x</i>, otherwise evaluate and return <i>y</i>. It's useful in situations   like:<p> <pre> print "Hey ", @name_bits ? diminutive($name_bits[0]) : 'you'; # If we have name bits on hand, use the diminutive #  of first one, otherwise just use "you".</pre>The trick is that you can nest x?y:z operators, and they'll do what you expect:<p> <pre>  % cat cond_test.pl  print     $condition1 ? $value1   : $condition2 ? $value2   : $condition3 ? $value3   : $otherwise_value  ;  % perl -MO=Deparse,-p cond_test.pl  print(($condition1 ? $value1 : ($condition2 ? $value2 :  ($condition3 ? $value3 : $otherwise_value))));</pre>In other words, that above block means that if $condition1 is true (which you can replace with any expression), then use the value of $value1 (likewise, any scalar expression); otherwise fall through to seeing whether $condition2 will let you use $value2; or whether $condition3 will let you use $value3; or otherwise you give up and use $otherwise_value.1<p> Now, since we could constant-fold <i>x</i> * <i>y</i> * <i>z</i>, what do   we do with <i>x</i> ? <i>y</i> : <i>z</i>, you might ask? After all, they're   both just operators. Deparse shows us:<p> <pre> % perl -MO=Deparse -e "print 0 ? $x : $y" print $y; % perl -MO=Deparse -e "print 1 ? $x : $y" print $x; % perl -MO=Deparse -e "print 'raspberries' ? $x : $y" print $x;</pre>In other words, Perl sees that since the condition is a constant, we know which of the consequents we'll end up evaluating every time -- if the constant-condition is true (like 1 or -57 or 'raspberries'), we want the first consequent, otherwise we want the second. So we can just replace it all with the expression for the condition we want, and <i>throw out the code</i> for the condition that we know will never evaluate.<p> Now, remember that since constant symbols are a kind of constant, everything   I've said about constant folding with literal constants applies to constant   symbols too:<p> <pre> % cat named_constants.pl use constant BUNCH =&gt; 3; print "That's a bunch of arguments!\n" if @ARGV &gt;= BUNCH; print "One more than a bunch is ", BUNCH + 1, "\n"; print "A bunch is ",   (BUNCH &lt;2) ? 'less' : 'not less', " than a pair\n"; % perl -MO=Deparse named_constants.pl sub BUNCH () {    package constant;    $scalar; } print "That's a bunch of arguments!\n" if @ARGV &gt;= <b>3</b>; print 'One more than a bunch is ', <b>4</b>, "\n"; print 'A bunch is ', <b>'not less'</b>, " than a pair\n";</pre>Note that the <b>BUNCH + 1</b> was constant-folded to 4, and the <b>(BUNCH &lt;2) ? 'less' : 'not less'</b> was constant-folded to 'not less'.<p> <b>Folding All Conditionals</b><p>We saw that the "x?y:z" conditional operator was constant-foldable -- but Perl   has two other kinds of basic conditional structures:<p> <ul>  <li> The short-circuit operators: "x &amp;&amp; y" and "x || y" (or their variants     "x and y" and "x or y", which are different only in that "and" and "or" have     lower precedence). These form expressions, so you can use them in the middle     of any statement.    <p>   <li> The structures: "if(cond) { block... }", "statement if cond", and the derivative     forms with "unless" and "else" and "elsif". These form statements, so can't     be in the middle of an expression. (I.e., you can't say "$x = if($cond) {     block } else { block }", although you can always wrap any statements in a     do { ... } to get an expression.)    <p> </ul>Since constant-folding applies to the "x?y:z" structure, does it also apply to the other two kinds of conditionals? Let's see:<p> <pre> % cat fold_if.pl <b>if(0)</b> {   print "Mmmm Abba-Zaba\n";  } else {  sleep 5;  print STDERR "I started at $^T\n"; }<b>1 &amp;&amp;</b> print time-$^T, "s elapsed\n"; % perl -MO=Deparse fold_if.pl sleep 5; print STDERR "I started at $^T\n";; print time - $^T, "s elapsed\n";</pre>So that means that you can sort of nullify any code by putting "if(0) { ... }" around it -- it <i>is</i> still parsed (so it had better be good code), but it gets discarded once Perl sees that it's something it'd never execute.<p> But this is really most effective when you combine it with named constants:<p> <pre> % cat fold_if2.pl use constant <b>DEBUG</b> =&gt; 2;   # our "debug level" <b>DEBUG</b> and print STDERR "Start: ", scalar(localtime), "\n"; print STDERR "Arguments: @ARGV\n" if <b>DEBUG</b> &gt; 1; print "...Pretend real work gets done here...\n"; sleep 3; <b>DEBUG</b> and print time-$^T, "s elapsed\n";<p> % perl -MO=Deparse fold_if2.pl sub DEBUG () { package constant; $scalar; } print STDERR 'Start: ', scalar localtime, "\n"; print STDERR "Arguments: @ARGV\n"; print "...Pretend real work gets done here...\n"; sleep 3; print time - $^T, "s elapsed\n";</pre><p> If we change the first line of the program to "use constant DEBUG =&gt; <b>1</b>;",   and then deparse it:<p> <pre> % perl -MO=Deparse fold_if2.pl sub DEBUG () { package constant; $scalar; } print STDERR 'Start: ', scalar localtime, "\n";<p> <b>'???';</b> print "...Pretend real work gets done here...\n"; sleep 3; print time - $^T, "s elapsed\n"; fold_if2.pl syntax OK</pre>The '???' thing looks strange here, but perldoc B::Deparse explains it as just "a sign that perl optimized away a constant value". It shows up a whole lot more when we change the first line of the program to "use constant DEBUG =&gt; <b>0</b>;", and then deparse it all:<p> <pre> % perl -MO=Deparse fold_if2.pl sub DEBUG () { package constant; $scalar; } '???'; '???'; print "...Pretend real work gets done here...\n"; sleep 3; '???';</pre>Effectively, it's as if your input program had consisted of just:<p> <pre> print "...Pretend real work gets done here...\n"; sleep 3;</pre>because those are the only statements that are actually executed at run-time.<p> <b>Optimizing with use constant DEBUG =&gt; 0</b><p>Although it's straightforward how (and when) it's clearer to define a SECONDS_PER_DAY   and use that instead of a bare 86400, it's less obvious why we should discard   this:<p> <pre> my $Debug = 0; print STDERR "Arguments: @ARGV\n" if $Debug &gt; 1;</pre>...in favor of this:<p> <pre> use constant DEBUG =&gt; 0;  print STDERR "Arguments: @ARGV\n" if DEBUG &gt; 1;</pre>An anecdote will explain the difference: Some time ago, I was debugging an early version of HTML::TreeBuilder (a module that's discussed in <i>TPJ</i> #19, and in my forthcoming book from O'Reilly). For HTML::TreeBuilder to correctly parse a piece of HTML source, a lot of different methods in several different classes have to cooperate. When it works, it works great; but when it doesn't, it's no easy task figuring out which method in which class went wrong.<p> In desperation, I went through just about every line in HTML::TreeBuilder,   and added a line just before it, explaining what it was about to do (or after   it, explaining what it'd just done), like this:<p> <pre> $Debug &gt; 1 and print $indent, $node-&gt;tag, "'s parent is a ",   $node-&gt;parent-&gt;tag, " -- about to check whether that's legal.\n";</pre>or like this rather more convoluted case:<p> <pre>  if($Debug &gt; 2) {  # Say who called the current routine:   require Data::Dumper;   local $Data::Dumper::Indent = 0;   local $Data::Dumper::Useqq  = 1;   printf "Called from %s line %s, with args %s",    (caller)[1,2], Data::Dumper::Dumper(\@_);  }</pre>Now, evaluating a single "$Debug &gt; 1", is nothing next to the overhead of actually performing the print statement -- when $Debug actually is greater than 1. But for the vast majority of times that people are running HTML::TreeBuilder on an HTML document, $Debug is 0, and stays 0, so all the evaluation and reevaluation of the "$Debug &gt; 1" lines and "$Debug &gt; 2" lines is wasted overhead. On the off chance that it might speed up the module (and HTML::TreeBuilder really needed speeding up), I tried changing the initial "my $Debug = 0" to "use constant DEBUG =&gt; 0", and then search-and-replaced "$Debug" to "DEBUG". That meant that for most users most of the time, all the dozens of "$Debug and print..." lines and "if($Debug){...}" blocks might as well not be there.<p> I then benchmarked the before and after versions of the module, and found   that the simple change from $Debug to DEBUG made HTML::TreeBuilder work about   ten percent faster -- a much appreciated speed payoff for just the few minutes   it took me the change and run some benchmarks. <p> That's an extreme case, since the average program or module isn't typically   so thick with "$Debug &gt; 1 and print..." lines as HTML::TreeBuilder was. But   since learning that the "<i>CONSTANT</i> &gt; <i>level</i> and print..." statements   and the "<code>if(CONSTANT &gt; level) {... }</code>" blocks get optimized way   before the program is even run, I've felt freer to use more such statements,   and that's made my programs both clearer, and easier to debug. They're clearer   because the content of the print lines has some of the same explanatory value   as comments. And the programs are easier to debug, because if one of them misbehaves,   I can simply change its "use constant DEBUG =&gt; 0" line to have a 2 or a 3,   and I then follow along through the resulting output, to see where unexpected   things start happening. <p> <b>Constants Based on Expressions</b><p>Now, most constants in typical programs do come from literals and all-literal   math expressions, like so:<p> <pre> use constant DEBUG =&gt; 2; use constant INDENT =&gt; "\t\t"; use constant SECONDS_IN_DAY =&gt; 60 * 60 * 24;</pre>However, you can easily take your values from some other sources, including Perl magic variables:<p> <pre> use constant DEBUG =&gt; $ENV{'DODAD_DEBUG'}; use constant IS_WIN =&gt; ($^O =~ m/Win32/); use constant HAS_CONFIG =&gt; (-e ".dodadrc");</pre>This, however, won't work:<p> <pre> my $x = 'stuff'; use constant THING =&gt; $x;</pre>... because Perl while Perl will have <i>compiled</i> the "my $x = 'stuff';" line before it parses and compiles the "use constant THING =&gt; $x;" line, it won't have <i>executed</i> the "my $x = 'stuff';" line. (And if or when it does execute it, it'll be too late.) The short story here is that defining a constant based on a variable is itself a fishy concept, and is best avoided -- except for the variables, like %ENV or $^O, which Perl pre-defines.<p> That even applies to @ARGV -- and you can make constants out of command-line   switches using my Getopt::constant module, available in CPAN. With that module,   the sort of optimizations that we saw applying to the "if(DEBUG)..." lines,   can be made to apply based on any number and combination of constants from the   command line switches, as with:<p> <pre> use Getopt::constant (  # Declare the @ARGV switches we accept, and their defaults:     'octal'   =&gt;  0,  # This is set to 1 if user says -octal      'margin'  =&gt; 78,  # Overridable with -margin=65      ':prefix' =&gt; 'C_',       # So the value of the "margin" and "octal" switch-options        #  shows up as constants called "C_margin" and "C_octal".      );   ...   $item = sprintf(C_octal ? '%03o' : '%02x', $value);   ...    $output =~ s/\s+// if C_octal and C_margin &lt; 70;   ...</pre>You can even generate constants of your own without the constant.pm library at all, based on any value -- say, a value read from a configuration file, or even pulled off a Web page. This, however, usually requires tinkering with BEGIN { ... } blocks, and/or symbol-table manipulation -- and each of those topics, to say the least, merits an article of its own.<p> <b>References</b><p>Ledgard, Henry F., John F. Hueras, and Paul A. Nagin. 1979. <i>PASCAL with   Style: Programming Proverbs: Principles of Good Programming with Numerous Examples   to Improve Programming Style and Proficiency.</i> Hayden Book Company, Rochelle   Park, New Jersey.<p> Pyster, Arthur B. 1980. <i>Compiler Design and Construction.</i> Van Nostrand   Reinhold, NY NY. <p> Abba-Zabas are made by the Annabelle Candy Company. <a href="http://www.annabelle-candy.com/abbazaba.htm" target="_blank">http://www.annabelle-candy.com/abbazaba.htm</a> <p> The modern-day equivalent of the good advice in PASCAL with Style can be found   in such sources as these:<p> <p> <b>per lstyle.pod</b> (Documentation in the standard Perl distribution.) <p> Scott, Peter and Ed Wright. 2001. <i>Perl Debugged.</i> Addison-Wesley, Boston. <p> Hunt, Andrew and David Thomas. 1999. <i>Pragmatic Programmer.</i> Addison-Wesley,   Boston. <p> 1 Yes, it's just like Lisp's <code>(cond (condition1 value1)(condition2 value2)   ... (t otherwise_value)) construct</code>. <p> <i>Sean M. Burke is an obsessive origamist. That explains his constant folding.</i> </body></html>