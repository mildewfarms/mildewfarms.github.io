<html><head><title>Jun03: Fuzzy Logic in Perl</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; The Perl Journal--><h1>Fuzzy Logic in Perl</h1><p><i>The Perl Journal</i> June 2003</p><h3>By Ala Qumsieh</h3><I>Ala works at NVidia Corp. as a physical ASIC designer. He can be reached at aqumsieh@cpan.org.</I><hr><p>Everyone has heard about how Fuzzy Logic (FL) is being used in many real-life applications such as traffic signal controls, automobile transmission control, cancer diagnosis, dam gate control for hydroelectric power plants, and elevator control. This article will show you how this is done, and will describe a new Perl module, <i>AI::FuzzyInference</i>, that allows you to write Perl programs that use Fuzzy Logic to make rational decisions.</p><p>In order to understand how the module works, it is helpful to know some of the theory behind Fuzzy Logic. What follows is a brief introduction to Fuzzy Logic and Fuzzy Inference Systems. A more detailed introduction can be found in an excellent tutorial by Jerry Mendel (http://sipi.usc.edu/~mendel/publications/ FLS_Engr_Tutorial_Errata.pdf). Please note that multiple terminologies exist to describe the same thing. What I will use might differ from that in the aforementioned tutorial.</p><h3>Fuzzy Logic</h3><p>Fuzzy Logic is an extension of regular two-valued logic that was developed by Lotfi Zadeh (L.A. Zadeh, "Fuzzy sets," <i>Information and Control</i>, vol. 8, pp. 338-353, 1965). In regular set theory, an element <i>x</i> either belongs to a set <i>S</i>, or it does not belong. For example, the element <i>apple</i> belongs to the set <i>Fruits</i>, but does not belong to the set <i>Vegetables</i>. We say that the element <i>apple</i> is a "member" of the set <i>Fruits</i>.</p><p>Problems start to arise when membership is not as easily determined. Consider, for example, the set of <i>Round Objects</i>. Is our apple a member of this set? Well, it depends on how round the apple is. In everyday life, we say "The apple is almost round." In order to take account of adverbs such as almost, sort of, and approximately, Zadeh extended regular set theory to allow for partial degrees of membership (DOM). This way, we can postulate that the degree of membership of our apple in the set of <i>Round Objects</i> is 0.8, while a pear's degree of membership is only 0.4, and that of a banana is 0.</p><p>Many people confuse fuzzy logic and probability. Although they look similar, they are completely different. As an example, consider two bottles filled with unknown liquids. The contents of bottle <i>A</i> have a probability of 0.9 of being a member of the set <i>Toxic Liquids</i>. The contents of bottle <i>B</i> have a fuzzy degree of membership of 0.9 in that same set. If I had to drink from one, I would choose bottle <i>A</i> because one time out of ten, the contents will not be toxic. Bottle <i>B</i> will always kill me because its contents are highly toxic (nine parts poison and one part water, say). Probability gives you the likelihood of the liquid being toxic. Fuzzy logic tells you how toxic it is.</p><h3>Term Sets</h3><p>It is very useful to be able to graphically depict what all this means. To do that, let's take another example. Let's try to categorize people based on their height. We can do so by defining three sets: <i>Short</i>, <i>Average,</i> and <i>Tall</i>. In FL, these three sets are called <i>Term Sets</i> of the variable <i>Height</i>, which is referred to as a "Linguistic Variable." Linguistic variables are variables that do not have defined numerical values, but are described by words or sentences. A 6' man is of average height, and a 6' woman is rather tall.</p><p>Let's define <i>Average</i> height as 6'. So, a 6' person has <i>DOM<sub>average</i></sub> of 1. We can expect that for people progressively shorter than that, their DOM will be progressively smaller. Similarly for taller people. If we plot a graph of height versus DOM, it might look like <A NAME="rf1"><A HREF="0306af1.htm">Figure 1</A>. This triangular shape of term sets is typical of Fuzzy Logic, and is mainly chosen for convenience. Other representations are possible, such as a bell-curve or Gaussian, but then computation becomes much more difficult. Corresponding term sets for <i>Short </i>and <i>Tall </i>can be similarly determined. Furthermore, term sets can overlap. A 6'3" person has DOM of 0.3 in the <i>Average</i> set, and a DOM of 0.6 in the <i>Tall </i>set.</p><p>An important thing to note here is that degrees of membership are highly dependent on the problem being investigated. For an average person, a 6'5" person is tall, but for the set of <i>Basketball Players</i>, such a person is of average height. Thus, in different contexts, the same term sets might have different shapes (thinner or fatter), and can shift and overlap by different degrees.</p><h3>Set Theoretic Operations</h3><p>In regular set theory, sets can be combined and manipulated using the logical operations of <i>union</i>, <i>intersection</i>, and <i>complement</i>. The same operations are extended to handle fuzzy sets in the following manner:</p><p><b>Union</b>: The union <i>C</i> of two sets <i>A</i> and <i>B</i> is the maximum of the two sets. This means that for every element <i>x</i>, <i>DOM<sub>C</sub>(x)= max(DOM<sub>A</sub>(x), DOM<sub>B</sub>(x))</i>.</p><p><b>Intersection</b>: The intersection <i>C</i> of two sets <i>A</i> and <i>B</i> is the minimum of the two sets. This means that for every element <i>x</i>, <i>DOM<sub>C</i></sub><sub>(x)=min(DOM</sub>A<sub>(x), DOM</sub>B<sub>(x))</sub>.</p><p><b>Complement:</b> The complement <i>C</i> of a set <i>A</i> is defined as <i>1-A</i>. So, for every element <i>x</i>, <i>DOM<sub>C</sub>(x)=1-DOM<sub>A</sub>(x)</i>.</p><p></p><p>Note that in the case of two-valued logic, those definitions collapse to their binary counterparts: OR, AND, and NOT, respectively. Another important thing to note here is that those are not the only definitions for the fuzzy set theoretic operations. We are free to choose any definition as long as it reduces to the binary form in the case of two-valued logic. As a matter of fact, Zadeh's original definitions were:</p><p><b>Union:</b> <i>DOM<sub>A</sub>(x)+DOM<sub>B</sub>(x)-DOM<sub>A</sub>(x)DOM<sub>B</sub>(x)</i></p><p><b>Intersection:</b> <i>DOM<sub>A</sub>(x)DOM<sub>B</sub>(x)</i></p><p><b>Complement:</b> <i>1-DOM<sub>A</sub>(x)</i></p><p>Other interpretations also exist.</p><h3>Fuzzy Inference</h3><p>Now we have just enough background to describe a Fuzzy Inference System (FIS). An FIS is a system that has a number of input variables and a number of output variables. Those variables are described by a number of term sets, and are related to each other via fuzzy rules. For example, a system with input variables <i>QualityOfFood</i> and <i>QualityOfService</i>, and output variable <i>AmountOfTip</i> might have the following rule:</p><blockquote><p>If QualityOfFood is good AND QualityOfService is bad THEN AmountOfTip is small</p></blockquote><p>The IF part is called the "precedent" while the THEN part is called the "consequent." Other rules can be defined for the remaining scenarios. For each variable (both input and output), term sets must be defined that span the whole universe of discourse of the variable, which is the range of possible values that the variable can take.</p><p>Now, given numerical values for its input variables, an FIS will use the fuzzy rules to compute a crisp numerical value for each of the output variables. This operation can be broken into four distinct steps.</p><h3>Fuzzification</h3><p>In this step, the values of the input variables are used to compute their degrees of membership into each term set. This is simply done by drawing a vertical line on the graph of each term set at the input variable's value, and noting where it intersects the graph. For example, if <i>QualifyOfFood==0.6</i>, then we calculate:</p><p>DOM<sub>qof_bad</sub>(0.6) = 0</p><p>DOM<sub>qof_good</sub>(0.6) = 0.9</p><p>DOM<sub>qof_excellent</sub>(0.6) = 0.2</p><p>and if <i>QualityOfService == 0.3</i>, then we calculate:</p><p>DOM<sub>qos_bad</sub>(0.3) = 0.7</p><p>DOM<sub>qos_good</sub>(0.3) = 0.2</p><p>DOM<sub>qos_excellent</sub>(0.3) = 0</p><h3>Inference</h3><p>Now, we examine all the defined rules, and for each rule, we compute a degree of support, which indicates the firing strength of that rule. This is done by looking at the precedent of the rule, and using fuzzy logic operations to combine the values of all its constituent parts to produce a single number. So, for the rule:</p><blockquote><p>If QualityOfFood is good AND QualityOfService is bad THEN AmountOfTip is small</p></blockquote><p>Degree of support will be <i>0.9 </i>AND<i> 0.7=min(0.9, 0.7)=0.7</i>. This value is then used to implicate the term set <i>small</i> of the variable <i>AmountOfT</i>ip. Implication modifies the shape of the term set. There are various methods, but the two most popular ones are scaling and clipping. In scaling, the whole term set is multiplied by the degree of support (0.7, in this case) to yield another term set. In clipping, the term set is clipped at the degree of support value to yield a trapezoidal term set.</p><h3>Aggregation</h3><p>In this step, all the implicated fuzzy term sets of the output variable are combined using fuzzy logic operations to yield one fuzzy set. For our <i>SizeOfTip</i> variable, this means that its three implicated term sets (corresponding to the original <i>Big</i>, <i>Average</i>, and <i>Small</i> term sets) will be combined to create one big set. A simple way to do that would be to take the maximum of the three sets at each point (see <A NAME="rf2"><A HREF="0306af2.htm">Figure 2</A>).</p><h3>Defuzzification</h3><p>Finally, the aggregated term set of the last step is used to compute a single crisp value for our output variable. The most widely used method is to take the centroid of the term set as its crisp value. Other methods are possible including taking the maximum value, or the average of the peaks.</p><p>We can see here that if a rule is not satisfied very well, then its degree of support will be close to 0. This, then, will implicate its term set by a large amount, reducing the contribution of this rule to the aggregated fuzzy set. This will, in turn, reduce its effect on the computed values of the output variables.</p><p>Systems with multiple output variables can be treated as multiple systems, each with a single output variable.</p><h3>Getting and Installing the Module</h3><p>You can grab a copy of <i>AI::FuzzyInference</i> from your local CPAN mirror at http://search.cpan.org/author/aqumsieh. The latest version, as of this writing, is 0.03. You can install it using the traditional method:</p><PRE>perl Makefile.PLmakemake testmake install</PRE><p>If you're on Windows, you can simply type "ppm install AI::FuzzyInference" at a command prompt. Alternatively, since it's all in pure Perl, you can unpack it in any place where <i>perl</i> will find it.</p><h3>An Example: Balancing Act</h3><p>Armed with our knowledge of FL and FIS's, we can now proceed to use <i>AI::FuzzyInference</i> in an example. Let's assume we have a solid horizontal 10-meter-long rod hinged exactly in its middle, with a ball placed on top of it. Furthermore, let's simplify things by assuming our world is two-dimensional, so we won't worry about the <i>z</i>-axis. We would like to be able to control our rod so as to balance the ball on it, and prevent it from falling off.</p><p>First, we have to create our <i>AI::FuzzyInference</i> object. That's easy since the constructor takes no arguments:</p><PRE>use AI::FuzzyInferencemy $fis = new AI::FuzzyInference;</PRE><p>Now, we have to define our input and output variables. We need variables to capture the states of the ball and the rod. For the ball, we define two variables: <i>$velBall</i> and <i>$posBall</i>. <i>$velBall</i> specifies the current velocity of the ball, where negative values indicate motion to the left. <i>$posBall</i> indicates the current position of the ball on the rod with 0 being the center of the rod and positive values to the right. Those will be our input variables. For the rod, we define a variable <i>$thRod</i> that is the angle the rod currently makes with the <i>x</i>-axis, where positive values indicate clockwise displacement. This is our output variable. This means that the angle that the rod makes with the horizontal is a function of the velocity and position of the ball.</p><p>To complete our variable definitions, we have to define the term sets associated with them. Those will be as defined in <A NAME="rf3"><A HREF="0306af3.htm">Figure 3</A>. The way you pass this information to the <i>AI::FuzzyInference</i> object is as follows:</p><PRE>$fis-&gt;inVar(posBall   =&gt; -5, 5,        far_left  =&gt; [-4, 1, -2, 0],        left      =&gt; [-4, 0, -2, 1, 0, 0],        center    =&gt; [-2, 0, 0, 1, 2, 0],        right     =&gt; [0, 0, 2, 1, 4, 0],        far_right =&gt; [2, 0, 4, 1],       );</PRE><p>The first argument of the <i>inVar()</i> method is the name of the input variable. The next two arguments define the limits of the values the variable can take (aka, the universe of discourse). The rest of the arguments are key-value pairs that define each term set along with its coordinates. Those coordinates are simply lists of <i>x</i>, <i>y</i> values. Successive points are connected together by a straight line. If the given coordinates of a term set do not span the whole universe of discourse, then <i>AI::FuzzyInference</i> will automatically extrapolate, by extending the first and last points horizontally, to complete the definition.</p><p>Similarly, we define our other input variable, $<i>velBall</i>. Our output variable, $<i>thRod</i>, is defined using the <i>outVar()</i> method, which has the exact same arguments as <i>inVar()</i>.</p><p>The next step is to define the rules. Here, we use our common sense to decide what to do in each scenario in order to keep the ball on the rod. One rule can be:</p><p>If   $posBall is far_left	AND   # ball is close to left edge of rod</p><p>     $velBall is slow	AND   # ball almost stationary</p><p>THEN $thRod   is medium_pos          # lower the right edge by small 				      # amount</p><p>In general, if all input variables have the same number of term sets, the number of possible rules is <i>TS<sup>VARS</i></sup> where <i>TS</i> is the number of term sets for each variable, and <i>VARS</i> is the number of input variables. We use the method <i>addRule()</i> to define our rules. So, for the rule declared above, we write:</p><PRE>$fis-&gt;addRule(              'position = far_left  &amp;               velocity = slow' =&gt; 'thRod = medium_pos',             );</PRE><p>The arguments of <i>addRule()</i> are key-value pairs. We can define multiple rules in the same call to <i>addRule()</i>, or in multiple calls. The key of each pair is the precedent string, and the value is the consequent string. Spaces are completely optional and will be ignored. Each precedent and consequent string is composed of <i>variable = term_set</i>. Multiple precedents are combined using <i>&amp;</i> and | for <i>AND</i> and <i>OR,</i> respectively. The equality can be reversed by using the<i> !</i> symbol, such as <i>position = !far_left</i>.</p><p>We round off our program with a subroutine, <i>calcNewData()</i>, which calculates the position and velocity of the ball after one time step has elapsed. And that is it&#151;we are now ready to relinquish control of the rod to our FIS. In each time step, we calculate the current position and velocity of the ball, and we pass them on to our FIS, which will spit out a new value for the angle of the rod. We do this by using the <i>compute()</i> method, which takes as input key value-pairs where the keys are the input variable names, and the values are the corresponding numerical values:</p><PRE>$fis-&gt;compute(posBall =&gt; 0.9,  #current ball position                velBall =&gt; -1.5, #current ball speed               );</PRE><p>This is the procedure that does all the work going through the <i>Fuzzification -&gt; Inference -&gt; Aggregation -&gt; Defuzzification</i> loop. After that, the <i>value()</i> method is used to get the newly computed value for the output variable <i>thRod</i>:</p><PRE>$thRod = $fis-&gt;value('thRod');</PRE><p>Then we loop back to the next time step. To better visualize this, the Perl program uses Tk to draw the rod with the ball balanced on top of it at each time step.</p><p>Running the program from random initial conditions, we can observe the behavior shown in <A NAME="rf4"><A HREF="0306af4.htm">Figure 4</A>. The <i>x</i>-axis is time, and the <i>y</i>-axis is the position of the ball on the rod. As we would expect, the ball oscillates from one side to the other as our system struggles to control it. As the system gains more control of the ball, the oscillations die down.</p><h3>Concluding Remarks</h3><p><b>Rules.</b> You do not have to define rules for ALL possible combinations of input variables. Any rule you do not define will not produce any change in the system when its associated scenario is encountered. Having said that, it is useful to specify as many rules as possible, since this will constrain your system more. In our case, we specify all the rules (see <A NAME="rl1"><A HREF="#l1">Listing 1</A>; also available for download at http://www.tpj.com/source/), which enhances our chances of controlling the ball. Removing some rules might cause more oscillation before the ball stops, or even prevent the system from controlling the ball altogether.</p><p>Moreover, choosing the correct response for every combination of input variables might not be a very easy thing to do in itself. One problem is that those rules are not set in stone. So, what constitutes common sense to one person might be considered ridiculous to another. Another problem is the sheer number of rules needed as the number of variables increases. This easily becomes the case if we have four or five input variables or more. Therefore, most people design their FISs with the smallest number of input variables possible to keep things under control. Of course, this hasn't deterred other researchers from using various techniques and heuristics to tackle such problems. Some interesting approaches use evolutionary and biologically inspired techniques such as neural networks and genetic algorithms to make the system "evolve" and "learn" its own rules. But this is a topic for another article.</p><p><b>Variables.</b> In this example, I chose a relatively simple system where the output is a function of only two variables. Some systems are even simpler and contain just a single input variable. Indeed, in our case, we could find rules that define the angle of the rod in terms of the ball's position only. Conversely, some systems are much more complicated. Initially, I designed the system to have three input variables: <i>ball position</i>, <i>ball speed</i>, and <i>rod angle</i>. The output variable was the change in the angle of the rod. I opted for the simpler version (yet not too simple) to avoid unnecessary complications. I would be interested in hearing from anyone who uses <i>AI::FuzzyInference</i> to design a system with more than two variables.</p><h3>The <i>AI::FuzzyInference</i> Module</h3><p>Finally, keep in mind that the module does not have too many checks integrated yet. So, if in your rules you use term sets or variables that are not defined (due to a typo for example), then the module will not warn you, and you might get "use of uninitialized value" warnings. Please check your code before you send in those bug reports :) Comments and suggestions regarding the module are greatly appreciated.</p><H4><A NAME="l1">Listing 1</H4><pre>#!perl -wuse strict;use Tk;use Tk::LabEntry;use AI::FuzzyInference;use constant PI =&gt; 3.1415927;use constant G  =&gt; 9.81;my $halfLenRod   = 5;my $timeStep     = 0.05;my $thRod;    # between -30 and 30 degrees.my $velBall;  # ball's velocity. From -15 .. 15 m/smy $posBall;  # ball's position. From -5 .. 5 mmy $time = 0;# initialize.$thRod   = -10;$velBall = -2;$posBall = 4;# create the FIS.my $fis = new AI::FuzzyInference;# define the input variables.$fis-&gt;inVar(posBall  =&gt; -5, 5,        far_left  =&gt; [-4, 1, -2, 0],        left      =&gt; [-4, 0, -2, 1, 0, 0],        center    =&gt; [-2, 0, 0, 1, 2, 0],        right     =&gt; [0, 0, 2, 1, 4, 0],        far_right =&gt; [2, 0, 4, 1],       );$fis-&gt;inVar(velBall   =&gt; -15, 15,        fast_neg   =&gt; [-9, 1, -3, 0],        medium_neg =&gt; [-9, 0, -3, 1, 0, 0],        slow       =&gt; [-3, 0, 0, 1, 3, 0],        medium_pos =&gt; [0, 0, 3, 1, 9, 0],        fast_pos   =&gt; [3, 0, 9, 1],       );# define the output variable.$fis-&gt;outVar(thRod      =&gt; -30, 30,         large_neg  =&gt; [-20, 1, -10, 0],         medium_neg =&gt; [-20, 0, -10, 1, 0, 0],         small      =&gt; [-10, 0, 0, 1, 10, 0],         medium_pos =&gt; [0, 0, 10, 1, 20, 0],         large_pos  =&gt; [10, 0, 20, 1],       );# now define the rules.$fis-&gt;addRule(          'posBall=far_left  &amp; velBall=fast_neg'   =&gt; 'thRod=large_pos',          'posBall=far_left  &amp; velBall=medium_neg' =&gt; 'thRod=large_pos',          'posBall=far_left  &amp; velBall=slow'       =&gt; 'thRod=medium_pos',          'posBall=far_left  &amp; velBall=medium_pos' =&gt; 'thRod=medium_pos',          'posBall=far_left  &amp; velBall=fast_pos'   =&gt; 'thRod=medium_pos',          'posBall=left      &amp; velBall=fast_neg'   =&gt; 'thRod=large_pos',          'posBall=left      &amp; velBall=medium_neg' =&gt; 'thRod=medium_pos',          'posBall=left      &amp; velBall=slow'       =&gt; 'thRod=medium_pos',          'posBall=left      &amp; velBall=medium_pos' =&gt; 'thRod=medium_pos',          'posBall=left      &amp; velBall=fast_pos'   =&gt; 'thRod=medium_pos',          'posBall=center    &amp; velBall=fast_neg'   =&gt; 'thRod=large_pos',          'posBall=center    &amp; velBall=medium_neg' =&gt; 'thRod=medium_pos',          'posBall=center    &amp; velBall=slow'       =&gt; 'thRod=small',          'posBall=center    &amp; velBall=medium_pos' =&gt; 'thRod=medium_neg',          'posBall=center    &amp; velBall=fast_pos'   =&gt; 'thRod=large_neg',          'posBall=right     &amp; velBall=fast_neg'   =&gt; 'thRod=medium_neg',          'posBall=right     &amp; velBall=medium_neg' =&gt; 'thRod=medium_neg',          'posBall=right     &amp; velBall=slow'       =&gt; 'thRod=medium_neg',          'posBall=right     &amp; velBall=medium_pos' =&gt; 'thRod=medium_neg',          'posBall=right     &amp; velBall=fast_pos'   =&gt; 'thRod=large_neg',          'posBall=far_right &amp; velBall=fast_neg'   =&gt; 'thRod=medium_pos',          'posBall=far_right &amp; velBall=medium_neg' =&gt; 'thRod=medium_neg',          'posBall=far_right &amp; velBall=slow'       =&gt; 'thRod=medium_neg',          'posBall=far_right &amp; velBall=medium_pos' =&gt; 'thRod=large_neg',          'posBall=far_right &amp; velBall=fast_pos'   =&gt; 'thRod=large_neg',         );drawGUI();MainLoop;# this subroutine calculates the new values of the ball's position# and velocity after a period of time $timeStep.# Friction is not modeled.sub calcNewData {  my $acc  = G * sin ($thRod * PI / 180);  my $Vnew = $velBall + $acc * $timeStep;  my $dist = $velBall * $timeStep + 0.5 * $acc * $timeStep * $timeStep;  $velBall  = $Vnew;  $posBall += $dist;  $velBall =  15 if $velBall &gt;  15;  $velBall = -15 if $velBall &lt; -15;  $time += $timeStep;}# This sub draws the gui.sub drawGUI {   my $mw = new MainWindow;   my $canvas = $mw-&gt;Canvas(qw/-bg black -height 400 -width 600/)-&gt;pack;   $canvas-&gt;createLine(0, 0, 0, 0,   qw/-width 2 -fill white -tags ROD/);   $canvas-&gt;createOval(0, 0, 50, 50, qw/-fill green -tags BALL/);   my $f = $mw-&gt;Frame-&gt;pack(qw/-fill x/);   my $dth;   $f-&gt;Button(-text    =&gt; 'run',          -command =&gt; sub {        my $id;        $id = $canvas-&gt;repeat(100 =&gt; sub {                    # update the ball's data.                    calcNewData();                    # check for termination conditions.                    # stop if ball is almost stationary and the rod                    # is almost flat.                    if (abs($velBall) &lt; 0.005 &amp;&amp; abs($thRod) &lt; 0.001) {                      print "Simulation ended.\n";                      $canvas-&gt;afterCancel($id);                      return;                    }                    # stop if ball fell off the rod.                    if ($posBall &gt; $halfLenRod or $posBall &lt; -$halfLenRod) {                      print "Ball fell off the rod!\n";                      $canvas-&gt;afterCancel($id);                      return;                    }                    # compute the new angle of the rod.                    $fis-&gt;compute(posBall =&gt; $posBall,                              velBall =&gt; $velBall);                    $thRod = $fis-&gt;value('thRod');                    # update our drawing.                    updateCanvas($canvas);                      });          })-&gt;pack(qw/side left -ipadx 10/);   $f-&gt;LabEntry(-label =&gt; 'Ball Pos',        -textvariable =&gt; \$posBall,           )-&gt;pack(qw/-side left -padx 10/);   $f-&gt;LabEntry(-label =&gt; 'Ball Speed',        -textvariable =&gt; \$velBall,           )-&gt;pack(qw/-side left -padx 10/);   $f-&gt;LabEntry(-label =&gt; 'Rod Angle',        -textvariable =&gt; \$thRod,           )-&gt;pack(qw/-side left -padx 10/);   updateCanvas($canvas);}# This subroutine draws the rod at its current angle, and# the ball at its current position.sub updateCanvas {  my $c = shift;  my $ly = 200;  my $dy = int(40 * $halfLenRod * tan(PI * $thRod / 180));  $c-&gt;coords(ROD =&gt; 100, $ly - $dy, 500, $ly + $dy);  my $by = 150 + $posBall * $dy / $halfLenRod;  my $bx = 100 + (5 + $posBall) * 40;  $c-&gt;coords(BALL =&gt; $bx - 25, $by, $bx + 25, $by + 50);}# tangent sub.sub tan { sin($_[0]) / cos($_[0])  }</pre><P><A HREF="#rl1">Back to Article</A></P></body></html>