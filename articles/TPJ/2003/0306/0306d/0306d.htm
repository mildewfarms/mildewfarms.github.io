<html><head><title>Jun03: Managing Newsletters with Perl</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; The Perl Journal--><h1>Managing Newsletters with Perl</h1><p><i>The Perl Journal</i> June 2003</p><h3>By Simon Cozens</h3><I>Simon is a freelance programmer and author, whose titles include Beginning Perl (Wrox Press, 2000) and Extending and Embedding Perl (Manning Publications, 2002). He's the creator of over 30 CPAN modules and a former Parrot pumpking. Simon can be reached at simon@ simon-cozens.org.</I><hr><p>It ought to have been very simple. I needed to produce a newsletter. The content was going to be created offline, and then uploaded to a processing script that was going to distribute it electronically. And Perl was going to help me.</p><p>It ought to have been very simple, but like so many things, it ended up being a little more complex than that. Complex enough, I hope, that there are one or two things involved in the process of creating the newsletter that we can all learn from.</p><p>The first idea I had was to produce a newsletter in HTML, which people could look at on the Web, or print off and distribute to less Internet-aware friends. And because I hate producing HTML by hand, I used the Template Toolkit to template it out. Let's begin by looking at how I did that.</p><h3>Template Toolkit</h3><p>Andy Wardley's Template Toolkit is a fantastically useful suite of Perl modules that implement a parser and interpreter for a little templating language. Templating languages are most often used to fill values computed by a program into some text. For instance, we could have a template like this:</p><PRE>[% today %][% title %] [% forename %] [% surname %][% address %]Dear [% title %] [% surname %],    Thank you for your letter dated [% their_date %]. This is toconfirm that we have received it and will respond with a moredetailed response as soon as possible. In the mean time, weenclose more details of ...</PRE><p>We tell Template Toolkit what the various values of <i>today</i>, <i>title</i>, and so on ought to be, and it fills out the template.</p><p>Of course, as we're about to find out with our newsletter project, things that start out nice and simple have a way of getting bigger and more complex. Template Toolkit supports a lot more than just filling scalars into a form: It has support for arrays, hashes and objects, the ability to include templates inside templates, declare macros, run blocks multiple times, filter text through various functions, and much more. Thankfully, we're only going to use a small amount of this functionality in the newsletter.</p><p>The HTML page we're constructing is slightly tricky. It uses CSS to lay out text in three columns. We'll have a header, a column describing generally what the newsletter is about, a main column of news, and then a further column of other information&#151;how to get in touch with me, and so on. At the bottom, we'll put some information about how to make sure people have the latest edition of the newsletter.</p><p>The top of the HTML is static, so we pass that out to a separate file. Let's assume we have a file called "Head" that contains all the HTML header and the initial <i>&lt;body&gt;</i> tag.</p><PRE>&lt;html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"&gt;&lt;head&gt;&lt;title&gt;Simon's Newsletter&lt;/title&gt;...&lt;/head&gt;&lt;body&gt;&lt;div class="box-wrap"&gt;</PRE><p>Similarly, we have a static "Foot" file:</p><PRE>&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</PRE><p>Now we can forget about most of the mucky business of HTML and concentrate on the content:</p><PRE>[% INCLUDE Head %]&lt;p&gt; My newsletter will appear here. &lt;/p&gt;[% INCLUDE Foot %]</PRE><p>We can process this with the Template Toolkit using the following bit of Perl:</p><PRE>use Template;my $template = Template-&gt;new();$template-&gt;process("newsletter.thtml");</PRE><p>(I use the extension "thtml" to remind myself that this is templated HTML.)</p><p>With that little program, the generated HTML page gets spat out to standard output. Great. In fact, Template Toolkit comes with a handy little utility called <i>tpage</i>, which is functionally equivalent to our Perl program above. You can just say <i>tpage newsletter.thtml</i>, and Template Toolkit will process the template in the same way.</p><p>So far so good. But of course, we haven't used any template variables yet. Let's add some now, by giving the newsletter an issue number and date:</p><PRE>[% INCLUDE Head %]&lt;div class="box-header"&gt;&lt;h1 align="center"&gt;Simon's Newsletter&lt;/h1&gt;&lt;p align="right"&gt;&lt;I&gt;Issue [% issue %] - [% date %]&lt;/I&gt;&lt;/p&gt;&lt;/div&gt;&lt;p&gt; My newsletter will appear here. &lt;/p&gt;[% INCLUDE Foot %]</PRE><p>Now we need a way to tell the template what the values of these variables are. We do this by passing in a hash reference as the second parameter of <i>process</i>.</p><PRE>use Template;my $template = Template-&gt;new();my $vars = {    issue =&gt; 1,    date =&gt; scalar localtime};$template-&gt;process("newsletter.thtml", $vars);</PRE><p>Once again, the newsletter will be produced on standard output. As it happens, we can still use <i>tpage</i>, even if we're adding template variables. We can say:</p><PRE>tpage &#151;define issue=1 &#151;date="May 17th" newsletter.thtml</PRE><p><i>tpage</i> is a very handy tool for prototyping your templates in the way we're doing here.</p><p>Now we have our header out of the way. Let's move on to our three columns. We'll handle them in order of complexity. The left-hand column is just static text, so we can dispose of that trivially:</p><PRE>&lt;div class="column-two"&gt;&lt;div class="column-two-content"&gt;&lt;h2&gt;WEC Trek to Japan&lt;/h2&gt;[% INCLUDE trek %]&lt;/div&gt;&lt;/div&gt;</PRE><p>The right-hand column will be partially static text, but will also contain an array of brief news items. I'm going to omit all the <i>div</i> and other extraneous tags for the time being so that we can concentrate on the content.</p><PRE>&lt;h2&gt;In brief&lt;/h2&gt;&lt;ul&gt;[% FOREACH point = brief %]&lt;li&gt;[% point %]&lt;/li&gt;[% END %]&lt;/ul&gt;&lt;h2&gt;Contact Details&lt;/h2&gt;[% INCLUDE contact %]</PRE><p><i>brief</i> is going to be an array of pieces of news. Just like in Perl, we use FOREACH to iterate over that array; the template code is equivalent to this in Perl:</p><PRE>for my $point (@brief) {</PRE><p>This makes the local variable <i>point</i> contain the text for each news item.</p><p>The middle column is very similar, but slightly more complex. We'll have a number of more substantial news items, separated by horizontal lines. These will be passed in as an array of hash references, and we let Template do the work of sorting it all out. Here's what the template looks like for the news column.</p><PRE>&lt;h2 align="center"&gt;News&lt;/h2&gt;[% FOREACH item = news %]    &lt;h3&gt;[%item.title%]&lt;/h3&gt;    [% item.content %]    &lt;P ALIGN="right"&gt;&lt;I&gt;- [%item.when%]&lt;/I&gt;&lt;/P&gt;    &lt;BR&gt;    &lt;HR WIDTH="80%" ALIGN="center"&gt;    &lt;BR&gt;[% END %]</PRE><p>What this says is that it expects an array called "<i>news</i>," and will iterate over the array (that's the familiar FOREACH), putting each element in a temporary variable called <i>item</i>. <i>item</i> will itself be a hash reference, and we extract the elements called <i>title</i>, <i>content</i>, and <i>when</i> from it.</p><p>Template's <i>dot</i> operator is a little like Perl 5's <i>arrow</i> operator (and Perl 6's <i>dot</i> operator), minus the worry about brackets: It can be used to retrieve elements from hashes or arrays and also call methods on objects. Template Toolkit knows how to look at <i>item</i> and do the right thing with it&#151;if we put an object inside our <i>news</i> array with <i>when</i>, <i>content</i>, and <i>title </i>methods, we'd get the same results.</p><p>This works well, but there's a little bit of a bug: We want the items separated by lines, but it looks slightly ugly to have a line right at the end after the last item. So we tell Template to output the <i>HR </i>tag unless we're on the last item:</p><PRE>[% '&lt;HR WIDTH="80%" ALIGN="center"&gt;' UNLESS item == news.last %]</PRE><p>Template Toolkit provides special "virtual methods" on Perl values, which allow us to do clever things like this: Arrays have methods like <i>first</i> and <i>last</i>, which are equivalent to <i>.[0] </i>and <i>.[-1]</i> respectively. There are also methods that allow you to call Perl functions such as <i>split</i> or <i>join</i> on template variables.</p><p>This completes the template part of the newsletter&#151;the complete template is given in <A NAME="rl1"><A HREF="#l1">Listing 1</A>. (All code for this article is also available online at http://www.tpj.com/source/.)</p><h3>Enter Blosxom</h3><p>Now let's start thinking about how we want to get these values into our template. We will have our "in brief" news points stored in a file, one point per line, to make it very easy to read those into an array:</p><PRE>open BRIEF, "inbrief" or die $!;my @brief = &lt;BRIEF&gt;;close BRIEF;$vars = {     issue =&gt; $issue,    brief =&gt; \@brief,    date =&gt; $date};$template-&gt;process("newsletter.thtml", $vars, "newsletter-$issue.html");</PRE><p>This time, we've used a third argument to <i>process</i>, which tells Template Toolkit not to write to standard output, but to save the output to the named file.</p><p>What about the main news items? Well, this is where the story starts to get a bit more complicated. I want the news articles to also appear on my blog (http://blog.simon-cozens.org/) as I upload them. My blog uses a piece of software called <i>blosxom</i>, written by Rael Dornfest at O'Reilly. I like blosxom because it has a UNIX nature&#151;I put my blog items as plain-text files in a directory and it sorts them all out. So a blog entry could be a file called "1234.txt" containing this:</p><PRE>Head Goes Here&lt;p&gt; Here is the text of today's blog entry &lt;/p&gt;</PRE><p>Blosxom looks at the first line of the file and uses that as the entry's heading. The rest of the file is HTML text that is added verbatim into the blog page which is being constructed. Blosxom also takes a look at the file's timestamp in the filesystem and uses that as the date of the entry. Note that the name of the file ("1234.txt") is arbitrary, and isn't used in building up the entry at all.</p><p>Now, because I wanted the news articles to appear on my blog, I thought it would be sensible to use blosxom format for the articles. That way, once they've been processed into the newsletter, they can be moved across to the blog data directory and be picked up there, too. So let's read in these files the same way blosxom does:</p><PRE>use File::stat;use File::Copy;my @news;for my $file (&lt;*txt&gt;) {    my $item = {};    $item-&gt;{when} = localtime(stat($file)-&gt;mtime);    $item-&gt;{when} =~ s/\d+:\d+:\d+ //;    open IN, $file or die "$file: $!";    $item-&gt;{title} = &lt;IN&gt;;    local $/;    $item-&gt;{content} = &lt;IN&gt;;    close IN;    push @news, $item;    copy $file, "/opt/blog/$file";}</PRE><p>We look for all the "txt" files in the current directory, and process each one of them. First, we look at the last-modified time of the file and convert that to a string. We remove the time, leaving only the date, and use that as the <i>when</i> element of our array. Now we can open up the file, read the first line as the <i>title</i>, and everything else goes into <i>content</i>. Once we've finished reading the file, we stick the item onto the array of news items and copy the entry over to the blog data directory for blosxom to pick it up.</p><p>Now we have all the data we need...or most of it at least.</p><h3>Unpacking Archives</h3><p>A further wrinkle comes from the fact that I only want to create one file offline and let my processing program do the right thing with it. This actually works to our advantage because we can produce a tar file that contains all the data and metadata we need in one directory.</p><p>We'll stipulate that the tar file comes in with a known filename and known format: Each issue should be contained in a file called "issueX.tar.gz" and this should contain a directory issueX/. We can now use <i>Archive::Tar</i> to extract the files:</p><PRE>use Archive::Tar;my $filename = shift;my $tar = Archive::Tar-&gt;new;$tar-&gt;read($filename, 1);$tar-&gt;extract;</PRE><p>And we can grab our issue number and the directory where we expect to find our files from the name of the file:</p><PRE>my $dir = $filename;$dir =~ s/\.tar\.gz//;$dir =~ /issue(-?\d+)$/     or die "Directory name not in correct format";my $issue = $1;</PRE><p>The <i>-?</i> is there because I wanted to produce "pre" issues of the newsletter, whimsically called "Issue -2" and "Issue -1." Because these preissues were monthly and the real issues will be weekly, I wanted to specify the date manually: "Issue -2" should have a date of "May," rather than "July 10-17" or whatever. So we read in the date of the newsletter from a file called date in our data directory:</p><PRE>open DATE, "$dir/date" or die "Can't open date file";my $date = &lt;DATE&gt;;</PRE><p>So now we have all we need to produce the HTML version of the newsletter: a way to untar the input, find the issue number, look at the date, read the brief news items, and also read in the blosxom entries.</p><h3>Uploading the HTML</h3><p>We have an HTML file, but it's not much good just sitting on our filesystem. We need to get it out onto the Web. My personal web site is currently externally hosted, so I have to use FTP to transfer the files up to the site. No problem&#151;Perl has the <i>Net::FTP</i> module to handle this for me:</p><PRE>use Net::FTP;$ftp = Net::FTP-&gt;new("simon-cozens.org");$ftp-&gt;login("simon",$password) or die $!.$@;print "Creating HTML version...\n";my $output = "newsletter$issue.html";$template-&gt;process("newsletter.thtml", $vars, $output);print "Uploading $output...\n";$ftp-&gt;put($output, "public_html/newsletter/$output");</PRE><p>And I also upload it once again calling it "latest.html" so people can make sure they're reading the most recent version.</p><PRE>print "Uploading as latest.html...\n";$ftp-&gt;put($output, "public_html/newsletter/latest.html");</PRE><h3>A Final Flourish</h3><p>So far we have the newsletter available as an HTML file on the Web, and also as entries on my weblog. But both of these are "pull" media&#151;people have to keep checking the site to see if there's something new. Some people expressed a desire to have the news available as "push," where they are informed every time there's an update. The obvious way to do this is by e-mail. (Another way is via RSS, but that raises the bar a little&#151;everyone knows how e-mail works.) And of course, I would rather die than knowingly send HTML e-mail.</p><p>Easy enough, I thought&#151;I'll just knock up another template that will generate a plain-text e-mail and send that out to a mailing list I had set up. This template was very similar to the HTML one, but obviously, much simpler:</p><PRE>Issue [% issue %] - [% date -%]&#151;&#151;&#151;&#151;&#151;&#151;&#151;&#151;&#151;&#151;&#151;&#151;&#151;News====[% FOREACH item = news -%][%item.title%][%- item.content -%]- [%item.when%][%- '&#151;-' UNLESS item == news.last %][%- END %]...</PRE><p>But when I processed this, I realized a slight problem. All of the news items are designed to be on the Web, in blosxom format&#151;in HTML. I had to de-HTMLify these items before putting them through the processor. The <i>HTML::TreeBuilder</i> and <i>HTML::FormatText</i> modules came to my rescue here:</p><PRE>use HTML::TreeBuilder;use HTML::FormatText;for (@news) {    my $text = $_-&gt;{content};    $tree = HTML::TreeBuilder-&gt;new-&gt;parse($text) or die $!;    $formatter = HTML::FormatText-&gt;new(leftmargin =&gt; 1, right					  margin =&gt; 75);    $_-&gt;{content} =$formatter-&gt;format($tree);}</PRE><p>This replaces each <i>content</i> with a plain-text equivalent, ready to be processed by our e-mail template.</p><p>Now it's a very simple matter of using <i>Mail::Mailer</i> to send out the processed e-mail:</p><PRE>$template-&gt;process("email.template", $vars, "email.txt");use Mail::Mailer;$mailer = new Mail::Mailer 'smtp', Server =&gt; "localhost";$fh = $mailer-&gt;open({Subject =&gt; "Newsletter Issue $issue",                     To    =&gt; 'wectrek2003@lists.netthink.co.uk');print "Sending...\n";open LET, "email.txt" or die $!;print $fh &lt;LET&gt;;$fh-&gt;close;</PRE><p>And we're done. 76 lines of Perl code and seven modules later, we have a system that allows me to take a file full of news and metadata, say</p><PRE>% process-newsletter issue3.tar.gz</PRE><p>and magically have a web site and weblog updated and a newsletter sent out via e-mail. The whole process-newsletter program can be found in <A NAME="rl2"><A HREF="#l2">Listing 2</A>.</p><h3>What It's All About</h3><BLOCKQUOTE><p><i>Larry is wise, and strong. But remember how his one regret was he didn't get to a Christian missionary? Guess what Ruby's creator used to be? A missionary in Hiroshima, Larry. In Hiroshima. </p><p></i>-Dave Green, NTK</p><p>http://www.ntk.net/index.cgi?b=02001-02-16&amp;l=160#l</p></BLOCKQUOTE><p>So far I've been very coy about what this newsletter is all about. Next month, I'm planning to even Larry's old score&#151;I'll be going out on a short-term mission trip working with churches around the Shiga area of western Japan. In the field, I may not have excellent Internet connectivity, so I wanted something that would allow me to do as much of the work offline as possible; this is why I wanted only to have to deal with one file and have the processing system do the rest.</p><p>In the process of writing the newsletter system, we've seen examples of how to use Template Toolkit, how to unpack tarballs with <i>Archive::Tar</i>, how to upload files with <i>Net::FTP</i>, how to turn HTML into plain text, and how to send out mail, all from Perl. By putting in the time to create this admittedly complex processor, I'll now be able to spend less time creating the newsletter and more time creating news to go in it.</p><p>This is, I believe, exactly the kind of laziness Larry had in mind when he created Perl&#151;laziness that requires a reasonable investment of time and effort up front, but then allows me to keep in touch with those back home, yet still have more time away from the computer, doing good things with good people.</p><p><i>You can keep up to date with my trip at http://simon-cozens.org/ mission/latest.html, where you'll see the output of this very system.</i></p><p><b>TPJ</b></p><H4><A NAME="l1">Listing 1</H4><pre>&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"&gt;&lt;html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" /&gt;&lt;title&gt;Newsletter&lt;/title&gt;&lt;link rel=stylesheet type="text/css"href="http://simon-cozens.org/mission/pl.css" title="myStyle"&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="box-wrap"&gt;&lt;div class="box-header"&gt;&lt;h1 align="center"&gt;Simon Cozens newsletter&lt;/h1&gt;&lt;p align="right"&gt;&lt;I&gt;Issue [% issue %] - [% date %]&lt;/I&gt;&lt;/p&gt;&lt;/div&gt;&lt;div class="columns-float"&gt;&lt;div class="column-one"&gt;&lt;div class="column-one-content"&gt;&lt;h2 align="center"&gt;News&lt;/h2&gt;[% FOREACH item = news %]&lt;h3&gt;[%item.title%]&lt;/h3&gt;[% item.content %]&lt;P ALIGN="right"&gt;&lt;I&gt;- [%item.when%]&lt;/I&gt;&lt;/P&gt;&lt;BR&gt;[% '&lt;HR WIDTH="80%" ALIGN="center"&gt;' UNLESS item == news.last %]&lt;BR&gt;[% END %]&lt;/div&gt;&lt;/div&gt;&lt;div class="column-two"&gt;&lt;div class="column-two-content"&gt;&lt;h2&gt;WEC Trek to Japan&lt;/h2&gt;[% INCLUDE trek %]&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;!-- close columns-float --&gt;&lt;div class="column-three"&gt;&lt;div class="column-three-content"&gt;&lt;h2&gt;In Brief&lt;/h2&gt;&lt;ul&gt;[% FOREACH point = brief %]&lt;li&gt;[% point %]&lt;/li&gt;[% END %]&lt;/ul&gt;[% INCLUDE phone %]&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;!-- close box-wrap --&gt;&lt;/body&gt;&lt;/html&gt;</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing 2</H4><pre>use Template;use File::stat;use Net::FTP;$ftp = Net::FTP-&gt;new("simon-cozens.org", Debug =&gt; 0);      $ftp-&gt;login("simon","xxx") or die $!.$@;use Archive::Tar;my $filename = shift;my $tar = Archive::Tar-&gt;new;$tar-&gt;read($filename, 1);$tar-&gt;extract;my $dir = $filename;$dir =~ s/\.tar\.gz//;$dir =~ /issue(-?\d+)$/ or die "Directory name not in correct format";my $issue = $1;open DATE, "$dir/date" or die "Can't open date file";open BRIEF, "$dir/brief"     or die "Can't open brief news file $dir/brief: $!";my @points = &lt;BRIEF&gt;;# Now, the rest will be in blosxom formatmy @news;for my $file (&lt;$dir/*txt&gt;) {    my $item = {};    $item-&gt;{when} = localtime(stat($file)-&gt;mtime);    $item-&gt;{when} =~ s/\d+:\d+:\d+ //;    open IN, $file or die "$file: $!";    $item-&gt;{title} = &lt;IN&gt;;    local $/;    $item-&gt;{content} = &lt;IN&gt;;    close IN;    push @news, $item;}my $template = Template-&gt;new();my $vars = {    issue =&gt; $issue,    news =&gt; \@news,    brief =&gt; \@points,    date =&gt; &lt;DATE&gt;};print "Creating HTML version...\n";my $output = "newsletter$issue.html";$template-&gt;process("newsletter.thtml", $vars, $output);print "Uploading $output...\n";$ftp-&gt;put($output, "public_html/japan/$output");print "Uploading as latest.html...\n";$ftp-&gt;put($output, "public_html/japan/latest.html");print "Processing email version...\n";# Now process the email version, and send it to the list.use HTML::TreeBuilder;use HTML::FormatText;for (@news) {    my $text = $_-&gt;{content};    $tree = HTML::TreeBuilder-&gt;new-&gt;parse($text) or die $!;    $formatter = HTML::FormatText-&gt;new(leftmargin =&gt; 1, rightmargin =&gt; 75);    $_-&gt;{content} =$formatter-&gt;format($tree);}$template-&gt;process("email.template", $vars, "email.txt");use Mail::Mailer;$mailer = new Mail::Mailer 'smtp', Server =&gt; "localhost";$fh = $mailer-&gt;open({Subject =&gt; "Newsletter Issue $issue",                         To      =&gt; 'wectrek2003@lists.netthink.co.uk');print "Sending...\n";open LET, "prayer-email.txt" or die $!;print $fh &lt;LET&gt;;$fh-&gt;close;</pre><P><A HREF="#rl2">Back to Article</A></P></body></html>