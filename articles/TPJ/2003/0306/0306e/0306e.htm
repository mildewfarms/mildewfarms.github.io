<html><head><title>Jun03: HTML Filtering in Perl, Part II</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; The Perl Journal--><h1>HTML Filtering in Perl, Part II</h1><p><i>The Perl Journal</i> June 2003</p><h3>By Randal Schwartz</h3><I>Randal is a coauthor of Programming Perl, Learning Perl, Learning Perl for Win32 Systems, <i>and</i> Effective Perl Programming, as well as a founding board member of the Perl Mongers (perl.org). Randal can be reached at merlyn@stonehenge.com.</I><hr><p>Last month I presented an HTML stripper that tackled the problem of removing unwanted HTML from posts in web-based bulletin board systems. I outlined some of the risks in allowing arbitrary HTML in such posts. Left unfiltered, such HTML can be exploited to allow cross-site scripting and the triggering of browser bugs, which can lead to denial-of-service attacks or usurped credentials, or it can simply mangle the display of your pages.</p><p>The code for the stripper that I described last month is in <A NAME="rl1"><A HREF="#l1">Listing 1</A>. This month, I'll explain the code for the <i>My_HTML_Filter</i> module, on which the HTML stripper depends. So how does <i>My_HTML_Filter</i> work? Let's go to <A NAME="rl2"><A HREF="#l2">Listing 2</A> for the details.</p><p>Line 3 pulls in the <i>XML::LibXML</i> module and line 4 creates a <i>$PARSER</i> object, using the default settings. This parser can be shared among many individual filters, so we've made it a class variable.</p><p>Lines 6 through 10 provide the constructor, which simply captures the <i>$permitted</i> parameter as an instance (member) variable, and returns the blessed object.</p><p>The real meat begins in line 12: the <i>strip</i> instance method. Lines 13 and 14 grab the instance variable and the input HTML, respectively.</p><p>Line 16 parses the HTML into a DOM. That's it. The result is an <i>XML::LibXML::Document</i> object from which we can get nice, clean HTML, or even XHTML if we choose. But we'll want to strip out the ugly stuff first. Line 17 caches the <i>$permitted</i> hashref into a simple scalar for quick access.</p><p>Line 19 establishes the "cursor" or "current node," conveniently and ambiguously called <i>$cur</i>. We'll do a walk of the DOM tree by moving this pointer around. We'll start by dropping down to the first child of the document node, and we'll end when the value hits <i>undef</i>, dropping out of the loop beginning in line 20.</p><p>Line 21 establishes a <i>$delete</i> flag. If this flag is true at the bottom of this loop, the current node must be deleted after we've computed the next node.</p><p>The comments in lines 23 and 24 reflect my feelings about how this is a bad design. Any design that requires you to ask an object for its type is generally a maintenance nightmare. Instead, a common protocol should have been established, where I'd merely have to query the properties and abilities of each thing within the tree using a Boolean-returning query method. But not here. So I grit my teeth and use <i>ref</i> a lot, hoping that some future version fixes all of this before it breaks all of this.</p><p>If it's an element, we'll note that in line 25, and then proceed to see whether the element type (the <i>nodeName</i> in line 27) is one of our permitted elements. If so, <i>$ok_attr</i> will then be a hashref of the permitted attributes, and we'll continue into line 28.</p><p>Lines 29 to 32 remove any attribute that is not permitted. Each attribute is queried for its <i>nodeName</i>, which is then checked against a list of permitted attributes, and removed if not permitted.</p><p>Line 34 moves our cursor down into the first child node, if it exists. For example, if we're looking at a <i>td</i> element, it will almost certainly have some content that we then have to scan. Some permitted elements (like <i>br</i>) won't have any content, so <i>$next</i> will be <i>undef</i>, and we'll use the normal "move forward" logic at the bottom of the loop.</p><p>That handles the permitted elements, but when we have a forbidden element, we need to remove it and reparent the orphaned children, using the code beginning in line 39.</p><p>Line 42 caches the parent node of the node to be deleted. Lines 43-45 move all of the node's children up to follow the node. This must be done in reverse order so that the order is retained following the current node, since we're always inserting immediately following the current node.</p><p>Finally, line 47 notes that the <i>$cur</i> node must be deleted after we've computed the following node at the bottom of the loop.</p><p>Lines 50 through 52 retain any existing text or <i>cdata</i> sections. The <i>cdata</i> section results when a <i>script</i> tag is used. Although our permitted list will probably cause the <i>script</i> element to be removed, the hoisted data is in a <i>cdata</i> element, and should be treated like text.</p><p>Lines 53 through 57 flag comments and DTDs as needing to be deleted. The former is dangerous (possibly hiding JavaScript). The latter is unnecessary, since we'll likely be including this text as part of a larger HTML page anyway.</p><p>Lines 58 to 60 attempt to flag anything else that I didn't see in my testing. I have no idea if I covered all of the nodes permitted in an HTML document, but I'm hoping I did.</p><p>Lines 62 to 73 compute the "next" node to be visited. I want the equivalent of the <i>XPath</i> expression <i>following::node()[1]</i>, without paying the price of parsing an <i>XPath</i> each time through the loop. This expression looks for the next node of any type, either at the same level or at any higher level. Child nodes are not considered.</p><p>Line 63 initially sets this "next" node to be the current node. Lines 65 to 68 determine if the next sibling node is available. If so, that's our selection, and we drop out of the "naked block" defined in lines 64 through 72.</p><p>If the node has no next sibling, then we need to pop up a level in the tree and look for that node's following node. Line 70 tries this, restarting the naked block if successful. If we're already at the top-level node, then the <i>undef</i> value is left in <i>$next</i>, which will end the outer loop started in line 20.</p><p>Lines 76 and 77 delete the current node if needed by requesting that the parent node forget about the current node. Line 79 advances the current node to the next node as the last step of this outer loop.</p><p>All that's left now is to spit out the modified DOM as HTML, in line 82, and then toss away the initial DTD in line 83. (In my tests, this was always the first line up to a newline, but this may change in future releases of the library, so this is a bit risky.)</p><p>Line 88 provides the mandatory true value for all files brought in with <i>require</i> or <i>use</i>.</p><p>And there you have it! A configurable HTML stripper that is fast and thorough. Now there's no excuse for letting someone start a comment tag or bold tag in your guestbook, messing up the rest of your display. Until next time, enjoy!</p><p><b>TPJ</b></p><H4><A NAME="l1">Listing 1</H4><pre>=0=     ###### LISTING ONE (main program) ######=1=     #!/usr/bin/perl=2=     use strict;=3=     $|++;=4=     =5=     use My_HTML_Filter;=6=     =7=     ## from http://www.perlmonks.org/index.pl?node_id=29281=8=     =9=     my %PERMITTED ==10=      map { my($k, @v) = split; ($k, {map {$_, 1} @v}) }=11=      split /\n/, &lt;&lt;'END';=12=    a href name target class title=13=    b =14=    big =15=    blockquote class=16=    br=17=    center =18=    dd =19=    div class=20=    dl =21=    dt =22=    em =23=    font size color class=24=    h1=25=    h2=26=    h3 =27=    h4 =28=    h5 =29=    h6 =30=    hr=31=    i =32=    li =33=    ol type start=34=    p align class=35=    pre class=36=    small =37=    span class title=38=    strike =39=    strong =40=    sub =41=    sup =42=    table width cellpadding cellspacing border bgcolor class=43=    td width align valign colspan rowspan bgcolor height class=44=    th colspan width align bgcolor height class=45=    tr width align valign class=46=    tt class=47=    u =48=    ul =49=    END=50=    =51=    use Test::More qw(no_plan);=52=    =53=    my $f = My_HTML_Filter-&gt;new(\%PERMITTED) or die;=54=    isa_ok($f, "My_HTML_Filter");=55=    =56=    is($f-&gt;strip(qq{Hello}),=57=       qq{&lt;p&gt;Hello&lt;/p&gt;\n},=58=       "basic text gets paragraphed");=59=    is($f-&gt;strip(qq{&lt;p&gt;&lt;bogus&gt;Thing}),=60=       qq{&lt;p&gt;Thing&lt;/p&gt;\n},=61=       "bogons gets stripped");=62=    is($f-&gt;strip(qq{&lt;a href="foo"&gt;bar&lt;/a&gt;}),=63=       qq{&lt;a href="foo"&gt;bar&lt;/a&gt;\n},=64=       "links are permitted");=65=    is($f-&gt;strip(qq{&lt;a href=foo&gt;bar&lt;/a&gt;}),=66=       qq{&lt;a href="foo"&gt;bar&lt;/a&gt;\n},=67=       "attributes get quoted");=68=    is($f-&gt;strip(qq{&lt;a href=foo bogus=place&gt;bar&lt;/a&gt;}),=69=       qq{&lt;a href="foo"&gt;bar&lt;/a&gt;\n},=70=       "bad attributes get stripped");=71=    is($f-&gt;strip(qq{&lt;p&gt;What do &lt;!-- comment --&gt;you say?}),=72=       qq{&lt;p&gt;What do you say?&lt;/p&gt;\n},=73=       "comments get stripped");=74=    is($f-&gt;strip(qq{&lt;table&gt;&lt;tr&gt;&lt;td&gt;Hi!}),=75=       qq{&lt;table&gt;&lt;tr&gt;&lt;td&gt;Hi!&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;\n},=76=       "tags get balanced");=77=    is($f-&gt;strip(qq{&lt;b&gt;&lt;i&gt;bold italic!}),=78=       qq{&lt;b&gt;&lt;i&gt;bold italic!&lt;/i&gt;&lt;/b&gt;\n},=79=       "b/i tags get balanced");=80=    is($f-&gt;strip(qq{&lt;b&gt;&lt;i&gt;bold italic!&lt;/b&gt;&lt;/i&gt;}),=81=       qq{&lt;b&gt;&lt;i&gt;bold italic!&lt;/i&gt;&lt;/b&gt;\n},=82=       "b/i tags get nested properly");=83=    is($f-&gt;strip(qq{&lt;B&gt;&lt;I&gt;bold italic!&lt;/I&gt;&lt;/B&gt;}),=84=       qq{&lt;b&gt;&lt;i&gt;bold italic!&lt;/i&gt;&lt;/b&gt;\n},=85=       "tags get lowercased");=86=    is($f-&gt;strip(qq{&lt;h1&gt;hey&lt;/h1&gt;one&lt;br&gt;two}),=87=       qq{&lt;h1&gt;hey&lt;/h1&gt;\n&lt;p&gt;one&lt;br&gt;two&lt;/p&gt;\n},=88=       "br comes out as HTML not XHTML");=89=    =90=    use Benchmark;=91=    my $homepage = do { open my $f, "homepage.html"; join "", &lt;$f&gt; };=92=    =93=    timethese=94=      (-1,=95=       {=96=        strip_homepage =&gt; sub { $f-&gt;strip($homepage) }=97=       });</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing 2</H4><pre>=0=     ###### LISTING TWO (My_HTML_Filter.pm) ######=1=     package My_HTML_Filter;=2=     use strict;=3=     require XML::LibXML;=4=     my $PARSER = XML::LibXML-&gt;new;=5=     =6=     sub new {=7=       my $class = shift;=8=       my $permitted = shift;=9=       return bless { permitted =&gt; $permitted }, $class;=10=    }=11=    =12=    sub strip {=13=      my $self = shift;=14=      my $html = shift;=15=    =16=      my $dom = $PARSER-&gt;parse_html_string($html) or die "Cannot parse";=17=      my $permitted = $self-&gt;{permitted};=18=    =19=      my $cur = $dom-&gt;firstChild;=20=      while ($cur) {=21=        my $delete = 0;             # default to safe=22=    =23=        ## I really really hate switching on class names=24=        ## but this is a bad interface design {sigh}=25=        if (ref $cur eq "XML::LibXML::Element") {=26=          ## "that which is not explicitly permitted is forbidden!"=27=          if (my $ok_attr = $permitted-&gt;{$cur-&gt;nodeName}) {=28=            ## so this element is permitted, but what about its attributes?=29=            for my $att ($cur-&gt;attributes) {=30=              my $name = $att-&gt;nodeName;=31=              $cur-&gt;removeAttribute($name) unless $ok_attr-&gt;{$name};=32=            }=33=            ## now descend if any kids=34=            if (my $next = $cur-&gt;firstChild) {=35=              $cur = $next;=36=              next;                 # don't execute code at bottom=37=            }=38=          } else {=39=            ## bogon - delete!=40=            ## we must hoist any kids to be after our current position in=41=            ## reverse order, since we always inserting right after old node=42=            my $parent = $cur-&gt;parentNode or die "Expecting parent of $cur";=43=            for (reverse $cur-&gt;childNodes) {=44=              $parent-&gt;insertAfter($_, $cur);=45=            }=46=            ## and flag this one for deletion=47=            $delete = 1;=48=            ## fall out=49=          }=50=        } elsif (ref $cur eq "XML::LibXML::Text"=51=                 or ref $cur eq "XML::LibXML::CDATASection") {=52=          ## fall out=53=        } elsif (ref $cur eq "XML::LibXML::Dtd"=54=                 or ref $cur eq "XML::LibXML::Comment") {=55=          ## delete these=56=          $delete = 1;=57=          ## fall out=58=        } else {=59=          warn "[what to do with a $cur?]"; # I hope we don't hit this=60=        }=61=    =62=        ## determine next node ala XPath "following::node()[1]"=63=        my $next = $cur;=64=        {=65=          if (my $sib = $next-&gt;nextSibling) {=66=            $next = $sib;=67=            last;=68=          }=69=          ## no sibling... must try parent node's sibling=70=          $next = $next-&gt;parentNode;=71=          redo if $next;=72=        }=73=        ## $next might be undef at this point, and we'll be done=74=    =75=        ## delete the current node if needed=76=        $cur-&gt;parentNode-&gt;removeChild($cur)=77=          if $delete;=78=    =79=        $cur = $next;=80=      }=81=    =82=      my $output_html = $dom-&gt;toStringHTML;=83=      $output_html =~ s/.*\n//;     # strip the doctype=84=    =85=      return $output_html;=86=    }=87=    =88=    1;</pre><P><A HREF="#rl2">Back to Article</A></P></body></html>