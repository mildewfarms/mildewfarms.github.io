<html><head><title>Jun03: Creating Module Distributions with <i>Module::Install</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; The Perl Journal--><h1>Creating Module Distributions with <i>Module::Install</i></h1><p><i>The Perl Journal</i> June 2003</p><h3>By Brian Ingerson</h3><I>Brian has been programming for 20 years, the last five of those in Perl. He lives in Portland, Oregon, and can be contacted at ingy@ttul.org.</I><hr><p>There is no doubt that Perl has the best code reuse infrastructure of all the open-source programming languages. This is due to the wonder known as the "Perl module." Almost every modern programming language worth a second look has a modular extension mechanism. But that's not what I'm getting at. The Perl module is different.</p><p>The reason has every bit as much to do with community and heroics as it does with technology and programming. Some very dedicated people have spent many years of their lives collectively nurturing the Perl module and, in the process, it has become something of a superstar of modern programming. The Perl module has a lot going for it:</p><ul>  <li><b>Good Documentation.</b> Perl modules have an exceptionally high quality of documentation, and the ubiquitous POD format converts nicely into all sorts of other formats including UNIX manpages, LaTeX, and HTML.  <li><b>Object Orientation.</b> Object-oriented interfaces are available for a large portion of modern modules.  <li><b>Consistency of Installation.</b> 99.9 percent of all Perl modules install the same way: <i>perl Makefile.PL &amp;&amp; make install</i>. This has made it possible to create sophisticated installation tools.  <li><b>Testability.</b> Perl modules have a standard for running unit tests that allow them to be tested by users with a single <i>make test</i>.  <li><b>Huge Repository.</b> CPAN has over 5500 modules. No other programming language can top that.</ul><p>The Perl forefathers spent a lot of time, thought, and hard work developing good standards for Perl modules. Because of this, Perl was able to excel in this domain while other languages have struggled.</p><p>But the Perl module has been in a bit of a rut lately, due to weaknesses that have begun to appear in the module installation process, some of which I'll discuss in this article. Perl has had many accomplishments, but the next big development in Perl may hinge on this installation question. However, the Perl community is (justifiably) wary of large overhauls that may cause more turmoil than they are worth.</p><p>In this article, I'll describe a new module called <i>Module::Install</i>, coauthored by Autrijus Tang and myself. It looks at things from a whole new perspective and breaks down many common barriers to module authoring. It also honors the three guiding principles of Perl:</p><ul>  <li>There's More Than One Way To Do It (TMTOWTDI).  <li>Do What I Mean (DWIM).  <li>It Just Works!</ul><p>There were other key ideas that affected the design of <i>Module::Install</i>:</p><p>1.	<i>Module::Install</i> should reduce the effects of module dependencies. If an author of a module (let's call it module X) incorporates <i>Module::Install</i> into a module, <i>Module::Install</i> itself need not even be available on CPAN to the users of module X.</p><p>2.	The average module user should never need to directly install <i>Module::Install</i>.</p><p>3.	Even if <i>Module::Install</i> becomes widely used, a need for backward compatibility should never be a limitation.</p><p>4.	<i>Module::Install</i> should get smarter over time. You should be able to teach it new tricks every time you use it.</p><h3>MakeMaker</h3><p>In the beginning, it was decided that the best way to build and manipulate Perl modules was with the UNIX "<i>make</i>" utility. This program is nearly ubiquitous and is a sharp tool for automating all sorts of processes, especially those having to do with building and configuring software. That means every Perl module (or more accurately, module distribution) needs a "makefile"&#151;the file that contains all the build rules.</p><p>The problem is that you can't create a makefile that is portable enough to work on all systems. This has to do both with differences in the system command processors (shells) and differences in the various implementations of make itself. The forefathers got around this problem in a clever way: They wrote a Perl module called <i>ExtUtils::MakeMaker</i> that could generate a proper makefile on any system. All it needed was a set of simple directives from the module author.</p><p>The convention has always been to put these directives in a Perl program called <i>Makefile.PL</i>. This has the advantage that an author can write any Perl code they want in order to set the directives. Often, this involves inspecting the local system, or prompting the person installing the module. In its most basic form, a <i>Makefile.PL</i> looks like this:</p><PRE>use ExtUtils::MakeMaker;WriteMakefile    NAME =&gt; 'Acme::Pie',    VERSION =&gt; '3.14';When anybody runs the command:perl Makefile.PL</PRE><p><i>ExtUtils::MakeMaker</i> will generate a rather large makefile for their system. This Makefile is capable of all sorts of tasks relating to Perl module building. If you dare to study the <i>MakeMaker</i> sources, you'll find them to be an arcane, nonextensible behemoth of a code base. In short, enough spaghetti code to feed the Italian Army. The code basically works, but it ain't gonna get much better. This ugliness leaves us with the good and the bad.</p><p>The good things about <i>ExtUtils::MakeMaker</i> are:</p><ul>  <li>It can produce a makefile that will work on all Perl platforms from Windows to UNIX to VMS to Mac OS (the old one!).  <li>The makefile can do everything that a Perl module needs to do&#151; run tests, build and link libraries, create documentation, and even generate a module distribution ready for CPAN.  <li>It has been shipped with Perl for a long time. That means a module author can expect it to be on virtually every installation of Perl that they would ship their module to.</ul><p>The bad things about <i>ExtUtils::MakeMaker</i> are:</p><ul>  <li>It relies on <i>make</i>. Why would such a powerful language need such a crufty little old UNIX utility to do what amounts to little more than invoking other commands?  <li>A <i>make</i> utility isn't always available on all platforms by default. Win32 is a common problem spot as it requires "nmake" to be installed.  <li>It can't realistically be overhauled. There are literally millions of Perl installations in the world with all sorts of administrative policies. How would you get them all to upgrade? It's like rolling a snowball up a mountain.  <li>It doesn't do what it doesn't do. Authors of modules with a complex build process end up writing lots of extra custom code inside <i>Makefile.PL</i> to make (no pun intended) up for the missing features of <i>ExtUtils::MakeMaker</i>.</ul><h3>The Cure</h3><p>So the Perl Module is kind of stuck in its legacy. Or is it?</p><p><i>Module::Install</i> offers some fairly clever solutions to the problems listed above. Its <i>modus operandi</i> is "embrace and extend," but in a better, more Perlish sense of that phrase. <i>Module::Install</i> simply makes use of all the goodness offered by <i>ExtUtils::MakeMaker</i>, and adds any extras as needed. Let's look at it in action:</p><PRE>use inc::<i>Module::Install</i>;name        ('Acme::Pie');version     ('3.14');check_nmake ();&amp;Makefile-&gt;write; </PRE><p>This does the same thing as the previous example, but in a completely different way. Let's see how: The first thing you'll notice is that we didn't use <i>Module::Install</i> at all. We used <i>inc::Module::Install</i>&#151;and therein lies the core of <i>Module::Install</i>'s subtle trickery.</p><h3>Authors and Users</h3><p>There are three types of people in the world&#151;well, the Perl world, anyway:</p><ul>  <li>Perl Module Authors.  <li>Perl Module Users.  <li>Perl Module Users who are also Authors.</ul><p><i>Module::Install</i> is different from most Perl modules because it is only installed by module authors. When the author runs <i>perl Makefile.PL</i>, the module called <i>inc::Module::Install</i> copies the module called <i>Module::Install</i> into the <i>./inc/</i> directory, if it doesn't already exist. Therefore, the new file has the path <i>./inc/Module/Install.pm</i>.</p><p>Next, <i>inc::Module::Install</i> adds <i>./inc/</i> to <i>@INC</i>, Perl's module-path lookup variable. Finally <i>inc::Module::Install</i> does a <i>require</i> <i>Module::Install</i>. The module that gets loaded is the one that was just copied. And the <i>Makefile.PL</i> proceeds.</p><p>There are several (potentially dozens) of submodules that <i>Module::Install</i> might need to make use of. Whenever one of these modules is needed, it goes through the same process of copying to the local directory and then loading into memory. Understanding this is the first key to understanding <i>Module::Install</i>.</p><p>All of the modules that get copied into the local <i>./inc/</i> directory need to be added to the MANIFEST file so that they will be shipped to the user. This can be done with the <i>make manifest</i> command, and <i>Module::Install</i> will warn you if you try to do a <i>make dist</i> without doing this first.</p><p>When the user gets the module, all of <i>Module::Install</i>'s parts will already be packaged right inside the module&#151;and that's the whole point. When the user runs the <i>Makefile.PL,</i> it will load <i>inc::Module::Install</i> directly from the local directory. This happens because Perl always has "." in the <i>@INC</i> path, so no user ever has to install <i>Module::Install</i> directly.</p><p>If the user also happens to be an author with his own (and possibly incompatible) version of <i>Module::Install</i>, his copy of <i>inc::Module::Install</i> will load the local copy from <i>./inc/</i>. This way, there can never be a conflict between different versions of <i>Module::Install</i>. The one that the module shipped with will always be the one used, so backward compatibility need not be maintained.</p><h3>Features on Demand</h3><p>Back to the example <i>Makefile.PL</i>. The next two lines are:</p><PRE>name        ('Acme::Pie');version     ('3.14');</PRE><p>These do exactly what you would think. They set the <i>NAME</i> and <i>VERSION</i> parameters so that <i>Module::Install</i> can call <i>ExtUtils::MakeMaker::WriteMakefile()</i> internally for you. But don't assume they aren't special. They are.</p><p><i>name</i> and <i>version</i> are not exported subroutines as you might think. They are simply two of myriad subroutines that exist in some unknown module. As long as that unknown module's name begins with <i>Module::Install::</i>, the subroutine will be found.</p><p><i>Module::Install</i> uses Perl's AUTOLOAD facility to catch the unknown subroutines, locate them in some module, and make sure that this module is inside the local <i>./inc/</i> directory. <i>Module::Install</i> only adds the modules that you actually need for your <i>Makefile.PL.</i> Note that when a module gets bundled into <i>./inc/</i> it is "pod stripped." In other words, all the documentation is removed. Since the <i>./inc/</i> modules never get installed by the user, the pod is just a waste of space.</p><p>Next we have:</p><PRE>check_nmake ();</PRE><p>This only comes into play when a user is installing your module on an MSWin32 system. It will check to see if nmake is installed. If not, it will download it from the Microsoft web site. Of course, it will ask the user first, just to be polite. This solves the common problem of people not having nmake on Windows.</p><p>Finally we have:</p><PRE>&amp;Makefile-&gt;write; </PRE><p><i>Makefile</i> is a subroutine that returns a <i>Module::Install::Makefile</i> object. This object holds all the info that is needed to create a Makefile by invoking <i>ExtUtils:MakeMaker::WriteMakefile</i>. The reason we don't just say <i>write</i> is because there are several modules that have <i>write</i> functions, as we'll see shortly. The <i>name</i> and <i>version</i> subroutines also happen to come from <i>Module::Install::Makefile</i>, so we could have written things like this:</p><PRE>use inc::<i>Module::Install</i>;&amp;Makefile-&gt;name    ('Acme::Pie');&amp;Makefile-&gt;version ('3.14');&amp;Makefile-&gt;write; </PRE><h3>Reducing Dependencies</h3><p><i>Module::Install</i> works independently. My recent CPAN module, <i>only.pm</i>, has been on CPAN for over two months, and it uses <i>Module::Install</i>. But as I am writing these words, <i>Module::Install</i> hasn't even been released. It simply doesn't need to be because all the parts of <i>Module::Install</i> that <i>only.pm</i> needs are shipped along with <i>only.pm.</i></p><p>In fact, Autrijus and I have started moving all of our modules over to <i>Module::Install</i>. We're testing our own creation. The whole <i>Module::Install</i> idea stems from a module that I released last year called <i>CPAN::MakeMaker</i>. Autrijus figured out how to accomplish all my goals in a simpler, more extendable way. When <i>Module::Install</i> is released, it will completely replace the need for <i>CPAN::MakeMaker</i>, which I will likely remove from CPAN.</p><p><i>Module::Install</i> should be released on CPAN by the time you read this. If not, keep an eye out for it.</p><h3>Bundles of Joy</h3><p><i>Module:Install</i> has another keen feature: bundling. You can actually convince <i>Module::Install</i> to pull in entire modules that it needs for building things. A great example is Michael Schwern's <i>Test::More</i>. It is great for writing tests, but some people don't use it because it doesn't exist by default on older versions of Perl. It's a tradeoff of whether or not to burden the users for the sake of writing better tests that, in the end, the users probably don't care about.</p><p><i>Module::Install</i> makes it a nonissue. It can simply pull in the author's version of <i>Test::More</i> right into the author's module. Here's an example:</p><PRE>include_deps    ('Test::More', 5.004);build_requires  ('Test::More');</PRE><p>The first line instructs <i>Module::Install</i> to bundle all the parts of your local <i>Test::More</i> into <i>./inc/</i>, as long as they support Perl 5.004 and higher. If they don't support 5.004, no bundling will take place.</p><p>The second line simply says that <i>Test::More</i> is required for building this module. By the way, the bundled <i>Test::More</i> modules are POD-stripped so the extra weight is minimal.</p><h3>What About <i>Module::Build</i>?</h3><p>Anybody who has been following the Perl module authors' scene in the past couple years should know about the <i>Module::Build</i> project. This is actually Ken Williams's attempt to do the impossible: replace <i>MakeMaker</i>. And he's doing a darn good job of it, too.</p><p>The main goal of <i>Module::Build</i> is to do everything important that <i>MakeMaker</i> does, but without using <i>make</i>. Ken has also done a fabulous job of keeping the code object oriented and clean as a whistle. That makes it easy for others to contribute to the project.</p><p>One of the hurdles Ken faces is getting people to use his module. Like <i>Test::More</i>, authors will have to make a choice between using the ubiquitous <i>MakeMaker</i> or the riskier new upstart, <i>Module::Build</i>.</p><p><i>Module::Install</i> will be a great ally for Ken. That's because <i>Module::Install</i> can use the same <i>Makefile.PL</i> that was created for <i>MakeMaker</i> to use <i>Module::Build</i> instead. Here's how to convert our <i>Makefile.PL</i> to use <i>Module::Build</i>:</p><PRE>use inc::<i>Module::Install</i>;name        ('Acme::Pie');version     ('3.14');check_nmake ();&amp;Build-&gt;write; </PRE><p>All I did was change <i>Makefile</i> to <i>Build</i>. Everything else remains the same! If I really wanted to cover my bases, I could ship with both methods in place like this:</p><PRE>use inc::<i>Module::Install</i>;name        ('Acme::Pie');version     ('3.14');check_nmake ();&amp;Makefile-&gt;write; &amp;Build-&gt;write; </PRE><p>If we also bundle in the <i>Module::Build</i> software, then there is almost no risk in using <i>Module::Build</i>. And then one day when <i>Module::Build</i> has replaced <i>MakeMaker</i> everywhere, authors can start dropping <i>MakeMaker</i> support.</p><h3>No Big Thing</h3><p>You may think that it's not a wise thing to add extra weight to all the CPAN modules. I personally wouldn't lose too much sleep over it. In the general case, you're only adding a few kilobytes once everything is gzip compressed. And much of this added weight is directly beneficial to your module.</p><p>Of course, it is possible to overdo it. I wouldn't suggest bundling the <i>Tk</i> module, for instance. But as long as you employ a modicum of wisdom, you (and the rest of the CPAN community) should be just fine.</p><h3>Metadata Support</h3><p>The future of a better CPAN lies in the ability of CPAN to easily obtain good metadata about each module. For instance, it would be immensely beneficial for CPAN to be able to report the license that each module is distributed under. Unfortunately, there is no good way to determine this unless the module author declares it somewhere.</p><p>Ken Williams realized this and created the META.yml standard file for holding module metadata. His <i>Module::Build</i> project encourages the use of META.yml. Michael Schwern has also added support for generating a META.yml file.</p><p><i>Module::Install</i> has very easy-to-use metadata support. Just add as many metadata fields as you wish to the <i>Makefile.PL</i> and <i>Module::Install</i> will make sure they get into the META.yml file.</p><p>Here is the <i>Makefile.PL</i> file for <i>only.pm</i>:</p><PRE>use inc::<i>Module::Install</i>;name           ('only');version_from   ('lib/only.pm');abstract       ('Load specific module versions; Install many');author         ('Brian Ingerson &lt;ingy@cpan.org&gt;');license        ('perl');include_deps   ('Test::More', 5.004);build_requires ('Test::More', 0);clean_files(qw(lib/only/config.pm));clean_files(qw(t/lib t/site t/distributions t/version t/alternate));create_config_module();check_nmake();&amp;Meta-&gt;write;&amp;Makefile-&gt;write;</PRE><p>As you can see, creating a META.yml is no harder than creating a makefile. Here's what the META.yml looks like:</p><PRE>name: onlyversion: 0.26abstract: Load specific module versions; Install manyauthor: Brian Ingerson &lt;ingy@cpan.org&gt;license: perldistribution_type: modulebuild_requires:  Test::More: 0private:  directory:    - inc</PRE><h3>CPAN for Scripts</h3><p>Traditionally, CPAN has been for distributing Perl modules, but not really for distributing Perl scripts. Some modules such as <i>LWP</i> and <i>YAML</i> come with a few helper scripts, but finding a distribution that only installs a Perl script in your path is rare indeed.</p><p>This distinction is somewhat artificial, in my opinion. I think the real reason that people don't generally do this is that it isn't easy to figure out how to do it. Here's a recipe for doing it with <i>Module::Install</i>:</p><p>First, create a script called "Hello World" that looks like this:</p><PRE>#!/usr/bin/perl -wuse strict;print ;"Hello, world\n";__END__=head1 NAME - Hello World ScriptDon't forget your documentation!=cutThen write the <i>Makefile.PL</i>:use inc::<i>Module::Install</i>;name('Hello-World');version('1.23');install_script('hello-world');&amp;Makefile-&gt;write;It's that easy. Run these commands:perl Makefile.PLmake manifest</PRE>make dist<p>And upload the tarball to CPAN. Well, actually there's a bit more to it than that: You still need to create some tests and a README and a Changes file. And, yes, you need to write a more useful script with better documentation. But that's about all.</p><h3>Extending <i>Module::Install</i></h3><p>The best part of <i>Module::Install</i> might not come from Autrijus or myself, but from you. You can easily create your own extensions to <i>Module::Install</i>. The trick is to put your functionality into a module called <i>Module::Install::PRIVATE::FooBar.</i> By using the private namespace, you'll avoid any possible collisions with future <i>Mode::Install::</i> modules.</p><p>Say you had a <i>Makefile.PL</i> that looked like this:</p><PRE>use inc::<i>Module::Install</i>;name('Acme::Pie');    print "Are you 18 years or older? ";if (&lt;&gt; !~ /^Y/i) {    die "Can't install this module for minors\n";}&amp;Makefile-&gt;write;</PRE><p>You could hide the query in a module, <i>Module::Install::PRIVATE::Assertions</i>:</p><PRE>package <i>Module::Install</i>::PRIVATE::Assertions;use base '<i>Module::Install</i>::Base';sub check_18 {    print "Are you 18 years or older? ";    if (&lt;&gt; !~ /^Y/i) {        die "Can't install this module for minors\n";    }}1;</PRE><p>Then your <i>Makefile.PL</i> would look like this:</p><PRE>use inc::<i>Module::Install</i>;name('Acme::Pie');check_18();&amp;Makefile-&gt;write;</PRE><p>That's so much cleaner. And you can use it over and over again for all your modules.</p><h3>Conclusion</h3><p><i>Module::Install</i> is just coming onto the scene. We hope that its fresh outlook on building Perl modules will help to keep Perl's future bright.</p><p><i>Module::Install</i> is just one of several <i>Module::*</i> modules that we hope will reinvent the way Perl authors do business. One of these will be <i>Module::Test</i>. Although it might not make its debut for a couple of months, its mission is clear&#151;to do for Perl testing what <i>Module::Install</i> does for Perl modules.</p><p><b>TPJ</b></p></body></html>