<html><head><title>Jan03: Sharing Cookies</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Sharing Cookies</h1><p><i>The Perl Journal</i> January 2003</p><h3>By brian d foy</h3><I>brian is the founder of the first Perl Users Group, NY.pm, and Perl Mongers, the Perl advocacy organization. He has been teaching Perl through Stonehenge Consulting for the past five years, and can be contacted at comdog@panix.com.</I><hr><p>I use several different web browsers to do my work. Some were created by other people, like Mozilla, Internet Explorer, and OmniWeb; and some I wrote in Perl using the LWP modules. I want all of these browsers to use the same cookies. Perl gets me most of the way to that goal.</p><p>The LWP::Simple module, which Gisle Aas designed for simple web transactions, does not use cookies. I can fetch the web page for this magazine with a couple of lines of code, and even though it tries to set a session cookie, LWP::Simple will not read it. If I try to access the web site again in the same program, the web server will try to set another cookie because my program did not send the first one the server tried to set.</p><DDJADVERTISEMENT INLINE><PRE>use LWP::Simple;    my $data = get( 'http://www.tpj.com' );</PRE><p>I have to do more work to use cookies. Behind the scenes, LWP::Simple uses LWP::UserAgent to do its work, and LWP::UserAgent can automatically send and receive cookies if I tell it to use a cookie file. I set the <i>autosave</i> parameter to True when I create the <i>HTTP::Cookies</i> object, so it will save its persistent cookies to a file when it goes out of scope. I tell the user agent which cookie jar to use with the <i>cookie_jar()</i> method.</p><PRE>use HTTP::Cookies;use LWP::UserAgent;    my $cookie_jar = HTTP::Cookies-&gt;new(     qw( autosave 1 file cookies.txt ) );    my $ua = LWP::UserAgent-&gt;new;$ua-&gt;cookie_jar( $cookie_jar );    # a lot more programming goes here</PRE><p>If I use LWP::UserAgent directly, I have to program the mechanics of the web transaction myself, but often, I just want to add cookie support. The LWP::Simple module exposes its user agent object if I import its <i>$ua</i> variable. Once I have the <i>$ua</i> object, I can change the user agent to do what I need as I did in the previous example, and I still get the benefit of LWP::Simple.</p><PRE>use HTTP::Cookies;use LWP::Simple qw(get $ua);    my $cookie_jar = HTTP::Cookies-&gt;new(     qw( autosave 1 file cookies.txt ) );$ua-&gt;cookie_jar( $cookie_jar );my $data = get( 'http://www.example.com' );</PRE><p>After I run this program, I have a file named "cookies.txt" in the current working directory. The cookies are in the HTTP::Cookies format, as shown in <A NAME="re1"><A HREF="0301de1.htm">Example 1</A>.</p><p>The problem with HTTP::Cookies is that it uses its own format for cookies. This has advantages, as I show later, but at the moment, I do not want to have several cookie files. I want one cookie file that all my user agents, including my usual web browsers, can use. All of my Perl programs can use the same cookies file as long as they all use HTTP::Cookies, but what about Netscape's browser, Mozilla, Internet Explorer, and others?</p><p>Gisle has already thought about some of this, and provides an <i>HTTP::Cookies::Netscape </i>subclass with HTTP::Cookies. I use the same module, HTTP::Cookies, because <i>HTTP::Cookies::Netscape</i> is in the same file. The only change is my cookie jar constructor.</p><PRE>use HTTP::Cookies;use LWP::Simple qw(get $ua);    my $cookie_jar = HTTP::Cookies::Netscape-&gt;new(     qw( autosave 1 file cookies.txt ) );    $ua-&gt;cookie_jar( $cookie_jar );my $data = get( 'http://www.example.com' );</PRE><p>After I run this program, my cookies file is in a cookie format that Netscape's browsers use, as shown in <A NAME="re2"><A HREF="0301de2.htm">Example 2</A>.</p><p>The HTTP::Cookies::Netscape module can also read files in the Netscape cookie format, so I can start with a cookie file that exists. If I am using Netscape Navigator from a Linux shell account, for instance, my cookie file is in the .netscape directory.</p><PRE>$cookie_jar = HTTP::Cookies::Netscape-&gt;new(  file      =&gt; "$ENV{HOME}/.netscape/cookies",  autosave  =&gt; 1,          );</PRE><p>My Perl program can read any cookies in that file and store any cookies it gets. So now, my Perl programs can use the same cookies as my Netscape browser. If I visit a web site that sets a cookie in either program, the other will be able to send the same cookie back, assuming that I do not use them simultaneously (since they do not write to the cookie file until they stop).</p><p>What if I want to use another browser, though? I no longer use any of Netscape's browsers, instead favoring the open-source alternative, Mozilla. Since Mozilla is not a product of Netscape, its cookie file is slightly different. The developers removed the word "Netscape" and added a comment about the Mozilla Cookie Manager. The rest of the format, though, is the same. See <A NAME="re3"><A HREF="0301de3.htm">Example 3</A>.</p><p>The HTTP::Cookies::Netscape module cannot read the Mozilla cookies file because its <i>load()</i> method, which reads the cookies from the file and puts them into the internal data structure, looks for "Netscape" in the first line. I have submitted a patch to RT.cpan.org (ticket 1816&#151;http://rt.cpan.org/NoAuth/Bug.html ?id=1816) to make this more flexible, but I also slightly modified the <i>HTTP::Cookies::Netscape</i> class to create HTTP::Cookies::Mozilla, which you can download from CPAN. I simply overrode the <i>load()</i> and <i>save()</i> methods to read and write the Mozilla cookie file header instead of the Netscape browser header. The module inherits the rest of its functionality from HTTP::Cookies. Now my Perl programs and Mozilla can share cookie files.</p><p>Once I knew how to make another cookie class, I wanted to do it for all of the browsers that I have on my machine. Since I use Mac OS X, I also have OmniWeb, which stores its cookies in an XML format, as shown in <A NAME="re4"><A HREF="0301de4.htm">Example 4</A>.</p><p>To read and write OmniWeb cookies, I did the same thing I did with Mozilla&#151;overrode the <i>load()</i> and <i>save()</i> methods to do the right thing. In this case, I had to completely reimplement these methods. The XML format is simple enough that I did not need any XML::Parser magic to create HTTP::Cookies::Omniweb, also available from CPAN. Now my Perl programs can use the same cookies as my OmniWeb browser.</p><p>After I wrote a couple of cookie modules, my Perl programs could share cookies with other applications. I would like to share cookies between applications, though. Can Mozilla and OmniWeb share cookies?</p><p>This problem entails a certain amount of concurrency. If I run both browsers at the same time, they potentially read more cookies from the web sites they visit and when I quit either browser, they will likely overwrite any changes to their cookie files. Instead of dealing with that problem, which is a simple matter of programming (even if the programming is not simple), I worry about the easy part&#151;converting from one format to another.</p><p>I have the ideal setup&#151;an internal format and a way to convert other formats to and from it. If I can get the data into the internal data structure, I can output it in any way that it knows about. So far I have four output formats: HTTP::Cookies, Netscape, Mozilla, and OmniWeb. With a large enough set of formats, I have about <i>N</i><sup>2</sup> different possible conversions. Since I have the common internal format, however, I only need to program <i>N</i> of those conversions. Gisle started off with two and I added another two already.</p><p>To convert between OmniWeb and Mozilla cookies, I need to read the OmniWeb cookies file just like I did earlier. When I create the object, HTTP::Cookies stores the cookies in its internal data structure.</p><PRE>use HTTP::Cookies::Omniweb;    my $omniweb = HTTP::Cookies::Omniweb-&gt;new( file =&gt; 'Cookies.xml' );</PRE><p>Once I have the cookies in the internal data structure (the common internal format), I only need to rewrite the file in the new format. Since I can muck with most of the object stuff in Perl&#151;do not try this in other languages&#151;I can change an object's identity. In this case, I want to make the <i>$omniweb</i> object use the <i>save()</i> method in the <i>HTTP::Cookies::Mozilla</i> class, which will write the file in the Mozilla format.</p><p>In Perl, a method call is just a subroutine invocation where the first argument is the object. I can call the <i>HTTP::Cookies::Mozilla::save()</i> subroutine directly and pass it the <i>$omniweb</i> object. Internally, objects of either class are the same. The only difference is the filename I started with, but <i>save()</i> takes an optional second argument to select the output filename.</p><PRE>use HTTP::Cookies::Mozilla;    HTTP::Cookies::Mozilla::save( $omniweb, 'cookies.txt' );</PRE><p>I can also rebless the <i>$omniweb</i> object into a new class. I still should call the <i>save()</i> method with the optional filename argument or it will try to use the filename with which I created it. I also leave off the <i>autosave</i> option so that HTTP::Cookies does not try to overwrite the original file when <i>$omniweb</i> goes out of scope.</p><PRE>use HTTP::Cookies::Omniweb;use HTTP::Cookies::Mozilla;    my $omniweb = HTTP::Cookies::Omniweb-&gt;new( file =&gt; 'Cookies.xml' );    bless $omniweb, 'HTTP::Cookies::Mozilla';    $omniweb-&gt;save( 'cookies.txt' );</PRE><p>Now I have the basics for working with cookies between applications. I can let Perl programs share cookies amongst themselves and with other applications, and I can convert formats from one to the other. I am also thinking about a way to do the same tasks with less typing that involves automatic format detection, but that is a topic for another article.</p><p><b>TPJ</b></p></body></html>