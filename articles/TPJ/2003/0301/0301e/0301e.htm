<html><head><title>Jan03: Why I Love Ruby</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Why I Love Ruby</h1><p><i>The Perl Journal</i> January 2003</p><h3>By Simon Cozens</h3><I>Simon is a freelance programmer and author, whose titles include Beginning Perl (Wrox Press, 2000) and Extending and Embedding Perl (Manning Publications, 2002). He's the creator of over 30 CPAN modules and a former Parrot pumpking. Simon can be reached at simon@ simon-cozens.org.</I><hr><p>In December's <i>The Perl Journal</i>, my fellow columnist brian d foy presented an introduction to Ruby. Well, he's not the only person who's been taking a look at this relative newcomer to the language scene, and I have to admit that I've been growing a lot more impressed with it recently.</p><p>This month, I'll take you on another tour of some of the things that attracted me to Ruby.</p><DDJADVERTISEMENT INLINE><h3>Perl 6, Now!</h3><p>Let's start with a polemic: Ruby provides what Perl 6 promises, right now. If you're excited about Perl 6, you should be very, very excited about Ruby. You want a clean OO model? It's there. You want iterators? Got them, too. You want user-redefinable operators? Check. Even the recent discussion on perl6-language about list operators&#151;Ruby's got them all. In fact, a lot of the things that you're waiting on Perl 6 for are already there&#151;and in some cases, cleaner, too.</p><p>Let's start by looking at some code. A typical example of object-oriented Perl 5 is shown in <A NAME="re1"><A HREF="0301ee1.htm">Example 1</A>(a).</p><p>Not too bad, right? Except, well, <i>package</i> is a bit of a silly name, since it's actually a class; and it would be nicer if we could take arguments to the method in a bit more normal way. And that hash is a bit disconcerting. In <A NAME="re1"><A HREF="0301ee1.htm">Example 1</A>(b), you can see what Perl 6 makes of it.</p><p>Much better&#151;except that, unfortunately, you can't actually run Perl 6 code through anything right now. That's always a bit of a problem when you need to get stuff done. So let's see it again, but this time in Ruby; see <A NAME="re1"><A HREF="0301ee1.htm">Example 1</A>(c).</p><p>Much neater, no? Apart from the bits that are exactly the same, of course. But what? No dollar signs on the variables? Well, you can have them if you want, but they mean something different in Ruby&#151;dollar signs make variables global. But hey, don't you need something to tell you what's an array or a hash or a scalar? Not in Ruby&#151;and actually, not in Perl 6 either, but for a different reason.</p><p>In Perl 6, variable prefixes are just a hint; Larry has said that you should consider them part of the name. You'll be able to dereference an array reference with <i>$myvar[123]</i> and a hash reference with <i>$myvar{hello}</i>, so things looking like scalars won't give you any indication of what's in them.</p><p>Ruby takes this approach further&#151;values have types, variables do not. Since everything's an object in Ruby, it doesn't make sense to distinguish between "array variables" and "scalar variables"&#151;everything's an object, and variables hold references to objects. If you get bored with your variable that has an array in it, you can put a hash in it. Ruby doesn't care; it's just a different kind of object.</p><p>So what are those "<i>@"</i> signs about? They're the Ruby equivalent of Perl 6's <i>$</i>.&#151;method instance variables. The only slight difference is that we want to ensure that the <i>age</i> is an integer; so we call its <i>to_i</i> method to turn it into an integer. We can do this because, as we've mentioned, in Ruby, everything's an object.</p><h3>Everything's an Object</h3><p>They say that a foolish consistency is the hobgoblin of tiny minds, and Perl takes this approach to justify some of its more unusual quirks. But unfortunately, when it comes to programming languages, a lot of consistency isn't foolish at all.</p><p>And so with the advent of Perl 6, I found myself wishing for a little more consistency in the area of object-oriented programming. In fact, I really wanted to be able to treat everything as an object, so that I could be sure that it would respond to methods. Ruby gives me that. Let's spend a little time with Ruby's interactive shell&#151;another neat feature&#151;and see what that really means:</p><PRE>irb(main):001:0&gt; a = [1, 2, 3, 4][1, 2, 3, 4]irb(main):002:0&gt; a.classArray</PRE><p>So arrays are objects; that's pretty natural, as you will want to ask an array for its length, run <i>map</i>s and <i>grep</i>s on it, and so on.</p><PRE>irb(main):003:0&gt; a.reverse[4, 3, 2, 1]</PRE><p>But what about the individual elements in the array?</p><PRE>irb(main):004:0&gt; a[1].classFixnum</PRE><p>Mmm, so numbers are just <i>Fixnum</i> objects. But wait, what's a <i>Fixnum</i>?</p><PRE>irb(main):005:0&gt; a[1].class.classClass</PRE><p>Ah, so even classes are objects; they're just objects of class <i>Class</i>. Fair enough. So this shouldn't be a surprise either:</p><PRE>irb(main):006:0&gt; a[1].class.class.classClass</PRE><p>It's objects all the way down!</p><p>Naturally, this allows pretty interesting introspection possibilities. For instance, we can ask an <i>Array</i> what it can do for us:</p><PRE>irb(main):007:0&gt; a.public_methods["sort!", "clone", "&amp;", "reverse", ...]</PRE><p>And of course, this list of methods is itself an <i>Array</i>, so we can tidy it up a bit:</p><PRE>irb(main):009:0&gt; a.public_methods.sort["&amp;", "*", "+", "-", "&lt;&lt;", "&lt;=&gt;", "==", "===", "=~","[]", "[]=", "__id__", "__send__", "assoc", "at", "class", "clear", "clone", "collect", "collect!", "compact", "compact!", "concat", "delete", "delete_at", "delete_if", "detect", "display", "dup", "each", ...]</PRE><p>Notice that since everything's an object, almost all operators are just methods on objects. One of those operator methods, <i>===</i>, is particularly interesting; Ruby calls this the "Case equality operator," and it's very similar to a concept you'll see bandied around in Perl 6...</p><h3>Making the Switch</h3><p>Perl 6 is touted to have an impressive new syntax for switch/case statements called "<i>given statements</i>." With a <i>given</i> block, you can pretty much compare anything to anything else using the <i>=~</i> "smart match" operator and Perl will do the right thing. Use <i>when</i> and a string, and it will test whether the given argument is string equivalent; use <i>when</i> and a regular expression, and it will test whether the argument matches the regex; use <i>when</i> and a class name, and it will test whether the argument is an object of that class. Really neat, huh?</p><p>Now I want to make you wonder where that idea came from.</p><p>Here's a piece of Perl 6 code taken directly from Exegesis 4:</p><PRE>my sub get_data ($data) {    given $data {        when /^\d+$/    { return %var{""} = $_ }        when 'previous' {             return %var{""} // fail NoData        }        when %var {             return %var{""} = %var{$_}        }        default { die Err::BadData : msg=&gt;"Don't understand $_"        }    }}</PRE><p>And translated into Ruby:</p><PRE>def get_data (data)  case data   when /^\d+$/    ; return var[""] = data   when 'previous' ; return var[""] || (fail No Data)   when var        ; return var[""] = var[data]   else      raise Err::BadData, "Don't understand #{data}"   endend</PRE><p>Of course, this doesn't quite do what we want because Ruby's default <i>case</i> comparison operator for hashes just checks to see whether two things are both the same hash. The Perl 6ish smart match operator checks through the hash to see whether <i>data</i> is an existing hash key. This code looks very much like the Perl 6 version, but it's not the same.</p><p>And we were doing so well.</p><h3>Everything is Overridable</h3><p>Not to worry. Not only is everything an object in Ruby, (almost) everything can be overriden, and the <i>Hash</i> class's <i>===</i> method is no exception. So all we need to do is write our own <i>===</i> method that tests to see if its argument is a valid hash key:</p><PRE>class Hash    def === (x)         return has_key?(x)    endend</PRE><p>And presto, our <i>case</i> statement now does the right thing. The <i>has_key?</i> method on a <i>Hash</i> object checks to see whether the hash has a given key. But wait, where's the <i>Hash</i> object? Because we're defining an object method, the receiver for the method is implicitly defined as <i>self</i>. And it just so happens that <i>self</i> is the default receiver for any other methods we call inside our definition, so <i>has_key?(x)</i> is equivalent to <i>self.has_key?(x)</i>. Now it all makes sense.</p><p>Of course, it's a little dangerous to redefine <i>Hash#===</i> globally, in case other things depend on it. Maybe it would be better to create a variant of <i>Hash</i> by subclassing it:</p><PRE>class MyHash &lt; Hash    def === (x)         return has_key?(x)    endendvar = MyHash[...];</PRE><p>As you can see, this means that we can define <i>===</i> methods for our own classes, and they'll also do the right thing inside of <i>when</i> statements.</p><p>It also means that we can redefine some of the built-in operators to do whatever we want. For instance, Ruby doesn't support Perl-style string-to-number conversion:</p><PRE>irb(main):001:0&gt; 1 + "0.345"TypeError: String can't be coerced into Fixnum        from (irb):1:in '+'        from (irb):1        irb(main):002:0&gt;</PRE><p>And this is one of the things people like about Perl; "scalar" is the basic type, and strings are converted to numbers and back again when context allows for it. Ruby can't do that. Bah, Ruby must really suck, then.</p><p>Now we are going to do something very unRubyish.</p><PRE>class Fixnum    alias old_plus +     def + (x)      old_plus(x.to_f)    endendirb(main):003:0&gt; 1 + "2"3.0</PRE><p>Ruby lovers would hate me for this. But at least it's possible.</p><p>First, we copy the old addition method out of the way because we really don't want to have to redefine addition without it. Now we define our own addition operator, which converts its argument to a <i>float</i> before calling the old method. Why is the addition operator unary? Well, remember that <i>1 + "2"</i> is nothing more than syntactic sugar, and what we're actually calling is a method:</p><PRE>1.+("2")</PRE><p>and the receiver of this method is our <i>self, 1</i>. It's consistent, is it not?</p><h3>You Want Iterators?</h3><p>There are a set of people on perl6-language who become amazingly vocal when anyone mentions iterators. I don't know why this is. Iterators aren't amazingly innovative or particularly interesting, nor do they solve all known programming ills. But hey, if you really get fired up about iterators, Ruby has those, too.</p><p>The most boring iterator Ruby supplies is <i>Array#each</i>. (<i>#</i> is not Ruby syntax&#151;it's just a convention to show that this is an object method on an <i>Array</i> object, not an <i>Array</i> class method.) This is equivalent to Perl's <i>for</i>(@array):</p><PRE>[1,2,3,4].each {    |x| print "The square of #{ x } is #{ x * x }\n"}</PRE><p>By the way, here's Ruby's block syntax: We're passing an anonymous block to each, and it's being called back with each element of the array. The block takes an argument, and we define the arguments inside parallel bars. Some people don't like the { |x| ... } syntax. If that includes you, you have two choices: the ever-beautiful sub{ my $x = shift; ... }, or waiting until Perl 6. See? { |x| ... } isn't that bad after all.</p><p>You can call <i>each</i> on ranges, too:</p><PRE>1..4.each {    |x| print "The square of #{ x } is #{ x * x }\n"}</PRE><p>Or maybe you prefer the idea of going from 1 up to 4, doing something for every number you see:</p><PRE>1.upto(4) {    |x| print "The square of #{ x } is #{ x * x }\n"}</PRE><p>Or even:</p><PRE>100.times {    |x| puts "I must not talk in class"}</PRE><p>(<i>puts</i> is just <i>print ..., "\</i>n", after all.)</p><p>Another frequent request is for some kind of array iterator that also keeps track of which element number in the array you're visiting. Well, guess what? Ruby's got that, too.</p><PRE>irb(main):001:0&gt; a = [ "Spring", "Summer", "Fall", "Winter" ]["Spring", "Summer", "Fall", "Winter"]irb(main):002:0&gt; a.each_with_index {  |elem, index| puts "Season #{ index } is #{ elem }"}Season 0 is SpringSeason 1 is SummerSeason 2 is FallSeason 3 is Winter["Spring", "Summer", "Fall", "Winter']</PRE><p>Oh yes&#151;these iterators return the original object, so that they can be chained, just in case you wanted to do something like that.</p><p>Those were the boring iterators. What about more interesting uses? I saw an interesting Perl idiom the other day for reading <i>key=value</i> lists out of a configuration file into a hash. Here it is:</p><PRE>open(EMAIL, "&lt;$EMAIL_FILE") or die     "Failed to open $EMAIL_FILE"; my %hash = map {chomp; split /=/} (&lt;EMAIL&gt;);</PRE><p>Of course, how does this translate to Ruby? There was quite a long thread about this on <i>comp.lang.ruby</i>, and I picked out three translations that impressed me for different reasons&#151;of course, there's more than one way to do it. Here's the first:</p><PRE>h = [] File.open('fred.ini').read.scan(/(\w+)=(\w+)/) {    h[$1] = $2 }</PRE><p>We open a file, read the whole lot into a string, and then iterate on a regular expression&#151;each time the regular expression matches, a block is called, and this associates the hash key with its element. Nice.</p><p>Established Perl programmers will see this and jump up and down about depending on the <i>open</i> call never failing. Good thinking, but Ruby has decent structured exceptions; if the <i>open</i> fails, an exception will be raised and hopefully caught somewhere else in your program.</p><p>Now that method is cute, but it reads the whole file into a single string. This can be memory hungry if you have 120-MB configuration files. Of course, if you do, you probably have other problems, but people will be pedantic. It'd be much better to read the file one line at a time, right? No problem.</p><PRE>File.foreach("fred.ini") {    |l| s = l.chomp.split("="); h[s[0]] = s[1]}</PRE><p>This is a more literal translation of what the Perl code is doing. Notice that Ruby's <i>chomp </i>returns the chomped string, without modifying the original. If you want to modify the original, you need <i>chomp!</i>&#151;methods ending with <i>!</i> are a warning that something is going to happen to the original object.</p><p>But even this method lacks the sweetness of the Perl idiom, which builds the whole hash in one go. Okay. In Ruby, you can construct a hash like this:</p><PRE>h = Hash[ "key" =&gt; "value", "key2" =&gt; "value2"];</PRE><p>So if we could read in our file, split it into keys and values, and then dump it into a hash constructor like that, we'd have it. Here's our first attempt:</p><PRE>h = Hash[File.open("fred.ini").read.split(/=|\n/)]</PRE><p>That's close, but it has a bit of a problem. Because objects can be hash keys in Ruby, what we've actually done is create a hash with an <i>Array</i> as the key and no value. Oops. To get around this, we need to invoke a bit of Perl 6 magic:</p><PRE>h = Hash[*File.open("fred.ini").read.split(/=|\n/)]</PRE><p>There we go, our old friend unary <i>*</i> turns the <i>Array</i> object into a proper list, and all is well.</p><p>So there are built-in iterators. But what if you want to define your own? All methods in Ruby can optionally take a block, and the keyword <i>yield</i> calls back the block. So, assuming we've already defined <i>Array#randomize</i> to put an array in random order, we can create a random iterator like so:</p><PRE>class Array    def random_each         self.randomize.each { |x| yield x }    endend</PRE><p>What does this mean? First, get the array in random order, and then for each element of that array, call back the block we were given, passing in the element. Simple, hmm?</p><h3>Messing with the Class Model</h3><p>Let's move on to some less simple stuff, then. In a recent perl6-language post, the eminent Piers Cawley wondered whether or not it would be possible to have anonymous classes defined at run time via Class.new or some such. Man, that would be cool. I'd love to see a language that could do that. You can see this coming, can't you?</p><PRE>c = Class.new;c.class_eval {    def initialize        puts "Just another Ruby hacker"    end}o = c.new;</PRE><p>First, we create a new class, <i>c</i>, at run time, in an object. Now, in the context of that class, we want to set up an initializer; <i>Object#initialize</i> is called as part of <i>Object#new</i>. So now our class has a decent <i>new</i> method that does something; we can instantiate new objects of our anonymous class. But they can't do very much at the moment. Now, we could add new methods to the class with <i>class_eval</i> as before, but that's kinda boring. We've seen that. How about adding individual methods to the object itself?</p><PRE>class &lt;&lt; o    def honk        raise "Honk! Honk!"    endendo.honk;</PRE><p>This doesn't do anything to our class <i>c</i>; it just specializes <i>o</i> with what's called a singleton method&#151;<i>o</i> and only <i>o</i> gets a <i>honk</i> method.</p><p>What about <i>AUTOLOAD</i>? This is a lovely feature of Perl that allows you to trap calls to unresolved subroutines. Ruby calls this <i>method_missing</i>:</p><PRE>class &lt;&lt; o    def method_missing (method, *args)        puts "I don't know how to #{ method } (with               arguments #{ args })";        end    end</PRE><p>And notice there the Perl 6 unary star again, collecting the remaining arguments into an array.</p><p>There are many other tricks we can play if we do evil things such as override <i>Object#new</i> or play about with the inheritance tree by messing with <i>Object#ancestors</i>. But time is short, and I'm sure you're dying to move onto the last bit: What I hate about Ruby.</p><h3>Ruby Gripes</h3><p>Ruby is a comparitively young language, which is a mixed blessing. It's been developed at the right time to learn from the mistakes of other languages&#151;try explaining why Python's array length operator <i>len</i> is a built-in function and not a method, and you'll appreciate the consistency of Ruby's OO paradigm. But, even though it's coming up to its 10th birthday, it's also still finding its way around, and the changes between minor releases are sometimes quite significant.</p><p>So what are the things I don't think Ruby has got right quite yet? First, I really, really, really miss using curly braces for my subroutine definitions. You can write subroutines in one line using Ruby; it's not as white-space significant as people make out:</p><PRE>def foo; puts "Hi there!"; end</PRE><p>but braces for blocks just seems so much neater.</p><p>I also miss default values for blocks; there is a special variable <i>$_</i> in Ruby, but it contains the last line read in from the terminal or a file. So you really do have to say</p><PRE>array.each{|x| print x}becausearray.each { print }</PRE><p>won't do what you want.</p><p>There are a few other odd things: For instance, variables have to be assigned before they're used, which is probably a good thing but can confuse me at times. I also find myself tripping over Ruby's <i>for</i> syntax; Ruby supports statements modifying <i>if</i>, <i>unless</i>, <i>while</i>, and <i>until</i>, but not <i>for</i>, as <i>for</i> is just syntactic sugar for <i>stuff.each</i> anyway.</p><p>But there is one major problem I have with Ruby, and that's basically the reason why I haven't switched over to it wholesale: CPAN. Perhaps Perl's greatest asset is the hundreds and thousands of modules already available. Ruby has a project similar to the CPAN, the <i>Ruby Application Archive</i>. But as the language is still quite young, it hasn't had the time to grow a massive collection of useful code, and the RAA itself has some flaws&#151;it's a collection of links, rather than a mirrored collection of material, and it can be pretty hard to find stuff on it at times.</p><p>This is, I'm sure, something that will be sorted out over time, but I have to sadly admit that Ruby's not quite there yet. Of course, Perl 6 will also need to spend time developing a large collection of useful modules; so at least Ruby does have a massive head start&#151;it has a real, existing interpreter that you can download, play with, and use for real code today. And if you're at all interested in Perl 6, I heartily encourage you to do so.</p><p>Finally, thanks to David Black and the other members of #ruby-lang who helped review this article.</p><p><b>TPJ</b></p></body></html>