<html><head><title>Feb03: Other People's Arguments</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; The Perl Journal--><h1>Other People's Arguments</h1><p><i>The Perl Journal</i> February 2003</p><h3>By Simon Cozens</h3><I>Simon is a freelance programmer and author, whose titles include Beginning Perl (Wrox Press, 2000) and Extending and Embedding Perl (Manning Publications, 2002). He's the creator of over 30 CPAN modules and a former Parrot pumpking. Simon can be reached at simon@ simon-cozens.org.</I><hr><p>I'm going to let you into a secret about writing technical articles. The trick that I often use to plan an article is to think of a particular technique I want to illustrate, then find a practical use for it and, finally, find a problem that the practical application solves. Here comes the trick: You then present it all back-to-front. That way, you've got an article that looks like it's showing you how to solve a particular problem, and the technique you want to talk about pops up magically as the answer to all your problems in the end.</p><p>In this article, for instance, the technique that I want to talk about is the little-known <i>@DB::args</i> magic variable; the application is my recent <i>rubyisms</i> Perl module; the problem, if you want to call it that, is my recent dabbling with Ruby.</p><p>As you can probably tell from last month's column, I've grown fond of some of the features I've been using in Ruby. This is a common problem&#151;or so I'm told&#151;with love affairs: If and when you come back to your first love, you can't help but want some of the things you've left behind. Thankfully, however, programming languages are a good deal easier to change than people. So the more frustrated I got with the things from Ruby that I thought Perl lacked, the more I wanted to sit down and fix them up.</p><p>The first thing I found myself missing was the <i>super</i> keyword. It came up in Perl as I was specializing a <i>Class::DBI</i>-based module. I had a class representing a database table, which I could search by its two columns, <i>real_name</i> and <i>displayed_name</i>. But I also wanted a "magical" search term name that searched through both columns. So, in my subclass, I would say:</p><PRE>sub search {      my ($self, $terms) = @_;    if (exists $terms-&gt;{name}) {         # Do our special search    } else {        # Call the superclass's search.    }}</PRE><p>Now, calling the <i>superclass</i> method is easy. We all know how to do that. Here's how you'd naturally write it in Perl:</p><PRE>$self-&gt;SUPER::search($terms);</PRE><p>However, this is what it looks like in Ruby:</p><PRE>super</PRE><p>You can probably understand why I felt spoiled by Ruby. No problem, I thought, I can find a way to do this in Perl. So I thought about what the <i>super</i> subroutine had to do:</p><ul>  <li>It should have a prototype of <i>()</i> so it could be called like a built-in.  <li>It should use <i>caller</i> to get at the method that called it.  <li>It should have to somehow get at the object and the arguments to the method, so it could work out the <i>superclass</i> method and call it with the same arguments.</ul><p>Well, the first two were pretty easy:</p><PRE> sub super () {      my $caller= (caller(1))[3];     $caller =~ s/.*:://; }</PRE><p>But the third had me completely confused. How on earth could I retrieve my caller's subroutine arguments? Well, the obvious place to start looking was the documentation for <i>caller</i>; and there I found something I had never noticed before:</p><blockquote><p>"Furthermore, when called from within the DB package, <i>caller</i> returns more detailed information: it sets the list variable <i>@DB::args</i> to be the arguments with which the subroutine was invoked."</p></blockquote><p>Wow, just perfect. So I wrote up a little subroutine to call <i>caller</i> from package <i>DB</i>:</p><PRE> package DB; sub uplevel_args { my @x = caller(2); return @DB::args }</PRE><p>This looks two frames up the stack (<i>DB::uplevel_args</i> is the zeroth frame, <i>SUPER::super</i> is the first, and the method that called <i>super</i> is the second), and returns the arguments from the method. The array is needed to stop Perl from optimizing the call to <i>caller</i>.</p><p>So now we know how the method was called, which tells us the object.</p><PRE> sub super () {      my $caller= (caller(1))[3];     $caller =~ s/.*:://;     @_ = DB::uplevel_args();     my $self = $_[0]; }</PRE><p>Unfortunately, it gets tricky again here: We'd like to say <i>$self -&gt;SUPER::$caller</i>, but that gives us a "<i>Bad name after ::</i>" error. And we want to avoid using <i>eval,</i> if possible. What we need is to somehow get hold of a reference to the appropriate <i>superclass</i> method. Since we already know the class and the method name, we are half way there. Let's assume a putative <i>UNIVERSAL::super</i> subroutine that works like <i>UNIVERSAL::can</i> and returns a reference to the method if one is available. Then we can say:</p><PRE> sub super () {      my $caller= (caller(1))[3];     $caller =~ s/.*:://;     my @their_args = DB::uplevel_args();     my $self = $their_args[0];     $self-&gt;UNIVERSAL::super($caller)-&gt;(@their_args); }</PRE><p>Now this is pretty clever, but it has a slight untidyness problem. Suppose we have a class <i>Wibble::Simple</i> that inherits from class <i>Wibble</i>. With our current use of <i>super,</i> we'd see a call stack like this:</p><PRE> Wibble::Simple::do_it    SUPER::super       Wibble::do_it</PRE><p>Whereas we'd prefer to see this:</p><PRE> Wibble::Simple::do_it    Wibble::do_it</PRE><p>Now, there is a way to make <i>SUPER::super</i> morph itself into the appropriate method: the <i>goto &amp;subroutine</i> technique. Since <i>UNIVERSAL::super</i>&#151;when it's written&#151;returns a subroutine reference, we merely need to set the <i>@_</i> to be what we want the superclass to see, and then <i>goto</i> the reference:</p><PRE> sub super () {      my $caller= (caller(1))[3];     $caller =~ s/.*:://;     @_ = DB::uplevel_args();     my $self = $_[0];     my $supermethod = $self-&gt;UNIVERSAL::super($caller);     goto &amp;$supermethod; }</PRE><p>Right, we're done! Well, apart from the little matter of that <i>UNIVERSAL::super</i> method, that is. But this isn't too much of a problem&#151;all we need to do to work out an object's <i>super</i> method is to think of what Perl would do. And what Perl does is ask each member of that object's class's <i>@ISA</i> array if it can perform the method. This can be done with the <i>can</i> method, which returns a code reference if the class can perform the given method&#151;precisely what we want!</p><PRE> package UNIVERSAL; sub super {     my ($class, $method) = @_;     if (ref $class) { $class = ref $class; }     my $x;     for (@{$class."::ISA"}, "UNIVERSAL") {         return $x if $x = $_-&gt;can($method);     } }</PRE><p>And with this&#151;and a little testing and documentation&#151;the <i>SUPER</i> module was born and released onto CPAN. Now I could write things like the following:</p><PRE>sub search {      my ($self, $terms) = @_;    if (exists $terms-&gt;{name}) {         # Do our special search    } else {        super;    }}</PRE><p>This made me happy.</p><p>But then, a few more lines of code later, there was another problem. One of the nice things about Ruby's OO model as opposed to Python's and Perl's is that the recipient of a method is implicit.</p><p>It's not necessary to say:</p><PRE>my $self = shift;</PRE><p>to get it from the argument list. It's just there, and it's possible to get at it with the <i>self</i> keyword.</p><p>Furthermore, you can call one method from another just by naming it, and the <i>self</i> is again passed around implicitly.</p><p>Here's a bit of Ruby to demonstrate this:</p><PRE>class Thing  def look      _print  end  def _print      puts self  endendfoo = Thing.newfoo.look</PRE><p>We create a new object and call its <i>look</i> method. This then calls another method, <i>_</i>print, implicitly passing the object around. <i>_</i>print receives the object, once again implicitly, before finally referencing it as <i>self</i>.</p><p>Of course, this can't be done in Perl&#151;we can't change the fact that method calls do pass around the receiver and that we need to pass the receiver to a submethod. And we can't rewrite <i>@_</i> (once we know the receiver) to pretend it was never there in the first place. But we can fake it.</p><p>Using the same <i>@DB::args</i> trick, we can create a subroutine that returns the first argument of its caller:</p><PRE>sub self () {    return (DB::uplevel_args())[0];}This means we can say things like:sub look   { self-&gt;_print }sub _print { print self, "\n" }Not a bad start. But we'd really like to be able to say:sub look   { _print }sub _print { print self, "\n" }</PRE><p>That's right: Even though we call <i>print</i> with no arguments, it should still know what the current receiver is.</p><p>Once again, being able to mess about with other subroutines' arguments comes to our aid. The key to this is realizing that we don't have to look just two levels up the stack&#151;we can look farther if we want to. And as we look up the call stack, we'll eventually come to a frame that is called "properly," with the appropriate type of object as its first argument.</p><p>So, we first modify <i>DB::uplevel_args</i> so that we can look up a variable number of frames:</p><PRE>sub uplevel_args { my @x = caller($_[0]+1); return @DB::args };</PRE><p>We now look up the stack until we find a subroutine whose first parameter <i>is-a</i> whatever class we were called by:</p><PRE>sub self () {    my $call_pack = (caller())[0];    my $level =1;    while (caller($level)) {        my @their_args = DB::uplevel_args($level);        if (ref $their_args[0]            and eval { $their_args[0]-&gt;isa($call_pack) }) {            return $their_args[0];        }        $level++;    }    return $call_pack;}</PRE><p>We're only interested in objects that are inherited from the caller, because if we have</p><PRE>package Thing;sub look_to_file { my $output = new IO::File (...);                    _print($output)                 }</PRE><p>we want the recipient of <i>_</i>print to be the <i>Thing</i>, not the <i>IO::File</i>. So in this case, we want to ignore the argument to <i>_</i>print but look back at the arguments of <i>look_to_</i>file.</p><p>Notice also that if we don't find any object of the relevant class at any time in the recent past, we assume that we're dealing with a class method, and that the <i>self</i> is the name of the calling package; this is a reasonable approach and is pretty much what Ruby does:</p><PRE>% ruby -e 'print self;'main% perl -Mrubyisms -e 'print self;'main</PRE><p>So now we can use an implicit <i>self</i>, and pass it around between methods of the same class. Very neat, no?</p><p>But I've glossed over another little detail of my Ruby example: Our class, <i>Thing</i>, had a constructor, but we didn't define a <i>new</i> method. This is because all classes in Ruby inherit from class <i>Class</i>, which provides a generally-good-enough default constructor and then calls the <i>initialize</i> method to allow us to specify the object. This is a neat idea, so I wanted to steal that too. First, we need to make everything that imports the <i>rubyism</i> method inherit from class <i>Class</i>:</p><PRE>sub import {    no strict 'refs';    push @{(caller())[0]."::ISA"}, "Class";    rubyisms-&gt;export_to_level(1, @_);}</PRE><p>We find the calling package's package name, and slap <i>Class</i> onto the end of its <i>@ISA</i> array. Then we can use a little <i>Exporter</i> trick that deserves to be better known: Call <i>Exporter</i>'s <i>import</i> to make <i>super</i> and <i>self</i> available to calling packages in addition to doing our own <i>import</i>ish things. You might think that after all we have seen in this article, we could so far just say:</p><PRE>sub import {    no strict 'refs';    push @{(caller())[0]."::ISA"}, "Class";    super;}</PRE><p>to jump to our superclass. Unfortunately, that doesn't quite work. This is because <i>Exporter</i>'s <i>import</i> method moves symbols from <i>Exporter</i> to the class calling the method&#151;in this case, <i>rubyisms</i>. This isn't what we want&#151;we want to move symbols from <i>rubyisms</i> to whatever <i>use</i>d it. So we call the <i>import_to_level</i> method, which moves symbols around at a different calling level. This does the right thing.</p><p>Now we can populate the <i>Class</i> class with the methods we want. A generally-good-enough constructor in Perl blesses an empty hash and calls a specializer before returning the new object:</p><PRE>package Class;sub new {    my $class = shift;    my $self = bless {}, $class;    $self-&gt;initialize(@_);    return $self;}</PRE><p>(Note that we can't use <i>self</i> here to get the recipient because in the constructor, there isn't a recipient yet!)</p><p>We provide a dummy specializer for completeness:</p><PRE>sub initialize {}</PRE><p>We can now rewrite our Ruby example in Rubyish Perl:</p><PRE>package Thing;use rubyisms;sub _print { print self }sub look   { _print }my $foo = Thing-&gt;new;$foo-&gt;look;</PRE><p>And I was happy again&#151;until I found another feature from Ruby I wanted to steal...</p><p>Now that we have this technique of inspecting the caller's arguments, it is very simple to write our own keywords such as <i>super</i> and <i>self</i> that depend on the properties of a subroutine. Another subroutine-specific keyword in Ruby is <i>yield</i>.</p><p>As we saw last month, every method in Ruby can take an optional block, and the <i>yield</i> keyword calls back that block. In Perl, we don't have the same optional block syntax, but we do have something similar: If subroutines are given a prototype starting with the <i>&amp; </i>character, they will behave somewhat like <i>map</i> or <i>grep</i>.</p><p>For instance, here's a truly simple array iterator. You might want to call it a "Visitor design pattern" if you're a Gang-of-Four devotee; if you're a Perl devotee, you might call it a highly redundant <i>for</i> loop. It simply visits each element of the array, calling a codeblock on the element:</p><PRE>sub each_arr (&amp;@) {     my ($code, @array) = @_;    for (@array) {          $code-&gt;($_);    }}</PRE><p>With the syntax-modifying <i>&amp;</i> prototype, this can be called as follows:</p><PRE>each_arr { print $_[0], "\n" } (10, 20, 30);</PRE><p>But we'd prefer to write this in a more Rubyish way, like so:</p><PRE>sub each_arr {    for (@_) { yield }}</PRE><p>The Perl way is slightly different&#151;instead of a block at the end, we expect a block at the beginning. So, once again, we look at our caller's arguments and ensure that the first argument is a code reference. If it isnt, we give a nice Ruby-friendly error:</p><PRE>sub yield {    my @their_args = DB::uplevel_args(1);    if ((!@their_args) or ref $their_args[0] ne "CODE") {        croak "no block given (LocalJumpError)";    }</PRE><p>And now we have the code reference; we can call it on <i>$_</i>:</p><PRE>    $their_args[0]-&gt;($_);}</PRE><p>This is pretty good, but Ruby's <i>yield</i> doesn't just yield the default value. In fact, Ruby doesn't really have a "default value" equivalent to <i>$_</i>. <i>yield</i> can take arguments, and those arguments should be passed to the code reference. But this being Perl, we want to support both styles: implicit <i>$_</i> and explicit arguments. So our <i>yield</i> subroutine ends up looking like this:</p><PRE>sub yield (@) {    my @their_args = DB::uplevel_args(1);    if ((!@their_args) or ref $their_args[0] ne "CODE") {        croak "no block given (LocalJumpError)";    }    my @stuff = (@_||$_);    $their_args[0]-&gt;(@stuff);}</PRE><p>But there is a slight problem. If we try out our shiny new <i>yield</i> with the <i>each_args</i> example, we might see something like this:</p><PRE>CODE(0x10774)102030</PRE><p>I must stress again that we're only faking it. We can't rewrite <i>each_arr</i>'s <i>@_</i> array so that the codeblock is squirrelled away for <i>yield</i> and doesn't appear when we call <i>for</i>. The code reference is going to stay part of <i>@_</i> whether you like it or not. So <i>yield</i> needs to be a bit tricky.</p><p>The obvious way to solve this problem in the majority of cases is to simply refuse to call the code reference on itself:</p><PRE>$their_args[0]-&gt;(@stuff)    unless $stuff[0] == $their_args[0];</PRE><p>And that is By And Large Good Enough. The iterators now work the way we expect them to.</p><p>So that's all I've wanted from Ruby so far, and the whole module, <i>rubyisms.pm</i>, is available from CPAN. I'm sure that there'll be more features added as I keep dragging things across from Ruby.</p><p>But we've seen that with the knowledge gained from a relatively simple but relatively obscure technique&#151;the interaction between <i>caller</i> and <i>@we</i> can bend Perl in some interesting and extraordinary directions without mucking about with XS, the Perl internals, or any other difficulty.</p><p>Sometimes, it seems, getting involved in other people's arguments isn't such a bad thing after all.</p><p><b>TPJ</b></p></body></html>