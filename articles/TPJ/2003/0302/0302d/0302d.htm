<html><head><title>Feb03: Amazon.com Wish Lists</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; The Perl Journal--><h1>Amazon.com Wish Lists</h1><p><i>The Perl Journal</i> February 2003</p><h3>By brian d foy</h3><I>brian is the founder of the first Perl Users Group, NY.pm, and Perl Mongers, the Perl advocacy organization. He has been teaching Perl through Stonehenge Consulting for the past five years, and can be contacted at comdog@panix.com.</I><hr><p>Over the holiday, I wanted to check my Amazon.com wish list, which I use to keep track of the books that I would like to read, even if I do not intend to buy them. With Amazon.com web services, I can easily download my wish list in XML format, and with <i>XML::Simple</i>, I can easily parse and access the information. The <i>Text::Template</i> module gives me a flexible way to display the information once I get it.</p><p>Recently, Amazon.com opened its data, which it calls "Properties," to the public through their "Amazon.com Web Services" (http://soap.amazon.com/). Anyone can use these services by signing up for the program and getting a "Developer's Token" that allows them to access the web service. Once you have a token, you can access book, DVD, and author information as well as the results of the many sorts of searches available on the Amazon.com web site. I started using the web service for some publishing clients who wanted to check sales rank and price data for their books, and now I am finding it useful for my personal information as well.</p><p>A Web Service, despite its general name, typically applies to something on a web server that returns XML data. Sometimes this XML result is a Simple Object Access Protocol (SOAP) message, but it can also be an XML/HTTP response. Amazon.com web services allows me to use either. For my wish list, I use the XML/HTTP method, which only requires a URL with the right parameters. This is much easier to use than SOAP for simple tasks.</p><p>Before I can start, I need to find my wish list ID string, which Amazon.com hides in a lot of information in their URLs, including session and user identifiers. If I look at my wish list page, I see a link to "Share Your Wishlist," which has as part of its link "/wishlist/1VGWQEYUDRN9V/." The string after "wishlist" (1VGWQEYUDRN9V) is my wish list ID.</p><p>Once I have my Developer's Token and wish list ID, I can download my wish list information. If I use XML/HTTP, I need to create the URL. The base of the request URL is &lt;URL:http://xml .amazon.com/onca/xml2&gt;. After the base, I form a query string with the information that I have collected; see <A NAME="rt1"><A HREF="0302dt1.htm">Table 1</A>.</p><p>I create the URL with the URL module, using my Amazon.com Associates ID (theperlreview-20); my Developer's Token, which I have in my shell's environment variable AMAZON_DEV_T; the "lite"<i> </i>version of the output; and my wish list ID (1VGWQEYUDRN9V). Amazon.com returns up to ten items in the wish list for each request. The first ten are page one, the next ten are page two, and so on. In this request, I set page to one to get the first ten results. To get all the results, I need to make multiple requests, increasing the page number by one each time, until Amazon.com returns no more results.</p><PRE>my $url = do {    require URI;    my %values = (        t		 =&gt; 'theperlreview-20',        'dev-t'	 =&gt; $ENV{AMAZON_DEV_T},        type		 =&gt; 'lite',        f		 =&gt; 'xml',        page		 =&gt; 1,        WishlistSearch	 =&gt; '1VGWQEYUDRN9V'        );            my $u = URI-&gt;new( 'http://xml.amazon.com/onca/xml2' );      $u-&gt;query_form( %values );    $u-&gt;as_string;    };</PRE><p>I fetch this URL with <i>LWP::Simple</i>, and store the result in the scalar <i>$xml</i>.</p><PRE>use LWP::Simple qw(get);my $xml = get( $url );</PRE><p>The result in <i>$xml</i>, for the "lite" output, is a <i>ProductInfo</i> node containing several <i>Details</i> nodes; see <A NAME="re1"><A HREF="0302de1.htm">Example 1</A>. In this example output, I have replaced long URLs with "..." to show the structure more clearly. The "heavy" output includes much more detailed information on the product, including category names, similar items, and sales rank.</p><p>I can parse this any way that I like, including using <i>XML::Parser</i> or simply using built-in pattern matching and text-manipulation functions. I use <i>XML::Simple</i> to get a hash, which makes the next step easier.</p><PRE>use XML::Simple;my $hash = XMLin( $xml );</PRE><p>The anonymous hash in <i>$hash</i> has a <i>Details</i> key, which is an array of hashes because I have more than one item in my wish list. (If I have only one item in my wish list, the value of the <i>Details</i> key will be just the hash for the product information.)</p><PRE>{'Details' =&gt; [    {    'OurPrice' =&gt; '$10.47',    'ImageUrlLarge' =&gt; '.../2290319740.01.LZZZZZZZ.jpg',    'ReleaseDate' =&gt; 'January, 2003',    'ImageUrlMedium' =&gt; '.../2290319740.01.MZZZZZZZ.jpg',    'Catalog'' =&gt; 'Book',    'Asin' =&gt; '2290319740',    'url' =&gt; '...',    'Manufacturer' =&gt; 'J Ai Lu Editions',    'ListPrice' =&gt; '$14.95',    'ProductName' =&gt; 'Je Parler Francais',    'ImageUrlSmall' =&gt; '.../2290319740.01.THUMBZZZ.jpg',    'Authors' =&gt; {        'Author' =&gt; 'David Sedaris'        }    },    ]}</PRE><p>The <i>Text::Template</i> module gives me a basic framework to hand off data to a presentation layer so I can change the way that I show the information without changing the logic code. I give <i>Text::Template</i>'s <i>fill_in_</i>file() function the filename of the template that I want to use, and pass the data as the value for the HASH key.</p><PRE>use Text::Template qw(fill_in_file);my $Template = 'wish_list-template.txt';print fill_in_file( $Template, HASH =&gt; $wish_list );</PRE><p>Inside the template, <i>Text::Template</i> turns <i>$wish_list</i> into variables. The <i>Details</i> key turns into the array <i>@Details</i> because it has an anonymous array for a value. Each element of <i>@Details</i> is an anonymous hash with keys that are the names of the XML tags. I use a very simple template to print the titles of everything in my wish list. <i>Text::Template</i> evaluates the parts of the file between the braces {} as Perl code. Everything outside of the braces is literal text.</p><PRE>My Amazon.com wish list:{my $string = '';foreach my $product ( @Details )    {    $string .= "Title: $product-&gt;{ProductName}\n";    }$string;}</PRE><p>The template reformats the wish list information, which I print to the screen. In this example, I use plain text, but I can output any format, including HTML.</p><PRE>My Amazon.com wish list:Je Parler FrancaisThe Rise of the Meritocracy1421: The Year China Discovered AmericaThe Declaration of Independence and Other Great 	Documents of American History, 1775-1865 (Dover 	Thrift Editions)Common Sense (Dover Thrift Editions)Democracy in AmericaThe Path to Victory: America's Army and the 	Revolution in Human AffairsBoyd: The Fighter Pilot Who Changed the Art of WarI May Be Wrong but I Doubt ItMy Losing Season</PRE><p>That's it&#151;a couple of Perl modules and a little help from Amazon.com, and I can download my wish list data. With a little work, so can you.</p><p><b>TPJ</b></p></body></html>