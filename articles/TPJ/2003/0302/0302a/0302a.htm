<html><head><title>Feb03: Using <i>PerlObjCBridge</i> to Write Cocoa Applications In Perl</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; The Perl Journal--><h1>Using <i>PerlObjCBridge</i> to Write Cocoa Applications In Perl</h1> <p><i>The Perl Journal</i> February 2003</p><h3>By Kevin O'Malley</h3><I>Kevin is a long-time Macintosh and UNIX developer. He is the author of the upcoming book Mac OS X Programming: A Guide for UNIX Developers (Manning Publications, 2003), on which this article is based. He can be contacted at omalley@umich.edu.</I><hr><p>On March 24, 2001, Apple released its new operating system, called "Mac OS X," to the public. Mac OS X (pronounced "OS Ten") is built on an open-source, UNIX-based core operating system called "Darwin." Mac OS X includes a full set of UNIX commands and tools, and a host of new development frameworks and technologies. One of these is Cocoa, an object-oriented environment for developing native Mac OS X applications. Cocoa provides developers with a rich component framework that greatly simplifies and facilitates the development of Mac OS X applications and GUIs. In fact, Apple recommends that developers use Cocoa when writing new applications for Mac OS X. For more information on Cocoa, see the Cocoa Resources section at the end of the article.</p><p>The latest release of Mac OS X (10.2), called "Jaguar," includes a Perl module called <i>PerlObjCBridge</i>. <i>PerlObjCBridge</i> enables Perl programmers to access Cocoa objects and services from their Perl scripts. This is very exciting news for Perl programmers working on the Mac OS X platform.</p><p>This article presents an introduction to <i>PerlObjCBridge</i> and shows how to use it in a real Perl program.</p><h3><i>PerlObjCBridge</i> Fundamentals</h3><p><i>PerlObjCBridge</i> provides the following functions:</p><p></p><ul>  <li>Enables access to many Objective-C objects from Perl.  <li>Enables Perl scripts to be Cocoa delegates or targets of notifications.  <li>Enables Perl scripts to access Cocoa's Distributed Objects (DO) mechanism, letting Perl objects send and receive messages to and from Objective-C or Perl objects running on different machines.</ul><p>One limitation of <i>PerlObjCBridge</i> is its lack of support for accessing Cocoa GUI objects. This means you cannot use it to construct user interfaces for your Perl scripts. (See http://camelbones .sourceforge.net/ for information about a GUI framework for constructing Cocoa interfaces in Perl.)</p><p>In terms of syntax, Objective-C uses ":" to delimit arguments, which is not legal in Perl. Therefore, the "_" character is used in its place. To access Objective-C objects and methods from Perl, you use the following forms:</p><ul>  <li>Static method (through the class)&#151;ClassName-&gt;method(...args...)  <li>Instance method (through the instance)&#151;$object-&gt;method(...args...)</ul><p>The following code shows a few examples of how to use these constructs:</p><PRE># Accessing a method through its class (static method).$pref = NSMutableDictionary-&gt;dictionary();# Accessing a method through an instance (instance method).$pref-&gt;objectForKey_($key);</PRE><p>One of the more powerful features of <i>PerlObjCBridge</i> is its ability to register Perl objects as recipients of notifications from Cocoa frameworks. For example, <i>PerlObjCBridge</i> automatically provides the stubs, or Objective-C objects, that act as proxies for Perl objects. If you have a Perl object like this:</p><PRE>package Foo;sub new { ... }sub aCallBack { ... }</PRE><p>you register <i>Foo</i> objects to receive <i>NSNotification</i> messages as follows:</p><PRE>$foo = new Foo();NSNotificationCenter-&gt;defaultCenter()-&gt;addObserver_selector_name_object_($foo,"aCallBack", "theNotificationName", undef);</PRE><p>When the event <i>theNotificationName</i> occurs, the Cocoa Foundation sends the <i>aCallBack</i> message to <i>$foo</i>. Behind the scenes, <i>PerlObjCBridge</i> automatically creates a <i>PerlProxy</i> object to stand in for <i>$foo</i> wherever an Objective-C object is expected, as in the observer argument to the <i>addObserver</i> method. Cocoa's DO mechanism enables Cocoa programs to access objects from different programs, possibly running on different machines. You can access DO from <i>PerlObjCBridge</i>, enabling interprocess messaging between Perl objects. Basically, you write Perl scripts that run on different machines&#151;or in different address spaces on the same machine&#151;and that send messages to one another. Doing so enables your scripts to communicate with other scripts by directly calling their methods as if they were part of the same program.</p><p>Let's look at how to apply this knowledge in a Perl script.</p><h3>A Perl-Based PIM Using <i>PerlObjCBridge</i></h3><p>These days, Palm devices are everywhere. They are used to track contacts and schedules, enter information into databases, access e-mail and the Web, and play games. In this example, we'll use software that comes with most UNIX systems to replicate some of this functionally at little or no cost.</p><p>The script, called "pim.pl," uses standard UNIX tools to track contacts, take notes, generate and view calendars, and even keep a list of quotes. The main UNIX programs used are <i>cal</i> and <i>remind</i>. (The <i>remind</i> program is freely available from http://www .roaringpenguin.com/remind/. It does not come with the system, so you will need to download it, compile it, and install it for Mac OS X.) The <i>cal</i> program displays a text-based calendar. If you have never used <i>remind</i>, you are in for a treat. Basically, <i>remind</i> is a calendar generator and reminder program with lots of options and uses. For the complete source code, see http://www.tpj.com/source/.</p><p>The first step in using <i>remind</i> is to create and edit your reminders file, called ".reminders", which is located in your home directory. </p><PRE># The .reminders file.REM 15 November +1 2002 MSG 4-5 Development meetingREM 05 November 2002 *7 MSG 4:00-5:00 AI seminarREM 04 November 2002 *1 until November 06 2002 MSG       Out of office</PRE><p>Entries in this file represent calendar events or reminders. Once you add entries to the file, you run the remind command to process the file. Depending on the options, <i>remind</i> will output everything from a reminder list to a text- or Postscript-formatted calendar. <A NAME="rf1"><A HREF="0302af1.htm">Figure 1</A> shows a text-based calendar generated from the reminders file.</p><p>To view or edit your contact list, the Perl-based pim script opens the file in an editor; to edit tasks, it opens the task file in an editor; and to view tasks, it processes the file and prints a formatted version of the task list.</p><p>The Cocoa classes include a particularly useful set of methods: the <i>writeToFile</i> and <i>stringWithContentsOfFile</i> family of methods. Collectively, these methods let you to take an object, serialize its data to disk, and read the stored data from disk into an object at run time. When used in conjunction with the <i>NSMutableDictionary</i>, a hash data structure, you do not need to deal with formatting or parsing data; it's all done for you. This feature is particularly attractive and is a strong reason to use Cocoa objects in your Perl scripts. This program uses these features to store and access preference settings.</p><p>Application preferences are stored in a preference file, which is a text file formatted as XML. Each key/value pair in the file describes a particular program option. For example, the editor keyword is used to look up the editor that the script uses to open files (contacts-file for the name of the contacts file). See <A NAME="rl1"><A HREF="#l1">Listing 1</A> for an example of the preferences file.</p><p>You can initially create this file either programmatically or by hand. To create it programmatically, you can use elements of the following code fragment:</p><PRE>my $pref = NSMutableDictionary-&gt;dictionary();setPrefVal("editor", "/usr/bin/emacs");setPrefVal("contacts-file", "contacts.txt");writePrefs("pim.prefs");sub setPrefVal {  my ($key, $val) = @_;  $pref-&gt;setObject_forKey_($val, $key);}sub writePrefs {  my ($fName) = @_;  $pref-&gt;writeToFile_atomically_($fName, 1);}</PRE><p>When the script starts, it creates a new, empty <i>dictionary</i> object by calling the static method dictionary from Foundation's <i>NSMutableDictionary</i> class. Next, it populates the dictionary (<i>readPrefs</i>) with key/value pairs from the preference file. To do so, it uses the <i>NSDictionary</i> static method <i>dictionaryWithContentsOfFile</i>. In a single call, it reads the preference file and stores each key/value pair into the <i>dictionary</i> object. This saves you the trouble of creating a new file format and writing code to parse and store the preference values:</p><PRE>my $prefs = readPrefs($PREFS_FILE);sub readPrefs {  my ($fName) = @_;  my($dict) = NSDictionary-&gt;dictionaryWithContentsOf						File_($fName);  if (!defined($dict)) {    logExit("preferences file not read: $PREFS_FILE");    exit;  }  return $dict;}</PRE><p>The rest of the script is quite simple. It goes into an infinite loop in which it displays a menu and handles user selections (see <A NAME="rl2"><A HREF="#l2">Listing 2</A>). To exit the program, press Control-c. The handling code is also straightforward, as demonstrated by the <i>if/elsif</i> block. In both cases, it gets the appropriate value from the dictionary (based on a key) and handles the operation. <A NAME="rf2"><A HREF="0302af2.htm">Figure 2</A> shows the program responding to the Task feature.</p><p>Overall, this script does the job, but it could be improved. The program could be extended to use Cocoa's Distributed Objects mechanism. For example, the script could act as a server running on one machine, and you could access it from another machine to read and update information. Additionally, you could write a Cocoa GUI client that displays the information in an interface while the main handling and storage code runs on the server.</p><p>Another addition would be to add items to your calendar or task list from your e-mail inbox. This functionality would let you send yourself e-mail that goes directly into your PIM. For example, to add a task to your PIM, you could send yourself an e-mail with a special tag (TASK, for example) in the subject. Then, your PIM could read your inbox looking for message subjects with this tag and add the appropriate e-mails to your task list. </p><h3>Summary</h3><p>This article has given you a brief look at <i>PerlObjCBridge</i>, a Perl module that comes installed under Mac OS X 10.2, Jaguar. Use the <i>PerlObjCBridge</i> man page to get more information on its features. Using <i>PerlObjCBridge</i>, Perl programmers can now take advantage of Mac OS X's Cocoa Foundation directly from their Perl scripts. <i>PerlObjCBridge</i> is a good piece of software engineering, providing many more functions than I've discussed here. I hope it will continue to grow and include more features, including the ability to construct Cocoa GUIs from Perl scripts. If you are a Perl programmer working under Mac OS X, take a serious look at <i>PerlObjCBridge</i>.</p><h3>Cocoa Resources</h3><ul>  <li>Apple Computer Inc. <i>Learning Cocoa</i>. Ed. Troy Mott. Sebastopol, CA: O'Reilly, 2001.  <li>Buck, Eric, Donald Yacktman, and Scott Anguish. <i>Cocoa Programming: Programming for the MAC OS X</i>. Indianapolis: Sams, 2001.  <li>Garfinkel, Simson, and Michael K. Mahoney. <i>Building Cocoa Applications</i>. Sebastopol, CA: O'Reilly, 2002.  <li>Hillegass, Aaron. <i>Cocoa Programming for Mac OS X</i>. Boston: Addison-Wesley, 2002.  <li>Cocoa Developer Documentation: "New to Cocoa Programming." http://developer.apple.com/techpubs/macosx/Cocoa/ SiteInfo/NewToCocoa.html.</ul><h3>Acknowledgement</h3><p>Thanks to Doug Wiebe of Apple Computer, the author of the <i>PerlObjCBridge</i>, for his information and insights on this topic, and for some of the code examples that appear in this article.</p><p><b>TPJ</b></p><H4><A NAME="l1">Listing 1</H4><pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN""http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt;&lt;plist version="1.0"&gt;&lt;dict&gt;  &lt;key&gt;prefs-path&lt;/key&gt;  &lt;string&gt;./&lt;/string&gt;  &lt;key&gt;editor&lt;/key&gt;  &lt;string&gt;/usr/bin/emacs&lt;/string&gt;  &lt;key&gt;viewer&lt;/key&gt;  &lt;string&gt;more&lt;/string&gt;  &lt;key&gt;file-path&lt;/key&gt;  &lt;string&gt;./&lt;/string&gt;  &lt;key&gt;contacts-file&lt;/key&gt;  &lt;string&gt;contacts.txt&lt;/string&gt;  &lt;key&gt;tasks-file&lt;/key&gt;  &lt;string&gt;tasks.txt&lt;/string&gt;  &lt;key&gt;words-file&lt;/key&gt;  &lt;string&gt;word_list.txt&lt;/string&gt;  &lt;key&gt;notebook-file&lt;/key&gt;  &lt;string&gt;notebook.txt&lt;/string&gt;  &lt;key&gt;quotes-file&lt;/key&gt;  &lt;string&gt;quotes.txt&lt;/string&gt;&lt;/dict&gt;&lt;/plist&gt;</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing 2</H4><pre>for(;;) {  system("clear");  print "=======================\n";  print "My PIM\n";  print "=======================\n";  print "0. Edit preferences file\n";  print "1. Edit reminders\n";  print "2. Edit contacts\n";  print "3. Edit tasks\n";  print "4. Show tasks\n";  print "5. Generate calendar (ps)\n";  print "6. View calendar (txt)\n";  print "7. Print calendar's";  print "8. Show system cal\n";  print "9. Show today's reminders\n";  print "-------------------\n";  print "-1. Edit word list\n";  print "-2. Edit notebook\n";  print "-3. Edit quotes\n";  print "-4. View quotes\n";  print "=======================\n";  print "-&gt; ";  my $s = &lt;STDIN&gt;;  chop($s);  if ($s == 0) {    system(getPrefVal("editor") . " " . $PREFS_FILE);  }  elsif ($s == 1) {  system(getPrefVal("editor") . " ~/.reminders");}</pre><P><A HREF="#rl2">Back to Article</A></P></body></html>