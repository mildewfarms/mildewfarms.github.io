<html><head><title>May03: Tracking Finances with <i>WWW::Me</i>chanize and <i>HTML</i>::Parser</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; The Perl Journal--><h1>Tracking Finances with <i>WWW::Me</i>chanize and <i>HTML</i>::Parser</h1><p><i>The Perl Journal</i> May 2003</p><h3>By Simon Cozens</h3><I>Simon is a freelance programmer and author, whose titles include Beginning Perl (Wrox Press, 2000) and Extending and Embedding Perl (Manning Publications, 2002). He's the creator of over 30 CPAN modules and a former Parrot pumpking. Simon can be reached at simon@ simon-cozens.org.</I><hr><p>One of the things I like about my bank is that it has a very comprehensive online banking service. I can fire up a web browser, log in, and transfer money, pay bills, check balances, and so on.</p><p>One of the things I really hate about it, though, is that this requires me to fire up a web browser, log in, and so on. So one of the first things I did when dealing with the bank was to write an <i>LWP::UserAgent-</i>based module that handled all the quirks of logging in and doing trivial tasks like checking balances and getting statements. I had <i>Finance::Bank::LloydsTSB</i>, and I was happy.</p><p>Unfortunately, the bank recently made matters worse by insisting on another layer of security. Now, don't get me wrong, I'm not averse to more security on my bank account per se, but I am averse to having my nice labor-saving module break.</p><p>However, I realized that this would give me the opportunity to rewrite <i>F::B::LloydsTSB</i> in terms of the <i>WWW::Mechanize</i> module, and also give me an opportunity to tell you how I did it.</p><h3><i>WWW::Mechanize</i></h3><p>But first, what is <i>WWW::Mechanize</i>, and why is it better than <i>LWP::UserAgent</i>? <i>WWW::Mechanize</i>, written by Andy Lester, is a fork of Kirrily Robert (Skud)'s <i>WWW::Automate</i>. Skud wrote <i>WWW::Automate</i> in order to help test web-based applications. The idea was to have a subclass of <i>LWP::UserAgent</i> that did more work behind the scenes, which would enable it to feel like it was emulating a web browser, rather than just a dumb web client.</p><p>For instance, it knows about the forms on a page, and can help you fill them in; it knows about following links, hitting a back button, reading the title of a page, and so on.</p><p>Let's take a simple example. We'll visit the Perl home page, http://www.perl.com/, follow the first link we find, and see where we end up:</p><PRE>use WWW::Mechanize;my $agent = WWW::Mechanize-&gt;new();$agent-&gt;get("http://www.perl.com/");$agent-&gt;follow(0);print $agent-&gt;title, " : ", $agent-&gt;uri, "\n";</PRE><p>(As it happens, it's a link back to www.perl.com, but hey.)</p><p>As <i>WWW::Mechanize</i> is a subclass of <i>LWP::UserAgent</i>, all the familiar methods are there&#151;<i>new</i> creates a new user agent and <i>get</i> downloads a page.</p><p>However, there's also the new <i>follow</i> method, which takes the number of a link on the page, starting from zero; 0 is the first link. <i>Mechanize</i> also stores the URL of the page it's currently visiting, and we can retrieve that with the <i>uri </i>method. It also knows how to parse the HTML for the page and extract the HTML title, which we retrieve with <i>title</i>.</p><h3>Examining the Lloyds Site</h3><p>To work out how we'd make <i>Mechanize</i> automate access to our web site, we first need to look at how we'd do so in a browser. As it turns out, we'll find some unpleasant secrets along the way.</p><p>We start by going to the site's entry URL, https://online .lloydstsb.co.uk/customer.ibc/. This gives us the main login box, prompting us for a username and password. We fill this in, and post the form back to the site (see <A NAME="rf1"><A HREF="0305df1.htm">Figure 1</A>).</p><p>Once we've done that, we come up against the new "memorable information" page, presumably created in order to stop people like us writing programmatic interfaces to log into the system. As well as a password, we've supplied the bank with a nine-character piece of information, and the new page presents us with a form with three drop-down menus, and asks us to select certain characters from the memorable information phrase (see <A NAME="rf2"><A HREF="0305df2.htm">Figure 2</A>).</p><p>Once we post that back, we're finally logged in. From the post-login page, the account balances are stored in a table that we'll parse out using <i>HTML::Parser</i>&#151;more on that later. First, we'll translate this complicated login sequence into <i>WWW::Mechanize</i> code.</p><h3>Mechanizing the Login</h3><p>The first phase is obvious&#151;we want to get the front page, fill in the form, and click the "log in" button. Here's what this code looked like originally:</p><PRE>my $orig_r = $ua-&gt;get 	     ("https://online.lloydstsb.co.uk/customer.ibc");croak $orig_r-&gt;error_as_HTML unless $orig_r-&gt;is_success;my $orig = $orig_r-&gt;content;my $key;$orig =~ /name="Key" type="HIDDEN" value="(\d+)"/	or croak "Couldn't parse key!";$key = $1;my $check = $ua-&gt;post 	    ("https://online.lloydstsb.co.uk/customer.ibc", {	Key =&gt; $key,	LOGONPAGE =&gt; "LOGONPAGE",	UserId1 =&gt; $opts{username},	Password =&gt; $opts{password},   });</PRE><p>As you can see, a lot of this is handling the hidden form fields that the front page provides. With <i>Mechanize</i>, all of that is taken away as the forms are preparsed and the form values persist nicely:</p><PRE>$ua-&gt;get("https://online.lloydstsb.co.uk/customer.ibc");croak $ua-&gt;res-&gt;error_as_HTML unless $ua-&gt;res-&gt;is_success;$ua-&gt;field(UserId1  =&gt; $opts{username});$ua-&gt;field(Password =&gt; $opts{password});$ua-&gt;click;</PRE><p>Much more Perlish! This is what I like about <i>WWW::Mechanize</i>; it allows us to code at the appropriate level&#151;we're simply saying what we want done, instead of how we want to do it. We don't want to get bogged down in the mechanics, we just want to fill in two fields and click the button.</p><p>Another useful feature is that we don't need to explicitly store the <i>HTTP::Response</i> object returned by <i>get</i>; <i>Mechanize</i> automatically stashes that away for us, as well as the current <i>HTTP::Request</i>.</p><p>Unfortunately, this doesn't work. It would, were it not for this little snippet of HTML:</p><PRE>&lt;input type="UserId1" name="UserId1" ...</PRE><p><i>Mechanize</i> uses <i>HTML::Form</i>, which quite rightly gets very distraught with the idea of a <i>UserId1</i>-type input. Most browsers render this as a text input, and we should do the same. Hence we have to get a little dirty with the <i>HTML::Form</i> object. First, we find the object that represents the user ID form input:</p><PRE>my $input = $ua-&gt;current_form-&gt;find_input("UserId1");</PRE><p>This is currently an ignored input, an instance of <i>HTML::Form::IgnoreInput</i>. We want to change it into a text input:</p><PRE>$input-&gt;{type} = "text";bless $input, "WWW::Form::TextInput";</PRE><p>And now we should find ourselves at a page with the three drop-down menus on it. If not, we've probably failed to login. The three characters it wants are stored in <i>ResponseKey0</i> through <i>ResponseKey2</i>, so we extract those from our memorable information phrase and put them back in the form:</p><PRE>for (0..2) {    my $key;    eval { $key = $ua-&gt;current_form-&gt;find_input 	    ("ResponseKey$_")-&gt;value; };    croak "Couldn't log in; check your password and username" 	if $@;    my $value = substr(lc $opts{memorable}, $key-1, 1);    $ua-&gt;field("ResponseValue$_" =&gt; $value);}</PRE><p>Now this happens to return a redirect (it's funny how bank sites tend to bring out all the interesting edge cases in screen scraping...), so we go to the location it specifies:</p><PRE>$response = $ua-&gt;click;$ua-&gt;get($response-&gt;{_headers}-&gt;{location});</PRE><p>And now, finally, we're logged in! Now what?</p><h3>Extracting the Account Balances</h3><p>The account balances are stored in a table on the front page. We need to parse the HTML for the table and extract the account name, number, and the balance. Thankfully, Johnathan Stowe has written a very neat little <i>HTML::Parser</i>-based table parser in his collection of <i>HTML::Parser</i> examples (http://www.gellyfish.com/htexamples/), and so we steal his code pretty much wholesale.</p><p><i>HTML::Parser</i> works by calling various methods every time it sees certain elements of the HTML document&#151;a method for an opening tag, one for a closing tag, and one for any text in the middle.</p><p>We want to collect the data out of a table, so we want to be concerned with the <i>table</i>, <i>tr</i>,<i> </i>and <i>td</i> tags. In particular, when we see a <i>tr</i> tag, we want to start a new row; when we see a <i>td</i> tag, we start a new entry:</p><PRE>sub start {   my ($self,$tag,$attr,$attrseq,$orig) = @_;   if ($tag eq 'table') { $intable++;  $self-&gt;{Table} = []; }   if ($tag eq 'tr')    { $inrecord++; $self-&gt;{Row}   = []; }   if ($tag eq 'td')    { $infield++;  $self-&gt;{Field} = ''; }}</PRE><p><i>HTML::Parser</i> actually passes in a lot of things we don't really care about, such as the attributes; we're only interested in storing data structures for the table, row, and cell.</p><p>Now, if we're inside a table and a row and a cell, we want to collect any text we see into the current field:</p><PRE>sub text {   my ($self,$text) = @_;   if ($intable &amp;&amp; $inrecord &amp;&amp; $infield) { $self-&gt;{Field} .= $text; }}</PRE><p>We have to concatenate onto <i>$self-&gt;{Field}</i>, as the cell may contain other tags. If we have:</p><PRE>&lt;TD&gt; Hello, &lt;B&gt;esteemed&lt;/B&gt; visitor&lt;/TD&gt;</PRE><p>then <i>text</i> will actually be called three times, and <i>start </i>and <i>end</i> will be called for the <i>B</i> tag as well. Because we want all three pieces of text instead of just the last one, we concatenate them all together.</p><p>The real hard work is done by the end tag processor. We've been gathering text into <i>$self-&gt;{Field}</i>, and when we come to the end of our cell, the <i>&lt;</i>/td&gt; tag, we push the contents we've accumulated into the current row; similarly, when we come to the end of a row, we push that row onto the table:</p><PRE>sub end {   my ($self,$tag) = @_;   if ($tag eq 'table') { $intable&#151;; }   if ($tag eq 'td')    { $infield&#151;;                            push @{$self-&gt;{Row}}, $self-&gt;{Field}; }   if ($tag eq 'tr')    { $inrecord&#151;;                          push @{$self-&gt;{Table}}, $self-&gt;{Row}; }}</PRE><p>And, well, that's it; once this package inherits from <i>HTML::Parser</i> like so:</p><PRE>package TableThing;use strict;use vars qw(@ISA $infield $inrecord $intable);use base 'HTML::Parser';</PRE><p>we will be able to use it to parse our tables. Once we've logged in, we can say:</p><PRE>my $table_parser = TableThing-&gt;new;$table_parser-&gt;parse($ua-&gt;content); </PRE><p>and <i>$table_</i>parser will now contain a data structure representing the table of accounts. Extracting the balances is now a matter of ordinary Perl data-structure munging.</p><h3>Putting It Together</h3><p>Let's now put this lot together into a module, <i>Finance::Bank ::LloydsTSB</i>. We'll start with the ordinary module preamble, and set up our browser object:</p><PRE>package Finance::Bank::LloydsTSB;use strict;use Carp;our $VERSION = '1.2';use WWW::Mechanize;our $ua = WWW::Mechanize-&gt;new(    env_proxy =&gt; 1,    keep_alive =&gt; 1,    timeout =&gt; 30,);</PRE><p>Our constructor will be called <i>check_balance</i> since it will return a bunch of account objects. We make sure that it has the requisite parameters, and bless that into an object:</p><PRE>sub check_balance {    my ($class, %opts) = @_;    croak "Must provide a password"         unless exists $opts{password};    croak "Must provide a username"         unless exists $opts{username};    croak "Must provide memorable information"         unless exists $opts{memorable};    my $self = bless { %opts }, $class;And now comes the <i>Mechanize</i> code we established before:$ua-&gt;get("https://online.lloydstsb.co.uk/customer.ibc");my $field = $ua-&gt;current_form-&gt;find_input("UserId1");$field-&gt;{type}="input";bless $field, "HTML::Form::TextInput";$ua-&gt;field(UserId1  =&gt; $opts{username});$ua-&gt;field(Password =&gt; $opts{password});$ua-&gt;click;for (0..2) {    my $key;    eval { $key = $ua-&gt;current_form-&gt;find_input 	    ("ResponseKey$_")-&gt;value; };    croak "Couldn't log in; check your password and username" if $@;    my $value = substr(lc $opts{memorable}, $key-1, 1);    $ua-&gt;field("ResponseValue$_" =&gt; $value);}my $response = $ua-&gt;click;$ua-&gt;get($response-&gt;{_headers}-&gt;{location});</PRE><p>Getting the data out of the table turns out to be slightly tricky; first, we extract those table rows that contain nonwhitespace:</p><PRE>my @table = @{$foo-&gt;{Table}};@table = grep { grep { s/&amp;nbsp;//g; s/\s{2,}//g; /\S/ } @$_ } @table;</PRE><p>The top row is a header, so we get rid of that:</p><PRE>shift @table;</PRE><p>And now we look for cells that contain nonwhitespace:</p><PRE>for (@table) {    my @line = grep /\S/, @$_;</PRE><p>The balance is the last cell in the line and is specified as a number, followed by either <i>CR</i> for credit or <i>DR</i> for overdrawn, so we fix that up to be a real number:</p><PRE>    my $balance = pop @line;    $balance =~ s/ CR//;    $balance = -$balance if $balance =~ s/ DR//;</PRE><p>We can extract the other components of the table directly and bless them into the <i>Finance::Bank::LloydsTSB::Account</i> class. We'll also throw in a link to the current <i>$self</i> because, although it's not used at the moment, we can later use this for reconfirming the password when we make transfers or payments:</p><PRE>    push @accounts, (bless {        balance    =&gt; $balance,        name       =&gt; $line[0],        sort_code  =&gt; $line[1],        account_no =&gt; $line[2],        parent     =&gt; $self    }, "Finance::Bank::LloydsTSB::Account");}return @accounts;</PRE><p>And that's basically our module. All that remains is to provide accessors for the <i>name</i>, <i>sort_code</i>, <i>account_no</i>, and <i>balance</i>, and we do this extremely lazily:</p><PRE>package Finance::Bank::LloydsTSB::Account;sub AUTOLOAD { my $self=shift; $AUTOLOAD =~ s/.*:://; 	       $self-&gt;{$AUTOLOAD} }</PRE><p>So before we know it, we've written an interface to our online banking system. Interestingly, even though we added another screen to go through in the form of our memorable information page, the module ended up being four lines shorter than the previous incarnation&#151;this was directly due to changing from <i>LWP::UserAgent</i> to <i>WWW::Mechanize</i> and programming at a more appropriate level.</p><p>I've found <i>WWW::Mechanize</i> useful for hacking up all kinds of screen-scraping code, from simple tests of web-based services right up to full-featured CPAN modules as we've seen in this article. <i>Finance::Bank::LloydsTSB</i> is available from CPAN, and has spawned several other online banking access modules, many of which switched to <i>Mechanize</i> much earlier than I did. I hope from this article you've gained some impression of how to go about writing something to interface to your own banking service, and an idea of how to use <i>WWW::Mechanize</i> in order to automate web access from Perl.</p><p><b>TPJ</b></p></body></html>