<html><head><title>May03: Data Manipulation & Perl Command-Line Options</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; The Perl Journal--><h1>Data Manipulation &amp; Perl Command-Line Options</h1><p><i>The Perl Journal</i> May 2003</p><h3>By Andy Lester</h3><I>Andy manages programmers for Follett Library Resources. He can be contacted at andy@petdance.com.</I><hr><p>In his article "Something For Nothing" (<i>TPJ</i>, March 2003), Simon Cozens talked about using the tools on CPAN to avoid reinventing the wheel. Even without CPAN, Perl itself provides a number of command-line options that do the heavy lifting for many data- and file-manipulation tasks. In this article, I'll provide an overview of Perl's most useful and commonly used data-manipulation options.</p><h3><i>-e</i> Command</h3><p>The most useful way to use the command-line options is by writing Perl one-liners right in the shell. The <i>-e</i> option is the basis for most command-line programs. It accepts the value of the parameter as the source text for a program:</p><PRE>$ perl -e'print "Hello, World!\n"'Hello, World!</PRE><p>Since this is a single statement in a block, you can omit the semicolon. Also, when the <i>-e</i> option is used, Perl no longer looks for a program name on the command line. This means you can't mix code with <i>-e</i> and a program file.</p><p>The <i>-e</i> option is repeatable, which lets you create entire scripts on the command line:</p><PRE>$ perl -e'print "Hello, ";' -e'print "World!\n"'Hello, World!</PRE><p>When chaining together multiple <i>-e</i> options, make sure you keep your semicolons in the right place. I reflexively put semicolons in my <i>-e</i> lines just for safety's sake, even if it's not strictly necessary because there's only one <i>-e</i> option.</p><p>With the <i>-e</i> option, any shell window becomes a Perl IDE. Use it as your calculator to figure out how many 80-line records are in a megabyte:</p><PRE>$ perl -e'print 1024*1024/80, "\n"'  13107.2</PRE><h3>Escaping Shell Characters</h3><p>When you're creating command-line programs, it's important to pay attention to quoting issues. In all my examples, I've quoted with single quotes&#151;not double quotes&#151;for two reasons. First, I want to be able to use double quotes inside my programs for literals, and double quotes don't nest in the shell. Second, I have to prevent shell interpolation, and single quotes make it easy. For example, if I use double quotes, then</p><PRE>$ perl -MCGI -e"print $CGI::VERSION"</PRE><p>gets the <i>$CGI</i> interpolated as a shell variable. Consequently, unless you have a shell variable called <i>$CGI</i>, Perl sees</p><PRE>print ::VERSION</PRE><p>You can escape the shell variables with a backslash:</p><PRE>$ perl -MCGI -e"print \$CGI::VERSION"</PRE><p>but that gets to be tough to maintain. That's why I stick with single quotes:</p><PRE>$ perl -MCGI -e'print $CGI::VERSION'</PRE><p>Windows has slightly different quoting issues. Windows doesn't have shell variable interpolation, so there's no need for escaping variables with dollar signs in them. On the other hand, you can use only double quotes under Windows, which can be a challenge if you want to use double quotes in your program. Under Windows, your "Hello, World" would look like this:</p><PRE>C:\&gt; perl -e"print \"Hello, World!\n\""</PRE><p>The inner double quotes are escaped with backslashes.</p><h3>The Diamond Operator</h3><p>Perl's diamond operator, &lt;&gt;, has a great deal of magic built into it, making operations on multiple files easy.</p><p>Have you ever written something like this:</p><PRE>for my $file ( @ARGV ) {    open( my $fh, $file ) or die "Can't open $file: $!\n";    while ( my $line = &lt;$fh&gt; ) {       # do something with $line    }    close $fh; } $ perl myprog.pl file1.txt file2.txt file3.txt</PRE><p>so that your program can operate on three files at once? Use the diamond operator instead. Perl keeps track of which file you're on, and opens and closes the filehandle as appropriate. With the diamond operator, it's as simple as:</p><PRE>while ( my $line = &lt;&gt; ) {    # do something}</PRE><p>Perl keeps the name of the currently open file in <i>$ARGV</i>. The <i>$.</i> line counter does not reset at the beginning of each file. </p><p>The diamond operator figures prominently in much Perl command-line magic, so it behooves you to get comfortable with it.</p><h3><i>-n</i> and <i>-p</i>: Automatic Looping Powerhouses</h3><p>The <i>-n</i> and <i>-p</i> options are the real workhorse options. They derive from the Awk metaphor of "Do something to every line in the file," and work closely with the diamond operator.</p><p>The following program prepends each line with its line number:</p><PRE>while (&lt;&gt;) {    $_ = sprintf( "%05d: %s", $., $_ );    print;  # implicitly print $_}</PRE><p>The construct of "Walk through a file, and <i>print $_</i> after you do some magic to it" is so common that Perl gives us the <i>-p</i> option to implement it for us. The previous example can be written as:</p><PRE>#!/usr/bin/perl -p$_ = sprintf( "%05d: %s", $., $_ );</PRE><p>or even shorter as:</p><PRE>$ perl -p -e'$_ = sprintf( "%05d: %s", $. $_ )'</PRE><p>The<i> -n</i> option is just like <i>-p</i>, except that there's no print at the bottom of the implicit loop. This is useful for grep-like programs when you're only interested in selected information. You might use it to print only commented-out lines from your input, defined as beginning with optional whitespace and a pound sign:</p><PRE>$ perl -n -e'print if /^\s*#/'</PRE><p>The next program prints every numeric value that looks like it's part of a dollar value, as in "$43.50."</p><PRE>#!/usr/bin/perl -nwhile ( /\$(\d+\.\d\d)/g ) {    print $1, "\n";}</PRE><p>This <i>while</i> loop is inside the implicit <i>while(&lt;&gt;)</i> loop. If you want to do something before or after your main <i>while()</i> loop, use BEGIN and END blocks. For example, to total up all those dollar values:</p><PRE>#!/usr/bin/perl -nBEGIN { $total=0 }END { printf( "%.2f\n", $total ) }while ( /\$(\d+\.\d\d)/g ) {    $total += $1;}</PRE><p>The order of the BEGIN and END blocks doesn't matter, so don't worry about having them in the right order. You can specify them with the <i>-e</i> option, too. Here's a quick one that I used while writing this article to strip verbatim paragraphs from POD:</p><PRE>$ perl -n -e'BEGIN {$/=""}; print unless /^\s+/;' article.pod</PRE><p>If you want an empty <i>while</i> loop with <i>-n</i> or <i>-p</i>, you still must specify the <i>-e</i> option, or else Perl waits for the body of the loop to be entered on standard input. Using <i>-e1</i> gives Perl a dummy loop body that does nothing.</p><h3><i>-l</i>: Line-Ending Handling</h3><p>When you're working with lines in a file, you'll find you're doing lots of chomping and <i>print $something, "\n"</i>. Perl has the <i>-l </i>(dash el) option to take care of this for you.</p><p>In the simplest sense, adding <i>-l</i> when you're using <i>-n</i> or <i>-p</i> automatically does a chomp on the input record, and adds a <i>"\n"</i> after everything you print. It makes command-line one-liners much easier, as in:</p><PRE>perl -l -e'print substr($_,0,40)'</PRE><p>This example only shows the first 40 characters of each line in the input, whether or not the line is longer than 40 characters, not counting the line-ending <i>"</i>\n". For command-line programmers, <i>-l</i> is a godsend because it means you can use <i>print $foo</i> instead of <i>print $foo,"</i>\n" to get the results you want.</p><p>The mechanics of how the <i>print ... "\</i>n" happens are a little more complex. The <i>-l</i> actually sets <i>$</i>\, the output record separator, to <i>$</i>/, the input record separator. You can override this by specifying the octal value for <i>$/</i> on <i>-l</i>. For instance, if you wanted to have all output lines have a Ctrl-M as the record terminator, specify <i>-l015</i> (that's "dash el zero one five").</p><h3><i>-i</i>: Edit in Place</h3><p>All the options you've learned so far are great for writing filters, where a number of files or standard input get fed out to standard output. Unfortunately, you're left to do the foo-move dance, as in:</p>perl -p -e"slick code" input.txt &gt; foomv foo input.txt<p>Perl comes to the rescue again with the <i>-i</i> option. Adding <i>-i</i> tells Perl to edit your files in place, so you can replace the previous example with</p><PRE>perl -p -i -e"slick code" input.txt</PRE><p>You can tell Perl to keep a copy of the original file(s) by specifying a string to tack on to the end of the file. Common examples are <i>-i~</i> or <i>-i.bak</i>. Perl doesn't treat ".bak" as an "extension" in the sense of replacing one extension with another:</p><PRE>perl -i.bak input.txt</PRE><p>leaves the original file called "input.txt.bak." Of course, the <i>-i</i> option does the right thing if you specify multiple files by creating a backup file for each of the files processed.</p><h3><i>-0</i>[octal]: Specify Input Record Separator</h3><p>Often when working on the command line, you'll want to specify your input record separator. Although this is possible with <i>e'BEGIN {$/=...}'</i>, it's easier with the <i>-0</i> option. (That's dash-zero, not dash-oh.) To specify an input record separator of <i>chr(13)</i>, use <i>-015</i>. Two special values for the <i>-0</i> option are <i>-00</i> for paragraph mode, equiavlent to <i>$/=""</i>, and <i>-0777</i> to slurp entire files, equivalent to <i>$/=undef</i>.</p><p>The earlier example for filtering POD paragraphs:</p><PRE>$ perl -n -e'BEGIN {$/=""}; print unless /^\s+/;' article.pod</PRE><p>can now be shortened to:</p><PRE>$ perl -n -00 -e'print unless /^\s+/;' article.pod</PRE><h3><i>-a</i> and <i>-F</i>: Autosplit Input Records</h3><p>The <i>-a</i> and <i>-F</i> options only work with <i>-n</i> and <i>-p</i>. Specifying <i>-a</i> tells Perl to run <i>@F=split</i> on your input line. Without the <i>-F</i> option, this means breaking up the input line on whitespace, which is most handy for log files. If you don't specify the <i>-l</i> option, your final element in <i>@F</i> has a <i>"\n"</i> at the end of it, which is probably not what you want.</p><p>Here's a quick way to count the bytes that your Apache server has sent out:</p><PRE>$ perl -l -a -n -e'$n+=$F[9];END{print $n}' access_log</PRE><p>Each line of the Apache log file is broken up on whitespace, and the number of bytes is the 10th field in the line.</p><p>If you don't want to split on whitespace, specify the regex to use with the <i>-F</i> option. This example walks through the /etc/passwd file, printing all usernames that have a login shell. The fields in /etc/passwd are separated by colons, with the user's name as the first field and login shell as the last.</p><PRE>perl -l -n -a -F: \    -e'print $F[0] unless $F[-1] eq "/bin/false"' /etc/passwd</PRE><p>Even though there are no slashes here, <i>-F:</i> still means that the regex is /:/.</p><h3>Option Stacking</h3><p>If you want to make the most of your keystrokes on the command line, you may want to stack your options. Single-character options may be combined with the following option. For example, our /etc/passwd-processing examples that start:</p><PRE>perl -l -n -a -F: -e'....'</PRE><p>can be written as:</p><PRE>perl -lnaF: -e'....'</PRE><p>I don't recommend combining options because it adds a layer of complexity for the small benefit of saving a few keystrokes. There are also pitfalls when combining options, especially with  the <i>-i </i>option. For example, say you have a program where you're editing a file in place to truncate each line to 40 characters:</p><PRE>$ perl -p -i -l -e'$_=substr($_,0,40)' myfile.txt</PRE><p>This works just fine. Now, combine those options overoptimistically into:</p><PRE>$ perl -pil -e'$_=substr($_,0,40)' myfile.txt</PRE><p>The <i>-p</i> option is just fine, but now you've told the <i>-i</i> options to append the letter "l" at the end of the backup file's name, and lost the <i>-l</i> functionality of handling line endings. The results aren't pretty.</p><h3>-[<i>mM</i>][-] Module</h3><p><i>-m</i> and <i>-M</i> are the module-loading options. They obviate the need to have a <i>-e'use ModuleName;'</i>.</p><p>The <i>-mModuleName</i> performs a <i>use ModuleName ();</i> before your program executes. <i>-MModuleName </i>is the same, but without the parentheses. The difference can be subtle, depending on the import semantics of the module you're importing, as we'll see below. You can also do a "no ModuleName" with <i>-M-ModuleName</i>.</p><p>The <i>-M</i> option is also a handy way to find out if a module is installed, and what version. Want to see which version of the CGI module you have installed?</p><PRE>$ perl -MCGI -le'print $CGI::VERSION'2.89</PRE><p>Of course, if you don't have the module installed, Perl will give an error.</p><p>Many modules have specific tricks built in for use on the command line. Probably the most common example is the CPAN module, where you can do:</p><PRE>$ perl -MCPAN -e'install "Module::Name"'</PRE><p><i>Text::Autoformat</i> exports the <i>autoformat</i> function by default, making it easy to write a one-liner to format a block of text from standard input:</p><PRE>$ perl -MText::Autoformat -e'autoformat'</PRE><h3>Applying What You've Learned</h3><p>With all these marvelous file-mangling command-line options at your disposal, you have a great deal of power at hand. For instance, a program to convert standard line endings to the Mac's Ctrl-M takes only 24 characters:</p><PRE>$ perl -i.bak -l015 -pe1 *.txt</PRE><p>A global search and replace of all occurences of "FOO" to "BAR" in .html files in a directory is as easy as:</p><PRE>$ perl -i -pe's/FOO/BAR/g' *.html</PRE><h3>Wrapping Up</h3><p>A few final notes about command-line options: Perl respects command-line options on the <i>#!perl</i> line of your script, so a script that you write as:</p><PRE>$ perl -i -pe's/FOO/BAR/g'</PRE><p>could also be written as:</p><PRE>#!/usr/bin/perl -i -ps/FOO/BAR/g;</PRE><p>Even in operating systems that don't use the <i>#!perl</i> line (like Windows), Perl still checks for it and will respect the options.</p><p>For future reference, if you don't have this article handy, you can run <i>perl -h</i> to get an alphabetical list of options, or run <i>perldoc perlrun</i> for the manpage.</p><p>Now go forth with your newfound power and keep getting something for nothing.</p><p><b>TPJ</b></p></body></html>