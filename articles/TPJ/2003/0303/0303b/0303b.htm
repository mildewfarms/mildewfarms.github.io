<html><head><title>Mar03: Writing Multilingual Sites With mod_perl and Template Toolkit</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; The Perl Journal--><h1>Writing Multilingual Sites With mod_perl and Template Toolkit</h1><p><i>The Perl Journal</i> March 2003</p><h3>By Stas Bekman and Eric Cholet</h3><I>Eric and Stas are the authors of the upcoming book Practical mod_perl (O'Reilly and Associates). Eric runs his own consulting business, Logilune, in Paris and can be reached at cholet@logilune.com. Stas is sponsored by TicketMaster to work on mod_perl development and can be reached at stas@ stason.org.</I><hr><p>Before you search for a solution for your multilingual site, you have to figure out what kind of service you are going to provide: dynamic or static. If the pages are static, you need to evaluate whether there will be many pages to maintain or just a few. If you have only a few pages, the easiest solution is to just prepare each page in each language and forget about it.</p><p>If you have many pages, it's pretty much the same whether your pages are dynamic or static: Manual maintenance of many pages is time consuming and error prone&#151;in a word, ineffective. Therefore, the correct solution is to approach the problem as if it were a dynamic site, and generate static pages. Template Toolkit (http:// www.template-toolkit.org/) provides a utility program called "<i>ttree</i>" that creates static pages from dynamically generated output. From now on, we will assume that you are developing a dynamic site.</p><h3>User Language Detection</h3><p>Another important question is the process of figuring out what language should be used when presenting the content. The following algorithm tries to answer this question:</p><p></p><p>1.	Separate users into two groups: those who are visiting the site for the first time, and those who have previously visited the site.</p><p>2.	If you use cookies to track users (or some other mechanism that stores the information on the client side), and a user connects from the same machine/account that was used when previously accessing your service, you should already know the language preferences: This bit of information can be stored in the cookie, thereby answering the question of language detection for the second group of users.</p><p>3.	If you don't use cookies or some other mechanism to track users, it probably doesn't matter whether they have accessed the site beforehand because you have no way to tell what their language preferences are.</p><p>4.	If users have registered with your service, their language preference will be known after they have logged in, since preferences can be stored on the server side. However, the problem is that you need to know the user's language to display the login form.</p><p>5.	You can try to figure out the user's language by deducing it from the user's country. One way to determine the user's country is by doing a reverse DNS lookup on the client IP address. This yields the user's computer name. You can then use the top level domain (TLD) to make some reasonable assumptions about the language: Chances are, most users in the .fr domain can read French, for example. Since many hosts do not have correct reverse DNS mapping, you might also be tempted to deduce the country from the IP address itself. However, this approach is due to fail in many cases: There are plenty of users whose visible IP address is outside their country; for example, AOL users worldwide use AOL proxies located in the United States.</p><p></p><p>So, we are back to the first group of users&#151;those we know nothing about. We must provide them a way to choose a language. The best method is to present a page with all available languages, with each language name written in that language. Each name is linked to the version of the service with content presented in that language.</p><p>We can go a little bit further and try to make an intelligent guess of the preferred language. This guess is made by looking at the <i>Accept-Language</i> header sent by most browsers. Localized versions of modern browsers set up the preferred language at install time. If users knows that it's possible to adjust the language preference in their browser, there is a chance that they will. For example they might set the following preferences:</p><p>German</p><p>English-US</p><p>French</p><p>which might mean the following: My preferred language is German. I also understand American English to some extent, and I know a little bit of French. (Of course, a user might know all three languages perfectly, but still prefer one language over another).</p><p>When a browser sends a request to a server, it generates the following header:</p><p>Accept-Language: de,en-us;q=0.7,fr;q=0.3</p><p>where each language is separated by a comma. In some browsers, the preference level can also be specified for alternate languages. So in this example, I've marked American English as 70 percent and French as 30 percent.</p><p>You can  parse this header manually, but a better approach is to use standard CPAN modules. If you are using mod_perl, you can use the <i>Apache::Language</i> module; otherwise, use the all-purpose <i>HTTP::Negotiate</i> module bundled into the <i>libwww</i> distribution.</p><p>Browsers bundled with OS or ISP packages are usually preconfigured with the language of the country the package was issued in. So if users aren't computer savvy, chances are that the default language setting will be correct. If you have accepted this header, you may want to try your luck and present the top of the first page using the language derived from the header. But you still have to give users an option to change the language, since the browser setting might be incorrect for the particular user.</p><p>Remember that <i>Accept-Language</i> is useful for making your service more user friendly and sparing yourself the hassle of picking the right language, but it doesn't come as a replacement for the standard way of presenting the available languages.</p><p>At this point, we know the user's preferred language. In the case of a dynamic site, we proceed with generating the content. Otherwise, we simply direct the user to the right static content.</p><h3>Generating the Content</h3><p>When dynamic content is generated, at least two basic ingredients are used:</p><ul>  <li>Invariant data: page headers and footers, side navigation, and other table information that is always the same.  <li>Variant data: data that is not known <i>a priori</i>, which depends on the user or some other input.</ul><p>When a site is generated in a single language, these two items are easily implemented: Either use templates for invariant data or hardcode it into the code, and retrieve the variant data from the database or through some other method. When the requirements include multilingualism, these tasks become more complex. I'm going to talk about each of them separately.</p><h3>Fetching Dynamic Data</h3><p>We separate the dynamic data requests into two groups: those that require user input and those that don't. A site search feature falls into the first category, whereas browsing the site belongs to the second one.</p><h3>Searching</h3><p>Let's use a movie server and a user whose preferred language is French as an example. Our user searches a movie by entering search keywords in a search box.</p><p>French includes accented characters. This is common in many other languages, too. An accented character usually uses some nonaccented character as a base. For example, characters: <i>&acirc;</i>, <i>&agrave;</i>, and <i>&aacute;</i> are all based on character <i>a</i>.</p><p>Because not all software supports accented characters, or appropriate keyboard maps are not always available, the user might generate input using only the base characters, without accents. In fact, even with proper software and hardware support, most French users will type keywords with no accents. The server is still expected to interpret this input correctly as if the accented characters were used.</p><p>We cannot guess which characters were inserted incorrectly, therefore, the obvious solution is to make the search index free of accented characters. This means that you'll have to keep two versions of the text; one version adjusted for the search, and the original unaltered version. You need the original because you still have to output the correct text, regardless of the user's input limitations.</p><p>In this article, I'll use the ISO-8859-1 character set, which is used by many Western European languages.</p><p><A NAME="rl1"><A HREF="#l1">Listing 1</A> allows you to convert accented characters into their base characters. The code generates two methods: <i>iso_8859_1_lc()</i>, which turns any input using ISO-8858-1 into a lowercase, accent-free version; and <i>iso_8859_1_uc()</i>, which yields an accent-free uppercase version of its input.</p><p>For example, when you call:</p><PRE>$stripped_lc = $charsets{'iso-8859-1'}{lc}-&gt;('Bienven&uuml;e');</PRE><p><i>$stripped_lc</i> will be set to:</p><PRE>bienvenue</PRE><p>These functions are used twice: first, when creating the search index, and second, when accepting the search string, before the actual search is performed. Usually, using the lower case for searching is the accepted technique.</p><p>In addition, these functions can be used for sorting. Consider the following function:</p><PRE>sub cmp_nocase{  return My::Language::lc($_[0], $_[1])          cmp         My::Language::lc($_[0], $_[2]);}</PRE><p>which can then be used as:</p><PRE>my @correctly_sorted =    sort { My::Language::cmp_nocase($lang,$a,$b) } @data;</PRE><p>where <i>$lang</i> is the currently used language (e.g., <i>fr</i>).</p><h3>Browsing</h3><p>When a user browses the site, preset data inputs are used (be careful to make sure that inputs you assume to be nonchangeable really can't be changed by users). For example, after a search has successfully completed and matches one or more records, you may list all the matched results or a subset of them. From now on, the user clicks on one of the links to get to the full record.</p><p>At this point, you may want to use the original text version using all the characters, but these should be encoded because when the link is clicked, it's possible that the browser will interpret the request incorrectly. To accomplish this, you can use <i>URI::Escape::uri_escape()</i> or <i>Apache::Util::escape_uri()</i> (a much faster implementation under mod_perl).</p><p>The text itself should be encoded as well so the browser will not mess it up. The <i>HTML::Entities::encode()</i> or <i>Apache::Util::escape_html()</i> functions can be used for that.</p><h3>Data Retrieval</h3><p>One of the big questions is how to build your database so that it will accommodate the site's multilingual capability. Obviously, you should avoid creating language-specific fields in every table that includes multilingual data. For example:</p><PRE>table movies:&#151;&#151;&#151;&#151;&#151;&#151;&#151;&#151;&#151;&#151;&#151;&#151;&#151;title_frtitle_entitle_esdescription_frdescription_endescription_es....</PRE><p>is a bad idea because, as you can see, the table will require many columns. Don't forget that the number of columns will actually be doubled, since you need to duplicate all the columns for the searchable version of the text. Every time you want to support a new language, you'll have to alter the table and add many columns. A better solution is to place all language-specific data in one table:</p><PRE>idlangreal_textsearch_text</PRE><p>where <i>lang</i> specifies the language, <i>real_text</i> the real text, and <i>search_text</i> holds the version of the text adjusted for searching. <i>id</i> is needed to map every record into the table the data belongs to. This link back to the actual data table can be more complex and comprised of several fields. In one project, we used three fields to represent a unique data ID:</p><PRE>orig_tableorig_columnorig_id</PRE><p>The concatenation of these three fields gives us a unique mapping from a record in the text table to the data table, and the record it belongs to. For example:</p><PRE>SELECT * FROM lang where orig_table='movies'AND orig_column='description' AND lang='fr' AND search_text LIKE '%foo%'</PRE><p>will search only the description columns in the <i>movies</i> table. If we want to retrieve all language fields tied to some record, we can do:</p><PRE>SELECT * FROM lang where orig_table='movies'AND orig_id=123456</PRE><p>If your particular database implementation cannot cope with all the textual data in all languages in one table, you may consider using one table per language.</p><h3>Invariant Data</h3><p>Finally, let's talk about invariant data. Data that doesn't change is either hardcoded in the code or, better yet, placed in a template. Let's take, for example, a search feature. The template will look something like <A NAME="re1"><A HREF="0303be1.htm">Example 1</A>. A simple mod_perl script that will parse this template and produce output is shown in <A NAME="re2"><A HREF="0303be2.htm">Example 2</A>.</p><p>So, these are the template and code used in a single-language site. When adding multilingualism to the site, we face this question: Should we use a template per language, or one template for all languages?</p><p>If you decide to go with the first option, you'll end up with many templates. However, keeping them synchronized will be a nightmare as changes must carefully be applied to each language template. A better approach is to keep all languages in one template. Modifications are easier because all strings are stored in the same place.</p><p>We have to find a way to parse this file and extract only the text in the requested language. Therefore, we've chosen to use XML tags, which will then be parsed by Template Toolkit so that texts in the right language will be selected.</p><p>We have used tag <i>&lt;text&gt;</i> for the text sections, and two-letter code tags for language-specific sections. <A NAME="re3"><A HREF="0303be3.htm">Example 3</A> shows the search input template after applying these definitions, and <A NAME="re4"><A HREF="0303be4.htm">Example 4</A> shows what the search results output template would now look like.</p><p>Template Toolkit allows us to provide our own template-parsing method. We use this feature to preprocess templates, turning <i>&lt;text&gt;</i> sections into conventional <i>[% IF %]</i>, <i>[% ELSE %],</i> and <i>[% END %]</i> Template Toolkit directives. The module in <A NAME="rl2"><A HREF="#l2">Listing 2</A> overrides the default Template Toolkit parsing method.</p><p>This parser assumes that a template variable named <i>lang</i> holding the current language code will exist at request time when the template is processed. We then use Template Toolkit to process the template and generate the output, using the following code:</p><PRE>use Template;use My::Template::Parser ();my $r = shift;$r-&gt;send_http_header('text/html; charset=ISO-8859-1');my $t = Template-&gt;new();$t-&gt;_init(PARSER       =&gt; My::Template::Parser-&gt;new,        INCLUDE_PATH =&gt; '/search/path',       ) or die $t-&gt;error();$t-&gt;process('search.ttml',          { input         =&gt; 'foo',            total_results =&gt; 15,            lang          =&gt; 'fr',          },          $r         ) or die $t-&gt;error();</PRE><h3>Handling Dates</h3><p>Date and time need to be formatted according to the locale. Different countries have different conventions for date and time presentation. Where an American user will read:</p><PRE>Thursday March 22, 2001 2:25pm</PRE><p>a French user will expect:</p><PRE>Jeudi 22 Mars 2001 14h25</PRE><p>In this article, we will assume that these conventions are tied to languages, rather than countries. This is incorrect in reality, but this assumption is good enough to be used as an example. In reality, you may want to tie the conventions to countries and not languages. In this case, you would need to ask the user for country preferences.</p><p>We specify the following data set for each language, as shown in <A NAME="rl3"><A HREF="#l3">Listing 3</A>. Then we use this data to produce the dates and times in the correct language using the correct format. These are handy compile-time constants that are used in the date and time generators:</p><PRE>use enum qw(YEAR MONTH DAY);use enum qw(HOUR MINUTE);</PRE><p><A NAME="rl4"><A HREF="#l4">Listing 4</A> shows some useful macros used in the formats above (they are derived from the format used by the <i>strftime()</i> function).</p><h3>Generating Correct <i>Charset</i> Headers</h3><p>When the page is produced, it's important to specify a correct charset, so the browser will do the right thing when rendering the output. There are two techniques to accomplish that:</p><ul>  <li>The preferred method to specify the character set is to use the <i>charset</i> parameter of the 'Content-Type' HTTP header. For example, to specify that an HTML document uses ISO-8859-1, a server would send the following header:</ul><PRE>Content-Type: text/html; charset=ISO-8859-1</PRE><ul>  <li>	With mod_perl, you can do that with:</ul><PRE>my $r = shift;$r-&gt;send_http_header('text/html; charset=ISO-8859-1');</PRE><ul>  <li>A less preferable method of setting the character encoding is by using the following tag in the 'HEAD' section of an HTML document:</ul><PRE>&lt;META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=ISO-8859-1"&gt;</PRE><ul>  <li>	This method requires that ASCII characters stand for themselves until after the &lt;META&gt; tag and often causes an annoying redraw with Netscape. The META HTTP-EQUIV method should only be used if you cannot set the <i>charset</i> parameter using the server.</ul><h3>Conclusion</h3><p>We've discussed the following multilingual site development issues:</p><ul>  <li>It's almost always better to develop a dynamic site rather than a static one.  <li>Language selection is done by asking the user about it and/or looking at the <i>Accept-Language</i> header.  <li>Storing user preference is best done via cookies or by making the user log in.  <li>We have seen that generated output is comprised from semistatic template text and dynamic database content.  <li>We have seen how site browsing is different from site searching in terms of multilingual input processing.  <li>We have discussed ways that language-specific data can be stored in the database.  <li>We have seen how multilingual variants of text can coexist in the same template and have the code deal with that.  <li>We have seen how the presentation of dates and times can be adjusted to the user preferences.  <li>Finally, we have learned how to tell client browsers to render the output using a correct language encoding.</ul><h3>Resources</h3><ul>  <li>mod_perl home page: http://perl.apache.org/  <li>mod_perl guide: http://perl.apache.org/guide/  <li>Template Toolkit home page: http://www.template-toolkit.org/  <li>Internationalization/Localization&#151;Charset parameter: http:// www.w3.org/International/O-HTTP-charset.html  <li>"A tutorial on character code issues" by Jukka Korpela: http://www.cs.tut.fi/~jkorpela/chars.html  <li>"Localizing Your Perl Programs" by Sean Burke and Jordan Lachler. <i>The Perl Journal,</i> Issue 13, Spring 1999.  <li>CPAN modules mentioned in this article:  <li><i>	HTTP::Negotiate</i>: http://search.cpan.org/search?dist=libwww-perl  <li><i>	HTML::Entities</i>: http://search.cpan.org/search?dist=libwww-perl  <li><i>	Apache::Util</i>: http://search.cpan.org/search?dist=mod_perl  <li><i>	Apache::Language</i>: http://search.cpan.org/search?dist=Apache-Language</ul><p><i>(Code for this article is also available online at http://www.tpj .com/source/.)</i></p><p><b>TPJ</b></p></body></html>