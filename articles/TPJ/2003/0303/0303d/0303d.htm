<html><head><title>Mar03: Something for Nothing</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; The Perl Journal--><h1>Something for Nothing</h1><p><i>The Perl Journal</i> March 2003</p><h3>By Simon Cozens</h3><I>Simon is a freelance programmer and author, whose titles include Beginning Perl (Wrox Press, 2000) and Extending and Embedding Perl (Manning Publications, 2002). He's the creator of over 30 CPAN modules and a former Parrot pumpking. Simon can be reached at simon@ simon-cozens.org.</I><hr><p>Everyone knows that the object of Perl modules is to make life easier for the programmer&#151;to reduce the amount of code you end up writing. More correctly, you can think of CPAN modules as reducing the amount of auxiliary code in your programs, leaving you free to get on with the specific algorithms you wish to implement.</p><p>In this article, I'm going to embrace and extend Mark-Jason Dominus's concept of "structural code." When Mark talks about structural code in his Red Flags tutorial, he means code that doesn't get you any closer to doing what you want to do, but is required to keep the compiler happy or the code looking sane. For instance, in</p><PRE>sub remove_duplicates {    my @list = @_;    my %seen;    return grep { !$seen{$_}++ } @list;}</PRE><p>most of the code is structural. The first three lines of that code do nothing towards removing duplicates from a list&#151; they fulfill no functional role, merely a structural one. This implementation is better, but still contains a lot of structural code that you can't avoid when you're programming in Perl:</p><PRE>sub remove_duplicates {   my %seen;   grep { !$seen{$_}++ } @_;}</PRE><p>As I said, I'm going to extend that concept. In this article, structural code is anything that is generic to programming and is not essential to the specific algorithms and functionality of the program you're writing.</p><p>I'd like to introduce four Perl modules&#151;three of mine, and one originally written by Michael Schwern&#151;and show how they can be combined to reduce the amount of structural code in an application to nearly zero. We'll first take a brief look at the four modules, then we'll show how they worked in a recent application of mine.</p><h3><i>Config::Auto</i></h3><p>Almost every single application needs to store a user's configuration settings. The end result is that every single application generally includes some code for dealing with whatever configuration format the programmer chose. Such a case is a prime candidate for modularization, and indeed there are a number of modules that can deal with various formats: <i>XML::Simple</i> for the ever-popular XML, <i>Config::IniFiles</i> for Windows-style INI, and several others. For UNIX applications, the standard configuration formats are either a variant of <i>key = value </i>(from lynx): </p><PRE># all cookies.accept_all_cookies=off# bookmark_file specifies the name and # location of the default bookmark file # into which the user can paste links for # easy access at a later date.bookmark_file=lynx_bookmarks.html</PRE><p>or colon separated (as in /etc/groups and friends): </p><PRE>nobody:*:-2:nogroup:*:-1:wheel:*:0:rootdaemon:*:1:root</PRE><p>Or maybe space separated (this one from is "gltron," a rather enjoyable OpenGL light-bikes game): </p><PRE>iset show_help 0iset show_fps 1iset show_wall 1iset show_glow 1iset show_2d 1</PRE><p>I've had to write code to deal with all of these different formats  many times over, and I finally gave up: I had what I call a "once and for all" moment. I wanted to sit down and crunch out some code that would just handle whatever I threw at it, and know that I would never ever have to tackle this problem again in my Perl programming career. Try it. It's tremendously freeing.</p><p>So I wrote <i>Config::Auto</i>, which parses all of the above formats and more. The idea is not that it gives the user a complete free-for-all. Ideally, you would specify what format you were prepared to read, what sort of data structure you expected to get at the end of it, and then you would know that the parser would be able to handle it with no additional work needed.</p><p>In its most basic use, you would say:</p><PRE>use Config::Auto;my $config = Config::Auto::parse("~/.myapprc", format =&gt; "equal");</PRE><p>to parse an equals-separated configuration file such as the .lynxrc above. But if we're trying to avoid extraneous code, why not have the parser work out what sort of configuration file it's been handed?</p><PRE>use Config::Auto;my $config = Config::Auto::parse("~/.myapprc");</PRE><p>And now it'll take a long look at your <i>rc</i> file and determine what format it looks like it's in.</p><p>And actually, there's no reason why, assuming standard naming conventions, you should have to tell it where the configuration file is, anyway. If your program is called <i>myapp</i>, then it's a reasonable guess that if the user has a ~/.myapprc file, those are the configuration settings. <i>Config::Auto</i> also tries a few other standard locations, to leave us with:</p><PRE>use Config::Auto;my $config = Config::Auto::parse();</PRE><p>Configuration file handled! Structural code: zero. (Well, near zero. Future versions of <i>Config::Auto</i> may well declare and populate a <i>$main::config</i> variable for you on import. But maybe there is such a thing as Too Much Magic.)</p><h3><i>Attribute::Persistent</i></h3><p>The next area that requires too much code is storing persistent data. As I've mentioned in a previous column, even with <i>AnyDBM_File</i> and <i>MLDBM</i>, handling persistent variables is still a pain in the neck. <i>Attribute::Persistent</i> just takes all the pain away, once and for all, with no <i>tie</i> and no structural code at all.</p><PRE>use Attribute::Persistent;my %hash :persistent; # And that's all.</PRE><p>Persistent storage handled! Structural code: zero.</p><h3><i>Getopt::Auto</i></h3><p>In a recent comp.lang.perl.moderated thread, it was pointed out that there are a number of things that every novice Perl program reinvents, despite there being perfectly round wheels out there; a command-line options processing system was one of them. Here, I disagree.</p><p>There are a number of different styles of command-line options: &#151;<i>l</i>ong, <i>&#151;s</i>hort, and the CVS-style "bare" command. In a similar vein to <i>Config::Auto</i>, I wanted a system that handled all of them.</p><p>But then I realized there was a more serious problem. If you're implementing something with an interface similar to CVS (that is, a single executable that can perform various commands, although it could be argued that this is not the UNIX Way), then you'll end up with a horrific piece of code that would look something like this:</p><PRE>my $command = shift @ARGV;if ($command eq "add") {   do_add(@ARGV);} elsif ($command eq "subtract") {   do_subtract(@ARGV);} ...</PRE><p>The two equally dissatisfying alternatives look slightly better:</p><PRE>my %commands = ( add =&gt; \&amp;do_add,                  subtract =&gt; \&amp;do_subtract,                 ...                );my $what = shift;if (exists $commands{$what}) {    $commands{$what}-&gt;(@ARGV) }else { do_help() }</PRE><p>Or even</p><PRE>no strict 'refs';my $what = shift;&amp;{"do_$what"}(@ARGV);</PRE><p>But they have two problems: First, you still need to handle things like <i>&#151;help</i> and <i>&#151;version</i> separately, and your <i>&#151;help</i> text will generally repeat all the possible arguments over again. Opponents of structural code will know that repetition is to be avoided at all costs: This is a specific case of the Prime Rule of programming and user-interface design&#151;"You should never tell the computer anything it already knows or can reasonably be expected to work out." If you're a manager, you might like to contemplate the fact that programmer time is expensive and computer time is cheap. Who should be doing the boring work?</p><p>The bigger problem is that all this is structural code once again. Dispatching to the appropriate routine is useful, but it's not as useful as actually doing the work of your program. So I had another once-and-for-all moment and decided that something else should be implementing this structural code. That "something else" is <i>Getopt::Auto</i>. As you can probably tell, I'm pretty fond of the idea that computers should do things <i>auto</i>matically&#151;it is, after all, what they're for.</p><p>With <i>Getopt::Auto</i>, you simply declare what commands you're willing to process, maybe give some help text for them, and the module does the rest. For instance:</p><PRE>use Getopt::Auto (   [ "&#151;add", "Add two numbers together", \&amp;do_add ],   [ "&#151;subtract",      "Subtract one number from another",      \&amp;do_subtract    ],      ...);</PRE><p>With no further code, <i>yourapp &#151;add 3 5</i> will call <i>do_add(3,5)</i>. And, as an added bonus, you get <i>&#151;version</i> and <i>&#151;help</i> free of charge:</p><PRE>% yourapp &#151;helpyourapp &#151;help - This textyourapp &#151;version - Prints the version numberyourapp &#151;add - Add two numbers togetheryourapp &#151;subtract - Subtract one number from another</PRE><p>Of course, you may not like GNU-style <i>&#151;long</i> options. Let's try again with CVS-style options without specifying the subroutines explicitly:</p><PRE>use Getopt::Auto (  [ "add", "Add two numbers together" ],  [ "subtract", "Subtract one number from another" ],    ...);</PRE><p>This time, <i>yourapp add 3 5</i> will call <i>add(3,5)</i>; <i>help</i> will still work and will now spit out the commands in the new bare style. You write the specification, and <i>Getopt::Auto</i> takes care of the rest.</p><p>The more alert of you may well be asking "Isn't this specification structural code?" Well, yes; I thought of that. What would be really nice is if you could say:</p><PRE>use Getopt::Auto;</PRE><p>and it would just work. Well, with one proviso, it does. The proviso is that you must provide POD documentation for each subroutine you want to turn into a command. But of course, all of your subroutines are documented anyway, so that shouldn't be a problem.</p><p>Here's our fully automated calculator example:</p><PRE>use Getopt::Auto;our $VERSION = "1.0";=head2 add - Adds two numbers together   calc add x yAdds x and y together and prints the result.=cutsub add { print $_[0] + $_[1], "\n" }=head2 subtract - Subtracts one number from another   calc subtract x ySubtracts y from x.=cutsub subtract { print $_[0]-$_[1], "\n" }</PRE><p>Now we can say: </p><PRE>% calc &#151;add 3 58% calc &#151;help   This is calc, version 1.0calc &#151;help - This textcalc &#151;version - Prints the version numbercalc &#151;add - Adds two numbers together[*]calc &#151;subtract - Subtracts one number from another[*]More help is available on the topics marked with [*]Try calc &#151;help &#151;fooAnd if we follow its suggestion: % calc &#151;help &#151;addThis is calc, version 1.0calc &#151;add - Adds two numbers together	 calc add x yAdds x and y together and prints the result.</PRE><p>Options processing and subroutine dispatch handled! Structural code: zero.</p><h3><i>Class::DBI</i></h3><p>The final module is not one of my own, but it's so efficient at removing structural code in database-backed applications that it absolutely has to be mentioned. Database applications with the DBI are breeding grounds for structural code: Either you spend a lot of time handling the various <I>select</I>, <i>insert</i>, <i>update,</i> and <i>delete</i> calls yourself, or you use some kind of abstraction layer that does some of the work for you.</p><p><i>Class::DBI</i> is like this abstraction layer, except that in most cases, it does almost all of the work for you. With <i>Class::DBI</i>, you set up one subclass that represents your database:</p><PRE>package Myapp::DBI;use base 'Class::DBI';and then tell it what your DBI parameters are:Myapp::DBI-&gt;set_db('Main', 'dbi:mysql:myapp');</PRE><p>No connecting, no disconnecting, no mucking about with handles. But how do you get at the data? Well, you need a class for each of the tables you want to play with:</p><PRE>package Myapp::Person;use base 'Myapp::DBI';Myapp::Person-&gt;table("person");</PRE><p>Next, tell it the columns you're interested in, starting with the primary key:</p><PRE>Myapp::Person-&gt;columns(All =&gt; qw(                                   id                                    name                                    department                                   salary                                )                       );</PRE><p>and away you go: Your class now has <i>create</i>, <i>retrieve,</i> and <i>search</i> methods to return <i>Person</i> objects, and you also have accessor methods for each of the columns.</p><PRE># 3% raise for all programmers!for my $person (Myapp::Person-&gt;search({                department  =&gt; "programming"}) {   $person-&gt;salary($person-&gt;salary()*1.03);}</PRE><p>There are good tricks for handling relationships between tables and between database and nondatabase objects; I refer you to Tony Bowden's article on <i>Class::DBI</i> for perl.com at http://www .perl.com/pub/a/2002/11/27/classdbi.html.</p><p>While this removes most of the rigmarole of handling data in databases, it still violates the Prime Rule because we're having to tell the computer about the columns in our database tables. In the vast majority of cases, the database can tell <i>us</i> what columns it has. Unfortunately, the way it tells us is generally database specific. So <i>Class::DBI</i> has certain database-specific add-on modules, such as <i>Class::DBI::mysql</i>. (It's only a matter of time before someone combines them all...)</p><p>Now we can tell our <i>Myapp::DBI</i> to inherit from this:</p><PRE>package Myapp::DBI;use base 'Class::DBI::mysql';...and the need to detail the columns goes away:package Myapp::Person;use base 'Myapp::DBI';__PACKAGE__-&gt;set_up_table('person');</PRE><p>(<i>Class::DBI</i> folk tend to use <i>__PACKAGE__</i> instead of repeating the class name; this is slightly related to the Prime Rule. If you ever need to change the class's name, you only want to be changing it in one place.)</p><p>But even this code is reasonably structural! The computer not only knows what columns it has in its database tables, but it also knows what tables it has. With <i>Class::DBI::Loader</i>, we can get it down to:</p><PRE>use Class::DBI::Loader;Class::DBI::Loader-&gt;new( dsn =&gt; "dbi:mysql:myapp", namespace =&gt; "MyApp");</PRE><p>and now we can use <i>MyApp::Person</i> as before.</p><p>Database access is handled with very little structual code indeed.</p><h3>Putting It All Together</h3><p>We've seen four tools that give us a great deal of functionality for very little cost in code. With all of these modules, what we gain in brevity, we sacrifice in flexibility. For instance, to make absolutely full use of <i>Class::DBI</i> requires some investment, in terms of tuning access to the columns of each table and declaring the various relationships between columns longhand.</p><p>In the code that I write from day to day, I try to strike a balance; the last thing you really want are classes and variables magicking themselves into existence without your really being aware of them. So, for instance, I don't use <i>Class::DBI::Loader</i>. I prefer to declare each table's class manually.</p><p>Well, not exactly "manually." That wouldn't be a very good use of my time. Instead, I have a little script that produces an application template&#151;a basis for an application that uses many of the aforementioned techniques. I spend most of my preparation time working out the best database schema, and then I type something like:</p><PRE>appgen PerlBooks</PRE><p>Anyone who bears the scars of the old dBase III+ application generator will recognize the name and the concept; <i>appgen</i> goes away, examines the database, and spits out a number of skeleton files, which I will turn into my eventual application.</p><p>So, first we take the name of the namespace (<i>PerlBooks</i>), turn it into our database name (<i>perlbooks</i>), and try to use <i>Class::DBI::Loader</i> on that database:</p><PRE>use Class::DBI::Loader;my $namespace = shift;my $database  = lc $namespace;my $loader = Class::DBI::Loader-&gt;new(   dsn       =&gt; "dbi:mysql:$database",   namespace =&gt; $namespace,);</PRE><p>(The application generator itself doesn't need to be portable to multiple databases&#151;although its output must be!&#151;since, for better or worse, I do all my development on MySQL.)</p><p>Now we do a little ugly messing about. First, we want our own copy of the database handle so we can prod the database, and this allows us to ask it for its tables. Instead of repeating the DSN in the DBI connection, we ask <i>$loader</i> what DSN it used:</p><PRE>my $dbh = DBI-&gt;connect(     @{ $loader-&gt;_datasource } ) or croak($DBI::errstr);my %tables = map { $_ =&gt; 1 } $dbh-&gt;tables;</PRE><p>Now for each table, we want to spit out a module representing that table in the ordinary <i>Class::DBI</i> way:</p><PRE>foreach my $table (keys %tables) {   my $class = $loader-&gt;_table2class($table);   my $ref   = $dbh-&gt;selectall_arrayref(                             "DESCRIBE $table"                                       );</PRE><p>Most of this code is cobbled together from bits of <i>Class:: DBI::mysql</i> and <i>Class::DBI::Loader</i>. Here, we turn the table name (say, <i>account</i>) into the appropriate class name, <i>PerlBooks::Account,</i> using <i>Class::DBI::Loader</i>'s built-in method, and then get a description of the database table.</p><p>Now we want to know what the primary key is, so we <i>grep</i> that out of the table's description:</p><PRE>my ( @cols, $primary );foreach my $row (@$ref) {   my ($col) = $row-&gt;[0] =~ /(\w+)/;   push @cols, $col;   next unless $row-&gt;[3] eq "PRI";   die "$table has composite primary key" if $primary;   $primary = $col;}die "$table has no primary key" unless $primary;</PRE><p>This gives us <i>$primary</i> and a list of columns in <i>@cols</i>. At this point, we can write our class:</p><PRE>my $file = $class; $file =~ s{::}{/}g;open OUT, "&gt;$file.pm" or die $!;print OUT &lt;&lt;EOF;package $class;use base '${namespace}::DBI';__PACKAGE__-&gt;table($table);__PACKAGE__-&gt;columns( Primary =&gt; q{$primary} );__PACKAGE__-&gt;columns( All     =&gt; qw{@cols} );EOF</PRE><p>We do something that <i>Class::DBI::Loader</i> doesn't do, which is to guess the "has-a" relationships in each table. For instance, if we have a column in <i>transaction</i> called <i>account</i>, we guess this is a reference to the primary key in the <i>account</i> table:</p><PRE>for (@cols) {   if (exists $tables{$_}) {      print OUT "__PACKAGE__-&gt;has_a($_ =&gt; q{".         $loader-&gt;_table2class($_)."});\n";   }}</PRE><p>This spits out something like:</p><PRE>__PACKAGE__-&gt;has_a(account =&gt; q{PerlBooks::Account});</PRE><p>Then the <i>account</i> method in our <i>PerlBooks::Transaction</i> will no longer produce a numeric ID, but will instead produce a <i>PerlBooks::Account</i> object. Finally, our generator finishes off the current class:</p><PRE>print OUT &lt;&lt;EOF;1;EOF   close OUT;}</PRE><p>Now we can get onto the main <i>PerlBooks</i> module, which has to load up the others, and any other modules we might want to use:</p><PRE>open OUT, "&gt;$namespace.pm" or die $!;print OUT "package $namespace;\n\n";print OUT "use Config::Auto\n";print OUT "use ".$loader-&gt;_table2class($_).";\n" for keys %tables;print OUT "\n1;\n";close OUT;</PRE><p>Our <i>PerlBooks::DBI</i> class is generated next, but this needs to be done a little carefully. As we've seen, <i>Class::DBI</i> expects the main class that subclasses it to tell it the connection parameters, including the username and password. Typically, though, we don't want to store the username and password in our main program files, so we bring them in from a <i>PerlBooks::Config</i> class:</p><PRE>open OUT, "&gt;$namespace/DBI.pm" or die $!;print OUT &lt;&lt;EOT;package ${namespace}::DBI;use ${namespace}::Config;use base 'Class::DBI';__PACKAGE__-&gt;set_db('Main',   'dbi:'.\$${namespace}::Config::dbd.   ':'.\$${namespace}::Config::db,   \$${namespace}::Config::username,    \$${namespace}::Config::password);__PACKAGE__-&gt;autocommit(1);1;EOTclose OUT;</PRE><p>Finally, we write out a skeleton version of that <i>PerlBooks::Config</i> class to be overwritten by the real values of the username and password by our application's installer:</p><PRE>open OUT, "&gt;$namespace/Config.pm" or die $!;print OUT &lt;&lt;EOTpackage ${namespace}::Config;our (\$dbd, \$db, \$username, \$password) =     ("mysql", "$database", "", "");1;EOT</PRE><p>This is as far as I've currently progressed with the application generator, and already it has saved me a lot of work. But as I look at it now, there's a lot more it ought to do. For instance, it could easily spit out an <i>ExtUtils::MakeMaker</i>-based installation program, which would prompt for the correct username and password and write the <i>::Config</i> module. As Alan Perlis said, "Programs that write programs are the happiest programs of all"&#151;this is a program that writes a program that writes a program!</p><p>The other obvious task for my application generator is to spit out the main application file <i>perlbooks</i>, containing at least:</p><PRE>use PerlBooks;use Getopt::Auto;...</PRE><p>But this may be overkill, and currently I'm sufficiently happy with the ability to point my application generator at a database and come out with most of what I need to start writing database-driven application code that is relatively free from structural code.</p><h3>In Closing</h3><p>There are a number of things you could take away from this article. You might think that I've created three really interesting modules that you should go and have a look at&#151;but then, I know who you'll come to for help with them, so maybe that's not such a good idea.</p><p>You might take away the Prime Rule&#151;never tell a computer what it already knows or can be reasonably expected to find out for itself. If you do, I promise it'll radically impact the way you think about user interfaces.</p><p>You could take away the fact that, with CPAN modules, there may well be More Than One Way To Do It, but there's almost always an easier way.</p><p>But what I really want you to take away is that programming really ought to be fun. If you find that your programming is becoming a drudge, see if there isn't a way you can abstract away the drudge, whether there's already a module out there that does it all for you or whether you should sit down and tackle it in a once-and-for-all moment.</p><p>Doing so will free you from banging out code for the sake of code, and allow you to get on with the interesting bit of your job&#151;having ideas, working out the best way to get things done, solving problems&#151;and my fervent hope is that it'll make programming fun for you once again.</p><p><b>TPJ</b></p></body></html>