<html><head><title>Oct03: Petal for XML Templating with Perl</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; The Perl Journal--><h1>Petal for XML Templating with Perl</h1><p><i>The Perl Journal</i> October 2003</p><h3>By Jean-Michel Hiver</h3><I>Jean-Michel is a partner with Webarchitects, a UK-based company that specializes in usable, accessible, and standards-compliant Internet solutions.</I><hr><p>There are a lot of templating modules on the Perl scene: <i>HTML::Template</i>, <i>Text::Template</i>, <i>CGI::FastTemplate</i>, and of course, the well known and formidable Template Toolkit. Why create yet another one?</p><p>All of these systems suffer from serious drawbacks, not least of which is loop management: Graphic designers have to know about the programmatic structure of the loops, and make sure the <i>end</i> statements are correctly placed.</p><p>The Zope Corporation came up with a very elegant solution&#151; the Template Attribute Language (TAL). TAL is an open specification that has been designed to make templates more compliant with WYSIWYG tools such as Adobe GoLive or Dreamweaver. There are many advantages to TAL, as described in Revuen Lerner's "At the Forge" article (http://www.lerner.co.il/atf/atf_98/).</p><p>In a nutshell, TAL lets you use extra XML attributes in a clever way so that you can control your templates. While TAL statements might look a bit alien at first, they integrate so nicely with the XML/XHTML syntax that template designers can simply ignore them&#151;even for loop and conditional statements.</p><p>Clearly, TAL is a good idea. There was no Perl module for it. Stealing a good idea is often also a good idea. So I started hacking around with <i>XML::Parser</i> and <i>HTML::TreeBuilder</i>.</p><p>Eventually, I released something on CPAN and created a mailing list. A small yet dedicated community of Perl hackers joined in, submitting bug reports, patches, benchmarks, and tests. Very quickly, Petal (PErl TAL) became a full-featured, robust module.</p><h3>A "Hello World" Example</h3><p>Say you need a screen for an application that says hello to a logged-in user. The template looks like this:</p><PRE>&lt;html&gt;  &lt;body&gt;    &lt;p&gt;Hello, World!&lt;/p&gt;   &lt;/body&gt;&lt;/html&gt;</PRE><p>Since Petal is an XML processing tool, the first thing you want to do on a template this simplistic is to send it through HTML <i>tidy</i> to make it valid XHTML as follows (the template just shown lives in file example1_01.html; all code from this article is available at http://www.tpj.com/source/):</p><PRE>$ tidy -asxhtml -asutf8 &lt;example1_01.html</PRE><p>Which outputs:</p><PRE>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"&gt;&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;&lt;head&gt;&lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Hello, World!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</PRE><h3>Replacing Bits with <i>tal:replace</i></h3><p>Assuming that you are using HTTP authentication, the user login  should be contained in the variable $ENV{REMOTE_USER}. In TAL expression syntax, this corresponds to ENV/REMOTE_USER.</p><p>Your template then becomes:</p><PRE>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"&gt;&lt;html  xmlns="http://www.w3.org/1999/xhtml"  xmlns:tal="http://purl.org/petal/1.0/"&gt;  &lt;head&gt;    &lt;title&gt;&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;p&gt;      Hello,      &lt;spantal:replace="ENV/REMOTE_USER"&gt;World&lt;/span&gt;!    &lt;/p&gt;  &lt;/body&gt;&lt;/html&gt;</PRE><p>(This template is <i>example1_03.html</i> in the source code for this article.) As you can see, a few things were added. The attribute <i>xmlns:tal="http://purl.org/petal/1.0/"</i> means "all the stuff that is prefixed with <i>tal:</i> is in the Petal namespace." If you don't specify this, Petal will default to using the <i>petal<i>:</i></i> prefix by default rather than <i>tal:</i>.</p><p><i>&lt;span tal:replace="ENV/REMOTE_USER"&gt;World&lt;/span&gt;</i> means "replace this tag and its contents with the value returned by the expression ENV/REMOTE_USER."</p><p>Now, open up your template in your favorite browser: It still looks like the original mockup!</p><h3>Sample Perl Script</h3><p><A NAME="re1"><A HREF="0310ae1.htm">Example 1</A> shows a sample Perl script to test our template. (This is file example1.pl in the source code.) As you can see, using Petal is pretty similar to other templating systems: You create a template object pointing to the template file you want to process, and then you execute the <i>process(%args)</i> method, passing a hash of arguments.</p><h3>Conditional Display with <i>tal:condition</i></h3><p>One problem with this template is that if $ENV{REMOTE_USER} is undefined, you will get the following output:</p><PRE>&lt;html&gt;&lt;body&gt;    &lt;p&gt;Hello, !&lt;/p&gt;  &lt;/body&gt;&lt;/html&gt;</PRE><p>Which doesn't exactly look good.</p><p>You can add a condition as follows:</p><PRE>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"&gt;&lt;html  xmlns="http://www.w3.org/1999/xhtml"  xmlns:tal="http://purl.org/petal/1.0/"&gt;  &lt;head&gt;    &lt;title&gt;&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;p tal:condition="true: ENV/REMOTE_USER"&gt;      Hello,      &lt;span tal:replace="ENV/REMOTE_USER"&gt;World&lt;/span&gt;!    &lt;/p&gt;  &lt;/body&gt;&lt;/html&gt;</PRE><p>In the event that ENV/REMOTE_USER is false, <i>tal:condition</i> will remove the <i>&lt;p&gt;</i> tag altogether. Now, open this new template in your favorite browser or HTML editor. Despite the added condition, it still looks the same!</p><p>As you can see, this template is perfectly well-formed XML. There are many useful things you can do with it. You can edit it in Dreamweaver or GoLive, send it through HTML <i>tidy</i>, or check it for well-formed XML with <i>xmllint</i>.</p><p>But now, let's move on to a more advanced, and more interesting example.</p><h3>More TAL Statements</h3><p>Let's say that you want to write a script that takes the URI of an RSS file and turns it into beautifully crafted XHTML. You could try to figure out an XSL stylesheet, which would transform the RSS into the XHTML page you've been given, and then use an XSL processor such as sabolotron to do the job. Eventually.</p><p>Or you could use <i>LWP::Simple</i> to fetch the file, <i>XML::RSS</i> to parse it, and Petal to template it, and leave work much earlier.</p><p>Let's look at the script in <A NAME="re2"><A HREF="0310ae2.htm">Example 2</A>. We are going to want Petal to access the following Perl values:</p><p>&middot;	<i>$rss-&gt;channel ('title')</i>, the title of the channel</p><p>&middot;	<i>$rss-&gt;channel ('link')</i>, the URI of the channel</p><p>&middot;	each element of the array <i>@{$rss-&gt;{items}}</i>, for example: <i>$rss -&gt;{item}-&gt;[$index]-&gt;{title}</i> and <i>$rss-&gt;{item}-&gt;[$index]-&gt;{link}</i></p><p>Now, let's look at this HTML mockup:</p><PRE>&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-							strict.dtd"&gt;&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;  &lt;head&gt;    &lt;title&gt;&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;h1&gt;      &lt;a href="#"&gt;This is the RSS title&lt;/a&gt;    &lt;/h1&gt;    &lt;ul&gt;      &lt;li&gt;        &lt;a href="#"&gt;RSS item&lt;/a&gt;      &lt;/li&gt;    &lt;/ul&gt;  &lt;/body&gt;&lt;/html&gt;</PRE><p>The very first thing we want to do is to add the Petal namespace:</p><PRE>&lt;html xmlns:tal="http://purl.org/petal/1.0/"&gt;</PRE><p>Then, using <i>tal:define,</i> we'll define a few aliases to save some typing in the rest of the template:</p><PRE>&lt;htmlxmlns:tal="http://purl.org/petal/1.0/"tal:define="rss_title rss/channel --title;              rss_link  rss/channel --link;              rss_desc  rss/channel --description;              rss_items rss/items"&gt;</PRE><p>As you can see:</p><blockquote><p><i>rss/channel -title</i>	maps to	<i>$rss-&gt;channel ('title')</i></p><p><i>rss/channel -link</i>	maps to	<i>$rss-&gt;channel ('link')</i></p><p><i>rss/channel -description</i>	maps to	<i>$rss-&gt;channel ('description')</i></p><p><i>rss/items</i>	maps to	<i>$rss-&gt;{items}</i></p></blockquote><p>You can use <i>some/stuff</i> and not worry about <i>stuff</i> being the key of a hash, an object attribute, or an object method. Petal will just Do The Right Thing.</p><p>Now, we want to replace the content of the <i>&lt;a&gt;</i> element within the <i>&lt;h1&gt;</i> element with the value of the <i>rss_title</i> variable. In order to do that, we use a <i>tal:content</i> directive.</p><PRE>&lt;ahref="#"  title="some_title"tal:content="rss_title"&gt;</PRE><p>We also want to replace the <i>href</i> attribute with the value of <i>rss_link</i>, and the <i>title</i> attribute with the value of <i>rss_desc</i>. Both are replaced with the <i>tal:attributes</i> statement. Our <i>&lt;a&gt;</i> element becomes:</p><PRE>&lt;a href="#"title="some_title"   tal:content="rss_title"tal:attributes="href rss_link; title rss_desc"&gt;</PRE><p>Now, we need to iterate through each element of the <i>rss_items</i> array. In order to do that, we'll use <i>tal:repeat</i> on the <i>&lt;li&gt;</i> element so that we get one <i>&lt;li&gt;</i> per iteration.</p><PRE>&lt;li tal:repeat="item rss_items"&gt;</PRE><p>This statement creates a new variable called <i>item</i> for each iteration of the loop. As previously, we use <i>tal:content</i> and <i>tal:attributes</i> on the <i>&lt;a&gt;</i> element, respectively.</p><PRE>&lt;ahref="#"  tal:attributes="href item/link"tal:content="item/title"&gt;</PRE><p>Our complete template is shown in <A NAME="rf1"><A HREF="0310af1.htm">Figure 1</A>. You can try it with the script in <A NAME="re2"><A HREF="0310ae2.htm">Example 2</A> (example2.pl in the source code).</p><p>So, to summarize the Petal attributes:</p><ul>  <li>	<i><b>tal:define</b></i> - defines variable to use them for later.  <li>	<i> <b>tal:condition</b></i> - processes a tag and its contents under a  	condition.  <li>	<i><b>tal:repeat</b></i> - iterates a tag through an array.  <li>	<i><b>tal:attributes</b></i> - replaces tag attributes values.  <li>	<i><b>tal:content</b></i> - replaces the content of a tag with the value of 		an expression.  <li>	<i><b>tal:replace</b></i> - same as <i>tal:content</i>, but replaces the tag as well.</ul><p>And that's pretty much what TAL is all about. Using these basic building blocks, you can template almost any kind of XML, while keeping your XML template well formed and compatible with whatever tool you use to edit, fix, or validate it.</p><h3>Inside Petal</h3><p>Let's examine what happens behind the scenes. Whenever you process an XML template using Petal, the library does (roughly) the following:</p><p>1. Read the source XML template.</p><p>2. $INPUT (XML or HTML) throws XML events from the source file.</p><p>3. $OUTPUT (XML or HTML) uses these XML events to canonicalize the template.</p><p>4. <i>Petal::CodeGenerator</i> turns the canonical template into Perl code.</p><p>5. <i>Petal::Cache::Disk</i> caches the Perl code on disk.</p><p>6. Petal turns the Perl code into a subroutine.</p><p>7. <i>Petal::Cache::Memory</i> caches the subroutine in memory.</p><p>8. Petal executes the subroutine.</p><p>This big, complicated procedure is really done only once. Subsequent calls to the same template will always resume at step 5  until the template file changes. If you are running a persistent environment a la <i>mod_perl</i>, then you get an extra bonus because subsequent calls to the same template in the same process will only involve step 8.</p><p>All this makes Petal pretty speedy. If you need even more speed, you can use Fergal Daly's most excellent <i>Petal::CodePerl</i>. <i>Petal::CodePerl</i> is a subclass of Petal that compiles your templates to highly optimized Perl code. This module is still experimental, yet it seems very sound.</p><h3>Input Parser</h3><p>Petal supports multiple parsing mechanisms. By default, Petal can parse your templates using the rather broken <i>XML::Parse</i>r (I wish I had known that when I started to write Petal).</p><p>However, if you find <i>XML::Parser</i> too picky for your source templates (because your templates are not well formed), you can also use <i>HTML::TreeBuilder</i>, which will do a reasonable job at parsing somewhat broken XHTML.</p><p>You can enable this behavior as follows:</p><PRE># use a local variablelocal $Petal::INPUT = 'XHTML';# or pass it as an argument to the constructormy $template = Petal-&gt;new (	   file     =&gt; â"gerbils.htmlâ",	   input    =&gt; â"HTMLâ",);</PRE><p>Whichever parser you use will fire <i>XML::Parser</i> look-alike XML events, which will be used by a canonicalizer.</p><h3>Output Canonicalizer</h3><p>At this point, I have to confess: Petal started as just a big hack. It is built on top of a previous twist in which I used a syntax made of XML processing instructions as follows:</p><PRE>&lt;?if name="something"?&gt;... do something &lt;?var name="foo"?&gt; etc...&lt;?end?&gt;</PRE><h3>Looks Familiar, Huh?</h3><p>Instead of building a module that directly converts XML events into Perl code, I've built a module that converts XML events into the just described syntax, because this system was already working. I've also made this module turn an <i>$inline_variable</i> into a <i>&lt;?var name="inline_variable"?&gt;</i>.</p><p>The Petal canonicalizer was born. It turns alternate syntaxes (TAL, inline) into the original canonical syntax, which unfortunately happens to look very ugly. A neat effect is that you can use all three syntaxes at the same time, so this is legal:</p><PRE>&lt;?if name="true:something"?&gt; &lt;p tal:repeat="item something"&gt;$item&lt;/p&gt;&lt;?end?&gt;</PRE><p>However, you should really stick with the standard TAL syntax as much as possible:</p><PRE>&lt;p tal:condition="true:something"   tal:repeat="item something"   tal:content="item"&gt;Exempli Gratia&lt;/p&gt;</PRE><p>If you want more information on the canonical syntax, see the perldoc Petal section "UGLY SYNTAX."</p><p>There are now two canonicalizer modules. The default canonicalizer produces generic XML. The XHTML canonicalizer has extra logic to deal with XHTML-specific syntaxic annoyances, such as: <i>&lt;br&gt;&lt;/br&gt;</i> needs to be <i>&lt;br /&gt;</i>. If you want to output HTML, you want to change the output canonicalizer to XHTML:</p><PRE># use a local variablelocal $Petal::OUTPUT = 'XHTML';# or pass it as an argument to the constructormy $template = Petal-&gt;new (	   file     =&gt; â"camels.htmlâ",	   output   =&gt; â"HTMLâ",);</PRE><h3>Code Generator</h3><p>So your poor template now looks like a terrible mix of XML processing instructions and XML tags. Although this syntax is hard to read for a human, Perl-wise it is much easier to tokenize and parse. As its name implies, the code generator returns a string that can be <i>eval</i>ed. When the string is <i>eval</i>ed, it returns a CODE reference ready to be executed.</p><p>You can even substitute Petal's code generator with another one using the <i>$Petal::CodeGenerator</i> variable, but you probably will never need to do that unless you're into serious Petal hacking.</p><h3>Modifiers</h3><p>Imagine that you want to replace an attribute of a tag with more than a simple variable. For the sake of the example, let's call the attribute <i>bar</i> and its tag <i>foo</i>. You want to replace it with the value <i>"Hello, $user"</i>.</p><PRE>&lt;foo bar="dummy value" /&gt;</PRE><p>Of course, you could directly replace <i>"dummy value"</i> with <i>"Hello, $user"</i> as follows:</p><PRE>&lt;foo bar="Hello, $user" /&gt;</PRE><p>but this is not compliant with the TAL specification. If you want to keep your <i>dummy value</i> intact, you can use the <i>tal:attributes </i>statement combined with the <i>string:</i> modifier. So, instead of writing:</p><PRE>&lt;!-- doesn't do the right thing --&gt;&lt;foo bar="dummy value" tal:attributes="bar user"/&gt;</PRE><p>You write:</p><PRE>&lt;!-- does the right thing --&gt;&lt;foo bar="dummy value" tal:attributes="bar string:Hello, ${user}!"/&gt;</PRE><p>Modifiers are implemented using either code references or modules. Petal features the following default modifiers:</p><ul>  <li><i>string:</i>, which as we have seen earlier interpolates expressions within a string.  <li><i>true:</i>, which returns True if a value is true unless it's an array reference pointing to an empty list.  <li><i>false:</i>, which you can work out.</ul><p>The exciting thing is that it's possible&#151;and dead easy&#151;to write your own modifiers. For example, let's write an <i>uppercase:</i> modifier:</p><PRE>$Petal::Hash::MODIFIERS-&gt;{'uppercase:'} = sub {	my $hash  = shift;	my $value = shift;	return uc ($value);};</PRE><p>We can then write the following template:</p><PRE>&lt;span tal:replace="uppercase:string:Hello, World!"&gt;hello, world&lt;/span&gt;</PRE><p>which will output:</p><PRE>HELLO, WORLD!</PRE><p>or we could write a <i>decrement:</i> modifier, which would decrement a variable:</p><PRE>$Petal::Hash::MODIFIERS-&gt;{'decrement:'} = sub {	my $hash  = shift;	my $value = shift;$hash-&gt;{$value}--;};</PRE><p>And try it on:</p><PRE>&lt;spantal:define="num 5" tal:replace="decrement:num" /&gt;</PRE><p>If the modifier you're planning to write is too big to be a single subroutine, you can write it as a module. The uppercase example becomes:</p><PRE>package Petal::Hash::UpperCase;use warnings;use strict;sub process{    my $class = shift;    my $hash  = shift;    my $expr  = shift;    return uc ($hash-&gt;get ($expr));}1;__END__</PRE><p> And that's it: Petal will automagically pick up any file in <i>@ISA </i>that looks like "Petal/Hash/SomeWeirdPlugin.pm" and install it as "someweirdplugin:".</p><h3>Conclusion</h3><p>Fortunately, Petal is <i>not</i> "yet another templating module." It is a stable Perl implementation of an open specification from the Zope Corporation team. So far, TAL has been implemented in Python, PHP, and Perl.</p><p>Petal has all the bells and whistles you would expect from a good templating module: a modular architecture, proper Unicode support, decent speed, <i>mod_perl</i> friendliness, POD documentation, and a test suite. Moreover, the TAL specification lets you amend XML templates in a way that stays compatible with existing XML tools. With TAL, error-prone <i>&lt;%end-loop%&gt;</i>-style tags are a nonissue. Petal makes use of TAL to help you produce industry-standard-compliant data.</p><p>Finally, and more important, the main strength of Petal has been and will be its mailing list and its fantastic community of friendly and competent users.</p><p>So type "perl -MCPAN -e 'install Petal"' and join us!</p><h3>References</h3><p><i>Text::Template</i>: http://search.cpan.org/author/MJD/Text- Template-1.44/lib/Text/Template.pm</p><p><i>HTML::Template</i>:http://search.cpan.org/author/ SAMTREGAR/HTML-Template-2.6/Template.pm</p><p><i>CGI::FastTemplate</i>: http://search.cpan.org/author/JMOORE/CGI-FastTemplate-1.09/FastTemplate.pm</p><p>Template Toolkit: http://template-toolkit.org/</p><p>TAL of ZPT: http://www.zope.org/Wikis/DevSite/Projects/ZPT/TAL</p><p>TAL specification: http://zope.org/Wikis/DevSite/Projects/ZPT/TAL%20Specification%201.4</p><p>Petal: http://search.cpan.org/author/JHIVER/Petal-1.03/</p><p>Petal mailing list: http://lists.webarch.co.uk/mailman/ listinfo/petal/</p><p>"At the Forge:" http://www.lerner.co.il/atf/atf_98 </p><p><b>TPJ </b></p></body></html>