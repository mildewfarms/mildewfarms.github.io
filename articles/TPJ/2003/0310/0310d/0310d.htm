<html><head><title>Oct03: Managing the  House with Perl</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; The Perl Journal--><h1>Managing the  House with Perl</h1><p><i>The Perl Journal</i> October 2003</p><h3>By Simon Cozens</h3><I>Simon is a freelance programmer and author, whose titles include Beginning Perl (Wrox Press, 2000) and Extending and Embedding Perl (Manning Publications, 2002). He's the creator of over 30 CPAN modules and a former Parrot pumpking. Simon can be reached at simon@ simon-cozens.org.</I><hr><p>These days, a lot of the code that I write for myself, out of work time, comes as a result of changes in my life situation. When I went to Japan for a month, I wrote some code that helped me maintain a diary and newsletter. Recently, I've moved house, and now have the joy of housemates again.</p><p>On top of everything else, this means all sorts of daily tasks require additional administration&#151;bills need to be divided up, the house network needs better organization, there needs to be a shopping list for communally bought items, and so on. Being a lazy hacker, I shun additional administration and code around it. And since there are quite a few overly geeky houseshares around who might benefit from automating their admin, I took the time to write <i>HouseShare.pm</i>.</p><h3>What It Does</h3><p>HouseShare is a web-based administration system for a shared house. When it's completely finished, it will look after the network, the phone bill, the shopping list, and pass messages and information between housemates. At the moment, it does a reasonable chunk of those things.</p><p>When you first connect to HouseShare with your web browser, you'll see a menu like <A NAME="rf1"><A HREF="0310df1.htm">Figure 1</A>.</p><p>Here, you see the front page for the Trinity House (that's my geekhouse) installation of HouseShare. At the bottom of the page are the latest blog entries&#151;notes that all housemates should see.</p><p>Let's add a new computer to the house network by following the link on the computer icon. This presents us with a list of the currently configured computers, and prompts us for information about a new one. (See <A NAME="rf2"><A HREF="0310df2.htm">Figure 2</A>.)</p><p>You'll notice that the system also suggests the next available IP address for us. Hosts on the network can be renamed, reconfigured, or deleted; changes to the network will be reflected in the DNS server, which is controlled by the whole HouseShare application.</p><p>HouseShare is a modular system and additional components can easily be added and updated. The phone bill and communal- shopping modules haven't yet been written, although they have been designed and I'll talk about their operation later on, but they will slot in with one additional database table and an additional Perl module each.</p><h3>How It Does It</h3><p>The heart of the HouseShare system is a combination of two of the Perl modules I talk about most in these columns: <i>Class::DBI</i> and the Template Toolkit. As Kake Pugh points out (http://www.perl.com/pub/a/2003/07/15/nocode.html), these two modules are almost made for each other, allowing you to go straight from a database to HTML with very little Perl in the middle.</p><p>Most of the magic that runs HouseShare is done in the appropriately named <i>HouseShare::Magic</i> class. This is a subclass of <i>Class::DBI</i>, which all the HouseShare classes inherit from. Its job is to provide all the bridging code necessary to get from the database to HTML output.</p><p>One of the most important methods it provides, for instance, is <i>list</i>. The various listing pages for computers, users, and so on is all provided by this one <i>list</i> method in <i>HouseShare::Magic</i>. Even more interestingly, most of the pages are produced by exactly the same Template Toolkit template. This raises an obvious question: How does the template know whether or not it's dealing with a user, a computer, or something else?</p><p><i>Class::DBI</i> helps with some of this, providing methods like <i>columns</i> which return a list of a database table's columns. If we tell the template the names of each table's columns, we can write code like this to turn a list of objects into a table:</p><PRE>[% FOR item = objects;    "&lt;tr&gt;";    FOR col = classmetadata.columns;        NEXT IF col == "id";        "&lt;td&gt;";item.$col;"&lt;/td&gt;";    END;     button(item, "edit");    button(item, "delete");    "&lt;/tr&gt;";END %]</PRE><p>Another very useful piece of code is <i>UNIVERSAL::moniker</i>, which adds two methods to every class: <i>moniker</i> and <i>plural_moniker</i>. These methods transform a class name like <i>HouseShare::Computer</i> into <i>computer</i> and <i>computers,</i> respectively.</p><p>Now code like:</p><PRE>&lt;h2&gt; Listing of all [% classmetadata.plural %]&lt;/h2&gt;</PRE><p>will say "Listing of all computers" and "listing of all users." If we have a class like <i>HouseShare::PhoneNumber</i>, which represents numbers that users have registered as having called recently, we can override the <i>moniker</i> and <i>plural_moniker</i> methods appropriately:</p><PRE>package HouseShare::PhoneNumber;sub plural_moniker { "recently called phone numbers" }sub moniker { "phone number" }</PRE><p>and the same template will still make sense.</p><p><i>HouseShare::Magic</i> contains a do-everything templating method, <i>process</i>, which finds the templates, sets up the <i>Template</i> object, and creates a default set of arguments for it to use. The more interesting of these are <i>classmetadata</i>. We've already seen the use of <i>columns</i> and <i>plural</i>; here's the <i>classmetadata</i> argument in full:</p><PRE>$args-&gt;{classmetadata} = {    name =&gt; $class,    columns =&gt; [ $class-&gt;columns ],    colnames =&gt; { $class-&gt;column_names },    moniker =&gt; $class-&gt;moniker,    plural  =&gt; $class-&gt;plural_moniker,    description =&gt; $class-&gt;description};</PRE><p>Two methods in that metadata section may not be immediately recognizable: <i>description</i> and <i>column_names</i> are provided by <i>HouseShare::Magic</i> itself, and are supposed to be overridden in <i>child</i> classes. <i>column_names</i> maps a database table's columns to names that are sensible for display; the default implementation just uppercases the first character:</p><PRE>sub column_names {     my $class = shift;     map { $_ =&gt; ucfirst $_ } $class-&gt;columns }</PRE><p>However, for some classes, you'll want to specify more human-readable column names. For instance, in the computer table, the column for the IP address is <i>ip</i>. With the default version of <i>column_names</i>, this will come out as "Ip," which is horrific. Instead, we provide a better mapping:</p><PRE>sub column_names {    ip =&gt; "IP Address",    hostname =&gt; "Hostname",    owner =&gt; "Owner",    comment =&gt; "Comment"}</PRE><p>Now our table can have a nice, friendly header:</p><PRE>&lt;TR&gt;[% FOR col = classmetadata.columns.list;    NEXT IF col == "id";    "&lt;TH&gt;"; classmetadata.colnames.$col; "&lt;/TH&gt;";END %]</PRE><p>Similarly, <i>description</i> provides a human-readable description of what the class represents.</p><p>This more or less covers what <i>process</i> does, and everything else that spits out HTML is implemented in terms of that. For instance, the <i>list</i> method that produces the lists of things just looks like this:</p><PRE>sub list {    my $class = shift;    $class-&gt;process("list", { objects =&gt; [$class-&gt;retrieve_all] });}</PRE><p>This code looks for a template called "list," and passes as additional arguments to an array called <i>objects</i>, which are all the table's rows.</p><p>As we've seen with our list template, we then go through all the columns of this class's database table, and ask each object for its details. This works perfectly for things such as comments and IP addresses, but when I asked a computer for its <i>owner</i>, I was surprised to see that my computers had an owner of "1", rather than "simon."</p><p>This is because, in the database schema, the <i>owner</i> is stored as a foreign key into the <i>users</i> table. We've set up a <i>Class::DBI</i> has-a relationship to say that each computer has an owner, and therefore, quite correctly, calling <i>owner</i> on the <i>HouseShare::Computer</i> object that returns a <i>HouseShare::User</i>.</p><p>Unfortunately, this object stringifies to the ID, which is not what we want. (At least it doesn't stringify to <i>HouseShare::User=HASH(0xgarbage)</i>, which would be even less useful.) We want to display the actual username.</p><p>There are two ways we could do this. I did it first a good way, and this helped me to see a better way. The good way is to allow each class to override the default template. We do this in the magic template processing method by providing a series of template search paths:</p><PRE>my ($class, $name, $args) = @_;my $template = Template-&gt;new({ INCLUDE_PATH =&gt; [    File::Spec-&gt;catdir($HouseShare::templatehome, $class-&gt;moniker),    File::Spec-&gt;catdir($HouseShare::templatehome, "custom"),    File::Spec-&gt;catdir($HouseShare::templatehome, "factory")]});</PRE><p>This means, if we call <i>HouseShare::Computer-&gt;list</i>, Template Toolkit will first look for templates in the /opt/houseshare/templates/computer directory, then in /opt/houseshare/templates/custom, (where installation-specific customizations can be made), and finally, in /opt/houseshare/templates/factory, where the factory settings are found. This allowed me to put code into templates/computer/list to fiddle with the <i>owner</i> column:</p><PRE>IF col == "owner"; item.owner.username; ELSE; item.$col; END;</PRE><p>Now we can have our <i>HouseShare::Computer</i> class-specific templates in one location, out of the way. That was the good way.</p><p>The better way is to realize that <i>Class::DBI</i> is only trying to be helpful when it stringifies a <i>HouseShare::User</i> object to the ID, and it could easily be persuaded to stringify it to something more useful instead. So, putting the following code in <i>HouseShare::User</i>:</p><PRE>__PACKAGE__-&gt;columns(Stringify =&gt; qw[ username ]);</PRE><p>solves the problem without having to mess with specific templates.</p><h3>Editing Records</h3><p>So much for displaying things. What about editing them? Well, there's the wonderful <i>Class::DBI::FromCGI</i> method, which turns a set of posted CGI form parameters into a <i>Class::DBI</i> object in your specified class, handling untainting via <i>CGI::Untaint</i>. That solves half the CGI problem, allowing you to create and update objects just by receiving form field values&#151;the other half of the problem involves creating the CGI form in the first place. As it turns out, there's a nice, generic way we can do this, too.</p><p>In the process of writing my HouseShare application, I found myself writing the <i>Class::DBI::AsForm</i> module. This provides a <i>to_cgi</i> method, returning hash mapping columns to HTML form elements.</p><p>If we feed this hash to our template too, we can create a generic form for adding entries to a database table like so:</p><PRE>&lt;h3&gt;Add a new [%classmetadata.moniker%]&lt;/h3&gt;&lt;FORM METHOD="post"&gt;    &lt;INPUT TYPE="hidden" NAME="action" VALUE="crate"&gt;    &lt;INPUT TYPE="hidden" NAME="class" VALUE="[%classmetadata.name%]"&gt;     [% FOR col = classmetadata.columns;        NEXT IF col == "id";        "&lt;b&gt;";classmetadata.colnames.$col;"&lt;/b&gt; : ";         classmetadata.cgi.$col;        "&lt;BR&gt;";        END;    %]    &lt;INPUT TYPE="submit" NAME="create" VALUE= "create"&gt;&lt;/FORM&gt;</PRE><p>Editing objects is very similar: Just replace the relevant row in the list table with a set of calls to<i> to_field($col)</i> on the object. This produces an HTML snippet for the column in question, optionally taking notice of has-a relationships. For instance, when we edit a computer, at some point, our template will do the equivalent of</p><PRE>object.to_field("owner")</PRE><p>The <i>owner</i> of a computer is a <i>HouseShare::User</i>, and <i>to_field</i> knows this, so it produces a drop-down box of the users, with the current owner selected:</p><PRE>&lt;select name="owner"&gt;    &lt;option value=1 selected&gt; simon &lt;/option&gt;    &lt;option value=2&gt; heth &lt;/option&gt;    ...&lt;/select&gt;</PRE><p>Hence, the add box we used to add a new computer to the network was generated completely generically, using a generic template and no special code in the computer class.</p><p>We've mentioned briefly the <i>FromCGI</i> module that is used to process these forms when the data is returned. Here's the code which does this, again in the generic <i>Magic</i> class:</p><PRE>sub do_edit {    my $class = shift;    my $r = Apache-&gt;request;    my $obj = $class-&gt;retrieve(shift);    my $h = CGI::Untaint-&gt;new(%{Apache::Request-&gt;new($r)-&gt;parms});    $obj-&gt;update_from_cgi($h);    $class-&gt;list;}</PRE><p>I've removed some of the error-checking code for the purposes of clarity: We'll be passed in an object ID by the front-end handler, and then <i>CGI::Untaint</i> reads and verifies the CGI form parameters. Sending this <i>CGI::Untaint</i> object to the <i>update_from_cgi</i> method, as provided by <i>Class::DBI::FromCGI</i> does the rest, and we direct the user back to the list page.</p><h3>Identifying Users</h3><p>What other information do we feed to our magical <i>process</i> method? You'll notice that at the top right-hand corner of our page, there was a little box with our name, demonstrating that the system had recognized the current user. This is done by passing in a <i>HouseShare::User</i> instance into the template arguments:</p><PRE>$args-&gt;{me} = HouseShare::User-&gt;me;</PRE><p>The <i>me</i> method tries to work out which of the housemates the remote user viewing the page actually is. How can we do that? Well, given that we know about all of their computers, and we can determine which IP address their browser is connected from, we can tell who owns the computer making the request. This is obviously a weak form of authentication, but in a house share situation where everyone has physical access to each other's kneecaps&#151;sorry, I mean, computers&#151;there's not much point in having any stronger authentication.</p><p>On the other hand, it is important to ensure that this request is actually coming from inside the house's network. The last thing you want is some random stranger out there on the Internet messing with your milk budget. To demonstrate the HouseShare system to the world at large, I added a demo mode which means that people can access and view the web site, but not change anything.</p><p>To work out who the user is, we start by knowing their IP address &#151; information we get from the environment:</p><PRE>sub my_ip {    return $ENV{'REMOTE_ADDR'} ||     inet_ntoa(scalar gethostbyname(hostname() || "localhost"));}</PRE><p>The first line checks the <i>REMOTE_ADDR</i> as set by the web server; the second line assures that this function will still work properly when <i>HouseShare</i> routines are called from the command line. As well as helping with debugging, we'll see later that this overcomes an interesting problem.</p><p>Now we can ask the main <i>HouseShare</i> module for the house's network and construct a <i>NetAddr::IP</i> representing the network range:</p><PRE>sub me {    my $class = shift;    my $net = NetAddr::IP-&gt;new(HouseShare-&gt;config-&gt; {network});</PRE><p>Now, if our IP address is not in this range, we switch to demo mode and don't return a user:</p><PRE>if (!$net-&gt;contains(NetAddr::IP-&gt;new($class-&gt;my_ip))) {    $HouseShare::demo = 1;     return;}</PRE><p>and now we can see if we have a computer in the house registered to this IP:</p><PRE>if (my @computer = HouseShare::Computer-&gt;search({ip =&gt; $class-&gt;my_ip})) {    return $computer[0]-&gt;owner;}</PRE><p>The <i>owner</i> method will, quite properly, return a <i>HouseShare::User,</i> so our work is done.</p><p>Now comes the interesting problem. Suppose, you've just installed HouseShare, and you go to the web site and want to start adding computers and users. Unfortunately, the computer doesn't currently know who you are&#151;and it can't look you up by computer, because you don't have any computers registered either! To bootstrap the system, the installation program prompts for the first user's information and creates a <i>HouseShare::User</i> object for them. From then on, any access from an unregistered IP address inside the network is assumed to be from this first "administrator" user:</p><PRE>my @users = $class-&gt;retrieve_all;return $users[0];</PRE><p>And that, basically, is the <i>HouseShare::User</i> class.</p><h3>The Front End</h3><p>Finally, in our tour of the <i>HouseShare</i> classes, let's look at the front-end <i>mod_perl</i> handler, which ties the whole system together.</p><p>Here's the entire handler:</p><PRE>sub handler {    my $r = shift;    my @pi = split /\//, $r-&gt;uri();    shift @pi while @pi and !$pi[0];    @pi = qw(user process frontpage) unless @pi;     my $class = "HouseShare::".ucfirst(shift(@pi));    my $method = shift @pi || "present";    return DECLINED if !$class-&gt;require || !$class-&gt;can($method);    $r-&gt;send_http_header("text/html");    $class-&gt;$method(@pi);    return OK; }    </PRE><p>I will admit that this code is a little insecure, although it's not easy to see how to exploit it&#151;you'd have to find a dangerous class method in a <i>HouseShare</i> class. This is not the way I would recommend you code, but it was a neat hack. The idea is that the URL http://houseshare.my.house/computer/edit/5 gets turned into <i>HouseShare::Computer-&gt;edit(5);</i>.</p><p>If there isn't a method, we call the generic method <i>present</i>; this means that things like the <i>HouseShare::Blog</i> class (based on Bryar, the subject of some of my previous articles) can be accessed from http://houseshare.my.house/blog.</p><p>And if there isn't even a class, such as when we hit the front page, we're effectively sent to <i>HouseShare::User-&gt;present("frontpage"),</i> which displays the <i>frontpage</i> template. (The choice of the user class to do this is somewhat arbitrary.)</p><p>One thing you might notice about that handler routine is that it's simple and compact, a theme that runs through the whole system&#151;in fact, the system currently weighs in at only 250 lines of actual Perl code, and 300 lines in the templates. All the heavy lifting is either done with existing modules or abstracting tasks away to a generic layer, such as the <i>Magic</i> class.</p><h3>Doing Real Work</h3><p>So far, we've discussed a lot of infrastructure &#151; a framework for doing neat things with databases and the Web. However, it's now very trivial to build on top of this framework to add "real work" functionality to HouseShare.</p><p>For instance, one piece of real work we can do with <i>HouseShare::Computer</i> is to update the DNS tables when a <i>Computer</i> object is added or modified. Thankfully, with <i>Class::DBI</i>'s trigger support, this is a very simple matter. Assuming we have a subroutine called <i>build_zonefile</i> which does the equivalent of:</p><PRE>print $_-&gt;hostname, " IN A ", $_-&gt;ip, "\n"    for HouseShare::Computer-&gt;retrieve_all;</PRE><p>(except, naturally, with a little more smarts...) we can trivially arrange for this to be called when anything changes:</p><PRE>__PACKAGE__-&gt;add_trigger(after_update =&gt; \&amp;build_zone	file);__PACKAGE__-&gt;add_trigger(after_create =&gt; \&amp;build_zone	file);</PRE><p>Now new hosts will automatically be added to the DNS server, and updates will automatically be reflected&#151;as usual, with only a tiny bit of code.</p><h3>What It Will Do Soon</h3><p>HouseShare currently does around 50 percent of what I would like to see it do. It was very simple to plug in <i>HouseShare::Blog</i> as a 20-line subclass of Bryar to add a blog to the site, and an <i>Apache::MP3</i> instance to share music around the house; I also plan to add a <i>CGI::Wiki</i> wiki to share information about who to call when the power fails, and so on.</p><p>The next big step will be integrating Tony Bowden's <i>Data::BT::PhoneBill</i> to download and parse phone-bill data. The methodology here is similar to what we've seen so far: A <i>Phonenumbers</i> class and database table will register known numbers and associate them with people who are likely to have called them, and then a method on that class will grab the data, share out the cost, and process a template displaying the results.</p><p>The final piece (for now) will be something to record purchases of house essentials and share the cost between the housemates; again, this will be a simple class with a database table, and a class method to do the work. This simple approach can be used to extended the system to add all kinds of functionality&#151;in fact, the framework we've drawn up can be used in a huge number of applications, and we use a (admittedly, more complex) variant of the idea at work as a basis for all kinds of e-commerce sites.</p><p>HouseShare is available from my CVS repository at http://cvs.simon-cozens.org/viewcvs.cgi/?cvsroot=HouseShare; it's currently a little underdocumented but e-mail me if you want to install it and hack on it and I'll help you through it.</p><p>I sometimes think that HouseShare is a little bit overkill for the job it does; it's currently slightly more useful than a whiteboard in the hall. But it's been a lot of fun, which is the main thing, and in the course of writing it, I've learned a lot about <i>Class::DBI</i>, Template Toolkit, abstracting functionality away, and making generic templates do a wide range of tasks. I hope through reading this, you have, too.</p><p><b>TPJ</b></p></body></html>