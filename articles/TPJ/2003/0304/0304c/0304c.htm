<html><head><title>Apr03: A Magic Header for Starting Perl Scripts</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; The Perl Journal--><h1>A Magic Header for Starting Perl Scripts</h1><p><i>The Perl Journal</i> April 2003</p><h3>By P&eacute;ter Szab&oacute;</h3><I>P&eacute;ter is studying computer science and informatics at Budapest University of Technology and Economics, Hungary. His primary interests are programming languages, model verification, and computer typesetting. He can be contacted at pts@inf.bme.hu.</I><hr><p>Most Perl scripts start with a line beginning with <i>#!</i> and containing the world <i>perl</i> (for example, <i>#!/usr/local/ bin/perl -w</i>). This line tells the UNIX operating system that it shouldn't treat the current file as a binary executable, but it should invoke the specified <i>perl</i> interpreter with the specified options, and that interpreter will take care of the Perl script. Although the concept of this first line is simple, writing it to be universally applicable tends to be very hard.</p><p>For example, specifying <i>#! /usr/local/bin/perl -w</i> will cause a confusing <i>my_script.pl: No such file or directory</i> message on many out-of-the-box Linux systems, on which <i>perl</i> is located in <i>/usr/bin/</i>. Specifying <i>#! /usr/bin/perl -w</i> solves the problem on those Linux boxes, but will break compatibility with most Solaris systems, on which the standard place for<i> perl</i> is <i>/usr/local/bin/perl</i>. The bad news is that there is no standard place for <i>perl</i> to be specified after <i>#!</i>. To make matters worse, some older UNIX systems impose very strict rules on what can be specified in the <i>#!</i> line. As a result, you may choose between:</p><ul>  <li>Specifying the path that works for the majority of your user base.  <li>Documenting the incompatibility, and politely asking the users to manually modify your scripts if there's a problem.  <li>Writing an install script to automate the modifications. (How will the user start the install script? By typing <i>perl install.pl</i>, presumably.)  <li>Finding a solution that will work anywhere.</ul><p>This article describes the last option&#151;the Magic Perl Header, a multiline solution for starting a Perl script on any UNIX operating system.</p><h3>Common One-Line Pitfalls</h3><p>The most obvious <i>#!</i> one-liners are just not good enough:</p><ul>  <li>Specifying <i>#!/usr/local/bin/perl -w -T</i> doesn't work because some UNIX operating systems allow only a single command-line switch after <i>#!</i>. This one-liner won't work on Linux.  <li>Specifying <i>#!/usr/local/bin/perl -wT</i> doesn't work because some UNIX operating systems expect a space after <i>#!</i>. This one-liner works on Linux only if <i>/usr/local/bin/perl</i> exists (but it usually doesn't).  <li>Specifying <i>#! /usr/local/bin/perl -wT</i> doesn't work because <i>perl</i> might be located in <i>/usr/bin </i>or somewhere else, such as on Debian Linux. (Remember: The user of your script may not be educated enough to be able to find the <i>perl</i> binary and modify the first line of the script accordingly; and in some security configurations, they may not have the permission to do it, even when they know exactly what to change.) This one-liner rarely works on out-of-the-box Linux.  <li>Specifying <i>#! perl -wT</i> doesn't work because some UNIX operating systems expect an absolute executable name (starting with <i>/</i>) after <i>#!</i>. This one-liner doesn't work on Linux.  <li>Specifying <i>#! /usr/bin/env perl -wT</i> doesn't work because some systems allow only zero or one argument after the command name. (Moreover, in some systems there is a limit for the overall length of the first line&#151;it can be as few as 32 or 64 characters.) It would be very hard to specify the <i>-T</i> switch from anywhere other than the command line. (The <i>-w</i> switch is easier: just write <i>BEGIN{$^W=1}</i> in front of the Perl code.) The <i>-T</i> switch is a security switch, and specifying it too late opens the backdoor for malicious accidents. You (the programmer) should be extremely careful here, but it is difficult because there is no place to specify the correct switches. This one-liner doesn't work on Linux.  <li>Specifying <i>#! /usr/bin/env perl</i> doesn't work, either, because <i>env</i> might be missing or located somewhere else on some systems. This one-liner works on Linux.</ul><h3>Building the Magic Perl Header</h3><p>It is clear that there is no single-<i>#!</i>-line solution to the problem in the general case, because there is no portable way to start Perl to run a script. A multiple-line solution will be necessary. In this section, I will begin to build this solution. I will identify problems and limitations along the way, and in the next section, present the final, complete magic header that will allow you to start a Perl script on any UNIX system.</p><p>The only portable beginning for a script is:</p><PRE>#! /bin/sh</PRE><p><i>/bin/sh</i> is available on all UNIX systems, but it might be a symlink to any shell, including Bourne shell variants (such as Bash and ash), Korn shell variants (such as pdksh and zsh), and C shell variants (such as csh and tcsh). Many UNIX utilities, and the libc <i>system(3)</i> function (conforming to ANSI C, POSIX.2, BSD 4.3) rely on a working <i>/bin/sh</i>. So it is fairly reasonable to assume that <i>/bin/sh</i> exists and is a Bourne, Korn, or C shell variant. On Linux, <i>/bin/sh</i> is usually a symlink to <i>/bin/bash</i>. (On Linux install disks, it is sometimes a symlink to <i>/bin/ash</i> or the built-in ash of BusyBox.) On Win32 MinGW MSYS, <i>/bin/sh</i> is Bash, but there is no <i>/bin/bash</i>. On Solaris, <i>/bin/sh</i> is Sun's own simplistic Bourne-shell clone, and Digital UNIX also has a simple Bourne-shell clone in <i>/bin/sh</i>. (The line <i>#! /bin/sh --</i> that is seen in many shell scripts to allow arbitrary filenames for the executable won't work here because tcsh gives an error for the -- switch.)</p><p>We can write a simple shell wrapper that will find the <i>perl</i> executable in <i>$PATH</i> and run it with the correct switches. In fact, this is the only way that this works on Win32 systems, using .bat batch files. A candidate for the solution is:</p><PRE>## file my_script.sh, version 1#! /bin/shperl my_script.pl## file my_script.pl# real Perl code begins here</PRE><p>This has the following problems:</p><p>1.	It doesn't pass command-line arguments.</p><p>2.	It doesn't propagate <i>exit()</i> status.</p><p>3.	It cannot find the Perl script on the <i>$PATH</i>&#151;it will take it from the current directory, which is usually wrong, and might also present a security issue.</p><p>4.	It needs two separate files.</p><p>Problems 1-3 can be overcome quite easily:</p><PRE>## file my_script.sh, version 2#! /bin/shexec perl -S -- my_script.pl "$@"</PRE><p>All Bourne and Korn shells (such as GNU Bash, ash, zsh, pdksh, and Solaris <i>/bin/sh</i>) can interpret <i>my_script.sh</i> correctly. However, C shells use a different notation for "all the arguments passed to the shell, unmodified." They use <i>$argv:q</i> instead of <i>"$@"</i>. The <i>perlrun(1)</i> manual page describes a memorable construct that detects the C shell:</p><PRE>eval '(exit $?0)' &amp;&amp; eval 'echo "Korn and Bourne"'echo All</PRE><p>The message "<i>All</i>" gets echoed on all three shell types, but only Korn and Bourne shells print the "<i>Korn and Bourne</i>" message. (In zsh, the result depends on the value of <i>$?</i>, but it won't cause a problem since zsh understands both the csh and Bourne shell constructs we use.) The trick here is that <i>$?</i> is the exit status of the previous command, with the initial value of 0, but <i>$?0</i> in the C shell is a test that returns "1" because the variable <i>$0</i> exists.</p><p>We can change <i>echo</i> in the C shell detection code to <i>exec perl</i>, and that's it:</p><PRE>## file my_script.sh, version 3#! /bin/sheval '(exit $?0)' &amp;&amp; exec perl -S &#151; "$0" "$@"exec perl -S -- "$0" $argv:q</PRE><p>Now we're ready to make our first wizard step: Combine <i>my_script.pl</i> and <i>my_script.sh</i> into a single file, which invokes itself using <i>perl</i> when run from the shell. (Forget about csh-compatibility for a moment&#151;we'll get to that later.)</p><p>A simple attempt would be:</p><PRE>#! /bin/sheval 'echo DEBUG; exec perl -S $0 ${1+"$@"}'if 0;# real Perl code begins here</PRE><p>Unfortunately, it doesn't run the real Perl code, but it produces an infinite number of DEBUG messages. That's because Perl has a built-in hack: If the first line begins with <i>#!</i> and it doesn't contain the word <i>perl</i>, Perl executes the specified program instead of parsing the script. See the beginning of the <i>perlrun(1)</i> manual page for further details.</p><p>In the following simple trick, suggested by the <i>perlrun(1)</i> manual page, we include the word <i>perl</i> in the first line:</p><PRE>#! /bin/sh &#151; # -*- perl -*-eval 'exec perl -S $0 ${1+"$@"}'if 0;# real Perl code begins here</PRE><p>This fails to work on many systems, including Linux, because the OS invokes the command line (<i>/bin/sh</i>, <i>-- # *-* perl -*-</i>, <i>./my_script.pl</i>), and the shell gives an unpleasant error message about the completely bogus switch.</p><p>So we can omit the first line:</p><PRE>eval 'exec perl -S $0 ${1+"$@"}'if 0;# real Perl code begins here</PRE><p>This solution is inspired by Thomas Esser's <i>epstopdf</i> utility, and it seems to work on Linux systems with both <i>perl my_script.pl</i> and <i>./my_script.pl</i>. But we can do better. The major flaw in this script is that it relies on the fact that the operating system recognizes executables beginning with ASCII characters as scripts, and runs them through <i>/bin/sh</i>. On some systems, a "Cannot execute binary file'' or "Exec format error'' may occur.</p><p>Note that this script is quite tricky since the first line is valid in both Perl and Bourne-compatible shells. (It doesn't work in the C shell, but we'll solve that problem later on.)</p><p>The solution has another problem: If someone gives the script a weird filename with spaces and other funny characters in it, such as:</p><PRE>-e system(halt)</PRE><p>then the command</p><PRE>perl -S -e system(halt)</PRE><p>will be executed, which is a disaster when there is a dangerous program named <i>halt</i> on the user's <i>$PATH</i>. This problem can be solved easily, by quoting <i>$0</i> from the shell, and prefixing it with <i>--</i> to prevent Perl from recognizing further options.</p><p>We have two conflicting requirements for the <i>#!</i> line: The portability requirement is that it must be exactly <i>#! /bin/sh</i>; but it must contain the word <i>perl</i> to avoid the infinite DEBUG loop described earlier. There is no single line that can satisify both of these requirements, but what about having two lines, then running <i>perl -x</i>, so the OS will parse the first and Perl will find the second?</p><PRE>#! /bin/sheval 'exec perl -S -x &#151; "$0" ${1+"$@"}'if 0;#!perl -w# real Perl code begins here</PRE><p>The trick here is that Perl, when invoked with the <i>-x</i> switch, ignores everything up to <i>#!perl</i>. Users of nonUNIX systems should invoke this script with <i>perl -x</i>. UNIX users may freely choose any of <i>perl my_script.pl</i>, <i>perl -x my_script.pl</i>, <i>./my_script.pl</i>, and even <i>sh my_script.pl</i>.</p><p>The subtle bilingual tricks in this script are worth studying. When the file is read by <i>perl -x</i>, it quickly skips to the real Perl code. When the file is read by the shell, it executes the line with <i>eval</i>: it calls <i>perl -x</i> with the script filename and command-line arguments. The double-quotes and <i>$@</i> are shell script wizardry, so things will work even when arguments contain spaces or quotes. The <i>-S</i> option tells Perl to search for the file in <i>$PATH</i> again because most shells leave <i>$0</i> unchanged (i.e., <i>$0</i> is the command the user has typed in).</p><p>Although the second and the third lines contain valid no-op Perl code, Perl never interprets these lines because of the <i>-x</i> switch. These lines are also completely ignored by <i>perl my_script.pl</i> because that immediately invokes <i>/bin/sh</i>. However, when the user loads this script with the <i>do</i> Perl built-in, the second and third lines get compiled and interpreted, a harmless no-op code is run, and no syntax error occurs.</p><p>There are still deficiencies that remain:</p><ul>  <li>It doesn't work in the C shell. We have already solved this earlier in this section.  <li>It reports line numbers in error messages relative to the <i>#!perl -w</i> line.  <li>It prints warnings when locale settings are invalid. (Try setting <i>'export LANG=invalid'</i> in Bash before running the script to see the ugly warning messages.)</ul><p>With regard to the line number problem, the <i>do</i> Perl built-in can be used to reread the script with a construct like this:</p><PRE>BEGIN{ if(!$second_run){ $second_run=1; do($0); die $@ if $@; exit } }</PRE><p><i>BEGIN</i> is required here to prevent Perl from compiling the whole file and possibly complaining about syntax errors with the wrong line numbers. The <i>die $@ if $@</i> instruction will print runtime error messages correctly. See <i>perlvar(1)</i> for details about <i>$@</i>. Unfortunately the code</p><PRE>BEGIN{ if(!$second_run){ $second_run=1; do($0); die $@ if $@; exit } }die 42;</PRE><p>yields an extra error message "BEGIN failed&#151;compilation aborted." This error is confusing because <i>die 42</i> causes a run-time error, not a compile-time error. To get rid of the message, we should eliminate <i>exit</i> somehow, and tell Perl not to continue parsing the input after <i>} }</i>. We'll use the <i>__END__</i> token to stop parsing early enough.</p><p>The locale warning is a multiline message starting with "perl: warning: Setting locale failed." Perl emits this if the locale settings specified in the environment variables <i>LANG</i>, <i>LC_ALL</i>, and <i>LC_*</i> are incorrect. See <i>perllocale(1)</i> for details. The real fix for this warning is installing and specifying locale correctly. However, most Perl scripts don't use locale anyway, so a broken locale doesn't do any harm to them.</p><p>Although Perl is a good diagnostics tool for locale problems, most of the time we don't want such warning messages, especially not in CGI (these warnings would fill the web server's log file), or some system daemon processes, when the program is prohibited from writing to <i>stderr</i> on normal operation. The system administrator should really fix locale settings, but that can take time. Most users don't have time to wait weeks to run a single Perl script that doesn't depend on locale anyway.</p><p>The <i>perllocale(1)</i> man page says that <i>PERL_BADLANG</i> should be set to a true value to get rid of locale warnings. Actually, <i>PERL_BADLANG</i> must be set to a nonempty, nonnumeric string (for example, <i>PERL_BADLANG=1</i> doesn't work). So we'll set it to <i>PERL_BADLANG=x</i> in the shell script section. Note that this has no effect if Perl is invoked before the shell. For example, <i>perl</i>, <i>perl -x</i>, <i>perl -S</i>, and <i>perl -x -S</i> all emit the warning long before the shell has a chance to change <i>PERL_BADLANG</i>.</p><h3>The Finished Header</h3><p>Combining it all together, we have the final version of the Magic Perl Header; see <A NAME="re1"><A HREF="0304ce1.htm">Example 1</A>. The file should have the executable attribute on UNIX systems.</p><p>This header is valid in multiple languages, so its meaning depends on the interpreter. Fortunately, the final effect of the header in all interpreters is that <i>perl</i> gets invoked running the real Perl code after the header. Let's see how the header achieves this:</p><ul>  <li>When executed with <i>perl</i>, without the <i>-x</i> switch, Perl runs <i>/bin/sh</i> immediately. (<i>/bin/sh</i> may be any type of shell.)  <li>Bourne and Korn shell variants interpret the file as:</ul><BLOCKQUOTE><PRE>#! /bin/sh &#151;true &amp;&amp; eval '...; exec perl -T -x -S "$0" #{1+"$@"}' # commentgarbage</PRE> So they run <i>perl -x</i>.</BLOCKQUOTE><ul>  <li>C shell variants interpret the file as:</ul><BLOCKQUOTE><PRE>#! /bin/sh --false &amp;&amp; eval '...' ;eval '...; exec perl -T -x -S &#151; "$0" $argv:q'  # commentgarbage</PRE>  So they run <i>perl -x</i>.</BLOCKQUOTE><ul>  <li>	    The backslash at the end of the second line of the header seems to be superfluous, but it isn't because csh doesn't allow the breaking of the line in the midst of the string without a backslash.  <li>The operating system runs the file by running <i>/bin/sh</i>, some shell variant. This is true even for ancient systems that don't know about the <i>#!</i>-hack, but just treat ASCII files as shell scripts.  <li><i>perl -x</i> interprets the file as:</ul><BLOCKQUOTE><PRE>#!perl -wuntaint $0; do $0; die $@ if $@; __END__garbage</PRE>  So it runs the current file again, with <i>do</i>, not respecting the <i>#!</i> lines. This is a good idea to make error line numbers come out correctly.</BLOCKQUOTE><ul>  <li>	The only way to untaint a value is regexp subexpression matching. We use it in <i>$0=~/(.*)/s</i>.  <li><i>do $0</i> treats the file as:</ul><BLOCKQUOTE><PRE>eval 'garbage' if 0;eval 'garbage' . q+garbage+ if 0;# real Perl code</PRE></BLOCKQUOTE><ul>  <li><i>	do $0</i> doesn't consult <i>$ENV{PATH}</i> for the location of the script (it iterates over <i>@INC</i>), but by the time <i>do $0</i> is invoked, <i>$0</i> already has the relevant component of <i>$ENV{PATH}</i> prepended to it if a path search was done, so <i>@INC</i> won't be examined here. Note that <i>$0</i> may be a relative pathname, but this isn't a problem since <i>chdir()</i> was not called since the path search. Without the <i>index</i> function in the script, <i>do</i> would have looked at <i>@INC</i> and found the Perl built-in <i>ftp.pl</i> instead of our magic script named <i>ftp.pl</i> when calling <i>perl -x ftp.pl</i> in the current directory.  <li>The real Perl code is compiled only once because the previous read (invoking <i>do $0</i>) has finished compilation at the <i>__END__</i> token. The real compilaion bypasses the <i>__END__</i> token because it is part of the single-quoted string <i>q+garbage+</i>.  <li>Error line numbers are reported correctly because compilation occurs inside <i>do</i>, which ignores <i>#!</i>. Both compile-time and run-time errors, including manual calls to <i>die()</i>, are caught and reported early by the <i>die $@ if $@</i> statement. Each error is reported only once because the real Perl code is compiled once.  <li>The real code may contain any number of <i>exit()</i>, <i>exec()</i>, <i>fork()</i>, and <i>die()</i> calls, and they will work as expected. <i>return</i> outside a subroutine is fortunately disallowed in pure Perl, so we don't have to treat this case.  <li><i>push@INC,"."</i> is required by <i>perl 5.8.0 -T</i>.</ul><p>So the real Perl code gets executed, even on old UNIX systems, no matter how the user starts the program. The header is suitable for inclusion into CGI scripts. (In nonCGI programs, where extreme security is not important, occurences of the <i>-T</i> option can be removed.)</p><p>All of the following work perfectly, without the locale warning:</p><PRE>DIR/nice.pl         # preferredash  DIR/nice.plsh   DIR/nice.plbash DIR/nice.plcsh  DIR/nice.pltcsh DIR/nice.plksh  DIR/nice.plzsh  DIR/nice.pl</PRE><p>The following invocations are fine:</p><PRE>perl -x -S DIR/nice.pl	# locale-warningperl DIR/nice.pl	# locale-warningperl -x DIR/nice.pl	# locale-warningperl -x -S nice.pl	# locale-warning; only if on # $PATH, recommended on Win32perl nice.pl		# locale-warning; only from curdirperl -x nice.pl	# locale-warning; only from curdirnice.pl		# only if on $PATH (or $PATH contains '.')</PRE><p>The following don't work, because buggy Perl 5.004 tries to run <i>/bin/sh -S nice.pl</i>:</p><PRE>perl -S nice.pl	# doesn't work perl -S DIR/nice.pl	# doesn't work</PRE><p>Of course, there is a noticeable performance penalty: <i>/bin/sh</i> is started each time the script is invoked. This cannot be completely avoided because <i>PERL_BADLANG</i> has to be set before <i>perl</i> gets invoked. After the shell has finished running, one line of helper Perl code is parsed (after <i>#!perl</i>), and the <i>do</i> causes five lines of helper code to be parsed. The time and memory spent on these six lines is negligible. So the only action that slows script startup is the shell. If the user sets and exports <i>PERL_BADLANG=x</i>, fast startup is possible by calling:</p><PRE>perl -x -S nice.plperl -x DIR/nice.pl</PRE><p>In a Makefile, you should write:</p><PRE>export PERL_BADLANG=xgoal:    perl -x DIR/nice.pl</PRE><p>The command-line options <i>-n</i> and -<i>p</i> would fail with this header. This is not a serious problem because <i>-n</i> can be implemented as wrapping the code inside <i>while (&lt;&gt;) { ... }</i>, and <i>-p</i> can be changed to the wrapping <i>while (&lt;&gt;) { ... } continue { print }</i>.</p><h3>Header Wizard</h3><p>I've implemented a Header Wizard that automatically adds the Magic Perl Header to existing Perl scripts. The Header Wizard is available from http://www.inf.bme.hu/~pts/Magic.Perl.Header/ magicc.pl.zip. [<i>For convenience, we have also posted this at http://www.tpj.com/source/, though downloading from the author's site guarantees that you get the most recent version. -Ed.</i>] </p><p>The easy recipe for the universally executable Perl script:</p><p>1.	Write your Perl script as usual. You may call <i>exit()</i> and <i>die()</i> as you like.</p><p>2.	Specify the <i>#! ... perl</i> line as usual. You may put any number of options, but the <i>-T</i> option must either be missing or specified alone (separated with spaces). Example: <i>#! /dummy/perl -wi.bak -T</i>. See <i>perlrun(1)</i> and <i>perlsec(1)</i> for more information about the <i>-T</i> option.</p><p>3.	Run <i>magicc.pl</i> (the Header Wizard), which will prepend an eight-line magic header containing the right options to the script, and it will make the script file executable (with <i>chmod +x ...</i>). (The <i>-T</i> option will be moved after both <i>exec perl</i>s, and other options will be moved after <i>#!perl</i> because Perl looks for switches only there.)</p><p>4.	Run your script with a slash, but without <i>sh</i> or <i>perl</i> on the command line. For example: <i>./my_script.pl arg0 arg1 arg2</i>. After you have moved the script into <i>$PATH</i>, run it just as <i>my_script.pl arg0 arg1 arg2</i>. (This avoids the locale warnings and makes options take effect.) Should these invocations fail on a UNIX system for whatever reason, please feel free to e-mail me. As a quick fix, run the script with <i>perl -x -S ./my_script.pl arg0 arg1 arg2</i>.</p><p>5.	Note that on Win32 systems, <i>perl -x -S</i> is the only way to run the script. You may write a separate .bat file that does this.</p><p>6.	Tell your users that they should run the script the way described in Step 4. There is a high chance that it will work even for those who don't follow the documentation.</p><h3>Conclusion</h3><p>For such a widely implemented language, Perl can be suprisingly hard to invoke reliably on a variety of platforms. I hope this Header Wizard helps you to write Perl scripts that will start with a minimum of fuss on just about any system.</p><p><b>TPJ</b></p></body></html>