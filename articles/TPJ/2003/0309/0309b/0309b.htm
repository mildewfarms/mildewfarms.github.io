<html><head><title>Sep03: Building Custom Tk Widgets in Pure Perl</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; The Perl Journal--><h1>Building Custom Tk Widgets in Pure Perl</h1><p><i>The Perl Journal</i> September 2003</p><h3>By Ala Qumsieh</h3><I>Ala works at NVidia Corp. as a physical ASIC designer. He can be reached at aqumsieh@cpan.org.</I><hr><p>One of the most useful Perl modules available on CPAN is Nick Ing-Simmons's Tk.pm. Also known as Perl/Tk, this is a port of Tcl/Tk with a Perl object-oriented front-end API. It is used to create graphical user interfaces, and contains a wide variety of widgets that should be sufficient to build the most sophisticated and professional looking GUIs.</p><p>Yet, there are times when you would like to add an extra touch to your application to make it stand out among the crowd. While a great number of user-contributed "mega-widgets" exist as modules on CPAN, almost all of them are built by combining native widgets together. While very convenient, this does not add visual uniqueness to an application. Of course, you can always interface directly with the underlying graphic display library via writing a C extension. In fact, a number of such modules exist, but the obvious limitations are the need to understand the low-level Tk API (which requires quite a bit of C experience, due to the API's extensive use of pointers and structures), and the need for users to compile the module before installation.</p><p>In this article, I will discuss a way to create visually unique-looking Tk widgets in pure Perl by using the Canvas widget. I do not claim ownership of this idea. In fact, it was suggested to me in an e-mail exchange on the pTk mailing list by Slaven Rezic. Also, I know of at least one Tk module, <i>Tk::ProgressBar</i>, that uses this technique, and that comes standard with the Perl/Tk distribution.</p><h3>The Canvas Widget</h3><p>The Canvas widget is the most powerful and most versatile of all Tk widgets. In addition to being able to draw primitives like lines, ovals, arcs, polygons, and text, the Canvas can contain embedded images and even other Tk widgets. It also has built-in mechanisms to handle grouping, overlap detection, z-ordering, translation, and scaling. This makes it a powerful tool for the creation of custom-looking widgets. Graham Barr used a Canvas to create his <i>Tk::ProgressBar</i> widget, which graphically shows the current value of a certain variable as it advances from a specified minimum to a specified maximum.</p><p>One unfortunate property of the Canvas widget is that, due to the inherent window-management mechanism, embedded widgets always obscure other primitives irrespective of the z-order. While this doesn't pose any problems for most applications, it would be nice if embedded widgets could respect their z-order. Being able to draw on <i>Button</i> and <i>Entry</i> widgets would definitely constitute a deviation from the traditional ways of GUI building, but would open up new pathways for people with fertile imagination.</p><p>Upon pointing this out to the Perl/Tk mailing list, Slaven Rezic suggested not using embedded Tk widgets at all, but rather using the Canvas primitives to "draw" the widgets to be embedded. This gave me the idea to create <i>Tk::FunkyButton</i> (which is a Perl/Tk widget written in pure Perl and based on the Canvas widget) that defines various nonstandard looking buttons, such as circular and cross shaped. Moreover, we can create special-effects buttons that are not just static. <i>Tk::FunkyButton</i> includes two such buttons: a vanishing button, in which the text slowly and repeatedly vanishes and reappears, and a rotating button, in which the text loops around the button (see <A NAME="rf1"><A HREF="0309bf1.htm">Figure 1</A>).</p><h3><i>Tk::FunkyButton</i></h3><p>The first step in creating a Perl/Tk mega widget is to define its base widgets and call the <i>Construct()</i> method. I will quickly outline the steps to a mega-widget creation. More detailed information can be found in <i>Mastering Perl/Tk</i> by Walsh &amp; Lidie (O'Reilly &amp; Associates, ISBN 1-56592-716-8).</p><PRE>package Tk::FunkyButton;use strict;use Carp;use vars qw/$VERSION/;$VERSION = 0.1;use Tk::widgets qw/Canvas/;use base qw/Tk::Derived Tk::Canvas/;Construct Tk::Widget 'FunkyButton';1;</PRE><p>Because this widget is derived from a Canvas, we use <i>Tk::Derived</i> and <i>Tk::Canvas</i> as base objects. The <i>Construct()</i> method is defined in Tk/Widget.pm, and defines a method in the </i><i>Tk</i> namespace with the name <i>FunkyButton</i>. This lets us create instances of our <i>FunkyButton</i>s like so:</p><PRE>$parent-&gt;FunkyButton($args);</PRE><p>The lonely "1;" is there to satisfy Perl's requirement that all modules return a true value. Now, we define a lexical hash that maps the possible shapes our <i>FunkyButton</i>s can have to the respective subroutines that will do the actual drawing:</p><PRE>use vars qw/%shapeToFunc/;%shapeToFunc = (            cross     =&gt; \&amp;_drawCross,            circle    =&gt; \&amp;_drawCircle,            rotary    =&gt; \&amp;_drawRotary,            vanishing =&gt; \&amp;_drawVanishing,            );</PRE><p>Next is to define the <i>ClassInit()</i> method:</p><PRE> sub ClassInit {     my $class = shift;     $class-&gt;SUPER::ClassInit(@_); }</PRE><p>This method gets called only once before the first <i>FunkyButton</i> instance is created. All it does in this case is to call the <i>ClassInit()</i> method defined somewhere in the class hierarchy of our widget, but we can use it to make class-wide adjustments. Since we don't do anything but call <i>SUPER::ClassInit()</i>, we can omit this method, and Perl's inheritance mechanism will take care of that for us.</p><p>When a new <i>FunkyButton</i> widget is to be created, the <i>Populate()</i> method gets called. This is the main place where your widget springs into existence, and this is where we will inspect the arguments to <i>FunkyButton</i> and call the proper function to draw it. It starts like this:</p><PRE>sub Populate {    my ($self, $args) = @_;      my $shape = delete $args-&gt;{-shape} || 'cross';        unless (exists $shapeToFunc{$shape}) {          croak "-shape must be one of: ", join(", ", keys %shapeToFunc)," ..";          return undef;        }        my $text = delete $args-&gt;{-text}        || '';        my $cmd  = delete $args-&gt;{-command}     || sub {};        my $relf = delete $args-&gt;{-relief}      || 'raised';        my $bw   = delete $args-&gt;{-borderwidth} || 2;        my $bg;        if      (exists $args-&gt;{-bg}) {                $bg = delete $args-&gt;{-bg};        } elsif (exists $args-&gt;{-background}) {                $bg = delete $args-&gt;{-background};        } else {                $bg = Tk::NORMAL_BG;        }        # now specify canvas-specific options.        $args-&gt;{-background}  = $self-&gt;parent-&gt;cget('-background');        $args-&gt;{-borderwidth} = 0;        $args-&gt;{-relief}      = 'flat';        $self-&gt;SUPER::Populate($args);</PRE><p>The two arguments of <i>Populate</i> are a reference to the created widget, and a reference to the arguments hash that the user passed. Since <i>FunkyButton</i> is based on a Canvas, our reference is a reference to a Canvas widget that has been blessed into our <i>Tk::FunkyButton</i> package. The first thing to do is to extract the information needed from the arguments. As a rule of thumb, try to give default values to each argument and <i>croak()</i> if the user supplies something you don't understand. Once all the info is extracted, we call the <i>Populate()</i> method that is defined in the superclass of our widget; in this case, the <i>Populate()</i> of <i>Tk::Canvas</i> will be called. This is necessary to make sure that all the features of <i>Tk::Canvas</i> get defined for us. Be sure to pass the arguments hash reference, after some editing perhaps, to <i>SUPER::Populate()</i>.</p><p>The next bit of code uses the shape option specified by the user to call the correct function to draw the button with the specified options:</p><PRE> $self-&gt;{MY_BUTTON} = $shapeToFunc{$shape}-&gt;($self, $text, $relf, $cmd,                                                             $bw, $bg, $spd);</PRE><p>The rest of the <i>Populate()</i> method deals with informing the window manager with our <i>FunkyButton</i>'s desired dimensions and with setting up the bindings for our button so that it responds to mouse events. I will not show this code here&#151;it can be found in <i>Tk::FunkyButton.pm</i> and should be straightforward.</p><h3>Drawing the <i>FunkyButton</i></h3><p>The <i>%shapeToFunc</i> hash maps the type of button to be drawn to the actual subroutine that draws the button. Currently, there are four types of buttons available: cross-shaped, circular, rotary, and vanishing. All of the subroutines that draw these buttons have the same general steps:</p><p></p><p><b>1. Compute the size of the button.</b> This is simply done by drawing the text of the button at (0, 0) and then using the <i>Canvas::bbox()</i> method to determine its bounding box. This area is multiplied by a factor, which was determined by trial and error, to get the final size of the button.</p><p><b>2. Draw the outline of the button.</b> To help draw the 3D outline of the button, I defined two subroutines: <i>_draw3DHorizontalBevel</i> and <i>_draw3DVerticalBevel</i>. Those subroutines are based on Tk's actual C code that draws the buttons (and are even named similarly), and are used to draw a single horizontal or vertical 3D edge. The arguments to these subroutines are the starting (x, y) location of the edge to be drawn, the edge's width and height, its relief, whether the edge is "in the shadow," the miter setting, and any tags that we want to give to that edge. In a normal button, the top and left edges are almost white in color while the right and bottom edges are dark grey. This gives the illusion of a 3D button with some sort of illumination coming from the top left. The shadow option specifies what kind of edge we're drawing, and hence its color. The color is also determined by the relief of the button. The miter setting defines the corner where a light and a dark edge meet is drawn. In case of the cross-shaped button, for example, we have to draw 12 edges, six of which are "in the light" and six "in the shadow."</p><p><b>3. Draw the background of the button.</b> Step 3 draws the background of the button with the color specified by the user (or the default system color if nothing is specified). The background is used to respond to the mouse events.</p><p><b>4. Center the text.</b> Now that the button is drawn, all we have to do is move the text that we drew in step 1 to the center of the button.</p><p>I will not include the code for the <i>_draw*</i> methods here, but the code should be self explanatory, especially with the aforementioned four steps in mind. Note that at this point, <i>Tk::FunkyButton</i> does not support images, but this can very easily be incorporated into the module.</p><p>The cross-shaped and circular buttons are the result of the four steps defined earlier. But the vanishing and rotating buttons deserve a closer look since they involve some special effects.</p><h3>Vanishing Button</h3><p>As stated earlier, the text for this button vanishes slowly and reappears repeatedly, as if pulsating. The speed of this pulse can be specified using the <i>-speed</i> option, which can take a value of <i>fast</i>, <i>normal</i> (the default), or <i>slow</i>. This value is used to look up a corresponding time delay (100 ms for <i>fast</i>, 500 ms for <i>normal</i>, and 1000 ms for <i>slow</i>).</p><p>The subroutine to draw a vanishing button first follows the mentioned four steps to draw a regular-looking button with the text centered. In order to achieve the pulsating effect, all we have to do at each time step is to make the text fade a little bit more. Once the text disappears completely, we have to make it reappear slowly. This can be achieved by using stipples. A stipple is a bitmap that is used as a pattern when drawing an object. It acts like a mask to hide certain parts of the object. All we have to do to achieve our fading effect is to define a suitable number of stipples that progressively show less and less of the object. Luckily, Perl/Tk comes with a few bitmaps that prove sufficient for our purposes. Those are:</p><PRE>my @stipples = ('', qw/gray75 gray50 gray25 transparent/);</PRE><p>Now, we use Tk's <i>repeat()</i> mechanism to run a callback at even intervals:</p><PRE>my $i   = 0;my $inc = 1;$self-&gt;repeat($delay =&gt; sub {              $i += $inc;              $inc = -1 if $i == $#stipples;              $inc =  1 if $i == 0;              $self-&gt;itemconfigure(TEXT =&gt; -stipple =&gt; $stipples[$i]);            });</PRE><p>Initially, we draw the text without a stipple. Then, at each time step, we advance through the <i>@stipples</i> array to get the next stipple and use that to draw the text. We have to make sure that once we reach the end of the array, we start going in reverse order. This is done via the <i>$i</i> and <i>$inc</i> variables, which keep track of where we are in the array, and in what direction we're moving, respectively.</p><h3>Rotary Button</h3><p>The text of the rotary button simply scrolls around the button repeatedly. Again, the speed of this rotation is controlled via the  <i>-speed</i> option. To achieve the desired effect, we use the <i>Canvas::move()</i> method to translate the text horizontally to the left. Once the text disappears completely, we simply move it such that its left-most point coincides with the button's right edge and continue with the translation. The code is again very simple:</p><PRE>my @orig = $self-&gt;coords('TEXT');$self-&gt;repeat($delay =&gt; sub {              $self-&gt;move(TEXT =&gt; -3, 0);              my @box = $self-&gt;bbox('TEXT');              if ($box[2] &lt; 0) {                $self-&gt;coords(TEXT =&gt; $w + 0.5 * ($box[2] - $box[0]),                              $orig[1]);              }            });</PRE><p>Here, we used the fact that our text is tagged with the TEXT string so that we can identify it. To check if the text has completely scrolled off to the left of the button, all we have to do is see whether the right-most x-coordinate (<i>$box[2]</i>) of the text is positive or not. If not, we move it just past the right edge of the button.</p><h3>Getting and Installing the Module</h3><p>You can grab a copy of <i>Tk::FunkyButton</i> from your local CPAN mirror at http://search.cpan.org/author/aqumsieh/. The latest version as of the date of writing of this article is 0.01. You can install it using the traditional method:</p><PRE>perl Makefile.PLmakemake testmake install</PRE><p>Alternatively, since it's all in pure Perl, you can unpack it in any place where Perl will find it.</p><h3>Conclusion</h3><p>Tk's Canvas widget is a very powerful widget that can be used to create nontraditional looking widgets. The built-in drawing primitives of <i>Tk::Canvas</i>, along with its support for querying, moving, and modifying those primitives make it an ideal canvas (pun intended) for creating unique-looking and dynamic widgets. There is much more potential to be exploited. Any questions regarding the <i>Tk::FunkyButton</i> and/or suggestions to improve it are very welcome.</p><p><b>TPJ</b></p></body></html>