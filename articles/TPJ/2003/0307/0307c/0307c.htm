<html><head><title>Jul03: Enhancing Terminal Output in Perl</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; The Perl Journal--><h1>Enhancing Terminal Output in Perl</h1><p><i>The Perl Journal</i> July 2003</p><h3>By Shay Harding</h3><I>Shay has worked  with transaction processing systems at CCBill LLC, for the last five years and can be contacted at sharding@ccbill.com.</I><hr><p>This article discusses how to make terminal output easier to read and monitor. If you are like me and spend most of the day at a UNIX command prompt, you'll probably benefit from using <i>Term::Report</i> and <i>Term::StatusBar</i>, two modules I created for making terminal output easier to track. They can be used separately, but are best if used together. These modules have few dependencies, which are loaded as required, so there is no need to install anything new.</p><p>Typically, programs send their output to STDOUT or STDERR. If there are too many lines sent to the terminal, they end up scrolling and may be irretrievable depending on your terminal's buffer size. You can send the output to a file, but then how do you monitor the program to make sure everything is going well? You could <i>tail -f &lt;file&gt;</i>, but then you run into the same problem of output scrolling off of the screen.</p><p>The most important components of useful terminal output are:</p><p>1. The ability to see that the program is processing.</p><p>2. The ability to see what the program is doing.</p><p>3. The ability to track the program's progress.</p><p>With these criteria met, there is no doubt about whether the program has hung or what progress it has made in processing the data.</p><h3>Standard Terminal Output</h3><p>A simple example of terminal output seen in many scripts is shown in <A NAME="rl1"><A HREF="#l1">Listing 1</A>. This first example will not utilize <i>Term::Report</i> or <i>Term::StatusBar</i>. This will be modified later in order to show how the <i>Term</i> modules work and how they can be useful.</p><p>This listing prints the output to the terminal. If there were thousands of items to iterate over, the output would end up scrolling off the screen. Another problem is that there is no way to gauge progress and tell how long it might take to finish. The data sent to the terminal ends up being cluttered and not very useful. In processing larger data sets, it would be difficult to determine the program's output by using this method.</p><h3>Cleaning up the Output</h3><p>The previous output can be organized with the help of <i>Term::Report</i>. With minor alterations, the amount of output can be reduced, thus improving readability; see <A NAME="rl2"><A HREF="#l2">Listing 2</A>.</p><p>The use of <i>Term::Report</i> usually doesn't get any more complicated than the aforementioned example. But even this simple implementation of <i>Term::Report </i>makes the output more organized and easier to follow. It is readily apparent that the program is working and what data it is processing. Two important criteria for useful terminal output have been met.</p><p>If there are thousands of items to iterate over, the constructor can be changed as shown below:</p><PRE>my $report = Term::Report-&gt;new(startRow =&gt; 1, numFormat =&gt; 1);</PRE><p>This would format numbers using <i>Number::Format</i> (i.e., 1000 becomes 1,000). This makes it even easier to read the output quickly.</p><p>The last criterion, the ability to track the program's progress, is accomplished by using <i>Term::StatusBar</i>. Rather than create a separate object, use <i>Term::Report</i>'s ability to wrap the <i>Term::StatusBar</i> module. (See <A NAME="rl3"><A HREF="#l3">Listing 3</A>.)</p><p>Notice that <i>Term::Report</i> has been used to create a status bar. The status bar needs to know how many items there are to process. Then it's just a matter of calling <i>StatusBar-&gt;update()</i> with each iteration of data processing.</p><p>When updating the inventory in the aforementioned example, the status bar is reset rather than creating a new object. To tell the status bar to empty rather than fill, pass <i>reverse =&gt; 1</i> to the <i>reset()</i> method. This is a recent addition to <i>Term::StatusBar</i>. Calling the <i>printBarReport() </i>method outputs our statistics summary. This prints a horizontal bar chart based on the final values and scale of the status bar.</p><p>With these minor changes, all three criteria for useful terminal output are satisfied. Use the <i>subText</i> and <i>subTextAlign</i> methods of <i>Term::StatusBar</i> to enhance the output further. These place information just under the status bar to show what the program is currently processing.</p><PRE>my $report = Term::Report-&gt;new(   startRow =&gt; 4,   numFormat =&gt; 1,   statusBar =&gt; [      label =&gt; 'Widget Analysis: ',      subText =&gt; 'Locating widgets',      subTextAlign =&gt; 'center'   ],);...if (!($_%int((rand(10)+rand(10)+1)))){   $report-&gt;finePrint('discarded', 0, ++$discard);   $status-&gt;subText("Discarding bad widget");}else{   $status-&gt;subText("Locating widgets");}</PRE><p>Another new addition to <i>Term::StatusBar </i>is the <i>showTime</i> parameter. When turned on, an estimated time to completion is placed at the top of the status bar. Notice in the code below, the value of <i>startRow</i> has changed. This is to allow space for the estimated completion time. In a future version, this sort of manual adjustment probably will not be necessary.</p><PRE>my $report = Term::Report-&gt;new(   startRow =&gt; 5,   numFormat =&gt; 1,   statusBar =&gt; [      label =&gt; 'Widget Analysis: ',      subText =&gt; 'Locating widgets',      subTextAlign =&gt; 'center',      showTime =&gt; 1   ],);</PRE><p>If the module is unable to figure out the estimated time, then "00:00:00" will be displayed. When using the <i>reverse</i> method, there is no estimated time tracked. This will be possible in future releases of the module.</p><h3>Caveats and Possible Enhancements</h3><p><i>Term::StatusBar</i> has some limitations. It requires knowing up front how many items there are to process. This is so it can properly set its scale and appropriately update progress. Problems might arise in processing an extremely large file. Many computers do not possess enough memory to load an entire file in order to determine how many lines it contains.</p><p>Even if memory is not a factor, it would take a while to read these kinds of files twice: once for <i>Term::StatusBar</i> and once to process the data. We can determine a file's size by using the file test operator <i>-s</i>. This is only useful if the program reads a byte at a time. Usually, a file is read line-by-line, and each line may not be the same length in bytes. One strategy would be to sample lines in the file some number of times. The <i>sysopen</i>, <i>sysseek</i>, and <i>sysread</i> functions can be used to avoid using a lot of memory. However, this would only give a good guess and could be completely wrong depending on the unevenness of the line lengths of the file.</p><p>Another, and possibly more accurate way would be to use the file's size as a basis. Then, when calling <i>Term::StatusBar-&gt;update()</i>, pass it the length of the line just processed. This would allow accurate tracking of progress as the file was processed. This would also allow the processing of many types of files in the same fashion.</p><p>Another possible addition in the near future is a way to "serialize" the output to a file and reinstate it to the terminal at a later point in time. This would allow a process to run in the background and be monitored periodically.</p><p>While <i>Term::Report</i> and <i>Term::StatusBar </i>may not be perfect, they can help improve readability of terminal output. These modules give you the ability to monitor a program's progress and quickly determine its processing status. They may not work in every situation, but the goal is to make them usable in many situations.</p><p><b>TPJ</b></p><H4><A NAME="l1">Listing 1</H4><pre>#!/usr/bin/perl$|++;use Time::HiRes qw(usleep);my ($items, $discard) = (100,0);## Monitor inventory (L=Locating; D=Discarding)for (1..$items){   if (!($_%int((rand(10)+rand(10)+1)))){      $discard++;      print " D ";   }   else {      print "L";   }   usleep(50000);}print "\n";## Update inventoryfor (1..($items-$discard)){   print "U";}print "\n\n\n    Summary for widgets: \n\n".      "       Total:        $items\n".      "       Good Widgets: ".($items-$discard)."\n".      "       Bad Widgets:  $discard\n\n";</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing 2</H4><pre>#/usr/bin/perl$|++;use Time::HiRes qw(usleep);use Term::Report;my $report = Term::Report-&gt;new(startRow =&gt; 1);my ($items, $discard) = (100,0);$report-&gt;savePoint('total', "Total widgets: ", 1);$report-&gt;savePoint('discarded', "\n  Widgets discarded: ", 1);## Monitor inventory for (1..$items){   $report-&gt;finePrint('total', 0, $_);   if (!($_%int((rand(10)+rand(10)+1)))){      $report-&gt;finePrint('discarded', 0, ++$discard);   }   usleep(50000);}## Update inventory$report-&gt;savePoint('inventory', "\n\nInventorying widgets... ", 1);for (1..($items-$discard)){   $report-&gt;finePrint('inventory', 0, $_);}$report-&gt;printLine("\n\n\n\n    Summary for widgets: \n\n");$report-&gt;printLine("       Total:        $items\n");$report-&gt;printLine("       Good Widgets: ".($items-$discard)."\n");$report-&gt;printLine("       Bad Widgets:  $discard\n");</pre><P><A HREF="#rl2">Back to Article</A></P><H4><A NAME="l3">Listing 3</H4><pre>#!/usr/bin/perl$|++;use Time::HiRes qw(usleep);use Term::Report;my $report = Term::Report-&gt;new(   startRow =&gt; 4,   numFormat =&gt; 1,   statusBar =&gt; [      label =&gt; 'Widget Analysis: ',   ],);my ($items, $discard) = (100,0);my $status = $report-&gt;{statusBar};$status-&gt;setItems($items);$status-&gt;start;$report-&gt;savePoint('total', "Total widgets: ", 1);$report-&gt;savePoint('discarded', "\n  Widgets discarded: ", 1);## Monitor inventoryfor (1..$items){   $report-&gt;finePrint('total', 0, $_);   if (!($_%int((rand(10)+rand(10)+1)))){      $report-&gt;finePrint('discarded', 0, ++$discard);   }   usleep(50000);   $status-&gt;update;}## Update inventory$status-&gt;reset({    reverse=&gt;1,     setItems=&gt;($items-$discard),     start=&gt;1});$report-&gt;savePoint(   'inventory',    "\n\nInventorying widgets... ",    1);for (1..($items-$discard)){   $report-&gt;finePrint('inventory', 0, $_);   $status-&gt;update;}   $report-&gt;printBarReport(      "\n\n\n\n    Summary for widgets: \n\n",      {            "       Total:        " =&gt; $items,            "       Good Widgets: " =&gt; $items-$discard,            "       Bad Widgets:  " =&gt; $discard,      }   );</pre><P><A HREF="#rl3">Back to Article</A></P></body></html>