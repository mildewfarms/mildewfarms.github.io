<html><head><title>Jul03: Five Ways to  Find Files</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; The Perl Journal--><h1>Five Ways to  Find Files</h1><p><i>The Perl Journal</i> July 2003</p><h3>By Andy Lester</h3><I>Andy manages programmers for Follett Library Resources in McHenry, IL. In his spare time, he works on his CPAN modules and does technical writing and editing. He can be contacted at andy@petdance.com.</I><hr><p>For most command-line utilities you'll write in Perl, chances are you'll need to operate on multiple files in the filesystem. As you'd expect, there's more than one way to do it, and you should choose your method based on the specifics of the task at hand. Do you want a list of files, or do you want to iterate over them? Do you need to operate on directories as well as files?  Do you need to find files in subdirectories, too? In this article, I'll show you five different ways your Perl program can find files. </p><p>No matter which method you choose, remember that searches will be relative to your current directory. Make sure that any solution you choose gives you filenames with path information. It doesn't help to get a filename of "foo.pl" if the file is three directory levels down. </p><h3>UNIX <i>find</i></h3><p>UNIX is filled with tools designed to do one thing well, and the <i>find</i> utility fits this description. If you're comfortable with <i>find</i>'s options, then it may make sense to use <i>find</i> from inside your Perl program and parse its output. This approach also has the advantage of making it easy for you to debug the rules you're using in the shell, and then wrap it up in your Perl code. </p><p><i>find</i> can be a bit cumbersome to use from the command line, but for simple searches, it does just fine. The following works from the shell for our example: </p><PRE>$ find . -name '*.pl' -o -name '*.pm' -o -name '*.t' -print    ./lib/WWW/Mechanize.pm    ./t/00.load.t    ./t/99.pod.t    ... etc ... </PRE><p><i>find</i> takes a starting directory, and then a series of options that tell which files you're interested in. The <i>-name</i> '*.pl' tells <i>find</i> to find files that match the pattern <i>*.pl</i>. The <i>-o</i> is the "or" option. Chained together, <i>find</i> finds anything that matches <i>*.pl</i>, <i>*.pm,</i> or <i>*.t</i>, and then <i>-print</i> tells <i>find</i> to print the found file to standard output. If you're using GNU <i>find</i>, you can leave off the <i>-print</i>, as it's assumed to be the action to take. </p><p>Note that you must single quote the pattern, or else the shell will expand the wildcard. For example, if you use: </p><PRE>find . -name *.pl -print </PRE><p>and there is one file in the current directory, and it is named "foo.pl," the shell will expand into </p><PRE>find . -name foo.pl -print </PRE><p>which tells <i>find</i> to only find files named "foo.pl," which is certainly not what you wanted. </p><p>Now that I have a working <i>find</i> command, I copy it into my Perl program and surround it with the backtick operators. To get the output from find into a list, use the backtick operator and read the lines into an array. </p><PRE>my @files = 'find  -name '*.pl' -o -name '*.pm' -o -name '*.t''; </PRE><p>Each line of the output from the <i>find</i> will be put into the <i>@files</i> array. They're not ready to be used yet, because each line has a "\n" at the end, so we just have to chomp it off. </p><PRE>chomp @files; </PRE><h3><i>opendir/readdir/closedir</i></h3><p>For a purely Perl solution, you have three options: <i>readdir</i>, globbing, or modules. I'll start with <i>readdir</i>.</p><p>Perl has the concept of <i>dirhandles</i> that act like filehandles, but let you iterate through entries in a directory in much the same way as iterating through lines of a text file. <i>dirhandles</i> are opened with <i>opendir</i>, read from with <i>readdir</i>, and closed with <i>closedir</i>.</p><p>In scalar context, <i>readdir</i> returns the next directory entry, or <i>undef</i> if there are no more. In list context, it returns all the directory entries. What makes <i>readdir</i> a challenge is that "directory entry" could be anything: a plain file, a directory, a symlink, special directories such as "." and "..", and so on. </p><p>For single-directory searching, <i>readdir</i> is pretty handy. Since it can return a list, it's easy to filter your files through <i>grep</i>, as in: </p><PRE>opendir( DIR, $dir ) or die "Can't open $dir";    my @files = grep -f "$dir/$_" &amp;&amp; /\.(pl|pm|t)$/, readdir DIR;    closedir DIR; </PRE><p>Each entry from <i>readdir</i> is checked to see if it's a plain file and ends in .pl, .pm or .t. Note that we have to prepend the <i>$dir</i> before we check the <i>-f</i> operator. Because <i>readdir</i> only returns the basename, not the full path, if <i>$dir</i> is anything other than ".", the test results will be inaccurate. This bit me during testing, so keep it in mind.</p><p>This approach with <i>readdir</i> works nicely for single directories, but for entire trees you need to create a recursive function. </p><PRE>my @files = get_files( "." ); sub get_files {        my $dir = shift;         opendir( DIR, $dir ) or die "Can't open $dir";        my @entries = readdir(DIR);        closedir DIR;         my @files;        for my $entry ( @entries ) {            # Skip current &amp; parent directories, lest we loop            next if $entry eq "." || $entry eq "..";             my $fullpath = "$dir/$entry";            if ( -f $fullpath ) {                if ( $entry =~ /\.(pm|pl|t)$/ ) {                    push( @files, $fullpath );                }            } elsif ( -d $fullpath ) {                push( @files, get_files( $fullpath ) );            }        } # for         return @files;    } </PRE><p>The <i>get_files</i> subroutine is basically the same as grepping through the list of <i>readdir</i> entries, but it recursively calls itself to get the contents of subdirectories. The full path name for each file must be built in each call to <i>get_files</i>, since <i>readdir</i> only returns filenames, not paths. Also, I need to <i>readdir</i> the entire directory at once, or else reading the global <i>DIR</i> in the recursed call to <i>get_files</i> will mess up the parent. </p><h3><i>globbing</i></h3><p>The <i>glob</i> operator &lt;&gt; and its spelled-out cousin <i>glob</i> can be an improvement over <i>readdir</i>, both for brevity and for providing shell filename-matching semantics. For example, <i>glob</i> does not return the "." and ".." directory entries, or any other file that starts with ".". It understands character classes like <i>*.p[lm]</i>, alternation such as <i>*.{pl,pm,t}</i>, and will expand the tilde to a home directory.</p><p>The first <i>readdir</i> example would be written with <i>glob</i> as: </p><PRE>my @files = grep -f, &lt;*.{pl,pm,t}&gt;; </PRE><p>I prefer the <i>glob</i> keyword in most cases. It looks less like line noise, and can't get confused with the diamond operator in file-reading context. </p><p>Updating the sample <i>get_files</i> from above to use <i>glob</i> is left as an exercise to the reader, but only if the reader wants to do more work than necessary. <i>glob</i> is meant only for single directories, so to handle directory structures, use <i>readdir</i>. Or, you can use our next file-finding method, <i>File::Find</i>.</p><h3><i>File::Find</i></h3><p>The <i>File::Find</i> module takes care of all the mess with directory descending that I've shown you in the previous examples, plus it adds a number of handy features. <i>File::Find</i> has been included with Perl since Perl 5.00307, and is available on CPAN if you have an older version.</p><p><i>File::Find</i> only has two functions, <i>find</i> and <i>finddepth</i>. They're identical except for <i>finddepth</i> performing a depth-first search. <i>find</i> takes a reference to a callback subroutine, often called "<i>wanted</i>" and a list of starting directories to start searching through. For each file or directory <i>find</i> finds, <i>wanted</i> is called, allowing you to perform actions and check information about the file.</p><p>When <i>wanted</i> is called, the following global variables will be set:</p><ul>  <li><i>$_</i> Set to the current filename in the current directory <i>$File::Find::dir</i>.  <li><i>$File::Find::dir</i> Set to the name of the current directory. <i>File::Find</i> automatically <i>chdir</i>s you to this directory when <i>wanted</i> is called.   <li><i>$File::Find::</i> Name the full path name, relative to the starting directory, of the current file. This is simply "$<i>File::Find::dir/$_</i>", and it is mostly a convenience.</ul><p>One of the simplest ways to use <i>File::Find</i> is to accumulate a list of wanted files, like I showed in previous examples, but without having to deal with the recursion into subdirectories. The following prints out all of the files from the current directory downward: </p><PRE>use File::Find; my @files;    sub wanted {        print $File::Find::name,"\n" if -f;    } find( \&amp;wanted, "." ); </PRE><p>Note that I need to print <i>$File::Find::name</i> and not just<i> $_</i> , or I would only get the filename without the path. </p><p>Since wanted can do anything, and you can specify multiple starting directories, you have a lot of flexibility. This program figures out how many bytes are used in the files in three different module distributions. </p><PRE>use File::Find; my @modules = qw(        www-mechanize        html-lint        marc-record    ); my @dirs = map { "/home/andy/$_" } @modules; my ($size, $n);    find( \&amp;wanted, @dirs );    print "$size bytes in $n files\n"; sub wanted {        if ( -d ) {            $File::Find::prune = 1 if $_ eq "CVS";        } elsif ( -f ) {            $size += -s;            ++$n;        }    } </PRE><p>Note the use of <i>$File::Find::prune</i>. Setting it to a true value tells <i>find</i> not to descend into the directory. In this case, we want to omit files in the CVS directory from our totals, since they're not part of the actual distribution. </p><p>The subroutine reference need not refer to a named subroutine. An anonymous subroutine will work just as well, and often makes for easier-to-follow logic for simple <i>wanted</i> functions. For example, to count the number of files in a given directory: </p><PRE>use File::Find; find( sub { $n++ if -f }, "." );    print "$n files found\n"; or even from the command line, as I discussed in the May issue: perl -MFile::Find -le'find( sub {$n++ if -f}, "." );' \        -e'END {print "$n files found"}' </PRE><h3><i>File::Find::Rule</i></h3><p>If you frequently use <i>File::Find</i> to return lists of files, and you spend a lot of time rewriting the same <i>wanted</i> functions over and over again, you may want to turn to Richard Clamp's <i>File::Find::Rule</i>. Instead of creating <i>wanted</i> functions, you'll create sets of rules, not unlike the <i>find</i> command, in order to retrieve lists of files.</p><p>In true Perl style, <i>File::Find::Rule</i> makes it easy to do the common tasks, such as finding all the *.pl files below the current directory: </p><PRE>use File::Find::Rule;    my @files = File::Find::Rule-&gt;file-&gt;name('*.pl')-&gt;in( "." ); </PRE><p>Each function in the chain (<i>file</i> and <i>nam</i>e) acts as both a constructor and a link in a method chain, and then the <i>in</i> method evaluates all the rules for a given directory. You can also use individual method calls on a <i>File::Find::Rule</i> object, like so: </p><PRE>my $rule = File::Find::Rule-&gt;new;    $rule-&gt;file;    $rule-&gt;name( '*.pl' );    my @files = $rule-&gt;in( "." ); </PRE><p>The various methods are extremely flexible. For example, to get *.pl, *.pm, and *.t files, call <i>name</i> with an anonymous array of specifications: </p><PRE>$rule-&gt;name( ['*.pl','*.pm','*.t'] ); </PRE><p>This ability to add rules one at a time makes it easy to build rulesets on the fly. For example, you might have command-line options in your program that tell which files you want, and the "<i>_big</i>" option shows that you only want files larger than 20 MB: </p><PRE>$rule-&gt;size( '&gt;20M' ) if $opt_big; </PRE><p>If the object style of specification doesn't suit you, <i>File::Find::Rule</i> also supports a functional interface. To find all the files in my home directory beginning or ending with a tilde, which are good candidates for deletion: </p><PRE>my @files = find( name =&gt; ['~*','*~'], in =&gt; '/home/andy' ); </PRE><p>The rules you use can be combined using Boolean logic with the <i>and</i> and <i>or</i> functions. If I wanted to find files beginning or ending with tildes, or files with 0 bytes, I can use: </p><PRE>my $rule = File::Find::Rule-&gt;new;    $rule-&gt;file;    $rule-&gt;or(        find( name =&gt; ['*~','~*'] ),        find( size =&gt; 0 ),    ); </PRE><p>Sometimes, you want to iterate over the list of files, like <i>File::Find</i>, rather than gathering a whole list of them. <i>File:: Find::Rule</i> supports this with the <i>start</i> and <i>match</i> methods: </p><PRE>$rule-&gt;start( "/home/andy" );    while ( my $file = $rule-&gt;match ) {        # do something with $file    } </PRE><p>For more on <i>File::Find::Rule</i>'s options and help on how to create your own extensions, see http://search.cpan.org/author/RCLAMP/File-Find-Rule/.</p><h3>Conclusion</h3><p>I've taken you on a tour of five different ways to gather lists of, and operate on, files in the filesystem based on your specific criteria. Which method is best?  As with any tool, it depends on your context. </p><p>For simple lists of files with rudimentary filename matching, globbing is the way to go. If you need to include directory names in your results as well as files, use <i>readdir</i>. As soon as you want to start finding files in subdirectories, one of the two modules will make life easier. Both <i>File::Find</i> and <i>File::Find::Rule</i> handle directories nicely, although <i>File::Find::Rule</i> may be better for complex logic that doesn't need to be wrapped up in a <i>wanted</i> function.</p><p><b>TPJ</b></p></body></html>