<html><head><title>Jul03: Building Collaborative Web Applications with CGI::Wiki</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; The Perl Journal--><h1>Building Collaborative Web Applications with CGI::Wiki</h1><p><i>The Perl Journal</i> July 2003</p><h3>By Kate L. Pugh</h3><I>Kate (aka "Kake") is a Perl programmer living in London. Her current main obsession is writing software that lets people collaborate with each other to write about, map, and annotate their town or city, and then plan pub crawls around it. She can be reached at kake@earth.li.</I><hr><p>Most people now know what a Wiki is&#151;in essence, it is a website that can be edited by anyone who comes across it, using a simple form in a web browser. The original Wiki concept was the work of Ward Cunningham nearly a decade ago. Ward's original design principles for Wiki can be seen at http://c2.com/cgi/wiki?WikiDesignPrinciples.</p><p>After having worked on grubstreet, the open community guide to London, for several months, I started to feel that some of these design principles were more important to me than others. Concentrating on a few key principles allows "slippage" of the other principles, and you might end up with something quite different from what you started with. <i>CGI::Wiki</i> is an example of this. It was originally planned as a rewrite of <i>UseModWiki</i> in more modern Perl, but along the way, it acquired a lot more power and flexibility.</p><h3>The Backend</h3><p><i>CGI::Wiki</i> is designed to be flexible about storage and indexing of its data. The main constructor takes between one and three arguments. The only mandatory argument is a <i>datastore</i> object. An <i>indexer</i> object can also be supplied, to aid searching, and a <i>formatter</i> object can be supplied if you wish to use the Wiki syntax other than the default.</p><PRE>my $datastore = CGI::Wiki::Store::SQLite-&gt;new(dbname =&gt; "/home/wiki/store.db");my $indexdb = Search::InvertedIndex::DB::DB_File_SplitHash-&gt;new(         -map_name  =&gt; "/home/wiki/indexes.db",         -lock_mode =&gt; "EX" );my $indexer = CGI::Wiki::Search::SII-&gt;new( indexdb =&gt; $indexdb );my $formatter = CGI::Wiki::Formatter::UseMod-&gt;new;my $wiki = CGI::Wiki-&gt;new( store     =&gt; $datastore,                           search    =&gt; $indexer,                           formatter =&gt; $formatter );</PRE><p>The datastore types currently available are all stored in a database&#151;your choice of Postgres, MySQL, or SQLite. You could write a flat-file backend if you liked; nobody has wanted one enough yet, though. The SQLite backend (see <i>DBD::SQLite </i>or http://www.hwaci.com/sw/sqlite/ for details) allows you to store a full RDBMS in a single file, so it will suit most situations where running an actual database server would be inconvenient.</p><p>The recommended search indexer is <i>Search::InvertedIndex</i>, though support for <i>DBIx::FullTextSearch</i> (which has phrase searching built in, but only works with MySQL) is also provided.</p><p>The formatters are perhaps the most fun bit. The default formatter uses the <i>Text::WikiFormat</i> formatting conventions, but a custom formatter is very easy to write. <i>CGI::Wiki::Formatter::UseMod</i>, which provides <i>usemod</i>-style syntax, and <i>CGI::Wiki::Formatter::Pod</i>, which allows you to write your Wiki entirely in POD, can both be found on CPAN, and should serve as examples if you want to write your own.</p><h3>A Toolkit, Not a Wiki</h3><p>So what are the important differences between <i>CGI::Wiki</i> and most other Wiki implementations? For one thing, it's not actually a Wiki; it's a toolkit for building Wikis&#151;and things that resemble Wikis. You can't just install it and have an instant Wiki, though it hardly takes any time at all to create a simple one.</p><p>Another major difference is its support for metadata. Most Wiki implementations treat their content as an undifferentiated block of text; indexing and categorization are done by hand, and searching rarely gets any more sophisticated than phrase matching.</p><p>Wiki users have developed various conventions to get around these limitations. The most widely used one seems to be the convention of adding WikiWords such as adding "CategoryPattern" and "CategoryPerl" to the bottom of a page about a programming pattern implemented in Perl. The concept of WikiWords is much wider than the concept of faking up categories like this. All pages about Perl can then be found by searching the Wiki for pages that contain the word "CategoryPerl." A hierarchy of categories can be created by creating a page for CategoryPerl and putting "CategoryProgrammingLanguages" at the bottom; and so on.<i></p><p>CGI::Wiki</i> allows you, as the writer of Wiki software, to attach any kind of metadata you like to a given node. A list of categories is an obvious choice; it's easy then to create a plug-in to look for everything in <i>Category Foo</i> or one of its subcategories. It's also very easy to provide your users with a macro to inline a category index into any given page. The index can even be a collapsible hierarchical listing, if you like. Other kinds of metadata that have proven very useful include location data&#151;latitude and longitude. I'll discuss some other useful metadata below.</p><h3>OpenGuides</h3><p>At the moment, the most fully developed <i>CGI::Wiki</i> application available is OpenGuides, a complete system for managing a collaboratively written guide to a city or town.</p><p>OpenGuides makes heavy use of <i>CGI::Wiki</i>'s metadata support. It uses the ability to store and retrieve location data, so it can easily handle queries such as "find me all pubs within 300m of Holborn Station," or "find me all Chinese restaurants within 500m of Trafalgar Square." It also uses a locale field (more on this later) for grouping places into neighborhoods within a city.<i></p><p>CGI::Wiki</i> provides simple metadata access directly; for example to find everything in Holborn we use the method:</p><PRE>my @nodes = $wiki-&gt;list_nodes_by_metadata( metadata_type  =&gt; "locale",                                         metadata_value =&gt; "Holborn" );</PRE><p>More complicated queries are done via plug-ins. Queries such as "pubs within 300m of Holborn Station" are handled by <i>CGI::Wiki::Plugin::Locator::UK</i>, for example. Anyone can write a <i>CGI::Wiki</i> plugin; more detailed guidelines are available in <i>perldoc CGI::Wiki::Extending</i>, but in essence your plug-in can choose between building on the simple access methods provided by <i>CGI::Wiki</i>, and accessing the database backend directly with SQL. The UK locator plug-in uses the latter technique for speed.</p><p>Many of OpenGuides' metadata fields are motivated by the desire to output RDF&#151;machine-readable versions of the nodes&#151;so that different OpenGuides installs can communicate with each other, and so that other Internet applications can make use of OpenGuides data. For example, an IRC bot interface to the London OpenGuides install might use <i>LWP::Simple</i> to request a URI such as:</p><PRE>http://un.earth.li/~kake/cgi-bin/wiki.cgi?action=index; index_type=locale;index_value=Chinatown;format=rdf</PRE><p>and receive a response like</p><PRE>&lt;?xml version="1.0"?&gt;&lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"       xmlns:rdfs="http://www.w3.org/2000/01/rdf-schema#"       xmlns:dc="http://purl.org/dc/1.0/"       xmlns:gs="http://the.earth.li/~kake/xmlns/gs/0.1/"      &gt;&lt;gs:locale rdf:about="http://un.earth.li/~kake/cgi-bin/wiki.cgi?action=index; index_type=locale;index_value=Chinatown;format=rdf"&gt;&lt;gs:name&gt;Locale Chinatown&lt;/gs:name&gt;  &lt;gs:object&gt;    &lt;rdf:Description rdf:about="http://un.earth.li/~kake/cgi-bin/wiki.cgi?De_Hems,_W1D_5BW"&gt;      &lt;dc:title&gt;De Hems, W1D 5BW&lt;/dc:title&gt;      &lt;rdfs:seeAlso rdf:resource="http://un.earth.li/~kake/cgi-bin/wiki.cgi?id=De_Hems,_W1D_5BW;format=rdf" /&gt;    &lt;/rdf:Description&gt;  &lt;/gs:object&gt;  &lt;gs:object&gt;    &lt;rdf:Description rdf:about="http://un.earth.li/~kake/cgi-bin/wiki.cgi?Golden_Harvest,_WC2H_7BE"&gt;      &lt;dc:title&gt;Golden Harvest, WC2H 7BE&lt;/dc:title&gt;      &lt;rdfs:seeAlso rdf:resource="http://un.earth.li/~kake/cgi-bin/wiki.cgi?id=Golden_Harvest,_WC2H_7BE;format=rdf" /&gt;    &lt;/rdf:Description&gt;  &lt;/gs:object&gt;&lt;/gs:locale&gt;&lt;/rdf:RDF&gt;Parsing this with <i>RDF::Core::Parser</i> is simple:use LWP::Simple;use RDF::Core::Parser;use URI::Escape;my $locale = "Chinatown";my $content = get("http://un.earth.li/~kake/cgi-bin/wiki.cgi?action=index;format=rdf;index_type=locale;index_value=" . uri_escape($locale));my $parser = RDF::Core::Parser-&gt;new( Assert =&gt; \&amp;_assert, BaseURI =&gt; "foo" );my (@finds, %name);$parser-&gt;parse( $content );my $return = "things in $locale: ";if ( @finds ) {    $return .= join("; ", map { $name{$_} } @finds ) . "\n";} else {    $return .= "none, sorry.\n";}print $return;sub _assert {    my %triple = @_;    if ( $triple{predicate_uri} eq                           "http://the.earth.li/~kake/xmlns/gs/0.1/object" ) {        push @finds, $triple{object_uri};    }      if ( $triple{predicate_uri} eq "http://purl.org/dc/1.0/title" ) {          $name{$triple{subject_uri}} = $triple{object_literal};    }}</PRE><p>And now we can talk to our OpenGuides install over IRC:</p><PRE>15:12 &lt;Kake&gt; grotbot: things in Chinatown15:12 &lt;grotbot&gt; OK, working on it&lt;grotbot&gt; Kake: things in Chinatown: Crispy Duck, W1D 6PR; De Hems, W1D 5BW; Golden Harvest, WC2H 7BE; HK Diner; Hung's, W1D 6PR; Misato, W1D 6PG; Tai, W1D 4DH; Tokyo Diner; Zipangu, WC2H 7JJ</PRE><p>So we have three ways to look at the same data&#151;as an HTML page in a web browser, as RDF, or via an IRC bot. How about a fourth&#151;a Scalable Vector Graphics plot?</p><PRE>use strict;use SVG::Plot;use URI::Escape;use CGI::Wiki;use CGI::Wiki::Plugin::Locator::UK;my $wiki = CGI::Wiki-&gt;new( ... );my $locator = CGI::Wiki::Plugin::Locator::UK-&gt;new;$wiki-&gt;register_plugin( plugin =&gt; $locator );my @nodes = $wiki-&gt;list_nodes_by_metadata(                                  metadata_type  =&gt; "locale",                                  metadata_value =&gt; "Chinatown" );my @points;foreach my $node (@nodes) {  my ($x, $y) = $locator-&gt;coordinates( node =&gt; $node );  if ($x and $y) {     my $uri = "http://un.earth.li/~kake/cgi-bin/wiki.cgi?" . uri_escape($node);     push @points, [ $x, $y, $uri ];  }}my $plot = SVG::Plot-&gt;new( points     =&gt; \@points,                          max_width  =&gt; 800,                          max_height =&gt; 600,                          point_size =&gt; 3 );my $svg = $plot-&gt;plot;print "Content-Type: image/svg+xml\n\n";print $svg;</PRE><h3>Collaborative Mapping</h3><p>Unlike a traditional Wiki, a metadata-enabled Wiki allows you to work with aggregated data. One excellent application of this is collaborative mapping of physical spaces&#151;not just the objective statistics such as latitude and longitude, but subjective measures like psychological distance between two places, or membership in a neighborhood.</p><p>Consider neighborhoods in London; places like Holborn, Bloomsbury, Chelsea, Fulham, Islington. Unlike boroughs, which have clear boundaries defined by the extent of local council responsibility, neighborhoods are vague and fuzzy. They overlap. Is my office in Holborn or is it in Bloomsbury? Is it in both? Do I live in Hammersmith or Fulham? Or both? Or neither?</p><p>The OpenGuides node edit form includes a field where one or more "locales" can be entered for a page. If a later editor thinks you've got the locales wrong, they can add or delete other locales. So each time a given locale is left alone during an edit could be considered to be some kind of "vote" for that place being in that locale. Here's how you'd write a plug-in to track these votes.</p><PRE>package OpenGuides::LocaleVote;use strict;use vars qw( $VERSION @ISA $plugin_key );$VERSION = '0.01';$plugin_key = "og_localevote";use Carp "croak";use CGI::Wiki::Plugin;@ISA = qw( CGI::Wiki::Plugin );</PRE><p>We inherit from <i>CGI::Wiki::Plugin</i> for easy access to the Wiki's backend datastore. We define a <i>$plugin_key</i> to identify the namespace for the tables we'll be writing to.</p><h3>Synopsis</h3><PRE>use CGI::Wiki;use OpenGuides::LocaleVote;my $wiki = CGI::Wiki-&gt;new( ... );my $ballot = OpenGuides::LocaleVote-&gt;new;$wiki-&gt;register_plugin( plugin =&gt; $ballot );$wiki-&gt;write_node( "Calthorpe Arms", "nice pub", undef, { locale =&gt; [ "Holborn", "Bloomsbury" ] } );my %locales = $ballot-&gt;get_locales( node =&gt; "Calthorpe Arms" );print "Votes for Holborn: $locales{Holborn}";</PRE><p>The API is nice and simple&#151;create a Wiki object, create a plugin object, register the plugin with the Wiki, write some data, and pull out the votes for a given node.</p><PRE>sub new {  my $class = shift;  my $self = { table =&gt; "p_" . $plugin_key . "_votes" };  bless $self, $class;  return $self;}</PRE><p>We follow the convention described in <i>CGI::Wiki::Extending</i> for our table name, and store it on instantiation, for convenience.</p><PRE>sub on_register {  my $self = shift;  my $table = $self-&gt;{table};  my $datastore = $self-&gt;datastore;  my $dbh = $self-&gt;datastore-&gt;dbh    or croak "Not implemented for non-database datastores";  my $store_class = ref $datastore;  $store_class =~ s/CGI::Wiki::Store:://;  # Check table is set up.  if ( $store_class eq "Pg" ) {      my $sth = $dbh-&gt;prepare        "SELECT count(*) FROM pg_tables WHERE tablename=?" );      $sth-&gt;execute($table);      my ($table_ok) = $sth-&gt;fetchrow_array;      $sth-&gt;finish;      unless ($table_ok) {          $dbh-&gt;do( "CREATE TABLE $table (node varchar(200), locale text, votes integer )" );      }  } elsif ( $store_class eq "MySQL" ) {      ...  } elsif ( $store_class eq "SQLite" ) {      ...  } else {      croak "Store class $store_class unknown";  }}</PRE><p>The <i>on_register</i> method will be called when the plug-in is registered by calling <i>register_plugin</i> on the Wiki object. <i>on_register</i> is our chance to check that the table we need to use has been set up in the backend database. We are careful to allow for the possibility that our plug-in may be used by Wikis with nondatabase datastores, if anyone ever writes one.</p><p>Since we are inheriting from <i>CGI::Wiki::Plugin</i>, before <i>on_register</i> is called, <i>CGI::Wiki</i> will store its <i>datastore</i>, <i>indexer</i> and <i>formatter</i> in our object, so we can get hold of the database handle by calling <i>$self-&gt;datastore-&gt;dbh</i>, and then we have full access to the database. Following the conventions in <i>CGI::Wiki::Extending</i>, we only write to tables labeled with our <i>$plugin_key</i>, though we can read from any table.</p><PRE>sub post_write {  my ($self, %args) = @_;  my $table = $self-&gt;{table};  my $dbh = $self-&gt;datastore-&gt;dbh    or croak "Not implemented for non-database datastores";  my $node = $args{node};  my $metadata = $args{metadata};  my $locs = $metadata-&gt;{locale} or return 1;  my @locales = ref $locs ? @$locs : ( $locs );  foreach my $locale (@locales) {      my $sth = $dbh-&gt;prepare(                      "SELECT votes FROM $table WHERE node=? AND locale=?" );      $sth-&gt;execute( $node, $locale );      my ($votes) = $sth-&gt;fetchrow_array;      $sth-&gt;finish;      if ($votes) {          $votes++;          my $sth = $dbh-&gt;prepare(                     "UPDATE $table SET votes=? WHERE node=? AND locale=?" );          $sth-&gt;execute( $votes, $node, $locale );      } else {          my $sth = $dbh-&gt;prepare(                   "INSERT INTO $table (node, locale, votes) VALUES(?,?,1)");          $sth-&gt;execute( $node, $locale );      }  }  return 1;}</PRE><p><i>post_write</i> is called after each node is written. This is where we do the actual storing of the votes.</p><PRE>sub get_locales {  my ($self, %args) = @_;  my $table = $self-&gt;{table};  my $node = $args{node};  my $dbh = $self-&gt;datastore-&gt;dbh    or croak "Not implemented for non-database datastores";  my $sth = $dbh-&gt;prepare( "SELECT locale, votes FROM $table WHERE node=?" );  $sth-&gt;execute($node);  my %locales;  while ( my ($locale, $vote) = $sth-&gt;fetchrow_array ) {      $locales{$locale} = $vote;  }  return %locales;}</PRE><p>Finally, <i>get_locales</i> just does a straight SQL query to find the locales a given node has been placed in, and the number of votes for each locale.</p><h3>Where to Go From Here</h3><p>What else can we do with this? I really don't know the extent of it. It seems that every time I talk with a group of programmers I come up with a new thing I can use <i>CGI::Wiki</i> for. As mentioned at the start of this article, I feel some of the original Wiki design principles are more immutable than others. In particular, I feel that almost anything calling itself a Wiki is greatly enhanced by being two things:</p><ul>  <li>Open. Anyone can edit any page. If something is wrong or just plain confusing, you can change it. <i>CGI::Wiki</i>'s plug-in system lets Wiki authors extend the collaborative aspect of openness to valuing the aggregate of opinions as visibly as the opinion of the last person to edit a page.  <li>Organic. I've watched grubstreet grow from a couple of very diverse pages written by two or three people, to a deeply organized structure. Some aspects of the structure came from preexisting Wiki conventions such as categories; others, such as the ideas of places being within locales and locales neighboring each other, originated entirely in the nature of grubstreet itself. The metadata support in <i>CGI::Wiki</i> is naive yet flexible, precisely because I don't believe I can foresee how people will want to structure the Wikis they use. Simply by creating a couple of specialist nodes for collaborative administration of your Wiki, you can let people add and organize categories, create and edit templates for node display and editing, and any other global aspect that you can think of.</ul><p>Everything else is just there waiting for you to stretch it in interesting ways.</p><p><b>TPJ</b></p></body></html>