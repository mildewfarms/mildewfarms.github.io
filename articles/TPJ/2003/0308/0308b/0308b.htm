<html><head><title>Aug03: Programming Persistent Objects with Class::PObject</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; The Perl Journal--><h1>Programming Persistent Objects with Class::PObject</h1><p><i>The Perl Journal</i> August 2003</p><h3>By Sherzod B. Ruzmetov</h3><I>Sherzod is a student at Central Michigan University. He is the author of several CPAN libraries, including Class::PObject. He can be reached at sherzodr@cpan.org.</I><hr><p>Ever wished you could just forget about database-specific routines to manage data files, BerkelyDB, MySQL, PostgreSQL, and the like, and use pure Perl for managing your application data? Or have you ever written a program with a specific database in mind, and had to port the application to another database and wished there was an easier way?</p><p>The philosophy behind persistent objects addresses just this issue&#151;to represent persistent data (otherwise stored on disk) as a software object, and provide methods and behaviors for manipulating its content.</p><h3>What is a Persistent Object?</h3><p>A persistent object can be thought of as another way of representing data on disk. It may help to think of a persistent object as a single row of a database table. It can look something like <A NAME="re1"><A HREF="0308be1.htm">Example 1</A>.</p><p>The whole record represents an object, and each column of the record represents attributes of the object. You use object methods from within your programs to create or access the data without having to run any database-specific queries.</p><p>What is the advantage? By treating the real data as an object, we achieve a higher level of database abstraction. This allows the development of platform-independent code, since our programs don't really care anymore how the data is stored and retrieved from the disk. It's up to the object drivers to perform these tasks transparently. Data, on the other hand, can be stored in plain files, BerkelyDB, Comma Separated Values (CSV), MySQL, or any other database system for which an object driver is available.</p><p>This design also makes development and maintenance easier, because maintainers will not need to learn implementation-specific database queries, but will only work with software objects. <i>Class::PObject </i>provides this framework.</p><h3>Programming Style</h3><p>The programming style of <i>Class::PObject </i>resembles that of standard <i>Class::Struct</i>, and allows us to create objects dynamically. <i>Class::PObject</i> imports a single function, <i>pobject()</i>, which takes arguments describing the class attributes.</p><p>In this section, we will tackle a real-world task: managing user accounts in a web project.</p><p>Let's try to think of a user as an object, and decide what attributes a single user can have. The minimum required attributes for a user might be <i>name</i>, <i>password</i>, and <i>email</i>. We'll stick to these three attributes for the sake of simplicity, and try to extend them later. The user can also have some behaviors. The most important of those behaviors is the ability to identify himself to our web site, a process also known as "login."</p><h3>Declaring a Class</h3><p>In this section, we will build a <i>User</i> class. There are two ways of declaring a class using <i>Class::PObject</i>: inside a dedicated .pm file or in an inline declaration. Inline declaration is the easiest, and you can declare it in anywhere, even inside your programs. Here is an example of declaring a <i>User</i> class using the inline syntax:</p><PRE>pobject User =&gt; {  columns =&gt; ['id', 'name', 'password', 'email']};</PRE><p>Unfortunately, objects created this way will not be accessible to other programs because they are embedded inside your program. A better way is to define objects in their dedicated class files. To do this, create a User.pm file, with the following content:</p><PRE>package User.pmuse strict;use Class::PObject;pobject {  columns =&gt; ['id', 'name', 'password', 'email']};1;</PRE><p>Although it might be hard to believe, the aforementioned examples create a fully functional <i>User</i> class. The <i>columns</i> in the aforementioned class definitions are attributes of the object that will be stored into disk. In other words, think of it as columns of a record stored in a database table. (Another example User.pm file is available online at http://www.tpj.com/source/.)</p><h3>The Generated <i>pobject</i></h3><p>The generated <i>pobject</i> provides the following methods:</p><p></p><ul>  <li><b><i><i></b>new()</i></i>--Constructor for creating a new object. Calling this method without any arguments will create an empty <i>User</i> object.  <li><b><i><i></b>load([$id] | [\%terms] [,\%args])</i></i>&#151;Constructor for loading object(s) from disk.  <li><b><i><i></b>save()</i></i>&#151;For storing the changes made to the object back to disk.  <li><b><i>remove()</i></b>&#151;Removing the object from the disk.  <li><b><i><i></b>remove_all()</i></i>&#151;Static class method for removing all the objects of the same type from the disk. </ul><p>It also creates accessor methods for each of the declared columns. These methods carry the same name as column names. You can change the value of the column by passing an argument. To access the current value of the column, you call it without an argument. For example, to get the user's name, we can say:</p><PRE>my $name = $user-&gt;name();To rename the user, we say:$user-&gt;name("Sherzod");</PRE><h3>Create a New Object</h3><p>Now let's create a new user account:</p><PRE>use strict;require User;my $user = new User();$user-&gt;name('Sherzod');$user-&gt;password('secret');$user-&gt;email('sherzodr@handalak.com');$user-&gt;save();</PRE><p>Notice we're loading the <i>User</i> class and creating an instance of a <i>User</i> object using the <i>new()</i> constructor. This will create an empty user. In consecutive lines, we are defining the user's attributes. When we're done, we save the object. <i>save()</i> will flush all the in-memory data to disk.</p><p>At this point, don't worry about how and where the above data is being stored. </p><h3>Loading Previously Stored Objects</h3><p>All the objects should have a unique ID that distinguishes them from other objects of the same type. This ID is a primary key attribute of the object, called "<i>id"</i> by default. <i>Class::PObject</i> will make sure that every object will be assigned a unique, autoincrementing ID. </p><p>The most efficient way of loading an object is through its ID. We pass it to the <i>load()</i> method:</p><PRE>my $user = User-&gt;load($id);</PRE><p>You can also load objects by specifying a set of terms. These terms can be passed to <i>load()</i> as the first argument in the form of hash reference. Consider the following example, which is loading a user account with <i>name</i> "Sherzod."</p><PRE>my $user = User-&gt;load({name=&gt;"Sherzod"}); </PRE><p>We can now perform some modifications on this user. Say, we want to change the password:</p><PRE>$user-&gt;password('top_secret');$user-&gt;save();</PRE><p>None of the modifications to the object will be flushed to disk unless we call <i>save()</i>.</p><h3>Loading Multiple Objects</h3><p>If you call the <i>load()</i> method in array context, it will return a list of all the results matching your terms. If no terms are given, all the objects of the same type will be returned:</p><PRE>my @users = User-&gt;load();</PRE><p>Elements of<i> @users</i> hold all the <i>User</i> objects. Suppose we wanted to generate a list of all the users in our database:</p><PRE>for my $user ( @users ) {  printf("[%03d] - %s &lt;%s&gt;\n", $user-&gt;id, $user-&gt;name, $user-&gt;email);}</PRE><p>In addition to terms, you can pass the second argument to <i>load()</i> to perform such actions as sorting on a specific column, limiting the number of results returned, or returning spliced result sets:</p><PRE># to return first 5 results ordered by 'name' column:my @users = User-&gt;load(undef, {sort=&gt;'name', limit=&gt;5});# to return results 10 through 25, sorting by 'name' in# descending order:my @users = User-&gt;load(undef, {sort=&gt; 'name', direction=&gt; 'desc',                           offset =&gt; 10, limit=&gt; 25 });</PRE><h3>Removing the Object</h3><p>To delete the data an object is associated with, you can call the <i>remove()</i> method on that object. It is a nonreversible action, so use it only when you really mean it. The following example removes the user account with <i>id 10</i>:</p><PRE>my $user = User-&gt;load(10);$user-&gt;remove();</PRE><p>and the following sample of code removes all the available <i>User</i>s:</p><PRE>my @users = User-&gt;load();for my $user ( @users ) {  $user-&gt;remove();}</PRE><p>For most object drivers, removing all the data at once is a lot more efficient than removing them one by one, as we did in the aforementioned example. For this reason, <i>Class::PObject</i> also provides a <i>remove_all()</i> method, which does exactly what its name claims:</p><PRE>User-&gt;remove_all();</PRE><p>Note that it is a static class method, and is not associated with any specific object. So saying something like this is not very intuitive:</p><PRE>my $user = User-&gt;load();  # &lt;-- returns any one User object$user-&gt;remove_all();      # &lt;-- huh?</PRE><h3>Extending the Object's Interface</h3><p>For some objects, accessor methods are not all you need. Many objects also need behaviors. A behavior is an action that an object can perform on its data. For example, an imaginary <i>Window</i> object could support behaviors such as <i>open()</i>, <i>close()</i>, <i>move()</i>, and so on. <i>authenticate()</i>, on the other hand, makes perfect sense for our <i>User</i> object. It's a procedure to be performed when a user submits a login form on a web page. The task of the <i>authenticate()</i> method is to validate the user's submitted <i>name</i> and <i>password</i> fields to the ones stored in the database. If they match, the user can enter.</p><p>To support this behavior, we need to open our User.pm file we created earlier, and define the <i>authenticate()</i> method:</p><PRE>package User;use strict;use Class::PObject;pobject {  columns =&gt; [    'id', 'name', 'password', 'email'  ]};sub authenticate {  my $class = shift;  # &lt;-- removing Class name from @_  my ($name, $psswd) = @_;  return $class-&gt;load({name=&gt;$name, password=&gt;$psswd});}1;__END__;</PRE><p>Our <i>authenticate()</i> accepts two arguments, <i>$name</i> and <i>$psswd</i>, and returns a matching object. If no such account can be found, it will return <i>undef</i>. We now can use this new feature from within our programs like so:</p><PRE># we take the form data using standard CGI.pmmy $name      = $cgi-&gt;param('name');my $password  = $cgi-&gt;param('password');# we then attempt to authenticate the user:my $user = User-&gt;authenticate($name, $password);unless ( defined $user ) {  die "couldn't authenticate. Username and/or password are incorrect\n";}</PRE><p><i>authenticate()</i> is a class method, which makes sense, since we use it to retrieve a valid user object.</p><p>There is much more than that <i>Class::PObject</i> offers. For the details, you should always consult the latest library manual, available from your CPAN mirror.</p><h3>On Object Drivers</h3><p>So far we have only discussed the programming syntax of <i>Class::PObject</i>. Now let's talk about how and where all the data is stored. Objects created using <i>Class::PObject </i>rely on object drivers for mapping objects into physical data.</p><p>The <i>User</i> class we have been working with so far was built using the most basic declaration. We didn't even tell it what driver to use, where and how the data should be stored, and so forth. In such cases, <i>Class::PObject</i> falls back to default driver, "file." To use any other drivers, you should define the <i>driver</i> class attribute. <i>datasource</i> can be defined to pass arguments for drivers:</p><PRE>package User;pobject {  columns =&gt; ['id', 'name', 'password', 'email'],  driver  =&gt; 'mysql',  datasource =&gt; {        DSN    =&gt; 'DBI:mysql:users',        UserName =&gt; 'sherzodr',        Password =&gt; 'secret'  }};</PRE><p>In the following section, we'll give a brief overview of various drivers available for <i>Class::PObject</i>, and how they map the object data to disk files.</p><h3>File Driver</h3><p>The <i>file</i> driver is a default driver used by <i>Class::PObject</i>. If <i>datasource</i> is provided, the driver will interpret it as a directory that objects will be stored in. If it's missing, it will create a folder in your system's temporary directory. The name of the folder will be the lowercased version of the class name, with nonalphanumerics replaced with underscores ("_").</p><p>The driver stores each object as a separate file, and uses <i>Data::Dumper</i> to serialize the data. The name of the file is in the form of "obj%05d.cpo," where "%05d" will be replaced with the object ID, with zeros padded if necessary.</p><p>As the number of objects in your database grows big, it will get less efficient and slower to manipulate objects in this form, since there will be lots of <i>open/close</i> and <i>eval() </i>calls.</p><H3>CSV Driver</H3><p><i>csv</i> stores objects of the same type in a single file in CSV (Comma Separated Values) format. These objects can easily be loaded to your favorite spreadsheet application, such as Excel, or loaded to an RDBMS such as MySQL or PostgreSQL. It uses the <i>DBI</i> and <i>DBD::csv</i> libraries.</p><p><i>csv</i> creates all the objects in your system's temporary folder unless you explicitly define <i>datasource</i> to be a <i>hashref</i> with the following keys:</p><ul>  <li><b><i>Dir</i></b>&#151;Directory where the object will be stored.  <li><b><i>Table</i></b>&#151;Name of the file that will hold this particular object. If you omit the <i>Table</i> name (recommended), it will default to the name of the object, nonalphanumerics underscored, and lowercased.</ul><PRE><p>Here's an example using the <i>csv</i> driver:</p>package User;pobject {    columns =&gt; ['id', 'name', 'password', 'email'],    driver  =&gt; 'csv',    datasource =&gt; {        Dir  =&gt; 'data/'    }};</PRE><h3>MySQL Driver</h3><p>The <i>mysql </i>driver can be used for storing objects in MySQL tables. Unlike the aforementioned database drivers, you first need to set up the table structure to be able to use the <i>mysql</i> driver. In other words, each <i>pobject</i> represents a single database table. Each column of the table represents an attribute of the object and is declared in the <i>columns</i> array.</p><p>Consider the following object configuration for our <i>User</i> class using the <i>mysql</i> driver:</p><PRE>package User;pobject {    columns =&gt; ['id', 'name', 'password', 'email'],    driver  =&gt; 'mysql',    datasource =&gt; {        DSN =&gt; "dbi:mysql:users",        UserName =&gt; "sherzodr",        Password =&gt; "secret"    }};</PRE><p>You can optionally provide <i>Table</i> inside <i>datasource</i> if you want to store the user data in a different table.</p><p>Now, let's create a table for storing the above object. Remember, you should create at least all the columns mentioned in the <i>columns</i> class attribute. Another thing to remember is to make <i>id</i> as an AUTO_INCREMENT column. Consider the following table schema, which is designed for storing the just defined <i>User</i> objects:</p><PRE>CREATE TABLE user (        id INT UNSIGNED NOT NULL AUTO_INCREMENT,        name VARCHAR(30) NOT NULL,        password CHAR(32) NOT NULL,        email VARCHAR(80) NOT NULL,        PRIMARY KEY(id));</PRE><p>Now, when we say:</p><PRE>my $u = new User();$u-&gt;name('sherzodr');$u-&gt;email('sherzodr@handalak.com');$u-&gt;password('secret');$u-&gt;save();</PRE><p>our MySQL table would then contain the following data as shown in <A NAME="re2"><A HREF="0308be2.htm">Example 2</A>.</p><h3>Conclusion</h3><p>Persistent objects allow you to forget the messy details of data storage, and to treat your data like you would any other software object. I hope this article gives you enough of an understanding of creating persistent objects with <i>Class::PObject</i> for you to get started using them in your own code. (For more example code for this article, see http::/www.tpj.com/source/.)</p><h3>References</h3><p><b>perlobj</b>&#151;The Standard Perl manual of Perl objects.</p><p><b>Class::PObject</b>&#151;The official manual for <i>Class::PObject</i>. The latest features will be available through your CPAN mirror. http://search.cpan.org/perldoc?Class::PObject/.</p><p><b>Class::DBI</b>&#151;Another utility for programming persistent objects.</p><p><b>Class::Struct</b>&#151;The Standard Perl library for automating creation of simple classes using C++'s <i>struct</i>-like syntax.</p><p><b>TPJ</b></p></body></html>