<html><head><title>Aug03: Learning Perl Objects, References, & Modules</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; The Perl Journal--><h1>Learning Perl Objects, References, &amp; Modules</h1><p><i>The Perl Journal</i> August 2003</p><h3>By Russell J.T. Dyer</h3><I>Russell is a Perl programmer, MySQL developer, and web designer living and working on a consulting basis in New Orleans. He is also an adjunct instructor at a local college where he teaches Linux and other open-source software. He can be reached at russell@dyerhouse.com.</I><hr><h4><br><i>Learning Perl Objects,  References &amp; Modules </i><br>Randal Schwartz with Tom Phoenix <br>O'Reilly &amp; Associates <br>$34.95 <br>ISBN: 0-596-00478-8 <br></h4><p>Randal Schwartz, the author and coauthor of several columns and books on Perl, has written a new book with his seminar partner, Tom Phoenix. <i>Learning Perl Objects, References &amp; Modules </i>is<i> </i>a more advanced book on learning Perl. If you enjoyed Schwartz's immensely popular book, <i>Learning Perl</i> (a.k.a, the Llama book), and you're ready to move up to a higher level in your Perl training, then you'll want to get a copy of this book. The Alpaca book (that's the signature O'Reilly cover animal for this book&#151;it's a close relative to the Llama) will be of particular interest to you if you've been working with Perl by yourself and you would like to be able to work for an organization with many Perl programmers. This book will help you develop the skills that you will need to work in a large group on extensive, lengthy programs.</p><h3>Style &amp; General Content</h3><p>As with all of Schwartz's writings, the Alpaca book is written in a clear and relaxed style, with lighthearted examples. Although it's somewhat advanced, the lessons are easy for intermediate Perl programmers to follow and learn. This is not a book to be rushed, though, nor would I recommend jumping around in it. But if you pace yourself and read it from beginning to end&#151;especially if you work through the exercises&#151;you'll find it to be a fairly easy read and will be surprised at how much your Perl coding will improve. What's important is to experiment with the concepts presented.</p><p><i>Learning Perl Objects, References &amp; Modules</i> is composed of three major sections, not in the order of the title. The first section is on references. Typically, a reference is a memory address for where a data structure like a hash or an array is contained. They can be very useful in speeding up scripts. Instead of moving the actual data around within a program, one can simply capture the memory address or rather a reference to the data (which is only a small string of characters) and pass it around. The second section of Schwartz's new book is on object-oriented programming (OOP) with Perl. OOP is particularly useful for organizations with many programmers, writing thousands of lines of code. The third section deals with creating one's own Perl modules, either for private use or to contribute to CPAN. Private modules can assist greatly in streamlining code. As you can see already just in this overview, the Alpaca book focuses on creating powerful, efficient code, while being mindful of other programmers who may use it.</p><h3>References Section</h3><p>The first two chapters discuss fundamental (albeit advanced) concepts involved in writing large Perl programs with several other programmers. For one thing, it gives suggestions on watching out for unnecessary redundancy in your code. To eliminate redundancy, Schwartz discusses using subroutines within a program; to be able to reuse subroutines among many programs, he recommends libraries to house them. The elimination of the bulk of a program's clutter makes way for the use of references for further fine tuning and clean up.</p><p>The third chapter introduces the concept of references and illustrates how to create them. With references, one can build and manipulate complex data structures. For instance, suppose you have a program with a set of hashes that contain information on your company's clients. One hash contains a client's account number, name, address, telephone number, and so forth. Suppose also that you have several such hashes&#151;one for each client. You could put all of these hashes together into an all encompassing hash by using references to each hash: </p><PRE>%clients = ('AC1234' =&gt; \%AC1234, 'AC1235' =&gt; \%AC1235, ...)</PRE><p>With only references to each client data hash contained in the values of each hash pair (the keys are account numbers), passing around a set of nested hashes like this poses no significant drain on resources. Chapter Four demonstrates how to dereference complex data structures involving references. It's effortless and it doesn't require a <i>loop</i> statement. For instance, to extract the telephone number of the client with the account number of AC1234 from the nested hashes, one would enter <i>$clients{'AC1234'} -&gt; {'telephone'}</i>. Clean as can be!</p><p>Of course, it can be difficult at first to plod through complex data structures with references. It doesn't take long before confusion sets in if you're not meticulous. When this happens, it's hard to know where the trouble lies. In Chapter Five, Schwartz shows how to use a few debugging tools to display the values contained in complex data structures in an organized manner at key points in a program. He covers the debugger, the <i>Data::Dumper</i> module, and the <i>Storable</i> module for this purpose. </p><p>In Chapter Six, Schwartz suggests referencing subroutines. This was a bizarre notion to me when I first read it. However, it can be quite slick. For instance, suppose you have a program in which you want to run one of 10 different subroutines, depending upon which of the 10 possible values the user selects. Normally, I would string together a long <i>if/elsif</i> statement. Instead, you could just put a reference to each subroutine in a hash and add something like this to your code to call the appropriate subroutine and to pass any parameters to the subroutine selected: </p><PRE>$sub_routines{$selection} -&gt; ($parameter)</PRE><p>What could be smoother than that? The last chapter on references, Chapter Seven, elaborates on how to sort data with references and with recursively defined data.</p><h3>Objects Section</h3><p>Most object-oriented programming tutorials tend to bog themselves down with conceptual differences between OOP and nonOOP. Since this isn't a beginner's book, and since Schwartz seems to prefer a more economical style of writing, he just tells the reader how OOP is done in a clutter-free, straight-forward manner. This is not to say that you need to understand OOP concepts before you can benefit from this section. Chapter Eight does walk the reader through the essential elements of OOP with Perl. It's just that some prior exposure to OOP, even if only through CGI.pm, will make it clearer. Chapter Nine goes into greater detail on object classes and methods. This includes understanding objects and not treating them in more linear ways, while remembering object inheritance. Schwartz also recommends bringing references into objects to make for still more powerful and efficient code.</p><p>Chapters Ten and Eleven cover some housekeeping aspects of objects. Chapter Ten explains to the reader how to deal with objects that become inactive in the course of programs, but are still referenced. These are known as "destroyed objects." Chapter Ten also covers "metavariables" (that is, objects in a hash). Even the minor chapters contain goodies for leveraging your code. </p><p>Chapter Eleven deals with more advanced object-oriented programming. For when objects fail, a default method can be established, a UNIVERSAL method. To catch failures before they can happen, there is the <i>isa</i> and the <i>can</i> methods. Schwartz discusses these and the AUTOLOAD method, which is used to reduce the drain on resources by little-used objects.</p><h3>Modules Section</h3><p>When most of us think of modules, we tend to think of either the modules that come with Perl (that is, DBI.pm and CGI.pm), or the thousands of modules found on the CPAN. Most of us don't consider creating our own modules for private use. Chapter Twelve explains how to build modules and how to use them effectively. It expounds on object-oriented modules in particular; it details their intricacies and how they should be called upon. Schwartz advises on building well-constructed modules for others to be able to utilize easily and intuitively.</p><p>If you create a module that you think would be of use to others outside of your organization, Chapter Thirteen will show you how to prepare it for public distribution. This includes creating the Makefile.PL, the README file, the MANIFEST file, and the documentation. This also includes setting up the module for users to be able to run <i>make test </i>and <i>make install</i>. In Chapter Fourteen, Schwartz goes over how to test a module before making it public. He suggests using a few other modules: <i>Test::Harness</i>, <i>Test::Simple</i>, and <i>Test::More</i>. Chapter Fifteen provides information on the final step in making a module public: joining CPAN and uploading a new module.</p><h3>Conclusion </h3><p>Although a slender book of only about 200 pages, the Alpaca book is probably the best Perl book to come along in a while. If you're an intermediate Perl programmer, after working through this book thoroughly, you should break through the barrier and become an advanced Perl programmer. It really is an outstanding book that will improve the quality of your code by leaps after reading each chapter. Every serious Perl fan should buy a copy.</p><p><b>TPJ</b></p></body></html>