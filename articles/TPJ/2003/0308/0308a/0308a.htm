<html><head><title>Aug03: Implementing the Khazad Block Cipher in Perl</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; The Perl Journal--><h1>Implementing the Khazad Block Cipher in Perl</h1><p><i>The Perl Journal</i> August 2003</p><h3>By Julius C. Duque</h3><I>Julius is a freelance network consultant in the Philippines. He can be contacted at jcduque@lycos.com.</I><hr><a NAME="#rs1"></a><A HREF="0308as1.htm">The Khazad Block Cipher</A><hr><p>Khazad is a new 64-bit block cipher that accepts a 128-bit key. Invented by Paulo S.L.M. Barreto and Vincent Rijmen, it is a finalist in the New European Schemes for Signatures, Integrity, and Encryption (NESSIE) Project.</p><p>In this article, I will show you how I implemented Khazad in Perl using XS programming. Using the techniques presented here, I hope that you will also be able to implement any block cipher that you fancy (or, perhaps, just create an XS-based Perl module).</p><p>At this writing, the current version of Crypt::Khazad is 1.0.3. It is available on CPAN at http://www.cpan.org/authors/id/J/JC/JCDUQUE/Crypt-Khazad-1.0.3.tar.gz. Files mentioned in this article are available in this module distribution. Also see http:// planeta.terra.com.br/informatica/paulobarreto/KhazadPage.html</p><h3>Using h2xs</h3><p>The first thing to do is create a subdirectory where the module will be created and stored using the program h2xs, which converts C header files to Perl extensions. On the command line, type: </p><p>h2xs --omit-autoload --omit-constant --name=Crypt::Khazad</p><p>Refer to the h2xs man pages for explanation of the options  <i>--omit-autoload</i> and <i>--omit-constant</i>. What's important here is the option <i>--name=Crypt::Khazad</i>. This tells h2xs to create a subdirectory Crypt/Khazad/.</p><p>The following files will be created in Crypt/Khazad/:</p><PRE>Changes Khazad.pm Khazad.xs MANIFEST Makefile.PL README ppport.h t</PRE><p>"t," which stands for tests, is a directory containing test scripts. For the moment, there's only one test script found here (1.t). All test scripts are placed in this directory and must be suffixed with '.t.' </p><h3>The typemap File </h3><p>Change directories (cd) into Crypt/Khazad. What is lacking in this directory is the typemap file. Create this file, and add the following line: </p><p>Crypt::Khazad   T_PTROBJ </p><p>Note that the whitespace separating <i>Crypt::Khazad</i> and <i>T_PTROBJ</i> must be a tab. </p><p>The typemap file contains the mapping of <i>Crypt::Khazad</i>, an arbitrary data type, to its corresponding Perl value, <i>T_PTROBJ</i>, a type representing a pointer to a structure. Thus, we can set up an encryption/decryption routine like this:</p><PRE>use  Crypt::Khazad; $cipherobj  =  new  Crypt::Khazad  $key; $ciphertext  =  $cipherobj-&gt;encrypt($plaintext); $plaintext   =  $cipherobj-&gt;decrypt($ciphertext); </PRE><p>Given an argument, <i>$key</i>, the <i>new()</i> function will create an object, <i>$cipherobj</i>, of type <i>Crypt::Khazad</i> (the data type we just declared in the typemap file).</p><p>Essentially, <i>new()</i> clones the object <i>Crypt::Khazad</i>. In most object-oriented languages, <i>new()</i> is already a built-in function. Unfortunately, there is no equivalent function in Perl. So, we have to create one ourselves. Since we are free to implement this function in any way we want, we could just as easily name it, say, <i>clone()</i>, and we would still get the same result. </p><p>Now, comes the fun part: XS programming!</p><h3>XS Programming</h3><p>Another missing file in Crypt/Khazad/ is the heart of the module, the Khazad C code. In our case, that file is named _khazad.c (it's available in the <i>Crypt::Khazad</i> module distribution on CPAN). So copy this file to Crypt/Khazad/.</p><p>The best way to understand C code is to study its <i>main()</i> function. In _khazad.c, we see how <i>main()</i> uses the other functions to perform the process of encryption and decryption. (See <A NAME="rl1"><A HREF="#l1">Listing 1</A>.)</p><p>In Line 3, we see that variable <i>subkeys</i> is declared as data type <i>NESSIEstruct</i>. Lines 14-16 tell us that we have to initialize <i>subkeys</i> with a call to <i>NESSIEkeysetup()</i> before calling the functions <i>NESSIEencrypt()</i> for encryption, and <i>NESSIEdecrypt()</i> for decryption.</p><p>Now,  open the file Khazad.xs. Initially, its content is just:</p><PRE>1      #include  "EXTERN.h" 2      #include  "perl.h" 3      #include  "XSUB.h" 4  5      #include  "ppport.h" 6  7      MODULE  =  Crypt::Khazad         PACKAGE  =  Crypt::Khazad </PRE><p>Edit Khazad.xs so that it becomes: </p><PRE>1      #include  "EXTERN.h" 2      #include  "perl.h" 3      #include  "XSUB.h" 4  5      #include  "ppport.h" 6  7      #include  "_khazad.c" 8  9      typedef  struct  khazad  { 10           NESSIEstruct  key; 11       }*  Crypt__Khazad; 12   13       MODULE  =  Crypt::Khazad  PACKAGE  =  Crypt::Khazad </PRE><p>Notice that we have now <i>#include</i>-d the C code, _khazad.c (line 7). What about lines 9-11, starting with <i>typedef struct khazad</i>? Because the C code declares <i>subkeys</i> as type <i>NESSIEstruct</i> (line 3 of <A NAME="rl1"><A HREF="#l1">Listing 1</A>), we have to declare the variable <i>key</i> in Khazad.xs (line 10) as type <i>NESSIEstruct</i> as well.</p><p>But there's a catch. When _khazad.c is compiled, everything is fine. But when the XS file is compiled by xsubpp, it complains. In fact, you are likely to get the following fatal errors: </p><PRE>Khazad.c:  In  function  `XS_Crypt__Khazad_new': Khazad.c:64:  `Crypt__Khazad'  undeclared  (first  use  in this  function) Khazad.c:64:  (Each  undeclared  identifier  is  reported  only once Khazad.c:64:  for  each  function  it  appears  in.) </PRE><p>The solution is to look for the <i>NESSIEstruct</i> line in _khazad.c, and check how <i>NESSIEstruct</i> is declared. That code snippet is as follows: </p><PRE>struct  NESSIEstruct  {     u32  roundKeyEnc[R  +  1][2];     u32  roundKeyDec[R  +  1][2]; }; </PRE><p>The xsubpp compiler does not like this code. So, revise this code into this: </p><PRE>typedef  struct  NESSIEstruct  {     u32  roundKeyEnc[R  +  1][2];     u32  roundKeyDec[R  +  1][2]; }  NESSIEstruct; </PRE><p>That will keep the xsubpp compiler happy. </p><h3>Ensuring <i>Crypt::CBC</i> Compliance </h3><p><i>Crypt::CBC</i> is a module developed by Lincoln Stein to be used specifically in conjunction with block ciphers. As with all Perl modules, <i>Crypt::CBC</i> is also available from http://search.cpan.org/.</p><p>To be Crypt::CBC compliant, our block cipher must be able to return the block size it is using, as well as the length of its key, when <i>Crypt::CBC</i> asks for them. Edit Khazad.xs, adding the following lines: </p><PRE>int keysize(...) CODE:     RETVAL  =  16; OUTPUT:     RETVAL int blocksize(...) CODE:     RETVAL  =  8; OUTPUT:     RETVAL </PRE><p>Our new Khazad.xs is transformed as shown in <A NAME="rl2"><A HREF="#l2">Listing 2</A>.</p><p>The keyword <i>int</i> must be on a line by itself. <i>RETVAL</i> stands for "return value" and this is the data that <i>Crypt::CBC</i> needs. Read the perlxstut man pages for more details. The <i>keysize()</i> function returns a value of 16 bytes (the 128-bit key), while <i>blocksize()</i> returns 8 bytes (the 64-bit block length). </p><p>If we have the following code snippet: </p><PRE>use  Crypt::Khazad;   $cipherobj  =  new  Crypt::Khazad  $key; $ks  =  $cipherobj-&gt;keysize(); $bs  =  $cipherobj-&gt;blocksize(); </PRE><p><i>$ks</i> should hold the value 16, and <i>$bs</i> should be 8. </p><p>To implement the <i>new()</i>, <i>encrypt()</i>, and <i>decrypt()</i> functions, we must be familiar with perlguts and perlxs.</p><p>Edit Khazad.xs. It should now look like <A NAME="rl3"><A HREF="#l3">Listing 3</A>. You'll want to consult the perlguts man pages for discussions of the following keywords: </p><PRE>SV* STRLEN SvPOK SvCUR Newz SvPV _nolen SvPV newSVpv </PRE><p>A couple of important things are worth mentioning here. The <i>new()</i> function actually calls the C function <i>NESSIEkeysetup()</i>. Similarly, <i>encrypt()</i> and <i>decrypt()</i> execute the C functions <i>NESSIEencrypt()</i> and <i>NESSIEdecrypt()</i>, respectively. Just refer to the <i>main()</i> function of _khazad.c (<A NAME="rl1"><A HREF="#l1">Listing 1</A>) to learn how these functions are used. </p><p>The <i>DESTROY()</i> function is special. This function is called when the object, <i>Crypt::Khazad</i>, goes out of scope and needs to be destroyed. If  the <i>DESTROY()</i> function  does  not  exist,  then  nothing  is  done,  and  a memory leak could occur.</p><h3>The Khazad.pm File</h3><p>Delete the Khazad.pm generated by h2xs. We will make our own from scratch. <A NAME="rl4"><A HREF="#l4">Listing 4</A> is our new Khazad.pm.</p><p>It is worth noting that variable <i>@EXPORT_OK</i> (line 7) should list only those functions that we want to be visible from outside of the Khazad module. Line 7 tells us that <i>keysize()</i>, <i>blocksize()</i>, <i>new()</i>, <i>encrypt()</i>, and <i>decrypt()</i> are the only functions of Khazad that are accessible by other modules. </p><h3>The Makefile.PL File</h3><p>Delete the generated Makefile.PL. We'll make our own instead. The following is our hand-crafted Makefile.PL:</p><PRE>1  use  ExtUtils::MakeMaker; 2  3  WriteMakefile( 4      'NAME'  =&gt;  'Crypt::Khazad', 5      'VERSION_FROM'  =&gt;  'Khazad.pm', 6      'PREREQ_PM'  =&gt;  {}, 7      'AUTHOR'  =&gt;  'Julius  C.  Duque', 8      'LIBS'  =&gt;  [''], 9      'DEFINE'  =&gt;  '', 10       'INC'  =&gt;  '-I.', 11       'dist'  =&gt;  {'COMPRESS'  =&gt;  'gzip  -9f',  'SUFFIX'  =&gt;  'gz'} 12   ); </PRE><p>Please read the perlxstut man pages for more details. </p><h3>Writing a Test Script </h3><p>Every Perl module should be accompanied by at least one test script. A sample test script is shown in <A NAME="rl5"><A HREF="#l5">Listing 5</A>. Place this script in the "t" directory. The test script must be suffixed with a ".t." (If you want to know more on how to make test scripts, read up on Test::More.)</p><h3>Preparing the Distribution </h3><p>This is the easiest part. Just type the following: </p><PRE>perl Makefile.PL   make manifest   make dist </PRE><p>The module is now bundled as a *.tar.gz file. </p><h3>How to Use Khazad</h3><p>An example of using Khazad in a Crypt::CBC-compliant code is shown in <A NAME="rl6"><A HREF="#l6">Listing 6</A>. The output should be:</p><PRE>plaintext1   :  0123456789abcdeffedcba9876543210 ciphertext   :  1be2bb1a7b1bfa4227e33b06cf45c2d0f942f14a5b414e41 plaintext2   :  0123456789abcdeffedcba9876543210 </PRE><h3>Other Crypt Modules</h3><p>In addition to <i>Crypt::Khazad</i>, I have created several other block cipher modules. All of these are available on CPAN:</p><PRE>Crypt::Misty1 Crypt::Anubis Crypt::Noekeon Crypt::Skipjack Crypt::Camellia Crypt::Square </PRE><h3>References </h3><p>The following man pages are essential reading: h2xs, perlxstut, perlxs, and perlguts. </p><p>The following books also got me going: <i>Perl 5 How-To</i> by M. Glover, A. Humphreys, and E. Weiss (Waite Group; ASIN 1571690581).<i></p><p>Perl Cookbook</i>. T. Christiansen and N. Torkington (O'Reilly &amp; Associates; ISBN 1565922433).</p><h3>Acknowledgments</h3><p>I am indebted to Marc Lehmann for his <i>Crypt::Twofish2</i> module. I used his module as a skeleton for the Khazad implementation. Many thanks also go to the inventors of Khazad, Paulo S.L.M. Barreto and Vincent Rijmen. The Khazad home page is at http://planeta.terra.com.br/informatica/paulobarreto/KhazadPage.html.</p><p><b>TPJ</b></p><H4><A NAME="l1">Listing 1</H4><pre>1      int  main(void) 2      { 3        struct  NESSIEstruct  subkeys; 4        u8  key[KEYSIZEB]; 5        u8  plain[BLOCKSIZEB]; 6        u8  cipher[BLOCKSIZEB]; 7        u8  decrypted[BLOCKSIZEB]; 8  9        int  v; 10   11         printf("Test  vectors  --  set  1\n"); 12         printf("=====================\n\n"); 13   14         NESSIEkeysetup(key,  &amp;subkeys); 15         NESSIEencrypt(&amp;subkeys,  plain,  cipher); 16         NESSIEdecrypt(&amp;subkeys,  cipher,  decrypted); 17   18         /******  more  lines  follow  ******/ </pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing  2</H4><pre>1     #include  "EXTERN.h" 2     #include  "perl.h" 3     #include  "XSUB.h" 4  5     #include  "ppport.h" 6  7     #include  "_khazad.c" 8  9     typedef  struct  khazad  { 10     NESSIEstruct  key; 11      }*  Crypt__Khazad; 12   13      MODULE  =  Crypt::Khazad    PACKAGE  =  Crypt::Khazad14   15      int 16      keysize(...) 17     CODE: 18    RETVAL  =  16; 19     OUTPUT: 20    RETVAL 21   22      int 23      blocksize(...) 24     CODE: 25    RETVAL  =  8; 26     OUTPUT: 27    RETVAL </pre><P><A HREF="#rl2">Back to Article</A></P><H4><A NAME="l3">Listing 3</H4><pre>1  #include  "EXTERN.h" 2  #include  "perl.h" 3  #include  "XSUB.h" 4  5  #include  "ppport.h" 6  7  #include  "_khazad.c" 8  9  typedef  struct  khazad  { 10       NESSIEstruct  key; 11   }*  Crypt__Khazad; 12   13   MODULE  =  Crypt::Khazad         PACKAGE  =  Crypt::Khazad 14   15   int 16   keysize(...) 17       CODE: 18           RETVAL  =  16; 19       OUTPUT: 20           RETVAL 21   22   int 23   blocksize(...) 24       CODE: 25           RETVAL  =  8; 26       OUTPUT: 27           RETVAL 28   29   Crypt::Khazad 30   new(class,  rawkey) 31       SV*  class 32       SV*  rawkey 33       CODE: 34       { 35           STRLEN  keyLength; 36           if  (!  SvPOK(rawkey)) 37               croak("Error:  Key  must  be  a  string  scalar!"); 38   39           keyLength  =  SvCUR(rawkey); 40           if  (keyLength  !=  16) 41               croak("Error:  Key  must  be  16  bytes  long!"); 42   43           Newz(0,  RETVAL,  1,  struct  khazad); 44           NESSIEkeysetup(SvPV_nolen(rawkey),  &amp;RETVAL-&gt;key); 45       } 46   47       OUTPUT: 48           RETVAL 49   50   SV* 51   encrypt(self,  input) 52       Crypt::Khazad  self 53       SV*  input 54       CODE: 55       { 56           STRLEN  blockSize; 57           unsigned  char*  intext  =  SvPV(input,  blockSize); 58           if  (blockSize  !=  8)  { 59               croak("Error:  Block  size  must  be  8  bytes  long!"); 60           }  else  { 61               RETVAL  =  newSVpv("",  blockSize); 62               NESSIEencrypt(&amp;self-&gt;key,  intext,  SvPV_nolen(RETVAL)); 63           } 64       } 65   66       OUTPUT: 67           RETVAL 68   69   SV* 70   decrypt(self,  input) 71       Crypt::Khazad  self 72       SV*  input 73       CODE: 74       { 75           STRLEN  blockSize; 76           unsigned  char*  intext  =  SvPV(input,  blockSize); 77           if  (blockSize  !=  8)  { 78               croak("Error:  Block  size  must  be  8  bytes  long!"); 79           }  else  { 80               RETVAL  =  newSVpv("",  blockSize); 81               NESSIEdecrypt(&amp;self-&gt;key,  intext,  SvPV_nolen(RETVAL)); 82           } 83       } 84   85       OUTPUT: 86           RETVAL 87   88   void 89   DESTROY(self) 90       Crypt::Khazad  self 91       CODE: 92           Safefree(self); </pre><P><A HREF="#rl3">Back to Article</A></P><H4><A NAME="l4">Listing 4</H4><pre>1  package  Crypt::Khazad; 2  3  use  strict; 4  use  warnings; 5  require  Exporter; 6  7  our  @EXPORT_OK  =  qw(keysize  blocksize  new  encrypt  decrypt); 8  our  $VERSION  =  '1.0.0'; 9  our  @ISA  =  qw(Exporter); 10   11   require  XSLoader; 12   XSLoader::load('Crypt::Khazad',  $VERSION); 13   14   #  Preloaded  methods  go  here. 15   16   1; 17   18   __END__ 19   20   =head1  NAME 21   22   Crypt::Khazad  -  Crypt::CBC-compliant  block  cipher 23   24   =head1  ABSTRACT 25   26   Put  abstract  here. 27   28   =head1  SYNOPSIS 29   30       use  Crypt::Khazad; 31       $cipher  =  new  Crypt::Khazad  $key; 32       $ciphertext  =  $cipher-&gt;encrypt($plaintext); 33       $plaintext   =  $cipher-&gt;decrypt($ciphertext); 34   35   =head1  DESCRIPTION 36   37   Put  description  here. 38   39   =head1  COPYRIGHT  AND  LICENSE 40   41   Put  copyright  notice  here. 42   43   =cut </pre><P><A HREF="#rl4">Back to Article</A></P><H4><A NAME="l5">Listing 5</H4><pre>1  use  diagnostics; 2  use  strict; 3  use  warnings; 4  use  Test::More  tests  =&gt;  2; 5  BEGIN  { 6      use_ok('Crypt::Khazad') 7  }; 8  9  BEGIN  { 10       my  $key  =  pack  "H32",  "80000000000000000000000000000000"; 11       my  $cipher  =  new  Crypt::Khazad  $key; 12       my  $plaintext  =  pack  "H16",  "0000000000000000"; 13       my  $ciphertext  =  $cipher-&gt;encrypt($plaintext); 14       my  $answer  =  unpack  "H*",  $ciphertext; 15       is("49a4ce32ac190e3f",  $answer); 16   }; </pre><P><A HREF="#rl5">Back to Article</A></P><H4><A NAME="l6">Listing 6</H4><pre>1  #!/usr/local/bin/perl 2  3  use  diagnostics; 4  use  strict; 5  use  warnings; 6  use  Crypt::CBC;     #  CBC  automatically  loads  Khazad  for  us 7  8  my  $key  =  pack  "H32",  "00112233445566778899aabbccddeeff"; 9  my  $IV  =  pack  "H16",  "0102030405060708"; 10   11   my  $cipher  =  Crypt::CBC-&gt;new({'key'  =&gt;  $key, 12                                 'cipher'  =&gt;  'Khazad', 13                                 'iv'  =&gt;  $IV, 14                                 'regenerate_key'  =&gt;  1, 15                                 'padding'  =&gt;  'standard', 16                                 'prepend_iv'  =&gt;  0 17                               }); 18   19   my  $plaintext1  =  pack  "H32",  "0123456789abcdeffedcba9876543210"; 20   print  "plaintext1   :  ",  unpack("H*",  $plaintext1),  "\n"; 21   22   my  $ciphertext  =  $cipher-&gt;encrypt($plaintext1); 23   print  "ciphertext   :  ",  unpack("H*",  $ciphertext),  "\n"; 24   25   my  $plaintext2  =  $cipher-&gt;decrypt($ciphertext); 26   print  "plaintext2   :  ",  unpack("H*",  $plaintext2),  "\n"; </pre><P><A HREF="#rl6">Back to Article</A></P></body></html>