<html><head><title>Aug03: Bryar: A New Weblogging Tool</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; The Perl Journal--><h1>Bryar: A New Weblogging Tool</h1><p><i>The Perl Journal</i> August 2003</p><h3>By Simon Cozens</h3><I>Simon is a freelance programmer and author, whose titles include Beginning Perl (Wrox Press, 2000) and Extending and Embedding Perl (Manning Publications, 2002). He's the creator of over 30 CPAN modules and a former Parrot pumpking. Simon can be reached at simon@ simon-cozens.org.</I><hr><p>In my last article, I mentioned that I maintain a blosxom-based weblog. blosxom is a very clever bit of Perl written by Rael Dornfest, and is designed to be simple, self-contained, and  easy to get up and running. I like its simplicity, I like the way it uses flat text files, I like the basic idea of it, but there are some things about it I don't actually like. So after my last article got me thinking about blogging, I decided the time was right to write my own blog software. That weekend, I heard someone speak about "blossoms and briars," and a new project was born.</p><p>A lot of what I've been doing recently might be categorized as reinventing wheels&#151;first the <i>Email::</i> project, and now this. But sometimes, it's necessary to reinvent wheels. If we didn't, to paraphrase Gary Burgquist, this would be The Cobol Journal, we'd have leeches all over our bodies, we would be listening to just 8-track tapes. Wheel reinvention is the only way we get smoother wheels. But we don't do so lightly and we don't do it just for the sake of it. When we're reinventing wheels, it's important to think about what problems we're trying to solve and how we're going to improve on the existing technology.</p><p>So, while the basic ideas of blosxom were great, it had two big problems. First, the code is monolithic, difficult to follow, and difficult to extend; if, for instance, you want to shift from flat files to a database-backed storage system, you're basically out of luck and reduced to tearing up major parts of the program. Second, because the software is self-contained, the templates for critical parts of the output live in a DATA section at the end of blosxom.cgi (at least for the 1.x series of blosxom; I'm told things get slightly better in the new 2.x series, but I was already fed up with blosxom by this point). Editing these to customize the output can be awkward, and having done so makes upgrading difficult.</p><p>It's also important to realize that these things aren't defects in blosxom at all; they come about because blosxom is confirming to a particular set of design goals, and they are goals that I agree with and think are suitable for most people. Keep it simple, self-contained, easy to install, and easy to use. But I also felt that I had outgrown the boundaries of what I could do with blosxom, and so it was time for something new.</p><p>Let's first look at a user's perspective on the result of all this deliberation, and then we'll take a look at how some of it was done; in the next article, we'll take a deeper look at the construction of Bryar, and how it can be extended. Along the way, we'll learn a little about blogging with Bryar, program design, finding files with <i>File::Find::Rule</i>, and efficient list handling.</p><h3>Using Bryar</h3><p>Installing Bryar is relatively simple. Not quite as simple as installing blosxom, but close. First, we have to grab all the modules we need from CPAN, and the best way to do this is with the <i>CPANPLUS</i> Perl module:</p><PRE>perl -MCPANPLUS -e 'install Bryar'</PRE><p>Once you've got <i>CPANPLUS</i> up and running&#151;an essential component of any serious Perl site&#151;the aforementioned command should install the Bryar code and its dependencies, and it should also tell you at some point:</p><p>You probably want to run bryar-newblog in a likely home for your blog once we've finished installing.</p><p>Let's do that now.</p><PRE># mkdir -p /opt/blog# chown simon:simon /opt/blog% cd /opt/blog% bryar-newblog</PRE><p>Setting up a Bryar blog in this directory</p><p>Done. Now you want to probably customize 'bryar.conf'. You should probably also customize template.html, head.html and foot.html Then point your browser at bryar.cgi, and get blogging!</p><p>Now, just as with blosxom, we need to tell the web server to serve up that directory and treat bryar.cgi as a CGI script and the directory's index. Once we've done that, we can point to our browser at the relevant location&#151;perhaps http://localhost/blog/ and we should see something like <A NAME="rf1"><A HREF="0308df1.htm">Figure 1</A>.</p><p>It's not pretty, but it works. As the message says, we should probably customize template.html, head.html, and foot.html to make it a bit prettier. <A NAME="rf2"><A HREF="0308df2.htm">Figure 2</A> shows what my blog looks like after a tiny bit of customization&#151;deliberately constructed to make it very similar to blosxom's default format. By default, Bryar uses Template Toolkit to format posts, so regular readers of this column should know how to deal with the HTML files generated by bryar-newblog.</p><p>To make blog posts, we simply add files called <i>something.txt</i> in our data directory:</p><p>Title</p><PRE>&lt;P&gt;HTML goes here&lt;/P&gt;</PRE><p>Bryar automatically picks these up, sorts them in date order, and formats them appropriately. In fact, I use a little script to ensure that I have a unique post ID every time I want to make a blog entry; here's my <i>bin/blog</i> command:</p><PRE>#!/usr/bin/perlmy $path = "/opt/blog/".shift()."/";$blog[$_]++ for map { /(\d+)\.txt/&amp;&amp;$1} &lt;$path/*txt&gt;; system("vim",$path.@blog.".txt");</PRE><p>The first line of code decides where to look for posts. The second is a sneaky way to find a new post number. My posts are all entered numerically (6065.txt, and so on). This line looks at all of the ".txt" files and builds an array of currently existing posts; if the highest numbered post we have currently is 1234.txt, it will set <i>$blog[1234]</i> to 1. It'll also assign to a bunch of other elements of that array, but we don't care about those; we only care about the highest number in existence at the moment.</p><p>If <i>$blog[1234]</i> is the highest numbered element, <i>@blog</i> itself will have 1235 elements, and thanks to the wonderful Mr. Cantor and his diagonal theorem, post 1235 is guaranteed not to be in use at the moment. So we start an editor on /opt/blog/1235.txt&#151;a brand new blog post.</p><p>For those of you who have embraced the RSS generation,  Bryar can also generate an RDF file by adding "/xml" to the end of the URL. The POD documentation to Bryar.pm details all the other things that can be done with Bryar URLs.</p><p>Now that we have an idea of what Bryar does, let's have a look at how it does it.</p><h3>Basic Design</h3><p>I designed Bryar to have four major areas of operation; it turns out that there are possibly some more things it needs to do, but these can be worked out over time. By splitting Bryar's operation into these distinct areas, we enable it to be highly customizable by letting people replacing any or all of the classes that implement these operations.</p><p>The four things that Bryar has to do can be described as "interface," "retrieval," "collation," and "formatting." But since I didn't think in those terms when I was designing the code, we'll call them the <i>Frontend</i>, <i>DataSource</i>, <i>Collector</i>, and <i>Formatter</i> classes.</p><p><b><i>Frontend</b>&#151;</i>The <i>Frontend</i> class deals with the interaction between Bryar and the outside world. As with blosxom, the primary interface mechanism is through the Common Gateway Interface; the URL and other options are determined from the execution environment, the final output is written to standard output, and so</p><p> on. We can equally conceive of a component which implements <i>Bryar::Frontend</i> as a <i>mod_perl</i> handler, for instance, or as a stand-alone program taking options from the command line.</p><p><b><i>DataSource</b>&#151;</i>Blog entries have to come from somewhere; the <i>DataSource </i>class finds entries, finding only those entries fulfilling particular criteria, and turns them into a set of <i>Bryar::Document</i> objects that abstract postings away from the data source and into a common interface. Since we're emulating blosxom, the default <i>DataSource</i> class reads all the .txt files in a given data directory, and uses filesystem properties such as the last-modified time and the owner as post metadata. We could also take blog entries from a database and we'll show an example of this later in the article.</p><p><b><i>Collector</i></b>&#151;The <i>Collector </i>class has the job of interpreting the options obtained from the <i>Frontend</i>, turning them into a search query, and asking the <i>DataSource</i> class for all the documents that fulfill the query. For instance, we might return the last 20 posts, (the default operation) or the posts in a particular month or day, or posts containing a given phrase. This is possibly the most "stationary" class in Bryar, since it's difficult to imagine a good reason for changing the default behavior.</p><p><b><i>Renderer</i></b>&#151;Once the <i>Collector </i>has decided on a set of <i>Bryar::Document</i> objects to be displayed, they are handed off to the <i>Renderer</i> class. As mentioned earlier, we use the Template Toolkit by default, but there's no reason why we couldn't create <i>Renderer </i>classes that use <i>HTML::Template </i>or <i>HTML::Mason</i>.</p><p>Bryar's operation can be summarized in the flowchart shown in <A NAME="rf3"><A HREF="0308df3.htm">Figure 3</A>.</p><p>Other satellite classes that turned out to be useful were <i>Bryar::Config</i>, which encapsulates the configuration, and <i>Bryar::Comment</i>, a subclass of <i>Bryar::Document</i> used for encapsulating comments on a blog posting.</p><p>We'll take a detailed look at two of these areas, those that are most likely to be customized&#151;the data source and the front end.</p><h3>Data Sources</h3><p>As I've mentioned, the job of the <i>DataSource </i>class is to turn our raw data into <i>Bryar::Document </i>objects. There are three methods we need to provide in order to do this: <i>all_documents</i> should return absolutely everything, <i>search</i> should return those documents matching specified search criteria, and <i>add_comment</i> should record a comment against an article.</p><p>As it turns out, if we implement <i>all_documents,</i> we don't need to implement <i>search</i> but can instead inherit from <i>Bryar::DataSource::Base</i>. This base class provides a very dumb search facility that looks at every single <i>Bryar::Document</i> and sorts out those that match the search terms. This is very inefficient, though, since it's usually faster to do some kind of searching at the data-source level&#151;for instance, if our posts are stored in a SQL database, we might as well use the capabilities of SQL SELECT to find posts within a certain time period or for a particular ID, rather than plough through individual posts.</p><p>Similarly, if we implement <i>search</i>, we don't actually have to implement <i>all_documents</i>, as nothing in Bryar calls it (yet). On the other hand, it may be useful to do so&#151;both for completeness, and as a warm up for writing <i>search</i>. It's also conceivable that, in the future, one might add extensions to, say, format an entire journal for printing as a PDF file.</p><p>Let's start by looking at <i>all_documents</i> in our flat file data source. With the obscene comments removed, this looks like:</p><PRE>sub all_documents {    my ($self, $bryar) = @_;    croak "Must pass in a Bryar object"         unless UNIVERSAL::isa($bryar, "Bryar");    my $where = cwd;    chdir($bryar-&gt;{config}-&gt;datadir);     my @docs = map { $self-&gt;make_document($_) }            File::Find::Rule-&gt;file()                            -&gt;name("*.txt")                            -&gt;maxdepth($bryar-&gt;{config}-&gt;depth)                            -&gt;in(".");    chdir($where);    return @docs;}</PRE><p>We're called as a class method and passed a <i>Bryar</i> object; this stores the configuration and current state of the blog, and essentially draws everything together. First, we need to determine where our data files live; this is stored in the Bryar config, which we access via <i>$bryar-&gt;{config}</i>. Once we've found this, we change to that directory and start looking for files. I've used Richard Clamp's wonderful <i>File::Find::Rule </i>module which, as we'll see later, turns out to be almost purpose built for what we're about to do.</p><p><i>File::Find::Rule</i> is a nicer way of finding files than the usual <i>File::Find</i>. The idea is that we chain together rules that describe what we're looking for, and finally tell it where to look. This acts a little like the UNIX <i>find(1) </i>command. So in this case, we look for all the <i>*.txt</i> files in the current directory and subdirectories below, up to a maximum depth specified in the blog configuration. This allows us to have entries categorized into subdirectories included in the blog. We call the helper function <i>make_document</i> on each one, which does the heavy work of turning a filename into a <i>Bryar::Document </i>object, and we return all these results.</p><p><i>make_document</i> is fairly uninteresting, being concerned with extracting metadata from a file; we saw in my last article how to do this for blosxom-style files. Now we're warmed up and ready to go, let's move on to the more interesting <i>search</i> method, which stretches <i>File::Find::Rule</i> a little more.</p><h3>Finding Files By Rule</h3><p>The <i>search </i>method takes a Bryar object as before, but it also takes a hash of things to look for. In particular, <i>id</i> finds a document with a particular ID; this is used to provide permanent links for articles, especially in the case of articles referenced from an RDF feed. <i>since</i> and <i>before</i> look for documents after and before particular UNIX epoch times; <i>contains</i> finds documents containing a particular word, and <i>subblog</i> looks for documents in a given sub-blog or category. Finally, the <i>limit</i> parameter is used to set a maximum number of entries to return. For instance, by default, the front page of a blog will show the 20 most recent articles.</p><p>Thanks to <i>File::Find::Rule</i>, we can actually construct a search that covers all but one of these search terms in one single call. Naturally, the more specific we can make a single search, the fewer passes over the data we need to do, and therefore, the more efficient our data source class turns out to be.</p><p>The first few lines of <i>search </i>should be reasonably obvious:</p><PRE>sub search {    my ($self, $bryar, %params) = @_;    croak "Must pass in a Bryar object"         unless UNIVERSAL::isa($bryar, "Bryar");    my $was = cwd;    my $where = $bryar-&gt;{config}-&gt;datadir."/";    if ($params{subblog}) { $where .= $params{subblog}; }    chdir($where);</PRE><p>We find our data directory as before, and this time, if we're given a subdirectory name to look in: We start searching from there instead of the document root.</p><p>Now we start putting our query together. The most obvious thing to look for is the document ID. If we're trying to find blog post number 89, then it's quite dull to look for "*.txt" and extract "89.txt"&#151;we might as well just go straight for "89.txt":</p><PRE>my $find = File::Find::Rule-&gt;file();if ($params{id}) { $find-&gt;name("$params{id}.txt") }            else { $find-&gt;name("*.txt") }</PRE><p>As before, we restrict our search to a maximum depth:</p><PRE>$find-&gt;maxdepth($bryar-&gt;{config}-&gt;depth);</PRE><p>And now the clever stuff starts. <i>File::Find::Rule</i> allows us to specify bounds for the last-modified time of a file, something that will help us to find entries within a given period:</p><PRE>if ($params{since})   { $find-&gt;mtime("&gt;".$params{since}) }if ($params{before})  { $find-&gt;mtime("&lt;".$params{before}) }</PRE><p>Notice what's happening here&#151;we're simply modifying the <i>$find</i> object by adding constraints to it. It isn't hitting the filesystem at all yet, it's simply building up a data structure that determines how to perform the search.</p><p>Finally, we can look for items that contain a particular word or phrase; <i>File::Find::Rule</i> allows us to grep through the contents of a file using the aptly named <i>grep</i> method:</p><PRE>if ($params{content}) { $find-&gt;grep(qr/\b\Q$params{content}\E\b/i) }</PRE><p>Are you comfortable with that regular expression? It says that we're looking for a word break, then the literal contents of <i>$params{content}</i>, then another word break. The word breaks are there to ensure that a search for "pie" only finds articles that talk about "pie," and not those which talk about being "occupied" or similar; the <i>\Q</i> and <i>\E</i> make sure that we don't treat <i>$params{content}</i> as a regular expression, but rather as literal text.</p><p>Why don't we let the users search using regular expressions? Although this would undeniably be powerful, we want to keep this relatively simple. Since some data sources, such as a SQL back end, won't support searching by regular expression, so we deliberately restrict the search to make it as efficient as possible.</p><h3>Setting a Limit</h3><p>Now we are ready to actually launch our search and grovel around the filesystem. The only search term we have not dealt with is <i>lim</i>it, restricting the number of documents returned. The problem with this is that we can't force <i>File::Find::Rule</i> to return the results in any particular order. When we want at most 20 blog entries, we actually want the most recent 20, not just the first 20 we come across on the disk; these may not turn out to be the same. So, to implement <i>limit</i>, we need to do a little trickery. Let's first dispatch the case where there is no limit given:</p><PRE>if (!$params{limit}) {    @docs = map { $self-&gt;make_document($_) } $find-&gt;in(".");}</PRE><p>We simply start the search in the current directory, turn all the found files into documents, and we're done. That was easy. When there's a limit, we have to be a bit more careful:</p><PRE>@docs =  map { $self-&gt;make_document($_) }        (            map { $_-&gt;[0] }            sort { $b-&gt;[1] &lt;=&gt; $a-&gt;[1] }            map { [$_, ((stat $_)[9]) ] }            $find-&gt;in(".")        ) [0..$params{limit}-1];</PRE><p>What's going on here? Well, the core of it is the same as the unlimited case&#151;we find the files in the current directory and turn some of them into <i>Bryar::Document</i>s. In the middle, though, we first have a well-known Perl sort technique, the Schwartzian transform:</p><PRE>@sorted_files =     map { $_-&gt;[0] }    sort { $b-&gt;[1] &lt;=&gt; $a-&gt;[1] }    map { [$_, ((stat $_)[9]) ] }    @files;</PRE><p>This is the most efficient way to sort a list of files newest-first. We could, of course, just say this:</p><PRE>@sorted_files = sort {    my $a_modification = (stat $a)[9];    my $b_modification = (stat $b)[9];    $b_modification &lt;=&gt; $a_modification;} @files;</PRE><p>Unfortunately, this makes two <i>stat</i> calls for every comparison, and every student of algorithms knows that Quicksort uses roughly <i>n</i> log <i>n</i> comparisons. This means that, for 100 files, we have about 1000 system calls. This isn't great. Instead, we use the Schwartzian transform to reduce that to only 100 <i>stat</i>s&#151;one per file&#151;can't get much better than that. For more details of how the Schwartzian works, see http://www.cpan.org/doc/FMTEYEWTK/sort.html.</p><p>Now that we have the sorted list of filenames, we use a slice to pull out the required number, and then pass these on to <i>make_document</i>:</p><PRE>@docs =  map { $self-&gt;make_document($_) }        @sorted_files[0..$params{limit}-1];</PRE><p>However, as we've seen, most of the heavy lifting has already been done by <i>File::Find::Rule</i>, so this turns out to be a reasonably efficient search routine, given that we're using a filesystem-based data source.</p><h3>Where to from Here?</h3><p>We've said that <i>Bryar::DataSource::FlatFile</i> is reasonably efficient. But of course, we can make the whole process of retrieving posts even more efficient. In our next article, we'll look at how we can implement the same <i>DataSource</i> interface with a SQL back end using <i>Class::DBI</i> to retrieve posts from a database, and how this affects the way we can search for posts.</p><p>We'll also look at extending some of the other parts of Bryar as well. It's a tribute to Bryar's component-based design that we'll be able to turn it from a CGI-based flat-file blog tool using <i>Template::Toolkit</i> to a database-backed Apache-mod_perl blog formatted by <i>HTML::Mason</i>. Tune in next time to find out how we do it&#151;and in the meantime, happy blogging!</p><p><b>TPJ</b></p></body></html>