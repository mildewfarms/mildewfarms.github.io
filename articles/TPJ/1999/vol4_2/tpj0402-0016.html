<html><head><META name=vscategory content="Perl"><META name=vsisbn content=""><META name=vstitle content="Perl/Tk Menus: Past, Present and Future"><META name=vsauthor content="Steve Lidie"><META name=searchdescription content="Menus are pervasive, appearing in nearly every graphical application. In this article we'll examine pulldown and popup menus, Tk 4 and Tk 8 style menubars, and finally, peek into the future and see one way menus might evolve."><META name=vsimprint  content="The Perl Journal"><META name=vspublisher content="Earthweb"><META name=vspubdate content="Summer 1999"><title>Perl/Tk Menus: Past, Present and Future - The Perl Journal, Summer 1999</title><body bgcolor="ffffff"><!-- end head --><font face="verdana" size="1">Issue 14, Summer 1999</font><h2 ALIGN="center">Perl/Tk Menus: Past, Present and Future </h2><h4>Steve Lidie</h4><p>Whether they drop down as rectangles or pop up as pies, menus are widgets that managebundles of related information. Menus are pervasive, appearing in nearly every graphicalapplication. In this article we'll examine pulldown and popup menus, Tk 4 and Tk 8 stylemenubars, and finally, peek into the future and see one way menus might evolve.  <p>Several years ago, Unix-only Tk 4 evolved into Tk 8, adding support for Windows and theMacintosh. The Tk team seized this opportunity to improve their menu design, bysimplifying menus and unifying their management across the three operating systems. (Notethat Tcl/Tk runs on Macs, but Perl/Tk doesn't. And by the way, there wasn't a Tk 5, 6, or7: the jump was to synchronize Tk's number scheme with Tcl's.) <p>There's still a lot of Tk 4 code out there, so it's helpful to be familiar with both Tk4 and Tk 8 menus. Indeed, <i>most</i> menu code is Tk 4 style, simply because it has beenaround the longest and works just fine in Tk 8.  <p>If you're still using Tk 4, that's okay for the short term. But you miss out on the newfeatures and widgets, and, most importantly, support and bug fixes. You also can't runsome of the demonstration code that goes with this article.  <h3>Menu Terminology</h3><p>You probably know how menus behave. In Tk lingo, menus are <i>widgets</i> containingone or more <i>menu items</i>. A menu remains hidden until it is "posted",usually by clicking a menubutton, and then the menu's items are displayed, vertically, ina rectangular window. Once a menu item is selected, the menu is unposted. <ahref="images/tk-1.gif">Figure 1</a> shows amenubutton, two menus, and the six different Tk menu items (described shortly). Mostapplications have several menubuttons arranged in a row across the top of their mainwindow, packaged in a construct termed a <i>menubar</i>. In Tk 4 a menubar is a framewidget filled with menubutton widgets, but in Tk 8 a menubar is a special menu widgetfilled with "cascade" menu items. We'll explore menubars in detail later. <p>In addition to cascades, there are five other menu items: <i>command</i>, <i>checkbutton</i>,<i>radiobutton</i>, <i>separator</i>, and <i>tearoff</i>, all shown in <ahref="images/tk-1.gif">Figure 1</a>. Except forseparators and tearoffs, these items are composed of two fields each, a <i>label</i> andan <i>accelerator</i>. The label is usually a text string (but might be an image) thatidentifies what the menu item does. The optional accelerator activates a menu item with akeyboard shortcut rather than the mouse. We'll talk about the various menu items in detailshortly, but first, some brief descriptions.  <h3>Some Brief Descriptions Of Menu Items</h3><p align="center"><img SRC="images/tk-1.gif" WIDTH="358" HEIGHT="208" ALIGN="center"ALT="tk-1"><p align="center"><b>Figure 1</b><p>The most common menu item, <i>command</i>, emulates a button widget because it executesa command (Tk callback) when clicked.  <p><i>Checkbutton</i> and <i>radiobutton</i> menu items resemble their widgetcounterparts: Checkbuttons are either on or off, while radiobuttons choose one item fromseveral alternatives. Both of these menu item types can invoke a callback and modifya Perl variable.  A <i>cascade</i> menu item posts a sub-menu that contains furthermenu items. Cascaded menus can contain more cascaded menus. We'll examine cascade menuitems in the discussion on menubars.  <p>A <i>separator</i> menu item is simply a thin horizontal line used to divide a menuinto logical partitions.  <p>The special <i>tearoff</i> menu item is a dashed line that, when clicked, <i>reparents</i>the menu inside its own decorative window manager border. The torn-off menu then remainspermanently posted until destroyed by a window manager action. These window manageractions are often <i>command</i> menu items activated by clicking the top-left corner ofthe window manager's border, sometimes called the <i>System Menubutton</i>. A tearoff menuitem is optional, but, when present, is always the first menu item. In <ahref="images/tk-1.gif">Figure 1</a> notice that the"Geometry Manager" cascade menu has no tearoff. <p>Finally, there are times when we need to refer to an individual menu item. We refer toa menu's items with an <i>index</i>, which can be an integer, a Y-pixel coordinaterelative to the menu's top left corner, a string to match against menu item labels, or aspecial identifier: "active", "last", or "none".  <h3>Popup Menus</h3><p>Assuming <tt>$mw</tt> is our MainWindow, we can create a mostly-empty menu like this: <pre>my $popup_menu = $mw-&gt;Menu;</pre><p>This menu isn't completely empty because it has a tearoff menu item, and thetearoff's menu index is zero. If we add <tt>-tearoff =&gt;</tt> '<tt>no</tt>' to the menucreation command, then menu index zero is assigned to the first menu item we create. Thismenu is also invisible, and can't be managed in the normal fashion with a geometry managerlike <tt>place()</tt>, <tt>pack()</tt>, or <tt>grid()</tt>. Menus can only be posted bypressing a menubutton (or cascade), or by manually calling the <tt>post()</tt> or <tt>Popup()</tt>method. To make this menu useful, let's add its second menu item, a command:  <pre>$popup_menu-&gt;command(-label =&gt; 'Quit',                 -command =&gt; \&amp;exit);</pre><p align="center"> <img SRC="images/tk-2.gif" WIDTH="252" HEIGHT="189"ALIGN="center" ALT="tk-2"><p align="center"><b>Figure 2</b><p>Menu widgets have methods to create the various menu item types like <tt>command()</tt>.The <tt>separator()</tt> method drew the thin horizontal line seen in <ahref="images/tk-1.gif">Figure 1</a>. We'll visit theremaining items types in later sections.  <p>Now let's create a button whose callback posts the menu (the complete program, <tt>popup1</tt>,is on the TPJ web site):  <pre>my $b = $mw-&gt;Button(-text =&gt; 'Popup!')-&gt;grid;$b-&gt;configure(-command =&gt; sub {                $popup_menu-&gt;post(500, 500) });</pre><p>Running <tt>popup1</tt> produces the window on the left half of <ahref="images/tk-2.gif">Figure 2</a>. Pressing thebutton invokes the <tt>post()</tt> method, and a naked menu appears at screen coordinates(500, 500), with dashed-tearoff and Quit-command items. Pressing the tearoff reparents themenu. Now we can treat the menu as a toplevel, move it around, make menu selections,iconify it, or whatever we like.  One problem with the <tt>post()</tt> method is theneed to specify <i>where</i> the menu is to appear. Placing it arbitrarily means that itoften won't be near the cursor. That's not very user friendly. Menubuttons convenientlyarrange for their menu to pop up right next to the cursor. Since a popup has no associatedmenubutton, we can use the <tt>Popup()</tt> method instead, as in the <tt>popup2</tt>program:  <pre>$b-&gt;configure(-command =&gt; sub {              $popup_menu-&gt;Popup(qw/-popover cursor/);});</pre><p>When this menu is posted, it's aligned so its north edge touches the cursor -- thecontact point is known as the <i>popanchor</i> position. With <tt>-popanchor =&gt; 'n'</tt>(the default value) the menu lies below the cursor. Similarly, with <tt>-popanchor =&gt;'s'</tt> the menu lies above the cursor. All eight cardinal compass directions are legalpopanchor values: <tt>n</tt>, <tt>ne</tt>, <tt>e</tt>, <tt>se</tt>, <tt>s</tt>, <tt>sw</tt>,<tt>w</tt>, <tt>nw</tt>, as well as <tt>c</tt> (for center). <p>Menus don't have to appear above the cursor. They can also pop over other widgets (youprovide the widget reference), or even over the root window itself (you provide <tt>undef</tt>).When a menu pops over something, it can be aligned on any of the standard eight compasspoints (and center) along the widget's border. This is known as the <i>overanchor</i>position. With <tt>-overanchor =&gt; 'w'</tt>, the menu appears on the widget's left edge,and <tt>-overanchor =&gt; 'e'</tt> makes the menu appear on the right edge. Combine <tt>-overanchor</tt>with <tt>-popanchor</tt> for fine -grained menu placement. <p>The <tt>Popup()</tt> method also works with toplevel widgets. A nice popupdemonstration is included with the Perl/Tk distribution, and is on the TPJweb site as <tt>ptk-popup</tt>.  <h3>Checkbuttons</h3><p align="center"><img SRC="images/tk-3.gif" WIDTH="137" HEIGHT="192" ALT="tk-3"><p align="center"><b>Figure 3 </b><p><a href="images/tk-3.gif">Figure 3</a> showsradio-button and checkbutton menu items -- the checkbuttons are in the lower half of themenu. Both menu items have an <i>indicator</i> on their left that advertises whether theyare on or off. A checkbutton's state (whether it's selected or not) is stored in a Perlscalar. Here's a typical checkbutton creation command:  <pre>$menu-&gt;checkbutton(-label =&gt; 'Autosize line',              -variable =&gt; \$autosize,              -onvalue =&gt; 1, -offvalue =&gt; 0,              -underline =&gt; 0, -command =&gt; \&amp;line);	 </pre><p>So Tk sets <tt>$autosize</tt> to 1 whenever the item is selected, and 0 when it'sdeselected. The reverse is true as well -- changing the variable to 0 or 1 changes theindicator. Also, the character at label position zero is underlined, and the subroutine <tt>&amp;line</tt>is called whenever there's a state change.  <h3>Radiobuttons</h3><p>Radiobuttons select a single item from a list of related items. (If you have a one itemlist, just use a checkbutton.) Each radiobutton in a group uses the same Perl scalar tostore its value, like this:  <pre>$menu-&gt;radiobutton(-label =&gt; '1 point',          -variable =&gt; \$point, -value =&gt; 1,           -underline =&gt; 0, -command =&gt; \&amp;point);$menu-&gt;radiobutton(-label =&gt; '2 point',          -variable =&gt; \$point, -value =&gt; 2,           -underline =&gt; 0, -command =&gt; \&amp;point);</pre><p>The scalar <tt>$point</tt> takes on one of several point sizes as the radiobuttonindicators are clicked. And like checkbuttons, changing the variable's value changes theTk indicator, and invokes a callback.  <h3>Tk 4 Menubars</h3><p>Many Perl/Tk programs manually build their menubars by packing menubuttons into aframe. Some buttons are left-justified, some are right-justified. The following statementsare from program <tt>menubar1</tt>, and produce a menubar identical to what you see in <ahref="images/tk-4.gif">Figure 4</a>.  <pre>my $mw = MainWindow-&gt;new;$mw-&gt;geometry('300x50');my $menubar = $mw-&gt;Frame(qw/-relief raised -borderwidth 2/);$menubar-&gt;pack(qw/-fill x/);my $file = $menubar-&gt;Menubutton(qw/-text File-underline 0/);my $cas1 = $menubar-&gt;Menubutton(qw/-text Cascades-underline 3/);my $help = $menubar-&gt;Menubutton(qw/-text Help -underline 0/);$file-&gt;pack(qw/-side left/);$cas1-&gt;pack(qw/-side left/);$help-&gt;pack(qw/-side right/);</pre><p>Thus far I've intentionally avoided cascades; it's time to remedy that situationby adding one (keep <a href="images/tk-4.gif">Figure4</a> in mind). I've found that almost no one grasps how to make multi-level cascades,mainly because the sub-menu creation is so obscure.  <pre>my $cas2 = $cas1-&gt;cascade(-label =&gt; "Cascade Level 2");$cas1-&gt;command(-label =&gt; 'Level 1');</pre><p align="center"><a href="images/tk-4.gif"><img SRC="images/tk-4_small.gif"ALIGN="center" ALT="tk-4" border="2" width="100" height="29"></a><p align="center"><b>Figure 4</b><p>The <tt>Cascades</tt> menu now has three menu items, a tearoff, a cascade and acommand. The cascade item <tt>Cascade level 2</tt> needs its sub-menu created, but thesub-menu must be a child of the <tt>Cascades</tt> menu. The following code fetches themenu reference for the parent menu, creates the sub-menu, and then configures the newcascade. <pre>my $cas1_menu = $cas1-&gt;cget(-menu);my $cas2_menu = $cas1_menu-&gt;Menu;$cas1-&gt;entryconfigure('Cascade Level 2', -menu =&gt; $cas2_menu);$cas2-&gt;command(-label =&gt; 'Level 2',                -command =&gt; sub {print "Level 2\n"});</pre><p>That's a lot of work, and we won't go any further with this Tk 4 idiom. Much haschanged, as we'll see.  <h3>Tk 8 Menubars</h3><p>When menubars were revamped in Tk 8 to support Macintosh and Win32 operating systems,they became even easier to use. For instance, a menu widget can be attached to anymainwindow or toplevel, and act as a menubar. This means we don't have to generate our ownmenubar from a frame and menubuttons. Nor do we have to worry about their geometrymanagement. Menubuttons are now superfluous -- cascades take their place. The menu manageralso looks for menu labels, like <tt>Help</tt> on Unix and <tt>System</tt> on Win32, andhandles them specially. The manager also ensures that the appearance and behavior of themenubar adheres to the user interface guidelines of the running operating system. Thefollowing program, <tt>menubar2</tt>, a Tk 8 version of <tt>menubar1</tt>, produced thedisplay shown in <a href="images/tk-4.gif">Figure 4</a>.The program speaks for itself: <pre>#!/usr/local/bin/perl -w## menubar2 - create a menubar in the modern Tk 8 style.use Tk 8.0;use strict;# Create the MainWindow (or Toplevel) with a # menubar attached to it. Think of the menubar # as a menu widget that's always posted, with its# cascade menu items displayed left to right # (and without adornments like indicators and # accelerators), instead of vertically, top to bottom.my $mw = MainWindow-&gt;new;$mw-&gt;geometry('300x50');my $menubar = $mw-&gt;Menu;$mw-&gt;configure(-menu =&gt; $menubar);# Create the pseudo-menubuttons, which are actually # cascade menu items. Since cascades post menus, # why bother with menubuttons? Note that the# cascade's menu widget is automatically created. # Also note the use of the ~ character to specify the # underline character, which is certainly easier than # counting and specifying -underline. On Unix the # "Help" cascade is automatically right # justified in the menubar, freeing us of the task. # For both Unix and Win32, a separator menu item right # justifies all following cascades in the menubar.my $file = $menubar-&gt;cascade(-label =&gt; '~File');my $cas1 = $menubar-&gt;cascade(-label =&gt; 'Cas~cades');my $help = $menubar-&gt;cascade(-label =&gt; '~Help');# Create the menu items for each menu. # First, the File menu item.$file-&gt;command(-label =&gt; "Quit!", -command =&gt; \&amp;exit);# Creating multi-level cascades in Tk 4 is a royal pain, # but in Tk 8 it's a piece of cake - all sub-menus are # created automatically!my $cas2 = $cas1-&gt;cascade(-label =&gt; "Cascade Level 2");;my $cas3 = $cas2-&gt;cascade(-label =&gt; 'Cascade Level 3');my $cas4 = $cas3-&gt;cascade(-label =&gt; 'Cascade Level 4');$cas1-&gt;command(-label =&gt; 'Level 1',          -command =&gt; sub {print "Level 1\n"});$cas2-&gt;command(-label =&gt; 'Level 2',          -command =&gt; sub {print "Level 2\n"});$cas3-&gt;command(-label =&gt; 'Level 3',          -command =&gt; sub {print "Level 3\n"});$cas4-&gt;command(-label =&gt; 'Level 4',          -command =&gt; sub {print "Level 4\n"});# Finally, the Help menu items.$help-&gt;command(-label =&gt; 'Version',          -command =&gt; sub {print "Version\n"});$help-&gt;separator;$help-&gt;command(-label =&gt; 'About',            -command =&gt; sub {print "About\n"});# In Tk 8 whenever the cursor passes over the menubar, # <MenuSelect> virtual events are generated. The # following callback tells us which menubar cascade we're # in by querying the event and looking for the active menu # item. The special variable $Tk::event is a localized # reference to the X11 event structure - the same thing # returned by a call to XEvent(). Its W() method reports # the window (actually, widget reference) that the event # occurred in, the menubar in this case. The menu method# entrycget() returns the -label attribute of the active # menu item, which is then printed. The Tk::catch construct # catches errors and throws them away.$menubar-&gt;bind('&lt;&lt;MenuSelect&gt;' =&gt; sub {   my $label = undef;   my $w = $Tk::event-&gt;W;   Tk::catch {$label = $w-&gt;entrycget('active', -label)};   print "$label!\n" if defined $label;});if ($^O eq 'MSWin32') {   # For Win32, add some special System menu items.    # The System menu is similar to Unix window manager    # controls, and is activated by clicking the icon at    # the upper left corner of the window.   my $syst = $menubar-&gt;cascade(-label =&gt; '~System',           -tearoff =&gt; 0);   $syst-&gt;separator;   $syst-&gt;command(-label =&gt; "System Menu Item 1",           -command =&gt; sub {$mw-&gt;bell});   $syst-&gt;command(-label =&gt; "System Menu Item 2",           -command =&gt; sub {$mw-&gt;bell});}MainLoop;</pre><h3>Menu Miscellany</h3><p>Menu (and menubutton) widgets accept a <tt>-menuitems</tt> parameter, a list of liststhat defines all the menu items comprising a menu. Each inner list describes a single menuitem, like this <tt>Exit</tt> command item:  <pre>my $mi = [ ['command' =&gt; 'E~xit', -command =&gt; \&amp;exit] ];my $menu = $mw-&gt;Menu(-menuitems =&gt; $mi);</pre><p align="center"><img SRC="images/tk-5.gif" WIDTH="131" HEIGHT="113" ALT="tk-5"><p align="center"><b>Figure 5</b><p>Program <tt>menuitems2</tt> uses a data structure like this to create <ahref="images/tk-3.gif">Figure 3</a>. Menus can bebroken into multiple columns. If a menu item's <tt>-columnbreak</tt> attribute is true, itbegins a new column (columns read left to right). Typically, multicolumn menus also set <tt>-hidemargin</tt>to true. <br><a href="images/tk-5.gif">Figure 5</a> was createdby this code (program <tt>colbreak</tt>):  <pre>my $mw = MainWindow-&gt;new;my $move = $mw-&gt;Menubutton(qw/-text Move/)-&gt;grid;$move-&gt;configure(-menu =&gt; $move-&gt;Menu(-tearoff =&gt; 0));my(@hm) = qw/-hidemargin 1/;my(@cb) = qw/-columnbreak 1/;$move-&gt;command(@hm,-label =&gt; " ", -state =&gt; 'disabled');$move-&gt;command(@hm, -label =&gt; "&lt;",                -command =&gt; sub {print "left\n"});$move-&gt;command(@hm, -label =&gt; " ", -state   =&gt; 'disabled');		 $move-&gt;command(@hm, @cb, -label =&gt; "^",                -command =&gt; sub {print "up\n"});$move-&gt;command(@hm, -label =&gt; " ", -state   =&gt; 'disabled');$move-&gt;command(@hm, -label =&gt; "v",                -command =&gt; sub {print "down\n"});$move-&gt;command(@hm, @cb, -label =&gt; "", -state =&gt; 'disabled');$move-&gt;command(@hm, -label =&gt; ">",                -command =&gt; sub {print "right\n"});$move-&gt;command(@hm,-label =&gt; " ", -state   =&gt; 'disabled');</pre><h3>Pie Menus</h3><p>I saw my first pie menu in <i>Scientific American</i> (July 1997). The circular menuhad numerous menu items arranged radially about its center point. The caption claimed thatusers could use pie menus in 30% less time that regular, linear menus, and with half theerror rate. This is explained by Fitts' law, a model of human psychomotor behaviour,developed in 1954. <p align="center"><img SRC="images/tk-6.gif" WIDTH="250" HEIGHT="107" ALIGN="center"ALT="tk-6"><p align="center"><b>Figure 6</b><p>Fitts' law describes the time required to hit a target based on target distance andsize. Unsurprisingly, for a person with a mouse, selecting a large menu item close at handis faster than hunting for a small target far away. The linear menus we have seen thus farare one dimensional -- the cursor is always positioned at the top of the menu, making theuser move the cursor down. Thus it takes longer to select a menu item at the end of themenu than at the beginning. In contrast, pie menus are two dimensional -- the cursor isinitially positioned in the center of the pie, so all the wedge shaped menu items are thesame distance from the cursor but in different directions. All menu items are equallyaccessible. Furthermore, each pie piece has a virtual section that extends from the pie'sperimeter to the edge of the display. To hit such a large target requires but agross, gestural motor movement, which your muscles easily learn and remember. If you'dlike to experiment with Fitts' law, run the demonstration program <tt>fittslaw</tt> fromthe TPJ web site. <p align="center"><img SRC="images/tk-7.gif" WIDTH="252" HEIGHT="177" ALT="tk-7"><p align="center"><b>Figure 7</b><p>As luck would have it, a message appeared on the Perl/Tk mailing list fromRussell Nelson asking how to integrate some pie menu code into Perl/Tk. With hispermission, I've taken that code and begun the conversion. (We'll see the fruits of thisongoing work in a later column.) The code was written over seven years ago by Don Hopkins,who has been developing pie menus ever since. <p><a href="images/tk-6.gif">Figure 6</a> shows anexample of Don's early work. The <tt>Demo</tt> pie menu has four items, each occupying a90 degree slice of the pie. To select an item we just need to click anywhere on thepiece's sector of the screen. Notice that this pie menu is rectangular and has abackground. <p><a href="images/tk-7.gif">Figure 7</a> shows the"Clock" pie menu, which is circular and has no background. In fact, theappearance of pie menus can vary greatly. For more about pie menus, visit Don's pie pageat <a href="http://catalog.com/hopkins/piemenus/index.html" target="resource window">http://catalog.com/hopkins/piemenus/index.html</a>.<p>A pie menu is ideally suited for selecting two pieces of information simultaneously.Consider a word processor where we want to select a font and its size -- each font can bea pie piece, and its size is determined by how far from the center of the pie we click. Orconsider a color wheel where the hues are the slices and the saturation varies from thepie's center to its circumference. <p>Maybe someday we'll have three-dimensional sphere menus with conical menu items. All weneed is the right input device...  <p>Until next time,  <tt>use Tk;</tt> <!-- end of file -->
