<html><head><META name=vscategory content="Perl"><META name=vsisbn content=""><META name=vstitle content="Manipulating Images with Perl and the Gimp"><META name=vsauthor content="Aaron Sherman"><META name=searchdescription content="As an introduction to the Gimp and its Perl interface, I will go over what you might want to do with the Gimp. If you are familiar with the Gimp, you might want to skip this section. Then I'll discuss where you can get the tools you need, and finally I'll walk you through a simple Gimp/Perl script that generates the logo for my current company (nothing like a shameless plug). This is a very simplistic example, but it has the advantage of being small enough to analyze in depth."><META name=vsimprint  content="The Perl Journal"><META name=vspublisher content="Earthweb"><META name=vspubdate content="Summer 1999"><title>Manipulating Images with Perl and the Gimp - The Perl Journal, Summer 1999</title><body bgcolor="ffffff"><!-- end head --><font face="verdana" size="1">Issue 14, Summer 1999</font><h2 ALIGN="center">Manipulating Images with Perl and the Gimp </h2><h4>Aaron Sherman</h4><div align="center"><a href="images/gimp-perl.gif"><imgSRC="images/gimp-perl_small.gif" ALIGN="center" ALT="gimp-perl" border="0" width="100"height="88"></a><br><font size="-1"><b>Figure 1 </b></font></div><p>Once, early in my career, I needed a high resolution version of my company's logo. Anyhand drawing of this logo would have been ugly, so I decided to write a small program inTcl/Tk which drew the image and generated Postscript. This had the advantage of producingan infinitely scalable, mathematically perfect version of the company logo (which happenedto be quite regular).  <p>Well, times have changed, but I'm still doing company logos for projects that I'mworking on. Now I have a new tool in my belt: the Gimp (<a href="http://www.gimp.org"target="resource window">www.gimp.org</a>). The Gimp is a powerful, Photoshop-like imagemanipulation program with a plug-in interface. Unlike Photoshop, this plug-in interface isself-documenting and extensible. Also, the Gimp allows programmers complete control fromtheir favorite language. Mine is Perl, of course, but APIs also exist for Scheme, C, andC++.  <p>As an introduction to the Gimp and its Perl interface, I will go over what <i>you</i>might want to do with the Gimp. If you are familiar with the Gimp, you might want toskip this section. Then I'll discuss where you can get the tools you need, and finallyI'll walk you through a simple Gimp/Perl script that generates the logo for my currentcompany (nothing like a shameless plug). This is a very simplistic example, but it has theadvantage of being small enough to analyze in depth. <h3>Using the Gimp, And What About This Perl Thing?</h3><p>The Gimp (which is an acronym for GNU Image Manipulation Program)was written by Spencer Kimball and Peter Mattis, two graduate students at UC Berkeley.They released the source code for an early version, and since then development has been awhirlwind of effort by hundreds of people writing everything from simple plug-ins tolanguage interfaces to documentation. The graphics toolkit (Gtk+) that was written tohandle the Gimp's display (buttons, scroll-bars, and so on) has even become thecornerstone of many other efforts, including GNOME (a desktop userinterface system).  <p>So what does it do? The simple explanation is that the Gimp can be thought of as apaint program with several key features:  <p><font size="+1">&#149;</font> <b>Layers. </b><i>Layers</i> allow you to work on different parts of the image asthough they were on separate sheets of transparent plastic. Anyone who has ever cut up anewspaper and pasted portions onto a single sheet of paper for photocopying is familiarwith the process: You pull elements from different sources together and combine them. <p><font size="+1">&#149;</font> <b>Channels.</b> Your image is made up of pixels, and each pixel has several <i>channels</i>.For example, in a typical color image there is one red channel, one green channel, and oneblue channel. In the Gimp, you can manipulate each of these channels separately. You canalso add other channels, which might be useful for storing information which relates tothe image, but is not visual (for instance, a selection shape) Such user-defined layers donot appear in the composite image, but can be saved in certain file formats. You can alsobreak down an image into the alternate cyan, magenta, yellow, and black colorspace forpesky physical processes like printing. <p><font size="+1">&#149;</font> <b>Alpha Channels</b>. In order for layers to have transparent or translucent parts,there needs to be a separate chunk of data associated with each pixel of a layer thatdescribes how opaque or transparent it is. This is called the <i>alpha channel</i>, and isstored along with the other channels used for holding color information.<p><font size="+1">&#149;</font> <b>Animation</b>. Using Gimp's layers as as series of frames, you can edit animationsuch as animated GIFs. <p><font size="+1">&#149;</font> <b>Scripting</b>. Many programming languages can be used to write extensions for theGimp including new image effects and filters and scripts that use the Gimp to generate animage of their own (as our example will do).  <p>The Gimp builds on and combines each of these concepts, creating a wealth of toolswhich can be used to do just about anything to an image, including analysis of an image inalternate colorspaces (for printing); photographic touch-up features including burning anddodging (techniques used in photo developing); and many other advanced features.  <p>For an excellent reference to the Gimp, I direct you to <ahref="http://www.gimp.org/docs.html" target="resource window">http://www.gimp.org/docs.html</a>, which has a good list of tutorials and manuals. There is also a book, The Artists' Guideto the Gimp, which has a Web page at <a href="http://www.thegimp.com/"target="resource window">http://www.thegimp.com/</a> .  <p><div align="center"><a href="images/gimp-menus.gif"><imgSRC="images/gimp-menus_small.gif" ALIGN="center" ALT="gimp-menus" border="0" width="100"height="150"></a><br><font size="-1"><b>Figure 2</b></font></div><p>The Perl interface to the Gimp is built on top of the standard Gimp C API. It allows you to create new functions and menu entries called <i>plug-ins</i>that are indistinguishable from the standard Gimp menus and functions. When you write aplug-in, you are writing a stand alone program using Gimp libraries. The Gimp executesthis program once during start-up to register the plug-in name and to add its menu entry.When that menu entry is selected (or the function is called from another plug-in) theGimp runs the plug-in again.  <p>For example, if you select the "Xtns" (extensions) menu from thetoolbox window and then select the "Render" sub-menu, you will see an"SNS Logo" entry if <i>and only if</i> you have installedthe example code from below in your <tt>.gimp/plug-ins</tt>directory. It will appear as shown in <a href="images/gimp-menus.gif">Figure 2</a>.<p><div align="center"><img SRC="images/gimp-cool-metal.gif" WIDTH=261 HEIGHT=101 ALIGN="center"ALT="gimp-cool-metal" border=0><br><font size="-1"><b>Figure 3</b></font></div><p>When the user runs a plug-in, they are presented with a dialog box whichlists each of the plug-in's parameters. Fortunately, you don't have to write the code thatdisplays the dialog box; that's all been taken care of for you. You just have to specifythe parameter types so that the Gimp knows what sorts of things to ask the user for. Todemonstrate plug-ins, you can run the many Script-Fu Logo plug-ins (under"Xtns/Script-Fu/Logos") which all take a text string and render it using aneffect (e.g. chrome, neon, or alien glow.) A demonstration of the "Cool Metal"plug-in is shown in <ahref="images/gimp-cool-metal.gif">Figure 3.</a> Perlopens up many areas to Gimp developers unavailable in other languages. For example, one ofthe recently contributed Perl plug-ins, <tt>image-tile</tt>, can render an image by tilingseveral thousand other images as the parts of the overall picture. This technique is somemory-intensive that the information stored about each image needs to be stored in aBerkeley DB database, which Perl knows how to map to a hash, transparently. This kind ofconvenience makes writing large, complex plug-ins for the Gimp quite simple, and puts thefocus of the programmer back on the effect. <h3>Getting the Tools</h3><p>Right now the Gimp only works under Unix. There are porting efforts to other platforms;one X-on-Win32 version does exist, but it doesn't support Perl yet.  <p>The following table lists what versions of what things you need for each version of theGimp. Check the Web sites listed below for current versions, which might be later thanthese.  <p><div align="center"><table cellspacing="4" cellpadding="4" table border="1">  <tr>    <td><tt><b>Package Edge: </b></tt></td>    <td><tt><b>Stable:</b></tt></td>    <td><tt><b>Development:</b></tt></td>    <td><tt><b>Bleeding </b></tt></td>  </tr>  <tr>    <td><tt>Gimp</tt></td>    <td><tt>1.0.4 </tt></td>    <td><tt>1.1.4 </tt></td>    <td><tt>cvs module (gimp)</tt></td>  </tr>  <tr>    <td><tt>Glib (c library) </tt></td>    <td><tt>1.2.1</tt></td>    <td><tt>1.2.1(*)</tt></td>    <td><tt>cvs module (glib)</tt></td>  </tr>  <tr>    <td><tt>Gtk+ (c library)</tt></td>    <td><tt>1.2.1</tt></td>    <td><tt>1.2.1(*)</tt></td>    <td><tt>cvs module (gtk+)</tt></td>  </tr>  <tr>    <td><tt>Gtk (perl module)</tt></td>    <td><tt>0.5120</tt></td>    <td><tt>0.5120</tt></td>    <td><tt>cvs module (gnome-perl)</tt></td>  </tr>  <tr>    <td><tt>Gimp (perl module)</tt></td>    <td><tt>1.072</tt></td>    <td><tt>N/A(**)</tt></td>    <td><tt>N/A(**)</tt></td>  </tr>  <tr>    <td><tt>PDL (optional)</tt></td>    <td><tt>2.0 </tt></td>    <td><tt>2.0</tt></td>    <td><tt>2.0</tt></td>  </tr>  <tr>    <td><tt>Mesa (optional)</tt></td>    <td><tt>3.0</tt></td>    <td><tt>3.0</tt></td>    <td><tt>3.0</tt></td>  </tr>  <tr>    <td><tt>perl (interpreter)</tt></td>    <td><tt>5.005</tt></td>    <td><tt>5.005</tt></td>    <td><tt>5.005</tt></td>  </tr>  <tr>    <td colspan="4">	<sup>* </sup>Glib and Gtk+ are currently undergoing re-structuring for the upcoming	1.3.x development series. For now, use the stable 1.2.x series, or get the source from	cvs, as described below.	</td>  </tr>  <tr>    <td colspan="4">	<sup>**</sup>You don't need a separate Gimp Perl module with 1.1.x Gimp or	later, as it is now part of the standard distribution.     </td>  </tr></table></div><p>For the stable series, you should be able to get a pre-compiled version of Gimp from <pre><a href="http://www.gimp.org/download.html" target="resource window">http://www.gimp.org/download.html</a></pre><p>and Gtk+/Glib from  <pre><a href="http://www.gtk.org/download.html"target="resource window">http://www.gtk.org/download.html</a>.</pre> The development seriesis available from the same places, but usually only in source code form.  <p>The Gimp and PDL Perl modules can be downloaded from:  <pre><a href="http://www.perl.com/CPAN/modules/by-module" target="resource window">http://www.perl.com/CPAN/modules/by-module</a></pre><p>For access to the source, I highly recommend the article (by Zach Beane, the maintainerof the Gimp News site) at:  <pre><a href="http://www.xach.com/gimp/tutorials/cvsgimp.html" target="resource window">http://www.xach.com/gimp/tutorials/cvsgimp.html</a></pre><p>This describes how you can get the Gimp straight from the source code repository. Itwill be more unstable (this is where new bugs first appear), but can be worth the extraeffort in terms of getting access to the latest features. When reading the above article,add <tt>gnome-perl</tt> to the list of modules to download and install, by including thestep: <pre>cd $PREFIXcvs -z3 get gnome-perlcd gnome-perlperl Makefile.PL PREFIX=$PREFIXmakemake install</pre><p>Do this after the steps described for downloading the source, compiling Glib andcompiling gtk+, but before compiling Gimp.  <p>The 5.004 Perl series may work for Gimp, but there are some features which will not besupported. For example, the "Last Vals" button will not work withoutData::Dumper, which is bundled with 5.005. <p>For all versions, the Gimp module really wants to have both the Perl Data Language (thePDL module; see <a href="http://pdl.perl.org" target="resource window">http://pdl.perl.org</a>), which in turn likes to haveMesa (a 3D/OpenGL library) around. Mesa is supposedly optional for PDL,but I've had problems compiling without it, and it's a very nice library to have around,especially in combination with the <tt>xscreensaver</tt> program, which can take advantageof it. PDL is quite large by itself, and worthy of a separatearticle [<i>TPJ #5. -Jon</i>]), but the Gimp uses it to allowefficient manipulation of image data (which would be very slow in Perl if you had to do itpixel-by-pixel). Most of the time, you'll find that you don't need PDL,because many high-level functions already exist to generate the effects that you want. Youcan find Mesa at:  <pre><a href="http://www.mesa3d.org/" target="resource window">http://www.mesa3d.org/</a></pre><p>The order of installation should be:  <pre>PerlMesa (optional)PDL (optional)GlibGtk+ (C library)Gtk (Perl module)Gimp (program)Gimp (Perl module)</pre><h3>Using the Gimp Module</h3><p>A Gimp/Perl plug-in, as mentioned above, is a Perl program. It is called by theGimp and uses the Gimp API to perform some action. Some plug-insaffect the current image, like the blur filter; others let you type a string and thenrender it with a special effect, like Cool Metal's chrome. The example in this article islike a logo plug-in, but generates a shape instead of text.  <p>Plug-ins for the Gimp go into your <tt>$HOME/.gimp/plug-ins</tt> directory. (If you areusing Gimp version 1.1, you will need to put things under <tt>$HOME/.gimp-1.1/plug-ins</tt>.)They need to be made executable: <tt>chmod a+x</tt> from your Unix prompt. I recommendthat you edit them elsewhere and copy them in, as things like backup copies and auto-savefiles can badly confuse the Gimp.  <p>Before getting into the example, let's discuss a few basic concepts. Your plug-in iseither being provided with an image, or (as in this example) you'll be creating one. Thisimage is represented by a Perl scalar variable, and most plug-ins call it <tt>$img</tt> or<tt>$image</tt>. When you want to modify an image, you will need a drawable. A <i>drawable</i>is an abstract term that can refer to a layer or any other part of an image that you candraw into. Your plug-in doesn't have to worry about this, it just needs to use thedrawable that it was given. Or, if it's creating its own image, the layer that you create.To make this even more convenient, every Gimp/Perl plug-in that operates on an existingimage takes the image and drawable as its first two parameters.  <p>There are a few other types to know about when writing plug-ins, but the only one thatwe will work with here is a <i>color</i>. Colors are manipulated by reference in athree-element array (red, green, and blue), but most often, you simply tell Gimp/Perl thatyour plug-in needs the user to select a color, and it will be passed to your plug-in.Other types such as layers and channels are similar to the image type. They are opaquedata-structures, which you manipulate by reference. (Actually, they're objects, but unlessyou want to use the object-oriented interface you don't have to worry about that.) Now let's see the Gimp in action. This example in <ahref="tpj0402-0018.html">Listing 1</a> creates a new image,and draws the logo for my company in it. The current foreground and background colors areused, as well as the currently selected paintbrush (check out the Brushes menu optionunder Dialogs, which is under File from the toolbox window for the available brushstyles).  <p>Let's look at what each step of this plug-in does.You need to include and initialize the Gimp modules:<pre>use Gimp qw(:auto);use Gimp::Fu;</pre><p>These are the two basic libraries. (The <tt>:auto</tt> forces inclusion of the entire Gimp Procedural Database as auto-loaded functions.) Don't confuse the <tt>Gimp::Fu</tt> module, which implements things like the registration interface, with Script-Fu. Script-Fu is the Scheme scripting interface for the Gimp. (Scheme is a programming language derived from LISP.) <tt>Gimp::Fu</tt> and Script-Fu have nothing to do with each other.<pre># use Gimp::Util;</pre><p>Gimp::Util is not strictly necessary, but if you include it, you can use a few extra goodies that it provides. For example, this module provides functions for adding text to an image (usually a multiple-step process) or finding a layer's position in an image. You can use <tt>perldoc Gimp::Util</tt> for more information. This script does not use these functions, so the line has been commented out.  <p>Most of your plug-in will be a subroutine, whose name can be whatever you like. Since you can register the function under a different name with the Gimp, you <i>can</i> choose any name here. However, be careful to avoid any name which is currently in use in the Gimp's Procedural Database (PDB). Use the DB Browser under the Xtns menu to make sure that your function name is not already in use. If you choose the same name as a PDB function, you will hide the Gimp version of the function from your program.<pre>sub perl_fu_safety_logo {</pre><p>In this function, you need to receive any arguments that were passed to you, and (as you'll see below) you can tell the Gimp what types of parameters you expect. If your plug-in is for working on an existing image, the first two parameters will always be an image and a drawable. In this case, we are creating our own image, so we expect only the plug-in specific parameters: <pre>sub perl_fu_safety_logo {   my $width  = shift;   my $height = shift;</pre><p>Now, this is where we need to actually start talking to the Gimp. You do thisthrough calls to the PDB. The Perl interface for doing this looksjust like normal function calls. Use the DB Browser, as mentioned above, to search the PDB for the function you're looking for. This browser allows you to lookat all of the Gimp functions and plug-ins, their arguments and return values, anddocumentation for each one. In the following examples I won't touch on <i>all</i> of theparameters for every function; you can use the PDB browser to lookup anything from the example source code that I skip. <p>The first thing we want to do is create our new image with the given width and height:<pre>my $img = gimp_image_new($width, $height, RGB);</pre><p>That's it! You've now got a new image (of type <tt>RGB</tt> -- full color). Ofcourse, it has nothing in it. That's not quite the same as being blank, which would meanthat it has a background and nothing else. This image really has <i>nothing</i> in it. Inorder to have actual image content in the Gimp, we must add a layer:  <pre>my $layer = gimp_layer_new($img, $width, $height,             RGB_IMAGE, "Safety Logo", 100, NORMAL_MODE);gimp_image_add_layer($img, $layer, 0);</pre><p>Notice that the type for this layer is <tt>RGB_IMAGE</tt>, and not <tt>RGB</tt> aswe used for our image. Also, an <i>opacity</i> must be specified, which tells us howopaque or transparent this layer is (here, we give 100%). <tt>NORMAL_MODE</tt> refers tothe layer combination mode, which is an advanced feature that can be used for somestunning effects. <p>The third parameter to <tt>gimp_image_add_layer()</tt> specifies which layer thisshould be in the image's list of layers. The first layer, layer 0, is the closest to theobserver. Each successive layer is farther away from the viewer, and may thus be obscuredby layers above it. Here, we'll use only the one layer, to keep things simple.  <p>Now you have to clear out your new layer, because at first it might have random garbagein it. You can do this by using <tt>gimp_bucket_fill()</tt> to put a background color init, or by using <tt>gimp_edit_clear()</tt>. <tt>gimp_edit_clear()</tt> will have differentbehavior, depending on whether the layer can have transparent areas (an alpha channel).Here we simply paint our background using <tt>gimp_bucket_fill()</tt> which could also beused to paint a pattern, if we wished. Note that <tt>gimp_drawable_fill()</tt> is a newfunction which should be a little faster and easier, but may not exist in your version ofGimp yet.  <pre>my $oldcolor = gimp_palette_get_foreground();gimp_palette_set_foreground(gimp_palette_get_background());gimp_selection_all($img);gimp_bucket_fill($layer, FG_BUCKET_FILL, NORMAL_MODE,            100,0,0,0,0);gimp_palette_get_foreground() and            gimp_palette_set_foreground() </pre><p>both work on the user-selected foreground and background colors. This is why we savethe value: so that it can be restored later. We could have used the <tt>BG_BUCKET_FILL</tt>parameter, and then none of this would be necessary, but doing it this way lets usdemonstrate more features.  <tt>gimp_selection_all()</tt> selects the entire image,and <tt>gimp_bucket_fill()</tt> fills up the entire selection with the current foregroundcolor. As before, the <tt>NORMAL_MODE</tt> and <tt>100</tt> arguments are layer mode(paint mode, in this case) and opacity. The last four arguments only matter if there is noselection, and that is not the case, here. So, we've filled the entire layer with thebackground color, which is a good starting place.  <p>One important thing to note: The second parameter to <tt>gimp_bucket_fill()</tt> mustbe a drawable. In this case we pass a layer, which is one kind of drawable. There areother drawables, and you will find them as you work with the Gimp. However, keep in mindthat if you write a plug-in which works on an existing image (see the <tt>register()</tt>function, below) you will be given a drawable, which you can use for calls like <tt>gimp_bucket_fill()</tt>,but it may not actually be a layer. You should never assume that it is, which is whatyou're doing if you pass it to a a function like <tt>gimp_layer_resize()</tt>. <pre>gimp_palette_set_foreground($oldcolor);gimp_selection_none($img);gimp_paintbrush($layer, 0, [$width/2, $height/18,           $width/2, $height-$height/18]);gimp_paintbrush($layer, 0, [$width/18, $height/2,           $width-$width/18, $height/2]);</pre><p>Here, we reset the user's foreground color, unset the selection and draw our firsttwo lines. It is possible to select a brush shape for the <tt>gimp_paintbrush()</tt>function, but we leave this up to the user. Note that the third parameter to <tt>gimp_paintbrush()</tt>is an anonymous array (the list inside brackets); more on this later.  <pre>my $magic = ($width/18*7) / sqrt(2);gimp_paintbrush($layer, 0,           [$width/2-$magic, $height/2-$magic,           $width/2+$magic, $height/2+$magic] );gimp_paintbrush($layer, 0,           [$width/2-$magic, $height/2+$magic,           $width/2+$magic, $height/2-$magic] );</pre><p>Here, we draw the next lines, diagonally, using a little bit of geometry to figureout where the endpoints of the vertical or horizontal lines would be if we rotated them by45 degrees.  <pre>for (my $i = 0; $i &lt; 4; $i++) {   gimp_ellipse_select($img, $width/18*(2+$i),             $height/18*(5+$i), $width/18*(14-$i*2),             $height/18*(8-$i*2), SELECTION_REPLACE,             1, 0, 0);   gimp_edit_stroke($layer);   gimp_ellipse_select($img, $width/18*(5+$i),             $height/18*(2+$i), $width/18*(8-$i*2),             $height/18*(14-$i*2), SELECTION_REPLACE,             1, 0, 0);    gimp_edit_stroke($layer); }</pre><p>The <tt>gimp_ellipse_select()</tt> function selects an elliptical region defined by the given x, y, width and height. The <tt>SELECTION_REPLACE</tt> parameter tells it to replace any existing selection, and the next parameter tells it to use anti-aliasing for smoothing the "stair-stepping" on the edges. <tt>gimp_edit_stroke()</tt> is like <tt>gimp_paintbrush()</tt>, but traces the current selection. So the two functions together draw an ellipse. <pre>gimp_selection_none($img);gimp_displays_flush();return $img;</pre><p>These are final steps that should be used to leave the user in a sane state. We unset the selection, flush any pending display draws, and return the image that we created. The Gimp module will display it for us. <p>Now, comes the most important part: registration. In order for the Gimp to use ourplug-in, it must know what it is called and how to execute it. Here is the registrationstatement:  <pre>register("safety_logo", "Render a          stand alone Safety Net Logo image",         ("Renders the Safety Net Solutions          company logo in the "."currently          selected brush and fg/bg colors."),         "Aaron Sherman &lt;ajs\@ajs.com&gt;",          "(c) 1999, Aaron Sherman",         "1999-03-20", "&lt;Toolbox&gt;         /Xtns/Render/Safety Logo", "*",         [         [PF_INT32, "Width", "Width", 256],         [PF_INT32, "Height", "Height", 256]         ],         \&amp;perl_fu_safety_logo);</pre><p><div align="center"><img SRC="images/gimp-dialog1.gif" WIDTH=283 HEIGHT=237 ALIGN="center" ALT="gimp-dialog1" border=0><br><font size="-1"><b>Figure 4</b></font></div>	<p>The full documentation can be found in Gimp::Fu, but the basic idea is that  the first seven parameters are just strings that set the name of the plug-in, the  description, help text, author's name, copyright message, date of last modification, and  which menu the plug-in appears in. The menu path is the only interesting parameter. If it  begins with <tt>&lt;Image&gt;</tt>, then it will be placed in the menu that comes up when  the user right-clicks in an image. If it begins with <tt>&lt;Toolbox&gt;/Xtns</tt>, then  it will show up under the <tt>Xtns</tt> menu in the main Gimp window. You can also use the  menu <tt>&lt;None&gt;</tt> to tell the Gimp not to display your plug-in as a menu option.  You might do this if you were writing a function meant to be used only by other plug-ins.   <p>The eighth parameter describes the image types that this plug-in can work on. In our  case, <tt>*</tt> makes sense because there is no input image, only an output.    <p>The next parameter specifies the list of parameters to the plug-in. It is a list of  lists, using anonymous arrays. Each of the inner anonymous arrays contains the description  of a single expected parameter. The description is made up of at least four values: the  type, name, description, and default value. As an example, let's say you added the  following item to the end of the list of plug-in parameters:     <pre>  [PF_COLOR, "Brush stroke color", "Color", [0,0,0]]</pre>    <p><div align="center">  <a href="images/gimp-dialog2.gif"><img  SRC="images/gimp-dialog2_small.gif" ALIGN="center" ALT="gimp-dialog2" border="0"  width="100" height="68"></a><br>  <font size="-1"><b>Figure 5</b></font></div>    <p>The Gimp module then displays a dialog box like the one in <a  href="images/gimp-dialog1.gif">Figure 4</a>. Notice  the black button -- <tt>[0, 0, 0]</tt> is black in RGB notation. If  the user clicks on the button they get a nice color-selection dialog for choosing a new  brush color <a href="images/gimp-dialog2.gif">Figure 5</a>.  The parameter types are all defined in the PARAMETER     TYPES section of the Gimp::Fu documentation. The only remaining argument to <tt>register()</tt>  is a reference to your new function.    <p><div align="center">  <a href="images/gimp-logo1.gif"><img  SRC="images/gimp-logo1_small.gif" ALIGN="center" ALT="gimp-logo1" border="0" width="100"  height="89"></a><br> <font size="-1"><b>Figure 6</b></font>  </div>  <p>Plug-ins in the <tt>&lt;Image&gt;</tt> menu will be available under the  pop-up menu that appears when you click the right mouse button in an image. They will  automatically get the image and drawable to work on as their first two parameters, so  don't list these parameters yourself. Plug-ins such as ours that live in the <tt>&lt;Toolbox&gt;</tt>  menu aren't associated with any particular image, although you can declare one or more  image parameters that allow the user to select from any currently open image. The last  parameter to <tt>register()</tt> is a reference to the function that actually implements  the plug-in.    <p>The last thing that your plug-in should do is <tt>exit</tt> with the status returned  from the main function, like so:   <pre>exit main;</pre><p>This closes the loop with the <tt>Perl::Fu</tt> interface, allowing it to take over.  The Gimp can then tell it which of several ways it is being asked to behave. You don't  have to worry about any of this; just call <tt>main</tt>. And be sure not to define a  subroutine in your plug-in called <tt>main</tt>, or you'll be sorry. Here's the finished  product:   <h3>Moving On</h3>  <p>Some notes to help you in your budding career as a plug-in author:   <p><font size="+1">&#149;</font> There is a mailing list for discussion about Gimp-Perl. To subscribe, send mail with  the single line:     <blockquote>  <tt>subscribe</tt> <p>  to <a href="mailto:gimp-perl-request@lists.netcentral.net">  gimp-perl-request@lists.netcentral.net</a>.  </blockquote>    <p><font size="+1">&#149;</font> You can be notified of new versions. Send mail with the single line:     <blockquote>   <tt>subscribe notify-gimp</tt> <p>  to <a href="mailto:majordomo@plan9.de">majordomo@plan9.de</a>.   </blockquote>  <p><font size="+1">&#149;</font> Please upload anything you think would be useful to others to the Gimp Plug-In  Registry: <a href="http://registry.gimp.org/" target="resource window">http://registry.gimp.org/</a>.  <p><font size="+1">&#149;</font> In the example above, <tt>gimp_paintbrush()</tt> demonstrated a very useful feature  of the Perl Gimp module. If you look in the PDB documentation for <tt>gimp_paintbrush()</tt>,  you will see that the third parameter is a number of stroke coordinates, and the fourth  parameter is the array of stroke coordinates. In Perl, we only have to give an array  reference, and the module will calculate its length for us. So wherever you see a function  that needs a count followed by an array, just pass the array.   <p><font size="+1">&#149;</font> Fonts are the most evil thing ever, because (like X) the Gimp failed to abstract them  sufficiently. As a result, you have to force the user to select a font and size, even  though the font selection box already includes a size parameter. This is because some font  names (such as scalable fonts from a TrueType font server) don't include size information,  and the Gimp only tracks fonts by their full XFont name. I've started using the convention  that if the user enters a size of &lt; 1, I use the font-provided size, but that's a  kludge around a broken feature.    <p><font size="+1">&#149;</font> You will really want to study other sources of Gimp user info (see www.gimp.org) and  find out more about the following topics: feathering, alpha layers, and channels.  <p><font size="+1">&#149;</font> For the menu path, don't put your plug-ins under Script-Fu, and don't invent new  menus if you can help it. Put them in with the other plug-ins that are written in C (e.g <tt>&lt;Image&gt;/Filters/section/plug-in</tt>  or <tt><Toolbox>/Xtns /section/plug-in</tt>).   <p><font size="+1">&#149;</font> Read the Gimp-Perl documentation. You can use your plug-in stand lone, or talk across  the network to a Gimp process. You can even debug plug-ins using the Perl debugger, which  is almost impossible with some of the other plug-in interfaces.   <p><font size="+1">&#149;</font> Gimp 1.0 and 1.1 differ in that some functions no longer take an image as their first  parameter. Gimp-Perl gets around this by allowing you to leave out the image parameter in  the older Gimps, but you may have to patch your 1.0 scripts to make them work with 1.1, or  eventually 1.2.    <p><font size="+1">&#149;</font> If you write two or more related plug-ins, they can go in the same file. You just  need to have one <tt>register()</tt> statement per plug-in.    <p><font size="+1">&#149;</font> If you want to know what's going on inside your plug-in, try using <tt>Gimp::set_trace(TRACE_ALL)</tt>.  This spews a <i>lot</i> of information, but lets you see everything that's going on.     <p><font size="+1">&#149;</font> When you look at the PDB documentation, you'll see that all of  the functions have dashes in their names. So that you can call these as Perl functions,  the Gimp module converts all PDB names to use underscores instead of  dashes. It will also do the reverse to your plug-in's name (as declared in the <tt>register()</tt>  statement) so that other Gimp plug-ins can use the standard Gimp naming conventions. This  means that you should name your plug-ins with underscores, not dashes (e.g. <tt>my_plug_in</tt>,  not <tt>my-plug-in</tt>). &nbsp; Good luck, and happy Gimping!   <p>__END__   <hr>  <p><i>Aaron Sherman</i> <a href="mailto:(ajs@ajs.com">(ajs@ajs.com)</a> <i>has been  programming in Perl since version 3, and using the Gimp since the 0.99's. He is the author  of the image-tile plug-in and the File::Copy module that comes with Perl</i> <!-- end of file -->
