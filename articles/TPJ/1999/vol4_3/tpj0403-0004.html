<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <title>Client-Server Applications - The Perl Journal, Fall 1999</title>
  <meta name="generator" content=
  "HTML Tidy for Linux/x86 (vers 12 April 2005), see www.w3.org">
  <meta name="vscategory" content="Perl">
  <meta name="vsisbn" content="">
  <meta name="vstitle" content="Client-Server Applications">
  <meta name="vsauthor" content="Lincoln D. Stein">
  <meta name="searchdescription" content=
  "There are times when the Web paradigm breaks down, and you need an application that has the immediacy and interactivity of an old-style client/server application, where custom software on both sides of the connection exchange data using protocols designed specifically for the purpose at hand. It's not generally appreciated how easy it is to write client/server applications in Perl. In this column, I'll show you how to do it.">
  <meta name="vsimprint" content="The Perl Journal">
  <meta name="vspublisher" content="Earthweb">
  <meta name="vspubdate" content="Fall 1999">
  <!-- always update the article title and issue -->

</head>

<body bgcolor="#FFFFFF">
  <font face="verdana" size="1">Issue 15, Fall 1999</font>

  <h2 align="center">Client-Server Applications</h2>

  <h4><i>Lincoln D. Stein</i></h4>
  <!-- packages described, if necessary -->

  <div align="center">
    <table border="1" cellspacing="0" cellpadding="5">
      <tr>
        <td align="center" bgcolor="#CCCC99"><b>Packages
        Used</b></td>
      </tr>

      <tr>
        <td>
          <p>
          Chatbot::Eliza:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://www.perl.com/CPAN"
          target="resource window">http://www.perl.com/CPAN</a><br>
          IO::Socket,
          IO::Handle:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bundled with
          Perl</p>
        </td>
      </tr>
    </table>
  </div>

  <p>Ah, for the good old days, when real programmers used vi,
  networking software was written in C, and monolithic
  client/server applications ruled the Internet. Nowadays, of
  course, it's easy to slap up a network application in a matter of
  minutes with a little CGI scripting, and if you are using a Web
  authoring tool like Microsoft FrontPage, you can even write a
  serviceable network application without knowing any programming
  whatsoever.</p>

  <p>Still, there are times when the Web paradigm breaks down, and
  you need an application that has the immediacy and interactivity
  of an old-style client/server application, where custom software
  on both sides of the connection exchange data using protocols
  designed specifically for the purpose at hand. It's not generally
  appreciated how easy it is to write client/server applications in
  Perl. In this column, I'll show you how to do it.</p>

  <p>Our running example uses the Chatbot::Eliza module, John
  Nolan's marvelous pure-Perl clone of Joseph Weizenbaum's classic
  psychotherapist simulation and the subject of his <a href=
  "../vol3_1/ewtoc.html" target="resource window">TPJ #9</a>
  article. Chatbot::Eliza works very simply. It accepts a line of
  input from the user, transforms it according to a clever set of
  transformational rules, and echoes it back to the user in the
  form of a question. The effect is a lot like talking to a
  Freudian psychoanalyst, except that the conversation never seems
  to go anywhere. (But do real-life psychoanalysis sessions go
  anywhere either? What does that mean to you?)</p>

  <p>Although Chatbot::Eliza can be customized extensively, most
  people will use its command-line interface, which can be invoked
  in just four lines of code (see <a href=
  "tpj0403-0004a.html">Listing 1</a>). The program begins by
  loading the Chatbot::Eliza module. Line 3, which puts STDOUT into
  autoflush mode, isn't strictly necessary for this example, but
  comes in handy when we turn the script into a server in the next
  section. The script now creates a new Chatbot::Eliza object,
  which is stored in the $bot variable, and invokes the object's
  <tt>command_interface()</tt> method. This method now takes over
  the show, reading user input from STDIN, and writing transformed
  text to STDOUT. When you run the script, the conversation goes
  something like this:</p>
  <pre>
  % <b>eliza.pl</b>
  Eliza:    Is something troubling you?
  you:    <b>Yes, my mother is getting on my nerves.</b>
  Eliza:    What else comes to mind when you think of your mother?
  you:    <b>I think of my father, of course.</b>
  Eliza:    Your father?
  you:    <b>Yes, the husband of my mother.</b>
  Eliza:    Your mother?
  you:    <b>Yes, the wife of my father.</b>
  Eliza:    Your father?
  you:    <b>Yes, the father of my brother.</b>
  Eliza:    Tell me more about your family.
  you:    <b>I have a dog too.</b>
  Eliza:    That's quite interesting.
  you:    <b>quit</b>
  Eliza:    Life is tough. Hang in there! 
</pre>

  <p>Eliza may seem more insightful when you try it.</p>

  <p>What if we wanted to make Chatbot::Eliza available via the
  Internet? You could probably write a CGI wrapper around the
  module and use text entry fields to input lines of text, but this
  wouldn't be entirely straightforward. For one thing, there would
  be the overhead of receiving and rendering the entire HTML page
  for each line of the conversation, and the rendering delay would
  make the conversation feel less spontaneous. For another thing,
  the Chatbot object maintains a certain amount of state. That is,
  it remembers portions of the session, allowing it to return to
  previous topics and restart stalled conversations. However, Web
  sessions are not stateful, and in order to create a CGI interface
  to Chatbot::Eliza, you'd have to maintain a pool of
  Chatbot::Eliza objects in memory or disk, and associate them with
  users so that one user doesn't end up in the middle of an user's
  psychoanalysis session. This can be done, but it's not short or
  elegant.</p>

  <h3>Using the <tt>inetd</tt> Super-Daemon</h3>In contrast, we can
  turn <a href="tpj0403-0004a.html">Listing 1</a> into a server
  without changing a line of code. If you are using a Unix (or
  Linux) system, the inetd super-daemon will do all the dirty work
  for you. Just add the following line to the bottom of the
  <tt>/etc/inetd.conf</tt> configuration file:
  <pre>
  12000 stream tcp nowait lstein /tmp/eliza/eliza.pl eliza.pl
</pre>

  <p>You must have superuser access to edit this file. Replace the
  user name lstein with your own login name, and adjust the path to
  the <tt>eliza.pl</tt> script to reflect its actual location.</p>

  <p>When you're done editing the file, restart the <tt>inetd</tt>
  daemon by sending it a HUP signal. You can do this by finding its
  process ID (PID) using the ps command and then using the kill
  command to send the signal. For example:</p>
  <pre>
% <b>ps aux | grep inetd</b>
  root    657  0.0  0.8  1220  552 ?       S    07:07   0:00 inetd
  lstein  914  0.0  0.5   948  352 pts/1   S    08:07   0:00 grep inetd
% <b>kill -HUP 657</b> 
</pre>

  <p>Two shortcuts which work on many Linux systems are shown
  below:</p>
  <pre>
  % <b>kill -HUP 'cat /var/run/inetd.pid'</b>
  % <b>killall -HUP inetd</b>
</pre>

  <p>Now you can use the vanilla telnet program to talk to Eliza.
  telnet acts as the client, and <tt>eliza.pl</tt> is the
  server:</p>
  <pre>
 % <b>telnet localhost 12000</b>
 Trying 127.0.0.1...
 Connected to localhost.
 Escape character is '^]'.
 Eliza:  Hello, I am a computer program. 
 you:    <b>I am a human being.</b>
 Eliza:  How long have you been a human being?
 you:    <b>About 39 years.</b>
 Eliza:  That is interesting. Please continue.
 you:    <b>It started when I was born...</b>
 Eliza:  Why do you tell me you were born now?
 you:    <b>Because you asked.</b>
 Eliza:  We were discussing you -- not me.
 you:    <b>bye</b>
 Eliza:  Goodbye. It was nice talking to you.
 Connection closed by foreign host. 
</pre>

  <p>If you aren't on a Unix system, or don't have superuser
  access, don't worry. A Chatbot::Eliza server that will work for
  you is coming up soon.</p>

  <p>Now let's look at that inetd.conf line in more detail. It's
  divided into seven fields delimited by whitespace (tabs or
  spaces):</p>

  <p><tt>12000</tt>: This is the port number that the server will
  listen to, and can be any number between 1024 and 65536. Numbers
  between 1-1023 are reserved for use by standard services like
  email and the Web. Port numbers above this range can be used by
  any program, but only one program can use a given port at a time.
  Be sure to check that your system doesn't already use a
  particular port for some service before adding a new server (you
  can use the netstat program for this purpose). 12000 is usually a
  pretty safe bet. This number can be replaced by a symbolic name
  taken from the file <tt>/etc/services</tt>.</p>

  <p><tt>stream</tt>: This field specifies the server type, and can
  either be <tt>stream</tt> for connection-oriented services that
  send and receive data as continuous streams of data, or
  <tt>dgram</tt>, for services that send and receive short
  fixed-length messages. Any program that reads STDIN and writes
  STDOUT is a stream-based service, so we use stream here.</p>

  <p><tt>tcp</tt>: This specifies the communications protocol, and
  may be either <tt>tcp</tt> or <tt>udp</tt> (many systems also
  support a few more esoteric protocols, but we won't discuss them
  here). The TCP protocol is a connection-oriented, reliable
  protocol that is used for stream-type communication. UDP is used
  for message-oriented datagrams. Stream-based services will use
  <tt>tcp</tt>.</p>

  <p><tt>nowait</tt>: This tells inetd what to do after launching
  the server program. It can be wait, to tell <tt>inetd</tt> to
  wait until the server is done before launching the program again
  to handle a new incoming connection, or <tt>nowait</tt>, which
  allows inetd to launch the program multiple times to handle
  several incoming connections at once. The most typical value for
  stream-based services is <tt>nowait</tt>, since communications
  sessions may be minutes or hours long. The implication of this
  value, however, is that there may be several copies of the script
  running at once. Some versions of inetd allow you to put a
  ceiling on this value.</p>

  <p><tt>/tmp/eliza/eliza.pl</tt>: This is the full path to the
  program. <tt>/tmp</tt> is not the best place to put executables,
  since many systems clear <tt>/tmp</tt> at boot time, but it
  suffices for tests and demos like this one. You'll want to choose
  a more stable directory, such as <tt>/usr/local/bin</tt>, or
  <tt>/usr/local/sbin</tt>.</p>

  <p><tt>eliza.pl</tt>: The seventh and subsequent fields are
  command-line arguments for the script. This can be any number of
  space-delimited command line arguments and switches. By
  convention, the first field is the name of the program itself.
  You can use the actual script name, as shown here, or make up
  your own name, such as "elizabot". This value will show up in the
  script in the <tt>$0</tt> variable. Other command-line switches
  will appear in the <tt>@ARGV</tt> array in the usual manner.</p>

  <p><tt>inetd</tt> allows you to take any program written in Perl
  (or another language) and turn it into a server. The main
  restriction is that the program must use standard input, standard
  output, and standard error for its interface. Fancy stuff, such
  as Curses-based graphics, will probably not work. There are very
  few gotchas, the main one being output buffering issues. By
  default, when Perl detects that STDOUT is not connected directly
  to the user's screen, it will buffer its <tt>print()</tt>
  statements to make them more efficient. This is okay when Perl is
  writing to a file, but not okay when it's writing to the network
  under the control of <tt>inetd</tt>. The Chatbot::Eliza object
  will write its initial greeting, but because the greeting is
  short it just gets buffered on the server side of the connection
  and the user never sees it.</p>

  <p>The solution to this problem is simple. Just turn on
  autoflushing by setting the <tt>$|</tt> global to true.</p>

  <h3>A Standalone Server</h3>What if you don't have superuser
  access, or are using a system that doesn't support the
  <tt>inetd</tt> super-daemon? Or what if the script has to load a
  lot of modules at startup time, making the launch time delay
  unacceptable for your application?

  <p>Under these circumstances, you can write a standalone server
  that does all the networking stuff itself. Thanks to Graham
  Barr's wonderful IO::Socket module, the code is not all that much
  more complicated than the original script.</p>

  <p>Before we walk through the code, some socket theory. Much of
  the Internet runs across Berkeley sockets, a networking API
  (application programming interface) that was part of one of the
  early Berkeley Standard Distribution releases of Unix. A socket
  is a communications endpoint that can be connected to another
  socket somewhere else on the same machine or Internet. There are
  different types of sockets corresponding to different network
  protocols and each having a unique addressing scheme. The most
  familiar kind, the TCP/IP socket, uses an address consisting of
  an IP address and a port number.</p>

  <p>Once connected, data sent to the socket at one end appears out
  the end, and vice versa. From Perl's point of view, sockets are
  filehandles, just like the more conventional ones that are
  connected to files and pipes. This makes writing networked
  applications extremely straightforward.</p>

  <p>Consider this complete networking client:</p>
  <pre>
  use IO::Socket;
  my $s = IO::Socket::INET-&gt;new( PeerAddr =&gt; 'phage.cshl.org',
                               PeerPort =&gt; 'daytime');
  die "Can't connect: $@" unless $s;
  print &lt;$s&gt;; 
</pre>

  <p>The first line loads the IO::Socket module, defining a number
  of new object classes for dealing with sockets and a number of
  handy constants. The second line attempts to create a new
  IO::Socket object. There are currently two subclasses of
  IO::Socket. One, called IO::Socket::INET, is used for Internet
  communications using TCP/IP. The other, used for communications
  between two process on the same machine, is called
  IO::Socket::UNIX.</p>

  <p>As we want to make an Internet connection, we attempt to
  create an IO::Socket::INET object by calling its <tt>new()</tt>
  method. <tt>new()</tt> recognizes multiple named arguments. In
  this case, we need just two: <tt>PeerAddr</tt> gives the name of
  the remote host to contact to (in this case "phage.cshl.org") and
  <tt>PeerPort</tt> gives the port number or symbolic name of the
  service to connect to, in this case the "daytime" service that
  runs on many Unix machines. <tt>new()</tt> attempts to connect to
  the indicated machine and port. If successful, it returns a new
  IO::Socket object. Otherwise <tt>new()</tt> returns an undefined
  value and leaves an error message in <tt>$@</tt>.</p>

  <p>Once created, a socket object looks and feels a lot like a
  read/write filehandle. You can use it as the argument to
  <tt>print()</tt>, or read lines from it using the angle-bracket
  operator (&lt;&gt;). Socket objects also support a large number
  of input/output methods inherited from the IO::Handle base class.
  For example, you can call <tt>$socket-&gt;print()</tt> to
  transmit some data across the connection, and you can call
  <tt>$socket-&gt;print getline()</tt> to fetch a line of text.</p>

  <p>The daytime service waits for incoming connections and then
  transmits its idea of the current day and time. We read whatever
  text it sends us using the &lt;&gt; operator, and immediately
  print it.</p>

  <p>If you run the program, you'll see this (adjusted for the
  correct time, of course):</p>
  <pre>
  % <b>daytime.pl</b>
  Thu Sep 16 09:50:48 1999 
</pre>

  <p>Servers are not much harder to write. <a href=
  "tpj0403-0004b.html">Listing 2</a> gives the source code for
  <tt>eliza_server.pl</tt>, a network-ready pseudo-psychoanalyst.
  It begins by importing the Chatbot::Eliza and IO::Socket modules,
  and brings in the WNOHANG constant from the POSIX module (used by
  the CHLD signal handler, see below).</p>

  <p>The code then defines a constant containing the port number to
  run on. We use 12000 again here. Be careful if you've already
  installed the <tt>inetd</tt> version of the script, because they
  both can't share the same port. You should either deactivate the
  <tt>inetd</tt> configuration line (by commenting it out and
  sending inetd a HUP signal), or change the constant to an unused
  port.</p>

  <p>Line 6 sets a handler for the CHLD handler. I will explain
  this technical detail after the main code walkthrough.</p>

  <p>The real fun begins in line 8, where we create a new
  IO::Socket object to accept incoming connections. Again we call
  the IO::Socket::INET class' <tt>new()</tt> method, but the
  arguments are quite different. Instead of providing
  <tt>new()</tt> with <tt>PeerAddr</tt> and <tt>PeerPort</tt>
  arguments, we hand it <tt>LocalPort</tt> and <tt>Listen</tt>
  arguments. <tt>LocalPort</tt> tells <tt>new()</tt> that it is to
  "bind to" (associate itself with) local port 12000, and Listen
  tells <tt>new()</tt> that the socket will be used to accept
  incoming connections. The numeric argument to <tt>Listen</tt>
  specifies how many incoming requests can be queued up while
  waiting the server to call <tt>accept()</tt> (see <a href=
  "tpj0403-0004b.html">Listing 2</a>). For this presumably
  low-volume service, 20 simultaneous connections is a very
  generous assumption! The other two arguments are not strictly
  necessary. Proto specifies the communications protocol, in this
  case <tt>tcp</tt>. Since stream-based TCP servers are much more
  common than message-based UDP servers, IO::Socket::INET's
  <tt>new()</tt> method will default to TCP unless otherwise
  specified.</p>

  <p>The Reuse argument tells <tt>new()</tt> that it is okay to
  reuse the port number if the program is killed and immediately
  restarted. Ordinarily, the operating system will impose a small
  delay of about 90 seconds between the time a socket is killed and
  the time its port can be reused. During this time, <tt>new()</tt>
  will be unable to create a new socket. This delay is protection
  against one program accidentally inheriting another program's
  delayed incoming connections. However, this protection is
  irrelevant when it's the same program opening the socket, so
  servers generally set <tt>Reuse</tt> to a true value in order to
  disable this delay.</p>

  <p>Another optional argument, not used in this example, is
  <tt>LocalAddr</tt>, which takes a local hostname or IP address.
  In the event that your machine has more than one network
  interfaces (or multiple IP addresses associated with the same
  interface), you can use <tt>LocalAddr</tt> to choose which
  interface the socket should listen to. If not specified, the
  socket will accept incoming connections bound to any of your
  machine's IP addresses.</p>

  <p>If something goes wrong, <tt>new()</tt> returns undef and
  places a description of the error in the <tt>$@</tt> global. We
  <tt>die()</tt> with a suitable message (line 12). Otherwise, we
  store the returned socket object in the variable
  <tt>$listen_socket</tt>. Technically, the socket returned by this
  call is a "listen socket", as opposed to the "connected socket"
  that was returned by <tt>new()</tt> in the short example
  earlier.</p>

  <p>The loop between lines 14 through 23 is where all the action
  happens. Multiple clients are going to connect to our server, and
  we must service each one in turn. Since we don't know in advance
  when a connection is going to come in, the most efficient way to
  do this is to go to sleep and let the operating system tell us
  that a new connection is ready for servicing. The
  <tt>accept()</tt> method does this. It suspends the process until
  an incoming connection is attempted, at which point it completes
  the connection and returns (to the server) a brand new socket
  object connected to the remote client. The server uses this
  connected socket to talk to the client. When it's finished, it
  closes the connected socket. Meanwhile, the original listening
  socket is still available to <tt>accept()</tt> new incoming
  connections.</p>

  <p>At the top of the loop (line 14), we call the listen socket's
  <tt>accept()</tt> method, and some time later it returns a
  connected socket. We could now go ahead and work with the
  connected socket, but there would be a slight problem. While we
  were working with the connected socket, other clients might be
  trying to connect, and wouldn't get an answer from the server
  until it called <tt>accept()</tt> again. Our server wants to call
  <tt>accept()</tt> again as soon as possible - preferably at the
  same time that it's servicing the current connection.</p>

  <p>To do this requires the server to walk and chew gum at the
  same time. On Unix systems, <tt>fork()</tt> is the way to do
  multiprocessing (we'll turn to Windows real soon now). The
  <tt>fork()</tt> call spawns a duplicate process called the
  "child." The child is identical in every respect to its parent,
  but with one difference. In the parent process, the
  <tt>fork()</tt> call's return value is the process ID of the
  child. In the child process, <tt>fork()</tt> returns numeric 0.
  In case of an error, <tt>fork()</tt> returns <tt>undef</tt>. The
  strategy here is for the child process to handle the task of
  talking to the connected client, while the parent goes back to
  the top of the loop and calls <tt>accept()</tt>. This way many
  clients can connect simultaneously; each will will have a
  dedicated child process to talk to.</p>

  <p>Line 15 calls <tt>fork()</tt> and saves the result code to the
  variable <tt>$child</tt>. If <tt>$child</tt> is undefined, then
  the <tt>fork()</tt> failed for some reason, and the server dies.
  Otherwise, it looks at the return value. If the value is equal to
  numeric 0, then the server knows it's in the child process. The
  child won't be calling <tt>accept()</tt> again, so it doesn't
  need the listen socket, so it closes it by calling the socket's
  <tt>close()</tt> method. While this closing is not strictly
  necessary, in network communications it's always a good idea to
  tidy up unneeded resources, and it avoids the possibility of the
  child inadvertently trying to perform operations on the listen
  socket.</p>

  <p>The child now calls a subroutine named <tt>interact()</tt>,
  passing it the connected socket object. <tt>interact()</tt>
  manages the Eliza conversation and returns when the user
  terminates the connection (by typing bye, for example). After
  <tt>interact()</tt> returns, the child process itself terminates
  by calling <tt>exit()</tt>.</p>

  <p>Meanwhile, back in the parent process, the main loop closes
  the connected socket by calling its <tt>close()</tt> method (line
  22) and goes back to the top of the loop to accept more
  connections. Explicitly closing the connected socket in this way
  is good practice because it avoids the possibility of the parent
  inadvertently interfering with the child's I/O.</p>

  <p>The actual input/output operations are performed in the
  <tt>interact()</tt> subroutine, lines 24-31. There's a slight
  problem with wiring Chatbot::Eliza up to the network, because
  Eliza's <tt>command_interface()</tt> method is hardwired to read
  and write to STDIN/STDOUT, whereas we want it to communicate via
  the connected socket. We could fix this by reaching into the
  chatbot's published lower-level methods and calling the routines
  to print the prompts and transform strings ourselves. This isn't
  much work, but there's an even lazier way to do it. We simply
  replace the default STDIN and STDOUT filehandles with the
  connected socket by reopening them.</p>

  <p>When we loaded IO::Socket, it also brought in methods from its
  parent class, IO::Handle. Among these methods is a filehandle
  method called <tt>fdopen()</tt>, which allows you to do a brain
  transplant on any previously opened filehandle, including the
  standard ones. Essentially, <tt>fdopen()</tt> closes the existing
  filehandle and reopens it using information from another
  filehandle that you give it. We call <tt>fdopen()</tt> three
  times, once each for STDIN and STDOUT, and once for STDERR for
  good measure. Each time we call <tt>fdopen()</tt>, we pass the
  socket object and a symbolic file access code. STDIN is reopened
  for reading with a mode of r, while STDOUT and STDERR are both
  reopened for writing with a mode of <tt>w</tt>. Now, almost as if
  by magic, writing to STDOUT and STDERR will send data flying down
  the socket, and reading from STDIN will perform a read on the
  socket.</p>

  <p>The last detail is to call STDOUT's <tt>autoflush()</tt>
  method. This is equivalent to setting <tt>$|</tt> to a true
  value, but is a bit easier to understand. At this point, we
  create a new Chatbot::Eliza object and invoke its
  <tt>command_interface()</tt> method.</p>

  <p>When you run this program, it wil print out a message saying
  that it's waiting for connections, and then it will appear to
  hang. Go to a second command-line window, telnet to port 12000,
  and talk to the psychiatrist for a while. Leaving the session
  open, go to another window, and telnet to the server again. The
  server should be able to handle both sessions simultaneously. If
  you go to a fourth window and run the ps command, you should see
  three copies of the script running. One is the parent server
  waiting in the <tt>accept()</tt> method for incoming connections.
  The other two are the children spawned to deal with the two
  running sessions.</p>

  <p>To stop the server, go back to the original window and press
  the interrupt key (usually control-C).</p>

  <p>Now to explain the CHLD signal handler. Whenever a parent
  process forks a child, and the child exits before the parent
  does, the Unix operating system gives the parent a chance to
  examine the status code from the child to see if it exited
  normally or as the result of an error. The CHLD signal is used to
  alert the parent that something has happened to its child, and
  the <tt>wait()</tt> and <tt>waitpid()</tt> calls are used to
  retrieve the status code, a process known as reaping. In this
  particular case we don't care about our childrens' exit status
  codes, but the operating system doesn't know that. If a child
  exits and the parent doesn't <tt>wait()</tt> on it, a mummified
  version of the child process will hang around in the system
  process table until the parent either waits on it, or the parent
  exits. These so-called zombie processes can take up system
  resources and are generally undesirable.</p>

  <p>The general technique of avoiding this problem is to install a
  CHLD signal handler in the parent. The handler calls
  <tt>wait()</tt> or <tt>waitpid()</tt> to retrieve the status code
  of the exited process and allow the zombie to go to its eternal
  reward. For a variety of reasons involving the handling of
  stopped processes and the rare event in which two children exit
  at nearly the same moment, the best technique is to call
  <tt>waitpid()</tt> in a tight loop with a first argument of
  <tt>&ndash;1</tt> and a second argument of WNOHANG. Together
  these arguments tell <tt>waitpid()</tt> to reap the next child
  that's available, and prevent the call from blocking if there
  happens to be no child ready for reaping. The handler will loop
  until <tt>waitpid()</tt> returns a negative number or zero,
  indicating that no more reapable children remain.</p>

  <h3>A Threaded Server</h3>You Windows and MacPerl users are
  probably fretting at this point, because neither of the server
  implementations I've shown so far will run on your platforms. You
  can't use <tt>inetd</tt> because there isn't one built into
  either operating system (though I understand there are plug-in
  replacements available on the Internet which you could try), and
  neither supports <tt>fork()</tt>.

  <p>Although I can offer no solace for MacPerl developers, Windows
  users are in luck. (MacPerl developers can use a technique known
  as <i>I/O multiplexing</i> to simulate the behavior of
  multithreading. This technique involves keeping track of multiple
  socket objects simultaneously and using <tt>select()</tt> to
  distinguish which ones are ready for reading and writing.
  It&rsquo;s a bit tedious to write such a server, but the reward
  is a system that runs more efficiently than either the
  <tt>fork()</tt> or the multithreading techniques. However, this
  is outside the scope of the article. For the gory details, see
  the W. Richard Stevens book referenced at the end of this
  article.) Recent ports of Perl can take advantage of
  multithreading capabilities, which in some ways are an
  improvement over <tt>fork()</tt>. In this section, I will show
  the standalone server rewritten to use threading. It's worth
  emphasizing here that Perl's multithreading facilities are still
  unstable. If you are on a Unix system you're safer using
  <tt>fork()</tt> rather than threads. Windows users must use
  multithreading for server applications because other options are
  limited.</p>

  <p><a href="tpj0403-0004c.html">Listing 3</a> gives the code for
  the multithreaded version of the server. You must be using Perl
  5.005_03 or higher for this program to work, and it must have
  been compiled with thread support. It starts out similarly to the
  forking version, except that it brings in the Thread module and
  my own derivative of the Chatbot::Eliza module called
  Chatbot::Eliza::Server (line 4). The rationale for using this
  derivative class will be explained momentarily.</p>

  <p>The listening socket is created exactly as before (lines 6-9),
  but the accept loop and the <tt>interact()</tt> subroutine are
  both rather different. After <tt>accept()</tt> returns a new
  connected socket, the code creates a new thread of execution by
  calling the Thread class's <tt>new()</tt> method. The arguments
  to <tt>new()</tt> are a code subroutine reference and an optional
  list arguments to pass to it. In this case, we pass
  <tt>Thread-&gt;new()</tt> a reference to the <tt>interact()</tt>
  subroutine and the connected socket object.</p>

  <p>Perl launches a new thread of execution and immediately calls
  <tt>interact()</tt>, returning a new Thread object which we'll
  call the <i>session thread</i>. When <tt>interact()</tt> is
  finished, the thread terminates. Back in the main thread, the
  Thread object can be used to monitor and control the session
  thread's activities.</p>

  <p>Threads can either be <i>attached</i> or <i>detached</i>. If
  attached, they hang around indefinitely after they've finished
  execution waiting for the main thread to call their
  <tt>join()</tt> method. This allows threads to return a result or
  return value to the main thread. Detached threads go into the
  background and disappear as soon as they're finished executing.
  This is used for threads that don't have any useful information
  to return to the main process. The threads that handle
  connections are of the latter type, so after creating the session
  thread, the main thread immediately calls the object's
  <tt>detach()</tt> method. At this point, the main thread can go
  back to waiting for incoming connections with
  <tt>accept()</tt>.</p>

  <p>The <tt>interact()</tt> method is shorter than the previous
  version. It recovers the connected socket from its argument list
  and places it in a variable named <tt>$handle</tt>. It then
  creates a new Chatbot::Eliza::Server object and immediately
  invokes <tt>command_interface()</tt>. Chatbot::Eliza::Server is a
  small subclass that I wrote for the purposes of supporting the
  multithreaded server. It is identical in all respects to
  Chatbot::Eliza, except that the <tt>command_interface()</tt>
  method now takes two filehandles as arguments, one for reading
  user input, and the other for writing psychoanalyst output.</p>

  <p>The rationale for creating this subclass is that the previous
  trick of reopening STDIN and STDOUT won't work in a multithreaded
  environment. Unlike the multiprocess solution based on
  <tt>fork()</tt>, where changes to global variables in the child
  don't affect the corresponding variables in the parent, each
  thread of execution in a multithreaded application shares exactly
  the same globals. Reopening STDIN in one session thread would
  affect the STDIN filehandle in all threads, with confusing
  results. For the same reason, you'll notice that the main thread
  doesn't close the connected socket, and the session thread
  doesn't close the listen socket. The main thread and each of the
  session threads are responsible for closing their own sockets
  when they are finished execution.</p>

  <p><a href="tpj0403-0004d.html">Listing 4</a> shows you the code
  to Chatbot::Eliza::Server. It is essentially a cut-and-paste job
  in which I took the <tt>command_interface()</tt> method out of
  the Chatbot::Eliza code, and overrode it with a version that
  reads and writes to filehandle objects that are passed to it at
  runtime. Essentially, I substituted <tt>$in-&gt;getline()</tt>
  everywhere that the original was reading from STDIN, and the
  expression <tt>$out-&gt;print()</tt> everywhere that the original
  was printing to STDOUT. The bad news is that I had to subclass
  the Chatbot::Eliza object in order to get the multithreaded
  server to work. The good news is that Perl's object-oriented
  features allowed me to do this without messing with the other 99%
  of the Chatbot::Eliza code.</p>

  <h3>Launching Standalone Servers from <tt>inetd</tt></h3>If
  you've been following along so far, you may have felt a little
  bit dissatisfied with both the <tt>inetd</tt> and standalone
  server solutions. The problem with inetd is that a new version of
  the script must be launched each and every time a connection
  comes in. There will be a perceptible delay while the script is
  launched, and having many copies of the script running
  simultaneously will consume memory resources (in contrast, when a
  script forks, much of its memory space is shared).

  <p>The standalone server has its problems too. First of all, you
  must launch it manually, or arrange for it to be launched at
  system startup time. This can be inconvenient, particularly if
  the service is used only occasionally. Secondly, there's actually
  a bit more work that must be done with the simple standalone
  server example before it's really ready for production. The
  server must background itself automatically, dissociate itself
  from the controlling terminal, respond appropriately to HUP
  signals, write status messages to the system log, and so
  forth.</p>

  <p>Fortunately inetd provides a mechanism that combines the
  convenience of <tt>inetd</tt> with the performance of the
  standalone server. It's achieved by changing the <tt>nowait</tt>
  flag in the <tt>inetd.conf</tt> line to wait and making a few
  small changes to the standalone server.</p>

  <p>To understand the effect of this, a brief discussion of inetd
  internals is in order. When <tt>inetd</tt> is first launched, it
  scans its configuration file and creates a whole bunch of
  listening sockets, one for each service defined in the
  configuration file. <tt>inetd</tt> monitors all these sockets
  simultaneously by using I/O multiplexing, a technique we haven't
  discussed in this article (see the earlier footnote). When a
  connection comes in, <tt>inetd</tt> calls <tt>accept()</tt> to
  create a connected socket, and then uses the trick from <a href=
  "tpj0403-0004b.html">Listing 2</a> to make the standard input,
  output, and error file descriptors all point to the connected
  socket. It now invokes the appropriate server program, which
  inherits the modified file descriptors. For Perl programs, these
  file descriptors eventually become the STDIN, STDOUT, and STDERR
  file handles seen by the script. So writing to STDOUT sends data
  to the connected socket, and reading from STDIN reads data from
  the socket. Meanwhile, inetd goes back to waiting for incoming
  connections on the original listen socket.</p>

  <p>This scenario occurs if the fourth field of the
  <tt>inetd.conf</tt> line is <tt>nowait</tt>. What happens if the
  field is <tt>wait</tt>? In this case, when <tt>inetd</tt> detects
  that a client is trying to establish a connection on a socket, it
  does <i>not</i> call <tt>accept()</tt>. Instead, it copies the
  listen socket into standard input, standard output, and standard
  error, and invokes the server program. The server must call
  <tt>accept()</tt> itself and handle the session. It is free to
  call <tt>accept()</tt> again as many times as it likes.
  <tt>inetd</tt> will wait politely for the server to finish and
  exit, at which point it will go back to listening on the
  socket.</p>

  <p><a href="tpj0403-0004e.html">Listing 5</a> contains the last
  version of our chatbot server. This one is designed to conserve
  resources without sacrificing performance. It is launched by
  <tt>inetd</tt> using the "wait" mechanism described above. It
  then services requests until a certain period of idle time goes
  by without any new incoming connections. At this point the server
  exits and returns control to <tt>inetd</tt>.</p>

  <p>The code is almost identical to the standalone server of
  <a href="tpj0403-0004b.html">Listing 2</a>. One new feature is a
  command-line argument indicating the number of minutes of idle
  time to allow before the server exits. Line 6 retrieves this
  argument, and defaults to one minute if absent. Line 8 installs
  an ALRM handler. Every time through the main loop the code will
  set a timer using the <tt>alarm()</tt> call. If the alarm goes
  off before <tt>accept()</tt> returns, this handler will be
  invoked, causing the server to exit.</p>

  <p>Lines 12 and 13 retrieve the listen socket. Instead of
  creating a new socket by calling IO::Socket::INET's
  <tt>new()</tt> method, the code checks STDIN with the <tt>-S</tt>
  operator. <tt>-S</tt> returns true if STDIN is actually a socket.
  If it's not a socket, then the server dies with an error. (This
  can happen if someone tries to run the server from the command
  line.) Otherwise, the code turns STDIN into an IO::Socket object
  by calling the IO::Socket class' <tt>new_from_fd()</tt> method.
  This method is nearly identical to <tt>fdopen()</tt>, except that
  it avoids having to first create the IO::Socket, and then reopen
  it. If this call is successful, the <tt>$listen_socket</tt>
  variable will contains a listening socket that is all ready to
  <tt>accept()</tt> an incoming connection.</p>

  <p>The main loop, lines 16-27, is identical to <a href=
  "tpj0403-0004b.html">Listing 2</a> with the addition of two calls
  to <tt>alarm()</tt>. Each time through the loop, in the
  <tt>continue{}</tt> block, the code calls <tt>alarm()</tt> with
  the value of the timeout expressed in seconds. If the code
  reaches this point before the alarm goes off, the server gets a
  new lease on life. Otherwise the ALRM handler is called and the
  server exits. However, we don't want the alarm to go off within a
  child session, so the code carefully turns off the alarm each
  time it forks off a child (line 18).</p>

  <p>To run this version of the chatbot server, enter a line like
  this one in <tt>inetd.conf</tt> and send <tt>inetd</tt> a HUP
  signal:</p>
  <pre>
12000 stream tcp wait lstein/tmp/eliza/eliza_inetd_server.pl
                                  eliza_inetd_server.pl 2
</pre>

  <p>While running <tt>ps</tt> or <tt>top</tt> in a separate
  window, telnet to port 12000 a few times and confirm that the
  same parent server is processing all the requests. Now refrain
  from connecting to the server for two minutes. You will see the
  parent disappear, leaving any active child sessions running. The
  next time you telnet to the port, a new parent server will be
  launched.</p>

  <h3>Further Information</h3>Everything I know about Berkeley
  sockets I learned from W. Richard Stevens, <i>Unix Network
  Programming: Networking API: Sockets and Xti (Volume 1)</i>,
  Prentice Hall, 1997. It's written for C programmers, but there's
  nothing there that can't be applied to Perl immediately. Also
  read through the POD documentation for IO::Handle, IO::Socket,
  and perlipc.

  <p>__END__</p>
  <hr>
  <i>Lincoln Stein is the author of CGI.pm.</i> 
  <!-- end of file -->
</body>
</html>
