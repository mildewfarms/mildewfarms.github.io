<html>
<head>
  <title>Truncating Japanese Text - The Perl Journal, Winter 1999</title>
  <meta name="generator" content=
  "HTML Tidy for Linux/x86 (vers 12 April 2005), see www.w3.org">
  <meta name="vscategory" content="Perl">
  <meta name="vsisbn" content="">
  <meta name="vstitle" content=
  "CS-Web: A Lightweight Summarizer for HTML - Truncating Japanese Text">
  <meta name="vsauthor" content="Tony Rose , Ave Wrigley">
  <meta name="searchdescription" content="">
  <meta name="vsimprint" content="The Perl Journal">
  <meta name="vspublisher" content="Earthweb">
  <meta name="vspubdate" content="Winter 1999">
  <!-- update listing #, listing title, and issue  -->

</head>

<body bgcolor="#FFFFFF" text="#000000" link="#DD0000" vlink=
"#DD0000" alink="#DD0000" leftmargin="0" topmargin="0" marginwidth=
"0" marginheight="0">
  <!-- update listing #, listing title, and issue throughout the table -->

  <table cellspacing="0" cellpadding="5" width="100%" border="0">
    <tr align="left" valign="top">
      <td bgcolor="#CCCC99">
        <table width="100%">
          <tr>
            <td valign="top" bgcolor="#CCCC99" nowrap><font face=
            "Arial,Helvetica" size="+1">Truncating Japanese
            Text</font><br></td>

            <td valign="top" bgcolor="#CCCC99"><font size="-1"
            face="Arial,Helvetica" color="#663300">CS-Web: A
            Lightweight Summarizer for HTML<br>
            The Perl Journal, Winter 1999</font></td>
          </tr>
        </table>
      </td>
    </tr>

    <tr>
      <td>
        <table width="100%">
          <tr>
            <td width="5%" bgcolor="#FFFFFF">&nbsp;</td>

            <td bgcolor="#FFFFFF">
              <font color="#000000">
              <!-- insert code listing or table here --></font>

              <h3><font color="#000000">Truncating Japanese
              Text</font></h3>

              <p>Canon is a Japanese company, with Japanese text on
              many of its web pages. Japanese text is usually
              encoded in one of several possible multibyte encoding
              schemes, and some of these schemes use variable
              numbers of bytes to represent single Japanese
              characters, or intermingle Japanese and regular ASCII
              characters. This was a problem.</p>

              <p>The summaries generated by Text::Summary are
              truncated at a fixed length, and this length is
              specified in bytes, not characters. If Japanese text
              is truncated at an arbitrary byte length, this might
              mean truncation in the middle of a character.</p>

              <p>Worse, our page abstracts can appear in result
              listings for keyword searches. If a page summary
              broken mid-character is inserted into running text,
              the byte immediately following the summary could be
              interpreted as the next byte of the previously
              uncompleted Japanese character, upsetting the
              character boundaries for the rest of the text.</p>

              <p>Text::Sentence includes another supporting module,
              Lingua::JA::Jtruncate, which addresses this problem.
              Lingua::JA::Jtruncate contains just one subroutine;
              jtruncate(), used as follows:</p>
              <pre>

    use Lingua::JA::Jtruncate qw( jtruncate );
    $truncated_jtext = jtruncate( $jtext, $length );
</pre>

              <p>where $jtext is some Japanese text that you want
              to truncate, $length is the maximum truncation
              length, and $truncated_text is the result.
              Here&#8217;s how it works.</p>

              <p>First, some regexes are defined that match
              characters in each of the three main Japanese coding
              schemes: EUC, Shift-JIS, and JIS.</p>
              <pre>
%euc_code_set = (
    ASCII_JIS_ROMAN     =&gt; '[\x00-\x7f]',
    JIS_X_0208_1997     =&gt; '[\xa1-\xfe][\xa1-\xfe]',
    HALF_WIDTH_KATAKANA =&gt; '\x8e[\xa0-\xdf]',
    JIS_X_0212_1990     =&gt; '\x8f[\xa1-\xfe][\xa1-\xfe]',
    );

    %sjis_code_set = (
        ASCII_JIS_ROMAN     =&gt; '[\x21-\x7e]',
        HALF_WIDTH_KATAKANA =&gt; '[\xa1-\xdf]',
        TWO_BYTE_CHAR       =&gt; 
                          '[\x81-\x9f\xe0-\xef][\x40-\x7e\x80-\xfc]',
    );

    %jis_code_set = (
        TWO_BYTE_ESC        =&gt; 
            '(?:' .
            join( '|',
                '\x1b\x24\x40',
                '\x1b\x24\x42',
                '\x1b\x26\x40\x1b\x24\x42',
                '\x1b\x24\x28\x44',
            ) .
            ')'
        ,
        TWO_BYTE_CHAR =&gt; '(?:[\x21-\x7e][\x21-\x7e])',
        ONE_BYTE_ESC =&gt; '(?:\x1b\x28[\x4a\x48\x42\x49])',
        ONE_BYTE_CHAR       =&gt;
            '(?:' .
            join( '|', 
                '[\x21-\x5f]',                    
                 # JIS7 Half width katakana
                '\x0f[\xa1-\xdf]*\x0e',             
                 # JIS8 Half width katakana
                '[\x21-\x7e]',                      
                 # ASCII / JIS-Roman
            ) .
            ')'
    );

    %char_re = (
        'euc' =&gt; '(?:' . join( '|', values %euc_code_set ) . ')',
        'sjis' =&gt; '(?:' . join( '|', values %sjis_code_set ) . ')',
        'jis' =&gt; '(?:' . join( '|', values %jis_code_set ) . ')',
    );
</pre>

              <p>Each of the regexes in %char_re matches one
              character encoded in the scheme corresponding to the
              keys of the hash.</p>

              <p>Now for the definition of the jtruncate()
              subroutine; first, some fairly obvious sanity
              checks:</p>
              <pre>

    sub jtruncate{
        my $text            = shift;
        my $length          = shift;

        # sanity checks

        return '' if $length == 0;
        return undef if not defined $length;
        return undef if $length &lt; 0;
        return $text if length( $text ) &lt;= $length;
</pre>

              <p>Now we save the original text; this is used later
              if the truncation process fails for some reason.</p>

              <blockquote>
                <pre>
        my $orig_text = $text;
</pre>
              </blockquote>

              <p>Now we use <tt>Lingua::JA::Jcode::getcode()</tt>
              to detect the character encoding.
              <tt>Lingua::JA::Jcode::getcode()</tt> is a simple
              wrapper around the jcode.pl Perl library for Japanese
              character code conversion. Kazumasa Utashiro kindly
              agreed to let us distribute the code with
              HTML::Summary.</p>

              <blockquote>
                <tt>my $encoding = Lingua::JA::Jcode::getcode(
                \$text );</tt>
              </blockquote>

              <p>If getcode returns undef, or a value other than
              <tt>euc, sjis</tt>, or <tt>jis</tt>, then it has
              either failed to detect the encoding, or detected
              that it is not one of those that we are interested
              in. We then take the brute force approach, using
              <tt>substr</tt>.</p>

              <blockquote>
                <pre>

        if ( not defined $encoding 
                     or $encoding !~ /^(?:euc|s?jis)$/ ){
            return substr( $text, 0, $length );
        }
</pre>
              </blockquote>

              <p>The actual truncation of the string is done in
              <tt>chop_jchars()</tt> - more about this later.</p>

              <blockquote>
                <pre>
        $text = chop_jchars($text, $length, $encoding );
</pre>
              </blockquote>

              <p><tt>chop_jchars()</tt> returns undef on failure.
              If we have failed to truncate the Japanese text
              properly we resort to substr again. We had to decide
              whether it was more important to meet the
              <tt>$length</tt> constraint or risk returning a
              Japanese string with broken character encoding. We
              chose the former:</p>

              <blockquote>
                <pre>
        return substr( $orig_text, 0, $length ) 
                                    unless defined $text;
</pre>
              </blockquote>

              <p>Next, a special case: JIS encoding uses escape
              sequences to shift in and out of single-byte and
              multi-byte modes. If the truncation process leaves
              the text ending in multi-byte mode, we need to add
              the single-byte escape sequence. Therefore, we
              truncate (at least) three more bytes from JIS encoded
              string, so we have room to add the single-byte escape
              sequence without going over the <tt>$length</tt>
              limit.</p>

              <blockquote>
                <pre>
        if ( $encoding eq 'jis' and 
            $text =~ /$jis_code_set{ TWO_BYTE_CHAR }$/) {
            $text = chop_jchars( $text, $length - 3, 
                                             $encoding );
            return substr( $orig_text, 0, $length ) 
                                     unless defined $text;
            $text .= "\x1b\x28\x42";
        }

And we&#8217;re done!


        return $text;
    }
</pre>
              </blockquote>

              <p>Now for <tt>chop_jchars()</tt>, which simply lops
              off Japanese characters from the end of the string
              until it is shorter than the requested length.
              It&#8217;s pretty ugly, and slow for large strings
              truncated to small values, but it does the job!</p>

              <blockquote>
                <pre>
    sub chop_jchars
    {
        my $text = shift;
        my $length = shift;
        my $encoding = shift;

        while( length( $text ) &gt; $length ) {
            return undef 
            unless $text =~ s!$char_re{ $encoding }$!!o;
        }

        return $text;
    }
</pre>
              </blockquote><!--  end code listing  -->
            </td>
          </tr>
        </table>
      </td>
    </tr>
  </table>
</body>
</html>
