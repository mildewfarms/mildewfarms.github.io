<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <title>Web Databases the Genome Project Way - The Perl Journal, Spring 1999</title>
  <meta name="generator" content=
  "HTML Tidy for Linux/x86 (vers 12 April 2005), see www.w3.org">
  <meta name="vscategory" content="Perl">
  <meta name="vsisbn" content="">
  <meta name="vstitle" content=
  "Web Databases the Genome Project Way">
  <meta name="vsauthor" content="Lincoln D. Stein">
  <meta name="searchdescription" content=
  "This issue's column is going to be a bit different. Instead of describing a neat trick or technique for Perl Web programming, I'm going to talk a bit about my own work in the Human Genome Project.">
  <meta name="vsimprint" content="The Perl Journal">
  <meta name="vspublisher" content="Earthweb">
  <meta name="vspubdate" content="Spring 1999">

</head>

<body bgcolor="#FFFFFF">
  <!-- end head -->
  <font face="verdana" size="1">Issue 13, Spring 1999</font>

  <h2 align="center">Web Databases the Genome Project Way</h2>

  <h4>Lincoln D. Stein</h4>

  <div align="center">
    <table border="1" width="503">
      <tr>
        <td align="center" width="497">
          <b>URLs and Databases</b>

          <p>ACEDB:<br>
          <a href=
          "ftp://ftp.ncbi.nlm.nih.gov/repository/acedb">ftp://ftp.ncbi.nlm.nih.gov/repository/acedb</a></p>

          <p>ACEDB Documentation and FAQs:<br>
          <a href="http://probe.nalusda.gov:8000/" target=
          "resource window">http://probe.nalusda.gov:8000/</a></p>

          <p>AcePerl code and documentation:<br>
          <a href="http://stein.cshl.org/AcePerl" target=
          "resource window">http://stein.cshl.org/AcePerl</a>.</p>

          <p>AceBrowser code and documentation:<br>
          <a href="http://stein.cshl.org/AcePerl/AceBrowser"
          target="resource window">http://stein.cshl.org/AcePerl/AceBrowser</a>.</p>

          <p>AcePerl access to the C. elegans data (read only):<br>
          server: wormsrv1.sanger.ac.uk, port: 210201<br>
          server: beta.crbm.cnrs-mop.fr, port: 20000100</p>
        </td>
      </tr>
    </table>
  </div>

  <p>This issue's column is going to be a bit different. Instead of
  describing a neat trick or technique for Perl Web programming,
  I'm going to talk a bit about my own work in the Human Genome
  Project.</p>

  <p>The data generated by the genome project is more complex than
  the type of data one usually sees in business applications.
  Instead of a few simple relationships between objects, biological
  objects are woven into a rich web of interconnections. For
  example, a DNA sequence contains a number of genes, each of which
  encodes one or more proteins, each of which has a confirmed or
  predicted function. The protein functions, in turn, are related
  to diseases, which are related to disease mapping information,
  which are related to genes, which are related back to DNA
  sequences. You can describe biological information in the
  familiar terms of a relational database schema, but you might not
  like the results. Inevitably you "fracture" the original
  biological objects into many small tables. Some Oracle-based
  genome databases use relational schemas of over 600 tables and
  require a database guru just to formulate and execute useful
  queries!</p>

  <p>A more natural solution for storing biological data is to use
  an object-oriented system. In such a system, real world objects
  like genes and DNA sequences are mapped directly onto database
  objects. This makes it easier for the biologist end-users to
  understand the database, and it facilitates communication between
  the users and the database designers.</p>

  <p align="center"><a href="images/stein1.gif"><img src=
  "images/stein1_small.gif" alt="stein1" hspace="10" border="2"
  width="100" height="108" vspace="10"></a><br>
  <font size="-1">Figure 1: An ACEDB data object</font></p>

  <h3>The ACEDB Database</h3>

  <p>There are a variety of object-oriented databases used by the
  genome project. The most widely used one, and the one I talk
  about in this column, is called ACEDB. It was written to support
  the sequencing of a small soil-living worm called <i>C.
  elegans</i>, a fact reflected in its name (ACEDB stands for "A
  <i>C. Elegans</i> DataBase").</p>

  <p>However, it's now used by groups sequencing everything from
  barley to swine, and is the primary database used by several of
  the larger labs in the human sequencing project as well.</p>

  <p>The primary authors of ACEDB are Richard Durbin and Jean
  Thierry-Mieg, aided and abetted over the years by a large number
  of volunteers and collaborators. It consists of some 250,000
  lines of C code, and is available for unrestricted use and
  distribution under open source terms. My role in the ACEDB
  project has been to develop Java and Perl client APIs, as well as
  to develop Web interfaces to a variety of ACEDB databases. These
  APIs and Web interfaces are also available on an open source
  basis.</p>

  <p>ACEDB can operate in single-user mode on Unix or Windows NT
  systems, in which case it interacts directly with users via a
  graphical front end. Or, it can operate as a faceless server,
  providing read/write or read-only access to network clients. As a
  database engine, the system compares favorably to mySQL and even
  some commercial database engines; server reliability is
  excellent, even when working with databases containing millions
  of objects.</p>

  <p>Although there are many features of ACEDB that betray its
  origins as a biological database (what other database has a
  primitive data type called "DNA"?) there's nothing preventing it
  from being used for other purposes. For instance, ACEDB has been
  used by the quality control division of Intel corporation to
  store test results on chip components. For the purposes of
  illustration, this column uses a small database of movie films
  called <i>moviedb</i> that was generously provided by Fred Wobus
  of the Sanger Centre in Cambridge, England.</p>

  <p>You can browse the <i>moviedb</i> database at the URL <a href=
  "http://stein.cshl.org/perl/ace/search/moviedb" target=
  "resource window">http://stein.cshl.org/perl/ace/search/moviedb</a>,
  but be aware that this database is intended as a demo only. It
  only contains a few entries, and none of its contents should be
  taken too seriously. To see a real biological database in action,
  have a look at the <i>C. elegans</i> genome database, a copy of
  which is located at <a href=
  "http://stein.cshl.org/elegans.html">http://stein.cshl.org/elegans.html</a>.</p>

  <h3>ACEDB Objects and Classes</h3>

  <p><a href="images/stein1.gif">Figure 1</a> shows you an ACEDB
  data object from <i>moviedb</i> in the form displayed by a CGI
  script you'll see later. Every ACEDB object has a "class", which
  describes its data type, and an identifier called its "name." In
  the object shown in the figure, the class is <tt>Person</tt>, and
  the name is <tt>scorsese</tt>. Together the name and class
  uniquely identify an object in the database.</p>

  <p>Every ACEDB object is a hierarchical tree consisting of tags
  and values. Some of the tags defined by the <tt>Person</tt> class
  are <tt>Full_name</tt>, <tt>Address</tt>, <tt>Stars_in</tt>, and
  <tt>Directed</tt>. To the right of each tag is either a data
  value, or more tags. Tags give the tree structure and serve to
  name portions of the subtree. For example, the subtree to the
  right of the <tt>Full_name</tt> tag is the single data value
  <tt>Martin Scorsese</tt>, while the subtree to the right of
  <tt>Address</tt> is a complex data type organized by the subtags
  <tt>Mail</tt> and <tt>Email</tt>. In ACEDB data objects, every
  part of the tree is potentially multivalued. The tree anchored at
  the <tt>Directed</tt> tag, for example, consists of five entries
  corresponding to the <tt>Movie</tt> objects that Martin Scorsese
  has directed. ACEDB data types can get more complex than this,
  allowing the database designer to specify a wide variety of
  constructed types, lists, and sets.</p>

  <p><a href="tpj0401-0005.html">Listing 1</a> shows the complete
  schema for <i>moviedb</i> (known as "the model file" in ACEDB
  parlance). The schema definition language looks a lot like a set
  of ACEDB objects, and in fact is represented as such in the
  database. Classes are denoted using the notation
  <tt>?Classname</tt>, tags are short string identifiers containing
  no whitespace, and data values are indicated using a series of
  reserved data type names like <tt>Text</tt>.</p>

  <p>Capitalized directives specify attributes for certain parts of
  the tree. For example, in the <tt>Person</tt> class, the subtree
  to the right of the <tt>Full_name</tt> tag has the attribute
  <tt>UNIQUE</tt> followed by the data type <tt>Text</tt>. This
  ensures that the <tt>Full_name</tt> subtree will never have more
  than a single data value, and that it will be of the
  <tt>Text</tt>, or string, type. The tree anchored at
  <tt>Height</tt> is a unique integer; however the tree to the
  right of <tt>Phone</tt> is not tagged as unique, indicating that
  a <tt>Person</tt> can have multiple phone numbers (which most of
  these Hollywood stars do, although they're all unlisted).</p>

  <p>Still focusing on the definition of the <tt>Person</tt> class,
  examine the subtrees anchored at the <tt>Stars_in</tt>,
  <tt>Directed</tt>, <tt>Scripted</tt> and <tt>Wrote</tt> tags.
  Instead of pointing to a primitive data type, these four tags all
  point to other constructed classes. For instance,
  <tt>Stars_in</tt> points to one or more <tt>Movie</tt> objects,
  signifying the movies that the <tt>Person</tt> has starred in.
  Further, the <tt>XREF</tt> attribute establishes a
  cross-reference relationship between two classes. For example,
  the <tt>Stars_in</tt> tag of the <tt>Person</tt> class is
  cross-referenced with the <tt>Cast</tt> tag of the <tt>Movie</tt>
  class. This means that whenever a new <tt>Movie</tt> is added to
  the <tt>Stars_in</tt> list, the <tt>Movie</tt> object's
  <tt>Cast</tt> list will be updated as well. A similar
  <tt>XREF</tt> in the <tt>Movie</tt> definition establishes the
  reverse relationship. The ACEDB data definition language provides
  a number of other features for controlling indexing and
  constraints.</p>

  <p>At the bottom of the schema file is a set of subclass
  definitions. (Ordinarily these belong in a separate file, but
  I've added them to this listing for simplicity.) Unlike most
  object-oriented databases, ACEDB's subclassing system is entirely
  data driven. An object is subclassed based on its contents. The
  definitions given here subclass the generic <tt>Person</tt> class
  into <tt>Actor</tt>, <tt>Director</tt>, <tt>ScriptWriter</tt> and
  <tt>Author</tt> subclasses based on a <tt>Filter</tt> directive.
  In the <i>moviedb</i> database, the <tt>Actor</tt> subclass is
  defined as any <tt>Person</tt> who has a <tt>Stars_in</tt> tag.
  Similarly, the <tt>Director</tt> subclass is any <tt>Person</tt>
  who has the tag <tt>Directed</tt>. These are all simple examples
  of the <tt>Filter</tt> directive, but interestingly, a filter can
  be any arbitrary ACEDB query. For example, you could define a
  <tt>SuperStar</tt> as a <tt>Person</tt> who has starred in more
  than 20 movies. Another consequence of this type of subclassing
  is that multiple inheritance is easy and natural.</p>

  <p>Setting up a new ACEDB database is as simple as editing the
  schema file with a text editor, and launching the database
  application from the command line. The system will ask whether it
  should initialize itself, and, if you confirm, it sets up an
  empty database. You'll then load some data as described below. At
  any later point you can edit the schema file and update the
  database by issuing the <tt>read models</tt> command. ACEDB will
  modify the data in-place to match the new schema, adding or
  removing tags as needed. This is in contrast to some other
  object-oriented systems where schema evolution is tricky at
  best.</p>

  <p>Data can be added to an ACEDB database in several ways. One
  way is to use the standalone application or a remote client to
  load a flat file in the format shown in <a href=
  "tpj0401-0006.html">Listing 2</a>. This format, which is easily
  generated by a Perl script, consists of each object flattened in
  such a way that each row of the object occupies a separate line.
  Blank lines separate objects. The entire hierarchy of tags
  doesn't have to be given, just the rightmost subtag; the ACEDB
  system knows how to rehydrate the tree based on the schema. ACEDB
  databases are commonly exported and dumped in this format, which
  makes it easy to transfer data from one database to another or to
  rebuild a corrupted database (although this is an extremely
  uncommon occurrence).</p>

  <p>Another way to load data into ACEDB is to enter data
  graphically using various editors that come with it. A third
  option is to use the Perl API described in the next section to
  create objects programmatically.</p>

  <h3>Accessing ACEDB from Perl</h3>

  <p>The Perl interface to ACEDB makes good use of Perl's
  object-oriented features to transparently map ACEDB objects to
  Perl objects.<a href="tpj0401-0007.html">Listing 3</a> shows a
  simple AcePerl script that fetches an object from a networked
  ACEDB server, reads a data value, and updates it. We'll walk
  through it a chunk at a time.</p>
  <pre>
#!/usr/bin/perl
use Ace;
&#13;my $db = Ace-&gt;connect(-port =&gt; 200008,
              -host =&gt; 'stein.cshl.org')
      || die "Can't connect ", Ace-&gt;error;
</pre>

  <p>The script begins by loading the Ace.pm module. It then calls
  Ace's <tt>connect()</tt> method to connect to an ACEDB server at
  the indicated host and port. If the connection fails, the script
  dies with an error message, calling the <tt>Ace::error()</tt>
  method to obtain a description of the problem. If the connection
  succeeds, it returns a database accessor object, which we store
  in a local variable, <tt>$db</tt>. It is possible to establish
  connections with multiple databases simultaneously, and to open
  up both remote and local (non-networked) databases.</p>
  <pre>
my $scorsese = $db-&gt;fetch(Person =&gt; 'scorsese') 
       || die "Can't get scorsese object ", Ace-&gt;error;
</pre>

  <p>The script now attempts to fetch the <tt>Person</tt> object
  with name <tt>scorsese</tt>. If it succeeds, it returns a Perl
  object blessed into the <tt>Ace::Object</tt> class. Otherwise the
  script dies with an error. This is the simplest way to fetch an
  object. Other ways include wildcard matches, or ACEDB query
  language statements, either of which can return multiple objects
  at once. It is also possible to create a <i>cursor</i> over the
  database in order to fetch objects one at a time in a
  memory-efficient manner.</p>
  <pre>
my @phone = $scorsese-&gt;Phone;
</pre>

  <p>The script now attempts to find Martin Scorsese's phone number
  by calling the object's <tt>Phone()</tt> method. Ace.pm
  dynamically generates <tt>Phone()</tt> and other data access
  methods by consulting the schema of the connected database. The
  returned phone number, if any, is stored in a local variable,
  <tt>@phone</tt>. Notice that since the <tt>Phone</tt> tag is
  potentially multivalued, the script uses an array to store the
  data. Because ACEDB objects can be quite large (some of the DNA
  <tt>Sequence</tt> objects are many megabytes in size), data
  access is done in a bandwidth- and memory-conserving manner.
  Unless you specify otherwise, only those parts of an object that
  you need are ever moved from the database into Perl.</p>
  <pre>
unless (@phone) {
    $scorsese-&gt;add(Phone =&gt; '501 555-1212');
    $scorsese-&gt;commit || die "Can't commit ", Ace-&gt;error;
}
</pre>

  <p>If the list of phone numbers is empty, the script updates the
  <tt>Phone</tt> tag by adding a new value. It then attempts to
  commit the change to the server.</p>

  <p>Although the host and port given here are real ones, this
  script won't work in your hands because the host is behind a
  firewall. If you wish to experiment with ACEDB, however, you can
  connect to some of the publicly-accessible read-only servers for
  DNA sequencing data provided at the beginning of this article. A
  variety of demo scripts come with the AcePerl package.</p>

  <p>The Perl representation of ACEDB objects has many more methods
  than the few shown in this sample script. Among other things, it
  is possible to navigate through objects without advance knowledge
  of the database schema. For example, you could obtain the list of
  top-level tags in the <tt>$scorsese</tt> object in this way:</p>
  <pre>
@tags = $scorsese-&gt;tags;
</pre>

  <p>Then you could fetch and print the contents of these tags one
  by one:</p>
  <pre>
foreach (@tags) {
    print $scorsese-&gt;get($_);
}
</pre>

  <p>Other methods allow you to determine the type of each node of
  the object tree. In this way you could detect which nodes of the
  tree were subtags, and recurse on them. In fact, built-in methods
  do just this to transform ACEDB objects into various text and
  HTML representations.</p>

  <p>Some ACEDB subtrees are actually pointers to other database
  objects. When you retrieve such subtrees, you obtain lists of
  Ace::Objects which will perform further database accesses when
  necessary. For example, here's how to find the titles of all the
  movies that Martin Scorsese has starred in:</p>
  <pre>
my @movies = $scorsese-&gt;Starred_in;
for my $movie (@movies) {
    print $movie-&gt;Title;
}
</pre>

  <p>And here's a way to find all Scorsese's coauthors for
  screenplays:</p>
  <pre>
my %coauthors;
for my $movie ($scorsese-&gt;Scripted) {
   foreach my $author ($movie-&gt;Writer) {
      $coauthors{$author}++ unless $author eq 'scorsese';
   }
}
</pre>

  <p>If you are looking carefully, you'll notice an interesting bit
  of magic in the fourth line. The Perl string operators are
  overloaded in the Ace::Object class allowing you to compare ACEDB
  objects to strings in a natural way. You can also print out
  objects and incorporate them into strings. During string
  interpolation, the object reference is replaced with its ACEDB
  object name.</p>

  <p>Because ACEDB keeps its objects intact, it's very easy to move
  objects from one database to another. Provided that their schemas
  are compatible, you can move an object from database A to
  database B as easily as this:</p>
  <pre>
my $object = $databaseA-&gt;fetch(.....);
$databaseB-&gt;put($object);
</pre>

  <h3>ACEDB Meets the Web</h3>

  <p>Recently I've been writing Perl modules for making ACEDB
  databases available for Web browsing. These modules, collectively
  called AceBrowser, sit on top of AcePerl and consists of several
  parts. There's a utility module called AceSubs.pm that exports a
  variety of useful functions for displaying ACEDB objects on HTML
  pages, and handles such things as making the ACEDB client-server
  connection persistent. There's a series of CGI scripts that
  display objects in different ways. There are both
  schema-independent displays, such as the generic tree browser
  shown in <a href="images/stein1.gif">Figure 1</a>, and
  schema-dependent displays, such as those that display DNA
  <tt>Sequence</tt> and <tt>Protein</tt> objects. Then there are
  several types of search pages, which again come in
  schema-dependent and schema-independent groups. Finally, there's
  a configuration file that contains site-specific definitions for
  what databases should be made available to the Web and how to
  connect to them. This configuration file also implements a simple
  object registration system that associates ACEDB object classes
  with the CGI scripts that display them.</p>

  <p>Out of the box, AceBrowser supports two different generic
  views on ACEDB objects. There's the tree browser, <i>tree</i>,
  which produced <a href="images/stein1.gif">Figure 1</a>. It is
  smart enough to collapse subtrees that are too long to display on
  a single page, and turn their tags into links that expand and
  collapse the subtree like the outliners of word processor
  programs. It is also capable of recognizing ACEDB object
  references and turning them in links into the appropriate CGI
  script.</p>

  <p>Then there's a graphical browser named <i>pic</i>. The
  <i>pic</i> display asks the ACEDB server to return the graphical
  representation of the object. Several ACEDB classes have special
  display methods on the server side that allow biological objects
  like sequence maps and clones to be graphed. The <i>pic</i>
  script takes advantage of this ability by turning
  server-generated graphics into clickable image maps. <i>pic</i>
  isn't particularly useful for the <i>moviedb</i> database since
  it doesn't have any special graphical representations. However,
  I've kept this script associated with the <i>moviedb</i> database
  in case someone decides to add pictures of the cast or MPEG
  trailers to the database.</p>

  <div align="center">
    <a href="images/stein2.gif"><img src="images/stein2_small.gif"
    alt="stein2" hspace="0" border="2" width="100" height=
    "113"></a><br>
    <font size="-1">Figure 2: The Biography display generated by
    Listing 4.</font>
  </div>

  <p>The <i>tree</i> display is useful for debugging and
  development, but the raw ACEDB hierarchical tree view isn't
  particularly attractive. For that, you need schema-dependent
  views that reformat data objects into nice HTML pages. <a href=
  "tpj0401-0008.html">Listing 4</a> shows a CGI script named
  <i>person</i>, which displays a <tt>Person</tt> object. <a href=
  "images/stein2.gif">Figure 2</a> showed a screenshot of this
  script's output, which we'll walk through now.</p>
  <pre>
use strict;
use vars '$DB';
use Ace 1.51;
use AceSubs;
use CGI 2.42 qw/:standard :html3 escape/;
</pre>

  <p>The script begins by turning on strict syntax checking and
  importing routines from Ace.pm. It also loads up handy
  subroutines defined by the AceSubs.pm module of the AceBrowser
  system, and imports various symbols from the CGI.pm module. A
  variable named <tt>$DB</tt> is declared global for use as the
  database handle.</p>
  <pre>
AceInit();
$DB = OpenDatabase() || AceError("Couldn't open database.");
AceHeader();
</pre>

  <p><tt>AceInit()</tt> is defined by the AceBrowser subsystem, and
  does some internal variable initialization.
  <tt>OpenDatabase()</tt> is another AceBrowser call; it consults
  the configuration file to determine which database to open and
  attempts to open it; the returned handle is stored in
  <tt>$DB</tt>. The name of the database is actually derived from
  the additional path information of the script URL. If this script
  were installed as /cgi-bin/ace/person, then calling it as
  http://your.site/cgi-bin/ace/person/moviedb, would tell the
  system to open the "moviedb" database. These URLs are ordinarily
  generated internally by AceSubs--you don't have to worry about
  it.</p>

  <p><tt>AceHeader()</tt> prints out the HTTP header and the top
  HTML boilerplate defined in the configuration file.</p>
  <pre>
my $person_name = param('name');
my ($person) = $DB-&gt;fetch(-class =&gt; 'Person',
	                 -name =&gt; $person_name,
	                 -fill =&gt; 1
	                ) if $person_name;
</pre>

  <p>The script looks for a CGI parameter named <tt>name</tt>. If
  present, it calls the Ace <tt>fetch()</tt> method to retrieve the
  named <tt>Person</tt> object. This is a slightly longer version
  of the <tt>fetch()</tt> method than we saw previously. The
  motivation for this is to use the <tt>-fill</tt> argument, which
  indicates that the entire <tt>Person</tt> object should be
  fetched in a single operation. Since the <tt>Person</tt> class is
  a relatively small one, it is more efficient to do the fetch in a
  single operation rather than a bit at a time as per default.</p>
  <pre>
print_top($person);
print_warning($person_name)  if $person_name &amp;&amp; !$person;
print_prompt();
print_report($person)        if $person;
print_bottom();
&#13;exit 0;
</pre>

  <p>The script now prints out the top of the HTML page and a
  warning if the requested <tt>Person</tt> does not exist in the
  database. It then prints out a textfield that allows the user to
  directly request another <tt>Person</tt> object without returning
  to the AceBrowser search pages. The <tt>print_report()</tt>
  function prints out a short report on the requested
  <tt>Person</tt> object, and <tt>print_bottom()</tt> prints out
  some bottom boilerplate. The script exits at this point.</p>
  <pre>
sub print_top {
  my $person = shift;
  my $title = $person ? "Bio for $person" : 
                        'Moviedb Person Report';
  print start_html (
                         '-Title' =&gt; $title,
                         '-style' =&gt; Style(),
	          ),
      HEADER,
      TypeSelector($person, 'Person'),
      h1($title);
}
&#13;sub print_bottom { print FOOTER; }
</pre>

  <p>The <tt>print_top()</tt> and <tt>print_bottom()</tt> functions
  are responsible for the top and bottom boilerplate of the HTML
  page. Most of this is self explanatory, except for a few calls
  into the AceBrowser system. <tt>Style()</tt>, defined in
  AceSubs.pm, returns a stylesheet for the page, based on settings
  in the configuration file. <tt>HEADER</tt> and <tt>FOOTER</tt>
  are constants derived from other definitions in the configuration
  file; they are responsible for the banner at the top of the page
  and the various links and attributions at the bottom.</p>

  <p><tt>TypeSelector()</tt>, defined in AceSubs.pm, produces a
  navigation bar for the object. It creates a row of icons at the
  top of the page which allow the user to navigate to the search
  pages, or to various alternative displays for the object. In
  <a href="images/stein2.gif">Figure 2</a>, we are showing the
  <tt>Biography</tt> display generated by the current script.
  Alternative displays include <tt>Tree Display</tt> generated by
  <i>tree</i>, and <tt>Graphic Display</tt> generated by
  <i>pic</i>. Some of the more complex biological objects have half
  a dozen alternate displays available.</p>
  <pre>
sub print_warning {
  my $name = shift;
  print p(font({-color =&gt; 'red'},
    "The person named \"$name\" 
	     is not found in the database."));
}
sub print_prompt {
  print
  start_form({-name=&gt;'form1',
        -action=&gt;Url(url(-relative=&gt;1))}),
    p("Database ID",
      textfield(-name=&gt;'name')
    ),
    end_form;
}
</pre>

  <p>The <tt>print_warning()</tt> and <tt>print_prompt()</tt>
  functions use CGI.pm methods to create HTML fragments.
  <tt>print_warning()</tt> is called when the requested
  <tt>Person</tt> object is not found in the database, producing a
  nice red error message. <tt>print_prompt()</tt> produces a tiny
  fill-out form containing a single textfield named <tt>name</tt>.
  The user can type in the name of a new <tt>Person</tt> object in
  order to display a new database object.</p>
  <pre>
sub print_report {
  my $person = shift;
  
  print h2($person-&gt;Full_name);
</pre>

  <p>The <tt>print_report()</tt> function is where the object is
  actually displayed. The function begins by shifting the
  <tt>Person</tt> object off the subroutine stack and storing it in
  a local variable. It then calls the object's <tt>Full_name()</tt>
  method, and incorporates it into a level 2 header.</p>
  <pre>
if (my @address = $person-&gt;Address(2)) {
   print h3('Contact Information'),
	      blockquote(address(join(br,@address)));
   print a({-href=&gt;'mailto:' . $person-&gt;Email(1)},
	 "Send e-mail to this person" if $person-&gt;Email;
} else {
   print p(font({-color=&gt;'red'},
	      'No contact information in database'));
}
</pre>

  <p>The next step is to print out the <tt>Person</tt>'s address.
  This section takes advantage of an ACEDB feature that we haven't
  seen yet. Subtrees are often structured so that higher-level tags
  indicate generic attributes while subtags indicate more specific
  ones. In the <tt>Person</tt> object, the <tt>Address</tt> tag
  anchors a subtree of address attributes, and the subtags
  <tt>Mail</tt>, <tt>Phone</tt> and <tt>EMail</tt> indicate
  specific types of addresses. We could generate the address by
  calling <tt>Mail()</tt>, <tt>Phone()</tt>, and <tt>EMail()</tt>
  explicitly, but what would happen if the schema later evolved to
  contain a new subtag named <tt>Fax</tt>? In many cases, what we
  want to do is to jump two steps to the right of the generic tag
  and retrieve all the lines in the column we find there. The data
  access methods allow this to be done easily by accepting an
  optional numeric argument, which specifies an offset from the tag
  into the data. <tt>Address(2)</tt> retrieves all the data two
  steps to the right of the <tt>Address</tt> tag. We incorporate
  these lines into a <tt>&lt;BLOCKQUOTE&gt;</tt> section and print
  it out.</p>

  <p>If the <tt>Person</tt> has an email address, we turn it into a
  <tt>mailto:</tt> link. Note that we call <tt>Email(1)</tt> here,
  explicitly stepping one data element to the right of the
  <tt>Email</tt> tag. This is because the data access methods have
  slightly different behaviors in scalar and list contexts. In a
  list context, data access methods return the column of data to
  the right of the tag (unless modified by a numeric value). This
  is the form we've previously seen. In a scalar context, data
  access methods return a reference to the tag itself. This allows
  constructions like <tt>$person-&gt;Address-&gt;Email</tt> to work
  the way you'd expect. When in doubt, it's safest to give an
  explicit offset.</p>
  <pre>
if ($person-&gt;Born || $person-&gt;Height) {
    print h3('Fun Facts'),
	  table({-border=&gt;undef},
	        TR({-align=&gt;'LEFT'}, th('Height'),
	                td($person-&gt;Height(1) || '?')),
	        TR({-align=&gt;'LEFT'}, th('Birthdate'),
	                td($person-&gt;Born(1) || '?'))
	          ),
}
</pre>

  <p>If either the <tt>Born</tt> or <tt>Height</tt> field is
  defined, the script prints out a table titled "Fun Facts" and
  prints the information. If one of these fields is missing, a
  question mark is printed instead (<i>moviedb</i> has a notable
  shortage of fun facts).</p>
  <pre>
if (my @directed = $person-&gt;Directed) {
   print h3('Movies Directed');
   my @full_names = map { a({-href=&gt;Object2URL($_)},
	                        $_-&gt;Title) } @directed;
   print ol(li \@full_names);
}
</pre>

  <p>This section prints out a list of the movies that the
  <tt>Person</tt> has directed, if any. It calls the
  <tt>Directed()</tt> method to recover a list of <tt>Movie</tt>
  objects. If not empty, the code turns them into a series of links
  by calling the <tt>Object2URL()</tt> function defined in
  AceSubs.pm. <tt>Object2URL()</tt> consults the object registry
  given in the configuration file, and turns it into a URL that
  links to the appropriate display script. We could use the
  <tt>Movie</tt> object's name as the link, but it is more elegant
  to dereference the object and recover the movie's full title for
  use in the link text. If using the raw database name in the link
  text were appropriate, we could shorten the code a bit by using
  the AceSubs.pm <tt>ObjectLink()</tt> method:</p>
  <pre>
my @full_names = ObjectLink(@directed); 
</pre>

  <p>The movie links are then incorporated into an ordered
  list.</p>
  <pre>
  
  if (my @scripted = $person-&gt;Scripted) {
      print h3('Movies Scripted');
      my @full_names = map { a({-href=&gt;Object2URL($_)},
	                       $_-&gt;Title) } @scripted;
      print ol(li \@full_names);
  }
&#13;  if (my @stars_in = $person-&gt;Stars_in) {
      print h3('Starring Roles In');
      my @full_names = map { a({-href=&gt;Object2URL($_)},
	                       $_-&gt;Title) } @stars_in;
      print ol(li \@full_names);
  }
}
</pre>

  <p>We do the same thing for movies that the <tt>Person</tt> has
  scripted, and for movies that the <tt>Person</tt> has starred in.
  It's left as an exercise to the reader to turn this bit of
  repeated code into a common subroutine.</p>

  <h3>Registering ACEDB Displays</h3>

  <p>The last thing that remains to do is to register "person" and
  "movie" with the AceBrowser object registration system. This
  allows the system to automatically generate the right object
  reference URL when <tt>Object2URL()</tt> is called, and provides
  a navigation bar containing a list of alternative object displays
  when <tt>TypeSelector()</tt> is called. Unfortunately unlike the
  rest of the system, the object registration code is in an
  incomplete state of evolution. Although functional, it is
  unsightly and will be replaced by a more elegant object-oriented
  approach in the near future.</p>

  <p>All object registration information is contained in a
  site-wide file called SiteDefs.pm. In addition to registration
  information, it contains a variety of defaults and user
  preferences. An excerpt of the relevant sections of my site's
  SiteDefs.pm file is given in <a href="tpj0401-0009.html">Listing
  5</a>.</p>
  <pre>
%DATABASES = (
  # deleted stuff...
  'moviedb'     =&gt; {
     host       =&gt; 'localhost',
     port       =&gt; 200008,
     stylesheet =&gt; '/stylesheets/moviedb.css',
     searches   =&gt; [qw(search grep query)],
     url_mapper =&gt; \&amp;movie_mapper,
     displays   =&gt; \%movie_displays,
     title      =&gt; '&lt;center&gt;&lt;span class="banner"&gt;
                   Moviedb Test Database&lt;/span&gt;&lt;/center&gt;',
  },
);
</pre>

  <p>The <tt>%DATABASES</tt> hash contains a list of all the
  databases that should be made visible to the Web interface. Each
  database has a symbolic name, used as the hash key, and an
  anonymous hash containing attributes of the database, used as the
  hash value. In this example we only show a single entry, the
  <i>moviedb</i> database. The anonymous hash contains keys
  describing the host that the database lives on, its port number,
  a stylesheet to use for displaying pages from this database, a
  list of search scripts to be made available for this database,
  and a title to display at the top of each of the pages. There are
  also two keys named <tt>url_mapper</tt> and <tt>displays</tt>
  that tell the system what CGI scripts are to be made available
  for displaying objects fetched from the database.</p>
  <pre>
sub movie_mapper {
    my ($display, $name, $class) = @_;
    my $n = escape($name);
    return ('person' =&gt; "name=$n") if $class eq 'Person';
    return ('movie' =&gt; "name=$n") if $class eq 'Movie';
    # fall through
&#13;    return basic_mapper($display, $name, $class);
}
</pre>

  <p>The <tt>movie_mapper()</tt> subroutine, referred to by the
  <tt>%DATABASES</tt> hash, defines how object links are turned
  into URLs for the <i>moviedb</i> database. The subroutine takes
  three arguments: the name of the current script (e.g.
  <i>tree</i>), the name of the object, and the class of the
  object. It returns two arguments: the URL of the CGI script to
  use to display the object (e.g. <tt>movie</tt>), and the
  URL-escaped arguments to pass to the script. In this case, the
  logic is to turn references to <tt>Person</tt> objects into links
  to a CGI script named <i>person</i>, and similarly to turn
  references to <tt>Movie</tt> objects into links to the
  <i>movie</i> script. Other classes, for example the <tt>Book</tt>
  class, will fall through to the <tt>basic_mapper()</tt> routine,
  which defines the default behavior of using <i>tree</i> and
  <i>pic</i> as the generic displays.</p>
  <pre>
%movie_displays =
     (
     Person =&gt; [
          {'url' =&gt; 'person',
           'label' =&gt; 'Biography',
           'icon' =&gt; '/icons/quill.gif'},
          ],
     Movie =&gt; [
          {'url' =&gt; 'movie',
           'label' =&gt; 'Movie Report',
           'icon' =&gt; '/icons/movie.gif'},
          ],
     );
</pre>

  <p>The last bit of the SiteDefs.pm file defines the alternative
  representations for each object that will be displayed in the
  <tt>TypeSelector()</tt>-generated navigation bar.
  <tt>%movie_displays</tt> is a hash whose keys are object class
  names, and whose values are anonymous arrays containing lists of
  alternative representations. In the simple <i>moviedb</i>
  database, <tt>Person</tt> and <tt>Movie</tt> each have one
  representation; in a more complex application, multiple
  representations can be defined.</p>

  <p>Information about each display is given as a hash in which the
  <tt>url</tt> key indicates the URL to call to display the object,
  <tt>label</tt> indicates a short descriptive string to print on
  the navigation bar, and <tt>icon</tt> gives the URL of the icon
  to display above the label.</p>

  <h3>Conclusions</h3>

  <p>Working with ACEDB is fun and easy because you're working with
  whole objects at a time, not bits and pieces of them. AceBrowser
  allows you to take any ACEDB database and make it browsable
  without writing a line of code, or to create customized data
  reports quickly and easily. The next time you're using DBI to
  fetch one row one at a time from a relational database, pause for
  a moment to reflect. Wouldn't you rather be doing this job the
  genome way?</p>

  <p>__END__</p>
  <hr>

  <p><i>Lincoln D. Stein is the author of CGI.pm.</i></p>
</body>
</html>
