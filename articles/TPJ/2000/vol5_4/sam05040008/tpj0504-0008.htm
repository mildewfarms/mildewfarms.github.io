<html><head><title>Glade</title></head><body bgcolor="ffffff"><h1>Glade </h1><p><b><i>Ace Thompson </i></b><br><span class="date">TPJ Issue #20</span><p><table border="1" cellspacing="0" cellpadding="3" bordercolor="#000000" bgcolor="#cccc99">  <tr>     <td><b>Packages</b></td>    <td>&nbsp;</td>  </tr>  <tr>     <td align="left" valign="top"> Glade </td>    <td valign="top" align="right"> <a href="http://glade.pn.org/" target="_blank">http://glade.pn.org/</a>     </td>  </tr>  <tr>     <td align="left" valign="top">Glade-Perl</td>    <td valign="top" align="right"><a href="http://freespace.virgin.net/dermot.musgrove/computers/perl" target="_blank">http://freespace.virgin.net/dermot.musgrove/computers/perl</a>     </td>  </tr>  <tr>     <td align="left" valign="top">GTK </td>    <td valign="top" align="right"><a href="http://www.gtk.org/" target="_blank">http://www.gtk.org/</a>     </td>  </tr>  <tr>     <td align="left" valign="top">GTK+ Tutorial</td>    <td valign="top" align="right"><a href="http://www.gtk.org/tutorial/gtk_tut.html" target="_blank">http://www.gtk.org/tutorial/gtk_tut.html</a>     </td>  </tr>  <tr>     <td align="left" valign="top">GTK+ Reference</td>    <td valign="top" align="right"><a href="http://developer.gnome.org/doc/API/gtk/" target="_blank">http://developer.gnome.org/doc/API/gtk/</a>     </td>  </tr>  <tr>     <td align="left" valign="top">Gtk-Perl</td>    <td valign="top" align="right">CPAN, <a href="http://projects.prosa.it/gtkperl/" target="_blank">http://projects.prosa.it/gtkperl/</a>     </td>  </tr>  <tr>     <td align="left" valign="top">Gnome</td>    <td valign="top" align="right"><a href="http://www.gnome.org/" target="_blank">http://www.gnome.org/</a>     </td>  </tr></table><p>There once was a time when "Windows" meant Microsoft. Nowadays, if   you don't precede the word with "Microsoft" or "X"   you may unwittingly reveal yourself as out-of-the-know. There are very few Linux   distributions which don't try to start an X session during the installation   process, and the battle over desktop environments (Gnome versus KDE) and GUI   toolkits (GTK+ versus Qt) puts the Cola Wars to shame. </p><p><p>The Unix desktop wars are clearly not limited to the various Linux distributions; the Gnome Project, for example, has gained the support of several large corporations. And it isn't too far-fetched to imagine stable ports of XFree86 and other Unix-y essentials coming to the Microsoft and Apple worlds (think Cygwin and Apple's OS X), opening up the possibility of even more widespread exposure for these desktop environments and the tools and applications that live in them.<p><p>How does this affect Perl developers? Perl has never lacked muscle in the world of back-end tool development, and is often described as the duct-tape of the Internet. On the server side, Perl is considered by many to be the language of choice for web development (look at the hundreds of Apache:: modules), database tools (DBI), text processing, application prototyping, haiku generation, and more. But GUI development?<p><p>What does it mean when the ground Perl sits on most firmly (the Unix world) begins its move to the desktop? In a peek at an increasingly popular area, this article will present one of the options currently available for developers wishing to develop GUIs with Perl on Unix.<p><p><b>GTK+/Gnome</b><p><p><b></b>One of the major players in the Unix desktop game is the Gnome Project, which is now steered by the Gnome Foundation. A Gnome desktop consists of applications built using GTK+ ("Graphical ToolKit"). The Gnome framework also provides other important features such as CORBA services, internationalization, and session management. GTK+ provides the widgets -- buttons, windows, menus, detachable toolbars, and so on -- which, when assembled properly, create the user experience.<p><p>There are also several Gnome widgets, many composed of multiple GTK+ widgets, which provide a common cross-application interface for basic tasks. For example, there's a "Gnome Number Entry" widget for entering numbers, a "Gnome File Entry" to let users select files, and a "Gnome About Dialog" which provides a standard format for "About" dialogs.<p><p>These types of widgets save time for developers, providing built-in functionality for basic tasks in addition to creating a common and convenient user experience across applications. For example, the "Gnome Number Entry" widget allows the user to either enter a number manually or to bring up a calculator for complex calculations, <br>all without a single line of code by the programmer. Similarly, the "Gnome File Entry" dialog lets users browse their filesystems to choose a file. These types of widgets make life much easier for developers as well as shortening the learning curve as users move from one Gnome application to another.<p><p><b>Perl and GTK+/Gnome</b><p><p>There are several tools which bring Perl to the world of GUI development on   the Gnome desktop. The most important are the Perl bindings to the GTK+ library.   The Perl GTK+ bindings, known collectively as Gtk-Perl, are currently maintained   by Paolo Molaro and are available on CPAN or at the Gtk-Perl homepage (<a href="http://projects.prosa.it/gtkperl/" target="_blank">http://projects.prosa.it/gtkperl/</a>).<p><p>Gtk-Perl allows you to create widgets and respond to user input in a fashion similar to Perl/Tk and Perl-Qt. Using Gtk-Perl alone, however, forces you to manage the creation and arrangement of widgets in your code. Not only is this time-consuming and prone to error, it can also be an obstacle in creating medium- to large-sized applications, because the functionality of your application gets mixed up with the definition of the user interface, one of the first no-no's in good GUI design.<p><b>Glade</b><p><p>Luckily, we have Glade. Glade is a free user interface builder for GTK+ and   Gnome, available at <a href="http://glade.pn.org" target="_blank">http://glade.pn.org</a>.   Glade doesn't force a language upon you: as of this writing, Glade applications   can be designed with C, C++, Ada95, Python, or Perl.<p><p>Glade simply defines the arrangement of the graphical widgets making up your application and stores this definition as XML. Then special code in your language of choice reads this definition, and using the GTK+/Gnome bindings in that language, puts together the interface when your application launches. Your code, and the main GTK+ user event handler, do the rest.<p><p> In the case of Perl, the "special code" gluing Glade and Perl together is   creatively named "Glade-Perl" and was developed by Dermot Musgrove. It is available   on CPAN or at <a href="http://freespace.virgin.net/dermot.musgrove/computers/perl" target="_blank">http://freespace.virgin.net/dermot.musgrove/computers/perl</a>.<p><p>So, to summarize:<p><blockquote>  <p> Gnome: a graphical user environment</p>  <p> GTK: GUI library used by Gnome</p>  <p> Glade: graphical interface designer for GTK applications</p>  <p> Perl: a language that can implement a Glade-designed interface</p></blockquote><p><p><b>Installation</b><p><p><b></b>Setting up the Glade-Perl development environment is fairly simple.<p><p> First, you must have a Gnome desktop running. Most Linux distributions include   an option to install Gnome. If you don't want to go through a fresh Linux installation,   you can go to the Gnome Project website (<a href="http://www.gnome.org" target="_blank">http://www.gnome.org</a>)   and find installation information there. Helix Code (<a href="http://www.helixcode.com" target="_blank">http://www.helixcode.com</a>)   also provides an easy Gnome installation.<p><p>The current version of Glade-Perl (0.57) requires gnome-libs 1.2.4 and GTK+ 1.2.7. You can find out which version of gnome-libs you have by typing gnome-config --version at a shell prompt. You can find out which version of GTK+ you have by typing gtk-config --version at a shell prompt.<p><p> Second, you must download and install the most recent version of Glade from   <a href="http://glade.pn.org/" target="_blank">http://glade.pn.org/</a>.<p><p> Finally, you should install the most recent versions of Glade-Perl and XML::Parser   from CPAN. You should get the latest version of Gtk-Perl (currently 0.7004)   from the Gtk-Perl homepage (<a href="http://projects.prosa.it/gtkperl/" target="_blank">http://projects.prosa.it/gtkperl/</a>).<p><b>Designing an interface</b><p> Putting together a user interface in Glade is easy. Start Glade, and look at the Palette Window, shown in <a href="tpj0504-0008_f1.htm" target="_blank">Figure 1</a>. This window displays the various widgets you can use in your application. The widgets are grouped into various categories (more categories and widgets can be added to the palette as well; for example, if you install gnome-db, the Gnome database connectivity package, you can include gnome-db widgets in your application). <p><p> Gnome applications typically start with a Gnome Application Window. You can   find this widget under the "Gnome" tab in the Palette Window. When you create   this widget, Glade gives it the name "app1". We'll use this name later.<p><p> The Gnome Application Window is a window containing a standard menu bar, toolbar,   and status line; it is an effort to give all Gnome applications a standard look   and feel, and is depicted in <a href="tpj0504-0008_f2.htm" target="_blank">Figure   2</a>. <p><p><b>Adding code</b><p><p><b></b>Of course, having a standard look and feel doesn't do you much good if the buttons don't do anything.<p><p>As an illustration, we will attach some code to the "New" button. To do this,   first click on the "New" button in the Gnome application window you created.   Then go to Glade's "Properties" window and select the "Signals" tab, shown in   <a href="tpj0504-0008_f3.htm" target="_blank">Figure 3</a>.   Signals connect your code to user interface events (button clicks, list selections,   mouse movements, and so on). <p><p> Every widget has a set of signals which it emits if and when the user interacts   with it. Clicking on the ellipsis (...) next to the "Signal" input box provides   a list of the signals our "New" button can emit (<a href="tpj0504-0008_f4.htm" target="_blank">Figure   4</a>). Select "clicked", press "Ok" and, returning to the "Properties" window,   click the "Add" button (<a href="tpj0504-0008_f5.htm" target="_blank">Figure   5</a>).<p><p> We want a Perl subroutine to be called when our button is clicked. This subroutine   is called a <i>signal handler</i>, and Glade automatically gave ours a name:   <code>on_button1_clicked()</code>. But where do we put this subroutine? As always   in Perl, There's More Than One Way To Do It. See "Writing the signal handler   code" below for our approach.<p><p><b>Saving and building the project</b><p><p><b> </b>Now we will save and build our new project. First, click the "Save"   button in the main Glade window. The first time you save a project, you are   given a "Project Options" window where you can set the name of your project   (it should say <code>Project1</code>) as well as the language you wish to have   it built in (<a href="tpj0504-0008_f6.htm" target="_blank">Figure 6</a>). Select Perl   as your language and click "Ok". <p><p>Now click the "Build" button in the main Glade window. The source code for your application will be written to the directory specified in the "Source Directory" input on the "Project Options" window.<p><p><b>Writing the signal handler code</b><p><p><b></b>There are several methods by which you can add signal handlers to your application. Remember that signal handlers are the Perl subroutines which respond to GUI events, like mouse clicks or cursor movements. In our example application we have specified that we wish to invoke a subroutine when a user clicks on the "New" button.<p><p> Glade writes several files to the source code directory. The names of the   files are based on the project name specified in the "Project Options" window   (<a href="tpj0504-0008_f6.htm" target="_blank">Figure 6</a>). <code>Project1UI.pm</code>   is a module used by the other modules to build the user interface; you generally   won't have to modify this code. <code>Project1SIGS.pm</code> contains stub routines   for the application's signal handlers. <p><p> Most of the time you will copy the stubs to another file and fill them in   with your signal handler code. As a convenience, Glade-Perl creates such a file   the first time you build your project. This file is <code>Project1.pm</code>.   Open it and locate the signal handler stub that Glade created for the "New"   button; remember that it is called <code>on_button1_clicked()</code>. Modify   that subroutine so that it looks like this:<p><pre>  sub on_button1_clicked {      my ($class, $data, $object, $instance, $event) = @_;      my $me = __PACKAGE__ . "-&gt;on_button1_clicked";      # Get ref to hash of all widgets on our form      my $form = $__PACKAGE__::all_forms-&gt;{$instance};      # We will display a message box to the user.      my $button_pressed = Gnome::MessageBox-&gt;new(         "New What?",	# the message         "question",	# the message type         "New Car",	# the button labels...         "New House",         "Never Mind"      )-&gt;run();	  } # End of sub on_button1_clicked</pre><p> Now we just need to run our application. In the project directory (see the   "Project Directory" option in the "Project Options" window, shown in <a href="tpj0504-0008_f6.htm" target="_blank">Figure   6</a>), create a file called <code>app.pl</code>:<p><pre>    #!/usr/bin/perl    # app.pl        use lib qw(./src);    use Project1;        app_run app1;</pre><p> <code>Project1.pm</code> is the module we just added our signal handler to.   We have to <code>use</code> <code>lib</code>, the recommended method of altering   <code>@INC</code>, to tell Perl where to find this module. As explained above,   Glade writes this file to the "Source Directory" specified in the "Project Options"   window (<a href="tpj0504-0008_f6.htm" target="_blank">Figure 6</a>). Since we are running   app.pl in the parent directory of the "Source Directory", we provide use lib   with a relative directory reference (<code>qw(./src)</code>).<p><p> <code>app1</code> is a package defined in <code>Project1.pm</code>. You will   recall that our Gnome Application Window was given the name <code>app1</code>.   The <code>app1</code> package is thus a Perl class representing the Gnome Application   Window we created.<p> <p><code> app_run()</code> is a class method defined for the app1 class, created   by Glade-Perl. Running this class method has the effect of initializing our   Gnome application, creating a new instance of the <code>app1</code> class, showing   it to the user, and entering the main GTK+/Gnome event loop.<p><p>The GTK+ event loop handles user interactions, handing off processing to our signal handler subroutines if the user does anything to trigger one of those signals.<p><p> Execute the <code>app.pl</code> script from a shell prompt:<p><pre>  perl app.pl</pre><p> Clicking the "New" button, we see the fruits of our signal-handling labors   in <a href="tpj0504-0008_f7.htm" target="_blank">Figure 7</a>. What is remarkable is   that we have written only four lines of code: one to fill in the stub of our   signal handler, and three to start up the application. Filling in a signal handler   to make "File-&gt;Exit" quit the application is left as an exercise to the reader   (hint: use the method <code>Gtk-&gt;main_quit()</code>).<p><p><b>Inheritance as a GUI development tool</b><p><p><b> </b>Now we will see how class inheritance can make our life as a GUI developer   easier. Using Glade's Palette Window, create a "Gnome Dialog Box" and fill it   in with widgets as demonstrated in <a href="tpj0504-0008_f8.htm" target="_blank">Figure   8</a>. Name the dialog box <code>dialog_details</code> and name the combo boxes   <code>combo_model</code> and <code>combo_color</code> respectively (hint: the   Table widget greatly simplifies layout).<p><p>The problem is simple. If a user wants a new car, we'd like to ask the user for details on which new car they want. If the user wants a new house, on the other hand, we want to provide them with choices appropriate for a new house. But designing two different dialog boxes which differ only in their combo box options seems like overkill; in addition, what if we want the choices to come from a database or some other external data source? A better approach would be to separate the design of the interface from the specific options themselves.<p><p> To do this, we'll create two classes which inherit from the <code>dialog_details</code>   class. Each will override the object constructor, filling in the combo boxes   with options appropriate for its class. For simplicity, we'll put the class   definitions in <code>app.pl</code>:<p><pre>  #!/usr/bin/perl  # app.pl  use lib qw(./src);  use Project1;  # Class definition for the "New Car Details" window  package Car_Details;  use vars qw(@ISA);  @ISA = qw(dialog_details);  my @models = qw(Audi Ford Honda Toyota);  my @colors = qw(Blue Green Red Watermelon);  sub new {      my $class = shift;      my $self = bless $class-&gt;SUPER::new(), $class;      $self-&gt;TOPLEVEL-&gt;title('New Car Details');      $self-&gt;FORM-&gt;{'combo_model'}-&gt;set_popdown_strings(@models);      $self-&gt;FORM-&gt;{'combo_color'}-&gt;set_popdown_strings(@colors);      return $self;  }  # Class definition for the "New House Details" window  package House_Details;  use vars qw(@ISA);  @ISA = qw(dialog_details);  my @models = qw(Mobile Ranch Suburban Victorian);  my @colors = qw(Brick Brown Red White);  sub new {      my $class = shift;      my $self = bless $class-&gt;SUPER::new(), $class;      $self-&gt;TOPLEVEL-&gt;title('New House Details');      $self-&gt;FORM-&gt;{'combo_model'}-&gt;set_popdown_strings(@models);      $self-&gt;FORM-&gt;{'combo_color'}-&gt;set_popdown_strings(@colors);      return $self;  }  package main;  app_run app1;</pre><p> We have created two new classes: <code>Car_Details</code> and <code>House_Details</code>.   Each of these inherits from <code>dialog_details</code>, the class Glade-Perl   created for us corresponding to the <code>Details</code> window (<a href="tpj0504-0008_f8.htm" target="_blank">Figure   8</a>). They override the new method (the constructor) inherited from <code>dialog_details</code>.   The new <code>new</code> first calls the inherited new, thus obtaining a valid   object reference for the "Details" window being created. It then sets the appropriate   window title and combo box options.<p><p> Now we must modify our "New" button signal handler to load up the appropriate   "Details" window in response to the user input. Remember that this signal handler   is in <code>Project1.pm</code>. Modify <code>on_button1_clicked()</code> as   follows:<p><pre>  sub on_button1_clicked {      my ($class, $data, $object, $instance, $event) = @_;      my $me = __PACKAGE__ . "-&gt;on_button1_clicked";      # Get ref to hash of all widgets on our form      my $form = $__PACKAGE__::all_forms-&gt;{$instance};      # We will display a message box to the user.      my $button_pressed = Gnome::MessageBox-&gt;new(             "New What?",    # the message         "question",     # the message type         "New Car",      # the button labels...         "New House",          "Never Mind"      )-&gt;run();      # $button_pressed is the 0-based index of the button      # pressed.  I.E. 0 = "New Car", 1 = "New House",       # 2 = "Never Mind".       # Stop if user pressed "Never Mind".      return if $button_pressed == 2;      # Create details window based on user response.      my $details = undef;      $details = Car_Details-&gt;new()if $button_pressed == 0;      $details = House_Details-&gt;new()if $button_pressed == 1;      # Display the details window, hiding it      # when the user is done choosing.      $details-&gt;TOPLEVEL-&gt;run_and_close();        Gnome::MessageBox-&gt;new(          "You are using free software! " .          "You obviously can't afford that model!",          "info",          "Ok"        )-&gt;run();                  } # End of sub on_button1_clicked</pre><p> By virtue of being an instance of one of our two inherited classes, the window   referenced by <code>$details</code> has combo box options appropriate to the   user response (<a href="tpj0504-0008_f9.htm" target="_blank">Figure 9</a>). Since <code>$details</code>   inherits from <code>dialog_details</code>, the <code>TOPLEVEL()</code> method   is available. This method returns the top-level widget corresponding to that   class, in this case a Gnome::Dialog widget which in turn implements the <code>run_and_close()</code>   method.<p><p><b>Further exploration</b><p><p><b></b>With just a few clicks of the mouse and a little organization we have laid out an extensible framework for a new application. We even used Perl's OO features to provide the framework for clean GUI development. Perl is already known as a rapid development language; combining it with a tool like Glade enables lightning-fast GUI application development.<p><p>As is often mentioned on the perl5-porters mailing list, most every problem domain Perl is brought into quickly becomes a Simple Matter of Programming, or SMOP. GUI development is no different, and Glade fulfills the exciting potential of bringing Perl and SMOP to the desktop.<p><p><b>More Information</b><p><p>For an introduction to using Gnome and Perl together, read Simon Cozens' excellent   article at <a href="http://www.perl.com/pub/2000/%2010/gnome.html" target="_blank">http://www.perl.com/pub/2000/   10/gnome.html</a>.<p><p> An invaluable resource in working with Gtk-Perl is the tutorial written by   Stephen Wilhelm, available at <a href="http://personal.riverusers.com/%7Eswilhelm/gtkperl-tutorial/" target="_blank">http://personal.riverusers.com/~swilhelm/gtkperl-tutorial/</a>.<p><p>For information on object-oriented Perl, read the definitive book of the same name by Damian Conway.<p><p><i>_ _END_ _</i><p><p> <i>Ace is known for his mindless fixation on shiny objects. You can almost   reach him at </i><a href="mailto:acethompson@yahoo.com">acethompson@yahoo.com</a>.</body></html>