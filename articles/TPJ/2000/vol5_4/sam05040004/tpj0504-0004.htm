<html><head><title>Developing Wireless Applications </title></head><body bgcolor="ffffff"><h1>Developing Wireless Applications </h1><i>Dan Brian</i><br><span class="date">TPJ Issue #20</span><p><table border="1" cellspacing="0" cellpadding="1" bgcolor="#cccc99" bordercolor="#000000">  <tr align="left" valign="top">     <td><b>Utilities       <p>       </b></td>    <td align="right">&nbsp;</td>  </tr>  <tr align="left" valign="top">     <td>UP Browser </td>    <td align="right"><a href="http://www.phone.com/developers/index.html" target="_blank">http://www.phone.com/developers/index.html</a></td>  </tr>  <tr align="left" valign="top">     <td>HTML::Mason </td>    <td align="right">CPAN, <a href="http://www.masonhq.com" target="_blank">http://www.masonhq.com</a></td>  </tr>  <tr align="left" valign="top">     <td>CGI::WML </td>    <td align="right">CPAN</td>  </tr>  <tr align="left" valign="top">     <td>Apache::WAP::AutoIndex </td>    <td align="right">CPAN</td>  </tr>  <tr align="left" valign="top">     <td>Apache::WAP::MailPeek </td>    <td align="right">CPAN</td>  </tr>  <tr align="left" valign="top">     <td>Mail::Cclient </td>    <td align="right">CPAN</td>  </tr></table><p>Mobility! In my day we had to pick up the phone and put it on the acoustic   modem. Now you can get stuff any time, anywhere. These kids... </p><p><p>I bought a new mobile phone with wireless Internet not long ago. The prospect of tracking news headlines, stock prices, and checking email over the phone seemed appealing. But after only a few minutes of browsing, I felt disappointed. Navigation was cumbersome, the viewscreen very small, and most frustrating of all, it took a really long time to get all the information I wanted. I read a bit more about the various portals that consolidate data from various sources, but after using one of them, I realized that no existing service would give me the variety of content I wanted. Besides, I've never much liked the idea of my username, passwords, and messages passing through someone else's servers. And this was about the same time I read the fine print on my service contract, explaining that I was paying for talk-time whenever I used my wireless Internet access.<p><p>In this article, I'll explore application development for wireless devices, first providing an overview of the WAP (Wireless Application Protocol) architecture, and then introducing some Perl modules to help create WAP applications.<p><p><b>A quick look at WAP<p></b><p><b></b>Wireless web browsers are the embodiment of a dominant trend in modern information technology. This trend is to equate "client" with "accessor", and "server" with "provider". While that definition might apply to most network applications, it has one of its simplest models in WAP, where dynamic functionality is best executed at the server, and no data is typically stored at the client. (Granted, you <i>can</i>, if youy try hard enough, use cookies with wireless devices, but such processing is interface-centric, like client-side JavaScript. Furthermore, support for such features is inconsistent.) This paradigm shift from client-distributed computing is evidenced by the popularity of personalized "my-" portals, web-based messaging, centralized file storage services, and the porting of major applications to the web.<p><p>WAP (Wireless Application Protocol) is a communications standard that includes markup, session, transaction, security, and transport application layers. These standards are maintained by the WAP Forum, founded by Ericsson, Nokia, Motorola, and Phone.com. (Phone.com was originally Unwired Planet, the company that pioneered wireless Internet services in the mid-1990s. Consequently, most of the browsers within modern phones run the Phone.com software.) Although the WAP Forum is currently working on version 1.3 of the specifications, most phones currently support only version 1.1.<p><p> The basics of WAP architecture are shown in <a href="tpj0504-0004_f1.htm">Figure   1</a>. An application server on the Internet receives WAP requests and responds   with data (typically WML documents), sent over the Internet between the application   server and a WAP gateway. The gateway routes and translates WAP requests to   HTTP requests, determining what WAP data gets sent over a wireless network to   a communications tower and eventually to your phone.<p><p><b>Enabling WAP on Apache<p></b><p>Thanks to the WAP gateway, any web server can deliver WML-formatted documents   over HTTP by simply adding them to the MIME types for the server. In the case   of Apache, you can add the following to an <code>.htaccess</code> file to WAP-enable   the server. (Most newer Apache servers already have these types in their <code>mime.types</code>   file):<p><pre>    addtype text/vnd.wap.wml	wml    addtype text/vnd.wap.wmlscript	wmls    addtype application/vnd.wap.wmlc	wmlc    addtype application/vnd.wap.wmlscriptc	wmlsc    addtype image/vnd.wap.wbmp	wbmp</pre>When a wireless user wants to visit your site, they enter the URL. Unless you want to require your visitors to type .wml after a request, Apache will usually serve up an HTML document by default. To remedy this situation, we could use Apache's mod_rewrite engine to rewrite every request for an <code>.html</code> file to look for a <code>.wml</code> file in the same directory.<sup><a href="#1">1</a></sup> Again, since the WAP gateway supports HTTP headers, we can do this easily by adding the following to httpd.conf. Additional <code>HTTP_USER_AGENT</code> entries would need to be added, since this one will only rewrite Phone.com's UP.Browser client: <p><pre>    RewriteEngine on    RewriteLog logs/rewrite    RewriteLogLevel 9    RewriteCond %{HTTP_USER_AGENT} UP\.Browser    RewriteRule ^(.+)\.html$ $1.wml</pre>There is another option, which makes use of Apache's HTTP_ACCEPT variable to list the MIME types that the connecting browser supports. However, most WAP clients report the ability to accept responses of type text/html, even though they lack the ability to translate the data. <br>A better option is to determine if the connecting browser supports WML, since most HTTP browsers cannot <br>read WML.<p><pre>    RewriteCond %{HTTP_ACCEPT} text\/vnd\.wap\.wml</pre>Of course, to serve any dynamic content will require a bit more work. Before delving into that, let's look a bit at WML.<p><p><b>WML basics<p></b><p><b></b>WML (Wireless Markup Language) is a standard set of XML tags for the display of documents on mobile devices. Similar in function to HTML, these tags allow content to be formatted and linked. But given the limitations of wireless displays, the feature set is much more limited than HTML. And this is a good thing.<p><p>Since it is XML, WML requires strict formatting. Any errors in the markup, such as unterminated paragraph tags (&lt;p&gt;&lt;/p&gt;) should cause a client to return an error. (So long as we're talking about them, note that <i>all</i> text content must be within paragraph tags.) XML is usually explained to novices as the opposite of display data: rather than containing information about the formatting of data, as in HTML, XML contains information about the data itself: its structure, interrelation, and organization. WML would seem to be an exception -- but when it comes to wireless applications, the appearance of the data and its structure become intertwined.<p><p>A simple WML document is shown below. If you aren't familiar with XML, all you need to know about the document header is that it occurs within every WML document, and provides a data type definition for the client parsing the code. This header will only change if documents use different versions of WAP. Most do not.<p><pre>&lt;?xml version="1.0"?&gt;&lt;!DOCTYPE wml PUBLIC "-//WAPFORUM//DTD WML 1.1//EN"  "http://www.wapforum.org/DTD/wml_1.1.xml"&gt;&lt;wml&gt;  &lt;card id="main" title="First Example"&gt;    &lt;p&gt;      Hello WAP World!    &lt;/p&gt;  &lt;/card&gt;&lt;/wml&gt;</pre><table border="0" cellspacing="0" cellpadding="1" align="right">  <tr>    <td align="center"><b>Figure 2<br>      </b><img src="tpj0504-0004_f2.gif" width="175" height="138" vspace="5" hspace="5"></td>  </tr></table><p><br>  When saved as <code>hello.wml</code> in a web server directory and requested   from a wireless client, it will display what's shown in Figure 2. <p><p> If our web server enabled rewrites using the <code>httpd.conf</code> directives   shown earlier, this document could be requested as <code>hello.html</code>,   and still produce the desired result.<p><p>There are many tools you can use to develop wireless applications. The screenshots in this article are taken from Phone.com's Up.Simulator program, which allows you to browse the wireless web without using your phone (or the precious minutes you pay for if you share my service plan). Keep in mind that no two wireless browsers are identical. Although there are far fewer hornet's nests in the nested tags of WML than there are for HTML, there is no real consolation here for those craving a "write-once, read-the-same-everywhere" environment. But it is a standard that is adhered to between enterprises, if not functionally, at least syntactically.  (Are you out there, XHTML?)<p><p><b>You got to know when to fold 'em<p></b><p><b> </b>Latency is a bigger issue for WAP than for HTTP, since the system architecture   itself is a many-hop, many-protocol network. In part to address the problem   of delivery time, but also to fit markup to the WAP model, WAP applications   don't use pages as they exist on the web. Instead, WAP has <i>cards</i>, where   a card is simply what is displayed on a device at any given time. A single WML   document might contain many cards. A collection of cards within a document is   referred to as a <i>deck</i>, and can be explained as many analogous web pages   folded into a single document with hyperlinks between the cards. The following   example shows a WML document containing three cards and a menu to navigate between   them, defined in the <code>&lt;template&gt;&lt;/template&gt;</code> element.<p><pre>&lt;?xml version="1.0" encoding="iso-8859-1"?&gt;&lt;!DOCTYPE wml PUBLIC "-//WAPFORUM//DTD WML 1.1//EN"                "http://www.wapforum.org/DTD/wml_1.1.xml"&gt;&lt;wml&gt;  &lt;template&gt;    &lt;do type="accept" label="Back"&gt;      &lt;prev/&gt;    &lt;/do&gt;    &lt;do type="accept" label="Football"&gt;      &lt;go href="#football"/&gt;    &lt;/do&gt;    &lt;do type="accept" label="Basketball"&gt;      &lt;go href="#basketball"/&gt;    &lt;/do&gt;  &lt;/template&gt;  &lt;card id="main" title="Main"&gt;    &lt;p&gt;      Use the option menu to find sports scores.    &lt;/p&gt;  &lt;/card&gt;  &lt;card id="football" title="football"&gt;    &lt;p&gt;      Saints &lt;b&gt;31&lt;/b&gt;, Rams &lt;b&gt;24&lt;/b&gt;&lt;br/&gt;      Chargers &lt;b&gt;17&lt;/b&gt;, Chiefs &lt;b&gt;16&lt;/b&gt;&lt;br/&gt;      Eagles &lt;b&gt;23&lt;/b&gt;, Redskins &lt;b&gt;20&lt;/b&gt;&lt;br/&gt;    &lt;/p&gt;  &lt;/card&gt;  &lt;card id="basketball" title="Basketball"&gt;    &lt;p&gt;      Lakers &lt;b&gt;102&lt;/b&gt;, Clippers &lt;b&gt;98&lt;/b&gt;&lt;br/&gt;      Timberwolves &lt;b&gt;88&lt;/b&gt;, Magic &lt;b&gt;87&lt;/b&gt;&lt;br/&gt;    &lt;/p&gt;  &lt;/card&gt;&lt;/wml&gt;</pre><table border="0" cellspacing="0" cellpadding="5" align="right">  <tr>    <td align="center" valign="top"><b>Figure 3</b><br>      <img src="tpj0504-0004_f3.gif" vspace="5" width="175" height="138" hspace="5">     </td>  </tr>  <tr>    <td align="center" valign="top"><b>Figure 4</b><br>      <img src="tpj0504-0004_f4.gif" width="175" height="138" vspace="5" hspace="5">     </td>  </tr>  <tr>    <td align="center" valign="top"><b>Figure 5</b><br>      <img src="tpj0504-0004_f5.gif" vspace="5" width="175" height="138" hspace="5"></td>  </tr></table><p>  I won't touch on the markup here much, other than to explain that the <code>&lt;do/&gt;</code>   tags specify an options menu to be displayed when the "Options" button on a   phone is selected. Note that the href links specify a link within the local   document, prefixed with the #. (These links could also be fully-qualified URLs   to non-local cards.) Also, the <code>&lt;template&gt;</code> tags enclose data   that will be applied to every card in the deck, saving space. Initially, this   doc-ument will display the screen shown in Figure 3. <p><p>Pushing the button beneath "Menu" will bring up <br>  the <code>&lt;do/&gt;</code> option menu, enclosed in the <code>&lt;template/&gt;</code>   element and dis-played in Figure 4.<p><p> Selecting the "Football" option from the list will take us to the card labeled   <code>football</code> and displayed in Figure 5.<p><p>A set of cards organized into a tree can collect many pages of data before sending a network request back to the web server, resulting in quicker WAP applications.<p><p> WML has other features intended to eliminate costly round-trips between mobile   devices and WAP application servers. For example, WML has a <code>&lt;select/&gt;</code>   element that is much more functional than its HTML cousin, with <code>&lt;option/&gt;</code>   elements that may contain events to handle a given selection. For example:<p><pre>    &lt;card id="products" title="Products"&gt;      &lt;p&gt;        &lt;select title="Flavors"&gt;          &lt;option onpick="#vanilla"&gt;Vanilla&lt;/option&gt;          &lt;option onpick="#chocolate"&gt;Chocolate&lt;/option&gt;        &lt;/select&gt;        &lt;do type="accept" label="Go"&gt;          &lt;noop/&gt;        &lt;/do&gt;      &lt;/p&gt;    &lt;/card&gt;</pre><p>In this example, selecting an option from the <code>&lt;select&gt;</code> menu   loads a different card from the deck, without another trip to the server and   back.<p><p>Variables are another part of the core WML specification, and use a familiar syntax:<p><pre>    &lt;setvar name="phone" value="432-0911"&gt;    &lt;p&gt;      Call me at $phone.    &lt;/p&gt;</pre><p> Variables can even be used within select lists to carry variables between   cards, much the same way as the HTML <code>&lt;input type="hidden"&gt;</code>   tag is often used to make data persistent across requests.<p><pre>    &lt;select title="products" name="product"&gt;      &lt;option value="Model B"&gt;Model B&lt;/option&gt;      &lt;option value="Model D"&gt;Model D&lt;/option&gt;    &lt;/select&gt;</pre><p>A subsequent card can then use the selected value, stored in $product:<p><pre>    Are you <b>sure</b> you want to buy a $(product) Steinway?&lt;br/&gt;</pre><p> And finally, variables can be posted to a server using the WML <code>&lt;go/&gt;</code>   elements with <code>&lt;postfield/&gt;</code> tags, placed inside an <code>&lt;anchor/&gt;</code>   element in order to link responses of "Yes" or "No" to their appropriate locations:<sup><a href="#2">2</a></sup> <p><pre>    &lt;anchor&gt;      Yes      &lt;go method="post"href="http://www.mypianostore.com/buy.cgi"&gt;        &lt;postfield name="product" value="$(product)"/&gt;      &lt;/go&gt;    &lt;/anchor&gt;    &lt;anchor&gt;       &lt;go href="#products"/&gt;       No    &lt;/anchor&gt;</pre><p>For a comprehensive look at WML, I recommend the new O'Reilly text <i>Learning WML &amp; WMLScript</i> by Martin Frost. Wrox's <i>Professional WAP</i> contains more information on general mobile phone development (beyond WML), but is not as concise a read as the Frost book, probably due to the many-author model that Wrox seems to favor.<p><p><b>Developing WAP applications<p></b><p><b></b>Typically, the purpose of a display markup language is to enhance the appearance of data, sometimes to a fault. This is true of WML. However, the simplicity of wireless displays demands that the formatting of display elements be basic and straightforward. For this reason, it is generally not too much work to develop an entire WAP site using a simple text editor. Introducing dynamic content into a document, however, presents many breeds of challenges. With HTML, creating dynamic content usually means adding one type of markup to another; for instance, adding Perl or PHP "programmatic markup" to the conventional display markup. An alternative solution is to print the HTML directly from a program either by embedding HTML within the program code, or by calling functions that create the interface themselves, much as CGI.pm's printing functions automate the creation of HTML. A third approach is a total separation of content (such as XML) from interface (such as HTML/CSS or XSL), with application data stored elsewhere.<p><p> I won't argue here for a particular model. As is the case with HTML, each   has its own strengths for WML development. Because of the simplicity of WML,   display code generally represents a smaller portion of the total application   than with HTML development. On the other hand, WML's notion of cards moves much   of the application logic to the interface, simplifying the server. In the case   of using XML with XSL to generate WML, there are serious issues of complexity   and overhead, especially considering the limited information being generated.&lt;sup&gt;<a href="#3">3</a>&lt;/sup&gt;   There are many such considerations to be made when choosing a design model for   WAP applications. For the remainder of this article, I'll explore three styles   of WML generation: using the CGI::WML module to automate the creation of WML,   marking up WML with Perl using a web development kit like Mason, and embedding   WML directly within Perl programs. I'll show examples of each.<p><p><b>CGI::WML<p></b><p><b></b>If you ever shied away from using CGI.pm's printing functions, you probably justified it because of the complexity of your HTML. No such excuse can be made when delivering WML. The CGI::WML module, by Angus Wood, subclasses Stein's CGI.pm to give users a familiar interface to WML programming. All of the input parameter processing functions remain, as well as new functions to help you create WML documents:<p><pre>use CGI::WML;$cgi = new CGI::WML;print   $cgi-&gt;header(),   $cgi-&gt;start_wml(),   $cgi-&gt;template(-content=&gt;$cgi-&gt;prev()),   $cgi-&gt;card(-id=&gt;"first_card",            -title=&gt;"First card",   -content=&gt;"&lt;p&gt;&lt;b&gt;No one&lt;/b&gt; when he has got &lt;i&gt;sufficient&lt;/i&gt; ".     "furniture for his house &lt;b&gt;dreams&lt;/b&gt; of making further ".     "purchases on this head, but of silver no one &lt;i&gt;ever&lt;/i&gt; ".     "yet possessed so much that he was forced to cry ".                "\"enough.\"&lt;/p&gt;"),   $cgi-&gt;end_wml(); </pre><p>This example displays:<p><pre>Content-Type: text/vnd.wap.wml; charset=ISO-8859-1&lt;?xml version="1.0" encoding="iso-8859-1"?&gt;&lt;!DOCTYPE wml PUBLIC "-//WAPFORUM//DTD WML 1.1//EN"                    "http://www.wapforum.org/DTD/wml_1.1.xml"&gt;&lt;wml&gt;  &lt;template&gt;    &lt;do type="accept" label="Back"&gt;      &lt;prev/&gt;    &lt;/do&gt;  &lt;/template&gt;  &lt;card id="first_card" title="First card" &gt;    &lt;p&gt;&lt;b&gt;No one&lt;/b&gt; when he has got &lt;i&gt;sufficient&lt;/i&gt; furniture for his house &lt;b&gt;dreams&lt;/b&gt; of making further purchases on this head, but of silver no one &lt;i&gt;ever&lt;/i&gt;          yet possessed so much that he was forced to cry "enough."&lt;/p&gt;  &lt;/card&gt;&lt;/wml&gt;</pre><p><table border="0" cellspacing="0" cellpadding="1" align="right">  <tr>     <td align="center" valign="top"><b>Figure 6<br>      <img src="tpj0504-0004_f6.gif" width="175" height="138" vspace="5" hspace="5"></b></td>  </tr></table><p>The result is shown in Figure 6. <p><p> (For those interested, the text is from "On Revenues" by Xenophon. Good stuff.   Emphasis mine.)<p>  The CGI::WML module also has functions for automated HTML-to-WML conversion   and WML-to-WMLC conversion. WMLC documents compress deck content for quicker   delivery, a task usually performed by a WAP gateway. WMLC conversion is also   useful for testing the size of a compiled WML deck, since most WAP browsers   have a maximum compiled deck size around 2000 bytes. Using the <code>wml_to_wmlc()</code>   function, you can continually check what size your deck will be after it has   passed through the WAP gateway: <p><pre>  if (length($cgi-&gt;wml_to_wmlc($wml)) &gt; 2000) {      # do something  }</pre><p>For the moment, CGI::WML lacks functions to automate the creation of many WML 1.1 elements, including option menus and variables. These will be added in a future version, according to Wood.<p><p><b>A small file browser with CGI::WML and mod_perl<p></b><p><b></b>To use CGI::WML within an application, we'll write a short file browser. Often, when an HTTP browser accesses a web server directory without an index file, Apache's mod_autoindex module generates a file list. WAP browsers can't display a listing unless the WAP gateway being used is translating HTML responses, which is unlikely. We'll write a very basic module to provide this capability.<p><p> To start, we need a way for our module to know whether to handle this request.   In a production environment, we'd want to determine if the requesting browser   was a WAP client, as well as look for any index files within that directory   prior to handling the request. Look at the Apache::AutoIndex module for code   to perform such tasks. For now, we're going to treat any incoming request that   ends in <code>filelist.wml</code> as a directory request. Here's the module:<p><pre>    package Apache::WAP::AutoIndex;    use strict;    use CGI::WML;    use Apache::Constants qw(:common);    sub handler {        my $r = shift;        my $cgi = new CGI::WML;        my $filename     = $r-&gt;filename;        my $url_filename = $r-&gt;uri;        $filename     =~ s/filelist\.wml$//;        $url_filename =~ s/filelist\.wml$//;        unless (opendir DH, $filename) { return FORBIDDEN; }        my $content = "&lt;p&gt;Directory $url_filename:&lt;br/&gt;";        my $filelink;        foreach my $file ( readdir DH ){            if (-d "$filename/$file")                 { $file .= "/"; $filelink = $file . "filelist.wml"; }            else { $filelink = $file; }            $content .= CGI::a({href =&gt; "$filelink"}, "$file");        }        $content .= "&lt;/p&gt;";        close DH;        $r-&gt;print( $cgi-&gt;header(),              $cgi-&gt;start_wml(),              $cgi-&gt;template(-content=&gt;$cgi-&gt;prev()),              $cgi-&gt;card(-id=&gt;"dirlist",                     -title=&gt;"Directory $filename",                     -content=&gt; $content),              $cgi-&gt;end_wml() );    }    1;</pre><p> To enable it, we need to add the following to <code>httpd.conf</code>:<p><pre>    PerlModule Apache::WAP::AutoIndex    &lt;Location ~ "filelist\.wml$"&gt;      SetHandler perl-script      PerlHandler Apache::WAP::AutoIndex    &lt;/Location&gt;</pre><p>&nbsp; <table border="0" cellspacing="0" cellpadding="1" align="right">  <tr>    <td align="center" valign="top"><b>Figure 7<br>      </b><img src="tpj0504-0004_f7.gif" width="175" height="138" vspace="5" hspace="5"></td>  </tr></table><p>Figure 7 shows the result when pointed at /wap/filelist.wml on the site. <p><b>Generating WML with HTML::Mason<p></b><p><b></b>Sometimes it is easier to work directly with the WML markup and surround with it program code. If you'd prefer to mark up WML code with Perl, Mason is a good choice.<p><p>Mason, described in TPJ#17 is a comprehensive site development and delivery engine in pure Perl. Running with mod_perl under Apache, it allows you to create dynamic and modular web sites easily. Incorporating programmatic features into web pages is as simple as importing a module and directly calling its functions from within that page, and component-based development means that you can reuse and consolidate information that appears within many pages (or decks, in our case).<p><p> For those who haven't used Mason, you can download and install it from CPAN   using the standard perl <code>Makefile.PL</code>, <code>make</code>, <code>make   test</code>, and <code>make install</code> commands. There are a few prerequisites,   and you need to configure mod_perl to load the HTML::Mason modules. Consult   the Mason documentation for help on this; it's quick and painless. Once installed   and loaded, you simply tell Mason which directories or files to handle, and   then write your pages. You embed Perl directly into your HTML, by placing it   within some predefined Mason tags, such as a <code>&lt;%perl&gt;</code> block:<p><pre>    &lt;%perl&gt;      use DBI;      my $DSN = 'dbi:mysql:books';      my $dbh = DBI-&gt;connect($DSN, "user", "pass", { RaiseError =&gt; 1 } )              or die "Couldn't connect to database: $!\n";    &lt;/%perl&gt;</pre><p> Single lines of Perl can be placed into pages by prefixing them with a <code>%</code>:<p><pre>    % my $query = $dbh-&gt;prepare("select name,author from books");    % $query-&gt;execute;</pre><p>Mason treats anything not beginning with <code>%</code> as HTML to be displayed.   Mason's ability to understand blocks of Perl code, interspersed with HTML, makes   this a powerful feature for program flow:<p><pre>    % # Print out all the books and authors    % while (my $dat = $query-&gt;fetchrow_hashref) {        &lt;% $dat-&gt;{name} %&gt; by &lt;% $dat-&gt;{author} %&gt;&lt;br&gt;    % }</pre><p> If you let Mason handle your HTTP headers, it will trust Apache to print a   header appropriate for the type of file (determined by the extension). More   to the point, this means that if Mason is handling all requests for a given   directory by having this in your <code>httpd.conf</code> file:<p><pre>    &lt;Location /mason&gt;        SetHandler perl-script        PerlHandler HTML::Mason    &lt;/Location&gt;</pre><p> ...then you can simply save Mason files in this directory with a .wml extension,   and they will be delivered with the proper MIME type. You can also test the   user agent within a Mason file, and thereby deliver the MIME type and content   appropriate for the browser. This is done using the Mason <code>&lt;%init&gt;</code>   section, which makes an Apache request object available as the familiar <code>$r:</code><sup><a href="#4">4</a></sup> <p><pre>    &lt;%init&gt;      my $content_type;      if ($r-&gt;header_in('Accept') =~ /text\/vnd\.wap\.wml/) {          $content_type = "wml";          $r-&gt;content_type('text/vnd.wap.wml');      } else {          $content_type = "html";          $r-&gt;content_type('text/html');      }    &lt;/%init&gt;</pre><p> Note what happens here: to determine the browser type, we're using the HTTP   header <code>HTTP_ACCEPT</code> (seen by mod_perl as <code>Accept</code>), rather   than the User Agent. (The only potential problem here: if future HTTP browsers   support WML, they'll display the WML instead of the HTML.)<p>Throughout the rest of the document, different content could be served for the two content types:<p><pre>    % if ($content_type eq "wml") {        &lt;card id="first_card" title="First card" &gt;            &lt;p&gt;The weather for today is cold and hard.&lt;/p&gt;        &lt;/card&gt;    % } else {        &lt;p&gt;&lt;font size=3&gt;The weather for today is cold and                                          hard.&lt;/font&gt;&lt;/p&gt;    % }</pre><p><b>A WML phone directory with Mason<p></b><p>The real benefits of placing program code markup within interface documents   arises when the bulk of the content is dynamic. Assume we had an address book,   and we wanted users to be able to browse it on WAP devices and directly call   numbers in the address book. In the following example, the list of addresses   is being generated from a MySQL database. We've stored the WML header information   in a file, <code>header.wml</code>, which is loaded as a component using the   <code>&lt;&amp; &amp;&gt;</code> syntax.<p><pre>    &lt;%perl&gt;      use DBI;      my $DSN = 'dbi:mysql:directory';      my $dbh = DBI-&gt;connect($DSN,"user","pass",                                    { RaiseError =&gt; 1 } )              or die "Couldn't connect to database: $!\n";      my $query = $dbh-&gt;prepare("select name,phonefrom addresses");      $query-&gt;execute;    &lt;/%perl&gt;    &lt;&amp; header.wml &amp;&gt;    &lt;wml&gt;      &lt;card id="phonelist"&gt;        &lt;p&gt;Place a call to:        &lt;do type="accept"&gt;          &lt;go href="wtai://vc/sc;$number;1" /&gt;        &lt;/do&gt;        &lt;select name="number"&gt;    % while (my $dat = $query-&gt;fetchrow_hashref) {            &lt;option value="&lt;% $dat-&gt;{phone} %&gt;"&gt;&lt;%$date-&gt;{name} %&gt;&lt;/option&gt;    % }            &lt;/select&gt;        &lt;/p&gt;      &lt;/card&gt;    &lt;/wml&gt;</pre><p>&nbsp; <table border="0" cellspacing="0" cellpadding="1" align="right">  <tr>    <td align="center" valign="top"><b>Figure 8<br>      </b><img src="tpj0504-0004_f8.gif" width="175" height="138" vspace="5" hspace="5"></td>  </tr></table><p>  The <code>href</code> tag here makes use of the WTAI standard WAP libraries,   which contain functions for interacting with the phone itself. This example   accesses the vc (Voice Call Control) library to dial the number stored in variable   <code>$number</code>. The resulting display appears in Figure 8, and selecting   a name from the list causes the phone to dial that number. <p><p>Of course, this could easily be extended to include more information from the address book, placing different types of information in different cards.<p><p><b>WML with straight Perl<p></b><p>When working with a markup language as simple as WML, there's something to   be said for developing an application entirely in plain Perl, and embedding   the WML tags directly into your program. While that may sound like a regression   to the hard-coded CGIs of our youth, the simplicity of WML actually makes such   interfaces easy to update and manage. Speaking of hard-coded CGIs, remember   how useful that <code>printenv</code> or <code>env.cgi</code> script was? It's   just as useful for debugging environments for WAP applications. Here it is in   straight Perl with WML output:<p><pre>#!/usr/bin/perl$output = &lt;&lt;EOF;Content-type: text/vnd.wap.wml&lt;?xml version="1.0" encoding="iso-8859-1"?&gt;    &lt;!DOCTYPE wml PUBLIC "-//WAPFORUM//DTD WML 1.1//EN""http://www.wapforum.org/DTD/wml_1.1.xml"&gt;&lt;wml&gt;&lt;card id="env"&gt;&lt;p&gt;EOFforeach $var (sort(keys(%ENV))) {    $val = $ENV{$var};    $val =~ s|\n|\\n|g;    $val =~ s|"|\\"|g;    $val =~ s|&lt;|&lt;|g;    $val =~ s|&gt;|&gt;|g;    $output .= "${var}=\"${val}\"&lt;br/&gt;\n";}$output .= "&lt;/p&gt;&lt;/card&gt;&lt;/wml&gt;";print $output;</pre><p><b>A remote control for home automation<p></b><p><b></b>Accessing information is only one use for wireless browsers. Wouldn't it be great if you could also use your phone to perform tasks? An interface to the Perl home automation package Control::X10 (see TPJ #17) makes just that possible.<p><p>Our application will have the user choose a house location and an appliance, and then be prompted to turn it on or off. The deck will consist of eight cards; the last card (turn on/off) will use values from previous cards for the action prompt, and will then post to the web server.<p><p>Translating this to a WML expression is trivial. In this example, we will place the deck directly into our Perl program. This excerpt could be run within a Perl module under mod_perl, or as a CGI script (gasp!). In our example, this is running within a module, with an Apache directive causing this module to handle all requests to /mister on the server.<p><p>&nbsp; <table border="0" cellspacing="0" cellpadding="1" align="right">  <tr>     <td align="center">       <p><b>Figure 9<br>        <img src="tpj0504-0004_f9.gif" width="175" height="138" vspace="5" hspace="5"></b>     </td>  </tr></table><p>First, we'll create our main card, shown in Figure 9.<p><pre>    my $main_card = &lt;&lt;EOF;        &lt;card id="main" title="Main"&gt;          &lt;p&gt;            Select an area:            &lt;select title="Areas"&gt;                &lt;option onpick="#outside"&gt;Outside&lt;/option&gt;                &lt;option onpick="#living"&gt;Living Room&lt;/option&gt;                &lt;option onpick="#kitchen"&gt;Kitchen&lt;/option&gt;            &lt;/select&gt;          &lt;/p&gt;          &lt;do type="accept" label="Back"&gt;              &lt;prev/&gt;          &lt;/do&gt;          &lt;do type="accept" label="Go"&gt;              &lt;noop/&gt;          &lt;/do&gt;        &lt;/card&gt;    EOF</pre><table border="0" cellspacing="0" cellpadding="1" align="right">  <tr>     <td>       <p><b>Figure 10<br>        <img src="tpj0504-0004_f10.gif" width="175" height="138"></b>     </td>  </tr></table><p>Next, the "outside" card (Figure 10): <pre>    my $outside_card = &lt;&lt;EOF;        &lt;card id="outside" title="Outside"&gt;          &lt;p&gt;            Select an appliance:            &lt;select name="appliance" title="Outside"&gt;                &lt;option value="flood light"&gt;Flood light&lt;/option&gt;                &lt;option value="christmas lights"&gt;Christmas lights&lt;/option&gt;            &lt;/select&gt;          &lt;/p&gt;          &lt;do type="accept" label="Back"&gt;              &lt;prev/&gt;          &lt;/do&gt;          &lt;do type="accept" label="Go"&gt;              &lt;go href="#toggle"/&gt;          &lt;/do&gt;        &lt;/card&gt;    EOF</pre><table border="0" cellspacing="0" cellpadding="1" align="right">  <tr>    <td align="center" valign="top">       <p><b>Figure 11<br>        </b><img src="tpj0504-0004_f11.gif" width="175" height="138" vspace="5" hspace="5">       <p>    </td>  </tr></table><p>We'll skip the cards for "Living Room" and "Kitchen", and skip to the last   card of the deck (Figure 11). <p><pre>    my $toggle_card = &lt;&lt;EOF;         &lt;card id="toggle" title="Toggle appliance"&gt;            &lt;p&gt;                Turn on/off the \$(appliance)?&lt;br/&gt;                &lt;a href="/mister?toggle=\$(appliance:e)"&gt;Yes&lt;/a&gt;            &lt;/p&gt;            &lt;do type="accept" label="Back"&gt;                &lt;prev/&gt;            &lt;/do&gt;        &lt;/card&gt;    EOF</pre><p>The <code>$(appliance:e)</code> syntax above causes the value of $appliance   to be escaped for inclusion on the URL line. Keep in mind that this entire deck   will be sent to the client at once. The server will not hear back from the client   until the user gets to the last card and selects the "Yes" <code>href</code>   link, which will repost to the same program. Assuming that we are running this   code as a mod_perl module, here's the rest of the program.<p><pre>  package MisterHouseWAP;  use Apache::Constants qw(:common);  use CGI::WML;  require 'start_port.pl';  use ControlX10::CM17;  our %appliances = ('christmas lights' =&gt; 'A1J',                     'flood light'      =&gt; 'A4J');  sub handler {    my $r      = shift;    my @msgnos = ();    my %params = $r-&gt;method eq 'POST' ? $r-&gt;content : $r-&gt;args;    if ($params{'toggle'}) {        toggle($params{'toggle'});    }    my $deck = CGI::WML::header() . "&lt;wml&gt;\n" . $main_card .             $outside_card . $toggle_card . "&lt;/wml&gt;";    $r-&gt;send_http_header('text/vnd.wap.wml');    $r-&gt;print($deck);  }  sub toggle {    # pseudo-sending code; see the X10 modules for real examples    my $serial = open_port('COM1');    send_cm17($serial, $appliances{$_[0]});    $serial-&gt;close;  }  1; </pre><p><b>Creating a personal portal<p></b><p><b></b>Finally, we come to my personal motivation for this article. The difficulty of navigating information on commercial portals prompted me to create my own. It's really quite simple, consisting of eight cards, and using CPAN modules to interface with stock quotes (Finance::Quote), news, new mail summaries (Mail::Cclient), and DBM files for everything else. Everything is delivered in a single deck, so I can connect with my phone, download the deck, disconnect, and be able to browse the updates offline.<p><p>The following example allows a user to browse unread mail messages by first prompting for a username and password, and then using the Mail::Cclient module by Malcolm Beattie to fetch the unread messages from an IMAP server.<p><p> First, the login screen, which we'll call <code>login.wml</code>:<p><pre>&lt;?xml version="1.0"?&gt;&lt;!DOCTYPE wml PUBLIC    "-//WAPFORUM//DTD WML 1.1//EN"    "http://www.wapforum.org/DTD/wml_1.1.xml"&gt;&lt;wml&gt;    &lt;card title="Login"&gt;        &lt;!-- Reset fields when entered backwards. --&gt;        &lt;onevent type="onenterbackward"&gt;            &lt;refresh&gt;                &lt;setvar name="username" value=""/&gt;                &lt;setvar name="password" value=""/&gt;            &lt;/refresh&gt;        &lt;/onevent&gt;        &lt;!-- Read login and password from user. --&gt;        &lt;p&gt;Username: &lt;input name="username"/&gt;&lt;/p&gt;        &lt;p&gt;Password: &lt;input type="password"                                     name="password"/&gt;&lt;/p&gt;        &lt;!-- Submit button sends data to server. --&gt;        &lt;do type="accept" label="Submit"&gt;            &lt;go href="/wmlmail/" method="post"&gt;                &lt;postfield name="username"                                        value="$(username)"/&gt;                &lt;postfield name="password"                                        value="$(password)"/&gt;            &lt;/go&gt;        &lt;/do&gt;    &lt;/card&gt;&lt;/wml&gt;</pre><p>&nbsp; <table border="0" cellspacing="0" cellpadding="5" align="right">  <tr>     <td align="left" valign="top"><b>Figure 12<br>      <img src="tpj0504-0004_f12.gif" width="175" height="138" vspace="5" hspace="5"></b></td>  </tr>  <tr>     <td align="left" valign="top"><b>Figure 13<br>      <img src="tpj0504-0004_f13.gif" width="175" height="138" vspace="5" hspace="5"></b></td>  </tr></table><p>This will prompt for a username and password as shown in Figures 12 and 13.<p>The module which handles the post from the above deck is handling all requests to /wmlmail/ using a Location directive in httpd.conf. If the login is successful, the user gets a list of unread mail messages with the sender and the subject, shown in Figure 4.<p><pre>package Apache::WAP::MailPeek;use strict;use Apache::Constants qw(:common);use Mail::Cclient;our $mail_server = 'brians.org';Mail::Cclient::parameters(  'NIL',  RSHTIMEOUT     =&gt; 0,  OPENTIMEOUT    =&gt; 1,  READTIMEOUT    =&gt; 1,  CLOSETIMEOUT   =&gt; 1,  MAXLOGINTRIALS =&gt; 1,);sub handler {  my $r      = shift;  my @msgnos = ();  my %params = $r-&gt;method eq 'POST' ? $r-&gt;content : $r-&gt;args;  Mail::Cclient::set_callback        login    =&gt; sub {            return $params{'username'}, $params{'password'}        },        searched =&gt; sub {            push (@msgnos, $_[1]);        },        log      =&gt; sub { print @_ }, dlog =&gt; sub { print @_};  my $mail = Mail::Cclient-&gt;new("{$mail_server/imap}") or die $!;  $r-&gt;content_type('text/vnd.wap.wml');  $r-&gt;send_http_header;  $r-&gt;print(&lt;&lt;END);    &lt;?xml version="1.0" encoding="iso-8859-1"?&gt;      &lt;!DOCTYPE wml PUBLIC "-//WAPFORUM//DTD WML 1.1//EN"                    "http://www.wapforum.org/DTD/wml_1.1.xml"&gt;    &lt;wml&gt;&lt;card id="mail"&gt;END  $mail-&gt;search("UNSEEN");  foreach my $msgno (@msgnos) {      my ($envelope,$body) = $mail-&gt;fetchstructure($msgno);      my $subject = $envelope-&gt;subject;      my $from    = ${$envelope-&gt;{from}}[0]-&gt;{personal} ||              ${$envelope-&gt;{from}}[0]-&gt;{mailbox} . "@" .               ${$envelope-&gt;{from}}[0]-&gt;{host};      $from =~ s/\&amp;/\&amp;amp\;/g; $subject =~ s/\&amp;/\&amp;amp\;/g;      $from =~ s/\$/\$\$/g;   $subject =~ s/\$/\$\$/g;      $r-&gt;print ("&lt;p&gt;&lt;b&gt;", $from, "&lt;/b&gt;: ", $subject, "&lt;/p&gt;\n");  }  $mail-&gt;close;  $r-&gt;print("&lt;/card&gt;&lt;/wml&gt;");}1; </pre> <table border="0" cellspacing="0" cellpadding="1" align="right">  <tr>     <td><b>Figure 14<br>      </b><img src="tpj0504-0004_f14.gif" width="175" height="138" vspace="5" hspace="5"></td>  </tr></table><p>In time, I'll abstract the entire portal enough to get it on CPAN. But as you   can see, creating of such a system is quite straightforward, thanks to the compact   nature of WML and the ease of developing applications in Perl. <p><p>Whether you opt to embed WML within scripts, mark up WML with Perl using a web development kit like Mason, or use modules to automate the creation of WML, Perl makes such development extremely simple and rapid. With tools like this, its a wonder we use anyone else's web services at all. I'm kidding.<p><p><i>_ _END_ _</i><p><p> <i>Dan is a composer, linguist, mentalist, gamer, and father of two. By day   he masquerades as a software engineer at Verio, Inc.</i> <br><p>&nbsp;<hr size="1" noshade><p class="date">1<a name="1"></a> If mod_rewrite isn't part of your Apache installation,   and you've compiled the Apache apxs utility, you can add mod_rewrite from the   Apache 1.3.12 source directory with apxs -i src/modules/standard/mod_rewrite.c. </p><p class="date"> 2<a name="2"></a> WML also supports some traditional HTML tags   for ease of use. For example, &lt;a/&gt; tags may be used in place of &lt;anchor/&gt;. <p class="date"> 3<a name="3"></a> While I'm a big fan of XSLT, being able to   transform a single data set to many types of interfaces does not necessarily   address the core issue here. A WAP application will hopefully not differ from   an HTTP application only in its presentation, but also in its design, flow,   and function. WAP usability concerns require that applications go far beyond   simply translating data for presentation. <p class="date"> 4<a name="4"></a> If you aren't familiar with the Apache API   as provided by mod_perl, consult O'Reilly's <i>Writing Apache Modules with Perl   and C</i> by Stein and MacEachern for information that will change your development   life and world view. <p>&nbsp;</body></html>