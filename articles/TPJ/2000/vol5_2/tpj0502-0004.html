<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <title>TREES - The Perl Journal, Summer 2000</title>
  <meta name="generator" content=
  "HTML Tidy for Linux/x86 (vers 12 April 2005), see www.w3.org">
  <meta name="vscategory" content="Perl">
  <meta name="vsisbn" content="">
  <meta name="vstitle" content="TREES">
  <meta name="vsauthor" content="Sean M. Burke">
  <meta name="searchdescription" content=
  "Last time in my column I talked about creating a streaming audio server for MPEG level 3 (MP3) files. Continuing with the same theme, today I'm giving you a peek at my latest work in progress, a Perl module for the Napster protocol called MP3::Napster.">
  <meta name="vsimprint" content="The Perl Journal">
  <meta name="vspublisher" content="Earthweb">
  <meta name="vspubdate" content="Summer 2000">
  <!-- always update the article title and issue -->

  <!-- end head -->
  <!-- link to the previous and next documents relative to the current document -->
</head>

<body>
  <font face="verdana" size="1">Issue 18, Summer 2000</font>

  <h2 align="center">Trees</h2>

  <h4><i>Sean M. Burke</i></h4>
  <!-- packages described, if necessary -->

  <div align="center">
    <table border="1" cellspacing="0" cellpadding="5">
      <tr>
        <td align="middle" bgcolor="#CCCC99"><b>Packages:</b></td>
      </tr>

      <tr>
        <td>Games::Alak ..........................................
        CPAN<br>
        HTML-Tree bundle ............................... CPAN<br>
        Tree::DAG_Node .................................. CPAN<br>
        Data::Dumper ........................................
        CPAN</td>
      </tr>
    </table>
  </div>

  <p><i>AaaAAAaauugh! Watch out for that tree!<br>
  - George of the Jungle theme</i></p>

  <p>Perl's facility with references, combined with its automatic
  management of memory allocation, makes it straightforward to
  write programs that store data in structures of arbitrary form
  and complexity.</p>

  <p>But I've noticed that many programmers, especially those who
  started out with more restrictive languages, seem at home with
  complex but uniform data structures - multidimensional arrays, or
  more struct-like things like
  hashes-of-arrays(-of-hashes(-of-hashes)), and so on - but they're
  often uneasy buliding more free form, less tabular structures,
  like trees.</p>

  <p>Trees are easy to build and manage in Perl, as I'll
  demonstrate by showing how the HTML::Element class manages
  elements in an HTML document tree, and by walking you through a
  from-scratch implementation of game trees. First, we need to nail
  down what we mean by a "tree".</p>

  <h3>Socratic Dialogues: "What is a Tree?"</h3>

  <p>My first brush with tree-shaped structures was in linguistics
  classes, where tree diagrams were used to describe the syntax
  underlying natural language sentences. After learning my way
  around <i>those</i> trees, I started to wonder - are what I'm
  used to calling "trees" the same as what programmers call
  "trees"? So I asked lots of helpful and patient programmers how
  they would define a tree. Many replied with a answer in jargon
  that they could not really explain (understandable, since
  explaining things, especially defining things, is harder than
  people think):</p>

  <blockquote>
    <i>So what is a "tree"? A tree-shaped data structure?</i><br>
    <i>A tree is a special case of an acyclic directed
    graph!</i><br>
    <i>What's a "graph"?</i><br>
    <i>Um... lines... and... you draw it... with... arcs! nodes!
    Um...</i>
  </blockquote>

  <p>The most helpful were folks who couldn't explain it directly,
  but with whom I could get into a rather Socratic dialog (where I
  asked the half-dim half-earnest questions), often with a lot of
  doodling.</p>

  <p><i>Question: So what's a tree?</i></p>

  <p>Answer: A tree is a collection of nodes that are linked
  together in a, well, tree-like way! Like this <i>[drawing on a
  napkin]</i>:</p>
  <pre>
     A
    / \
   B   C
     / | \
    D  E  F 
</pre>

  <p><i>Q: So what do these letters represent?</i></p>

  <p>A: Each is a different node, a chunk of data. Maybe C is a
  bunch of data that stores a number, maybe a hash table, maybe
  nothing at all besides the fact that it links to D, E, and F
  (which are other nodes).</p>

  <p><i>Q: So what are the lines between the nodes?</i></p>

  <p>A: Links. Also called "arcs". They just symbolize the fact
  that each node holds a list of nodes it links to.</p>

  <p><i>Q: So what if I draw nodes and links, like this? Is this
  still a tree?</i></p>
  <pre>
     B - E
    / \  / \
   A   C    
    \ /
     E 
</pre>

  <p>A: No, not at all. There are a lot of un-treelike things about
  that. First, E has a link coming off of it going into nowhere.
  You can't have a link to nothing - you can only link to another
  node. Second, I don't know what that sideways link between B and
  E means.</p>

  <p><i>Q: Okay, let's work our way up from something simpler. Is
  this a tree...?</i></p>
  <pre>
    A
</pre>

  <p>A: Yes, I suppose. It's a tree of just one node.</p>

  <p><i>Q: So how about...</i></p>
  <pre>
   A
   
   B
</pre>

  <p>A: No, you can't just have nodes floating there,
  unattached.</p>

  <p><i>Q: Okay, I'll link A and B. How's this?</i></p>
  <pre>
   A
   |
   B
</pre>

  <p>A: Yup, that's a tree. There's a node A, and a node B, and
  they're linked.</p>

  <p><i>Q: How is that tree any different from this one?</i></p>
  <pre>
   B
   |
   A
</pre>

  <p>A: Well, in both cases A and B are linked. But it's in a
  different direction.</p>

  <p><i>Q: Direction? What does the direction mean?</i></p>

  <p>A: Well, it depends what the tree represents. If it represents
  a categorization, like this:</p>
  <pre>
          citrus
        /   |   \
       /    |    \
   orange  lemon  kumquat ...
</pre>

  <p>then you mean to say that oranges, lemons, and kumquats are
  all kinds of citrus fruit. But if you drew it upside down, you'd
  be saying, falsely, that citrus is a kind of kumquat, a kind of
  lemon, and a kind of orange. If the tree represented
  cause-and-effect (or at least what situations could follow
  others), or represented what is a part of what, you wouldn't want
  to get those backwards, either. So with the nodes you draw
  together on paper, one has to be over the other, so can tell
  which way the relationship in the tree works.</p>

  <p><i>Q: So are these two trees the same?</i></p>
  <pre>
     A          A
    / \        / \
   B   C      B   \
                   C
</pre>

  <p>A: Yes, although by convention we often try to line up things
  in the same generation, like it is in the diagram on the
  left.</p>

  <p><i>Q: "Generation"? This is a family tree?</i></p>

  <p>A: No, not unless it's a family tree for just yeast cells or
  something else that reproduces asexually.</p>

  <p>But for sake of having lots of terms to use, we just pretend
  that links in the tree represent the "is a child of"
  relationship, instead of "is a kind of" or "is a part of", or
  "could result from", or whatever the real relationship is. So we
  get to borrow a lot of kinship words for describing trees - B and
  C are "children" (or "daughters") of A; A is the "parent" of B
  and C. Node C is a "sibling" (or "sister") of node C; and so on,
  with terms like "descendants" and "generation" (all the nodes at
  the same "level" in the tree are either all grandchildren of the
  top node, or all great-grandchildren, etc.), and "lineage" or
  "ancestors".</p>

  <p>So then we get to express rules in terms like "<b>A node
  cannot have more than one parent</b>", which means that this is
  not a valid tree:</p>
  <pre>
    A
   / \
  B   C
   \ /
    E
</pre>

  <p>And: "<b>A node can't be its own parent</b>", which excludes
  this looped-up connection:</p>
  <pre>
    /\
   A  |
    \/
</pre>

  <p>Or, put more generally: "<b>A node can't be its own
  ancestor</b>", which excludes the above loop, as well as the one
  here:</p>
  <pre>
      /\
     Z  \
    /    |
   A     |
  / \    |
 B   C  /
      \/
</pre>

  <p>That tree is excluded because A is a child of Z, and Z is a
  child of C, and C is a child of A, which means A is its own
  great-grandparent. So this whole network can't be a tree, because
  it breaks the meta-rule: <b>Once any node in the supposed tree
  breaks the rules for trees, you don't have a tree
  anymore.</b></p>

  <p><i>Q: Okay, now, are these two trees the same?</i></p>
  <pre>
     A         A
   / | \     / | \
  B  C  D   D  C  B
</pre>

  <p>A: It depends whether you're basing your concept of trees on
  each node having a set (unordered list) of children, or an
  (ordered) list of children. It's a question of whether ordering
  is important for what you're doing. With my diagram of citrus
  types, ordering isn't important, so these tree diagrams express
  the same relationships:</p>
  <pre>
          citrus
            |    
   orange  lemon  kumquat


          citrus
            |    
   kumquat  orange  lemon
</pre>

  <p>It doesn't make sense to say that oranges are "before" or
  "after" kumquats in the whole botanical scheme of things.
  (Unless, of course, you <i>are</i> using ordering to mean
  something, like a degree of genetic similarity.)</p>

  <p>But consider a tree that's a diagram of what steps constitute
  an activity, to some degree of specificity:</p>
  <pre>
           make tea
          /   |    \
         /    |     \
   pour     infuse   serve
 hot water    / \
in cup/pot   /   \
            /     \
          add     let
          tea     sit
         leaves
</pre>

  <p>This means that making tea consists of putting hot water in a
  cup or pot, infusing it (adding tea leaves and letting it sit),
  and then serving it - <i>in that order</i>. If you serve an empty
  dry pot, let it sit, add tea leaves, and pour in hot water, then
  what you're doing is performance art, not tea preparation:</p>
  <pre>
       performance art
          /  |   \
         /   |    \
        /    |     \
   serve   infuse    pour hot water
            / \       in cup/pot
           /   \
          /     \      
         let     add
         sit     tea
                leaves
</pre>

  <p>Except for my having renamed the root, this tree is the same
  as the making-tea tree as far as what's under what, but it
  differs in order, and what the tree means makes the order
  important.</p>

  <p><i>Q: Root? What's a root?</i></p>

  <p>A: Besides kinship terms like "sister" and "daughter", the
  jargon for tree parts also has terms from real-life tree parts:
  the part that everything else grows from is called the "root";
  and nodes that don't have children are called "leaves".</p>

  <p><i>Q: But you've been drawing all your trees with the root at
  the top and leaves at the bottom!</i></p>

  <p>A: Yes, but for some reason, that's the way everyone seems to
  think of trees. They can draw trees as above; or they can draw
  them sort of sideways with indentation representing what nodes
  are children of what:</p>
  <pre>
  * make tea
     * pour hot water in cup/pot
     * infuse
        * add tea leaves
        * let sit
     * serve
</pre>

  <p>But folks almost never seem to draw trees with the root at the
  bottom. So imagine it's a spider plant in a hanging pot.
  Unfortunately, spider plants <i>aren't</i> botanically trees,
  they're plants; but "spider plant diagram" is rather a mouthful,
  so let's just call them trees.</p>

  <h3>Trees Defined Formally</h3>

  <p>In time, I digested all these assorted facts about
  programmers' ideas of trees (which turned out to be just a more
  general case of linguistic ideas of trees) into a single
  rule:</p>

  <ul>
    <li>A node is an item that contains (or "is over", or "is the
    parent of") zero or more other nodes.</li>
  </ul>

  <p>From this you can build up formal definitions for useful
  terms:</p>

  <ul>
    <li>A node's <i>descendants</i> are defined as all its
    children, and all their children, and so on. Or, stated
    recursively: a node's descendants are all its children, and all
    its children's descendants. (And if it has no children, it has
    no descendants.)</li>

    <li>A node's <i>ancestors</i> consist of its parent, and its
    parent's parent, and so on up to the root. Or, recursively: a
    node's ancestors consist of its parent and its parent's
    ancestors. (If it has no parent, it has no ancestors.)</li>

    <li>A <i>tree</i> is a root node and all the root's
    descendants.</li>
  </ul>

  <p>And you can add a proviso or two to clarify exactly what I
  mean by the word "other" in "other nodes":</p>

  <ul>
    <li>A node cannot contain itself, or contain any node that
    contains it. Looking at it the other way, a node cannot be its
    own parent or ancestor.</li>

    <li>A node can be the root (that is, no other node contains it)
    or it can be contained by only one parent; no node can have
    more than one parent.</li>
  </ul>

  <p>Add to this the idea that children are sometimes ordered, and
  sometimes not, and that's about all you need to know about
  defining what a tree is. From there it's a matter of using
  them.</p>

  <h3>Markup Language Trees: HTML-Tree</h3>

  <p>Not <i>all</i> markup languages are inherently tree-like, but
  the best-known ones (HTML, SGML, and XML) are about as tree-like
  as you can get. In these languages, a document consists of
  elements and character data in a tree structure where there is
  one root element, and elements can contain either other elements,
  or character data.<sup><a href=
  "tpj0502-0004-ft1.html"><font size="-1">1</font></a></sup> For
  example, consider this HTML document:</p>
  <pre>
  &lt;html lang="en-US"&gt;
    &lt;head&gt;
      &lt;title&gt;
        Blank Document!
      &lt;/title&gt;
    &lt;/head&gt;
    &lt;body bgcolor="#d010ff"&gt;
      I've got
      &lt;em&gt;
        something to saaaaay
      &lt;/em&gt;
      !
    &lt;/body&gt;
  &lt;/html&gt;
</pre>

  <p>I've indented this to point out what nodes (elements or text
  items) are children of what, with each node on a line of its
  own.</p>

  <p>The HTML::TreeBuilder module (in the HTML-Tree bundle on CPAN)
  takes some HTML text and constructs a tree that the document
  source represents. It requires the HTML::Parser module (described
  in the last issue of TPJ), which tokenizes the source:
  identifying tags, bits of text, comments, and so on.</p>

  <p>The tree structure that it builds represents bits of text with
  normal Perl scalar string values; but elements are represented
  with objects - that is, chunks of data belonging to a class (in
  this case, HTML::Element), a class that provides methods
  (routines) for accessing the pieces of data in each element, and
  otherwise doing things with elements. (See my article in TPJ #17
  for a quick explanation of objects, the <tt>perltoot</tt>
  documentation bundled with Perl for a longer explanation, or
  Damian Conway's excellent book <i>Object-Oriented Perl</i>
  (Manning Publications) for the full story.)</p>

  <p>Each HTML::Element object contains a number of pieces of
  data:</p>

  <ul>
    <li>The element name ("<tt>html</tt>", "<tt>h1</tt>", and so
    on, accessed as <tt>$element-&gt;tag</tt>)</li>

    <li>A list of elements (or text segments) that it contains, if
    any (accessed as <tt>$element-&gt;content_list</tt> or
    <tt>$element-&gt;content</tt>, depending on whether you want a
    list, or an array reference)</li>

    <li>What element, if any, contains it (accessed as
    <tt>$element-&gt;parent</tt>)</li>

    <li>Any SGML attributes that the element has, such as
    <tt>lang="en-US"</tt> or <tt>align="center"</tt>, which would
    be accessed as <tt>$element-&gt;attr('lang')</tt> and
    <tt>$element-&gt;attr('center')</tt>.</li>
  </ul>

  <p>For example, when HTML::TreeBuilder builds the tree for the
  above HTML document source, the object for the "body" element has
  these pieces of data:</p>

  <div>
    <p>element name: "<tt>body</tt>"</p>

    <p>nodes it contains:</p>

    <div>
      <p>the string "<tt>I've got</tt>"</p>

      <p>the object for the "<tt>em</tt>" element</p>

      <p>the string "<tt>!</tt>"</p>
    </div>

    <p>its parent:</p>

    <div>
      <p>the object for the "<tt>html</tt>" element</p>
    </div>

    <p>bgcolor: "<tt>#d010ff</tt>"</p>
  </div>

  <p>Now, once you have this tree of objects, almost anything you'd
  want to do with it starts with searching the tree for some bit of
  information in some element.</p>

  <p>Accessing a piece of information in, say, a hash of hashes of
  hashes, is straightforward:</p>
  <pre>
  $password{sean}{sburke1}{hpux}
</pre>

  <p>because you know that all data points in that structure are
  accessible with that syntax, but with just different keys. Now,
  the "<tt>em</tt>" element in the above HTML tree does happen to
  be accessible as the root's first child's first child:</p>
  <pre>
  $root-&gt;content-&gt;[1]-&gt;content-&gt;[1]
</pre>

  <p>But with trees, you typically don't know the exact location
  (via indexes) of the data you're looking for. Instead, finding
  what you want will typically involve searching through the tree,
  seeing if every node is the kind you want. Searching the whole
  tree is simple enough - look at a given node, and if it's not
  what you want, look at its children, and so on. HTML-Tree
  provides several methods that do this for you, such as
  <tt>find_by_tag_name()</tt>, which returns the elements (or the
  first element, if called in scalar context) under a given node
  (typically the root) whose tag name is whatever you specify.</p>

  <p>For example, that <tt>em</tt> node can be found as:</p>
  <pre>
  my $that_em = $root-&gt;find_by_tag_name('em');
</pre>

  <p>or as:</p>
  <pre>
  @ems = $root-&gt;find_by_tag_name('em');
    # will only have one element for this particular tree
</pre>

  <p>Now, given an HTML document of arbitrary structure and
  complexity, let's suppose you wanted to do something like change
  every</p>
  <pre>
  &lt;em&gt;stuff&lt;/em&gt;
</pre>

  <p>to</p>
  <pre>
  &lt;em class="funky"&gt;&lt;b&gt;[-&lt;/b&gt;stuff&lt;b&gt;-]&lt;/b&gt;&lt;/em&gt;
</pre>

  <p>the first step is to frame this operation in terms of what
  you're doing to the tree. You're changing this:</p>
  <pre>
      em
       |
       |
      ...
</pre>

  <p>to this:</p>
  <pre>
      em
     / | \
    /  |  \  
   b  ...   b
   |        |
  "[-"    "-]"
</pre>

  <p>In other words, you're finding all elements whose tag name is
  <tt>em</tt>, setting its class attribute to <tt>funky</tt>, and
  adding one child to the start of its content list - a new
  <tt>b</tt> element whose content is the text string <tt>[-</tt>,
  and one to the end of its content list - a new <tt>b</tt> element
  whose content is the text string <tt>-]</tt>.</p>

  <p>Once you've got it in these terms, it's just a matter of
  running to the HTML::Element documentation, and coding this up
  with calls to the appropriate methods, like so:</p>
  <pre>
  use HTML::Element 1.53;
  use HTML::TreeBuilder 2.96;
  # Build the tree by parsing the document
  my $root = HTML::TreeBuilder-&gt;new;
  $root-&gt;parse_file('whatever.html'); # source file
  
  # Now make new nodes where needed
  foreach my $em ($root-&gt;find_by_tag_name('em')) {
      $em-&gt;attr('class', 'funky'); # Set that attribute
    
      # Make the two new B nodes
      my $new1 = HTML::Element-&gt;new('b');
      my $new2 = HTML::Element-&gt;new('b');
      # Give them content (they have none at first)
      $new1-&gt;push_content('[-');
      $new2-&gt;push_content('-]');
    
      # And put 'em in place!
      $em-&gt;unshift_content($new1);
      $em-&gt;push_content($new2);
  }
  print "&lt;!-- Looky see what I did! --&gt;\n",
        $root-&gt;as_HTML(), "\n";
</pre>

  <p>The class HTML::Element provides just about every method I can
  imagine you needing for manipulating trees made of HTML::Element
  objects. (And what it doesn't directly provide, it gives you the
  components to create.)</p>

  <h3>Building Your Own Trees</h3>

  <p>Theoretically, any tree is pretty much like any other tree, so
  you could use HTML::Element for anything you'd ever want to do
  with any tree-arranged object. However, as its name suggests,
  HTML::Element is designed for HTML elements; it has lots of
  features that make sense only for HTML elements, like the idea
  that every element must have a tag name. And it lacks some
  features that might be useful for general applications, such as
  any sort of checking to make sure that you're not trying to
  arrange objects in a non-treelike way. For a general-purpose tree
  class that does have such features, you can use the
  Tree::DAG_Node module, also available from CPAN.</p>

  <p>However, if your task is simple enough, you might find it
  overkill to use Tree::DAG_Node. And, in any case, I find that the
  best way to learn how something works is to implement it (or
  something like it, but simpler) yourself. So I'll discuss how
  you'd implement a tree structure from scratch, without using any
  of the existing classes for tree nodes.</p>

  <h3>Implementation: Game Trees for Alak</h3>

  <p>Suppose that the task at hand is to write a program that can
  play against a human opponent at a strategic board game (as
  opposed to a board game where there's an element of chance). For
  most such games, a "game tree" is an essential part of the
  program (as I will argue, below), and this will be our test case
  for implementing a tree structure from scratch. To choose moves,
  we'll develop a subroutine that examines the tree by evaluating
  moves, and responses to those moves, and responses to those
  responses; such algorithms are called <i>minimax
  algorithms</i>.</p>

  <p>For sake of simplicity, our game is not chess or backgammon,
  but a much simpler game called Alak. Alak was invented by the
  mathematician A. K. Dewdney, and described in his 1984 book
  <i>Planiverse</i>. The rules of Alak are simple:<sup><a href=
  "tpj0502-0004-ft2.html"><font size="-1">2</font></a></sup></p>

  <ul>
    <li>Alak is a two-player game played on a one-dimensional board
    with eleven slots on it. Each slot can hold at most one piece
    at a time. There's two kinds of pieces, which I represent here
    as <tt>x</tt> and <tt>o</tt> - <tt>x</tt>'s belong to a player
    called X, and <tt>o</tt>'s to the player called O.</li>

    <li>The initial configuration of the board is:</li>
  </ul>
  <pre>
   xxxx___oooo
</pre>

  <p>For sake of the article, the slots are numbered from 1 (on the
  left) to 11 (on the right), and X always has the first move.</p>

  <ul>
    <li>The players take turns moving. At each turn, each player
    can move only one piece, once. (This is unlike checkers, where
    you move one piece at a time, but get to keep moving if you
    jump over your opponent's piece.) A player cannot give up his
    turn. A player can move any one of his pieces to the next
    unoccupied slot to its right or left, which may involve jumping
    over occupied slots. A player cannot move a piece off the side
    of the board.</li>

    <li>If a move creates a pattern where the opponent's pieces are
    surrounded, on both sides, by two pieces of the mover's color
    (with no intervening unoccupied blank slot), then those
    surrounded pieces are removed from the board.</li>

    <li>The goal of the game is to remove all of your opponent's
    pieces, at which point the game ends. Removing all pieces but
    one ends the game as well, since the opponent can't surround
    you with one piece, and so will always lose within a few moves
    anyway.</li>
  </ul>

  <p>Consider, then, this rather short game where X starts:</p>
  <pre>
  xxxx___oooo
    ^         
</pre>

  <p>Move 1: X moves from 3 (shown with caret) to 5, yielding the
  board below. (Note that any of X's pieces could move, but that
  the only place they could move to is 5.)</p>
  <pre>
  xx_xx__oooo
          ^   
</pre>

  <p>Move 2: O moves from 9 to 7.</p>
  <pre>
  xx_xx_oo_oo
     ^        
</pre>

  <p>Move 3: X moves from 4 to 6.</p>
  <pre>
  xx__xxoo_oo
           ^  
</pre>

  <p>Move 4: O (stupidly) moves from 10 to 9.</p>
  <pre>
  xx__xxooo_o
      ^       
</pre>

  <p>Move 5: X moves from 5 to 10, making the board
  <tt>xx___xoooxo</tt>. The three <tt>o</tt>'s that X just
  surrounded are removed:</p><tt>xx___x___xo</tt>

  <p>O has only one piece, so has lost.</p>

  <p>Now, move 4 could have gone the other way:</p>
  <pre>
  xx__xxoo_oo
</pre>

  <p>Move 4: O moves from 8 to 4, making the board
  <tt>xx_oxxo__oo</tt>. The surrounded <tt>x</tt>'s are
  removed:</p>
  <pre>
  xx_o__o__oo
  ^           
</pre>

  <p>Move 5: X moves from 1 to 2.</p>
  <pre>
  _xxo__o__oo
        ^     
</pre>

  <p>Move 6: O moves from 7 to 6.</p>
  <pre>
  _xxo_o___oo
   ^          
</pre>

  <p>Move 7: X moves from 2 to 5, removing the <tt>o</tt> at 4.</p>
  <pre>
  __x_xo___oo
</pre>

  <p>...and so on.</p>

  <p>To teach a computer program to play Alak (as player X, say),
  it needs to be able to look at the configuration of the board,
  figure out what moves it can make, and weigh the benefits and
  costs, immediate or eventual, of those moves.</p>

  <p>So consider the board from just before move 3, and figure all
  the possible moves X could make. X has pieces in slots 1, 2, 4,
  and 5. The leftmost two <tt>x</tt>'s (at 1 and 2) are up against
  the end of the board, so they can move only right. The other two
  <tt>x</tt>'s (at 4 and 5) can move either right or left:</p>
  <pre>
  Starting board: xx_xx_oo_oo
   moving 1 to 3 gives _xxxx_oo_oo
   moving 2 to 3 gives x_xxx_oo_oo
   moving 4 to 3 gives xxx_x_oo_oo
   moving 5 to 3 gives xxxx__oo_oo
   moving 4 to 6 gives xx__xxoo_oo
   moving 5 to 6 gives xx_x_xoo_oo
</pre>

  <p>For the computer to decide which of these is the best move to
  make, it needs to quantify the benefit of these moves as a number
  - call that the "payoff". The payoff of a move can be figured as
  just the number of <tt>x</tt> pieces removed by the most recent
  move, minus the number of <tt>o</tt> pieces removed by the most
  recent move. (It so happens that the rules of the game mean that
  no move can delete both <tt>o</tt>'s and <tt>x</tt>'s, but the
  formula still applies.) Since none of these moves removed any
  pieces, all these moves have the same immediate payoff: 0.</p>

  <p>Now, we could race ahead and write an Alak-playing program
  that could use the immediate payoff to decide which is the best
  move to make. And when there's more than one best move (as here,
  where all the moves are equally good), it could choose randomly
  between the good alternatives. This strategy is simple to
  implement, but it makes for a very dumb program. Consider what
  O's response to each of the potential moves (above) could be.
  Nothing immediately suggests itself for the first four
  possibilities (X having moved something to position 3), but
  either of the last two (illustrated below) are pretty perilous,
  because in either case O has the obvious option (which he would
  be foolish to pass up) of removing x's from the board:</p>
  <pre>
   xx_xx_oo_oo
      ^        
</pre>

  <p>X moves 4 to 6, yielding this board:</p>
  <pre>
   xx__xxoo_oo
          ^    
</pre>

  <p>O moves 8 to 4, giving <tt>xx_oxxo__oo</tt>. The two
  surrounded <tt>x</tt>'s are removed:</p>
  <pre>
   xx_o__o__oo
</pre>

  <p>or</p>
  <pre>
   xx_xx_oo_oo
       ^       
</pre>

  <p>X moves 5 to 6.</p>
  <pre>
   xx_x_xoo_oo
          ^    
</pre>

  <p>O moves 8 to 5, giving <tt>xx_xoxo__oo</tt>. The sole
  surrounded <tt>x</tt> is removed.</p>
  <pre>
   xx_xo_o__oo
</pre>

  <p>Both contingencies are quite bad for X. What's needed is for X
  to think <i>more</i> than one step ahead - to consider not merely
  what it can do in this move, and what the payoff is, but to
  consider what O might do in response, and the payoff of those
  potential moves, and so on with X's possible responses to those
  cases could be. All these possibilities form a <i>game tree</i> -
  a tree where each node is a board, and its children are
  successors of that node - that is, boards that could result from
  every move possible, given the parent's board.</p>

  <p>But how to represent the tree, and how to represent the nodes?
  Well, consider that a node holds several pieces of data:</p>

  <div>
    <p>First, the configuration of the board, which, being nice and
    simple and one-dimensional, can be stored as just a string,
    like <tt>xx_xx_oo_oo</tt>.</p>

    <p>Second, whose turn it is, X or O. (Or: who moved last, from
    which we can deduce whose turn it is.)</p>

    <p>Third, the successors (child nodes).</p>

    <p>Fourth, the immediate payoff of having moved to this board
    position from its predecessor (parent node).</p>

    <p>Fifth, what move gets us from our predecessor node to here.
    (Granted, knowing the board configuration before and after the
    move, it's easy to figure out the move; but it's easier still
    to store it as the node's successors are being computed.)</p>

    <p>Sixth, whatever else we might want to add later.</p>
  </div>

  <p>These could be stored equally well in an array or in a hash,
  but it's my experience that hashes are best for cases where you
  have more than just two or three bits of data, or especially when
  you might need to add new bits of data. Moreover, hash key names
  are mnemonic - <tt>$node-&gt;{'last_move_payoff'}</tt> is plain
  as day, whereas it's not so easy having to remember with an array
  that <tt>$node-&gt;[3]</tt> is where you decided to keep the
  payoff.<sup><a href="tpj0502-0004-ft3.html"><font size=
  "-1">3</font></a></sup></p>

  <p>So, we might as well represent nodes like so:</p>
  <pre>
  $node = { # hashref
     'board'    =&gt; ...board string, like "xx_x_xoo_oo"
     
     'last_move_payoff' =&gt; ...payoff of the move
                        that got us here.
                            
     'last_move_from'   =&gt; ...the start...
     'last_move_to'     =&gt; ...and end point of the move
                        that got us here.  Say, 5 and 6,
                        representing a move from 5 to 6.

     'whose_turn'       =&gt; ...whose move it then becomes.
                        just an 'x' or 'o'.
                              
     'successors'       =&gt; ...the successors
  };
</pre>

  <p>Note that we could have a field called something like
  <tt>last_move_who</tt> to denote who last moved, but since turns
  in Alak always alternate (and no one can pass), storing whose
  move it is now <i>and</i> who last moved is redundant - if X last
  moved, it's O turn now, and vice versa. I chose to have a
  <tt>whose_turn</tt> field instead of a <tt>last_move_who</tt>,
  but it doesn't really matter. Either way, we'll end up inferring
  one from the other at several points in the program.</p>

  <p>When we want to store the successors of a node, should we use
  an array or a hash? On the one hand, the successors to
  <tt>$node</tt> aren't ordered, so there's no reason to use an
  array <i>per se</i>; on the other hand, if we used a hash, with
  successor nodes as values, we don't have anything particularly
  meaningful to use as keys. (And we can't use the successors
  themselves as keys, since the nodes are referred to by hash
  references, and you can't use a reference as a hash key.) Given
  no particularly compelling reason to do otherwise, I choose to
  just use an array to store all a node's successors, although the
  order is never actually used for anything:</p>
  <pre>
  $node = {
    ...
    'successors' =&gt; [ ...nodes... ],
    ...
  };
</pre>

  <p>In any case, now that we've settled on what should be in a
  node, let's make a little sample tree out of a few nodes and see
  what we can do with it:</p>
  <pre>
  # Board just before move 3 in above game
  my $n0 = {
    'board' =&gt; 'xx_xx_oo_oo',
    'last_move_payoff' =&gt; 0,
    'last_move_from' =&gt;  9,
    'last_move_to'   =&gt;  7,
    'whose_turn' =&gt; 'x',
    'successors' =&gt; [],
  };

  # And, for now, just two of the successors:
  
  # X moves 4 to 6, giving xx__xxoo_oo
  my $n1 = {
    'board' =&gt; 'xx__xxoo_oo',
    'last_move_payoff' =&gt; 0,
    'last_move_from' =&gt;  4,
    'last_move_to'   =&gt;  6,
    'whose_turn' =&gt; 'o',
    'successors' =&gt; [],
  };
  # or X moves 5 to 6, giving xx_x_xoo_oo
  my $n2 = {
    'board' =&gt; 'xx_x_xoo_oo',
    'last_move_payoff' =&gt; 0,
    'last_move_from' =&gt;  5,
    'last_move_to'   =&gt;  6,
    'whose_turn' =&gt; 'o',
    'successors' =&gt; [],
  };

  # Now connect them...
  push @{$n0-&gt;{'successors'}}, $n1, $n2;
</pre>

  <h3>Digression: Links to Parents</h3>

  <p>In comparing what we store in an Alak game tree node to what
  HTML::Element stores in HTML element nodes, you'll note one big
  difference: every HTML::Element node contains a link to its
  parent, whereas we don't have our Alak nodes keeping a link to
  theirs.</p>

  <p>The reason this can be an important difference is because it
  can affect how Perl knows when you're not using pieces of memory
  anymore. Consider the tree we just built above:</p>
  <pre>
      node 0
      /    \
     /      \
  node 1    node 2
</pre>

  <p>There are two ways Perl knows you're using a piece of memory.
  It might be memory that belongs directly to a variable (that is,
  it's necessary to hold that variable's value) or it might be a
  piece of memory that something holds a reference to. In the above
  code, Perl knows that the hash for node 0 (for board
  <tt>xx_xx_oo_oo</tt>) is in use because something (namely, the
  variable <tt>$n0</tt>) holds a reference to it. Now, even if you
  followed the above code with this:</p>
  <pre>
  $n1 = $n2 = 'whatever';
</pre>

  <p>to make your variables <tt>$n1</tt> and <tt>$n2</tt> stop
  holding references to the hashes for the two successors of node
  0, Perl would still know that those hashes are still in use,
  because node 0's array of successors holds a reference to those
  hashes. And Perl knows that node 0 is still in use because
  something still holds a reference to it. Now, if you added:</p>
  <pre>
  my $root = $n0;
</pre>

  <p>This would change nothing - there's just <i>two</i> things
  holding a reference to the node 0 hash, which in turn holds a
  reference to the node 1 and node 2 hashes. And if you then
  added:</p>
  <pre>
  $n0 = 'stuff';
</pre>

  <p>still nothing would change, because something (<tt>$root</tt>)
  still holds a reference to the node 0 hash. But once
  <i>nothing</i> holds a reference to the node 0 hash, Perl knows
  it can destroy that hash (and reclaim the memory for later use,
  say), and once it does that, nothing will hold a reference to the
  node 1 or the node 2 hashes, and those will be destroyed too.</p>

  <p>But consider if the node 1 and node 2 hashes each had an
  attribute "parent" (or "predecessor") that held a reference to
  node 0. If your program stopped holding a reference to the node 0
  hash, Perl couldn't say that <i>nothing</i> holds a reference to
  node 0 - because node 1 and node 2 still do. So, the memory for
  nodes 0, 1, and 2 would never get reclaimed (until your program
  ends, at which point Perl destroys <i>everything</i>). If your
  program grew and discarded lots of nodes in the game tree, but
  didn't let Perl know it could reclaim their memory, your program
  could grow to use immense amounts of memory - never a good thing.
  There are three ways around this:</p>

  <p>First, when you're finished with a node, delete the reference
  each of its children have to it (in this case, deleting
  <tt>$n1-&gt;{'parent'}</tt>, say). When you're finished with a
  whole tree, just go through the whole tree erasing links that
  children have to their children.</p>

  <p>Second, reconsider whether you really need to have each node
  hold a reference to its parent. Just not having those links will
  avoid the whole problem.</p>

  <p>Third, use the WeakRef module if you have Perl 5.6 or later.
  This allows you to "weaken" some references (like the references
  that node 1 and 2 could hold to their parent) so that they don't
  count when Perl goes asking whether anything holds a reference to
  a given piece of memory. This wonderful new module eliminates the
  headaches that can often crop up with either of the two previous
  methods.</p>

  <p>It so happens that our Alak program is simple enough that we
  don't need for our nodes to have links to their parents, so the
  second solution is fine. But in a more advanced program, the
  first or third solutions might be unavoidable.</p>

  <h3>Recursively Printing the Tree</h3>

  <p>I don't like working blind - if I have any kind of a complex
  data structure in memory for a program I'm working on, the first
  thing I do is write something that can print the structure. Now,
  I could just use the <tt>x</tt> pretty-printer command in Perl's
  interactive debugger, or I could have the program use the
  Data::Dumper module. But in this case, I think the output from
  those is rather too verbose. Once we have trees with dozens of
  nodes in them, we'll really want a dump of the tree to be as
  concise as possible, hopefully just one line per node. What I'd
  like is something that can print <tt>$n0</tt> and its successors
  (see above) as something like:</p>
  <pre>
        xx_xx_oo_oo  (O moved 9 to 7, 0 payoff)
    xx__xxoo_oo  (X moved 4 to 6, 0 payoff)
    xx_x_xoo_oo  (X moved 5 to 6, 0 payoff)
</pre>

  <p>A subroutine to print a line for a given node, and then do
  that again for each successor, would look something like:</p>
  <pre>
  sub dump_tree {
      my $n = $_[0]; # "n" is for node
      print
        ...something expressing $n's content...
      foreach my $s (@{$n-&gt;{'successors'}}) {
          dump($s);
      }
  }
</pre>

  <p>And we could start that out with a call to
  <tt>dump_tree($n0)</tt>.</p>

  <p>Since this routine does its work (dumping the subtree at and
  under the given node) by calling itself, it's <i>recursive</i>.
  However, there's a special term for this kind of recursion across
  a tree: traversal. To <i>traverse</i> a tree means to do
  something to a node, and to traverse its children. This can
  happen in two ways: <i>pre-order</i> and <i>post-order</i>. With
  pre-order, you do something to X and then traverse its children;
  with post-order, you traverse X's children before operating on
  X.</p>

  <p>Dumping the tree to the screen the way we want it happens to
  be a matter of pre-order traversal, since the thing we do (print
  a description of the node) happens before we recurse into the
  successors.</p>

  <p>When we try writing the <tt>print</tt> statement for our above
  <tt>dump_tree()</tt>, we can get something like:</p>
  <pre>
  sub dump_tree {
      my $n = $_[0];

      # "xx_xx_oo_oo  (O moved 9 to 7, 0 payoff)"
      print $n-&gt;{'board'}, "  (",
        ($n-&gt;{'whose_turn'} eq 'o' ? 'X' : 'O'),
        # Infer who last moved from whose turn it is now.
        " moved ", $n-&gt;{'last_move_from'},
        " to ",    $n-&gt;{'last_move_to'},
        ", ",      $n-&gt;{'last_move_payoff'},
        " payoff)\n";

      foreach my $s (@{$n-&gt;{'successors'}}) {
          dump_tree($s);
      }
  }
</pre>

  <p>If we run this on $n0 from above, we get this:</p>
  <pre>
  xx_xx_oo_oo  (O moved 9 to 7, 0 payoff)
  xx__xxoo_oo  (X moved 4 to 6, 0 payoff)
  xx_x_xoo_oo  (X moved 5 to 6, 0 payoff)
</pre>

  <p>Each line on its own is fine, but we forget to allow for
  indenting, and without that we can't tell what's a child of what.
  (Imagine if the first successor had successors of its own - you
  wouldn't be able to tell if it were a child, or a sibling.) To
  get indenting, we'll need to have the instances of the
  dump_tree() routine know how far down in the tree they're being
  called, by passing a depth parameter between them:</p>
  <pre>
  sub dump_tree {
      my $n = $_[0];
      my $depth = $_[1];
      $depth = 0 unless defined $depth;
      print "  " x $depth,
        ...more stuff to print...
      foreach my $s (@{$n-&gt;{'successors'}}) {
          dump_tree($s, $depth + 1);
      }
  }
</pre>

  <p>When we call <tt>dump_tree($n0)</tt>, the <tt>$depth</tt>
  variable (from <tt>$_[1]</tt>) is undefined, so gets set to 0,
  which translates into an indenting of no spaces. But when
  <tt>dump_tree()</tt> invokes itself on <tt>$n0</tt>'s children,
  those instances see <tt>$depth</tt> +<tt>1</tt> as their
  <tt>$_[1]</tt>, providing appropriate indenting.</p>

  <h3>Growing the Tree</h3>

  <p>Our <tt>dump_tree()</tt> routine works fine for the sample
  tree we've got, so now we should get the program working and
  making its own trees, starting from a given board.</p>

  <p>In Games::Alak (the CPAN-released version of Alak that uses
  essentially the same code that we're currently discussing the
  tree-related parts of), there is a routine called
  <tt>figure_successors()</tt> that, given one childless node, will
  figure out all its possible successors. That is, it looks at the
  current board, looks at every piece belonging to the player whose
  turn it is, and considers the effect of moving each piece every
  possible way - notably, it figures out the immediate payoff, and
  if that move would end the game, it notes that by setting an
  <tt>endgame</tt> entry in that node's hash. (That way, we know
  that that's a node that <i>can't</i> have successors.)</p>

  <p>In the code for Games::Alak, <tt>figure_successors()</tt> does
  all these things, in a rather straightforward way. I won't walk
  you through the details of the <tt>figure_successors()</tt> code
  I've written, since the code has nothing much to do with trees,
  and is all just implementation of the Alak rules for what can
  move where, with what result. Especially interested readers can
  puzzle over that part of code in the source listing in the
  archive from CPAN, but others can just assume that it works as
  described above.</p>

  <p>But consider that <tt>figure_successors()</tt>, regardless of
  its inner workings, does not grow the tree; it only makes one set
  of successors for one node at a time. It has to be up to a
  different routine to call <tt>figure_successors()</tt>, and to
  keep applying it as needed, in order to make a nice big tree that
  our game-playing program can base its decisions on.</p>

  <p>Now, we could do this by just starting from one node, applying
  <tt>figure_successors</tt> to it, then applying
  <tt>figure_successors</tt> on all the resulting children, and so
  on:</p>
  <pre>
  sub grow {  # Just a first attempt at this!
      my $n = $_[0];
      figure_successors($n)
        unless @{$n-&gt;{'successors'}} or $n-&gt;{'endgame'};
      foreach my $s (@{$n-&gt;{'successors'}}) {
          grow($s); # recurse
      }
  }
</pre>

  <p>If you have a game tree for tic-tac-toe, and you grow it
  without limitation (as above), you will soon enough have a fully
  "solved" tree, where every node that <i>can</i> have successors
  <i>does</i>, and all the leaves of the tree are <tt>all</tt> the
  possible endgames (where, in each case, the board is filled). But
  a game of Alak is different from tic-tac-toe, because it can, in
  theory, go on forever. For example, the following sequence of
  moves is quite possible:</p>
  <pre>
  xxxx___oooo
  xxx_x__oooo
  xxx_x_o_ooo
  xxxx__o_ooo (x moved back)
  xxxx___oooo (o moved back)
  ...repeat forever...
</pre>

  <p>So if you tried using our above attempt at a <tt>grow()</tt>
  routine, Perl would happily start trying to construct an
  infinitely deep tree, containing an infinite number of nodes,
  consuming an infinite amount of memory, and requiring an infinite
  amount of time. As the old saying goes: "You can't have
  everything - where would you put it?" So we have to place limits
  on how much we'll grow the tree.</p>

  <p>There's more than one way to do this:</p>

  <p>First, we could grow the tree until we hit some limit on the
  number of nodes we'll allow in the tree.</p>

  <p>Second, we could grow the tree until we hit some limit on the
  amount of time we're willing to spend.</p>

  <p>Third, we could grow the tree until it is fully fleshed out to
  a certain depth.</p>

  <p>Since we already know to track depth (as we did in writing
  <tt>dump_tree()</tt>), we'll do it that way, the third way. The
  implementation for that third approach is also pretty
  straightforward:</p>
  <pre>
  $Max_depth = 3;
  sub grow {
      my $n = $_[0];
      my $depth = $_[1] || 0;
      figure_successors($n)
        unless $depth &gt;= $Max_depth
               or @{$n-&gt;{'successors'}}
               or $n-&gt;{'endgame'};
      }
      foreach my $s (@{$n-&gt;{'successors'}}) {
          grow($s, $depth + 1);
      }
      # If we're at $Max_depth, then figure_successors
      #  didn't get called, so there are no successors
      #  to recurse under -- that's what stops recursion.
  }
</pre>

  <p>If we start from a single node (whether it's a node for the
  starting board <tt>xxxx___oooo</tt>, or for whatever board the
  computer is faced with), set <tt>$Max_depth</tt> to 4, and apply
  <tt>grow()</tt> to it, the tree will grow to include several
  hundred nodes.<sup><a href="tpj0502-0004-ft4.html"><font size=
  "-1">4</font></a></sup></p>

  <p>What we need to derive from that tree is the information about
  the best moves for X. The simplest way to consider the payoff of
  different successors is to just average them - but what we
  average isn't always their immediate payoffs (because that'd
  leave us using only one generation of information), but the
  average payoff of <i>their</i> successors, if any. We can
  formalize this as:</p>

  <p>To figure a node's average payoff:</p>

  <div>
    If the node has successors:<br>
    &nbsp;&nbsp;&nbsp; Figure each successor's average payoff.<br>
    &nbsp;&nbsp;&nbsp; My average payoff is the average of
    theirs.<br>
    Otherwise:<br>
    &nbsp;&nbsp;&nbsp; My average payoff is my immediate payoff.
  </div>

  <p>Since this involves recursing into the successors
  <i>before</i> doing anything with the current node, this will
  traverse the tree <i>in post-order</i>.</p>

  <p>We could work that up as a routine of its own, and apply that
  to the tree after we've applied <tt>grow()</tt> to it. But since
  we'd never grow the tree without also figuring the average
  benefit, we might as well make that figuring part of the
  <tt>grow()</tt> routine itself:</p>
  <pre>
  $Max_depth = 3;
  sub grow {
      my $n = $_[0];
      my $depth = $_[1] || 0;
      figure_successors($n)
        unless $depth &gt;= $Max_depth
               or @{$n-&gt;{'successors'}}
               or $n-&gt;{'endgame'};

      if (@{$n-&gt;{'successors'}}) {
          my $a_payoff_sum = 0;
          foreach my $s (@{$n-&gt;{'successors'}}) {
              grow($s, $depth + 1);  # RECURSE
              $a_payoff_sum += $s-&gt;{'average_payoff'};
          }
 
          $n-&gt;{'average_payoff'} = 
             $a_payoff_sum / @{$n-&gt;{'successors'}};
      } else {
          $n-&gt;{'average_payoff'} = 
             $n-&gt;{'last_move_payoff'};
      }
  }
</pre>

  <p>So, by the time <tt>grow()</tt> has been applied to a node
  (wherever in the tree it is), it will have figured successors if
  possible (which, in turn, sets <tt>last_move_payoff</tt> for each
  node it creates), and will have set <tt>average_payoff</tt>.</p>

  <p>Beyond this, all that's needed is to start the board out with
  a root node of <tt>xxxx___oooo</tt>, and have the computer (X)
  take turns with the user (O) until someone wins. Whenever it is
  O's turn, Games::Alak presents a prompt to the user, letting him
  know the state of the current board, and asking what move he
  selects. When it is X's turn, the computer grows the game tree as
  necessary (using just the <tt>grow()</tt> routine from above),
  then selects the move with the highest average payoff (or one of
  the highest, in case of a tie).</p>

  <p>In either case, "selecting" a move means just setting that
  move's node as the new root of the program's game tree. The
  sibling nodes and their descendants (the boards that
  <i>didn't</i> get selected) and its parent node will be erased
  from memory, since they will no longer be in use (as Perl can
  tell by the fact that nothing holds references to them
  anymore).</p>

  <p>The interface code in Games::Alak (the code that prompts the
  user for his move) actually supports quite a few options besides
  just moving - including dumping the game tree to a specified
  depth (using a slightly fancier version of <tt>dump_tree()</tt>,
  above), resetting the game, changing <tt>$Max_depth</tt> in the
  middle of the game, and quitting the game. Like
  <tt>figure_successors()</tt>, it's a bit too long to print here,
  but interested users are welcome to peruse (and freely modify)
  the code, as well as to enjoy just playing the game. The code is
  available on the TPJ web site.</p>

  <p>Now, in practice, there's more to game trees than this: for
  games with a larger branching factor than Alak (most of them!),
  game trees of depth four or larger would contain too many nodes
  to be manageable, most of those nodes being strategically quite
  uninteresting for either player; dealing with particular game
  trees is therefore a matter of recognizing uninteresting
  contingencies and not bothering to grow the tree under them. For
  example, if O has a choice between moves that puts him in
  immediate danger of X winning and moves that don't, then O won't
  ever choose the dangerous moves, so there's no point in growing
  the tree any further beneath those nodes.</p>

  <p>But this sample implementation should illustrate the basics of
  how to build and manipulate a simple tree structure in memory.
  And once you've understood the basics of tree storage here, you
  should be ready to better understand the complexities and
  peculiarities of other systems for creating, accessing, and
  changing trees, including Tree::DAG_Node, HTML::Element,
  XML::DOM, or related formalisms like XPath and XSL.</p>_ _END_
  _<br>
  <br>
  <hr>

  <p><i>Sean M. Burke (<a href=
  "mailto:sburke@cpan.org">sburke@cpan.org</a>) is a tree-dwelling
  hominid.</i></p>
  <hr>

  <h3>References</h3>

  <p>Dewdney, A[lexander] K[eewatin]. <i>Planiverse: Computer
  Contact with a Two-Dimensional World. Poseidon Press, New York.
  1984.</i></p>

  <p>Knuth, Donald Ervin. <i>Art of Computer Programming, Volume 1,
  Third Edition: Fundamental Algorithms. Addison-Wesley, Reading,
  MA. 1997.</i></p>

  <p>Wirth, Niklaus. <i>Algorithms + Data Structures = Programs.
  Prentice-Hall, Englewood Cliffs, NJ. 1976.</i></p>

  <p>Worth, Stan and Allman Sheldon. <i>George of the Jungle theme.
  (Music by Jay Ward.) Circa 1967.</i></p>

  <p><i>Wirth's classic, currently and lamentably out of print, has
  a good section on trees. I find it clearer than Knuth's (if not
  quite as encyclopedic), probably because Wirth's example code is
  in a block-structured high-level language (basically Pascal),
  instead of in assembler (MIX).</i></p>

  <p><i>Worth's classic, however, is available on the soundtrack to
  the 1997</i> George of the Jungle <i>movie, as performed by The
  Presidents of the United States of America.</i></p>
  <!-- end of article -->
  <!-- link to the previous and next documents relative to the current document -->
  <!-- end of file -->
</body>
</html>
