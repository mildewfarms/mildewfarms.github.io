<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <title>A NAPSTER CLIENT LIBRARY - The Perl Journal, Spring 2000</title><!-- end head -->
  <meta name="generator" content=
  "HTML Tidy for Linux/x86 (vers 12 April 2005), see www.w3.org">
  <meta name="vscategory" content="Perl">
  <meta name="vsisbn" content="">
  <meta name="vstitle" content="A NAPSTER CLIENT LIBRARY">
  <meta name="vsauthor" content="Lincoln D. Stein">
  <meta name="searchdescription" content=
  "Last time in my column I talked about creating a streaming audio server for MPEG level 3 (MP3) files. Continuing with the same theme, today I&rsquo;m giving you a peek at my latest work in progress, a Perl module for the Napster protocol called MP3::Napster.">
  <meta name="vsimprint" content="The Perl Journal">
  <meta name="vspublisher" content="Earthweb">
  <meta name="vspubdate" content="Spring 2000">
  <!-- always update the article title and issue -->

  <!-- link to the previous and next documents relative to the current document -->
</head>

<body bgcolor="#FFFFFF">
  <font face="verdana" size="1">Issue 17, Spring 2000</font>

  <h2 align="center">A Napster Client Library</h2>

  <h4><i>Lincoln D. Stein</i></h4>
  <!-- packages described, if necessary -->

  <div align="center">
    <table border="1" cellspacing="0" cellpadding="5">
      <tr>
        <td align="middle" bgcolor="#CCCC99"><b>URLS</b></td>
      </tr>

      <tr>
        <td>Perl 5.005 with
        threading..............................................CPAN<br>

        MP3::Napster...............................................................CPAN<br>

        MP3::Info.....................................................................CPAN<br>

        Digest::MD5.................................................................CPAN<br>

        Napster
        protocol...http://www.onelist.com/community/napdev/</td>
      </tr>
    </table>
  </div>

  <p>Last time in my column I talked about creating a streaming
  audio server for MPEG level 3 (MP3) files. Continuing with the
  same theme, today I&rsquo;m giving you a peek at my latest work
  in progress, a Perl module for the Napster protocol called
  MP3::Napster.</p>

  <p>Napster (<a href="http://www.napster.com" target=
  "resource window">http://www.napster.com</a>) is an online
  community of music aficionados that combines three major
  functions. First, it provides an IRC-like chat function in which
  members can subscribe to various channels (corresponding to
  musical genres) and exchange messages. Second, Napster provides
  file transfer services. Anyone who logs into a Napster server can
  publish a collection of MP3 files, making the files available for
  peer-to-peer transfer to any other user of the Napster service.
  Finally, Napster provides a search service for all these files,
  depicted in <a href="images/tpj0501-0003-01.gif">Figure 1.</a>
  You can enter a few words from a song&rsquo;s title or the
  artist&rsquo;s name, and in a few seconds the server will list
  all the other users who are sharing a matching song. A click of
  the mouse later, and you can transfer this song to your local
  machine.</p>

  <h3>Napster In Action</h3>

  <p><a href="tpj0501-0004a.html">Example 1</a> will give you a
  better idea of what Napster is all about. This demonstrates a
  session using a small line-oriented Napster client that I wrote
  to demonstrate and test the MP3::Napster module. The session
  begins by prompting me for my username and password. This is
  followed by a server statistics message informing us that there
  are currently 155193 files available for download from 1106
  users, and a message of the day which has been truncated for
  brevity.</p>

  <p>As you can see, I issued the <tt>/search</tt> command for
  songs containing the word <tt>madonna</tt>. This returned 100
  songs (the maximum), most of which are by the artist Madonna.
  (Again, the full list has been truncated for brevity.) The list
  shows the login name of the user who published the file, the
  streamrate of the MP3 file (where larger numbers give higher
  fidelity), the size of the file, the user&rsquo;s modem/link
  speed, and the title of the song. I issued the <tt>/play</tt>
  command to play song number 10 ("La Isla Bonita"). After a second
  the client began to download the song and stream it to an MP3
  decoder. The messages you see following the <tt>/play</tt>
  command come from the command-line <tt>mpg123</tt> program. After
  listening to about twenty seconds of the song, I aborted the
  download with /<tt>abort</tt>, and then issued a
  <tt>/download</tt> command to download a copy to my local disk.
  Downloads occur in the background; throughout the rest of the
  session you will see occasional messages like "<tt>[
  Madonna-La_Isla_Bonita.mp3: 1002932 bytes ]</tt>" indicating the
  current status of the download.</p>

  <p>While this was going on, I joined the Alternative channel
  using the <tt>/join</tt> command, and was greeted by a welcome
  message and a list of active users (truncated for space). The
  transcript now shows intermittent messages from several of these
  users, as well as server messages indicating when users arrive or
  depart the channel. At this point, anything I type other than
  commands were sent as public messages to the channel. Being shy,
  I didn&rsquo;t avail myself of this opportunity.</p>

  <p>I now performed a new search for "<tt>bach</tt>", and got 79
  results, mostly for J.S. Bach, but a few from other artists such
  as Tal Bachman. I initiated another download, and you can now see
  status messages from the Bach download intermixed with messages
  from the ongoing Madonna download. To confirm that both downloads
  were going on simultaneously, I issued the <tt>/status</tt>
  command. After another half minute or so, both downloads were
  complete and I logged out using <tt>/quit</tt>.</p>

  <h3>The Napster Protocol</h3>

  <p>Apart from the ethical issues - the example session shows how
  easily the service invites MP3 piracy - Napster is a very
  interesting networking protocol. First of all, it&rsquo;s one of
  a rare breed of peer-to-peer protocols designed to be used across
  the Internet. Instead of having a step in which Napster users
  upload their MP3 files to a centralized server, all the file
  transfers occur directly between users&rsquo; computers. The
  Napster server acts as a search engine, identifying which users
  own the desired song. When you go to download a song, your
  Napster client contacts the remote user&rsquo;s client and
  arranges a peer-to-peer transfer.</p>

  <p>Another interesting aspect of Napster is its asynchronous
  nature. Most Internet networking protocols are highly
  synchronous. A client issues a request and then waits for a
  response from the server. Responses occur at regular and
  predictable intervals, and never arrive out of order. In
  contrast, the Napster protocol is highly asynchronous. After the
  initial login, the server can send messages to the client at any
  time, even while processing long-running requests such as
  searches. This accommodates the interactive IRC-style chat
  functions, and also allows multiple downloads to proceed in
  parallel.</p>

  <p>These characteristics make writing a Napster client a bit
  challenging. Fortunately, the Napster protocol has been reverse
  engineered by a number of Open Source developers, and you can
  find a partial specification at <a href=
  "http://www.onelist.com/community/napdev/" target=
  "resource window">http://www.onelist.com/community/napdev/</a>.
  As a result there are already a number of freely available
  clients and servers for this protocol. I was able to develop the
  Perl client library by following the specification and reading
  the source code for clarification where necessary.</p>

  <p>Because of the asynchronous nature of the protocol,
  MP3::Napster has to handle multiple threads of execution
  simultaneously. For example, it must be able to capture user
  chitchat while downloading song files. I could have implemented
  this functionality using multiprocessing or multiplexing (see
  "Client-Server Applications" in <a href="../vol4_3/ewtoc.html"
  target="resource window">TPJ #15</a>). However, multiprocessing
  requires the <tt>fork()</tt> system call, which is not available
  on non-Unix platforms, and multiplexing makes the code
  significantly more complex. Instead, I relied on the
  <i>multithreading</i> that first appeared in Perl 5.005. Although
  Perl threading is still experimental, it is more than stable
  enough to use in a non-critical application such as this one. To
  use MP3::Napster, you therefore need to run it under a version of
  Perl built with threading enabled, preferably a recent
  development version. I used version 5.005_63 to develop this
  module.</p>

  <p>The MP3::Napster API</p>

  <p>The MP3::Napster API is quite simple. First, you create a
  MP3::Napster object by calling its <tt>new()</tt> method:</p>
  <pre>
$nap = MP3::Napster-&gt;new;
</pre>

  <p>The new() method attempts to establish a connection with a
  Napster server. There are several servers, so <tt>new()</tt>
  first contacts a master server which then gives it the host name
  and port of the best server to use, where "best" is determined
  using load balancing so that a particular server isn&rsquo;t
  overwhelmed. If the connection fails, <tt>new()</tt> returns
  <tt>undef</tt>. Otherwise it returns an MP3::Napster object,
  which is then used for all interactions with the server.</p>

  <p>The next step will then to be to log in as an existing user,
  or to register as a new user. <tt>login()</tt> has this form:</p>
  <pre>
$email = $nap-&gt;login($nickname, $pass, $link_type);
</pre>

  <p><tt>$nickname</tt> and <tt>$pass</tt> are the user name and
  password. The <tt>$link_type</tt> is a constant indicating the
  speed of your network link, and can be selected from a set of
  constants ranging from <tt>LINK_14K</tt> through
  <tt>LINK_T3</tt>. If successful, the method returns an email
  address. According to the reverse-engineered specification, this
  should be the email address provided by the user at initial
  registration time, but the Napster servers now seem to return
  <tt>anon@napster.com</tt> for all users. If unsuccessful,
  <tt>login()</tt> returns <tt>undef</tt> and sets an error message
  which can be retrieved with <tt>error()</tt>:</p>
  <pre>
$message = $nap-&gt;error;
</pre>For new users, the <tt>register()</tt> method will establish
a new account with the server:
  <pre>
 $result = $nap-&gt;register($nickname, $pass, $attributes);
</pre>

  <p><tt>$attributes</tt> is a hash reference that contains various
  optional fields that will be presented to other users when they
  invoke the <tt>whois</tt> command. Possible fields include
  <tt>name</tt>, <tt>address</tt>, <tt>age</tt>, and even
  <tt>income</tt>. If the registration is successful, the method
  attempts to log in, returning a true value. If registration is
  unsuccessful, the method returns undef and sets
  <tt>$nap-&gt;error</tt> to some error message, typically
  indicating that the desired nickname is already taken.</p>

  <p>Once logged in, you can search for a song with the
  <tt>search()</tt> method, download a song with the
  <tt>download()</tt> method, and check on the status of ongoing
  downloads with the downloads() method. The <tt>search()</tt>
  method has both short and long forms. Its simplest form looks
  like this:</p>
  <pre>
@songs = $nap-&gt;search('Joan Baez');
</pre>

  <p>This will search for any song that has <tt>Joan Baez</tt> in
  the title (the current Napster server treats title and artist
  identically). All matching songs, up to a server limit of 100,
  are returned as an array of MP3::Napster::Song objects.</p>The
  longer form of <tt>search()</tt> looks like this:
  <pre>
@songs = $nap-&gt;search(artist    =&gt; $artist,
                       title     =&gt; $title,
                       linespeed =&gt; $linespeed,
                       bitrate   =&gt; $bitrate,
                       frequency =&gt; $freq,
                       limit     =&gt; $limit);
</pre>

  <p>This lets you select up to <tt>$limit</tt> songs matching a
  set of criteria such as the line speed of the user offering the
  song, the bitrate and sampling frequency of the song, and the
  artist and title. Again, artist and title are not currently
  distinguished; this is provided for future compatibility.</p>

  <p>MP3::Napster::Song objects have a number of attributes that
  you can access via methods. For example, you can learn the
  nickname of the song&rsquo;s owner with its <tt>owner()</tt>
  method and the size of the song file with <tt>size()</tt>:</p>
  <pre>
   $song  = $songs[0];
   $size  = $song-&gt;size;
   $owner = $song-&gt;owner;
</pre>

  <p>To download a song, either call the Song object&rsquo;s
  <tt>download()</tt> method, or pass the song to the Napster
  object&rsquo;s method of the same name. Either method will return
  a MP3::Napster::Download object which you can then use to monitor
  the status of the download. Downloads proceed in a separate
  thread, so you can have multiple simultaneous downloads.</p>
  <pre>
   $download1 = $song-&gt;download;
   $download2 = $nap-&gt;download($songs[1]);
</pre>

  <p>By default, the download will be placed in the current
  directory using a file of the same name as the song title. You
  can change this in one of two ways. First, you can tell the
  Napster object to use a different destination directory with its
  <tt>download_dir()</tt> method:</p>
  <pre>
$nap-&gt;download_dir('/tmp/mp3s');
</pre>

  <p>Alternatively, you can provide the <tt>download()</tt> method
  with a file path or a filehandle. With a path, the method creates
  the indicated file and copies the song into it. If you provide a
  filehandle, the song will be written to it. This allows you to
  open pipes to MP3 decoders for real-time playback:</p>
  <pre>
open (PLAYER,"|/usr/local/bin/mpg123 -");
   $download = $song-&gt;download(\*PLAYER);
</pre>The Napster <tt>downloads()</tt> method returns a list of all
the pending Download objects:
  <pre>
@pending_downloads = $nap-&gt;downloads;
</pre>

  <p>The Download object has a number of methods that you can use
  to check the transmission status. Most useful are the
  <tt>bytes()</tt>, <tt>status()</tt>, and <tt>done()</tt> methods.
  <tt>bytes()</tt> returns the number of bytes that have been
  transferred, <tt>status()</tt> returns a human-readable string
  indicating the status of the transfer, and <tt>done()</tt>
  returns true if the transfer is complete. If you treat the
  Download object as a string, it will automatically be converted
  into a string containing the name of the owner and the song
  title. One way to print out intermittent status messages would be
  a polling loop like this one:</p>
  <pre>
   while (!$download-&gt;done) {
       print "$download: ", $download-&gt;status, "\n";
       sleep 5;
   }
</pre>

  <p>However, a better way to do this is to ask the Napster object
  to wait for <tt>TRANSFER_IN_PROGRESS</tt> events, which are
  issued periodically whenever a certain number of bytes are
  transferred (100K by default, settable using the Download
  object&rsquo;s <tt>interval()</tt> method):</p>
  <pre>
   $download-&gt;interval(200_000);  # get an event every 200K
   while (!$download-&gt;done) {
       $nap-&gt;wait_for(TRANSFER_IN_PROGRESS);
       print "$download: ", $download-&gt;status, "\n";
   }
</pre>

  <p>You&rsquo;ll learn more about the <tt>wait_for()</tt> method
  when we discuss MP3::Napster&rsquo;s event-driven model.</p>

  <p>At any time you can manually set <tt>done()</tt> to a true
  value to abort the transfer. Note that you&rsquo;ll have to
  remove the partially transferred file manually.</p>
  <pre>
$download-&gt;done(1);
</pre>

  <p>Other methods provide access to Napster&rsquo;s chat
  functions. The <tt>channels()</tt> method will return a list of
  MP3::Napster::Channel objects, any of which you can join().</p>
  <pre>
   @channels = $nap-&gt;channels;
   $channels[4]-&gt;join;
</pre>

  <p>You can also call the Napster object&rsquo;s own
  <tt>join_channel()</tt> method in order to join a channel you
  already know about:</p>
  <pre>
$nap-&gt;join_channel('Funk');
</pre>

  <p>Once you have joined a channel, you can send a public message
  with <tt>public_message()</tt>:</p>
  <pre>
$nap-&gt;public_message("hi guys, does anyone here do $]?");
</pre>

  <p>You can obtain a list of logged-in users with
  <tt>users()</tt>. This returns an array of MP3::Napster::User
  objects, which has information about the user&rsquo;s active
  status, link speed, and number of uploads and downloads:</p>
  <pre>
   @users = $nap-&gt;users();
   foreach my $u (@users) {
       print "$u: has been logged on ", $u-&gt;login_time, "\n";
   }
</pre>

  <p>The ability to send private messages to users has not yet been
  implemented, but this will surely be part of the API by the time
  you read this.</p>

  <p>The <tt>whois()</tt> method provides detailed information on a
  particular user, and <tt>ping()</tt> returns true if the
  user&rsquo;s client is reachable. You might want to ping a
  song&rsquo;s owner before trying to download it:</p>
  <pre>
$song-&gt;download if $song-&gt;owner-&gt;ping;
</pre>

  <p>The <tt>disconnect()</tt> method politely severs the
  connection to the Napster server. You must call this method
  before exiting your script, or one or more threads will continue
  to run indefinitely. The best way to ensure that the threads are
  terminated is to include an <tt>END { }</tt> block like this one
  somewhere in your script:</p>
  <pre>
END { $nap-&gt;disconnect }
</pre>

  <h3>MP3::Napster Events</h3>

  <p>As the preceding section shows, it&rsquo;s possible to write a
  fully-automated Perl script that connects to a Napster server,
  searches for new songs by your favorite artist, and downloads
  them. However, in order to deal with Napster&rsquo;s IRC-like
  chat facility, MP3::Napster has to be able to deal with
  asynchronous events such as a user posting a message. The
  MP3::Napster event model takes care of this.</p>

  <p>Anything that happens while connected to a Napster server - a
  user posting a message, a user entering or leaving a channel, a
  download initiating - generates an event. Most events are
  generated directly by the Napster server, but a few are
  synthesized internally by MP3::Napster itself. There are a few
  dozen such events, each of which has a numeric constant exported
  by the module. For example, a <tt>SERVER_STATS</tt> event is sent
  whenever the Napster server decides to send the client its
  connection statistics, something that happens randomly every few
  minutes. The MOTD event is sent once after login when the server
  announces its message of the day. The <tt>USER_JOINS</tt> and
  <tt>USER_DEPARTS</tt> events are generated whenever a user joins
  or departs an active channel.</p>

  <p>To act on a particular event, you can install a callback
  function using the Napster object&rsquo;s <tt>callback()</tt>
  method. Thereafter, whenever an event occurs, your function will
  be notified immediately. Callbacks are passed two arguments, the
  Napster object and an event-specific message. In most cases, the
  messages are strings received directly from the Napster server.
  For instance, when a user joins a channel, the message consists
  of the string <tt>&lt;channel&gt;</tt> <tt>&lt;user&gt;</tt>
  <tt>&lt;sharing&gt;</tt> <tt>&lt;link-type&gt;</tt>, which can be
  decoded with a simple pattern match. In other cases, MP3::Napster
  performs some preprocessing on the message. As an example, the
  <tt>SEARCH_RESPONSE</tt> event, which returns one item in the
  list of songs produced in response to a search, returns a
  MP3::Napster::Song object as the message. The current event code
  can be recovered from the Napster object using its
  <tt>event_code()</tt> method, and the name of the event with
  <tt>event()</tt>.</p>

  <p>For example, this code fragment installs a callback routine
  for the <tt>PUBLIC_MESSAGE_RECVD</tt> message. The message in
  this case is a string containing the channel name, the nickname
  of the user sending the message, and the message the user sent,
  all separated by spaces. The code creates an anonymous subroutine
  that processes and acts on the message. It then installs this
  subroutine using the Napster object&rsquo;s <tt>callback()</tt>
  method:</p>
  <pre>
   $mysub = sub {
      my ($napster,$message) = @_;
      my ($channel,$user,$msg) = $message =~ /^(\S+) (\S+) (.*)/;
      print "[$channel] $user says: $msg\n";
   };
   $nap-&gt;callback($mysub);
</pre>

  <p>There are three events involved in downloads:
  <tt>TRANSFER_STARTED</tt>, sent just after the peer-to-peer
  transfer is initiated; <tt>TRANSFER_IN_PROGRESS</tt>, sent at
  user-controllable intervals during the transfer; and
  <tt>TRANSFER_DONE</tt>, sent after the transfer completes
  (whether successfully or prematurely). TRANSFER_IN_PROGRESS is
  useful for printing out intermittent status messages, while
  <tt>TRANSFER_DONE</tt> can be used to detect incomplete downloads
  and remove the leftover files. Here is how it&rsquo;s often
  used:</p>
  <pre>
   $nap-&gt;callback(TRANSFER_DONE,
     sub { 
       my ($nap, $download) = @_;
       my $path = $download-&gt;local_path;
       unlink $path if $path &amp;&amp; 
$download-&gt;status ne 'download complete';
     });
</pre>

  <p>The <tt>TRANSFER_DONE</tt> callback subroutine gets the
  Napster and Download objects. It recovers the path to the local
  file by calling the <tt>local_path()</tt> method. If the path
  exists and the <tt>status()</tt> method does not return
  "<tt>download complete</tt>", the path is unlinked.</p>

  <p>Sometimes it&rsquo;s more natural to wait for a particular
  event to occur rather than install a callback. The
  <tt>wait_for()</tt> method is designed for this purpose. Pass
  <tt>wait_for()</tt> a single event code or an anonymous list of
  such codes, and optionally a timeout in seconds. It will put the
  current thread to sleep until one of the listed events occurs or
  the timeout expires. In the former case, <tt>wait_for()</tt>
  returns a two-element list consisting of the result code and a
  message (event-dependent). In the case of a timeout,
  <tt>wait_for()</tt> returns an empty list.</p>

  <p>This facility provides a simple way to wait for all pending
  downloads to complete before your script exits. In the following
  example, we assume that <tt>@songs</tt> contains a list of songs
  you desire to download.</p>
  <pre>
   # initiate downloads
   foreach (@songs) { $_-&gt;download }
 
   # wait for them to finish
   while (@d = $nap-&gt;downloads) {
       warn "waiting for ", scalar(@d), 
" downloads to finish...\n";
       # sleep until one is done
      ($event, $download) = $nap-&gt;wait_for(TRANSFER_DONE);   
      warn "$download is done...\n";
   }
</pre>

  <h3>The <tt>napster.pl</tt> Client</h3>

  <p>shows the code for the simple interactive client I used to
  test and debug the MP3::Napster module. We&rsquo;ll go over it
  lightly; you can fill in the details from the description of the
  API I gave above.</p>

  <p>The script begins by creating a new MP3::Napster object and
  declaring an <tt>END{}</tt> block to call the
  <tt>disconnect()</tt> method before the script exits. If need be,
  it creates a directory to hold downloaded songs and points the
  Napster object at it by calling the <tt>download_dir()</tt>
  method.</p>

  <p>Now the script sets up the callbacks. The
  <tt>setup_callbacks()</tt> subroutine is lengthy but
  straightforward. Callbacks are installed for three messages:
  <tt>PUBLIC_MESSAGE_RECVD</tt>, <tt>USER_JOINS</tt>, and
  <tt>USER_DEPARTS</tt>, all of which support the chat facility.
  The <tt>CHANNEL_ENTRY</tt> event occurs when the server returns a
  list of channels that the user can join, while the
  <tt>CHANNEL_TOPIC</tt> event carries a welcome message sent when
  a user first joins a channel. More callbacks are installed for
  <tt>SEARCH_RESPONSE</tt>, sent by the server every time it
  returns a song in response to a search query, as well as for
  <tt>SERVER_STATS</tt> and <tt>MOTD</tt>, the message of the day.
  In addition, the script installs callbacks for
  <tt>TRANSFER_IN_PROGRESS</tt> and <tt>TRANSFER_DONE</tt>. By and
  large, the callbacks simply print out status messages so that the
  user knows what&rsquo;s going on.</p>

  <p>After installing the callbacks, the client attempts to log in.
  The <tt>login()</tt> routine prompts the user for his name and
  password. New registrations are not yet supported by the client,
  but currently the server accepts any unused username/password
  combination.</p>

  <p>If the login is successful, the script enters a loop in which
  it accepts lines of input from standard input. If the input
  begins with a slash command (<tt>/join</tt>, for example), it
  passes the command to the appropriate subroutine. Otherwise it
  treats the line as a public message, and attempts to send it to
  the current channel.</p>

  <p>The individual commands are simple front ends to the
  MP3::Napster API methods. For example, the <tt>/search</tt>
  command invokes a subroutine named <tt>search()</tt>, which in
  turn passes the rest of the command line to
  <tt>MP3::Napster-&gt;search()</tt>. The returned Song objects, if
  any, are placed in a global array named <tt>@SEARCH</tt>. The
  <tt>/download</tt> command invokes <tt>download()</tt>, which
  splits the rest of the command line into a set of numeric
  arguments. These arguments are then used to index into the
  <tt>@SEARCH</tt> array and call each selected Song object&rsquo;s
  <tt>download()</tt> method.</p>

  <h3>The Threaded Module Design</h3>

  <p>A few words about the design of the MP3::Napster module
  itself. Because it operates in a multithreaded environment, I had
  to take special care to make it thread-safe. This involves the
  following general precautions:</p>&bull;&nbsp; Avoid updating
  global variables<br>
  &bull;&nbsp; Use accessors to access and change object state
  variables<br>
  &bull;&nbsp; Mark methods that change state variables as "locked
  methods"<br>

  <p>The problem with threads is that a <i>context switch</i> can
  occur between one thread and another without warning. If one
  thread is in the midst of working with a global variable, and
  another thread changes the global&rsquo;s value, very confusing
  results will ensue. Using object data (e.g. the contents of a
  blessed hash) limits the havoc that a thread context switch can
  wreak because it is easier to control access to an object&rsquo;s
  data, and there is often a one-to-one correspondence between an
  object and a thread.</p>

  <p>To further ensure stability, critical methods can be marked as
  <i>locked</i>. An example is the MP3::Napster
  <tt>download_dir()</tt> method, which gets and sets the directory
  in which downloaded songs are stored:</p>
  <pre>
   sub download_dir {
       use attrs qw(locked method);
       my $self = shift;
       return defined $_[0] ? $self-&gt;{download_dir} = $_[0]
                            : $self-&gt;{download_dir};
   }
</pre>

  <p>After recovering the object reference from the subroutine
  argument list, the method looks at what&rsquo;s left. If there is
  a defined value, it is used to change the value of the
  <tt>download_dir</tt> key. Otherwise, the current value of
  <tt>download_dir</tt> is returned. The section relevant to
  threading is the <tt>use attrs</tt> line. On entry into the
  method, Perl tries to lock the object. It retains the lock until
  the method has finished executing, preventing other threads from
  obtaining the value of <tt>download_dir</tt> until the update has
  completed.</p>

  <p>All methods that alter MP3::Napster&rsquo;s state variables
  are locked in this way.</p>

  <p>Another issue in designing MP3::Napster was dealing with the
  asynchronous and unpredictable nature of messages coming from the
  Napster server. In order to handle this, the module launches a
  separate thread which does nothing but listen for incoming
  messages and pass them to callbacks for processing. The
  interesting action begins with the <tt>connect()</tt> method,
  which is called during the Napster initialization procedure:</p>
  <pre>
   sub connect {
       use attrs qw(locked method);
       my $self = shift;
       return $self-&gt;error('No server address defined') 
unless $self-&gt;server;
   
       my $sock = IO::Socket::INET-&gt;new($self-&gt;server);
       return $self-&gt;error("Could not connect to napster 
server: $!") unless $sock;
       $self-&gt;install_default_callbacks;
       return unless $self-&gt;{receive_tid} = 
Thread-&gt;new(\&amp;receive_loop,$self);
       $self-&gt;{receive_tid}-&gt;detach;
       return $self-&gt;socket($sock);
   }
</pre>

  <p>The <tt>connect()</tt> method runs as a locked method. It
  recovers the address of a Napster server from the
  <tt>server()</tt> method (which I won&rsquo;t show here), and
  attempts to connect a TCP/IP socket to the server using Graham
  Barr&rsquo;s IO::Socket::INET module. If successful,
  <tt>connect()</tt> installs a few default callback routines, and
  then calls <tt>Thread-&gt;new()</tt> to launch a new thread
  running the <tt>receive_loop()</tt> method. If successful, the
  new thread is made independent of the main thread by calling its
  <tt>detach()</tt> method.</p>The <tt>receive_loop()</tt> method
  runs in the new thread. It&rsquo;s extremely simple:
  <pre>
   sub receive_loop {
       my $self = shift;
       while (my($rc,$message) = $self-&gt;recv) {
          $self-&gt;process_message($rc, $message);
       }
   }
</pre>

  <p>Basically, <tt>receive_loop()</tt> calls the <tt>recv()</tt>
  method repeatedly to retrieve an event code and message from the
  server. These values are then passed to another method, named
  <tt>process_message()</tt>, for processing. The <tt>recv()</tt>
  method is also straightforward:</p>
  <pre>
   sub recv {
       my $self = shift;
       my $sock = $self-&gt;socket;
    
       # read four bytes from the input stream
       my $data;
       my $bytes = read($sock, $data, 4);
       return unless $bytes;
   
       # unpack it into length and type
       my ($length,$event) = unpack("vv", $data);
       
       # read the rest of the data
       if ($length &gt; 0) {  
           return unless read($sock,$data,$length);
           return ($event,$data);
       }
       return $event;
   }
</pre>

  <p>The events sent by the Napster server consist of a two-byte
  message length, a two-byte event code, and a variable-length
  message. <tt>recv()</tt> first reads four bytes of data from the
  socket and unpacks the data into the length and event code. If
  the message length is greater than zero, <tt>recv()</tt> performs
  a second read to get the message data. This information is then
  returned to the caller.</p>

  <p>Once this is all running, the client has two main threads of
  execution. One is the original thread used to send command data
  to the Napster server, and the other is the event thread that
  runs the <tt>receive_loop()</tt>. Other threads are launched as
  necessary to handle the peer-to-peer transfer and for other
  specialized tasks.</p>

  <p>Although the two threads are essentially independent, they do
  need to be synchronized from time to time. A typical scenario
  occurs when the command thread sends out a search request and the
  event thread receives and processes the result. The command
  thread wants to clear the previous search results if any, issue
  the search command, and then wait for the event thread to return
  the new search results. But how can the command thread do this
  when it has no link to the event thread?</p>

  <p>The key is to use a locked variable and a combination of the
  <tt>cond_wait()</tt> and <tt>cond_signal()</tt> functions, both
  of which are part of Perl&rsquo;s standard Thread package.</p>

  <p>Here&rsquo;s how it works. One thread selects a pre-agreed on
  variable called a <i>condition variable</i> and locks it. The
  second thread continues to run until it reaches a synchronization
  point, at which point it tries to lock the same variable.
  However, the first thread already has the lock on this variable,
  so the second thread stalls. The first thread is then free to do
  whatever setup it likes, such as clearing state variables and
  sending queries to the server. When it has finished its setup it
  calls <tt>cond_wait()</tt> on the locked variable. This call
  atomically puts the first thread to sleep and unlocks the
  variable.</p>

  <p>Now that the variable is unlocked, the second thread wakes up
  and acquires the lock. It does whatever processing it needs to
  (such as parsing the incoming search results). The second thread
  then calls <tt>cond_signal()</tt> on the locked variable. This
  wakes up the first thread, which reacquires the lock. The first
  thread is now free to act on the information processed by the
  second thread while the first one was asleep. The second thread,
  meanwhile, again stalls at the synchronization point until the
  first thread again calls <tt>cond_wait()</tt> or simply gives up
  the lock for good.</p>

  <p>The <tt>wait_for()</tt> and <tt>process_message()</tt> methods
  illustrate how this works. <tt>wait_for()</tt> is called by the
  command thread whenever it needs to stop and wait for a
  particular event or set of events. A simplified version of the
  subroutine is shown below:</p>
  <pre>
   sub wait_for {
       my $self = shift;
       my $ec = shift;
       my %ok = (ref $ec eq 'ARRAY') ? map {$_=&gt;1} @$ec : ($rc=&gt;1);
   
       lock $self-&gt;{ec};
   
       $self-&gt;ec('');
       foreach (keys %ok) { $self-&gt;message($_,'')  }
   
       while (1) {
           cond_wait $self-&gt;{ec};
           last if $ok{$self-&gt;ec};
       }
   
      return wantarray ? ($self-&gt;ec,$self-&gt;message($self-&gt;ec)) 
                     : $self-&gt;ec;
   }
</pre>

  <p>The <tt>wait_for()</tt> method accepts either a single event
  code or an array of such codes, and stores them in a variable
  named <tt>$ec</tt> (for "event code"). If <tt>$ec</tt> is a
  scalar it is stored as a key into the <tt>%ok</tt> hash.
  Otherwise it is dereferenced and all the desired event codes are
  stored into this hash.</p>

  <p>The condition variable in this case is a key in the Napster
  object hash named <tt>ec</tt>. In addition to being a condition
  variable, it is also used by the module to store the last event
  code received. <tt>wait_for()</tt> locks the condition variable,
  thereby preventing the event thread from changing it until it is
  unlocked. The method now clears the contents of ec by calling the
  <tt>ec()</tt> accessor to set it to an empty string, and
  furthermore clears the messages associated with any of the
  desired events, by calling the <tt>message()</tt> accessor.</p>

  <p>The method now enters a <tt>while()</tt> loop. It first calls
  <tt>cond_wait()</tt> in order to release the lock on the
  condition variable and allow other threads (and in particular the
  event thread) to access it. The method then goes to sleep until
  another thread calls <tt>cond_signal()</tt> on the variable. When
  it wakes up, <tt>wait_for()</tt> checks what&rsquo;s in
  <tt>ec</tt> by calling the <tt>ec()</tt> method. If this is one
  of the desired events, the loop terminates. Otherwise it goes
  back to waiting.</p>

  <p>At the end of the subroutine, the method returns the event
  code and event message in an array context, and the returned
  event code only in a scalar context.</p>

  <p>The actual subroutine differs from this by having an
  additional half-dozen lines of code that deals with timeouts. If
  a timeout is requested, the method launches a new thread that
  sleeps for the indicated period of time and then locks
  <tt>ec</tt>, sets its value to <tt>TIMEOUT</tt>, and calls
  <tt>cond_signal</tt>. When <tt>wait_for()</tt> wakes up, it sees
  that <tt>ec()</tt> contains <tt>TIMEOUT</tt> and returns an
  undefined value.</p>

  <p>The <tt>process_message()</tt> method runs within the event
  thread. Here is a slightly simplified version which excludes some
  debugging code:</p>
  <pre>
sub process_message {
    my $self = shift;
    my ($ec, $message) = @_;
    
    # wait until someone has unlocked {ec}
    lock $self-&gt;{ec};
    
    $self-&gt;ec($ec);
    $self-&gt;error($message) if $ERRORS{$ec};
    
    # transform some messages
    $message = $MESSAGE_CONSTRUCTOR{$ec}-&gt;new($self, $message) 
               if $MESSAGE_CONSTRUCTOR{$ec};
   
    if ($MULTILINE_CODE{$ec}) {
        lock $self;
        push (@{$self-&gt;{messages}{$ec}}, $message);
    } else {
        $self-&gt;message($ec, $message);
    }
   
    $self-&gt;callback($ec)-&gt;($self, $message) 
if $self-&gt;callback($ec);
    cond_signal $self-&gt;{ec};
}
</pre>

  <p>The method begins by copying the event code and associated
  message from the subroutine array. It then acquires a lock on
  <tt>ec</tt>, possibly synchronizing itself on the
  <tt>wait_for()</tt> method&rsquo;s <tt>cond_wait()</tt>. It uses
  the <tt>ec()</tt> accessor to remember the current event code,
  and also checks a global <tt>%ERRORS</tt> hash containing a list
  of event codes that signify error conditions. If appropriate, the
  method remembers the error message by calling the
  <tt>error()</tt> accessor.</p>

  <p>Some event messages are to be treated as plain strings, but
  others are transformed into specialized objects (such as Song and
  User objects). The next two lines of code check a list of special
  event codes and invoke the <tt>new()</tt> constructor to
  transform any messages falling into this category. Similarly,
  some events are multivalued (such as search results), while
  others are single valued (such as the current server statistics).
  The method checks the <tt>%MULTILINE_CODE</tt> hash, and if the
  event code falls into this category its message is pushed onto an
  array of messages associated with this event. Otherwise the
  <tt>message()</tt> accessor is used to replace the current event
  message.</p>

  <p><tt>process_message()</tt> now invokes the callback for the
  event, if any. Consequently the callback subroutine will be
  executed within the event thread rather than the command thread.
  Finally, the method invokes <tt>cond_signal()</tt> to wake up any
  threads waiting for an update to <tt>ec</tt>.</p>

  <h3>Limitations of the Client</h3>

  <p>As I said at the beginning of this article, MP3::Napster is
  still a work in progress. Not all aspects of the Napster protocol
  are implemented. In particular, the module can&rsquo;t yet handle
  incoming connections (uploads). This will involve creating yet
  another thread to listen for and process incoming connections.
  The ability to send private messages to other users on this
  system is not implemented, as well as a number of functions that
  require administrative access, such as the ability to boot a user
  off the server. Most of these functions will be available by the
  time you read this article.</p>

  <p>The command-line client is extremely primitive. Because it
  uses no screen control, your typing can be interrupted by
  asynchronous messages from the server and other users. I get
  around this by running the client in an Emacs shell window, but
  clearly this isn&rsquo;t for everyone. It would be a nice
  exercise to convert the client into a curses-based application
  for terminal windows, or perhaps a Tk or GTk graphical
  application. Any takers?</p>_ _END_ _<br>
  <br>
  <hr>
  <i>Lincoln Stein wrote CGI.pm.</i> <!-- end of article -->
  <!-- link to the previous and next documents relative to the current document -->
  <!-- end of file -->
</body>
</html>
