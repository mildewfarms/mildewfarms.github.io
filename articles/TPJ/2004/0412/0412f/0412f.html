
<html>
<head>
<title>December, 2004: Letter from the Editor</title>
</head>

<body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000">
<!--Copyright &#169; The Perl Journal-->

<h1>Emulation Evolution</h1>
<p><i>The Perl Journal</i> December, 2004</p>



<hr>


<p>Programming often boils down to modeling something. User interfaces that we build often look like real-world physical objects. Our applications sometimes model physical tasks we perform, such as punching buttons on a keypad or wiring objects together with cables. The analog world is so often virtualized that we don't even bat an eye at it anymore. In fact, we expect it, and take it for granted.</p>

<p>But we don't just model the analog world. We run entire operating systems in emulation. We now digitally model the digital. This isn't new&#151;I distinctly remember running DOS in emulation on a Macintosh back in '92. But the power and usability of such emulation has increased dramatically in recent years. Take VMWare, for instance. The fact that Sam Tregar (see his article on page 13) can run not just one, but six virtual operating systems on one machine attests to just how smart and useful our emulation has become.</p>

<p>The rise in emulation and the concept of the virtual machine at one time promised an end to platform dependency. The Java VM was supposed to allow us to stop worrying about what hardware and underlying OS we were running. But the devil was in the details, of course. The Java VM has provided some wonderful benefits, to be sure, but it's hardly the liberation we were promised. The phrase "platform independent" still comes with many qualifications and exceptions, whether you program in Perl, C++, Java, or any other language you care to name.</p>

<p>As long as multiple operating systems and multiple types of microprocessors exist, the virtual machine designer's job will remain one of lowest common denominators&#151;figuring out what subset of functionality exists on all host platforms, and limiting the VM to that subset. There are ways to fudge that, of course, but you'll never be able to, for instance, provide accelerated 3D rendering on a system with no accelerated 3D video hardware. Highly cross-compatible emulation is directly opposed to platform-specific optimization. That's a law that can't be gotten around, and it's what has kept us from that hardware- and OS-agnostic promised land. We want optimization and performance, so we have to care about what's under the hood.</p>

<p>Within those limitations, however, emulation can do wonders. It's very useful when you aren't particularly concerned about performance, but you just have to run that Mac program on your PC, or vice versa. And when emulation is freed from the yoke of cross-platform operation, it can really shine. Apple's "Classic" environment is a good example. It allows the execution of OS 9 apps in OS X, and because it doesn't need to run on multiple platforms, it can be highly optimized. Classic apps on the Mac run impressively fast. With some apps, performance is indistinguishable from native operation.</p>

<p>While we haven't entered the emulation promised land, there's still a lot to like about the current state of emulation. We get access to applications that would otherwise require a prohibitively expensive hardware purchase. We get some apps that, if carefully designed, can be mostly cross platform. And we get a backwards-compatibility insurance policy for cherished or necessary older programs. All in all, I'd call that real progress.</p>

<p>
Kevin Carlson<br>
Executive Editor<br>
<i>The Perl Journal</i>
<p>
</body>
</html>