
<html>
<head>
<title>May, 2004: Perl Medic: Optimizing Legacy Code</title>
</head>

<body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000">
<!--Copyright &#169; The Perl Journal-->

<h1>Perl Medic: Optimizing Legacy Code</h1>
<p><i>The Perl Journal</i> May, 2004</p>
<h2></h2>


<h3>By Jack J. Woehr</h3>


<I>Jack J. Woehr is an independent consultant and team mentor practicing in Colorado. He can be contacted at http://www.softwoehr.com.</I>

<hr>


<p>Perl Medic: Optimizing  Legacy Code<br>
Peter J. Scott <br>
Addison-Wesley, 2004 <br>
336 pp, $34.99<br>
ISBN 0-201-79526-4<br></p>


<p>The subtitle of <i>Perl Medic</i>, "Optimizing Legacy Code," sounds like bizspeak. A more nerdly description of this book might be, "Maintaining Perl code whether it's written by you or others and whether or not it was designed to be maintained." Apropos the latter, author Peter J. Scott is cheerfully free to suggest the classic solution&#151;a total rewrite&#151;where appropriate. That, by itself, would have made a very short book and an even shorter review. Luckily for us, there are many more solutions and development patterns to discuss regarding Perl maintenance. <i>Perl Medic</i>'s target audience begins at the level of intermediate Perl programmers who have been "working with Perl long enough to have heard terms like scalar, array, and hash," but reaches well beyond that entry level.</p>

<p>In many cases, the patient, a sick or dying Perl corpus, can be saved. One half of the value in <i>Perl Medic</i> is in the diagnostic and remedial techniques Scott provides. The residual value of the book are found in the practices that make your Perl code more maintainable. Maintainability strategies for Perl code have sometimes been obscure, even to experienced Perl programmers. It's been a hair-raising roller-coaster ride watching the language develop. The degree of cult participation traditionally necessary to stay on top of trends that could unexpectedly invalidate a seemingly reasonable application lifecycle taxes the patience of working developers. Scott offers the reader a compendium of what one might call "simplest-best" practices that are easily followed.</p>

<p>In the first four chapters, after introducing his subject and offering a few practical tips for achieving handover in some other fashion than having the code dumped onto your disk, Scott starts off reasonably enough by examining the use of Perl warnings.He continues with forensic techniques for evaluating the code and your tasks in taking up the code. Then testing is introduced, right where it should be, at the point before you start modifying code. Next comes the actual labor of rewriting code, beginning from style and variable names&#151;in no other language than Forth do variable names seem to matter so much as in Perl&#151;and concluding with antipatterns and the ongoing evolution of the code.</p>

<p>In the fifth and sixth chapters, the book moves on to issues of discipline, cognition, and semantics (or so I would characterize it) with an overarching theme of knowing why you are coding the way you are coding, why you are following certain patterns, and how to recognize code that follows blindly misunderstood or only partially grasped patterns. Then there's a complete chapter on upgrading, covering Perl 4 and 12 earlier releases of Perl 5 to Perl 5.8.3, the latter being the stable version used in the book, followed by chapters on CPAN and the use of modules&#151;other people's and your own.</p>

<p>In Chapter 9, the books returns to forensics: static analysis, superfluous code, inefficient code, and debugging. Chapter 10 deals with robustness and Chapter 11 is a case study. There follows a brief wrap-up, which concludes with the sage (albeit utterly self-evident) warning that, "One day your code, too, will be inherited by someone else."</p>

<p>This is really a working programmer's book. Section 4.10 casts an interesting light on this point. In it, the author introduces a pithy and sometimes witty several-pages-long list of steps and considerations in program evolution, after begging off from expanding on each of these points on grounds of time and space. As they say in the East, "The good horse runs at the shadow of the whip." While Scott wriggles himself out from under the onus of spelling everything out, he concomitantly liberates the reader from having to slog through a bog of minutiae. It's the sort of bullet-list help a busy senior developer in the next cubicle might e-mail you in response to a very broad and general question. The subtext in both situations is, "If you're good enough to do this sort of work, this is all the help you need." Serendipity!</p>

<p><i>Perl Medic</i> is a cute little book with the flavor of a 1980's programming language tome. Each chapter is introduced by a relevant (or occasionally irrelevant) quote and a cartoon &agrave; la Leo Brodie. Some of the quotations are rather apt: My favorite is Chapter 2's quote from Henrik Ibsen about how one's outlook may be haunted by the ghosts of "dead ideas and lifeless old beliefs," a concept many team programmers will greet with a sigh of recognition. Scott has a sharp eye for fluff and ambiguity. He communicates his insights in a "teach a man to fish" fashion that is equally rewarding to the reader, whether that reader is immersed in a chapter or browsing a paragraph for tips. The writing is colloquial and intimate and exhibits very little dependency between chapters, making this an open-anywhere book. The publication production quality is high, and the book is gratifyingly well indexed.</p>

<p>The book's web site is http://www.perlmedic.com/, where you can download the files that accompany the book after you answer a question about the book. Or, if you're tired of reading, you can click on links for the author's consulting services.</p>
<p><b>TPJ</b></p>




</body>
</html>