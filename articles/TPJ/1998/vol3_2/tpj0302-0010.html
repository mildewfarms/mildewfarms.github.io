<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <title>Threads - The Perl Journal, Summer 1998</title>
  <meta name="generator" content=
  "HTML Tidy for Linux/x86 (vers 12 April 2005), see www.w3.org">
  <meta name="vscategory" content="Perl">
  <meta name="vsisbn" content="">
  <meta name="vstitle" content="Threads">
  <meta name="vsauthor" content="Dan Sugalski">
  <meta name="searchdescription" content=
  "One of the most prominent new features of Perl 5.005 is the inclusion of threads. Threads make a number of things a lot easier, and are a very useful addition to your bag of programming tricks.">
  <meta name="vspublisher" content="Earthweb">
  <meta name="vsimprint" content="The Perl Journal">
  <meta name="vspubdate" content="Summer 1998">
  <!-- always update the article title and issue -->

  <!-- end head -->
</head>

<body>
  <font face="verdana" size="1">Issue 10, Summer 1998</font>

  <h2 align="center">Threads</h2>

  <h4><i>Dan Sugalski</i></h4>
  <!-- packages described, if necessary -->

  <div align="center">
    <table border="1" cellspacing="0" cellpadding="5">
      <tr>
        <th colspan="2" bgcolor="#CCCC99">PACKAGES USED</th>
      </tr>

      <tr>
        <td align="center">Package</td>

        <td align="center">Version</td>
      </tr>

      <tr>
        <td><b>Perl</b></td>

        <td>5.004_50 or higher</td>
      </tr>
    </table>
  </div>

  <p>One of the most prominent new features of Perl 5.005 is the
  inclusion of threads. Threads make a number of things a lot
  easier, and are a very useful addition to your bag of programming
  tricks.</p>

  <div align="center">
    <h3>WHAT IS A THREAD ANYWAY?</h3>
  </div>

  <p>A thread is a flow of control through a program with a single
  execution point.</p>

  <p>Sounds an awful lot like a process, doesn't it? Well, it
  should. Threads are one of the pieces of a process. Every process
  has at least one thread and, up until now, every process running
  Perl had only one thread. With 5.005, though, you can create
  extra threads. We're going to show you how, when, and why.</p>

  <h4>THREADED PROGRAM MODELS</h4>

  <p>There are three basic ways that you can structure a threaded
  program. Which model you choose depends on what you need your
  program to do. For many non-trivial threaded programs you'll need
  to choose different models for different pieces of your
  program,</p>

  <p><b>Boss/Worker.</b> The boss/worker model usually has one
  'boss' thread and one or more 'worker' threads. The boss thread
  gathers or generates tasks that need to be done, then parcels
  those tasks out to the appropriate worker thread.</p>

  <p>This model is common in GUI and server programs, where a main
  thread waits for some event and then passes that event to the
  appropriate worker threads for processing. Once the event has
  been passed on, the boss thread goes back to waiting for another
  event.</p>

  <p>The boss thread does relatively little work. While tasks
  aren't necessarily performed faster than with any other method,
  it tends to have the best user-response times.</p>

  <p><b>Work Crew.</b> In the work crew model, several threads are
  created that do essentially the same thing to different pieces of
  data. It closely mirrors classical parallel processing and vector
  processors, where a large array of processors do the exact same
  thing to many pieces of data.</p>

  <p>This model is particularly useful if the system running the
  program will distribute multiple threads across different
  processors. It can also be useful in ray tracing or rendering
  engines, where the individual threads can pass on interim results
  to give the user visual feedback.</p>

  <p><b>Pipeline.</b> The pipeline model divides up a task into a
  series of steps, and passes the results of one step on to the
  thread processing the next. Each thread does one thing to each
  piece of data and passes the results to the next thread in line.
  This model makes the most sense if you have multiple processors
  so two or more threads will be executing in parallel, though it
  can often make sense in other contexts as well. It tends to keep
  the individual tasks small and simple, as well as allowing some
  parts of the pipeline to block (on I/O or system calls, for
  example) while other parts keep going. If you're running
  different parts of the pipeline on different processors you may
  also take advantage of the caches on each processor.</p>

  <p>This model is also handy for a form of recursive programming
  where, rather than having a subroutine call itself, it instead
  creates another thread. Prime and Fibonacci generators both map
  well to this form of the pipeline model. (A version of a prime
  number generator is presented later on.)</p>

  <p><b>Listing 1</b>. <a href="tpj0302-0010a.html">PERL THREADS
  ARE DIFFERENT</a></p>

  <h4>NATIVE THREADS</h4>

  <p>There are several different ways to implement threads on a
  system. How threads are implemented depends both on the vendor
  and, in some cases, the version of the operating system. Often
  the first implementation will be relatively simple, but later
  versions of the OS will be more sophisticated.</p>

  <p>While the information in this section is useful, it's not
  necessary, so you can skip it if you don't feel up to it.</p>

  <p>There are three basic categories of threads - user - mode
  threads, kernel threads, and multiprocessor kernel threads.</p>

  <p><b>User-mode threads</b> are threads that live entirely within
  a program and its libraries. In this model, the OS knows nothing
  about threads. As far as it's concerned, your process is just a
  process.</p>

  <p>This is the easiest way to implement threads, and the way most
  OSes start. The big disadvantage is that, since the OS knows
  nothing about threads, if one thread blocks they all do. Typical
  blocking activities include most system calls, most I/O, and
  things like <tt>sleep()</tt>.</p>

  <p><b>Kernel threads</b> are the next step in thread evolution.
  The OS knows about kernel threads, and makes allowances for them.
  The main difference between a kernel thread and a user-mode
  thread is blocking. With kernel threads, things that block a
  single thread don't block other threads. This is not the case
  with user-mode threads, where the kernel blocks at the process
  level and not the thread level.</p>

  <p>This is a big step forward, and can give a threaded program
  quite a performance boost over non-threaded programs. Threads
  that block performing I/O, for example, won't block threads that
  are doing other things. Each process still has only one thread
  running at once, though, regardless of how many CPUs a system
  might have.</p>

  <p>Since kernel threading can interrupt a thread at any time,
  they will uncover some of the implicit locking assumptions you
  may make in your program. For example, something as simple as
  <tt>$a = $a + 2</tt> can behave unpredictably with kernel threads
  if <tt>$a</tt> is visible to other threads, as another thread may
  have changed <tt>$a</tt> between the time it was fetched on the
  right hand side and the time the new value is stored.</p>

  <p><b>Multiprocessor Kernel Threads</b> are the final step in
  thread support. With multiprocessor kernel threads on a machine
  with multiple CPUs, the OS may schedule two or more threads to
  run simultaneously on different CPUs.</p>

  <p>This can give a serious performance boost to your threaded
  program, since more than one thread will be executing at the same
  time. As a tradeoff, though, any of those nagging synchronization
  issues that might not have shown with basic kernel threads will
  appear with a vengeance.</p>

  <p>In addition to the different levels of OS involvement in
  threads, different OSes (and different thread implementations for
  a particular OS) allocate CPU cycles to threads in different
  ways.</p>

  <p><b>Cooperative multitasking systems</b> have running threads
  give up control if one of two things happen. If a thread calls a
  yield function, it gives up control. It also gives up control if
  the thread does something that would cause it to block, such as
  perform I/O. In a cooperative multitasking implementation, one
  thread can starve all the others for CPU time if it so
  chooses.</p>

  <p><b>Preemptive multitasking systems</b> interrupt threads at
  regular intervals while the system decides which thread should
  run next. In a preemptive multitasking system, one thread usually
  won't monopolize the CPU.</p>

  <p>On some systems, there can be cooperative and preemptive
  threads running simultaneously. (Threads running with real-time
  priorities often behave cooperatively, for example, while threads
  running at normal priorities behave preemptively.)</p>

  <p><b>Listing 2</b>. <a href="tpj0302-0010b.html">THREADSAFE
  MODULES</a></p>

  <div align="center">
    <h3>THREAD BASICS</h3>
  </div>

  <p>The core Thread module provides the basic functions you need
  to write threaded programs. In the following sections we'll cover
  the basics, showing you what you need to do to create a threaded
  program. After that, we'll go over some of the features of the
  Thread module that make threaded programming easier.</p>

  <h4>BASIC THREAD SUPPORT</h4>

  <p>Thread support is a Perl compile-time option - it's something
  that's turned on or off when Perl is built at your site, rather
  than when your programs are compiled. If your Perl wasn't
  compiled with thread support enabled, then any attempt to use
  threads will fail.</p>

  <p>Remember that the threading support in 5.005 is in beta
  release, and should be treated as such. You should expect that it
  may not function entirely properly, and the thread interface may
  well change some before it is a fully supported, production
  release. The beta version shouldn't be used for mission-critical
  projects. Having said that, threaded Perl is pretty nifty, and
  worth a look.</p>

  <p>Your programs can use the Config module to check whether
  threads are enabled. If your program can't run without them, you
  can say something like:</p>
  <pre>
$Config{usethreads} or
      die "Recompile Perl with threads to run this program.";
</pre>

  <p>A possibly-threaded program using a possibly-threaded module
  might have code like this:</p>
  <pre>
use Config;
Use MyMod;
if (<b>$Config{usethreads}</b>) {
    # We have threads
    require MyMod_threaded;
    import MyMod_threaded;
} else {
    require MyMod_unthreaded;
    import MyMod_unthreaded;
}
</pre>

  <p>Since code that runs both with and without threads is usually
  pretty messy, it's best to isolate the thread-specific code in
  its own module. In our example above, that's what MyMod_threaded
  is, and it's only imported if we're running on a threaded
  Perl.</p>

  <h4>CREATING THREADS</h4>

  <p>The Thread package provides the tools you need to create new
  threads. Like any other module, you need to tell Perl you want to
  use it; use Thread imports all the pieces you need to create
  basic threads.</p>

  <p>The simplest, straightforward way to create a thread is
  with</p>
  <pre>
new():

use Thread;

$thr = new Thread \&amp;sub1;

sub sub1 {
    print "In the thread\n";
}
</pre>

  <p>The <tt>new()</tt> method takes a reference to a subroutine
  and creates a new thread, which starts executing in the
  referenced subroutine. Control then passes both to the subroutine
  and the caller.</p>

  <p>If you need to, your program can pass parameters to the
  subroutine as part of the thread startup. Just include the list
  of parameters as part of the Thread::new call, like this:</p>
  <pre>
use Thread;
$Param3 = "foo";
$thr = new Thread \&amp;sub1, "Param 1", "Param 2", $Param3;
$thr = new Thread \&amp;sub1, @ParamList;
$thr = new Thread \&amp;sub1, qw(Param1 Param2 $Param3);

sub sub1 {
    my @InboundParameters = @_;
    print "In the thread\n";
    print "got parameters &gt;", join("&lt;&gt;", @InboundParameters), "&lt;\n";
}
</pre>

  <p>The subroutine runs like a normal Perl subroutine, and the
  call to <tt>new Thread</tt> returns whatever the subroutine
  returns.</p>

  <p>The last example illustrates another feature of threads. You
  can spawn off several threads using the same subroutine. Each
  thread executes the same subroutine, but in a separate thread
  with a separate environment and potentially separate
  arguments.</p>

  <p>The other way to spawn a new thread is with <tt>async()</tt>,
  which is a way to spin off a chunk of code like <tt>eval()</tt>,
  but into its own thread:</p>
  <pre>
use Thread qw(async);

$LineCount = 0;

$thr = async {
               while(&lt;&gt;) { $LineCount++ }
               print "Got $LineCount lines\n";
};

print "Waiting for the linecount to end\n";
$thr-&gt;join;
print "All done\n";
</pre>

  <p>You'll notice we did a <tt>use Thread qw(async)</tt> in that
  example. async is not exported by default, so if you want it,
  you'll either need to import it before you use it or fully
  qualify it as <tt>Thread::async</tt>. You'll also note that
  there's a semicolon after the closing brace. That's because
  <tt>async()</tt> treats the following block as an anonymous
  subroutine, so the semicolon is necessary.</p>

  <p>Like <tt>eval()</tt>, the code executes in the same context as
  it would if it weren't spun off. Since both the code inside and
  after the async start executing, you need to be careful with any
  shared resources. Locking and other synchronization techniques
  are covered later.</p>

  <h4>GIVING UP CONTROL</h4>

  <p>There are times when you may find it useful to have a thread
  explicitly give up the CPU to another thread. Your threading
  package might not support preemptive multitasking for threads,
  for example, or you may be doing something compute-intensive and
  want to make sure that the user-interface thread gets called
  frequently. Regardless, there are times that you might want a
  thread to give up the processor.</p>

  <p>Perl's threading package provides the <tt>yield()</tt>
  function that does this. <tt>yield()</tt> is pretty
  straightforward, and works like this:</p>
  <pre>
use Thread qw(yield async);
async {
        my $foo = 50;
        while ($foo--) { print "first async\n" }
        <b>yield;</b>
        $foo = 50;
        while ($foo--) { print "first async\n" }
};
async {
        my $foo = 50;
        while ($foo--) { print "second async\n" }
        <b>yield;</b>
        $foo = 50;
        while ($foo--) { print "second async\n" }
};
</pre>

  <h4>WAITING FOR A THREAD TO EXIT</h4>

  <p>Since threads are also subroutines, they can return values. To
  wait for a thread to exit and extract any scalars it might
  return, you can use the <tt>join()</tt> method.</p>
  <pre>
use Thread;
$thr = new Thread \&amp;sub1;

@ReturnData = <b>$thr-&gt;join;</b>
print "Thread returned @ReturnData";

sub sub1 { return "Fifty-six", "foo", 2; }
</pre>

  <p>In the example above, the <tt>join()</tt> method returns as
  soon as the thread ends. In addition to waiting for a thread to
  finish and gathering up any values that the thread might have
  returned, <tt>join()</tt> also performs any OS cleanup necessary
  for the thread. That cleanup might be important, especially for
  long-running programs that spawn lots of threads. If you don't
  want the return values and don't want to wait for the thread to
  finish, you should call the <tt>detach()</tt> method instead.
  <tt>detach()</tt> is covered later in the article.</p>

  <h4>ERRORS IN THREADS</h4>

  <p>So what happens when an error occurs in a thread? Any errors
  that could be caught with <tt>eval()</tt> are postponed until the
  thread is joined. If your program never joins, the errors appear
  when your program exits.</p>

  <p>Errors deferred until a <tt>join()</tt> can be caught with
  <tt>eval()</tt>:</p>
  <pre>
use Thread qw(async);
$thr = async {$b = 3/0}; # Divide by zero error
$foo = eval {$thr-&gt;join};
if ($@) {
    print "died with error $@\n";
} else {
    print "Hey, why aren't you dead?\n";
}
</pre>

  <p><tt>eval()</tt> passes any results from the joined thread back
  unmodified, so if you want the return value of the thread, this
  is your only chance to get them.</p>

  <h4>IGNORING A THREAD</h4>

  <p><tt>join()</tt> does three things:it waits for a thread to
  exit, cleans up after it, and returns any data the thread may
  have produced. But what if you're not interested in the thread's
  return values, and you don't really care when the thread
  finishes? All you want is for the thread to get cleaned up after
  when it's done.</p>

  <p>In this case, you use the <tt>detach()</tt> method. Once a
  thread is detached, it'll run until it's finished, then Perl will
  clean up after it automatically.</p>
  <pre>
use Thread;
$thr = new Thread \&amp;sub1; # Spawn the thread

$thr-&gt;detach; # Now we officially don't care any more

sub sub1 {
    $a = 0;
    while (1) {
        $a++;
        print "\$a is $a\n";
        sleep 1;
    }
}
</pre>

  <p>Once a thread is detached, it may not be joined, and any
  output that it might have produced (if it was done and waiting
  for a join) is lost.</p>

  <div align="center">
    <h3>THREADS AND DATA</h3>
  </div>

  <p>Now that we've covered the basics of threads, it's time for
  our next topic: data. Threading introduces a couple of
  complications to data access that non-threaded programs never
  need to worry about.</p>

  <h4>SHARED AND UNSHARED DATA</h4>

  <p>The single most important thing to remember when using threads
  is that all threads potentially have access to all the data
  anywhere in your program. While this is true with a non-threaded
  Perl program as well, it's especially important to remember with
  a threaded program, since more than one thread can be accessing
  this data at once.</p>

  <p>Perl's scoping rules don't change because you're using
  threads. If a subroutine (or block, in the case of
  <tt>async()</tt>) could see a variable if you weren't running
  with threads, it can see it if you are. This is especially
  important for the subroutines that create, and makes my variables
  even more important. Remember - if your variables aren't
  lexically scoped (declared with my) you're probably sharing it
  between threads.</p>

  <h4>THREAD PITFALL:RACES</h4>

  <p>While threads bring a new set of useful tools, they also bring
  a number of pitfalls. One pitfall is the race condition:</p>
  <pre>
use Thread;
$a = 1;
$thr1 = Thread-&gt;new(\&amp;sub1);
$thr2 = Thread-&gt;new(\&amp;sub2);

sleep 10;
print "$a\n";

sub sub1 { $foo = $a; $a = $foo + 1; }
sub sub2 { $bar = $a; $a = $bar + 1; }
</pre>

  <p>What do you think <tt>$a</tt> will be? The answer,
  unfortunately, is "it depends." Both <tt>sub1()</tt> and
  <tt>sub2()</tt> access the global variable <tt>$a</tt>, once to
  read and once to write. Depending on factors from your thread
  implementation's scheduling algorithm to the phase of the moon,
  <tt>$a</tt> can be 2 or 3.</p>

  <p>Race conditions are caused by unsynchronized access to shared
  data. Without explicit synchronization, there's no way to be sure
  that nothing has happened to the shared data between the time you
  access it and the time you update it. Even this simple code
  fragment has the possibility of error:</p>
  <pre>
use Thread qw(async);
$a = 2;
async{ $b = $a; $a = $b + 1; };
async{ $c = $a; $a = $c + 1; };
</pre>

  <p>Two threads both access <tt>$a</tt>. Each thread can
  potentially be interrupted at any point, or be executed in any
  order. At the end, <tt>$a</tt> could be 3 or 4, and both
  <tt>$b</tt> and <tt>$c</tt> could be 2 or 3.</p>

  <p>Whenever your program accesses data or resources that can be
  accessed by other threads, you must take steps to coordinate
  access or risk data corruption and race conditions.</p>

  <h4>CONTROLLING ACCESS: <tt>lock()</tt></h4>

  <p>The <tt>lock()</tt> function takes a variable (or subroutine,
  but we'll get to that later) and puts a lock on it. No other
  thread may lock the variable until the locking thread exits the
  innermost block containing the lock. Using <tt>lock()</tt> is
  straightforward:</p>
  <pre>
use Thread qw(async);
$a = 4;
$thr1 = async {
    $foo = 12;
    {
      <b>lock ($a);</b> # Block until we get access to $a
      $b = $a;
      $a = $b * $foo;
    }
    print "\$foo was $foo\n"; };
$thr2 = async {
    $bar = 7;
    {
      <b>lock ($a);</b> # Block until we can get access to $a
      $c = $a;
      $a = $c * $bar;
    }
    print "\$bar was $bar\n"; };
$thr1-&gt;join;
$thr2-&gt;join;
print "\$a is $a\n";
</pre>

  <p><tt>lock()</tt> blocks the thread until the variable being
  locked is available. When <tt>lock()</tt> returns, your thread
  can be sure that no other thread can lock that variable until the
  innermost block containing the lock exits.</p>

  <p>It's important to note that locks <i>don't</i> prevent access
  to the variable in question, only lock attempts. This is in
  keeping with Perl's longstanding tradition of courteous
  programming, and the advisory file locking that <tt>flock()</tt>
  gives you. Locked subroutines behave differently, however. We'll
  cover that later in the article.</p>

  <p>You may lock arrays and hashes as well as scalars. Locking an
  array, though, will not block subsequent locks on array elements,
  just lock attempts on the array itself.</p>

  <p>Finally, locks are recursive, which means it's okay for a
  thread to lock a variable more than once. The lock will last
  until the outermost <tt>lock()</tt> on the variable goes out of
  scope.</p>

  <h4>THREAD PITFALL:DEADLOCKS</h4>

  <p>Locks are a handy tool to synchronize access to data. Using
  them properly is the key to safe shared data. Unfortunately,
  locks aren't without their dangers. Consider the following
  code:</p>
  <pre>
use Thread qw(async yield);
$a = 4;
$b = "foo";
async {
        lock($a);
        yield;
        sleep 20;
        lock ($b);
};
async {
        lock($b);
        yield;
        sleep 20;
        lock ($a);
};
</pre>

  <p>This program will probably hang until you kill it. The only
  way it won't hang is if one of the two <tt>async()</tt> routines
  acquires both locks first. A guaranteed-to-hang version is more
  complicated, but the principle is the same.</p>

  <p>The first thread spawned by <tt>async()</tt> will grab a lock
  on <tt>$a</tt> then, a second or two later, try to grab a lock on
  <tt>$b</tt>. Meanwhile, the second thread grabs a lock on
  <tt>$b</tt>, then later tries to grab a lock on <tt>$a</tt>. The
  second lock attempt for both threads will block, each waiting for
  the other to release its lock.</p>

  <p>This condition is called a <i>deadlock</i>, and it occurs
  whenever two or more threads are trying to get locks on resources
  that the others own. Each thread will block, waiting for the
  other to release a lock on a resource. That never happens,
  though, since the thread with the resource is itself waiting for
  a lock to be released.</p>

  <p>There are a number of ways to handle this sort of problem. The
  best way is to always have all threads acquire locks in the exact
  same order. If, for example, you lock variables <tt>$a</tt>,
  <tt>$b</tt>, and <tt>$c</tt>, always lock <tt>$a</tt> before
  <tt>$b</tt>, and <tt>$b</tt> before <tt>$c</tt>. It's also best
  to hold on to locks for as short a period of time to minimize the
  risks of deadlock.</p>

  <h4>QUEUES: PASSING DATA AROUND</h4>

  <p>A queue is a special thread-safe object that lets you put data
  in one end and take it out the other without having to worry
  about synchronization issues. They're pretty straightforward, and
  look like this:</p>
  <pre>
use Thread qw(async);

use Thread::Queue;

my $DataQueue = new Thread::Queue;
$thr = async {
    while ($DataElement = $DataQueue-&gt;dequeue) {
        print "Popped $DataElement off the queue\n";
    }
};

$DataQueue-&gt;enqueue(12);
$DataQueue-&gt;enqueue("A", "B", "C");
$DataQueue-&gt;enqueue(\$thr);
sleep 10;
$DataQueue-&gt;enqueue(undef);
</pre>

  <p>You create the queue with new <tt>Thread::Queue</tt>. Then you
  can add lists of scalars onto the end with <tt>enqueue()</tt>,
  and pop scalars off the front of it with <tt>dequeue()</tt>. A
  queue has no fixed size, and can grow as needed to hold
  everything pushed on to it.</p>

  <p>If a queue is empty, <tt>dequeue()</tt> blocks until another
  thread enqueues something. This makes queues ideal for event
  loops and other communications between threads.</p>

  <div align="center">
    <h3>THREADS AND CODE</h3>
  </div>

  <p>In addition to providing thread-safe access to data via locks
  and queues, threaded Perl also provides general-purpose
  semaphores for coarser synchronization than locks provide and
  thread-safe access to entire subroutines.</p>

  <h4>SEMAPHORES: SYNCHRONIZING DATA ACCESS</h4>

  <p>Semaphores are a kind of generic locking mechanism. Unlike
  lock, which gets a lock on a particular scalar, Perl doesn't
  associate any particular thing with a semaphore so you can use
  them to control access to anything you like. In addition,
  semaphores can allow more than one thread to access a resource at
  once, though by default semaphores only allow one thread access
  at a time.</p>

  <p><b>Basic semaphores.</b> Semaphores have two methods, down and
  up. down decrements the resource count, while up increments it.
  down calls will block if the semaphore's current count would
  decrement below zero. This program gives a quick
  demonstration:</p>
  <pre>
use Thread qw(yield);
use Thread::Semaphore;
my $semaphore = new Thread::Semaphore;
$GlobalVariable = 0;

$thr1 = new Thread \&amp;sample_sub, 1;
$thr2 = new Thread \&amp;sample_sub, 2;
$thr3 = new Thread \&amp;sample_sub, 3;

sub sample_sub {
    my $SubNumber = shift @_;
    my $TryCount = 10;
    my $LocalCopy;
    sleep 1;
    while ($TryCount--) {
        <b>$semaphore-&gt;down;</b>
        $LocalCopy = $GlobalVariable;
        print "$TryCount tries left for sub $SubNumber
                   (\$GlobalVariable is $GlobalVariable)\n";
        yield;
        sleep 2;
        $LocalCopy++;
        $GlobalVariable = $LocalCopy;
        <b>$semaphore-&gt;up;</b>
    }
}
</pre>

  <p>The three invocations of the subroutine all operate in sync.
  The semaphore, though, makes sure that only one thread is
  accessing the global variable at once.</p>

  <p><b>Advanced Semaphores.</b> By default, semaphores behave like
  locks, letting only one thread <tt>down()</tt> them at a time.
  However, there are other uses for semaphores.</p>

  <p>Each semaphore has a counter attached to it. <tt>down()</tt>
  decrements the counter and <tt>up()</tt> increments the counter.
  By default, semaphores are created with the counter set to one,
  <tt>down()</tt> decrements by one, and <tt>up()</tt> increments
  by one. If <tt>down()</tt> attempts to decrement the counter
  below zero, it blocks until the counter is large enough. Note
  that while a semaphore can be created with a starting count of
  zero, any up() or down() always changes the counter by at least
  one. <tt>$semaphore-&gt;down(0)</tt> is the same as
  <tt>$semaphore-&gt;down(1)</tt>.</p>

  <p>The question, of course, is why would you do something like
  this? Why create a semaphore with a starting count that's not
  one, or why decrement/increment it by more than one? The answer
  is resource availability. Many resources that you want to manage
  access for can be safely used by more than one thread at
  once.</p>

  <p>For example, let's take a GUI driven program. It has a
  semaphore that it uses to synchronize access to the display, so
  only one thread is ever drawing at once. Handy, but of course you
  don't want any thread to start drawing until things are properly
  set up. In this case, you can create a semaphore with a counter
  set to zero, and up it when things are ready for drawing.</p>

  <p>Semaphores with counters greater than one are also useful for
  establishing quotas. Say, for example, that you have a number of
  threads that can do I/O at once. You don't want all the threads
  reading or writing at once though, since that can potentially
  swamp your I/O channels, or deplete your process' quota of
  file-handles. You can use a semaphore initialized to the number
  of concurrent I/O requests (or open files) that you want at any
  one time, and have your threads quietly block and unblock
  themselves.</p>

  <p>Larger increments or decrements are handy in those cases where
  a thread needs to check out or return a number of resources at
  once.</p>

  <h4>ATTRIBUTES: RESTRICTING ACCESS TO SUBROUTINES</h4>

  <p>In addition to synchronizing access to data or resources, you
  might find it useful to synchronize access to subroutines. You
  may be accessing a singular machine resource (perhaps a vector
  processor), or find it easier to serialize calls to a particular
  subroutine than to have a set of locks and sempahores.</p>

  <p>One of the additions to Perl 5.005 is subroutine attributes.
  The Thread package uses these to provide several flavors of
  serialization. It's important to remember that these attributes
  are used in the compilation phase of your program so you can't
  change a subroutine's behavior while your program is actually
  running.</p>

  <p><b>Subroutine Locks.</b> The basic subroutine lock looks like
  this:</p>
  <pre>
sub test_sub {
    use attrs qw(locked);
}
</pre>

  <p>This ensures that only one thread will be executing this
  subrou-tine at any one time. Once a thread calls this subroutine,
  any other thread that calls it will block until the thread in the
  subroutine exits it. A more elaborate example looks like
  this:</p>
  <pre>
use Thread qw(yield);

new Thread \&amp;thread_sub, 1;
new Thread \&amp;thread_sub, 2;
new Thread \&amp;thread_sub, 3;
new Thread \&amp;thread_sub, 4;

sub sync_sub {
    use attrs qw(locked);
    my $CallingThread = shift @_;
    print "In sync_sub for thread $CallingThread\n";
    yield;
    sleep 3;
    print "Leaving sync_sub for thread $CallingThread\n";
        
}

sub thread_sub {
    my $ThreadID = shift @_;
    print "Thread $ThreadID calling sync_sub\n";
    sync_sub($ThreadID);
    print "$ThreadID is done with sync_sub\n";
}
</pre>

  <p>The <tt>use attrs qw(locked)</tt> locks <tt>sync_sub()</tt>,
  and if you run this, you can see that only one thread is in it at
  any one time.</p>

  <p><b>Methods.</b> Locking an entire subroutine can sometimes be
  overkill, especially when dealing with Perl objects. When calling
  a method for an object, for example, you want to serialize calls
  to a method, so that only one thread will be in the subroutine
  for a particular object, but threads calling that subroutine for
  a <i>different</i> object aren't blocked. The method attribute
  indicates whether the subroutine is really a method.</p>
  <pre>
use Thread;

sub tester {
    my $thrnum = shift @_;
    my $bar = new Foo;
    foreach (1..10) {
        print "$thrnum calling per_object\n";
        $bar-&gt;per_object($thrnum);
        print "$thrnum out of per_object\n";
        yield;
        print "$thrnum calling one_at_a_time\n";
        $bar-&gt;one_at_a_time($thrnum);
        print "$thrnum out of one_at_a_time\n";
        yield;
    }
}

foreach my $thrnum (1..10) {
    new Thread \&amp;tester, $thrnum;
}

package Foo;
sub new {
    my $class = shift @_;
    return bless [@_], $class;
}

sub per_object {
    use attrs qw(locked method);
    my ($class, $thrnum) = @_;
    print "In per_object for thread $thrnum\n";
    yield;
    sleep 2;
    print "Exiting per_object for thread $thrnum\n";
}

sub one_at_a_time {
    use attrs qw(locked);
    my ($class, $thrnum) = @_;
    print "In one_at_a_time for thread $thrnum\n";
    yield;
    sleep 2;
    print "Exiting one_at_a_time for thread $thrnum\n";
}
</pre>

  <p>As you can see from the output (omitted for brevity; it's 800
  lines) all the threads can be in per_object() simultaneously, but
  only one thread is ever in one_at_a_time() at once.</p>

  <h4>LOCKING A SUBROUTINE</h4>

  <p>You can lock a subroutine as you would lock a variable.
  Subroutine locks work the same as a <tt>use attrs qw(locked)</tt>
  in the subroutine, and block all access to the subroutine for
  other threads until the lock goes out of scope. When the
  subroutine isn't locked, any number of threads can be in it at
  once, and getting a lock on a subroutine doesn't affect threads
  already in the subroutine. Getting a lock on a subroutine looks
  like this:</p>
  <pre>
lock(\&amp;sub_to_lock);
</pre>

  <p>Simple enough. Unlike <tt>use attrs</tt>, which is a compile
  time option, locking and unlocking a subroutine can be done at
  runtime at your discretion. There is some runtime penalty to
  using <tt>lock(\&amp;sub)</tt> instead of <tt>use attrs
  qw(locked)</tt>, so make sure you're choosing the proper method
  to do the locking.</p>

  <p>You'd choose <tt>lock(\&amp;sub)</tt> when writing modules and
  code to run on both threaded and unthreaded Perl, especially for
  code that will run on 5.004 or earlier Perls. In that case, it's
  useful to have subroutines that should be serialized lock
  themselves if they're running threaded, like so:</p>
  <pre>
package Foo;
use Config;
$Running_Threaded = 0;

BEGIN { $Running_Threaded = $Config{'usethreaded'} }

sub sub1 { lock(\&amp;sub1) if $Running_Threaded }
</pre>

  <p>This way you can ensure single-threadedness regardless of
  which version of Perl you're running.</p>

  <p><b>Listing 3</b>. <a href="tpj0302-0010c.html">PLATFORMS
  SUPPORTING THREADED PERL</a></p>

  <div align="center">
    <h3>GENERAL THREAD UTILITY ROUTINES</h3>
  </div>

  <p>We've covered the workhorse parts of Perl's threading package,
  and with these tools you should be well on your way to writing
  threaded code and packages. There are a few useful little pieces
  that didn't really fit in anyplace else.</p>

  <h4>WHAT THREAD AM I IN?</h4>

  <p>The <tt>Thread-&gt;self</tt> method provides your program with
  a way to get an object representing the thread it's currently in.
  You can use this object in the same way as the ones returned from
  the thread creation.</p>

  <h4>THREAD IDS</h4>

  <p><tt>tid()</tt> is a thread object method that returns the
  thread ID of the thread the object represents. Thread IDs are
  integers, with the main thread in a program being 0. Currently
  Perl assigns a unique <tt>tid</tt> to every thread ever created
  in your program, assigning the first thread to be created a
  <tt>tid</tt> of 1, and increasing the <tt>tid</tt> by 1 for each
  new thread that's created.</p>

  <h4>ARE THESE THREADS THE SAME?</h4>

  <p>The <tt>equal()</tt> method takes two thread objects and
  returns true if the objects represent the same thread, and false
  if they don't.</p>

  <h4>WHAT THREADS ARE RUNNING?</h4>

  <p><tt>Thread-&gt;list</tt> returns a list of thread objects, one
  for each thread that's currently running. Handy for a number of
  things, including cleaning up at the end of your program:</p>
  <pre>
# Loop through all the threads
foreach $thr (Thread-&gt;list) {
    # Don't join the main thread or ourselves
    if ($thr-&gt;tid &amp;&amp; !Thread::equal($thr, Thread-&gt;self)) {
        $thr-&gt;join;
    }
}
</pre>

  <p>The example above is just for illustration. It isn't strictly
  necessary to join all the threads you create, since Perl detaches
  all the threads before it exits.</p>

  <h4>A COMPLETE EXAMPLE</h4>

  <p>Confused yet? It's time for an example program to show some of
  the things we've covered. This program finds prime numbers using
  threads.</p>
  <pre>
1 #!/usr/bin/perl -w
2 # prime-pthread, courtesy of Tom Christiansen
3
4 use strict;
5
6 use Thread;
7 use Thread::Queue;
8
9 my $stream = new Thread::Queue;
10 my $kid = new Thread(\&amp;check_num, $stream, 2);
11
12 for my $i ( 3 .. 1000 ) {
13     $stream-&gt;enqueue($i);
14 }
15
16 $stream-&gt;enqueue(undef);
17 $kid-&gt;join();
18
19 sub check_num {
20     my ($upstream, $cur_prime) = @_;
21     my $kid;
22     my $downstream = new Thread::Queue;
23     while (my $num = $upstream-&gt;dequeue) {
24         next unless $num % $cur_prime;
25         if ($kid) {
26            $downstream-&gt;enqueue($num);
27         } else {
28           print "Found prime $num\n";
29           $kid = new Thread(\&amp;check_num, $downstream, $num);
30         }
31     }
32     $downstream-&gt;enqueue(undef) if $kid;
33     $kid-&gt;join()if $kid;
34 }
</pre>

  <p>This program uses the pipeline model to generate prime
  numbers. Each thread in the pipeline has an input queue that
  feeds numbers to be checked, a prime number that it's responsible
  for, and an output queue that it funnels numbers that have failed
  the check into. If the thread has a number that's failed its
  check and there's no child thread, then the thread must have
  found a new prime number. In that case, a new child thread is
  created for that prime and stuck on the end of the pipeline.</p>

  <p>This probably sounds a bit more confusing than it really is,
  so lets go through this program piece by piece and see what it
  does. (For those of you who might be trying to remember exactly
  what a prime number is, it's a number that's only evenly
  divisible by itself and 1)</p>

  <p>The bulk of the work is done by the <tt>check_num()</tt>
  subroutine, which takes a reference to its input queue and a
  prime number that it's responsible for. After pulling in the
  input queue and the prime that the subroutine's checking (line
  20), we create a new queue (line 22) and reserve a scalar for the
  thread that we're likely to create later (line 21).</p>

  <p>The while loop from lines 23 to line 31 grabs a scalar off the
  input queue and checks against the prime this thread is
  responsible for. Line 24 checks to see if there's a remainder
  when we modulo the number to be checked against our prime. If
  there is one, the number must not be evenly divisible by our
  prime, so we need to either pass it on to the next thread if
  we've created one (line 26) or create a new thread if we
  haven't.</p>

  <p>The new thread creation is line 29. We pass on to it a
  reference to the queue we've created, and the prime number we've
  found.</p>

  <p>Finally, once the loop terminates (because we got a 0 or undef
  in the queue, which serves as a note to die), we pass on the
  notice to our child and wait for it to exit if we've created a
  child (Lines 32 and 37).</p>

  <p>Meanwhile, back in the main thread, we create a queue (line 9)
  and the initial child thread (line 10), and pre-seed it with the
  first prime: 2. Then we queue all the numbers from 3 to 1000 for
  checking (lines 12-14), then queue a die notice (line 16) and
  wait for the first child thread to terminate (line 17). Because a
  child won't die until its child has died, we know that we're done
  once we return from the join.</p>

  <p>That's how it works. It's pretty simple; as with many Perl
  programs, the explanation is much longer than the program.</p>

  <p><b>Listing 4</b>. <a href=
  "tpj0302-0010d.html">COUNTERPOINT</a></p>

  <div align="center">
    <h3>CONCLUSION</h3>
  </div>

  <p>A complete thread tutorial could fill a book (and has, many
  times), but this should get you well on your way. The final
  authority on how Perl's threads behave is the documention bundled
  with the Perl distribution, but with what we've covered in this
  article, you should be well on your way to becoming a threaded
  Perl expert.</p>

  <p>Here's a short bibliography courtesy, of J&uuml;rgen
  Christoffel:</p>

  <h4>INTRODUCTORY TEXTS</h4>

  <p>Birrell, Andrew D. <i>An Introduction to Programming with
  Threads</i>. Digital Equipment Corporation, 1989, DEC-SRC
  Research Report #35 online as <a href=
  "http://www.research.digital.com/SRC/staff/birrell/bib.html"
  target="resource window">http://www.research.digital.
  com/SRC/staff/birrell/bib.html</a> (highly recommended)</p>

  <p>Robbins, Kay. A., and Steven Robbins. <i>Practical Unix
  Programming: A Guide to Concurrency, Communication, and
  Multithreading</i>. Prentice-Hall, 1996.</p>

  <p>Lewis, Bill, and Daniel J. Berg. <i>Multithreaded Programming
  with Pthreads</i>. Prentice Hall, 1997, ISBN 0-13-443698-9 (a
  well-written introduction to threads).</p>

  <p>Nelson, Greg (editor). <i>Systems Programming with
  Modula-3</i>. Prentice Hall, 1991, ISBN 0-13-590464-1.</p>

  <p>Nichols, Bradford, Dick Buttlar, and Jacqueline Proulx
  Farrell. <i>Pthreads Programming</i>. O'Reilly &amp; Associates,
  1996, ISBN 1- 56592-115-1 (covers POSIX threads).</p>

  <h4>OS-RELATED REFERENCES</h4>

  <p>Boykin, Joseph, David Kirschen, Alan Langerman, and Susan
  LoVerso. <i>Programming under Mach</i>. Addison-Wesley, 1994,
  ISBN 0-201-52739-1.</p>

  <p>Tanenbaum, Andrew S. <i>Distributed Operating Systems</i>.
  Prentice Hall, 1995, ISBN 0-13-143934-0 (great textbook).</p>

  <p>Silberschatz, Abraham, and Peter B. Galvin. <i>Operating
  System Concepts, 4th ed</i>. Addison-Wesley, 1995, ISBN
  0-201-59292-4</p>

  <p>OTHER REFERENCES</p>

  <p>Arnold, Ken and James Gosling. <i>The Java Programming
  Language, 2nd ed</i>. Addison-Wesley, 1998, ISBN
  0-201-31006-6.</p>

  <p>Le Sergent, T. and B. Berthomieu. "Incremental Multi-Threaded
  Garbage Collection on Virtually Shared Memory Architectures" in
  <i>Memory Management: Proc. of the International Workshop IWMM
  92</i>, St. Malo, France, September 1992, Yves Bekkers and
  Jacques Cohen, eds. Springer, 1992, ISBN 3- 540-55940-X
  (real-life thread applications).</p>

  <h4>ACKNOWLEDGEMENTS</h4>

  <p>Thanks (in no particular order) to Chaim Frenkel, Steve Fink,
  Gurusamy Sarathy, Ilya Zakharevich, Benjamin Sugars, J&uuml;rgen
  Christoffel, Joshua Pritikin, and Alan Burlison, for their help
  in reality-checking and polishing this article. Big thanks to Tom
  Christiansen for his rewrite of the prime number generator.</p>

  <p>__END__ <!-- end of article -->
   <!-- end of file --></p>
</body>
</html>
