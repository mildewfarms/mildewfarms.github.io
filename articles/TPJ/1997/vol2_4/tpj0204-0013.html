<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <title>The Perl Wizard's Quiz - The Perl Journal, Winter 1997</title>
  <meta name="generator" content=
  "HTML Tidy for Linux/x86 (vers 12 April 2005), see www.w3.org">
  <meta name="vscategory" content="Perl">
  <meta name="vsisbn" content="">
  <meta name="vstitle" content="The Perl Wizard's Quiz">
  <meta name="vsauthor" content="Tom Christiansen">
  <meta name="searchdescription" content="The Perl Wizard's Quiz">
  <meta name="vspublisher" content="Earthweb">
  <meta name="vsimprint" content="The Perl Journal">
  <meta name="vspubdate" content="Winter 1997">
  <!-- always update the article title and issue -->

</head>

<body bgcolor="#FFFFFF">
  <font face="verdana" size="1">Issue 8, Winter 1997</font>

  <h2 align="center">The Perl Wizard's Quiz</h2>

  <h4><i>Tom Christiansen</i></h4>
  <!-- packages described, if necessary -->
  1. What value is returned by a lone <tt>return</tt>;
  statement?<br>
  &nbsp;&nbsp;&nbsp;&nbsp;a. The empty list value <tt>()</tt>.<br>
  &nbsp;&nbsp;&nbsp;&nbsp;b. The undefined value in scalar context,
  and the empty list value <tt>()</tt> in list context.<br>
  &nbsp;&nbsp;&nbsp;&nbsp;c. The result of the last evaluated
  expression in that subroutine's block.<br>
  &nbsp;&nbsp;&nbsp;&nbsp;d. The undefined value.<br>

  <p>2. What's the difference between <tt>/^Foo/s</tt> and
  <tt>/^Foo/?</tt><br>
  &nbsp;&nbsp;&nbsp;&nbsp;a. The first would allow the match to
  cross newline boundaries.<br>
  &nbsp;&nbsp;&nbsp;&nbsp;b. The first would match <tt>Foo</tt>
  other than at the start of the record if the previous match were
  <tt>/^Foo/gcm</tt>, new in the 5.004 release.<br>
  &nbsp;&nbsp;&nbsp;&nbsp;c. The second would match Foo other than
  at the start of the record if <tt>$*</tt> were set.<br>
  &nbsp;&nbsp;&nbsp;&nbsp;d. There is no difference because
  <tt>/s</tt> only affects whether dot can match newline.<br></p>

  <p>3. What does <tt>length(%HASH)</tt> produce if you have
  thirty-seven random keys in a newly created hash?<br>
  &nbsp;&nbsp;&nbsp;&nbsp;a. 5<br>
  &nbsp;&nbsp;&nbsp;&nbsp;b. 37<br>
  &nbsp;&nbsp;&nbsp;&nbsp;c. 74<br>
  &nbsp;&nbsp;&nbsp;&nbsp;d. 2<br></p>

  <p>4. What does <tt>read()</tt> return at end of file?<br>
  &nbsp;&nbsp;&nbsp;&nbsp;a. 0<br>
  &nbsp;&nbsp;&nbsp;&nbsp;b. "0 but true"<br>
  &nbsp;&nbsp;&nbsp;&nbsp;c. "\0"<br>
  &nbsp;&nbsp;&nbsp;&nbsp;d. <tt>undef</tt><br></p>

  <p>5. How do you produce a reference to a list?<br>
  &nbsp;&nbsp;&nbsp;&nbsp;a. <tt>[ @array ]</tt><br>
  &nbsp;&nbsp;&nbsp;&nbsp;b. <tt>\($s, @a, %h, &amp;c)</tt><br>
  &nbsp;&nbsp;&nbsp;&nbsp;c. You can't produce a reference to a
  list.<br>
  &nbsp;&nbsp;&nbsp;&nbsp;d. <tt>\@array</tt><br></p>

  <p>6. Why aren't Perl's patterns regular expressions?<br>
  &nbsp;&nbsp;&nbsp;&nbsp;a. Because Perl allows both minimal
  matching and maximal matching in the same pattern.<br>
  &nbsp;&nbsp;&nbsp;&nbsp;b. Because Perl uses a non-deterministic
  finite automaton rather than a deterministic finite
  automaton.<br>
  &nbsp;&nbsp;&nbsp;&nbsp;c. Because Perl patterns can have
  look-ahead assertions and negations.<br>
  &nbsp;&nbsp;&nbsp;&nbsp;d. Because Perl patterns have
  backreferences.<br></p>

  <p>7. Why doesn't Perl have overloaded functions?
  &nbsp;&nbsp;&nbsp;&nbsp;a. Because you can inspect the argument
  count, return context, and object types all by yourself.<br>
  &nbsp;&nbsp;&nbsp;&nbsp;b. It does, along with overloaded
  operators as well as overridden functions and methods.<br>
  &nbsp;&nbsp;&nbsp;&nbsp;c. Because Perl doesn't have function
  prototypes.<br>
  &nbsp;&nbsp;&nbsp;&nbsp;d. Because it's too hard.<br></p>

  <p>8. Why is it hard to call this function: <tt>sub y { "because"
  }</tt><br>
  &nbsp;&nbsp;&nbsp;&nbsp;a. It's not.<br>
  &nbsp;&nbsp;&nbsp;&nbsp;b. Because <tt>y</tt> is a predefined
  function.<br>
  &nbsp;&nbsp;&nbsp;&nbsp;c. Because it has no prototype.<br>
  &nbsp;&nbsp;&nbsp;&nbsp;d. Because <tt>y</tt> is a kind of
  quoting operator.<br></p>

  <p>9. How do you print out the next line from a filehandle with
  all its bytes reversed?<br>
  &nbsp;&nbsp;&nbsp;&nbsp;a. <tt>print reverse scalar
  &lt;FH&gt;</tt><br>
  &nbsp;&nbsp;&nbsp;&nbsp;b. <tt>print scalar reverse scalar
  &lt;FH&gt;</tt><br>
  &nbsp;&nbsp;&nbsp;&nbsp;c. <tt>print scalar reverse
  &lt;FH&gt;</tt><br>
  &nbsp;&nbsp;&nbsp;&nbsp;d. <tt>print reverse &lt;FH&gt;</tt></p>

  <p>10. When would <tt>local $_</tt> in a function ruin your
  day?<br>
  &nbsp;&nbsp;&nbsp;&nbsp;a. When your caller was in the middle for
  a <tt>while(&lt;&gt;)</tt> loop.<br>
  &nbsp;&nbsp;&nbsp;&nbsp;b. When your caller was in the middle for
  a <tt>while(m//g)</tt> loop<br>
  &nbsp;&nbsp;&nbsp;&nbsp;c. When <tt>$_</tt> was imported from
  another module.<br>
  &nbsp;&nbsp;&nbsp;&nbsp;d. When your caller was in the middle for
  a <tt>foreach(@a) loop</tt>.<br></p>

  <p>11. Which of these is a difference between C++ and Perl?<br>
  &nbsp;&nbsp;&nbsp;&nbsp;a. C++ can have objects whose data cannot
  be accessed outside its class, but Perl cannot.<br>
  &nbsp;&nbsp;&nbsp;&nbsp;b. C++ supports multiple inheritance, but
  Perl does not.<br>
  &nbsp;&nbsp;&nbsp;&nbsp;c. C++ will not call destructors on
  objects that go out of scope if a reference to that object still
  exists, but Perl will.<br>
  &nbsp;&nbsp;&nbsp;&nbsp;d. Perl can have objects whose data
  cannot be accessed outside its class, but C++ cannot.<br></p>

  <p>12. Assuming both a <tt>local($var)</tt> and a
  <tt>my($var)</tt> exist, what's the difference between
  <tt>${var}</tt> and <tt>${"var"}</tt>?<br>
  &nbsp;&nbsp;&nbsp;&nbsp;a. <tt>${var}</tt> is the package
  variable <tt>$var</tt>, and <tt>${"var"}</tt> is the scoped
  variable <tt>$var</tt>.<br>
  &nbsp;&nbsp;&nbsp;&nbsp;b. There is no difference.<br>
  &nbsp;&nbsp;&nbsp;&nbsp;c. <tt>${var}</tt> is a package variable
  <tt>$var</tt>, and <tt>${"var"}</tt> a global variable
  <tt>$var</tt>.<br>
  &nbsp;&nbsp;&nbsp;&nbsp;d. <tt>${var}</tt> is the lexical
  variable <tt>$var</tt>, and <tt>${"var"}</tt> is the dynamic
  variable <tt>$var</tt>.<br></p>

  <p>13. How do you match one letter in the current locale?<br>
  &nbsp;&nbsp;&nbsp;&nbsp;a. <tt>/[a-z]/i</tt><br>
  &nbsp;&nbsp;&nbsp;&nbsp;b. <tt>/[^\W_\d]/</tt><br>
  &nbsp;&nbsp;&nbsp;&nbsp;c. <tt>/[:isalpha:]/</tt><br>
  &nbsp;&nbsp;&nbsp;&nbsp;d. <tt>/[a-zA-Z]/</tt><br></p>

  <p>14. If EXPR is an arbitrary expression, what is the difference
  between <tt>$Foo::</tt>{EXPR} and <tt>*{"Foo::"</tt>.EXPR} ?<br>
  &nbsp;&nbsp;&nbsp;&nbsp;a. The second is disallowed under <tt>use
  strict "refs"</tt>.<br>
  &nbsp;&nbsp;&nbsp;&nbsp;b. The first only happens at runtime, the
  second at only compile time.<br>
  &nbsp;&nbsp;&nbsp;&nbsp;c. One is just a regular hash, the other
  a typeglob access for a strangely named variable.<br>
  &nbsp;&nbsp;&nbsp;&nbsp;d. The first can create new globs
  dynamically, but the second cannot.<br></p>

  <p>15. Assuming <tt>$_</tt> contains HTML, which of the following
  substitutions will remove all tags in it?<br>
  &nbsp;&nbsp;&nbsp;&nbsp;a. <tt>s/&lt;.*&gt;//g;</tt><br>
  &nbsp;&nbsp;&nbsp;&nbsp;b. <tt>s/&lt;.*?&gt;//gs;</tt><br>
  &nbsp;&nbsp;&nbsp;&nbsp;c.
  <tt>s/&lt;\/?[A-Z]\w*(?:\s+[A-Z]\w*(?:\s*=\s*(?:(["']).*?\1|[\w-
  .]+))?)*\s*&gt;//gsix;</tt><br>
  &nbsp;&nbsp;&nbsp;&nbsp;d. You can't do that.<br></p>

  <p>16. What does <tt>new $cur-&gt;{LINK}</tt> do? (Assume the
  current package has no <tt>new()</tt> function of its own.)<br>
  &nbsp;&nbsp;&nbsp;&nbsp;a. <tt>$cur-&gt;new()-&gt;{LINK}</tt><br>
  &nbsp;&nbsp;&nbsp;&nbsp;b. <tt>new($cur-&gt;{LINK})</tt><br>
  &nbsp;&nbsp;&nbsp;&nbsp;c. <tt>$cur ? ($cur-&gt;{LINK}-&gt;new())
  : (new()-&gt;{LINK})</tt><br>
  &nbsp;&nbsp;&nbsp;&nbsp;d.
  <tt>$cur-&gt;{LINK}-&gt;new()</tt><br></p>

  <p>17. What does <tt>$result = f() .. g()</tt> really return?<br>
  &nbsp;&nbsp;&nbsp;&nbsp;a. It produces a syntax error.<br>
  &nbsp;&nbsp;&nbsp;&nbsp;b. True if and only if both <tt>f()</tt>
  and <tt>g()</tt> are true, or if <tt>f()</tt> and <tt>g()</tt>
  are both false, but returns false otherwise.<br>
  &nbsp;&nbsp;&nbsp;&nbsp;c. False so long as <tt>f()</tt> returns
  false, after which it returns true until <tt>g()</tt> returns
  true, and then starts the cycle again.<br>
  &nbsp;&nbsp;&nbsp;&nbsp;d. The last number from the list of
  numbers returned in the range between <tt>f()</tt>'s return value
  and <tt>g()</tt>'s.<br></p>

  <p>18. What happens when you return a reference to a private
  variable?<br>
  &nbsp;&nbsp;&nbsp;&nbsp;a. The underlying object is silently
  copied.<br>
  &nbsp;&nbsp;&nbsp;&nbsp;b. Nothing bad - it just works.<br>
  &nbsp;&nbsp;&nbsp;&nbsp;c. The compiler doesn't let you.<br>
  &nbsp;&nbsp;&nbsp;&nbsp;d. You get a core dump later when you use
  it.<br></p>

  <p>19. How do you give functions private variables that retain
  their values between calls?<br>
  &nbsp;&nbsp;&nbsp;&nbsp;a. Include them as extra parameters in
  the prototype list, but don't pass anything in at that slot.<br>
  &nbsp;&nbsp;&nbsp;&nbsp;b. Use localized globals.<br>
  &nbsp;&nbsp;&nbsp;&nbsp;c. Create a scope surrounding that sub
  that contains lexicals.<br>
  &nbsp;&nbsp;&nbsp;&nbsp;d. Perl doesn't support that.<br></p>

  <p>20. What happens to objects lost in "unreachable" memory, such
  as the object returned by <tt>$Ob-&gt;new()</tt> in <tt>{ my $ap;
  $ap = [ $Ob-&gt;new(), \$ap ]; }</tt> ?<br>
  &nbsp;&nbsp;&nbsp;&nbsp;a. Their destructors are called when the
  memory becomes unreachable.<br>
  &nbsp;&nbsp;&nbsp;&nbsp;b. Their destructors are never
  called.<br>
  &nbsp;&nbsp;&nbsp;&nbsp;c. Perl doesn't support destructors.<br>
  &nbsp;&nbsp;&nbsp;&nbsp;d. Their destructors are called when that
  interpreter thread shuts down.<br></p>

  <p>21. What does Perl do if you try to exploit the execve(2) race
  condition involving setuid scripts?<br>
  &nbsp;&nbsp;&nbsp;&nbsp;a. Sends mail to root and exits.<br>
  &nbsp;&nbsp;&nbsp;&nbsp;b. Runs the fake script with setuid
  permissions.<br>
  &nbsp;&nbsp;&nbsp;&nbsp;c. Runs the fake script, but without
  setuid permissions.<br>
  &nbsp;&nbsp;&nbsp;&nbsp;d. Reboots your machine.<br></p>

  <h3>Answers</h3>

  <p><b>1. b.</b> This way functions that wish to return failure
  can just use a simple return without worrying about the context
  in which they were called.<br>
  a: That would only be true in list context.<br>
  c: That's what happens when the function ends without
  <tt>return</tt> being used at all.<br>
  d: That would only be true in scalar context.<br></p>

  <p><b>2. c.</b> The deprecated <tt>$*</tt> flag does double duty,
  filling the roles of both <tt>/s</tt> and <tt>/m</tt>. By using
  <tt>/s</tt>, you suppress any settings of that spooky variable,
  and force your carets and dollars to match only at the ends of
  the string and not at ends of line as well - just as they would
  if <tt>$*</tt> weren't set at all.<br>
  a: <tt>/s</tt> only makes a dot able to match a newline, and then
  only if the string actually has a newline in it.<br>
  b: Although the <tt>/c</tt> modifier is indeed new as of 5.004
  (and is used with <tt>/g</tt>), this has no particular
  interaction with <tt>/s</tt>.<br>
  d: <tt>/s</tt> does more than that.</p>

  <p><b>3. a.</b> <tt>length()</tt> is a built-in function
  prototyped as <tt>sub length($)</tt>, and that scalar prototype
  silently changes aggregates into radically different forms.The
  scalar sense of a hash is false (<tt>0</tt>) if it's empty,
  otherwise it's a string representing the fullness of the hash
  buckets, like <tt>'18/32'</tt> or <tt>'39/64'</tt>. The length of
  that string is likely to be 5. Likewise, <tt>length(@a)</tt>
  would be 2 if there were 37 elements in <tt>@a</tt>.<br>
  b: <tt>length %HASH</tt> is nothing at all like <tt>scalar keys
  %HASH</tt>, which is a good bit more useful.<br>
  c: <tt>length %HASH</tt> is nothing at all like the size of the
  list of all the keys and values in <tt>%HASH</tt>.<br>
  d: You probably think it decided there were 37 keys, and that
  length(37) is 2. Close, but not quite.<br></p>

  <p><b>4. a.</b> A defined (but false) 0 value is the proper
  indication of the end of file for <tt>read()</tt> and
  <tt>sysread()</tt>.<br>
  b: You're thinking of the <tt>ioctl()</tt> and <tt>fcntl()</tt>
  functions which return this when the C version returned 0,
  reserving <tt>undef</tt> for when the C version returns -1. For
  example, <tt>fcntl(STDIN,F_GETFL,1)</tt> returns "0 but true"
  depending on whether and how standard input has been redirected.
  (The <tt>F_GETFL</tt> flag can be loaded from the Fcntl.pm
  module.)<br>
  c: That's a string of length 1 consisting of the NULL character,
  whose <tt>ord()</tt> is 0, which is false. The string, however,
  is true. <tt>read()</tt> doesn't return strings, but rather
  byte-counts.<br>
  d: That would signal an I/O error, not normal end of file. The
  circumfix operator <tt>&lt;&gt;</tt> returns <tt>undef</tt> when
  it reaches end of file, but a normal read does not.</p>

  <p><b>5. c.</b> A list is not an array, although in many places
  one may be used for the other. An array has an AV allocated,
  whereas a list is just some values on a stack somewhere. You
  cannot alter the length of a list, for example, any more than you
  could alter a number by saying something like <tt>23++</tt>.
  While an array contains a list, it is not a list itself.<br>
  a: That makes a reference to a newly allocated anonymous array,
  and populates it with a copy of the contents of @array.<br>
  b: The backslash operator is distributive across a list, and
  produces a list in return, this being (<tt>\$s, \@a, \%h,
  \&amp;c</tt>). Well, in list context. In scalar context, it's a
  strange way to get a reference to the function &amp;c.<br>
  d: @array is not a list, but an array.</p>

  <p><b>6. d.</b> A regular expression (by definition) must be able
  to determine the next state in the finite automaton without
  requiring any extra memory to keep around previous state. A
  pattern <tt>/([ab]+)c\1/</tt> requires the state machine to
  remember old states, and thus disqualifies such patterns from
  being regular expressions in the classic sense of the term.<br>
  a: The mere presence of minimal and maximal repetitions does not
  disqualify a language from being "regular."<br>
  b: Both NFAs and DFAs can be used to solve regular expressions.
  Given an NFA, a DFA for it can be constructed, and vice versa.
  For example, classical grep uses an NFA, while classical egrep a
  DFa. Whether a pattern matches a particular string doesn't
  change, but where the match occurs may. In any case, they're both
  regular. However, an NFA can also be modified to handle
  backtracking, while a DFA cannot.<br>
  c: The (<tt>?=foo</tt>) and (<tt>?!foo</tt>) constructs no more
  violate whether the language is regular than <tt>^</tt> and
  <tt>$</tt>, which are also zero-width statements.</p>

  <p><b>7. a.</b> In Perl, the number of arguments is available to
  a function via the scalar sense of <tt>@_</tt>, the return
  context is available via <tt>wantarray()</tt>, and the types of
  the arguments via <tt>ref()</tt> (if they're references) and
  simple pattern matching like <tt>/^\d+$/</tt> (otherwise). In
  low-level languages like C++, where you can't do this, you must
  resort to overloading of functions.<br>
  b: Actually, Perl does support overloaded operators via use
  overload, overridden functions as in <tt>use Cwd qw!chdir!</tt>,
  and overridden methods via inheritance and polymorphism. It just
  doesn't support functions automatically overloaded on parameter
  signature or return type. Not that such isn't longed for.<br>
  c: Perl actually does have function prototypes, but this isn't
  used for the traditional sort of prototype checking, but rather
  for creating functions that exactly emulate Perl's built-ins,
  which can implicitly force context conversion or
  pass-by-reference without the caller being aware.<br>
  d: Just because it's hard isn't likely to rule out something from
  being implemented - someday.</p>

  <p><b>8. d.</b> The <tt>y///</tt> operator is the sed-savvy
  synonym for <tt>tr///</tt>. That means <tt>y(3)</tt> would be
  like <tt>tr()</tt>, which would be looking for a second string,
  as in <tt>tr/a-z/A-Z/, tr(a-z)(A-Z)</tt>, or
  <tt>tr[a-z][A-Z]</tt>.<br>
  a: Most people don't call functions with ampersands anymore. If
  they did, as in <tt>&amp;y()</tt>, it wouldn't be so hard.<br>
  b: <tt>y</tt> isn't really a function, per se. If it were, you
  would never see <tt>y!abc!xyz!</tt>, since proper functions do
  not like getting banged on that way.<br>
  c: Functions don't require prototypes in Perl.<br></p>

  <p><b>9. b.</b> Surprisingly enough, you have to put both the
  <tt>reverse()</tt> and the <tt>&lt;FH&gt;</tt> into scalar
  context separately for this to work.<br>
  a: Although <tt>scalar &lt;FH&gt;</tt> did retrieve just the next
  line, the <tt>reverse()</tt> is still in the list context imposed
  on it by print, so it takes its list of one element and reverses
  the order of the list, producing exactly the next line. An
  expensive way of writing print scalar <tt>&lt;FH&gt;</tt>.<br>
  c: Although the first use of scalar inhibits the list context
  being imposed on <tt>reverse()</tt> by <tt>print()</tt>, it
  doesn't carry through to change the list context that
  <tt>reverse()</tt> is imposing on <tt>&lt;FH&gt;</tt>. So
  <tt>reverse()</tt> catenates all its arguments and does a
  byte-for-byte flip on the resulting string.<br>
  d: That reads all lines in F H, then reverses that list of lines
  and passes the resulting reversed list off to print. This is
  actually a very useful thing, and simulates <tt>tail -r</tt>
  behavior but without the annoying buffer limitations of that
  utility. Nonetheless, it's not what we want.<br></p>

  <p><b>10. b.</b> The <tt>/g</tt> state on a global variable is
  not protected with local. That'll teach you to stop using locals.
  Too bad <tt>$_</tt> can't be the target of a <tt>my()</tt> -
  yet.<br>
  a: However, if you do a while(<tt>&lt;&gt;</tt>) and forget to
  first localize <tt>$_</tt>, you'll hurt someone above you. That's
  because even though foreach implicitly localizes <tt>$_</tt>,
  while(<tt>&lt;&gt;</tt>) does not.<br>
  c: Doing a <tt>local()</tt> on an imported variable is not
  harmful. Of course, in the case of <tt>$_</tt>, it's virtually
  unnecessary, since <tt>$_</tt> is always forced to mean the
  version in the main package, that is, <tt>$main::_</tt>.<br>
  d: This looks close to the bizarre phenomenon known as variable
  suicide, but as of this writing, you should be safe from
  it.<br></p>

  <p><b>11. d.</b> Perl can use closures with unreachable private
  data as objects, and C++ doesn't support closures.Furthermore,
  C++ does support pointer arithmetic via <tt>int *ip =
  (int*)&amp;object</tt>, allowing you to look all over the object.
  Perl doesn't have pointer arithmetic. It also doesn't allow
  <tt>#define private public</tt> to change access rights to
  foreign objects. On the other hand, once you start poking around
  in <tt>/dev/mem</tt>, no one is safe.<br>
  a. See above for why.<br>
  b: Both support multiple inheritance.<br>
  c: Exchange "Perl" and "C++" in that answer, and you would be
  telling the truth. C++ is too primitive to know when an object is
  no longer in use, because it has no garbage collection system.
  Perl does.<br></p>

  <p><b>12. d.</b> Odd though it appears, this is how it works.
  Note that because the second is a symbol table lookup, it is
  disallowed under <tt>use strict "refs"</tt>. The words global,
  local, package, symbol table, and dynamic all refer to the kind
  of variables that <tt>local()</tt> affects, whereas the other
  sort, those governed by <tt>my()</tt>, are variously knows as
  private, lexical, or scoped variables.<br>
  a: Try again. You're close.<br>
  b: One is the scoped variable, the other the package variable.
  Which is which, though?<br>
  c: There is no difference between a package variable and a global
  variable. All package variables are globals, and vice
  versa.<br></p>

  <p><b>13. b.</b> We don't have full POSIX regexes, so you can't
  get at the <tt>isalpha()</tt> macro from <i>ctype.h</i> except
  indirectly. You ask for one byte which is neither a
  non-alphanumunder, nor an under, nor a numeric. That leaves just
  the alphabetics, which is what you want.<br>
  a: You still forgot the locale-specific letters. The <tt>/i</tt>
  flag doesn't bring them in.<br>
  c: Lamentably, this reasonably standard syntax is not yet
  supported in Perl.<br>
  d: You forgot the locale-specific letters.<br></p>

  <p><b>14. a.</b> Dereferencing a string with <tt>*{"STR"}</tt> is
  disallowed under the refs stricture, although <tt>*{STR}</tt>
  would not be. This is similar in spirit to the way
  <tt>${"STR"}</tt> is always the symbol table variable, while
  <tt>${STR}</tt> may be the lexical variable. If it's not a
  bareword, you're playing with the symbol table in a particularly
  dynamic fashion.<br>
  b: Assuming that the expressions don't get resolved at compile
  time, this all has to wait until run time. Something like
  <tt>*Foo::varname</tt>, however, would be looked up at compile
  time.<br>
  c: The <tt>%Foo::</tt> hash is always the symbol table associated
  with package Foo; such a hash can hardly be called regular. Both
  versions actually refer to the same typeglob, although somewhat
  differently.<br>
  d: Although you can get package Foo's symbol table via the hash
  <tt>%Foo::</tt>, you cannot usefully generate new typeglobs
  (symbols) this way. You could copy old ones into that slot,
  though, effectively doing the Exporter's job by hand.<br></p>

  <p><b>15. d.</b> If it weren't for HTML comments, improperly
  formatted HTML, and tags with interesting data like
  <tt>&lt;SCRIPT&gt;</tt>, you could do this. Alas, you cannot. It
  takes a lot more smarts, and quite frankly, a real parser.<br>
  a: As written, the dot will not cross newline boundaries, and the
  star is being too greedy. If you add a <tt>/s</tt>, then yes, it
  will remove all tags - and a great deal else besides.<br>
  b: It is easy to construct a tag that will cause this to fail,
  such as <tt>&lt;IMG SRC='foo.gif' ALT="&gt; "&gt;</tt>.<br>
  c: For a good deal of HTML, this will actually work, but it will
  fail on cases with annoying comments, poorly formatted HTML, and
  tags like <tt>&lt;SCRIPT&gt;</tt> and <tt>&lt;STYLE&gt;</tt>,
  which can contain things like <tt>while (&lt;FH&gt;) {}</tt>
  without those being counted as tags. Comments that will annoy you
  include <tt>&lt;!-- &lt;foo bar = "--&gt;"&gt;</tt> which will
  remove characters when it shouldn't; it's just a comment followed
  by <tt>"&gt;</tt>. And even something like <tt>&lt;!-- &lt;foo
  bar = "--&gt;</tt> most browsers will get right, but the
  substitution will not. And if you have improper HTML, you get
  into even more trouble, like this: <tt>&lt;foo bar = "bleh" @&gt;
  text text text &lt;foo bar = "bleh"&gt;</tt> in which case the
  <tt>.*?</tt> will gobble up much more than you thought it
  would.</p>

  <p><b>16. a.</b> The indirect object syntax only has a single
  token lookahead. That means if <tt>new()</tt> is a method, it
  only grabs the very next token, not the entire following
  expression. This is why <tt>new $obj[23] arg</tt> doesn't work,
  as well as why <tt>print $fh[23] "stuff\n"</tt> doesn't work.
  Mixing notations between the OO and IO notations is perilous. If
  you always use arrow syntax for method calls, and nothing else,
  you'll never be surprised.<br>
  b: If the current package did in fact have its own <tt>new()</tt>
  function, then this would be the right answer, but for the wrong
  reasons. Within a class, it might appear to make no difference
  since the <tt>new()</tt> subroutine would get its argument in
  <tt>$_[0]</tt> whether it's called as a function or a method.
  However, a method call can use inheritance, while a function call
  never does. That means esoteric overridden <tt>new()</tt> methods
  would be duped out of calling their derived class' constructor
  first, and we wouldn't want that to happen, now would we?<br>
  c: Perl may be crazy, but it's not quite that crazy. Yet.<br>
  d: Just because it looks like a unary function doesn't mean a
  method call parses like one. You just want it to work this way.
  If you want that, write that.<br></p>

  <p><b>17. c.</b> This is scalar context, not list context, so we
  have the bistable flip-flop range operator famous in parsing of
  mail messages, as in <tt>$in_body = /^$/ .. eof()</tt>. Except
  for the first time <tt>f()</tt> returns true, <tt>g()</tt> is
  entirely ignored, and <tt>f()</tt> will be ignored later when
  <tt>g()</tt> is evaluated. Double dot is the inclusive range
  operator; <tt>f()</tt> and <tt>g()</tt> will both be evaluated on
  the same record. If you don't want that to happen, the exclusive
  range operator, triple dots, can be used instead. For extra
  credit, describe this: <tt>$bingo = ( a() .. b() ) ... ( c() ..
  d() );</tt><br>
  a: You'd be amazed at how many things in Perl don't cause syntax
  errors.<br>
  b: That sounds more like a negated logical xor. A logical xor is
  <tt>!$a != !$b</tt>, so you've just described <tt>!$a ==
  !$b</tt>. Interesting, and perhaps even useful, but unrelated to
  .., our scalar range operator.<br>
  d: That might work in list context, but never in scalar. The list
  operator .. is a totally different creature than the scalar one.
  They're just spelled the same way, kind of like when you can the
  rusty old can down by the guys' can just because you can.
  Context, as always, is critical.<br></p>

  <p><b>18. b.</b> Perl keeps track of your variables, whether
  dynamic or otherwise, and doesn't free things before you're done
  using them.<br>
  a: Even though the reference returned is for all intents and
  purposes a copy of the original (Perl uses return by reference),
  the underlying referent has not changed.<br>
  c: Perl seldom stops you from doing what you want to do, and
  tries very hard to do what you mean to do. This is one of those
  cases.<br>
  d: Perl is not C or C++.<br></p>

  <p><b>19. c.</b> Only lexical variables are truly private, and
  they will persist even when their block exits if something still
  cares about them. Thus: <tt>{ my $i = 0; sub next_i { $i++ } sub
  last_i { --$i } }</tt> creates two functions that share a private
  variable. The <tt>$i</tt> variable will not be deallocated when
  its block goes away because <tt>next_i()</tt> and
  <tt>last_i()</tt> need to be able to access it.<br>
  a: Perl is not the Korn shell, nor anything like it. If you tried
  this, your program probably wouldn't even compile.<br>
  b: The <tt>local()</tt> operator merely saves the old value of a
  global variable, restoring that value when the block in which the
  local occurred exits. Once the subroutine exits, the temporary
  value is lost. Before then, other functions can access the
  temporary value of that global variable.<br>
  d: It would be difficult to keep private state in a function
  otherwise.<br></p>

  <p><b>20. d.</b> When the interpreter exits, it first does an
  exhaustive search looking for anything that it allocated. This
  allows Perl to be used in embedded and multithreaded applications
  safely, and furthermore guarantees correctness of object
  code.<br>
  a: Under the current implementation, the reference-counted
  garbage collection system won't notice that the object in
  <tt>$ap</tt>'s array cannot be reached, because the array
  reference itself never has its reference count go to zero.<br>
  b: That would be very bad, because then you could have objects
  whose class-specific cleanup code didn't get called ever.<br>
  c: A class's DESTROY function, or that of its base classes, is
  called for any cleanup. It is not expected to deallocate memory,
  however.<br></p>

  <p><b>21. a.</b> It has been said that all programs advance to
  the point of being able to automatically read mail. While not
  quite there yet (well, without loading a module), Perl will at
  least automatically send it.<br>
  b: That would be bad. Very Bad. What do you think we are? A shell
  or something?<br>
  c: It would be improper to run anything at all in the face of
  such naughtiness.<br>
  d: An appealing idea, though, isn't it? After all, Perl does
  possess super(user)powers at this point. You just never know what
  it might do. In the interests of courtesy, though, Perl stays out
  of your power supply just as it stays out of your living
  room.<br></p>

  <p>_ _END_ _</p>
  <hr>
  <i>Tom Christiansen is the co-author of Programming Perl,
  Learning Perl, and the upcoming Perl Cookbook. He would like to
  thank Nathan Torkington, Abigail, and Jeffrey Friedl for their
  suggestions.</i> <!-- end of article -->
   <!-- end of file -->
</body>
</html>
