<html><head><title>Nov99: Linux,  Real-Time Linux,  & IPC</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Linux,  Real-Time Linux,  &amp; IPC</h1><p><i>Dr. Dobb's Journal</i> November 1999</p><h2>FIFO versus  shared memory </h2><h3>By Frederick M. Proctor</h3><I>Fred is a member of the Intelligent Systems Division at NIST. He can be contacted at frederick.proctor@nist.gov.</I><hr><p>When dealing with real-time systems, the overhead of interprocess communications (IPC) becomes important. The formalized structures that are used in Linux for IPC can carry with them a significant amount of overhead. This can create timing problems for your applications. In this article, I'll examine two of the best IPC mechanisms available under Linux -- FIFOs and shared memory.</p><p>Communication between Linux and Real-Time Linux (RT-Linux) processes is usually accomplished via first-in-first-out (FIFO) connections -- point-to-point queues of serial data analogous to UNIX character devices. FIFOs have the following characteristics: </p><DDJADVERTISEMENT INLINE><p> </p><ul>  <li>FIFOs queue data, so no protocol is required to prevent data overwrites.   <li>Boundaries between successive data writes are not maintained.   <li>Applications must detect boundaries between data, particularly if data is of varying size.   <li>FIFOs support blocking for synchronization. Processes need not poll for the arrival of data.   <li>FIFOs are a point-to-point communication channel. FIFOs do not support the one writer/several readers model. </ul><p>You declare the maximum number of FIFOs in rt_fifo_new.c as <i>#define RTF_NO 64.</i> These appear as devices dev/rtf0..63 in the filesystem. This limit can be changed and the rt_fifo_new.o module recompiled. There is no limit to the number of FIFOs an application can use, or to the size of data that can be written to a FIFO (within practical memory limits). </p><p>An alternative to FIFOs is shared memory, in which a portion of physical memory is set aside for sharing between Linux and real-time processes. In a nutshell, shared memory is a pool of memory segments reserved at boot time. These segments may be mapped into the address space of more than one application, allowing for fast data sharing, data updates, and handshaking. This allows for low-latency parallel updates.</p><p>Shared memory has the following characteristics: </p><ul>  <li>It does not queue data written to it. Applications requiring handshaking must define a protocol to assure data is not overwritten.   <li>Because data is not queued, individual items in data structures (megabytes in size) can be quickly updated.   <li>It has no point-to-point restriction. Shared memory can be written or read by any number of Linux or real-time processes.   <li>The number of independent shared memory channels is limited only by the size of physical memory.   <li>Blocking for synchronization is not directly supported. To determine if data is new, the data must contain a count that can be compared against previous reads.   <li>Mutual exclusion of Linux and RT-Linux processes is not guaranteed. Interrupted reads and writes can be detected, however.  </ul><p>Whether you use FIFOs or shared memory depends on the application's natural communication model. For control applications involving processes that execute cyclically based on the expiration of an interval timer (where data queuing is the exception rather than the rule), shared memory is a good choice for communication.</p><h3>Setting up the Shared-Memory Pool </h3><p>The shared-memory pool is a block of physical memory set aside at boot time so that Linux does not use it for processes. To set up the pool, you first determine how much physical memory the system has and how much is to be used for shared memory. Subtracting the size of the shared memory desired from the size of physical memory gives the absolute base address of the pool. The result is passed to the Linux boot loader (LILO) at boot time. This is accomplished by editing /etc/lilo.conf and inserting a line with the <i>append</i> keyword. </p><p>Suppose, for example, the system has 32 MB of memory and 1 MB is to be used for the shared-memory pool. The base address for shared memory is<i> </i>32 MB-1 MB=31 MB. Assuming the original /etc/lilo.conf file contained <A NAME="re1"><A HREF="9911be1.htm">Example 1</A>(a), the file should be modified like <A NAME="re1"><A HREF="9911be1.htm">Example 1</A>(b).</p><p>Similarly, suppose the system has 16 MB of memory and 512 KB are to be used for the shared-memory pool. The base address for shared memory is 16384 KB-512 KB=15872 KB<i>.</i> The /etc/lilo.conf file should be modified like <A NAME="re1"><A HREF="9911be1.htm">Example 1</A>(c).</p><p>The size of the shared-memory pool must be less than the page size declared in /usr/include/asm/param.h. In Intel Pentium-class machines and above, the page size is 4 MB; on earlier machines, the page size is 1 MB. </p><h3>Addressing the  Shared-Memory Pool in C Programs </h3><p>The base address of the shared-memory pool needs to be declared in C so that both Linux and RT-Linux code can reference it. For example, you can access shared memory based at 31 MB using the C statement <i>#define BASE_ADDRESS (31 * 0x100000)</i>. Similarly, shared memory based at 15872 KB may be accessed using the C statement <i>#define BASE_ADDRESS (15872 * 0x400)</i>. This address is used differently in Linux than in RT-Linux. Linux processes need to map this physical address into their virtual address space. RT-Linux processes can reference data located at this address as a pointer directly. </p><p>In addition to this declaration, the Linux and RT-Linux C code must agree on the data structures written into shared memory. In <A NAME="rl1"><A HREF="#l1">Listing One</A>, for example, a Linux process sends a command to an RT-Linux process by filling in the MY_COMMAND structure and writing it into shared memory. The RT-Linux process reads this structure from shared memory to get the command. An RT-Linux process sends status to a Linux process by filling in the MY_STATUS structure and writing it into shared memory. The Linux process reads this structure from shared memory to get the status. </p><p>The MY_STRUCT structure is a combination of both the command and status structure, and can be used to ensure that the two structures do not overlap and that their fields are aligned on the proper boundaries. It is also possible to define two base addresses -- one for each structure -- making sure the start of one structure is after the end of the previous one and that all fields are properly aligned. By combining them into a single aggregate structure and letting the compiler allocate storage, the structure will have a valid byte alignment automatically. </p><p>In a typical application, the BASE_ADDRESS declaration and shared-structure declarations would be put in a header file shared by both Linux and RT-Linux code. </p><h3>Accessing the Shared-Memory Pool from Processes other than RT-Linux </h3><p>Normal Linux processes are required to map physical memory into their private address space to access it. To do this, the Linux processes calls <i>open()</i> on the memory device /dev/mem; see <A NAME="re2"><A HREF="9911be2.htm">Example 2</A>.</p><p>Due to security concerns, the default permissions on /dev/mem allow only root processes to read or write /dev/mem. To access physical memory, the program must be run as root, its permissions must be changed to <i>setuid</i> <i>root</i>, or the permissions on /dev/mem must be changed to allow access to users other than root. </p><p>After the file descriptor is opened, the Linux process maps the shared memory into its address space using <i>mmap()</i>; see <A NAME="rl2"><A HREF="#l2">Listing Two</A>. BASE_ADDRESS is passed to <i>mmap()</i>, which returns a pointer to the shared memory as mapped into the Linux process's address space. Once the shared memory is mapped, it may be accessed by dereferencing the pointer, as in <A NAME="re3"><A HREF="9911be3.htm">Example 3</A>(a). When the process terminates, you use <i>munmap()</i> to unmap the shared memory by passing the pointer and the size of its object; see <A NAME="re3"><A HREF="9911be3.htm">Example 3</A>(b).</p><h3>Accessing the  Shared-Memory Pool from RT-Linux </h3><p>Shared-memory access is much easier in RT-Linux since the real-time code executes in kernel space and thus is not required to map physical addresses to virtual addresses. In Linux kernels 2.0.XX, the pointer can be set directly; see <A NAME="re4"><A HREF="9911be4.htm">Example 4</A>(a). In Linux kernels 2.1.XX, the pointer needs to be mapped via a call to the <i>__va()</i> macro defined in /usr/include/asm/page.h, as in <A NAME="re4"><A HREF="9911be4.htm">Example 4</A>(b).</p><h3>Detecting New Writes </h3><p>FIFOs have an advantage over shared memory in that reads and writes follow standard UNIX conventions. Processes other than RT-Linux processes can use <i>write()</i> to queue data onto a FIFO, and <i>read()</i> returns the number of characters read. Zero characters read from a FIFO means no new data was written since the last read. On the RT-Linux side, a handler is associated with a FIFO that is invoked after a nonreal-time Linux process writes to the FIFO. Normally the handler calls <i>rtf_get()</i> to dequeue the data from the FIFO. </p><p>These functions are not necessary with shared memory. Reads and writes are accomplished by reading and writing directly to pointers. Consequently, the operating system provides no way to detect if the contents of shared memory have been updated. You need to set up this handshaking explicitly. </p><p>One way to do this is to use message identifiers that are incremented for each new message. The receiver then polls the shared-memory buffer and compares the current identifier with the previous one. If they are different, a new message has been written. Handshaking to prevent message overrun is implemented by echoing message identifiers in the status structure once they have been received. New messages are not sent until the status echoes the message identifier. </p><p>This presumes a time-cyclic polling model on the part of both the Linux and RT-Linux processes. If this is not the natural model for the application, then shared memory may not be a good choice for communication. If shared memory is required for other reasons, and polling is not desirable, other synchronization between Linux and RT-Linux processes can be used. For example, RT-Linux FIFOs can be used only for their synchronization properties. A byte written to a FIFO can be used to wake up a Linux process blocked on a read, or to call the handler in an RT process. </p><h3>Realizing Mutual Exclusion </h3><p>It is possible (and therefore a certainty) for a Linux process to be interrupted by a real-time process while in the middle of a read/write to memory they are sharing. If the Linux process is interrupted during a read, the Linux process sees stale data at the beginning and fresh data at the end. If the Linux process is interrupted during a write, the real-time process sees fresh data at the beginning but stale data at the end. Both problems are fatal in general. </p><p>The problem of ensuring consistency of data shared between two processes is the subject of operating-systems research, and general solutions exist (see, for instance, <i>An Introduction to Operating Systems</i>, Second Edition, by Harvey M. Dietel, Addison-Wesley, 1990). Our problem is simpler because only the Linux process can be interrupted. In no case can a Linux process interrupt a real-time process during the execution of its task code. </p><p>This simplification means that an <i>inuse </i>flag can be used by the Linux process to signal that it is accessing the shared memory. You declare the <i>inuse </i>flag at the beginning of the shared-memory structure, and it is set by the Linux process when it wants to read or write and cleared when the Linux process is finished. The real-time process checks the <i>inuse </i>flag before it accesses shared memory; if set, the process defers the read or write action until it detects that the flag is cleared. </p><p>This may lead to the indefinite postponement of the real-time process, if the following conditions are true: </p><ul>  <li>   <li>The real-time process runs at the period of the Linux process, or at multiples of this period.   <li>The accesses are synchronized so that the real-time process always interrupts the Linux process during the critical section when it has set the <i>inuse </i>flag.   <li> </ul><p>The first condition implies that the real-time code is running as slow or slower than the Linux code, and the second implies that the Linux code is running as deterministically as the real-time code. Neither is typically true, and both are rarely true at the same time. If these conditions are true for a system, successive deferrals can be detected by the real-time code and can trigger actions to keep the system under control. </p><p><A NAME="rl3"><A HREF="#l3">Listing Three</A> illustrates the application of the <i>inuse </i>flag for commands written by the Linux process to the real-time process, and status written by the real-time process and read by the Linux process. Assume that <i>command_ptr</i> has been set up in a Linux process to point to the shared-memory area for commands to the real-time process. To write to shared memory, you must compose the command, set the <i>inuse</i> flag in shared memory directly, write the command, and reset the <i>inuse </i>flag; see <A NAME="rl4"><A HREF="#l4">Listing Four</A>.</p><p>Assuming that the real-time code has set <i>command_ptr</i> to point to the shared memory for commands, it would read commands as in <A NAME="rl5"><A HREF="#l5">Listing Five</A>. To read status information, the Linux process sets the <i>inuse </i>flag before copying out the data. Assuming that <i>status_ptr</i> has been set up in a Linux process to point to the shared-memory area for status from the real-time process, this would look like <A NAME="rl6"><A HREF="#l6">Listing Six</A>.</p><p>When writing status, the real-time process checks for the <i>inuse</i> flag and defers a status write if it is set. Assuming that the real-time code has set <i>status_ptr</i> to point to the shared memory for status, this would look like <A NAME="rl7"><A HREF="#l7">Listing Seven</A>.</p><h3>Queuing Data in Shared  Memory Using Ring Buffers </h3><p>While shared memory is most naturally suited for communications in which data overwrites the previous contents, queuing can be set up using ring buffers. Ring buffers queue 0 or more instances of a data structure, up to a predetermined maximum. </p><p>To illustrate the use of ring buffers, consider a system that queues error messages. Errors are declared as strings of a fixed maximum length, and there is a fixed maximum number of errors that can be queued. This is implemented as a two-dimensional array, as in <A NAME="rl8"><A HREF="#l8">Listing Eight</A>.</p><p>Supplementing the actual list of errors are indices to the start and end of the queue, which wrap around from the end of the shared-memory area to the beginning (hence the name "ring buffer"), and a count of the errors queued. As previously described, an <i>inuse</i> flag is also declared to signal that a Linux process is accessing the ring buffer to prevent data inconsistencies in the event a real-time process interrupts Linux process access. The full shared-memory structure declaration is then <A NAME="rl9"><A HREF="#l9">Listing Nine</A>.</p><p>Both Linux and RT-Linux use the same access functions. However, Linux processes need to set the <i>inuse</i> flag before getting an error off the ring, and real-time processes need to check the <i>inuse</i> flag and defer access until the flag is zero. Assuming that <i>errlog</i> is a pointer to the shared-memory area for both Linux and real-time processes, the access functions look like <A NAME="rl10"><A HREF="#l10">Listing Ten</A>. </p><p>For Linux, getting an error off the ring buffer is accomplished by <A NAME="rl11"><A HREF="#l11">Listing Eleven</A>. For an RT process, writing an error to the ring looks like <A NAME="rl12"><A HREF="#l12">Listing Twelve</A>.</p><h3>Sample Code</h3><p>I've included a sample application that illustrates Linux to real-time commands, real time to Linux status, and real time to Linux error logging. </p><p>The application consists of two parts. The first is a real-time process that runs cyclically, reads a command buffer, continually updates a status buffer, and logs some diagnostic messages to the queued error buffer. The second part is a command-line Linux program that handles a few keyboard commands for sending commands and printing the real-time process status and error log. </p><p>This application is available electronically; see "Resource Center," page 5. The application is provided as a ZIP file and a gzipped tar file (shmex.tgz). Unpack and compile with:</p><blockquote><p>tar xzvf shmex.tgz </p><p>make </p></blockquote><p>You have to set up Linux to boot with shared memory set aside, as detailed previously. </p><h3>Acknowledgments</h3><p>Thanks to Rich Bowser, bowser@luz.cs .nmt.edu, for information on the 4-MB memory chunking and the problems with 486 systems; Albert D. Cahalan, acahalan@ cs.uml.edu, for help with memory page and <i>mmap()</i> information; and Daniele Lugli, danlugli@tin.it, for review and comments. </p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>typedef struct  {  unsigned char inuse;  /* more on this later */  int command;  int command_number;  int arg1;  int arg2; } MY_COMMAND; typedef struct  {  unsigned char inuse;  /* more on this later */  int command_echo;  int command_number_echo;  int stat1;  int stat2; } MY_STATUS; typedef struct  {  MY_COMMAND command;  MY_STATUS status; } MY_STRUCT; </pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>#include &lt;stdlib.h&gt;                /* sizeof() */ #include &lt;sys/mman.h&gt;              /* mmap(), PROT_READ, MAP_FILE */ #define MAP_FAILED ((void *) -1)   /* omitted from Linux mman.h */ #include "myheader.h" MY_STRUCT *ptr; ptr = (MY_STRUCT *) mmap(0, sizeof(MY_STRUCT),  PROT_READ | PROT_WRITE, MAP_FILE | MAP_SHARED, fd, BASE_ADDRESS); if (MAP_FAILED == ptr) {   /* handle error here */ } close(fd);                    /* fd no longer needed */ </pre><P><A HREF="#rl2">Back to Article</A></P><H4><A NAME="l3">Listing Three  </H4><pre>typedef struct  {   unsigned char inuse;   int command;   int command_number;   int arg1;   int arg2; } MY_COMMAND; typedef struct  {   unsigned char inuse;   int command_echo;   int command_number_echo;   int stat1;   int stat2; } MY_STATUS; </pre><P><A HREF="#rl3">Back to Article</A></P><H4><A NAME="l4">Listing Four </H4><pre>MY_COMMAND my_command; /* compose command in local structure */ my_command.inuse = 1;  /* will overwrite during copy, so set here too */ my_command.command = 123; my_command.command_number++; my_command.arg1 = 2; my_command.arg2 = 3; /* set inuse flag */ command_ptr-&gt;inuse = 1; /* copy local structure to shared memory */ memcpy(command_ptr, &amp;my_command, sizeof(MY_COMMAND)); /* clear inuse flag */ command_ptr-&gt;inuse = 0; </pre><P><A HREF="#rl4">Back to Article</A></P><H4><A NAME="l5">Listing Five </H4><pre>if (0 != command_ptr-&gt;inuse) {  /* ignore it, perhaps incrementing a deferral count */ } else {   /* okay to access shared memory */ } </pre><P><A HREF="#rl5">Back to Article</A></P><H4><A NAME="l6">Listing Six</H4><pre>MY_STATUS my_status; /* set inuse flag */ status_ptr-&gt;inuse = 1; /* copy shared memory to local structure */ memcpy(&amp;my_status, status_ptr, sizeof(MY_STATUS)); /* clear inuse flag */ status_ptr-&gt;inuse = 0; /* refer to local struct from now on */ if (my_status.stat1 == 1) {   ... } </pre><P><A HREF="#rl6">Back to Article</A></P><H4><A NAME="l7">Listing Seven </H4><pre>if (0 != status_ptr-&gt;inuse) {   /* defer status write, perhaps incrementing deferral count */ } else {   /* okay to write status */ } </pre><P><A HREF="#rl7">Back to Article</A></P><H4><A NAME="l8">Listing Eight</H4><pre>#define ERROR_NUM 64  /* max number of error strings to be queued */ #define ERROR_LEN 256  /* max string length for an error */ char error[ERROR_NUM][ERROR_LEN]; </pre><P><A HREF="#rl8">Back to Article</A></P><H4><A NAME="l9">Listing Nine</H4><pre>#define ERROR_NUM 64  /* max number of error strings to be queued */ #define ERROR_LEN 256  /* max string length for an error */ typedef struct {   unsigned char inuse; /* flag signifying Linux accessing */   char error[ERROR_NUM][ERROR_LEN]; /* the errors themselves */   int start; /* index of oldest error */   int end; /* index of newest error */   int num; /* number of items */ } MY_ERROR; </pre><P><A HREF="#rl9">Back to Article</A></P><H4><A NAME="l10">Listing Ten </H4><pre>/* initialize ring buffer; done once, perhaps in init_module() */ int error_init(MY_ERROR *errlog) {  errlog-&gt;inuse = 0;  errlog-&gt;start = 0;  errlog-&gt;end = 0;  errlog-&gt;num = 0;  return 0; } /* queue an error at the end */ int error_put(MY_ERROR *errlog, const char *error) {   if (errlog-&gt;num == ERROR_NUM)     {       /* full */       return -1;     }   strncpy(errlog-&gt;error[errlog-&gt;end], error, ERROR_LEN);   errlog-&gt;end = (errlog-&gt;end + 1) % ERROR_NUM;   errlog-&gt;num++;   return 0; } /* dequeue the error off the front */ int error_get(MY_ERROR *errlog, char *error) {   if (errlog-&gt;num == 0)     {       /* empty */       return -1;     }   strncpy(error, errlog-&gt;error[errlog-&gt;start], ERROR_LEN);   errlog-&gt;start = (errlog-&gt;start + 1) % ERROR_NUM;   errlog-&gt;num--;   return 0; } </pre><P><A HREF="#rl10">Back to Article</A></P><H4><A NAME="l11">Listing Eleven</H4><pre>char error[ERROR_LEN];  /* place to copy error */ /* set in-use flag in shared memory */ errlog-&gt;inuse = 1; /* copy error out */ if (0 != error_get(errlog, error)) {   /* empty */ } else {   /* handle it */ } /* clear in-use flag in shared memory */ errlog-&gt;inuse = 0; </pre><P><A HREF="#rl11">Back to Article</A></P><H4><A NAME="l12">Listing Twelve</H4><pre>char error[ERROR_LEN];  /* place to compose error */ /* check for in-use */ if (0 != errlog-&gt;inuse) {   /* defer writing, perhaps incrementing deferral count */ } else {   /* compose it */   strcpy(error, "your error here");   if (0 != error_put(errlog, error))   {     /* full */   } } </pre><P><A HREF="#rl12">Back to Article</A></P><HR><I>Copyright &copy; 1999, Dr. Dobb's Journal</I><BR>
</body></html>