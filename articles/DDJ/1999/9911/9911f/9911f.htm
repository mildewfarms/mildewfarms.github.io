<html><head><title>Nov99: The BeRays  Ray Tracer</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>The BeRays  Ray Tracer</h1><p><i>Dr. Dobb's Journal</i> November 1999</p><h2>Making it easy to plug in new rendering ideas</h2><h3>By Regan Russell</h3><I>Regan is a programmer in Sydney, Australia. He can be contacted at rrussell@ c2.telstra-mm.net.au.</I><hr><p>BeOS, an operating system from Be Inc. (http://www.be.com/), was designed for digital media applications on PCs and Internet appliances. Consequently, BeOS supports a 64-bit journaling filesystem, real-time multimedia streaming, pervasive multithreading, and multiprocessor support. </p><p>There are two types of Be applications -- GUI applications and console applications. A console application can be written in C and is comparable to UNIX programming. In fact, many tools are GNU based. The default shell is the BeShell, a slightly modified Bourne Again Shell (BASH), popular with users of FreeBSD, Linux, Solaris, and the like. The open-source versions of Lex and YACC -- Flex and Bison -- are also available. Additionally, for the Intel version, NASM (assembler with MMX support) is available. </p><DDJADVERTISEMENT INLINE><p>The Be GUI API, on the other hand, is C++ based. Unlike Windows (and XII), which lets you write apps in C using the raw Win32 API without using C++ and MFC (or Motif applications without a C++ wrapper), you cannot write GUI-based BeOS applications in C. To do anything interesting, applications must create objects derived from the classes <i>BApplication</i>, <i>BWindow</i>, and <i>BView</i> in C++.</p><p>In this article, I present a GUI-based Be ray-tracer application called "BeRays" -- an object-oriented application (written in C++) that makes it easy to plug in new rendering ideas. Most public source ray tracers are written in C and simulate inheritance in case statements or by implementing their own virtual function tables (commonly known as "vtbls") by manipulating function pointers. In BeRays, I use flex and bison to generate the parser for the input language.The source code and related files for the BeOS implementation of BeRays is available electronically; see "Resource Center," page 5. Although I've tested BeRays on both Intel BeOS 4.5 and PowerPC BeOS 4.0, I'm only providing the Intel version with Intel project file. To build a PowerPC version, you simply create a new project and add all the required source files and libraries. </p><h3>BeOS Kits</h3><p>The keys to developing BeOS applications are kits (classes and interfaces to classes that provide support) and the Smalltalk Model View Controller (MVC) concept. There are a number of kits, including:</p><p></p><ul>  <li>The Application kit. The most important kit for beginning BeOS programming is the Application kit. Like most C++ programs, a BeOS application starts in <i>main()</i>. The <i>main</i> function is usually used to create an application object and <i>Run()</i> it; see <A NAME="rl1"><A HREF="#l1">Listing One</A>. When using a derived class version of <A NAME="rl1"><A HREF="#l1">Listing One</A>, the subclassed application object constructor usually constructs a window and view, then attaches the view to the window and the window to the application. The MIME encoded string is a signature used by the constructor (<i>BApplication::BApplication()</i>). There is one string of this type for each application. The operating-system framework uses the signature string in the same manner that MIME is used in browsers. It knows to run applications. Windows COM experts might consider a Be application's signature similar to a GUID in that it distinguishes components, or in this case applications, from one another.  <li>	   Additionally, the Application kit includes <i>BMessage</i>, which provides functionality for application objects and is the basis for event handling. Any class derived from <i>BHandler</i> or <i>Blooper</i> can handle <i>BMessages</i>. In addition to normal events, such as a window being resized, messages can be sent from one application to another. This is called "scripting" and supports chaining graphical applications together in the same manner that shell commands are linked.  <li>The Storage kit handles file I/O, directories, MIME types, and filesystems.   <li>The Interface kit handles all GUI work and contains drawing, controls, view, and window classes.   <li>The Kernel kit facilitates low-level access to kernel features such as threads, teams (a collaborative collection of threads), semaphores, and linker images.   <li>The Media kit provides an interface to sound files and digital-to-analog (and back) conversion support.   <li>The Midi kit supports Midi sampling and synthesizer files.   <li>The OpenGL kit provides an interface to OpenGL support of GLScreens and GLViews.   <li>The Device kit handles joystick, the three-fuse geek port, and serial I/O.   <li>The Game kit enables direct window and direct screen access for games.   <li>The Network kit supports sockets and network services.   <li>The Translation kit enables the development of filters for different file types; for example, PNG and BMP.   <li>The Mail kit is a foundation of e-mail agent and delivery services.   <li>The Support kit contains miscellaneous functionality including void pointer lists (<i>BList</i>) and profiler watchdog support.</ul><p>Kits talk to servers. Servers are daemon processes that manage things. One such server is the application server, which includes a psycho-killer thread that goes around cleaning up processes that have gone wild, such as UNIX zombie processes. Kits also require a library and possibly a header file to be included. For example, the OpenGL kit needs libGL.so and be/opengl/GLView.h.</p><p>Kits are not only threadsafe but spawn threads themselves. Creating a window (from the Interface kit and managed by the application server) creates a separate thread to manage it. A group of threads are a team and an application is usually a team of a few threads.</p><p>Many objects in kits take responsibility for their subobjects. For example, a <i>BMenu </i>will delete each <i>BMenuItem </i>in its destructor. It is often valid to allocate variables without keeping track of them and not expect memory leaks. BeRays contains a few new statements without matching deletes. The general case still remains that if the OS allocates it, the OS frees it. If the application allocates it, then the application should free it if the OS will not. <i>BList</i>, for example, will not delete attached objects, but will delete its list nodes.</p><p>Messages are generated from events. Events can have their handler specified at creation time. For example, the <i>BFilePanel</i> in BeRay's ray tracer directs its messages to the parent window. The messages the parent receives depend on the user choices when the dialog is shown. Some events are handled by member functions for example <i>BWindow::FrameMoved(). </i>Threads do not receive messages. Message handlers receive messages. </p><h3>The BeRays Ray-Tracer Application</h3><p>The major components of the BeRays ray tracer I present here are the user interface, rendering engine, and rendering-engine support. The <i>main </i>function fires off the user interface components, and the rendering engine is then constructed and rendered (via the Go menu item, handled by the <i>MessageReceived</i> member function).</p><p>The application starts in <i>main</i> and creates a new RaysApp application, <i>Run</i>s<i> </i>the application, and then deletes the application when the <i>Run</i> returns. The RaysApp's (subclassed from <i>BeApplication</i>) constructor creates a <i>RaysWnd</i> (subclassed from <i>BWindow</i>). The window handles messages and the constructor creates a view. The RaysView constructor creates <i>BMenuItem</i>s and a <i>BMenu</i> and attaches the menu items to the menu and the menu to the view. The message is directed to the window message handler when the menu item is constructed.</p><p>The <i>Go</i> member is called from the window's message-handling function. The <i>RaysWnd</i> <i>MessageReceived</i> member is called when there is a MOPTION_RENDER message generated from the menu item. The menu item is created in the window's constructor with <i>BMenuItem('Render'</i>, <i>new BMessage(MOPTION_RENDER ) );</i>. </p><p>Another message the windows message handler deals with is the file open menu message. The file is read and input is passed to the flex scanner and bison grammar parser. The parser calls the <i>MultiRender </i>member to create new objects. <A NAME="rl2"><A HREF="#l2">Listing Two</A> is the BNF grammar for the input language.</p><p>The general approach I take to ray tracing is not new and is well documented by Glasner, Foley and van Dam, Heckbert, Watt, Watt and Watt, and others, including <i>DDJ</i> (see, for instance, "RAY: A Ray-Tracing Program in C++," by Alain Mangen, July 1994; and "Ray Tracing," Daniel Lyke, September 1990). It is fairly well understood that backward ray tracing starts at an eye or camera position and rays are traced through a view plane toward a scene full of objects. If the ray intersects an object, other rays are traced from the surface of that object for shadows, shading, and reflection. If the ray does not intersect with an object, a background color is set. Forward ray tracing starts at a light source. Backward tracing is also known as "persistence of vision."</p><p>Because a photon is its own antiparticle, a ray going forward in time from a light source to a light receptor can be considered the same as its antiparticle (itself) going backwards in time from the receiver to the transmitter. This has the added bonus that rays emitted from the source but never reach the receiver are not considered. This is a significant speed improvement. For a photon travelling at the speed of light, time has no meaning.</p><p>For all rows and columns of the image, the <i>Go</i> member function constructs a ray starting from the viewpoint and starts a (potentially recursive) <i>Trace</i> through the scene, determining intersections of the ray with scene objects. The result of the <i>Trace</i> is passed to the <i>Shade </i>routine, which determines a color (possibly by calling <i>Trace</i>) and passes it back up to <i>Go </i>where it is set. The <i>RenderEngine </i>also maintains a list of scene objects and a list of light sources.</p><p>The <i>Trace</i> iterates through a list (<i>BList</i>) of scene objects and determines the rays intersection (or lack of) by using the scene objects intersection function. The <i>Shade </i>member uses the scene objects <i>CalcNormal</i> interface to determine the amount of shading. In fact the <i>Trace</i> and <i>Shade</i> members directly or indirectly use a lot of support functions. </p><p><i>SceneObject</i> is a base class for any objects that appear in a scene. <i>SceneObject</i> is used in <i>Trace</i>, <i>Shade</i>, and LightSource's <i>GetColour</i> member for shadow determination. Scene objects need to support three interfaces: Construction, Intersection, and Calculate Normal. Light source, sphere, and plane are types of scene objects. New objects and variations of existing objects can be added at will. Scene objects store properties as a surface object.</p><p>Light source is a type of scene object and is used in the shade routine. It contains the light's color and position and has interfaces for getting the color and ray intersection. The method for getting the color determines if there are objects between the light source and the object the traced ray has stuck. This is used in shadow determination and is called a "shadow feeler."</p><p>In addition to scene objects, the<i> MultiRender</i> class uses a color class to represent colors such as the light to define a scene. The color class stores red, green, and blue triples. It is used in shading and specifying objects properties. Colors can be specified in the range of 0 to 1.0 or in 0 to 255. They are automatically converted.</p><p>Vectors are used extensively through the render engine to generate an image from the definition. The vector class is a mathematical entity for storing x, y, and z triples with operator overloading for vector operations. The methods and operations include length, rotate, reverse rotate, min, max, ~ (normalization), ^ (cross product), % (dot product), * / +, and -. A ray is two vectors from an origin to a direction. All vectors only contain a direction as they start from a common origin of (0,0,0).</p><p>The generation of the image starts with the viewpoint. The viewpoint is an eye position or camera position. A viewpoint contains four vectors: up, right, location, and direction. Rays originate from the viewpoint and once constructed with MakeRay, the viewpoint is discarded.</p><p>With future development in mind, I defined an image class with a red, green, and blue channel bitmap so that per channel image processing could be done later. </p><p>To build BeRays, you start at the command line and compile the lex (flex) and yacc (bison) specifications into C sources with the <i>make</i> command and a standard Makefile. The project can then be compiled and linked with the Build menu item from the IDE. </p><p>When running BeRays, you are presented with a window, blank white view, and menu bar. The menus include File, Go, and Help. The file menu consists of Open scene file and Quit. The Go menu contains the item Render and the Help menu contains About. The scene file is created with a text editor like vi. The program on start up does not contain a scene, so a default scene is used. </p><h3>Conclusion</h3><p>BeRays is simple and can be extended in a multitude of ways. Different illumination methods could be tried, as well as adding bounding volumes, BSP trees, and octrees. One major problem to solve is spatial aliasing or jaggies. Antialiasing techniques (such as stochastic ray tracing) could also be applied. Image processing could be integrated. Other types of objects can be added: You need to create a derived class for the new object and override the <i>Intersection</i> and <i>CalcNormal</i> members and add lex and yacc descriptions for the new object and a function in the render engine to add the object passed in from the parser to the scene list. </p><h3>References</h3><p>Glasner, Andrew S. (editor). <i>An Introduction to Ray Tracing</i>, Academic Press, 1989.</p><p>The Be Development Team. <i>Be Developer Guide</i>, O'Reilly &amp; Associates, 1997.</p><p>Heckbert Paul S. (editor). "A Minimal Ray Tracer" Graphics Gems IV, Academic Press, 1994.</p><p>Foley, James D. Andries van Dam et al. <i>Computer Graphics: Principle and Practice</i>, Second Edition, Addison-Wesley, 1990.</p><p>Watt, A. <i>3D Computer Graphics</i>, Second Edition, Addison-Wesley, 1993.</p><p>Watt, A and M.Watt. <i>Advanced Animation and Rendering Techniques: Theory and Practice</i>, Addison-Wesley, 1992.</p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>#include &lt;Application.h&gt;main(){   const int left = 10, right = 500, top = 10, bottom = 200;   // Create application, window and view..    BApplication *TheApp = new BApplication( "application/x-vnd.ddj-sample" );   BWindow *TheWindow = new BWindow(BRect( left, top, right, bottom ),                "Rays", B_TITLED_WINDOW, B_NOT_ZOOMABLE | B_NOT_RESIZABLE );   BView *TheView = new BView( BRect( 100, 100, 200, 200 ),               "Rays", B_FOLLOW_ALL_SIDES,  B_WILL_DRAW );       // Attach view to window, show the window and run the application.   TheWindow-&gt;AddChild( TheView );   TheWindow-&gt;Show();   TheApp-&gt;Run();   // Clean up.   delete TheView;   delete TheWindow;   delete TheApp;}</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>DIGIT ::= 0|1|2|3|4|5|6|7|8|9NUMBER::= DIGIT {DIGIT}SCENE::= OBJECT | SCENE OBJECTOBJ::= SPHERE_OBJECT | PLANE_OBJECT | BACKGROUND_OBJECT BACKGROUND_OBJECT::=   BACKGROUND  NUMBER NUMBER NUMBERSPHERE_OBJECT::=    SPHERE OPEN_BRACKET_ID  NUMBER NUMBER NUMBER RADIUS COLOUR_REF CLOSE_BRACKETCOLOUR_REF::=   { COLOUR_VAL }COLOUR_VAL::=   COLOUR_ID OPEN_BRACKET_ID NUMBER_ID NUMBER_ID NUMBER_ID CLOSE_BRACKET_ID  RADIUS::=   { NUMBER }  PLANE_OBJ::=    PLANE OPEN_BRACKET NUMBER NUMBER NUMBER NUMBER CLOSE_BRACKET </pre><P><A HREF="#rl2">Back to Article</A></P><HR><I>Copyright &copy; 1999, Dr. Dobb's Journal</I><BR>
</body></html>