<html><head><title>May99: Algorithm Alley</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Code Tuning in Context</h1><h3>By Jon Bentley</h3><I>Jon is a Member of Technical Staff at Bell Labs. He can be contacted at jlb@ research.bell-labs.com.</I><hr><p>Some people spend hours tweaking the very last bit of horsepower out of their automobile engines. Others adjust strings until their violins sing sweetly, practice golf swings, or finely polish web pages. I, too, enjoy tuning: I love to tinker with code to make it run faster.</p><p>When I started programming, code tuning was easy: You found the innermost loop, got rid of the expensive parts, and your program ran faster. Nowadays, though, I'm no longer surprised when I tune code and find that it is not substantially faster, and is sometimes slower.</p><p>What has changed? Lots of things. Computer architectures have more accelerators, and compilers perform more optimizations. This column studies code tuning in several different contexts. I'll start with a family of four related algorithms, apply four tuneups to them, and measure the results on various hardware and compilers.</p><h3>Background</h3><p>Last month's column presented a sequence of four algorithms to solve the Traveling Salesman Problem (TSP), and analyzed the run times of each.</p><p>Algorithm 1 was the simplest code for the job. It enumerated all <i>n!</i> permutations, and stored the shortest. Since it employed <i>n</i> distance calculations to find the cost of each tour, it used a total of <i>n</i>&times;<i>n!</i> distance functions.</p><p>Algorithm 2 was a minor variant of Algorithm 1. It required fixing a starting city by changing one parameter in one call from <i>n</i> to (<i>n</i>-1); this reduced the number of tours examined from <i>n!</i> to (<i>n</i>-1)<i>!</i>, and the total run time to <i>n</i>&times;(<i>n</i>-1)<i>!</i> or <i>n!</i> distance functions.</p><p>Algorithm 3 reduced the number of distance functions by keeping a partial sum of the tour distance. The total number of distance calculations was approximately (1+<i>e</i>)&times;(<i>n</i>-1)<i>!</i>, where <i>e</i>Å2.71828...is the base of natural logarithms.</p><p>Algorithm 4 pruned the search by returning whenever the partial sum exceeded the length of the smallest tour yet observed. Experiments showed that it is much faster than Algorithm 3, but its run time was very dependent on the particular input data.</p><p>These algorithms are fine candidates for tuning: Each is a small loop that is likely to consume many cycles in an application. I'll tune all four in parallel for the sake of experiments; in a real application, you would tune only the fastest algorithm.</p><h3>Tuneup B: Precompute Distances</h3><p>The critical operation in TSP algorithms is often the distance function:</p><blockquote><p>Dist geomdist(int i, int j)</p><p>{ return (Dist) (sqrt(sqr(c[i].x-c[j].x)</p><p>      + sqr(c[i].y-c[j].y)));</p><p>}</p></blockquote><p>A profile showed that Algorithm 1 spent 16.6 percent of its time in <i>geomdist</i>, 64.6 percent in <i>sqrt</i>, and 5.7 percent in this <i>sqr</i> function:</p><blockquote><p>float sqr(float x)</p><p>{  return x*x;</p><p>}</p></blockquote><p>Together, these three functions account for about 87 percent of the time used by the program.</p><p><i>Exercise 1. How can you reduce the time the program spends in the </i>geomdist <i>function?</i></p><p>You could tune the function in several ways: You could write the <i>sqr</i> functions inline, eliminate common subexpressions, or use a special-purpose square root. I will, instead, leave its cost unchanged, but almost eliminate its time by precomputing all <i>n</i><sup>2</sup> possible distances and storing them in an array:</p><blockquote><p>for (i = 0; i &lt; n; i++)</p><p>  for (j = 0; j &lt; n; j++)</p><p>    distarr[i][j] = geomdist(i, j);</p></blockquote><p>This approach trades space for time. The <i>distarr</i> table uses <i>n</i><sup>2</sup> words of storage, but you can now compute the distance from point <i>i</i> to point <i>j</i> with an array access:</p><blockquote><p>#define dist(i, j) distarr[i][j]</p></blockquote><p><i>Exercise 2. How will this tuneup change the run times of the various algorithms?</i></p><p>I'll call the original code for each algorithm (which calls the function) "Tuneup A," and the modified code (which accesses the array) "Tuneup B." Thus Algorithm 1A (implemented in tsp2.c; available electronically, see "Resource Center," page 5) is the original Algorithm 1, Algorithm 1B incorporates the array, and so on for the three other algorithms. <A NAME="rt1"><A HREF="9905lt1.htm">Table 1</A> shows before and after run times on a 200-MHz Pentium Pro. Because the later algorithms are so much faster than the earlier ones, I had to increase the input size <i>n</i> on the various rows to get accurate run times. In every case, though, Tuneup B represents a substantial performance increase. Furthermore, this is not the kind of speedup supported by hardware or system software.</p><p>Lesson: Tuneups beyond the reach of hardware accelerators and optimizing compilers still play a vital role in software performance. </p><p>The rightmost column in <A NAME="rt1"><A HREF="9905lt1.htm">Table 1</A> shows the speedup ratio. Algorithm 1B is about 5.5 times faster than the original Algorithm 1A: That "dumb" algorithm spent most of its time performing the critical distance calculations, and very little time in overhead. Algorithm 2 uses the same code as Algorithm 1, with just a single parameter changed. "Smart" Algorithms 3 and 4 add overhead (for maintaining partial sums and pruning the search) to reduce distance computations, so they are less affected by the dramatic reduction in the cost of distance calculations. </p><p><b>Lesson: </b>Tuneups to critical operations have the most impact on "dumb" algorithms with little overhead.</p><p>This tuneup successfully added space to reduce run time. That technique was a sure bet in the old days, but it can mean a slowdown when running out of modern caches. </p><p><b>Lesson:</b> Measure the effect of tuneups to ensure they indeed reduce the run time.</p><p><i>Exercise 3. Write a program to determine experimentally the run times of the key operations in these algorithms, such as loops, array accesses, and arithmetic operations.</i></p><h3>Tuneup C: Change Arithmetic</h3><p>These algorithms must keep sums of potentially large numbers. I've been bitten in the past by arithmetic precision (or lack thereof), so I instinctively made the type of distances the largest possible:</p><blockquote><p>typedef double Dist;</p></blockquote><p>In the past, changing the <i>double</i> to <i>float</i> or <i>long</i> or <i>short</i> would have easily given a huge speedup.</p><p><i>Exercise 4. Estimate the result of changing to various data types on your machine.</i></p><p>There's a little more to the job than changing one <i>typedef</i>. The first task is to scale distances to use the precision available in our chosen word lengths:</p><blockquote><p>return (Dist) (DistFACT * sqrt(...));</p></blockquote><p><i>Exercise 5. What are appropriate scale values? What other changes need to be made to the program? How would you incorporate them into a program?</i></p><p>Algorithms 1C through 4C incorporate different kinds of arithmetic. <A NAME="rt2"><A HREF="9905lt2.htm">Table 2</A> presents experiments on Algorithm 3C (which has an intermediate amount of overhead) with <i>n</i>=9 on a decade's worth of Intel processors. The first six lines used the same 16-bit executable, while the bottom line used a 32-bit executable. Old hardware was pretty fast on <i>short</i>s and <i>long</i>s, and much slower on <i>float</i>s and <i>double</i>s. In recent years, though, computer architects have used massive transistor counts and wide data paths to make floating-point operations run almost as fast as their integer cousins.</p><p>Can modern programmers ignore ancient hardware? Some indeed can: They know their programs will run only on particular machines. Others certainly cannot: Their programs run today on small processors (in cell phones, joysticks, or even legacy computers), and who knows where they'll be used tomorrow?</p><p><b>Lesson:</b> Old hardware was relatively slow for <i>float</i>s and <i>double</i>s. Modern (large) processors operate on such variables as quickly as on <i>int</i>s and <i>short</i>s.</p><p>For the remainder of this column, I'll focus on modern machines, and reckon Tuneup C as a blind alley. Keep it in mind, though, the next time you work on a small processor.</p><h3>Tuneups to Reduce Overhead</h3><p>The innermost loop of <i>search1</i> currently is:</p><blockquote><p>for (i = m-1; i &gt;= 0; i--) {</p><p>  swap(i, m-1);</p><p>  search1(m-1);</p><p>  swap(i, m-1);</p><p>}</p></blockquote><p>This consists of two calls to the <i>swap</i> function and a recursive call to itself; Algorithms 2 through 4 have similar inner loops.</p><p>In the old days, a sure speedup could be gained by writing the <i>swap</i> function inline, and removing the overhead of function calls. This process results in Tuneup D:</p><blockquote><p>for (i = m-1; i &gt;= 0; i--) {</p><p>  t = p[m-1];</p><p>  p[m-1] = p[i];</p><p>  p[i] = t;</p><p>  search1d(m-1);</p><p>  t = p[i];</p><p>  p[i] = p[m-1];</p><p>  p[m-1] = t;</p><p>}</p></blockquote><p>Tuneup E pares a few additional lines of fat from the innermost loop by moving two assignments out of the loop and removing one redundant assignment:</p><blockquote><p>t = p[m-1];</p><p>for (i = m-1; i &gt;= 0; i--) {</p><p>  p[m-1] = p[i];</p><p>  p[i] = t;</p><p>  search1e(m-1);</p><p>  p[i] = p[m-1];</p><p>}</p><p>p[m-1] = t;</p></blockquote><p>The resulting program spends the lion's share of its run time in this function. <A NAME="rt3"><A HREF="9905lt3.htm">Table 3</A> presents a profile of Algorithm 4E with <i>n</i>=12. </p><p>Code tuners face two nightmare profiles. When the profile is entirely flat, and each function accounts for just 1 or 2 percent of the run time, it is hard to know where to start. This profile is at the other end of the spectrum: All the run time is in one function, and I've already squeezed it all I can.</p><h3>Results of the Tuneups</h3><p>I now have five tuneups across four algorithms and I'm ready to examine their interactions in detail. I'll start with a simple study of compiler optimizations using versions of Algorithm 4 with <i>n</i>=12; see <A NAME="rt4"><A HREF="9905lt4.htm">Table 4</A>.</p><p>With the single exception of Algorithm 4A on the Pentium Pro, optimization is a win.</p><p>Lesson: Compiler-optimized code is sometimes dramatically faster than unoptimized code. Compiler optimization may, however, slow down a program.</p><p>The compiler-optimized versions of Algorithms 4D and 4E were slower than (simpler) Algorithm 4C on the MIPS processor, yet faster on the Pentium Pro.</p><p><b>Lesson:</b> Code tuning may interact badly with compiler optimizations, and increase the resulting run time.</p><p>All of the other experiments in this column have been conducted with optimization enabled.</p><p>Our next experiment runs the complete set of algorithms and tuneups (with the exception of dead-end Tuneup C) on a 200-MHz Pentium Pro; see <A NAME="rt5"><A HREF="9905lt5.htm">Table 5</A>.</p><p>The result of Tuneup B was previously discussed. Tuneup D gave a speedup of 13 to 30 percent (but recall that it caused a slowdown on a MIPS R10000). Tuneup E made little difference on Algorithms 1 and 2 (where run time was still dominated by summing distances), but gave a 12 percent speedup on Algorithms 3 and 4.</p><p><b>Lesson: </b>Fine-tuning inner loops can still yield 10 percent here and 30 percent there, but sometimes slows the code.</p><p>The overall speedup, from Tuneup A to Tuneup E, ranged from a factor of 6.6 to 3.6.</p><p>Our final experiment (see <A NAME="rt6"><A HREF="9905lt6.htm">Table 6</A>) runs all Tuneups on Algorithm 4, across three Intel processors.</p><p><b>Lesson: </b>Tuning code on old processors was predictable and could yield speedups of orders of magnitude.</p><p><b>Lesson: </b>Tuning code on modern processors is less predictable and yields smaller, but still important, speedups.</p><p><i>Exercise 6. Perform additional experiments changing variables such as compiler, operating system, optimization level, and so on.</i></p><h3>Principles</h3><p>Back in the old days, when code was easy to tune, supermarket shopping was pretty easy, too. I would walk through the store, putting items into my basket, keeping a running total as I went. I sometimes snapped up a few items on "two-for-one" sale. When I came to the cashier, I handed over a coupon or two, and if the total price was more than a few percent off my estimate, I would ask to see the receipt.</p><p>Modern marketing techniques have changed all that. I now go the store armed with more coupons. I can swipe my frequent-shopper card across a machine at the front of the store to get just-in-time coupons. I try to take advantage of "buy five of these, get two of those free" sales when I can. When I present my card to the checker, I get extra discounts on items already scanned, custom-printed coupons for future use, and credit towards a free turkey if I rack up enough sales before the next holiday. The process results in lower prices (I suppose), but I no longer understand my shopping trips.</p><p>What marketing techniques have done to food shopping, computer architects and compiler writers have done to code tuning. Pipelines and other instruction-level parallelism offer many instructions for the price of one (except when hazards jeopardize the deal). Multilevel caches usually yield on-chip speed at DRAM prices. Optimizing compilers manipulate your code at no additional charge. These devices automate many of the tasks that used to fall to code tuners, and they usually do a pretty fine job. But some code-tuning tasks remain, and we have to keep a much larger context in mind as we set to work.</p><h3>Solutions to Selected Exercises</h3><p><b>Exercise 3</b>. Brian Kernighan, Chris Van Wyk, and I described "An Elementary C Cost Model" in the February 1991 issue of <i>UNIX Review</i>. When I ran a 50-line C program on the 200-MHz Pentium Pro, it produced this estimate of the run times for various operations:</p><blockquote><p><b>Operation</b>		<b>Nanosecs</b></p><p>Null Loop</p><p>  {} 	36</p><p>Int Operations</p><p>  i1++ 	-5</p><p>  i1=i3++ 	-1</p><p>  i1-i2 + i3  	3</p><p>Control Structures</p><p>  if (i==5)i1++ 	0</p><p>  while (i&lt;0)i1++	3</p><p>Array Operations</p><p>  p[i]=i  	40</p><p>  i2=p[i]  	20</p><p>  swap(0,i)  	160</p><p>Square Root</p><p>  f1=sqrt(f2)  	888</p></blockquote><p>The first line says that a null loop requires about 36 nanoseconds per operation. The second through fourth lines show the costs of arithmetic operations on integers.</p><p><b>Lesson: </b>Adding instructions to a small inner loop can make it run faster.</p><p>The array operations are more substantial, and the square roots are relatively expensive.</p><p><b>Exercise 5. </b>This code sequence assumes that precisely one of the variables SHORT, LONG, FLOAT, and DOUBLE is nonzero, and that variable signifies the type to use: </p><blockquote><p>#ifdef SHORT</p><p>typedef short Dist;</p><p>#define INF 30000</p><p>#define DistFACT 100</p><p>#elif LONG</p><p>typedef long Dist;</p><p>#define INF 1000000000</p><p>#define DistFACT 100000</p><p>#elif FLOAT || DOUBLE</p><p>typedef float Dist;</p><p>#define INF ((Dist) 1e35)</p><p>#define DistFACT 1.0</p><p>#endif</p></blockquote><p>Scaling and rounding may slightly change the output sequence, but the tour distance should be very close to the true distance. </p><p></p><p><b>DDJ</b></p><HR><I>Copyright &copy; 1999, Dr. Dobb's Journal</I><BR>
</body></html>