<html><head><title>Mar99: Java Q&A</title></head><BODY BGCOLOR="#ffffff" TEXT="#000000" LINK="#0000ff" VLINK="#330066" ALINK="#FF0000">
<!--Copyright &#169; Dr. Dobb's Journal--><h1>How Do I Implement Microsoft's <i>delegate </i>in Pure Java?</h1><p><i>Dr. Dobb's Journal</i> March 1999</p><h3>By Andrew Wilson</h3><I>Andy, a developer for NuMega Technologies, can be contacted at andyw@numega.com.</I><hr><p>The Microsoft <i>delegate</i> keyword brings a shudder to many pure Java developers. This keyword locks an application to the Microsoft VM, eliminating the possibility of running the application on a nonWindows platform. However, <i>delegate</i> provides you with a new event-handling scheme that can simplify complex GUI applications. </p><p>Another problem is that <i>delegate</i> works with the Windows Foundation Class (WFC), but does not work with the existing AWT or the new Java Foundation Classes (JFC) event models. Both the AWT and JFC event models could benefit from the <i>delegate</i> scheme. </p><p>Bringing <i>delegate</i>s to pure Java code is currently not possible. However, creating something that behaves similar to a <i>delegate</i> is not too difficult. Consequently, I'll present classes that mimic the <i>delegate</i> keyword, allowing you to build a complex user interface with simpler event-handling code. The complete source code and related files for this <i>delegate</i>-like implementation are available electronically (see "Resource Center," page 5).</p><h3>Event Handling and AWT</h3><p>Each Java AWT and JFC GUI object sends various events. Events often represent user actions, like pressing a key or clicking a mouse button. Events also represent state changes in the application, such as the window closing or the window needing to be repainted. Event objects often represent specific areas of the application. For example, there are <i>WindowEvent</i> objects that represent events relating to the state of the current window. Handling these events is beyond the scope of this column; however, I will examine a few of the more common event-handling schemes.</p><p>The first (and simplest) way to handle events in a GUI application is to override one (or a few) of the core event-handling methods -- <i>processEvent</i>, <i>processComponentEvent</i>, <i>processKeyEvent</i>, <i>processMouseEvent</i>, or <i>processMouseMotionEvent</i>. These methods dispatch events to an object of type <i>java.util.EventListener</i>. However, you can override any of these methods to handle a given event.</p><p>Overriding an event-dispatching method raises a couple of important issues. First, these dispatchers only dispatch events directly related to the GUI object. For example, if a user clicks on a button within a frame, only the button's <i>processEvent</i> method is called. Also, the overridden event-dispatching method must call the base class's event-dispatching method; otherwise, other event handlers may not execute.</p><p>The second way to handle an event is by registering a <i>java.util.EventListener</i> object with a GUI object. Such an object (an event listener) gives you a lot of flexibility. This event-handling scheme allows for three different ways of implementing event-handling code. </p><h3><i>EventListener</i>-based Event Handlers</h3><p>Event-dispatching methods call <i>EventListener</i> object methods. Consequently, <i>EventListener</i> objects should implement some sort of event-handling code for a given event type. Event-handling code can do anything from disabling a button or menu option, to saving the current document and exiting the application. </p><p>The java.awt.event package contains most of the standard <i>Event</i> and <i>EventListener</i> classes. There are several different event classes, and for each <i>Event</i> class there is an <i>EventListener</i> class. Each <i>Event</i> class represents a variety of different pieces of information about the GUI object. For example, a <i>WindowEvent</i> object may indicate if a window is being resized or closed. The corresponding <i>WindowListener</i> class has methods that handle the various <i>WindowEvent</i> states. Therefore, there are methods that specifically handle window resizing and closing events.</p><p>Using <i>EventListener</i> classes is straightforward; you create a new class and implement all the methods of the <i>EventListener</i> interface for the event you want to receive. For example, if an application wants to receive <i>WindowEvent</i> objects, the application must have a class that implements all the methods of the <i>WindowListener</i> interface. The only issue is that many of these <i>EventListener</i> classes have several methods that you must implement. Many of these methods are unnecessary for most applications, so you end up writing a lot of code that never gets used.</p><p>Realizing that implementing unused methods in interfaces is annoying, Sun implemented most of the <i>EventListener</i> classes with event-adapter classes. These adapter classes have the function definitions of the underlying interface stubbed out. You can simply inherit from the adapter class and override the methods for the events you are interested in handling.</p><p>There are three ways to handle events using these <i>EventListener</i> derived classes. The first is that you implement the <i>EventListener</i> in the applet or application GUI class. Obviously, you can implement as many <i>EventListener</i> interfaces as you wish. Doing this is usually helpful because the event handlers have direct access to all class fields. The biggest drawback is that you may have to stub out many unused event-handler functions.</p><p>The second method is to override an event-adapter class, or implement a new <i>EventListener</i> class as a class separate from the main GUI class. This method is more modular and relatively easy to debug. It also has the virtue of not forcing you to implement every event method, if you are using the event-adapter class. The downside is that the new event-handler class may not have access to all the GUI class's member fields.</p><p>The third method is to implement an event adapter as an anonymous or nested class. This method is a more tricky, and sometimes more difficult to debug. However, both anonymous and nested classes have access to the GUI class's member fields.</p><p>The notion of an anonymous class is a little strange. The idea is that I can define a class inline during construction. <A NAME="re1"><A HREF="9903le1.htm">Example 1</A> illustrates this notion. When the compiler executes on the Java source file, the compiler generates a new class file representing the anonymous class. The result is something like "Foo$1.class" for the anonymous class. Consequently, each time you build your application, the anonymous class name may change. Beyond this, there is almost no difference between an anonymous class and a nested class; both can access all the fields and methods of the enclosing class.</p><p>The downside to anonymous classes is that debuggers may have difficulty with breakpoints and debug information. It has also been argued that the construct is more difficult to read and is not portable from one application to the next.</p><p>After creating an event-handling class, you must bind the event handler to a GUI object. The GUI object will then send events corresponding to the event handler via the event-dispatching methods. </p><p>Overriding event dispatchers or implementing <i>EventListener</i> classes brings up a few issues. First, overriding an event-dispatcher method requires you to add some code to check for a particular event. However, this event checking occurs constantly, and consequently introduces a significant amount of overhead. Second, implementing separate <i>EventListener</i> classes causes the event-handling code to be disjointed from the main GUI class's code, thus some symmetry between creation and event handling is lost. Third, implementing <i>EventListener</i> interfaces in the main GUI class often forces you to write a lot of unused code to stub out event-handler definitions. Finally, using anonymous or nested classes, though they work fine, can make the code somewhat less readable, and the classes are no longer portable between applications.</p><p>These gripes are just a few irritations that you can deal with rather easily. However, all of these methods require you to write a lot of boilerplate code that is used in nearly every GUI application. Eliminat-ing the boilerplate code would certainly simplify the development process and remove some of the tedium.</p><p>This leads us to the <i>delegate</i> keyword. </p><h3>The <i>delegate</i> Keyword</h3><p>A <i>delegate</i> can simply be described as a proxy. You register a method with the <i>delegate</i>, and then register the <i>delegate</i> with a WFC GUI object. When the GUI object receives an event, the GUI object forwards the event to the <i>delegate</i>, which forwards the event to the event-handling method you wrote. You may define any method to receive an event, however, the method must have a specific signature. </p><p>A method signature is made up of the order and type of parameters, along with the return type. Event-handler methods in the <i>delegate</i> model use the same basic signature. The event-handler method has no return type <i>(void)</i>, and takes two parameters. The first is of type <i>Object</i> and represents the original sender of the event. The second parameter is the event object itself.</p><p><A NAME="rl1"><A HREF="9903l.htm#l1">Listing One</A> shows a <i>delegate</i> in use. The <i>initForm()</i> method builds the user interface in a WFC application. This method is often automatically generated using Visual J++ 6.0. The interesting line is the call to <i>sortButton.addOnClick(new EventHandler(this.sortClick))</i>. </p><p>The <i>sortButton.addOnClick()</i> method takes a parameter of type <i>EventHandler</i>, a <i>delegate</i> class. All <i>delegate</i>s require a <i>java.lang.reflect.Method</i> object as a parameter. The <i>Method</i> object represents the user-defined event-handling method. For this <i>EventHandler</i> object, the event-handling function is <i>this.sortClick</i>.</p><p>The effect of this line of code is the binding of a method (<i>sortClick</i>) to a <i>delegate</i>, then a <i>delegate</i> to a GUI object (<i>sortButton</i>). Consequently, every time users click on the button, the <i>sortButton</i> object sends an event to the <i>delegate</i>, the <i>delegate</i> forwards the event to the <i>sortClick</i> method.</p><p>This implementation allows the <i>delegate</i> class to be a separate entity from the main GUI class. However, the event-handling code remains in the main GUI class. The advantage is that you only need to implement a method to handle a specific event type. Moreover, you don't have to write any boilerplate code for event handling.</p><p><i>delegate</i>s are actually more complex than I've just described. A <i>delegate</i> is actually a special type of class, but its declaration is completely different from any other class declaration in Java. In fact, a <i>delegate</i>'s declaration looks more like a function. <A NAME="rl2"><A HREF="9903l.htm#l2">Listing Two</A> is a custom <i>delegate</i> necessary to handle some asynchronous sorting. There is no constructor in this declaration. All <i>delegate</i> constructors take one parameter, a <i>Method</i> object. Instead, the <i>delegate</i> declaration defines the signature of the event-handling method. According to this listing, the user-defined event-handler method must have two parameters, the first of type <i>Object</i>, representing the sender of the event, and a second of type <i>WFCSortEvent</i>, representing the event itself.</p><p>Probably the most important thing to note about Microsoft <i>delegate</i>s is the conspicuous lack of code. The compiler automatically generates the remaining code to represent the <i>delegate</i> object; you don't have to do anything more than define the <i>delegate</i>'s signature, and the compiler does the rest. Subsequently, you get a class file that represents the <i>delegate</i> object, all of which is automatically generated. </p><p><A NAME="rl3"><A HREF="9903l.htm#l3">Listing Three</A> shows the WFC class that binds the <i>delegate</i> class to the object. <A NAME="rl4"><A HREF="9903l.htm#l4">Listing Four</A> shows how the class actually sends an event. Finally, <A NAME="rl5"><A HREF="9903l.htm#l5">Listing Five</A> shows the application binding a local event-handing method to the <i>delegate</i>, and subsequently to the object that will send the event.</p><p>This seems like a lot of code to allow for something as simple as a notification message. However, much of this code was automatically generated by the Visual J++ environment, so it took only about a second for the code to appear.</p><p>Building <i>delegate</i>-like functionality in pure Java is straightforward. The reflection package provides us with all the necessary functionality. Consider building a <i>delegate</i> to handle <i>WindowEvent</i> objects. You simply need to implement a <i>WindowListener</i> class. This class must store a set of <i>Method</i> objects. Each <i>Method</i> object represents a user-defined event-handler method. The class needs to override the <i>WindowListener</i> methods, and invoke the appropriate <i>Method</i> object. This results in the same sort of event- forwarding functionality provided by Microsoft <i>delegate</i>s.</p><p>The <i>WindowDelegate</i> and its base class (available electronically) binds event-handling methods to specific event types. Once this binding is done, you just bind the user-defined event-handler to the GUI object. <A NAME="rl6"><A HREF="9903l.htm#l6">Listing Six</A> performs the binding in the main GUI class, and the subsequent event-handler method.</p><p>The resulting <i>WindowDelegate</i> class is a reusable object, allowing you to use this <i>delegate</i>-like class in every application, without having to modify the <i>delegate</i> class itself. However, this pure Java <i>delegate</i> class will work on all AWT and JFC applications.</p><h3>Conclusion</h3><p>The <i>delegate</i> class I present here brings all the benefits of both <i>EventListener</i> and <i>delegate</i> classes. The pure Java <i>delegate</i> class lets you register a method in any class as an event handler for any class that supports the JDK 1.1 event model. The event-handling code remains in the main GUI class, but does not break the <i>EventListener</i> model. Finally, all the boilerplate code is written once for all applications, eliminating the tedium of writing classes or implementing methods that are never used.</p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</A></H4><pre>Button sortButton = new Button();private void initForm(){        sortButton.setDock(ControlDock.BOTTOM);        sortButton.setLocation(new Point(0, 277));        sortButton.setSize(new Point(300, 23));        sortButton.setTabIndex(0);        sortButton.setText("Sort");        sortButton.addOnClick(new EventHandler(this.sortClick));        /*Download complete sample for full code */       }private void sortClick(Object source, Event e){        m_pDlg = new ProgressDialog();        m_pDlg.show();        m_pDlg.progressBar.setMaximum( m_items.length );                m_items = m_app.sortItems( m_items );                showItems();}</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>public delegate void WFCSortEventDelegate ( Object sender, WFCSortEvent e ); </pre><P><A HREF="#rl2">Back to Article</A></P><H4><A NAME="l3">Listing Three</H4><pre>package WFCExtensions;<p></p>import com.ms.wfc.core.*;import com.ms.wfc.ui.*;import com.ms.lang.Delegate;public class WFCApp extends App{    WFCSortEventDelegate m_SortCompletionEvent;    WFCSortEventDelegate m_SortProgressEvent;    public WFCApp ( int items )    {        super ( items );    }    public void addOnSortCompletionEvent(WFCSortEventDelegate value)    {        m_SortCompletionEvent = (WFCSortEventDelegate)Delegate.                                 combine(m_SortCompletionEvent, value);    }    public void addOnSortProgressEvent(WFCSortEventDelegate value)    {        m_SortProgressEvent = (WFCSortEventDelegate)Delegate.                                 combine(m_SortProgressEvent, value);    }    protected void onSortCompletionEvent(WFCSortEvent event)    {        if (m_SortCompletionEvent != null) m_SortCompletionEvent.                                                 invoke(this, event);    }    protected void onSortProgressEvent(WFCSortEvent event)    {        if (m_SortProgressEvent != null) m_SortProgressEvent.                                                 invoke(this, event);    }    public void removeOnSortCompletionEvent(WFCSortEventDelegate value)    {        m_SortCompletionEvent = (WFCSortEventDelegate)Delegate.                                   remove(m_SortCompletionEvent, value);    }    public void removeOnSortProgressEvent(WFCSortEventDelegate value)    {        m_SortProgressEvent = (WFCSortEventDelegate)Delegate.                                    remove(m_SortProgressEvent, value);    }    protected void sortCompleteEvent( )    {        WFCSortEvent e = new WFCSortEvent();        onSortCompletionEvent( e );    }    protected void sortProgressEvent( int position, int total )    {        WFCSortEvent e = new WFCSortEvent ( position, total );        onSortProgressEvent( e );    }    public static class ClassInfo extends com.ms.wfc.core.ClassInfo    {        public static final EventInfo sortCompletionEvent = new EventInfo(            WFCApp.class, "sortCompletionEvent", EventHandler.class);        public static final EventInfo sortProgressEvent = new EventInfo(            WFCApp.class, "sortProgressEvent", EventHandler.class);        public void getEvents(IEvents events)        {            super.getEvents(events);            events.add(sortProgressEvent);            events.add(sortCompletionEvent);        }        public void getProperties(IProperties props)        {            super.getProperties(props);        }    }}</pre><P><A HREF="#rl3">Back to Article</A></P><H4><A NAME="l4">Listing Four</H4><pre>import java.util.*;<p></p>public abstract class App{    protected int[] m_items;    public App(int items)    {        m_items = new int[ items ];        fillItems( m_items );    }    protected void fillItems( int[] items )    {        Random rnd = new Random();        for ( int i = 0; i &lt; items.length; i++ )        {            int tmp;            do             {                tmp = rnd.nextInt();             } while ( tmp &lt; 0 );            m_items[i] = tmp;         }    }    public int[] sortItems( int[] items )    {        int[] sortedList = new int[ items.length ];        System.arraycopy( m_items, 0, sortedList, 0, m_items.length );        for ( int i = 0; i &lt; sortedList.length; i++ )        {            for( int j = i; j &lt; sortedList.length; j++ )            {                if (  sortedList[i] &gt; sortedList[j] )                {                    int tmp = sortedList[j];                    sortedList[j] = sortedList[i];                    sortedList[i] = tmp;                }            }           sortProgressEvent( i, m_items.length );        }        sortCompleteEvent();        return sortedList;    }    public int[] getItems( )    {        return m_items;    }    protected abstract void sortCompleteEvent( );    protected abstract void sortProgressEvent( int position, int total );}</pre><P><A HREF="#rl4">Back to Article</A></P><H4><A NAME="l5">Listing Five</H4><pre>public class Example1 extends Form{    WFCApp m_app;    public Example1()    {        super();        m_app = new WFCApp ( 2500 );        m_items = m_app.getItems();        m_sortedItems = m_app.sortItems( m_items );                // bind custom delegate classes to WFCApp class        m_app.addOnSortCompletionEvent(                    new WFCSortEventDelegate( this.sortCompletionEvent ) );        m_app.addOnSortProgressEvent(                    new WFCSortEventDelegate( this.sortProgressEvent ) );        initForm();     }}</pre><P><A HREF="#rl5">Back to Article</A></P><H4><A NAME="l6">Listing Six</H4><pre>public class Example2 extends Frame{    public void initForm ( )    {    /** Download complete source for full example */            this.addWindowListener(             new WindowDelegate( this,            "windowClosing",            WindowDelegate.CLOSING ) );     }    public void windowClosing ( WindowEvent e )    {        System.exit(1);    }}</pre><P><A HREF="#rl6">Back to Article</A></P><HR><I>Copyright &copy; 1999, Dr. Dobb's Journal</I><BR>
</body></html>