<html><head><title>Mar99: Algorithm Alley</title></head><BODY BGCOLOR="#ffffff" TEXT="#000000" LINK="#0000ff" VLINK="#330066" ALINK="#FF0000">
<!--Copyright &#169; Dr. Dobb's Journal--><h1>Implementing Fast DCTs</h1><p><i>Dr. Dobb's Journal</i> March 1999</p><h3>By Tim Kientzle</h3><I>Tim is senior technical editor for DDJ. He can be reached at kientzle@ddj.com.</I><hr><p>The Discrete Cosine Transform (DCT) is a crucial part of modern image and sound compression. It is used in JPEG, MPEG video, MPEG audio, and Digital VCR, to name just a few. Mathematically, the DCT provides a way to break a complex signal down into separate components, and does so in a way that's nearly optimal for compression.</p><p>However, the computational overhead of the DCT is an obstacle to efficient implementation of these compression algorithms. In a typical DCT-based encoder/ decoder, DCT calculations alone can easily take up 50 percent of the CPU time for the entire program.</p><p>In this article, I'll discuss several fast algorithms for computing the 8-point DCT and IDCT. Since these algorithms are typically expressed using a diagram notation, I'll present both the diagrams and a somewhat mechanical technique for translating these diagrams into efficient C code. Using this technique, building efficient DCT and IDCT implementations is straightforward.</p><h3>Why DCT?</h3><p>Lossy compression -- whether for video, audio, or still graphics -- rests on a simple idea: You want to identify imperceptible features and remove them without changing features that are noticeable. To do this, you need a good understanding of human perception and a mathematical tool that can separate features.</p><p>From a purely mathematical standpoint, the Karhunen-Loeve Transform (KLT) is an ideal tool for separating a data stream into separate features. The KLT works by first analyzing the data to identify certain statistical properties, then using those properties to construct an optimal decomposition. Unfortunately, this analysis is extremely time consuming -- you have to analyze the data, construct a transform tailored to that data, then compute the final transform.</p><p>The DCT closely matches the KLT for common types of data, and is simpler to compute. The DCT converts a single block of data into a collection of DCT coefficients. Intuitively, you can think of these coefficients as representing different frequency components. The first coefficient (the DC coefficient) is simply the average of the entire block. Later coefficients (the AC coefficients) represent successively higher frequencies. (For graphics compression, "higher frequency" roughly corresponds to "finer detail.")</p><h3>Typical DCT Use</h3><p>A typical compression algorithm starts by breaking the data into small blocks. A DCT is applied to each block. Each coefficient is then multiplied by a fixed weight; higher-frequency coefficients typically use smaller weights. The result is that the higher-frequency values become small, zeros will usually predominate. Finally, standard compression techniques such as Huffman, arithmetic coding, or simple run-length coding are used to pack the coefficients into a small number of bits. Often, this process is iterative; if the final encoded data is too large, the weighting is adjusted and the coefficients are compressed again. Usually, the compressed output indicates the weighting used.</p><p>Decompression works in reverse. First, the bits are decoded to yield a series of weighted coefficients. Then, each coefficient is divided by the corresponding weight and an Inverse DCT is used to recover the final values.</p><p>The DCT and Inverse DCT are not lossy except for minor errors in calculation. The lossy part of this process is the weighting and inverse weighting that effectively rounds less-important coefficients to one of a few numbers. Of course, designing a good weighting requires a detailed knowledge of human perception.</p><h3>1D and 2D DCTs</h3><p>DCT-based graphics compression usually employs an 8&times;8 DCT. For this reason, there has been extensive study of this particular DCT. <A NAME="rf1"><A HREF="9903mf1.htm">Figure 1</A> shows the equations for the DCT. <A HREF="9903mf1.htm">Figure 1</A>(a) is the one-dimensional (1D), 8-element DCT, while <A HREF="9903mf1.htm">Figure 1</A>(b) is the corresponding equation for the two-dimensional 8&times;8 Forward DCT. </p><p><A HREF="9903mf1.htm">Figure 1</A>(c) is the same as <A HREF="9903mf1.htm">Figure 1</A>(b), but factored to illustrate an important property. The square brackets in <A HREF="9903mf1.htm">Figure 1</A>(c) enclose a 1D, 8-element DCT computed over each row of the input samples. Once this is computed, the outer sum is another 1D, 8-element DCT. In simpler language, you can compute a 2D DCT by first computing a 1D DCT over each row, then computing a 1D DCT over each column. This separation is the first crucial step to developing a fast DCT algorithm. Even in the most naive implementation, a separated 2D DCT can easily be 10 times faster than the nonseparated version.</p><p><A NAME="rf2"><A HREF="9903mf2.htm">Figure 2</A> shows the corresponding equations for the IDCT. The IDCT can be separated in the same fashion as the Forward DCT.</p><h3>DCT Flow Diagrams</h3><p>The starting point, then, for a fast 2D DCT is a fast 1D DCT. <A NAME="rf3"><A HREF="9903mf3.htm">Figure 3</A> is the flow diagram for a typical fast algorithm.</p><p>The diagram notation used in <A HREF="9903mf3.htm">Figure 3</A> is fairly standard; some slight variation of this notation is used in almost every paper discussing the DCT. <A NAME="rf4"><A HREF="9903mf4.htm">Figure 4</A> shows the basic building blocks of this notation.</p><p><A HREF="9903mf3.htm">Figure 3</A> is typical in several respects. After the first stage, the algorithm splits into even and odd halves; the even half (in the purple area) is just a four-point DCT. Similarly, this four-point DCT splits into two halves, one of which is a two-point DCT in the red area. All of the additions in <A HREF="9903mf3.htm">Figure 3</A> appear in symmetric add/subtract pairs. In fact, the entire first stage is simply four such pairs in a very typical cross-over pattern; note that the four-point DCT diagram starts with a similar pattern.</p><h3>Translating Flow Diagrams into Code</h3><p>If you step through the diagram, it's remarkably routine to convert these diagrams into efficient code. I'll demonstrate by converting the four-point DCT diagram in <A NAME="rf5"><A HREF="9903mf5.htm">Figure 5</A> into C code. The inputs in <A HREF="9903mf5.htm">Figure 5</A>(a) are labeled <i>x</i>0 through <i>x</i>3. I'll also need one additional variable which I call <i>x</i>4. The red lines in <A HREF="9903mf5.htm">Figure 5</A>(b) indicate a sum; <i>x</i>4 is currently unused, so I put the sum into <i>x</i>4. I now have to compute the difference in <A HREF="9903mf5.htm">Figure 5</A>(c); I place that result in <i>x</i>0, and <i>x</i>3 is now available to be used in <A HREF="9903mf5.htm">Figure 5</A>(d). The remaining add/subtract pairs are calculated following the same pattern. (An animated GIF version of <A HREF="9903mf5.htm">Figure 5</A> is available electronically; see "Resource Center," page 5).</p><p>The rotation is a bit trickier. First, as in <A NAME="rf6"><A HREF="9903mf6.htm">Figure 6</A>, you can use a temporary variable to reduce the calculation to only three multiplications. (<i>k</i> is a constant here.) Once you've calculated the temporary variable, D only requires A, and C only requires B. In this code, by the time you get to calculate the rotation, <i>x</i>3 is available and can be used for the temporary variable. By letting <i>x</i>0 be C and B, and using <i>x</i>1 for A and D, you end up with the efficient code in the last part of <A HREF="9903mf6.htm">Figure 6</A>.</p><p>I've used 10-bit fixed point for the constants in the rotation. This means that at the end of the algorithm, I have to shift the outputs of the rotation to the right by 10 bits. Before I do this, I add 512, which is 1/2 in 10-bit fixed-point arithmetic. This properly rounds the result, and significantly improves the accuracy. (The 512 is actually added to <i>x</i>3 earlier so that both <i>x</i>0 and <i>x</i>1 will be correctly biased.) The only remaining step is to assign the final values to the correct output locations.</p><p>Implementing the full algorithm in <A HREF="9903mf3.htm">Figure 3</A> is similar. The only tricky part is that the outputs of the bottom two rotations must later be multiplied by another constant. This requires care to prevent overflow; if you use 10-bit fixed-point values for both multiplications and 32-bit arithmetic, then the inputs to these rotations can't exceed 12 bits. Fortunately, to get 11-bit accuracy, the square root of 2 is 2896/2048, which is exactly equal to 181/128. Thus, you can get 11-bit accuracy with 7-bit fixed point, reducing overflow problems. <A NAME="rl1"><A HREF="9903m.htm#l1">Listing One</A> is the resulting code, while <A HREF="9903m.htm#l2">Listing Two</A> extends this to the full 2D 8&times;8 DCT.</p><p>The inverse DCT can be directly implemented from the same diagram. You follow the same rules, only working from left to right instead of right to left.</p><h3>Performance</h3><p><A HREF="9903m.htm#l1">Listings One</A> and Two are fast DCT implementations. To illustrate, I implemented the basic formulas given at the beginning of this article, and timed them. <A NAME="rt1"><A HREF="9903mt1.htm">Table 1</A> shows the results on a 266-MHz Pentium-II. The source code for this article (available electronically) includes test programs that exercise these DCT implementations and provide timing information.</p><p>The literature on DCTs usually categorizes implementations according to the number of multiplications. The theoretical minimum for a complete 1D, 8-element DCT is 11 multiplications. (<A HREF="9903mf3.htm">Figure 3</A> achieves this minimum.) When using fixed-point arithmetic on newer processors, however, the number of multiplications is not the only concern. </p><h3>Further Optimizations</h3><p>In typical applications, the forward DCT is followed by a weighting stage that multiplies every DCT output by a constant value. In many DCT algorithms, there are several multiplications that occur at the end. These factors can be combined with the weighting, effectively eliminating several multiplications. The algorithm in <A HREF="9903mf3.htm">Figure 3</A> can be reduced to eight internal multiplications: the rotation <i><img SRC="sqrt12.gif" width="7" height="10">2 R6</i> can be written as in <A NAME="re2"><A HREF="9903me2.htm">Example 2</A>, and of course the two multiplications by <i><img SRC="sqrt12.gif" width="7" height="10">2 </i>are already at the end.</p><p><A NAME="rf7"><A HREF="9903mf7.htm">Figure 7</A> shows another DCT algorithm that pushes this idea to the extreme. This algorithm, due to Arai, Agui, and Nakajima, uses only five multiplications within the algorithm, and eight postmultiplications. Better yet, those postmultiplications are all by powers of two. This gives a total of 80 internal multiplications for a full 8&times;8 DCT.</p><p>Finally, since DCT implementations are fairly compact and speed critical, hand-coded assembly is often a good idea. In particular, newer processor extensions, including Intel's MMX, directly support simple parallelism, allowing you to compute multiple 1D DCTs at a time. This works extremely well for separable 2D DCT algorithms, such as the ones I've discussed in this article.</p><h3>Accuracy</h3><p>Although optimizing a program for speed often requires sacrificing accuracy, fast DCT algorithms can actually be more accurate than slower algorithms. Remember that each multiplication involves some loss of accuracy due to roundoff. Algorithms with fewer multiplications are therefore not only faster, but also more accurate. The only place that practical DCT implementations sacrifice accuracy is by using fixed-point rather than floating-point arithmetic. With careful attention to rounding, however, even fixed-point implementations can be extremely accurate.</p><p>The listings that are available electronically use several different measurements to assess the accuracy of a DCT implementation. The basic approach is to generate random test data, compute the DCT in two different ways, and compare the results. The reference version is a direct implementation of the formulas using double-precision floating point. Among the measurements that are of interest are:</p><ul><li>How many outputs are in error, and by how much?  <li>Is the output correct for certain special inputs?</ul><p></p><p>For a fixed-point implementation using 32-bit arithmetic with 8-bit inputs, no output should be in error by more than one, and a typical block should have no more than one error for each eight elements. If all the inputs are the same, the AC coefficients should all be precisely zero.</p><p>Another way to measure the error is to compute the "mean square error" -- simply take the difference between your test output and your reference output, square the results, and compute the average for each block of data and for several thousand random tests. If you have no errors larger than one, the mean square error is simply the percentage of incorrect outputs. The test programs (available electronically) measure and display several of these error measurements.</p><h3>Weaknesses</h3><p>DCT-based image compression is based on two principles. The first is that the DCT -- because it approximates the Karhunen-Loeve Transform -- is a nearly optimal mathematical decomposition. The other is that the human eye is less sensitive to errors in fine details. Since those fine details are represented by high-frequency components, you can safely discard some or all of that information.</p><p>The problem is that the eye is quite sensitive to edges, which are also represented by high-frequency components. DCT-based image compression does not do well on images that have a lot of hard edges, such as line art or text. Also, because each block of data is compressed independently, DCT-based compression is subject to "edge artifacts," in which the reconstructed blocks no longer match at the edges.</p><h3>References</h3><p>Rao, K.R. and P. Yip. <i>Discrete Cosine Transform</i>, Academic Press, 1990.</p><p>"Practical Fast One-Dimensional DCT Algorithms with 11 Multiplications" by Loeffler, Ligtenberg, and Moschytz. ICASSP-89, IEEE, 1989.</p><p>Pennebaker and Mitchell. <i>JPEG: Still Image Data Compression Standard</i>, Van Nostrand Reinhold, 1993.</p><p>Sherlock and Monro. "Algorithm 749: Fast Discrete Cosine Transform," <i>ACM Transactions on Mathematical Software</i>, December 1995.</p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</A></H4><pre>static voiddct1dTest(int *dctBlock) {  static const int c1=1004 /*cos(pi/16)&lt;&lt;10*/, s1=200 /*sin(pi/16)&lt;&lt;10*/;  static const int c3=851 /*cos(3pi/16)&lt;&lt;10*/, s3=569 /*sin(3pi/16)&lt;&lt;10*/;  static const int r2c6=554 /*sqrt(2)*cos(6pi/16)&lt;&lt;10*/, r2s6=1337;  static const int r2=181; /* sqrt(2)&lt;&lt;7 */  int x0=dctBlock[0], x1=dctBlock[1], x2=dctBlock[2], x3=dctBlock[3],    x4=dctBlock[4], x5=dctBlock[5], x6=dctBlock[6], x7=dctBlock[7];  int x8;<p></p>  /* Stage 1 */  x8=x7+x0; x0-=x7;  x7=x1+x6; x1-=x6;  x6=x2+x5; x2-=x5;  x5=x3+x4; x3-=x4;<p></p>  /* Stage 2 */  x4=x8+x5; x8-=x5;  x5=x7+x6; x7-=x6;  x6=c1*(x1+x2); x2=(-s1-c1)*x2+x6; x1=(s1-c1)*x1+x6;  x6=c3*(x0+x3); x3=(-s3-c3)*x3+x6; x0=(s3-c3)*x0+x6;<p></p>  /* Stage 3 */  x6=x4+x5; x4-=x5;  x5=r2c6*(x7+x8); x7=(-r2s6-r2c6)*x7+x5; x8=(r2s6-r2c6)*x8+x5;  x5=x0+x2;x0-=x2; x2=x3+x1; x3-=x1;<p></p>  /* Stage 4, round, and output */  dctBlock[0]=x6;  dctBlock[4]=x4;  dctBlock[2]=(x8+512)&gt;&gt;10; dctBlock[6] = (x7+512)&gt;&gt;10;  dctBlock[7]=(x2-x5+512)&gt;&gt;10; dctBlock[1]=(x2+x5+512)&gt;&gt;10;  dctBlock[3]=(x3*r2+65536)&gt;&gt;17; dctBlock[5]=(x0*r2+65536)&gt;&gt;17;}<p></p></pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>static voiddct2dTest(int (*dctBlock)[8]) {  static const int c1=1004 /*cos(pi/16)&lt;&lt;10*/, s1=200 /*sin(pi/16)&lt;&lt;10*/;  static const int c3=851 /*cos(3pi/16)&lt;&lt;10*/, s3=569 /*sin(3pi/16)&lt;&lt;10*/;  static const int r2c6=554 /*sqrt(2)*cos(6pi/16)&lt;&lt;10*/, r2s6=1337;  static const int r2=181; /* sqrt(2)&lt;&lt;7 */  int row,col;<p></p>  for(row=0;row&lt;8;row++) {    int x0=dctBlock[row][0], x1=dctBlock[row][1], x2=dctBlock[row][2],      x3=dctBlock[row][3], x4=dctBlock[row][4], x5=dctBlock[row][5],      x6=dctBlock[row][6], x7=dctBlock[row][7], x8;    /* Stage 1 */    x8=x7+x0; x0-=x7; x7=x1+x6; x1-=x6; x6=x2+x5; x2-=x5; x5=x3+x4; x3-=x4;<p></p>    /* Stage 2 */    x4=x8+x5; x8-=x5; x5=x7+x6; x7-=x6;    x6=c1*(x1+x2); x2=(-s1-c1)*x2+x6; x1=(s1-c1)*x1+x6;    x6=c3*(x0+x3); x3=(-s3-c3)*x3+x6; x0=(s3-c3)*x0+x6;<p></p><p></p>    /* Stage 3 */    x6=x4+x5; x4-=x5; x5=x0+x2;x0-=x2; x2=x3+x1; x3-=x1;    x1=r2c6*(x7+x8); x7=(-r2s6-r2c6)*x7+x1; x8=(r2s6-r2c6)*x8+x1;<p></p>    /* Stage 4 and output */    dctBlock[row][0]=x6;  dctBlock[row][4]=x4;    dctBlock[row][2]=x8&gt;&gt;10; dctBlock[row][6] = x7&gt;&gt;10;    dctBlock[row][7]=(x2-x5)&gt;&gt;10; dctBlock[row][1]=(x2+x5)&gt;&gt;10;    dctBlock[row][3]=(x3*r2)&gt;&gt;17; dctBlock[row][5]=(x0*r2)&gt;&gt;17;  }  for(col=0;col&lt;8;col++) {    int x0=dctBlock[0][col], x1=dctBlock[1][col], x2=dctBlock[2][col],      x3=dctBlock[3][col], x4=dctBlock[4][col], x5=dctBlock[5][col],      x6=dctBlock[6][col], x7=dctBlock[7][col], x8;<p></p>    /* Stage 1 */    x8=x7+x0; x0-=x7; x7=x1+x6; x1-=x6; x6=x2+x5; x2-=x5; x5=x3+x4; x3-=x4;<p></p>    /* Stage 2 */    x4=x8+x5; x8-=x5; x5=x7+x6; x7-=x6;    x6=c1*(x1+x2); x2=(-s1-c1)*x2+x6; x1=(s1-c1)*x1+x6;    x6=c3*(x0+x3); x3=(-s3-c3)*x3+x6; x0=(s3-c3)*x0+x6;<p></p>    /* Stage 3 */    x6=x4+x5; x4-=x5; x5=x0+x2;x0-=x2; x2=x3+x1; x3-=x1;    x1=r2c6*(x7+x8); x7=(-r2s6-r2c6)*x7+x1; x8=(r2s6-r2c6)*x8+x1;<p></p>    /* Stage 4 and output */    dctBlock[0][col]=(x6+16)&gt;&gt;5;  dctBlock[4][col]=(x4+16)&gt;&gt;5;    dctBlock[2][col]=(x8+16384)&gt;&gt;15; dctBlock[6][col] = (x7+16384)&gt;&gt;15;    dctBlock[7][col]=(x2-x5+16384)&gt;&gt;15; dctBlock[1][col]=(x2+x5+16384)&gt;&gt;15;    dctBlock[3][col]=((x3&gt;&gt;8)*r2+8192)&gt;&gt;14;    dctBlock[5][col]=((x0&gt;&gt;8)*r2+8192)&gt;&gt;14;  }}</pre><P><A HREF="#rl2">Back to Article</A></P><HR><I>Copyright &copy; 1999, Dr. Dobb's Journal</I><BR>
</body></html>