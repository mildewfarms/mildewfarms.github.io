<html><head><title>Mar99: Hierarchical Logic Simulation</title></head><BODY BGCOLOR="#ffffff" TEXT="#000000" LINK="#0000ff" VLINK="#330066" ALINK="#FF0000">
<!--Copyright &#169; Dr. Dobb's Journal--><h1>Hierarchical Logic Simulation</h1><p><i>Dr. Dobb's Journal</i> March 1999</p><h2>A simulator engine in C++</h2><h3>By Donald C. Craig</h3><I>Donald is a software developer currently employed at Stratos Network Research. He can be contacted at donald@cs.mun.ca.</I><hr><p>Simulators provide an economical means of understanding and evaluating the performance of both abstract and real-world systems. Unfortunately, the design and implementation of simulators is almost as complex as the systems being simulated. To be efficient, therefore, simulators must be able to adapt to ever-increasing system complexity. Luckily, the object-oriented paradigm lends itself to implementing simulators that are extensible, while preserving their relative efficiency. </p><p>In this article, I'll present an approach by which hardware components can be represented and simulated hierarchically using C++. Unlike traditional event simulators, the simulation strategy I describe here does not use the concept of a global event queue or global clock to synchronize the events that are propagated through components within the simulation. Instead, this simulation strategy is completely asynchronous, meaning that the concept of global time has been abandoned in favor of each component maintaining its own concept of local time (see "Asynchronous Distributed Simulation via a Sequence of Parallel Computations," by K.M Chandy and J. Misra, <i>Communications of the ACM</i>, April 1981). By eliminating the reliance of components upon a global event queue for synchronization, the autonomy of each component is increased, making it easier to distribute the simulation over several hierarchical components.</p><p>This approach is central to a simulation tool I've built called "DigiTcl." This tool consists of a GUI that lets users construct and simulate digital circuits. The GUI was implemented using Tcl/Tk8.0 and serves as the front end for the simulator engine, which was written in C++. Here, I focus on the simulator engine, specifically how C++ components interact with one another. DigiTcl (available electronically from <i>DDJ, </i>see "Resource Center," page 5,<b> </b>and at http:// www.cs.mun.ca/~donald/digitcl/) is available as a gzipped tar file and as a zip archive. The release content in both archives is the same. The simulator engine will have to be compiled for your platform; refer to the README file for more details. </p><p>C++ supports features that make it favorable for the description of hardware at the logic level (see "Object-Oriented Programming for CAD," by Wayne H. Wolf, <i>IEEE Design &amp; Test</i>, March 1991). It has, for instance, comprehensive support for encapsulation and inheritance, both of which I use extensively when describing hardware. I also use the language's support for polymorphism when implementing the simulation algorithm. In addition, the code employs a modest use of Standard Template Library (STL), but does not use exception handling (to ensure portability with existing C++ compilers). </p><p>One of the goals of object-oriented design is to create classes that correspond either to entities in the real world or to abstractions that have a well-defined state and behavior (see <i>Object-Oriented Analysis and Design with Applications</i>, Second Edition, by Grady Booch (Benjamin/Cummings Publishing, 1994). This is the approach I adopted when developing the class library used to describe and simulate logic hardware. </p><h3>The <i>Component</i> Class</h3><p>The primary functional entity in most circuits is the component. At the lowest level of abstraction, a component is the entity that performs the logic transformations that, in turn, give the circuit its behavior. At higher levels of abstraction, a component can be composed of other subcomponents in a hierarchical manner; during simulation, higher level components simply delegate simulation responsibility to subcomponents. <A NAME="rl1"><A HREF="9903b.htm#l1">Listing One</A> presents the <i>Component</i> class.</p><p>The <i>Component</i> class defines a public input port list (<i>I_List</i>) and public output port list (<i>O_List</i>). These data members are made public because they represent the interface through which the component communicates with the external world. The class contains data members for the transport delay, the name of the component (which can be used for debugging purposes), and the component's local time (used during the simulation). The <i>ckt_time</i> type is simply <i>typedef</i>ed to be of type <i>long</i>.</p><p>The constructor takes a <i>ckt_time</i> value representing the delay of the element and a string representing the component's name. Both values are stored in the corresponding data members by the constructor. For components composed of subcomponents, the delay of the encompassing component is determined by the cumulative delays of its subcomponents. In this case, the delay parameter is irrelevant. The constructor for the <i>Component</i> class is made protected so as to enforce the abstract nature of the class. To actually create a component, you must derive a component from the <i>Component</i> class. </p><p>Components need a means by which they can communicate with other components in the circuit. This leads to the creation of another high-level class -- the <i>Connector</i>.</p><h3>The <i>Connector</i> Class</h3><p>The basic function of the <i>Connector</i> class is to act as the conduit through which signals are retrieved and propagated from one component to another. As such, the <i>Connector</i> class has methods that can receive and transmit signals, see <A NAME="rl2"><A HREF="9903b.htm#l2">Listing Two</A>. Because the <i>Connector </i>class is abstract, both the <i>get_signal()</i> and <i>send_signal()</i> methods are defined as pure virtual methods, thereby preventing the instantiation of a <i>Connector</i> class. The <i>Signal</i> class itself is simply an aggregate consisting of a signal value and the time that the signal value occurred.</p><p>As with the <i>Component</i> class, the <i>Connector</i> class declares a protected constructor, which simply takes the name of the connector and stores it in the <i>name</i> data member. The <i>Connector</i> class also contains a list of components to which it is connected. This represents the fan-out of the connector. Components are added to this data member via the <i>connect()</i> method. </p><p>During hierarchical simulation, a component must have a mechanism through which it can communicate with components in the same level of the hierarchy and with components in lower levels (that is, its subcomponents). These two goals are accomplished by the <i>Wire</i> and <i>Port</i> classes, respectively, both of which are derived from the <i>Connector</i> class.</p><h3>The <i>Wire</i> Class</h3><p>The <i>Wire</i> class (<A NAME="rl3"><A HREF="9903b.htm#l3">Listing Three</A>) provides two constructors. The first (default) constructor is used to create a wire with an initial undefined input, while the second initializes a wire with the supplied array of signal values and times. This constructor initializes the primary inputs for the circuit being simulated.</p><p>In addition to connecting components at the same hierarchical level, wires also act as signal archivers. During simulation, all signals that are sent through a wire are archived so that all components that require input from the wire can retrieve signals from it at any time.</p><p>The <i>Wire</i> class provides the <i>add_signal()</i> method to add a signal to a wire. This method simply appends the supplied signal to the wire after ensuring that the signal is not out of time order with the last signal already on the list.</p><p>The <i>Wire</i> class overrides both the <i>get_signal()</i> and <i>send_signal()</i> methods defined as pure virtual functions in the base <i>Connector</i> class. </p><h3>The <i>Port</i> Class</h3><p>The <i>Port</i> class (<A NAME="rl4"><A HREF="9903b.htm#l4">Listing Four</A>) lets components communicate with their nested subcomponents. The <i>Port</i> class was first used in the declaration of the <i>Component</i> class. As with the <i>Wire</i> class, the <i>Port</i> class also overrides both the <i>get_signal()</i> and <i>send_signal()</i> methods of its base <i>Connector</i> class. </p><p>Like its base class, <i>Connector</i>, the constructor for <i>Port</i> is protected, thereby allowing only classes derived from it to be instantiated. <i>Port</i> maintains a pointer to the external connector to which it is connected. This data member is assigned the <i>Connector</i> reference parameter passed to the <i>Port</i> constructor. Because the <i>external</i> data member is a pointer to a <i>Connector</i>, it can legitimately point to either a <i>Wire</i> object or another <i>Port</i> object.</p><p>Finally, two classes are derived from the <i>Port</i> class -- an <i>Input</i> and <i>Output</i> class; see <A NAME="rl5"><A HREF="9903b.htm#l5">Listing Five</A>. Both classes define public constructors, therefore allowing objects of type <i>Input</i> and <i>Output</i> to be instantiated. Both <i>Input</i> and <i>Output</i> constructors take, as parameters, a reference to the <i>Component</i> in which the port is contained, the external connector for the port, and an optional string representing the port name. The constructors for both the <i>Input</i> and <i>Output</i> port simply pass the <i>Connector</i> reference and the name string to their base <i>Port</i> class constructors for storage. Also, as part of their construction, both <i>Input</i> and <i>Output</i> classes add pointers to themselves to the input/output port lists of the <i>Component</i> that is supplied to the constructor. The <i>Input</i> port constructor also adds the supplied component to the fan-out list of the external connector. This is done so that the external connector can find the component to which it is connected during the simulation.</p><p>Because input ports can only request signals (not send them), <i>Input</i> overrides the <i>send_signal()</i> method to generate a diagnostic error should this method be inadvertently called for an input port.</p><h3>A 3-Input AND Gate Example</h3><p>To demonstrate how these classes can be used to hierarchically describe hardware, I'll build a 3-input AND gate by using two 2-input AND gates and an internal wire.</p><p>First, you define a 2-input AND gate; see <A NAME="rl6"><A HREF="9903b.htm#l6">Listing Six</A>. The <i>And2</i> class is derived from the <i>Component</i> class. The constructor takes three <i>Connector</i> references -- two inputs and one output. These connectors represent the external linkages of the component to the outside world. The constructor also optionally permits the specification of a transport delay and a name for the component. The <i>And2</i> class also overrides the <i>process()</i> method so as to implement the gate's logic.</p><p><A NAME="rl7"><A HREF="9903b.htm#l7">Listing Seven</A> is the actual constructor. The delay and the component name are passed to the base <i>Component</i> class for initialization and the <i>Port</i> constructors are called to build up the component's input and output port list and link up the component's ports with the supplied connectors.</p><p>Finally, you construct the 3-input AND gate using two 2-input AND gates and a wire. <A NAME="rl8"><A HREF="9903b.htm#l8">Listing Eight</A> is the class for the 3-input AND gate. The constructor takes four connector references -- three inputs, one output, and an optional name. Privately, the class encapsulates the three input ports -- one output port, the wire, and the two 2-input AND gates.</p><p><A NAME="rl9"><A HREF="9903b.htm#l9">Listing Nine</A> shows the constructor for the 3-input AND gate. As with the 2-input AND gate, the constructor does all of its initialization in the member initialization list. The three input ports and the output port are connected to the external connectors, the wire is constructed, and the two 2-input AND gates are built and connected to the ports and wire of the 3-input AND gate. Because the transport delay of the 3-input AND component is determined by the transport delay of its two 2-input AND subcomponents, an unused transport delay value is passed to the base <i>Component</i> constructor.</p><p>Once all the connections have been made, the hierarchical component in <A NAME="rf1"><A HREF="9903bf1.htm">Figure 1</A> is constructed. </p><h3>Hardware Simulation</h3><p>The simulation of a circuit, represented using the strategy just described, is similar to a depth-first traversal of the 3D hierarchy of components along the wires and ports. Components may be visited multiple times during the traversal over the course of the simulation. The basic strategy behind the simulation is for a component to propagate any output it produces immediately to all the components to which it is connected. Signals are propagated horizontally and vertically through the hierarchy.</p><p>The primary method responsible for simulating a component is the <i>simulate()</i> method (<A NAME="rl10"><A HREF="9903b.htm#l10">Listing Ten</A>), which is inherited by all components and should not be overridden. This method processes the component's inputs and updates its local time as long as its inputs are available. When all the inputs have been processed, the <i>simulate()</i> method terminates.</p><p>The <i>inputs_are_ready()</i> method scans the component's list of input ports and calls the <i>get_signal()</i> method to determine if all the input signals are available at the local time of the component. If so, it will return True; otherwise, False is returned.</p><p>Components composed of subcomponents process their inputs differently than components that are leaf nodes in the hierarchy. The former components essentially delegate simulation responsibilities to its subcomponents, while the latter ones actually perform the low-level functional logic of the circuit. <A NAME="rl11"><A HREF="9903b.htm#l11">Listing Eleven</A> is the <i>process()</i> method for high-level components. All nonleaf components should inherit this method, which propagates input signals to the nested subcomponents.</p><p>Because <i>And2</i> is a low-level leaf component, it overrides the <i>process()</i> method; see <A NAME="rl12"><A HREF="9903b.htm#l12">Listing Twelve</A>. The method uses the <i>get_signal()</i> method of the <i>Port</i> class to obtain the inputs which occurred on the two input wires at the specified time and performs the AND option on them. A resultant output signal is created and the <i>send_signal()</i> method of the output port is used to send it to the appropriate wire and propagate it to the components in the output's fan-out.</p><p><A NAME="rl13"><A HREF="9903b.htm#l13">Listing Thirteen</A> presents the <i>Connector</i>'s <i>propagate()</i> method, used by the <i>simulate() </i>method of the <i>Component</i> base class. This method simply iterates over all the components in the <i>Connector</i>'s fan-out and tells them to simulate. This is the mechanism by which signal propagation occurs during the simulation.</p><p>Next, the <i>get_signal()</i> and <i>send_signal()</i> methods of the <i>Wire</i> class are defined. The <i>get_signal()</i> method (<A HREF="9903b.htm#l4">Listing Four</A>teen) scans the linked list of signals searching for the signal that occurred at the time passed to this method. This method assumes that if signal value <i>X</i> occurred at time <i>t</i>1 and signal value <i>Y</i> occurred at time <i>t</i>2 (where <i>t</i>2&gt;<i>t</i>1), then the value of the signal at time <i>t </i>(where  <i>t</i>1&lt;=<i>t</i>&lt;<i>t</i>2) is <i>X</i>. If the signal is not found, an undefined signal -- with an undefined value and undefined time -- is returned.</p><p>The <i>send_signal()</i> method (<A NAME="rl15"><A HREF="9903b.htm#l15">Listing Fifteen</A>) adds the supplied signal to the wire's archive of signals and attempts to propagate the signal to the wire's fan-out list of components (which the <i>Wire</i> class inherited from the <i>Connector</i> class). The <i>add_signal()</i> method itself does some sanity checking of the current state of the signal list before actually pushing the signal value onto the back of the list.</p><p>The <i>Port</i>'s <i>get_signal()</i> and <i>send_signal()</i> methods are relatively simple; see <A HREF="9903b.htm#l16">Listing Sixteen</A>. The <i>get_signal()</i> method obtains the signal that occurred at the specified time by querying the external connector. This method recurses from port to port up the hierarchy until the <i>get_signal()</i> message is eventually sent to a wire external connector, after which the recursion unfolds.</p><p>The <i>Port</i>'s <i>send_signal()</i> method sends the supplied signal to the outside world using the external connector. This method recurses until a <i>send_signal()</i> message is sent to a <i>Wire</i> object. Since every port eventually connects to a wire, this recursion eventually terminates and unfolds. After sending the signal to the outside world, an attempt is made to propagate the signal to components which are at the same level of the hierarchy and are in the fan-out list of the port.</p><p>Finally, the main driver function (<A HREF="9903b.htm#l17">Listing Seventeen</A>) creates three signal arrays and populates them with the primary inputs for the 3-input AND gate. Four wires are then created (three to hold the input values and one to hold the outputs). The 3-input AND gate is then constructed with the appropriate parameters. The <i>simulate()</i> method is then sent to the component and the output values of the 3-input AND gate's output wire are displayed.</p><p>Upon running the program, the output in <A NAME="rf2"><A HREF="9903bf2.htm">Figure 2</A> is produced. The format of the output is a list of pairs. The first element of the pair is the time that the signal occurred (where underscore represents the initial time) and the second value represents the actual value of the signal (either 0, 1 or <i>X</i>).</p><h3>Conclusion</h3><p>As you can see, simple logic components can be represented and simulated hierarchically using C++, and the code required is relatively compact and straightforward. However, the simulator engine is somewhat clumsy to use, since it actually requires recompilation whenever a new composite component is created.</p><p>The DigiTcl GUI does make the simulator easier to use, at least when laying out circuit components and wiring them together. Communication to and from the simulator engine was implemented by a bidirectional pipe. The GUI feeds the simulator both the circuit description and the input signals to the simulator engine via the pipe. The simulator constructs the circuit, simulates it, and passes the corresponding output signals through the pipe back to the GUI for display. Unfortunately, the GUI does not support the hierarchical composition of components. This is something you might want to add.</p><p>Another enhancement would be to use CORBA as a means to distribute the simulation. Because there is no need for a central point of control (such as a global event queue or a global clock), the wires and components that comprise the circuit can be distributed over several different processes or even over several different processors. The relatively simple interfaces that make up the <i>Component</i>, <i>Wire</i>, and <i>Port</i> classes make this idea tempting.</p><h3>Acknowledgment</h3><p>I'd like thank Dr. Paul Gillard from Memorial University of Newfoundland for his assistance during the preparation of this article.</p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</A></H4><pre>class Component{public:    virtual     ~Component();<p></p>    list&lt;Port *&gt;     I_List;    list&lt;Port *&gt;     O_List;    virtual void     process(ckt_time);    void         simulate();protected:    Component(ckt_time delay = 1L, const char *name = "Component");     ckt_time     delay;private:    boolean      inputs_are_ready() const;    char        *name;    ckt_time     local_time;};</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>class Connector{public:    virtual     ~Connector();    virtual Signal   get_signal(ckt_time) const = 0;    virtual void     send_signal(Signal) = 0;<p></p>    void         connect(Component &amp;);    void         propagate() const;protected:    Connector(const char* = "Connector");private:    list&lt;Component *&gt; fan_out;    char         *name;};</pre><P><A HREF="#rl2">Back to Article</A></P><H4><A NAME="l3">Listing Three</H4><pre>class Wire : public Connector{public:    Wire(const char *name = "Wire");    Wire(Signal s[], int num, char *name);<p></p>    Signal  get_signal(ckt_time) const;    void    add_signal(Signal);<p></p>private:    list&lt;Signal&gt;    signals;};</pre><P><A HREF="#rl3">Back to Article</A></P><H4><A NAME="l4">Listing Four</H4><pre>class Port : public Connector{public:    Signal       get_signal(ckt_time) const;    void         send_signal(Signal);protected:    Port(Connector &amp;, const char* = "Port");    Connector   *external;};</pre><P><A HREF="#rl4">Back to Article</A></P><H4><A NAME="l5">Listing Five</H4><pre>class Input : public Port{public:    Input(Component &amp;, Connector &amp;, const char *name = "Input");    void    send_signal(Signal);};class Output : public Port{public:    Output(Component &amp;, Connector &amp;, const char *name = "Output");};</pre><P><A HREF="#rl5">Back to Article</A></P><H4><A NAME="l6">Listing Six</H4><pre>class And2 : public Component{public:    And2(Connector &amp;, Connector &amp;, Connector &amp;,         ckt_time = 1L, char* = "And2");    void process(ckt_time);private:    Input   I1, I2;    Output  O1;};</pre><P><A HREF="#rl6">Back to Article</A></P><H4><A NAME="l7">Listing Seven</H4><pre>And2::And2(Connector &amp;ci1, Connector &amp;ci2, Connector &amp;co1,       ckt_time dly, char *n) :    Component(dly, n),    I1 (*this, ci1, "And2 I1"),    I2 (*this, ci2, "And2 I2"),    O1 (*this, co1, "And2 O1"){ }</pre><P><A HREF="#rl7">Back to Article</A></P><H4><A NAME="l8">Listing Eight</H4><pre>class And3 : public Component{public:    And3(Connector &amp;, Connector &amp;,          Connector &amp;, Connector &amp;,          char* = "And3");private:    Input   I1, I2, I3;    Output  O1;    Wire    w;    And2    and2a, and2b;};</pre><P><A HREF="#rl8">Back to Article</A></P><H4><A NAME="l9">Listing Nine</H4><pre>And3::And3(Connector &amp;ci1, Connector &amp;ci2,           Connector &amp;ci3, Connector &amp;co1,            ckt_time dly, char *n) :        Component(CKT_TIME_NULL, n),        I1 (*this, ci1, "And3 I1"),        I2 (*this, ci2, "And3 I2"),        I3 (*this, ci3, "And3 I3"),        O1 (*this, co1, "And3 O1"),        w("And3 wire"),        and2a(I1, I2, w, 1L, "And2a"),        and2b(w, I3, O1, 1L, "And2b"){ }                The 3-input AND gate constructor.</pre><P><A HREF="#rl9">Back to Article</A></P><H4><A NAME="l10">Listing Ten</H4><pre>void Component::simulate(){    // Continue to simulate the component as long as inputs signals    // exist at the current local time of the component.    while (inputs_are_ready())    {        // If so, then increment local time here.        // Otherwise, circuits with feedback go on forever.        local_time++;        // Send the process message to component. This may trigger further         // simulate() messages depending upon connectivity of component.        process(local_time - 1);    }}</pre><P><A HREF="#rl10">Back to Article</A></P><H4><A NAME="l11">Listing Eleven</H4><pre>void Component::process(ckt_time){    list&lt;Port *&gt;::const_iterator      p;<p></p>    // Scan all the input port pointers in the input port list    // and activate any subcomponent immediately connected to an input port.    for (p = I_List.begin(); p != I_List.end(); p++)        (*p)-&gt;propagate();}</pre><P><A HREF="#rl11">Back to Article</A></P><H4><A NAME="l12">Listing Twelve</H4><pre>void And2::process(ckt_time t){    Sig_Val     sigval1 = I1.get_signal(t).get_value();    Sig_Val     sigval2 = I2.get_signal(t).get_value();<p></p>    if (sigval1 == SIG_HIGH &amp;&amp; sigval2 == SIG_HIGH)        O1.send_signal(Signal(t + delay, SIG_HIGH));    else if (sigval1 == SIG_LOW || sigval2 == SIG_LOW)        O1.send_signal(Signal(t + delay, SIG_LOW));    else        O1.send_signal(Signal(t + delay, SIG_X));}</pre><P><A HREF="#rl12">Back to Article</A></P><H4><A NAME="l13">Listing Thirteen</H4><pre>void Connector::propagate() const{    list&lt;Component *&gt;::const_iterator   c;<p></p>    // Scan all the elements in the component pointer list and    // send simulate() messages to each of them.    for (c = fan_out.begin(); c != fan_out.end(); c++)        (*c)-&gt;simulate();}</pre><P><A HREF="#rl13">Back to Article</A></P><H4><A NAME="l14">Listing Fourteen</H4><pre>Signal Wire::get_signal(ckt_time t) const{    // If signal list is empty or if time we are looking for is greater than     // the time last signal came into wire, then return an undefined signal.    if (signals.empty() || signals.back().get_time() &lt; t)        return Signal(CKT_TIME_NULL, SIG_NULL);<p></p>    list&lt;Signal&gt;::const_iterator     s = signals.begin();    Signal  found;<p></p>    // Do a linear scan over the list and return the signal that occurred    // at the specified time (if it exists).    while (s != signals.end() &amp;&amp; (*s).get_time() &lt;= t)        found = *s++;    return found;}</pre><P><A HREF="#rl14">Back to Article</A></P><H4><A NAME="l15">Listing Fifteen</H4><pre>void Wire::send_signal(Signal sig){    add_signal(sig);    propagate();}</pre><P><A HREF="#rl15">Back to Article</A></P><H4><A NAME="l16">Listing Sixteen</H4><pre>Signal Port::get_signal(ckt_time t) const{    // Send message to the external feeder to get its signal.    return external-&gt;get_signal(t);}void Port::send_signal(Signal s){    // Send the signal to the external Connector.    external-&gt;send_signal(s);    // Propagate the signal at the current level of the hierarchy.    propagate();}</pre><P><A HREF="#rl16">Back to Article</A></P><H4><A NAME="l17">Listing Seventeen</H4><pre>int main(){    // Create signal arrays for the inputs.    Signal  Signal1[] =    {        // {0 1} {2 0} {3 1} {4 0} {31 0}        Signal(0, SIG_HIGH),        Signal(2, SIG_LOW),        Signal(3, SIG_HIGH),        Signal(4, SIG_LOW),    };    Signal  Signal2[] =    {        // {0 1} {1 0} {2 1} {4 0} {31 0}        Signal(0, SIG_HIGH),        Signal(1, SIG_LOW),        Signal(2, SIG_HIGH),        Signal(4, SIG_LOW)    };    Signal  Signal3[] =    {        // {0 1} {2 0} {4 1} {5 0} {31 0}        Signal(0, SIG_HIGH),        Signal(2, SIG_LOW),        Signal(4, SIG_HIGH),        Signal(5, SIG_LOW)    };    // Build input &amp; output wires and populate input wires with input signals.    Wire    w1(Signal1, sizeof(Signal1) / sizeof(Signal), "Main in_w1");    Wire    w2(Signal2, sizeof(Signal2) / sizeof(Signal), "Main in_w2");    Wire    w3(Signal3, sizeof(Signal3) / sizeof(Signal), "Main in_w3");    Wire    w4("Main out_w4");<p></p>    // Build the 3-input AND gate, simulate it and show its output.    And3    and3(w1, w2, w3, w4, CKT_TIME_NULL, "and3");    and3.simulate();    and3.show_outputs();<p></p>    return 0;}</pre><P><A HREF="#rl17">Back to Article</A></P><p><b>DDJ</b></p><HR><I>Copyright &copy; 1999, Dr. Dobb's Journal</I><BR>
</body></html>