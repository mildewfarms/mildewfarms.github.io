<html><head><title>Mar99: The THRSim11 68HC11 Simulator</title></head><BODY BGCOLOR="#ffffff" TEXT="#000000" LINK="#0000ff" VLINK="#330066" ALINK="#FF0000">
<!--Copyright &#169; Dr. Dobb's Journal--><h1>The THRSim11 68HC11 Simulator</h1><p><i>Dr. Dobb's Journal</i> March 1999 </p><h3>By Wilbert Bilderbeek, Harry Broeders, and Alex van Rooijen </h3><hr><p>THRSim11 is a Windows-based simulator that lets you edit, assemble, simulate, and debug programs for the Motorola 68HC11 microcontroller. THRSim11 simulates the CPU, ROM, RAM, and all memory-mapped I/O ports and onboard peripherals, such as the timer (including pulse accumulator), analog-to-digital (A/D) converter, parallel port, serial port, and I/O pins (analog and interrupt). Furthermore, a number of simulated external components can be connected to the pins of the simulated 68HC11 while debugging, including LEDs, switches, analog sliders (with variable voltage potential), and serial transmitters/receivers. There is also a 4&times;20 LCD character display mapped in the address space of the 68HC11.</p><p>THRSim11's user interface lets you view and control every register (CPU registers and I/O registers), memory location (data, program, and stack), and pin of the simulated microcontroller while debugging. You can also stop the simulation at any combination of events.</p><p>THRSim11 got its start in 1992 at the      Rijswijk Institute of Technologies in the Netherlands. We are now working on the THRSim11 Component Development Kit, which lets you develop your own components. These can then be connected to the pins, registers, and/or memory locations of simulated microcontrollers. Because this framework is based on Microsoft's COM specification, any programming language that supports COM can be used. The components currently available include LED, switch, seven segment displays, and logical ports. A freely available demo version of THRSim11 3.06 is available at http://www .thrijswijk.nl/~bd/thrsim11/ thrsim11.htm, and from <i>DDJ</i> (see "Resource Center," page 5). </p><p>Central to THRSim11's design is the Observer pattern (see <A NAME="re1"><A HREF="9903de1.htm">Example 1</A>), described by Erich Gamma and Richard Helm in "Observations on Observer" (<i>Dr. Dobb's Sourcebook</i>, September/ October 1995), and <i>Design Patterns</i>, by Erich Gamma et al. (Addison-Wesley, 1995). To implement THRSim11, we extended Observer to make the pattern easier to apply. (We also made extensive use of Observer when we implemented the simulation of the 68HC11's onboard devices -- timer, serial ports, parallel ports, A/D converter, and the like.) The heavy use of the Observer pattern resulted in an application that consists of several components or modules loosely coupled together. Each component consists of several subjects and observers which can be connected to the observers and subjects of other components. This makes the THRSim11 68HC11 simulator program easy to extend. You can, for example, connect a simulated AND gate to the pins of the simulated 68HC11 as easily as you can connect a real AND gate to the pins of a real 68HC11. </p><p>When we originally evaluated the Observer pattern, we asked the following questions: </p><ul>  <li>Since every <i>ConcreteObserver</i> has to call <i>attach()</i>/<i>detach()</i> in relation to a <i>Subject</i>, can this responsibility that all <i>ConcreteObservers</i> share be transferred to a common base class (<i>Observer</i>)?   <li>Since every <i>ConcreteObserever</i> must contain a reference to the <i>ConcreteSubject</i> it observes, can this reference be defined in the common base class (<i>Observer</i>)?   <li>Since every kind of <i>ConcreteSubject</i> must be derived from <i>Subject</i>, is it possible to automate the generation of <i>ConcreteSubjects</i>?   <li>If a <i>ConcreteSubject</i> being observed by a <i>ConcreteObserver</i> is destroyed, can we avoid the reference inside the <i>ConcreteObserver</i> becoming a dangling reference?  <li>If a <i>ConcreteObserver</i> observes more than one <i>ConcreteSubject, </i>the following problem arises: If the <i>ConcreteObserver</i> receives an <i>update()</i> call, it cannot determine the cause of this call. So the <i>ConcreteObserver</i> does not know which value it should update. According to Gamma and Helm, the solution to this problem is to send along a parameter with the <i>update()</i> call. This can be the pointer of the <i>ConcreteSubject</i> that caused this <i>update()</i> call. But this leads to a switch statement inside the <i>ConcreteObserver::update()</i> member function to determine the cause of the <i>update()</i> call and take appropriate action. This <i>switch</i> statement switches on an alarm bell inside our object-oriented minds because it is more often than not a sign of improper object-oriented design. Is there another way to observe several <i>ConcreteSubjects</i> from within one <i>Concrete-Observer</i>? </ul><p><A NAME="re2"><A HREF="9903de2.htm">Example 2</A> illustrates how we extended the Observer pattern to answer "yes" to all of the aforementioned questions. As you can see, we moved the link from <i>ConcreteObserver</i> to <i>ConcreteSubject</i> to their base classes (from <i>Observer</i> to <i>Subject</i>). This makes it possible to avoid dangling references. The template <i>Model&lt;T&gt;</i> can be used to generate a simple <i>ConcreteSubject </i>that encapsulates a value of type <i>T. </i>The template <i>CallOnWrite&lt;T,C&gt; </i>can be used to generate a kind of smart pointer to every <i>Model&lt;T&gt;</i> that a component <i>C </i>wants to observe. We used Microsoft's COM to extend this pattern even further to make it possible to observe models from within other applications. More information, including all source code, is available at http://www.thrijswijk.nl/~bd/thrsim11/ddj/. </p><p><b>DDJ</b></p><P><A HREF="9903d.htm#rs1">Back to Article</A></P><HR><I>Copyright &copy; 1999, Dr. Dobb's Journal</I><BR>
</body></html>