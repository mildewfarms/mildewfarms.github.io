<html><head><title>Oct99: The Small Scripting Language</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>The Small Scripting Language</h1><p><i>Dr. Dobb's Journal</i> October 1999</p><h2>Introducing a  Small-C descendent </h2><h3>By Thiadmer Riemersma</h3><I>Thiadmer writes multimedia software and animation toolkits for ITB CompuPhase in the Netherlands. He can be contacted at thiadmer@compuphase.com.</I><hr><p>Many years ago, I retyped the Small-C compiler from <i>Dr. Dobb's Journal</i>. (See "Putting C on a Microcomputer: The Original Small-C," by Ron Cain, and "The Small-C Compiler," by J.E. Hendrix, on <i>Dr. Dobb's Small-C Resource CD-ROM; </i>http://www.ddj.com/store/.) Having just grasped the basics of the C language, working on the Small-C compiler was a learning experience of its own. The compiler, as published, generated code for an 8080 assembler. The first modification I needed to make was to adapt it to the 8086. Over the years, I used it to write low-level system software, extending the compiler with new features and fixing many details. Eventually, as I was moving toward bigger applications in more conventional environments, the Small-C compiler was replaced by main-stream development environments.</p><p>In early 1998, I was looking for a scripting language for an animation toolkit. Among the languages that I evaluated were Lua (see "Lua: An Extensible Embedded Language," by Luiz Henrique de Figueiredo, Roberto Ierusalimschy, and Waldemar Celes, <i>DDJ</i>, December 1996), BOB (see "Your Own Tiny Object-Oriented Language," by David Betz, <i>DDJ</i>, September 1991), Scheme, REXX Java, ScriptEase, and Forth. None of these languages met my requirements completely. Experimenting with Al Stevens's Quincy C interpreter (see "C Programming," by Al Stevens, <i>DDJ</i>, May-December 1994) brought me to the idea that a simplified C might be a good fit. I dusted off Small-C. The result is "Small," a simple, typeless, 32-bit extension language with a C-like syntax. The Small compiler outputs P-code (or bytecode) that subsequently runs on an abstract machine. Execution speed, stability, simplicity, and a small footprint were essential design criteria for both the language and the abstract machine.</p><DDJADVERTISEMENT INLINE><p>Small is not a proper subset of C; that is, Small programs are not necessarily compilable with a C compiler. In other words, "Small" is Small-C without the "C." The complete Small toolkit and example programs are available at http://www .compuphase.com/small.htm and from <i>DDJ</i> (see "Resource Center," page 5). </p><h3>The Language</h3><p>Small is a descendent of the original Small-C, which in turn is a subset of C. The fundamental changes I made were the removal of the primitive type system and the substitution of pointers by references. Many of the other modifications are a direct or indirect consequence of these changes. To get a feel for the language, look at <A NAME="rl2"><A HREF="#l2">Listings Two</A> (the Sieve of Eratosthenes) and <A NAME="rl3"><A HREF="#l3">Three</A> (the day of the week, using Zeller's congruence algorithm).</p><p>The variable type system has a useful side effecttype checking. The type of variable or constant is usually also an indication of its purpose. By not having types, Small would lack an automatic way to catch a whole class of common programming errors. That is why Small introduces variable tagnames that denote the purpose, or usage, of a variable, but without describing a memory layout of the data object. The Small compiler checks the tagnames of parameters passed to functions, and of operands on both sides of a binary operator.</p><p>A language without pointers needs the ability to pass function arguments by reference. Without it, creating a function that reorders or sorts data would require a few clumsy workarounds, probably involving global variables. Small supports pass-by-reference arguments with a syntax similar to that of C++. Arrays are always passed by reference.</p><p>C language functions can pass output values via pointer arguments. The standard function <i>scanf()</i>, for example, stores the values or strings that it reads from the console into its arguments. You can design a function in C so that it optionally returns a value through a pointer argument. If the caller of the function does not care for the return value, it passes NULL as the pointer value. The standard function <i>strtol()</i> is an example of a function that does this. This technique frequently saves you from declaring and passing dummy variables. Small replaces pointers with references, but references cannot be NULL. Thus, Small needed a different technique to drop the values that a function returns via references. Its solution is the use of an argument placeholder that is written as an underscore character ("_"). Prolog programmers will recognize it as a similar feature in that language. The argument placeholder reserves a temporary anonymous data object (called a "cell" in Small) that is automatically destroyed after the function call.</p><p>The temporary cell for the argument placeholder should still have a value. Therefore, a function must specify what value each passed-by-reference argument will have upon entry when the caller passes the placeholder instead of an actual argument. By extension, I also added default values for arguments that are pass-by-value. The feature to optionally remove all arguments with default values from the right was copied from C++.</p><p>When speaking of BCPL and B, Dennis Ritchie said that C was invented in part to provide a plausible way of dealing with character strings when one begins with a word-oriented language (see "The C Programming Language," by D.M. Ritchie, S.C. Johnson, M.E. Lesk, and B.W. Kernighan, <i>DDJ</i>, May 1980). Small provides two options for working with strings: packed and unpacked. In a packed string, every character fits in a cell. The overhead for a typical 32-bit implementation would be large; one character would take 4 bytes. Packed strings store up to four characters in one cell, at the cost of being significantly more difficult to handle. Modern BCPL implementations provide two array indexing methods: one to get a word from an array and one to get a character from an array. Small copies this concept, although the syntax differs from that of BCPL. The packed string feature also led to the new operator <i>char</i>. <A NAME="re1"><A HREF="9910fe1.htm">Example 1</A> shows how to access cells and characters.</p><p>Unicode applications often have to deal with two character sets: 8-bit ASCII for legacy file formats and standardized transfer formats (like many of the Internet protocols), and the 16-bit Unicode character set. Although the Small compiler has an option that makes characters 16-bit (so only two characters fit in a 32-bit cell), a more convenient approach may be to store 8-bit character strings in packed strings and 16-bit (Unicode) strings in unpacked strings. This turns a weakness in Small, the need to distinguish packed strings from unpacked strings, into a strength. Small can make the distinction quite easily, because of the way that packed characters are aligned in a cell. <A NAME="re2"><A HREF="9910fe2.htm">Example 2</A> is a function that distinguishes a packed string from an unpacked string and a function that determines the length of both packed and unpacked strings.</p><p>Small supports named parameters in addition to the more common positional parameters. Argument names are often easier to recall than argument positions, especially if the argument list of a function is long. Named parameters are also more convenient to use than positional parameters if many parameters have default values; contrast <A NAME="re3"><A HREF="9910fe3.htm">Example 3</A>(a) with 3(b), for instance.</p><p>In general, I have tried to keep Small close to C. For example, Small has the same operator set as C (with the exception of a few operators that deal with structures and unions). It is generally agreed upon that some operators in this table have counterintuitive precedence. In an expression parser that I wrote for the interactive multimedia development system EGO (which has an equally large set of operators), I have had favorable experiences with a different organization of operators in their precedence levels. It would have been a simple step to adapt Small to the operator set and the precedence levels that I prefer. For the sake of similarity with C, I resisted such a change.</p><p>Minor differences between Small and C are:</p><ul>  <li>When the body of a function is a single instruction, the braces (for a compound instruction) are optional; see <A NAME="re4"><A HREF="9910fe4.htm">Example 4</A>(a), the ubiquitous "hello world" program.  <li>Escape characters are called "control characters" in Small, and they start with a caret ("^") rather than a backslash ("\"). I prefer the caret to the backslash, because path names in DOS and Windows use backslashes. Small provides a <i>#pragma</i> to change the control character back into a backslash.  <li>Variables have no type. To declare a new variable, you use the keyword <i>new</i>; see <A NAME="re4"><A HREF="9910fe4.htm">Example 4</A>(b). Variables may be declared anywhere in the function; they need not precede any instruction in the block. The first expression of a <i>for</i> statement may also hold a variable declaration.   <li>Arrays can be filled with an incrementing or decrementing sequence using so called "progressive initializers;" see <A NAME="re5"><A HREF="9910fe5.htm">Example 5</A>.  <li>Variable number of arguments is also supported (always passed by reference).  <li>Direct support for assertions. Small also has an "assertion directive" to flag compile-time errors.  <li>The cases in a <i>switch</i> statement are not drop through.  <li>There is no preprocessor. Conditional compilation is supported, but <i>#define</i> can only declare simple numeric constants.  <li><i>char</i> is an operator, not a type.  <li>The empty statement is an empty compound block ("{}"), not a semicolon.</ul><h3>Interfacing with C Programs</h3><p>The required functions for the abstract machine are all gathered in a single C file (assuming that you use the ANSI C version of the abstract machine), but there are two additional files for core functions for Small programs and a basic set of console I/O functions. The abstract machine itself is a data structure. That is, you can create two or more abstract machines by declaring more variables of the <i>AMX</i> type.</p><p>The abstract machine has no function to actually read a file from disk, but once you obtain a memory image of a compiled Small file in memory, you use it to initialize the abstract machine. At this stage, all native functions are also registered to the abstract machine. Function <i>amx_Register</i> returns an error code if it finds one or more functions in the compiled Small program that it cannot resolve from the list of native functions. You may have several lists of native functions, so you can continue to call <i>amx_Register</i> until it returns a success flag. If you have several abstract machines, you must register the native functions for every abstract machine separately.</p><p>The third step is to run the program by calling <i>amx_Exec</i>. You can start running from the <i>main</i> function or from any function in the Small program that is declared <i>public</i>.</p><p><A NAME="rl1"><A HREF="#l1">Listing One</A> is a run-time program that loads and runs a compiled Small program from the command line. The Small compiler optionally inserts symbolic information and line number information in the compiled file. The abstract machine provides a function to browse through all global symbols, as well as a debug callback function that is called on every event that might be of interest to a debugger (such as a function call or return, or the start of a new instruction). By installing a callback routine, an application can provide source-level debugging of the Small programs with relative ease.</p><h3>The Abstract Machine</h3><p>It appears to be some kind of a tradition to design an abstract machine as a stack machine. All of the abstract machine implementations that I studied were stack machines, from the B language in 1972, to Java today. With Small, I decided to deviate from this path, because I considered the fact that a stack machine cannot take advantage of processor registers in the same way as an abstract machine with pseudoregisters.</p><p>The abstract machine mimics a dual-register processor. In addition to the two general-purpose registers, it has a few internal registers; see <A NAME="rt1"><A HREF="9910ft1.htm">Table 1</A>. Notably missing from the register set is a flags register. The abstract machine keeps no separate set of flags; instead, all conditional branches are taken depending on the contents of the PRI register.</p><p>Every instruction consists of an opcode followed by 0 or 1 parameters. Each opcode is 1 byte in size; an instruction parameter has the size of a cell (usually 4 bytes).</p><p>Most instructions have implied registers as operands. This reduces the number of operands and the amount of time needed to decode an instruction. </p><p>In several cases, the implied register is part of the name of the opcode. For example, <i>PUSH.pri</i> is the name of the opcode that stores the PRI register on the stack. This instruction has no parameters. Its parameter (PRI) is implied in the opcode name, see the Small manual for a list of all opcodes and their semantics.</p><h3>Threading</h3><p>In an indirect threaded interpreter, each opcode is an index in a table that contains a jump address for every instruction. A threaded abstract machine is conventionally written in assembler, because most high-level languages cannot store label addresses in an array. The GNU C compiler (GCC), however, extends the C language with an unary &amp;&amp; operator that returns the address of a label. This address can be stored in a <i>void *</i> variable type and may be used later in a <i>goto</i> instruction. Basically, the following snippet does the same as <i>goto start;</i>:</p><blockquote><p>void *ptr = &amp;&amp;start;</p><p>goto *ptr;</p></blockquote><p>The ANSI C version of the abstract machine uses a large <i>switch</i> statement to choose the correct instructions for every opcode. The GNU C version of the abstract machine runs twice as fast as the ANSI C version. Fortunately, GNU C runs on quite a few platforms. This means that the fast GNU C version is still fairly portable.</p><p>Two benchmark programs (the Sieve of Eratosthenes and the calculation of Fibonacci numbers via recursion) indicate that the ANSI C version of Small's abstract machine is about as fast as the Java Virtual Machine (JVM) 1.0. This should be seen as an order-of-magnitude measure; the Java and Small languages and their goals are different enough to make any comparison questionable.</p><h3>Compiling the Tools</h3><p>The Small compiler and the abstract machine are written in ANSI C as much as possible. I have compiled the sources with 16-bit and 32-bit compilers of different brands. There are several compile options that you can set to adjust the compiler and the abstract machine to your platform or your preferences; see <A NAME="rt2"><A HREF="9910ft2.htm">Table 2</A>.</p><h3>Conclusion</h3><p>Again, the Small toolkit, including documentation in Postscript format, source of the compiler and the abstract machine, and example programs, is available at http://www .compuphase.com/small.htm. Updates and additional notes will also be posted at that location as they become available.</p><p></p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include "amx.h"void *loadprogram(AMX *amx,char *filename){  FILE *fp;  AMX_HEADER hdr;  void *program = NULL;  if ((fp = fopen(filename,"rb")) != NULL) {    fread(&amp;hdr, sizeof hdr, 1, fp);    if ((program = malloc((int)hdr.stp)) != NULL) {      rewind(fp);      fread(program, 1, (int)hdr.size, fp);      fclose(fp);      if (amx_Init(amx,program,NULL) == AMX_ERR_NONE)        return program;      free(program);    } /* if */  } /* if */  return NULL;}int main(int argc,char *argv[]){extern AMX_NATIVE_INFO core_Natives[];extern AMX_NATIVE_INFO console_Natives[];  AMX amx;  cell ret;  int err;  void *program;  if (argc != 2 || (program = loadprogram(&amp;amx,argv[1])) == NULL) {    printf("Usage: SRUN &lt;filename&gt;\n\n"           "The filename must include the extension\n");    return 1;  } /* if */  core_Init();  amx_Register(&amp;amx, core_Natives, -1);  err = amx_Register(&amp;amx, console_Natives, -1);  if (err == AMX_ERR_NONE)    err = amx_Exec(&amp;amx, &amp;ret, AMX_EXEC_MAIN, 0);  if (err != AMX_ERR_NONE)    printf("Run time error %d on line %ld\n", err, amx.curline);  else if (ret != 0)    printf("%s returns %ld\n", argv[1], (long)ret);  free(program);  core_Exit();  return 0;}</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>/* Print all primes below 100, using the * "Sieve of Eratosthenes" algorithm */#include &lt;console&gt;main()    {    const max_primes = 100;    new series[max_primes] = { true, ... };    for (new i = 2; i &lt; max_primes; ++i)        if (series[i])            {            printf("%d ", i);            /* filter all multiples of this "prime" from the list */            for (new j = 2 * i; j &lt; max_primes; j += i)                series[j] = false;            }    }</pre><P><A HREF="#rl2">Back to Article</A></P><H4><A NAME="l3">Listing Three</H4><pre>/* illustration of Zeller's congruence algorithm to * calculate the day of the week given a date */#include &lt;console&gt;weekday(day, month, year)    {    if (month &lt;= 2)        month += 12, --year;    new j = year % 100;    new e = year / 100;    return (day + (month+1)*26/10 + j + j/4 + e/4 - 2*e) % 7;    }readdate(&amp;day, &amp;month, &amp;year)    {    print("Give a date (dd-mm-yyyy): ");    day = getvalue(_,'-','/');    month = getvalue(_,'-','/');    year = getvalue();    }main()    {    new day, month, year;    readdate(day, month, year);    new wkday = weekday(day, month, year);    printf("The date %d-%d-%d falls on a ", day, month, year);    switch (wkday)        {        case 0:            print("Saturday");        case 1:            print("Sunday");        case 2:            print("Monday");        case 3:            print("Tuesday");        case 4:            print("Wednesday");        case 5:            print("Thursday");        case 6:            print("Friday");        }    print("^n");    }</pre><P><A HREF="#rl3">Back to Article</A></P><HR><I>Copyright &copy; 1999, Dr. Dobb's Journal</I><BR>
</body></html>