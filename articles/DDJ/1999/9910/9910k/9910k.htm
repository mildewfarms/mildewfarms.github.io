<html><head><title>Oct99: Java Q&A</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Does Java  Support <i>enum</i>s?</h1><p><i>Dr. Dobb's Journal</i> October 1999</p><h3>By Evan Easton</h3><I>Evan is a software architect in the Twin Cities working on better ways to build software. He can be contacted at evan@eeaston.com.</I><hr><p>If you are familiar with C or C++, you know that <i>enum</i>s let you define a constrained set of options for an API parameter. Java, however, does not directly support this concept. You can work around this deficiency using simple generic types (such as integers or strings) to pass <i>enum</i>-style information in a program. While common, this approach demonstrates disregard for well-designed, safe interfaces, in preference of quick-and-dirty solutions. This approach is dangerous because generic types are inappropriate for the job. They can represent a set of values that is much larger than the set which is valid for the API call. As a result, the method accepting the parameter must face the possibility that a caller will try to pass it an invalid value. The compiler is not equipped to help avoid the problem. So you must wait until run time to witness the mistake.</p><p>There are plenty of examples where this shortcoming may be demonstrated and where a real <i>enum</i> capability would be beneficial. Let's look at a few that can be found in the JDK itself. For instance, the class <i>java.awt.Label</i>'s constructor <i>Label (String text, int alignment)</i> takes an integer as the alignment parameter. This integer is supposed to be from the set <i>{Label .LEFT=0, Label.CENTER=1, Label.RIGHT=2}</i>. There is no compile-time mechanism for preventing a call to the <i>Label</i> constructor with an integer that is not in this set. The behavior of <i>Label</i>, if such an integer is used, is to throw an <i>IllegalArgumentException</i>. <A NAME="rl1"><A HREF="#l1">Listing One</A> throws an exception with the stack trace shown in <A NAME="rl2"><A HREF="#l2">Listing Two</A>.</p><DDJADVERTISEMENT INLINE><p>Another case involves the class <i>java.awt.BorderLayout</i>, which uses a <i>String</i> as its layout constraint. That string should be in the set <i>{BorderLayout.NORTH, BorderLayout.SOUTH, BorderLayout.EAST, BorderLayout.WEST, BorderLayout.CENTER}</i> (these are the Western values). If a string from outside this set is used (see <A NAME="rl3"><A HREF="#l3">Listing Three</A>), you get an <i>IllegalArgumentException</i> (<A NAME="rl4"><A HREF="#l4">Listing Four</A> shows the stack trace).</p><p>Yet another example involves the class <i>java.util.Calendar</i>, which uses a number of integers defined to distinguish the various components of a timestamp -- <i>Calendar.YEAR, Calendar.DAY_OF_MONTH, Calendar.MINUTE</i>, and so on. These can be passed into the methods <i>get(int field)</i> and <i>set(int field, int value)</i> to read and change the value of a particular field of a timestamp. Examining the source of the <i>Calendar</i> class reveals that these integers are indices into an internal array and they are unchecked, so using an invalid field (see <A NAME="rl5"><A HREF="#l5">Listing Five</A>) will result in an <i>ArrayIndexOutOfBoundsException</i> (see <A NAME="rl6"><A HREF="#l6">Listing Six</A>). This demonstrates a particularly nasty scenario where the exception thrown does not clearly indicate the true problem. In addition to failing at run time, the <i>set </i>method does not indicate that the fault is the result of an invalid input parameter.</p><h3>Implementing <i>enum</i> Classes</h3><p>All of these examples have a similar negative consequence -- you receive an exception at run time. Of course, there is nothing wrong with checking an input at run time and throwing an exception if it is invalid. But these are examples where the burden of a possible run-time failure, even if the code is under development, is just plain unnecessary.</p><p>The alternative is to use a specialized <i>enum</i>-like class to represent the parameters instead of general types like integers or strings. The most important property that this class must exhibit is that it should only be possible to create valid instances. This is accomplished by taking the following steps:</p><p>1. Make the constructor private. You will only be able to create instances from within the class.</p><p>2. For each valid <i>enum</i> value, declare a <i>public static final</i> instance of the class.</p><p>3. For each declared <i>enum</i> value, initialize a new instance of the class, either at the point of declaration or in the class's static initializer.</p><p></p><p>For example, consider how <i>Label</i> alignment might have been better done (<A NAME="rl7"><A HREF="#l7">Listing Seven</A>). Because <i>Label</i> is the only class that can instantiate <i>HorizontalAlignment</i>, there is no need to check the value of the alignment parameter in the constructor or the <i>setAlignment</i> method.</p><p>Using the new <i>HorizontalAlignment enum</i> (<A NAME="rl8"><A HREF="#l8">Listing Eight</A>) is identical to the way that you are supposed to do it with the current JDK version of <i>java.awt.Label</i>. The only difference is that you cannot pass in a raw, invalid integer value.</p><h3>Serialization Support</h3><p>The solution is not complete. The class <i>Label</i>, by virtue of being a <i>java.awt.Component</i>, must support the <i>java.io.Serializable</i> interface. This means that the <i>Label</i>'s state must be written to the output stream when the <i>Label</i> is serialized. As the previous example is written, however, the <i>HorizontalAlignment</i> class is not serializable. So, if you attempt to serialize a <i>Label</i>, you will receive a <i>java.io.NotSerializableException</i>.</p><p>You can't fix this problem by just declaring the <i>HorizontalAlignment</i> inner class as <i>Serializable</i>, however. Serializable objects must have an identity so that they retain their original meaning when they are deserialized. <A NAME="rl7"><A HREF="#l7">Listing Seven</A> relies upon placement in memory to distinguish the three <i>HorizontalAlignment</i> instances. This assumes that only three instances are ever created in a JVM. If you simply declare <i>HorizontalAlignment</i> as serializable, then deserializing <i>Label</i>s will create <i>HorizontalAlignment</i> instances in addition to the three that are declared in the <i>Label</i> class.</p><p>Because there is no good way to circumvent this problem, I'll work with it by giving <i>HorizontalAlignment</i>s an identity so that there can be multiple instances of a particular <i>HorizontalAlignment</i> (<i>Label.LEFT</i>, for instance) that will all be considered equal.</p><p>Just as with C <i>enum</i>s, the identity can be as simple as an integer, as in <A NAME="rl9"><A HREF="#l9">Listing Nine</A>. Each distinct alignment is distinguished by a number, for example <i>{LEFT=0, CENTER=1, RIGHT=2}</i>. To utilize the identity in comparisons,the methods <i>hashCode</i> and <i>equals</i> are defined so that value equality may be employed to compare instances. Of course, reference equality can no longer be used, and the <i>equals </i>method will have to be used exclusively for all comparisons. Applying these changes results in <A NAME="rl9"><A HREF="#l9">Listing Nine</A> for the <i>Label</i> class.</p><h3>What About Java 1.0?</h3><p>The <i>HorizontalAlignment</i> example was written via an inner class. This is a feature introduced in Java 1.1. If you want, or more likely need, to use the described Java <i>enum</i> technique in Java 1.0, then you'll have to make some changes that are actually quite simple.</p><p>First, the <i>HorizontalAlignment</i> class must be declared as a separate public class. Second, to avoid having to make the constructor package visible, declare the three alignment instances in the standalone <i>HorizontalAlignment</i> class (<A NAME="rl10"><A HREF="#l10">Listing Ten</A>), rather than in the <i>Label</i> class. Last, because serialization didn't exist in Java 1.0, you'll have to remove the customizations made in the previous section to support this feature. The only big consequence is that you will have to replace <i>Label.LEFT</i> with <i>HorizontalAlignment.LEFT</i> because the LEFT, CENTER, and RIGHT are no longer members of the <i>Label</i> class.</p><blockquote><p>// Valid at compile- and run-time</p><p>Label label = new Label("Read Me!", Hori-			zontalAlignment.RIGHT);</p></blockquote><p>This turns out to be a great side effect. Now the <i>HorizontalAlignment</i> class is a general-purpose class that can be used wherever alignment is needed. The Swing libraries took a small step in this direction by putting a wide variety of constants into a single class <i>javax.swing.SwingConstants</i>.</p><h3>Supporting the == Operator</h3><p>Now, wouldn't it be nice if you didn't  have to call the <i>equals</i> method to compare serializable instances of <i>HorizontalAlignment</i>? The problem stems from the fact that you can end up with redundant instances of the same logical <i>enum</i> value when you deserialize them. In JDK 1.1, there is no way to resolve identical instances of deserialized objects to the same object without subclassing <i>java.io.ObjectInputStream</i>. However, JDK 1.2 introduced a serialization feature that lets you do this sort of resolution in the serializable class itself.</p><p>This feature is the <i>readResolve</i> method on <i>java.io.Serializable</i>. After deserializing an object, Java invokes the <i>readResolve</i> method on that object, if it is defined. You can define this method to use the <i>enum</i>'s identity to roll all value-wise identical instances into the same instance. </p><p>First, add an instance dictionary to the class. This dictionary will hold onto all distinct instances of <i>HorizontalAlignment</i>. Second, in the constructor, put <i>this</i> into the instance dictionary with the integer representation as the key. The three declared static instances will be added to the dictionary via their constructors when the class is first loaded into memory.</p><p>Finally, implement the <i>readResolve</i> method to return the instance of <i>HorizontalAlignment</i> in the instance dictionary that has the same integer value as <i>this</i>. <A NAME="rl11"><A HREF="#l11">Listing Eleven</A> presents the new methods. I've left out error-handling code to keep things simple. Now you can count on there only being three accessible instances of <i>HorizontalAlignment</i>. This leaves you free to use == when comparing instances to each other.</p><p>Admittedly, I've put a lot of work into getting this class right, a process that's surely making you think twice about using these techniques for your <i>enum</i>s. However, if you are using JDK 1.2, then all the functionality shown thus far can be rolled into a common base class for all your <i>enum</i> needs. The classes <i>Enum.java</i>, <i>DuplicateEnumIdException.java</i>, and <i>NonExistentEnumException.java</i> (all available electronically; see "Resource Center," page 5) let you define <i>HorizontalAlignment</i> with the simplicity of <A NAME="rl12"><A HREF="#l12">Listing Twelve</A>.</p><h3>Readability and Usability Benefits</h3><p>The benefits up to now have been to improve validation of input parameters. There is another benefit to using <i>enum</i> classes, and that is readability.</p><p>Without the <i>enum</i> class, you would see a method declaration like this (from the JDK):</p><blockquote><p>// from class java.util.Calendar</p><p>public final void set(int field, int value);</p></blockquote><p>The documentation for that method does not clearly indicate the domain of the field parameter. If instead the field was reimplemented as an <i>enum</i> class named <i>CalendarField</i>, then the method declaration would look like this:</p><blockquote><p>public final void set(CalendarField field, int 			          value);</p></blockquote><p>This minor difference in declaration arguably makes the method more developer friendly. This is especially true because the javadoc documentation tool would create a link to the <i>CalendarField</i> class that you could follow to learn more about the domain it represents.</p><h3>An IDE that Helps?</h3><p>In the spirit of usability, you may have noticed that many of the newer Java IDEs offer a feature often referred to as code completion. This feature tries to help you complete code statements as you type them by providing code clauses that are valid in the current editing scope. This feature makes <i>enum</i> class types even easier to use because it can make the valid (declared) values available to developers without having to even look them up. For example, you could type,</p><p>new Label("Read Me!", HorizontalAlignment</p><p>and the IDE will give you the options of LEFT, CENTER, and RIGHT to complete the parameter. While this works for the integer versions of <i>Label </i>alignment, using an <i>enum</i> class eliminates the clutter of the extra constants declared on the superclass <i>Component. </i>This feature makes the usability of <i>enum</i> classes very attractive.</p><h3>Performance Concerns </h3><p>After all the positive arguments for <i>enum</i> classes, you may be clamoring about the negative performance implications. Well, yes, it's true that this technique has some downsides. Now you have to instantiate extra objects and invoke methods on them. However, in a majority of cases, the impact is negligible.</p><p>Consider the case of <i>Label</i>. The only place that the alignments really matter is when setting the alignment of the peer <i>Label</i> object. In <A NAME="rl13"><A HREF="#l13">Listing Thirteen</A> (from the JDK sources) the method could be rewritten with the new <i>HorizontalAlignment</i> class to look like <A NAME="rl14"><A HREF="#l14">Listing Fourteen</A>. The rewritten code is not much more costly. You've traded a check for a valid integer alignment with a final method call to get the numeric value of the alignment. This is slower, but consider that the <i>setAlignment</i> method gets called rather infrequently, and you'd have to conclude that performance concerns aren't warranted in this case.</p><h3>Conclusion</h3><p>While Java doesn't incorporate the notion of <i>enum</i>s, it is fairly easy to implement them using classes. The benefits include: <i>enum</i> classes offer compile-time rather than run-time validation of parameter values; and code using the <i>enum</i> classes is very suggestive.</p><p>On the flip side, the detriments include: <i>enum</i> classes require that you write and deploy a little extra code, particularly when serialization support is needed; and <i>enum</i> classes may introduce slight performance hits to your software.</p><p>In general, however, the benefits will outweigh the detriments. Just remember to weigh them against each other as you would for any design decision. Lastly, make these decisions with your ultimate goals in mind. Hopefully, these goals include producing high-quality, safe, and flexible software.</p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>// Pass in an invalid alignmentnew Label("Read me!", 4);</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>java.lang.IllegalArgumentException: improper alignment: 4    at java.awt.Label.setAlignment(Label.java:184)    at java.awt.Label.&lt;init&gt;(Label.java:127)    at ...</pre><P><A HREF="#rl2">Back to Article</A></P><H4><A NAME="l3">Listing Three</H4><pre>// Pass in an invalid layout constraintJPanel p = new JPanel();p.setLayout(new BorderLayout());p.add(new JButton("Push Me!"), "TOP");</pre><P><A HREF="#rl3">Back to Article</A></P><H4><A NAME="l4">Listing Four</H4><pre>java.lang.IllegalArgumentException: illegal component position         at java.awt.Container.addImpl(Compiled Code)         at java.awt.Container.add(Container.java:230)         at ...</pre><P><A HREF="#rl4">Back to Article</A></P><H4><A NAME="l5">Listing Five</H4><pre>// Pass in an invalid Calendar fieldCalendar calendar = Calendar.getInstance();calendar.set(123456, 2);</pre><P><A HREF="#rl5">Back to Article</A></P><H4><A NAME="l6">Listing Six</H4><pre>java.lang.ArrayIndexOutOfBoundsException: 123456         at java.util.Calendar.set(Calendar.java:767)         at ...</pre><P><A HREF="#rl6">Back to Article</A></P><H4><A NAME="l7">Listing Seven</H4><pre>public class Label  extends Component{  public static final HorizontalAlignment LEFT = new HorizontalAlignment();  public static final HorizontalAlignment CENTER = new HorizontalAlignment();  public static final HorizontalAlignment RIGHT = new HorizontalAlignment();  private HorizontalAlignment alignment_;  public static class HorizontalAlignment        {                // can only be invoke inside Label class scope                private HorizontalAlignment()                {                }        }        public Label(String text, HorizontalAlignment alignment)        {                ...                setAlignment(alignment);        }        public void setAlignment(HorizontalAlignment alignment)        {                // just make the assignment, no check needed                alignment_ = alignment;                ...        }        ...}</pre><P><A HREF="#rl7">Back to Article</A></P><H4><A NAME="l8">Listing Eight</H4><pre>// Valid at compile- and run-timeLabel label = new Label("Read Me!", Label.RIGHT);// Invalid at compile-time, which is good!label = new Label("Read Me!", 4);</pre><P><A HREF="#rl8">Back to Article</A></P><H4><A NAME="l9">Listing Nine</H4><pre>public class Label  extends Component  implements java.io.Serializable{  public static final HorizontalAlignment LEFT = new HorizontalAlignment(0);  public static final HorizontalAlignment CENTER = new HorizontalAlignment(1);  public static final HorizontalAlignment RIGHT = new HorizontalAlignment(2);  private HorizontalAlignment alignment_ = LEFT;  /** Enum class for horizontal alignment of Labels. */         public static class HorizontalAlignment                 implements java.io.Serializable         {                 private int alignValue_;                 // can only be invoke inside Label class scope                 private HorizontalAlignment(int align_value)                 {                         alignValue_ = align_value;                 }                 private int asInt()                 {                         return alignValue_;                 }                 /** Required for equality comparisons. */                 public int hashCode()                 {                         return asInt();                 }                 /** Required for equality comparisons. */                 public boolean equals(Object obj)                 {                   boolean ret = (obj == this);                   if(!ret &amp;&amp; obj != null &amp;&amp; obj instanceof HorizontalAlignment)                         ret = ((HorizontalAlignment)rhs).asInt() == asInt();                   return ret;                 }         }         public Label(String text, HorizontalAlignment alignment)         {                 ...                 setAlignment(alignment);         }         public void setAlignment(HorizontalAlignment alignment)         {                 alignment_ = alignment;                 ...         }         ...}</pre><P><A HREF="#rl9">Back to Article</A></P><H4><A NAME="l10">Listing Ten</H4><pre>public final class HorizontalAlignment  implements java.io.Serializable{  public static final HorizontalAlignment LEFT = new HorizontalAlignment(0);  public static final HorizontalAlignment CENTER = new HorizontalAlignment(1);  public static final HorizontalAlignment RIGHT = new HorizontalAlignment(2);  private int alignValue_;  // can only be invoke inside HorizontalAlignment class scope  private HorizontalAlignment(int align_value)  {                 alignValue_ = align_value;  }         /** Allow others to get the int value. Use carefully. */         public int asInt()         {                 return alignValue_;         }         /** Required for equality comparisons. */         public int hashCode()         {                 return asInt();         }         /** Required for equality comparisons. */         public boolean equals(Object rhs)         {                 boolean ret = (obj == this);                 if(!ret &amp;&amp; obj != null &amp;&amp; obj instanceof HorizontalAlignment)                         ret = ((HorizontalAlignment)rhs).asInt() == asInt();                 return ret;         }}</pre><P><A HREF="#rl10">Back to Article</A></P><H4><A NAME="l11">Listing Eleven</H4><pre>public final class HorizontalAlignment   implements java.io.Serializable {         // new field   private static Hashtable instanceDictionary__ = new Hashtable(3, 0.75f);         // changed constructor         private HorizontalAlignment(int align_value)         {                 alignValue_ = align_value;                 // Store this in the instance dictionary using the                 // int value as the key.  Needs to check for duplicate                 instanceDictionary__.put(new Integer(align_value), this);         }         // new method         protected Object readResolve()                 throws ObjectStreamException         {            // Simple look up of the instance with the same integer            // value as mine.  Needs to check for null entry.            return (HorizontalAlignment)instanceDictionary__.get(new                                                           Integer(asInt()));         }         // all other fields and methods unchanged         ...}</pre><P><A HREF="#rl11">Back to Article</A></P><H4><A NAME="l12">Listing Twelve</H4><pre>public class HorizontalAlignment  extends Enum{  public static final HorizontalAlignment LEFT = new HorizontalAlignment(0);  public static final HorizontalAlignment CENTER = new HorizontalAlignment(1);  public static final HorizontalAlignment RIGHT = new HorizontalAlignment(2);  private HorizontalAlignment(int id)  {                 super(id);  }}</pre><P><A HREF="#rl12">Back to Article</A></P><H4><A NAME="l13">Listing Thirteen </H4><pre>public synchronized void setAlignment(int alignment){         switch (alignment) {                 case LEFT:                 case CENTER:                 case RIGHT:                         this.alignment = alignment;                         LabelPeer peer = (LabelPeer)this.peer;                         if (peer != null) {                                 peer.setAlignment(alignment);                         }                         return;      }      throw new IllegalArgumentException("improper alignment: " + alignment);}</pre><P><A HREF="#rl13">Back to Article</A></P><H4><A NAME="l14">Listing Fourteen</H4><pre>public synchronized void setAlignment(HorizontalAlignment alignment){         alignment_ = alignment;         LabelPeer peer = (LabelPeer)this.peer;         if(peer != null)         {                 peer.setAlignment(alignment.asInt());         }}</pre><P><A HREF="#rl14">Back to Article</A></P><HR><I>Copyright &copy; 1999, Dr. Dobb's Journal</I><BR>
</body></html>