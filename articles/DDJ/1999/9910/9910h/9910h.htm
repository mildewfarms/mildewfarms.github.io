<html><head><title>Oct99: Programmer's Toolchest</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>PETE: The Portable  Expression Template Engine</h1><p><i>Dr. Dobb's Journal</i> October 1999</p><h2>Adding expression-template  functionality to container classes</h2><h3>By Scott Haney, James Crotinger,  Steve Karmesin, and Stephen Smith</h3><I>The authors are members of the technical staff in the Advanced Computer Laboratory at Los Alamos National Laboratory. They can be contacted at http://www .pooma@acl.lanl.gov.</I><hr><a name="rs1"><a href="9910hs1.htm">Applicative Operator Functors</a><hr><p>In 1995, Todd Veldhuizen and David Vandevoorde developed the expression-template technique to transform arithmetic expressions involving array-like containers into efficient loops that rivaled hand-coded C in speed (see "Expression Templates," by Todd Veldhuizen, <i>C++ Report</i>, July 1995 and "Linear Algebra with C++ Template Metaprograms," by Todd Veldhuizen and Kumaraswamy Ponnambalam, <i>DDJ</i>, August 1996). Expression templates are now at the heart of highly efficient scientific container libraries such as Pooma (http://www.acl.lanl.gov/pooma/) and Blitz++ (http://monet.uwaterloo.ca/ blitz/). Unfortunately, the technique's perceived complexity and the belief that it is limited to evaluating array expressions have deterred many potential expression-template users. Consequently, we developed a portable C++ framework that lets users easily add expression-template functionality to container classes and perform complex expression manipulations. This package is called "PETE," short for "Portable Expression Template Engine."</p><p>PETE is a compact package, consisting of about 3000 lines of ANSI/ISO C++. As the name suggests, PETE is widely portable and has been tested under UNIX with KAI C++ and EGCS, under Windows 95/98/NT with CodeWarrior Professional 4 and the Intel C++ compiler (part of VTune 3.0), and under MacOS with CodeWarrior Professional 4. Other compilers with ANSI-compliant template support should be able to compile the package with little difficulty. Achieving maximum performance requires aggressive inlining. In this regard, we get the best performance with KCC.</p><DDJADVERTISEMENT INLINE><p>PETE is a mature framework. As part of the Pooma framework, we have used PETE in several large scientific codes in the areas of hydrodynamics, linear accelerator modeling, neutron transport, and fusion device modeling on platforms ranging from laptops to the 1.6 TFLOP Accelerated Strategic Computing Initiative (ASCI) BlueMountain supercomputer.</p><p>PETE is available electronically from <i>DDJ</i> (see "Resource Center," page 5) and the Los Alamos Advanced Computing Laboratory at http://www.acl.lanl .gov/ pete/).</p><h3>An Overview of PETE</h3><p>To illustrate PETE's features, we'll add full expression-template evaluation functionality to Standard Template Library (STL) vectors in fewer than 20 lines of code. Our goal is to transform statements such as:</p><blockquote><p>A += -B + 2 * C;</p></blockquote><p>(where <i>A</i> and <i>C</i> are <i>vector&lt;double&gt;</i>s and <i>B</i> is a <i>vector&lt;int&gt;</i>) into the single efficient inlined loop in <A NAME="re1"><A HREF="9910he1.htm">Example 1</A>.</p><p>The first step is to supply overloaded arithmetic operator functions. Unlike conventional overloaded operators, which immediately apply an operation and typically generate temporaries to hold intermediate results, PETE operator functions return objects that can be combined to incrementally build up the parse tree of an expression. In our example, <i>operator-(const vec</i>tor&lt;T, Allocator&gt;&amp;) returns an object of type</p><blockquote><p>Expression&lt;UnaryNode&lt;OpUnaryMinus,             vector&lt;T, Allocator&gt;::const_iterator&gt; &gt;</p></blockquote><p>while </p><blockquote><p>operator*(T1, const vector&lt;T2, Allocator&gt;&amp;) </p></blockquote><p>returns an</p><blockquote><p>Expression&lt;BinaryNode&lt;OpMultiply, Scalar&lt;int&gt;, vector&lt;T2, Allocator&gt;::const_ 			      iterator&gt; &gt;</p></blockquote><p>These objects are combined by <i>operator+(const Expression&lt;T1&gt;&amp;, const Expression&lt;T2&gt;&amp;)</i> to produce the type in <A NAME="rf1"><A HREF="9910hf1.htm">Figure 1</A>. By comparing this to the graphical representation of the parse tree, you can see that the structure of the parse tree is encoded in the object's type. The <i>UnaryNode</i> and <i>BinaryNode</i> classes represent nonterminal nodes containing an applicative operator functor, such as <i>OpMultiply</i> (see the accompanying text box entitled "Applicative Operator Functors"), and one or more leaves, consisting of scalars, iterators, or other nonterminal nodes. The class <i>Scalar</i> is used to wrap noncontainer objects, like integers, which have a constant value wherever the expression is evaluated. Finally, the class <i>Expression</i> wraps nonterminal nodes and thereby provides a common interface for all expression objects.</p><p>PETE knows how to store nonterminal nodes and scalars in the expression parse tree, but it must be told how to store the container objects that are passed as arguments to the operator functions. This is done in <A NAME="rl1"><A HREF="#l1">Listing One</A> by specializing the <i>CreateLeaf</i> class for <i>vector&lt;T, Allocator&gt;</i>. There are basically two choices: You can store a helper class like an iterator or you can store a reference to the container class itself. To store an iterator as in <A NAME="rf1"><A HREF="9910hf1.htm">Figure 1</A>, you simply provide a <i>Leaf_t typedef</i> that specifies that a <i>const_iterator</i> is to be stored at the leaves and a make member function that takes a container as an argument and turns it into a <i>Leaf_t</i> by simply calling <i>vector</i>'s <i>begin</i> function. Classes for which <i>CreateLeaf</i> is not specialized are assumed to be scalar objects.</p><p>By default, PETE supports 45 built-in operators including all of the C++ mathematical operators along with a collection of common mathematical functions like <i>sin()</i>. A <i>where(a,b,c)</i> function is also provided since the conditional expression <i>a ? b : c</i> cannot be overloaded. PETE includes an easy-to-use tool called "MakeOperators" to automatically generate all of the required functions. For example, the four-line MakeOperators input file in <A NAME="re2"><A HREF="9910he2.htm">Example 2</A> produces the approximately 4000 lines of code and 249 functions needed to fully support arithmetic involving STL vectors. These functions are written to the Listing1Operators.h file (see <A NAME="rl1"><A HREF="#l1">Listing One</A>). As <A NAME="re2"><A HREF="9910he2.htm">Example 2</A> shows, a MakeOperators class specification consists of the template arguments (ARG) and the class (CLASS). MakeOperators substitutes unique numbers for the string <i>"[n]"</i> to number the arguments for binary and ternary operators. MakeOperators can also be used to add custom functions to the expression-template system.</p><p>MakeOperators can generate global assignment operator functions such as <i>operator+=</i>. This feature is optional so you can define your own assignment operators if you want. MakeOperators can also generate an assign function to handle straight assignment for classes, like the standard vector, where it is not possible to add an <i>operator=</i> member function. Therefore, if you are willing to put up with somewhat awkward syntax like <i>assign(X,Y+Z)</i> in lieu of <i>X=Y+Z</i>, it is possible to add expression-template functionality to a class without changing or adding any member functions.</p><p><A NAME="re3"><A HREF="9910he3.htm">Example 3</A> shows the generated definition of <i>operator+=</i> for accumulating a PETE expression into an STL vector. This passes the arguments along with an applicative operator functor, <i>OpAddAssign</i>, on to a user-supplied evaluate function. Delegating the actual assignment operation to a functor allows a single evaluate function to be used by all of the various assignment operators. </p><p><A NAME="rl1"><A HREF="#l1">Listing One</A> contains the evaluate function for our STL vector example. This function iterates through the elements of the container, assigning the values computed from the expression on the right-hand side (RHS) of the assignment operator to the appropriate elements of the container on the left-hand side (LHS).</p><p>Because we store iterators in the expression tree, evaluation consists of two parts. First, for each iterator position, the RHS expression must be dereferenced and assigned to the LHS container. Second, the iterators stored in the RHS expression must be bumped to the next element. The first of these tasks is performed by</p><blockquote><p>op(*iterLHS, forEach(rhs, DereferenceLeaf(), 		            OpCombine()));</p></blockquote><p>Here <i>op</i> is our applicative operator functor object. This call to its <i>operator()</i> will perform the appropriate assignment. For example, if <i>op</i> is an <i>OpAddAssign</i> object, this code inlines to</p><blockquote><p>*iterLHS += forEach(rhs, DereferenceLeaf(), 		           OpCombine()));</p></blockquote><p>The <i>forEach</i> function is the most important tool in PETE. This function performs a compile-time post-order parse-tree traversal (see "Generic Programming in POOMA and PETE," by James A. Crotinger, Julian Cummings, Scott Haney, William Humphrey, Steve Karmesin, John Reynders, Stephen Smith, and Timothy J. Williams, <i>Lecture Notes in Computer Science</i>, 1999). Its general form is:</p><blockquote><p>forEach(Expression, LeafTag, CombineTag);</p></blockquote><p>This function call traverses the nodes of the <i>Expression</i> object, applying an operation selected by <i>LeafTag</i> at the leaves, and combining the results from nonleaf nodes' children according to <i>CombineTag</i>. In our example, each leaf iterator is dereferenced (as indicated by the <i>DereferenceLeaf</i> tag), and the results are combined using the operators stored at the nonleaf nodes (as indicated by the <i>OpCombine</i> tag). Thus, if RHS represents <i>-B + 2 * C</i>, the <i>forEach</i> call above will inline to the code</p><blockquote><p>-*iterB + 2 * *iterC,</p></blockquote><p>where <i>iterB</i> and <i>iterC</i> are the current values of the iterators to vectors B and C, respectively. Dereferencing STL iterators and combining results according to arithmetic rules are common operations. Therefore, PETE predefines the actions associated with <i>DereferenceLeaf</i> and <i>OpCombine</i> (as well as several others). After evaluating the expression, the leaf iterators are bumped by applying the <i>IncrementLeaf</i> operation at the leaves and ignoring the return values by specifying the <i>NullCombine</i> tag:</p><blockquote><p>forEach(rhs, IncrementLeaf(), </p><p>		NullCombine());</p></blockquote><p>This call inlines to</p><blockquote><p>++iterB; ++iterC;</p></blockquote><p>Thus, we see that evaluate expands to precisely the code in <A NAME="re1"><A HREF="9910he1.htm">Example 1</A>.</p><h3>Advanced Examples</h3><p>Extending the aforementioned example to allow vectors and lists to be mixed in expressions turns out to be simple using PETE's tools. First, modify the MakeOperators input file to add entries for <i>list</i>, as in <A NAME="re4"><A HREF="9910he4.htm">Example 4</A>. Then add a custom <i>CreateLeaf</i> specialization for <i>list, </i>storing an iterator in the leaf nodes, and a custom evaluate function that can deal with a list on the left side. <A NAME="rl2"><A HREF="#l2">Listing Two</A> demonstrates the mixed usage.</p><p>You can easily extend evaluation of STL vector expressions to check for size conformance (source code that illustrates this is available electronically; see "Resource Center," page 5). This introduces important techniques for extending PETE's functionality. The necessary operators are the same as in the first example, so you can reuse the MakeOperators file in <A NAME="re2"><A HREF="9910he2.htm">Example 2</A>. There is a new wrinkle here though. We need to access the vector objects themselves at the leaves because a vector's size cannot be inferred from a single iterator. By default, PETE stores leaves by value, which is appropriate for iterators or for container classes with shallow copy semantics. However, vectors have deep copy semantics, so we must modify PETE's behavior to have it store references to the vectors in the leaves. This requires a straightforward modification to <i>CreateLeaf</i> to wrap the container in a <i>Reference </i>object that tells PETE's nonterminal nodes to store it by reference.</p><p>Conformance testing is done by passing the size of the LHS container down to the leaves, with each leaf comparing the LHS size with its own and returning a <i>bool </i>to indicate conformance. To do this, you first define a <i>SizeLeaf</i> tag to express the fact that you want to check size conformance at the leaves. This tag is initialized with the size of the LHS, and it uses <i>operator()(int)</i> to compare its value with the argument. The actual leaf operations are delegated to the <i>LeafFunctor</i> class, which is templated on the leaf type and on the leaf tag. You specify PETE's actions on the expression's leaves by specializing <i>LeafFunctor</i> for a particular combination of leaf type and tag. <i>LeafFunctor</i> must supply an <i>apply</i> method that performs the desired action and a <i>Type_t typedef</i> giving <i>apply</i>'s return type. When you introduce a new leaf tag (one that is not already defined in PETE), you must tell PETE what to do when it applies this tag to a leaf that contains a scalar value. This is done by specializing <i>LeafFunctor</i> for your tag and <i>Scalar&lt;T&gt;</i>. In this case, <i>apply</i> is specialized to return True for scalars (they always conform), and to invoke the <i>SizeLeaf</i> test on the leaf's size if the leaf is a vector.</p><p>Because the leaves contain vectors instead of iterators, the <i>evaluate</i> function must be modified. PETE provides an <i>EvalLeaf1</i> tag that expresses the desire to evaluate a container at a particular index, which is stored as a data member of the <i>EvalLeaf1</i> object. Although PETE supplies this tag, you have to tell PETE explicitly what this means for your container class. For the case of applying the <i>EvalLeaf1</i> operation to an STL vector, you simply extract the index from the <i>EvalLeaf1</i> object and return the appropriate element from the vector. Finally, you can write <i>evaluate</i>. It is similar to the first example, except that it includes a conformance test based on the value returned from:</p><blockquote><p>forEach(rhs, SizeLeaf(lhs.size()), </p><p>	         AndCombine());</p></blockquote><p>This traverses the parse tree, checking conformance of the leaves with <i>lhs.size()</i>, and combining the results with <i>AndCombine</i>, which simply takes the logical AND of the results from a node's children. This will return True if all of the leaves conform, in which case you then loop through the elements, evaluating the RHS at the <i>i</i>th element with:</p><blockquote><p>forEach(rhs, EvalLeaf1(i), OpCombine())</p></blockquote><p>The final example is the most complex, demonstrating the use of PETE to synthesize types. These types can be used to implement compile-time polymorphism, whereby highly efficient custom code can be generated based on the types involved in an expression. The goal here is to write a function, <i>elem(expression, i)</i>, that evaluates the expression for the <i>i</i>th element of each term, where the terms can be either list or vector objects. If all of the leaves are vectors, the iterators in the leaves are directly offset and dereferenced. If any of the leaves contain lists, the iterators are first advanced to the appropriate position before dereferencing. Thus, the <i>elem</i> function has to determine the most general (lowest-common-denominator) iterator type for the expression and then perform the appropriate action depending on this type. This example is a bit simplistic: Instead of repeatedly incrementing the iterators, <i>elem</i> could just use the STL advance algorithm, in which case this type synthesis would be unnecessary to obtain an efficient evaluation. However, the principles here are applicable to more advanced situations.</p><p>To access the iterator types in an expression, you first need to add a new leaf tag, <i>GetIteratorTagLeaf</i>, and specialize <i>LeafFunctor</i> to define <i>Type_t</i> to be the iterator tag for each possible leaf type (source code that illustrates this is available electronically). You do not need to define an apply method here (or in the <i>Combine2</i> functors) because this function is not used in type computations. Next, you specialize the <i>Combine2</i> functor. <i>Combine2</i> is only applied to binary-tree nodes in the parse tree. Its template parameters are the types of the node's left and right children, the applicative operator type (ignored here), and the combine-tag type. You define a new combine tag, <i>IteratorTagCombine</i>, and specialize on the various combinations of iterator tags to define <i>Combine2::Type_t</i> to be the most general iterator tag of the ones returned from the children. Thus, <i>LeafFunctor</i> will get the iterator tag types appropriate for the containers in the expression. These types are propagated up, and <i>Combine2</i> selects the most general iterator type. This is further propagated up and combined with results from other subtrees until the root is reached, at which point the most general iterator for the entire expression will be determined.</p><p>Finally, you write the <i>elem</i> functions. The general one takes an expression and an offset. Here you see the direct use of the template metaprogram class <i>ForEach</i>. The <i>forEach</i> function used in most of this article is simply a template function wrapper for <i>ForEach::apply()</i>. This is done because template functions can infer their template parameters from their arguments, thus providing a simpler interface. However, for type computations you must use <i>ForEach</i> directly. <i>ForEach::Type_t</i> is the return type of the <i>forEach</i> function. This fact is used to deduce the return type for the <i>elem</i> function. Inside of <i>elem</i>, you use <i>ForEach</i> to deduce the appropriate iterator tag for the whole expression. The <i>typedef</i> statement, defining <i>IteratorTag_t</i>, will cause the <i>ForEach</i> template metaprogram to go through the expression, performing the type computation outlined earlier. You then use the resulting iterator tag type to select the appropriate overloaded version of <i>elem</i>. These are straightforward extensions of our earlier examples.</p><h3>Conclusion </h3><p>PETE is a powerful, yet easy-to-use, framework for adding expression-template functionality to a container class. You simply define a few external traits classes and provide a few lines of input to a tool that writes a required header file. PETE can also be used in a completely external manner, without making any changes to the user's container classes. Finally, PETE can be used for more general expression manipulations, such as conformance checking and type synthesis.</p><h3>Acknowledgment</h3><p>This work was performed under the auspices of the U.S. Department of Energy by Los Alamos National Laboratory under contract #W-7405-ENG-36.</p><p></p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>#include &lt;iostream.h&gt;#include &lt;vector.h&gt;#include "PETE/PETE.h"#include "Listing1Operators.h"// We need to specialize the CreateLeaf traits class for STL vectors so that// operators know what to stick in the leaves of the expression tree. In this// case, we store a const_iterator at the leaves.template&lt;class T, class Allocator&gt;struct CreateLeaf&lt;vector&lt;T, Allocator&gt; &gt;{  typedef typename vector&lt;T, Allocator&gt;::const_iterator Leaf_t;  inline static Leaf_t make(const vector&lt;T, Allocator&gt; &amp;a)                                               { return a.begin(); }};// Loop over vector and evaluate the expression at each location.template&lt;class T, class Allocator, class AssignOp, class RHS&gt;inline void evaluate(vector&lt;T, Allocator&gt; &amp;lhs,                                        const AssignOp &amp;op, const RHS &amp;rhs){  typename vector&lt;T, Allocator&gt;::iterator iterLHS = lhs.begin();  while (iterLHS != lhs.end())    {      // The actual assignment operation is performed here. PETE operator       // tags all define operator() to perform the operation. (In this case       // op performs an assignment operation.) forEach is used to compute       // the rhs value. DereferenceLeaf gets the values at each node by      // deferencing an iterator, and the tag OpCombine tells forEach to use      // the operator tags in the expression to combine values together.      op(*iterLHS, forEach(rhs, DereferenceLeaf(), OpCombine()));      // Increment the LHS iterator.      iterLHS++;      // Now, we have to increment the iterators for everything on the RHS.      // The results don't need to be combined so we use a NullCombiner.      forEach(rhs, IncrementLeaf(), NullCombine());    }}int main(){  int i;  const int n = 10;  vector&lt;double&gt; A, C, E(n);  vector&lt;int&gt; B, D;  for (i = 0; i &lt; n; ++i)    {      A.push_back(i);      B.push_back(2*i);      C.push_back(3*i);      D.push_back(i);    }  A += -B + 2 * C;  assign(B, 2);  assign(D, A + B * C);  A += where(D &lt; 30, B, C);  assign(E, C);  E += E - 4 / (sin(C) + 1);  for (i = 0; i &lt; n; ++i)    {      cout &lt;&lt; " A[" &lt;&lt; i &lt;&lt; "] = " &lt;&lt; A[i]           &lt;&lt; " B[" &lt;&lt; i &lt;&lt; "] = " &lt;&lt; B[i]           &lt;&lt; " C[" &lt;&lt; i &lt;&lt; "] = " &lt;&lt; C[i]           &lt;&lt; " D[" &lt;&lt; i &lt;&lt; "] = " &lt;&lt; D[i]           &lt;&lt; " E[" &lt;&lt; i &lt;&lt; "] = " &lt;&lt; E[i]           &lt;&lt; endl;    }  return 0;}</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>#include &lt;iostream.h&gt;#include &lt;list.h&gt;#include &lt;vector.h&gt;#include "PETE/PETE.h"#include "Listing2Operators.h"// We need to specialize the CreateLeaf traits class for STL vectors and lists// so that operators know what to stick in the leaves of the expression tree.// In these cases, we store const_iterators at the leaves.template&lt;class T, class Allocator&gt;struct CreateLeaf&lt;vector&lt;T, Allocator&gt; &gt;{  typedef typename vector&lt;T, Allocator&gt;::const_iterator Leaf_t;  inline static Leaf_t make(const vector&lt;T,Allocator&gt; &amp;a) { return a.begin();}};template&lt;class T, class Allocator&gt;struct CreateLeaf&lt;list&lt;T, Allocator&gt; &gt;{  typedef typename list&lt;T, Allocator&gt;::const_iterator Leaf_t;  inline static Leaf_t make(const list&lt;T, Allocator&gt; &amp;a) { return a.begin(); }};// Loop over vector and evaluate the expression at each location.template&lt;class T, class Allocator, class Op, class RHS&gt;inline void evaluate(vector&lt;T, Allocator&gt; &amp;lhs, const Op &amp;op, const RHS &amp;rhs){  for (int i = 0; i &lt; lhs.size(); ++i)    {      // The actual assignment operation is performed here.      // PETE operator tags all define operator() to perform the operation.      // (In this case op performs an assignment operation.)      // forEach is used to compute the rhs value.  DereferenceLeaf gets the      // values at each node by deferencing an iterator, and the tag      // OpCombine tells forEach to use the operator tags in the expression      // to combine values together.      op(lhs[i], forEach(rhs, DereferenceLeaf(), OpCombine()));      // Now, we have to increment the iterators for everything on the RHS.      // The results don't need to be combined so we use a NullCombiner.      forEach(rhs, IncrementLeaf(), NullCombine());    }}// Loop over list and evaluate the expression at each location.template&lt;class T, class Allocator, class Op, class RHS&gt;inline void evaluate(list&lt;T, Allocator&gt; &amp;lhs, const Op &amp;op, const RHS &amp;rhs){  typename list&lt;T, Allocator&gt;::iterator i = lhs.begin();  while (i != lhs.end())    {      // The actual assignment operation is performed here.      // PETE operator tags all define operator() to perform the operation.      // (In this case op performs an assignment operation.)      // forEach is used to compute the rhs value.  DereferenceLeaf gets the      // values at each node by deferencing an iterator, and the tag      // OpCombine tells forEach to use the operator tags in the expression      // to combine values together.      op(*i++, forEach(rhs, DereferenceLeaf(), OpCombine()));      // Now, we have to increment the iterators for everything on the RHS.      // The results don't need to be combined so we use a NullCombiner.      forEach(rhs, IncrementLeaf(), NullCombine());    }}int main(){  int i;  const int n = 10;  vector&lt;double&gt; A, C;  vector&lt;int&gt; B;  list&lt;int&gt; D;  list&lt;double&gt; E;  for (i = 0; i &lt; n; ++i)    {      A.push_back(i);      B.push_back(2*i);      C.push_back(3*i);      D.push_back(i);      E.push_back(0.0);    }  A += -B + 2 * C;  assign(B, 2);  assign(D, A + B * C);  A += where(D &lt; 30, B, C);  assign(E, C);  E += E - 4 / (sin(C) + 1);  list&lt;int&gt;::const_iterator di = D.begin();  list&lt;double&gt;::const_iterator ei = E.begin();  for (i = 0; i &lt; n; ++i)    {      cout &lt;&lt; " A[" &lt;&lt; i &lt;&lt; "] = " &lt;&lt; A[i]           &lt;&lt; " B[" &lt;&lt; i &lt;&lt; "] = " &lt;&lt; B[i]           &lt;&lt; " C[" &lt;&lt; i &lt;&lt; "] = " &lt;&lt; C[i]           &lt;&lt; " D[" &lt;&lt; i &lt;&lt; "] = " &lt;&lt; *di++           &lt;&lt; " E[" &lt;&lt; i &lt;&lt; "] = " &lt;&lt; *ei++           &lt;&lt; endl;    }  return 0;}</pre><P><A HREF="#rl2">Back to Article</A></P><HR><I>Copyright &copy; 1999, Dr. Dobb's Journal</I><BR>
</body></html>