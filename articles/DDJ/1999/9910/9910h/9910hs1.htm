<html><head><title>Oct99: Applicative Operator Functors</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h2>Applicative Operator Functors</h2><p>The amount of code required to write PETE is greatly reduced through the use of applicative operator functors. These functor classes overload <i>operator()</i> to perform the desired operation. They allow us to construct generic classes, such as <i>BinaryNode</i>, that work with arbitrary operators, thus greatly reducing code duplication. Due to their generic nature, these functors can be a bit tricky to write. For example, <i>OpMultiply'</i>s <i>operator()</i> looks like:</p><blockquote><p>template&lt;class T1, class T2&gt;</p><DDJADVERTISEMENT INLINE><p>inline typename </p><p>BinaryReturn&lt;T1, T2, OpMultiply&gt;::Type_t</p><p>OpMultiply::operator()(const T1 &amp;a, </p><p>		    constT2 &amp;b) const</p><p>{ return (a * b); }</p></blockquote><p>The return type is generated by the <i>BinaryReturn</i> traits class using the two input types and the operation type. Therefore, if <i>T1</i> is an <i>int</i> and <i>T2</i> is a <i>double</i> (as in the "2 * C" part of the expression in <A NAME="rf1"><A HREF="9910hf1.htm">Figure 1</A>), this function will do the correct promotion to double. PETE knows how to perform operations on the built-in C++ types, so an expression involving <i>vector&lt;int&gt;</i> and <i>vector&lt;double&gt;</i> objects requires no special code. Moreover, adding new types and operations involves only a few specializations.</p><p>--S.H.</p><a href="9910h.htm#rs1">Back to Article</a><HR><I>Copyright &copy; 1999, Dr. Dobb's Journal</I><BR>
</body></html>