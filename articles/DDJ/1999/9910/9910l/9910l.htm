<html><head><title>Oct99: Algorithm Alley</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Median Filtering</h1><p><i>Dr. Dobb's Journal</i> October 1999</p><h2>A useful tool for  digital signal processing</h2><h3>By Wesley Bylsma</h3><I>Wesley is a project engineer with the U.S. Army Research, Development and Engineering Center in Warren, Michigan. He can be contacted at bylsmaw@tacom.army.mil.</I><hr><p>There are many different kinds of filters, each with distinct advantages for a particular application. Mechanical filters, for instance, are used to filter out specific sizes of particles from water or dirt, while capacitors and inductors only pass high- or low-frequency electrical signals. The field of digital signal processing, however, is concerned with the development of information filters. Given a signal, or set of data points, how can the data be manipulated to achieve a desired output signal that meets the goals of a problem. "Discontiguous Exponential Averaging," by John C. Gunther (<i>DDJ</i>, September 1998) discussed exponential filtering and highlighted one type of informational filter used in adapting network protocols. For the purpose of removing impulsive signal noise while maintaining signal trends, I will present the use of median filtering.</p><p>Given a discrete set of data points, the median filter is defined as</p><DDJADVERTISEMENT INLINE><blockquote><p><i>y[n]=median(x[n-k],...,x[n],...,x[n+k])</p></blockquote><p>where </i>N=2<i>k</i>+1 is known as the filter window length. Notice the difference from an averaging filter which is defined as</p><blockquote><p><i>y[n]=sum(x[n-k],...,x[n],...,x[n+k])/N</i></p></blockquote><p>The median filter always selects an actual data point from the input signal, whereas the averaging filter calculates a new point. </p><p><A NAME="rl1"><A HREF="#l1">Listing One</A> is a MATLAB (http://www .mathworks.com/) median filter function. Note that <i>L=k</i> for the function call. The signal is extended by the endpoints at the beginning and end so the filter window will be full at the original signal starting point. For each input signal data point, the filter window values are sorted and the middle value is chosen to replace the original signal value. If the length of any impulsive noise is more than <i>k</i>+1 the filter will have no effect on it. If the noise width is less than <i>k</i>+1 it will be removed completely. You can see that the window length affects how well the filter will work on various types of noise inputs. The bigger the window length, the smoother the signal will be. For smaller window lengths, the filtered signal follows the original more closely.</p><p><A NAME="rf1"><A HREF="9910lf1.htm">Figure 1</A> shows a comparison between median filtering and averaging filtering to remove random noise from a square wave pulse. As you can see, the median filter closely recovers the original signal embedded with noise. The difference between the original signal with no noise is markedly greater for the averaging filter at the square wave pulse edges. Median filtering is particularly good at preserving trends or signal edges.</p><p><A NAME="rf2"><A HREF="9910lf2.htm">Figure 2</A> illustrates the capability of removing impulsive signal noise. The first pane shows (<i>k</i>=30) the trend preservation characteristic. To more fully illustrate the removal of signal noise, panes 2 and 3 show the filtering results with window length <i>N</i>=7 (<i>k</i>=3). Both impulses are removed in pane 2 but nothing is changed in pane 3. <A NAME="rt1"><A HREF="9910lt1.htm">Table 1</A> lists some definitions that help define and understand how median filters work. Pane 3 of <A NAME="rf2"><A HREF="9910lf2.htm">Figure 2</A> is obviously a root signal for a filter window length of <i>N</i>=7 (<i>k</i>=3) since the filtering process produced no change.</p><p>Finding the root signal may take more than one filtering pass. In <A NAME="rf3"><A HREF="9910lf3.htm">Figure 3</A>, pane 3 took two passes to achieve the root signal. It is possible to use a recursive median filter defined as</p><blockquote><p><i>y[n]=median(y[n-k],...,y[n-1],x[n], x[n+1],...,x[n+k])</p></blockquote><p>to achieve the root signal in only one pass. However, starting with an arbitrary signal using the recursive median filter or multiple nonrecursive filtering may not result in the same root signal.</p><h3>Variations of  Median Filtering</h3><p>Because median filtering is nonlinear, it does not have nice properties such as linear filters do. One property it does have, however, is that of threshold decomposition that approximates the superposition principle of linear filters. In principle, it states that given an integer valued signal </i>x[n], with <i>M</i> discrete sample values, the signal can be decomposed into <i>M</i>-1 binary signals as in <A NAME="re1"><A HREF="9910le1.htm">Example 1</A> for <i>m</i>=1 to <i>M</i>-1. Reconstruction of the original signal is then shown in <A NAME="re2"><A HREF="9910le2.htm">Example 2</A>.</p><p>Application of the median filter to the original signal is equivalent to applying the filter to each decomposed binary signal and then adding them up. <A NAME="rf4"><A HREF="9910lf4.htm">Figure 4</A> illustrates this principle. This technique can be applied to noninteger signals if they are quantized to <i>M</i> levels.</p><p>Even more interesting is the fact that the median filter on a binary signal (0 or 1) is a simple majority decision. If there are more 1s, then the output is a 1. If there are more 0s, then the output is a 0. Consider a window length <i>N</i>=3 (<i>k</i>=1) median filter. The binary combinations are:</p><blockquote>xyz m<br><br>000 0<br>001 0<br>010 0<br>011 1<br>100 0<br>101 1<br>110 1<br>111 1<br></blockquote><p>where <i>m</i> denotes the majority outcome. Using Boolean algebra, the value for <i>m</i> is defined in <A NAME="re3"><A HREF="9910le3.htm">Example 3</A>.</p><p>Using the principle of decomposition, you could implement in hardware using AND, OR, and other logic gates of the median filtering function.</p><p>Another variation of the median filter is the weighted median filter. Here, weights are given to vary the influence each sample has in the filter. New filter properties can be explored by giving more weight to specific filter window positions. Each filter window position is assigned a weight <i>w<sub>i</i></sub>. The definition of the weighted median filter is then</p><blockquote><p><i>y[n]=median(w<sub>i</sub><img src="diam12.gif" width="12" height="17">x[n-k],...,W<sub>k+</i>1</sub><i><img src="diam12.gif" width="12" height="17">x[n],...,W<sub>N</sub><img src="diam12.gif" width="12" height="17">x[n+k])</i></p></blockquote><p>where "<img src="diam12.gif" width="12" height="17">" denotes replication of that signal data point.</p><p>Median filters can even be expanded into the 2D realm for image processing applications. Here a two-dimensional window is used. For a 3&times;3 square, the filter would be defined as</p><blockquote><p><i>y[m,n]=median(x[m-</i>1<i>,n+</i>1<i>], x[m,n+</i>1<i>], x[m+</i>1<i>,n+</i>1<i>], x[m-</i>1<i>,n], x[m,n], x[m+</i>1<i>,n], x[m-</i>1<i>,n-</i>1<i>], x[m,n-</i>1<i>], x[m+</i>1<i>,n-</i>1<i>])</i></p></blockquote><p>The median value inside the window is used as the filter output.</p><h3>Conclusion</h3><p>Clearly, median filters are useful tools in digital signal processing. Their properties of maintaining signal trends while removing unwanted impulsive noise are unique and they require only one parameterthe window size. The window size lets them be flexible for adaptation to specific problems. Their unique structure enables variations of the standard median filter to include threshold decomposition, weighted median filtering, recursive median filtering, and even application into two dimensions. Other extensions and derivations of the basic median filter are possible and I refer you to Internet searches under "Median Filters" or "Nonlinear Signal and Imaging Processing" and to the reference for further insights.</p><h3>References</h3><p>Mitra, S.K., Kaiser, J.F. <i>Digital Signal Processing Handbook</i>, John Wiley &amp; Sons, 1993, ISBN 0-471-61995-7.</p><p></p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>% [y]=medianL(x,L) calculates the median over N=2L+1 of x% INPUT:%  x - input signal%  L - interval (N=2L+1)%% OUTPUT:%  y - median of interval N%function [y]=medianL(x,L);% get the signal lengthl=length(x);%extend the end points so that filter window is fullx=[x(1)*ones(1,L),x',x(l)*ones(1,L)]';%at each data point, sort values in window and pick middle onefor i=1:l,t=sort(x(L+i-L:L+i+L));% k &lt;=Ly(i)=t(L+1);endy=y';</pre><P><A HREF="#rl1">Back to Article</A></P><HR><I>Copyright &copy; 1999, Dr. Dobb's Journal</I><BR>
</body></html>