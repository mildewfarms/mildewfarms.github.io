<html><head><title>Oct99: <b>DataStructures as Objects</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>DataStructures as Objects</h1><p><i>Dr. Dobb's Journal</i> October 1999</p><h2>Designing software ten-times more efficiently</h2><h3>By Jiri Soukup </h3><I>Jiri is president of CodeFarms and author of Taming C++: Pattern Classes and Persistence for Large Projects. He can be contacted at jiri@codefarms.com.</I><hr><p>In almost every case, software differs significantly from application to application. Telephone switches and airline reservations databases, for instance, aren't the same as C++ compilers, text editors, missile-control system, or stress calculations for concrete bridges. Consequently, it is unlikely that we could improve software productivity equally for such diverse applications.</p><p>In particular, complex programsthose which include a complex interaction among objectsemploy many data organizations (data structures or design patterns). They use so many, in fact, that practically every class participates in one or more data organization. Organizations such as collections, aggregates, graphs, or hash tables involve two classes; many-to-many involves three; pattern composites involve three or more; while a tree involves only one class. For examples of complex systems, see <A NAME="rt1"><A HREF="9910at1.htm">Table 1</A>.</p><DDJADVERTISEMENT INLINE><h3>An Example</h3><p><A NAME="rf1"><A HREF="9910af1.htm">Figure 1</A> illustrates an electrical circuit where blocks B1,B2,... have terminals T1,T2,... connected into nets N1,N2,... Nets represent only logical connections. A physical implementation of the circuit would represent connections as wires, composed of horizontal and vertical segments of certain width. A typical operation used in many algorithms is, for a given net, to find all the blocks to which it is attached or, for a given block, to find all adjacent nets.</p><p><A NAME="rf2"><A HREF="9910af2.htm">Figure 2</A> is the Unified Modeling Language (UML) diagram describing this problem. There are four classes involved in four one-to-many relations. Each terminal is attached to exactly one net and exactly one block. <A NAME="rl1"><A HREF="#l1">Listing One</A> shows how you would implement these relations in C. Because this implementation style is efficient both in space and in the access speed of the data, it is frequently used in performance-sensitive applications (sometimes even in C++ today).</p><p>Still, this implementation has problems:</p><ul>  <li>The numerous pointers implementing the data permeate structures, and unless you have a diagram at hand, you can't see what is going on. In this example, there are only four relations. Imagine a problem with 25 relations!  <li>It is easy to make an error in setting one of the pointers. Such errors cause program crashes, and are extremely hard to find. If you visited any programming department these days, you would find many programmers walking through the pointer chains with a debugger.  <li>Maintenance and modifications of such programs are difficult. Replacing or removing a data structure means, more or less, wading through the entire code.   <li>The same data structures are coded again and again, without any efficient code reuse.</ul><p>Most C++ programmers would likely implement this data organization using a collection class from a library, such as the Standard Template Library (STL) or Rogue Wave's tools.h++, which also have iterator classes associated with them. A good C++ implementation would also use a <i>String</i> class for all names, and <i>cout&lt;&lt;</i> instead of <i>printf()</i>, but that is not essential here. For instance, the C++ implementation in <A NAME="rl2"><A HREF="#l2">Listing Two</A> is an improvement over the C version in <A NAME="rl1"><A HREF="#l1">Listing One</A> in the following ways:</p><ul>  <li>Some, but not all, of the pointers disappeared from the class (structure) definitions, and even though you still have to walk through all the classes, it is easier to see the underlaying data organization.  <li>It is much less likely to make a pointer error, because we use safe, well-debugged library functions such as <i>Collection&lt;T&gt;::add()</i>.  <li>Modifications of this code are also easier. For example, if you remove collection <i>Circuit::blocks</i> from class <i>Circuit</i>, the compiler tells you about all the places that have to be modified.</ul><p>It may come as a surprise, but the C++ version implements a completely different data structure than the original C version. The reason is that practically all class libraries implement the collection not as a linked list, but as an array of pointers; see <A NAME="rl3"><A HREF="#l3">Listing Three</A>.</p><p>Why? Because this is the way collections are implemented in Smalltalk, and the first extensively used class librarythe NIH class library by Gorlen et al. (see <i>Data Abstraction and Object-oriented Programming in C++</i>, by K.E. Gorlen, S.M. Orlow, and P.S. Plexico, John Wiley 1990, ISBN 0-471-92346)followed the Smalltalk style. Generic linked lists can be implemented with C++ templates, but both the implementation and the use of array-based collections are easier. This, of course, is a chicken-and-egg situation, because templates were introduced after array-based collections were already in use, which influenced the design of templates.</p><p>Besides some effect on the required space and performance, this also means that the <i>Collection</i> is a <i>Bag</i>, instead of a <i>Set</i> as in the C version. In the original problem, a <i>Terminal</i> can be only under one net and one block. The <i>Collection</i> (<i>Bag</i>) is better suited for problems such as <A NAME="rf3"><A HREF="9910af3.htm">Figure 3</A>, where a student can take several courses. As <A NAME="rl4"><A HREF="#l4">Listing Four</A> illustrates, however, two <i>Collection</i>s are required if you need two-way access.</p><h3>Missed Opportunity</h3><p>By switching from linked lists to arrays of pointers, we missed an opportunity that improves the robustness and the quality of any data structure. When coding linked lists in both C and C++, it is much better to use rings, rather than NULL ending lists found in every textbook.</p><p>When an object is attached to a ring, its pointer is never NULL. When an object is disconnected, you can set all its pointers to NULL. This permits a checkin the run time and with only a few <i>if</i> statementsto determine whether or not an object can be safely added to the data structure or destroyed.</p><p>For example, in the C version in <A NAME="rl1"><A HREF="#l1">Listing One</A>, you can rewrite functions <i>addTermToNet()</i> and <i>addTermToBlock()</i> to be safer when adding an object to a list, or when destroying it; see <A NAME="rl5"><A HREF="#l5">Listing Five</A>. This technique must be used by the class library, not just by the application programmer. Since I started using it, I rarely need a debugger, and my data structures are free of errors more or less after the code compiles. By going to array-based collections, we deprived ourselves of this opportunity.</p><p>The C implementation is what is sometimes called an "intrusive data structure" because pointers or other values are inserted into the objects that participate in it. The array-based <i>Collection&lt;T&gt;</i> is an example of an "indirectly linked data structure" where you can add a collection of terminals to the <i>Circuit</i>, without adding any pointers or other members to the <i>Terminal</i> class (for more information, see my article series "Intrusive Data Structures," <i>The C++ Report</i>, May/July/October 1998).</p><p>Even though the C++ version is much better than the C one, it nonetheless suffers drawbacks:</p><ul>  <li>You can add the same terminal to two nets, and the program will not catch it. Also, if you destroy a terminal or a block that is part of the data structure, the program will mysteriously crashsometimes much later than the moment when this happened, and the error is extremely hard to find.  <li>The definition of the data structure is still spread through all the classes. In real-life applications, programs with more than 15 or 20 collections are common, and to keep track of how the data is connected is physically impossible, even for top-grade programmers.   <li>Some data structures are inherently intrusive. In <A NAME="rf1"><A HREF="9910af1.htm">Figure 1</A>, <i>Terminal</i> must have a pointer to <i>Net</i>. In <A NAME="rf3"><A HREF="9910af3.htm">Figure 3</A>, <i>Student</i> must have a <i>Collection&lt;Course&gt;</i>. This means that the definition of one data structure is spread over several classes.</ul><p>The first drawback can be solved by reference counting, but complicates the logic of the code, and implies performance and space penalties. The second and third drawbacks are the primary reasons for introducing graphical diagrams such as UML.</p><h3>Spaghetti++</h3><p>The fact that we need UML diagrams means that something in our programming style is out of control. We cannot follow what is going on. A similar thing happened in the past. Flowcharts were considered essential, until structured programming was invented. Very few people use flowcharts today.</p><p>Before we eliminated <i>goto</i> statements from programs, program statements created a complicated graph. Today, the graph is reduced to a tree, which is easier to follow. Prior to structured programming, we had a graph of statements. Now we have a graph of classes. The complexity moved one level up, but is showing its horns again. Part of this messiness is that data structures and design patterns are not represented as objects. They are built into our classes, but do not stand out as clearly defined entities.</p><p>Assume you design a hypothetical class library that provides a class for each data structure. To introduce a data structure into your code, you create an instance of that class, but you do not attach it to any of your objects. This class gives you the complete interface needed for the data structure. The pointers/arrays that form the data structure will beby some magicautomatically inserted under the statement <i>(className)</i> <i>PARTICIPATES. </i>This statement indicates that class "<i>className</i>" participates in one or more data structures. You don't want to know what is under that statement or how it got there; see <A NAME="rl6"><A HREF="#l6">Listing Six</A>.</p><p>This has a remarkable effect. The data structures completely disappeared from the class definitions, and are now all together as one compact schema definition. Those few lines are equivalent to a UML diagram, and an automatic conversion back and forth would be simple to implement. Our schema actually provides more information (implementation details) than the UML diagram, and because it is an integral part of the code, it can never be out of date. Hopefully, the library is implemented with rings, so it is also protected against pointer errors or mistakes in using the library.</p><p>If you want to start the architecture design without implementing specific details, you can limit yourself to one-to-many and many-to-many organizations in the beginning. As your design grows, you replace them later by some other data structure.</p><p>What I've said to this point can be interpreted in another way. Without any performance penalty, you are treating program internal data as a memory-resident, custom-designed database. You have the schema that describes the logic of the database, data integrity is guaranteed by implementing the data structures with rings, and methods of the hypothetical class library form the database interface.</p><p>If you work with the class libraries commonly in use today (see <A NAME="rl2"><A HREF="#l2">Listing Two</A>, for example), class <i>Block</i> has a member <i>termsOnBlock</i>, which is a collection of <i>Terminal</i>s. To add a terminal to this collection you write: </p><blockquote><p>    Block *bp; Terminal *tp;</p><p>    ...</p><p>    bp-&gt;termsOnBlock.add(tp);</p></blockquote><p>The logic of this statement says: "Go to block <i>bp</i>, get its data structure <i>termsOnBlock</i>, and add <i>tp</i> to it." This reflects the philosophy of the data structures being built-in and distributed throughout the application classes.</p><p>When using our hypothetical class library, there is a paradigm shift in how the data is accessed. The difference may appear insignificant, but it changes the concept of how you treat the data structures. Adding a terminal to a block now becomes:</p><blockquote><p>    Block *bp; Terminal *tp;</p><p>    ...</p><p>    termsOnBlock.add(bp,tp);</p></blockquote><p>This says: "Go to data structure <i>termsOnBlock</i> and, under block <i>bp</i>, add terminal <i>tp</i> to this data structure." The logic is different. Data structures have been elevated to the same level of visibility as application classes. If you want to know what data structure is involved here, you go to the schema and instantly see it.</p><p><A NAME="rf4"><A HREF="9910af4.htm">Figures 4</A>(a) and 4(b) show the difference between how the two different approaches look at the same data structure. In the new approach in <A NAME="rf4"><A HREF="9910af4.htm">Figure 4</A>(b), there is a duality between data objects and their relations. Relations (data structures) are treated as self-standing objects, not as something that must be attached to an application class. The new approach always gives you two rows of entities with easy-to-understand links between them, and if you encounter a reference to any data structure somewhere in the code, you just go the schema and see right away what the data structure does. For more complex data structures, the commonly used approach in <A NAME="rf4"><A HREF="9910af4.htm">Figure 4</A>(a) results in a network of many objects, which is difficult to interpret or remember. I call this situation "Spaghetti++."</p><h3>A New Approach</h3><p>The central idea of the new approach is to evolve one piece of code that compiles and runs correctly at all stages of the designeven as a preliminary architecture design. There is no rapid prototyping or code redesigns. The software is designed rapidly, but as it evolves into the final product, it is always testable and always correct.</p><p>You begin with a skeleton of all the classes you neednot many members in them yetas in <A NAME="rl6"><A HREF="#l6">Listing Six</A>. You define the data structure by typing in the schema, and then code some simple functions. For example, <i>howBig()</i> in <A NAME="rl7"><A HREF="#l7">Listing Seven</A> returns the current size of the problem. Such a function permits instant evaluation of<b> </b>the impact of changes in the size of the internal data; for example, when replacing a collection by a hash table.</p><p>Another useful function is <i>Circuit::autoCheck()</i>, which traverses the data in all chains and directions, and verifies that everything is correct. Calling this function is much more useful than walking through the data with a debugger. From the beginning of the project, I also like code functions such as those shown in <A NAME="rl7"><A HREF="#l7">Listings Seven</A> and Eight. Function <i>inputData()</i> lets you create tests for special situations, and <i>randomData()</i> lets you test for large, realistic data sets.</p><p>The system architect then gives the programmer a small running program with the schema in place. This improves the communication and ensures that the intended architecture is really implemented. The coding is easier with the schema always at hand.</p><p>Most of the errors related to the data organization are detected by the compiler. Remaining data errors are automatically detected at run time. Bugs caused by errors in the program logic cannot be prevented and must be found by standard methods, but these errors are usually easier to find, especially when data errors are immediately detected.</p><p>Testing is faster and much more thorough, because the program has been tested repeatedly during its evolution, using functions such as <i>autoCheck()</i>, <i>prtNets()</i>, and so on. With each new layer of logic, new test functions are added. </p><p>Every program eventually reaches the point where it has to be redesigned. When using the schema, even major changes to data organization are simple. For example, if you have the schema in <A NAME="rl6"><A HREF="#l6">Listing Six</A>:</p><blockquote><p>Collection&lt;Circuit,Block&gt;  blocks;</p><p>Collection&lt;Circuit,Net&gt;    nets;</p><p>Aggregate&lt;Block,Terminal&gt; termsOnBlock;</p><p>Aggregate&lt;Net,Terminal&gt;   termsOnNet;</p></blockquote><p>and decide to replace the <i>Collection</i> of blocks by a hash table and add to each <i>Circuit</i> a collection of all <i>Terminal</i>s, you just change the schema to:</p><blockquote><p></p><p>Hash&lt;Circuit,Block&gt;  blocks;</p><p>Collection&lt;Circuit,Net&gt;   nets;</p><p>Collection&lt;Block,Terminal&gt;termsOnBlock;</p><p>Aggregate&lt;Net,Terminal&gt;  termsOnNet;</p><p>Collection&lt;Circuit,Terminal&gt;   allTerms;</p></blockquote><p>The compiler pinpoints all places in the code that you have to update. Besides making modifications easy, the schema helps new programmers to quickly penetrate the organization of the data, and avoid costly mistakes.</p><h3>Persistent Data</h3><p>When the software requires storage of complex data to disk, 50 percent of the total development time (sometimes more) is spent on this task alone. Some C++ class libraries support serialization, but coding two serialization functions for every class is tedious and error prone. At one time, I had the opportunity to examine a commercial system for business data processing that had over 1 million lines of C++, one third of which were serialization functions. Because of the complexity of serialization functions, it reached the point that nobody dared to add any new features to that entire system. Also, serialization is the least efficient method of storing data to disk (see my book <i>Taming C++: Pattern Classes and Persistence for Large Projects</i>, Addison-Wesley 1994, ISBN 0-201-52826-6).</p><p>If we can supplement our hypothetical library by automatic persistence, which would not require coding serialization functions (as in Java, for example), we would also significantly improve the design processbut only for those applications that store data to disk. The mechanism can be implemented as a <i>DiskUtility</i> class, which we add to the schema:</p><blockquote><p>DiskUtility util;</p></blockquote><p>we call</p><blockquote><p>util.save("myFile",cp,"Circuit");</p></blockquote><p>when saving circuit <i>cp</i> and all connected data to <i>myFile</i>, or we call</p><blockquote><p>util.open("myFile",&amp;cp,"Circuit");</p></blockquote><p>when reading data from <i>myFile</i> and returning the new <i>cp</i> pointer.</p><p>In Java, you don't have to code serialization functions, but internally the storage mechanism uses serialization.</p><h3>Practical Results</h3><p>My company (CodeFarms) has implemented two libraries that closely resemble the hypothetical library described here. Data Object Library (DOL) (originally called Organized C++) uses a code generator to create blocks of pointers hidden under PARTICIPATES(...). It also generates functions that make the data persistent. The Pattern Template Library (PTL) uses C++ templates and multiple inheritance to implement the PARTICIPATES(...) code segments. It does not provide persistence. (Both manuals and versions of these libraries for major platforms and compilers are freely available at http://www.codefarms.com/.)</p><p>DOL includes several methods of automatic persistence, one of them (called "memory blasting") is an order of magnitude faster than serialization. DOL's drawback is that, prior to compilation, a code generator has to be called. The generator requires only 1/10 of the compilation time, and has to be called only when the schema, inheritance, or members of some classes changenot before every compilation. The code generator does not mangle existing source, it only generates a new header file, which must be included. However, the additional step is not smoothly supported by integrated environments such as Microsoft Developer Studio.</p><p>PTL's drawbacks are multiple layers of multiple inheritance, which are transparent but still make classes internally complex. In addition to data structures, PTL also provides design patterns not available in DOL such as Composite, Flyweight, and a fast, dynamically reconfigurable Finite State Machine.</p><p>In general, our experience is that, with this new approach, complex projects that do not need persistence can be developed three to five times faster, depending on how users are acquainted with the new technology. When persistence is required, a 5- to 10-fold improvement can be expected. Part of this success is that the new method decreases the required manpower, which in turn decreases the communication among people, which then results in an additional reduction of the required development time.</p><h3>Is STL a Good Standard?</h3><p>There is an interesting anomaly in STL: Its iterators are already coded in the style I recommend (independent interface classes), but its data organizations are designed to be either members ofor be inherited byapplication classes. It does not support the paradigm shift described here, and it does not provide multiway data structures such as aggregate, graphs, or many-to-many. Practically all STL classes are two-class, one-way organizations.</p><p>If the new approach dramatically improves the efficiency of the design process (and I believe I gave enough evidence), then STL should either be redesigned, replaced, or complemented with classes for two-way data structuressee Al Stevens's "C Programming" column (<i>DDJ</i>, December 1998) for an implementation of two-way data structures with STL.</p><h3>What About Java?</h3><p>Though Java's creators claim they removed pointers, Java's libraries still work with references and are subject to potential misuse as described for STL earlier. Java has automatic persistence, but it is based on serialization, and its performance is even poorer than that of the C++ serialization. </p><p>I can't figure out how to implement the hypothetical library in Javamaybe you can. DOL uses a code generator to create the PARTICIPATES() statements, and inserts them as macros. In PTL, PARTICIPATES() statements hide multiple inheritance. Neither method would work in Java.</p><p>Any language that allows a seamless implementation of the new approach<b> </b>will quickly topple all other languages because of the enormous potential to improve software productivity.</p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>struct Circuit {    Block *blocks;    Net *nets;};struct Block {    Block *next;    Terminal *term;    char *name;};struct Net {    Net *next;    Terminal *term;    char *name;};struct Terminal {    Block *nextOnBlock;    Block *nextOnNet;    Block *block;    Net *net;    char *name;};/* print all nets in the circuit */void prtNets(Circuit *c){    Net *np;    for(np=nets; np; np=np-&gt;next){        printf("%s\n",np-&gt;name);    }}/* print nets connected to block bp */void prtTerms(Block *bp){    Terminal *tp;    for(tp=bp-&gt;term; tp; tp=tp-&gt;next){        printf("%s\n",tp-&gt;net-&gt;name);    }}/* add Terminal to a Block */void addTermToBlock(Terminal *tp, Block *bp){    tp-&gt;nextOnBlock=bp-&gt;term;    bp-&gt;term=tp;    block=bp;}/* add Terminal to a Net */void addTermToNet(Terminal *tp, Net *np){    tp-&gt;nextOnNet=np-&gt;term;    np-&gt;term=tp;    tp-&gt;net=np;}/* create Terminal, attach it to block and net */Terminal *createTerminal(Block *bp, Net *np, char *name){    Terminal *tp; char *p;    tp=(Terminal*)malloc(sizeof(Terminal));    p=malloc(strlen(name)+1);    if(!tp || !p)return NULL;    addTermToBlock(tp,bp);    addTermToNet(tp,np);    strcpy(p,name);    tp-&gt;name=p;    return tp;}</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>template&lt;class T&gt; Collection {public:    void add(T *tp);    ...};template&lt;class T&gt; CollIterator {public:    CollIterator(Collection&lt;T&gt;&amp; col);    T* operator++();    ...};class Circuit {    Collection&lt;Block&gt; blocks;    Collection&lt;Net&gt; nets;public:    void prtNets();};class Block {    Collection&lt;Term&gt; termsOnBlock;    char *name;public:    void prtTerms();};class Net {    Collection&lt;Term&gt; termsOnNet;    char *name;};class Terminal {    Block *block;    Net *net;    char *name;public:    Terminal(Block *bp, Net *np, char *tName);};/* print all nets in the circuit */void Circuit::prtNets(){    Net *np;    CollIterator&lt;Net&gt; it(nets);    while(np= ++it){        printf("%s\n",np-&gt;name);    }}/* print nets connected to block bp */void Block::prtTerms(){    Terminal *tp;    CollIterator&lt;Terminal&gt; it(termsOnNet);    while(np= ++it){        printf("%s\n",tp-&gt;net-&gt;name);    }}/* replaces the original function createTerminal() */Terminal:Terminal(Block *bp, Net *np, char *tName){    name= new char[strlen(name)+1];    if(name)strcpy(name,tName);    bp-&gt;blocks.add(this);    block=bp;    np-&gt;nets.add(this);    net=np;    return tp;}</pre><P><A HREF="#rl2">Back to Article</A></P><H4><A NAME="l3">Listing Three</H4><pre>template&lt;class T&gt; Collection {    T **p;    int sz,used;    void growArray();public:    Collection(){p=NULL; sz=used=0;}    void add(T *tp){        if(used&gt;=sz)growArray();        p[used]=tp; used++;    }    ...};</pre><P><A HREF="#rl3">Back to Article</A></P><H4><A NAME="l4">Listing Four</H4><pre>class Course {    Collection&lt;Student&gt; students;    ...};class Student {    Collection&lt;Course&gt; courses;    ...};</pre><P><A HREF="#rl4">Back to Article</A></P><H4><A NAME="l5">Listing Five</H4><pre>void addTermToNet(Terminal *tp, Net *np){    if(tp-&gt;nextOnNet || tp-&gt;net){        printf("error: cannot add term=%x\n",tp);        return;    }    tp-&gt;nextOnNet=np-&gt;term;    np-&gt;term=tp;    tp-&gt;net=np;}/* returns NULL when np properly destroyed */Net *destroyNet(Net *np){    if(next || term || name){        printf("error: net=%x not disconnected\n",np);    }    else {free np; np=NULL;}    return np;}</pre><P><A HREF="#rl5">Back to Article</A></P><H4><A NAME="l6">Listing Six</H4><pre>// ---------- class library --------------------// In Collection, Child does not know its Parent.template&lt;class Parent, class Child&gt; Collection {public:    void add(Parent *pp, Child *cp);    ...};template&lt;class Parent, class Child&gt; CollIterator {public:    CollIterator(Parent *pp);    Child* operator++();    ...};// Aggregate is a Collection, where each Child keeps a pointer to its Parent.template&lt;class Parent, class Child&gt; Aggregate {public:    void add(Parent *pp, Child *cp);    ...};template&lt;class Parent, class Child&gt; AggrIterator {public:    AggrIterator(Parent *pp);    Child* operator++();    ...};// -------- application code -------------------class Circuit {    PARTICIPATES(Circuit);public:    void prtNets();};class Block {    PARTICIPATES(Block);    char *name;public:    void prtTerms();};class Net {    PARTICIPATES(Net);    char *name;};class Terminal {    PARTICIPATES(Terminal);public:    Terminal(Block *bp, Net *np, char *tName);};/* --------  DATA STRUCTURE SCHEMA -------- */Collection&lt;Circuit,Block&gt;  blocks;Collection&lt;Circuit,Net&gt;    nets;Aggregate&lt;Block,Terminal&gt; termsOnBlock;Aggregate&lt;Net,Terminal&gt;   termsOnNet;/* ---------------------------------------- *//* print all nets in the circuit */void Circuit::prtNets(){    Net *np;    CollIterator&lt;Circuit,Net&gt; it(this);    while(np= ++it){        printf("%s\n",np-&gt;name);    }}/* print nets connected to block bp */void Block::prtTerms(){    Terminal *tp;    AggrIterator&lt;Block,Terminal&gt; it(this);    while(np= ++it){        printf("%s\n",tp-&gt;net-&gt;name);    }}/* replaces the original function createTerminal() */Terminal:Terminal(Block *bp, Net *np, char *tName){    name= new char[strlen(name)+1];    if(name)strcpy(name,tName);    blocks.add(bp,this);    nets.add(np,this);    return tp;}</pre><P><A HREF="#rl6">Back to Article</A></P><H4><A NAME="l7">Listing Seven</H4><pre>int Circuit::howBig(int numBlocks,int numNets,int numTerminals){    return numBlocks*sizeof(Block) +           numNets*sizeof(Net) +           numTerminals*sizeof(Terminal);}</pre><P><A HREF="#rl7">Back to Article</A></P><H4><A NAME="l8">Listing Eight</H4><pre>    // input a small data set from a manually coded ascii file;void Circuit::inputData(char *fileName);    // generate large pseudorandom data of given sizevoid Circuit::randomData(int numTerms,int maxTermsOnNet,int				maxTermsOnBlock);</pre><P><A HREF="#rl8">Back to Article</A></P><HR><I>Copyright &copy; 1999, Dr. Dobb's Journal</I><BR>
</body></html>