<html><head><title>Oct99: Implementing  operator->* for Smart Pointers</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Implementing  <i>operator-&gt;*</i> for Smart Pointers</h1><p><i>Dr. Dobb's Journal</i> October 1999</p><h2>Classes and  member templates  for smart pointers</h2><h3>By Scott Meyers</h3><I>Scott is a C++ consultant and author of  Effective C++ CD-ROM, Effective C++, <i>and</i> More Effective C++. You can contact him at http://www.aristeia.com/.</I><hr><a name="rs1"><a href="9910bs1.htm">Partial Template Specialization and  <i>operator-&gt;*</i></a><hr><p>When I wrote <i>More Effective C++: 35 Ways to Improve Your Programs and Designs</i> (Addison-Wesley, 1995), one of the topics I examined was smart pointers. As a result, I get a fair number of questions about them, and one of the most interesting questions came from Andrei Alexandrescu who asked, "Shouldn't a really smart smart pointer overload operator-&gt;*? I've never seen it done." I hadn't seen it done, either, so I set out to do it. The result is instructiveand for more than just <i>operator-&gt;</i>*. It also involves insights into interesting and useful applications of templates.</p><h3>Review of <i>operator-&gt;*</i></h3><p>If you're like most programmers, you don't use <i>operator-&gt;</i>* on a regular basis. Consequently, before I explain how to implement this operator for smart pointers, I'll review the behavior of the built-in version. </p><DDJADVERTISEMENT INLINE><p>Given a class C, a pointer <i>pmf</i> to a parameterless member function of C, and a pointer <i>pc</i> to a C object, the expression</p><blockquote><p>(pc-&gt;*pmf)(); //  invoke the member  		     function *pmf on *pc</p></blockquote><p>invokes the member function pointed to by <i>pmf</i> on the object pointed to by <i>pc</i>. As you can see in <A NAME="rl1"><A HREF="#l1">Listing One</A>, pointers to member functions behave similarly to pointers to regular functions; the syntax is just a little more complicated. By the way, the parentheses around <i>pc-&gt;</i>*<i>pmf</i> are necessary, because the compiler would interpret</p><blockquote><p>pc-&gt;*pmf();  // error!</p></blockquote><p>as </p><blockquote><p>pc-&gt;*(pmf());  // error!</p></blockquote><h3>Designing Support for <i>operator-&gt;*</i></h3><p>Like many operators, <i>operator-&gt;</i>* is binary: It takes two arguments. When implementing <i>operator-&gt;</i>* for smart pointers, the left argument is a smart pointer to an object of type T. The right argument is a pointer to a member function of class T. The only thing that can be done with the result of a call to <i>operator-&gt;</i>* is to hand it a parameter list for a function call, so the return type of <i>operator- &gt;</i>* must be something to which <i>operator()</i> (the function call operator) may be applied. <i>operator-&gt;</i>*'s return value represents a pending member function call, so I'll call the type of object returned from <i>operator-&gt;</i>*,<i> PMFC</i> a "Pending Member Function Call."</p><p>Put all this together, and you get the pseudocode in <A NAME="rl2"><A HREF="#l2">Listing Two</A>. Because each <i>PMFC</i> object represents a pending call to the member function passed to <i>operator-&gt;</i>*, both the member function and <i>PMFC::operator()</i> expect the same list of parameters. To simplify matters, I'll assume that<i> T</i>'s member functions never take any arguments. (I'll remove this restriction below.) That means you can refine <A NAME="rl2"><A HREF="#l2">Listing Two</A> as <A NAME="rl3"><A HREF="#l3">Listing Three</A>. </p><p>But what is the return type of the member function pointed to by <i>pmf</i>? It could be <i>int</i>, <i>double</i>, or <i>const Wombat</i>&amp;. It could be anything. You express this infinite set of possibilities in the usual fashionby using a template. Hence, <i>operator-&gt;</i>* becomes a member function template. Furthermore, <i>PMFC</i> becomes a template, too, because different instantiations of <i>operator-&gt;</i>* must return different types of <i>PMFC</i> objects. (That's because each <i>PMFC</i> object must know what type to return when its <i>operator()</i> is invoked.)</p><p>After templatization, you can abandon pseudocode and write <i>PMFC</i> and <i>SP::operator-&gt;</i>*; see <A NAME="rl4"><A HREF="#l4">Listing Four</A>.</p><h3>Zero-Parameter Member Functions</h3><p><i>PMFC</i> represents a pending member function call, and needs to know two things to implement its <i>operator()</i>: the member function to call, and the object on which to invoke that member function. The <i>PMFC</i> constructor is the logical place to request these arguments. Furthermore, a standard pair object seems like a logical place to store them. That suggests the implementation in <A NAME="rl5"><A HREF="#l5">Listing Five</A>.</p><p>Though it may not look it at first glance, it's all pretty simple. When creating a <i>PMFC</i>, you specify which member function to call and the object on which to invoke it. When you later invoke the <i>PMFC</i>'s <i>operator()</i> function, it just invokes the saved member function on the saved object. </p><p>Note how <i>operator()</i> is implemented in terms of the built-in <i>operator-&gt;</i>*. Because <i>PMFC</i> objects are created only when a smart pointer's user-defined <i>operator-&gt;*</i> is called, that means that user-defined <i>operator-&gt;</i>*s are implemented in terms of the built-in <i>operator-&gt;</i>*. This provides nice symmetry with the behavior of the user-defined <i>operator-&gt;</i> with respect to that of the built-in<i> operator-&gt;</i>, because every call to a user-defined <i>operator-&gt;</i> in C++ ultimately ends in an (implicit) call to the built-in <i>operator-&gt;</i>. Such symmetry is reassuring. It suggests that the design is on the right track.</p><p>You may have noticed that the template parameters <i>ObjectType</i>, <i>ReturnType</i>, and <i>MemFuncPtrType</i> are somewhat redundant. Given <i>MemFuncPtrType</i>, it should be possible to figure out <i>ObjectType</i> and <i>ReturnType</i>. After all, both <i>ObjectType</i> and <i>ReturnType</i> are part of <i>MemFuncPtrType</i>. It is possible to deduce <i>ObjectType</i> and <i>ReturnType</i> from <i>MemFuncPtrType</i> using partial template specialization, but, because support for partial specialization is not yet common in commercial compilers, I've chosen not to use that approach here. For information on a design based on partial specialization, see the accompanying text box entitled "Partial Template Specialization and <i>operator-&gt;</i>*." </p><p>Given the implementation of <i>PMFC</i> in <A NAME="rl5"><A HREF="#l5">Listing Five</A>, <i>SP&lt;T&gt;</i>'s<i> operator-&gt;</i>* almost writes itself. The <i>PMFC</i> object it returns demands an object pointer and a member function pointer. Smart pointers conventionally store an object pointer, and the necessary member function pointer is just the parameter passed to <i>operator-&gt;</i>* as in <A NAME="rl6"><A HREF="#l6">Listing Six</A>. Consequently, the code in <A NAME="rl7"><A HREF="#l7">Listing Seven</A> should work, and for the compilers with which I tested it (Visual C++ 6 and egcs 1.1.2), it does.</p><p>Yes, I know, the code has a resource leak (the <i>new</i>ed <i>Wombat</i> is never <i>delete</i>d) and it employs a using directive (<i>using namespace std;</i>) when using declarations will do, but please try to focus on the interaction of <i>SP::operator-&gt;</i>*<i> </i>and <i>PMFC</i> instead of such relative minutiae. If you understand why the statements <i>(pw-&gt; </i>*<i>pmf)()</i> behave the way they do, there's no doubt you can easily fix the stylistic shortcomings of this example.</p><p>By the way, because both the <i>operator-</i>&gt;* member functions and all the <i>PMFC</i> member functions are (implicitly) inline, you may hope that the generated code for the statement </p><blockquote><p>(pw-&gt;*pmf)();</p></blockquote><p>using <i>SP</i> and <i>PMFC</i> will be the same as the generated code for the equivalent</p><blockquote><p>(pw.ptr-&gt;*pmf)();</p></blockquote><p>which uses only built-in operations. The run-time cost of using <i>SP</i>'s overloaded <i>operator-&gt;</i>* and <i>PMFC</i>'s overloaded <i>operator()</i> could thus be zerozero additional bytes of code, zero additional bytes of data. The actual cost, of course, depends on the optimization capabilities of your compiler as well as on your standard library's implementation of <i>pair</i> and <i>make_ pair</i>. For the two compilers (and associated libraries) with which I tested the code (after enabling full optimization), one yielded a zero-run-time-cost implementation of <i>operator-&gt;</i>*, but the other did not. </p><h3>Adding Support for  <i>const</i> Member Functions</h3><p>Look closely at the formal parameter taken by <i>SP&lt;T&gt;</i>'s <i>operator-&gt;</i>* functions: It's <i>ReturnType (T::</i>*<i>pmf)()</i>. More specifically, it's not <i>ReturnType (T::</i>*<i>pmf)() const</i>. That means no pointer to a <i>const</i> member function can be passed to <i>operator-&gt;</i>*, and that means that <i>operator-&gt;</i>* fails to support <i>const</i> member functions. Such blatant <i>const</i> discrimination has no place in a well-designed software system. Fortunately, it's easy to eliminate. Simply add a second <i>operator-&gt;</i>* template to <i>SP</i>, one designed to work with pointers to <i>const</i> member functions; see <A NAME="rl8"><A HREF="#l8">Listing Eight</A>. Interestingly, there's no need to change anything in <i>PMFC</i>. Its type parameter <i>MemFuncPtrType,</i> will bind to any type of member function pointer, regardless of whether the function in question is <i>const</i>.</p><h3>Adding Support for  Member Functions Taking Parameters</h3><p>With the zero-parameter case under our belt, let's move on to support for pointers to member functions taking one parameter. The step is surprisingly small, because all you need to do is modify the type of the member-pointer parameter taken by <i>operator-&gt;</i>*, then propagate this change through <i>PMFC</i>. In fact, all you really need to do is add a new template parameter to <i>operator-&gt;</i>* (for the type of the parameter taken by the pointed-to member function), then update everything else to be consistent. Furthermore, because <i>SP&lt;T&gt;</i> should support member functions taking zero parameters as well as member functions taking one parameter, you add a new <i>operator-&gt;</i>* template to the existing one. In <A NAME="rl9"><A HREF="#l9">Listing Nine</A>, I show only support for non<i>const</i> member functions, but <i>operator-&gt;</i>* templates for <i>const</i> member functions should be available, too.</p><p>Once you've got the hang of implementing support for zero and one parameters, it's easy to add support for as many as you need. To support member functions taking <i>n</i> parameters, declare two member template <i>operator-&gt;</i>*s inside <i>SP</i>, one to support non<i>const</i> member functions, one to support <i>const</i> ones. Each <i>operator-&gt;</i>* template should take <i>n</i>+1 type parameters, <i>n</i> for the parameters, and one for the return type. Add the corresponding <i>operator()</i> template to <i>PMFC</i>, and you're done. The source code for <i>operator-&gt;</i>*s taking up to two parameters (supporting both <i>const</i> and non<i>const</i> member functions) is available electronically; see "Resource Center," page 5.</p><h3>Packaging Support for <i>operator-&gt;</i><b>*</b></h3><p>Many applications have several varieties of smart pointers and it would be unpleasant to have to repeat the foregoing work for each one (for an example of the different varieties of smart pointers that can be imagined, plus some killer-cool C++, see Kevin S. Van Horn's web site at http:// www.xmission.com/ ~ksvsoft/code/smart_ ptrs.html). Fortunately, support for <i>operator-&gt;</i>* can be packaged in the form of a base class, as in <A NAME="rl10"><A HREF="#l10">Listing Ten</A>.</p><p>Smart pointers that wish to offer <i>operator-&gt;</i>* can then just inherit from <i>SmartPtrBase</i>. (This design applies only to smart pointers that contain dumb pointers to do the actual pointing. This is the most common smart pointer design, but there are alternatives. Such alternative designs may need to package <i>operator-&gt;</i>* functionality in a manner other than that described here.) However, it's probably best to use private inheritance, because the use of public inheritance would suggest the need to add a virtual destructor to <i>SmartPtrBase</i>, thus increasing its size (as well as the size of all derived classes). Private inheritance avoids this size penalty, though it mandates the use of a using declaration (see <A NAME="rl11"><A HREF="#l11">Listing Eleven</A>) to make the privately inherited <i>operator-&gt;</i>* templates public. To package things even more nicely, both <i>SmartPtrBase</i> and the <i>PMFC</i> template could be put in a namespace.</p><h3>Loose Ends</h3><p>After I'd developed this approach to implementing <i>operator-&gt;</i>* for smart pointers, I posted my solution to the Usenet newsgroup comp.lang.c++.moderated to see what I'd overlooked. It wasn't long before Esa Pulkkinen made these observations:</p><p></p><p>There are at least two problems with your approach:</p><p>1.	You can't use pointers to data members         (though this is easy enough to solve).</p><p>2.	You can't use user-defined pointers-to-members. If someone has overloaded <i>operator-&gt;* </i>to take objects that act like member pointers, you may want to support such "smart pointers to members" in your smart pointer class. Unfortunately, you need traits classes to get the result type of such overloaded <i>operator-&gt;*s.</i></p><p>Smart pointers to members! Yikes! Esa's right. (Actually, he's more right than I originally realized. Shortly after writing the draft of this article, one of my consulting clients showed me a problem that was naturally solved by smart pointers to members. I was surprised, too.) Fortunately, this article is long enough that I can stop here and leave ways of addressing Esa's observations in the time-honored form of exercises for the reader. So I will.</p><h3>Summary</h3><p>If your goal is to make your smart pointers as behaviorally compatible with built-in pointers as possible, you should support <i>operator-&gt;</i>*, just like built-in pointers do. The use of class and member templates makes it easy to implement such support, and packaging the implementation in the form of a base class facilitates its reuse by other smart pointer authors. </p><h3>Acknowledgments</h3><p>In addition to motivating my interest in <i>operator-&gt;</i>* in the first place, Andrei Alexandrescu helped me simplify my implementation of <i>PMFC</i>. Andrei also provided insightful comments on earlier drafts of this paper and the accompanying source code, as did Esa Pulkkinen and Mark Rodgers. I am greatly indebted to each of them for their considerable help with this article.</p><p></p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>class Wombat {          // wombats are cute Australian marsupialspublic:                 // that look something like dogs    int dig();          // return depth dug    int sleep();        // return time slept};typedef int (Wombat::*PWMF)(); // PWMF--a pointer to a Wombat member functionWombat *pw = new Wombat;  PWMF pmf = &amp;Wombat::dig;   // make pmf point to Wombat::dig(pw-&gt;*pmf)();              // same as pw-&gt;dig();pmf = &amp;Wombat::sleep;      // make pmf point to Wombat::sleep(pw-&gt;*pmf)();              // same as pw-&gt;sleep();</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two </H4><pre>class PMFC {               // "Pending Member Function Call"public:    ...    <b>return type</b> operator()( <b>parameters</b> ) const;    ...};template&lt;typename T&gt;        // template for smart ptrs-to-Tclass SP {                  // supporting operator-&gt;*public:    ...    const PMFC operator-&gt;*( <b>return type</b> (T::*pmf)(<b> parameters</b> ) ) const;    ...};</pre><P><A HREF="#rl2">Back to Article</A></P><H4><A NAME="l3">Listing Three</H4><pre>class PMFC {public:    ...    <b>return type</b> operator()() const;    ...};template&lt;typename T&gt;class SP { public:   ...    const PMFC operator-&gt;*( <b>return type</b> (T::*pmf)() ) const;    ...};</pre><P><A HREF="#rl3">Back to Article</A></P><H4><A NAME="l4">Listing Four</H4><pre>template&lt;typename ReturnType&gt;   // template for a pending mbr funcclass PMFC {                    // call returning type ReturnTypepublic:    ...    ReturnType operator()() const;    ...};template&lt;typename T&gt;class SP { public:    ...    template&lt;typename ReturnType&gt;        const PMFC&lt;ReturnType&gt;            operator-&gt;*( ReturnType (T::*pmf)() ) const;    ...};</pre><P><A HREF="#rl4">Back to Article</A></P><H4><A NAME="l5">Listing Five</H4><pre>template&lt;typename ObjectType,        // class offering the mem func         typename ReturnType,        // return type of the mem func         typename MemFuncPtrType&gt;    // full signature of the mem funcclass PMFC { public:    typedef std::pair&lt;ObjectType*, MemFuncPtrType&gt; CallInfo;    PMFC(const CallInfo&amp; info): callInfo(info) {}    ReturnType operator()() const         { return (callInfo.first-&gt;*callInfo.second)(); } private:    CallInfo callInfo;};</pre><P><A HREF="#rl5">Back to Article</A></P><H4><A NAME="l6">Listing Six</H4><pre>template &lt;typename T&gt;class SP {public:    SP(T *p): ptr(p) {}    template &lt;typename ReturnType&gt;        const PMFC&lt;T, ReturnType, ReturnType (T::*)()&gt;            operator-&gt;*(ReturnType (T::*pmf)()) const                 { return std::make_pair(ptr, pmf); }    ... private:    T* ptr;};</pre><P><A HREF="#rl6">Back to Article</A></P><H4><A NAME="l7">Listing Seven</H4><pre>#include &lt;iostream&gt;#include &lt;utility&gt;using namespace std;  template&lt;typename ObjectType, typename ReturnType, typename MemFuncPtrType&gt;class PMFC { ... };              // as abovetemplate &lt;typename T&gt;            // also as aboveclass SP { ... }; class Wombat { public:     int dig()     {        cout &lt;&lt; "Digging..." &lt;&lt; endl;        return 1;    }     int sleep()     {        cout &lt;&lt; "Sleeping..." &lt;&lt; endl;        return 5;    }};int main(){                                     // as before, PWMF is a     typedef int (Wombat::*PWMF)();    // pointer to a Wombat member function    SP&lt;Wombat&gt; pw = new Wombat;    PWMF pmf = &amp;Wombat::dig;   // make pmf point to Wombat::dig     (pw-&gt;*pmf)();              // invokes our operator-&gt;*;                               // prints "Digging..."     pmf = &amp;Wombat::sleep;      // make pmf point to Wombat::sleep     (pw-&gt;*pmf)();              // invokes our operator-&gt;*;}                              // prints "Sleeping..."</pre><P><A HREF="#rl7">Back to Article</A></P><H4><A NAME="l8">Listing Eight</H4><pre>template &lt;typename T&gt;class SP {public:    ...                     // as above    template &lt;typename ReturnType&gt;        const PMFC&lt;T, ReturnType, ReturnType (T::*)() const&gt;  // const added            operator-&gt;*(ReturnType (T::*pmf)() const) const   // const added                { return std::make_pair(ptr, pmf); }    ...                     // as above};</pre><P><A HREF="#rl8">Back to Article</A></P><H4><A NAME="l9">Listing Nine</H4><pre>template &lt;typename ObjectType, typename ReturnType, typename MemFuncPtrType&gt;class PMFC {public:    typedef pair&lt;ObjectType*, MemFuncPtrType&gt; CallInfo;    PMFC(const CallInfo&amp; info)   : callInfo(info) {}    // support for 0 parameters    ReturnType operator()() const         { return (callInfo.first-&gt;*callInfo.s   d)(); }      support for 1 parameter    template &lt;typename Param1Type&gt;        ReturnType operator()(Param1Type p1) const            { return (callInfo.first-&gt;*callInfo.second)(p1); }private:    CallInfo callInfo;}; template &lt;typename T&gt;class SP {public:    SP(T *p): ptr(p) {}     // support for 0 parameters    template &lt;typename ReturnType&gt;        const PMFC&lt;T, ReturnType, ReturnType (T::*)()&gt;             operator-&gt;*(ReturnType (T::*pmf)()) const                { return std::make_pair(ptr, pmf); }    // support for 1 parameter    template &lt;      typename ReturnType, typename Param1Type&gt;        const PMFC&lt;T, ReturnType, ReturnType (T::*)(Param1Type)&gt;            operator-&gt;*(ReturnType (T::*pmf)(Param1Type)) const                { return std::make_pair(ptr, pmf); }    ... private:    T* ptr;};</pre><P><A HREF="#rl9">Back to Article</A></P><H4><A NAME="l10">Listing Ten</H4><pre>template &lt;typename T&gt;   // base class for smart pointers wishingclass SmartPtrBase {    // to support operator-&gt;*public:    SmartPtrBase(T *initVal): ptr(initVal) {}    // support for 0 parameters    template &lt;typename ReturnType&gt;        const PMFC&lt;T, ReturnType, ReturnType (T::*)()&gt;             operator-&gt;*(ReturnType (T::*pmf)()) const                { return std::make_pair(ptr, pmf); }    // support for 1 parameter    template &lt;   typename ReturnType, typename Param1Type&gt;        const PMFC&lt;T, ReturnType, ReturnType (T::*)(Param1Type)&gt;            operator-&gt;*(ReturnType (T::*pmf)(Param1Type)) const                { return make_pair(ptr, pmf); }    ...protected:    T* ptr;};</pre><P><A HREF="#rl10">Back to Article</A></P><H4><A NAME="l11">Listing Eleven</H4><pre>template &lt;typename T&gt;class SP: private SmartPtrBase&lt;T&gt; {public:    SP(T *p ): SmartPtrBase&lt;T&gt;(p) {}    using SmartPtrBase&lt;T&gt;::operator-&gt;*;    // make the privately inherited                                           // operator-&gt;* templates public    // normal smart pointer functions would go here;  operator-&gt;*    // functionality is inherited};</pre><P><A HREF="#rl11">Back to Article</A></P><H4><A NAME="l12">Listing Twelve</H4><pre>template &lt;typename T&gt;                       // traits classstruct MemFuncTraits {};template &lt;typename R, typename O&gt;           // partial specializationstruct MemFuncTraits&lt;R (O::*)()&gt; {          // for zero-parameter    typedef R ReturnType;                   // non-const member    typedef O ObjectType;                   // functions};template &lt;typename R, typename O&gt;           // partial specializationstruct MemFuncTraits&lt;R (O::*)() const&gt; {    // for zero-parameter    typedef R ReturnType;                   // const member    typedef O ObjectType;                   // functions};template &lt;typename R, typename O, typename P1&gt;  // partial specializationstruct MemFuncTraits&lt;R (O::*)(P1)&gt; {            // for one-parameter    typedef R ReturnType;                       // non-const member    typedef O ObjectType;                       // functions};template &lt;typename R, typename O, typename P1&gt; // partial specializationstruct MemFuncTraits&lt;R (O::*)(P1) const&gt; {     // for one-parameter    typedef R ReturnType;                      // const member    typedef O ObjectType;                      // functions};</pre><P><A HREF="9910bs1.htm#rl12">Back to Article</A></P><H4><A NAME="l13">Listing Thirteen</H4><pre>template &lt;typename MemFuncPtrType&gt;class PMFC {public:    typedef typename MemFuncTraits&lt;MemFuncPtrType&gt;::ObjectType ObjectType;    typedef typename MemFuncTraits&lt;MemFuncPtrType&gt;::ReturnType ReturnType;    ...                 // same as before};</pre><P><A HREF="9910bs1.htm#rl13">Back to Article</A></P><H4><A NAME="l14">Listing Fourteen</H4><pre>template &lt;typename MemFuncPtrType&gt;const PMFC&lt;MemFuncPtrType&gt;operator-&gt;*(MemFuncPtrType pmf) const{ return std::make_pair(ptr, pmf); }</pre><P><A HREF="9910bs1.htm#rl14">Back to Article</A></P><HR><I>Copyright &copy; 1999, Dr. Dobb's Journal</I><BR>
</body></html>