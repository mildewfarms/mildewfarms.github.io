<html><head><title>Oct99: Partial Template Specialization and  operator->*</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h2>Partial Template Specialization and  <i>operator-&gt;*</i></h2><p>As I worked on this article, Esa Pulkkinen and Mark Rodgers pointed out that partial template specialization can be used to extract the object and return the type of a member function from the type of a pointer to that member function. One need merely apply the traits technique, which is widely used in the standard C++ library. (For more information on the traits technique, see Nathan Myers's article, "Traits: A New and Useful Template Technique," <i>C++ Report</i>, June 1995 and at http://www.cantrip .org/traits.html.) </p><p>Mark Rodgers suggested the templates in <A NAME="rl12"><A HREF="9910b.htm#l12">Listing Twelve</A> for member functions taking zero or one parameters. (The extension to more parameters is straightforward.) Given these templates, <i>PMFC</i> can be simplified to take only one type parameter, <i>MemFuncPtrType</i>. That's because the other two type parameters<i>ObjectType</i> and <i>ReturnType</i>can be deduced from <i>MemFuncPtrType</i>:</p><DDJADVERTISEMENT INLINE><ul>  <li><i>ObjectType</i> is <i>MemFuncTraits&lt;Mem		      FuncPtrType&gt;::ObjectType.</i>  <li><i>ReturnType</i> is <i>MemFuncTraits&lt;Mem		      FuncPtrType&gt;::ReturnType.</i></ul><p>This leads to the revised implementation of </i>PMFC in <A NAME="rl13"><A HREF="9910b.htm#l13">Listing Thirteen</A>. Other than offering a chance to show off knowledge of traits and when <i>typename </i>must precede the name of a type in a template, this doesn't appear to have bought much, but don't be fooled. This greatly reduces the work smart pointer classes must do to implement <i>operator-&gt;*</i>. In fact, Mark Rodgers noted that a <i>single operator-&gt;*</i> <i>template </i>can support all possible member function pointers, regardless of the number of parameters taken by the member functions and whether the member functions are <i>const</i>. Just replace all the <i>operator-&gt;*</i> templates in <i>SP</i> (or <i>SmartPtrBase</i>) with the code in <A NAME="rl14"><A HREF="9910b.htm#l14">Listing Fourteen</A>. The type parameter <i>MemFuncPtrType</i> will bind to any pointer to member function type, regardless of parameters, return type, and <i>const</i>ness. It will then pass that type on to <i>PMFC</i>, where partial specialization will be used to pick the type apart. </p></ul><p>Source code employing this approach to implementing <i>operator- &gt;*</i> is available electronically.</p><p>S.M.</p><a href="9910b.htm#rs1">Back to Article</a><HR><I>Copyright &copy; 1999, Dr. Dobb's Journal</I><BR>
</body></html>