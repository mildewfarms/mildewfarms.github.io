<html><head><title>Feb99: Java and Lightweight Components</title></head><BODY BGCOLOR="#ffffff" TEXT="#000000" LINK="#0000ff" VLINK="#330066" ALINK="#FF0000">
<!--Copyright &#169; Dr. Dobb's Journal--><h1>Java and Lightweight Components</h1><p><i>Dr. Dobb's Journal</i> February 1999</p><h2>Implementing platform-independent look-and-feel</h2><h3>By David K. Perelman-Hall</h3><I>David develops client/server Java software at NetGenics Inc. in Cleveland, Ohio, and teaches Java for Sun Microsystems. He can be reached at dph@netgenics.com.</I><hr><p>By now you know that you can write Java code once, then run it in any virtual machine -- no matter what platform is hosting the VM. However, if you write code that uses UI components native to the platform hosting the VM (which is what the Abstract Windowing Toolkit (AWT) does for each UI widget in the toolkit), the write-once/run-anywhere quality of Java has to have a door to the native implementation. That makes Java code using the AWT dependent on platform-specific resources.</p><p>If you've paid attention to how Java AWT components look on different platforms, you know that UI components look like those of the platform proper. Java achieves this by forwarding requests for the creation of AWT UI components to platform-dependent UI peers, which render their on-screen representations using native platform-dependent UI resources. This means that with the AWT there is no single cross-platform implementation of any UI component. It also means that every VM that can display AWT components has access to a platform-specific set of peer classes to render the AWT components.</p><p>Forwarding to peers is dubbed the "heavyweight component" technique because peers make heavy use of resources -- each heavyweight component renders itself using a separate native window with its own native graphics resources. Native windows also impose certain, perhaps unwanted but immutable, characteristics, including a square shape and opacity, which are inherited when you subclass the AWT, thus making it difficult to build a set of, say, round or partially transparent components.</p><p>In contrast to the heavyweights, JDK 1.1 lightweight components let you give programs the same look for components, no matter which platform hosts the VM, because lightweights don't use peers. Instead, lightweights get rendered by programmer-defined code, and can have any shape -- even transparent sections. They use fewer resources than their heavyweight siblings because, instead of using a native window for every component, lightweights render themselves using the native window graphics resource of their nearest heavyweight ancestor. An example of a full-fledged lightweight library is Sun's SwingSet, delivered with the JDK 1.1.</p><p>To examine lightweight component development, I present my dph.awt.lightweight package and an alarm-clock application made of lightweight pieces, which runs in a Java Frame and can be used as an application or applet. The code for this application (available electronically; see "Resource Center," page 5) requires JDK 1.1 and will not compile under JDK 1.02. When run as an applet, the alarm clock works under Netscape Navigator 4.04, but requires the latest JDK 1.1 patch.</p><h3>The Overall Picture</h3><p>The dph.awt.lightweight package I present here demonstrates the steps of lightweight component development. It is not a complete lightweight component set. Nor am I providing exact replacements for AWT components (the AWT doesn't even have a <i>Spinner</i> class). Instead, I'm providing components that overlap with the AWT. My <i>FlatButton</i> and <i>Label</i>, for example, could be replacements for AWT <i>Button</i> and <i>Label</i>, but my <i>Label</i> lets you designate a border, and my <i>FlatButton</i> does not look or behave like an AWT <i>Button</i>. </p><p>There are five components that make up the dph.awt.lightweight package: <i>Label</i>, <i>Checkbox</i>, <i>Spinner</i>, <i>FlatButton</i>, and <i>TabPanel</i>. There is also a <i>RoundButton</i> class, but it is not used in the alarm clock. Except for <i>TabPanel</i>, these inherit from class <i>dph.awt.lightweight.CommonBase</i>, which principally encapsulates a behavioral pattern used to size lightweight components. <i>CommonBase</i> inherits from <i>java.awt.Component</i>, while <i>TabPanel</i> inherits from <i>java.awt.Container</i>. These are the only JDK parents lightweights can have. <A NAME="rf1"><A HREF="9902af1.htm">Figure 1</A> provides an overall view of the classes making up the dph.awt.lightweight package.</p><p>Additional classes include <i>dph.play.alarmclock.AlarmClockFrame</i> (the window in which the alarm clock appears), <i>dph.play.alarmclock.AlarmClockApplet</i> (the applet that invokes <i>AlarmClockFrame</i> to let the alarm clock run as an applet), <i>dph.play.alarmclock.ClockCanvas</i> (the clock face), and <i>dph.play.alarmclock.SecondsThread</i> (a subclass of <i>java.lang.Thread</i> that does the timing of the clock). There are also nested inner classes for event handlers. </p><p>There are three canonical steps of lightweight development. Lightweights are required to:</p><ul><li>Inherit from <i>java.awt.Component</i> or <i>java.awt.Container</i> or another lightweight.  <li>Do all the drawing required to represent the component on screen, including any graphical behavior that would normally occur in reaction to mouse events.  <li>Do the event handling appropriate to the component. This means you must provide the hooks to let listeners register and deregister for notification that an event has taken place, and you must pass the event notification to the listeners. </ul><p>In addition, if the lightweight component you are creating is a container (like <i>TabPanel)</i> and not just a component, then it is essential that you call <i>super.paint</i>, because containers are responsible for drawing the components they hold, and calling <i>super.paint</i> ensures that this responsibility will be fulfilled.</p><h3>The First Canonical Step</h3><p>The first step is that all lightweights extend <i>java.awt.Component</i>, <i>java.awt.Container</i>, or another lightweight. For the alarm clock, the class <i>CommonBase</i> performs this step for the noncontainer lightweights, such as <i>Label</i>, <i>Spinner</i>, <i>FlatButton</i>, and <i>Checkbox</i>. The lightweight container <i>TabPanel</i> extends directly from <i>java.awt.Container</i>. <A NAME="rl1"><A HREF="9902a.htm#l1">Listing One</A> is the skeleton class definition for <i>CommonBase</i>. </p><p>Sizing, painting, and enabling/disabling behaviors are partly managed in this base class. Many sizing activities rely on a font to determine how large to draw a component, and, in Java, a font is part of the graphics context for a component. Thus, it is often important to delay size calculating until a graphics context has been established. The call to <i>addNotify</i> ensures a graphics context is available, so <i>CommonBase</i> overrides this to call <i>figureMySize</i> once the graphics context has been supplied. Each child class only needs to define the hook method <i>figureMySize</i> to return the <i>Dimension</i> object, which represents the preferred size of the object.</p><p>The second behavior managed by this class is painting. Lightweights tend to have noticeable flicker that can be resolved by the use of off-screen image buffering, sometimes called "double-buffering." Double-buffering prepares the screen's contents initially in an image buffer in memory, and then with the paint method whisks the image in memory onto the screen.</p><p>The solution involves placing lightweights in containers which do the buffering, then overriding update in the components' call to paint, thus omitting the default behavior of clearing the screen in update. <i>CommonBase</i> implements the override of update so none of its child components need to. The double-buffering in the container classes <i>DoubleBufferedPanel</i> and <i>DoubleBuffered- ExitingFrame</i> is based on examples in the demo/awt-1.1/lightweight directory of the JDK1.1. </p><p>The third behavior is enabling/disabling, which is overridden merely to enforce a repaint occurring as a result of a change to an enabled state.</p><h3>The Second Canonical Step</h3><p>The second step is to provide constructors and methods for manipulating the state of the component, including its appearance. If you are creating a component to replace one of the AWT components, extending <i>java.awt.Component</i> gives you the methods and data of the <i>Component</i> class, so look at the methods of the AWT class you are replacing, and supply the constructors, data members, and method implementations needed to make your lightweight component behave like the AWT component. Most Java reference books itemize the data members and class methods for the AWT components, but I recommend <i>Java AWT Reference</i>, by John Zukowski (O'Reilly &amp; Associates, 1997). </p><p>I provide at least a minimum set of constructors for lightweight components; see <i>Label </i>in <A NAME="rl2"><A HREF="9902a.htm#l2">Listing Two</A>. I define a set of constructors that creates a <i>Label</i> with a textual <i>String</i>. I also let users designate whether there should be a rectangular border around the <i>Label</i>. <i>Label</i>'s flaw is that it will always draw its text left justified. This means that if users call <i>setSize</i> to give a <i>Label</i> a wide graphical representation, the text won't appear in the middle of that area.</p><p>One of the more interesting classes is <i>FlatButton</i>, which lies flat and pops up when the cursor moves over it. <i>FlatButton</i> differs from the AWT <i>Button</i> in that it lets you have a textual label, an image label, or both, on the surface of the button. If both are there, <i>FlatButton</i> draws the text over the image. To get it to appear with an image, pass the constructor a <i>String</i> representing the URL of the image you want painted on its surface. You can also call <i>setImageURL</i> after it has been constructed, and pass in the <i>String</i> representing the URL. One of the tricks this class employs is the use of a <i>MediaTracker</i> object to ensure that the image is loaded. It is essential to have a valid image before trying to use the image to determine the <i>FlatButton</i>'s dimensions. <A NAME="rl3"><A HREF="9902a.htm#l3">Listing Three</A> shows the steps <i>FlatButton</i> takes to ensure that the image is fully loaded before figuring its size.</p><p>You must control all aspects of a lightweight's appearance, and <i>FlatButton</i>s appear to pop up when the cursor enters them, pop down when pressed, or go flat when the cursor exits them. Consequently, the class must track these states, and the drawing code in the paint method must shift the image and/or text when it changes state. You must even handle the differences in appearance and behavior between the enabled and the disabled states for each lightweight component.</p><p>In fact, because you must control every aspect of the lightweight component's appearance, you must override the paint method to draw the component. Bear in mind that the double-buffering (to control flickering) does not take place in the components themselves, but rather should take place in the container the components are placed in. Therefore, you won't see any evidence of double-buffering in the paint methods of these lightweights. In fact, they are not aware of being double-buffered. If done correctly, however, the <i>Graphics</i> object that is used in their <i>paint</i> methods will originate from the buffered <i>Image</i> of the highest-level container they are in.</p><p>The only lightweight under discussion, which extends <i>java.awt.Container</i> and not <i>java.awt.Component</i> is <i>TabPanel</i>. To ensure that this class behaves more like a tabbed folder than a <i>Panel</i>, the <i>TabPanel</i> class does not implement a host of methods inherited from <i>java.awt.Container</i>, such as <i>add</i>, <i>getComponent</i>, <i>getComponentCount</i>, <i>remove</i>, and <i>removeAll</i>. The class data supporting the <i>TabPanel</i> are minimal: </p><ul><li>An array of <i>String</i> to hold the tab labels.  <li>An array of <i>Rectangle</i> designating regions of the screen where the tabs are drawn so that mouse clicks can be associated with particular tabs.  <li>An <i>int</i> to designate the currently selected tab.   <li>A <i>Hashtable</i> to hold the contents of each tab in the form of <i>Panel</i>s keyed to their tab labels.  <li>A <i>DoubleBufferedPanel</i> called <i>currentPanel</i>.</ul><p>To use <i>TabPanel</i>, users build up a <i>Panel</i> outside of <i>TabPanel</i> by adding components to a <i>Panel</i>, then invoking one of the <i>TabPanel</i> <i>add</i> methods to add the <i>Panel</i> to the <i>TabPanel</i> along with a label that appears in a tab for that <i>Panel</i>. This <i>TabPanel</i> has two flaws:</p><ul><li>Tabs are only positioned across the top of the folder. In fact, there is a trick to how tabs appear as a separate row of features above the folder for each tab. Because the <i>TabPanel</i> itself is a <i>Container</i>, it has a <i>LayoutManager</i> which controls how the components on it are laid out. The <i>TabPanel</i> nulls out its <i>LayoutManager</i>, and each <i>Panel</i> selected by a mouseclick on a tab is positioned by the call <i>currentPanel.setLocation(2,27)</i>. Thus, there is a row 27 pixels tall above each <i>Panel</i>; this is where the tabs are drawn.   <li>The row of tabs across the top of the <i>TabPanel</i> will not intelligently handle more tabs than there is horizontal space for as determined by the width of the <i>TabPanel</i>.</ul><p>The real work of this component is done in the methods called from the <i>paint</i> method, which is split into three chores (see <A NAME="rl4"><A HREF="9902a.htm#l4">Listing Four</A>), the first of which is the all-important task of any lightweight container, calling <i>super.paint</i>. The second task is to draw the <i>TabPanel</i> so that it has a background color and border; the third task is to paint the tabs, showing which one is currently selected. It is possible to have the <i>TabPanel</i> show first  without any tab being selected. The code in the <i>set-SelectedTab</i> method (<A NAME="rl5"><A HREF="9902a.htm#l5">Listing Five</A>) shows how the panels are swapped when users click on different tabs.</p><h3>The Third Canonical Step</h3><p>Except for <i>TabPanel</i> (which calls it directly by itself), all constructors eventually call <i>enableEvents(AWTEvent.MOUSE_EVENT_MASK)</i> through their common parent lightweight component <i>CommonBase</i>. The final canonical step, therefore, is to provide the means to let event listeners register with lightweights and receive notifications of the types of events appropriate to the component. This is a multipart process that involves:</p><ul><li>Enabling lightweight components to receive event notifications appropriate for them (this is what's going on in the call to <i>enableEvent</i>s).  <li>Giving event listeners a way to register with a lightweight component so that the listeners can be notified when the lightweight component has an event of interest.  <li>Having the lightweight component disperse the event to registered listeners. </ul><p>I'll show how this is done using the <i>FlatButton</i>, <i>Checkbox</i>, and <i>Spinner</i> lightweight classes.</p><p>The <i>java.awt.Component</i> method <i>enableEvents(int eventMask)</i> allows a component to listen for those events designated by the <i>eventMask</i> parameter (defined in the <i>AWTEvent</i> class to have values such as WINDOW_EVENT_MASK and MOUSE_EVENT_MASK), and to do so without having any registered listeners. In Java 1.1, events are not normally produced when there are no registered listeners, but this technique ensures that events are generated. You can turn off listening by calling <i>disableEvents(int eventMask)</i>.</p><p>Because each of my lightweight UI components is the target of some mouse activity in the constructor class <i>CommonBase</i>, I enable each lightweight to receive mouse events by calling <i>enableEvents</i> with the argument set to MOUSE_EVENT_MASK. Each of the child classes uses the event notifications differently. For example, a <i>FlatButton</i> can pop up in reaction to a mouse-entered event, <i>Spinner</i> can start a thread that changes its value in response to a mouse-pressed event, and it can stop the thread when it gets a mouse-released event; and <i>Checkbox</i> can change its state in reaction to a mouse-clicked event.</p><p>With every instance of an event source (like a button object), there is a list of listeners that have registered interest in being notified that an event has taken place. All you need to know is what type of event is being listened for, then keep a reference to the list of listeners in your own class. The way to access this list is through the <i>AWTEventMulticaster</i> class, which lets you have access to this listener chain so that you can insert or remove listeners, and, so that you can then deliver your own event to the chain.</p><p>Buttons normally let listeners register to listen for <i>ActionEvent</i>, so you define the <i>addActionListener</i> and <i>removeActionListener</i> methods (like standard AWT Buttons have), and use the static <i>add</i> and <i>remove</i> methods of the <i>AWTEventMulticaster</i> class to add or remove an <i>ActionListener</i> to instances of your buttons; see <A NAME="rl6"><A HREF="9902a.htm#l6">Listing Six</A>. The adding/removing of listeners is done at the <i>ButtonBase</i> class level and is inherited by both <i>FlatButton</i> and <i>RoundButton</i>. In <A HREF="9902a.htm#l6">Listing Six</A>, the reference being assigned the return from <i>AWTEventMulticaster.add</i> or remove is <i>actionListener</i>, which is a protected data member in the <i>ButtonBase</i> class. The <i>dph.awt.lightweight.Spinner</i> class also registers <i>ActionListener</i>s. Checkboxes register <i>ItemListener</i>s that want notification when the state of the checkbox changes, so you keep a reference to <i>ItemListener</i> and use the <i>AWTEventMulticaster</i> class to reference the checkbox's list of listeners.</p><p>Finally, you need to process events appropriate to the component. Because every button type should respond to a mouse-click by generating an <i>ActionEvent</i> for its listeners, I've put that behavior in the <i>ButtonBase</i> class. <A NAME="rl7"><A HREF="9902a.htm#l7">Listing Seven</A> tests if the button is enabled by using the <i>java.awt.Component</i>'s <i>isEnabled</i> method, then tests if it has any registered listeners, and then calls <i>actionPerformed</i> on the list of listeners. The parameters to <i>actionPerformed</i> are: a reference to the source of the event (which you provide by a reference to this), an event ID, and the command string. Placing this responsibility in the parent class necessitates a call to <i>super.processEvent</i> in the <i>FlatButton</i> and <i>RoundButton</i> child classes. </p><p>As <A NAME="rl8"><A HREF="9902a.htm#l8">Listing Eight</A> shows, you respond to mouse activity in <i>FlatButton</i> by manipulating state information, which you use to draw the current state of the button. The call to <i>super.process- Event</i> is outside of the tests and takes place every time.</p><p>Finally, <i>dph.awt.lightweight.Spinner</i> handles mouse activity by tracking whether users press on the spinner's up- or down-arrow, then calls <i>spin</i>, which starts a thread to increment or decrement the spinner's value. It uses a thread because users might leave the mouse button pressed down while on the spinner arrow, and the expected behavior would be to continue changing the spinner's value while the button is pressed. Because it wants to start a thread in reaction to every mouse-down on a spinner arrow, and because users might repeatedly click on it in rapid succession, there is a built-in time delay, which prevents threads from being built willy-nilly and causing the control to spin too rapidly.</p><p>The <i>spin</i> method (<A NAME="rl9"><A HREF="9902a.htm#l9">Listing Nine</A>) shows a reasonable use of a locally defined class, which is a class nested not only within another class, but within a method as well. Usually this is a maintenance headache, but here, the sole purpose of the thread is to spin the value up or down, and the class is short and can be understood fairly quickly. It makes sense to keep it together with the function that uses it. You can see that the <i>spin</i> function does only two things -- it defines the <i>SpinThread</i> class and calls start on an instance of it.</p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</A></H4><pre>package dph.awt.lightweight;public abstract class CommonBase extends java.awt.Component {    public void addNotify() {        super.addNotify();        java.awt.Dimension d = getSize();        if( d.width == 0  ||  d.height == 0 ) {            setSize( this.figureMySize( this.getGraphics() ) );        }    }    public void setEnabled( boolean state ) {        super.setEnabled( state );        repaint();    }    public void update( java.awt.Graphics g ) {        paint( g );        }    public java.awt.Dimension getMinimumSize() {        return getPreferredSize();    }    public java.awt.Dimension getPreferredSize() {        if( getSize().width != 0  &amp;&amp;  getSize().height != 0 )            return getSize();        else            return figureMySize( getGraphics() );    }    protected abstract java.awt.Dimension figureMySize( java.awt.Graphics g );}<p></p></pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>public Label() {    this( "", false );}public Label( String text ) {    this( text, false );}public Label( String text, boolean showBorder ) {    super();    this.text = text;    this.showBorder = showBorder;<p></p></pre><P><A HREF="#rl2">Back to Article</A></P><H4><A NAME="l3">Listing Three</H4><pre>public FlatButton ( java.awt.Image image ) {    super( "" );    this.image = image;    this.setup();}private final void setup() {    if( image != null  &amp;&amp;  (image.getWidth(this)==-1  ||                                            image.getHeight(this)==-1) )        this.ensureImageLoaded( image );}private final void ensureImageLoaded( java.awt.Image image ) {    try {        java.awt.MediaTracker tracker = new java.awt.MediaTracker( this );        tracker.addImage( image, 0 );        tracker.waitForID( 0 );        Util.assert( tracker.statusID(0, false) ==                         java.awt.MediaTracker.COMPLETE, "image complete" );    } catch( InterruptedException ex ) {        Util.debug( "Image loading interrupted" );    }}<p></p></pre><P><A HREF="#rl3">Back to Article</A></P><H4><A NAME="l4">Listing Four</H4><pre>public void paint( Graphics g ) {    super.paint( g );    this.paintTabPanel( g );    this.paintTabs( g );}<p></p></pre><P><A HREF="#rl4">Back to Article</A></P><H4><A NAME="l5">Listing Five</H4><pre>public void setSelectedTab( int tabNum ) {    if( tabNum &gt;= 0  &amp;&amp;  tabNum &lt; tabLabels.length ) {        this.remove( currentPanel );        selectedTab = tabNum;        currentPanel = (DoubleBufferedPanel)cards.get( tabLabels[tabNum] );        this.add( currentPanel );        currentPanel.setLocation( 2, 27 );        currentPanel.setSize( this.getPanelSize() );    }    repaint();}<p></p></pre><P><A HREF="#rl5">Back to Article</A></P><H4><A NAME="l6">Listing Six</H4><pre>public void addActionListener( ActionListener al ) {    actionListener = AWTEventMulticaster.add( actionListener, al );}public void removeActionListener( ActionListener al ) {    actionListener = AWTEventMulticaster.remove( actionListener, al );}<p></p><p></p><p></p></pre><P><A HREF="#rl6">Back to Article</A></P><H4><A NAME="l7">Listing Seven</H4><pre>public void processMouseEvent( MouseEvent me ) {    if( isEnabled() ) {      switch( me.getID() ) {        case MouseEvent.MOUSE_CLICKED:            if( actionListener != null ) {              actionListener.actionPerformed( new ActionEvent (                this, ActionEvent.ACTION_PERFORMED, this.getActionCommand()                 ) );            }        }    }    super.processMouseEvent( me );}<p></p></pre><P><A HREF="#rl7">Back to Article</A></P><H4><A NAME="l8">Listing Eight</H4><pre>public void processMouseEvent( java.awt.event.MouseEvent evt ) {    if( isEnabled() ) {      switch( evt.getID() ) {      case java.awt.event.MouseEvent.MOUSE_ENTERED:         mouseIsIn = true;         repaint();         break;      case java.awt.event.MouseEvent.MOUSE_EXITED:         mouseIsIn = false;         repaint();         break;      case java.awt.event.MouseEvent.MOUSE_PRESSED:         mouseIsDown = true;         repaint();         break;      case java.awt.event.MouseEvent.MOUSE_RELEASED:         mouseIsDown = false;         repaint();         break;      }   }<p></p></pre><P><A HREF="#rl8">Back to Article</A></P><H4><A NAME="l9">Listing Nine</H4><pre>public void spin() {    class SpinThread extends Thread {        SpinThread() {            super();            this.setPriority( Thread.MIN_PRIORITY );        }        public void run() {            try {                if( upPressed )                    increment();                if( dnPressed )                    decrement();                repaint();                Thread.sleep( 1250 );                while( upPressed || dnPressed ) {                    if( upPressed )                        increment();                    if( dnPressed )                        decrement();                    repaint();                        Thread.sleep( 400 );                }            } catch( InterruptedException ex ) {                // ignore it            }        }        new SpinThread().start();    }</pre><P><A HREF="#rl9">Back to Article</A></P><HR><I>Copyright &copy; 1999, Dr. Dobb's Journal</I><BR>
</body></html>