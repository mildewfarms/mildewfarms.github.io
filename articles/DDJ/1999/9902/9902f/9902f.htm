<html><head><title>Feb99: Jperl: Accessing Perl from Java</title></head><BODY BGCOLOR="#ffffff" TEXT="#000000" LINK="#0000ff" VLINK="#330066" ALINK="#FF0000">
<!--Copyright &#169; Dr. Dobb's Journal--><h1>Jperl: Accessing Perl from Java</h1><p><i>Dr. Dobb's Journal</i> February 1999</p><h2>Adding power and flexibility</h2><h3>By S. Balamurugan</h3><I>The author is a software design engineer working for the ASIC group of Texas Instruments, India. He can be contacted at sbm@india.ti.com.</I><hr><p>Jperl provides an interface to Perl from Java. The Jperl interface was written in C++ using Perl APIs and integrated into Java using the Java Native Interface (JNI). The APIs in Jperl also make accessing Perl from C++ simple, with a single overloaded function that masks argument ordering, stack manipulation, and data structure conversion. The package -- freely available (courtesy of Texas Instruments) at http://www.angelfire.com/ in/sbm, from Comprehensive Perl Archives Network (CPAN) at http://www.perl.com/ CPAN-local/authors/id/S/SB/SBALA/, and from <i>DDJ</i> (see "Resource Center," page 5) -- includes source code, examples, documentation, and precompiled libraries for Solaris. To compile your own libraries, you need to install JDK 1.1.4, g++ 2.7.x, Perl 5.002 (or higher). </p><p>More specifically, the modules include:</p><ul><li>jperl.c, which contains the implementation for the Perl access in C++.   <li>jperl.h, which contains the function prototypes.   <li>jp.c and jp.h, which provide the JNI.   <li>jp.java, which defines the package for Perl access.</ul><h3>Accessing Perl from Java</h3><p>Before accessing Perl, you must make sure the path to libperl.so is added to LD_LIBRARY_PATH and jp.class to the CLASSPATH. jp.class defines six public methods for calling Perl subroutines, two for turning debug on/off in the native code, and a constructor (see <A NAME="rt1"><A HREF="9902ft1.htm">Table 1</A>).</p><p> The constructor <i>jp()</i> takes the path to the Perl file as a string argument and initializes the interpreter. Ideally, the Perl file should include all the subroutines that will be called from Java. Only one instance of the Perl interpreter can be alive at a time; trying to initialize more than one instance throws a <i>RuntimeException</i>.</p><p>Additional Perl modules (other than those required by the Perl file supplied to the <i>jp()</i> constructor) can be included at run time using <i>IPLLoadLibrary()</i>. This method takes as an argument the path of the Perl package and adds it to the interpreter within the existing namespace.</p><p>The <i>DebugOn()</i> and <i>DebugOff()</i> methods turn the debug flag on and off in the native code. When the debug flag is on, arguments are passed to Perl subroutines, values are returned, and status messages are displayed on <i>stdout</i>. Make sure you unbuffer the output in Perl so that messages from Perl and debug messages from the native code appear in order. In Perl, you can do this with <i>select((select(STDOUT),$| = 1)[0]);.</i></p><p>Perl subroutines or package methods can be called using one of Java's <i>PLCall</i> methods. There are three methods, one for each type of data being returned from Perl. Package methods can be called by specifying <i>package_name::method_name</i>. All <i>PLCall</i> methods take an <i>Object</i> array as an argument and make this data available as arguments to the Perl subroutine through the "@_" array in Perl.</p><p><i>PLCallScalar()</i> calls a Perl subroutine and returns a scalar value. <i>PLCallArray()</i> calls the subroutine and returns a Perl list as a <i>String[]</i>. <i>PLCallHash()</i>, calls the specified subroutine and returns a Perl <i>Hash</i> array (or a list with even numbers of elements) as Hashtable in Java. If an odd number of elements are returned from Perl, a <i>RuntimeException</i> is thrown.</p><p>Perl scalars can be converted to <i>Integer</i>, <i>Double</i>, or <i>String</i>, although all values returned from Perl are stored as <i>String</i>. <i>Hash</i> arrays from Perl are converted to Java <i>Hashtable</i>s. Both <i>key</i> and <i>value</i> are stored as <i>String</i>, which can contain an empty string if nothing is returned from Perl. In case of error in conversion from Perl data structure to Java, the string will contain "(null)" as its value. All strings are guaranteed to be defined.</p><p>As previously mentioned, <i>PLCall</i> methods take an <i>Object</i> array as arguments to be passed to Perl. Application can directly pass <i>Integer</i>, <i>Double</i>, or <i>String</i> arrays as valid arguments. If the application must pass a <i>Vector</i> or a <i>Hashtable</i>, an <i>Object</i> array has to be explicitly created and the <i>Hashtable</i> or <i>Vector</i> made elements of the <i>Object</i> array; see <A NAME="rl1"><A HREF="9902f.htm#l1">Listings One</A> and <A NAME="rl2"><A HREF="9902f.htm#l2">Two</A>. One of the most powerful features of Jperl is its ability to evaluate Perl expressions on the fly. The <i>IPLEval</i> method enables this functionality. It takes a Perl expression as an argument, evaluates it, and returns a <i>String</i> array of results; for example, <i>String[] EvRet = perl.IPLEval("$a = 'This is a test';$b = reverse($a);' + "return ($a,$b);");</i>.</p><p><A NAME="rl3"><A HREF="9902f.htm#l3">Listings Three</A> and <A NAME="rl4"><A HREF="9902f.htm#l4">Four</A> give the complete picture. In <A HREF="9902f.htm#l3">Listing Three</A>, the test.pl program contains two subroutines -- <i>MyPerlFunc</i> and <i>TestFuncHash</i>. The first prints the arguments passed and returns them. The second creates a <i>Hash</i> array and returns it. In <A NAME="rl4"><A HREF="9902f.htm#l4">Listing Four</A>, example.java uses jp.class to access the subroutines in test.pl. Almost all of these methods throw <i>RuntimeException</i> and <i>IllegalArgumentException</i>. The <i>try</i>-<i>catch</i> block is used to catch these exceptions and display error messages. <i>Hashtable.toString()</i> displays a string representation of the hashtable.</p><h3>Accessing Perl from C++</h3><p><A NAME="rt2"><A HREF="9902ft2.htm">Table 2</A> lists Jperl's function calls. The <i>PLInit()</i> function initializes the Perl interpreter. It takes the path to the Perl file as an argument. This Perl file would normally include all the subroutines that you intend to call. <i>PLLoadModule()</i> lets you add additional Perl modules at run time. This function takes the full path of the <i>modulename</i> as an argument and loads it into the interpreter. After you have finished using the Perl subroutines, call <i>PLClose()</i> to release the resources held by the interpreter.</p><p>Perl subroutines can be called using the overloaded <i>PLCall</i> function. The first parameter is the variable in which to return the data, the second parameter is the subroutine name to be called, and the third parameter defines the format of the arguments to be passed to Perl. All <i>PLCall()</i> functions take a variable number of arguments and pass them as arguments to the Perl subroutine in <i>@_.</i> The functions return the number of elements returned by the Perl subroutine or -1 on error.</p><p>The return values from the Perl subroutine can be <i>int</i>, <i>double</i>, <i>String (char *)</i>, and arrays of <i>int</i>, <i>double</i>, or <i>String</i>. You should call the appropriate <i>PLCall()</i> based on the expected return type from Perl subroutines. If you are not sure of the return types, use <i>PLCall()</i>, which takes the <i>String</i> array as the return parameter. <i>Hasharray</i> from Perl should be received as an array of <i>String</i>, with alternate elements being <i>key</i> and <i>values</i>.</p><p>Each of the variable numbers of arguments is converted to an appropriate Perl data structure based on the type specified in format. Valid formats are <i>%d</i> for <i>int</i>, <i>%f</i> for <i>double</i>, <i>%s</i> for <i>char </i>*, <i>%D</i> for an array of <i>int</i>, <i>%F</i> for an array of <i>double</i>, <i>%S</i> for an array of <i>char </i>*. When passing arrays, the first argument should be the length of the array followed by the actual array; see <A NAME="rl5"><A HREF="9902f.htm#l5">Listing Five</A>.</p><p>Perl expressions can be evaluated with the <i>PLEval()</i> function, which takes a Perl expression as input, evaluates it, and returns the results as an array of <i>String</i>.</p><p><i>PLGeneric()</i> is similar to <i>PLCall()</i>, except that it concatenates all the return values from Perl separated by the passed delimiter and returns a single string. For example, <i>sub foo { return ("Hai",1); }</i>, when called with <i>PLGeneric()</i> with delimiter "**", returns a single string "<i>Hai</i>**<i>1</i>" in <i>retval</i>.</p><p>The <i>PLCall()</i> functions, as well as <i>PLEval()</i> and <i>PLGeneric()</i>, allocate the necessary memory for returning the values from Perl. It is up to the application using these functions to free them.</p><h3>Accessing Perl from Applets</h3><p>Since you cannot add native code to applets, one workaround is to create a plug-in that exports the necessary functionality. These methods can then be accessed from other applets on the same document. You need to download Netscape's Plug-in SDK (http://home.netscape .com/comprod/development_partners/ plugin_api/ index.html), write your own plug-in on top of jperl.c, and export the needed functionality. </p><h3>Conclusion</h3><p>The Jperl package provides programmers with the functionality of CPAN modules without having to rewrite them in Java. You can refer to the perlembed, perlguts, and perlcall documentation at http://www.perl.com/CPAN-local/doc/manual/ html/pod/perl.html if you want to extend the C++ interface of Jperl. Refer to JNI documentation at http://java.sun.com/ docs/books/tutorial/native1.1/index.html if you want to extend the Java interface.</p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</A></H4><pre>// Passing String array as argument to Perl. // Intger and Double arrays can be passed similarly.String[]  INP = new String[2];<p></p>// ... fill in INP<p></p>perl.PLCallScalar("MyFunc",INP); // Ditto for PLCallArray &amp; PLCallHash</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>// Passing a Hashtable and Vector as arguments to Perl Object[] ARGS = new Object[2];Vector    V;Hashtable H;<p></p>// ... fill in H &amp; V<p></p>ARGS[0] = H;ARGS[1] = V;perl.PLCallScalar("MyFunc",ARGS); // Ditto for PLCallArray &amp; PLCallHash</pre><P><A HREF="#rl2">Back to Article</A></P><H4><A NAME="l3">Listing Three</H4><pre>test.pl sub MyPerlFunc{ my($a,$b) = @_; print $a,":",$b,"\n"; return 0;}sub TestFuncHash{ my($a,$b) = @_; my(%ret)  = ("A"=&gt;$a,"B"=&gt;$b); return ret;}</pre><P><A HREF="#rl3">Back to Article</A></P><H4><A NAME="l4">Listing Four</H4><pre>example.javaimport java.util.Hashtable;import java.util.Stack;import jp; // The Jperl interfaceclass main{ public static void main(String[] args)  {   String[] INP = new String[2];   INP[0] = "Data1";   INP[1] = "Data2";   try {        // The perl file that contains the subroutines        jp perl = new jp("test.pl"); <p></p>        //Turn on Debug if necessary        //perl.DebugOn;                // Make a call and ignore the returned value!        String t = perl.PLCallScalar("MyPerlFunc",INP);<p></p>        String[] EvRet = perl.IPLEval("$a = 'This is a test';                                       $b = reverse($a); return ($a,$b);");       // Display result of evaluation       for(int i=0;i&lt;EvRet.length;i++)          {           System.out.println(EvRet[i]);          }        // Call Hash       Hashtable H = perl.PLCallHash("TestFuncHash",INP);<p></p>       // Output content of Hash       System.out.println(H.toString());       }   catch(IllegalArgumentException e)     {      System.out.println("Error caught "+e.getMessage());     }   catch(RuntimeException e)     {      System.out.println("Error caught "+e.getMessage());     }  }}</pre><P><A HREF="#rl4">Back to Article</A></P><H4><A NAME="l5">Listing Five</H4><pre>// IntializePLInit("/user/java/dev/test/mytest.pl");<p></p>// Passing a double array to Perl and recieving an intint I;                            // Return valuedouble DA[] = { 0.10, 0.20 } ;    // Arguments to the Perl subPLCall(I,"TestFuncAI","%F",2,DA); // Length is passed before the array<p></p>// Passing an int, float and string to Perl and recieving a Hash arraychar **S;int ct = PLCall(S,"TestFunc","%d%f%s",33,(double)100,"Hello World");for(int i=0;i&lt;ct;i++)   {    printf("%s\n",S[i]);   }// Evaluate a Perl expressionct = PLEval(EvalRet,"$a = 'This is a Test'; @b = split(/\\s+/,$a);             return @b;");// print results here ....// Free resourcesPLCose();</pre><P><A HREF="#rl5">Back to Article</A></P><HR><I>Copyright &copy; 1999, Dr. Dobb's Journal</I><BR>
</body></html>