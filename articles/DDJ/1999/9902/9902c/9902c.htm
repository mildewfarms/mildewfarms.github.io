<html><head><title>Feb99: The Java 2D API</title></head><BODY BGCOLOR="#ffffff" TEXT="#000000" LINK="#0000ff" VLINK="#330066" ALINK="#FF0000">
<!--Copyright &#169; Dr. Dobb's Journal--><h1>The Java 2D API</h1><p><i>Dr. Dobb's Journal</i> February 1999</p><h2>A powerful and extensible graphics interface 2D API</h2><h3>By Bill Loeb</h3><I>Bill is a senior software engineer at Stingray Software and can be contacted at wloeb@stingray.com.</I><hr><p>Version 1.2 of the Java Development Kit (JDK) includes the Java 2D API -- a set of functions that is a more flexible and full-featured rendering package than previous versions of the Abstract Windowing Toolkit (AWT). The 2D API provides enhanced graphics, text and image handling, as well as color definition and composition, hit detection on shapes and text, and device-independent printing.</p><p>The 2D API is designed to be extensible. The graphics operations of previous versions of the API performed a few specific functions. The graphics operations included in JDK 1.2 expand on that original functionality by supporting more-general graphics operations that can be extended.</p><p>The advantages of the 2D API are many. JDK 1.1 gave you the ability to draw simple shapes like rectangles, ellipses, and polygons with a single-width line. With JDK 1.2, you can draw virtually any shape with different line styles, fill styles and textures. Two-dimensional transforms can be used to translate, rotate, scale, or shear any graphical object. Clipping regions can be applied when drawing the shapes. Overlapping colors can be blended together to create a transparency effect.</p><p>To demonstrate the Java 2D API, I'll start with a drawing program that doesn't use the Java 2D API -- you could compile and run <i>TooDee</i> under the JDK 1.1 without problems. <A NAME="rl1"><A HREF="9902c.htm#l1">Listing One</A> presents the <i>Too-Dee</i> class, which extends <i>Canvas</i> and provides a white surface on which to draw. The <i>main()</i> method just creates a frame and sets up its dimensions. The <i>paint()</i> method merely takes the standard graphics context of the canvas and draws a blue rectangle on it.</p><h3>Adding Java 2D</h3><p>So, what does it take to start using the 2D API in a class such as <i>TooDee</i>? Not much. The 1.2 graphics functionality was designed with backward compatibility in mind.</p><p>The 1.2 graphics context class <i>java.awt.Graphics2D</i> adds most of the operations commonly used to draw shapes. Conveniently, it is derived from the original <i>java.awt.Graphics</i> class and maintains all of the original functionality. When using the JDK 1.2, the <i>Graphics2D</i> object is passed into methods like <i>paint()</i>, even though the method declaration still shows the old <i>Graphics</i> object. Therefore, to use the <i>Graphics2D</i> object all you really need to do to is cast the <i>Graphics</i> object that was passed to a <i>Graphics2D</i> object like this: <i>Graphics2D g2 = (Graphics2D)g;</i>.</p><p><A NAME="rl2"><A HREF="9902c.htm#l2">Listing Two</A> shows the <i>paint()</i> method of the <i>TooDee</i> canvas using the <i>Graphics2D</i> class to draw our blue rectangle. To show that I'm actually doing something different, I set the stroke object in the graphics context to draw the lines of the rectangle with a width of 4. (The stroke object in the <i>Graphics2D</i> context determines how lines are drawn.)</p><h3>Drawing Shapes</h3><p>There are three steps to rendering shapes in the 2D API. These remain basically unchanged from previous versions of the AWT:</p><ol type="1" start="1">	<LI>Set up the graphics context.	<LI>Define the object to draw.	<LI>Call one of the rendering methods.</ol><p>You can see these three steps in the existing <i>paint()</i> method, with the exception of the second and third steps, which are lumped together in the call to <i>drawRect()</i>. To shift the <i>paint()</i> method to use the 2D API, start with the graphical objects that implement the <i>java.awt.Shape </i>interface.</p><p>The <i>Shape</i> interface is used to define geometric shapes for use by the 2D API. As long as you implement the methods defined by this interface, you can create any shape you like. Many common shapes are already provided for you in the <i>java.awt.geom</i> package, including lines, curves, ellipses, rectangles, and rounded rectangles.</p><p>There are several key methods in the <i>Graphics2D</i> class that operate on <i>Shapes</i>. The most important to us here is <i>draw()</i>, which will draw any <i>Shape</i> using the current settings of the graphics context. The <i>paint()</i> method in <A NAME="rl3"><A HREF="9902c.htm#l3">Listing Three</A> demonstrates this by creating a <i>Rectangle2D Shape</i> and sending it to the <i>draw()</i> method. The <i>paint()</i> method now follows the standard three steps.</p><p>There are a couple of things to note about the predefined <i>Shapes</i> in the 2D API. The first is that the class names all end with "2D." The second is that each <i>Shape</i> has two subclasses, one named <i>Float</i> and one named <i>Double</i>. This lets you choose the precision of the stored values. In this case, to use floating-point numbers, I chose <i>java.awt.geom.Rectangle2D.Float</i>. <i>Rectangle2D</i> is an abstract superclass that cannot be instantiated.</p><p>So what about the <i>java.awt.Rectangle</i> object in <A HREF="9902c.htm#l1">Listing One</A>? This is a holdover from JDK 1.1 and couldn't possibly implement the <i>Shape</i> interface, right? Actually, while the rectangle object is still in the java.awt package in JDK 1.2, it is now derived from <i>Rectangle2D,</i> and therefore can be passed into new methods, such as <i>draw()</i>.</p><h3>Stroking Shapes</h3><p>The <i>Graphics2D</i> context has an object that implements <i>java.awt.Stroke</i>, which determines how lines are drawn. Once you set the <i>Stroke</i> in the graphics context using the <i>setStroke()</i> method, all subsequent lines drawn in the graphics context will have those characteristics until the <i>Stroke</i> is changed again.</p><p>Since <i>Stroke</i> is an interface, you can create your own custom <i>Strokes</i>. There is one <i>Stroke</i> object provided for your convenience -- <i>java.awt.BasicStroke</i>, which allows you to change the most common properties of a drawn line, such as the line width, the line style (solid, dotted, dashed, and so on), the line-end cap style, and the line-join style.</p><p>The one major piece of information left out of the <i>BasicStroke</i> object is the color of the line. This is maintained separately by the graphics context with a <i>Paint</i> object, and can be set by calling the <i>setPaint()</i> method. A <i>Paint</i> object is any class that implements the <i>java.awt.Paint</i> interface. Luckily, the <i>java.awt.Color</i> object implements the <i>Paint</i> interface and you can use the colors you are familiar with from JDK 1.1. In <A HREF="9902c.htm#l3">Listing Three</A>, calling <i>setColor()</i> still sets the line color.</p><p><A NAME="rl4"><A HREF="9902c.htm#l4">Listing Four</A> shows a more advanced use of the <i>BasicStroke</i> object. Here, I set up a <i>Stroke</i> object to draw lines with a width of 4, a rounded-end cap style, a bevel-join style, and a dashing style where there are lines of length 20 followed by spaces of length 10 (as defined in the <i>dash[]</i> array). I've made the rectangle a little bigger so that when the program is run, all of the effects are noticeable. The rectangle is obviously dashed, the dashed lines have rounded ends, and the corners of the rectangle are beveled where the lines meet. You can play around with the values passed into the <i>BasicStroke</i> constructor and witness the effects when <i>TooDee</i> is executed.</p><h3>Filling Shapes</h3><p>Filling <i>Shapes</i> works on the same principles as stroking <i>Shapes</i>. The <i>Paint</i> object in the graphics context also determines how <i>Shapes</i> are filled. To change the fill style, you just pass in a new <i>Paint</i> object to the <i>setPaint()</i> method of the <i>Graphics2D</i> object. It is important to note that the standard <i>draw()</i> method does not automatically fill a <i>Shape</i> for you -- it handles <i>Stroking</i> only. Instead, you need to call the separate <i>fill()</i> method, which also takes any <i>Shape</i> as a parameter.</p><p>Since <i>Paint</i> is an interface, you can create your own custom fills by creating new classes that implement it. There are several <i>Paint</i> objects already available for you to work with: a solid color, color gradient, and texture paint.</p><p>Filling with a solid color is straightforward, since the old <i>java.awt.Color</i> implements the <i>Paint</i> interface. In <A NAME="rl5"><A HREF="9902c.htm#l5">Listing Five</A>, all you need to do is call <i>setPaint()</i> with the <i>Color</i> of your choice and call <i>fill()</i> with the <i>Shape</i> you wish to fill.</p><p>The <i>java.awt.GradientPaint</i> object implements the <i>Paint</i> interface and provides a few useful constructors for setting the starting coordinates, starting <i>Color</i>, ending coordinates, and ending <i>Color</i> of the gradient. <A NAME="rl6"><A HREF="9902c.htm#l6">Listing Six</A> shows the same circle from <A HREF="9902c.htm#l5">Listing Five</A> being filled, but with a color gradient beginning in the top-left corner with blue, and then fading to green in the bottom-right corner.</p><p>Texture fills are accomplished with the help of the <i>java.awt.TexturePaint</i> object. A <i>TexturePaint</i> takes a <i>BufferedImage</i> that acts as the texture and a rectangle that defines the area of the <i>BufferedImage</i> to replicate for the texture. In the <i>paint()</i> method in <A NAME="rl7"><A HREF="9902c.htm#l7">Listing Seven</A>, you first create a <i>BufferedImage</i> in memory and draw a simple pattern onto it. Then you create a <i>TexturePaint</i> object out of the <i>BufferedImage</i> and add it to the graphics context as our <i>Paint</i> object.</p><p>When you were drawing into the buffered image's graphics context, you used the old JDK 1.1 methods <i>setColor()</i> and <i>fillRect()</i>. Remember that <i>Graphics2D</i> is derived from the original <i>Graphics</i> object and you can still use all of its drawing methods. Whether you use the old methods or the new methods is a matter of what works for you. In this case, it was convenient to make the two calls to <i>fillRect()</i> rather than creating two different <i>Rectangle2D</i> objects and calling <i>draw()</i> on each.</p><p>Another important fact to keep in mind is that the same <i>setPaint()</i> method sets up the graphics context for both <i>Strokes</i> and <i>Fills</i>. Therefore, it makes sense that you could draw lines that are drawn with textures or gradients. This is exactly what is demonstrated in the <i>paint()</i> method in <A NAME="rl8"><A HREF="9902c.htm#l8">Listing Eight</A>. Here, a <i>Stroke</i> of width 10 is defined so that you can see what is going on, and the <i>GradientPaint</i> from <A HREF="9902c.htm#l6">Listing Six</A> is used to draw an outline of the circle with the blue-green gradient. This is a good example of just how flexible the 2D API is.</p><h3>Rendering Hints</h3><p>There are a set of options with which you can set priorities between rendering speed and quality, called "Rendering Hints." These are available so that you can determine which is more important to your Java program -- looking better or drawing faster. All the hints are kept in a single <i>RenderingHint</i> object maintained by the graphics context.</p><p>There are many rendering hints, and you distinguish between them by passing the proper key into the <i>setRenderingHint()</i> method in the graphics context along with the value to set for the hint. The two most commonly used keys are KEY_RENDERING and KEY_ANTIALIASING. The former lets you choose an overall preference between speed and quality, and the latter whether or not to smooth out graphics as they are drawn. Most of the remaining hints relate to image processing.</p><p>For example, to set the hint for rendering quality, you make a call with the key and the value: <i>g2.setRenderingHint(RenderingHints.KEY_RENDERING,RenderingHints.VALUE_RENDER_QUALITY);.</i></p><p>If you want to set the hint to prefer speed to quality, you would pass in <i>RenderingHints.VALUE_RENDER_SPEED</i> instead. <A NAME="rl9"><A HREF="9902c.htm#l9">Listing Nine</A> takes the previous gradient stroke example and adds in our two hints for quality. You should be able to see the difference, especially on the interior of the <i>Stroke</i>.</p><p>Not all platforms support all rendering hints. The ability of a particular machine to implement a hint depends on the available hardware.</p><h3>Transformations</h3><p>Any <i>Shape</i> or image can be drawn translated, rotated, scaled, or sheared through the use of a transformation. The graphics context maintains a <i>java.awt.geom.AffineTransform</i> object that determines how the coordinate system of the drawing surface will be transformed before rendering takes place. Basically, an <i>AffineTransform</i> is a two-dimensional matrix that transforms the values of the geometry being drawn from the normal coordinate system into a modified one.</p><p>For instance, a rectangle drawn from (100,100) to (200,200) without a transform will be drawn just how you expect. However, if you set the transform in the graphics context to be rotated by 45 degrees, the coordinates of the rectangle will remain the same, but they will be transformed to the rotated coordinate space just before the rectangle is drawn. This makes it appear at a 45-degree angle with respect to the origin. </p><p>These transforms are for the entire coordinate system of the window. This means the rotation described earlier will rotate the rectangle around the origin, which is defined as the top-left corner of the canvas. The rectangle will not be rotated in place!</p><p>To set the transform in the graphics context you must first create and initialize an <i>AffineTransform</i> object, and then pass it to the <i>setTransform</i> method. The <i>AffineTransform</i> object has many convenient methods for setting up the transformation. Usually, all you need to do is call one method, such as <i>rotate()</i>, and you are good to go.</p><p><A NAME="rl10"><A HREF="9902c.htm#l10">Listing Ten</A> demonstrates the use of transformations by rotating a rectangle 10 degrees around the origin.</p><h3>Creating Custom Shapes</h3><p>The <i>Shapes</i> provided by the 2D API are sufficient for many programs. If you get into more advanced graphics work, however, chances are you will need to create your own custom shapes. One of the ways to do this is to implement the <i>Shape</i> interface in your own object. You could then set up your <i>Shape</i> with whatever geometry you have in mind.</p><p>Another way to make a custom <i>Shape</i> is to use the <i>java.awt.geom.GeneralPath</i> object. This is a <i>Shape</i> that lets you piece together other <i>Shapes</i> to form a single object. This is useful for tacking together lines and curves to create a custom outline.</p><p>To add a new <i>Shape</i> to a <i>GeneralPath</i>, you call the <i>append()</i> method, which takes a <i>Shape</i> to append plus a Boolean indicating if the geometry passed in should be connected to the existing geometry in the <i>GeneralPath</i>. <A NAME="rl11"><A HREF="9902c.htm#l11">Listing Eleven</A> is an example of two lines and a curve combined together to create a custom shape.</p><p>The 2D API also provides a set of operations that perform constructive-area geometry to create new <i>Areas</i> out of two existing <i>Shapes</i>. The <i>Area</i> object is another class which implements the <i>Shape</i> interface and can perform the Boolean operations add, subtract, intersect, and exclusive OR. These operations can only be performed with <i>Area</i> objects, but it is easy to create <i>Areas</i> out of <i>Shapes</i>.</p><p>The <i>Area</i> constructor takes a <i>Shape</i> as a parameter and gathers all of the necessary information from it. Once you have two <i>Area</i> objects, you may use the Boolean operations to combine the areas. The call would look something like:</p><blockquote><p>area1 = new Area(shape1);</p><p>area1.intersect(new Area(shape2));</p></blockquote><p>This would place the results of the Boolean intersection in the area1 object. <A NAME="rl12"><A HREF="9902c.htm#l12">Listing Twelve</A> shows this technique being used to create a square with a circular hollow within it.</p><h3>Conclusion</h3><p>The Java 2D API is a powerful and extensible graphics enhancement to the JDK that makes life much easier if you have advanced graphics needs. It is simple to move your JDK 1.1 code to use the graphics system in the JDK 1.2 because such great efforts were made to make the 2D API backward compatible. Your existing programs will work without problems, but you now have the ability to utilize the new capabilities.</p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</A></H4><pre>import java.awt.*;import java.awt.event.*;public class TooDee extends Canvas {    public TooDee() {        setBackground(Color.white);    }    public void paint(Graphics g) {        g.setColor(Color.blue);        g.drawRect(100,100,100,100);    }    public static void main(String argv[]) {        WindowListener l = new WindowAdapter() {            public void windowClosing(WindowEvent e) {System.exit(0);}        };        Frame f = new Frame("Too Dee");        f.addWindowListener(l);        f.add("Center", new TooDee());        f.pack();        f.setSize(new Dimension(400,400));        f.show();    }}</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>public void paint(Graphics g) {    Graphics2D g2 = (Graphics2D)g;    g2.setColor(Color.blue);    g2.setStroke(new BasicStroke(4.0f));    g2.drawRect(100,100,100,100);}</pre><P><A HREF="#rl2">Back to Article</A></P><H4><A NAME="l3">Listing Three</H4><pre> ...import java.awt.geom.*; // need the geometry package for Shapes ...public void paint(Graphics g) {    Graphics2D g2 = (Graphics2D)g;    // Step 1: Set up the graphics context    g2.setColor(Color.blue);    g2.setStroke(new BasicStroke(4.0f));    // Step 2: Define the object to draw    Rectangle2D r = new Rectangle2D.Float(100.0f,100.0f,100.0f,100.0f);    // Step 3: Call one of the rendering methods    g2.draw(r);}</pre><P><A HREF="#rl3">Back to Article</A></P><H4><A NAME="l4">Listing Four</H4><pre>public void paint(Graphics g) {    Graphics2D g2 = (Graphics2D)g;    float dash[] = { 20.0f, 10.0f };    g2.setPaint(Color.blue);   g2.setStroke(new BasicStroke(        4.0f,                   // line width        BasicStroke.CAP_ROUND,  // end cap style        BasicStroke.JOIN_BEVEL, // join style        0.0f,                   // miter limit        dash,                   // dash array        0.0f));                 // dash phase    Rectangle2D r = new        Rectangle2D.Float(100.0f,100.0f,200.0f,200.0f);    g2.draw(r);}</pre><P><A HREF="#rl4">Back to Article</A></P><H4><A NAME="l5">Listing Five</H4><pre>public void paint(Graphics g) {    Graphics2D g2 = (Graphics2D)g;    Ellipse2D e = new Ellipse2D.Float(100.0f,100.0f,100.0f,100.0f);    // draw the interior in blue    g2.setPaint(Color.blue);    g2.fill(e);    // draw the outline in red    g2.setPaint(Color.red);    g2.draw(e);}</pre><P><A HREF="#rl5">Back to Article</A></P><H4><A NAME="l6">Listing Six</H4><pre>public void paint(Graphics g) {    Graphics2D g2 = (Graphics2D)g;    Ellipse2D e = new Ellipse2D.Float(100.0f,100.0f,100.0f,100.0f);    GradientPaint gp = new GradientPaint(        100.0f, 100.0f, // starting point        Color.blue,     // starting color        200.0f, 200.0f, // ending point        Color.green);   // ending color    g2.setPaint(gp);    g2.fill(e);    g2.setPaint(Color.red);    g2.draw(e);}</pre><P><A HREF="#rl6">Back to Article</A></P><H4><A NAME="l7">Listing Seven</H4><pre> ...import java.awt.image.*; // needed for BufferedImage ...public void paint(Graphics g) {    Graphics2D g2 = (Graphics2D)g;    Ellipse2D e = new Ellipse2D.Float(100.0f,100.0f,100.0f,100.0f);    BufferedImage bi = new BufferedImage(        5,  // width        5,  // height        BufferedImage.TYPE_INT_RGB);    // RGB image    // Get the graphics context of the image and draw into it    Graphics2D big = bi.createGraphics();    big.setColor(Color.blue);    big.fillRect(0,0,6,6);    big.setColor(Color.green);    big.fillRect(2,2,4,4);    // Create the texture from the complete image    Rectangle2D r = new Rectangle2D.Float(0.0f,0.0f,6.0f,6.0f);    TexturePaint tp = new TexturePaint(bi, r);<p></p>    g2.setPaint(tp);    g2.fill(e);    g2.setPaint(Color.red);    g2.draw(e);}</pre><P><A HREF="#rl7">Back to Article</A></P><H4><A NAME="l8">Listing Eight</H4><pre>public void paint(Graphics g) {    Graphics2D g2 = (Graphics2D)g;    Ellipse2D e = new Ellipse2D.Float(100.0f,100.0f,100.0f,100.0f);    GradientPaint gp = new GradientPaint(        100.0f, 100.0f, // starting point        Color.blue,     // starting color        200.0f, 200.0f, // ending point        Color.green);   // ending color    g2.setPaint(gp);    g2.setStroke(new BasicStroke(10.0f));    g2.draw(e);}</pre><P><A HREF="#rl8">Back to Article</A></P><H4><A NAME="l9">Listing Nine</H4><pre>public void paint(Graphics g) {    Graphics2D g2 = (Graphics2D)g;<p></p>    g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,                        RenderingHints.VALUE_ANTIALIAS_ON);    g2.setRenderingHint(RenderingHints.KEY_RENDERING,                        RenderingHints.VALUE_RENDER_QUALITY);    Ellipse2D e = new Ellipse2D.Float(100.0f,100.0f,100.0f,100.0f);    GradientPaint gp = new GradientPaint(        100.0f, 100.0f, // starting point        Color.blue,     // starting color        200.0f, 200.0f, // ending point        Color.green);   // ending color    g2.setPaint(gp);    g2.setStroke(new BasicStroke(10.0f));    g2.draw(e);}</pre><P><A HREF="#rl9">Back to Article</A></P><H4><A NAME="l10">Listing Ten</H4><pre>public void paint(Graphics g) {    Graphics2D g2 = (Graphics2D)g;    Rectangle r = new Rectangle(100,100,100,100);    // Set up a rotation of 10 degrees around the origin.    // Note that we need to convert from degrees to radians.    AffineTransform t = new AffineTransform();    t.rotate(10*java.lang.Math.PI/180);    g2.setTransform(t);<p></p>    g2.setPaint(Color.blue);    g2.fill(r);    g2.setPaint(Color.red);    g2.draw(r);}</pre><P><A HREF="#rl10">Back to Article</A></P><H4><A NAME="l11">Listing Eleven</H4><pre>public void paint(Graphics g) {    Graphics2D g2 = (Graphics2D)g;<p></p>    GeneralPath gp = new GeneralPath();    Line2D l1 = new Line2D.Float(50.0f,100.0f,100.0f,100.0f);    gp.append(l1, true);    CubicCurve2D cc = new CubicCurve2D.Float(        100.0f,100.0f,  // starting point        125.0f,125.0f,  // control point 1        150.0f,125.0f,  // control point 2        175.0f,100.0f); // ending point    gp.append(cc, true);<p></p>    Line2D l2 = new Line2D.Float(175.0f,100.0f,225.0f,100.0f);    gp.append(l2, true);<p></p>    g2.setStroke(new BasicStroke(4.0f));    g2.setPaint(Color.blue);    g2.draw(gp);}</pre><P><A HREF="#rl11">Back to Article</A></P><H4><A NAME="l12">Listing Twelve</H4><pre>public void paint(Graphics g) {    Graphics2D g2 = (Graphics2D)g;    Rectangle r = new Rectangle(100,100,100,100);    Area a = new Area(r);<p></p>    Ellipse2D e = new Ellipse2D.Float(150.0f,150.0f,25.0f,25.0f);    a.subtract(new Area(e));<p></p>    g2.setPaint(Color.blue);    g2.fill(a);<p></p>    g2.setPaint(Color.red);    g2.draw(a);}</pre><P><A HREF="#rl12">Back to Article</A></P><p><b>DDJ</b></p><HR><I>Copyright &copy; 1999, Dr. Dobb's Journal</I><BR>
</body></html>