<html><head><title>Apr99: The HMAC Algorithm</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>The HMAC Algorithm</h1><h2>Key hashing for message authentication</h2><h3>By William Stallings</h3><I>William is a consultant, lecturer, and author of books on data communications and computer networking. His most recent book is Cryptography and Network Security: Principles and Practice, Second Edition (Prentice-Hall, 1998). He can be contacted at http://www.shore.net/~ws.</I><hr><p>Message authentication is a procedure that allows communicating parties to verify that received messages are authentic. The two important aspects are verifying that the contents of the message have not been altered and that the source is authentic. The Message Authentication Code (MAC) is a widely used technique for performing message authentication. A variation on the MAC algorithm has emerged as an Internet standard for a wide variety of applications -- HMAC, short for "Keyed-Hashing for Message Authentication." HMAC was introduced in "Keying Hash Functions for Message Authentication," by M. Bellare, R. Canetti, and H. Krawczyk in <i>Proceedings, CRYPTO '96</i> (Springer-Verlag,andathttp://wwwcse .ucsd.edu/users/mihir). HMAC is currently an Internet draft that has been distributed by the Internet Engineering Task Force as Request For Proposal (RFP) 2104.</p><h3>MAC</h3><p>MAC algorithms involve the use of a secret key to generate a small block of data, known as a "message authentication code," that is appended to the message. This technique assumes that two communicating parties, say A and B, share K as a secret key. When A has a message to send to B, it calculates the message authentication code as a function of the message and the key. The message and code are transmitted to the intended recipient. The recipient performs the same calculation on the received message, using the same secret key, to generate a new message authentication code. The received code is compared to the calculated code; see <A NAME="rf1"><A HREF="9904ef1.htm">Figure 1</A>. If you assume that only the receiver and the sender know the identity of the secret key, and if the received code matches the calculated code, then:</p><p></p><p>1. The receiver is assured that the message has not been altered. If an attacker alters the message but does not alter the code, then the receiver's calculation of the code will differ from the received code. Because the attacker is assumed not to know the secret key, the attacker cannot alter the code to correspond to the alterations in the message.</p><p>2. The receiver is assured that the message is from the alleged sender. Because no one else knows the secret key, no one else could prepare a message with the proper code.</p><p>3. If the message includes a sequence number (such as is used with X.25, HDLC, and TCP), then the receiver can be assured of the proper sequence, because an attacker cannot successfully alter the sequence number.</p><p>A number of algorithms could be used to generate the code. The National Bureau of Standards (NBS), in its publication <i>DES Mode of Operation</i> (http://www.nist .gov/itl/div897/pubs/fip113.htm), recommends the use of the DES algorithm. The DES algorithm is used to generate an encrypted version of the message, and the last bits of ciphertext are used as the code. A 16- or 32-bit code is typical. HMAC is a more efficient, and increasingly popular, alternative.</p><p>The process just described is similar to encryption. One difference is that the authentication algorithm does not need to be reversible, as it must for decryption. It turns out that because of the mathematical properties of the authentication function, it is less vulnerable than encryption to being broken.</p><h3>HMAC</h3><p>In recent years, there has been increased interest in developing a MAC derived from a cryptographic hash code, such as MD5, SHA-1, or RIPEMD-160. The motivations for this interest are:</p><p></p><ul>  <li>Cryptographic hash functions generally execute faster in software than symmetric block ciphers such as DES.  <li>Library code for cryptographic hash functions is widely available.  <li>There are no export restrictions for cryptographic hash functions, whereas symmetric block ciphers, even when used for MACs, are restricted. </ul><p>A hash function such as MD5 was not designed for use as a MAC and cannot be used directly for that purpose because it does not rely on a secret key. There have been a number of proposals to incorporate a secret key into an existing hash algorithm. HMAC received the most support. HMAC has been chosen as the mandatory-to-implement MAC for IP Security, and is used in other Internet protocols, such as Transport Layer Security (TLS, soon to replace Secure Sockets Layer) and Secure Electronic Transaction (SET).</p><h3>HMAC-Design Objectives</h3><p>Design objectives that RFC 2104 lists for HMAC include:</p><p></p><ul>  <li>To use, without modifications, available hash functions. In particular, hash functions that perform well in software, and for which code is freely and widely available.  <li>To allow for easy replaceability of the embedded hash function in case faster or more secure hash functions are found or required.   <li>To preserve the original performance of the hash function without incurring a significant degradation.  <li>To use and handle keys in a simple way.  <li>To have a well understood cryptographic analysis of the strength of the authentication mechanism based on reasonable assumptions on the embedded hash function.</ul><p>The first two objectives are important to the acceptability of HMAC. HMAC treats the hash function as a black box. This has two benefits. First, an existing implementation of a hash function can be used as a module in implementing HMAC. The bulk of the HMAC code is prepackaged and ready to use without modification. Second, to replace a given hash function in an HMAC implementation, you must simply remove the existing hash function module and drop in the new module. This could be done if a faster hash function were desired. More important, if the security of the embedded hash function were compromised, the security of HMAC could be retained simply by replacing the embedded hash function with a more secure one (replacing MD5 with SHA-1, for example). </p><p>The last design objective in the preceding list is, in fact, the main advantage of HMAC over other proposed hash-based schemes. HMAC can be proven secure provided that the embedded hash function has some reasonable cryptographic strengths. </p><h3>The HMAC Algorithm </h3><p><A NAME="rf2"><A HREF="9904ef2.htm">Figure 2</A> illustrates the overall operation of HMAC (see <A NAME="rt1"><A HREF="9904et1.htm">Table 1</A> for definition of the terms in <A NAME="rf2"><A HREF="9904ef2.htm">Figure 2</A>). HMAC can then be expressed; see <A NAME="rf3"><A HREF="9904ef3.htm">Figure 3</A>. In other words:</p><p></p><p>1. Append zeros to the left end of <i>K </i>to create a <i>b</i>-bit string <i>K<sup>+</sup> </i>(for example, if <i>K </i>is of length 160 bits and <i>b</i> = 512, then <i>K </i>will be appended with 44 zero bytes 0x00).</p><p>2. XOR (bitwise exclusive OR) <i>K<sup>+</sup> </i>with <i>ipad</i> to produce the <i>b</i>-bit block S<sub><i>i</i></sub>.</p><p>3. Append <i>M </i>to <i>S<sub>i</sub>.</i></p><p>4. Apply <i>H </i>to the stream generated in Step 3.</p><p>5. XOR <i>K<sup>+</sup> </i>with <i>opad</i> to produce the <i>b</i>-bit block S<sub><i>o</i></sub>.</p><p>6. Append the hash result from Step 4 to <i>S</i><sub>o</sub>.</p><p>7. Apply <i>H </i>to the stream generated in Step 6 and output the result.</p><p>Note the XOR with <i>ipad</i> results in flipping one-half of the bits of <i>K. </i>Similarly, the XOR with <i>opad</i> results in flipping one-half of the bits of <i>K, </i>but a different set of bits. In effect, by passing <i>S<sub>i</i></sub> and <i>S<sub>o</i></sub> through the compression function of the hash algorithm, you have pseudorandomly generated two keys from <i>K. </i>HMAC should execute in approximately the same time as the embedded hash function for long messages. HMAC adds three executions of the hash compression function (for <i>S<sub>i</sub>, S<sub>o</sub>, </i>and the block produced from the inner hash).</p><h3>HMAC Security </h3><p>The security of any MAC function based on an embedded hash function depends in some way on the cryptographic strength of the underlying hash function. The appeal of HMAC is that its designers have been able to prove an exact relationship between the strength of the embedded hash function and the strength of HMAC. The security of a MAC function is generally expressed in terms of the probability of successful forgery with a given amount of time spent by the forger and a given number of message-MAC pairs created with the same key. In essence, it can be shown that, for a given level of effort (time, message-MAC pairs), on messages generated by legitimate users and seen by attackers, the probability of a successful attack on HMAC is equivalent to one of the following attacks on the embedded hash function:</p><p></p><p>1. Attackers are able to compute an output of the compression function even with an Initial Value (IV) that is random, secret, and unknown to attackers.</p><p>2. Attackers find collisions in the hash function even when the IV is random and secret.</p><p></p><p>In the first attack, you can view the compression function as equivalent to the hash function applied to a message consisting of a single <i>b</i>-bit block. For this attack, the IV of the hash function is replaced by a secret, random value of <i>n</i> bits. An attack on this hash function requires either a brute-force attack on the key, which is a level of effort on the order of 2<sup><i>n</i></sup>, or a birthday attack, which is a special case of the second attack.</p><p>In the second attack, attackers are looking for two messages, <i>M </i>and <i>M',</i>that produce the same hash: <i>H(M)=H(M'). </i>This requires a level of effort of 2<sup><i>n</i>/2</sup> for a hash length of <i>n</i>. On this basis, the security of MD5 is called into question, because a level of effort of 2<sup>64</sup> looks feasible with today's technology. Does this mean that a 128-bit hash function such as MD5 is unsuitable for HMAC? The answer is no. To attack MD5, attackers can choose any set of messages and work on these offline on a dedicated computing facility to find a collision. Because attackers know the hash algorithm and the default IV, attackers can generate the hash code for each of the messages that attackers generate. However, when attacking HMAC, attackers cannot generate message/code pairs offline because attackers do not know <i>K. </i>Therefore, attackers must observe a sequence of messages generated by HMAC under the same key and perform the attack on these known messages. For a hash code length of 128 bits, this requires 2<sup>64 </sup>observed blocks (2<sup>73 </sup>bits) generated using the same key. On a 1-Gbps link, you would need to observe a continuous stream of messages with no change in the key for about 250,000 years to succeed. Thus, if speed is a concern, it is fully acceptable to use MD5 rather than SHA-1 or RIPEMD-160 as the embedded hash function for HMAC.</p><p><A NAME="rl1"><A HREF="#l1">Listing One</A>, the appendix to RFC 2104, is sample code for the implementation of HMAC with MD5. <A NAME="rl2"><A HREF="#l2">Listing Two</A> (also from RFC 2104) presents test vectors for <A NAME="rl1"><A HREF="#l1">Listing One</A> (trailing '\0' of a character string not included). </p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>/* Function: hmac_md5 */voidhmac_md5(text, text_len, key, key_len, digest)unsigned char* text; /* pointer to data stream */int text_len; /* length of data stream */unsigned char* key; /* pointer to authentication key */int key_len; /* length of authentication key */caddr_t digest; /* caller digest to be filled in */{     MD5_CTX context;         unsigned char k_ipad[65]; /* inner padding - key XORd with ipad */         unsigned char k_opad[65]; /* outer padding - key XORd with opad */         unsigned char tk[16];         int i;         /* if key is longer than 64 bytes reset it to key=MD5(key) */         if (key_len &gt; 64) {     MD5_CTX      tctx;     MD5Init(&amp;tctx);     MD5Update(&amp;tctx, key, key_len);     MD5Final(tk, &amp;tctx);     key = tk;     key_len = 16;     }             /* the HMAC_MD5 transform looks like:              * MD5(K XOR opad, MD5(K XOR ipad, text))              * where K is an n byte key              * ipad is the byte 0x36 repeated 64 times              * opad is the byte 0x5c repeated 64 times              * and text is the data being protected              */             /* start out by storing key in pads */             bzero( k_ipad, sizeof k_ipad);             bzero( k_opad, sizeof k_opad);             bcopy( key, k_ipad, key_len);             bcopy( key, k_opad, key_len);             /* XOR key with ipad and opad values */             for (i=0; i&lt;64; i++) {                     k_ipad[i] ^= 0x36;                     k_opad[i] ^= 0x5c;             }             /* perform inner MD5 */             MD5Init(&amp;context);               /* init context for 1st pass */             MD5Update(&amp;context, k_ipad, 64)      /* start with inner pad */             MD5Update(&amp;context, text, text_len); /* then text of datagram */             MD5Final(digest, &amp;context);          /* finish up 1st pass */             /* perform outer MD5 */             MD5Init(&amp;context);               /* init context for 2nd pass */             MD5Update(&amp;context, k_opad, 64); /* start with outer pad */             MD5Update(&amp;context, digest, 16); /* then results of 1st hash */             MD5Final(digest, &amp;context);      /* finish up 2nd pass */}</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>key =         0x0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0bkey_len =     16 bytesdata =        "Hi There"data_len =    8  bytesdigest =      0x9294727a3638bb1c13f48ef8158bfc9dkey =         "Jefe"data =        "what do ya want for nothing?"data_len =    28 bytesdigest =      0x750c783e6ab0b503eaa86e310a5db738key =         0xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkey_len       16 bytesdata =        0xDDDDDDDDDDDDDDDDDDDD...              ..DDDDDDDDDDDDDDDDDDDD...              ..DDDDDDDDDDDDDDDDDDDD...              ..DDDDDDDDDDDDDDDDDDDD...              ..DDDDDDDDDDDDDDDDDDDDdata_len =    50 bytesdigest =      0x56be34521d144c88dbb8c733f0e8b3f6</pre><P><A HREF="#rl2">Back to Article</A></P><HR><I>Copyright &copy; 1999, Dr. Dobb's Journal</I><BR>
</body></html>