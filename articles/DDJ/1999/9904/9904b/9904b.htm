<html><head><title>Apr99: Designing Algorithms Incrementally </title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Designing Algorithms Incrementally </h1><h2>Finding powerful problem-solving  techniques</h2><h3>By Udi Manber</h3><I>Udi is a professor of computer science at the University of Arizona. He can be  contacted at udi@cs.arizona.edu.</I><hr><p>Our first intuition when looking at an algorithmic problem is to think of the whole input and try to find a solution for it. We carry with us the intuition of the physical world; when we try to solve a problem, we have to deal with all of it. The incremental method is different. It assumes that you have already found a solution, and now someone gives you a slightly larger problem and asks you to extend the solution. If you can find a general way to extend the solution, then you can start with an empty input and keep extending it. Concentrating on the incremental is often easier and it leads to powerful techniques for attacking problems.</p><p>I called this method the "induction method" in my book <i>Introduction to Algorithms: A Creative Approach</i> (Addison-Wesley, 1989), because it employs the same principle as mathematical induction. Since then, I found that induction intimidates many people, and using it in this context can confuse things. So I'll stick with "incremental method" here, which is a clearer and more descriptive name. </p><p>The maximum rectangle problem, described wonderfully by David Vandevoorde in his article "The Maximal Rectangle Problem" (<i>DDJ</i>, April 1998), turns out to be a perfect example to illustrate the incremental method. (Vandevoorde referred to the problem as the "maximal rectangle problem," but "maximum" problem is more precise, because maximal usually means something that cannot be extended, whereas maximum means the global maximum.) The incremental method is not perfect, and it is not always the best way, but it is applicable most of the time, and it is definitely a technique every algorithm designer should keep in their arsenal. </p><h3>The Maximum Rectangle Problem </h3><p>The maximum rectangle problem can be summed up as:</p><blockquote><p>The input: An <i>N</i>&times;<i>M</i> binary matrix <i>B</i>. </p><p>The output: A rectangle in <i>B</i> of maximum area containing all 1s. </p></blockquote><p>The first issue when trying the incremental method is to define the incremental. For matrices, there aren't too many choices; either you add a new row or a new column. (I'll show later that this is not always straightforward.) Let's try a new row. Assume that you have found the largest rectangle in the original matrix, and that you are now given one additional row. You need to determine if there is an even larger rectangle with the new row. That already limits your search. You need to consider only rectangles that end at the last row. So all the 0s in the last row do not contribute. That means that you can divide the problem into several subproblems by looking only at intervals in the last row that contain only 1s; see <A NAME="rf1"><A HREF="9904bf1.htm">Figure 1</A>. The subproblems are independent of one another, so you need to consider only one of them at a time. The same solution will apply to all of them. </p><p>Looking at each subproblem, you are now looking for the maximum rectangle that ends at the last row, and you know that the last row contains all 1s. So you need to know, for each column <i>i</i>, the length of the bottom block of 1s; call it <i>C<sub>i</i></sub>. This kind of information is easy to maintain as you add rows; for each column, you either increment the bottom block length (if the last row contains a 1) or set it to 0 (if it contains a 0). The division into subproblems is used here mostly for simplicity; you can just as easily consider the whole row, with the 0s, as one problem. Given this information, you can now define your problem as a one-dimensional problem: </p><blockquote><p>The input: a sequence of integers,  <i>C<sub>1</i></sub>, <i>C<sub>2</i></sub>, ..., <i>C<sub>k</i></sub>.</p><p>The output: the interval <i>[i,j]</i> that maximizes the product of the length of the interval <i>(j-i)</i> times the minimum number in it. </p></blockquote><p>(The area of a rectangle of all 1s corresponds to such a product; the width of the rectangle corresponds to the length of the interval and its height corresponds to the minimum number in it.) </p><p>The incremental method lets you reduce a two-dimensional problem to a one-dimensional one. If you want to obtain an optimal <i>O(MN)</i> solution for the original problem, you will need to solve this one-dimensional problem in linear time <i>O(k).</i> Using the incremental method again, you assume that you know how to solve the problem up to <i>k </i>numbers, and you now need to handle the <i>k</i>+1 number; call it <i>C<sub>k</i>+1</sub>. If successful, this will reduce the problem one more time and allow us to concentrate on just one number. </p><p>You need to concentrate only on intervals that end at <i>C<sub>k</i></sub>, and check how <i>C<sub>k</i>+1</sub> can change them to produce better intervals. If <i>C<sub>k</i>+1</sub>>=<i>C<sub>k</i></sub>, then the best interval that ends at <i>C<sub>k</i></sub> can be extended to end at <i>C<sub>k</i>+1</sub>, without changing its minimum number, so it is the best possible interval. But, as <A NAME="rf2"><A HREF="9904bf2.htm">Figure 2</A> shows, if <i>C<sub>k</i>+1</sub>&lt;<i>C<sub>k</i></sub>, then you cannot easily determine the best interval. Without <i>C<sub>k</i>+1</sub>=3, the best interval (2a) consists of the last two numbers, giving the product min{6,5}&times;2=10. Extending that interval to include the 3 (2b) gives min{6,5,3}&times;3=9, which is not better. But since the minimum number is now 3, you can use a bigger interval (2c), leading to a product of min{3,6,5,3}&times;4=12. If you extend it all the way (2d), you get a product of min{4,2,3,6,5,3}&times;6=12. There is no easy way to figure it out by looking at only <i>C<sub>k</i>+1</sub> and the best interval up to <i>C<sub>k</i></sub>. That seems like a failure of the incremental method, because concentrating on <i>C<sub>k</i>+1</sub> alone does not seem to be sufficient.</p><p>But the incremental method can be applied in many different ways, which is why it is so powerful. Incrementing by adding one number at a time to the end of the sequence is the natural thing to do, but it is not the only way to increment. Maybe instead of incrementing by looking at the last number, <i>C<sub>k</i>+1</sub>, you should look at the first number, <i>C</i><sub>1</sub>? In this case, the first number has the exact same effect as the last number, so this will not help. But what about the minimum number in the sequence, or the maximum number? As it turns out, using the minimum number and using the maximum number lead to two different algorithms, both optimal.</p><p>Start with the minimum number; call it <i>m</i>. For simplicity, I'll use <i>m</i> both to point to the number and to its value. How can <i>m</i> be involved in the solution? If the best interval contains <i>m</i>, then that interval might as well contain everything. In other words, if <i>m</i> is involved then the best interval is the whole sequence. Keep that in mind, and check the alternatives. If <i>m</i> is not contained in the best interval, then the best interval is somewhere to the side of <i>m</i>, either to the left or to the right. You have now partitioned the problem into two independent subproblems, each of which can be solved recursively, so the problem is solved. In <A NAME="rf3"><A HREF="9904bf3.htm">Figure 3</A>, you see the intervals corresponding to choosing, from top to bottom, 2, 3, 4, 5, and 6. Getting a linear-time implementation of this solution is not straightforward, but since you spent only a constant time handling <i>m</i>, there is hope. </p><p>Let's try the incremental method concentrating on the maximum number; call it <i>M. </i>This turns out to be slightly more tricky, but it leads to an easier to implement algorithm. Again, how can <i>M </i>be involved in the solution? There are two possibilities when <i>M </i>is part of the interval. Either the interval consists of <i>M </i>by itself, in which case its area is <i>M</i>&times;1 = <i>M, </i>or the interval includes one of <i>M</i>'s neighbors as well. In the latter case, <i>M </i>will contribute no more than its neighbor contributes. So if you can figure out which neighbor to choose, you can assign<i> M</i>'s contribution to that neighbor by specifying that the neighbor is worth twice its size, and do away with <i>M. </i>If you can do that safely, you have an incremental solution, because you can continue to handle maximum numbers one at a time. </p><p>You allocate a counter to each number to indicate how many of its neighbors should be counted when this number is used for the best interval. You then remove <i>M </i>and increment the counter of one of its neighbors (the mystery of which neighbor to choose will be revealed in a minute). In effect, what will happen is that when the minimum number in an interval is considered, all its larger neighbors will have been considered by then, and their number will be assigned. So at that point the smallest number will know the size of its interval. </p><p>Suppose that the numbers are in decreasing order with the largest on the left. The algorithm will take <i>C</i><sub>1</sub> as the first rectangle by itself, then increment the counter of <i>C</i><sub>2</sub> to 2. In the second step, <i>C</i><sub>2</sub> counts twice (since its counter is 2), and so its rectangle is worth 2&times;<i>C</i><sub>2</sub>. Check whether this is larger than the previous best rectangle (<i>C</i><sub>1</sub>), and take the maximum of them. You then assign <i>C</i><sub>2</sub>'s counter to <i>C</i><sub>3</sub> which will be set at 3, and contribute 3&times;<i>C</i><sub>3</sub> and so on. This is the simplest case, and in general the algorithm works just as well. </p><p>Which neighbor to use -- the smaller or the larger? The answer is the larger, because it is the safer choice. Any interval that contains one of <i>M'</i>s neighbors will at least contain <i>M </i>and the larger of the neighbors (it may contain both neighbors). So by assigning <i>M'</i>s contribution to the larger neighbor you ensure that <i>M </i>will be considered for any interval that contains it. An example of using this algorithm for the matrix in <A NAME="rf1"><A HREF="9904bf1.htm">Figure 1</A> is in <A NAME="rf4"><A HREF="9904bf4.htm">Figure 4</A>. The contribution 6 is 1&times;6. The second largest is 5, whose counter is now 2, so it contributes 2&times;5. Next is 4, which assigns its contributions to its neighbor 2. Next is 3 (I chose the 3 to the right, but you could just as well chose the other one), which contributes 3&times;3. When the other 3 is considered, its counter is 4, so it contributes 4&times;3=12. The last one is 2, whose counter is now 6, leading to another best solution of 12.</p><p>The two algorithms suggested by the incremental method are not complete. You need to carefully design the right data structures to handle all the operations efficiently. The devil is in the details. But the details are easier once you have an overview and an understanding of the algorithm, which you now do. One of the strengths of the incremental method is the ease in which one gets to an algorithmic idea. </p><p>The algorithm demonstrated in <A NAME="rf4"><A HREF="9904bf4.htm">Figure 4</A> consists of the following four steps, which are repeated for each number: </p><p>1.	Find the next maximum <i>M.</i> </p><p>2.	Check <i>M</i>'s current contribution against the previous best. </p><p>3.	Assign<i> M</i>'s counter to its larger neighbor. </p><p>4.	Delete <i>M. </i></p><p>To get a repeated list of maximums you need to sort the numbers. Fortunately, all the numbers are in the range of 1 to <i>N </i>(since they sum the number of 1s in a column), so you can sort all of them in linear time using a simple bucket sort. Finding the neighbors of each number can be achieved by linking all the numbers in a doubly linked list, which also lets you delete each number. All these operations can be done in linear time. (The algorithm can be further simplified by noticing that the sort is not crucial, because the main step of assigning worth can be performed any time a number is larger than both its neighbors.)</p><h3>Conclusion</h3><p>The incremental method is particularly useful as a way to arrive at possible new algorithms. It can lead the way and suggest different approaches. It is not a magic bullet, and it will not replace intuition and experience, but it helps to develop both. </p><p></p><p><b>DDJ</b></p><HR><I>Copyright &copy; 1999, Dr. Dobb's Journal</I><BR>
</body></html>