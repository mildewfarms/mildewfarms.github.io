<html><head><title>Apr99: Algorithm Alley</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Analysis of Algorithms</h1><h3>By Jon Bentley</h3><I>Jon is a Member of Technical Staff at Lucent Technologies's Bell Labs. He can be reached at jlb@research.bell-labs.com.</I><hr><p>You've just designed a nifty new algorithm. It's fast, but exactly how fast is it? To help you find out, this column presents tools and techniques for analyzing the performance of algorithms. It starts with a simple program for an important problem, and improves it through several versions. </p><p>I originally presented versions of these algorithms in <i>Unix Review</i> magazine (June, 1997). In the process, I observed huge performance speedups -- a factor of 30,000 -- but didn't take the time to understand the details of the run times. This column analyzes those algorithms, with an emphasis on methods that real programmers might use to understand performance.</p><h3>The Problem</h3><p>The Traveling Salesman Problem (TSP) calls for finding the shortest tour through a collection of cities. <A NAME="rf1"><A HREF="9904nf1.htm">Figure 1</A> shows the shortest circuit through 14 cities that Abraham Lincoln visited when he rode the Illinois Eighth Circuit in 1850. This prototypical network design problem often arises in applications such as scheduling mechanical devices and factory production lines.</p><p>The fundamental mathematical abstraction for dealing with the TSP is a permutation -- an ordered sequence of objects. For instance, there are a total of six permutations of the three letters "a," "b," and "c":</p><blockquote><p>abc  acb  bac  bca  cab  cba</p></blockquote><p>In general, there are <i>n!</i> ("<i>n</i> factorial") permutations of <i>n</i> letters, where <i>n!</i>=<i>n</i>&times;(<i>n</i>-1)&times; (<i>n</i>-2)&times;...&times;3&times;2&times;1. This is because any one of the <i>n</i> elements can go in the first position, any one of the remaining <i>n</i>-1 elements can go in the second position, and so on down to the single remaining element that must go in the last position. The factorial function grows very quickly:</p><blockquote><p>10!=3,628,800,</p><p>20!<IMG SRC="aprxeq18.gif" ALT="" WIDTH="14" HEIGHT="10">2.43&times;10<sup>18</sup>, and</p><p>30!<IMG SRC="aprxeq18.gif" ALT="" WIDTH="14" HEIGHT="10">2.65&times;10<sup>32</sup>.</p></blockquote><p>A TSP tour is a permutation of the input cities, implicitly closed by the tour by traveling from the last city back to the first. The program tsp1.c (and a sample input file, both available electronically; see "Resource Center," page 5) deals with <i>n</i> cities, where <i>n</i> is a global variable:<i> int n;.</i></p><p>The code won't peek inside the representation of cities. Instead, it will access distances between cities with the distance function</p><blockquote><p>typedef double Dist;</p><p>Dist d(int i, int j)</p></blockquote><p>It will represent the tour in the vector <i>p</i></p><blockquote><p>int p[MAXN];</p></blockquote><p>where <i>p[0..n-1]</i> is a permutation of the cities in the tour. For instance, a tour that goes from city 3 to 1 to 4 then 2 (and finally back to 3) would be represented by the permutation vector 3 1 4 2.</p><h3>Algorithm 1: The Easiest Program</h3><p>The first algorithm is easy: It will recursively generate all <i>n!</i> permutations, and choose the one with least cost. Because it inspects so many tours, we can't expect the algorithm to be fast; we'll soon analyze it to see exactly how slow it is. Assume that the variables are initialized with </p><blockquote><p>for (i = 0; i &lt; n; i++)</p><p>     p[i] = i;</p><p>minsum = INF;</p></blockquote><p>The name <i>solve1</i> denotes that this is the first version:</p><blockquote><p>void solve1()</p><p>{  search1(n);</p><p>}</p></blockquote><p>The workhorse is the following search function. The parameter <i>m</i> tells how many elements of the vector <i>p</i> have yet to be permuted. It operates top-down by leaving <i>p[m..n-</i>1<i>]</i> fixed while it permutes <i>p[0..m-</i>1<i>]</i>:</p><blockquote><p>void search1(int m)</p><p>{   int i;</p><p>    if (m == 1)</p><p>       check1();</p><p>    else</p><p>        for (i = m-1; i &gt;= 0; i--) {</p><p>            swap(i, m-1);</p><p>            search1(m-1);</p><p>            swap(i, m-1);</p><p>        }</p><p>}</p></blockquote><p>The <i>swap</i> function exchanges pairs in the vector <i>p</i>. The <i>for</i> loop swaps each element in turn to the end, recurs with size <i>m</i> decreased by one, then swaps the element back to its original place. This code is short but subtle, and is worth serious study before proceeding.</p><p>When a complete permutation is fixed, <i>m</i> is 1 and <i>search1</i> calls the <i>check1</i> function:</p><blockquote><p>void check1()</p><p>{   int i;</p><p>    Dist sum = d(p[0], p[n-1]);</p><p>    for (i = 1; i &lt; n; i++)</p><p>        sum += d(p[i-1], p[i]);</p><p>    save(sum);</p><p>}</p></blockquote><p>This function computes the cost of the tour by summing the <i>n</i>-1 distances between adjacent points and adding in the distance from the last point to the first. The <i>save</i> function records the tour and its cost, if it is the best so far:</p><blockquote><p>void save(Dist sum)</p><p>{ int i;</p><p>  if (sum &lt; minsum) {</p><p>    minsum = sum;</p><p>    for (i = 0; i &lt; n; i++)</p><p>        minp[i] = p[i];</p><p>  }</p><p>}</p></blockquote><p>The global variables <i>minp</i> and <i>minsum</i> record the best tour and its length.</p><p>How slow is this program? The run times listed in <A NAME="rt1"><A HREF="9904nt1.htm">Table 1</A> were generated on a 200-MHz Pentium Pro machine. The first three times are observed values in seconds, and the final four times are back-of-the-envelope extrapolations. The program is indeed pokey.</p><p>A little mathematics shows why it is so slow. The code investigates all <i>n!</i> permutations, and performs <i>n</i> distance calculations for each (to calculate the cost of the tour). The total number of distance calculations used by the program is therefore <i>n</i>&times;<i>n!</i>.</p><p>The analysis is confirmed by looking at a profile. <A NAME="rt2"><A HREF="9904nt2.htm">Table 2</A> describes one run of the program with <i>n</i>=9. This data confirms the analysis: The <i>check1</i> function is called <i>n!</i> (or 362,880) times. The distance function is called <i>n</i>&times;<i>n!</i> (or 3,265,920) times. This profile also shows that the distance function is indeed the critical operation in this program: The <i>dist</i> function and the <i>sqr</i> and <i>sqrt</i> functions it calls account for almost 87 percent of the run time of the program. </p><p>Exercise 1: Try profiling a C implementation of an algorithm.</p><h3>Algorithm 2: A Fixed Point</h3><p>The next algorithm reduces the run time by examining fewer permutations. It fixes the last city in the permutation, and starts the search at one lower value:</p><blockquote><p>void solve2()</p><p>{  search1(n-1);</p><p>}</p></blockquote><p>This code no longer inspects all <i>n!</i> permutations, but still examines all possible tours. Algorithm 2 looks at only (<i>n</i>-1)<i>!</i> permutations, and performs <i>n</i> distance calculations at each. The total number of distance calculations is <i>n</i>&times;(<i>n</i>-1)<i>!</i>, or precisely <i>n!</i>.</p><p>To verify this, we'll augment the <i>dist</i> function with instrumentation code that gives key counts without the overhead of profiling: </p><blockquote><p>Dist dist(int i, int j)</p><p>{   </p><p>#if COUNTDISTS</p><p>    distcnt++;</p><p>#endif</p><p>    ...</p></blockquote><p>When the program turns on <i>COUNTDISTS</i>, it increments <i>distcnt</i> at each call. (If the constant is zero, no additional run-time overhead is incurred.) <A NAME="rt3"><A HREF="9904nt3.htm">Table 3</A> shows the number of distance calculations performed by the function. The first and second columns show that the number of distance calculations is indeed <i>n!</i>. The third row divides the current number of distance calculations by the previous number. In this case, those ratios repeat precisely the first column, and characterize factorial performance. </p><p>Of course, it is always important to verify that theory translates into reality; see <A NAME="rt4"><A HREF="9904nt4.htm">Table 4</A>. Both algorithms increase their run times by about a factor of <i>n</i> as <i>n</i> increases, and the run time of Algorithm 2 on <i>n</i> is a bit more than Algorithm 1 on <i>n</i>-1. Both of these observations are consistent with the predicted values.</p><h3>Algorithm 3: Sum Times Not</h3><p>The next version of the algorithm reduces the overhead of computing the sum for each permutation from scratch. Instead, the code carries along the partial sum in a new parameter to the <i>search3</i> function. It initially calls the function with the partial sum set to zero:</p><blockquote><p>void solve3()</p><p>{  search3(n-1, 0);</p><p>}</p></blockquote><p>It adds in the distance from the top city to the city next to it at each recursive call:</p><blockquote><p>void search3(int m, Dist sum)</p><p>{   int i;</p><p>  if (m == 1)</p><p>    check3(sum + d(p[0], p[1]));</p><p>  else</p><p>    for (i = m-1; i &gt;= 0; i--) {</p><p>       swap(i, m-1);</p><p>       search3(m-1, sum + d(p[m-1], p[m]));</p><p>       swap(i, m-1);</p><p>    }</p><p>}</p></blockquote><p>The new <i>check3</i> function adds in the distance from the first to the last city: </p><blockquote><p>void check3(Dist sum)</p><p>{  sum += d(p[0], p[n-1]);</p><p>   save(sum);</p><p>}</p></blockquote><p>This algorithm still looks at <i>(n-</i>1<i>)!</i> permutations, and I guessed that it would average roughly one distance calculation for each. I therefore expected another speedup of about a factor of <i>n</i>. <A NAME="rt5"><A HREF="9904nt5.htm">Table 5</A> lists the run times. Where I hoped for a speedup of around 10, I observed a speedup of just 2 or 3. What gives?</p><p>I enabled the operation counts, and examined the sequence <i>c<sub>m</i></sub>, which denotes the count of distance functions used when the first parameter to <i>search</i> is <i>m</i>. I started with small values: </p><blockquote><p>c<sub>1</sub> = 2, c<sub>2</sub> = 6, c<sub>3</sub> = 21.</p></blockquote><p>The sequence begins:</p><blockquote><p>2, 6, 21, 88, 445, 2676, 18739, ...</p></blockquote><p>My first approach was to check this sequence in Neil Sloane's online encyclopedia of integer sequences, but it wasn't there at the time. </p><p><i>Exercise 2: Try looking up the sequence at Sloane's web site at http:// www.research .att.com/~njas/sequences/.</i></p><p>The next step involves finding a recurrence relation to describe the sequence in terms of its earlier values. When <i>m</i> is one, there are two cities in the array and the algorithm makes two comparisons (between that pair and from the first to the last): <i>c</i><sub>1</sub>=2. When there are <i>m>=</i>2 cities, the algorithm swaps each of them to be the last, calls itself recursively on size <i>m</i>-1 (at cost <i>c<sub>m-</i>1</sub>), and then makes one additional distance calculation for each: <i>c<sub>m</sub>=m</i>&times;<i>(c<sub>m</i>-1</sub>+1<i>).</i></p><p>I verified the first few values by hand, then used a spreadsheet to check larger values against the instrumented runs. </p><p><i>Exercise 3: How would you construct that recurrence in a spreadsheet? You may want to warm up by constructing the sequence </i>m!<i>.</i></p><p>The recurrence matched the experiments. To understand the sequence, I toyed further with the spreadsheet. Because I expected <i>c<sub>m</i></sub> to be similar to factorials, the third column in <A NAME="rt6"><A HREF="9904nt6.htm">Table 6</A> shows <i>m!</i>. I next played with several different comparisons of the second and third rows: I subtracted <i>c<sub>m</i></sub> from <i>(m</i>+1)<i>!</i> and took several ratios, all without insight. I finally stumbled across the ratio <i>c<sub>m</sub>/m!</i> shown in the fourth column, in which I at long last recognized a pattern.</p><p>In high school, I memorized the natural logarithmic base <i>e</i> to accuracy 2.718281828459045...(Your guesses about my social life in high school may prove uncannily accurate.) My complete spreadsheet converged to 14 of those decimal digits at <i>m</i>=18, where floating-point accuracy finally gave out. This led immediately to the conjecture that:</p><blockquote><p>c<sub>m </sub><IMG SRC="aprxeq18.gif" ALT="" WIDTH="14" HEIGHT="10"> m!&times;(1+e)</p></blockquote><p>But how does the ubiquitous <i>e</i> sneak into my TSP program? Subtracting one from the right column gives the sequence 1, 2, 2 1/2, 2 2/3,..., which I recognized as the partial sums of the Taylor series expansion of <i>e<sup>x</i></sup> evaluated at <i>x=</i>1. This suggests the theorem: </p><blockquote><p>c<sub>m</sub>=m!&times;(1+1/0!+1/1!+...+1/(m-1)!)</p></blockquote><p><i>Exercise 4: Use mathematical induction to prove that this solution satisfies the recurrence relation. </p><p>Exercise 5: Play further with a spreadsheet to discover additional patterns in the sequence </i>c<sub>m</sub>.<i></i></p><p>Because Algorithm 3 makes the original call <i>search3(n-</i>1, 0<i>)</i>, it uses <i>c<sub>n</i>-1</sub> or approximately (<i>n</i>-1)<i>!</i>&times;(1+<i>e</i>) calls to the distance function. The speedup is not <i>n</i>, but rather roughly <i>n</i>/(1+<i>e</i>), which closely matches the experimental run times. </p><h3>Algorithm 4: Pruning the Search</h3><p>"Don't keep doing what doesn't work" is good advice for programs as well as people. As the program progresses, <i>sum</i> can never decrease: Adding edges only increases the tour length. The program can therefore terminate the search when <i>sum</i> grows too large:</p><blockquote><p>void search4(int m, Dist sum)</p><p>{   int i;</p><p>    if (sum &gt; minsum)</p><p>        return;</p><p>    if (m == 1)</p><p>        ... as before ...</p></blockquote><p>Each previous algorithm runs in the same time, for any size <i>n</i>, regardless of the particular input data. The run time of Algorithm 4 varies dramatically with its input. <A NAME="rt7"><A HREF="9904nt7.htm">Table 7</A> shows the number of distance calculations it uses on one sequence of inputs, where each input adds a single city of Lincoln's tour. By <i>n</i>=11, pruned Algorithm 4 uses about a factor of 10 fewer distance calculations than Algorithm 3. Furthermore, the ratios of distance calculations show that the run time does not increase by a factor of <i>n</i> at each stage, but rather by a smaller factor (apparently near 5 for this range). As <A NAME="rt8"><A HREF="9904nt8.htm">Table 8</A> shows, run-time experiments confirm both predictions.</p><p>Algorithm 4 is much faster than Algorithm 3, and its run time grows more slowly. </p><p><i>Exercise 6: Analyze Algorithm 4 in greater detail across a wider variety of inputs.</i></p><h3>Tools and Techniques</h3><p>Programming tools and techniques for analyzing algorithms include:</p><ul>  <li>Profilers. These general tools help us identify the key operations in code and their associated counts.  <li>Operation Counts. After identifying distance calculations as a critical operation, we added instrumentation code to count those operations.  <li>Integer Sequences. You can analyze some algorithms by studying their operation counts with tools such as ratios and Sloane's online encyclopedia of sequences.  <li>Spreadsheets. Spreadsheets provide a convenient way for storing and analyzing program performance data.  <li>Mathematics. Detailed analyses can sometimes provide real insight into real programs.  <li>Experiments and Common Sense. Always run experiments to ensure that your theory matches practice.</ul><h3>Stay Tuned!</h3><p>In my next column, I'll examine how code-tuning techniques speed up the various algorithms.</p><h3>Solutions to Selected Exercises</h3><p><b>Exercise 2</b>. Although the sequence was not there when I originally looked it up in April, 1998, it has since been added. (Amazing how one sequence pops up in various contexts!) The encyclopedia now gives the recurrence, but not the approximation derived in this column.</p><p><b>Exercise 3</b>. To compute <i>m!</i>, first set the A column to the integers 1, 2, 3,... Next set B1 to 1, then set B2 to =A2&times;B1, and drag it down the B column. To compute <i>c<sub>m</i></sub>, set the first column as before, set B1 to 2, set B2 to =A2&times;(B1+1), and drag it down.</p><p>Exercise 5. The first four columns in <A NAME="rt9"><A HREF="9904nt9.htm">Table 9</A> are from the previous spreadsheet. The fifth column shows the difference between elements in the fourth column, and the fifth column is the inverse of the fourth column. I was delighted to see the factorials pop out in the fifth column. This is an alternate derivation of the fact that <i>c<sub>m</sub>/m!=</i>1<i>+</i>1/0<i>!+</i>1/1<i>!+...+</i>1/<i>(m-</i>1<i>)!</i>. </p><p><b>DDJ</b></p><HR><I>Copyright &copy; 1999, Dr. Dobb's Journal</I><BR>
</body></html>