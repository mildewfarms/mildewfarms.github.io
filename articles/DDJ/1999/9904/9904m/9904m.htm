<html><head><title>Apr99: Java Q&A</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Are Java Applets Independent Programs?</h1><p><i>Dr. Dobb's Journal</i>, April 1999</p><h3>By Steve Ball and John Miller Crawford</h3><I>Steve is an independent contractor specializing in C++/Java/UNIX development. He also lectures in Object-Oriented Design and C++ programming at the Auckland Institute of Technology, New Zealand. Steve can be contacted at steve@effectivejava.com. John is Interactive Technology manager at Dave Clark Design Associates and principal lecturer at the Auckland Institute of Technology. He can be contacted at john.m.c@ait.ac.nz.</I><hr><p>AJava applet may seem to be an independent program, but in one crucial aspect, it is not. If you change a static field of a class used within an applet, that change pervades all applets -- even if they are on different web pages. Although, as we showed in " Channels for Inter-Applet Communication" (<i>DDJ</i>, September 1998), this behavior opens up a channel for inter-applet communication, such effects can be as unwelcome as they are unexpected.</p><p>An example CAD system we wrote, called "WebCAD," which lets models be built and displayed in 3D, demonstrates these unwelcome effects. (The complete source code and related files for WebCAD are available electronically; see "Resource Center," page 5.) First, consider this system implemented as a stand-alone Java application. <A NAME="rf1"><A HREF="9904mf1.htm">Figure 1</A> shows two instances of this application, in separate windows.</p><p>At its lowest level, WebCAD deals entirely in polygons (or planes). The model is displayed by drawing each plane in turn. Users can zoom in or out of the picture by changing the scale factor, set the display to either wireframe or solid-object mode, and spin the object around its x-and y-axes by dragging it with the mouse. All of these settings necessarily affect every plane in the model.</p><p>In WebCAD, we use static fields in the <i>Plane</i> class to express these display properties -- one for the scale factor, another for the display mode, and two together for the current viewing angle; see <A NAME="rl1"><A HREF="#l1">Listing One</A>. This is the alternative to storing the display properties as nonstatic members in each <i>Plane</i> object, which would require iterating through all <i>Plane</i> objects and changing each individually -- a task that is both tedious and needlessly time consuming, since it would be meaningless for any two planes to be displayed with a different scale factor or viewing angle.</p><p>Used this way, static fields are fulfilling the role for which they were originally created in C++ (from which Java inherited them). According to Bjarne Stroustrup and Margaret Ellis in <i>The Annotated C++ Reference Manual</i> (Addison-Wesley, 1990), "A static member function or variable acts as a global for members of its class without affecting the rest of the program." They go on to say that since "a static data member [is] shared by all objects of a class in a program," their scope is limited to the executing program.</p><p>The consequence for WebCAD is that if we have two windows, each displaying separate instances of it (see <A NAME="rf1"><A HREF="9904mf1.htm">Figure 1</A>), we can change their display properties independently even while the planes in each separate model share the same values.</p><p>In contrast, if we make a direct translation of WebCAD to an applet and display separate instances of it on separate web pages, we cannot make independent changes to their display properties. The browser executes applets as separate threads in the same Java Virtual Machine, so all applets share the same values of the static fields of any common classes. The scope of the static fields is not limited to the applet object or its executing thread, but encompasses all objects of the applet's class, wherever they are instantiated by the browser.</p><p><A NAME="rf2"><A HREF="9904mf2.htm">Figure 2</A> shows two applets experiencing just this problem. The models should be in different scales and different display modes, but they both have identical appearances.</p><h3>Reclaiming Static Semantics  for Applets</h3><p>What you need for applets, then, is some means of resolving the sibling rivalry that occurs when applets wish to have their own private copies of static fields. In this article, we present a workaround that lets the conventional semantics of static fields be reclaimed through the use of a specialized mechanism that mimics the behavior of static fields. More importantly, this workaround possesses the same meaning in both Java applications and applets.</p><p>This lets you develop classes that operate identically, whether instantiated within an application or an applet -- something not possible if the classes use static fields. First, we present our solution in code form, and then we abstract its essence in the form of a design pattern. We'll also provide a set of rules that may be mechanically applied to a class that uses static fields, which will convert it to a class that is portable between executing environments.</p><h3>Mimicking Static Fields</h3><p>Because static fields may not be used to store values particular to just one applet, it follows that these values need to be represented as instance variables in some object. The main <i>Applet</i> object is an excellent candidate for the custodian of these values, both because it sits at the root of the function call hierarchy and because there is only one per applet.</p><p>However, the corollary to this decision is that in some form these values have to appear in every stack frame from the topmost to the bottommost. We will discuss three ways to do this.</p><p>First, they may be passed as constructor arguments to each class (see <A NAME="rl2"><A HREF="#l2">Listing Two</A>) in the composition hierarchy. </p><h3>Eliminating Argument Clutter</h3><p>The second solution seeks to avoid the passing of long lists of values to a particular class (such as <i>Cube</i>) with no other purpose than to allow that class to pass them on down. Instead, you can simply pass a reference to the applet itself; see <A NAME="rl3"><A HREF="#l3">Listing Three</A>. </p><p>This approach of placing the values in the <i>Applet</i> object is adequate for many situations where objects depend upon global state values particular to just their applet. Consider, for example, an applet that supports an HTML parameter that allows sound effects to be turned on or off. The setting of this value needs to be available to a variety of methods in a number of different low-level classes. If the value is stored in the applet during its initialization, then all objects with access to the <i>Applet</i> object are able to query it.</p><p>We recommend that you routinely pass the main <i>Applet</i> object as a constructor argument to all helper classes. Then, when you discover you need to configure the applet's behavior at some low level based on a global value, you do not have the arduous task of retracing your steps back up the call hierarchy and inserting <i>Applet</i> references and constructor arguments into every intervening class.</p><h3>Emphasizing Relationships  Between Classes</h3><p>The third approach is suitable for simple cases, particularly where global data (like sound-effects flags) are not clearly owned by any one class (other than the applet).</p><p>The disadvantage is that the <i>Applet</i> object, like the constructor argument list in our first solution, becomes cluttered with the shared values from all the other classes in the application that require applet-specific values to be stored. Also, there is no explicit relationship between the mysterious appearance of an instance variable in the <i>Applet</i> object and the class of the objects that depend on it.</p><p>WebCAD is a good example of this, as there is a clear family tie between the <i>Plane</i> objects and the global properties that affect them all. That structural relationship may be expressed by encapsulating the display properties in a separate class, an instance of which is placed in the main <i>Applet</i> object and passed (eventually) as a constructor argument to each <i>Plane</i> object; see <A NAME="rl4"><A HREF="#l4">Listing Four</A>.</p><p>This relationship between a class (<i>Foo</i>) and the class that holds its static fields (<i>FooProperties</i>) mirrors the traditional relationship between a class and its static fields. According to Stroustrup and Ellis, "The association between the static members and their class is explicit and obvious, whereas the use of global variables and functions for similar purposes is neither." </p><p>Intermediate classes (such as <i>Cube</i>) still have the task of passing on the properties reference (though they have no personal interest in it), but at least the ultimate destination class is obvious and documented in the code; see <A NAME="rl5"><A HREF="#l5">Listing Five</A>.</p><p>The class that makes use of the applet's properties object ends up holding a reference to it. The class (<i>Plane</i>, in this case; see <A NAME="rl6"><A HREF="#l6">Listing Six</A>) refers to the display properties by prefixing them with the name of the properties object, but otherwise treats them just as if they were static fields of the same class -- which is effectively what they are, except they are not shared with other applets.</p><h3>Independent Applets in Java</h3><p>WebCAD is implemented as an applet that may be safely instantiated multiple times in the same browser window without any unpleasant inter-applet interference.</p><p><A NAME="rf3"><A HREF="9904mf3.htm">Figure 3</A> is a web page with two instances of the applet displayed. The instances have entirely different display properties: One has a wireframe appearance, the other is solid with hidden-line removal; one has been scaled down to 80 percent of its initial size; and the models are being viewed from different angles. This mechanism can be applied in any situation where a class wishes to have shared global values that are not affected by other applets, and may be generalized in the form of the Shared Property design pattern.</p><p>Intent. Allow the sharing of properties within a defined subset of the set of all objects instantiated from a class.</p><p><b>Motivation.</b> It is primarily in the context of Java applets that the Shared Property pattern is most usefully implemented, since web browsers' implementations allow Java class variables to be shared across applet boundaries. The Shared Property pattern mimics the behavior of static fields in classes executed within independent Java applications.</p><p><b>Applicability.</b> Use the Shared Property pattern when undesirable side effects are produced by allowing the complete set of instantiated class objects to share a property (such as when executing within a browser environment).</p><p><b>Structure.</b> The Shared Property pattern is a composite of three classes: <i>SharedProperties</i>, <i>PropertySharer</i>, and <i>PropertyOwner</i>. <A NAME="rf4"><A HREF="9904mf4.htm">Figure 4</A> shows the structure of the Shared Property pattern.</p><p><b>Participants.</b> <i>SharedProperties</i>, (<i>PlaneProperties</i>), the attributes to be shared by a group of objects; <i>PropertySharer</i> (<i>Plane</i>), an object belonging to the group sharing the common attributes; <i>PropertyOwner</i> (<i>WebCAD</i>), the object responsible for the construction and storage of the common <i>SharedProperties</i> object.</p><p><b>Collaborations.</b> Clients access shared properties via a reference to the unique <i>SharedProperties</i> object, instead of through a static class variable of the sharing class. Intermediate classes in the composition hierarchy are obliged to pass on that reference to the <i>SharedProperties</i> object until it reaches its ultimate destination in the <i>PropertySharer</i> class objects.</p><p><b>Consequences.</b> The Shared Property pattern allows the conventional behavior of static class variables to be reclaimed in an environment where static variables do not have their traditional semantics.</p><p><b>Implementation.</b> The steps to convert a class that uses static fields to one that implements the Shared Properties pattern are:</p><p>1.	Extracting the shared properties. Extract any fields defined as static in the class to be converted (the <i>PropertySharer)</i> and place them in their own separate class (the <i>SharedProperties</i> class). The crucial step is to ensure that they are defined as regular members in the new class rather than as static fields.</p><p>2.	Creating the shared properties object. Construct a single instance of the <i>SharedProperties</i> class as part of the applet class's construction and record it in a private instance variable. If the values for the initial state of this object are not yet known, simply create an object using default values. Being shared, changes made to this object are made immediately apparent to members of the <i>PropertySharer</i> class, so initializing the values in the <i>SharedProperties</i>  object may be deferred until the point that the first <i>PropertySharer</i> object needs to use them. </p><p>3.	Making the shared properties accessible. The <i>SharedProperties</i> object needs to be available wherever objects of the <i>PropertySharer</i> class are instantiated. The easiest way to achieve this is to pass a reference to the applet's <i>SharedProperties</i> object down the function call hierarchy through the constructors of any intermediate classes (or, alternatively, a reference to the Applet object, from which the <i>SharedProperties</i> object may be obtained). </p><p>4.	Associating the objects with their shared properties. Simply provide an additional argument to each of the constructors for the <i>PropertySharer</i> class. A reference to the SharedProperties object should be stored in a private instance variable.</p><p>5.	Implementing Accessors and Mutators. Any existing accessor (get methods) or mutator (set methods) functions in the <i>PropertySharer </i>class, along with any other references to the erstwhile static fields, are modified to reference the fields in the <i>SharedProperty</i> object by prefixing them with the name of the <i>SharedProperty</i> instance variable. The accessors and mutators remain in this class and are not relocated in the <i>SharedProperties</i> class, so that use of the design pattern is as transparent to users of the class as possible.</p><h3>Conclusion</h3><p>Classes that use static fields with their traditional semantics almost always give undesired behavior when instantiated in an applet environment. To produce portable code or to use static fields with their conventional meaning in applets, an alternative idiom is required.</p><p>We've presented two possible solutions. For simple cases -- and especially where a value is global to the applet and not particular to any one class -- the approach of storing the data directly in the main <i>Applet</i> object and passing the applet object down to the other helper classes is concise, effective, and extensible.</p><p> Where there is a deliberately exclusive relationship between a set of shared data and objects of a particular class, the Shared Property pattern is superior because, in addition to all the benefits of the first approach, it explicitly establishes a tightly coupled relationship between the two classes.</p><p>We recommend that you use either of the solutions we present even when producing classes targeted for stand-alone Java applications, so that if you wish to utilize those classes in an applet at a later time, you may reuse them freely without having to make any modifications.</p><p>The working Java applets from this article may be viewed at http://effectivejava .com/steve/iapps/ and at http://www.dcda .co.nz/jmc/iapps/.</p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>class Plane {    static int displayMode;    static double scaleFactor;    static double rotation, elevation;}</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>class WebCAD extends Applet {    WebCAD() {        cubes[0] = new Cube(displayMode, scaleFactor, rotation,            elevation, /*other args*/);        ...    }}class Cube {    Cube(int displayMode, double scaleFactor, double rotation,            double elevation, /*other args*/) {        topFace = new Plane(displayMode, scaleFactor, rotation,            elevation, /*other args*/);        ...    }}</pre><P><A HREF="#rl2">Back to Article</A></P><H4><A NAME="l3">Listing Three</H4><pre>class WebCAD extends Applet {    WebCAD() {        cubes[0] = new Cube(this, /*other args*/);        ...    }}class Cube {    Cube(Applet applet, /*other args*/) {        topFace = new Plane(applet, /*other args*/);        ...    }}class Plane {    Plane(Applet applet, /*other args*/) {        this.applet = (WebCAD) applet;        ...    }    void draw(Graphics g) {        switch (applet.displayMode) {            case DM_WIRE_FRAME:            case DM_SOLID_OBJECT:        }    }    private WebCAD applet;}</pre><P><A HREF="#rl3">Back to Article</A></P><H4><A NAME="l4">Listing Four</H4><pre>class PlaneProperties {    int displayMode;    double scaleFactor;    double rotation;    double elevation;    PlaneProperties(int displayMode, double scaleFactor,            double rotation, double elevation) {        this.displayMode = displayMode;        this.scaleFactor = scaleFactor;        this.rotation = rotation;        this.elevation = elevation;    }}class WebCAD extends Applet {    WebCAD() {        planeProperties = new PlaneProperties(Plane.DM_WIRE_FRAME,            1.0, INITIAL_ROTATION, INITIAL_ELEVATION);        cubes[0] = new Cube(planeProperties, /*other args*/);    }    private PlaneProperties planeProperties;}</pre><P><A HREF="#rl4">Back to Article</A></P><H4><A NAME="l5">Listing Five</H4><pre>class Cube {    Cube(PlaneProperties planeProperties, /*other args*/) {        topFace = new Plane(planeProperties, /*other args*/);        ...    }}</pre><P><A HREF="#rl5">Back to Article</A></P><H4><A NAME="l6">Listing Six</H4><pre>class Plane {    Plane(PlaneProperties planeProperties, /*other args*/) {        this.planeProperties = planeProperties;        ...    }    void draw(Graphics g) {        switch (planeProperties.displayMode) {            case DM_WIRE_FRAME:            case DM_SOLID_OBJECT:        }    }    private PlaneProperties planeProperties;}</pre><P><A HREF="#rl6">Back to Article</A></P><HR><I>Copyright &copy; 1999, Dr. Dobb's Journal</I><BR>
</body></html>