<html><head><title>Apr99: Examining PerLDAP</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Examining PerLDAP</h1><h2>Simplifying  LDAP access</h2><h3>By Troy Neeriemer</h3><I>Troy is a systems engineer for Intraware and can be contacted at troy@ intraware.com.</I><hr><p>LDAP (short for "Lightweight Directory Access Protocol") promises to be a central repository of information about users and corporate resources. However, if it is difficult to access or manipulate that information, then few organizations will take LDAP seriously. Programmers and administrators, in particular, need to be able to access this information through a variety of methods and tools.</p><p>From a programmer's perspective there should be several ways to access the information. A low-level C API for directory access, for those times when speed is important, needs to be embedded in a compiled application. Java is becoming more important in the corporate environment, and as a result access to LDAP from Java has become a necessity. But there are also times when the ability to generate a quick prototype in a scripting language can make the difference in a project's success.</p><p>Administrators also need several ways to get to the information in a directory. A GUI for adding and changing information easily is an absolute requirement. Command-line utilities are frequently important for doing batch updates. However, sometimes command-line utilities don't allow a fine enough degree of control, so once again access through a scripting language is important.</p><p>To address issues such as these, Netscape has released PerLDAP, which provides a mechanism for accessing directory information from Perl. This is an important tool for both programmers and administrators. In this article, I'll provide both a high-level overview of what PerLDAP does and a detailed explanation of how you can use it.</p><h3>What is PerLDAP?</h3><p>PerLDAP (available in source code form at http://www.mozilla.org/directory/ perldap.html) is a set of Perl functions and objects that simplify access to LDAP services. Although Netscape released PerLDAP with the intent that it be used with the Netscape Directory Server, it should work equally well with most LDAP v3-compliant directories.</p><p>Netscape now has three ways for you to access LDAP. The first of these is the C API, which is distributed in the form of the Directory Server SDK. This SDK is available for a wide variety of platforms, and would be used by anyone developing an LDAP application in either C or C++. For Java developers, Netscape has the Java LDAP SDK. As you'd expect, the Java SDK has an object-oriented approach, and as such is much easier to use than the C API. PerLDAP also has an object-oriented approach to LDAP. PerLDAP is the most approachable of these three tools for accessing the Directory Server. All three tools (and some others as well) are available at Netscape's DevEdge Online (http:// developer.netscape.com/program/ home.html).</p><p>Experienced Perl developers may already be familiar with the Net::LDAP- api package available on the CPAN, the Comprehensive Perl Archive Network (http://www .cpan.org/). Net::LDAPapi does have a Perl object-oriented interface, but does not provide a general-purpose LDAP object. In other words, Net::LDAPapi really only gives you access to the LDAP API without providing a simpler-to-use object-oriented mechanism. PerLDAP, on the other hand, gives you a more general-purpose LDAP object that behaves much like the Java LDAP classes, which are part of the Java LDAP SDK 3.0. Both PerLDAP and Net::LDAPapi require the Directory Server SDK 3.0.</p><p>PerLDAP comes with a set of Perl functions that mirror the functions in the Directory Server SDK. These functions let you connect to a Directory Server, create, modify, and delete LDAP entries. More importantly, PerLDAP includes two objects that wrap around these functions, creating a more friendly developer experience. These objects are <i>Mozilla::LDAP::Conn</i> and <i>Mozilla::LDAP::Entry</i>.</p><p><i>Mozilla::LDAP::Conn</i> is a general-purpose LDAP object that is instantiated by calling the <i>new() </i>method with the appropriate parameters. The parameters are the host name of the directory server, the bind distinguished name (dn), the bind password, and the LDAP search base. Once a connection has been established, <i>Mozilla::LDAP::Conn</i> has methods for searching the directory server, adding entries, modifying entries, and deleting entries. </p><p>Mozilla::LDAP::Entry is an object that gives you access to the components of an LDAP entry. It also provides methods for modifying an entry. Many <i>Mozilla::LDAP:: Conn</i> methods return <i>Mozilla::LDAP::En</i>try objects.</p><p>Because most LDAP entries are in textual format, Perl's strong string-processing capabilities make it a natural fit. Furthermore, the ease of using the PerLDAP objects can make it an attractive alternative to using the command-line tools such as ldapsearch and ldapmodify. PerLDAP gives you the ability to create an LDIF export without shutting down the Directory Server. It includes sample code for synchronization with PeopleSoft. It can also be used to batch import users from other user databases. Only need and imagination limit the list of possible uses.</p><h3>An Example Application</h3><p>It is common for an organization to set up a variety of mailing lists. The uses range from being an alias for an entire department to being a tool for collaboration. If you've ever seen an e-mail address such as "engineering-newengland@company.com," then you've seen mailing lists in action. Collaborative mailing lists frequently allow people to subscribe and unsubscribe to the mailing list on their own without the intervention of an administrator. This is usually done using a list server such as Majordomo.</p><p>The Netscape Messaging Server supports mailing lists, but doesn't provide a means for users to subscribe or unsubscribe to those mailing lists. It requires that administrators manually add users to groups. This generally encourages people to look to an external program such as Majordomo to manage their mailing lists.</p><p>The example I present here, which demonstrates the inner workings of PerLDAP, is a CGI program that can be used to manage mailing lists via Directory and Messaging Servers. I will demonstrate some techniques for connecting (or binding) to the Directory Server, processing the results of a search, and modifying LDAP entries.</p><h3>Binding to the Directory Server Using PerLDAP</h3><p>The demo CGI program needs to do a few basic things, such as prompt users to log in, display a list of mailing groups available on the server, and let users modify membership in those mailing groups. <A NAME="rl1"><A HREF="#l1">Listing One</A> is the core of this program. In a nutshell, it checks the state of the application and sends back the appropriate screen. The basic approach that I've taken with this CGI program is to separate the functions that display HTML from those that process LDAP entries. This is a good CGI programming practice, and it also makes it easier to focus the discussion on functions that make use of PerLDAP.</p><p>Since users are going to be modifying LDAP entries, it is necessary to make them bind to the Directory Server. However, users should be able to simply type in their user ID and password without having to remember their entire distinguished name. Users are used to this sort of behavior, and you want to mimic it. It turns out that this is actually pretty easy to accomplish.  </p><p>There are three steps to binding to the Directory Server starting with just a user ID. The first step is to bind anonymously to the Directory Server. The second step is to search for the distinguished name for that user ID. <A NAME="rl2"><A HREF="#l2">Listing Two</A> shows the <i>ldap_get_user_info()</i> function that does these first two steps. This function also returns the full name of the user, but this is only for display purposes and not a necessary component to binding to the Directory Server. The third step is to use the distinguished name returned by <i>ldap_get_user_info()</i> to bind to the Directory Server. This is a common approach to solving this problem. In fact, the Netscape Enterprise Server uses a similar mechanism for logging into the web server using just a user ID and password.</p><p>The <i>ldap_get_user_info()</i> function shows the basics of using the <i>Mozilla::LDAP::Conn </i>package. Calling the <i>new()</i> method without specifying a <i>bind dn</i> creates an anonymous connection to the Directory Server. Once a connection has been established, a search can be conducted. The <i>search()</i> method is similar to using the LDAP search feature in Communicator or in the command-line tools. You simply specify a search base and an attribute to search on. The <i>sub</i> parameter tells the <i>se</i>arch() method to look in subtrees. From there, it's just a matter of processing the result set that <i>search()</i> returned.</p><p>The <i>search()</i> function returns a <i>Mozilla ::LDAP::Entry</i> if the search was successful. You can then use the <i>Mozilla::LDAP::Entry</i> methods to access the data in the entry. One such method is <i>getDN(),</i> which returns the distinguished name of that entry. Another useful method is <i>exists(),</i> which lets you check if a value exists for the specified attribute.</p><p>Extracting the values of attributes can be a little tricky. The most important thing to remember is that an entry can have more than one value for each attribute. In fact, it is quite common. For example, a typical entry for an individual will have the values "top," "person," "organizationalperson," and "inetorgperson" for the <i>objectclass</i> attribute. This is important because when you ask <i>Mozilla::LDAP::Entry</i> for the value of an attribute, it will return a reference to an array. The general syntax looks something like:</p><blockquote><p>$value = $entry-&gt;{attribute}[array_index];</p></blockquote><p>You can use the <i>size()</i> method to determine how many elements are in the array. For the purposes of <i>ldap_get_user_info()</i>, you know that there is generally only one common name per entry, so you just grab the first one after testing to make sure a value exists.</p><p>Since most searches will return more than one entry, a method is needed to iterate through the result set. That method is <i>nextEntry(),</i> which is a <i>Mozilla::LDAP::Conn</i> method. In the case of <i>ldap_get_user_info()</i>, getting more than one entry back indicates there is a problem with the directory information tree because Netscape requires that uids be unique for the entire directory. The last thing that needs to be done with any basic LDAP connection is to close it. To do this, simply call <i>close()</i>.</p><h3>Processing Search Results</h3><p>Once you know the <i>bind dn</i> of the user in question, you can bind to the Directory Server as that user and search for a list of available mailing lists. <A NAME="rl3"><A HREF="#l3">Listing Three</A> shows the <i>ldap_get_mail_groups()</i> function, which does exactly that. This function is a straightforward LDAP search. The primary differences between this function and <i>ldap_get_user_info()</i> are that you aren't binding anonymously and the function populates an array with LDAP entries that are the results of the search. After calling <i>ldap_get_mail_groups()</i>, you have an array full of  <i>Mozilla::LDAP::Entry</i> objects.</p><p><A NAME="rl4"><A HREF="#l4">Listing Four</A> shows what you can do with that array, although this is not the only way to process the results of a search. Rather than stuffing each entry into an array, the <i>ldap_get_mail_groups()</i> function could have processed each entry as it was retrieved. However, I wanted to be able to reuse my primary search so I separated it into an another function.</p><p><A NAME="rl4"><A HREF="#l4">Listing Four</A> demonstrates how to look through each entry to see if the user is a member of that group. The group lists members by using the <i>uniqueMember</i> attribute. In other words, to find a user in a group, you have to step through the array of <i>uniqueMember</i> attributes looking for the member. This is done by finding out how many elements are in the array using the <i>size()</i> method. Once this is known, it's simply a matter of using a <i>for</i> loop to look at each entry. You exit the <i>for</i> loop when you find the member. </p><h3>Modifying Entries</h3><p>The last major piece of functionality in PerLDAP that I'll examine is how to modify an entry, specifically how to add or remove an attribute and its corresponding value. The process is similar for both actions, so I'll take a look at adding an attribute. <A NAME="rl5"><A HREF="#l5">Listing Five</A> shows how to do this. First, connect to the LDAP server. Second, find the entry that you want to modify. Third, add the attribute value. This is done with the <i>addValue()</i> method of the <i>Mozilla::LDAP::Entry</i> object. Finally, update the entry on the server. The <i>update()</i> method of the <i>Mozilla::LDAP::Conn</i> object has a single parameter, which is the <i>Entry</i> that has been modified. This is an important step. If <i>update()</i> isn't called, then the <i>Entry</i> is only modified in memory and not on the server.</p><h3>Making the Mailing List Manager</h3><p>If you've spent any time poking around the access control mechanism for the Directory Server, you may have noticed a permission called "selfwrite." Don't be surprised if Netscape renames this permission in a future release because it doesn't do what you'd expect. The first thing that comes to mind is that setting this permission for a group of users would allow them to modify their own entry. However, what it really does is allow users to add or remove themselves from a <i>groupofuniquenames</i>, which is also a <i>mailGroup</i>.</p><p>If you are using the Netscape Messaging Server in conjunction with the Directory Server, the installer for the Messaging Server extends the default schema to support the use of groups as mailing lists. In other words, if a group is given an e-mail address, then the Messaging Server will send an e-mail addressed to all members of the group. A typical use of this functionality would be to create e-mail aliases for departments or teams. The <i>selfwrite</i> permission allows users to modify their membership in the group.</p><p>With a little creativity, this feature can also be used to mimic some of the functionality of a list server such as Major-domo. An important feature of Major-domo lets users self-administer their membership in mailing groups by using commands sent by e-mail. PerLDAP makes it easy to create a web-based self-administration tool. <A NAME="rl1"><A HREF="#l1">Listing One</A> shows the basic framework of such an application. The <i>process_login()</i> function makes use of binding to the Directory Server, searching, and processing the result set. The <i>process_submit()</i> function also adds or removes attributes from Entries. These functions both call functions that display HTML as well. The complete source code is available electronically from <i>DDJ</i> (see "Resource Center," page 5) or by writing me at troy@intraware.com.</p><p>You must grant the <i>selfwrite</i> privilege to at least some groups and users for the Mailing Group administration CGI to work. Refer to the Directory Server Administrator's Guide if you need help in setting up access control on the Directory Server. Be sure to look at the comments at the beginning of the source code because they will tell you what all the necessary components are and how to point the program at your Directory Server.</p><p>There are a couple of other things about this program you should be aware of. The first is that the program passes the user's password as a parameter and as a hidden field. This means that if you use it in an extranet environment you should be sure to use SSL so that this information is encrypted. Second, you don't want to tread lightly in the area of access control. If you are working with a production Directory Server, be sure to coordinate all activities with the primary administrator because it is easy to lock everyone out.</p><h3>Conclusion</h3><p>I've presented just one possible use for PerLDAP. There are many ways this tool can be used to simplify Directory Server administration. The key things to remember about doing a search with PerLDAP are:</p><p></p><ul>  <li>Set up the connection using <i>new()</i>.  <li>Make the search using <i>search()</i>.  <li>Process the results.  <li>Close the connection.</ul><p>There are, of course, many variations on this theme, but if you keep these four steps in mind it should be relatively easy for even beginning Perl developers to make good use of this tool.</p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>unless ($cgi-&gt;param()) {    html_display_login();} elsif ($cgi-&gt;param("exit") eq "Exit") {    html_display_login();} elsif ($cgi-&gt;param("mode") eq "login") {    process_login();} elsif ($cgi-&gt;param("mode") eq "submit") {    process_submit();}</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>sub ldap_get_user_info {    my $user = $_[0]; # The user ID    my $bind_dn;    my $cn;    my $anon_conn = new Mozilla::LDAP::Conn($ldap_host,             $ldap_port, "", "", "") || die "Can't connect to $ldap_host.\n";    my $entry = $anon_conn-&gt;search($search_base, "sub", "(uid=$user)");    if (! $entry) {        return;    } else {        my $i = 0;        while($entry) {            $i++;           $bind_dn = $entry-&gt;getDN();            if ($entry-&gt;exists("cn")) {                $cn = $entry-&gt;{"cn"}[0];            } else {                return;            }            $entry = $anon_conn-&gt;nextEntry();        }        if ($i &gt; 1) {            return;        }    }       $anon_conn-&gt;close();    return ($bind_dn, $cn);}</pre><P><A HREF="#rl2">Back to Article</A></P><H4><A NAME="l3">Listing Three</H4><pre>sub ldap_get_mail_groups {    my $bind_dn = $_[0];  # The user's bind DN    my $password = $_[1];  # The user's password    my $mgref = $_[2];  # A reference to an array of Entry objects    my $conn = new Mozilla::LDAP::Conn($ldap_host, $ldap_port, $bind_dn,                                      $password, "");    my $entry;    my $cn;    if (! $conn) {        html_display_error( "Couldn't connect to the directory server.");        exit(0);    } else {        $entry = $conn-&gt;search($search_base, "sub", "objectclass=mailGroup");        if (! $entry) {            html_display_error("There aren't any mailing lists on this server.");            exit(0);        }        while($entry) {            $cn = $entry-&gt;{"cn"}[0];            # add the entry to the array unless it's the Postmaster group            if ($cn ne "Postmaster") {                push(@$mgref,$entry);            }            $entry = $conn-&gt;nextEntry();        }        $conn-&gt;close();    }}</pre><P><A HREF="#rl3">Back to Article</A></P><H4><A NAME="l4">Listing Four</H4><pre>foreach (@mailGroup){    $groupName = $_-&gt;{"cn"}[0];    $description = $_-&gt;{"description"}[0];    my $isMember = 0;    my $ct = $_-&gt;size("uniquemember");    for ($i = 0; $i &lt; $ct ; $i++) {        if ($bind_dn eq $_-&gt;{"uniquemember"}[$i]) {            $isMember = 1;            last;        }    }    html_row($isMember, $groupName, $ct, $description);}</pre><P><A HREF="#rl4">Back to Article</A></P><H4><A NAME="l5">Listing Five</H4><pre>sub ldap_add_to_group {    my $bind_dn = $_[0];  # The user's bind DN    my $password = $_[1]; # The user's password    my $mg_cn = $_[2]; # The CN of the Group    my $conn = new Mozilla::LDAP::Conn($ldap_host, $ldap_port, $bind_dn,                                                    $password, "");if (!$conn) {        html_display_error( "Couldn't connect to the directory server.");        exit(0);    } else {        my $entry = $conn-&gt;search($search_base, "sub", "(cn=$mg_cn)");        if (!$entry) {            html_display_error( "Couldn't find $mg_cn.");            exit(0);        }        $entry-&gt;addValue("uniquemember", $bind_dn);        $conn-&gt;update($entry);        $conn-&gt;close();    }}</pre><P><A HREF="#rl5">Back to Article</A></P><HR><I>Copyright &copy; 1999, Dr. Dobb's Journal</I><BR>
</body></html>