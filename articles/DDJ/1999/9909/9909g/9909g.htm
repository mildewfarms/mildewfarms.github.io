<html><head><title>Sep99: Event-Based Servers in Tcl</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Event-Based Servers in Tcl</h1><p><i>Dr. Dobb's Journal</i> September 1999</p><h2>Multithreading  without threads</h2><h3>By Stephen Uhler</h3><I>Stephen is a senior staff engineer at Sun Microsystems laboratories. He can be contacted at stephen.uhler@sun.com.</I><hr><p>The primary goal of a high-performance server is to spend all of its time servicing client requests. It shouldn't spend any time waiting for client input, waiting for a client to accept output, or waiting for client-specific resources to become available. If a client or resource isn't ready, the server should deal with a different client instead.</p><p>Many people think that multithreading is a must for high-performance servers. In this article, I present an alternative to a threaded architecture that yields as good as or better performance than thread-based systems. To illustrate, I'll implement a web server that demonstrates the simplicity of my approach, which is based on events and callbacks. Finally, I'll suggest when it is appropriate to use event-based systems and when a multithreading approach is a better choice.</p><h3>Thread-Based Servers</h3><p>In an ideal world, writing a server is straightforward, as the following server loop indicates:</p><p>1.	Get a request from the client.</p><p>2.	Compute the response.</p><p>3.	Transmit the response to the client.</p><p></p><p>As long as the client cooperates and is always ready, this server is ideal. There is no overhead switching among clients -- they are serviced as the requests arrive. The server operates in a strict first-come/first-served manner, and since the clients are always ready, the server is always busy servicing requests, thus achieving maximum throughput.</p><p>In the real world, where servers are fast and clients are slow, this simple scheme falls apart. The server can go no faster than its slowest client. While getting a request from the client, the server ends up waiting for the request to arrive. While the client is reading the response, the server waits some more. The solution to this waiting is to have the server work on another client's request while waiting for the first client to be ready.</p><p>A common approach to this situation is the use of threads -- a general-purpose mechanism for handling concurrency by providing multiple streams of execution with shared programs and data. Modern preemptive thread systems manage the switching of threads automatically and provide primitives for managing synchronized access to avoid data corruption.</p><p>On the surface, threads seem ideal. The simple request-at-a-time server magically becomes concurrent with threads. Where the server would have waited for a slow client, the underlying thread system realizes the server needs to wait, automatically switches to a new execution context, and begins servicing a different client. The code appears sequential on paper, but behind the scenes, the thread system magically switches between threads, eliminating the time spent waiting for a client.</p><p>Unfortunately, threads aren't really so simple. Because the thread system can't know the intent of a particular program, it switches threads at an arbitrary point. If a thread is interrupted in the middle of modifying a shared data structure, the next thread gets corrupted data.</p><p>You need locks to prevent data corruption. A lock prevents thread A from running while thread B is modifying shared data. Forget a lock, and the program breaks. If A is waiting for B, and B is waiting for A, then you have deadlock, and the program breaks. If the locks are placed around large sections of code, so-called "coarse-grain locking," then threads are waiting on locks much of the time. Concurrency is reduced and performance is back to the level of the aforementioned simple-server scenario. If fine-grain locking is used, with locks tightly bracketing critical code sections, then concurrency is improved -- but it is easy to forget a lock, and overhead increases as more time is spent checking and managing locks.</p><h3>Event-Based Servers</h3><p>Where threads preserve the sequential look of the simple server by using concurrency, event-based systems require a different program structure -- an event loop that:</p><p>1.	Waits for something to do.</p><p>2.	Figures out what to do, and does it until I/O is needed.</p><p>Step 2 involves doing whatever the server can do without waiting, such as getting part of a client request, computing part of a result, or sending part of a response. The program flow no longer appears to be sequential. However, with this approach there is no concurrency, no locks, no data corruption, and almost no overhead.</p><p>All blocking I/O is replaced by event notification and callbacks. Instead of waiting for data to become available, the server is notified when it is available, processes the available data, then waits for the next notification. Notifications on behalf of many different clients can be intermingled, based solely on the order in which the clients are ready.</p><p>Tcl supports event-based programming via the <i>fileevent</i> command, which handles I/O events, and the <i>after</i> command, which manages temporal events. The <i>fcopy</i> command packages a common <i>fileevent-event</i> idiom in a single command for even higher performance.</p><p>When first faced with event-based programming, one source of confusion for threads programmers is how to deal with the program context. In a threaded system, the execution context for each thread lives on a stack. The threads package manages the saving and restoring of the execution stack as threads are switched in and out. With event-based systems, the execution context needs to be handled explicitly by you. When an event happens, you need to know for which client the event happens, and what the state of the client request was. Fortunately, managing the execution state associated with the events is easy to do in Tcl.</p><h3>An Event-Based Web Server in Tcl</h3><p>A web server implements the HTTP protocol, which defines how clients make requests and how servers respond to those requests. An HTTP request consists of a request line containing a URL, some headers, a blank line, and an optional body, which is typically used for form data in POST requests. The server reads the request, gathers the relevant information, finds the resource represented by the request, and replies to the client in a format that is similar to the request -- a response line, some headers, and the body of the response (the data displayed by the browser).</p><p>Available electronically (see "Resource Center," page<b> </b>5) you'll find a small but complete web server that supports HTTP 1.0 and is written in about 200 lines of Tcl. It uses Tcl 8.0, the most recent production release of Tcl, and runs on Windows, UNIX, and the Macintosh. Rather than use Tcl namespaces, which earlier versions of Tcl do not support, I used the prefix "DDJ" on all my functions to prevent namespace clashes. This lets the code run on earlier versions of Tcl with only minor modifications. (Tcl is available at ftp://ftp.scriptics .com/pub/tcl/. A full-featured web server that uses the techniques presented and written entirely in Tcl by Stephen Uhler and Brent Welch is available at http://www .scriptics.com/tclhttpd/.)</p><p>The first thing the event-driven server does is call the socket command; see <A NAME="rl1"><A HREF="#l1">Listing One</A>. The parameters to the socket command cause the server to call the function <i>DDJaccept</i> (a callback, see <A NAME="rl2"><A HREF="#l2">Listing Two</A>) anytime the server accepts a socket connection from a client. The line <i>vwait forever</i> starts the Tcl event loop until the value of the variable <i>forever</i> changes, which, in this case, is never. From this point on, everything the server does is in response to an event.</p><p>When a client connects to the server, <i>DDJaccept</i> is automatically called. The first two parameters of <i>DDJaccept</i>, <i>root</i>, and <i>timelimit</i>, were specified when the callback was defined in <i>socket</i>. Tcl automatically adds some additional parameters. The first additional parameter is the name of the socket that the program uses to communicate with the client.</p><p>The next line, <i>upvar #0 $socket request</i>, is a standard Tcl idiom that is used to manage the execution state for the various clients. In an event-based system, each client request needs to be uniquely identified so that its state can be associated with it. The socket name <i>$socket</i> serves this purpose: It is a unique value for any active client connection. Next, <i>upvar</i> creates a persistent (global) reference to this client's state, and gives it a local name -- <i>request</i>. Whenever a callback is registered for an event, <i>$socket</i> is included as a parameter so that the function can associate the right execution state with the socket. </p><p>The request array stores client-specific data and <i>array set request</i> initializes the state for this client request. The next line, <i>fconfigure</i>, sets the socket into nonblocking mode to ensure the server will never be stuck waiting on I/O.</p><p>Finally, two more callbacks are set up. The <i>fileevent</i> callback causes the function <i>DDJread</i> (<A NAME="rl3"><A HREF="#l3">Listing Three</A>) to be called any time data is available to be read from a client. In general, not all of the data will be ready at once. The last callback sets a <i>watchdog</i> timer to fire after 60 seconds. This helps prevent denial-of-service attacks by preventing malicious clients from hogging socket connections. It also provides an opportunity to use time-based events. Both callbacks get passed <i>$socket</i> to make sure we get the proper execution state when the event happens.</p><p>Most of the server is fairly generic: It sets up the event handlers and creates the machinery for managing the execution state. The <i>DDJread</i> procedure contains all of the HTTP-specific handling code. It reads the request line, processes all of the HTTP headers, and reads the request body (the POST data, for instance). As this information is acquired, it is stuffed into the execution state of the client, using the request array.</p><p>In a nonevent-based server, the various parts of the request would be processed sequentially -- first the request line, then the headers, and finally the request body. The current part of the request being processed is implicit in the sequential nature of the code. In the event model, the execution state must be explicit. The <i>switch</i> block in <i>DDJread</i> uses the execution state to keep track of which part of a request is being dealt with. In actual operation, a header line might arrive from one client, followed by the initial request line from another, and a body from a third, seemingly out of order when viewed from the perspective of a sequential system. By representing the code as a state machine, the proper section of code is found to deal with the current request. Although the order of the arms of the <i>switch </i>statement is the same as in the sequential case, they could be ordered arbitrarily without affecting the operation.</p><p>Once the entire request has been processed, <i>DDJrespond</i> (<A NAME="rl4"><A HREF="#l4">Listing Four</A>) is called to deliver the results to the client. <i>DDJrespond</i>, in a more general case, would be used to dispatch the request to the appropriate handler, based on the requested URL and request headers. In this simple example, I'll just dispatch files, although all of the information about the client request has been neatly packaged into the request array. When this procedure is called, the entire request has been processed, so the <i>filevent</i> and <i>watchdog</i> times for this request are canceled. The URL is converted to a filename, and if the file exists, it is sent to the client, along with the proper HTTP headers. Otherwise, a standard error message is returned.</p><p>The <i>fcopy</i> command allows the contents of the file to be transmitted to the client in the background, eliminating the need for another set of event handlers that would dole out pieces of the file to the client at the speed the client could accept them. When <i>fcopy</i> completes the data transfer, <i>DDJcopydone</i> (<A NAME="rl5"><A HREF="#l5">Listing Five</A>) is called, and the connection to the client and the execution state are removed.</p><p>If, for some reason, the client is unable to complete the request in the allotted time, the timer event, set up when the client connection was first opened, expires, and <i>DDJtimeout</i> (<A NAME="rl6"><A HREF="#l6">Listing Six</A>) is called. <i>DDJtimeout</i> closes the connection to the client, and removes the execution state associated with it.</p><p>The other functions in the server (see <A NAME="rl7"><A HREF="#l7">Listing Seven</A>) consist of HTTP-specific utility routines that are needed to create a fully functional server, but have nothing  to do, per se, with event-based programming.</p><h3>Event-Based Limitations </h3><p>Assuming the underlying support for nonblocking I/O, the chief disadvantage of an event-based system arises when the computation required to handle a single event takes too long. For example, if the web server had a built-in search capability that took 60 seconds of elapsed CPU time to complete, then no other clients would be serviced until the search was complete. The throughput would still be high, and the responses would still be returned in first-come/first-serve order, but in this case, that's not good enough. The easiest solution is to break the computation into smaller pieces, say 60 one-second computations. After the first second's worth of computation is complete, the current state of the calculation is saved, and a timer event is scheduled using <i>after</i> to cause the next portion of the computation to commence after other client requests have had a chance to be serviced.</p><p>If the computation is not easily subdivided, or it is impossible to predict in advance how long it would take, then using threads for this portion of the system may be a good idea.</p><h3>Events or Threads?</h3><p>The decision to use events or threads for a particular application depends on several factors: throughput, overhead, and fairness. You should use events when:</p><ul>  <li>	There is underlying support for nonblocking I/O.  <li>	The time to process an event is small compared to the overall latency of the system, or the need for fairness isn't important.</ul><p>Examples of applications that benefit from events include: Internet servers (HTTP for instance), where the user's expected response time is small compared to the time required to calculate the response; and GUIs, where the human response time for an input event, such as a button press, is long in comparison to the time needed to process that button.</p><p>You should consider using threads when:</p><ul>  <li>	There is underlying support for threads in the OS and the required libraries.  <li>	There are few data dependencies among the various threads, minimizing the need for synchronization locks.  <li>	Multiple CPUs are needed for a particular application, and true concurrency is required.</ul><p>Examples of systems where threads are appropriate include high-performance database servers, when true concurrency on multiple CPUs is required, and certain numerical calculations, where a single computation takes a long time, and there are few data dependencies.</p><p>There are many real systems with requirements that don't fit neatly into either category. In such cases, both techniques can be used in the same application. A GUI, written using events, could be interfaced to a thread-based simulation system.</p><h3>Conclusion</h3><p>Event-based programming presents a powerful alternative to threads in the construction of high-speed network servers. It is possible to obtain maximum throughput with the minimum overhead without the need for locks or the fear of data corruption. The built-in support for event-based I/O in Tcl, coupled with simple techniques to manage execution state, make it ideal for this type of application. In the server I present here, there is exactly one thread of execution -- no two event handlers are ever running at the same time, yet the performance and throughput is comparable to commercial servers.</p><h3>References</h3><p>Ousterhout, John. "Why Threads are a Bad Idea (For Most Purposes)." <i>1996 USENIX Conference Proceedings</i>; http://www.scriptics .com/people/john.ousterhout/threads.ps/.</p><p>Welch, Brent. <i>Practical Programming in Tcl and Tk</i>, Second Edition. Prentice Hall, 1997, ISBN 0-13-616830-2. http://www .beedub.com/book/.</p><p>Welch, Brent and Steve Uhler. "Web Enabling Applications." <i>1996 Tcl/Tk Conference</i> (abstract); http://www.scriptics.com/ tclhttpd/usenixAbstract.html.</p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>  set port 8080     ;# the port to listen on  set timeout 60000 ;# max seconds to wait for client request  set root [pwd]    ;# our document root  socket -server [list DDJaccept $root $timeout] $port  vwait forever</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>proc DDJaccept {root timelimit socket ip args} {    upvar #0 $socket request    array set request [list State start Root $root Ip $ip]    fconfigure $socket -block 0 -translation {auto crlf}    fileevent $socket readable [list DDJread $socket]    set request(Cancel) [after $timelimit [list DDJtimeout $socket]]}</pre><P><A HREF="#rl2">Back to Article</A></P><H4><A NAME="l3">Listing Three</H4><pre>proc DDJread {socket} {    upvar #0 $socket request    # unexpected EOF - abort    if {[eof $socket]} {        puts stderr "$socket: Eof ([array get request])"        close $socket        after cancel $request(Cancel)        unset request    }    switch $request(State) {        start {         # Get HTTP request line            gets $socket line            if [regexp {(POST|GET|HEAD) ([^?]+)\??([^ ]*) HTTP/1.0} \                    $line {} request(Proto) request(Url) request(Query)] {                set request(State) headers            } else {                DDJerror $socket "400 Bad Request" "Invalid request:$line"            }        }           headers {            set count [gets $socket line]            if {$count == 0} {  # end of headers                catch {incr count $request(content-length)}                if {$count &gt; 0} {                    fconfigure $socket -translation {binary crlf}                    array set request [list data {} State body Count $count]                } else {                        DDJrespond $socket                }            } elseif {[regexp {([^:]+):[    ]*(.*)}  $line {} key value]} {               set key [string tolower $key]               if {[info exists request($key)]} {               append request($key) ", " $value               } else {               set request($key) $value               }               set request(Key) $key            } elseif {[regexp {^[   ]+(.*)} $line {} value]} {               append request($request(Key)) " " $value            } else {               DDJerror $socket "400 Bad Request" "Invalid header:$line"            }        }        body {            append request(Body) [read $socket $request(Count)]            set request(Count) [expr {$request(content-length) - \                    [string length $request(Body)]}]            if {$request(Count) == 0} {                DDJrespond $socket            }        }    }}</pre><P><A HREF="#rl3">Back to Article</A></P><H4><A NAME="l4">Listing Four</H4><pre>proc DDJrespond {socket} {    upvar #0 $socket request    fileevent $socket readable {}    after cancel $request(Cancel)    set fileName [DDJurlToFile $request(Root) $request(Url)]    if {[file isfile $fileName]} {        append response [DDJheaders "200 data Follows" \                [DDJcontentType $fileName] \                [file size $fileName]] \                "Last-Modified: [DDJdate [file mtime $fileName]]\n"         puts $socket $response        if {$request(Proto) != "HEAD"} {            set in [open $fileName]            fconfigure $socket -translation binary            fconfigure $in -translation binary            fcopy $in $socket -command [list DDJcopyDone $socket $in]        } else {            DDJcopyDone $sock ""        }    } else {        DDJerror $socket "404 Not Found" "Can't find $request(Url)"    }}</pre><P><A HREF="#rl4">Back to Article</A></P><H4><A NAME="l5">Listing Five</H4><pre>proc DDJcopyDone {socket fd size} {    upvar #0 $socket request    puts stderr "[incr ::Ok] $request(Ip) $request(Url) ($size bytes)"    catch {close $fd}    close $socket    # parray request    unset request}</pre><P><A HREF="#rl5">Back to Article</A></P><H4><A NAME="l6">Listing Six</H4><pre>proc DDJtimeout {socket} {    upvar #0 $socket request    puts stderr "$socket: timeout ([array get request])"    close $socket    unset request}</pre><P><A HREF="#rl6">Back to Article</A></P><H4><A NAME="l7">Listing Seven</H4><pre>proc DDJcontentType {fileName}   Looks at the Url suffix, and determines the HTTP document typeproc DDJheaders {code type length}  Formats the standard set of HTTP headers used for replies.proc DDJerror {socket code reason}  Generates a standard error responseproc DDJdate {seconds}  Formats an HTTP date stringproc DDJurlToFile {root Url}  Converts a URL into a file nameproc DDJdecode {data}  Converts any %xx codings embedded in a Url into the equivalent character  representation</pre><P><A HREF="#rl7">Back to Article</A></P><HR><I>Copyright &copy; 1999, Dr. Dobb's Journal</I><BR>
</body></html>