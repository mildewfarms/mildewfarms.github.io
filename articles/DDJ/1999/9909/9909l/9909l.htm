<html><head><title>Sep99: Algorithm Alley</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Rendering Line  Drawings From 3D Models</h1><p><i>Dr. Dobb's Journal</i> September 1999</p><h3>By Thomas E. Janzen</h3><I>Tom is a systems programmer for an entertainment graphics company. He can be contacted at tej@world.std.com.</I><hr><a name="rs1"><a href="9909ls1.htm">B&eacute;zier Curves</a><hr><p>The imitation of reality has been the supreme goal of computer graphics. There's just one problem: When was the last time you could make sense of reality? When driving, I can miss seeing a stop sign that hides behind a tree, struggle to keep my car inside fading lane lines, or fail to notice a patrol car behind me. Reality, in other words, is a mess -- contrast between adjacent items can be poor, outlines indefinite, and colors distracting. In short, photorealistic rendering suffers from these problems to the degree that it imitates reality. </p><p>For immediate visual communication, however, a simple line drawing may be all that is needed. A black line drawing on a white background can be clear and definite, as well as cheap to print. It can emphasize important details and drop extraneous clutter. Nonphotorealistic graphics make an immediate impression on the viewer. </p><p>Luckily, there are techniques for extracting precise edge-and-shape information from less-than-precise 3D models so that you can generate clear and discernible pen-and-ink-like drawings. In this article, I'll examine three of these algorithms:</p><ul>  <li>	Using difference operators on the Z buffer.  <li>	For parametric surfaces, drawing isoparametric lines.  <li>	Using normals and dot products to detect where the surface curves away from the viewer, and also drawing boundaries.</ul><p>To illustrate these techniques, I'll use the room scene in <A NAME="rf1"><A HREF="9909lf1.htm">Figure 1</A>, which includes a desk, globe, chair, and levitating B&eacute;zier surface. The example program, called "room" (available electronically; see "Resource Center," page 5) is about 900 lines of C++ and based on OpenGL. Although a class hierarchy makes sense here, it isn't as helpful in describing algorithms. Even the vector container from the Standard Template Library becomes annoying for arrays of fixed length; I have to declare both a standard array and the vector object, then fill in the vector with the old array. Unless I'm doing sorts and other heavier algorithms provided by the STL, this doesn't return much. The program is built from four modules, each in its own .cpp file and represented by an include file: room.cpp (main) and room.h, world.cpp and world.h, roomutil.cpp and roomutil.h, and Bezier.cpp and Bezier.h.</p><p>I've made use of the OpenGL graphics library because it takes care of the modeling and <i>n</i> issues, and provides access to a Z buffer. I developed "room" under Linux 2.2 with Mesa (by Brian Paul), but room should run under Windows. My GUI is GLUT because, although limited when compared with major GUIs, GLUT makes the code more portable. You may need to acquire GLUT over the Web for your system, but OpenGL seems to be included in Windows 95, and may be included with other operating systems.</p><h3>Difference Operators on the Z Buffer</h3><p>One technique for making line drawings from 3D models is to apply difference operators to the Z buffer. While each pixel in the framebuffer is the value of the red, green, and blue colors given the object color and the light falling on it, the value of each pixel in the Z buffer is the distance from the viewer's eye to the model in OpenGL's internal coordinates between 0 and 1. Displayed, the Z buffer is brighter for more distant points and darker for closer ones. <A NAME="rf2"><A HREF="9909lf2.htm">Figure 2</A>, a view of the room via the Z buffer, shows that the more distant objects are brighter because they have higher Z or depth values, and higher values are displayed as bright in the frame buffer.</p><p>In the continuous domain, rates of change in functions are found with derivatives. For derivatives of scalar fields, there are the general operators  --  (<i>del</i>, a derivative) and  -- <sup>2</sup> (the <i>laplacian, </i>a second-order derivative). When applied to a graphic image in one color, a <i>del</i> operator tends to make a derivative image that has higher values where there were rapid changes between light and dark -- where you might want outlines. From a Z buffer image, this tends to draw silhouette lines at edges of objects against the background because there is a big change in depth from the object to the background. This change from an object to the background is called a "discontinuity," even though this term applies in math only to continuous functions and not an array of discrete points.</p><p>A first-order <i>Sobel</i> operator tends to draw lines at simple changes in value. From a Z buffer, <i>Sobel</i> operators draw silhouettes around objects, because it detects the change in value from the object's edge to the background. Unlike the <i>laplacian</i>, <i>Sobel</i> requires two matrices, one of which finds changes horizontally and the other vertically. The matrices are:</p><img src="matrix1.gif" width="159" height="49" hspace="3"><p><A NAME="rl1"><A HREF="#l1">Listing One</A>, from the module room.cpp in the function <i>sobel_diff()</i>, uses these matrices (<i>sobela </i>and <i>sobelb</i>, respectively). <A NAME="rf3"><A HREF="9909lf3.htm">Figure 3</A> is output from <A NAME="rl1"><A HREF="#l1">Listing One</A>. Advanced work has addressed issues with these operators, such as doubling narrow lines and occasionally drawing lines on the middle of a model's surface because its slope (relative to the viewer) is very fast, and therefore found by difference operators. </p><p>A second-order operator such as a <i>laplacian</i> tend to show turnarounds (inflections). From a Z buffer image, a <i>laplacian</i> tends to draw lines at the cornered intersections of walls and other surfaces. The <i>laplacian</i> operator is simply:</p><img src="matrix2.gif" width="76" height="49" hspace="3"><p>The purpose of "-1" is to subtract neighboring pixel values from the value at the center of the operator's matrix, which is scaled to be in units of the same magnitude. <A NAME="rl2"><A HREF="#l2">Listing Two</A> is from room.cpp's <i>laplace_diff()</i> function. The <i>laplacian</i> operator is centered over a pixel in the Z buffer. In <A NAME="rf4"><A HREF="9909lf4.htm">Figure 4</A>, this is centered over the part of the Z buffer that has the values:</p><img src="matrix3.gif" width="67" height="48" hspace="3"><p>All you do is multiply corresponding values and add:</p><img src="matrix4.gif" width="127" height="49" hspace="3"><p>then add the products:</p><blockquote><p>-.2-.3-.2-.2+2.4-.2-.2-.3-.2=.6.</p></blockquote><p>You do this for each pixel. (I skipped the border pixels to avoid the <i>if</i> statements required to detect the borders and fill in the missing values, such as the center value, which would register no difference with the missing pixels -- appropriate behavior for this operator). <A NAME="rl2"><A HREF="#l2">Listing Two</A> does this.</p><p>The outer loops of <i>i</i> and <i>j</i> scan the entire image width and height. The inner loops move through the 3&times;3 operator. Clearly, this could be optimized by replacing the two inner loops on <i>io</i> and <i>jo</i> with a single statement; see <A NAME="rl3"><A HREF="#l3">Listing Three</A>. <A NAME="rf5"><A HREF="9909lf5.htm">Figure 5</A> is the result of this operator. </p><h3>Isoparametric Lines</h3><p>Isoparametric lines are those in which one parameter is held constant while another changes. This presumes that your model's surface is defined parametrically in the first place. The B&eacute;zier surface in this example has two parameters (<i>u</i> and <i>v</i> in the code). When you select "isoparametric" from the menu, the B&eacute;zier surface is drawn as a collection of lines with a <i>u</i> constant for each sweep of the surface by a changing <i>v</i>. The lines suggest the curvature of the surface, and also bunch up where the surface is narrower. This may help define the surface, but there are algorithms for dropping out lines as they become crowded. Without hidden line removal, this algorithm is incomplete, but it serves as an illustration. Although OpenGL supports B&eacute;zier surfaces, I built mine from scratch to have direct access to the way it is drawn and to illustrate the techniques used.</p><p>The code to draw the B&eacute;zier surface as lines (see <A NAME="rl4"><A HREF="#l4">Listing Four</A>, from bezier.cpp) is combined with the code that draws it as quadrilateral patches. All this does is draw sets of connected line segments as you change the <i>u</i> parameter. The result is a set of curves that follows and suggests the surface. <A NAME="rf6"><A HREF="9909lf6.htm">Figure 6</A> is the result of this approach.</p><h3>Finding Silhouette  Edges from Vector Operations</h3><p>The final technique I'll present here for making line drawings from 3D models involves finding silhouettes from vector operations on the normals to the surface of the model. I'll use the B&eacute;zier surface for this example as well, since finding its silhouette where it bends behind is more interesting than finding the boundaries of boxes.</p><p>Finding this silhouette is easy for boundaries. I know where the boundaries of my B&eacute;zier surface are -- at the boundaries of my matrix of vertices. All I need to do is to draw lines along the vertices at the edges of my matrix of vertices. It's trickier to find the silhouette of where I made the surface curve behind. To do that, I use the normals (the vectors at right angles to the quad patches), and the vector from the viewer's eye to the normals.</p><p>For each test vertex:</p><p>1.	Find the normal to the test patch and those neighboring patches that share an edge.</p><p>2.	Find the vector from the viewer's eye to the patch.</p><p>3.	Find the dot product of the view vector and the normal for each of the patches.</p><p>4.	Compare the resulting dot products. If there is a change of sign in the dot product from the test patch to its neighbor, then one is bent behind the other; draw the edge between the two patches. <A NAME="rf7"><A HREF="9909lf7.htm">Figure 7</A> shows the relationships between these various vectors.</p><p></p><p>The code is in <i>bezier()</i> and is the "else" to "if (isoparm)" on the assumption that you are using either isoparametric lines or silhouettes. Some code for finding silhouettes is in <i>bezier()</i> and <A NAME="rl5"><A HREF="#l5">Listing Five</A> (from the <i>bezier()</i> function in the module bezier.cpp). The code has to check that the parametric indices that march along the surface still have at least one more vertex to go, because it will compare dot products for this surface and the next one. I don't need to compare dot products for the last surface because it is a boundary and will get a line for that reason. <A NAME="rf8"><A HREF="9909lf8.htm">Figure 8</A> shows the results of finding the silhouette of the B&eacute;zier surface. I have neglected hidden-line removal for this algorithm as well, and the small end of the surface can be seen.</p><h3>References</h3><p>Angel, Edward. <i>Interactive Computer Graphics: A Top-down Approach with OpenGL</i>. Addison-Wesley, 1997. </p><p>Janzen, Thomas.<i> 10 Papers on Non-Pho</i>torealistic Rendering. http://world.std .com/~tej/, 1998.</p><p>Lansdown, John and Simon Schofield. "Expressive Rendering: A Review of Nonphotorealistic Techniques." <i>IEEE Computer Graphics and Applications</i>. May 1995.</p><p>Paul, Brian(brianp@elastic.avid.com). Mesa 3.0. ftp://iris.ssec. wisc.edu/pub/Mesa/.</p><p>Saito, Takafumi and Tokiichiro Takahashi. "Comprehensible Rendering of 3-D Shapes." <i>ACM Computer Graphics: Proceedings of SIGGRAPH</i>, 1990. </p><p>Williamson, Richard E. and Hale F. Trotter. <i>Multivariable Mathematics: Linear Algebra, Calculus, Differential Equations</i>. Prentice-Hall, 1979.x</p><p>SGI OpenGL resources: http://www.sgi .com/Technology/openGL/, http://www .digital.com:80/pub/doc/opengl/, http:// www.sgi.com/Technology/openGL/glspec/glspec.html.</p><p>Woo, Mason, Jackie Neider, and Tom Davis. <i>OpenGL Programming Guide</i>, Second Edition. Addison-Wesley Developers Press, 1997.</p><p>Kempf, Renate and Chris Frazier, editors. <i>OpenGl Reference Manual</i>, Second Edition. Addison-Wesley Developers Press, 1997.</p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>for (i = 1; i &lt; (gw - 1); ++i) {  for (j = 1; j &lt; (gh - 1); ++j) {    suma = 0.0; sumb = 0;    for (io = -1; io &lt;= 1; ++io) {      for (jo = -1; jo &lt;= 1; ++jo) {        suma  += sobelaM[io+1][jo+1] * pixels[i + io][j + jo];        sumb += sobelbM[io+1][jo+1] * pixels[i + io][j + jo];      }    }    diffpixels[i][j] = (fabs(suma) + fabs(sumb)) / 8.0;  }}</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>for (i = 1; i &lt; (gw - 1); ++i) {  for (j = 1; j &lt; (gh - 1); ++j) {    sumo = 0.0;    for (io = -1; io &lt;= 1; ++io)      for (jo = -1; jo &lt;= 1; ++jo)        sumo  += laplaceline[io+1][jo+1] * pixels[i + io][j + jo];    diffpixels[i][j] = sumo / 3;  }}</pre><P><A HREF="#rl2">Back to Article</A></P><H4><A NAME="l3">Listing Three </H4><pre>sumo += (-pixels[i-1][j-1] - pixels[i-1][j] - pixels[i-1][j+1]       - pixels[i][j-1] + 8*pixels[i][j] - pixels[i][j+1]       - pixels[i+1][j-1] - pixels[i+1][j] - pixels[i+1][j+1])/8;</pre><P><A HREF="#rl3">Back to Article</A></P><H4><A NAME="l4">Listing Four</H4><pre>glBegin(GL_LINES); ...for (u_ctr = 0; u_ctr &lt; PARM_STEP_QTY; ++u_ctr) {  for (v_ctr = 0; v_ctr &lt; PARM_STEP_QTY; ++v_ctr) {    if (isoparm) {      if (!(u_ctr % 4) || (u_ctr == (PARM_STEP_QTY - 1))) {        glVertex3dv(vertices[u_ctr][v_ctr]);        glVertex3dv(vertices[u_ctr][v_ctr + 1]);      }    }else {      ... // draw either silhouettes or patches    }  }}glEnd(); ...</pre><P><A HREF="#rl4">Back to Article</A></P><H4><A NAME="l5">Listing Five </H4><pre>void Bezier(Bezier_type points, const dbl_vec_type LookAtEye)...for (u = 0; u &lt;= PARM_STEP_QTY; ++u) {  for (v = 0; v &lt;= PARM_STEP_QTY; ++v) { ...  cross(vert[u][v + 1], vert[u][v], vert[u + 1][v], n);  if (silhouette) {    ... // draw borders on edge vert    if ((v + 2) &lt;= PARM_STEP_QTY) { // for inner patches      cross(vert[u][v + 2], vert[u][v + 1], vert[u + 1][v + 1], n2);      eyevect[0..2] = vert[u][v + 1][0..2] - Eye[0..2];      if (oppositesigns(dot(eyevect, n), dot(eyevect, n2))) {         glVertex3dv(vert[u][v+1]);        glVertex3dv(vert[u + 1][v + 1]);      }    }    if ((u + 2) &lt;= PARM_STEP_QTY) {      //... similar code along changing u counter    }  }else {   //  draw normal patches.    ...</pre><P><A HREF="#rl5">Back to Article</A></P><H4><A NAME="l6">Listing Six</H4><pre>for (k = 0; k &lt; DIM_QTY; ++k) {  for (i = 0; i &lt; DIM_QTY; ++i) {    for (j = 0; j &lt; DIM_QTY; ++j)      p[k] += bu[i] * bv[j] * p_control[i][j][k];  }}</pre><P><A HREF="#rl6">Back to Article</A></P><HR><I>Copyright &copy; 1999, Dr. Dobb's Journal</I><BR>
</body></html>