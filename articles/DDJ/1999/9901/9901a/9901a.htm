<html><head><title>Jan99: Automating the Web with WebL</title></head><BODY BGCOLOR="#ffffff" TEXT="#000000" LINK="#0000ff" VLINK="#330066" ALINK="#FF0000">
<!--Copyright &#169; Dr. Dobb's Journal--><h1>Automating the Web with WebL</h1><p><i>Dr. Dobb's Journal</i> January 1999</p><h2>A scripting language for prototyping web apps</h2><h3>By Hannes Marais and Tom Rodeheffer</h3><I>Hannes and Tom are members of the research staff at Compaq Computer Corp. Systems Research Center. They can be contacted at marais@pa.dec.com and tomr@pa.dec.com, respectively.</I><hr><p>Many people regard the World Wide Web as a world-wide distributed hypertext with content that is read and understood by humans. However, the Web is also home to a growing number of software applications such as spiders, softbots, and intelligent agents. These applications perform various operations on web data, primarily automating tasks that humans find too repetitive and time consuming.</p><p>Such applications need to be programmed to discern the organization, protocols, and data formats encountered on the Web. Although rudimentary software libraries exist for communicating across the Internet, there are few comprehensive libraries for fetching and serving web pages, resolving URLs, filling out input forms, parsing HTML, and so on. To bring such facilities to the application programmer, we at Compaq Computer Corporation's Systems Research Center (SRC) have developed a new web scripting language called "WebL" (pronounced "webble").</p><p>WebL is an ideal language for prototyping web applications. Shopping robots, meta-search engines, site validators, and page-information extractors are typical applications that are easy to write in WebL. The WebL language interpreter is written in Java, and is freely available (including documentation) at http://www.research.digital.com/SRC/WebL/. We described an earlier version of WebL at the 7th International World Wide Web Conference (see "WebL: A Programming Language for the Web," <i>Proceedings of the 7th International World Wide Web Conference</i>, <i>In Computer Networks and ISDN Systems 30</i>, 1998).</p><p>As <A NAME="rf1"><A HREF="9901af1.htm">Figure 1</A> shows, a typical WebL program fetches documents from the Web, extracts and refines data from the documents, then converts the resulting data back into a document on the Web. In addition to the usual assortment of high-level control statements and data types, WebL contains two special features to help the web-application programmer: service combinators, which help handle unreliable services; and a markup algebra, which helps handle structured text like HTML and XML. </p><h3>Special Features In WebL</h3><p>In theory, the Web is ubiquitous, but in practice, you often find traffic jams and construction delays on the information superhighway. For example, a web server might provide intermittent service or a data connection might abort or stall. These are modes of failure. Humans know when to click "stop" and try again, but in most computer languages, failure is difficult to handle and programmers often do not bother to try. WebL provides service combinators to simplify handling failures. Service combinators can also be used to exploit the inherent parallelism of replicated servers, as we will explain later.</p><p>In addition, most web pages contain structured text written in a markup language such as HTML or XML. In theory, structured text is a carefully organized presentation of data, but in practice, you often find clutter, misuse, and unexpected reorganization. For example, many pages use manual formatting in place of headings or lists; tables are frequently used for presentation effects; illegal HTML is not rare, and formats unexpectedly change from day to day. WebL provides a markup algebra to simplify the extraction of data from structured text. The operators of the markup algebra are designed to make it easy to selectively pick information from a page while ignoring the surrounding clutter. WebL programs can also be updated quickly to reflect page format changes because, in general, only a few lines of code need to be changed.</p><h3>Service Combinators</h3><p>First introduced by L. Cardelli and R. Davies (see "Service Combinators for Web Computing," <i>Research Report 148</i>, Digital Equipment Corporation Systems Research Center, June 1997 at http://gatekeeper.dec.com/pub/DEC/SRC/research-reports/abstracts/src-rr-148.html), service combinators are used to handle service failures and exploit replicated servers. Service combinators make it easy to mimic human reflexes such as reloading stalled links, retrying requests after pauses, switching to lesser used servers, and running multiple requests in parallel. By providing an easy way to express these reflexes, it becomes easier to write robust scripts.</p><p>A service is either a primitive action (such as fetching a web page) or a compound action involving control structures and component services. A service terminates with either success or failure and, in the event of success, the service also produces a value. A service combinator is a control structure that determines the execution order of its component services based on their success or failure. <A NAME="rt1"><A HREF="9901at1.htm">Table 1</A> gives brief descriptions of service combinators, and <A NAME="re1"><A HREF="9901ae1.htm">Example 1</A> uses them in some WebL program fragments.</p><p>The <i>GetURL</i> and <i>PostURL</i> functions perform the primitive service of fetching a web page. <i>GetURL</i> uses the HTTP GET protocol and returns a WebL object that encapsulates the parsed structure of the page. If the fetch fails, then the function fails. The optional second argument to GetURL provides query arguments. <i>PostURL</i> is similar but uses the HTTP POST protocol, which fills in web-based input forms. <A HREF="9901ae1.htm">Example 1</A>(a) attempts to fetch the named URL and <A HREF="9901ae1.htm">Example 1</A>(b) looks up the word "java" on the AltaVista search engine.</p><p>The sequential execution combinator <i>?</i> allows a secondary service to be consulted in case the primary service fails. The service <i>S ? T</i> acts like the service <i>S</i>, except that if <i>S</i> fails, it then executes the service <i>T</i>. <A HREF="9901ae1.htm">Example 1</A>(c) first attempts to contact AltaVista in California and, in case of failure, then attempts to contact a mirror site in Australia.</p><p>The concurrent execution combinator <i>|</i> allows two services to be executed concurrently. The service <i>S | T</i> starts both services <i>S</i> and <i>T</i> in parallel and returns the result of whichever succeeds first. If both <i>S</i> and <i>T</i> fail, then the combined service also fails. <A HREF="9901ae1.htm">Example 1</A>(d) attempts to fetch a page from one of two alternate sites. Both sites are attempted concurrently, and the result is the site successfully contacted first.</p><p>The timeout combinator allows a time limit to be placed on a service. The service <i>Timeout(t,S)</i> acts like <i>S</i>, except that it fails after <i>t</i> milliseconds if <i>S</i> has not terminated within that time. <A HREF="9901ae1.htm">Example 1</A>(e) attempts to fetch a page from one of two alternate sites, but gives a limit of 10 seconds to succeed.</p><p>The retry combinator provides a way to repeatedly invoke a service until it succeeds. The service <i>Retry(S)</i> acts like <i>S</i>, except that each time <i>S</i> fails, <i>S</i> starts again. Combining retry with sequential execution, <A HREF="9901ae1.htm">Example 1</A>(f) makes repeated attempts in the case of failure, alternating between two sites.</p><p>Finally, the primitive service <i>Stall()</i> never succeeds or fails. Combining stall with timeout and retry, <A HREF="9901ae1.htm">Example 1</A>(g) repeatedly attempts to fetch the URL, but waits 10 seconds after each failure before trying again.</p><h3>Markup Algebra</h3><p>The markup algebra is used to extract information from, and manipulate the contents of, web pages written in HTML and XML format. The markup algebra is based on the WebL data types piece and piece-set and on a set of algebraic operators. </p><p>A piece is a contiguous region of text in a document, identified by a starting position and an ending position. A piece is either named or unnamed.</p><p>A named piece is a markup element and its starting and ending positions are the element's open and close tags. The name of a named piece is simply the name of the markup element itself, for example, "img," "h1," or "p."</p><p>An unnamed piece is a region of text that does not correspond to a markup element. The starting and ending positions of an unnamed piece are unnamed, invisible open and close tags that WebL automatically inserts as necessary. These invisible tags function merely as placeholders in the document and have no other effect. Unnamed pieces are created, for example, by a text search.</p><p><A NAME="rf2"><A HREF="9901af2.htm">Figure 2</A> shows some pieces in a fragment of an HTML document. As you can see, pieces may overlap in an arbitrary manner.</p><p>A piece-set is an ordered set of pieces. Pieces within a piece-set may overlap but must belong to the same document. Pieces are ordered according to starting position, with ties broken according to ending position. By comparing the starting and ending positions of a piece <i>p</i> and a piece <i>q</i>, WebL determines whether <i>p</i> is before, after, inside, contains, or overlaps with <i>q</i>. <A NAME="rf3"><A HREF="9901af3.htm">Figure 3</A> illustrates the possible comparisons.</p><p>Typically, piece-sets are created by searching a page for markup elements (<i>Elem</i>) or for occurrences of given text (<i>Pat</i>). For example, consider the HTML page in <A NAME="rl1"><A HREF="9901a.htm#l1">Listing One</A>, the WebL program in <A NAME="rl2"><A HREF="9901a.htm#l2">Listing Two</A>, and the output of this program in <A NAME="rl3"><A HREF="9901a.htm#l3">Listing Three</A>. </p><p>The <i>Elem</i> function searches a page for all HTML or XML markup elements of a specific name. In our example, the <i>Elem</i> on line 5 searches for hyperlink anchor elements. The result is a piece-set that contains a piece for each anchor element in the page. Note that the attributes of the element can be accessed as fields of the piece (lines 10, 20). The pieces in a piece-set can be enumerated in order (lines 9-15), or an individual piece can be extracted by using a numerical index (line 20).</p><p>The <i>Pat</i> function searches a page for all occurrences of a Perl5-style regular expression (see J.E.F. Friedl's <i>Mastering Regular Expressions: Powerful Techniques for Perl and Other Tools</i>, O'Reilly &amp; Associates, 1997). In our example, the <i>Pat</i> on line 24 searches for the character sequence "Web" or "web." The search ignores markup. The result is a piece-set that contains a piece for each matched text segment. WebL automatically inserts unnamed, invisible tags to serve as starting and ending positions for these unnamed pieces.</p><p>In addition, a function called <i>Seq</i> searches for a sequence of markup elements. This function is useful for matching <sup></sup>computer-generated HTML, which often contains highly stylized markup patterns without hierarchical structure. In our example, the <i>Seq</i> on line 40 searches for a bold element, followed by text, followed by an italic element. For each piece in the resulting piece-set, a numerical index can be used to extract the region of text matched by the corresponding specifier in the sequence. These regions are actually pieces as well.</p><p>In addition to searching a page, WebL's searching functions can also search inside a single piece. The results are the same, but limited as to what appears inside the piece.</p><h3>Algebraic Operators</h3><p>Once we have some initial piece-sets, we can combine them algebraically to produce additional piece-sets. Each of WebL's algebraic operators takes two piece-sets, <i>P</i> and <i>Q,</i> and produces a third piece-set as a result. WebL provides set operators, positional operators, and hierarchical operators. <A NAME="rt2"><A HREF="9901at2.htm">Table 2</A> gives brief definitions and <A NAME="re2"><A HREF="9901ae2.htm">Example 2</A> uses them in some WebL program fragments. WebL also has negated versions of the positional and hierarchical operators, as well as functions to traverse the document in a hierarchical manner. </p><p>In addition to piece-sets, the algebraic operators also work with single pieces as operands. The algebraic operators treat a piece as if it was a piece-set with a single element.</p><p>Set operators are used for basic set manipulation. The set union operator merges the two piece-sets <i>P</i> and <i>Q</i>, eliminating duplicates. The set intersection operator returns the set of all pieces that are in both <i>P</i> and <i>Q</i>. The set exclusion operator calculates the set of pieces that are in <i>P</i> but not in <i>Q</i>. <A HREF="9901ae2.htm">Example 2</A>(a) extracts level-one and level-two headings, then merges them.</p><p>Positional operators are used to express relationships between pieces based on their locations in the linear text flow of the document. The <i>before</i> operator returns the set of pieces in <i>P</i> that is located before some piece in <i>Q</i>. In <A HREF="9901af3.htm">Figure 3</A>, a piece <i>p</i> is before a piece <i>q</i> if the ending position of <i>p </i>precedes the starting position of <i>q</i>. Similarly, the <i>after</i> operator returns the set of pieces in <i>P</i> that is located after some piece in <i>Q</i>, and the <i>overlap</i> operator returns the set of pieces in <i>P</i> that overlaps with some piece in <i>Q</i>. <A HREF="9901ae2.htm">Example 2</A>(b) finds all instances of "Web" or "web" that occur before the fourth level-one heading. (Recall that index zero extracts the first element of a piece-set.)</p><p>Although they are very effective, the <i>before</i> and <i>after</i> operators are not always sufficient. For example, you might be interested in only the first occurrence of a link after a special keyword, rather than all occurrences. For this purpose, WebL provides the stronger operator <i>directlyafter</i>, which returns the set that contains, for each <i>q</i><img SRC="memof10.gif" width="7" height="7"><i>Q</i>, the first piece (if any) in <i>P</i> that follows that <i>q</i>. The <i>directlybefore</i> operator is analogous. <A HREF="9901ae2.htm">Example 2</A>(c) finds the first anchor element that occurs after each occurrence of the word "CITE."</p><p>Hierarchical operators are used to express relationships between pieces based on containment and inclusion. The <i>inside</i> operator returns the set of pieces in <i>P</i> that is contained in some piece in <i>Q</i>. A piece <i>p</i> is contained in a piece <i>q</i> if: <i>p</i> does not start before <i>q</i> starts, <i>p</i> does not end after <i>q</i> ends, and either the starting positions or the ending positions (or both) are different. Correspondingly, the <i>contain</i> operator returns the set of pieces in <i>P</i> that contains some piece in <i>Q</i>. <A HREF="9901ae2.htm">Example 2</A>(d) finds all hyperlink anchors that contain an image. As in the case of positional operators, WebL also provides the stronger hierarchical operators <i>directlyinside</i> and <i>directlycontain</i>.</p><p>The true power of the algebraic operators becomes clear when they are combined in useful ways. In fact, one of WebL's innovations is the ability to combine piece-set operators with arguments calculated using <i>Elem</i>, <i>Pat</i>, <i>Seq</i>, and so on. <A HREF="9901ae2.htm">Example 2</A>(e) extracts all rows of all tables that mention the phrase "Stock Quotes," except the first such table -- which is omitted. Our example uses <i>directlycontain</i> to extract only the innermost tables that mention the phrase. This is because web pages often use nested tables for presentation effects, and we want to ignore such clutter.</p><p>WebL also contains functions for manipulating web pages to insert, delete, and replace the contents of pieces (some of which are in <A NAME="rl5"><A HREF="9901a.htm#l5">Listing Five</A>). </p><h3>Putting it all Together</h3><p>Using service combinators and the markup algebra, it becomes quite easy to program the Web. For example, <A NAME="rl4"><A HREF="9901a.htm#l4">Listing Four</A> implements a meta-search engine that combines search results from the AltaVista and HotBot public-search services. The tricky part is determining how to parse the search results, but whatever parse you choose will be easy to write. <A HREF="9901a.htm#l5">Listing Five</A> implements a highlight server that fetches an arbitrary web document, modifies it to highlight all occurrences of some given text, and serves the result back to a browser. It also rewrites all hyperlinks to query through the highlight server so that clicking on a link gets the highlighted version of the linked document. Each of these examples takes less than a single page of WebL code.</p><p>WebL is distributed as a research prototype and includes source code. It is easy to dynamically add new functionality to the system in the form of modules written in either WebL or Java. Modules that control your web browser, manipulate URLs, and implement a web server and a customizable web crawler are already available. More information about WebL can be found at our release page at http://www.research.digital.com/SRC/WebL/.</p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</A></H4><pre>&lt;html&gt;&lt;head&gt;&lt;title&gt;WebL Test Page&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;img SRC="pix/webllogo.gif"&gt;&lt;p&gt;&lt;font size=+2&gt;W&lt;b&gt;e&lt;/b&gt;bL&lt;/font&gt; (pronounced "webble")is a &lt;font size=+1&gt;scripting language&lt;/font&gt; for automating tasks on theWorld-Wide Web.It is an imperative, interpreted language that has built-in supportfor common web protocols like HTTP and FTP, andpopular data types like HTML and XML.&lt;p&gt;&lt;a name="features"&gt;WebL has two special features.&lt;/a&gt;&lt;p&gt;&lt;b&gt;Service combinators&lt;/b&gt; provide an &lt;i&gt;exception-handling mechanism&lt;/i&gt;that makes computations on the web more reliable.&lt;p&gt;A &lt;b&gt;markup algebra&lt;/b&gt; provides a wayto &lt;i&gt;extract &lt;b&gt;and&lt;/b&gt; manipulate data&lt;/i&gt; in web pages.&lt;p&gt;These features make it easy to implement tools like web shopping robots,meta-search engines, HTML analysis and checking routines, and so on.&lt;p&gt;WebL's implementation language is Java, and the complete source code is&lt;font size=+1&gt;&lt;a href="http://www.research.digital.com/SRC/WebL/index.html"&gt;freely available&lt;/a&gt;&lt;/font&gt;.Extensions (in the form of modules) are easy to add by Java programmers.&lt;p&gt;&lt;a href=http://www.compaq.com&gt;&lt;img SRC="pix/cpqlogo.gif"&gt;&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;<p></p></pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>1 var page = GetURL("file:demo.html");   // fetch the demo page2 3 4 5 var links = Elem(page,"a");         // extract anchor elements6 7 // loop for each piece, same order as in document8 9 every link in links do10     PrintLn(link.href) ? nil        // print its href attribute11 12     // link.href fails if piece has no href attribute,13     // service combinator handles failure with a secondary14     // execution of nil (which does nothing)15 end;16 17 // since piece-sets are ordered, the individual pieces can be18 // extracted by applying a numeric index19 20 PrintLn("name = ",links[0].name);   // name attribute of first anchor21 22 23 24 var words = Pat(page,"(W|w)eb");    // extract text occurrences25 26 // loop for each piece, same order as in document27 28 every word in words do29     Print(Markup(word)," ")         // print word including markup30 end;31 32 PrintLn("= ", Size(words), " times.");    // how many words33 34 35 36 // extract sequences of &lt;bold element&gt; text &lt;italic element&gt;37 // each resulting piece is such a sequence38 // loop for each piece, same order as in document39 40 every item in Seq(page,"b # i") do41 42     // by applying a numeric index, we get the component that43     // matched the respective specifier of the search sequence44 45     // print the bold element and the italic element,46     // just text, ignoring markup47 48     PrintLn(Text(item[0])," -- ",Text(item[2]))49 end;<p></p></pre><P><A HREF="#rl2">Back to Article</A></P><H4><A NAME="l3">Listing Three</H4><pre>http://www.research.digital.com/SRC/WebL/index.htmlhttp://www.compaq.com/name = featuresWeb W&lt;b&gt;e&lt;/b&gt;b web Web web Web web web web Web = 10 times.Service combinators -- exception-handling mechanismmarkup algebra -- extract and manipulate data</pre><P><A HREF="#rl3">Back to Article</A></P><H4><A NAME="l4">Listing Four</H4><pre>1 import Str;2 3 var QueryAltaVista = fun(query)4   var results = [];               // initially empty result list5   var page = GetURL(              // how to query AltaVista6     "http://www.altavista.digital.com/cgi-bin/query",7     [. pg="q", q=query .]);8   every i in Seq(page,"b a br # font br #") do  // find the answers9     results = results +          // concatenate this answer10       [[.                        // make an object with these fields11         title = Text(i[1]),12         href = i[1].href,13         abstract = Str_Trim(Text(i[6]))14       .]]15   end;16   results17 end;18 19 var QueryHotBot = fun(query)20   var results = [];              // initially empty result list21   var page = GetURL(             // how to query HotBot22     "http://www.hotbot.com/default.asp",23     [. MT=query .]);24   every i in Seq(page,"b br # br") do     // find the answers25     // Elem can search inside a piece too26     // URL is the 2nd anchor in the 1st component 27     var a = Elem(i[0],"a")[1];  28     results = results +          // concatenate this answer29       [[.                        // make an object with these fields30         title = Text(a),31         href = a.href,32         abstract = Text(i[2])33       .]]34   end;35   results36 end;37 38 var q = ARGS[1];                 // get query word from command line39 var results = QueryAltaVista(q) + QueryHotBot(q);40 PrintLn("Results for ",q,":");41 every r in results do            // print each result42   PrintLn();43   PrintLn("    ",r.title);44   PrintLn("    ",r.href);45   PrintLn(r.abstract);46 end<p></p></pre><P><A HREF="#rl4">Back to Article</A></P><H4><A NAME="l5">Listing Five</H4><pre>1 import Url;2 import WebServer;3 4 var port = 9092;5 var where = "/bin/highlight";6 7 8 var Highlight = fun(req,res)9   // access the url and word parameters from the request10   // missing parameters cause the field access to fail11   // default values supplied using a service combinator12 13   var url = req.param.url ? "http://www.compaq.com";14   var word = req.param.word ? "Compaq";15 16   PrintLn("url=",url," word=",word);   // log it on the console17 18   var page = GetURL(url);              // fetch the page19 20   // for each matching text not inside the title 21   every w in Pat(page,word) !inside Elem(page,"title") do22     var p = NewNamedPiece("font",w);   // wrap a font element around it23     p.size := "+1";                    // define its size attribute24     p.color := "red";                  // define its color attribute25   end;26 27   every a in Elem(page,"a") do         // for each anchor28     a.href = where +                   // rewrite its href to be me29              "?word=" + Url_Encode(word) +    // word parameter30              "&amp;url=" + Url_Encode(a.href)     // url parameter31       ? nil;                           // but do nothing if no href32   end;33 34   res.result = Markup(page);           // this is the result35 end;36 37 38 WebServer_Publish(where,Highlight);    // associate url with function39 WebServer_Start("/dev/null",port);     // disk pages root, server port40 41 // when a browser tries to fetch a "published" page,42 // web server task calls back to our function to handle the request43 44 PrintLn("Highlight Server running. Contact :",port,where);45 46 Stall()                                // server task runs in background</pre><P><A HREF="#rl5">Back to Article</A></P><HR><I>Copyright &copy; 1999, Dr. Dobb's Journal</I><BR>
</body></html>