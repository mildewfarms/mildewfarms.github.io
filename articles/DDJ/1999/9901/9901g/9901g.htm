<html><head><title>Jan99: Ficl: An Embeddable Extension Language Interpreter</title></head><BODY BGCOLOR="#ffffff" TEXT="#000000" LINK="#0000ff" VLINK="#330066" ALINK="#FF0000">
<!--Copyright &#169; Dr. Dobb's Journal--><h1>Ficl: An Embeddable Extension Language Interpreter</h1><p><i>Dr. Dobb's Journal</i> January 1999</p><h2>Forth for the rest of us</h2><h3>By John Sadler</h3><I>John works for Hewlett-Packard. He can be contacted at john_sadler@alum.mit.com.</I><hr>Sidebar: <A NAME="rs1"><a href="9901gs1.htm">Ficl Syntax (and more)</a><hr><p>Glue languages such as Perl, Tcl, and Python are popular because they help you get results quickly. They make quick work of problems that are often tedious to code in C or C++, and they can work with code written in other languages. People often miss this last benefit because Perl and Python usually run standalone. Tcl, on the other hand, was designed from scratch as an extension language and is relatively simple to insert into another program. All of these languages were designed to work with mainstream operating systems, so they require lots of memory, a filesystem, and other resources that are commonplace on a modern PC or workstation. </p><p>In this article, I'll describe an interpreter that has a system interface similar in spirit to Tcl, but is specifically designed for embedded systems with minimal resources. Because the syntax is ANS Forth, I call it "Ficl," short for "Forth-Inspired Command Language." (From here on, I'll use the terms "Forth" and "Ficl" interchangeably.) The complete source code for Ficl is available electronically; see "Resource Center," page 5.</p><p>Ficl is Forth, but you don't have to be a Forth zealot to use it. In fact, you can learn enough Forth in a half-hour to begin using it. </p><p>Ficl is a small but complete programming language -- not just a command interpreter -- so you can hack a prototype for new behavior. Because Ficl is interactive, you can use it to help troubleshoot problems. One further advantage of using Ficl is that you can find several good tutorials for free on the web, so you save time on documentation and training -- you only need to document extensions to the language. </p><p>Furthermore, people who do not program for a living can do useful work with Ficl. Electrical engineers can easily benchtest new hardware using Ficl, saving you time to add features or fix bugs (not that there would be any). You can use a minimal Ficl system to do rapid prototyping on new hardware and get new features to a demonstrable state in much less time than would be required with a compiled language.</p><h3>Using Ficl</h3><p>In the examples that follow, you may wish to download the Ficlwin executable and play with the language. Ficlwin has some simulated hardware that will be useful later. Ficlwin runs under Windows 95 or NT. </p><p>The first rule of Ficl is to use spaces to separate everything. Forth is simple minded about parsing its input. It looks for space-delimited tokens and tries to interpret them one by one. </p><p>The second rule of Ficl is this: If it's not a word, try to make it a number. If that does not work, it's an error. A word is a named piece of code (like a function or subroutine) that may also own some data. Words are organized into a list called a "dictionary." For each token in the input stream, the interpreter tries to find a word in the dictionary with the same name. If successful, the interpreter will execute the word; otherwise, the interpreter will attempt to convert the token to a number. If the conversion fails, you get an error message. (By the way, the second rule means that you can do evil things such as redefining your favorite number.) </p><p>The third rule of Ficl is that words find their arguments on a stack. The interpreter pushes numbers onto the stack automatically. The language does not have the equivalent of a function prototype, so Forth programmers use comments to show the state of the stack before and after execution of a word. For example: </p><blockquote><p>+ ( a b - - c ) </p></blockquote><p>indicates that the word "+" consumes two values from the stack (<i>a</i> and <i>b</i>) and leaves a third (<i>c</i>, the sum). An open paren followed by a space tells the interpreter to treat everything up to the next close paren as a comment. You can comment to the end of a line with a backslash character followed by a space.</p><p>Here's how to add the two numbers in Forth:</p><blockquote><p>2 3 + . </p></blockquote><p>The interpreter pushes the "2" and the "3," then executes the word "plus" and finally executes the word "dot," which prints <i>5</i>, the top value on the stack.</p><p>There are really two stacks in Forth -- one stores return addresses and the other stores parameters. I'll refer to the parameter stack simply as "the stack" from now on.</p><p>Ficl is not case sensitive. Word names can be up to 255 characters long, but only the first 31 characters will be stored. All words are stored in a linked list.</p><p>The main Ficl data structures are:</p><ul><li>A virtual machine that stores one execution context, and would typically map to a thread.  <li>Two stacks within each virtual machine; one for parameters and the other for return addresses.  <li>A word that binds a name to code, and optionally, data.  <li>The dictionary -- a list of all words of the system.</ul><p>See the accompanying text box entitled "Ficl Syntax (and More)" for more information.</p><h3>Porting Ficl</h3><p>As <A NAME="rl1"><A HREF="9901g.htm#l1">Listing One</A> shows, it only takes a few lines of code to hook Ficl into your system: Initialize the Ficl system-data structures with a call to <i>ficlInitSystem</i>, and create one or more virtual machines using <i>ficlNewVM</i>. After that, you simply feed blocks of text to the virtual machine from an I/O device, a file, or stored strings using <i>ficlExec</i>. You can tear down memory allocated to Ficl with <i>ficlTermSystem</i>.</p><p>Ficl requires an ANSI C compiler and its run-time library to build and execute. Porting to a new CPU involves editing the files sysdep.c and sysdep.h. The header file contains macros that control build properties of Ficl and insulate the implementation from differences among compilers. Ficl interfaces to the operating system via four functions: </p><ul><li><i>FiclMalloc</i> and <i>ficlFree</i> map closely to the standard C <i>malloc</i> and <i>free</i> functions, but they act as a choke point for Ficl memory management in case your operating system has specialized functions for this purpose or you've rolled your own OS.  <li><i>ficlLockDictionary</i> provides exclusive access to the dictionary in multithreaded implementations. If you only intend to make one Ficl Virtual Machine, this function can be empty.   <li><i>ficlTextOut</i> acts like standard C's <i>put</i>s, except that it takes a virtual machine pointer and one additional parameter to indicate whether or not to terminate the string with a newline sequence. </ul><p>Although Ficl is a 32-bit Forth, the language requires some 64-bit math. There are two unsigned primitives in sysdep.c that handle this. One function multiplies two 32-bit values to yield a 64-bit result, and the other divides a 64-bit value by a 32-bit value to return a 32-bit quotient and remainder. These are usually simple to implement as inline assembly for a 32-bit CPU (see the Intel 386 example in the source). I was too lazy to come up with a generic version in C. If you're also lazy, you can kludge these functions to use only the low 32 bits of the 64-bit parameter and be safe -- as long as you avoid multiplying and dividing really big numbers.</p><p>Memory requirements of the code vary by processor. The dictionary is the largest RAM-resident structure. The word-set that comes with the source requires about 1000 cells or 4 KB. Stacks default to 128 cells (512 bytes) each, so you can fit a useful implementation into 8 KB of RAM plus code space (which can be in ROM). </p><p>Use testmain.c as a guide to install the Ficl system and one or more virtual machines into your code. You do not need to include testmain.c in your build. The source package includes a Win32 executable that helps you get a feel for the language.</p><h3>Rolling Your Own Extensions </h3><p>You can extend the language with words, written in C, Forth, or a mixture of C and Forth, that are specific to your application. Use the <i>ficlBuild</i> function to bind a C function to a name in the dictionary. Functions that implement Ficl words take one parameter: a pointer to a FICL_VM. This pointer refers to the running virtual machine in whose context the word executes. The files words.c and testmain.c have (literally) hundreds of examples of words coded in C. <A NAME="rl2"><A HREF="9901g.htm#l2">Listing Two</A> is a function that interfaces ficl to the Win32 <i>chdir</i> service.</p><p>To write a new Ficl word in Forth, follow the examples in softcore.c; embed the source in a string constant and feed the string to <i>ficlExec</i> once you have a virtual machine created.</p><p>You'll also find some examples of words coded in a mixture of C and Forth in words.c (see <i>evaluate</i>, for example). Because <i>ficlExec</i> calls can be nested, you can invoke <i>ficlExec</i> from within a function that implements a word and feed it a string argument, effectively mixing the two languages. </p><h3>An Example</h3><p>Suppose that you have a simple target board that has a block of eight LEDs, eight DIP switches, an 8-bit analog to digital converter, and an 8-bit DAC. (Conveniently, this is what Ficlwin simulates). You start by setting up an address map.</p><p>The first line in <A NAME="re1"><A HREF="9901ge1.htm">Example 1</A> tells Ficl that you're going to be writing numbers in hexadecimal. The next four lines set up named constants for the registers you want to use. When you invoke one of these constants (by typing its name), it pushes its value.</p><p>A constant pushes its value when invoked; and a variable pushes its address when invoked. The Ficl word <i>@</i> (the at sign) fetches the contents of an address and puts the 32-bit value on the stack. <A NAME="re2"><A HREF="9901ge2.htm">Example 2</A> defines words that fetch and store using the address constants defined earlier. Ficl also has <i>c@</i> to fetch a byte, and <i>w@</i> to fetch 16 bits. Likewise,<i> ! w! </i>and <i>c! </i>store a value at an address. The syntax is ( <i>value address --</i> ), meaning that the operations consume a value and an address from the stack. <A HREF="9901ge2.htm">Example 2</A> creates Ficl words that hide the width of the registers they use by wrapping the fetch or store operation. Ficlwin implements the four words in these examples so that you can try the rest of the code verbatim.</p><p>The first line in <A NAME="re3"><A HREF="9901ge3.htm">Example 3</A> creates a variable to track the LED state. (Real hardware engineers often find it too expensive or too bothersome to add a readback capability to digital output registers.) The word on the second line writes the LED register and updates the shadow variable. The last line forces the LEDs off.</p><p>The word in <A NAME="re4"><A HREF="9901ge4.htm">Example 4</A> toggles an LED by index (0..7). LSHIFT is equivalent to C's &lt;&lt; operator.</p><p>Finally, <A NAME="re5"><A HREF="9901ge5.htm">Example 5</A> loops, writing the ADC value back to the DAC until the ADC value reaches 255. After each ADC sample, there is a 100 millisecond pause (msec is implemented in Ficlwin with the Win32 <i>Sleep</i> function). </p><p>Although these are simple examples, they give a feel for the process you use to bring up hardware with Ficl. I invite you to try them with Ficlwin.</p><h4>For More Information<br><br>http://www.taygeta.com/forth.html <br>http://www.taygeta.com/forth/dpans.html<br>http://www.fig.org/fig.html<br>http://www.forth.org/forth_intro/stackflo.htm<br>http://astro.pas.rochester.edu/Forth/forth.html<br>http://www.gis.net/~dmiller/mmsforth.html#BOOKS<br>ftp://ftp.taygeta.com/pub/Forth/Compilers/native/misc/</h4><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</A></H4><pre>FICL_VM *pVM;ficlInitSystem(10000); /* create a 10,000 cell dictionary */pVM = ficlNewVM();<p></p>for (;;){    int ret;    gets(in);    ret = ficlExec(pVM, in);    if (ret == VM_USEREXIT)    {        ficlTermSystem();        break;    }}</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>/* Ficl interface to _chdir (Win32)** Gets a newline (or NULL) delimited string from the input** and feeds it to the Win32 chdir function...** Usage example:**    cd c:\tmp*/static void ficlChDir(FICL_VM *pVM){    FICL_STRING *pFS = (FICL_STRING *)pVM-&gt;pad;    vmGetString(pVM, pFS, '\n');    if (pFS-&gt;count &gt; 0)    {        int err = _chdir(pFS-&gt;text);        if (err)        {            vmTextOut(pVM, "Error: path not found", 1);            vmThrow(pVM, VM_QUIT);        }    }    return;}/* Here's the corresponding ficlBuild call... ** ficlBuild("cd",       ficlChDir,    FW_DEFAULT);*/</pre><P><A HREF="#rl2">Back to Article</A></P><HR><I>Copyright &copy; 1999, Dr. Dobb's Journal</I><BR>
</body></html>