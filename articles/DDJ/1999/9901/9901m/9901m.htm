<html><head><title>Jan99: Java Q&A</title></head><BODY BGCOLOR="#ffffff" TEXT="#000000" LINK="#0000ff" VLINK="#330066" ALINK="#FF0000">
<!--Copyright &#169; Dr. Dobb's Journal--><h1>What's in Store when Moving from JDK 1.1 to JDK 1.2?</h1><p><i>Dr. Dobb's Journal</i> January 1999</p><h3>By Kenneth Hittleman and Ted Leung</h3><I>The authors are software engineers at the IBM Center for Java Technology in Cupertino, California. They can be reached at ken_hittleman@ us.ibm.com and ted_leung@ us.ibm.com, respectively.</I><hr><p>Version 1.2 of the Java Development Kit (JDK) is a major upgrade from JDK 1.1, with changes that could impact developers working on JDK 1.1 applications. In this article, we'll discuss what you need to know when migrating applications from JDK 1.1 to JDK 1.2. The information we present is based on our experiences in porting large Java applications such as SanFrancisco Business Process Components and the VisualAge WebRunner Toolkit technology from JDK 1.1 to JDK 1.2. </p><p>The SanFrancisco Business Process Components comprise a framework containing over 750,000 lines of code and 7500 classes. We ported Version 1.2.0 of the SanFrancisco frameworks from JDK 1.1.2 and Swing 1.0.1 to JDK 1.2 Beta 3. The VisualAge for Java Toolkit is a collection of Java Beans and wizards containing over 500 classes. We ported the VisualAge for Java Toolkit from JDK 1.1.5 to both JDK 1.2 Beta 3 and JDK 1.2 Beta 4.</p><p>In addition to SanFrancisco and VisualAge for Java Toolkit, we also used Sun's Java Certification Kit (JCK) to help find porting problems. The JCK contains thousands of method-level tests for the classes in the JDK. While no test suite can be exhaustive, the JCK provides good coverage of the JDK APIs. We compiled and ran the JCK tests for JDK 1.1.6 using both the JDK 1.2 Beta 3 and JDK 1.2 Beta 4 run times. </p><p>A number of issues surfaced repeatedly during our porting efforts, specifically: </p><ul><li>Inheriting from JDK classes or implementing JDK interfaces was repeatedly a source of migration problems. Some classes and interfaces have new abstract methods which must be provided by a subclasser or implementor, while other new concrete methods introduce signature conflicts with methods of classes that inherit from them. Most errors of this kind (signature clashes and unimplemented methods) will be signaled by the compiler. It is good to be aware that methods were added to some classes.   <li>Use of collection classes can be problematic. The severity of the problem can range from slight changes in the semantics of existing collections to full-scale clashes with the new collection-class functionality.   <li>Improved error checking in JDK 1.2 can cause applications that worked under JDK 1.1 to fail. </ul><h3>Deprecated API</h3><p>As in JDK 1.1, a number of interfaces, classes, and methods have been deprecated in JDK 1.2. A full list of the deprecated API is at http://java.sun.com/products/jdk/1.2/docs/api/deprecated-list.html. Examine this list to see if you are using deprecated APIs.</p><h3>General Subclassing andImplementing Issues</h3><p>JDK 1.2 adds many new methods to existing classes. While at first glance this should not create compatibility issues, signature conflicts may arise in classes that inherit from them if the new methods have similar signatures to the existing methods of the subclass. For example, we found that a specialized class loader that inherits from <i>java.lang.ClassLoader</i> developed a signature conflict with <i>java.lang.ClassLoader.getLocalResource(String)</i>, which was introduced in JDK 1.2 Beta 3 (and removed in JDK 1.2 Beta 4), since java .lang.ClassLoader had already used that method name (with a similar yet incompatible signature) for a slightly different purpose. If you get a signature conflict where none previously existed, a newly inherited method is probably the cause. The easiest remedy is probably to rename your own methods. (Don't forget to also update all the old references to your old method so they don't call the newly inherited method by mistake.) </p><p>Some of the AWT classes (<i>Font</i>, <i>Window</i>, <i>Component</i>, and so on) have new methods with signatures that conflict (different argument types) with methods in SanFrancisco classes which inherit from them. Suppose that, as in <A NAME="rl1"><A HREF="9901m.htm#l1">Listing One</A>, you had a subclass of <i>java.awt.Window</i> with a method that you added called <i>getOwnedWindows</i>. <i>MyWindow</i> will fail to compile under JDK 1.2 because a <i>getOwnedWindows</i> method has been added to <i>java.awt.Window</i>; the signature of the new method is <i>public Window[] getOwnedWindows(),</i> which conflicts with the method that you have already defined.</p><p>Another situation to be aware of is when the two signatures match instead of conflict. When this happens, it is possible that the subclass may silently override the new method it inherited, and the new callers under JDK 1.2 may invoke your subclass's method instead of the intended method from the JDK. This case will not be flagged by the compiler and should be considered when tracking down unexpected results in migrated code. </p><p>This would occur for <A HREF="9901m.htm#l1">Listing One</A> if the subclass of <i>java.awt.Window</i> had added a <i>getOwnedWindows</i> that looked like <A NAME="rl2"><A HREF="9901m.htm#l2">Listing Two</A>. In this situation, the subclassed <i>getOwnedWindows</i> method will be called instead of the superclass's version. This could be especially dangerous if the overridden method was for a <i>set</i> instead of a <i>get</i>.</p><p>Some new abstract methods have been added to existing classes. Since they are abstract, this forces all classes that subclass them to provide implementations for them. Any class that implements an interface that now has a new method (such as <i>java.sql.Connection</i>) will need to be updated to provide an implementation for it.</p><p>For example, the <i>getTypeMap</i> method on interface <i>java.sql.Connection</i> is new in JDK 1.2. Suppose you had the class in <A NAME="rl3"><A HREF="9901m.htm#l3">Listing Three</A>. Since a <i>getTypeMap</i> method has been added to JDK 1.2, you would need to add a <i>getTypeMap</i> method to <i>MyJDBCConnection</i> for your class to compile -- you must implement all of the methods on an interface. The new <i>MyJDBCConnection</i> would look like <A NAME="rl4"><A HREF="9901m.htm#l4">Listing Four</A>. <A NAME="rt1"><A HREF="9901mt1.htm">Table 1</A> lists the JDK 1.1 interfaces with new methods, and <A NAME="rt2"><A HREF="9901mt2.htm">Table 2</A> lists the JDK 1.1 classes that contain new abstract methods.</p><p>The JDK 1.2 <i>java.util.Calendar</i> class has three methods that are abstract in JDK 1.1 -- <i>after</i>, <i>before</i>, and <i>equals</i>. If you used these classes and had to implement these methods, you can probably remove these overrides now as they are likely to be redundant to the newly supplied ones. Leaving the old ones in is not likely to cause problems, but it makes the code and executables slightly larger. You should check to make sure your implementation functions similarly to the new ones, in either case.</p><h3>General Language-Related Issues</h3><p>Casts of <i>char</i> literals to <i>byte</i> or <i>short</i> can no longer be implicit. Fortunately, the compiler is good at pointing out cases of this and forces you to add explicit casts. So <i>byte b = 'c';</i> must become <i>byte b = (byte) 'c';</i>. </p><p>Another interesting discovery (that is probably true for earlier JDKs as well) is that references to final static strings from other classes get compiled directly into each .class file. Consequently, if a final static field of another class changes, all .java files that import that class and reference it must be recompiled to update their copies of the value.</p><p>The <i>String</i> class hashcode algorithm was corrected in JDK 1.2. Any string hashcode values persisted under JDK 1.1 will no longer match new results generated under JDK 1.2. Also the hashcode values returned from <i>File</i> objects have changed in JDK 1.2 Beta 4. These changes are not a problem for serialization in general, as hashcode values are not serialized by default.</p><h3>Collection Class Issues</h3><p>Under 1.2, <i>Vector.indexOf()</i> allows passing null for the target object. JDK 1.1 would throw a <i>NullPointerException</i> for this situation. Situations that previously threw the exception will now perform differently. This can change the behavior of classes that use <i>Vector</i>s, such as the <i>Menu</i> class. So <A NAME="rl5"><A HREF="9901m.htm#l5">Listing Five</A>, which was illegal in JDK 1.1, is legal in JDK 1.2. </p><p>JDK 1.2 introduces new collection classes that have the usual names, including <i>Map</i>, <i>Set</i>, and <i>Iterator</i>. If your code has taken these names, you will have naming conflicts with the new JDK classes. These conflicts will result in compile-time errors if you import all of <i>java.util</i> by writing <i>import java.util.</i>*<i>;</i>. This can also be an issue if your code uses a third-party class library that provides collection-class functionality (such as SanFrancisco). To prevent this conflict, there are a number of alternatives:</p><p>1.	Avoid importing the new collection classes by enumerating each desired class import from <i>java.util</i> rather than by using the wildcard ("*") import. So if you need <i>Vector</i>, write <i>import</i> <i>java.util.Vector;</i> not <i>import</i> <i>java.util.</i>*<i>;</i></p><p>2.	Add specific import statements for the conflicted classes you actually wish to use, in addition to using the wildcard imports. For example, if you use <i>java.util.Vector</i> and <i>com.mycorp.Map</i>, write <i>import java.util; import java.util.Vector; import com.mycorp.Map;</i>, but don't write <i>import java.util.Map;</i>.</p><p>3.	Fully qualify the class for each usage. Suppose you have <i>com.mycorp.Map</i>, and you want to use both <i>java.util.Map</i> and <i>com.mycorp.Map</i>. Write <i>import java.util.Map;</i>, and every time you want to use the name <i>Map</i> and have it mean <i>com.mycorp.Map</i>, write <i>com.mycorp.Map</i> in your program. If you want to be even handed, you can skip importing <i>java.util.Map</i> and do the same thing you do for <i>com.mycorp.Map</i>. </p><p>Which alternative is best depends upon the situation. It may be easiest to use approach #2 with the existing code, since the import statements for <i>Map</i>, <i>Set</i>, and <i>Iterator</i> can be added to all files without bothering to see if they are actually needed for that file. Approach #1 seems to be the cleanest solution, and may lead to faster compiles because unneeded imports are eliminated. Approach #3 is the only solution that allows simultaneous use of both an existing collection class and the JDK 1.2 <i>Collection</i> class of the same name.</p><p>Inheriting from a JDK 1.1 collection class (<i>Hashtable</i>, <i>Vector</i>) as a way of getting an implementation is a good way to incur problems due to the new collection classes. If your code does this, be sure to inspect it and the new collections to make sure that there will be no problems, since the APIs for <i>Hashtable</i> and <i>Vector</i> have changed with the introduction of the new collection classes. </p><p>Suppose, as in <A NAME="rl6"><A HREF="9901m.htm#l6">Listing Six</A>, <i>WidgetManager</i> has subclassed <i>java.util.Vector</i> to support maintaining a list of widgets. Under JDK 1.1, <i>WidgetManager</i> is fine. Under JDK 1.2 it will compile, but the <i>add</i> method silently overrides the new <i>add(Object o)</i> method on <i>Vector</i> that was inherited from <i>java.util.AbstractCollection</i>, and will probably cause <i>Vector</i> to stop behaving like an <i>AbstractCollection</i>.</p><h3>The AWT</h3><p>If a requested <i>Font</i> is unavailable, JDK 1.2 Beta 3 returns (for the font name) the name of the font used instead of the original font requested. This affects the string representation of <i>Font.toString</i>, as well as the other methods that return the names of a font. <A NAME="rl7"><A HREF="9901m.htm#l7">Listing Seven</A> returns <i>BogusFontName</i> under JDK 1.1 and JDK 1.2 Beta 4, but returns "Arial" under JDK 1.2 Beta 3.</p><p>If a requested <i>Font</i> is unavailable, JDK 1.2 Beta 4 returns (for the font family) the name of the font family used instead of the original font name requested. This affects the string representation of <i>Font .toString</i>, as well as the other methods that return the family name of a font. <A NAME="rl8"><A HREF="9901m.htm#l8">Listing Eight</A> returns <i>BogusFontName </i>under JDK 1.1 and JDK 1.2 Beta 3, but returns "Courier New" under JDK 1.2 Beta 4.</p><p>If null is passed for the font name to the <i>Font</i> constructor, JDK 1.2 Beta 4 creates a default font instead of throwing a <i>NullPointerException</i>. For example, the line <i>Font testFont = new Font(null, Font.ITALIC, 9);</i> throws a <i>NullPointerException</i> under JDK 1.1 and JDK 1.2 Beta 3, but returns a default font under JDK 1.2 Beta 4.</p><p>java.awt.peer.ActiveEvent moved up a level in the package hierarchy, to <i>java.awt</i>. This shouldn't affect you, unless you are porting Java Virtual Machines or writing your own GUI toolkits.</p><p>The Swing imports moved from <i>com .sun.java.swing</i> in Swing 1.0.1 (and Swing 1.0.2 as JFC 1.1) to <i>java.awt.swing</i> in JDK 1.2 Beta 3. They then moved back to <i>com.sun.java.swing</i> for JDK 1.2 Beta 4.</p><h3>I/O</h3><p>Some classes in JDK 1.1 did not complain if a null was passed as an <i>OutputStream</i>. JDK 1.2 now throws a <i>NullPointerException</i>. Null can no longer be used as a bit recycler (/dev/null for UNIX) kind of destination. Using null was probably never intended in the first place; this is most likely improved error checking in JDK 1.2. <A NAME="rl9"><A HREF="9901m.htm#l9">Listing Nine</A> runs under JDK 1.1 but throws a <i>NullPointerException</i> under JDK 1.2.</p><p>Improved error checking also results in new and/or different exceptions being thrown for invalid buffer sizes (<i>size&lt; = 0</i>). <A NAME="rl10"><A HREF="9901m.htm#l10">Listing Ten</A> will run under JDK 1.1 and JDK 1.2 Beta 3, but throws <i>IllegalArgumentException</i> under JDK 1.2 Beta 4.</p><p><i>java.io.StringReader.ready</i> can now throw an <i>IOException</i> in JDK 1.2. <A NAME="rl11"><A HREF="9901m.htm#l11">Listing Eleven</A> is legal in 1.1, but becomes <A HREF="9901m.htm#l12">Listing Twelve</A> for 1.2. Changes and/or bug fixes relating to use of the system-dependent default name-separator character ("/" on UNIX and "\" on Win32) result in different return values under JDK 1.2 Beta 4 for some <i>String</i>s that contain paths. On Win32, <A HREF="9901m.htm#l13">Listing Thirteen</A> returns "/" under JDK 1.1 and JDK 1.2 Beta 3, but returns "\" under JDK 1.2 Beta 4. </p><p>The hashcode values returned from File objects have changed in JDK 1.2 Beta 4.</p><p>Serialization has also changed. You should check the JDK 1.2 release notes for full details -- there are no breaking API changes in JDK 1.2 Beta 4, but there is new functionality. In particular, there is a new API for accessing persistent fields -- <i>java.io.ObjectOutputStream.putField</i> and <i>java.io.ObjectInputStream.getField</i>. Furthermore, serialization now uses the new JDK 1.2 security model. </p><h3>Utilities</h3><p><i>java.util.properties.put</i> is stricter in JDK 1.2 and requires both the key and value arguments to be of type <i>String</i>. An <i>IllegalArgumentException</i> is now thrown if an object which is not a <i>String</i> is passed. This is probably just improved error checking in JDK 1.2, and shouldn't cause any migration difficulties. <A NAME="rl14"><A HREF="9901m.htm#l14">Listing Fourteen</A> is allowed in JDK 1.1 but throws an <i>IllegalArgumentException</i> in 1.2.</p><h3>Security</h3><p>Code signed using JDK 1.2 will appear unsigned on JDK 1.1, and vice versa. If you used digital signatures to ensure the authenticity and integrity of code in JDK 1.1, such security measures will be ignored under JDK 1.2, and vice versa.</p><p>In JDK 1.2, security has changed drastically. Some of the JDK 1.1 API is still present but there are major changes. Most of the interfaces in <i>java.security.acl</i> have been superseded, and the interface <i>java.security.acl.Permission</i> has become the abstract class <i>java.security.Permission</i>. The following classes in <i>java.security</i> are deprecated in 1.2: <i>Certificate</i>, <i>Identity</i>, <i>IdentityScope</i>, <i>Signer</i>. The method <i>java.lang.SecurityManager.Check</i> has been added to <i>java.lang.SecurityManager</i>. If your application makes any significant use of the Java security features, you should examine the new security architecture very carefully.</p><h3>Remote Method Invocation (RMI)</h3><p>JDK 1.2 no longer uses the system properties <i>java.rmi.loader.packagePrefix</i> and <i>java.rmi.server.packagePrefix</i> to override the system default value (<i>sun.rmi.server</i>) for the public <i>String</i> data members <i>java.rmi .server.LoaderHandler.packagePrefix</i> and <i>java.rmi.server.RemoteRef.packagePrefix</i>. <i>LoaderHandler</i> uses its package prefix to locate the implementation of the <i>LoaderHandler</i> class and <i>RemoteRef</i> uses its package prefix to find the implementation of server <i>ref</i> classes (<i>UnicastRef</i>, <i>UnicastServerRef</i>, and so on). These changes should only impact implementors of specialized versions of RMI, such as SanFrancisco's Extended RMI (SF ERMI).</p><h3>Tools</h3><p>The Java tools have also changed substantially. A common debugging tactic is to insert specialized versions of JDK classes in a private directory hierarchy, which is then placed at the beginning of the CLASSPATH, so that the specialized classes are found before the regular versions. In JDK 1.2, inserting substitute classes earlier in the CLASSPATH no longer replaces system classes in the rt.jar and i18n.jar files (JDK 1.2 Beta 4) or the classes.zip file (JDK 1.2 Beta 3). You can use the new -<i>Xbootclasspath</i> in JDK 1.2 Beta 4 (<i>-Xsysclasspath</i> option in JDK 1.2 Beta 3), which is similar to -<i>classpath</i> but for the new separate boot/system path. Starting with JDK 1.2, -<i>classpath</i> is used for the application class loader that is now separate from the boot/system class loader.</p><p>There is also a new property in JDK 1.2 that parallels <i>java.class.path</i> but is for the boot/system classes. In JDK 1.2 Beta 4, this property is <i>sun.boot.class.path</i>, and in JDK 1.2 Beta 3, the property is <i>java.sys.class.path</i>. This property is combined with the user-class path (from the CLASSPATH environment variable) and placed in the system property <i>java.class.path</i>. If your program needs to find the bootstrap classes, you should probably use <i>sun.boot.class.path</i>.</p><p>Also, JDK 1.2 appears to use more memory than JDK 1.1. At times, memory needed to be increased when running <i>javadoc</i>, <i>javac</i>, and <i>java</i> on JDK 1.2 for tasks that, on JDK 1.1, succeeded in the default heap allocation.</p><p>We hope this will be unnecessary in the final release of JDK 1.2. The initial and maximum heap allocation sizes can be reset on JDK 1.2 using the -<i>Xms</i> and -<i>Xmx</i> flags (just like the -<i>ms</i> and -<i>mx</i> flags on JDK 1.1). These flags can be passed through <i>javac</i> and <i>javadoc</i> by prepending the -<i>J</i> flag; for example, <i>javac -J-Xmx128m &lt;java file&gt;</i>. Alternatively, the main programs for <i>javadoc</i> and <i>javac</i> can be run directly via a java command with the appropriate -<i>Xmx</i> flag (for example, <i>java -Xmx128m sun.tools.javadoc.Main</i> on JDK 1.2 Beta 3). This becomes more difficult starting with JDK 1.2 Beta 4, because these classes moved from sun.tools in the <i>classes.zip </i>file to <i>com.sun.tools</i> in the new <i>tools.jar</i> file, which must be added to either the <i>classpath</i> or <i>bootclasspath</i> to locate and load them (for instance, <i>java -Xmx128m -classpath</i> <i>.;D:\ jdk1.2beta4\lib\tools.jarcom.sun.tools. javadoc.Main</i>). </p><p>We also found that, although the -<i>ms</i> and -<i>mx</i> flags for JDK 1.1 are no longer listed in the options help list for java on JDK 1.2, they still seem to work. If you are currently using either the -<i>ms</i> or -<i>mx</i> flag, at some point in the future you may be forced to upgrade to the newer -<i>Xms</i> and -<i>Xmx</i> flags.</p><h3>Conclusion</h3><p>Due to the size of the original JDK 1.1 and the subsequent expansion of JDK 1.2, we probably haven't uncovered every porting issue related to moving to JDK 1.2. We do believe that we have found many of the common challenges that you will experience when the time comes to jump to 1.2. You can visit our web site at http://www. ibm.com/java/ for this and other IBM Java related activities.</p><h3>Acknowledgment</h3><p>We would like to thank Chih-Hsiang Chou and Jeff Ryan for their timely and valuable technical help with SF ERMI. We would also like to thank Richard Gillam and Rahul Jain for their helpful comments and review of this article. Finally, we would like to thank Rajiv Jain, Tom Watson, and Kathleen Wilson for their support and guidance.</p><p></p><p><b>DDJ</b></p><H4><A NAME="l1"><A HREF="9901m.htm#l1">Listing One</A></H4><pre>public class MyWindow extends java.awt.Window {    public Vector getOwnedWindows() {        // body of getOwnedWindows    }    // ... rest of MyWindow}</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>public class MyWindow extends java.awt.Window {    public Window[] getOwnedWindows() {        // body of getOwnedWindows    }    // ... rest of MyWindow}</pre><P><A HREF="#rl2">Back to Article</A></P><H4><A NAME="l3">Listing Three</H4><pre>public class MyJDBCConnection implements java.sql.Connection {   // body of class ...}</pre><P><A HREF="#rl3">Back to Article</A></P><H4><A NAME="l4">Listing Four</H4><pre>public class MyJDBCConnection implements java.sql.Connection {    // body of class from above ...    public Map getTypeMap() throws SQLException {        // new code    }}</pre><P><A HREF="#rl4">Back to Article</A></P><H4><A NAME="l5">Listing Five</H4><pre>public integer indexOfNull(Vector v) {    return v.indexOf(null);}</pre><P><A HREF="#rl5">Back to Article</A></P><H4><A NAME="l6">Listing Six</H4><pre>class WidgetManager extends Vector {    public boolean add(Object o) {        // body of add    }    // remainder of WidgetManager}</pre><P><A HREF="#rl6">Back to Article</A></P><H4><A NAME="l7">Listing Seven</H4><pre>public String fontName() {    Font testFont = new Font("BogusFontName", Font.ITALIC, 9);    return (testFont.getName());}</pre><P><A HREF="#rl7">Back to Article</A></P><H4><A NAME="l8">Listing Eight</H4><pre>public String fontName() {    Font testFont = new Font("BogusFontName", Font.ITALIC, 9);    return (testFont.getFamily());}</pre><P><A HREF="#rl8">Back to Article</A></P><H4><A NAME="l9">Listing Nine</H4><pre>Properties p = new Properties();OutputStream out = null;String header = null;p.put("key", "value");p.save(out, header);</pre><P><A HREF="#rl9">Back to Article</A></P><H4><A NAME="l10">Listing Ten</H4><pre>PipedOutputStream pipedStream = new PipedOutputStream(newPipedInputStream());BufferedOutputStream bufferedStream = new BufferedOutputStream(pipedStream,0);</pre><P><A HREF="#rl10">Back to Article</A></P><H4><A NAME="l11">Listing Eleven </H4><pre>public boolean readyTest {StringReader r) {   return  r.ready();}</pre><P><A HREF="#rl11">Back to Article</A></P><H4><A NAME="l12">Listing Twelve</H4><pre>public boolean readyTest(StringReader r) {    try {        return r.ready();    } catch (IOException e) {        System.out.println("StringReader not ready");    }}</pre><P><A HREF="#rl12">Back to Article</A></P><H4><A NAME="l13">Listing Thirteen</H4><pre>public String whatPath() {    File myFile=new File("/");    return (myFile.getPath());}</pre><P><A HREF="#rl13">Back to Article</A></P><H4><A NAME="l14">Listing Fourteen</H4><pre>public void putStuffOnProperties(Properties p) {    p.put("Number",1);}</pre><P><A HREF="#rl14">Back to Article</A></P><HR><I>Copyright &copy; 1999, Dr. Dobb's Journal</I><BR>
</body></html>