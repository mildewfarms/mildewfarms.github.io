<html><head><title>Jan99: Extending JScript</title></head><BODY BGCOLOR="#ffffff" TEXT="#000000" LINK="#0000ff" VLINK="#330066" ALINK="#FF0000">
<!--Copyright &#169; Dr. Dobb's Journal--><h1>Extending JScript</h1><p><i>Dr. Dobb's Journal</i> January 1999</p><h2>Supporting constructors and arrays in JScript</h2><h3>By Paul Butcher</h3><I>Paul is a project manager at Superscape, working on the Viscape Universal browser. He can be reached at pbutcher@superscape.com.</I><hr>Sidebar: <a name="rs1"></a><A HREF="9901ds1.htm">Threading Models and ActiveX Scripting</A><HR><p>Microsoft's ActiveX Scripting specification defines a standard mechanism, based upon COM, that lets scripting engines be embedded within host applications. To implement ActiveX Scripting, Microsoft provides a scaled-down version of Visual Basic called "VBScript," and JScript, an implementation of ECMAScript (previously called "Java-Script"). Both scripting engines are included as part of Internet Explorer or can be installed separately (see http://www.microsoft.com/scripting/).</p><p>In this article, I'll discuss how you can extend JScript's capabilities by adding support for constructors and arrays when embedding JScript. In the process, I'll present a program called "JScriptTest," which displays a user interface that lets users type and execute JScript source. Although JScriptTest is written with the ActiveX Template Library (ATL), the techniques behind it are not ATL specific and apply to hosts written with MFC or any other library that supports COM. For instance, I've successfully used these techniques to implement ECMAScript support within a VRML97 browser. The complete source code and related files for JScriptTest are available electronically; see "Resource Center," page 5.</p><h3>Hosting JScript</h3><p><A NAME="rl1"><A HREF="9901d.htm#l1">Listing One</A> is the declaration of class <i>CScriptEngine</i>, which JScriptTest uses to encapsulate an instance of either VBScript or JScript. </p><p>JScriptTest communicates with the script via global variables and functions exposed within the namespace of the script. All these variables and functions are members of a single <i>Automation</i> object of the class <i>CGlobals</i>. An instance of <i>CGlobals</i> is passed to <i>CScriptEngine::AddGlobals</i>, which, in turn, calls <i>IActiveScript::Add-NamedItem</i> with the argument SCRIPTITEM_GLOBALMEMBERS.</p><p>One of <i>CGlobals</i>' member functions is <i>messageBox</i> (which calls the Win32 MessageBox API). This allows </p><blockquote><p>var x = 42;</p><p>messageBox(x);</p></blockquote><p>to display the message "42." (I'll use <i>messageBox</i> throughout this article to show that code is working as expected.)</p><h3>Constructors</h3><p>Scripts written in JScript perform tasks by interacting with <i>Automation</i> objects provided by the host application. Such objects export methods via <i>IDispatch</i> or <i>IDispatchEx</i> and are called by the script. Objects may be created by the host and provided to the script (the <i>CGlobals</i> object is an example), or they may be created dynamically by the script itself.</p><p>JScript provides the <i>ActiveXObject</i> constructor for dynamically creating ActiveX objects. This can be used as in <i>var x = new ActiveXObject("ServerName.ObjectType");</i>. This approach has some limitations that may make it unacceptable in certain cases. First, there is no way to provide additional arguments to the <i>ActiveXObject</i> constructor, meaning that objects may have to be initialized in a separate step. Next, using this constructor makes it clear that objects created in this way are not normal JScript objects. Finally, it may be necessary to support a particular syntax; the VRML97 specification (http:// www.vrml.org/Specifications/VRML97/), for example, requires that scripts be able to create instances of the <i>SFRotation</i> type as in: <i>var r = new SFRotation(0, 1, 0, 0);</i>. If you wanted to implement the <i>SFRotation</i> type via an ActiveX object, you would not be able to use the <i>ActiveXObject</i> constructor.</p><p>To illustrate support for constructors, I've added support for complex numbers to JScript. This lets <i>var c = new Complex(3, 5);</i> create an instance of the complex number <i>3+5i</i>. Calling the <i>Complex</i> constructor with no arguments creates a complex number initialized to zero. Complex numbers support two properties:<i> r</i> (which represents the real part) and <i>i</i> (which represents the imaginary part). They support three methods: <i>add</i>, <i>multiply</i>, and <i>toString</i>. <A NAME="re1"><A HREF="9901de1.htm">Example 1</A>, for instance, displays the answer 4+6<i>i</i>. <A NAME="rl2"><A HREF="9901d.htm#l2">Listing Two</A> is an IDL fragment describing the <i>Complex</i> class.</p><p>To support constructors, you'll need to support the <i>IDispatchEx</i> interface, which adds eight functions to <i>IDispatch</i> -- <i>DeleteMemberByDispID</i>, <i>DeleteMemberByName</i>, <i>GetDispID</i>, <i>GetMemberName</i>, <i>GetMemberProperties</i>, <i>GetNameSpaceParent</i>, <i>GetNextDispID</i>, and <i>InvokeEx</i>. As the names of these functions suggest, <i>IDispatchEx</i> adds a great deal of functionality to <i>IDispatch</i>, allowing methods to be added to or removed from an <i>Automation</i> interface at run time. I'll only scratch the surface of the features provided by <i>IDispatchEx</i>, since all that we're interested in is the DISPATCH_CONSTRUCT flag supported by <i>InvokeEx</i>.</p><p>Before JScript can call my implementation of <i>IDispatchEx</i>, it needs to obtain a pointer to it. I achieve this by adding a read-only property called <i>Complex</i> of type <i>IDispatch</i>* to the <i>CGlobals</i> object. When JScript comes across the code fragment <i>new Complex()</i>, it queries the <i>CGlobals</i> object for the value of its <i>Complex</i> property. It then calls <i>QueryInterface</i> on that pointer to retrieve a pointer to its <i>IDispatchEx</i> interface. Finally, it calls the <i>InvokeEx</i> function with a dispatch ID of DISPID_VALUE and the DISPATCH_CONSTRUCT flag.</p><p>JScriptTest uses an instance of class <i>CJScriptTypeConstructor</i> to implement constructor properties. Instances of this class maintain a pointer to an instance-creation function in the member variable <i>m_pfnCreateObject</i>, allowing the same class to be used to construct multiple types. In the case of <i>Complex</i>, the instance-creation function used is <i>CComplex::Create</i>, which creates instances of the <i>CComplex</i> class. All of <i>CJScriptTypeConstructor</i>'s member functions apart from <i>InvokeEx</i> simply return E_NOTIMPL or S_OK as appropriate. <A NAME="rl3"><A HREF="9901d.htm#l3">Listing Three</A> is the implementation of <i>InvokeEx</i>. The first few lines of <i>InvokeEx</i> check its arguments. If they are okay, it passes a pointer to the parameters passed to the constructor in JScript to the instance-creation function; see <A NAME="re2"><A HREF="9901de2.htm">Example 2</A>.</p><p><A NAME="rl4"><A HREF="9901d.htm#l4">Listing Four</A> presents the implementation of <i>CComplex::Create</i>. First, it creates an instance of <i>CComplex</i> and then it examines the DISPPARAMS* passed from JScript. If there are no arguments, it initializes the <i>m_r</i> and <i>m_i</i> members of the new object to zero. If there are two arguments, it attempts to convert them into numbers (with <i>VariantChangeType</i>) and uses them to initialize <i>m_r</i> and <i>m_i</i>.</p><p>The implementations of the other members of <i>CComplex</i> are straightforward, with one exception. Because <i>CComplex</i> communicates with JScript via <i>Automation</i>, only types compatible with <i>Automation</i> can be used as function parameters. This means that <i>CComplex</i> functions that take instances of <i>CComplex</i> as arguments are actually passed an <i>IDispatch*</i>. Somehow, given an <i>IDispatch*</i>, you need to get hold of a <i>CComplex*</i>. </p><p>This is done using the function <i>DispatchToComplex</i> (see <A NAME="rl5"><A HREF="9901d.htm#l5">Listing Five</A>). Given an <i>IDispatch*</i>, this function first calls <i>QueryInterface</i> to see if it supports <i>IComplex</i>. If it does not, then it cannot be an instance of <i>CComplex</i> and the function fails. If the call to <i>QueryInterface</i> succeeds, the function uses <i>static_cast</i> to cast the <i>IComplex*</i> to a <i>CComplex*</i>. You cannot immediately use <i>static_cast</i> as the pointer may not have originated within your address space. This approach takes considerable liberties with the COM specification. In this particular case, you know it will work because the JScript engine is an in-process server that supports the "Both" threading model and, therefore, that interface pointers are simply raw C++ vtbl pointers. This technique is not guaranteed to work in the general case, however.</p><p>If you feel uneasy about taking such liberties, an alternative approach would be to have one <i>CComplex</i> object access another's state via its <i>IComplex</i> interface. While this is fine for a simple example, it may result in inefficiencies (because inline functions cannot be used). It may also require that you expose more functionality to external clients than you would otherwise. The latter objection may be addressed by supporting a second back door interface (<i>IComplexInternal</i>, perhaps) that is made available only to your own code.</p><h3>Arrays</h3><p>At first glance, it appears that arrays in JScript are similar to those provided by other languages. When you look deeper, however, you quickly discover that they are strange beasts. Although it is customary to think of objects and arrays as being distinct types in JScript, they are actually identical -- objects can be treated as arrays and vice versa.</p><p>Objects in JScript are a collection of properties indexed by names. These properties can be of any type, including functions (methods are actually properties of functional type). Properties may be accessed in one of two different styles. <A NAME="re3"><A HREF="9901de3.htm">Example 3</A>(a), for instance, assigns the value 25 to the property indexed by the string <i>salary </i>of the <i>person</i> object. Arrays are objects that have properties whose names are numbers. Names are always strings, so it is a string representation of the array index that is used. <A HREF="9901de3.htm">Example 3</A>(b), for example, writes the string <i>Fred </i>to the third element of the <i>forenames</i> array. If an expression that evaluates to a number (1+1, for instance) is placed inside the square brackets, it is first evaluated, then automatically converted into a string.</p><p>Arrays support a special property, <i>length</i>, the value of which is one greater than the largest array index in use. As <A NAME="re4"><A HREF="9901de4.htm">Example 4</A> illustrates, <i>length</i> is automatically adjusted as the array grows, or can be explicitly assigned to. Assigning to <i>length </i>grows or truncates the array as appropriate. </p><p>JScriptTest adds support for three-dimensional vectors to JScript. The <i>Vector</i> constructor (implemented via the same method that we used for <i>Complex</i>) creates an array of three elements. These objects support three methods: <i>add</i>, <i>cross</i> (which calculates the vector cross product), and <i>toString</i>. <A NAME="re5"><A HREF="9901de5.htm">Example 5</A>(a), for instance, prints the answer 0, 0, 1, while <A HREF="9901de5.htm">Example 5</A>(b) prints the answer 0.2, 0, 0.3.</p><p><A NAME="rl6"><A HREF="9901d.htm#l6">Listing Six</A> is an IDL fragment describing the <i>Vector</i> class. There is nothing in this fragment that addresses array access. In general, it is not possible to describe JScript array support in IDL, as we would have to provide one property per array element. Although in the specific case of this <i>Vector</i> type, you know that there are only three array elements and you could potentially implement this as three properties. But for other arrays, this will not necessarily be the case. JScriptTest makes use of the class <i>CDispatchWithArrayAccess</i> to provide support for JScript arrays. It defines two pure virtual functions <i>ArrayPut</i> and <i>ArrayGet</i>, which will be called whenever an element of the array is written or read, respectively. Any class that provides support for arrays should derive from this class and provide implementations of these two functions.</p><p><i>CDispatchWithArrayAccess</i> derives from ATL's <i>IDispatchImpl</i> class, and overrides both <i>GetIDsOfNames</i> and <i>Invoke</i>. Whenever JScript attempts to resolve a name it calls <i>GetIDsOfNames</i>. This initially delegates the call to the base class. If the base class cannot resolve the name (it is not declared in the IDL file), it is not the special-case <i>length </i>property and a few basic sanity checks are passed, <A NAME="re6"><A HREF="9901de6.htm">Example 6</A> is executed. This code examines the name to see whether all its characters are digits. If they are, then we convert the name into an integer with <i>_wtoi</i> and return a dispatch ID of this number plus the constant, DISPID_ARRAY. DISPID_ARRAY is a large number chosen to be larger than any of the dispatch IDs defined in the IDL file.</p><p>When JScript calls <i>Invoke</i>, the function examines the dispatch ID to see if it is greater than or equal to DISPID_ARRAY. If it is, then the call to <i>Invoke</i> represents an array access. You can calculate the array index by subtracting DISPID_ARRAY from the given dispatch ID, and then call either <i>ArrayPut</i> or <i>ArrayGet</i> as appropriate; see <A NAME="re7"><A HREF="9901de7.htm">Example 7</A>.</p><h3>Conclusion</h3><p>The techniques I've described here let host applications implement a more natural interface to JScript than straightforward JScript embedding would provide. It allows experienced JScript programmers to treat objects implemented by the host as though they were native JScript objects.</p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</A></H4><pre>class CScriptEngine :    public CComObjectRootEx&lt;CComMultiThreadModelNoCS&gt;,    public IActiveScriptSite{    public:        CScriptEngine();        virtual ~CScriptEngine();        enum EngineType { EngineType_JScript, EngineType_VBScript };        HRESULT Create(EngineType type);        HRESULT Close();        HRESULT ParseScript(const OLECHAR* pszScriptText);        HRESULT AddGlobals(IDispatch* pDispatch);        ...};</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>[    object,    uuid(FCC9CDD3-EFFF-11d1-A9F0-00A0244AC403),    dual]interface IComplex : IDispatch{    [propget, id(1)] HRESULT r([out, retval] double* pVal);    [propput, id(1)] HRESULT r([in] double Val);    [propget, id(2)] HRESULT i([out, retval] double* pVal);    [propput, id(2)] HRESULT i([in] double Val);    [id(3)] HRESULT add([in] IDispatch* pArg,                                 [out, retval] IDispatch** pRetVal);    [id(4)] HRESULT multiply([in] IDispatch* pArg,                                 [out, retval] IDispatch** pRetVal);    [id(5)] HRESULT toString([out, retval] BSTR* pRetVal);};</pre><P><A HREF="#rl2">Back to Article</A></P><H4><A NAME="l3">Listing Three</H4><pre>HRESULT STDMETHODCALLTYPECJScriptTypeConstructor::InvokeEx(/* [in] */ DISPID id,                           /* [in] */ LCID /*lcid*/,                           /* [in] */ WORD wFlags,                           /* [in] */ DISPPARAMS* pdp,                           /* [out] */ VARIANT * pvarRes,                           /* [out] */ EXCEPINFO * /*pei*/,                           /* [unique][in] */ IServiceProvider* /*pspCaller*/){    // We only know how to handle DISPID_VALUE    if(id != DISPID_VALUE)    {        _ASSERT(false);        return DISP_E_MEMBERNOTFOUND;    }    // This had better be a call to a constructor!    if(!(wFlags &amp; DISPATCH_CONSTRUCT))    {        _ASSERT(false);        return DISP_E_MEMBERNOTFOUND;    }    // We don't know how to handle named arguments    if(pdp-&gt;cNamedArgs != 0)    {        _ASSERT(false);        return DISP_E_NONAMEDARGS;    }    // Construct an object and return its IDispatch pointer    IDispatch* pdisp;    HRESULT hr = m_pfnCreateObject(pdp, &amp;pdisp);    if(SUCCEEDED(hr))    {        pvarRes-&gt;vt = VT_DISPATCH;        pvarRes-&gt;pdispVal = pdisp;    }    return hr;}</pre><P><A HREF="#rl3">Back to Article</A></P><H4><A NAME="l4">Listing Four</H4><pre>HRESULTCComplex::Create(DISPPARAMS* pdp, IDispatch** ppdisp){    // Create the object    CComObject&lt;CComplex&gt;* pNewObject = new CComObject&lt;CComplex&gt;;<p></p>    if(pdp-&gt;cArgs == 0)    {        // No arguments - initialize to default (zero)        pNewObject-&gt;m_r = pNewObject-&gt;m_i = 0.0;    }    else if(pdp-&gt;cArgs == 2)    {        // Two arguments - first argument is r, second is i (remember that        // the DISPPARAMS::rgvarg array contains arguments in reverse order)        VARIANTARG vaTemp;        VariantInit(&amp;vaTemp);<p></p>        HRESULT hr = VariantChangeType(&amp;vaTemp, &amp;(pdp-&gt;rgvarg[0]), 0, VT_R8);        if(!SUCCEEDED(hr))        {            return hr;        }        pNewObject-&gt;m_i = vaTemp.dblVal;<p></p>        hr = VariantChangeType(&amp;vaTemp, &amp;(pdp-&gt;rgvarg[1]), 0, VT_R8);        if(!SUCCEEDED(hr))        {            return hr;        }        pNewObject-&gt;m_r = vaTemp.dblVal;    }    else    {        // Number of arguments must be 0 or 2        return DISP_E_BADPARAMCOUNT;    }    pNewObject-&gt;AddRef();    *ppdisp = pNewObject;    return S_OK;}</pre><P><A HREF="#rl4">Back to Article</A></P><H4><A NAME="l5">Listing Five</H4><pre>HRESULTCComplex::DispatchToComplex(IDispatch* pdisp,CComObject&lt;CComplex&gt;** ppComplex){  // Given an IDispatch*, convert it (if possible) to a CComObject&lt;CComplex&gt;*  IComplex* pinterface;  if(FAILED(pdisp-&gt;QueryInterface(IID_IComplex,        reinterpret_cast&lt;void**&gt;(&amp;pinterface))))  {        return DISP_E_TYPEMISMATCH;  }  *ppComplex = static_cast&lt;CComObject&lt;CComplex&gt;*&gt;(pinterface);  pinterface-&gt;Release(); return S_OK;}</pre><P><A HREF="#rl5">Back to Article</A></P><H4><A NAME="l6">Listing Six</H4><pre>    [        object,        uuid(FCC9CDD4-EFFF-11d1-A9F0-00A0244AC403),        dual    ]    interface IVector : IDispatch    {        [id(1)] HRESULT add([in] IDispatch* pArg,                                   [out, retval] IDispatch** pRetVal);        [id(2)] HRESULT cross([in] IDispatch* pArg,                                  [out, retval] IDispatch** pRetVal);        [id(3)] HRESULT toString([out, retval] BSTR* pRetVal);    };</pre><P><A HREF="#rl6">Back to Article</A></P><p><b>DDJ</b></p><HR><I>Copyright &copy; 1999, Dr. Dobb's Journal</I><BR>
</body></html>