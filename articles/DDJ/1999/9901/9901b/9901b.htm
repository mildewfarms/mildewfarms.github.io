<html><head><title>Jan99: Little Languages with Lex, Yacc, and MFC</title></head><BODY BGCOLOR="#ffffff" TEXT="#000000" LINK="#0000ff" VLINK="#330066" ALINK="#FF0000">
<!--Copyright &#169; Dr. Dobb's Journal--><h1>Little Languages with Lex, Yacc, and MFC</h1><p><i>Dr. Dobb's Journal</i> January 1999</p><h2>Slide provides an IDEfor little languages</h2><h3>By Jason Shankel</h3><I>Jason is a programmer at Maxis, where he develops simulators and simulation languages. He can be contacted at jshankel@maxis.com.</I><hr><p>Whether designed to perform complex mathematical calculations, control specialized equipment, or specify text layout in web-based documents, little languages offer users a great deal of power while sparing nonprogrammers from the complexity of general-purpose languages. In this article, I will describe how to use lex, yacc, and MFC to create integrated Win32 development environments for little languages. More specifically, I'll develop a multidocument-interface application called "Slide" (short for "Small Language Integrated Development Environment") and integrate it with lex and yacc. The source code and related files for Slide, bison, and flex are available electronically (see "Resource Center," page 5). </p><h3>Overview of Lex and Yacc</h3><p>Lex and yacc are two of the most powerful utilities in a language designer's toolbox. Lex generates lexical analyzers (lexers) that split streams of symbols into substrings (tokens). Yacc generates grammar parsers that analyze streams of tokens and assemble the tokens into grammatical structures. The two utilities go hand-in-hand, letting you quickly develop code for converting symbol streams into grammatical structures.</p><p>Both lex and yacc translate script files into C source-code modules. The C code implements the lexer and the parser. The entry point for the yacc-generated parser is a function called <i>yyparse()</i>, which relies on <i>yylex()</i>, an external function generated by lex.</p><p>There are a number of implementations of lex and yacc available for PCs. In this article, I use BSD's flex Version 2.5.4 for lex and GNU's bison Version 1.25 for yacc. For more information on lex and yacc, see "Lex and Yacc," by Ian E. Gorman (<i>DDJ</i>, February 1996).</p><h3>Overview of MFC</h3><p>MFC is Microsoft's C++ foundation class library and application framework for Windows. The main value of MFC for projects such as this is not its structure or ease of use as a library, but its connection to Visual C++'s automated code generators -- AppWizard and ClassWizard. </p><p>AppWizard generates skeletal Windows applications. Users can customize, among other things, window style, OLE support, control styles, file extensions, Internet capabilities, and help-file support. After AppWizard creates an application, ClassWizard can be used to extend it. Users can create new window classes and add functionality to existing classes with a simple visual interface. The combination of MFC, wizards, and visual resource editors makes Visual C++ a useful tool for rapid application development without preventing serious applications from exploiting the full power of C++ and Win32.  </p><h3>Setting up the MFC Application</h3><p>To set up a multidocument text-editing application using MFC's AppWizard, first create a new MFC AppWizard project called Slide. Make Slide a multiple document application and accept the default settings for all the other options. When you build the application and run it, you should see a multiple document interface application with a single blank document, toolbar, menu, and status bar.</p><p>Getting the Slide application ready for flex and bison involves changing Slide's project settings to accommodate C source code and redefining Slide's document and view types to support text editing. By default, AppWizard projects expect all compilation units to use precompiled headers through stdafx.h. Unfortunately, the C code generated by flex and bison cannot accept stdafx.h, so you need to change the Slide's precompiled header settings.</p><p>To change the precompiled header settings, go to the project settings dialog, select the C/C++ tab, and set precompiled headers to "Automatic use of precompiled headers." This setting prevents Visual C++ from searching for stdafx.h in each compilation unit.</p><p>Next, modify Slide's document and view classes to support text editing. The document and view classes generated by AppWizard inherit directly from the generic <i>CDocument</i> and <i>CView</i> classes. They need to be modified to inherit from <i>CRichEditDoc</i> and <i>CRichEditView</i>, respectively.</p><p>Add <i>#include&lt;afxrich.h&gt;</i> to the top of SlideView.h and SlideDoc.h, and replace all occurrences of <i>CDocument</i> in SlideDoc.h and SlideDoc.cpp with <i>CRichEditDoc</i>, and all occurrences of <i>CView</i> in SlideView.h and SlideView.cpp with <i>CRich- EditView</i>.</p><p><i>CRichEditDoc</i> has one pure virtual function, <i>CreateClientItem(_reobject *)</i>, which <i>CSlideDoc</i> must define. <i>CreateClientItem(_reobject *)</i> is used for creating additional rich text edit controls. Because Slide only needs the default rich text edit control, you can give this function a trivial implementation. Add <A NAME="re1"><A HREF="9901be1.htm">Example 1</A> to <i>CSlideDoc</i> in SlideDoc.h.</p><p>By default, <i>CRichEditDoc</i> saves and loads text files via <i>Serialize</i>, which is precisely the functionality Slide needs. Change <i>CSlideDoc</i>'s <i>Serialize</i> function so it calls <i>CRichEditDoc</i>'s implementation (see <A NAME="re2"><A HREF="9901be2.htm">Example 2</A>).</p><p>When you recompile and run, the Slide1 view should be a text edit window, complete with select, cut, and paste capabilities. The Cut and Paste toolbar and menu items should be fully functional and File Load and Save should be working. You now have a multiple-document text editor. The next step is to format Slide's text for the compiler. </p><p>The first thing you need to do here is add a Compile item to Slide's menu and to use ClassWizard to add <i>OnCompile()</i> to <i>CSlideView</i>. <i>OnCompile()</i> will be called by MFC whenever the Compile item is selected from the menu.</p><p>Select the resource tab in the project view and open the IDR_SLIDETYPE menu for editing. Add a Build submenu between the View and Window submenus and add a Compile menu item with IDM_COMPILE as its ID to the Build menu. Now, open the ClassWizard, select the Message Maps tab, make sure <i>CSlideView</i> is in the class name dropdown, select IDM_COMPILE in the object ID's listbox, and double-click on the COMMAND selection to add <i>OnCompile()</i> to <i>CSlideView</i>. ClassWizard should have added <i>OnCompile()</i> to <i>CSlideView</i> at the bottom of SlideView.cpp. </p><p>Now that <i>OnCompile()</i> is defined, <i>CSlideView</i> needs to stream <i>CRichEditCtrl</i>'s text into a <i>CString</i> to get it ready for the compiler. Right above <i>CSlideView::OnCompile()</i>, add the callback function in <A NAME="rl1"><A HREF="9901b.htm#l1">Listing One</A>. The rich edit control will use this callback function to stream out its text. The parameters of the callback are:</p><ul><li><i>dwCookie</i>, a user-supplied value which <i>OnCompile()</i> will use to hand the callback a pointer to a <i>CString</i>.   <li><i>pbBuff</i>, a pointer to the text to be streamed.   <li><i>cb</i>, the size of <i>pbBuff</i>.   <li><i>pcb</i>, a return value indicating how many bytes were actually copied. </ul><p></p><p>As you can see, the callback simply tacks each character in <i>pbBuff</i> onto the end of the string pointer passed in <i>dwCookie</i> and returns <i>cb</i> in <i>pcb</i>.</p><p>To stream <i>CSlideView</i>'s text into a <i>CString</i>, add <A NAME="re3"><A HREF="9901be3.htm">Example 3</A> to the body of <i>OnCompile()</i>. If everything goes well, you should be able to set a breakpoint at the end of <i>OnCompile()</i>, type some text into Slide1, select Compile, examine <i>compileString</i> in a watch window, and see the text you typed contained in <i>compileString</i>. </p><p>Slide now has everything it needs to send a text stream to a yacc-generated grammar parser.</p><h3>Setting Up Flex and Bison</h3><p>Flex and bison use script files to generate C modules. For the purposes of this article, I will implement a rudimentary parser that recognizes an arbitrarily long sequence of comma-delimited strings, where a string is any letter followed by any number of letters or digits.</p><p>The first step is to put the appropriate flex and bison utility files into Slide's project directory. These are FLEX.EXE, FLEX  .SKL, BISON.EXE, BISON.SIMPLE, and BISON.HAI. BISON.SIMPLE is usually called BISON.SIM thanks to the 8.3 filename legacy, so you may need to rename it.</p><p>The next step is to add the script files for the parser and the lexer to the project. The parser's file is called SLPARS.Y (<A NAME="rl2"><A HREF="9901b.htm#l2">Listing Two</A>), and the lexer's is SLLEX.L (<A NAME="rl3"><A HREF="9901b.htm#l3">Listing Three</A>).</p><p>The idea is to add SLLEX.L and SLPARS.Y to the Slide project and to use the Custom Build feature to tell Visual C++ how to build these files. The build rules for SLLEX.L and SLPARS.Y generate C code files that must also be compiled and linked into the project. Therefore, it is important to make sure that you set up the dependencies and output files in the custom build settings to guarantee that SLLEX.L and SLPARS.Y are processed before their corresponding C files. </p><p>Add SLLEX.L and SLPARS.Y to the Slide project and open the settings for SLLEX.L. Add FLEX SLLEX.L to the Build command(s) listbox.</p><p>Next, add LEXYY.C to Output file(s) and SLPARS.Y to Dependencies. This informs Visual C++ that SLLEX.L generates LEXYY.C and that SLLEX.L must be rebuilt if SLPARS.Y is modified. Now select SLPARS.Y's settings and add the build command BISON SLPARS.Y<i> -d</i>. Add SLPARS_T.C and SLPARS_T.H to the Output file(s) listbox.</p><p>When you build, flex and bison should generate three new files in Slide's project directory: LEXYY.C, SLPARS_T.C, and SLPARS_T.H. LEXYY.C is generated by flex and implements the lexer. Bison generates SLPARS_T.C and SLPARS_T.H. SLPARS_T.C implements the grammar parser and SLPARS_T.H exports the symbols defined by the parser for use by the lexer. The <sub></sub>d parameter in the bison build rule instructs bison to generate SLPARS_T.H. Add LEXYY.C, SLPARS_T.C and SLPARS_T.H to the Slide project. </p><h3>Redirecting Lex's Input</h3><p>Once both the MFC text editor and grammar parser are working in the application, the next step is to feed the text from the text editor window to the parser code.</p><p>The key to interfacing yacc with MFC is redirecting <i>yylex()</i>'s input stream. By default, <i>yylex()</i> expects the input stream to be <i>yin</i>, which is a FILE *. If <i>yin</i> is 0, then <i>yylex()</i> takes input from <i>stdin</i>. </p><p>Neither of these options is ideal for the Win32 world. You could dump <i>CSlideView</i>'s text into a temporary FILE * and hand this to <i>yylex()</i>, but ideally, <i>yylex()</i> should read its symbols from the <i>CString</i> that <i>OnCompile()</i> generates.</p><p>Different flavors of lex have different protocols for redirecting the input stream. Flex lets users redirect input by redefining the YY_INPUT macro in the script file. YY_INPUT has the form: <i>YY_INPUT (buffer, result, max_size)</i>, where <i>buffer</i> is the pointer to be filled in, <i>max_size</i> is the storage capacity for buffer, and <i>result</i> gets the number of bytes actually read.</p><p>In this case, SLLEX.L redefines YY_INPUT as follows: <i>#define YY_INPUT(buf,result,max_size) (result = SlideYYInput (buf,max_size))</i>, where <i>SlideYYInput(char *,int)</i> is defined in the C source-code section of SLLEX.L. It copies data from a static <i>char *, SlideInputStream</i>, into the buffer provided by lex (see <A HREF="9901b.htm#l3">Listing Three</A>). <i>SlideCompile(char *)</i> (also in <A HREF="9901b.htm#l3">Listing Three</A>) is Slide's compiler entry point. It takes a <i>char *</i> input stream and assigns it to <i>SlideInputStream</i>, calls <i>yyrestart(0)</i> to reset lex's state machine, and calls <i>yyparse()</i> to run the grammar parser. </p><h3>Final Details</h3><p>Finally, lex and yacc require you to define the functions <i>yyerror(char *)</i> and <i>yywrap()</i>. <i>yyerror(char *)</i> gets called when the parser encounters an illegal token sequence. The <i>char *</i> parameter is a string describing the error and it is almost always "parse error."</p><p>For my purposes here, <i>yyerror(char *)</i> calls <i>SlideMessage(char *)</i> (see <A NAME="re4"><A HREF="9901be4.htm">Example 4</A>), which pops a message box. It is important to declare <i>SlideMessage extern "C"</i> because it is called from the C code generated by flex and bison.</p><p><i>yywrap()</i> gets called when lex runs out of input, giving users the opportunity to continue tokenizing with a new stream. In Slide's case, <i>yywrap()</i> should just return 1, indicating that the input stream has terminated.</p><h3>Putting it all Together</h3><p>The pieces are all in place. Now all that's left to do is declare the compiler entry point in SlideView.cpp and call <i>SlideCompile(char *) from OnCompile()</i>. <A NAME="rl4"><A HREF="9901b.htm#l4">Listing Four</A> shows the final form of <i>OnCompile()</i>. That's all. Slide is now ready to go.</p><h3>Testing Slide</h3><p>The language implemented in SLLEX.L and SLPARS.Y is extremely simple. It recognizes an arbitrarily long sequence of comma-delimited strings. When it recognizes such a list it displays "StringList Found" in a message box. If it encounters anything else, it displays an error message. </p><p>You'll notice that sometimes you get both messages. For example, the sequence <i>little,languages,are,cool ddj</i> generates a "StringList Found" message followed by a parse error message. This happens because the first four words of the sentence are properly comma delimited. Those words form a proper sentence, which the grammar parser recognizes. The trailing "ddj" is not grammatically correct, so it generates an error.</p><h3>Parting Thoughts</h3><p>As consumer software becomes increasingly content-driven, the desire on the part of nonprogrammers to control application behavior and appearance will increase. One of the most striking examples of this phenomenon in recent years is HTML.</p><p>Providing content managers with special-purpose languages for modifying applications can not only save development time, but can also help clarify product designs by formalizing a vocabulary and grammar for describing product features.</p><p>In this article, I have described how to use MFC, flex, and bison to create an integrated text editor and compiler. But there is more to an integrated development environment than just text editing and compiling. Error reporting, debugging, and multifile project management are typical features of modern development environments. MFC makes extending Slide to support these features relatively easy.</p><h3>Further Reading </h3><p>Aho, Alfred V., Ravi Sethi, and Jeffrey D. Ullman. <i>Compilers: Principles, Techniques, and Tools</i>. Addison-Wesley, 1985.</p><p>Kaplan, Randy M. <i>Constructing Language Processors for Little Languages</i>. John Wiley &amp; Sons, 1994.</p><p>Levine, John R., Tony Mason, and Doug Brown. <i>lex &amp;yacc</i>. O'Reilly &amp; Associates, 1992.</p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</A></H4><pre>/* This callback is used by CSlideView's rich text edit control to stream textinto a CString dwCookie - pointer to a CStringpbBuff - pointer to textcb - size of pbBuffpcb - gets number of bytes copied*/static DWORD CALLBACK SlideViewEditStreamCallBack( DWORD dwCookie, LPBYTE pbBuff, LONG cb, LONG *pcb){ CString *compileString = reinterpret_cast&lt;CString *&gt;(dwCookie); for (int i=0;i&lt;cb;i++)  (*compileString) += static_cast&lt;char&gt;(pbBuff[i]); *pcb = cb; return 0;}<p></p></pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two </H4><pre>%{/* This bison file implements the grammar rules for recognizing a sequence of comma-delimited strings*/void SlideMessage(char *message);void yyerror(char *);int yylex(void);%}<p></p>%token TOKEN%%<p></p>start: /*empty*/ | little_list {SlideMessage("Stringlist Found");};little_list : TOKEN  | little_list ',' TOKEN ;%%<p></p></pre><P><A HREF="#rl2">Back to Article</A></P><H4><A NAME="l3">Listing Three </H4><pre>%{/* This flex file implements the rules for tokenizing strings */#include "slpars_t.h"#include &lt;stdlib.h&gt;#include &lt;string.h&gt;<p></p>/* Redefine input source (see article) */int SlideYYInput(char *buf,int max_size);#undef YY_INPUT#define YY_INPUT(buf,result,max_size) \ (result = SlideYYInput(buf,max_size))%}%%[A-z][A-z0-9]* { return TOKEN;};[ \t\n] {/*ignore whitespace*/}; . {return yytext[0];};%%void SlideMessage(char *message);int yyparse();static char *SlideInputStream;<p></p>/* yywrap and yyerror are required by flex and bison */void yyerror(char *err){ SlideMessage(err);}int yywrap(){ return 1;}/* YY_INPUT redirects lex to get its input from this function.  It just copies data from a local static char * assigned in SlideCompile.*/int SlideYYInput(char *buf,int max_size){ int n = min(max_size,(int)strlen(SlideInputStream)); if (n &gt; 0) {  memcpy(buf,SlideInputStream,n);  SlideInputStream += n; } return n;}/* SlideCompile runs the compiler. Called from OnCompile in CSlideView */void SlideCompile(char *inputStream){ SlideInputStream = inputStream; yyrestart(0); yyparse();}<p></p></pre><P><A HREF="#rl3">Back to Article</A></P><H4><A NAME="l4">Listing Four</H4><pre>/* OnCompile streams text from the rich edit control into a local CString and sends the CString to SlideCompile for processing by lex and yacc*/extern "C" void SlideCompile(char *inputStream);void CSlideView::OnCompile() { CString compileString = ""; EDITSTREAM es =   {reinterpret_cast&lt;DWORD&gt;(&amp;compileString), 0, SlideViewEditStreamCallBack}; GetRichEditCtrl().StreamOut(SF_TEXT, es);   if (es.dwError == 0) {  SlideCompile(const_cast&lt;char *&gt;(LPCTSTR(compileString))); }}</pre><P><A HREF="#rl4">Back to Article</A></P><HR><I>Copyright &copy; 1999, Dr. Dobb's Journal</I><BR>
</body></html>