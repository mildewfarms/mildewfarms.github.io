<html><head><title>Jan99: Online versus Offline Algorithms</title></head><BODY BGCOLOR="#ffffff" TEXT="#000000" LINK="#0000ff" VLINK="#330066" ALINK="#FF0000">
<!--Copyright &#169; Dr. Dobb's Journal--><h1>Online versus Offline Algorithms</h1><p><i>Dr. Dobb's Journal</i> January 1999 </p><HR><p>Clearly, an offline program, which knows the entire sequence of requests in advance, can always perform better than an online algorithm, which must anticipate any possible future event. To see how much better, assume there is an adversary: A person making requests of your algorithm who knows the operation of the algorithm and is deliberately trying to make it perform as poorly as possible.</p><p>To evaluate memory allocation, we'll measure the total amount of system memory required to satisfy a sequence of allocations. For an online algorithm, the adversary might ask for <i>n </i>objects of size 1. Since the adversary knows how the allocator does this, he knows which of those <i>n</i> objects have the highest and lowest addresses. He can then free the remaining objects, leaving a hole of size <i>k</i> (which is at least as big as <i>n</i>). The adversary can then ask for a <i>k</i>+1-byte object. This object can't be placed between the two 1-byte objects, so the total memory required for this sequence of requests is at least 2<i>k</i>+3 bytes.</p><p>An offline algorithm, however, knows which two 1-byte objects will remain, so it can allocate them at addresses 0 and 1, and then allocate the <i>k</i>+1-byte object just above them. Thus the offline algorithm requires <i>k</i>+3 bytes of memory, which is one-half of the online algorithm's requirements.</p><p>--S.G. and I.H.</p><a href="9901n.htm#rs1">Back to Article</a><HR><I>Copyright &copy; 1999, Dr. Dobb's Journal</I><BR>
</body></html>