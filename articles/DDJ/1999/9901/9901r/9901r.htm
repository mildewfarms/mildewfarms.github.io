<html><head><title>Jan99: Letters</title></head><BODY BGCOLOR="#ffffff" TEXT="#000000" LINK="#0000ff" VLINK="#330066" ALINK="#FF0000">
<!--Copyright &#169; Dr. Dobb's Journal--><h1>Letters</h1><hr><h3>WinCE's CeRapiInvoke API</h3><p>Dear <i>DDJ</i>,</p><p>In his article "The Windows CE 2.0 Remote API" (<i>DDJ</i>, September 1998), Andrew Tucker explored some of the possibilities offered by the <i>CeRapiInvoke</i> API. Unfortunately, there are some major flaws with the stream mode implementation of <i>CeRapiInvoke</i> that Andrew did not mention.</p><p>It states that <i>CeRapiInvoke</i> in stream mode returns an <i>IRAPIStream*</i> that lets you perform asynchronous communications with the Windows CE device. The problem, however, is that this stream seems to be the <i>same</i> stream used by the Remote API (RAPI) for other RAPI function calls. (For example, <i>CeRapiInvoke</i> in stream mode appears to simply hook into the underlying communications channel used by the remainder of the RAPI).</p><p>This means that no RAPI function may be called as long as your application maintains a reference to the <i>IRAPIStream</i> object. Any RAPI functions that are called while the stream object exists simply block.</p><p>If you create a thread, which listens to the stream, as is done in Andrew's sample program, things gets even more interesting. Apparently, RAPI calls are encoded as some type of request and transmitted to the Windows CE device across the stream. Thus, the thread that reads from the stream will intercept any such requests. The RAPI function will of course block as it waits for an answer to its request.</p><p>We haven't performed exhaustive testing to see if every RAPI function will block after invoking <i>CeRapiInvoke</i> in stream mode (and before releasing the stream) but, in testing a number of RAPI functions (such as <i>CeGetVersionEx</i>, <i>CeFindAllDatabases</i>, and <i>CeRegOpenKeyEx</i>) we have yet to find one that completes successfully.</p><p>We're providing (available electronically; see "Resource Center," page 5) a modified version of the stream mode sample program which Andrew wrote. We modified it to support bidirectional communication in a chat style. Further, a menu has been added which allows you to trigger various RAPI functions. The communication does not have to be bi-directional for the problems mentioned earlier to be apparent.</p><p>We tested Visual C++ 5.0 with both the H/PC and P/PC toolkits running under NT 4.0 SP3 using Windows CE Services 2.1. We connected with an Ericsson MC16 and a Philips Velo 500 using direct cable connection, network connection via LAN and network dial-up connection.</p><p>Based on these observations (and Andrew's comments about the Set/GetRapiStat methods), we are forced to conclude that the stream mode of<i> CeRapiInvoke</i>, while interesting, is a somewhat less than versatile tool. While useful in a severely limited way, it would be more accurate to describe this little nugget of the API (and its accompanying documentation) as horribly broken!  </p><p>Roger McFarlane at rogerm@cst.ca<br>Costa Siourbas at costas@cst.ca</p><h3>Year 2000 Fix</h3><p>Dear <i>DDJ</i>,</p><p>I was surprised when I read your "News &amp; Views" about the year 2000 correction (<i>DDJ</i>, October 1998). I have used the simple solution described there since 1992 in projects for 8-bit microcontrollers (like MC68HC05), especially when I need days calculations. In this simple solution, you can calculate the days passing from one event to another, with a simple converter function. I would never think about this solution as a patent pending since there is no new technology, nor a new date structure for calculations.</p><p>Nassie Evyatar <br>eznasi@inter.net.il</p><p>Dear <i>DDJ</i>,</p><p>I just read of the Y2K software patent filed for by Wesley Stout in the October 1998 "News &amp; Views." This only serves as yet another reminder of how bad the software patent problem is becoming. Many publications, including <i>DDJ</i>, have published articles on the Y2K problem and possible solutions. Many of these articles have given the solution Mr. Stout is trying to patent; some ignorant patent clerk and judge will probably grant it as well. It brings to mind the infamous XOR patent that put Commodore out of business, or the patent on storing more than one type of data on a storage media. Patents like this only hurt the software industry and stifle further growth. Excuse me now, but I have to run out and get a patent on using contractions for the days of the week; anyone using "MON" for "MONDAY" will have to pay me a royalty.</p><p>Joseph Fenton<br>jlfenton@ctaz.com </p><p>Dear <i>DDJ</i>,</p><p>Has anybody discussed or acknowledged the "hidden" Y2K date issues with Microsoft software from a developers standpoint?</p><p>What I am referring to (in Visual Basic terms) is the use of "Long Date" and "Short Date" formats, and the fact that in Windows 95/98/NT you can change your Long and Short date formats to be set to formats not in the drop-down box, that may or may not display correctly, or be interpreted correctly by application programs.</p><p>For example, go to the Control Panel-Regional Settings, and set the date formats </p><p>Short Date: M/d/y</p><p>Long Date: M/d/yy</p><p>The Short Date format is accepted by Win95, but NT will display it as M/d/yy -- until you do something like try formatting a date with that "Short Date" format, in which case you get a strange year. Also, if the user changes the Long Date format to a two-digit year, and the program somewhere formats the date to "Long Date" then stores it, totally new problems can be created for the application.</p><p>If you really want to raise some eyebrows, try this in VB5 or above: Create a form, with txt1...txt8 (labels) with label1...label8 (labels) and a command button with <A NAME="rl1"><A HREF="9901r.htm#l1">Listing One</A>. Use the button to refresh the screen, and then goto control panel regional settings, date, and play with the date formats.</p><p>Justin Gale<br>jgale@omc-online.com </p><h3>DebugAPI</h3><p>Dear <i>DDJ</i>,</p><p>I enjoyed Fritz Lowrey's article "Examining the Win32 Debug API" (<i>DDJ</i>, November 1998). I have been programming NT Services for some time now and can attest to the utility of the Debug API and <i>OutputDebugString</i> in particular. I have found the class in <A NAME="rl2"><A HREF="9901r.htm#l2">Listing Two</A> to be useful under MSVC5.0 and 6.0. It wraps the <i>OutputDebugString</i> function in a class that permits stream operations.</p><p>The conditional compilation flags allow the machinery to be removed for a release build; but, as Fritz points out, that is not really necessary. With more ambition, and time, you can create a <i>streambuf</i> and then an <i>ostream</i> that does the same thing more elegantly and safely. If the debug output is to be left in the final build, I strongly recommend that one do just that; or, at the very least, handle the failure modes of the simple class presented here.</p><p>The class (see <A NAME="rl3"><A HREF="9901r.htm#l3">Listing Three</A> for DbgPrint.h) is designed to handle only character strings and will not properly handle wide character strings. This was chosen since debug output usually contains text typed in by the programmer, and it rapidly becomes tiresome to type L ''blah, blah, blah" rather than just "blah, blah, blah."</p><p>Robert Stafford<br>stafford@bindview.com</p><h3>Template-Driven Web Pages</h3><p>Dear <i>DDJ</i>,</p><p>The article "Template-Driven Web Pages," by Jay Johansen (<i>DDJ</i>, November 1997) described a CGI solution to allow visitors to update web pages. He covered a few different methods of security including disallowing "bad" HTML. However, the method described does not provide the security desired.</p><p>The problem with most early attempts at CGI security when passing untrusted input to shells was that they removed "bad" characters, however, some little used characters were overlooked, or environment variables not checked breaching the security.</p><p>Removing "bad" input is not safe enough, the moral of the CGI story is to only allow "good" input, since it is harder to include a bad input in your good list than to overlook some little known bad input. </p><p>The method Jay used was described in the article as "simply disallow all markup tags from user input by removing all '&lt;' and '&gt;' characters and everything in between."</p><p>HTML containing "&amp;<i>{location.replace('http://evil.replica.com')};</i>" will cause Netscape 3.0 and later with Javascript enabled to go to replace the current page with the specified URL in the window and in the history, so the back button will go to the page before the original page. This could be used to make a replica of your web site with sensitive information modified. A less sophisticated attack could use &amp;<i>{while(true)alert('')}</i>; which will lock up the browser.</p><p>The problem is that Javascript doesn't need to be within &lt;SCRIPT&gt; tags in Netscape 3.0 it can be in a special Javascript HTML entity.</p><p>The only way to be truly secure is to encode the supplied text using the standard encode method provided by most CGI libraries, this will encode all the characters special to HTML including &lt;,&gt;, and &amp;. Encoding the text after removing the tags would be the simplest modification required.</p><p>Sam Holden<br>sholden@cs.su.oz.au</p><h3>DDA and Fast Image Scaling</h3><p>Dear <i>DDJ</i>,</p><p>I'm writing in response to an article "A 2D DDA Algorithm for Fast Image Scaling" by Dean Clark (<i>DDJ</i>, April 1997). It appears that the algorithm Dean describes can be optimized <i>and</i> simplified even further.</p><p>The gist of the algorithm to scale a <i>N</i>0&times;<i>M</i>0 image to a new <i>N</i>1&times;<i>M</i>1 pixel grid is described in <A NAME="re1"><A HREF="9901re1.htm">Example 1</A> of the article: </p><p>For clarity, the example described the algorithm in 1D; scale is the ratio of the number of output pixels to that of the original pixels (along X or Y dimension), that is, <i>N</i>1/<i>N</i>0. The algorithm as presented involves some floating-point computations. As Dean writes, "To get rid of the floating-point numbers, simply scale up the differential. Let's use a scaling constant 1000 an cast the differential to an <i>int</i> using <i>Dx = (int)(1.0/scale*1000);</i> There is no real magic to 1000..."</p><p>Well, there is magic: note, that scale is <i>N</i>1/<i>N</i>0, that is, the differential is <i>N</i>0/<i>N</i>1. Thus <i>N</i>1 (rather than 1000) is the natural (and the best) scaling factor. It frees the algorithm from any floating-point computations whatsoever; see <A NAME="re2"><A HREF="9901re2.htm">Example 2</A>.</p><p>Note that all computations in this algorithm are integer from the outset. There are not a single multiplication/division, either. The accumulated differential can never become greater than twice the number of original pixels, <i>N</i>0. Thus we are guaranteed to never run into overflow or other nasty thing. The internal <i>while</i> loop would run at most 2*scale times (that is, <i>floor(</i>2*<i>N</i>0<i>/N</i>1<i>)</i>: unless the image is being shrunk more than twice, the loop would never go through more than two iterations). The algorithm appears more in Bresenham's spirit. As a spot validation test, it's easy to see that if <i>N</i>0=<i>N</i>1, the algorithm copies pixels; if <i>N</i>0=2*<i>N</i>1, the algorithm skips every other original pixel, and if <i>N</i>1=2*<i>N</i>0, it duplicates the pixels.</p><p>The 1D algorithm presented earlier can be generalized to 2D as the article describes in detail.</p><p>Oleg Kiselyov<br>oleg@pobox.com</p><p><i>Dean responds:</i> Yes, the scale factor is <i>N</i>1/<i>N</i>0, where <i>N</i>0 is the original image dimension, and <i>N</i>1 is the scaled dimension. However, don't forget that the algorithm doesn't know what <i>N</i>1 is, only what <i>N</i>0 (and <i>M</i>0) is. We would have to calculate <i>N</i>1, to wit: <i>N1 = (int)(N0 </i>* <i>scale)</i>, which is still a floating-point expression. So either way there's one FP in the code.</p><p>Also, although your idea of using the number of original pixels (did you mean the number of scaled pixels? You said "<i>N</i>1" in the paragraph) would likely be acceptable in many cases, there's a potential for excessive resampling errors if the the multiplication factor (my 1000 magic number) is too small. Scaling up the differential and truncating it to an integer saves a bunch of FP additions and compares, but also throws away some precision. Don't know for sure what the minimum factor is but intuitively it seems that it would be <i>max(M</i>1<i>,N</i>1<i>)</i>. My experience over the last 8+ years is that 1000 works fine, but calculating <i>N</i>1 is probably more correct.</p><p>As far as your color interpolation idea, the algorithm from the article can be used to do interpolated image scaling since the differentials (as floats this time) are the interpolation factors (for linear interpolation, that is). What's much more interesting is, how can you arrange your color table so that, in general, two pixels that are separated by some span contain colors that are separated by some predetermined constant? Seems to me that's the hard part! Of course I'm assuming it's not just an "intensity" image, where the display value maps one-to-one with the color palette entry. Thanks.</p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</A></H4><pre>Private Sub Command1_Click()Dim Test_Date As DateDim Test_Text As String    Test_Date =3D Now    Label1.Caption =3D Format(Date, "Long Date")    Test_Text =3D Format(Date, "Short Date")    Test_Date =3D CDate(Test_Text)    Label2.Caption =3D Format(Date, "Short Date")    Label3.Caption =3D Date    Label4.Caption =3D Format(Now, "Long Date")    Label5.Caption =3D Format(Now, "Short Date")    Label6.Caption =3D Now    Label7.Caption =3D Format(Test_Date, "M/d/yyyy")    Label8.Caption =3D DateDiff("m", "10/08/1998", Test_Date)End SubPrivate Sub Form_Load()    txt1 =3D "Format(Date,Long Date)"    txt2 =3D "Format(Date,Short Date)"    txt3 =3D "Date"    txt4 =3D "Format(Now,Long Date)"    txt5 =3D "Format(Now,Short Date)"    txt6 =3D "Now"    txt7 =3D "Variable set Long Date-yyyy format"    txt8 =3D "DateDiff(m,10/08/1998," &amp; Test_Date &amp; ")"    Command1_ClickEnd Sub</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>int threadMain(){ DbgPrint dbg;    ... dbg &lt;&lt; "Thread[" &lt;&lt; std::setw(4) &lt;&lt; ::GetCurrentThreadId() &lt;&lt; "] Starting.";    ...}</pre><P><A HREF="#rl2">Back to Article</A></P><H4><A NAME="l3">Listing Three</H4><pre>#ifndef DBGPRINT#define DBGPRINT// A simple class to wrap calls to OutputDebugString(). It can be used// like a stream--it understands how to format anything you can pass to// cout. The dtor flushes the accumulated string. If you wish to put// several messages using the same object, the flush() member function// will output the accumulated string and start again with an empty// one. The clear() member function will discard any pending string.<p></p>#if defined(_DEBUG) || defined(DEBUG)<p></p>#ifndef _WINDOWS_#include &lt;windows.h&gt;#endif<p></p>#include &lt;iostream&gt;#include &lt;sstream&gt;#include &lt;iomanip&gt;<p></p>class DbgPrint{        // Don't allow these        DbgPrint(const DbgPrint &amp;rhs);        DbgPrint&amp; operator=(const DbgPrint &amp;rhs);        std::ostringstream* myStream;        void out()        {                std::string s = myStream-&gt;str();                OutputDebugStringA(s.c_str());        }public:        DbgPrint() {myStream = new std::ostringstream;}<p></p>        void clear() {delete myStream;myStream = new std::ostringstream;}        void flush()        {                out();                clear();        }        template&lt;class I&gt;        DbgPrint&amp; operator &lt;&lt; (const I&amp; i)       {                (*myStream) &lt;&lt; i;                return *this;        }        ~DbgPrint()        {                out();                delete myStream;        }};#elseclass DbgPrint{        DbgPrint(const DbgPrint &amp;rhs);        DbgPrint&amp; operator=(const DbgPrint &amp;rhs);        void out() {}public:        DbgPrint() {}        void clear() {}        void flush() {}        template&lt;class I&gt;        DbgPrint&amp; operator &lt;&lt; (const I&amp;) {return *this;}        ~DbgPrint() {}};#endif#endif</pre><P><A HREF="#rl3">Back to Article</A></P><HR><I>Copyright &copy; 1999, Dr. Dobb's Journal</I><BR>
</body></html>