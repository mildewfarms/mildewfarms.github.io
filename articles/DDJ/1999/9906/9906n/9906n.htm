<html><head><title>Jun99: Algorithm Alley</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Efficiently Sorting Linked Lists</h1><h3>By Bill McDaniel</h3><I>Bill is a professor of computing science at the University of Central Oklahoma. He can be reached at mcdaniel@aix1 .ucok.edu.</I><hr><p>I've become a big fan of the merge sort recently, ever since someone pointed out that it never degenerates into an O(<i>N</i><sup>2</sup>) algorithm as quicksort does. This month, Bill McDaniel shows how to speed up the merge sort even more by keeping already-sorted sections together.</p><p>As a bonus, Bill's algorithm is also a good place to demonstrate Igor Kolpakov's technique for simplifying linked-list operations. Igor recently wrote me to explain the technique, which I describe in the accompanying text box "Simplifying Linked Lists."</p><p>If you have a favorite trick you'd like to share with other <i>DDJ</i> readers, write me at kientzle@ddj.com.</p><p> -- Tim Kientzle</p><hr><a name="rs1"><a href="9906ns1.htm">Simplifying Linked Lists</a><hr><p>Many sorting algorithms require you to go through a fixed set of operations, even if the input data is already mostly sorted. I wanted to develop an algorithm for sorting, using linked lists, that capitalizes on already ordered subsequences. In particular, a list that's nearly ordered should sort very quickly.</p><p>I also wanted a routine that would work well even when the data was in the worst possible order. Quicksort has been used for years, and has been considered to be the best overall sort for randomly distributed data. However, quicksort is slow -- approaching O(<i>N</i><sup>2</sup>) -- when the data is ordered (either forward or backward). In addition, the algorithm is defined and implemented recursively, which results in more overhead and, hence, slower run times.</p><p>My starting point for the development of this algorithm was the merge sort, described in many algorithm books. My algorithm is similar to Donald Knuth's "list merge sort," except that Knuth uses an extra bit to mark the ends of sublists, whereas I look for patterns in the data itself to identify sublists.</p><h3>Sorting by Sections</h3><p>Many lists to be sorted already have sections that are in the correct order. Suppose you took a list with <i>R</i> sorted sections and split it into separate sorted lists, as in <A NAME="rf1"><A HREF="9906nf1.htm">Figure 1</A>.</p><p>The basic idea behind my algorithm is to merge successive pairs of lists. Each such merge requires O(<i>N</i>) time, since it requires examining every item. Each merge pass halves the number of lists so you make a total of <i>log</i><sub>2</sub>(<i>R</i>) passes. Note that <i>R</i>, the number of sorted sublists, is always less than <i>N</i>, so the total time is never more than O(<i>N log N</i>). And, if the original list was mostly sorted, <i>R</i> will be very small and the algorithm will complete quickly.</p><h3>The McDaniel Sort</h3><p>Instead of having <i>R</i> lists, my algorithm (which I refer to as the "McDaniel Sort") uses just two output lists. As <A NAME="rf2"><A HREF="9906nf2.htm">Figure 2</A> shows, the first one holds the even sections, the second holds the odd sections.</p><p>With this arrangement, I only need four lists -- two input lists (<A NAME="rf2"><A HREF="9906nf2.htm">Figure 2</A>) and two output lists (<A NAME="rf3"><A HREF="9906nf3.htm">Figure 3</A>). During each pass, I merge sections from the input lists and alternate the resulting sorted sections in the output lists. <A NAME="rf3"><A HREF="9906nf3.htm">Figure 3</A> shows how I merge L0 and L1 to make L01, merge L2 and L3 to make L23, and so on.</p><p>The tricky part is knowing where one group (L0 and L1) ends and the next group (L2 and L3) begins. This can be determined by comparing the first elements in both input lists to the last element sent (to either output list). If the first elements in both input lists are less than the item just output, this indicates the start of a new group.</p><h3>Detailed Algorithm</h3><p>The loop at the bottom of <A NAME="re1"><A HREF="9906ne1.htm">Example 1</A> is the essential part of my algorithm. In each iteration of this loop, you can choose the first element from either input list and place that element at the end of either output list. Remember that you want to construct long sorted sequences. If only one of the candidates is larger than the last item output, then that's the only one that can continue the current sorted sequence. If both candidates are larger, then choosing the smaller of the two will let you construct a longer sequence. If both candidates are smaller, then you have to start a new sequence, so choosing the smaller will let that new sequence be as long as possible.</p><p>Of course, since you want to alternate sorted sequences between the two output lists, whenever you start a new sequence, you switch output lists.</p><p><A NAME="rl1"><A HREF="#l1">Listing One</A> presents the complete algorithm. The central loop involves comparing new candidate elements to the last element output. This requires that you initialize the first output list with the first element from one of the input lists. The second output list is initially set to empty.</p><p>The outermost <i>do</i>/<i>while</i> loop retrieves items from the two input lists and sends them to the output lists. The code inside this loop constitutes one pass. When the loop is finished, the second output list is checked. If the second output list (<i>out[1]</i>) is empty, then all of the items were routed to the first output list and the items are all sorted. If the second output list is not empty, then another pass is required.</p><p>The code to select an item from the correct input list is fairly complex because you have to determine the relative order of the last item output and the first item in each input list. Whenever you select an input item smaller than the last output item, you have to switch output lists.</p><p>The algorithm is surprisingly fast. The best case behavior occurs with a list whose items are already sorted. The sort will be finished after one pass. The worst case is when the items are in reverse order. For a list of <i>N</i> items, it will take <i>log</i><sub>2</sub>(<i>N</i>) complete passes to sort the items, making the order of this algorithm <i>N</i>log<sub>2</sub>(<i>N</i>).</p><h3>The Sample Program</h3><p>I've implemented the code in C for clarity. This code illustrates several programming ideas, one of which involves passing the address of the comparison routine as a parameter. This lets the code sort a linked list of virtually any structure, as long as the first field of the structure is a pointer to the next item.</p><p>To use the <i>Sort</i> function, you must first write a compare routine (<i>comp</i>) that references any user-defined fields of the structure. This function contains a "less_than" test, that returns True (1) if the item pointed to by the first parameter is less than the item pointed to by the second parameter; otherwise, it returns False (0). The parameters to <i>comp</i> are void pointers simply because <i>comp</i> is not yet written. The function <i>LT_comp</i> in <A NAME="rl2"><A HREF="#l2">Listing Two</A> is a good example. <A NAME="rl2"><A HREF="#l2">Listing Two</A> is a sample program that sorts a text file. </p><p>This sort works well for random data, data that has sorted subsequences, and data that has a lot of duplicate keys. It can be used in a variety of different situations, and -- unlike quicksort -- does not involve recursion.</p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>typedef struct GenericNode GenericNode;struct GenericNode { GenericNode *next; };void Sort(void ** pList, int (*comp) (void *, void *)){  int outindex;                 /* current output list (0 or 1) */  GenericNode *p;               /* Scratch variable */  GenericNode *in[2], *out[2];  /* Input/Output lists */  GenericNode **outTail[2];     /* Track last items in output lists */  GenericNode *lastOut;         /* Last node output */  if(!*pList) return;           /* Empty list is already sorted */  out[0] = *pList;              /* point out[0] to the list to be sorted */  out[1] = 0;  do {    in[0] = out[0];             /* Move output lists to input lists */    in[1] = out[1];    if (!in[1]) {        /* Only one list? Grab first item from other list */      p = in[0]; if(p) in[0] = in[0]-&gt;next;    } else {             /* There are two lists, get the smaller item */      int smallList = comp(in[0],in[1])  ? 0 : 1;      p = in[smallList]; if(p) in[smallList] = in[smallList]-&gt;next;    }    /* Initialize out[0] to first item, clear out[1] */    out[0] = p; outTail[0] = &amp;(p-&gt;next); lastOut=out[0];    p-&gt;next = (GenericNode *)0;    outindex = 0;    out[1] = (GenericNode *)0; outTail[1] = &amp;(out[1]);    while (in[0] || in[1]) {        /* while either list is not empty */      if (!in[1]) {                 /* Second list empty, choose first */        p = in[0]; if(p) in[0] = in[0]-&gt;next;        if(comp(p,lastOut))         /* p &lt; lastOut */          outindex = 1-outindex;    /* switch lists */      } else if (!in[0]) {          /* First list empty, choose second */        p = in[1]; in[1] = in[1]-&gt;next;        if(comp(p,lastOut))         /* p &lt; lastOut */          outindex = 1-outindex;    /* switch lists */      } else if (comp(in[0],lastOut)) { /* in[0] &lt; lastOut */        if(!comp(in[1],lastOut)) {  /* lastOut &lt;= in[1] */          p = in[1]; in[1] = in[1]-&gt;next;        } else {                    /* in[1] &lt; lastOut */          if(comp(in[0],in[1])) {   /* in[0] &lt; in[1] */            p = in[0]; in[0] = in[0]-&gt;next;          } else {            p = in[1]; in[1] = in[1]-&gt;next;          }          outindex = 1-outindex;    /* Switch lists */        }      } else {                     /* lastOut &lt;= in[0] */        if(comp(in[1],lastOut)) {  /* in[1] &lt; lastOut */          p = in[0]; in[0] = in[0]-&gt;next;        } else {                   /* lastOut &lt;= in[1] */          if(comp(in[0],in[1])) {  /* in[0] &lt; in[1] */            p = in[0]; in[0] = in[0]-&gt;next;          } else {            p = in[1]; in[1] = in[1]-&gt;next;          }        }      }      *outTail[outindex] = p;      outTail[outindex] = &amp;(p-&gt;next);      p-&gt;next = (GenericNode *)0;      lastOut = p;    }  } while (out[1]);  *pList = out[0];}</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>/* llsort.c. Sort 1 or more lines of text. * Usage: llsort &lt;infile&gt; &lt;outfile&gt; &lt;optional sort column&gt; * Sort column - defaults to 1. */#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#define maxLength 1000    /* n is the maximum length of an input line *//* If you're sorting on the first column, sortPointer will point to first  * character of 'info'. Otherwise, it will point further into the string. */typedef struct MyNode {  struct MyNode *next;  char *sortPointer;                    /* Pointer to string to be sorted */  char info[1];                         /* String data */} MyNode;int LT_comp(void *a, void *b) {  char *p=((MyNode*)a)-&gt;sortPointer;  char *q=((MyNode*)b)-&gt;sortPointer;  return (strcmp(p,q) &lt; 0);            /* True if a&lt;b */}int main (int argc,char **argv){  FILE *infile, *outfile;  MyNode *p, *list, **pTail;  long int sort_column = 0;  char st[maxLength], infn[256], outfn[256];  if (argc &lt; 2) {    printf("Usage: %s infile outfile [number] \n",argv[0]);    exit(1);  }   /* pick off the file names */  strcpy( infn, argv[1]);  strcpy(outfn, argv[2]);  /* pick off the starting sort column (if it exists) */  sort_column = 0;  if (argc == 4 ) sort_column = atol(argv[3])-1;  /* open the files */  infile = fopen(infn,"r");  if (!infile) {    printf("File %s could not be found.\n",infn);    exit(1);  }  outfile = fopen(outfn,"w");  if (!outfile) {    printf("Output file %s could not be opened.\n",outfn);    exit(1);  }  /* initialize the list */  list = 0; pTail = &amp;list;  /* read the input file and build the linked list */  while (fgets(st,maxLength,infile))      /* get one line */  {    /* fetch a node that is just the right size */    p = malloc(sizeof(MyNode)+strlen(st)+1);    if(!p) {      fprintf(stderr,"Out of memory!");      return 1;     }    /* copy the string into the info portion of the node */    strcpy(p-&gt;info,st);    /* sortPointer points to the part of the string being sorted */    if (strlen(p-&gt;info) &lt; sort_column) {      p-&gt;sortPointer = "";          /* Too short, treat as empty string */    } else {      p-&gt;sortPointer = p-&gt;info + sort_column;    }    /* insert the node onto the tail end of the list */    *pTail = p; pTail = &amp;(p-&gt;next);  }  *pTail = 0; /* Terminate list with null */  fclose(infile);  printf("Sorting: %s by column %ld\n",infn, sort_column+1);  Sort((void**)&amp;list, LT_comp);  /* Send the sorted data to the output file. */  p = list;  while(p) {    fputs(p-&gt;info,outfile);    p = p-&gt;next;  }  fclose(outfile);  return 0;}</pre><P><A HREF="#rl2">Back to Article</A></P><H4><A NAME="l3">Listing Three</H4><pre>/* Igor Kolpakov's "reverse pointer" trick */typedef struct _ITEM ITEM;struct _ITEM {   int key;   ITEM * next;};ITEM *listHead;AddItem(ITEM *newItem) {  /* Keep a 'reverse pointer' to the pointer to this item */  ITEM ** rpItem = &amp;listHead;  ITEM * item = listHead;  while(item &amp;&amp; (key &gt; item-&gt;key)) {    rpItem = &amp;item-&gt;next;    item = item-&gt;next;  }  /* Note: No extra tests!! */  *rpItem = newItem;  newItem-&gt;next = item;}DeleteItem(int key) {  ITEM ** rpItem = &amp;listHead;  ITEM * item = listHead;  while(item &amp;&amp; (key &gt; item-&gt;key)) {    rpItem = &amp;item-&gt;next;    item = item-&gt;next;  }  if(item &amp;&amp; (key == item-&gt;key)) {    /* Note: No extra tests!! */    *rpItem = item-&gt;next;    free( item );  }}</pre><P><A HREF="#rl3">Back to Article</A></P><HR><I>Copyright &copy; 1999, Dr. Dobb's Journal</I><BR>
</body></html>