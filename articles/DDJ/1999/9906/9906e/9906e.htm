<html><head><title>Jun99: A DNA Sequence Class in Perl</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>A DNA Sequence Class in Perl</h1><h2>Using Perl's object- oriented and text-manipulation features </h2><h3>By Lincoln Stein</h3><I>Lincoln develops databases, applications, and user interfaces for the Human Genome Project at Cold Spring Harbor Laboratory in Long Island, NY. His books on web software development include The Official Guide to CGI.pm (John Wiley &amp; Sons, 1998) and Writing Apache Modules in Perl and C (O'Reilly &amp; Associates, 1999).</I><hr><p>The Human Genome Project is a multinational project to determine the entire human DNA sequence by the year 2003. Obtaining this information means pushing around massive amounts of information -- estimates quickly run into the terabytes. This in turn requires sophisticated software engineering, fault-tolerant information systems, and rapid application development.</p><p>In this article, I describe a Perl library for manipulating DNA and RNA sequences. In the course of examining this library, you'll see how Perl's object-oriented features work together to create an elegant API. And hopefully, you'll learn a little biology as well.</p><h3>DNA, RNA, and Proteins</h3><p>The stuff of the genome is deoxyribonucleic acid (DNA), a long thin molecule that is usually compactly coiled into the chromosomes of our cells. DNA consists of four distinct subunits, called "nucleotide bases," which are repeated across its entire length. The four bases have been assigned the convenient single-letter names A, G, C, T -- abbreviations for their longer chemical names.</p><p>In DNA, the nucleotide bases are linked together into long chains that can be written down as an ASCII string. <A NAME="rf1"><A HREF="9906ef1.htm">Figure 1</A>(a), for example, is a DNA sequence consisting of 39 nucleotides.</p><p>DNA doesn't usually float around the cell in its single-stranded form. Instead it spends its time in a stable double-stranded form, the famous "double helix." In the double-stranded form, each nucleotide is paired with another nucleotide. Because of their chemical nature, A always pairs with T, and G pairs with C. Written down in a text representation, the double-stranded form of this short sequence looks like <A NAME="rf1"><A HREF="9906ef1.htm">Figure 1</A>(b).</p><p>Because the nucleotide bases are paired, they are often referred to as base pairs (bp). I've labeled the left end of the top strand 5' and the right end 3'. On the bottom strand, the numbering of the two ends is reversed. This numbering system is related to the way that DNA is put together chemically. Here, the only significance of this is that it emphasizes that DNA strands are directional. The two strands are often arbitrarily labeled the "plus" and "minus" strands to distinguish them.</p><p>DNA can do just two things: It can replicate, and it can be transcribed into RNA. The replication process is the key to both cell replication and to propagation of the species. The two strands of DNA unwind like a zipper, and each strand dictates the assembly of its complementary second strand. Schematically, the process looks like <A NAME="rf1"><A HREF="9906ef1.htm">Figure 1</A>(c).</p><p>More interesting is the transcription and translation process. Along its length, DNA encodes the instructions for many thousands of proteins, everything from the crystalline protein of the eye lens to the enzymes that make up the digestive juices of the gastrointestinal tract. These protein coding regions, separated from each other by large tracts of DNA of unknown function, are in fact genes.</p><p>To make a protein from the DNA sequence of a gene, the cell performs two phases of chemical transformation. In the first phase, the gene is transcribed into ribonucleic acid (RNA). RNA is like DNA in many ways, but instead of being double-stranded it usually exists in single-stranded form. In addition, instead of being composed of the four bases A, G, C, and T, RNA has no T, but uses a different nucleotide abbreviated as U.  </p><p>To transcribe RNA, DNA unwinds just a bit in the region of an activated gene, and the nucleotide sequence of the DNA is read off by enzymes that synthesize an RNA copy of the gene. Sometimes the plus DNA strand is transcribed, and sometimes the minus strand, depending on whether the gene is oriented right-to-left or left-to-right.</p><p>Represented in text form, an RNA strand looks just like its parent DNA strand except for the substitution of U for every T. <A NAME="rf2"><A HREF="9906ef2.htm">Figure 2</A>(a) depicts our example DNA in RNA form.</p><p>Unlike DNA (which never leaves the nucleus of the cell), RNA is free to travel through the nuclear envelope into the cellular cytoplasm. Once there, the RNA is translated into a protein. Like RNA and DNA, proteins are also long strands of repeating units. However, instead of there being only four units, proteins are made up of 21 different "amino acid" subunits. Proteins fold into complex structures dictated by the order of their amino acids. The folding determines the protein's structure and function.</p><p>Like the nucleotide bases, biologists use one-letter abbreviations to refer to the amino acids as well. Protein sequences use the letters A, C, D, E, F, G, H, I, K, L, M, N, P, Q, R, S, T, V, W, and Y. Because there just aren't enough letters in the Latin alphabet to go around, the protein alphabet overlaps with the nucleotide alphabet, but don't let that confuse you. An A found in a nucleic acid sequence has nothing to do with the A of a protein sequence.</p><p>Because only four RNA bases must dictate the order of 20 amino acids, there is obviously more to protein translation than the simple one-to-one encoding that takes place during transcription. In fact, the protein translation machinery uses a three-letter code to translate RNA into protein. During translation, the RNA is divided into groups of three-letter "codons," as in <A NAME="rf2"><A HREF="9906ef2.htm">Figure 2</A>(b).</p><p>The codons are used as a template to synthesize a protein sequence, using a little lookup table that's hardwired into the biological machinery. AUG becomes the amino acid M, UUC becomes F, CGA becomes R, and so forth. Our example DNA is translated into a 12 amino acid protein in <A NAME="rf2"><A HREF="9906ef2.htm">Figure 2</A>(c).</p><p>There are two things to notice in this example. One is that certain amino acids are encoded by several different codons. For example, the amino acid K is encoded by both AAA and AAG. This should be expected from the fact that there are 64 possible codons, and only 20 amino acids for them to encode. The other thing to notice is that certain codons (three in all) don't encode any amino acids. Instead they are "stop codons," which tell the translation machinery to stop translating and release the finished protein. Generally, the RNA molecule extends farther to the left and right than the protein it encodes (I've glossed over this fact for simplicity of illustration). Like the stop codons, the AUG codon is special because it tells the protein translation machinery with which codon to begin.</p><h3>A Sequence Class Library for Perl</h3><p>A lot of Genome informatics involves splicing, dicing, and processing long strings of DNA sequences. I created a library of Perl routines specialized for dealing with DNA (available electronically; see "Resource Center," page 5), with a small class hierarchy like <A NAME="rf3"><A HREF="9906ef3.htm">Figure 3</A>.</p><p><i>Sequence::Generic</i> is an abstract class that implements a few generic methods that all biological sequences share, such as a method for determining the sequence's length and a method for concatenating two sequences together. <i>Sequence::Nucleotide</i> is a subclass of <i>Sequence::Generic</i> that adds support for DNA- and RNA-specific operations. One of these new operations is the reverse complementation method, which transforms one strand of DNA into its complement; another is a method to translate RNA into protein.</p><p><i>Sequence::Nucleotide::Subsequence</i> is a descendent of <i>Sequence::Nucleotide</i>. Because the chunks of DNA that need to be analyzed are usually quite long (100,000 bp is not unusual), it's typical to work with one subregion at a time. A <i>Subsequence</i> represents a subregion of a longer sequence.</p><p>The <i>Sequence::Alignment</i> class is a utility class that stores information about how two similar sequences are related. It is useful for figuring out how a smaller sequence fits into a larger one.</p><p>For completeness, there should also be a <i>Sequence::Protein</i> class descended from <i>Sequence::Generic</i>, but that was too much to squeeze into this article. Instead of returning a real <i>Sequence::Protein</i> object, the method that translates RNA into proteins just returns a simple character string.</p><h3>The <i>Sequence::Generic</i> Class</h3><p><i>Sequence::Generic</i> (<A NAME="rl1"><A HREF="#l1">Listing One</A>) defines three methods that are intended to be overridden by child classes: <i>new()</i>, <i>seq()</i>, and <i>type()</i>. The <i>new()</i> method is the object constructor. It does nothing but call the <i>croak()</i> function from the <i>Carp</i> package to abort the program with an error message. This prevents the generic class from being instantiated. The <i>seq()</i> method is a low-level routine that returns the raw sequence information as a text string. This  method also croaks in case. <i>Sequence ::Generic</i> is subclassed without the <i>seq()</i> method being overridden. The <i>type()</i> method returns a human-readable string describing the type of the sequence, and is intended for debugging work. It's intended to return something like DNA, RNA, or "Protein." In the abstract class, this method returns "Generic Sequence."</p><p>The remainder of the methods are generic ones that will work with almost any biological sequence. One of these is <i>length()</i>, which returns the length of the sequence data; see <A NAME="re1"><A HREF="9906ee1.htm">Example 1</A>. By convention, Perl methods are invoked with a reference to the object as the first argument on the subroutine argument list. This method begins with the idiom <i>my $self = shift</i>. The effect of this statement is to shift the object off the argument list and to copy it into a local variable named <i>$self</i>. The methods then invoke our object's <i>seq()</i> method with the Perl method-invocation syntax <i>$self-&gt;seq</i> and pass it to the Perl string-length function <i>length()</i> (this is a normal function call, not a method call). The result is then returned to the caller.</p><p>Another method defined in this file, <i>concatenate()</i> (see <A NAME="re2"><A HREF="9906ee2.htm">Example 2</A>), concatenates two <i>Sequence::Generic</i> objects together or concatenates a <i>Sequence::Generic</i> object with a string, returning a new sequence object as the result. </p><p>In addition to its object reference, the method takes two arguments. The first is the new sequence to concatenate to the current one. The second argument is a flag that indicates whether the new sequence is to be prepended (true) or appended (false). <i>concatenate()</i> is usually called via operator overloading, and the Perl overload machinery actually takes care of setting up the two arguments.</p><p>The method first checks whether the new sequence is an object by calling the Perl built-in <i>ref()</i>, which returns the class name for objects, and the undefined value for nonobjects. If <i>ref()</i> indicates that the new sequence is an object, <i>concatenate()</i> checks whether it is a subclass of <i>Sequence::Generic</i> by using the built-in <i>isa()</i> method. The <i>__PACKAGE__</i> token is replaced by the Perl run time with the name of the current package, and avoids having to hardcode the name of the class. If the object is not a subclass, the routine aborts with an error message. Otherwise, it recovers the sequence as a string by calling its <i>seq()</i> method. If the <i>$new_seq</i> argument isn't an object at all, the method treats it as a string.</p><p>The last statement of this method uses the Perl built-in concatenation operator "." to combine the sequence strings together in the order dictated by the <i>$prepend</i> flag. The concatenated string is passed to the object's <i>new()</i> constructor to create a new <i>Sequence</i> object, which is returned to the caller. Because <i>concatenate()</i> will be called from a subclass of <i>Sequence::Generic</i>, the <i>new()</i> constructor that gets called will belong to the subclass, not to <i>Sequence::Generic</i>. In Perl there is no strong distinction between constructors and object methods, which may be a source of confusion for C++ and Java programmers.</p><p>Perl lets you overload many of its built-in operators so that when they are applied to objects they invoke a method call rather than take their default actions. I overload three different operators in the <i>Sequence::Generic</i> class (<A NAME="re3"><A HREF="9906ee3.htm">Example 3</A>). For example, by binding the "." operator to  <i>concatenate(), </i>each of the constructions in <A NAME="re4"><A HREF="9906ee4.htm">Example 4</A> will work in the natural way.</p><h3>The <i>Sequence::Nucleotide</i> Class</h3><p><i>Sequence::Nucleotide</i> (<A NAME="rl2"><A HREF="#l2">Listing Two</A>) is a dual-purpose class that represents both DNA and RNA. Because DNA can be transformed into RNA and vice versa simply by exchanging Ts and Us, I store the data as DNA and transform it into an RNA form on demand.</p><p>This module begins by loading the other modules it depends on, including <i>Sequence::Generic</i>, <i>Sequence:: Nu</i>cleotide::Subsequence, <i>Sequence::Alignment</i>, and <i>Carp</i>.</p><p>One difference between <i>Sequence::Nucleotide</i> and <i>Sequence::Generic</i> is its use of the <i>@ISA</i> global. The <i>@ISA</i> array contains a list of all the classes that the current one inherits from. Unlike Java, Perl's object system allows for multiple inheritance, although this feature is rarely needed. In this case, <i>@ISA</i> is a one-element list containing the name of the superclass, <i>Sequence::Generic</i>.</p><p>The next line in <A NAME="rl2"><A HREF="#l2">Listing Two</A> defines a private package variable named <i>%CODON _TABLE</i>. It is a Perl hash table (associative array) that maps the 64 RNA codons to the 20 amino-acid protein alphabet.</p><p>The first method this class defines is the <i>new()</i> constructor, defined in <A NAME="re5"><A HREF="9906ee5.htm">Example 5</A>. <i>new()</i> creates a hash array that contains the key's data and type. The data key will point to the raw nucleotide string data, canonicalized into upper-case DNA form. The "type" key is either DNA or RNA, indicating whether the sequence is to be displayed in DNA or RNA form.</p><p>The <i>new()</i> method can be called in several different contexts. It can be called "de novo" as a class constructor with a plain string argument to be interpreted as sequence data, as in <A NAME="re6"><A HREF="9906ee6.htm">Example 6</A>(a). Alternatively, the argument might be another <i>Sequence</i> object (either a <i>Sequence::Nucleotide</i> or another subclass of <i>Sequence::Generic</i>), in which case the constructor should return a clone of the original sequence, as in <A NAME="re6"><A HREF="9906ee6.htm">Example 6</A>(b). A final context in which the constructor might be called is one in which <i>new()</i> is used as an object method call rather than as a constructor. In this case, we want to return a new object of the same subclass as the object, as in <A NAME="re6"><A HREF="9906ee6.htm">Example 6</A>(c). Finally, the <i>new()</i> method takes an optional second argument that can be used to force the sequence type. If the second argument is omitted, the method will guess whether the sequence is RNA or DNA by looking for the presence of "U-base pairs," as in <A NAME="re6"><A HREF="9906ee6.htm">Example 6</A>(d).</p><p>When a method is called in the class constructor style (as in the first two examples above), the first argument passed to the function is a string containing the class name. When a method is called as an object method (as in the third example), the argument is a reference to the object. The first thing this method does is to recover the class name from the object reference in the event that the argument is a reference rather than an ordinary string. This ensures that both class constructor and method call styles work properly.  </p><p>The method recovers the other arguments from the subroutine argument list, storing them in local variables <i>$sequence</i> and <i>$type</i>. It also initializes an empty hash reference using the anonymous hash constructor {}, and uses the <i>bless</i> operator to associate this reference with the current class, turning it into an object reference.</p><p>new() then examines the <i>$sequence</i> argument. If it is an object reference, the method determines whether the object implements the <i>seq()</i> method by invoking the built-in <i>can()</i> method. The decision to use <i>can()</i> here rather than <i>isa()</i>, as I did in <i>Sequence::Generic</i>, was an arbitrary choice, motivated only by the desire to show something new. If the object doesn't implement <i>seq()</i>, it isn't likely to be a <i>Sequence</i>, so it <i>croak()</i>s with an error message. Otherwise, it clones the object with the simple expedient operation of copying its entire hash table.</p><p>If the <i>$sequence</i> argument is not an object reference, the method treats it as a string. <i>new()</i> does a quick check to see if it looks like a nucleic acid by matching it against a regular expression containing the characters GATC and U. I also allow whitespace to match (character class \<i>s</i>) and the N character, commonly used in experimental data to indicate an unknown or ambiguous base. If the sequence passes this test, <i>new()</i> passes it to a private routine named <i>_canonicalize()</i> to fix case, to strip out whitespace, and convert the sequence into DNA form, if necessary. The canonicalized sequence is then stored in the <i>data</i> field of our object's hash reference. <i>new()</i> also sets the <i>type</i> field to contain either the value provided by the caller, or, if not provided, to a guess based on the nucleotide composition of the provided sequence. <i>new()</i> returns the new object as the function result.</p><p>The <i>translate()</i> method takes the current sequence and translates it into protein sequence. It often happens with novel DNA sequences that you don't know in advance where the gene or genes actually begin. The part of the gene that encodes the protein may start at any of three offsets along the strand, and may be read either from the plus or the minus strand, giving a total of six possible "reading frames" that the protein may be read from.</p><p>The <i>translate()</i> method accepts an optional frame number argument, which can be any of the integers 1, 2, 3, or -1, -2, -3, and returns the protein translation for that reading frame. If no argument is provided, the routine returns the translation beginning from the first nucleotide in the sequence, reading frame +1. After a bit of adjustment to trim the sequence to an even multiple of three, the core of the translation routine is: </p><blockquote><p>$s=~s/(\S{3})/$CODON_TABLE{$1} || 'X'/eg;</p></blockquote><p>This is a Perl global pattern match and substitution operation. It finds codons by identifying groups of exactly three nonwhitespace characters <i>\S{3}</i> and replaces them with the amino acid value looked up in <i>%CODON_TABLE</i>. If, for some reason, the codon isn't present in the table (perhaps because of an ambiguous "N" in the sequence), an X is used for the corresponding amino acid residue. The translated sequence is then returned as the function result.</p><h3>Conclusion</h3><p>Perl has met the needs of the Genome Project admirably so far and will probably continue to do so for years to come. In this article, I've tried to give you a taste of how Perl can reach beyond its "quick and dirty" heritage to build a set of object- oriented classes. These classes can, in turn, serve as the foundation for large and complex software projects.</p><p>If you are interested in learning more about the use of Perl in biology, check out the Bioperl Project at http://bio .perl.org/. This cooperative project is creating an extensive class library of biologically important objects. Here you'll find full-featured cousins of the simple nucleotide sequence classes presented here, as well as Perl classes for proteins, genes, genetic maps, phylogenetic trees, and 3D protein structures.</p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>package Sequence::Generic;# File: Sequence/Generic.pmuse strict;use Carp;use overload   '""'        =&gt; 'asString',  'neg'       =&gt; 'reverse',  '.'         =&gt; 'concatenate',  'fallback'  =&gt; 'TRUE';# These methods should be overriden by child classes# class constructorsub new {    my $class = shift;    croak "$class must override the new() method";}# Return the sequence as a stringsub seq {    my $self = shift;    croak ref($self)," must override the seq() method";}# Return the type of the sequence as a human readable stringsub type {    return 'Generic Sequence';}# These methods probably don't have to be overridden# The length of the sequencesub length {    my $self = shift;    return length($self-&gt;seq);}# The reverse of the sequencesub reverse {    my $self = shift;    my $reversed = reverse $self-&gt;seq;    return $reversed;}# A human-readable description of the objectsub asString {  my $self = shift;  return $self-&gt;type . '(' . $self-&gt;length . ' residues)';}# Concatenate two sequences together and return the resultsub concatenate {  my $self = shift;  my ($new_seq,$prepend) = @_;  my ($to_append);  if (ref($new_seq)) {      croak "argument to concatenate must be a string or a Sequence object"      unless $new_seq-&gt;isa(__PACKAGE__);      $to_append = $new_seq-&gt;seq ;  } else {      $to_append = $new_seq;  }  return $self-&gt;new($prepend ? $to_append . $self-&gt;seq                      : $self-&gt;seq . $to_append);}1;</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>package Sequence::Nucleotide;# file: Sequence/Nucleotide.pmuse Sequence::Generic;use Sequence::Nucleotide::Subsequence;use Sequence::Alignment;use Carp;use strict;use vars '@ISA';:Generic';my %CODON_TABLE = (           UCA =&gt; 'S',UCG =&gt; 'S',UCC =&gt; 'S',UCU =&gt; 'S',           UUU =&gt; 'F',UUC =&gt; 'F',UUA =&gt; 'L',UUG =&gt; 'L',           UAU =&gt; 'Y',UAC =&gt; 'Y',UAA =&gt; '*',UAG =&gt; '*',           UGU =&gt; 'C',UGC =&gt; 'C',UGA =&gt; '*',UGG =&gt; 'W',           CUA =&gt; 'L',CUG =&gt; 'L',CUC =&gt; 'L',CUU =&gt; 'L',           CCA =&gt; 'P',CCG =&gt; 'P',CCC =&gt; 'P',CCU =&gt; 'P',           CAU =&gt; 'H',CAC =&gt; 'H',CAA =&gt; 'Q',CAG =&gt; 'Q',           CGA =&gt; 'R',CGG =&gt; 'R',CGC =&gt; 'R',CGU =&gt; 'R',           AUU =&gt; 'I',AUC =&gt; 'I',AUA =&gt; 'I',AUG =&gt; 'M',           ACA =&gt; 'T',ACG =&gt; 'T',ACC =&gt; 'T',ACU =&gt; 'T',           AAU =&gt; 'N',AAC =&gt; 'N',AAA =&gt; 'K',AAG =&gt; 'K',           AGU =&gt; 'S',AGC =&gt; 'S',AGA =&gt; 'R',AGG =&gt; 'R',           GUA =&gt; 'V',GUG =&gt; 'V',GUC =&gt; 'V',GUU =&gt; 'V',           GCA =&gt; 'A',GCG =&gt; 'A',GCC =&gt; 'A',GCU =&gt; 'A',           GAU =&gt; 'D',GAC =&gt; 'D',GAA =&gt; 'E',GAG =&gt; 'E',           GGA =&gt; 'G',GGG =&gt; 'G',GGC =&gt; 'G',GGU =&gt; 'G',          );*complement = *reversec = \&amp;reverse;sub new {  my $class = shift;  $class = ref($class) if ref($class);  my ($sequence,$type) = @_;  my $self = bless {},$class;  if (ref($sequence)) {    croak "Can't initialize sequence from non-Sequence object.\n"      unless $sequence-&gt;can('seq');    %{$self} = %{$sequence};  # clone operation  } else {    croak "Doesn't look like sequence data"       unless $sequence=~/^[gactnu\s]+$/i;    $self-&gt;{'data'} = $self-&gt;_canonicalize($sequence);    $self-&gt;{'type'} = $type || ($sequence=~/u/i ? 'RNA' : 'DNA');  }  return $self;}sub seq {    my $self = shift;    $self-&gt;{'data'} = $self-&gt;_canonicalize($_[0])  if defined($_[0]);    my $seq = $self-&gt;{'data'};    return $seq unless $self-&gt;is_RNA;    $seq=~tr/T/U/;    return $seq;}sub type {    my $self = shift;    return defined($_[0]) ? $self-&gt;{'type'} = $_[0] : $self-&gt;{'type'};}sub is_DNA {    my $self = shift;    return $self-&gt;type eq 'DNA';}sub is_RNA {  my $self = shift;  return $self-&gt;type eq 'RNA';}sub subseq {  my $self = shift;  my ($start,$end) = @_;  return (__PACKAGE__ . '::Subsequence')-&gt;new($self,$start,$end);}sub reverse {  my $self = shift;  return (__PACKAGE__ . '::Subsequence')-&gt;new($self,$self-&gt;length,1);}sub translate {  my $self = shift;  my $frame = shift() || 1;  my $l = $self-&gt;length;  my $seq = $frame &gt; 0 ? $self-&gt;subseq($frame,$l-($l-$frame+1)%3)              : $self-&gt;reverse-&gt;subseq(abs($frame),$l-($l-abs($frame)+1)%3);  my $s = $seq-&gt;seq;  $s=~tr/T/U/;  # put it in RNA mode  $s =~ s/(\S{3})/$CODON_TABLE{$1} || 'X'/eg;  return $s;}sub longest_orf {    my $self = shift;    my ($max,$pos,$frame);    foreach (-3..-1,1..3) {    my $translation = $self-&gt;translate($_);    while ($translation=~/([^*]+)/g) {        if (length($1) &gt; length($max)) {        $max = $1;        $frame = $_;        $pos = pos($translation) - length($max);         }    }    }    $pos *= 3;    $pos += abs($frame);    return ($pos,$pos+3*length($max)-1) if $frame &gt; 0;    return ($self-&gt;length-$pos,$self-&gt;length-$pos-3*length($max));}sub align {    my $self = shift;    my $seq = shift;    $seq = $seq-&gt;seq if ref($seq);    return new Sequence::Alignment(src=&gt;$seq,target=&gt;$self-&gt;seq);}sub _canonicalize {  my $self = shift;  my $seq = shift;  $seq =~ tr/uU/tT/;  $seq =~ s/[^gatcn]//ig;  return uc($seq);}1;</pre><P><A HREF="#rl2">Back to Article</A></P><HR><I>Copyright &copy; 1999, Dr. Dobb's Journal</I><BR>
</body></html>