<html><head><title>Jul99: Java, Synchronization,  & the PalmPilot</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Java, Synchronization,  &amp; the PalmPilot</h1><p><i>Dr. Dobb's Journal</i> July 1999</p><h2>Portability for  heterogeneous hosts</h2><h3>By Tilo Christ</h3><I>Tilo is a student of medical informatics in Heilbronn and Heidelberg, Germany. He also works as a freelancer for Siemens Med, and can be reached at tilo.christ@online.de.</I><hr><p>Palm computing devices -- the PalmPilot, Palm III, and their cousins -- are designed to exchange data with stationary host machines. Unfortunately, Palm's desktop software for handling the data transfer runs only on Windows and Macintosh. You can develop your own custom synchronization code (called "conduits") using Palm's Conduit Development Kit, which interacts with Palm's HotSync Manager (HSM). However, the HSM itself has several weaknesses:</p><p></p><ul>  <li>It will not run as a Windows NT service.  <li>It offers poor support for multiple simultaneous connections.  <li>There are no management features for multiple PalmPilots.  <li>It is tied to the Windows platform.</ul><p>To address these weaknesses, I wrote the SyncBuilder framework. It lets you write Java applications that can communicate with an arbitrary number of PalmPilots and can be deployed on any host platform. SyncBuilder works independently of the HotSync manager, supports the use of Network HotSync, and facilitates code sharing and reuse by offering a clearly defined interface for the synchronization modules.</p><p>SyncBuilder (available electronically from <i>DDJ</i>; see "Resource Center," page 5, and at http://come.to/SyncBuilder) is built on top of Kenneth Albanowski's Pilot-Link package (ftp://ryeham.ee.ryerson.ca/pub/ PalmOS/), a freely<b> </b>available (under the Library GNU Public License) package for building synchronization code on UNIX platforms. A port to Win9x/NT is available at http:// lemming.stud.fh-heilbronn.de/~christ/ pilot-xfer/. SyncBuilder derives from the Pilot-Link Java binding, and is also available under the LGPL. Because some of SyncBuilder still relies on Pilot-Link, it has limitations on platforms other than UNIX and Windows 9x/NT. However, there are plenty of things that SyncBuilder can do on all platforms, and the examples in this article have been designed to work on all platforms. Nevertheless, I am working hard to remove the existing limitations, one by one.</p><h3>PalmPilot Basics</h3><p>Before you can synchronize with the PalmPilot, you need to have a rough idea of what kind of data entities you may find on this gizmo. What follows is a quick, albeit incomplete, rundown:</p><p></p><ul>  <li>Databases. Each application on the device has zero or more databases that contain a header with some information (date of creation, number of records, and so on), variable-length records that contain the actual data, a Creator ID (CID), a type, and a name. The CID is used to link the database to an application. The CID, name, and type can be used to identify the database.  <li>Records. Each database contains records. The records store the content of the database. They are of arbitrary length, and they contain their own headers that contain information about the record (category, modified, deleted, and the like).  <li>Application information, which is linked to an application's database. Every application can have as many application information blocks as it has databases. These information blocks are typically used to store information about the database categories.  <li>Preferences. Each application may have arbitrary preferences that are associated with that application as a whole.  <li>User information, card information, and network HotSync information. These are various items that can be retrieved from the device. They are global and not tied to a specific app.</ul><h3>Desktop Link Protocol</h3><p>The PalmPilot and host communicate through the Desktop Link Protocol (DLP). The PalmPilot initiates the connection, using either a direct serial cable or modem to reach the host. After an initial handshake, the host takes control. Using DLP, the host can order the PalmPilot to find, retrieve, and manipulate all of the aforementioned data entities. When the host is finished, it informs the PalmPilot, and both parties will disconnect.</p><p>Although DLP is a datagram-oriented protocol, the PalmPilot only uses it over reliable streaming connections (either an error-correcting serial connection or TCP/IP). The serial protocol stack consists of three layers and an extra mode for the negotiation of interface parameters; see <A NAME="rf1"><A HREF="9907ef1.htm">Figure 1</A>.</p><p>DLP is based on a simple request/response pattern, with the host sending the requests. The host assembles a datagram, which consists of a command code and a block of parameters. It then sends this datagram to the PalmPilot. The PalmPilot replies with a response datagram that contains a response code and a block of return values. The layout of these datagrams is illustrated in <A NAME="rf2"><A HREF="9907ef2.htm">Figures 2</A>, <A NAME="rf3"><A HREF="9907ef3.htm">3</A>, and <A NAME="rf4"><A HREF="9907ef4.htm">4</A>.</p><p>For example, if the host wanted to read a record from an open database, it would construct a datagram that contained the command code for "Read Record by Index," the database handle, and the record index in the parameter block. The PalmPilot would reply with a datagram that contained a response code indicating successful execution, and a return value with a verbatim binary copy of the record's contents.</p><p>If the host wanted to write a record to the PalmPilot, it would place the data and the database handle in the parameter block, and the command code would be set to "Write Record." The response datagram in these cases is very short, because it only contains the response code and the unique ID of the newly created record. Similar read and write operations are available for all the data entities on the PalmPilot. Some entities can also be looked up in various ways. The database records can be found through their index, through their unique ID, through their category (PalmOS lets you place records into 15 user-defined categories), and through their state of modification.</p><p>As the developer, you do not have to concern yourself with the internals of the DLP protocol. An array of easy to use methods will conceal all the complexity from you. These methods will do all the conversion tasks between Java data types and the byte-arrays of the datagrams for you. They also relieve you from the burden of having to remember the command codes of the DLP protocol.</p><h3>Conduits</h3><p>Conduits are dynamically loadable modules that tell the HotSync Manager software how to synchronize a specific PalmPilot app's data with a specific desktop app. Conduits use an API exposed by the HotSync Manager to handle the communications.</p><p>Because it can be tedious to operate on this low level, Palm sells the Conduit Development Kit (CDK), a C++ framework that encapsulates most of the synchronization logic and all of the necessary calls to the HotSync Manager. This framework contains a set of classes that can scan a database on the PalmPilot and retrieve the state of modification of all the records. You have to implement code that creates a similar list for the mirror database (the database of the desktop application that is supposed to be synchronized with the PalmPilot application). The C++ framework can then compare all of the states and decide how to update both databases.</p><p>You have to implement helper code that can translate single database records from the PalmPilot application's format to the mirror database's format. This process is described in an article by Stu Slack, published in <i>PDA Developer</i> magazine (September/ October 1996, also available at http:// www.wwg.com/published/conduit.html).</p><p>Palm Computing has also released CDK Java, a similar development kit for Java. However, this kit is still tied to the Windows platform and needs to cooperate with the HSM, which means it inherits all of its weaknesses.</p><h3>SyncBuilder</h3><p>SyncBuilder, on the other hand, supports all of the previously mentioned data entities, and communicates through either a direct serial cable, or through Network HotSync. Network HotSync works on all platforms, but serial connectivity is only supported on Windows 9x/NT and UNIX machines. Modem HotSync is not supported at all; you can get identical results using Network HotSync.</p><p>The framework began as a set of Java classes that encapsulated the native UNIX code of the Pilot-Link library. While this gave me a quick, working implementation on my Linux box, it restricted me to UNIX platforms. The Pilot-Link code was also not reentrant, which made it hard to use in conjunction with the multithreaded Java applications. I therefore decided to reimplement all the functionality of the Pilot-Link library in Java, with an emphasis on networking through TCP/IP and on full thread safety. This conversion is not complete yet, but the following parts are done:</p><ul>  <li>The ability to use Network HotSync.  <li>Support for all operations of the DLP protocol.  <li>Special support for some of the PalmPilot's built-in applications (Memo Pad, ToDo list, Datebook, Mail, and Address Book).  <li>Support for PalmPilot database files (.PRC and .PDB files).</ul><p>Only synchronization through a direct serial cable still relies on native code.</p><p>The design of the framework is centered around the packages com.syncbuilder.sync, which contains classes for establishing connections between the host and the PalmPilot, and com.syncbuilder .storage, which contains classes that mirror the data entities.</p><p>The <i>com.syncbuilder.sync.Dlp-class</i> links these two packages by encapsulating the functionality of DLP. Every time you establish a connection with the PalmPilot, you can obtain an instance of <i>Dlp</i>. The <i>Dlp</i> class's methods take objects from the storage package as their parameters, and return objects from the same package. Many methods in the <i>Dlp</i> class open or create databases. These methods give you <i>com.syncbuilder.storage.Database</i> objects as the return value. The <i>Database</i> class has a set of methods to read/write records, which delegate their work to nonpublic methods of the <i>Dlp</i> class. This might not be a clean approach, but it is usable.</p><p>Other packages include <i>com.syncbuilder .device</i>, which offers wrappers for the global data entities (<i>UserInfo</i>, <i>CardInfo</i>, <i>NetSyncInfo</i>), and <i>com.syncbuilder.util</i>, which offers various utility classes (packing/unpacking of data structures, and so on).</p><h3>The <i>Database</i> Class</h3><p>The <i>com.syncbuilder.storage.Database</i> class is one of the key classes in SyncBuilder. You will not be able to develop synchronization applications without a working knowledge of it. <i>Database</i> is also one of the keys to developing reusable code for custom PalmPilot applications.</p><p>The <i>Dlp</i> object's <i>openDB()</i> method returns a <i>Database</i> object, which represents an opened database. This object gives you access to the records and properties of the database. You can also retrieve the Application Information block of the database, which is represented by the <i>AppBlock</i> class. The subclass <i>CategoryAppBlock</i> can store the names of up to 15 database categories within the Application Information block. This ability is used by most of the built-in applications.</p><p>Most of the methods in these classes (such as <i>getRecord()</i> and <i>putRecord()</i>) are self explanatory. Their parameters require an understanding of the ways in which the Palm devices organize their data. <A NAME="rf5"><A HREF="9907ef5.htm">Figure 5</A> is an Entity-Relationship (ER) diagram of the Palm device. The class diagram in <A NAME="rf6"><A HREF="9907ef6.htm">Figure 6</A> is organized similar to the ER diagram and should help you determine how the classes of the framework map to the entities on the Palm device.</p><p>Most PalmPilot applications use a different format for the data layout of their records, and contain application information that is different from that of any other application. SyncBuilder accommodates these differences by using specializations (inheritance) of the relevant classes. If you wish to develop support for a proprietary application, you will have to create specializations of three classes: <i>DatabaseImpl</i>, <i>Record</i>, and <i>AppBlock</i>. You might want to look at the subpackages in <i>com.syncbuilder.storage</i> (generic, appointment, ToDo, and the like).</p><p><i>Database</i> uses <i>DatabaseImpl</i>, which implements the methods that are different between different databases. <i>DatabaseImpl</i>'s main responsibility is to return the right specializations of <i>Record</i> and <i>AppBlock</i>. For example, the <i>getRecord()</i> method of the <i>Database</i> class specifies <i>Record</i> as the return parameter, but the type that is actually returned is a specialization of <i>Record</i>. The <i>Database</i> class delegates the creation of the right specializations to <i>DatabaseImpl</i>. I separated <i>DatabaseImpl</i> from <i>Database</i> to make it more reusable. I am already reusing it for a class that deals with in-memory databases (com.syncbuilder.storage.MemoryDatabase).</p><p>When you obtain a <i>Database</i> object through the <i>Dlp</i>, you specify the <i>DatabaseImpl</i> you wish to use as a parameter to the <i>openDB()</i> method. <i>Record</i> is responsible for properly parsing and constructing the internal representation of a database's records. Your own specialization needs to implement the <i>pack()</i> and <i>unpack()</i> methods. You might also wish to add accessor methods for the record's attributes. <i>pack()</i> is responsible for packing the record's attributes into the application's native byte structure. The native structure and its meaning are defined by the application that runs on the Palm device. You should derive meaningful attributes from that structure and write a conversion routine. The <i>unpack()</i> method does the exact opposite. It unpacks the application's native byte structure into the record's attributes. The methods in <i>com.syncbuilder.util.PackUtils</i> can help you write <i>pack()</i> and <i>unpack()</i> methods.</p><p>Implementing <i>AppBlock</i> is only necessary when the Palm application wishes to use application information blocks. The methods of this class are comparable to those of the <i>Record</i> class. This is not surprising, because they both inherit from the same parent class (<i>com.syncbuilder .storage.Block</i>). You will have to implement the <i>pack()</i> and <i>unpack()</i> methods again. If you wish to support database categories, like the built-in applications do, you can let your <i>AppBlock</i> class inherit from <i>com.syncbuilder.storage.CategoryAppBlock</i> instead of <i>com.syncbuilder .storage.AppBlock</i>. <i>CategoryAppBlock</i> already contains helpful support methods for parsing and creating categories.</p><p>You can use these classes right away to do simple data retrieval from your newly supported application. If you wish to do two-way synchronization, you need to determine the synchronization logic, and then write a specialization of the <i>SyncHandler</i> class. <A NAME="rl2"><A HREF="#l2">Listing Two</A> shows the basic layout of a synchronization specialization and explains how all the parts fit together to form a synchronization application. The <i>SyncHandler</i>'s <i>init()</i> method needs to reserve all the resources that are required by the synchronization procedures. The <i>service()</i> method is invoked for every Palm device that connects to your host. It provides you with a <i>Dlp</i> object and thus allows you to open a database and do synchronization work. Finally, the <i>destroy()</i> method is responsible for freeing up all resources when the synchronization application is shut down.</p><h3>Examples</h3><p><A NAME="rl1"><A HREF="#l1">Listing One</A> shows the typical structure of a simple synchronization application, which reads information from the Pilot and adds a nonsensical datebook entry. The application first determines how the user wants to synchronize (serial or network), then sets up an instance of <i>ServerSocket</i> and invokes the <i>ServerSocket</i>'s <i>accept()</i> method. This is a blocking method that returns a <i>Link</i> object when it has successfully established a connection with a PalmPilot. The <i>Link</i> object's <i>getDlp()</i> method returns a <i>Dlp</i> object, which gives you access to all the functionality of the DLP protocol. SyncBuilder comes with special support for the PalmPilot's built-in applications. For example, there is a special <i>DatabaseImpl</i> class that supports the Datebook application, and you can feed that <i>DatabaseImpl</i> class to the <i>Dlp</i>'s <i>openDB()</i> method to open the Datebook's database.</p><p>If you run this example through a serial cable, you should not wait longer than a few seconds before pressing Return; otherwise, the Pilot will consider the connection dead. Network HotSync does not have this limitation.</p><p><A NAME="rl2"><A HREF="#l2">Listing Two</A> shows you how to write a simple program that can serve many PalmPilots simultaneously through the Network HotSync protocol. <A NAME="rf7"><A HREF="9907ef7.htm">Figure 7</A> illustrates the control flow for this program. The key element here is the <i>SyncServer</i> class, a multithreaded server that takes care of connection management. It delegates each incoming connection to a <i>SyncHandler</i> object. The <i>SyncHandler</i> object gets a <i>Link</i> to the connected device and can execute all DLP operations through this <i>Link</i>. You will have to provide your own implementation of <i>SyncHandler</i> to do anything meaningful. The implementation in <A NAME="rl2"><A HREF="#l2">Listing Two</A> is called <i>SimpleHandler</i>. It is important to understand that all connections are handled simultaneously by the same <i>SyncHandler</i> object. This raises the same synchronization issues as JavaSoft's Servlet technology, but it can generally be handled easily.</p><p>The <i>SyncHandler</i> interface is one of the keys to software reuse in this framework (the other one is the ability to reuse implementations of <i>DatabaseImpl</i>, <i>Record</i>, and <i>AppBlock</i>). You can encapsulate all of your synchronization strategy into a <i>SyncHandler</i>, and then share it with others. You can also use a <i>SyncHandler</i> either with single-threaded code, or with the <i>SyncServer</i>. You can combine <i>SyncHandler</i>s by chaining them. In that scenario, one <i>SyncHandler</i> would be used to invoke the <i>service()</i> method of other <i>SyncHandlers</i>, perhaps based on the identity of the PalmPilot.</p><h3>Conclusion</h3><p>SyncBuilder is an open and continuing effort to develop a powerful framework for all of your synchronization needs. It is usable now and will be better in the future. Planned additions include user-management capabilities, configurable error-handling, and ready-to-use SyncHandlers for some of the more popular applications (e-mail, Satellite Forms). I appreciate all comments, success stories, and contributions of code.</p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>/* samplecode/dlptest.java:* Copyright (C) 1998, Tilo Christ* This is free software, licensed under the GNU Public License V2.* See the file COPYING for details.*//* $Id: dlptest.java,v 1.1 1998/09/16 08:57:51 christ Exp $ */import com.syncbuilder.sync.*;import com.syncbuilder.storage.*;import com.syncbuilder.device.*;/** A test for the PalmOS DLP-functionality. This is also a sanity check for the new Pure Java Implementation of the DLP.* @author Tilo Christ*/public class dlptest{    public static void main(String[] args)    {        try        {        String port = null;        System.out.print("Port to use (\".\" means                                       Network HotSync) [/dev/pilot]? ");        System.out.flush();        port = com.syncbuilder.util.Util.readLine();        if (port.equals(""))             port = "/dev/pilot";        if (port.equals("."))        {            Socket.setSocketFactory( new NetworkHSSocketImplFactory() );            System.out.println("Initiate Network HotSync now.");         }        else        {            System.out.println("Please hit the HotSync button now.");         }        ServerSocket ssock = new ServerSocket(port);        Link link = ssock.accept();        Dlp dlp = link.getDlp();        System.out.println("The connection-protocol has a version of: "                                                + link.getProtocolVersion());        System.out.println("Information about the HotSync user will");        System.out.println("be read from your device");        System.out.println("as soon as you start the action.");        System.out.println("Press &lt;RETURN&gt; to start the action...");        com.syncbuilder.util.Util.readLine();        UserInfo uinfo = dlp.getUserInfo();        System.out.println( uinfo.toString() );        System.out.println("The user-info should have been displayed now.");        System.out.println("Press &lt;RETURN&gt; to continue...");        com.syncbuilder.util.Util.readLine();                System.out.println("The message on your PalmOS device should");        System.out.println("switch from 'Identifying User'                                                       to 'Synchronizing'");        System.out.println("as soon as you start the action.");        System.out.println("Press &lt;RETURN&gt; to start the action...");        com.syncbuilder.util.Util.readLine();        dlp.switchMessage();                System.out.println("The message should have switched now.");        System.out.println("Press &lt;RETURN&gt; to continue...");        com.syncbuilder.util.Util.readLine();        System.out.println("The message on your PalmOS device should");        System.out.println("switch from 'Synchronizing' to                                               'Synchronizing Datebook'");        System.out.println("as soon as you start the action.");        System.out.println("Press &lt;RETURN&gt; to start the action...");        com.syncbuilder.util.Util.readLine();        Database dbase = dlp.openStockDB                 (new com.syncbuilder.storage.appointment.DatabaseImpl());        System.out.println("The message should have switched now.");        System.out.println("Press &lt;RETURN&gt; to continue...");        com.syncbuilder.util.Util.readLine();        System.out.println("All " + dbase.getRecordCount() + "                   entries from your datebook will be read and displayed");        System.out.println("as soon as you start the action.");        System.out.println("Press &lt;RETURN&gt; to start the action...");        com.syncbuilder.util.Util.readLine();        for (int i = 0;; i++)        {            Record rec = dbase.getRecord(i);            if (rec == null)                break;            System.out.println( rec.toString() );        }        System.out.println("The records should have been printed now.");        System.out.println("Press &lt;RETURN&gt; to continue...");        com.syncbuilder.util.Util.readLine();        System.out.println("A test entry will be added to                                     your datebook at the current date");        System.out.println("as soon as you start the action.");        System.out.println("Press &lt;RETURN&gt; to start the action...");        com.syncbuilder.util.Util.readLine();        com.syncbuilder.storage.Record record = dbase.createRecord();        ((com.syncbuilder.storage.appointment.Record)record).description =                                                  "Dinner at the White House";        dbase.putRecord(record);        System.out.println("The record should have been added                           now with UID " + record.getID().getValue() + ".");        System.out.println("Press &lt;RETURN&gt; to continue...");        com.syncbuilder.util.Util.readLine();        dlp.endHotSync();        }        catch(Throwable t)        {            t.printStackTrace();        }    }}</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>/* samplecode/SyncServerTest.java:* Copyright (C) 1998, Tilo Christ* This is free software, licensed under the GNU Public License V2.* See the file COPYING for details.*//* $Id$ */import com.syncbuilder.sync.*;import com.syncbuilder.device.*;/** Demonstrates use of the com.syncbuilder.sync.SyncServer-class.* Will not work through PalmPilot's regular HotSync app; only through* the Network HotSync app (obtain separately from Palm Computing).* @author Tilo Christ*/public class SyncServerTest{    public static void main(String[] args)    {        try        {        // Create a ServerSocket for use with Network HotSync.        Socket.setSocketFactory( new NetworkHSSocketImplFactory() );        ServerSocket ssock = new ServerSocket(null);        // Create the SyncServer from the ServerSocket. The SyncServer        // will serve all clients using SimpleHandler (see the class        // SimpleHandler below). SimpleHandler will mostly print diagnostic        // messages and read the UserInfo from the device.        SyncServer sync_server = new SyncServer(ssock, new SimpleHandler());         System.err.println("Initiate the Network HotSync procedures now.");         // The SyncServer starts running NOW!        sync_server.start();        System.err.println("Press &lt;RETURN&gt; to stop the service");        com.syncbuilder.util.Util.readLine();         // The SyncServer is shut down        sync_server.stop();        }        catch(Throwable t)        {            t.printStackTrace();        }    }}  /** Non-public class. Used by SyncServer to handle incoming connections. */  class SimpleHandler        implements com.syncbuilder.sync.SyncHandler  {        /** Invoked one time at start-up */        public void init()        {           System.err.println("SimpleHandler.init()");        }        /** Invoked every time a device connects */             public void service(Link link)            throws Exception        {            System.err.println("SimpleHandler.service() with "                                                   + link.toString() );            Dlp dlp = link.getDlp();            // Do it ten times, so it takes more time...            for (int i=0; i &lt; 10; i++)            {                UserInfo uinfo = dlp.getUserInfo();                System.err.println( uinfo.toString() );            }            dlp.endHotSync();        }        /** Invoked one time at shutdown */             public void destroy()        {            System.err.println("SimpleHandler.destroy()");        }    }</pre><P><A HREF="#rl2">Back to Article</A></P><HR><I>Copyright &copy; 1999, Dr. Dobb's Journal</I><BR>
</body></html>