<html><head><title>Aug99: IEEE 1394 Configuration ROM Decoder</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>IEEE 1394 Configuration ROM Decoder</h1><p><i>Dr. Dobb's Journal</i> August 1999</p><h2>Finding out what's inside a Firewire device</h2><h3>By William F. Alexander</h3><I>Bill is a senior software engineer at LSI Logic (formerly Symbios Logic). His current responsibilities include developing 1394 device drivers, software, and utilities. He can be contacted at http://www .geocities.com/SiliconValley/Haven/4824/.</I><hr><p>I started developing software in the IEEE 1394 ("FireWire") arena about two years ago. Symbios Logic (now LSI Logic) was developing the SYM13FW500 chip, which is a 1394-to-ATA/ATAPI bridge that lets IDE drives connect to a system in a hot plug-and-play fashion. At the time there were not many 1394 development tools. The Open Host Controller Interface (OHCI) initiative was still coming up to speed and the only 1394 PCI controllers on the market were Texas Instruments' TSBKPCI and Adaptec's AHA-8940. My group decided to standardize on the TI TSBKPCI because of the robust and reliable software development environment (called "LynxSoft") included with the controller. The main parts of LynxSoft are a Windows 95 VxD (PCILYNX.VXD) and a DLL (CSL1394.DLL), which work together to provide developers with a powerful API in which to begin 1394 development (see http://www.ti.com/sc/docs/msp/ 1394/evm/pcitst.htm for more details).</p><p>One utility I wrote for the SYM13FW500 project is a configuration ROM dumper and decoder called "DUMPROM" that lets you examine the configuration ROM of any 1394 device connected to the TSBKPCI. In this article, I'll first examine the 1394 addressing scheme and other issues, then present the DUMPROM utility. The complete source code and executable is available electronically; see "Resource Center," page 5; it is also available at http://www.geocities .com/SiliconValley/Haven/4824/.</p><h3>The IEEE 1394 Addressing Scheme</h3><p>1394 is a serial bus design in which nodes participate in making up a 64-bit address space. When the bus is initialized or reset, each node is assigned a node number. A node number is used as part of the 64-bit address to access the memory space on a specific node. An address is made up of three fields: </p><p></p><ul>  <li><i>bus_number</i> (bits 54-63).   <li><i>node_number</i> (bits 48-53).   <li><i>address_offset</i> (bits 0-47). </ul><p>Currently, no vendor is routing from one 1394 bus to another, so the <i>bus_number</i> you will always see is 0x3FF (local bus). <i>Node_number</i> ranges from 0 to 0x3F (64 nodes). 0x3F is a special node number denoting a broadcast to all nodes on a specified <i>bus_number</i>, so there are only 63 usable nodes possible on a single bus. <i>Address_offset</i> ranges from 0x0000: 00000000 to 0xFFFF:FFFFFFFF, which gives you up to 256 terabytes of address space for a single node. I use the ":" character to help differentiate the upper 16 bits from the lower 32 bits of the <i>address_offset</i>.</p><p>Inside this 256 TB address space on a node, 1394 defines an address map for three subspaces: </p><ul>  <li>Initial memory space (0x0000:00000000 to 0xFFFF:DFFFFFFF).  <li>Private space (0xFFFF:E0000000 to 0xFFFF:EFFFFFFF).  <li>Register space (0xFFFF:F0000000 to 0xFFFF:FFFFFFFF). </ul><p>The configuration ROM is defined to start at offset 0x400 within the register space (<i>address_offset</i> 0xFFFF:F0000400).</p><p>From this point on, I will not deal with <i>bus_number</i> and <i>node_number</i>. When I say "address," I really mean the 48-bit "<i>address_offset.</i>"</p><h3>The IEEE 1394  Configuration ROM Format</h3><p>The IEEE 1394 configuration ROM is based on another IEEE standard called "1212." The 1212 specification defines a generic Control and Status Register (CSR) architecture for microcomputer buses. One part of the specification defines the configuration ROM definition. The 1394 configuration ROM definition is a specific implementation of 1212. The Serial Bus Protocol 2 (SBP-2) is another 1394-related specification that defines how to communicate with storage devices on a 1394 bus. The SBP-2 configuration ROM definition is a specific implementation of 1394. <A NAME="rf1"><A HREF="9908ff1.htm">Figure 1</A> illustrates the relationship between the three configuration ROM specifications.</p><p>The purpose of the configuration ROM is to provide the system with information about a node on the bus. The information usually consists of the Global Unique ID (GUID), device type, device name, manufacturer name, model number, device's capabilities, and so on. A configuration ROM is made up of a series of blocks. These blocks are in turn made up of entities that 1394 calls "quadlets" (4 bytes). The blocks are logically arranged in a hierarchical structure with the upper blocks referring to subsequent blocks. <A NAME="rf2"><A HREF="9908ff2.htm">Figure 2</A> illustrates a general 1394 configuration ROM format.</p><p>By definition, all 1394 configuration ROMs must start at address 0xFFFF: F0000400 on the device. The first quadlet is the Configuration ROM Header structure. This structure is made up of three fields: </p><ul>  <li><i>info_length</i> (bits 24-31).  <li><i>crc_length</i> (bits 16-23).  <li><i>cfg_rom_CRC</i> (bits 0-15). </ul><p>The <i>info_length</i> field defines the length in quadlets of the Bus Information Block, which starts immediately after the header. The <i>crc_length</i> field indicates the number of quadlets following the header that makes up the configuration ROM. The <i>cfg_rom_CRC</i> is a CRC-16 value calculated on the quadlets referred to by the <i>crc_length</i>. The Configuration ROM Header is shown in <A NAME="rf3"><A HREF="9908ff3.htm">Figure 3</A>.</p><p>The Bus Information Block is a four-quadlet structure. The first quadlet is the <i>bus_name</i>, which is always set to 0x31333934 (ASCII 1394). The second quadlet defines the node capabilities. The last two quadlets of the Bus Information Block are made up of the <i>node_vendor_id</i>, <i>chip_id_hi</i>, and <i>chip_id_lo</i> fields. Together, these fields provide a GUID for the node. <A NAME="rf4"><A HREF="9908ff4.htm">Figure 4</A> shows the structure of the Bus Information Block.</p><p>The Root Directory Block immediately follows the Bus Information Block. The Root Directory is a collection of directory entries that both describe the node and refer to other directory and leaf blocks in the configuration ROM. At the beginning of the Root Directory Block (and all other blocks) is a Block Header structure. This structure is made up of two fields: </p><ul>  <li><i>length</i> (bits 24-31).  <li><i>CRC-16</i> (bits 0-23). </ul><p>The <i>length</i> field indicates the block's length in quadlets (excluding the header) and the CRC-16 value calculated for these quadlets. <A NAME="rf5"><A HREF="9908ff5.htm">Figure 5</A> illustrates the structure of a Block Header.</p><p>After the header, the directory entries begin. Each directory entry is a quadlet made up of three fields: </p><ul>  <li><i>key_type</i> (bits 30-31).  <li><i>key_value</i> (bits 24-29).  <li><i>value</i> (bits 0-23). </ul><p>The <i>key_type</i> is really a misnomer: It has nothing to do with the type of data being described. Rather, <i>key_type</i> defines the way in which the data is referenced. If <i>key_type</i> is 0, the value field is an immediate data value. <i>key_type</i>s of 1, 2, and 3 turn the value field into a pointer, which is really an offset counted in quadlets. <i>key_type 1</i> means that the value field is an offset relative to the node's 1394 CSR space (address 0xFFFF:F0000000). For example, a value of 0x000001 indicates that the data is located at address 0xFFFF:F0000004 on the node. <i>key_type 2</i> makes the value field a pointer to a leaf block. The pointer is offset relative to the directory entry's position in the configuration ROM. For example, if the address of a director entry is 0xFFFF:F0000440 and the value field is 0x000002, then the leaf block is located at address 0xFFFF:F0000448. <i>key_type 3</i> is the same as <i>key_type 2</i> except that the block being pointed to is a directory instead of a leaf. The <i>key_value</i> field dictates the kind of data being referenced. For example, <i>key_value 0x03</i> means that data is the <i>Module_Vendor_Id</i>. <A NAME="rf6"><A HREF="9908ff6.htm">Figure 6</A> shows the structure of a directory entry.</p><p>One important point is that the <i>key_value</i> usually restricts the values of the <i>key_type</i> field. For instance, the <i>key_value</i> <i>Module_Vendor_Id</i> (0x03) restricts <i>key_type</i> to 0 (immediate data value). Logically, it does not make sense to have a <i>Mode_Vendor_Id</i> directory. Another example is <i>key_value</i> <i>Unit_Dependent_Info</i> (0x14). Under 1212, <i>Unit_Dependent_Info key_type</i>s can be either 2 (leaf) or 3 (directory). No immediate value is possible as defined by 1212. However, you know how specifications evolve, and need dictates that we utilize available space. So under SBP-2, <i>key_value</i> 0x14 is redefined as <i>Logical_Unit</i>. If <i>key_type</i> is 0 (immediate), the value is a <i>Logic_Unit_Number</i> structure. If <i>key_type</i> is 3 (directory), the value field is a pointer to a <i>Logical_ Unit_Directory</i>. Now enters the exception: If <i>key_type</i> is 1 (CSR offset), the value field is an offset in the CSR space of the <i>Management_Agent</i> register -- not of a <i>Logic_Unit</i>.</p><p>Sometimes the <i>key_type</i> and <i>key_value</i> fields are combined and referred to as the key field. In fact, the SBP-2 specification only refers to the concatenation of the <i>key_type</i> and <i>key_value</i> fields. It uses the combination to avoid confusion over the exceptions it defines in the <i>key_value</i> field. Thus for SBP-2, key 0x14 is a <i>Logical_ Unit_Number</i>, key 0xD4 is a <i>Logical_Unit_ Directory,</i> and key 0x94 is the <i>Management_Agent</i>.</p><h3>DUMPROM Utility Operation</h3><p>The DUMPROM utility is a Win32 console application that calls TI's CLS1394.DLL. Running DUMPROM without any parameters simply dumps the configuration ROM of the first 1394 device other than the controller. <A NAME="rl1"><A HREF="#l1">Listing One</A> is output from DUMPROM with the SYM13FW500.</p><p>The output is divided into two parts. The first part is the raw quadlet data dump. This section shows nothing but raw 32-bit hexadecimal data. The second section is the decode of the ROM data. The decode is broken into blocks with each block delimited by a blank line and description. The beginning of each line starts with the address followed by a quadlet value. Then the meaning of the quadlet is displayed.</p><h3>DUMPROM Source Code</h3><p>One of the first things that DUMPROM does is load TI's CLS1394.DLL. The program does this via the <i>LoadLibraryAndFixPointers()</i> function, which calls the two Win32 APIs <i>LoadLibrary()</i> and <i>GetProcAddress()</i>. The function first calls <i>LoadLibrary()</i> to load the DLL and then uses <i>GetProcAddress()</i> to fetch the addresses of various functions. The functions that DUMPROM needs to call are:</p><p></p><ul>  <li><i>cls1394Initialize().</i>  <li><i>cls1394Terminate().</i>  <li><i>cls1394CreateFile().</i>  <li><i>cls1394CloseHandle().</i>  <li><i>cls1394DeviceIoControl().</i>  <li><i>GetDeviceInfo().</i></ul><p>You may be wondering why I did not link with the CLS1394.LIB import library and avoid the hassle of <i>LoadLibrary()</i> and <i>GetProcAddress()</i>. The reason is that CLS1394.LIB and CLS1394.DLL are incompatible between versions 2.1 and 2.2. The problem stems from the fact that 2.1 and 2.2 were developed for different revisions of the Lynx hardware, namely the TSBKPCI and TSBKPCI403. LynxSoft 2.1 does not work with the TSBKPCI403 and vice versa. In spite of the incompatibilities, the API between the versions did not change significantly. So using the <i>LoadLibrary()</i> and <i>GetProcAddress()</i> functions lets me build one program that works with both versions.</p><p>Once the CLS1394.DLL is loaded, DUMPROM initializes the DLL by calling <i>cls1394Initialize()</i>. Next, DUMPROM obtains a handle to a 1394 device. The <i>DeviceOpen()</i> function calls <i>GetDeviceInfo()</i> to get the device ID of the first device on the bus. Next, <i>DeviceOpen()</i> calls <i>cls1394CreateFile()</i> to get the handle to the device.</p><p>The device handle now lets you communicate with the device. DUMPROM needs only to read quadlets from the device, which it does through the <i>ReadQuadlet()</i> function; see <A NAME="rl2"><A HREF="#l2">Listing Two</A>.</p><p>Before DUMPROM can display and decode the configuration ROM, it must first determine the size of the ROM and allocate a buffer to hold it in memory. The <i>AllocateConfigRomBuffer()</i> function performs this operation by reading the first quadlet in the configuration ROM, which contains the size in quadlets of the ROM (<i>crc_length</i>). It then allocates a buffer with the <i>size = (crc_length+1)*sizeof(QUADLET)</i>. Next, <i>ReadConfigRomBuffer()</i> reads the entire ROM into the buffer. In a <i>for </i>loop, <i>ReadConfigRomBuffer()</i> starts at address 0xFFFF:F0000400 and reads one quadlet at a time until it has read the ROM, incrementing the address by <i>sizeof(QUADLET)</i> for each iteration.</p><p>Next, DUMPROM performs the raw quadlet data dump of the buffer. Since there is nothing exciting here, I'll move along to the decode process.</p><p>The <i>DecodeConfigRom()</i> function parses and decodes the configuration ROM buffer one quadlet at a time. To facilitate single-pass parsing, the routine allocates a table (called "blockInfo") of <i>BlockInfoT</i> structures, which has one element for every quadlet in the configuration ROM. There are three fields in this structure: </p><ul>  <li><i>BlockType</i>.  <li><i>ReferringDirEntry</i>.  <li><i>ReferringDirEntryIdx</i>. </ul><p>The <i>BlockType</i> field indicates that the corresponding quadlet in the ROM is the beginning of a new block. <i>BlockType BT_NONE (0)</i> indicates that the quadlet is an ordinary element of the current block. <i>BlockType BT_DIRECTORY (1)</i> indicates that the quadlet is the beginning of a directory block. <i>BlockType BT_LEAF (2)</i> indicates that the quadlet is the beginning of a leaf block. The <i>ReferringDirEntry</i> field is a copy of the directory entry that refers to this specific block. <i>ReferringDirEntryIdx</i> is the quadlet offset from the beginning of the ROM of the directory entry that refers to this block. <A NAME="rl3"><A HREF="#l3">Listing Three</A> shows the <i>BlockInfoT</i> definition.</p><p>The idea of the <i>blockInfo</i> table is to record block information when references are parsed in directory blocks. Initially, the entire <i>blockInfo</i> table is zeroed, thus indicating that all of the quadlets are elements of the current block. The Configuration ROM Header and Bus Information Block are special exceptions to the algorithm. These are parsed up front apart from the directories that follow.  </p><p>The Root Directory is where the algorithm starts its main parsing loop. Before entering the parsing loop, however, the <i>blockInfo</i> table entry for the Root Directory Block is initialized by setting the <i>BlockType</i> field to BT_DIRECTORY (1) and the <i>ReferringDirEntry</i> field to DT_ROOT (0xFFFFFFFF). </p><p>The parsing loop begins at index 5. The loop examines the <i>BlockType</i> field and finds BT_DIRECTORY (1), which indicates the beginning of a new directory block. The header is parsed and the loop prints a new line, the block type, a back reference, the 1394 address, the quadlet value, and the decode information (see <A NAME="rl2"><A HREF="#l2">Listing Two</A>). The block type is determined by looking at the <i>ReferringDirectoryEntry</i>. In this case, 0xFFFFFFFF indicates the Root Directory Block, which has no back reference because it is the top of the hierarchy. The decode information for a block header consists of a 16-bit length field followed by a CRC-16 field. Next, the parsing loop sets the <i>curBlockType</i> variable to the <i>BlockType</i> field. The <i>curBlockType</i> variable is used by the loop to keep track of the current parsing state on subsequent iterations.</p><p>On the next iteration of the parsing loop (index 6), the <i>BlockType</i> is now BT_NONE (0), which indicates that the current quadlet in the ROM buffer is an element of the current block. Since the <i>curBlockType</i> is BT_DIRECTORY, the quadlet is decoded as a directory entry. In <A NAME="rf7"><A HREF="9908ff7.htm">Figure 7</A>, the directory entry is 0x0C0083C0. The <i>key_type</i> field is 0, meaning this is an immediate value. The <i>key_value</i> field is 0x0C, which indicates a <i>Node_Capabilities</i> value. The value 0x083C0 is a bitmap of 1394 node capabilities with the <i>spt</i>, <i>64</i>, <i>fix</i>, <i>lst</i>, and <i>drg</i> bits set. On the next iteration (index 7), <i>BlockType</i> is also BT_NONE. So the directory entry 0x0300A0B8 is decoded to a <i>Module_Vendor_Id</i> of value 0x00A0B8. This is Symbios Logic's registered IEEE 1394 vendor ID.</p><p>The quadlet at index 8 is more interesting. <i>BlockType</i> is 0 and <i>curBlockType</i> is still BT_DIRECTORY, so this is a directory entry, but the quadlet 0x81000015 is a pointer. The <i>key_type</i> field is 2, so this is a leaf pointer. What kind of leaf? <i>Key_value</i> is 0x01, which is <i>Textual_Descriptor</i>. How far away from the current position? The value field is 0x00000F (15 decimals). Counting 15 quadlets from the current position, the newly detected leaf block starts at index 23. At index 23 in the <i>blockInfo</i> table, the parsing loop sets <i>BlockType</i> to BT_LEAF (2), <i>ReferringDirEntry</i> to 0x8100000F, and <i>ReferringDirEntryIndex</i> to 8. <A NAME="rf8"><A HREF="9908ff8.htm">Figure 8</A> shows the two tables at this point.</p><p>Parsing continues in this way one quadlet at a time. At index 11 <i>key_type</i> 3, <i>key_value</i> 0x14, value 0x000001 means a <i>Unit_Directory</i> is located one quadlet away (index 12). At index 12 in the <i>blockInfo</i> table, the parsing loop sets <i>BlockType</i> to BT_DIRECTORY (1), <i>ReferringDirEntry</i> to 0xD1000001, and <i>ReferringDirEntryIdx</i> to 11.</p><p>On the next iteration, index 12, <i>BlockType</i> is 1. This signifies a transition from one block to another. In this case, it is another directory, the <i>Unit_Directory</i>. Processing of the <i>Unit_Directory</i> continues just as with the <i>Root_Directory</i>. I will now skip ahead to index 15 where the <i>key_type</i> is 1, meaning a pointer relative to the CSR base address 0xFFFF:F0000000. The <i>key_value</i> is 0x14, <i>Management_Agent</i> -- not <i>Unit_Directory</i>! Remember that this is the SBP-2 exception to the uniform definitions of 1212. The value is 0x00C000, so the <i>Management_Agent</i> register is located at address <i>0xFFFF:F0000000 + (0x00C000 * sizeof(QUADLET)) = 0xFFFF: F0030000</i>.</p><p>Skipping ahead to index 18, this directory entry references a <i>Logical_Unit_Directory</i> one quadlet away, so the parsing loop sets up the <i>blockInfo</i> at index 19. At index 19 a new block starts. At index 23, the <i>Textual_Descriptor</i> leaf block that was referenced by index 8 is finally reached. At this point, all elements in the block are parsed as ASCII data even though <i>Textual_Descriptor</i> leaf blocks have their own structure.</p><h3>Conclusion</h3><p>DUMPROM is a handy utility, but lacks some features that would make it even more useful. For instance, DUMPROM tends to be SBP-2 oriented and does not properly decode digital-video information. This would be a nice enhancement because there is more interest in video on 1394 than in storage. You should be able to extend the code to include the digital video <i>key_values</i> with no trouble.</p><p>Another enhancement you could add is proper leaf-block decoding. Currently DUMPROM decodes leaf quadlets as ASCII data. Decoding leaf blocks in their true structures would be a good improvement. </p><p>If you are interested in the 1212, 1394, or SBP-2 specifications, I recommend looking at the definitions in the source code and reading the specifications themselves.</p><h3>Acknowledgments</h3><p>I would like to acknowledge Matt Pujol and Leo Grassens for their assistance in writing this article.</p><h3>References</h3><p><i>ISO/IEC 13212:1994(E) ANSI/IEEE Std 1212</i>, 1994 Edition, pp 79-100.</p><p><i>IEEE Standard for a High Performance Serial BUS</i>, IEEE Std 1394-1995, August 30, 1996.</p><p>ANSI T10, Project 1155D, Revision 4, May 19, 1998.</p><p><i>Texas Instruments LynxSoft 1394 Software Application Programmer User's Guide</i>, SLLU003, February 24, 1998, Version 2.2.</p><p>Tewell, Thomas. "FireWire: The IEEE 1394 Serial Bus," <i>DDJ</i>, September, 1997.</p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>Raw Data Dump of the Configuration ROM from device number 1 (id=00A0B800)1394 Addr Off    Data-------------    --------  --------  --------  -------- FFFF:F0000400    042E19A8  31333934  00FF5000  00A0B800  FFFF:F0000410    00005000  00067A52  0C0083C0  0300A0B8  FFFF:F0000420    8100000F  0400500A  81000015  D1000001  FFFF:F0000430    00067752  1200609E  13010483  5400C000  FFFF:F0000440    3A401E08  14000000  D4000001  000329A2  FFFF:F0000450    0400500A  8100000A  8200000E  0007BD5D  FFFF:F0000460    00000000  00000000  53594D42  494F5320  FFFF:F0000470    4C4F4749  432C2049  4E432E00  00044469  FFFF:F0000480    00000000  00000000  53594D42  494F5300  FFFF:F0000490    000AE09E  00000000  00000000  53594D31  FFFF:F00004A0    33465735  30302D44  49534B20  44524956  FFFF:F00004B0    45000000  00000000  00000000  Decode of the Configuration ROM from device number 1 (id=00A0B800)1394 Addr Off Quadlet  Meaning------------- -------- --------------------------------------------------Confiruation ROM HeaderFFFF:F0000400 042E19A8 info_length=04, crc_length=2E, rom_crc_value=19A8Bus_Info_BlockFFFF:F0000404 31333934 bus_name=31333934 ("1394")FFFF:F0000408 00FF5000 irmc=0, cmc=0, isc=0, bmc=0, cyc_clk_acc=FF, max_rec=5FFFF:F000040C 00A0B800 node_vendor_id=00A0B8, chip_id_hi=00FFFF:F0000410 00005000 chip_id_lo=00005000Root_DirectoryFFFF:F0000414 00067A52 length=0006, crc=7A52FFFF:F0000418 0C0083C0 Node_Capabilities spt 64 fix lst drg FFFF:F000041C 0300A0B8 Module_Vendor_Id 00A0B8FFFF:F0000420 8100000F Textual_Descriptor leaf ind_off=00000F (FFFF:F000045C)FFFF:F0000424 0400500A Module_Hw_Version 00500AFFFF:F0000428 81000015 Textual_Descriptor leaf ind_off=000015 (FFFF:F000047C)FFFF:F000042C D1000001 Unit_Directory directory ind_off=000001 (FFFF:F0000430)Unit_Directory directory referenced from FFFF:F000042CFFFF:F0000430 00067752 length=0006, crc=7752FFFF:F0000434 1200609E Unit_Spec_Id 00609EFFFF:F0000438 13010483 Unit_Sw_Version 010483FFFF:F000043C 5400C000 Management_Agent crc_offset=00C000 (FFFF:F0030000)FFFF:F0000440 3A401E08 Unit_Characteristics 401E08FFFF:F0000444 14000000 Logical_Unit_Number o=0, device_type=00, lun=0000FFFF:F0000448 D4000001 Logical_Unit_Directory                                   directory ind_off=000001 (FFFF:F000044C)Logical_Unit_Directory directory referenced from FFFF:F0000448FFFF:F000044C 000329A2 length=0003, crc=29A2FFFF:F0000450 0400500A Module_Hw_Version 00500AFFFF:F0000454 8100000A Textual_Descriptor leaf ind_off=00000A (FFFF:F000047C)FFFF:F0000458 8200000E Bus_Dependent_Info leaf ind_off=00000E (FFFF:F0000490)Textual_Descriptor leaf referenced from FFFF:F0000420FFFF:F000045C 0007BD5D length=0007, crc=BD5DFFFF:F0000460 00000000 ....FFFF:F0000464 00000000 ....FFFF:F0000468 53594D42 SYMBFFFF:F000046C 494F5320 IOS FFFF:F0000470 4C4F4749 LOGIFFFF:F0000474 432C2049 C, IFFFF:F0000478 4E432E00 NC..Textual_Descriptor leaf referenced from FFFF:F0000454FFFF:F000047C 00044469 length=0004, crc=4469FFFF:F0000480 00000000 ....FFFF:F0000484 00000000 ....FFFF:F0000488 53594D42 SYMBFFFF:F000048C 494F5300 IOS.Bus_Dependent_Info leaf referenced from FFFF:F0000458FFFF:F0000490 000AE09E length=000A, crc=E09EFFFF:F0000494 00000000 ....FFFF:F0000498 00000000 ....FFFF:F000049C 53594D31 SYM1FFFF:F00004A0 33465735 3FW5FFFF:F00004A4 30302D44 00-DFFFF:F00004A8 49534B20 ISK FFFF:F00004AC 44524956 DRIVFFFF:F00004B0 45000000 E...FFFF:F00004B4 00000000 ....FFFF:F00004B8 00000000 ....</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>BOOL ReadQuadlet(cls1394HANDLE hDev, LARGE_INTEGER liAddress, QUADLET *qValue){clsAsyncRead aw;BOOL rc;// Setup request structureaw.DestinationAddress = &amp;liAddress;aw.nNumberOfBytesToRead = sizeof(QUADLET);aw.nBlockSize = 0;aw.fulFlags = 0;aw.lpBuffer = qValue;    // Call driverrc = lpfnCls1394DeviceIoControl(hDev,CLS_REQUEST_ASYNC_READ,                                     &amp;aw,sizeof(clsAsyncRead),0,0,0,0);return (rc);}</pre><P><A HREF="#rl2">Back to Article</A></P><H4><A NAME="l3">Listing Three</H4><pre>// Block Types#define BT_NONE        0#define BT_DIRECTORY   1#define BT_LEAF        2// Block Information Structuretypedef struct BlockInfoStruct{    DWORD       BlockType;             // NONE, DIRECTORY or LEAF    DirEntryT   ReferringDirEntry;     // Copy of the directory entry quadlet    DWORD       ReferringDirEntryIdx;  //Quadlet offset from 0xFFFF:F0000400} BlockInfoT, *PBlockInfoT;</pre><P><A HREF="#rl3">Back to Article</A></P><HR><I>Copyright &copy; 1999, Dr. Dobb's Journal</I><BR>
</body></html>