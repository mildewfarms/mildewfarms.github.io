<html><head><title>Aug99: Java Q&A</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Can Java Handle Exception Handling?</h1><p><i>Dr. Dobb's Journal</i> August 1999</p><h3>By W. David Pitt</h3><I>David is a Senior Consultant for CrossLogic Corp. and is currently working on the Strata Layered Development Architecture. He can be contacted at dpitt@crosslogic.com.</I><hr><p>Most procedural languages require that you apply exception handling using defined return values from invoked functions, procedures, or methods. This approach has a couple of downsides. First, methods must return some kind of agreed upon code/value and a lot of conditional logic must be applied in order to react to it. Second, exception values have to be "bubbled up" from calling methods in a given message flow, thereby coupling methods potentially across many class definitions. If you want to express a message and react to return exception values, then it must be obtained and interrogated or returned to another calling method; see <A NAME="re1"><A HREF="9908le1.htm">Example 1</A>. </p><p>Java provides a more functional exception-handling mechanism. A sequence of Java expressions can be defined in a <i>try</i> code block; see <A NAME="re2"><A HREF="9908le2.htm">Example 2</A>(a). When an exception occurs, control is transferred to a <i>catch</i> block defined for a specific exception. If multiple exception types can be thrown from a <i>try</i> code block, multiple <i>catch</i> blocks can be defined with the enumerated exceptions; see <A NAME="re2"><A HREF="9908le2.htm">Example 2</A>(b).</p><p>Another optional feature of the try/catch mechanism is the <i>finally</i> clause, which allows the definition of a block of code that is guaranteed to be executed even if an exception is thrown; see <A NAME="re2"><A HREF="9908le2.htm">Example 2</A>(c). A common application of the <i>finally</i> clause is to perform Java's exception-handling mechanism. Moreover, creating and communicating exceptions is also semantically part of the Java lexicon. Exceptions, like most other things in Java, are objects, and therefore can be instantiated using the <i>new</i> keyword. The throws keyword is used to raise the exception object and terminate control flow inside the logic of a method. The method signature communicates to calling method exceptions that are thrown using the <i>throws</i> keyword; see <A NAME="re3"><A HREF="9908le3.htm">Example 3</A>. </p><p>Java defines a hierarchy of exceptions that are thrown in the classes supporting the JDK implementation. You can extend the hierarchy to communicate custom exceptions. Treating exceptions of a similar type allows generalized behavior to be defined for all exceptions. An example is the <i>printTrace()</i> method which, when sent to an exception instance, outputs the method execution stack.  </p><p>All exceptions subclass <i>Throwable</i>, thereby allowing them to be treated in an abstract fashion. More importantly, by organizing exceptions in a hierarchy, <i>catch</i> blocks can be defined to catch specific exception types or a more general array of exceptions by referring to a super class. For instance, defining a <i>try</i> catch for a <i>Throwable</i> exception will perform exception handling for any thrown exception. The order of the catch blocks must be defined from the most specific to the most general exceptions.</p><p>Java forces you to deal with exception handling when invoking methods that define the <i>throws</i> keyword. When a method is expressed, the compiler produces an error if a thrown exception is not handled by a calling method. Of course, you could simply rethrow the method; however, if nothing catches the exception, the run-time environment outputs a message to the <i>stderr</i> device and terminates execution. </p><h3>Checked and Unchecked Exceptions</h3><p>All exception types extend from <i>Throwable</i>; however, the hierarchy is divided into <i>Error</i> and <i>Runtime</i> exceptions, commonly referred to as "checked" or "unchecked" exceptions, respectively. Instantiating and throwing checked exceptions require a calling method that either implements a <i>try/catch</i> block, or rethrows to its calling method. </p><p>On the other hand, handling unchecked exceptions with a <i>try/catch</i> block is optional. The application of an unchecked exception is illustrated in the <i>java.util.Vector</i> class. Method <i>elementAt(0)</i> throws an <i>IndexOutOfBound</i> unchecked exception if the index argument is out of bounds. However, you can exercise this method without a <i>try/catch</i> block. Thankfully so, because having to catch every <i>Vector</i> element access could produce unwieldy code. </p><h3>Applying Exceptions</h3><p>Some restraint should be applied when throwing exceptions, because requiring you to continuously catch or rethrow exceptions could be problematic. So, when should you create and throw exceptions? </p><p>One scenario involves attempting to access external resources from Java. Exceptions are created and thrown by methods failing to perform their prescribed operations. The Java JDBC implementation typifies this by defining and throwing SQLException objects when attempting to connect or execute SQL statements. Another exception throwing guideline is exemplified by classes defined in the java.lang.reflect package. Reflection allows objects, fields, and methods to be used dynamically using <i>String</i>s to identify the elements. Exceptions are thrown for problems such as misspelled names or illegal arguments. You can emulate this behavior when implementing data-driven designs using reflection behavior. </p><p>When should exceptions not be applied? As tempting as it may be, using exceptions to control normal control flow of an application is not advised, because  control flow can be easily broken by a called method catching the exception before it reaches the calling method, or by <i>Exception</i> type changes. </p><h3>Another Generalized  Exception-Handling Implementation</h3><p>Exception-handling requirements change from application to application. But if reuse is a major objective, how can you implement exception handling in a general way?</p><p>It is important to implement a handling mechanism that supports different requirements. For example, GUI-based two-tier applications could suffice with reporting exception information to a console or dialog. On the other hand, server-based applications need to report exceptions to a file. Moreover, the design should support the introduction of more sophisticated exception-handling implementations such as automatically e-mailing on-call personnel. </p><p>The following exception-handling design allows different exception-handling mechanisms to be installed at run time on an application-by-application basis. Moreover, the design supports the installation of multiple handlers. The design also standardizes how exception handling is applied. Consistently implementing exception handling goes a long way in delivering reusable code. </p><p>Applying the Observer design pattern (see <A NAME="rf1"><A HREF="9908lf1.htm">Figure 1</A>) allows multiple loosely coupled exception handlers to be notified of an exception. The JDK uses the Observer pattern to effectively communicate user-interface events to listeners added to a particular AWT control. Borrowing on this design, handler objects are installed and notified with an instance of an <i>ExceptionEvent</i> object. </p><p>Similar to the AWT event-notification design, instances of an <i>ExceptionEvent</i> type are created and sent to observing handler objects. Handlers are defined to implement specific exception-handling requirements. For instance, outputting exception information to a Java console is accomplished by installing a <i>ConsoleHandler</i>.</p><p>Handlers could be created by extending an abstract class. An alternative design decision is to define an interface that handler classes implement. Interfaces prevent the development of a large hierarchy of classes where the only thing they may have in common is their type. The interface requires programmers to define a <i>handle()</i> method that accepts an <i>ExceptionEvent</i> instance as an argument; see <A NAME="rf2"><A HREF="9908lf2.htm">Figure 2</A>.</p><p>Exception handling is centered around the <i>Dispatch</i> class, which implements a static <i>handle()</i> method that accepts a <i>Throwable</i> object. You apply exception handling by sending the exception instance to the <i>Dispatch.handle()</i> method; see <A NAME="rf3"><A HREF="9908lf3.htm">Figure 3</A>. The <i>Dispatch</i> class defines a vector of handlers that are iterated over and sent an instance of an <i>ExceptionEvent</i>. <i>ExceptionEvent</i> objects are created by the dispatch class and define date and time attributes, and the stack trace with an attribute that holds a reference to the thrown exception instance (<A NAME="rf3"><A HREF="9908lf3.htm">Figure 3</A>). If handlers are not installed, then an <i>ExceptionEvent</i> instance is routed to the default handler. </p><p>Handlers are installed for an application by creating an instance of a handler class and passing it as an argument to the Dispatcher <i>install()</i> method (see <A NAME="rl1"><A HREF="#l1">Listing One</A>). Notice that multiple handlers can be installed, meaning multiple handlers will perform their function. The on-call developer is e-mailed and information will be recorded in a flat file.</p><p>Exceptions can be logged to a file by creating and installing a <i>FileExceptionHandler</i> class. The class implements the Handler interface implementation of the <i>handle()</i> method and appends exception information obtained from the <i>ExceptionEvent</i> to a file using a <i>PrintWriter</i> (see <A NAME="rl2"><A HREF="#l2">Listing Two</A>). </p><p>Another handler type takes advantage of the networking capabilities of Java. The handler formats an e-mail message and sends it to an address of an on-call developer. </p><h3>Conclusion</h3><p>Identifying, standardizing, and designing common application services such as exception handling is the first step in delivering reusable applications with Java. The effort spent in producing designs that can be applied across applications furthers the quest for producing reusable code. Try applying a design to other application services such as logging or obtaining application properties. Finally, source code and demos that implement the exception-handling scheme presented here are available electronically; see "Resource Center," page 5.</p><p></p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>/** Install file exception handler. * @param args java.lang.String[] */public static void main(String args[]) {    // Install flat file handler    Dispatch.install( new FileHandler("c:\\temp\\errors.txt") );    String aString = new String("Hello");    try {        // cause an exception to be thrown...           aString.charAt(aString.length()+1);            }    catch(Throwable e) {Dispatch.handle(e); }}</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>import java.io.*;/** Exception Handler designed to output exception info to a flat file.  */public class FileHandler implements Handler {    FileWriter writer = null;/** Initialize FileWriter instance. */public FileHandler(String aFileName) {    super();    // Create file writer    try {        writer = new FileWriter( new File(aFileName));    } catch(IOException e) {Dispatch.handleUsingDefault(e); }}protected void finalize() //throws IOException {    try {    writer.flush();    writer.close();    System.out.println("Finalize: file handler closed");}    catch(IOException e) {Dispatch.handleUsingDefault(e); }}/** Write exception info to a file. */public void handle(ExceptionEvent event) {   try {    writer.write(event.info()); }    catch(IOException e) {Dispatch.handleUsingDefault(e); }      }}</pre><P><A HREF="#rl2">Back to Article</A></P><HR><I>Copyright &copy; 1999, Dr. Dobb's Journal</I><BR>
</body></html>