<html><head><title>Aug99: C Programming</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>C++ for...</h1><h3>By Al Stevens</h3><I>Al is a DDJ contributing editor. He can be contacted at astevens@ddj.com.</I><hr><p>A while back Michael Swaine took a poke in one of his columns about the "...for Dummies" line of books from IDG Books. Subsequently, <i>DDJ</i> got a letter from IDG's lawyers enjoining Michael from infringing their trademarks merely to denigrate such a prestigious body of work. Michael, now a person of property in Oregon and proprietor of his own business with, no doubt, a trademark or two of his own to protect, has dutifully refrained from showing further disrespect to the property of others, particularly those with deep pockets and huge staffs of snarling lawyers.</p><p>Several years before, when it was okay to mention dummies in public, Michael remarked in his column that people who converse with dummies, also known as ventriloquists, are, in his opinion, geeks. I responded in a column of my own that in my youth I was a ventriloquist and did not consider myself a geek until such time as I read Michael's comments. It's embarrassing to find yourself forced out of a closet when you didn't know you were in one.</p><p>I once published a cartoon that I drew (Yeah, I used to be a cartoonist, too, Michael, what of it?) in a book named, <i>Welcome to Programming</i>, published by MIS:Press in 1994 and now out of print. The cartoon's caption similarly parodied the "...for Dummies" titles to explain that people who consider themselves dummies don't usually try to learn programming. IDG's lawyers probably did not read that book since they sent no such baleful warnings my way or to MIS:Press.</p><p>Too late. Last year IDG Books purchased MIS:Press. They'd have to enjoin themselves.</p><p>Now they are thinking about reprinting the book. I wonder what they'll do about the cartoon. If you want to see it and read its caption, you'll have to find a copy of the book's first edition somewhere and turn to page xxiv in the front matter. (That's page 24 for those of you who haven't read "Roman Numerals for..." oh, never mind.) Or you could get a copy of <i>The</i> <i>Al Stevens Cram Course on C/C++ CD-ROM</i>, published by <i>DDJ</i>, which includes the text and illustrations of that and two of my other MIS:Press books. <i>DDJ</i> has snarling lawyers, too, and they won't let me reproduce the cartoon and caption here because of the precedent that Michael's earlier indiscretion established.</p><p>Inasmuch as I am now one of IDG's favorite authors, a legacy of their acquisition and author of a best-seller or two, I wonder if they'll object to the title of this column, which includes a picture of my Jerry Mahoney collection, a vestige of former times. (The big guy in the middle is a home-built figure named Jack. That's right, Michael, I even build and dress them. So what's it to ya?)</p><p>By the way, I have to find a better place for my collection. If you think publishers' lawyers are grouchy, you should see the snarl on Judy's face as she tells me that she wants her living room sofa back. Right now.</p><p>Anyway, how can anyone complain if, on my 11th anniversary at <i>DDJ</i>, I dedicate this column to my collection of -- er -- ventriloquial figures? If anyone does object, I'll simply advise them that they have leaped to conclusions, rushed to judgment, and totally misinterpreted my meaning. The title of this column is obviously, "C++ for Publishers and Lawyers."</p><h3>Language Law</h3><p>Speaking of C++ for lawyers, a debate is underway among the language lawyers and standardizers on the comp.std.c++ newsgroup about a C++ language feature that quietly slipped into the standard definition with no one noticing it. Well, perhaps the committee's deliberations weren't so quiet because they seem to be the ones who disagree the loudest, but the change came as a surprise to some of us on the outside. What surprised me wasn't the new behavior but what it replaced. Consider the program in <A NAME="re1"><A HREF="9908ke1.htm">Example 1</A>(a). Does the code look correct? Well, it does to me on the surface, and it is indeed correct, according to the new rules of the standard. The program in the example instantiates a pointer to <i>const Foo</i> and initializes the pointer with the address of a <i>Foo</i> object built on the heap by the <i>new</i> operator. Because of the <i>const</i> type qualifier, the program may not modify the object through the pointer without casting away the <i>const</i>ness of the pointer or by changing only mutable members. The program may, however, delete the object. This program compiles with the newer, nearly compliant compilers, such as egcs 1.1 and is well-formed according to the C++ standard definition.</p><p>What surprised me was that this code used to be incorrect. The program fails to compile under older compilers such as VC++ 5.0, which reports:</p><blockquote><p>error C2664: 'delete' : cannot convert parameter 1 from 'const int *' to 'void *'</p></blockquote><p>The <i>ARM</i> says, "A destructor can be invoked for a <i>const</i> or volatile object," which at first reading seems to support the correctness of <A NAME="re1"><A HREF="9908ke1.htm">Example 1</A>(a) since the <i>delete</i> operator calls the class destructor. But then it says, "A pointer to constant cannot be deleted. The reason is that the deletion in principle modifies the object pointed to...The purpose of prohibiting the deletion of pointers to constants is to allow programmers to rely on <i>const</i> objects being immutable...Without the restriction against deleting pointers to <i>const</i> objects the <i>delete </i>operator would have the effect of implicitly removing the <i>const </i>attribute from a pointer. No operator should have that property."</p><p>I not only didn't know that, I never gave it the first thought. On the rare occasion when a compiler complained about my violation of that rule, I shrugged it off as yet another anomaly in the compiler or the language and removed whatever <i>const</i> qualifiers were in the way so I could get on with the task at hand -- <i>const</i> can do that to you.</p><p>Somewhere during the standardization process, they changed the rule. The change had its advocates and its opposition, none of whom seem to have changed their opinions, and both sides make compelling arguments that the other side deems spurious. I'll paraphrase some of the arguments that appeared on the newsgroup.</p><p>Those who support the current and new behavior argue that <i>const</i>ness begins when the constructor completes processing and ends just before the destructor begins processing. They also argue that inasmuch as <A NAME="re1"><A HREF="9908ke1.htm">Example 1</A>(b) has always been correct code and invokes the destructor for the <i>const</i> object when the function exits, <A NAME="re1"><A HREF="9908ke1.htm">Example 1</A>(a) should be correct also. It is not easy to see the difference between the effects of the two examples. Supporters of the new behavior go on to say that changing an object's value is unrelated to causing the object to cease to exist and that if <i>delete</i> were not permitted, memory leaks would be the result.</p><p>Those who support the earlier behavior and oppose the change argue that a destructor, which by definition cannot be <i>const</i>, changes the state of the object and, consequently, should not be permitted to execute for a <i>const</i> object when invoked by the <i>delete </i>operator. One debater said, "The result [of the new rule] is that a whole class of preventable errors are not caught by a standard-conforming compiler..." <A NAME="re1"><A HREF="9908ke1.htm">Example 1</A>(c) illustrates this concern. The caller of <i>bar</i> fully expects that <i>bar</i> cannot change the caller's <i>Foo</i> object through the pointer. Yet <i>bar</i> now has the freedom to delete the object. This is not good; the caller's guarantee of <i>const</i>ness has been seriously compromised by the new rule. If the caller tries to make further use of the object, the program probably crashes. Someone pointed out that the guarantee really never was there because the older compilers permit explicit calls to the destructor through pointers to <i>const</i> as in <A NAME="re1"><A HREF="9908ke1.htm">Example 1</A>(d).</p><p>They address the question of the difference between <A NAME="re1"><A HREF="9908ke1.htm">Examples 1</A>(a) and 1(b) by observing that the compiler destroys the object in <A NAME="re1"><A HREF="9908ke1.htm">Example 1</A>(b), whereas the programmer destroys the object in <A NAME="re1"><A HREF="9908ke1.htm">Example 1</A>(a). "There are...many things that are allowed to the compiler and not allowed to the user," said one participant. Another participant pointed out that, "A local <i>const</i> variable is being destroyed with full knowledge of its creator, in the same context where it was created, and where it is lexically impossible to try to continue using it." This argument, compelling at first, weakens when you realize that the language has always permitted a function that instantiates a local <i>const</i> variable to pass the variable's address to another function that may then call the object's destructor as <A NAME="re1"><A HREF="9908ke1.htm">Example 1</A>(d) shows.</p><p><A NAME="re1"><A HREF="9908ke1.htm">Examples 1</A>(c) and 1(d) are, in my opinion, really bad code. <A NAME="re1"><A HREF="9908ke1.htm">Example 1</A>(c) assumes that the object was instantiated with the <i>new</i> operator, which might be wrong. The explicit call to the destructor in <A NAME="re1"><A HREF="9908ke1.htm">Example 1</A>(d) does not do what <i>delete</i> does, because it does not return the memory to the heap. If you write code like that, you deserve what you get. If you are the unlucky caller of those functions as written by someone else, however, you do not deserve what they might do to you. Sometimes I write code wherein a function (I'm not discussing destructors now) deletes a pointer that the function did not initialize with <i>new</i>. Rarely if ever is that pointer passed to the deleting function. It is usually a data member. </p><p>Someone in the group asked if there was any empirical evidence that the old rule caused problems that mandated the change. This question reflects once again a larger concern that I, in my role as founder, president, sole member, and chief spokesperson of the C++ Dead Horse Molester's Society, continue to express. That concern has to do with the wisdom of using the standardization process to invent language features with which no one has gained any experience. In this particular case, I have no complaints. The new rule is what I always thought the rule was without any thought as to what it should be. I used to be wrong. Now I am right. How nice. Whether the language is wrong or right with respect to deleting pointers to <i>const</i> is likely to be argued for years to come.</p><p>Java programmers must be laughing themselves to sleep at night.</p><h3>Wild Arguments</h3><p>Speaking of being wrong, in a recent column, I spoke to the issue of wild card expansion on the MS-DOS command line, observing that the MS-DOS command.com shell provides none and that programs written for UNIX, which enjoy wild card expansion through the shell, do not work properly when ported to MS-DOS. </p><p>No column in all these years of my tenure has generated as much interest. You dear readers often enjoy disagreeing with my opinions or offering up a few of your own, but nothing stirs you like me being dead bang wrong. To date, I have over half a hundred e-mail messages that all say essentially the same thing. Most MS-DOS compilers include a relocatable object file named setargv.obj, wildargs.obj, or some such that, when linked with a program, provide wild card expansion through the compiler's startup code. All you have to do is link with the object file, and the <i>argc</i> and <i>argv</i> parameters automatically reflect properly expanded wild card arguments rather than the raw wild card specifications that the user types on the command line.</p><p>Some of your messages to me were quite understanding, realizing that no one can know everything and that mistakes do happen. But others were less forgiving, insisting that people like me who set themselves up as experts at least get their facts right before going public with them.</p><p>Fortunately, it happened in a magazine, a mostly disposable medium once its value has been extracted, and not in a more enduring vehicle, such as a book that might languish on shelves for years waiting for future readers to discover my lapse in journalistic judgment. But wait. There's that <i>Dr. Dobb's Journal</i> CD-ROM with all the editorial content. They never wear out. I'm doomed to leave my legacy of ignorance and stupidity for generations to follow. Oh, the shame.</p><p>Besides the correction to my bad information, not everyone agrees that the UNIX behavior is all that desirable, and several readers offered additional insight into the issue. </p><p>From Paul Sobolik, </p><blockquote><p>I found out about UNIX's alternate behavior when I was working with Perl, the Win32 implementation of which emulates UNIX's expansion of command line file specs. The trouble was, I wanted my little program to recurse subdirectories and process the files found there as well as those in the current directory, and automatically expanded wildcards were unwanted. I eventually discovered that expansion could be suppressed by putting the argument in quotes, but that made the program a little bit harder to remember how to use. (Another common feature of UNIX, as I understand it.)</p></blockquote><p>From Greg Miller, </p><blockquote><p>...you seem to have missed one of the biggest reasons why...only UNIX shells do automatic expansion: It's simply a less powerful approach. Consider a common archiver syntax:</p><p>&lt;archiver&gt; d *.ext *.txt</p><p></p><p>On DOS archivers, this normally deletes all files with the extension ".txt" from all archives with the extension ".ext" in the current directory. Doing the same in UNIX requires that the user manually disable globbing using quotation marks. As another example, with 4DOS and 4NT, I can copy *.c to *.bak to make quick-and-dirty backups. Under UNIX, the "cp" command simply can't do this.</p></blockquote><p>From Andy Glew,</p><blockquote><p>UNIX shell's argv wildcard expansion is a half-hearted feature -- it works maybe 80% of the time, but not all of the time. Certainly, I have learned the hard way that you should never use wildcard expansion in shell scripts, Perl scripts that invoke the shell, and frequently you should not use it in Makefiles. It can be really annoying when such tools break just when you really need them to be able to work, to clean up a large mess of temporary files.</p></blockquote><p>From Robert Dibley,</p><blockquote><p>I have written many utilities which need to allow a very flexible approach to my development directory structures, and one of the best ways to handle this seems to be a recursive directory tree scanning approach combined with full wildcard specification. This has allowed me to do such things as process all the town models in all the different data-sets I'm using, from one single command.</p><p>...the real culprits are the ones who thought they should modify what you typed without you asking. </p></blockquote><p>From Vadim Slesarev,</p><blockquote><p>I was shocked by this new knowledge... I...never expected [the] UNIX shell [to] behave so UGLY.</p></blockquote><p>From Tarjei Tjxstheim Jensen,</p><blockquote><p>UNIX does not cope with unlimited expansion of file names. The limit may vary from version to version, but there is a finite limit. If my memory serves me right the limit is around 10 KB. Once the shell command line expansion reaches that limit it will barf (print an error message and refuse to run the program you specified). So if there are a lot of files involved there is a good chance that nonUNIX programs are more able to cope with that situation.</p></blockquote><p>From Julius Caesar,</p><blockquote><p>You make me think about a time when the world was young and I was a little bit younger (as you and K&amp;R) and 48K was really a lot (my first computer had 4K) and data got saved on tape in Kansas City Standard.</p></blockquote><p></p><p>Julius, was it really that long ago?</p><p>From Chris Jennings,</p><blockquote><p>...MS-DOS offers very little flexibility with its wildcards. For example, there is no standard way that I know of to deactivate one with an escape character. Presumably this is a side effect of the fact that in the original design escaping a wildcard wasn't required since the programmer got to pick which arguments he or she expanded (if any). Chicken and egg.</p></blockquote><p>From John Wendel, who quoted a common tagline found in usenet news groups,</p><blockquote><p>Those who don't understand UNIX are doomed to recreate it, often poorly.</p></blockquote><p>Finally, you'll remember that I began that particular column with a story about my grandson Landon and his friends yelling "Doorknob" whenever someone did "a bad thing." I didn't quite know what it meant until Landon explained it to me. </p><p>This from Scott Seely,</p><blockquote><p>When I was growing up, my friends and I had a similar game. Whenever someone "left one," the first one to smell it and figure out who let it go shouted "Doorknob." If the offender didn't touch a doorknob before he was caught, he got noogies from the first one to catch him.</p></blockquote><p></p><p>Now if someone can just tell me what a "noogie" is...</p><p></p><p><b>DDJ</b></p><HR><I>Copyright &copy; 1999, Dr. Dobb's Journal</I><BR>
</body></html>