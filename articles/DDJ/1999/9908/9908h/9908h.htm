<html><head><title>Aug99: Using  Internet Explorer's  HTMLParser</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Using  Internet Explorer's  HTMLParser</h1><p><i>Dr. Dobb's Journal</i> August 1999</p><h2>Loading  and parsing HTML</h2><h3>By Andrew Tucker</h3><I>Andrew works on development tools for Windows CE at BSQUARE Corp. He can be reached at andrewt@bsquare.com.</I><hr><p>Like it or not, HTML is becoming a part of every programmer's life. Beyond the obvious web page uses, HTML is also a good format for distributing platform-independent documentation, technical papers, and reference manuals. Partnered with a scripting language and applets or Component Object Model (COM) objects, HTML provides an easy way to create interactive examples and demos that anyone with a browser can utilize.</p><p>Because it is a text-layout language rather than a programming language, however, parsing HTML takes on a little different flavor. Commands in the form of tags and arguments are used to specify how something looks rather than how something is performed. Browsers and other tools just ignore unrecognized tags and arguments. To this extent, a browser usually parses HTML into an internal form that is then used for display. </p><p>Microsoft's Internet Explorer 4.0 (IE4) is a typical browser in this regard and provides COM interfaces that let you easily load and parse HTML without actually having to display it. In this article, I'll describe these interfaces and implement a C++ class, <i>HTMLParser, </i>which lets you take advantage of them. With a little help from the WinInet APIs, I'll then use <i>HTMLParser </i>to write a utility called CheckLinks that checks HTML pages for dead links. The complete source code and related files for CheckLinks is available electronically; see "Resource Center," page 5.</p><h3>COM Interfaces</h3><p>Although IE4 exposes approximately 189 different COM interfaces via MSHTML.DLL, I only need four to implement <i>HTMLParser. </i>For purposes here, the most important interface is <i>IHTMLDocument2, </i>which provides everything necessary to load and parse HTML. Once a document is loaded, an <i>IHTMLElementCollection</i> object is retrieved via interface functions. <i>HTMLParser </i>only uses <i>get_links</i> and <i>get_images</i>, but collections of other element types can be retrieved with alternative <i>get_</i> methods. Each element in the document is represented by one of the 54 interfaces in <A NAME="rt1"><A HREF="9908ht1.htm">Table 1</A>, all of which are derived from <i>IHTMLElement</i>. <i>HTMLParser </i>will use <i>IHTMLImgElement</i> and <i>IHTMLAnchorElement</i> to retrieve the image and link URLs specified in the currently loaded document. </p><p><A NAME="rl1"><A HREF="#l1">Listing One</A> is the header file for <i>HTMLParser. </i>The <i>#import</i> statement causes the compiler to read the type library in MSHTML.DLL and create header files (MSHTML.TLH and MSHTML.TLI) that allow us to easily utilize the interfaces. Unfortunately, these header files do not contain some of the constants that we need to build <i>HTMLParser, </i>so you have to also include MSHTMDID.H. If you are using Visual C++ 6.0, this file is provided in the standard include directory; otherwise, you will have to install it from the Internet SDK or this article's source archive (available electronically). Another thing to note is that you must have IE4 installed for <i>HTMLParser </i>to work correctly. The MSHTML.DLL provided with previous versions of IE does not implement <i>IHTMLDocument2 </i>and will cause numerous compile time errors if used.</p><p>As you can see from <A NAME="rl1"><A HREF="#l1">Listing One</A>, <i>HTMLParser </i>itself is actually a COM object, deriving from the stock interfaces <i>IPropertyNotifySink</i>, <i>IOleClientSite</i>, and <i>IDispatch</i>. Most of the functionality of these interfaces is unnecessary for our purposes, so the corresponding member functions just return an error code. The only COM interface methods that you need to implement in <i>HTMLParser </i>are the three standard <i>IUnknown</i> members (<i>AddRef</i>, <i>Release</i>, and <i>QueryInterface</i>), <i>IPropertyNotifySink::OnChanged</i>, and <i>IDispatch::Invoke</i>. </p><p><A NAME="rl2"><A HREF="#l2">Listing Two</A> implements <i>HTMLParser. </i>Like any COM object, it must implement the three standard <i>IUnknown</i> interfaces. The only interesting thing to note here is that the implementation of <i>Release</i> deletes itself when the reference count drops to zero. This implies that the object must have been allocated on the heap via new rather than declared as a local variable on the stack. Rather than stating this in the source file and dismissing it as caveat emptor, I made <i>HTMLParser</i>'s constructors and destructor protected, and provided a public <i>Create</i> member function that returns a newly allocated object. This arrangement results in a compiler error if <i>HTMLParser </i>is declared as a local variable or via an explicit call to new and forces the user to always use the <i>Create</i> function. </p><p><i>IPropertyNotifySink::OnChanged</i> is used to track the state of our <i>IHTMLDocument2 </i>object. <i>HTMLParser</i>'s constructor sets up a connection point with <i>IHTMLDocument2, </i>requesting to be notified if any property values change. When <i>OnChanged</i> is called with a property ID value of DISPID_READYSTATE, it then retrieves the property's current value via a call to <i>IHTMLDocument2::Invoke</i>. If the value is READYSTATE_COMPLETE, then IE4 has finished parsing the document and you notify yourself of this via the <i>PostThreadMessage </i>API. </p><p><i>HTMLParser </i>implements <i>IDispatch::Invoke</i> for one reason -- to avoid downloading or executing Java applets, scripts, and ActiveX controls. To accomplish this, you must utilize <i>IOleControl::OnAmbientPropertyChange</i> with the value DISPID_AMBIENT_DLCONTROL. Before you can do this, however, you must call <i>IOleObject::SetClientSite</i> so that <i>IOleControl</i> will work properly. This is the reason that you derive from <i>IOleClientSite</i>, even though you don't extend its functionality in any way. After the call to <i>OnAmbientPropertyChange</i>, IE4 will call your <i>Invoke</i> method to check the value of DISPID_AMBIENT_DLCONTROL. <i>Invoke</i> simply sets the correct bits to disable the behavior you don't want and returns NOERROR.</p><h3><i>HTMLParser</i> and HTML Files </h3><p>Now that I've covered the <i>HTMLParser</i>'s COM plumbing, I turn to the public methods used to actually load and get info from an HTML file. <i>IsConnected</i> is a simple function that can be used to determine if the constructor completed successfully, and will typically only fail if IE4 is not installed. <i>LoadHTMLFile</i> is the workhorse routine that specifies the document to parse. After making sure the object is valid and cleaning up old member variable values, it checks to see if the requested file exists. This is necessary to avoid IE4 displaying a "file not found" dialog box, which would create problems when <i>HTMLParser </i>is used in noninteractive batch sessions. You then use the object's <i>IPersistFile </i>interface to load the file and drop it into a message pump. You continue to dispatch messages until you receive the WM_USER_LOAD_COMPLETE notification from <i>IPropertyNotifySink::OnChanged</i>. This mechanism must be done via a message loop rather than using a <i>WaitForSingleObject</i> strategy on some kernel event. IE4 sends window messages in the process of parsing the file and will never complete unless they are properly dispatched. After you drop out of the message loop you fill in member variables with the link and image collections and return.</p><p>The remaining public member functions are simply wrappers around the <i>IHTMLElementCollection</i> objects created in <i>LoadHTMLFile</i>. <i>GetLinkCount</i> and <i>GetImageCount</i> return the number of items in the collection, while <i>GetLinkURL</i> and <i>GetImageURL</i> retrieve the data for an item. <i>GetLinkURL</i> and <i>GetImageURL</i> both call the internal workhorse function <i>GetURLFromCollection</i>. If the requested index is out of range, <i>IHTMLElementCollection::raw_item</i> returns an error and the function will return False. Otherwise, you retrieve the interface corresponding to the requested element type and retrieve the associated URL. If no URL exists, <i>get_href</i> returns a null BSTR and the function returns False.</p><h3><i>HTMLParser </i>In Action</h3><p>CheckLinks.cpp (available electronically) utilizes <i>HTMLParser </i>to implement a dead-link checker. It takes a file specification on the command line and iterates through all the files, checking each link and reporting its status. The method used to actually check the status of the link depends on the protocol specified in the URL passed to <i>WinInet::CheckLink</i>. The full source to the WinInet class is available electronically. Since <i>WinInet::CheckLink</i> actually retrieves the file's status over the Internet, the connection speed is the bottleneck that determines how quickly it executes.  </p><h3>Conclusion</h3><p>I've only scratched the surface of the possibilities for the HTML IE4 COM interfaces. CheckLinks could be improved to check internal anchor link consistency or verify that scripts and controls are available for download. <i>HTMLParser </i>can easily be extended to utilize additional IHTMLDocument2 functionality to accomplish whatever is necessary for your specific task.</p><p></p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>/* Implement an HTML parser using IE4's IHTMLDocument2 interface. */#ifndef __HTML_H__#define __HTML_H__#include &lt;windows.h&gt;#include &lt;string&gt;// if you are using VC6 or higher, get this from the stock include// directory; otherwise get it from the Internet SDK#if _MSC_VER &gt;= 1200#pragma warning(disable:4099)   // disable spurious namespace warnings#include &lt;mshtmdid.h&gt;#else#include "./inetsdk/include/mshtmdid.h"#endif#import "mshtml.dll" named_guids no_namespaceusing namespace std;#define WM_USER_LOAD_COMPLETE   WM_USER+1class HTMLParser: public IPropertyNotifySink, IOleClientSite, IDispatch{    public:        static HTMLParser *Create();    // forces dynamic allocation        STDMETHOD_(ULONG, Release)();         BOOL LoadHTMLFile(LPCSTR pcszFile);        long GetLinkCount();        BOOL GetLinkURL(long lIndex, string &amp;rstrURL);        long GetImageCount();        BOOL GetImageURL(long lIndex, string &amp;rstrURL);        BOOL IsConnected() const { return SUCCEEDED(m_hrConnected); }    protected:        // hidden constructors/destructor to force use of Create/Release        HTMLParser();         HTMLParser(const HTMLParser &amp;); // eliminate compiler                                         // synthesized copy ctor        virtual ~HTMLParser();     // IUnknown methods        STDMETHOD(QueryInterface)(REFIID riid, LPVOID* ppv);        STDMETHOD_(ULONG, AddRef)();    // IPropertyNotifySink methods        STDMETHOD(OnChanged)(DISPID dispID);        STDMETHOD(OnRequestEdit)(DISPID dispID) { return NOERROR; }        // IOleClientSite methods        STDMETHOD(SaveObject)(void)             { return E_NOTIMPL; }        STDMETHOD(GetMoniker)(DWORD dwAssign,                                   DWORD dwWhichMoniker, IMoniker** ppmk)            { return E_NOTIMPL; }        STDMETHOD(GetContainer)(IOleContainer** ppContainer)            { return E_NOTIMPL; }        STDMETHOD(ShowObject)(void)            { return E_NOTIMPL; }        STDMETHOD(OnShowWindow)(BOOL fShow)            { return E_NOTIMPL; }        STDMETHOD(RequestNewObjectLayout)(void)            { return E_NOTIMPL; }            // IDispatch method        STDMETHOD(GetTypeInfoCount)(UINT* pctinfo)            { return E_NOTIMPL; }        STDMETHOD(GetTypeInfo)(UINT iTInfo, LCID lcid, ITypeInfo** ppTInfo)            { return E_NOTIMPL; }        STDMETHOD(GetIDsOfNames)(REFIID riid, LPOLESTR* rgszNames,                                UINT cNames, LCID lcid, DISPID* rgDispId)            { return E_NOTIMPL; }        STDMETHOD(Invoke)(DISPID dispIdMember, REFIID riid, LCID lcid,            WORD wFlags, DISPPARAMS __RPC_FAR *pDispParams,            VARIANT __RPC_FAR *pVarResult, EXCEPINFO __RPC_FAR *pExcepInfo,            UINT __RPC_FAR *puArgErr);        // helper functions        BOOL GetURLFromCollection(IHTMLElementCollection *pCollection,                                   REFIID rIID, long lIndex, string &amp;rstrURL);        // member variables        DWORD   m_dwRef;        HRESULT  m_hrConnected;        DWORD    m_dwCookie;        IHTMLDocument2* m_pMSHTML;        LPCONNECTIONPOINT m_pCP;        IHTMLElementCollection *m_pAnchorLinks;        IHTMLElementCollection *m_pImageLinks;};#endif</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>/* Implement an HTML parser using IE4's IHTMLDocument2 interface. */#include &lt;windows.h&gt;#include &lt;comdef.h&gt;#include &lt;io.h&gt;#include "html.h"#include &lt;iostream&gt;using namespace std;/* static function used to force dynamic allocation */HTMLParser *HTMLParser::Create(){    return new HTMLParser;}// constructor/destructorHTMLParser::HTMLParser(){    HRESULT hr;    LPCONNECTIONPOINTCONTAINER pCPC = NULL;    LPOLEOBJECT pOleObject = NULL;    LPOLECONTROL pOleControl = NULL;    // initialize all the class member variables    m_dwRef = 1;    // must start at 1 for the current instance    m_hrConnected = S_FALSE;    m_dwCookie = 0;    m_pMSHTML = NULL;    m_pCP = NULL;    m_pAnchorLinks = NULL;    m_pImageLinks = NULL;    // Create an instance of an dynamic HTML document    if (FAILED(hr = CoCreateInstance( CLSID_HTMLDocument, NULL,            CLSCTX_INPROC_SERVER, IID_IHTMLDocument2, (LPVOID*)&amp;m_pMSHTML )))    {        goto Error;    }    if (FAILED(hr = m_pMSHTML-&gt;QueryInterface(IID_IOleObject,                                                    (LPVOID*)&amp;pOleObject)))    {        goto Error;    }   hr = pOleObject-&gt;SetClientSite((IOleClientSite*)this);    pOleObject-&gt;Release();    if (FAILED(hr = m_pMSHTML-&gt;QueryInterface(IID_IOleControl,                                                    (LPVOID*)&amp;pOleControl)))    {        goto Error;    }    hr = pOleControl-&gt;OnAmbientPropertyChange(DISPID_AMBIENT_DLCONTROL);    pOleControl-&gt;Release();    // Hook up sink to catch ready state property change    if (FAILED(hr = m_pMSHTML-&gt;QueryInterface(IID_IConnectionPointContainer,                                                             (LPVOID*)&amp;pCPC)))    {        goto Error;    }    if (FAILED(hr = pCPC-&gt;FindConnectionPoint(IID_IPropertyNotifySink,                                                                   &amp;m_pCP)))    {        goto Error;    }    m_hrConnected = m_pCP-&gt;Advise((LPUNKNOWN)(IPropertyNotifySink*)this,                                                                 &amp;m_dwCookie);Error:    if (pCPC) pCPC-&gt;Release();}HTMLParser::~HTMLParser(){    if ( m_pAnchorLinks )        m_pAnchorLinks-&gt;Release();    if ( m_pImageLinks )        m_pImageLinks-&gt;Release();    if (SUCCEEDED(m_hrConnected))        m_pCP-&gt;Unadvise(m_dwCookie);    if (m_pCP)         m_pCP-&gt;Release();    if ( m_pMSHTML )        m_pMSHTML-&gt;Release();}STDMETHODIMP HTMLParser::QueryInterface(REFIID riid, LPVOID* ppv){    *ppv = NULL;    if (IID_IUnknown == riid || IID_IPropertyNotifySink == riid)    {        *ppv = (LPUNKNOWN)(IPropertyNotifySink*)this;        AddRef();        return NOERROR;    }    else if (IID_IOleClientSite == riid)    {        *ppv = (IOleClientSite*)this;        AddRef();        return NOERROR;    }    else if (IID_IDispatch == riid)    {        *ppv = (IDispatch*)this;        AddRef();        return NOERROR;    }   else        return E_NOTIMPL;}STDMETHODIMP_(ULONG) HTMLParser::AddRef(){    return ++m_dwRef;}STDMETHODIMP_(ULONG) HTMLParser::Release(){    if (--m_dwRef == 0)     {         delete this;         return 0;     }    return m_dwRef;}STDMETHODIMP HTMLParser::OnChanged(DISPID dispID){    HRESULT hr;    if (DISPID_READYSTATE == dispID)    {        VARIANT vResult = {0};        EXCEPINFO excepInfo;        UINT uArgErr;        long lReadyState;        DISPPARAMS dp = {NULL, NULL, 0, 0};        if (SUCCEEDED(hr = m_pMSHTML-&gt;Invoke(DISPID_READYSTATE, IID_NULL,                           LOCALE_SYSTEM_DEFAULT, DISPATCH_PROPERTYGET,                           &amp;dp, &amp;vResult, &amp;excepInfo, &amp;uArgErr)))        {            lReadyState = (READYSTATE)V_I4(&amp;vResult);            switch (lReadyState)            {               case READYSTATE_UNINITIALIZED:            case READYSTATE_LOADING:             case READYSTATE_LOADED:             case READYSTATE_INTERACTIVE:                break;            case READYSTATE_COMPLETE:                 // IE4 is finished parsing the file                BOOL fRet = PostThreadMessage(GetCurrentThreadId(),                                WM_USER_LOAD_COMPLETE, (WPARAM)0, (LPARAM)0);                break;            }            VariantClear(&amp;vResult);        }    }    return NOERROR;}STDMETHODIMP HTMLParser::Invoke(DISPID dispIdMember, REFIID riid, LCID lcid,            WORD wFlags, DISPPARAMS __RPC_FAR *pDispParams,            VARIANT __RPC_FAR *pVarResult, EXCEPINFO __RPC_FAR *pExcepInfo,            UINT __RPC_FAR *puArgErr){   if (!pVarResult)    {        return E_POINTER;    }    switch(dispIdMember)    {    case DISPID_AMBIENT_DLCONTROL:        // This tells IE4 that you want to download the page, but you don't         // want to run scripts, Java applets, or ActiveX controls        V_VT(pVarResult) = VT_I4;        V_I4(pVarResult) =  DLCTL_DOWNLOADONLY |                             DLCTL_NO_SCRIPTS |                             DLCTL_NO_JAVA |                            DLCTL_NO_DLACTIVEXCTLS |                            DLCTL_NO_RUNACTIVEXCTLS;        break;    default:        return DISP_E_MEMBERNOTFOUND;    }    return NOERROR;}BOOL HTMLParser::LoadHTMLFile(LPCSTR pcszFile){    HRESULT        hr;    LPPERSISTFILE  pPF;    IHTMLElementCollection* pColl = NULL;    MSG msg;    if ( !IsConnected() )        return FALSE;    // kill any previous links    if ( m_pAnchorLinks )    {        m_pAnchorLinks-&gt;Release();        m_pAnchorLinks = NULL;    }    if ( m_pImageLinks )    {        m_pImageLinks-&gt;Release();        m_pImageLinks = NULL;    }    // avoid IE error msg box if the file does not exist    if ( access(pcszFile, 0x00) != 0x00 )    {        return FALSE;    }    _bstr_t bstrFile(pcszFile);    // use IPersistFile to load the HTML    if ( SUCCEEDED(hr = m_pMSHTML-&gt;QueryInterface(IID_IPersistFile,                                                          (LPVOID*) &amp;pPF)))    {        hr = pPF-&gt;Load((LPCWSTR)bstrFile, 0);        pPF-&gt;Release();    }    BOOL bOK = FALSE;    if (SUCCEEDED(hr))    {        while (GetMessage(&amp;msg, NULL, 0, 0))        {            // notification from OnChanged            if (WM_USER_LOAD_COMPLETE == msg.message &amp;&amp; NULL == msg.hwnd)            {                bOK = TRUE;                break;            }            else            {                DispatchMessage(&amp;msg);            }        }    }    if ( bOK )    {        try        {            if ( FAILED(m_pMSHTML-&gt;get_links(&amp;m_pAnchorLinks)) ||                 FAILED(m_pMSHTML-&gt;get_images(&amp;m_pImageLinks)) )             {                throw exception();            }        }         catch ( exception e )        {            if ( m_pAnchorLinks )            {                m_pAnchorLinks-&gt;Release();                m_pAnchorLinks = NULL;            }            if ( m_pImageLinks )            {                m_pImageLinks-&gt;Release();                m_pImageLinks = NULL;            }            bOK = FALSE;        }    }    return bOK;}/* Get the number of links present in the current HTML file */long HTMLParser::GetLinkCount(){    long lCount = 0;    if ( m_pAnchorLinks )        m_pAnchorLinks-&gt;get_length(&amp;lCount);    return lCount;}/* Get the number of images present in the current HTML file */long HTMLParser::GetImageCount(){    long lCount = 0;    if ( m_pImageLinks )        m_pImageLinks-&gt;get_length(&amp;lCount);    return lCount;}/* Get the URL associated with a given link */BOOL HTMLParser::GetLinkURL(long lIndex, string &amp;rstrURL){    if ( IsConnected() &amp;&amp; m_pAnchorLinks )        return GetURLFromCollection(m_pAnchorLinks,                                 IID_IHTMLAnchorElement, lIndex, rstrURL);    else        return FALSE;}/* Get the URL associated with a given image */BOOL HTMLParser::GetImageURL(long lIndex, string &amp;rstrURL){    if ( IsConnected() &amp;&amp; m_pImageLinks )        return GetURLFromCollection(m_pImageLinks, IID_IHTMLImgElement,                                                          lIndex, rstrURL);    else        return FALSE;}/* Get URL associated with an element in a collection. Element must be an image or an anchor. */BOOL HTMLParser::GetURLFromCollection(IHTMLElementCollection *pCollection,                                   REFIID rIID, long lIndex, string &amp;rstrURL){    VARIANT     varIndex;    VARIANT     var2;    HRESULT     hr;    IDispatch*  pDisp = NULL;     BOOL        bFound = FALSE;    varIndex.vt = VT_UINT;    varIndex.lVal = lIndex;    VariantInit( &amp;var2 );    hr = pCollection-&gt;raw_item( varIndex, var2, &amp;pDisp );    if ( SUCCEEDED(hr) &amp;&amp; pDisp)    {        IHTMLImgElement* pImgElem = NULL;        IHTMLAnchorElement* pAnchorElem = NULL;        BSTR bstr = NULL;        if ( rIID == IID_IHTMLImgElement &amp;&amp;                          SUCCEEDED(pDisp-&gt;QueryInterface(rIID, (void **)&amp;pImgElem)) )        {            pImgElem-&gt;get_href(&amp;bstr);            pImgElem-&gt;Release();            bFound = (bstr != NULL);        }        else if ( rIID == IID_IHTMLAnchorElement &amp;&amp;                               SUCCEEDED(pDisp-&gt;QueryInterface(rIID,                                               (void **)&amp;pAnchorElem)) )        {            pAnchorElem-&gt;get_href(&amp;bstr);            pAnchorElem-&gt;Release();            bFound = (bstr != NULL);        }       pDisp-&gt;Release();        if ( bFound &amp;&amp; bstr )        {            // _bstr_t wrapper will delete since fCopy is FALSE            _bstr_t bstrHREF(bstr, FALSE);            rstrURL = (LPCSTR)bstrHREF;         }    }    return bFound;}</pre><P><A HREF="#rl2">Back to Article</A></P><HR><I>Copyright &copy; 1999, Dr. Dobb's Journal</I><BR>
</body></html>