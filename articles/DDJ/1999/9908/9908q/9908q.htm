<html><head><title>Aug99: Letters</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Letters</h1><h3>Robotics</h3><p>Dear <i>DDJ</i>, </p><p>Since <i>DDJ</i> has its roots in hobby computing, it's great to see <i>DDJ</i> providing coverage of the rapidly growing field of hobby robotics. In his April 1999 editorial, Jonathan Erickson credited Dave Baum with creating RCX Command Center. Dave wrote NQC (Not Quite C), while RCX-CC was created by Mark Overmars. I purchased one RIS in early October for my 11-year-old son. By November, "we" had a second RCX. By December, we had expanded our robotics inventory to include a Handy Board by Fred Martin of MIT. And now, in early March, my 11-year-old is building a hexapod walker out of A/C plywood and a BASIC Stamp 2 brain -- an IR obstacle detector and two touch sensors. The LEGO RIS makes a fantastic introduction to mechatronics. It would be nice to see an entire issue of <i>DDJ</i> devoted to hobby robotics.</p><p>Nick Taylor </p><p>ntaylor@iname.com</p><h3>Thread Communication  and Parallel Algorithms</h3><p>Dear <i>DDJ</i>,</p><p>In his April 1999 <i>DDJ</i> article "Thread Communication in Parallel Algorithms," Lalit Pant gives an algorithm for a breadth-first multiway tree search using a queue. He then says that using a stack would have resulted in a depth-first traversal. That is not quite correct. Using the simplest case of one root and one child, switching out the queue for the stack would not change that the first element processed would be the root node. In a depth-first traversal, the child should be processed first. Creating a nonrecursive depth-first traversal (using either a queue or stack) is sufficiently more complicated, which I will not detail here. Perhaps I'm chickening out, but I realize that it's certainly more work than the replacement suggests.</p><p>Robert Konigsberg </p><p>rikonigsberg@sai2000.com</p><p><i>Lalit replies</i>: Thanks for your note, Rob. In general, the term "depth-first traversal" (or "depth-first search") is used in connection with graphs. For a tree, which of course is a special case of a graph, depth-first search is equivalent to preorder traversal (see <i>Algorithms in C++</i>, Third Edition, by Robert Sedgewick, Section 5.8, "Introduction to Algorithms," by Cormen, Leiserson and Rivest, Section 23.3; and <i>Principles of Compiler Design</i>, by Aho and Ullman, Section 13.3). In depth-first search/traversal, the node representing the data structure you want to traverse is visited first. Nodes connected to this node are visited subsequently. The order of these subsequent visits has a very specific nature, of course. But the key point here is that the node representing the data structure to be traversed (the root in the case of a tree) is visited first. So, the statement that forms the basis of your argument "In a depth-first traversal, the child should be processed first" is incorrect.</p><h3></h3><p>Analyzing Algorithms</p><p>Dear <i>DDJ</i>,</p><p>I enjoyed Jon Bentley's April 1999 "Analysis of Algorithms" article as it took a well-known problem with some well-explained mathematical analysis and a couple of those "neat tricks" that come in handy when you least expect it. My tendency is usually to go straight for the language- and platform-specific performance enhancements. Jon's article highlighted the importance of also ensuring the algorithm is optimal.</p><p>Late at night I decided to play with the algorithm and the exercises Jon suggested. While rereading the article I remembered Jon had profiled the time spent in each function. I pondered the <i>swap</i> function (swap two integer elements of an array). It also took up quite a bit of time, and more importantly was called often.</p><p>Initially I thought this was not a candidate for algorithmic optimization -- "it's just swapping two integers." But then I remembered from a flicker of recognition whilst inspecting his algorithm that sometimes swap would be working on the same two numbers. A quick bit of instrumentation code verified that this was so.</p><p>Why bother swapping the same number? In fact, why bother calling the <i>swap</i> function at all in that case? Some of my language-specific performance disciplines kicked in to help, to save a function call and an extra condition. Still, I think the following is an algorithm improvement more than any other type of performance tweak.</p><p>For brevity, here is the code adjustment for version 4 of the algorithm:</p><blockquote><p>for (i = m-1; i &gt;= 0; i -- )</p><p>{</p><p> #if DONTSWAPEVEN</p><p> if (i != m-1)</p><p> {</p><p>#endif</p><p>  swap(i, m-1);</p><p>  search4(m-1, sum + d(p[m-1], p[m]));</p><p>  swap(i, m-1);</p><p>#if DONTSWAPEVEN</p><p> }</p><p> else</p><p>  search4(m-1, sum + d(p[m-1], p[m]));</p><p>#endif</p><p>}</p></blockquote><p>So now the swaps are only called if the two numbers are different. Of course, the search is called in every case. I'm not sure how much this theoretically speeds up the code because I think it will depend on the relative time in the swap function versus the other functions. I counted the number of swaps and the number that were removed by this optimization, but haven't analyzed the pattern yet:</p><blockquote><p>n=3: 4 total - 2 not needed</p><p>n=4: 18 total - 8 not needed</p><p>n=5: 80 total - 34 not needed</p></blockquote><p>Small tests I've run on low values of <i>n</i> show a reduction in total run time of about "1/n"th using Visual C++ 6 on Windows NT 4, Intel Pentium Pro.</p><p>Joshua Graham</p><p>jagraham@computer.org</p><p>Dear <i>DDJ</i>,</p><p>I've enjoyed reading Jon Bentley's columns since they first appeared in the August 1983 issue of <i>Communications of the ACM</i>, and wish to use this opportunity to thank him for his articles. I am delighted to see his work published in <i>DDJ</i>.</p><p>Jon's attention is focused in April and May 1999 on the Traveling Salesman Problem (TSP). Several valuable lessons are drawn as to where to look these days in attempts to speed up calculations. However, one point Jon has perhaps missed can be briefly stated: "Don't calculate unnecessarily." </p><p>In the function <i>geomdist(), d=sqrt(a2+ b2)</i> is used to calculate the distance between two points. Since <i>sqrt()</i> is responsible for 64.6 percent of the execution time of the original program, the question to be asked is: How can we dump <i>sqrt()</i>?</p><p>In the TSP, the distances between points are summed to produce an overall "cost" for a route. But the exact distance between points is not required; rather, what is required is the relationship of sums of distances between points. It is easily seen that that relationship is preserved when we use the square of the distance, rather than its exact value. That is, square both sides of the distance equation to obtain <i>d2=a2+b2</i>, and use <i>d2</i> as the "comparison value." Of course, the squaring operation has taken us back to the Pythagorean theorem, whence the distance equation was derived. </p><p>Because the relationship is preserved, we can discard <i>sqrt()</i>, and <i>geomdist()</i> becomes:</p><blockquote><p>Dist geomdist(int i, int j) {</p><p>  return (Dist)(sqr(c[i].x-c[j].x) + sqr(c[i].y-				        c[j].y));</p><p>}</p></blockquote><p>Voila, 64.6 percent faster, give or take. This clearly illustrates that a change of algorithm brings great improvement to our programs. For this reason, I continue to anticipate Jon's columns eagerly.</p><p>Peter Roth</p><p>peteroth@erols.com</p><h3>Command-Line Arguments</h3><p>Dear <i>DDJ</i>,</p><p>I've enjoyed Al Stevens's column for years. A couple of notes on the doorknob column in his May 1999 column.</p><p>1. Perhaps now you understand a bit better why people like me who started programming on UNIX found DOS, written nearly 10 years later, to be so primitive. Subnote: In 1980, we got a Motorola 68000 desktop workstation with 2 MBs of memory and a 100K UNIX kernel (and a $10K price tag -- not many were built). We sometimes had up to four people simultaneously editing files or what not. One MB (as with ATs) should be enough for a stripped-down one user -- few process system, with a good shell (and all the standard utilities on disk). So the limited memory excuse does not completely wash Microsoft.</p><p>2. Contrary to your assertion ("[C compiler builders] choose not to expand file specifications"), Borland did provide such as an option at least by Turbo C 2. So I never had to write such a routine as you did. The real question, if you are otherwise correct, is why did not Microsoft do so?</p><p>Terry J. Reedy</p><p>tjreedy@udel.edu</p><p><i>Al responds: </i>They did, as many readers pointed out. See the "C Programming" column in this issue for more information.</p><h3>Simulated Recursion</h3><p>Dear <i>DDJ</i>,</p><p>The "simulated recursion" technique Earl Augusta described in the April 1999 issue of <i>DDJ</i> is useful not only in languages that do not support recursion, but also as an optimization technique in languages that do support recursion. Many recursive procedures, though not quite tail recursive, are finished with most of their local variables by the time they reach the recursive call. Thus, pushing an entire stack frame, with all of its local variables, is wasteful; one can optimize by explicitly stacking only the recursion's control parameters rather than actually making a recursive function call. The impact of this optimization varies widely -- on an architecture with many registers and a good optimizing compiler it may have little effect -- but I've often seen it dramatically speed up recursive routines, even on RISC machines with (allegedly) good compilers.</p><p>Joe Ganley</p><p>joe@ganley.org </p><h3>Y2K Bug?</h3><p>Dear <i>DDJ</i>,</p><p>There's a novel Y2K bug in the advertisement for Objectivity (April 1999, page 37). The ad gives 2000 bc as the date for Archimedes, who actually flourished in 250 bc. It looks like someone is treating negative dates as 2000.</p><p>Doug McIlroy</p><p>doug@tahoe.cs.dartmouth.edu </p><p><b>DDJ</b></p><HR><I>Copyright &copy; 1999, Dr. Dobb's Journal</I><BR>
</body></html>