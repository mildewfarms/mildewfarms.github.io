<html><head><title>Dec99: Programmer's Toolchest</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Porting the  SPICE Library</h1><p><i>Dr. Dobb's Journal</i> December 1999</p><h2>From Fortran to C, from C to C++</h2><h3>By Ed Wright</h3><I>Ed is a member of the JPL NAIF team and founder of the JPL Perl User Group. He can be contacted at ewright@spice.jpl.nasa.gov.</I><hr><p>The Navigation Ancillary Information Facility (NAIF), under the direction of NASA's Office of Space Science, created the SPICE data system and library in the early 1990s to assist scientists with the planning and interpretation of scientific observations from space-borne instruments. The system provides ancillary information needed to recover the full value of science instrument data and facilitate the correlation of individual instrument data sets with data from other instruments on the same or other spacecraft.</p><p>NAIF serves as the Ancillary Data Node of NASA's Planetary Data System, responsible for the distribution of the SPICE data sets, called "kernel files," produced by NASA's planetary flight projects. SPICE data kernels exist for:</p><DDJADVERTISEMENT INLINE><ul>  <li><i>S</i>pacecraft trajectory, given as a function of time (SPK kernels).  <li><i>P</i>lanet, satellite, comet, asteroid, associated physical, and cartographic constants (PCK kernels).  <li><i>I</i>nstrument information, including internal timing and other geometric information (I kernels).  <li><i>C</i> matrix, time-tagged orientation data of mounted structures and instruments (C kernels).  <li><i>E</i>vents for the spacecraft and ground data system, both planned and unplanned (E kernels).</ul><p>Hence, the SPICE acronym. NAIF also assembles and distributes PCK kernels based on software provided by JPL's Solar System Dynamics Group.</p><p>The SPICE library (SPICELIB; available via anonymous ftp at ftp://naif.jpl.nasa.gov/ in/pub/naif/toolkit) consists of 952 portable Fortran routines with 79,369 lines of executable code and 153,649 comment lines. The library contains reader subroutines to retrieve data (position, velocity, and instrument observation geometry parameters) from each of the SPICE kernels, plus a wide assortment of geometry, math, time conversion, and utility routines. SPICELIB compiles natively on several platforms, including HP, SunOS, Solaris, Macintosh, Macintosh Power PC, SGI, Windows 95/NT, DEC VAX, DEC/Alpha, and NeXT. In this article, I'll describe what's involved in porting a large Fortran library such as SPICELIB to C. I'll then examine some of the issues we've encountered in moving the C implementation to C++.</p><h3>Introducing CSPICE</h3><p>Many NAIF users have asked for a C version of the SPICELIB library. Why? Because not every site has access to a Fortran compiler or programmer, although most do possess a C compiler. C improves ease-of-use, and C libraries avoid cross-language I/O problems and nonportable interface issues. C integrates easily with Java, C++, and software environments such as Interactive Data Language (IDL).</p><p>Consequently, in 1997 we began development of CSPICE, a library that extends the SPICE system to the C language realm. The functionality of CSPICE (available at http://naif.jpl.nasa.gov/CSPICE.html and via anonymous ftp at naif.jpl.nasa.gov in /pub/naif/cspice) approximates that of SPICELIB, with minor differences due to the disparate properties of ANSI C versus Fortran. The CSPICE toolkit consists of an ANSI C version of SPICELIB, support library, SPICE utility programs, documentation, and example programs. The toolkit's main component -- the CSPICE library -- includes the source for all C routines generated by f2c (a freely available Fortran-to-C converter; see http://www.netlib.org/f2c/) from SPICELIB routines, both f2c support libraries (libF77, libI77), a set of hand-coded wrapper routines that encapsulate certain translated routines, and all required header files. Again, functional library ports exist for HP, Solaris, Macintosh PPC (Metrowerks compiler), SGI (o32 and n32), Windows 95/NT, Linux, and DEC Alpha Digital UNIX.</p><p>Other C libraries exist, which provide geometric/vector/matrix math functions (though not all are as numerically stable), but only CSPICE provides the ability to read and write SPICE kernel files. CSPICE also includes extensive time conversion routines and a sophisticated, user-configurable error trace/signal system that emulates exception handling.</p><h3>SPICELIB to CSPICE</h3><p>CSPICE requires the automatic conversion of Fortran code to C via the f2c utility. The utility creates C code that emulates the behavior of input Fortran code. The conversion of 79,000-plus lines of Fortran code to C is impractical without f2c, so lacking f2c, development of CSPICE would require a routine-by-routine rewrite of SPICELIB and take a horrendous amount of time.</p><p>NAIF uses a naming convention to distinguish between the various forms of a routine. Given a Fortran routine sub in file sub.f(or), f2c creates a C routine sub_ in file sub.c. The wrapper's name is sub_c in file sub_c.c and sub_c may call sub_. The code base of the CSPICE library is the set of all f2c translated routines.</p><p>The f2c application has several command-line options. The CSPICE library builds with the options: <i>-u -C -a -A -P -!bs</i>. <A NAME="rt1"><A HREF="9912ht1.htm">Table 1</A> describes these options. The Macintosh version of CSPICE does not use the <i>-a</i> argument due to a 32K size limit for local variables imposed by the Metrowerks CodeWarrior compiler.</p><p>The f2c distribution consists of the source for the application, as well as the source for the libI77 and libF77 libraries, which simulate Fortran functionality in C. </p><h3>Wrappers</h3><p>Wrappers provide a C-friendlier interface to the more commonly used routines or to routines hand coded in C and not dependent on an f2c translation (such as math functions). Compare the program interface between a Fortran routine, its f2c counterpart, and the corresponding wrapper. <A NAME="re1"><A HREF="9912he1.htm">Example 1</A> presents the argument list for the Fortran version of SPKEZ. <A NAME="re2"><A HREF="9912he2.htm">Example 2</A> is the f2c created interface. Finally, <A NAME="re3"><A HREF="9912he3.htm">Example 3</A> shows the argument list of the wrapper spkez_c (this wrapper calls spkez_).</p><p>spkez_c passes C strings, single values (for input), and pointers (strings and outputs); spkez_ passes only Fortran strings, pointers (input and output), and the string length values. Internally, f2c uses Fortran-style strings -- blank padded without null terminators.</p><p>Wrappers also replace system-dependent calls. SPICELIB contains several routines with such calls; the most common return Fortran equivalents of <i>argv</i>, <i>argc</i>, and system time. f2c understandably fails to translate these routines to usable C, so those are manually recoded.</p><p>A number of nonportable SPICELIB routines provide some functionality available in the standard C library. The appropriate C calls replace the CSPICE versions of the routines via either a macro or wrapper.</p><p>The CSPICE design assumes calls to the library from pure C programs, not an f2c version of some program. You should access CSPICE through a wrapper, assuming  that a wrapper for the needed routine exists. Otherwise, direct calls to the f2c code base are needed. A wrapper may call other wrappers, but the f2c code base calls only other f2c code (sub1_ calls sub2_, not sub2_c).</p><h3>Problems and Solutions</h3><p>The process of creating a C version of a large Fortran library lends itself to numerous problems, from code format and style issues to the use of internal data types. The requirement of full ANSI compatibility for the wrappers ensures few or no portability problems. Wrapper development uses the GNU C compiler (gcc) with the arguments <i>-ansi</i> (support ANSI standard), <i>-Wall</i> (warn of all errors), and <i>-pedantic</i> (reject nonANSI extensions).</p><p>The NAIF team defined a coding standard for C routines that includes complete, informative, and human-understandable internal documentation. NAIF SPICELIB routines contain extensive headers that list revisions, authors, and platform-specific modifications, as well as a detailed description of the routine's function.</p><p>With regards to the generation of the wrappers, the original Fortran routines are the seeds for the wrappers. DOC2C.PL, a simple Perl script (available electronically; see "Resource Center," page 5), casts the Fortran comments to C style, then creates a skeleton for the new subroutine containing the comments. (Admittedly, the script isn't the best example of Perl coding, but I wrote it at the beginning of my involvement with CSPICE to avoid brain dulling rewrite work. I knew far less about Perl than I do now. Still, it gets the job done.) </p><p>CSPICE and f2c use <i>typedef</i>s to emulate Fortran data types. CSPICE deliberately uses <i>typedef</i>s that differ from the f2c <i>typedef</i>s. The basic f2c <i>typedef</i>s are:</p><blockquote><p>typedef long  int 	integer;</p><p>typedef short int 	shortint;</p><p>typedef float		real;</p><p>typedef double    	doublereal;</p><p>typedef long  int 	logical;</p><p>typedef long  int 	ftnlen;</p></blockquote><p>f2c treats all characters and strings as <i>char *</i>. The most commonly used CSPICE <i>typedef</i>s:</p><blockquote><p>typedef char 		SpiceChar;</p><p>typedef double    	SpiceDouble;</p><p>typedef float		SpiceFloat;</p><p>typedef long 		SpiceInt;</p><p>typedef const char	ConstSpiceChar;</p><p>typedef const double   	ConstSpiceDouble;</p><p>typedef const float    	ConstSpiceFloat;</p><p>typedef const long	ConstSpiceInt;</p><p>enum _Spiceboolean { SPICEFALSE = 0,    			       SPICETRUE = 1 };</p><p>typedef   	enum _Spiceboolean Spice			       Boolean;</p><p>typedef  const 	enum _Spiceboolean Const			       SpiceBoolean;</p></blockquote><p>The <i>const</i> types are not required by a need of function, but their use ensures that input values are not unintentionally modified within a routine. All functions with input-only vectors and matrices have those arguments declared constant.</p><p>A problem exists with the function declarations in stdlib.h on the Sun platform. The f2c header file, f2c.h, defines several macros that conflict with those found in stdlib.h. As some CSPICE functions require both f2c.h and stdlib.h, our solution is to copy the needed <i>typedef</i>s to CSPICE instead of including f2c.h in a CSPICE header file.</p><p>The translated routines' argument list and f2c internal string formats caused most of the problems during the first stage of CSPICE development. As mentioned, f2c-converted code uses Fortran strings, consequently, a string passed from a standard C routine to a translated routine must be converted to a Fortran string; a string passed from a translated routine to a standard C routine must be converted to a C string. Translated routines do not detect possible error modes such as zero-length strings or null-character pointers, so several subroutines and a set of macros handle these string operations. As in other Fortran-C interfaces, the routines require string-length arguments.</p><h3>Performance</h3><p>The C code created by f2c may well emulate the behavior of the source Fortran code, but it tends to run slow without compiler optimization. Consequently, CSPICE uses optimization on all target platforms when possible. A small difficulty expressed itself, however, during the first attempts to compile CSPICE under CodeWarrior Pro 3. If the compiler optimization settings are:</p><blockquote><p>Instruction Scheduling for 604,</p><p>Optimize for SPEED,</p><p>Global Optimization Level 4,</p><p>Peephole Optimization</p></blockquote><p>several routines fail to compile due to memory constraints on the CodeWarrior IDE. Trial and error proved the culprit to be Global Optimization Level 4, so the offensive routines now compile at Global Optimization Level 1. Another routine resists optimization on the Microsoft platform; this routine compiles unoptimized.</p><h3>C++ Issues</h3><p>CSPICE is the basis for a prototype object-oriented version of the SPICE library in C++ (SPICE++, still under design). We encountered several problems with calls to CSPICE from C++ code.</p><p>All input arrays and matrices to wrappers are of type <i>ConstSpiceDouble</i> (<i>const</i> double). Some pesky compilers flag a "non-const passed to a const" warning when passing non<i>const</i> arguments. Nat Bachman wrote a set of interface macros that perform type casting for the appropriate routines. The macros prevent the warning without forcing users to explicitly declare vectors or arrays as <i>const</i>.</p><p>Another issue is name mangling. A C++ compiler does not create the same symbol name for a routine as a C compiler -- a consequence of C++ function overloading. To link a C library to a C++ program requires that the C routine be defined as an external routine. Again, Nat Bachman added a compile-time flag to identify the CSPICE prototypes as external functions when linking the CSPICE library against a C++ routine.</p><h3>Applications of the CSPICE Library</h3><p><A NAME="rl1"><A HREF="#l1">Listing One</A> is a program called "states" with a complete header, which retrieves SPICE kernel data to calculate a body's state with respect to some observer in a user-defined reference frame. The program demonstrates how to load SPK, PCK, and leapseconds kernel files, convert a time/date string to the epoch time (a time measured against a known reference date), then retrieve a state in a particular reference frame at the epoch time.</p><p>Other CSPICE uses include:</p><ul>  <li>IDL, CSPICE, and a collection of interface routines allows IDL to access SPICE kernel data.  <li>Solar System Calculator (SSC), a simple scripting interface to CSPICE. Originally designed by Mike Spencer, updated to use CSPICE by Ed Wright.  <li>SOAP, a sophisticated orbit-analysis tool by The Aerospace Corp. for the Macintosh PPC, Windows NT, and Solaris. For more information, see http://www.aero .org/software/soap/index.html. The use of CSPICE gives SOAP users the ability to visualize trajectory data and view geometry from data in SPICE kernels. <A NAME="rf1"><A HREF="9912hf1.htm">Figure 1</A>, for instance, is a SOAP-generated view of the Cassini probe at its first encounter (fly-by) with Venus in April 1998.</ul><h3>Future Work</h3><p>CSPICE work continues for the foreseeable future. Our current goals include an expansion of the number of wrappers, improvements in platform compatibility, C-specific documentation, and bug tracking and correction. Long range goals include the release of SPICE++, decoupling the f2c I/O libraries from CSPICE, use of dynamic memory allocation in low-level CSPICE routines, and complete documentation with tutorial code examples. CSPICE is not designed for multithreaded applications, nor does NAIF plan to add this capability. SPICELIB and CSPICE are stable across all dates and calendars.</p><h3>Acknowledgment</h3><p>Development of CSPICE was accomplished by the Jet Propulsion Laboratory, California Institute of Technology, under contract with NASA. My thanks to Nat Bachman, who provided input and reviews of this article.</p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>/*-Procedure states( Compute state of one body relative to another )-Abstract   This "cookbook" program demonstrates the use of NAIF S- and P-   Kernel (SPK) files and subroutines to calculate the state   (position and velocity) of one solar system body relative to   another solar system body. The purpose of this program is twofold:      1) To show how NAIF ephemeris data may be made available to a program.      2) To show how the apparent, true, or geometric state         (inertially referenced cartesian position and velocity)         of one solar system body relative to another solar         system body may be calculated.   The CSPICE subroutine spklef_c (S/P Kernel, Load Ephemeris   File) handles the first task by maintaining a database of   ephemeris files. The calling program indicates which files   to load by passing their names to spklef_c.   spkezr_c (S/P Kernel, Real easy reader) handles the second task   by accessing the data loaded with spklef_c (spkezr_c does not   require the name of an SPK file as input).-Copyright   Copyright (1998), California Institute of Technology.   U.S. Government sponsorship acknowledged.-Input   The program prompts the user for the following input:      - The name of a NAIF leapseconds kernel file.      - The name of a NAIF binary SPK ephemeris file.      - The name for the observing body.      - The name for the target body.      - A time string of interest.      - An reference frame, i.e., "J2000".      - The type of aberration correction desired.-Output      - The state of the target body relative to the observing body.      - The one-way light-time from the target body to the observing body.-Particulars   The user supplies a NAIF leapseconds kernel file, a NAIF binary   SPK ephemeris file, valid names for both the target and   observing bodies, and the time to calculate the body's state.   Note that the `target body' and the `observing body' are both   NAIF ephemeris objects described via their common names, and   may be any of the following, provided ephemeris data are   available for them in the SPK file:      - a spacecraft      - a planet or satellite mass center      - a planet barycenter      - the sun      - the solar system barycenter      - a comet      - an asteroid   By definition, the ephemerides in SPK files are continuous. The   user can obtain states for any epoch within the interval of   coverage. Epochs are always specified in ephemeris seconds past   Julian year 2000 when accessing SPK files.   The ephemeris data in a single SPK file may be referenced to a   number of different (inertial or non-inertial) frames. The user   can specify that states be returned in any of the recognized   frames listed in the NAIF IDs Required Reading, including J2000   and B1950.   spkezr_c returns apparent, true, or geometric states depending   on the value of the aberration flag when it is called.   Flag    Type of correction           State computed by spkezr_c   ---------------------------------------------------------------   "LT+S"   light-time and stellar aberration             Apparent   "LT"     light-time only                                   True   "NONE"   no correction                                Geometric   For the sake of brevity, this program performs no error checks   on its inputs. Mistakes will cause the program to crash.-References   For additional information, see NAIF IDS Required Reading, and   the headers of the CSPICE subroutines spklef_c, spkez_c and str2et_c.-Restrictions   None.-Literature_References   None.-Author_and_Institution   E.D. Wright     (JPL)-Version   -CSPICE Version 1.0.0, 01-MAR-1998   (EDW)-&amp;*/   /* Load needed headers. */   #include &lt;stdio.h&gt;   #include "SpiceUsr.h"   /* Local declarations. */   #define                 UTCLEN   48   #define                 LENOUT   32   #define                 FILELEN  72   SpiceDouble             vec    [3];   SpiceDouble             vec1   [3];   SpiceDouble             vec2   [3];   SpiceDouble             vout   [3];   SpiceDouble             state  [6];   SpiceDouble             lt;   SpiceDouble             et;   SpiceChar            *  leap;   SpiceChar            *  spk;   SpiceChar            *  corr;   SpiceChar            *  ref;   SpiceChar            *  utc;   SpiceChar            *  format;   SpiceChar            *  targ;   SpiceChar            *  obs;   SpiceChar               utcstr[ UTCLEN ];   SpiceInt                prec;   SpiceInt                handle;void main()   {   /* Set the time output format and the precision of that output. */   format = "C";   prec   = 0;   /* Start out by prompting for names of kernel files. Load each kernel as   name is supplied. prompt_c allocates needed memory for returned strings.   */   /* Get and load the leapsecond kernel. */   leap   = prompt_c ( "Enter name of leapseconds kernel    : ");   ldpool_c ( leap );   /* Get and load the spk kernel. */   spk    = prompt_c ( "Enter name of SPK file              : ");   spklef_c ( spk, &amp;handle );   /* Get the rest of the needed parameters. */   targ   = prompt_c ( "Target (what am I looking at)       : ");   ref    = prompt_c ( "Reference frame (J2000, B1950, etc.): ");   corr   = prompt_c ( "Aberration correction                : ");   obs    = prompt_c ( "Observer (where am I)               : ");   utc    = prompt_c ( "Event time                          : ");   /* Convert the time string to ephemeris time J2000. */   str2et_c ( utc, &amp;et );   /* Compute the state of targ from obs at et. */   spkezr_c (  targ, et, ref, corr, obs, state, &amp;lt );   /* Convert the ephemeris time to a calendar format. */   et2utc_c ( et , format, prec, UTCLEN, utcstr );   /*   Everything's computed.  Output the results.  Units are   kilometers and kilometers per second.   */   printf ("\n The state of %s wrt %s at UTC time %s\n", targ, obs, utcstr );   printf ( " X :  %f KM \n", state[0] );   printf ( " VX:  %f KMS\n", state[3] );   printf ( " Y :  %f KM \n", state[1] );   printf ( " VY:  %f KMS\n", state[4] );   printf ( " Z :  %f KM \n", state[2] );   printf ( " VZ:  %f KMS\n", state[5] );   }</pre><P><A HREF="#rl1">Back to Article</A></P><HR><I>Copyright &copy; 1999, Dr. Dobb's Journal</I><BR>
</body></html>