<html><head><title>Dec99: Elliptic-Curve Cryptography</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Elliptic-Curve Cryptography</h1><p><i>Dr. Dobb's Journal</i> December 1999</p><h2>Comparing elliptic curve with other types of cryptography</h2><h3>By Andrew D. Fernandes</h3><I>Andrew is chief scientist for Cryptonym, a company specializing in cryptography, public key infrastructure, and risk management. He can be reached atandrew@ cryptonym.com.</I><hr><p>As cryptosystems become increasingly widespread in all aspects of information security, elliptic-curve cryptography is quickly entering the mainstream. In this article, I'll compare the advantages and disadvantages of elliptic-curve cryptography to other cryptosystems. By selecting and validating different curves step-by-step, you will see how elliptic-curve cryptosystems (ECC) are built, and that they require only slightly more complicated math than traditional integer-based cryptosystems.</p><h3>Mathematics of Elliptic Curves</h3><p>Before diving into the details of elliptic curves (EC), I'll first review the relevant algebra. For a more in-depth look, see Certicom's excellent tutorial at http:// www.certicom.com/ecc/index.htm. </p><DDJADVERTISEMENT INLINE><p>Much cryptography, elliptic curve included, is based on the idea of a mathematical group. A group is a set of objects and a combining rule that takes two objects and produces a third. Examples of groups used in cryptography are:</p><ul>  <li>Adding pairs of integers modulo <i>n</i>, called the <i>Z<sub>n</i></sub> group.   <li>Multiplying pairs of nonzero integers modulo <i>p</i>, where <i>p</i> is prime, called the <i>Z<sup>*<sub>p </i></sub></sup>group.</ul><p>With these, the group operation can be written in either additive or multiplicative form. In a multiplicative group, given <i>x=y<sup>z</i></sup>, we would say the logarithm base <i>y </i>of <i>x </i>is <i>z</i>. However, if we used additive instead of multiplicative notation, then <i>x=z</i>&times;<i>y</i>. Confusingly, mathematicians still refer to <i>z</i> as the discrete log of <i>x</i>. This distinction between additive and multiplicative notations is important because traditional cryptography uses groups with multiplicative notation, while ECC deals with additive notation.</p><p>If a group has two operations, and not just one, you call the set and its operations a "ring." For instance, both addition and multiplication work in <i>Z<sup>*<sub>p</i></sub></sup>, which is both a group and a ring. Finally, if division always works in the ring, so that every nonzero element <img src="alpha18.gif" width="10" height="8"> in the ring has a multiplicative inverse <img src="alpha18.gif" width="10" height="8"><sup>-1</sup> in the ring such that <img src="alpha18.gif" width="10" height="8">&times;<img src="alpha18.gif" width="10" height="8"><sup>-1</sup>=1, we call the ring a "field." Examples of familiar fields are the rational, real, and complex numbers. If the field has a finite number of elements, it is called a "finite field" or "Galois field." Elliptic curves in cryptography are formed using elements from Galois fields.</p><p>One familiar example of a Galois field is the ubiquitous <i>Z<sup>*<sub>p</i></sub></sup>, which happens to be a group, a ring, and also a field. When using <i>Z<sup>*<sub>p </i></sub></sup> as a Galois field, we often write  <i>GF(p)</i> instead of <i>Z<sup>*<sub>p</i></sub></sup>. A less familiar example of a field is found in the polynomials</p><blockquote><img src="9912dq1.gif" width="30" height="41" align="middle">  <i>c<sub>i</sub>x<sup>i</i></sup> of degree <i>n</i></blockquote><p>where each coefficient<i> c<sub>i</i> </sub>is an element from <i>GF(p),</i> and <i>x </i>is an indeterminate value. This polynomial field is built by extending the field <i>GF(p)</i>, so it is called an extension field and is denoted by<i> GF(p<sup>n</sup>)</i>. For an example of how multiplication works in this field, see <A NAME="rf1"><A HREF="9912df1.htm">Figure 1</A>. In <i>GF(p<sup>n</sup>)</i>,  <i>p </i>is called the field characteristic, and <i>n </i>is called the extension degree.</p><p>Galois fields are used in cryptography to build elliptic curves. The connection is provided by the definition of an elliptic curve. Elliptic curves are defined as a combination of three things:</p><ul>  <li>The set of points <i>(x,y) </i>that satisfy the equation <i>y</i><sup>2</sup>+<i>a</i><sub>1</sub><i>xy</i>+<i>a</i><sub>3</sub><i>y=x</i><sup>3</sup>+<i>a</i><sub>2</sub><i>x</i><sup>2</sup>+<i>a</i><sub>4</sub><i>x</i>+<i>a</i><sub>6</sub>, where <i>x, y,</i> and the coefficients <i>a<sub>i</sub> </i>are all from <i>GF(p<sup>n</sup>)</i>.  <li>A special point <i>O </i>called the "point at infinity."  <li>A special addition operator <img src="xor12.gif" width="8" height="8" hspace="3" vspace="3"> that adds these points together.</ul><p>We say that the <i>m</i>+1 points <i>E</i>={<i>O,(x</i><sub>1</sub>,<i>y</i><sub>1</sub><i>), (x</i><sub>2</sub>,<i>y</i><sub>2</sub><i>),...,(x<sub>m</sub>,y<sub>m</sub>)</i>} are the points on the elliptic curve, and the group <i>E </i>has order <i>m</i>+1. Within <i>E</i>, we can add two points together using the <img src="xor12.gif" width="8" height="8"> operator, so that <i>(x<sub>i</sub>,y<sub>i</sub>)</i><img src="xor12.gif" width="8" height="8"><i>(x<sub>j</sub>,y<sub>j</sub>)=Cx<sub>k</sub>,y<sub>k</sub>)</i>. In other words, points on the elliptic curve are a group. The special point <i>O </i>is the group's additive identity -- it acts the way zero does in normal integer addition, giving <i>(x<sub>i</sub>,y<sub>i</sub>)</i><img src="xor12.gif" width="8" height="8"><i>O=(x<sub>i</sub>,y<sub>i</sub>)</i> for every point on the elliptic curve.</p><h3>Pros and Cons of  Elliptic-Curve Cryptography</h3><p>Traditionally, cryptosystems such as the Digital Signature Algorithm (DSA), Diffie-Hellman key exchange (DH), or El Gamal encryption are implemented over the group <i>Z<sup>*<sub>p</i></sub></sup>. Each of these cryptosystems relies on the difficulty of taking discrete logarithms in <i>Z<sup>*<sub>p</i></sub></sup> for their security. In contrast, elliptic-curve cryptosystems replace <i>Z<sup>*<sub>p</i></sub></sup> with the elliptic curve group <i>E</i>. If a computer can perform addition in <i>E </i>faster than multiplication in <i>Z<sup>*<sub>p</i></sub></sup>, then a cryptosystem implemented over <i>E</i> should be proportionally faster than in <i>Z<sup>*<sub>p</i></sub></sup>. For some estimates, see "Elliptic Curves and Cryptography," by Aleksandar Jurisicand Alfred Menezes (<i>DDJ</i>, April 1997).</p><p>The potential speed increase is impressive. In <i>Z<sup>*<sub>p</i></sub></sup>, the fundamental cryptographic operation is exponentiation, and much effort has been spent to make this operation as fast as possible. In <i>E</i>, the fundamental cryptographic operation is multiplication, and the numbers we multiply are much smaller. According to the IEEE P1363 working group, the effort needed to crack a 254-bit EC system is about the same for a 2800bit <i>Z<sup>*<sub>p</i></sub></sup> system -- about 5.5&times;10<sup>24</sup> MIPS years. Since addition in either group is an <i>O(n log</i><sub>2</sub>3<sup><img src="approx18.gif" width="13" height="6" hspace="3" vspace="3">1.585</sup><i>)</i> to <i>O(n</i><sup>2</sup><i>)</i> process, we could expect an elliptic-curve cryptosystem to be43 to116 times faster than its traditional counterpart. However, since EC addition needs more computational steps than <i>Z<sup>*<sub>p</i></sub></sup> addition, the ratio theoretically drops from 43-116 to 4-10.</p><p>Not only should ECC be faster than traditional cryptosystems, but most cryptographers believe that calculating discrete logs in <i>E</i> is fundamentally harder than in <i>Z<sup>*<sub>p</i></sub></sup>. To calculate discrete logs in <i>Z<sup>*<sub>p</i></sub></sup>, the difficult job is to find a factor base for <i>p</i>. Once found, calculating a discrete log in <i>Z<sup>*<sub>p</i></sub></sup> is a fast and simple process. The group becomes broken for all future cryptographic work. In contrast, nobody knows how to find a factor base for elliptic-curve groups, nor do mathematicians believe any such algorithm would be tractable. Finding the discrete log of one element in <i>E </i>will not help find the logarithm of any other element. In fact, let <i>#E</i> denote group order of <i>E</i>, and let <i>r </i>be the largest prime factor of <i>#E.</i> Then the best known algorithms for finding discrete logs in <i>E </i>have complexity <i>O(<img src="sqrt12.gif" width="7" height="10">r/n)</i>, where <i>n </i>is the number of processors working on the problem.</p><p>Mathematics aside, the real strength of ECC comes from the small size of EC cryptographic keys. A mere 256 bits can represent a 255-bit EC public or private cryptographic key. To achieve equivalent security, a <i>Z<sup>*<sub>p</i></sub></sup> cryptosystem would need over 2800bits. Such a ten-fold savings in size can be crucial when designing smartcard or embedded security systems. Smaller keys need smaller amounts of secure storage for archiving, and need smaller arithmetic units for processing. Using ECC, digital certificates are smaller and cryptographic operations are faster. These time and space efficiencies are the reason that EC cryptography is spreading rapidly in e-commerce.</p><p>On the other hand, for each prime number <i>p</i>, there is only one group <i>Z<sup>*<sub>p</i></sub></sup> but a huge number of different elliptic curve groups <i>E</i>. In fact, when implementing an EC cryptosystem, the chief problem is actually picking which curve or family of curves you want to deal with. Different curves are suitable for different purposes, and because every application has different requirements, no elliptic curve can be optimal for all applications. In fact, a large portion of EC research involves finding particular families of curves that are computationally efficient. So how do you pick a curve for a particular application?</p><h3>How to Pick an Elliptic Curve</h3><p>There are two major curve families used in cryptography: binary curves constructed from <i>GF(</i>2<sup><i>m</sup>)</i>, and prime curves constructed from <i>GF(p<sup>n</sup>)</i>, where <i>p </i>is a prime greater than 3 and <i>n </i>is usually 1. Binary curves are the best choice for hardware applications, where it takes remarkably few logic gates to create a powerful and incredibly fast cryptosystem. In software, prime curves are faster because the extended bit-fiddling operations needed by binary curves are not necessary. Here, I'll focus on prime curves, since it was a software-based project of mine that prompted this article.</p><p>In a prime field, a little algebra reduces the elliptic-curve equation from the form <i>y</i><sup>2</sup>+<i>a</i><sub>1</sub><i>xy</i>+<i>a</i><sub>3</sub><i>y</i>=<i>x</i><sup>3</sup>+<i>a</i><sub>2</sub><i>x</i><sup>2</sup>+<i>a</i><sub>4</sub><i>x</i>+<i>a</i><sub>6</sub> to the form <i>y</i><sup>2</sup>=<i>x</i><sup>3</sup>+<i>Ax</i>+<i>B</i>, where <i>A,B</i><img src="memof12.gif" width="8" height="8"><i>GF(p<sup>n</sup>)</i> and 4<i>A</i><sup>3</sup>+27<i>B</i><sup>2</sup><img src="noteq.gif" width="10" height="12">0. Therefore, you need to pick four parameters <i>A, B, p, </i>and <i>n </i>to select a particular curve. If <i>n</i>&gt;1, the extension polynomial must also be chosen (see <A NAME="rf2"><A HREF="9912df2.htm">Figure 2</A>). Not all parameters are equally secure, nor do they result in curves with equally efficient operations. In fact, when selecting values for the curve parameters, efficiency and security are often traded off against each other, sometimes in surprising ways.</p><p>Not just any values of <i>A,</i> <i>B, p, </i>and <i>n </i>can be used for cryptography. If the order of the curve group happens to be exactly equal to <i>p, </i>the curve is called anomalous and is prone to subexponential discrete logarithm algorithms. Similarly, if the curve does not satisfy the Menezes-Okamoto-Vanstone (MOV) condition, or if the curve is supersingular, it is unsuitable for cryptography. Fortunately, the vast majority of curves are secure, and it is simple and fast to validate the security of a given curve.</p><p>As cryptographers, we need to assume that even if a cryptosystem is safe today, it may not be safe tomorrow. For instance, EC operations in a prime field are fastest when <i>p</i><img src="equiv12.gif" width="9" height="5">3mod4 and <i>A</i>=0. Such curves are said to have complex multiplication discriminant 3 (CM3). Theoretically, these CM3 curves are just as secure as any other elliptic curve. A true paranoid would be worried, however, because given any finite field, mathematicians have shown that there are only six different CM3 curves. Although we may have millions of choices for <i>B </i>yielding millions of curves, each curve is isomorphic to one of just six different curves. Cryptographers already know how to attack certain specialized curves, such as the supersingular, MOV, or anomalous curves. CM3 curves are arguably a very restricted curve family, so they may be the next to fall to mathematical cryptanalysis. I am not implying that CM3 curves are insecure. They just seem like a good target for concerted mathematical attack over the next 10 to 20 years.</p><p>Another family of prime field curves with efficient computational properties are those that have <i>n</i>=1 and <i>A</i><img src="equiv12.gif" width="9" height="5">-3mod<i>p</i>. These curves aren't quite as algorithmically efficient as the CM3 curves, but there are a lot more of them. Depending on <i>p</i>, up to 1/2 of all curves can be rescaled to have this value for <i>A</i>. Therefore, any attempt to find an algorithm for fast discrete logs with these curves would have to be very general in application, weakening ECC in its entirety. It's very unlikely that any such attack is forthcoming.</p><p>These security considerations suggest selecting <i>n</i>=1 and <i>A</i><img src="equiv12.gif" width="9" height="5">-3mod<i>p</i> for long-lived, software-based ECC applications. For picking specific EC and cryptosystem parameters, there are only two guides: Make it fast and make it efficient.</p><h3>Picking Cryptosystem Parameters</h3><p>With the goal of speed in mind, Daniel Bailey and Christof Paar presented an interesting paper at the CRYPTO'98 conference. They suggested using primes of the form <i>p</i>=2<sup><i>n</i></sup>&plusmn<i>c</i> and extension polynomials of the form <i>x<sup>m</i></sup>-<img src="omega12.gif" width="9" height="7"> to form the elliptic curve's base field. That way, the base <i>p </i>modular reductions could be done rapidly using the Mohan-Adiga algorithm in <A NAME="rf3"><A HREF="9912df3.htm">Figure 3</A>. Reducing polynomials modulo the monomial <i>x<sup>m</i></sup>-<img src="omega12.gif" width="9" height="7">  can also be accomplished very quickly using the identity</p><blockquote><img src="9912dq2.gif" width="357" height="48"></blockquote><p>Using Bailey and Paar's techniques, I found that <i>p</i>=2<sup>31</sup>-1 with an extension of  <i>x</i><sup>7</sup>-(2<sup>24</sup>+1) gave an EC group size of about 217 bits -- equivalent to using a 108-bit symmetric key. This field is also very efficient to work with on 32-bit processors. Unfortunately, ECC using primes of the form 2<sup><i>n</i></sup>-<i>c</i> for <i>c</i>&gt;-1 has been patented, a fact unnoticed by many researchers. I did find other suitable fields, such as <i>GF</i>(2<sup>31</sup>+209) with extension <i>x</i><sup>7</sup>-5, but none had the efficiency of <i>GF</i>(2<sup>31</sup>-1). The lesson to learn here is that you must always be aware of the intellectual property you are using. </p><p>Fortunately, the Mohan-Adiga algorithm is equally efficient with positive or negative values of <i>c</i>, and primes of the form <i>p</i>=2<sup><i>n</i></sup>+<i>c</i> with <i>c</i>&gt;2 are still free for use. However, given the upcoming popularity of 64-bit processors, why limit our cryptosystem to efficiency on 32-bit CPUs? Instead, are there any <i>GF(p) </i>fields with suitable characteristics that enable fast computation?</p><p>When selecting EC parameters, you have to pick curves where you can quickly calculate the exact EC group order. Although algorithms are known for counting the elements of an arbitrary elliptic curve, the procedures are rather complicated and require <i>O(ln</i><sup>8</sup><i>n)</i> time. For two certain families of curves, it is much easier to find <i>#E</i>. In the first case, if <i>p </i>is small and <i>n</i>&gt;1 in <i>GF(p<sup>n</sup>)</i>, you can use the relation between the base field and the extension field to quickly count the curve's points. In the second case, you look for curves with a known complex multiplication discriminant. CM3 curves, for instance, have complex multiplication discriminant 3, which means there is a simple formula for counting the elements. The P1363 draft describes simple algorithms for finding the CM discriminant of many curves. I used the techniques specified in the draft to find the group orders of my test curves.</p><p>Furthermore, I looked at primes for which Mohan-Adiga reduction is particularly efficient. Because <i>c</i>&gt;2, maximum efficiency implies that the algorithm's bit shifting should be as fast as possible. Using a patient trial-and-error search, I found two potential candidates. The first was <i>p</i>=2<sup>248</sup>+81, where I found many curves with group sizes of 245 to 249 bits. Because 248 is divisible by 8, the right shifts required by the Mohan-Adiga algorithm could be implemented as byte-oriented memory moves. Unfortunately, using memory moves instead of bit shifts would only be possible if the storage pattern of the <i>GF(p) </i>integer matched the endianness of the CPU. Because I didn't want to maintain different large-integer libraries for different CPUs, I decided to pick another value for <i>p. </i>Finally, I selected <i>p</i>=2<sup>255</sup>+95 to serve as my base field.</p><p>The prime <i>p</i>=2<sup>255</sup>+95 has many computational advantages over other field characteristics.</p><ul>  <li>The prime <i>p</i><img src="equiv12.gif" width="9" height="5">3mod4, which means that  calculating square roots in <i>GF(p) </i>is simple and there is a good chance we can find a secure curve where <i>A</i><img src="equiv12.gif" width="9" height="5">-3mod<i>p</i>.  <li>Each element <i>x</i><img src="memof12.gif" width="8" height="8"><i>GF(p)</i> can be represented by a 256-bit array. This array is easily partitioned into 16-, 32-, or 64-bit words for big-integer libraries.  <li>The 256-bit array is ideal for <i>O(nlog</i><sub>2</sub>3<sup><img src="approx18.gif" width="13" height="6">1.585</sup><i>)</i> Karatsuba-Ofman multiplication, regardless of the native word size of the target CPU.  <li>The right shifts can be implemented as a 256-bit aligned memory move, followed by a 1-bit left shift. This operation is relatively endian independent, and can be accelerated in assembly language.</ul><p>These advantages are tempered by two small disadvantages:</p><ul>  <li>Right-shifting 255 times requires two passes through the array holding the <i>GF(p) </i>large integer.  <li>Multiplication by <i>c</i>=95 is not particularly fast, although since <i>c </i>fits within a single byte, multiplying an element of <i>GF(p) </i>by <i>c </i>is a linear-time operation.</ul><p>While sorting through various CM discriminants, I found that <i>GF</i>(2<sup>255</sup>+95) allows the construction of a curve that has complex multiplication by 1318, yielding a curve with a 254-bit prime factor of the group order. This is remarkably useful, since it means that 254 bits of our 256-bit operations are contributing to the cryptosystem's security. Calculating logs in this group is as difficult as brute force guessing a 127-bit symmetric key. It's been estimated that for data to remain secure for the next 20 years, the effective key size of an algorithm should be at least 90 bits. An effective key size of 127 bits is comfortably larger than this estimate. As an added bonus, the technique of point compression lets you represent the 510 bits of any EC point <i>(x,y)</i><img src="memof12.gif" width="8" height="8"><i>E</i> with exactly 256 bits, and, therefore, it fits evenly in any byte array.</p><p>I've implicitly assumed that the cryptosystem I'm building will have shared parameters for a group of users. They will all use the same curve, and hopefully all use the same base point. These shared-parameter cryptosystems are accepted in the cryptocommunity as secure; so much so that even the DSA allows them. However, they definitely present an attractive target for a cryptanalyst to attack, so it's important that any shared-parameter cryptosystem have some security wiggle room. In my case, if the complexity of taking discrete logs in the curve group was mathematically reduced by even a huge <img src="approx18.gif" width="13" height="6">2<sup>32</sup>, the cryptosystem will still be quite secure.</p><p>The specific curve and cryptoparameters I chose are in <A NAME="rf2"><A HREF="9912df2.htm">Figure 2</A>. I managed to find a base point of appropriate order with an x<i>-</i>coordinate of two. This base point is nice for embedded systems, where secure memory holding cryptoparameters is a scarce resource. With this choice of base point, only the y-coordinate needs permanent secure storage. Alternatively, the y-coordinate could be generated in situ by selecting the smaller square root of <i>z=x</i><sup>3</sup><i>+Ax+B</i>. Since <i>p</i><img src="equiv12.gif" width="9" height="5">3mod4, it is simple to calculate <img src="sqrt12.gif" width="7" height="10"><i>z</i>=&plusmn;(<i>z</i><sup>(<i>p</i>+1)/4</sup>)mod<i>p</i>, and select the smaller root (in this case, the positive one). Therefore, of all the parameters in <A NAME="rf2"><A HREF="9912df2.htm">Figure 2</A>, only <i>B </i>needs to be stored as a full-sized large integer. In fact, only one of <i>B </i>or <i>g<sub>y </i></sub>needs to be stored in secure memory. However, without <i>B, </i>it is impossible to determine if any given input coordinate really is on our elliptic curve. Therefore, it is probably more secure to keep <i>B </i>in memory, use it to generate <i>g<sub>y</sub>, </i>and also use it to validate any other input EC point.</p><h3>Real-World Comparisons</h3><p>Cryptographic literature is full of theoretical calculations estimating how much faster EC algorithms should be over their traditional counterparts. Many of these comparisons are misleading because they do not compare security-equivalent cryptosystems, and implementing a cryptosystem usually requires a lot of CPU-dependent programming. To do a fair comparison, I decided to benchmark Certicom's Elliptic Curve Digital Signature Algorithm (ECDSA), implemented with my 255-bit curve, against the standard DSA algorithm at <i>p</i>=2048 bits, with a subgroup of <i>q</i>=256 bits. Theoretically, 255 EC bits are equal to more than 2800 <i>Z<sup>*<sub>p</i></sub></sup> bits, but a real programmer would stick to 2048 bits allowing the fastest possible use of Karatsuba-Ofman multiplication. Further, the DSA standard specifically forbids moduli greater than 1024 bits or subgroups larger than 160 bits, because DSA is based on the 160-bit SHA1 hash function (which itself provides only 80 effective bits of security). However, we are interested in raw speed comparisons, so signing and verifying longer hashes should only accentuate any speed difference.</p><p>The points on an elliptic curve actually have two different representations, each of which has very different computational characteristics. The normal <i>(x,y) </i>pairs we have been discussing, called "affine coordinates," are most commonly seen in discussions of curves over finite fields. There is another representation of the point, called "projective coordinates," where the triplet <i>(x,y,z)</i> satisfies the modified equation <i>y</i><sup>2</sup><i>z=x</i><sup>3</sup>+<i>Axz</i><sup>2</sup><i>+Bz</i><sup>3</sup>. We can translate between affine and projective coordinates using the relation <i>(x,y)«(x<img src="lambda.gif" width="8" height="11"></i><sup>2</sup><i>,y<img src="lambda.gif" width="8" height="11"></i><sup>3</sup><i>,<img src="lambda.gif" width="8" height="11">) </i>for any <i><img src="lambda.gif" width="8" height="11"></i><img src="noteq.gif" width="10" height="12">0. By convention, we set <i><img src="lambda.gif" width="8" height="11"></i>=1 for equating the two. The reason for using projective coordinates over affine has to do with how the EC points are added together. Using affine coordinates, two to three field multiplications and one field inversion are needed to add EC points. Using projective coordinates, no field inversions and 11 to 16 field multiplications are needed to add EC points. If field inversion is a relatively slow operation, it may be faster to use projective coordinates despite the larger number of multiplications.</p><p>The results of six test cases run over three slightly different CPUs are shown in <A NAME="rt1"><A HREF="9912dt1.htm">Table 1</A>. All the tests were compiled with egcs-1.1.1 under Linux-2.2.5/glibc-2.1.1. The large-integer library came from the GNU Privacy Guard (GnuPG) project (http://www.gnupg.org/), Version0.9.5. Hand-optimized assembler code was available and used for the major time-critical functions of the library. The table compares both the absolute and relative speeds of performing signature and verification operations between:</p><ul>  <li>The standard DSA with <i>p/q </i>values of1024/160 and2048/256.  <li>My ECDSA system in using either projective or affine coordinates.  <li>For each ECDSA coordinate representation, a trial using the Mohan-Adiga algorithm or GnuPG's standard modular reduction algorithm.</ul><p>The CPU row shows the speed of DSA-1024 normalized to the fastest processor. Otherwise, the CPU time results are shown normalized to the speed of DSA-1024. The three processors are a:</p><ul>  <li>Celeron with 128K L2 cache at 450/75MHz core/bus frequency.  <li>P-II with 512K L2 cache at 266/66 MHz.  <li>Mobile P5 with 512K L2 cache at 166/66 MHz.</ul><p>The first interesting result is that all the cryptosystems tested fit comfortably into the Celeron's relatively tiny 128-KBL2 cache. Across each CPU family, the relative speed of each operation was essentially constant and was simply a multiple of the CPU core frequency ratios; thus, it is clear that each cryptosystem occupies relatively little L2 cache.</p><p>The next interesting conclusion is that using the special modular reduction algorithm is no faster, and in some cases slower, than the GnuPG's modular reduction algorithm for arbitrary bases. Although the trials presented in <A NAME="rt1"><A HREF="9912dt1.htm">Table 1</A> do not use forced function inlining for the Mohan-Adiga algorithm, my experiments with forced full inlining indicate function call overhead is responsible for only5 to 7 percent of the overall calculation time. It seems that using a special form for <i>p </i>does not seriously affect the speed of the EC cryptosystem for an optimized large-integer library.</p><p>With respect to comparing affine and projective coordinates, the projective coordinates are much faster to use than affine, giving an eight-fold increase in speed despite the large number of modular multiplications that the technique uses. Run-time profiles of the executables show a huge amount of time spent in the modular inversion step for the affine case, as expected. In the projective case, 90 percent of the computation is evenly split between large-integer multiplication, addition, and modular reduction, each of which is a highly optimized subroutine in its own right.</p><p>Testing ECDSA against DSA showed a surprising result: At its fastest, my ECDSA was between 25 and 80 percent slower than DSA-1024. Of course, at 1024 bits, DSA does not provide the security of a 254-bit EC scheme. Comparing apples to apples, ECDSA clocked well over twice as fast as the security-equivalent DSA-2048. Although interesting, this factor of two falls far short of the four- to eight-fold speedups often talked about in EC whitepapers.</p><p><A NAME="rt2"><A HREF="9912dt2.htm">Table 2</A></p><h3>Conclusion</h3><p>Software-based prime field elliptic-curve cryptosystems seem to be more efficient than traditional cryptosystems at high levels of security. The small sizes of their public and private keys are a definite advantage, although one that holds only if all ECC users agree on a common set of EC parameters. If EC parameters need to be negotiated on a message-to-message basis, the additional information needed to specify the exact elliptic curve may make the effective EC key size almost as large as a key in <i>Z<sup>*<sub>p</i></sub></sup>.</p><h3>References</h3><p>IEEE draft standard P1363: <i>Standards for Public-Key Cryptography</i>, available at http:// stdsbbs.ieee.org/groups/1363/index.html.</p><p>Koblitz, Neal. <i>Algebraic Aspects of Cryptography</i>. Springer-Verlag, 1998.</p><p> --  --  -- . <i>A Course in Number Theory and Cryptography</i>, Second Edition. Springer-Verlag, 1994.</p><p>Menezes, Alfred. <i>Elliptic Curve Public Key Cryptosystems</i>. Kluwer Academic Publications, 1993.</p><p>Menezes, Alfred, vanOorschot, Paul, and Vanstone, Scott. <i>Handbook of Applied Cryptography</i>. CRC Press, 1997.</p><p><b>DDJ</b></p></body></html>