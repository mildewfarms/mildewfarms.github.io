<html><head><title>January, 2006: Detecting  Potential Deadlocks</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><p><i>Dr. Dobb's Journal</i>, January 2006</p><h1>Detecting  Potential Deadlocks</h1><h2>Uncovering problems before they occur </h2><h3>By Tomer Abramson </h3><I>Tomer is a software engineer for Verint Systems. He can be contacted at tomer.abramson@verint.com.</I><hr><p>One of the hardest problems to solve in multithreaded programming is that of deadlocks. While there are numerous applications that detect and analyze deadlocks, most (if not all) of them perform a "post" deadlock analysis. In other words, they analyze deadlocks after they occur.</p><p>There's a problem with this approach. For instance, the following code (where <i>T</i> is for Thread, <i>R</i> for Resource) contains a potential deadlock. However, you can run it 100 times and it will not deadlock. This means that tools that perform post-deadlock analysis will not report on the problem.</p><blockquote>T1:         T2:<br>Lock(R1)  Lock(R2)<br>Lock(R2)  Lock(R1)<br><br>Main()<br>Run(T1); <br>Run(T2);<br></blockquote><p>Post-deadlock analysis forces you to have deadlock detection applications constantly running. If deadlock did not occur during the debug session, you must continue using the deadlock detection application in release versions as well, something that can be problematic in terms of performance issues, stability, and the like.</p><p>The solution is to use tools that detect potential deadlocks every time the code is executed, even if no deadlock occurred during execution time. In this article, I present the Deadlock Detection Application (DDA), which detects potential deadlocks before they occur. (The complete source code for the DDA is available electronically; see "Resource Center," page 4.)</p><p>As <a name="rf1"></a><a href="0601nf1.html">Figure 1</a> illustrates, the DDA contains the following components:</p><ul>  <li>DDA Agent. Initializes and terminates the DDA. This is the only component from the DDA used directly by the application.  </li>  <li>DDA Manager. Manages the main flow of the DDA. </li>  <li>DDA View. Implements a simple GUI and notifies the DDA Manager about user actions.</li>  <li>Locks Logger. Keeps a log of each lock/unlock operation made in the application.</li>  <li>Lock Data Queue. The queue is the object through which the application communicates with the DDA. The application passes to the queue information about each lock/unlock operation. The DDA Logger retrieves the information from the queue and stores it for future use.</li>  <li>Lock Sequence Builder. Receives as input the locks information in the format that the logger holds, and translates it to a new format called "lock sequence."</li>  <li>Lock Sequence Analyzer. Takes as input a list of lock sequences, analyzes them, and decides if the application contains a potential deadlock. If so, the analyzer returns the deadlock cycle.</li></ul><p>The DDA program flow is: When the application starts to run, the DDA hooks all synchronization functions (<i>WaitForSingleObject(), CreateMutex()</i>, and so on). Once functions are hooked, each lock operation triggers an event that inserts the lock's info into the queue from which the DDA's logger pulls data. This way, the DDA tracks each and every lock operation in the application. </p><p>You then perform a few tests. When you finish running the tests, you tell the DDA (via a simple GUI) to start analyzing the collected information. The DDA analyzes the locks and searches for potential deadlocks. If a potential deadlock is detected, then the DDA tells you and displays a detailed description of the test that leads to a deadlock.</p><h3>The Algorithm</h3><p><a name="re1"></a><a href="0601ne1.html">Example 1</a> contains a potential deadlock that occurs with the following scenario: <i>T1</i> executes lines 1 to 3. At this point, <i>T1</i> locks <i>R1</i>. <i>T2</i> executes line 1. <i>T2</i> then locks <i>R3</i>. Now <i>T1</i> tries to lock <i>R3</i> (in line 4) while <i>R3</i> is locked by <i>T2,</i> and <i>T2</i> tries to lock <i>R1</i> (in line 2) while <i>R1</i> is locked by <i>T1</i>. The application is deadlocked.</p><p>Now assume a different scenario: <i>T2</i> starts to run only after <i>T1</i> has completed. In this scenario no deadlock occurs. </p><p>In the first phase, the DDA tracks and logs all lock/unlock operations in the application. In the second phase, the DDA has a list for each thread, where each list contains the lock/unlock operations performed by the thread (<i>L</i>=Lock, <i>U</i>=Unlock, <i>T</i>=Thread, <i>R</i>=Resource):</p><blockquote>T1: L(R1), L(R2), U(R2), L(R3), L(R4), U(R1), U(R3)<br>T2: L(R3), L(R1), U(R3), L(R2), U(R2), U(R1)<br></blockquote><p>In this second phase, the DDA uses logger information to find all the lock sequences in the application. A lock sequence represents the current resources locked by a specific thread at a given time. If you have a lock sequence of (<i>R1, R2</i>), it means that at a specific time during execution there was a thread that locked resources <i>R1</i> and <i>R2</i> (in this specific order!). For example:</p><blockquote>Lock(R1)    // curr lock sequence: R1 <br>Lock(R2),   // curr lock sequence: R1, R2<br>Unlock(R2) // curr lock sequence: R1<br>Lock(R3)    // curr lock sequence: R1, R3<br></blockquote><p>Lock sequences that are subsequences of other sequences are dropped. </p><p>This example has four lock sequences:</p><blockquote>1.  T1:  R1, R2<br>2.  T1:  R1, R3, R4<br>3.  T2:  R3, R1<br>4.  T2:  R1, R2<br></blockquote><p>Now you are ready to search for potential deadlocks, which exist if the lock sequences contain cyclic dependencies. The most intuitive way to check for such cycles is to represent the lock sequences as a directed graph. A node in the graph is a resource, while a directed vertex is drawn from a resource in the lock sequence to the next resource in the sequence. For a simple lock sequence such as<i> R1, R2,</i> the graph looks like<i> R1-&gt;R2</i>. The graph that corresponds to the lock sequences in the example is:</p><blockquote>R1  -&gt; R2<br><br>^|<br>|v <br><br>R3  -&gt; R4<br></blockquote><p>It is easy to see that the graph contains the cycle <i>R1-&gt;R3-&gt;R1</i>, which represents a potential deadlock upon which the DDA reports.</p><h3>Implementation</h3><p>The DDA, which was developed and tested with Visual C++ 6 under Windows 2000, was implemented in a separate DLL. The DDA is initialized by defining in the application a global object of type <i>DDAAgent</i>, a simple class that starts the DDA in the constructor and terminates it in the destructor. This is the only class that the DDA DLL exports. The rest of the communication between the application and the DDA is done via the Windows messaging queue.</p><p>When the application performs lock/unlock, a notification is sent to the queue. To make the operation of sending a notification to the queue transparent to the application, the DDA wraps all synchronization functions by hooking them. The hooking function technique (introduced and implemented by John Robbins in his <i>MSDN</i> October 1998 "BugSlayer" column) lets you take control over a function (or set of functions) so that each call to the function is routed to another function that you defined. </p><p>To illustrate how hooked functions are used by the DDA, I focus on <i>WaitForSingleObject().</i> Listing One (available electronically) presents the function <i>MyWaitForSingleObject(),</i> which acts as a wrapper for <i>WaitForSingleObject()</i> that is called every time the application calls <i>WaitForSingleObject().</i> </p><p><i>MyWaitForSingleObject()</i> gets the same parameters as <i>WaitForSingleObject().</i> What this function does is collect information about the lock action (such as the ID of the locking thread, the handle to the locked resource, the stack trace, and so on), encapsulates the information into the structure <i>LockData</i>, and sends the information to the DDA via the queue. Finally, it calls the original <i>WaitForSingleObject()</i>. This flow is similar for all the hooked functions: getting lock information, sending information to the DDA via the messaging queue, and calling the original function. The complete set of functions can be found in the file hookedFunctions.cpp (also available electronically).</p><p>Again, <i>LockData</i> is the structure that encapsulates all the information about the lock. If you want to add additional information about each lock, just add new fields to the <i>LockData</i> (implemented in lockData.h; available electronically). </p><p>On the DDA's side of the queue, the logger runs in a separate thread, retrieves lock data from the queue, and stores it in a list. There is a separate list for each thread: If a lock operation was made by thread <i>X</i>, its lock data is saved in a different list than if the operation was made by thread <i>Y</i>. The <i>locksLogger</i> class (available electronically) is implemented as a Singleton, meaning there could be only one instance of it in the application. This is done to assure that all information about the locks is stored in one place.</p><p>The main flow of the DDA is determined by <i>DDAMgr</i>, which is responsible for hooking the functions at start time and unhooking them on termination. It also controls the logger and notifies it when to start/stop. To analyze the information stored in the logger, <i>DDAMgr</i> uses the <i>LockSequenceBuilder</i> and <i>LockSequenceAnalyzer</i> helper classes. The builder transforms the info stored in the logger into a lock sequence, and the analyzer looks for cycles in the lock sequences. I used STL lists to implement the lock sequences and the lists of lock data.</p><h3>Integrating the DDA</h3><p>As <a name="re2"></a><a href="0601ne2.html">Example 2</a> illustrates, to integrate the DDA into your application, you need to perform three steps:</p><ol>  <li>Add the lib DAA.lib to your project settings (under the link tab, in the object/library modules field).</li>  <li>Add to the file that contains your <i>main()</i> function an <i>#include</i> to the DDAAgent.h file.</li>  <li>Declare a global object of type <i>DDAAgent</i>.</li>  </ol><p>To benefit from the DDA, you must produce .pdb files for your application. This is necessary to get the stack trace for problematic locks. I've also included a directory named "Integration" that contains all the components needed for the integration: DDA.lib, DDA.dll, and DDAAgent.h (the dll and lib were compiled in debug mode). </p><h3>Using the DDA</h3><p>Once you've integrated the DDA into your application, it runs automatically when you launch the program. Once the application is running, you will see the DDA GUI (<a name="rf2"></a><a href="0601nf2.html">Figure 2</a>) in the upper left corner of the screen. Exercise your application by running a few scenarios. When you want the DDA to analyze the scenarios, push the Stop button from the GUI. If there is a potential deadlock, the DDA pops up a message box with a detailed description about the deadlock cycle (<a name="rf4"></a><a href="0601nf4.html">Figure 4</a>). If you do not press Stop, the DDA automatically checks for potential deadlocks when you exit the application. If you see "Error-Disabled!," the DDA has failed to initialize and is not functional. Also, the DDA works in debug and release mode.</p><h3>Example</h3><p>To demonstrate the power of the DDA, I've provided a demo program (see Listing Two; also available electronically) that includes three mutexes and three threads. Each thread performs the following locks:</p><blockquote>Thread1: Lock(Mutex1), Lock(Mutex2)<br>Thread2: Lock(Mutex2), Lock(Mutex3)<br>Thread3: Lock(Mutex3), Lock(Mutex1)<br></blockquote><p><a name="rf3"></a><a href="0601nf3.html">Figure 3</a> is the output of the demo program. Although this scenario contains a potential deadlock (the cycle: <i>Mutex1-&gt; Mutex2-&gt; Mutex3-&gt; Mutex1</i>), the application terminates successfully (no deadlock occurred). The DDA detects the potential deadlock and prompts you.</p><p>The DDA's output (<a name="rf4"></a><a href="0601nf4.html">Figure 4</a>) shows you each lock that is part of the deadlock cycle (all locks, in this case). For each lock it shows the handle to the locked object, the ID of the locking thread, and the most important thing&#151;where in the code the lock was performed (if desired, the DDA can display a full stack trace for each lock). As part of the example, I've included a directory named "Test" that contains the compiled test application. (The test was compiled in debug mode. You must have Visual C++ installed on your computer in order to run it.)</p><h3>Caveats</h3><p>The DDA still needs some work to execute perfectly. For now, it does not support <i>WaitForMultipleObjects()</i> or events. While the DDA can be extended to support <i>WaitForMultipleObjects(),</i> I did not do it because it makes the basic idea and the code much harder to understand. Events are a special type of synchronization object that have a unique behavior, so handling them correctly is not straightforward.</p><p>Another problem is a case where the DDA can report about a false deadlock. Think of the following scenario:</p><blockquote>T1        T2<br>Lock(R1)  Lock(R1)<br>Lock(R2)  Lock(R3)<br>Lock(R3)  Lock(R2)<br></blockquote><p>The DDA reports about a potential deadlock cycle: <i>R2-&gt; R3-&gt; R2</i>, while the aforementioned code never deadlocks because each thread first tries to acquire a lock on <i>R1</i>. This bug can be easily fixed. However, leaving it as-is may be a good idea because the code may cause problems in other scenarios.</p><h3>References</h3><p>Robbins, John. "BugSlayer," <i>MSDN</i>, October 1998.</p><p>"Tech Tips (Identifying Your Caller)," <i>Windows Developer's Journal</i>, December 2000.</p><p><b></b></p><p><b></b></p><p><b>DDJ</b></p></body></html>