<html><head><title>January, 2006: Sorting in Java &amp; C#</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><p><i>Dr. Dobb's Journal</i>, January 2006</p><h1>Sorting in Java &amp; C#</h1><h2>A reusable  comparator for sorting complex types</h2><h3>By David Perelman-Hall</h3><I>David teaches and writes about Java and C#, and can be contacted at dph@apk.net.</I><hr><p>Sorting lists of built-in types or primitives in Java or C# is straightforward. Both languages offer sorting routines that work on in-memory lists of comparable items&#151;comparable because each item in the list implements a "compare" interface expected by the list's sorting routine. In Java, each element to be sorted implements the <i>java.lang.Comparable</i> interface, and in C#, each element implements the <i>System.Collections.IComparer</i> interface. These interfaces allow types to define a natural ordering of instances of their class.</p><p>In Java, the <i>java.util.Collections</i> class can be used to sort lists, and in C#, the <i>System.Collections.ArrayList</i> class also offers a <i>sort</i> routine. These do their sorting by using the comparison routine defined in the <i>java.lang.Comparable</i> interface or the <i>System.Collections.IComparer</i> interface. Numerous built-in language types already implement this interface, so sorting types such as strings, numbers, and dates takes no extra effort beyond loading up the list and calling the <i>sort</i> method.</p><p>However, we often need to sort lists of complex domain-specific types such as <i>Employee</i> or <i>Animal&#151;not</i> just lists of built-in strings. In this article, I use reflection to sort a list of complex types through a fully implemented example using <i>Animal</i>s, leaving you with the chance to try it out by completing a partial implementation of <i>Employee</i>s. Neither <i>Animal</i> nor <i>Employee</i> implements a comparator interface that would make them fit the sorting routines of either language. Users will want to sort a list of domain-specific objects on domain-specific fields. They'll want to sort a list of <i>Employee</i>s by first name, or by last name, or by department, or by hire date, by contractor status, by manager, or by salary. Without trying very hard, that's seven possible ways to sort a list of <i>Employee</i>s.</p><p>Both languages do offer a means for sorting user-supplied complex types by providing an additional <i>sort</i> method that takes both the list and a separate comparator that knows how to compare the elements in the list. Though the comparator is a separate type from the elements in the list, it is coded to know how to compare the elements in the list in some specific way. This separate, standalone comparator works the same way in both languages&#151;it knows how to compare two like objects such that they can be ordered like this:</p><blockquote>if (object1 &lt; object2) return -1; <br>                   // a value less than 0 <br>else if (object1 &gt; object2) return 1; <br>                   // a value greater than 0<br>else return 0; // the objects sort equally<br></blockquote><p>Obviously, the standalone comparator must know what field of the complex object is plucked from the list to sort on&#151;<i>Employee.salary</i> or <i>Employee.hireDate</i>, and so on. For this to sort lists of <i>Employee</i>s seven different ways, there would need to be seven <i>java.util.Comparator</i> implementations (or seven .NET <i>System.Collections.IComparer</i> implementations). The code would then need to pass to the <i>sort</i> method the list of <i>Employee</i>s and the appropriate <i>Comparator/IComparer</i> implementation for the chosen field.</p><p>A time-tested paradigm to solve this kind of problem is to build an <i>EmployeeComparator</i> factory that knows how to supply all seven <i>Comparator</i>s. You obtain the specific comparator for the chosen field by passing a key (such as "firstname") into the factory, and you get back a comparator implementation that knows how to compare <i>Employee</i> objects specifically by first name. This technique works well, and it is possible to lazily build comparator implementations only once and only as needed, store them in a map, and access them quickly by key from the map. <a name="rl1"></a><a href="#l1">Listing One</a> is an incomplete implementation of the Java <i>Employee</i> class, and <a name="rl2"></a><a href="#l2">Listing Two</a> is a partially completed comparator factory for it. (The complete code for sorting <i>Animal</i>s with nested <i>Classification</i> references in both C# and Java is available electronically, see "Resource Center," page 4.)</p><p>The problem with an approach like this is that you have to code each key-comparator requirement into the factory, as indicated by the case blocks in the sample factory class. This makes it difficult to extend, and cumbersome for types such as <i>Employee,</i> which have more than a mere handful of sortable fields. As your application requirements grow to include associating a <i>Project</i> with each <i>Employee</i>, a new field called <i>currentProject</i> gets added to the <i>Employee</i> class. You then have the ability to display each employee's current project when you show a list of <i>Employee</i>s. Because users will see this and want to sort by <i>currentProject</i>, you must go back to the factory and build another case block. Using reflection, you can have one reusable comparator, and therefore, avoid this maintenance.</p><h3>Reflecting</h3><p>Both Java and C# let you examine the details of each type that has been loaded into the runtime environment during code execution. The first time a type is loaded into the runtime environment of Java, for example, the environment essentially creates and stores a template of type <i>Class</i> that describes everything about the newly loaded type. When an instance of a particular type is asked for by the application, the template is used to render that instance, identifying all the fields, methods, properties, and constructors. Using reflection, all of these can be made available to applications at runtime.</p><p>In Java, the template object is the <i>java.lang.Class</i> object, and in C#, it is the <i>System.Type</i> object. Both can be used programmatically with reflection to look up methods by name and invoke them on specific objects. I access the appropriate field of the complex type using this ability of reflection to work by name. The C# <i>Animal</i> class in <a name="rl3"></a><a href="#l3">Listing Three</a> is an easy domain-specific type to start with; <a name="rl4"></a><a href="#l4">Listing Four</a> is its Java counterpart. They are nearly identical, except that the C# <i>Animal</i> defines <i>age</i> to be a true C# <i>Property</i> of the <i>Animal</i>, available by a "get" property accessor, while all the members of the Java <i>Animal</i> class are accessed by a method. There is a minor difference in the C# class involved if the reflected item is a property versus a method, and the code accounts for both.</p><p>Class <i>Animal</i> aggregates just three fields: a string <i>animalType</i> with values such as <i>Monkey, Dog</i>, or <i>Bird</i>; an <i>int</i> for the <i>Animal</i>'s age; and another complex type called <i>Classification</i> that basically is used to house values such as <i>mammal, reptile, amphibian, </i>and so on. The <i>Animal</i> constructor wants all three values as arguments. When sorting<i> Animal</i>s, the string <i>animalType</i> field and <i>int</i> age field clearly would be built-in types that already implement <i>Comparator/IComparer</i>. The <i>Classification</i> reference of an <i>Animal</i> by default is not sortable, but you can make it sortable, as will be shown later. The three steps involved in using reflection to access the <i>animalType</i> field of an <i>Animal</i> instance by method name are:</p><ol>  <li>Get the template for the given class. In C#, obtaining the <i>System.Type</i> template looks like this:</li><pre>Animal parakeet =    new Animal("Parakeet", 2,     new Classification("bird")); Type t = parakeet.GetType();</pre>  <li>Ask the <i>System.Type</i> reference to vend the template for a specific method by name. This returns a reference to a <i>System.Reflection.MethodInfo</i> object that cannot be invoked by itself&#151;it is not associated with the original <i>parakeet</i> object or with any <i>Animal</i> instance. It is just a template that knows what the properties of the named method are: public, returns a string, takes no arguments, and so on. Again, the C# example looks like:<pre>MethodInfo method =    t.GetMethod("GetAnimalType");</pre>  	<i>System.Reflection.MethodInfo</i> inherits from <i>System.Reflection.MethodBase</i>, which in turn, inherits from <i>System.Reflection.MemberInfo&#151;</i>the base type for reflective behavior in .NET. In Java, the method reference is a <i>java.lang.reflect.Method</i> object that inherits from <i>java.lang.reflect.AccessibleObject</i>&#151;the base class for reflecting <i>Field, Method, </i>and <i>Constructor</i> objects. By the way, Java throws a <i>NoSuchMethodException</i> if it can't find the named method, while C# returns a null <i>MethodInfo</i> reference if it can't find the method. This difference in the way the languages treat reflection has a small design impact on the standalone compare routine. The Java code can forego testing for null, but instead wraps the entire compare routine in a <i>try-catch</i> block.<br><br>  <li>When it comes time to use this method template to invoke the method, the application needs to tell it which <i>Animal</i> instance it should be invoked on, and supply the method with the values of any arguments it requires. For this example, I assume the methods are simple getters or property accessors, and take no arguments. After obtaining the method template for the public string <i>getAnimalType()</i> method of the <i>Animal</i> class, you can invoke the method on the <i>parakeet</i> object via reflection in C# like this:<pre>object result = null;if(method != null){   // no args for getter method   object[] params = null;    result =       method.Invoke(parakeet, params);}<br></pre>  	Because this is the C# implementation, you have to first check for a null method, which is the only way you will know if the <i>GetMethod</i> request worked. Now you have the value of the <i>animalType</i> field (that you want to sort on) in the result that was returned from the invocation of the method.</ol><h3>Sorting with Reflection</h3><p>Using the reflection abilities of both languages, you can bypass the factory altogether and reuse a comparator to sort anything that implements the interface required for the comparison. This is accomplished by providing a single, reusable, standalone <i>System.Collections.IComparer</i> (or <i>java.lang.Comparable</i>) implementation for all sorting of complex types. At runtime, the reusable comparator uses "reflection-by-name" to access from the complex type a specific field to be sorted on. The comparator then tests whether or not the reflected field itself implements the <i>System.Collections.IComparer</i> interface and therefore can be used to do comparison itself. In effect, it says: Give me by reflection the animal's <i>animalType</i>, and if the reflected <i>animalType</i> string implements <i>IComparer</i>, then let it handle the sorting.  </p><p>For the remainder of this article, I concentrate on the C# example. The techniques and outcomes are similar for both languages. The starting point for sorting lists of complex types is with the <i>sort</i> method of the <i>Compare.Comparator</i> class:</p><blockquote>public static void sort(ArrayList list, <br>                string methodName, string dir)<br></blockquote><p>When you invoke this method, behind the scenes it uses the standalone, reusable <i>IComparer</i>, so you don't need to be aware of how to bring the comparator into play, only of what arguments to pass to the <i>sort</i> method. The <i>sort</i> method sorts the list (of <i>Animal</i>s) in argument one by comparing the results of reflection used to invoke the method named in argument two (for example, <i>"GetAnimalType"</i> ). Finally, it renders the results in ascending or descending order according to the direction supplied in the last argument. Invoke the <i>sort</i> routine as in CompareTest.cs or CompareTest (both available electronically), a snippet that does the sort on <i>animalType</i> follows. Recall, the <i>Animal</i> constructor wants an <i>animalType</i>, an <i>age</i>, and a <i>Classification</i>:</p><blockquote>ArrayList aList = new ArrayList();<br>aList.Add(new Animal<br>    ("Cat", 8, new Classification("mammal")));<br>aList.Add(new Animal<br>   ("Stork", 5, new Classification("bird")));<br> ...<br>Comparator.sort<br>   (aList, "GetAnimalType", "asc");<br></blockquote><p>The <i>Comparator.sort</i> routine is short:</p><ol>  <li>Acquiring the static-level lock on the <i>Comparator</i>'s <i>System.Type</i> object to enforce thread safety. There is only going to be one of these locks because there is only one instance of the <i>System.Type</i> template per class loaded into the runtime environment. This ensures that only one thread can gain access to the sorting code, which is important because, as a static method, numerous threads could be vying for it and you would want to be sure that each <i>sort</i> invocation is complete before another invocation has a chance to access the comparator Singleton.  </li>  <li>Setting the method name in the Singleton that reflection should use.</li>  <li>Setting the sort direction in the Singleton.  </li>  <li>Invoking <i>Sort</i> on the list and passing in the Singleton as the <i>IComparer</i> to use.</li><pre>lock(typeof(Compare.Comparator)){Compare.Comparator.    comparatorInstance.MethodName =          methodName;Compare.Comparator.    comparatorInstance.Direction =         dir;             list.Sort(Compare.Comparator.                       comparatorInstance);}></pre>  	   The Singleton <i>Compare.Comparator.comparatorInstance</i> is the reusable, standalone comparer, and it is an instance of the <i>ListComparator : IComparer </i>class. As such, it must define<i> public int Compare(object obj1, object obj2). </i>This method, of course, is where the guts of the reusable comparison are. This method follows the steps already outlined for using reflection. It attempts to obtain the <i>System.Reflection.MethodInfo</i> object named by the <i>methodName</i> parameter. If it can't get this, it thinks the <i>methodName</i> names a C# property instead, and tries to obtain the <i>System.Reflection.PropertyInfo</i> object by the same <i>methodName</i>.<br><br>  	   With either a <i>MethodInfo</i> or a <i>PropertyInfo</i> in hand, it uses reflection to invoke the named getter, thereby accessing the fields of the two <i>Animal</i> instances from the list that need to be compared. The results of the invocation-by-reflection are stored in object references called <i>result1</i> and <i>result2</i>,<i> </i>respectively. If the method named was, for example, <i>"GetAnimalType"</i> then <i>result1</i> and <i>result2</i> hold strings such as <i>"Monkey"</i> or <i>"Alligator"</i>. After doing the reflection, the code tests to see if it can forward the actual comparison on to <i>result1</i> and <i>result2</i> by using the <i>as</i> operator to cast both results to <i>IComparable</i>.</ol><p>This is the beauty of object-oriented code at work. Any type that implements <i>IComparable</i> can be compared using <i>CompareTo</i>. Because most built-in types  in C# implement the <i>IComparable</i> interface, it is possible to cast to <i>IComparable</i> and let the built-in type handle the comparison. If the <i>IComparable comp1 = result1</i> as <i>IComparable</i>; cast succeeds for both <i>result1</i> and <i>result2,</i> then you can return <i>icomp1.CompareTo(icomp2).</i> If you are not comparing built-in types, but instead comparing another complex type such as <i>Classification</i>, the trick is just to make sure it implements the <i>IComparable</i> interface, and it will fit right into this <i>sort</i> method. If the attempt to cast to <i>IComparable</i> fails for either <i>result1</i> or <i>result2</i>, you fall back on the trick of converting <i>result1</i> and <i>result2</i> to type <i>string</i>, and force a string comparison by returning <i>result1.ToString().CompareTo(result2.ToString()).</i> If the return from the reflected method is a null in either <i>result1</i> or <i>result2</i>, then the code sorts the null to the front of the list without doing any actual comparison.</p><p>The very minor downside to this is that the code is plying the wily skills of reflection&#151;a knock against which is that it might impact performance if the list to be sorted is lengthy&#151;although I have not noted much penalty in performance as I've been using this technique on lists with thousands of items. But the great benefit is that there exists a single <i>Comparator</i> for every complex type that needs to be sorted. You won't need another comparator, nor need to maintain another comparator factory.</p><p><b></b></p><p><b></b></p><p><b>DDJ</b></p>		<br><br><b><a name="l1"></a>Listing One</b><br><pre>package dph;/** Incomplete Employee implementation. Readers can build out this class, and possibly add a reference to an instance of type Project to match what the Animal class does with type Classification. */public class Employee{     // Member Data     private String firstname;     private String lastname;     private String department;     private java.util.Date hiredate;     private Boolean contractorStatus;     private String manager;     private Float salary;          // Constructor     public Employee(String fn, String ln)     {          this.firstname = fn;          this.lastname = ln;     }     // Public accessor methods     public String getFirstName() { return this.firstname; }     public String getLastName() { return this.lastname; }     // Public setter methods     public void setDepartment(String d) { this.department = d; }     /* Project reference that can be used to test sorting of Employee     // based on another complex type.  Reader needs to define the     // Project class so it implements java.lang.Comparable to compare     // based on some member of the Project type.     private Project curProject;     public Project getCurrentProject() { return this.curProject; }     public void setCurrentProject(Project p) { this.curProject = p; }     */}</pre><a href="#rl1">Back to article</a><br>			<br><br><b><a name="l2"></a>Listing Two </b><br><pre>package dph;/** Incomplete factory implementation for accessing Comparators    that know how to compare Employees based on specific properties. */public class EmployeeComparatorFactory{     // Class-level member for determining if types to be compared     // actually are type Employee.  Used in convertToEmployee method.     private static Class employeeClass;     static     {          try          {               employeeClass = Class.forName("dph.Employee");          }          catch(Exception ex)          {               ex.printStackTrace();          }     }     // Store the Comparators in this map     private static java.util.Map&lt;String,java.util.Comparator&gt; map =                    new java.util.HashMap&lt;String,java.util.Comparator&gt;();     // Help ensure singleton pattern--only want one factory to exist.     private EmployeeComparatorFactory() {}     // Public class-level interface. Pass all exceptions along for     // simplicity's sake. Attempt to acquire already-existing Comparator     // by key from the map, and build one for the map if it doesn't exist.     // This is the only public interface necessary.     public static java.util.Comparator                    getComparator(String type) throws Exception     {          java.util.Comparator comp = map.get(type);          if(comp == null)          {               comp = makeComparator(type);               map.put(type,comp);          }          return comp;     }     // Handy for converting Strings to type that can be used in a switch     enum ComparisonType     {           FIRSTNAME, LASTNAME, DEPARTMENT, HIREDATE,           CONTRACTORSTATUS, MANAGER, SALARY     };     // The maintenance work goes in here, when need to add new types to     // be compared on. Convert type to an enum value, switch on enum value     // and build the appropriate Comparator to be returned from this method.     // The FactoryComparator class is nested in this class, defined below.     private static java.util.Comparator                           makeComparator(String type) throws Exception     {          java.util.Comparator comp = null;          switch(ComparisonType.valueOf(type.toUpperCase()))          {          case FIRSTNAME:               comp = new FactoryComparator()               {                    public int compare(Object obj1, Object obj2)                    {                         Employee e1 = convertToEmployee(obj1);                         Employee e2 = convertToEmployee(obj2);                         return e1.getFirstName().compareTo(e2.getFirstName());                    }               };               break;          case LASTNAME:               //...and so on and so on...               break;          }          return comp;     }     // Private helper method to test on type before casting     private static Employee convertToEmployee(Object obj)     {          if(obj.getClass() != EmployeeComparatorFactory.employeeClass)          {             throw new RuntimeException(obj +                                  " can't be compared as type Employee");          }          return (dph.Employee)obj;     }     // Private helper abstract implementation of Comparator so don't need     // to define public boolean equals(Object other) in every case.  This is     // abstract because it doesn't implement the compareTo method yet.     private static abstract class                        FactoryComparator implements java.util.Comparator     {          // Required by java.util.Comparator interface          public boolean equals(Object other)          {               return this.getClass().getName().equals(other.getClass().getName());          }         }}</pre><a href="#rl2">Back to article</a><br>			<br><br><b><a name="l3"></a>Listing Three</b><br><pre>using System;namespace Compare{     /// &lt;summary&gt;     /// Summary description for Animal.     /// &lt;/summary&gt;     public class Animal     {          private string _type;          private int _age;          private Classification _class;          public Animal(string theType, int theAge, Classification theClass)          {               this._type = theType;               this._age = theAge;               this._class = theClass;          }          public override string ToString()          {               return this._type + ", " + this._age + " " + this._class;          }          // methods          public string GetAnimalType() { return this._type; }          public Classification GetClassification() { return this._class; }          // property          public int Age           {                get { return this._age; }           }     }}</pre><a href="#rl3">Back to article</a><br>			<br><br><b><a name="l4"></a>Listing Four</b><br><pre>package dph;/** A (slightly) complex domain-specific type that aggregates the     Classification type. */public class Animal{     // Member Data     private String type;     private Integer age;     private Classification _class;     // Constructor--uses 1.5 autoboxing to convert int to Integer.     // Requires all three data members to be initialized.     public Animal(String _type, int age, Classification _class)     {          this.type = _type;          this.age = age;          this._class = _class;     }     // Public accessors for member data     public Integer getAge() { return this.age; }     public String getAnimalType() { return this.type; }     public Classification getClassification() { return this._class; }     public String toString() { return type + ", " + age + " " + _class; }}</pre><a href="#rl4">Back to article</a><br>			</body></html>