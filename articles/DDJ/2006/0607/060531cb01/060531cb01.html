<html>
<head>
<title>Assurance &amp;  Agile Processes</title>
<link rel="Stylesheet" rev="Stylesheet" href="../../../../forms/Layout.css" type="text/css">
<link rel="Stylesheet" rev="Stylesheet" href="../../../../forms/FontStyles.css" type="text/css">
<link rel="Stylesheet" rev="Stylesheet" href="../../../../forms/newarticle.css" type="text/css">
<script src="../../../../forms/popwindow.js"></script>
</head>

<body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000">
<!--Copyright &#169; Dr. Dobb's Journal-->
<p><i>Dr. Dobb's Journal</i> July 2006</p>

<h1>Assurance &amp; Agile Processes</h1>
<h2>Does agility conflict with security or reliability?</h2>

<h3>by Cliff Berg & Scott W. Ambler</h3>

<I>Cliff is founder of Assured By Design and author of High-Assurance Design (Addison-Wesley Professional, 2005). He can be contacted at cliff.berg@assuredbydesign.com<br><br>

Scott is a software process improvement consultant, mentor, and trainer with Ambysoft Inc. He can be contacted at www.ambysoft.com.</I>

<hr>




<p>For organizations of all sizes, security failures can have devastating consequences. But security is only one aspect of overall application reliability. Indeed, it is often possible to equate the cost of a security failure with a given level of downtime. Thus, overall assurance of an application&#151;that is, its ability to perform as required and resist or recover from failure of any kind&#151;is really the key issue that organizations need to consider.</p>

<p>While the improved productivity achieved by agile software development practices is compelling, agile methods such as Extreme Programming (XP) do not explicitly address security and reliability. Why not? Because the assumption is that these issues will be addressed by the project's customers. Some have addressed the issues from the perspective of testing (<a href="http://www.testing.com/writings/evaluating-test-suites-paper.pdf" target="_blank">www.testing.com/writings/ evaluating-test-suites-paper.pdf</a>) and design (<i>Agile Modeling: Effective Practices for Extreme Programming and the Unified Process</i>, by Scott Ambler, Wiley, 2002) or security (e.g., Beznosov, Towards Agile Security Assurance, presented at <a href="http://www.nspw.org/2004" target="_blank">www.nspw.org/2004</a>). Still, there needs to be a cohesive agile framework that addresses assurance.</p>

<h3>The Importance of  Design for Assurance</h3>

<p>To avoid constantly saying "architecture and design," we use the terms "architecture" and "design" interchangeably. After all, an architecture is merely a high-level design, and for purposes here the distinction is not important.</p>

<p>Newcomers to some agile methods think that design is pass&eacute;, a myth dispelled in many sources (<a href="http://www.martinfowler.com/ieeeSoftware/whoNeedsArchitect.pdf" target="_blank">www.martinfowler.com/ieeeSoftware/ whoNeedsArchitect.pdf</a>). In <i>Agile Modeling: Effective Practices for Extreme Programming and the Unified Process</i>, one of us (Scott) explains why long-term objectives need to be considered if they are important to the organization. For example, objectives such as maintainability may mean that certain kinds of documentation are  required as deliverable artifacts. The key is to create "agile documents" (<a href="http://www.agilemodeling.com/essays/agileDocumentation.htm" target="_blank">www.agilemodeling.com/essays/ agileDocumentation.htm</a>).</p>

<p>Let's be clear about what a design is. A design is an enumeration or description of elements or attributes of an application's intended manifestation. Design may also address semantic elements, such as relationships between structural elements, sequence, cardinality, and in general, any aspects important for implementers to know to be able to produce an implementation that adheres to the design's intent.</p>

<p>The embodiment of a design is a set of artifacts. The artifacts can be code, unit tests, diagrams, or documented decisions about important technical issues. These are not mutually exclusive.</p>

<p>In 2004, Peter Neumann stated, "Good system and network architecture is perhaps the most fundamental aspect of any efforts to develop trustworthy systems..." (<a href="http://www.csl.sri.com/users/neumann/chats4.html" target="_blank">www.csl.sri.com/users/ neumann/chats4.html</a>). The reason behind this belief is that a design embodies the concepts that ensure that the system has certain hard-to-test properties, such as being secure. The design addresses how these properties are achieved, via the components of the design and their required relationships.</p>

<p>A design should not only state what elements exist in an application, but it should also state why they exist. For example, if a particular software layer exists to protect an underlying resource, then the layer should not be eliminated in order to simplify the design. The layer exists to satisfy a security requirement, and the layer's design should state how that is achieved. To explain how, you must ask "why?"; otherwise, you are explaining how something happens that you do not even have an expressed justification for.</p>

<p>There is another reason that "why" is important: It expresses a conclusion about the adequacy of a feature. That conclusion is then open to challenge. Agile design is about evolving a solution over time, and about continually challenging each "why" and its associated conclusions.</p>








<h3>Emergent Properties</h3>

<p>In the foreword to <i>High Assurance Design</i> (by Cliff Berg; Addison-Wesley Professional, 2005), Neumann states that "Security and reliability are both emergent properties of an entire system..." A consequence of this is that many kinds of tests that must be performed to verify security and reliability are so-called "negative tests" that verify that something cannot be done, rather than verifying that something can be done. To do these kinds of testing, a complex testing configuration might be necessary that is best left in the hands of professional testers. As Brian Marick put it, "good programmers do functional testing, and testers should do everythingelse" (<a href="http://www.testing.com/writings/classic/mistakes.html" target="_blank">www.testing.com/writings/ classic/mistakes.html</a>).</p>

<p>While considering a holistic system design, you must be careful to avoid falling into the pit of "big design up-front" (BDUF). You should be able to accomplish this if you follow agile principles regarding how the design is developed. Specifically, the criteria in Table 1 should be met for a design to be "agile."</p>


<div>
<table cellpadding=3 cellspacing=3>
  <tr bgcolor="lightblue">
    <td>1. Create the minimal design that is necessary at the time.</td>
  </tr>
  <tr bgcolor="lightblue">
    <td>2. Maintain only those parts of the design that need to be maintained to satisfy the mission of the application&#151;Update Only When It Hurts (see Agile Modeling).</td>
  </tr>
  <tr bgcolor="lightblue">
    <td>3. Define success criteria&#151;tests&#151;that the design must meet from the beginning, in a manner analogous to test-driven development (TDD), and require the design to be "tested" with each build of the system.</td>
  </tr>
</table>

<div class="caption">
Table 1: Agility criteria for design.
</div>
</div>

<p>As an example of item 3 in Table 1, consider an application for which the design includes a layer to protect an underlying resource, and for which the design includes a rule that "no module may directly access the resource except for the protection layer." Any code that violates this rule puts the entire protection scheme at risk. Therefore, verification of compliance with this rule must be achieved if it is to be successful. Because this rule cannot be tested by using functional tests, another means must be used. The testing of this design rule&#151;its verification&#151;can be achieved through any or several means, including the methods in Table 2.</p>


<div>
<table cellpadding=3 cellspacing=3>
  <tr bgcolor="lightblue">
    <td>1. Manual inspection of the entire code that might be able to directly access the resource.</td>
  </tr>
  <tr bgcolor="lightblue">
    <td>2. Automated inspection, using code scanning or parsing tools.</td>
  </tr>
  <tr bgcolor="lightblue">
    <td>3. Runtime checking, using dynamic tools.</td>
  </tr>
  <tr bgcolor="lightblue">
    <td>4. Sufficient awareness on the part of developers, so that they know not to violate the rule.</td>
  </tr>
</table>

<div class="caption">
Table 2: Design compliance verification methods.
</div>
</div>


<p>The choice should be made in consideration of the project's unique circumstances, including the level of maturity of the team, the size of the project, and the complexity of the overall code base.</p>








<h3>Methodological Challenges</h3>

<p>Some agile methodologies such as XP have raised questions among security and reliability experts. Their questions primarily focus around the concerns in Table 3.</p>


<div>
<table cellpadding=3 cellspacing=3>
  <tr bgcolor="lightblue">
    <td>1. Need for a focus on a comprehensive design.</td>
  </tr>
  <tr bgcolor="lightblue">
    <td>2. Need for a focus on documentation of the design and its intent.</td>
  </tr>
  <tr bgcolor="lightblue">
    <td>3. Need for a focus on nonfunctional testing.</td>
  </tr>
  <tr bgcolor="lightblue">
    <td>4. Need for a separation of high-risk modules, in light of "collective code ownership."</td>
  </tr>
</table>

<div class="caption">
Table 3: Assurance concerns often raised for agile methods.
</div>
</div>


<p>For example, in their paper "Modeling and Implementing Software Architecture with Acme and ArchJava," Abi-Antoun et al. assert that the benefits of architecture are "contingent upon correct implementation [with respect to] program understanding, software evolution, checking architectural constraints, [and] analysis of quality attributes" (<a href="http://www.cs.cmu.edu/~aldrich/papers/icse05-demo.pdf" target="_blank">www.cs.cmu.edu/~aldrich/ papers/icse05-demo.pdf</a>). This is a widely held view in the security and software assurance communities.</p>

<p>Items 1 and 2 in Table 3 have to do with defining, disseminating, and perpetuating architectural intent. "Intent" is the "why" that we previously discussed. Because TDD focuses on specification in the form of a unit test suite, the TDD-style of checking architectural intent would be to implement architectural rules as a test suite. A less formal approach is for the architects to be active members of the development team, thereby ensuring that design intent is adhered to because they're actually building it themselves (see <i>The Practical Guide to Enterprise Architecture</i>, by James McGovern et al., Prentice Hall PTR, 2003). Still, the assumptions and concepts&#151;the "why"&#151;should be written down and maintained.</p>

<p>Agile Modeling (AM) was specifically designed to be tailored into other agile methods to address the modeling and documentation issue. Similarly, TDD can be tailored to address assurance testing issues (<a href="http://www.testing.com/cgi-bin/blog/2003/08/21#agile-testing-project-1" target="_blank">www.testing.com/cgi-bin/blog/2003/08/ 21#agile-testing-project-1</a>).</p>







<h3>Agile Assurance</h3>

<p>To address assurance from an agile perspective, the practices in Table 4 should be followed.</p>


<div>
<table cellpadding=3 cellspacing=3>
  <tr bgcolor="lightblue">
    <td>1. When a requirement cannot be effectively verified using execution tests, use the design (not the code) as the focus of evidence of correctness and completeness.</td>
  </tr>
  <tr bgcolor="lightblue">
    <td>2. Ensure that requirements that are collected include assurance objectives.</td>
  </tr>
  <tr bgcolor="lightblue">
    <td>3. Use test-driven development and other techniques to continually verify compliance of the implementation with ongoing design (the AM effort; see below) as well as with requirements.</td>
  </tr>
  <tr bgcolor="lightblue">
    <td>4. Augment 3 with randomized testing to empirically assess actual assurance.</td>
  </tr>
</table>

<div class="caption">
Table 4: Agile assurance practices.
</div>
</div>



<p>Thus, for assurance-related requirements, our focus shifts to design rather than implementation, leaving implementation as a concurrent activity. A software implementation is merely a low-level design, and if a high-level design must remain authoritative for some aspects, then the low-level design is, by definition, subordinate to it for those aspects. We use the term "agile assurance" (AA) to refer to our approach.</p>

<p>To explain this approach, we discuss its implementation within the context of XP. Let's take the elements of our agile assurance approach, one by one.</p>



<p><b>Design as Evidence. </b>Approach 1 in Table 4 states that the design is a focus on an AA effort. A design is not an objective in its own right; rather, a design is an instrument for verifying that assurance is achieved. Further, a design must be adequately documented, to the extent necessary to achieve assurance objectives, including proving that the code agrees with the design intent, and ensuring that future maintenance also complies with design intent. For this to be achievable, the design must be maintained in a concrete and durable form, such as unit tests, a document, code comments, rules specified via a design language, or any means appropriate for a project. Thus, because a high-assurance design must be sufficiently documented, in the rest of this article we use the term "design" as synonymous with "design specification."</p>

<p>Here, we propose an approach for capturing design (<a href="http://www.agilemodeling.com/essays/amdd.htm" target="_blank">www.agilemodeling.com/ essays/amdd.htm</a>). Agile Model Driven Development (AMDD) is the application of the principles and practices of AM on an agile project. </p>



<p><b>Identification of Stakeholders and Requirements Collection.</b> In AMDD, stakeholders are defined as anyone who is a direct user, indirect user, manager of users, senior manager, operations staff member, support (help desk) staff member, developers working on other systems that interact with the one under development, or maintenance professionals potentially affected by the development/deployment of a software project (<a href="http://www.agilemodeling.com/essays/activeStakeholderParticipation.htm" target="_blank">www.agilemodeling.com/essays/ activeStakeholderParticipation.htm</a>).</p>

<p>Requirements such as security, reliability, failure recovery, disaster recovery, maintainability, and manageability cannot be treated as implicit. An agile design in a high-assurance environment requires that all assurance requirements be expressed through stakeholder stories. This requires that all of the application's stakeholders must be represented in collecting requirements. Those who have the most dynamic requirements&#151;typically the end users&#151;should be met with each iteration.</p>



<p><b>Continual Design Verification Augments TDD.</b> Agile proponents know the value of test-driven design (TDD), in which a test is written and then enough production code is written to fulfill that test. Again, a primary purpose of a design should be to explain why certain features exist in the application. AMDD addresses TDD by differentiating between high-level design, which utilizes agile modeling, and detailed design, which uses TDD to define detailed behavior.</p>

<p>An agile design must be continually verified, in the same manner that the implementation must be continually tested. Verification must occur from two perspectives: </p>

<ul>
  <li>Agreement between the design and the implementation (for instance, as-built equals as-designed).</li>
  <li>Verification that the design meets assurance requirements.</li>
  </ul>

<p><b>Empirical Testing. </b>The very nature of assurance requirements, in that they tend to be negative requirements specifying that something cannot be done, means that it is difficult to create a high-coverage test suite. This means that some amount of empirical testing, with inputs that are randomly chosen, is necessary to measure the actual soundness of the application so that it can be compared with the designed soundness.</p>








<h3>Agile Modeling</h3>

<p>Development of the Agile Modeling (AM) methodology was led by one of us (Scott). Agile Modeling is a collection of values, principles, and practices for modeling software that can be applied on a software-development project in an effective and lightweight manner. AM provides a framework of practices for developing and maintaining an application design. AM is meant to be tailored into other, full-fledged methodologies such as XP, RUP, or the Agile Unified Process (<a href="http://www.ambysoft.com/services/agileUP.html" target="_blank">www.ambysoft.com/services/ agileUP.html</a>), letting you develop a software process that truly meets your needs.</p>



<p><b>Agile Model Driven Development (AMDD).</b> Agile Model Driven Development (AMDD) is the application of AM to the software design and development process. Figure 1 shows that with AMDD, you do just enough high-level modeling at the beginning of a project to understand the scope and potential architecture of the system, and then during development iterations you take a just-in-time (JIT) model-storming approach where you model for several minutes as a precursor to several hours of coding. Extreme programmers (XPers) would call model-storming sessions stand-up design sessions or customer Q&amp;A sessions.</p>

<div>
    
<img class="illowide" src="060531cb01_f1.gif" style="width:446px" onclick = "popimage(this,'www.ddj.com - Assurance &amp;  Agile Processes - Figure 1')">

<div class="caption" style="width:448px">
Figure 1: The AMDD Lifecycle.
</div>
</div>


<p><b>The Use of Agile Modeling (AMDD) for Achieving Assurance.</b> The goal of AMDD is to provide a structure to the design aspect of agile development. There are four AM practices that have strong assurance benefits:</p>

<ul>
  <li>Apply the Right Artifact(s). The design should address how each assurance requirement is satisfied. This should include a discussion of the intent of each design element, in the context of any applicable abstract models that were developed.</li>
  <li>Collective Ownership. We claim that assurance concerns mandate some moderation of the XP tenet of collective code ownership. A strong case can be made that high-risk modules should be updateable only by a subset of the developers on a project&#151;the implication for a pair programming team is that at least one member of a pair must be allowed to do such an update. This applies to the design of those modules as well, and the contracts that specify their interfaces.</li>
  <li>	   The reason for this separation comes back to risk management. Not everyone on a team is as experienced in the issues that are pertinent to the design of every module in an application. </li>
  <li>Formalize Contract Models. There is a long history in the security and reliability professions of the importance of hierarchical decomposition of function. Contracts between different layers or different components are extremely important and such contracts need to be formalized and verified.</li>
  <li>	   There is also a long-established security concept of minimizing the trusted computing base. This concept applies to reliability as well. For it to succeed, the most failure-critical portions of an application should be delineated so that special attention can be paid to them. This is simple risk management. "Risk" is simply the product of the cost of failure and complexity (<a href="http://www.hpl.hp.com/techreports/2001/HPL-2001-132.html" target="_blank">www.hpl.hp.com/techreports/ 2001/HPL-2001-132.html</a>). Establishing formal contracts between high-risk modules and other modules helps to ensure that risk is contained within those components that are considered to represent the highest risk.</li>
  <li>Update Only When It Hurts. Keeping the model up-to-date addresses a major concern of assurance experts. For example, the assertion cited by Abi-Antoun et al. that the benefits of architecture are "contingent upon correct implementation" is addressed by ensuring that it reflects the implementation.</li>
  </ul>
<h3>Conclusion</h3>

<p>Assurance does not conflict with agility&#151;it merely challenges it. For those applications that need it, a high-assurance process can be employed that retains the agility that the business needs to be able to respond to market changes and organizational changes. Explicit steps must be taken to ensure that the required assurance will be provided by the software application, so that it holds up under the stresses of high-visibility, high-usage, and mission-critical dependence that is characteristic of so many of today's Internet-facing applications in large organizations.</p>


</body>
</html>