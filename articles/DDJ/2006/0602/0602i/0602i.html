<html><head><title>February, 2006: Sudoku &amp;  Graph Theory</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><p><i>Dr. Dobb's Journal</i>, February 2006</p><h1>Sudoku &amp;  Graph Theory</h1><h2>Algorithms for building solvers</h2><h3>By Eytan Suchard, Raviv Yatom, and Eitan Shapir</h3><I>Eytan, Raviv, and Eitan are software engineers in Israel. They can be contacted at  esuchard@012.net.il, ravivyatom@bezeqint  .net, and eitans@ima.co.il, respectively. </I><hr><p>Sudoku is a logic puzzle in which there are 81 cells (vertices) filled with numbers between 1 and 9. In each row, the numbers 1,2,3,..,9 must appear without repetition. Likewise, the numbers 1,2,3,..,9 must appear without repetition in the columns. In addition to the row and column constraints, the numbers 1,2,3,..,9 must appear in the nine nonoverlapping 3&times;3 subsquares without repetition. So in short, the puzzle board is separated into nine blocks, with nine cells in each block (see <a name="rf1"></a><a href="0602if1.html">Figure 1</a>). </p><p>There are several possible rules you can use to successfully fill in missing numbers. In this article, we examine two rules&#151;Chain Exclusion and Pile Exclusion&#151;for solving Sudoku puzzles. These rules are at the heart of a Windows-based Sudoku solver that we built using Visual C++. Executables and the complete source code for this solver are available electronically (see "Resource Center," page 6). The goal of this logical Sudoku solver is to prove that only one possible number can be assigned to each vertex, and to find that number for each vertex in which the number is not defined. Illogical Sudoku puzzles can also be solved, but require guesses (Implementation, OK button).</p><p>We refer to possible numbers that should be assigned to a row, column, or one of the nine 3&times;3 subsquares as a "Permutation Bipartite Graph" or nodes. A node consists of a vector of <i>n</i>&gt;1,<i>n</i>=2,3,4... vertices and all possible numbers that can be assigned to these vertices, such that there exists at least one possible match between the vertices of the vector and the numbers 1,2,...<i>n</i>.</p><p>For example, the following are nodes:</p><blockquote>({1,2,3,5},{2,3},{2,3,4},{3,4},{4,5}, n=5<br>({1,2,3,7},{3,6},{3,4},{1,4},{5,6,7},{4,6},{2,7},<br>		       {8,9},{8,9}, n=9<br></blockquote><p>A possible match for the first vector is easy:</p><blockquote>1 -&gt; {1,2,3,5}<br>2 -&gt; {2,3}<br>3 -&gt; {2,3,4}<br>4 -&gt; {3,4}<br>5 -&gt; {4,5}<br></blockquote><p>A possible match for the second vector is more tricky:</p><blockquote>2 -&gt; {1,2,3,7}<br>3 -&gt; {3,6}<br>4 -&gt; {3,4}<br>1 -&gt; {1,4}<br>5 -&gt; {5,6,7}<br>6 -&gt; {4,6}<br>7 -&gt; {2,7}<br>8 -&gt; {8,9}<br>9 -&gt; {8,9}<br></blockquote><p>A number can be only assigned to a vertex that contains the possibility of assigning that number. For instance, only the following possibilities are accepted:  </p><blockquote>7 -&gt; {2,7} or 2 -&gt; {2,7}.<br></blockquote><p>Pile Exclusion and Chain Exclusion provide the basis of logical elimination rules.</p><p>To understand Pile Exclusion, consider the following nodes:</p><blockquote>({1,2,3,5},{3,6},{3,4},{5,6},{1,7,8,9},{4,6},{5,7,8,9},<br>                    {4,6},{6,7,8,9},{1,4}, n=9<br></blockquote><p>The numbers 7,8,9 appear only in three vertices:</p><blockquote>{1,7,8,9},{5,7,8,9},{6,7,8,9} <br></blockquote><p>Because there is at least one possible match in the Permutation Bipartite Graph, one vertex will be matched to 7, one to 8, and one to 9. Thus, you can erase the other numbers from these three vertices to get the following three augmented vertices:</p><blockquote>{1,7,8,9} -&gt; {7,8,9} <br>{5,7,8,9} -&gt; {7,8,9} <br>{6,7,8,9} -&gt; {7,8,9} <br></blockquote><p>and the entire Permutation Bipartite Graph becomes:</p><blockquote>({1,2,3,5},{3,6},{3,4},{5,6},{7,8,9},{7,8,9},{4,6},<br>                             {7,8,9},{1,4}), n=9<br></blockquote><p>As for Chain Exclusion, consider these nodes:</p><blockquote>({1,2,3,7},{3,6},{3,4},{1,4},{5,6,7},{4,6},{2,7},{8,9},<br>                                    {8,9}, n=9<br></blockquote><p>In the second, third, and sixth positions in the vertices vector, you have:</p><blockquote>{3,6},{3,4},{4,6}<br></blockquote><p>Only the numbers 3,4,6 can be assigned to these vertices. From this, you infer that 3,4,6 are not a matching option in any of the remaining vertices. Thus, you can erase these numbers from all the other vertices, resulting in a new, more simple graph:</p><blockquote>({1,2,7},{3,6},{3,4},{1},{5,7},{4,6},{2,7},{8,9},<br>                                     {8,9}, n=9<br></blockquote><p>You can do the same thing with {1}, so that the resulting graph is:</p><blockquote>({2,7},{3,6},{3,4},{1},{5,7},{4,6},{2,7},{8,9},<br>                                  {8,9}, n=9<br></blockquote><h3>Algorithms</h3><p>We now present an algorithm that finds all such chains in polynomial time. The first stage is to find the best bipartite matching using the Ford Fulkerson maximum flow algorithm or any other bipartite matching algorithm (see <i>Introduction to Algorithms</i>, Second Edition, by Thomas H. Cormen et al., MIT Press, 2001).</p><p>Let <i>W</i> be the set of <i>n</i> cells in a row, column, or subsquare.</p><p>That means that there are <i>n</i> cells or vertices in <i>W</i> when the entire Sudoku puzzle has <i>n&times;n</i> cells or vertices. Let <i>D</i> be the set of numbers that are matched to <i>W</i>. In an <i>n&times;n</i> Sudoku, <i>D</i> is the set of numbers 1,2,3,...,<i>n.</i></p><p>Let <i>S</i><sub>k<i></i></sub> be a subset of <i>k</i> cells out of the <i>n</i> cells in which the possible numbers are exactly <i>k&lt;n</i> numbers <i>T</i><sub>k</sub>. We say that <i>S</i><sub>k </sub>is a "chain" if it doesn't contain a smaller set <i>Q</i><sub>r</sub> such that <i>r&lt;k</i> to which only <i>r</i> numbers can be matched. Moreover, in our model, if the number <i>v</i> in <i>D</i> can be matched to the cell <i>u</i> in <i>W,</i> then we say that our Permutation Bipartite Graph <i>G</i> contains the edge &#8712; =(<i>u,v</i>) between the vertex <i>u</i> from <i>W</i> and <i>v</i> from <i>D</i>. In addition, let <i>M</i> denote a maximal match between <i>W</i> and <i>D.</i> A match is a set of edges connecting cells or vertices in <i>W</i> to numbers or vertices in <i>D</i>. Each cell in <i>W</i> is allowed to have only one edge in <i>M</i> that connects it to a number in <i>D</i>.</p><p>Each number in <i>D</i> is allowed to have only one edge in <i>M</i> that connects it to a cell or vertex in <i>W</i>. Let <i>E</i> denote the entire set of possible vertices between <i>W</i> and <i>D</i>.</p><p>Because the vertices of <i>S</i><sub>k</sub> are only connected to vertices of <i>T</i><sub>k</sub>, the condition |<i>M</i>|=|<i>W</i>| implies that each element <i>s&#8712;<i>S<sub>k</sub></i></i> is matched to exactly one element <i>t &#8712; T<sub>k</sub></i> and vice versa. Start scanning a vertex <i>u<sub>1</sub> &#8712; W</i>. Suppose <i>u</i><sub>1</sub>&#8712;<i>S</i><sub>k</sub>. We check all the vertices <i>v</i><sub>i1</sub> in <i>D</i> such that the edges (<i>u</i><sub>1</sub>,<i>v</i><sub>i1</sub>) exist in <i>E</i>. Because <i>S</i><sub>k</sub> is connected only to <i>T</i><sub>k</sub>,<i>v</i><sub>i1</sub> are all in <i>T</i><sub>k</sub>. We mark <i>u</i><sub>1</sub> such that we will not consider <i>u</i><sub>1</sub> again. We remove <i>u</i><sub>1</sub> from the list of vertices the algorithm will visit. Now we look for all the edges (<i>u</i><sub>i1</sub>,<i>v</i><sub>i1</sub>) in <i>M</i> that are connected to one of these vertices <i>v</i><sub>i1</sub>. Obviously, <i>u</i><sub>i1</sub> are in <i>S</i><sub>k</sub> for all indices <i>i</i><sub>1</sub> because all the vertices in <i>T</i><sub>k</sub> are matched by <i>M</i> to vertices in <i>S</i><sub>k</sub>. We continue the process recursively. Now, for each <i>u</i><sub>i1</sub> we look for all <i>v</i><sub>i2</sub> in <i>D</i> that are connected to at least one of the <i>u</i><sub>i1</sub> vertices by edges. We mark <i>u</i><sub>i1 </sub>such that these vertices will not be considered again. Again, the <i>v</i><sub>i2</sub> must be in <i>T</i><sub>k</sub> and we continue and look for all the edges (<i>u</i><sub>i2</sub>,<i>v</i><sub>i1</sub>)&#8712;<i>M</i>. Obviously, <i>u</i><sub>i2</sub> are in <i>S</i><sub>k</sub>. </p><p>Because <i>u</i><sub>1</sub> and the vertices <i>u</i><sub>i1 </sub>were removed from the list of vertices that the algorithm visits, there are fewer vertices that can be visited by the algorithm. The process is repeated until all the vertices in <i>W</i> it can visit are reached.</p><p>Because all the vertices it can reach are in <i>S</i><sub>k</sub>, what is left to prove is that there is no vertex <i>u</i> in <i>S</i><sub>k</sub> that is not visited by the algorithm. Suppose there is such a vertex <i>u.</i> Then, obviously, the vertex <i>v</i> in <i>T</i><sub>k </sub>that is matched to <i>u</i> could not be visited either; otherwise, <i>u</i> could be visited. But then, <i>v</i> is also not connected to any one of the vertices in <i>S</i><sub>k</sub> that were visited. So we can define <i>Q</i><sub>k-1</sub>=<i>S</i><sub>k</sub>-{<i>u</i>}, which is connected to |<i>S</i><sub>k</sub>|-1 vertices in <i>D.</i> That is a contradiction to the requirement that <i>S</i><sub>k</sub> is minimal.</p><p>A simpler algorithm is the Pile algorithm. Let <i>G</i> be a Permutation Bipartite Graph. We would like to find if there exist vertices <i>v</i><sub>i1</sub>,...,<i>v</i><sub>ik</sub> in <i>D</i> such that they are all connected to the same <i>k</i> vertices in <i>W</i>, <i>u</i><sub>j1</sub>,...,<i>u</i><sub>jk</sub>. Such vertices are called "Pile" or "Set." The algorithm is trivial. Start traversing the vertices <i>v</i><sub>k</sub> in <i>D</i> serially in a loop. Activate a second loop within the first loop and count all the other vertices in <i>D</i> that are connected to the same <i>k</i> vertices <i>u</i><sub>j1</sub>,...,<i>u</i><sub>jk</sub> in <i>W</i> that <i>v</i><sub>k</sub> is connected to. If there are <i>k</i> such vertices <i>v</i><sub>i1</sub>,...,<i>v</i><sub>ik</sub> in <i>D</i>, then you are done. Although this algorithm can be improved, it is efficient and its runtime is |<i>W</i>|<sup>2</sup>/2.</p><p>After finding a chain, the algorithm can erase all the edges that are connected to the vertices in <i>T</i><sub>k </sub>that are not connected to <i>S</i><sub>k</sub>. This operation is called "Chain Exclusion." That is, if &#8712;=(<i>u,v</i>) and <i>v&#8712;T</i><sub>k</sub> and <i>u&#8712;S</i><sub>k </sub>, then &#8712; is removed from the Permutation Bipartite Graph <i>G.</i></p><p>After finding a Pile, remove all the edges that connect <i>u</i><sub>j1</sub>,...,<i>u</i><sub>jk</sub> to <i>D-</i>{<i>v</i><sub>i1</sub>,...,<i>v</i><sub>ik</sub>}.</p><h3>Implementation</h3><p>We've used the Chain Exclusion and Pile Exclusion algorithms described here to build a Windows-based Sudoku solver in Visual Studio C++ 6.00. Executables and the complete source code are available electronically; see "Resource Center," page 6. You will need to rename the file Sudoku.ex1 to Sudoku.exe. Alternatively, you can compile the entire project Sudoku.dsw or Sudoku.dsp with Visual Studio 6.00. We've included a simple console application, Logic.ex1, that demonstrates Chain Exclusion. This file should be renamed to Logic.exe. In Sudoku.exe, the Logic button calls the class Square3.cpp, and Square3.cpp calls Bipartite.cpp. The Logic button fills as many cells as possible with numbers, by using logic only. You can generate puzzles that usually have more than one solution by clicking on the Test button when the Unique option doesn't have a check mark. If the Unique option is checked, the Sudoku puzzle is solved by logic only. The Very Hard option automatically checks the Unique option and takes 5 seconds. You can also enter your own puzzle and press either the Logic button or the OK button. If the puzzle can't be solved because of contradictions, OK won't fill it and Logic will fill as many cells as possible. When the contradiction is encountered, it inserts a double number in row, column, or square. That can be verified by the Check button.</p><p>In addition, Sudoku.exe also solves illogical puzzles via the OK button that calls recursion that in each iteration fills in numbers in locations in which there are less degrees of freedom. For more information on Sudoku puzzles, see the Daily Sudoku (http://www.dailysudoku.co.uk/) or the <i>Times Online </i>(http://www.timesonline.co.uk/section/0,,18209,00.html). </p><p><b>DDJ</b></p></body></html>