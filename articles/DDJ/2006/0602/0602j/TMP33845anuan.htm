<html><head><title>February, 2006: Google's Summer of Code: Part III</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><a name=top></a><p><i>Dr. Dobb's Journal</i> February, 2006</p><h1>Google's Summer of Code: Part III</h1><hr><a href="#0602js1">FreeBSD/nsswitch and Caching</a><br><a href="#0602js2">Userspace Filesystems Framework for NetBSD</a><br><a href="#0602js3">gloox: A High-Level Jabber/XMPP Library for C++</a><br><a href="#0602js4">SPARQL for Sesame</a><br><a href="#0602js5">TSC-I2: A Lightweight Implementation for Precision-Augmented Timekeeping </a><br><hr><a name="0601js1"></a><h2>FreeBSD/nsswitch and Caching</h2><img src="0602js1f1.jpg" width="125" height="171" align="right">Name: Michael A. Bushkov<br>Contact:<a href="mailto:bushman@rsu.ru">bushman@rsu.ru</a><br>School: Rostov State University, Russian Federation<br>Major: Applied Mathematics<br>Project: FreeBSD/nsswitch and Caching<br>Project Page:<a href="http://wikitest.freebsd.org/moin.cgi/NsswitchAndCachingFinalReport/"> http://wikitest.freebsd.org/moin.cgi/NsswitchAndCachingFinalReport/</a><br>Mentors: Brooks Davis and Jacques Vidrine<br>Mentoring Organization: FreeBSD (<a href="http://www.freebsd.org/">http://www.freebsd.org/ </a>) <p>Nsswitch is an extremely useful subsystem that exists on UNIX platforms such   as Linux, Solaris, and FreeBSD. It provides a flexible and convenient way to   configure how name-service lookups are done. Nsswitch operates with two basic   concepts&#151;database and source. When users query the particular database   (password, group, hosts, and so on) for information, nsswitch decides which   source (files, NIS, LDAP) this information should be taken from. The basic idea   of nsswitch is that hard-coded name-service lookup functions (<i>getpw**</i>, <i>getgr**</i>,   <i>gethost**</i>, <i>getaddrinfo</i>, and the like) are never called directly. The function:</p> <pre> nsdispatch(void *retval,   const ns_dtab dtab[],   const char *database,   const char *method_name,   const ns_src defaults[], &#133;) </pre> <p> is called instead. In turn, it dispatches the call to the appropriate sources. <p> FreeBSD nsswitch implementation supports various possible databases: password,   groups, hosts, netgroups, and shells. In this project, we extended this list   by adding services, rpc, protocols, OpenSSH, and Globus Grid Toolkit 4 databases.   To add the support for the particular database, we had to implement several   nsswitch sources for it, and then replace all hard-coded function calls with   the nsdispatch calls.</p> <p> To add the support for services, rpc, and protocols, we also had to change the   interface of the corresponding internal reentrant <i>libc</i> functions to improve   the compatibility with Linux/Solaris nsswitch implementations. We&#146;ve changed   the interfaces from the HP-UX style: <pre> int getservbyname_r(const char *name,   const char *proto,   struct servent *serv, struct</pre> <p> to Linux/Solaris style:<pre>  int getservbyname_r(const char *name,   const char *proto,   struct servent *serv, char *buffer,   size_t bufsize, struct servent **result);</pre> <p> Because all nsswitch requests are passed through nsdispatch, it&#146;s a great   place to organize caching in a general way. Caching can significantly improve   system performance. It&#146;s useful for the services database, for example,   because the /etc/services file becomes bigger and bigger, and <i>getserv**</i> functions   become slower and slower.</p> <p> We had to modify the nsdispatch code, so that it could process the &#147;cache&#148;   source. Besides, marshaling and unmarshaling routines had been implemented for   every nsswitch database type.</p> <p> To make the cache, nsdispatch interacts with the caching daemon, which is built   on top of the caching library (they were both developed during the &#147;Summer   of Code&#148;). The caching library provides a simple interface for cache organization.   It uses hash tables to store data and supports different policies, which are   applied when cache size is exceeded. The caching daemon uses UNIX socket to   communicate with libc to perform read/write operations.</p> <p> The interesting feature of the caching daemon (and the caching library) is   the multipart caching and the concept of sessions. This approach is very useful   for g<i>etXXXent() </i>functions. When the first call to <i>getXXXent() is</i>   made, the write session is opened. If the <i>setXXXent()</i> or <i>endXXXent()   </i>is called, the session is abandoned and all its data are freed. If the <i>getXXXent()</i>   function indicates the successful end of a sequence, the session is gracefully   closed and all session data are placed in the cache.</p><a href="#top">Back to Top</a><hr><a name="0602js2"></a> <h2>Userspace Filesystems Framework for NetBSD</h2><p><img src="0602js2f1.jpg" width="125" height="142" align="right">Name: Antti   Kantee<br>  Contact: <a href="mailto:pooka@cs.hut.fi">pooka@cs.hut.fi</a><br>  School: Helsinki University of Technology, Finland<br>  Major: Graduate student, Computer Science<br>  Project: Userspace Filesystems Framework for NetBSD<br>  Project Page: <a href="http://netbsd-soc.sourceforge.net/projects/userfs/">http://netbsd-soc.sourceforge.net/projects/userfs/</a><br>  Mentor: William Studenmund<br>  Mentoring Organization: NetBSD Project (<a href="http://www.netbsd.org/">http://www.netbsd.org/</a>)</p>  <p>A long time ago, the two competing paradigms for designing an operating system   were the monolithic and microkernel approaches. While the performance benefits   of monolithic kernels with direct access to memory are undeniable, microkernels   have more beauty and theoretical appeal. Since these days everybody is using   excessive hardware performance as an excuse to add bloat; it is only fair to   use it to add something useful.</p>  <p>Implementing a filesystem in userspace is beneficial for several reasons:<ul> <li> Development can take advantage of a faster bugfix-compile-restart cycle.   Also, debugging is easier because it is possible to run the filesystem under   a normal userspace symbolic debugger.<li>The filesystem can access information that traditionally has been difficult   to access from inside the kernel. A simple example could be a web site accessed   over HTTP using a readily available HTTP library.<li>The actual implementation does not necessarily have to be written in   C. Of course, having a userspace API for C is only half the battle (but it&#146;s   the larger half).<li>Leveraging existing application code written against the well-known libc   filesystem API is made possible.</ul><p>  Producing a framework involved attaching a new filesystem to the kernel frameworks,   creating a communication pipe to the userspace and a serialized representation   of filesystem operations, and creating an API to which userspace implementations   could attach.</p> <p> Adding a new filesystem to the kernel side was mostly a question of leg work.   However, one problem was having to think somewhat differently from the typical   case: Usually, filesystems are implemented with a clear idea of the semantic   effects of each vnode <i>operation</i>. But in this case, a &#147;generic implementation&#148;   had to be devised.</p><p>  Communication to the userspace was implemented as a device node, some ioctls,   and argument structures. This is an area for future work that may possibly produce   a framework for generic kernel upcalls.</p><p> The userspace API is dictated by the need to have an implementation backing   each <i>vfs</i> and <i>vnode</i> operation. Also, the API aims to lift the burden of communication   subroutines common to all filesystem implementations without restricting the   potential for, say, an asynchronous implementation.</p><p> Currently, the framework is still very much in the infant prototyping stage.   After the system is stress tested, hardened, and perfected, it would be interesting   to investigate providing similar frameworks in NetBSD for other subsystems,   such as networking stacks and device drivers.</p> <a href="#top">Back to Top</a><hr><a name="0602js3"></a> <h2>gloox: A High-Level Jabber/XMPP Library for C++</h2><p><img src="0602js3f1.jpg" width="125" height="156" align="right">Name: Jakob   Schr&ouml;ter<br>  Contact:<a href="mailto:js@camaya.net"> js@camaya.net</a><br>  School: University of Applied Sciences, Bremen, Germany<br>  Major: Computer Science <br>  Project: gloox<br>  Project Page: <a href="http://camaya.net/gloox">http://camaya.net/gloox</a><br>  Mentors: Peter Saint-Andre<br>  Mentoring Organization: Jabber Software Foundation (<a href="http://www.jabber.org/">http://www.jabber.org/</a>)</p><p>gloox was born as part of a university project (XMPPGrid: A Grid Framework)   that used Jabber/XMPP as a transport protocol. Because, at that time, there   were no C++ XMPP libraries available that suited my needs, I decided to roll   my own.</p><p>gloox (http://camaya.net/gloox) heavily uses the Observer Pattern. There are   listeners ("handlers" in gloox-speak) for almost every imaginable event that   can occur, from connection establishment to error conditions. After a connection   has been established, everything is event driven, and simple applications, such   as bots, can easily do without a mainloop or threads. On the other hand, gloox   exposes the necessary interface to manually initiate fetching of data from the   socket.</p><p>Right after the XML parser receives a complete stanza, it is parsed into a   <i>Stanza</i> object that offers a convenient interface to take apart such an   XML element. The respective handlers are then called based on the stanza's type.</p><p>The library offers classes to create regular clients as well as components.   These only offer basic functionality, but can be extended with several included   implementations of so-called Jabber Enhancement Proposals (JEPs) to create a   full-featured client/component.</p><p>In general, using the library is as simple as:</p><ul>  <li>Creating a new <i>Client</i> or <i>Component</i> object.</li>  <li>Creating and registering the desired handlers.</li>  <li>Calling <i>connect().</i></li></ul><p></p><p>Most protocol enhancements follow a similar approach: They simply register   as handlers for one of the <i>Stanza</i> types. For example, the Info/Query   (IQ) mechanism of the XMPP spec is an important tool to control various aspects   of a session. The basic syntax of IQ packets is always the same and different   protocols are distinguished based on the payload of an IQ packet: The child   element and its namespace. gloox offers a handler for these namespaces, which   makes it extremely easy to implement every IQ-based protocol.</p><p>Additionally, handlers for the remaining XMPP packet types (called "stanzas"   in XMPP) are included, along with a generic tag handler for protocols not using   these defined stanza types.</p><p>While using these interfaces, the higher level layers offer handlers themselves,   with data types tailored to their needs. This minimizes the need to know the   XMPP protocol by heart if the included classes are used.</p><p>Even though it is defined in the XMPP IM spec, Roster Management is an example   for such a higher level protocol. The <i>RosterManager</i> registers itself   as a handler for IQ stanzas carrying "query" elements qualified by the <i>jabber:iq:roster</i>   namespace. It can then add or remove items from a user's contact list, and react   to incoming so-called roster pushes, an updated contact list item sent by the   server.</p><p>The <i>RosterManager</i> offers clients a rich interface to be notified about   any changes happening to the contact list. Events exist for adding and removing   contacts, as well as for changes in subscription states.</p><p>The decision of using/activating one (or more) of the protocol enhancements   is with the user of the library. The modular structure allows addition and removal   of those enhancements at runtime. More JEPs can easily be implemented, usually   by creating handlers for the respective XML namespaces a JEP uses. gloox is   licensed under the GPL and commercial licenses are available. </p><a href="#top">Back to Top</a><hr><a name="0602js4"></a> <h2>SPARQL for Sesame</h2><p><img src="0602js4f1.jpg" width="125" height="149" align="right">Name: Ryan   Levering<br>  Contact: <a href="mailto:rrlevering@yahoo.com">rrlevering@yahoo.com</a><br>  School: Binghamton University<br>  Major: Ph.D. candidate, Computer Science<br>  Project: SPARQL for Sesame<br>  Project Page: <a href="http://sparql.sourceforge.net/">http://sparql.sourceforge.net/</a><br>  Mentors: Giovanni Tummarello and Jeen Broekstra<br>  Mentoring Organization: Semedia Semantic Web and Multimedia Group (<a href="http://semedia.deit.univpm.it/">http://semedia.deit.univpm.it/</a>)</p> <p>The initial goal of my project was to write a Java interpreter of the SPARQL   query language for use in Sesame, an RDF data server. SPARQL, the first W3C   standardized query language for the RDF data format, is a step toward standardization   of the Semantic Web vision of W3C.</p><p>The language is reminiscent of SQL&#151;users specify a series of set and value   constraints on the data in the server:</p><blockquote> SELECT ?title <br>  WHERE { _:book :title ?title . <br>  FILTER (?title != "Old Title") }<br></blockquote><p>The server then returns data values that fit those constraints. However, RDF   data is not relational and is usually visualized as a graph of data relationships.   Therefore, queries are more akin to graph pattern matching, with variables being   bound to certain matched parts of the graph.</p><p>The first design was a library of classes that processed the query from within   the object structure created by parsing the query into an abstract syntax tree.   This design, however, suffered from one of the common problems in OO programming&#151;a   dependence on inheritance for extension. To customize the interpreter for other   servers, one had to subclass certain query objects and rebuild the library. </p><p>The final design uses a combination of design patterns to overcome this dependence.   The main principle of the design is the separation of interpretation logic and   query data, via prolific use of the Strategy pattern. Because abstract syntax   trees lend themselves ideally to the Visitor pattern, a visitor is used at interpretation   time to walk the AST query structure and bind logic to each part of the query,   using an Abstract Factory to create the logic objects. Developers wishing to   implement a customized query interpreter can shortcut the default logic using   their own factory implementation to rewrite any part of the logic, without ever   needing to recompile the main library. The primary efficiency penalty of the   design is found in the data interface between the library and the server. Because   most servers use a slightly different data object representation, every data   value that is used by the interpreter has to be passed through its own adapter,   which either passes on method calls or creates a new interpreter-compatible   data value. For greater speed, the most computationally intensive set logic   in the interpreter can be overridden to let servers do their own native data   manipulation. Hopefully, the benefits of using a standardized specification   library will allow server developers to focus more on the front-end server interfaces   and underlying persistent storage and less on the particular quirks of this   new query language.</p><p></p><a href="#top">Back to Top</a><hr><a name="0602js5"></a> <h2>TSC-I2: A Lightweight Implementation for Precision-Augmented Timekeeping </h2><p><img src="0602js5f1.jpg" width="125" height="157" align="right">Name: Xun Luo<br>  Contact: <a href="mailto:xluo@cs.uic.edu">xluo@cs.uic.edu</a><br>  School: University of Illinois at Chicago<br>  Major: Ph.D. candidate, Computer Science<br>  Project: Timekeeping Using TSC Register<br>  Project Page: <a href="http://tsc-xluo.sourceforge.net/">http://tsc-xluo.sourceforge.net/</a><br>  Mentors: Jeff Boote<br>  Mentoring Organization: Internet2 (<a href="http://www.internet2.edu/">http://www.internet2.edu/</a>)</p>  <p>The quality of timekeeping is critical for many network protocols and measurement   tools. TSC-I2 (TSC-Internet2) ensures accuracy and precision by making TSC rate   calibration a continuous process, thus the accuracy of interpolation parameters   could be ensured, which in turn results in satisfying clock precision. TSC-I2   maintains a soft clock of its own, periodically comparing this clock to the   system clock. During each comparison, it synchronizes itself with the system   clock, and adjusts the interpolation rate based on the offset and rate errors   regarding to system clock. Whenever the accuracy of the soft clock is ensured,   TSC-I2 uses this clock to report time to the library user; otherwise, the system   clock value is reported. The advantage of this design is that system clock is   enhanced rather than substituted. </p><p>The clock discipline algorithm is enlightened by NTP. A state-machine-controlled   PLL (Phase Lock Loop) traps the rate-induced phase difference between TSC clock   and system clock. Rate wander is captured within one loop delay, and corrected   in three to four following loops. To avoid incorrect recognition of noise as   a rate-induced error, two filters&#151;a popcorn filter and a spike detector&#151;are   used. There are two usage modes: DAEMON and CLIENT. In DAEMON mode, a standalone   daemon takes charge of timekeeping, serving one or more clients. In CLIENT mode,   the library creates a thread running within the hosting process. Thus, it minimizes   the application's external dependency. There are also clear distinctions between   TSC-I2 algorithms and its NTP counterparts, mainly due to the different natures   of referencing sources. Readers interested in TSC-I2 internals can visit the   project web site, where more details are illustrated.</p><p>TSC-I2, which is fully implemented in around 2000 lines of C, is fairly lightweight.   It has been published under the Open Source License at http://tsc-xluo.sourceforge.net/.   TSC-I2 currently supports IA32, AMD64, and Power PC architectures, as well as   Linux, FreeBSD, Mac OS X, and Microsoft Windows.</p> <p> <b>DDJ</b></p><a href="#top">Back to Top</a> </body></html>