<html><head><title>February, 2006: Viewing &amp;  Organizing Log Files </title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><p><i>Dr. Dobb's Journal</i>, February 2006</p><h1>Viewing &amp;  Organizing Log Files </h1><h2>LogChipper&#151;a generic approach to tracking log content</h2><h3>By Phil Grenetz</h3><I>Phil has developed software for over 20 years in the defense, publishing, database, and financial industries. He can be contacted at ivden-1@comcast.net.</I><hr><p>Developers charged with supporting mission-critical applications need to be alerted to problems when they arise in the production environment. Once a problem is identified, it is essential that you can browse and/or search application log files for clues as to the nature and cause of the problem. Only then can the implications of the problem be assessed and resolved as quickly as possible.</p><p>Today's applications are highly distributed. Clients interact with server processes asynchronously. As a result, logged events reflecting user activity are intermixed in the strictly chronological log files with events reflecting numerous types of notifications from server processes.</p><p>Diagnosing production problems is a form of forensic analysis. Typically, on being alerted to an application error, the first step is to open the log file in a text viewer such as Notepad and search or browse the file for the exceptional event and other events that may have contributed to it. This can be a tedious process. Relevant clues can be missed. In addition, third-party tools maintain log files in their own formats. A generic approach to viewing and organizing log file contents is highly valuable in such an environment. In this article, I present LogChipper&#151;one solution to this problem for the .NET platform.</p><p><a name="rf1"></a><a href="0602kf1.html">Figure 1</a> is LogChipper's user interface. It uses two <i>ListView</i> controls to present the original view and the sorted and filtered view of events. Note the radio buttons for toggling between them. Also note the checkboxes for enabling autoscroll and dynamic load and pausing the loading process. The column chooser lets users select the desired columns and rearrange them.</p><p>The Format menu is populated by the plug-in parser with items for selecting custom features offered by the plug-in. The plug-in in <a name="rf1"></a><a href="0602kf1.html">Figure 1</a> parses logs of a popular FIX engine, a protocol used in the financial industry to send buy and sell orders to the exchanges, and communicate about events on these orders (see http://www.fixprotocol.org/).</p><h3>Plug-In Architecture</h3><p>LogChipper is designed as a plug-in framework. Such a framework has three key ingredients. </p><ul>  <li>The interface is one ingredient. LogChipper is a WinForms application designed as several assemblies; see <a name="rf2"></a><a href="0602kf2.html">Figure 2</a>. The assembly named "LogView" contains the application's host executable. "LogViewCommon" contains definitions of some common enumeration types. "LogViewInterfaces" is the assembly that exposes the definition of the plug-in parser interface. "LogViewPlugin_FIX" contains a specific implementation of the interface for FIX engine logs. One assembly houses a definition of the plug-in interface and the other implements that interface. The plug-in interface <i>ILogViewParser</i> is defined in <a name="rl1"></a><a href="#l1">Listing One</a>. Any parser must implement <i>ILogViewParser</i>. In so doing, it must be responsible for processing events into fields of information, assigning the corresponding values to grid columns, and exploiting metadata (such as data type, identifying tag, and column heading).</li>  <li>Dynamic activation is another key ingredient. To be effective, the application needs to be able to instantiate any parser that implements <i>ILogViewParser</i> at will. In the .NET Framework, the <i>Activator</i> class makes this possible. <a name="rl2"></a><a href="#l2">Listing Two</a> demonstrates what happens when users select a plug-in parser. Note the use of the <i>Activator</i> class method <i>CreateInstance</i>. There are several overloads, but the one that takes the assembly file name, and the name of the type to be instantiated serves the current purpose best. <i>CreateInstance</i> constructs an instance of the requested type and returns a <i>System.Runtime.Remoting.ObjectHandle</i>. Calling <i>Unwrap</i> on this handle reconstitutes the object. Casting this object to the requisite interface type completes the process, equivalent to calling <i>CoCreateInstance</i> in COM, but without GUIDs or registry accesses.</li>  <li>The third key ingredient of a plug-in framework is the ability to insert its custom features into the host application.  Recall from <a name="rl1"></a><a href="#l1">Listing One</a> that <i>ILogViewParser</i> defines the method <i>GetPluginMenuItems</i>. The plug-in implements this method by returning an array of objects of type <i>MenuItem</i>, defined in the <i>System.Windows.Forms</i> namespace. A plug-in typically constructs the <i>MenuItem</i> array and linked <i>MenuItem</i> arrays (if any) representing cascading submenus during its initialization.</li></ul><p>Continuing in <a name="rl2"></a><a href="#l2">Listing Two</a>, after instantiating the plug-in parser object, the host application calls <i>GetPluginMenuItems</i> on the interface and populates the Format menu.</p><p>The plug-in parser constructs the menus as in <a name="rl3"></a><a href="#l3">Listing Three</a>(a). The menu items allow for three modes of column heading display: </p><ul>  <li>Events in the FIX protocol consist of tag-value pairs, where the tags are numeric.  </li>  <li>The parser maintains a mapping between the numeric tags and alphabetic equivalent headings.  </li>  <li>The modes of display provided by this parser are numeric, alphabetic equivalent, and a blend of the two.  </li></ul><p><a name="rl3"></a><a href="#l3">Listing Three</a>(b) illustrates one of the Format menu handlers.</p><p>You need a way of determining which parser assemblies are available to users. You could iterate over the DLLs in the application directory using <i>CreateInstance</i> to determine which DLLs are .NET assemblies that implement <i>ILogViewParser</i>. This solution offers dynamic discovery, but can be expensive. Instead, I decided to list the available parsers in the application configuration file (<a name="rl4"></a><a href="#l4">Listing Four</a>). This way, users can choose from a collection of parsers by familiar format names, while the application instantiates the parser based on the assembly DLL filename.</p><h3>Multithreaded Design</h3><p>To let users browse, sort, and filter logs while they are being loaded, the file I/O for loading and parsing the events is placed in its own thread. This requires some thread synchronization; for instance, to ensure that new rows are not being inserted into a grid while new sort or filter criteria are being applied.</p><p><a name="rl5"></a><a href="#l5">Listing Five</a>(a) contains a portion of the handler for opening a log file. After restoring the user's settings for this file, it constructs a new thread to perform the file I/O and parsing. The member variable <i>m_thPopulateList</i> is of type <i>Thread</i>, defined in the <i>System.Threading</i> namespace.</p><p>Creating the thread is a matter of constructing a <i>Thread</i> object, passing a <i>ThreadStart</i> delegate to its constructor.  <i>Delegate</i> is a .NET type representing a callback method with a specified signature.  A <i>ThreadStart</i> delegate represents a callback method that takes no arguments and returns <i>void</i>. A <i>ThreadStart</i> delegate is created by passing its constructor a reference to a method that has the proper signature and is designed to perform the work of the thread. In this case, that method is <i>PopulateListThreadFunc</i>.</p><p><a name="rl5"></a><a href="#l5">Listing Five</a>(b) contains a portion of <i>PopulateListThreadFunc</i> demonstrating thread synchronization and indirect communication with the main thread. First, note the use of <i>m_SortParseMutex</i>, a member variable of type <i>Mutex</i>, defined in the <i>System.Threading</i> namespace.</p><p><i>Mutex</i> offers a way to ensure that an operation that affects the state of a shared resource from one thread will not conflict with one in progress on another thread. A <i>Mutex</i> instance representing a Win32 mutex kernel object is created for each shared resource. All threads call the <i>WaitOne</i> method on the applicable <i>Mutex</i> instance before beginning an operation that affects the shared resource's state. <i>WaitOne</i> blocks if another thread holds the mutex, returning only when <i>Release</i> has been called on it. In this case, the <i>ListView</i> controls must be protected from concurrent manipulation by the user and the file I/O thread. To prevent such a change from occurring while a new row is being inserted in its proper sequence into the sorted <i>ListView</i> control, changes to the sort sequence are synchronized via a call to <i>WaitOne</i> on <i>m_SortParseMutex</i>.</p><h3>"Tailing" the File</h3><p>Returning to <a name="rl5"></a><a href="#l5">Listing Five</a>(b), note the references to various Boolean flags&#151;variables <i>m_bInitialLoadInProgress, m_bDynamicUpdate, m_bLoadPaused,</i> and <i>m_bStopRequested</i>. To load new events from the log file as they are written, the I/O loop is continuous. If set to True, the variable <i>m_bInitialLoadInProgress</i> indicates that the end of the file has not yet been reached. Once the end of file is reached, new events (if any) are read from the file after putting the file I/O thread to sleep briefly so as not to hog the CPU when the bulk of the I/O task is finished.</p><p>Again, the UI thread communicates indirectly with the file I/O thread. The checkbox labeled "Dynamic Update" is initially checked. The variable <i>m_bDynamicUpdate</i> alternates between True and False as users uncheck/recheck the checkbox. While False, "tailing" the file is disabled.</p><p>Similarly, the variable <i>m_bLoadPaused</i> is synchronized with the state of the Pause Load checkbox. While False, file loading is disabled. Also, when a user selects Close, Exit, or Open from the File menu and clicks OK on the confirmation prompt, the variable <i>m_bStopRequested</i> is set to True. On detecting that the user has confirmed closing the current file, <i>PopulateListThreadFunc</i> returns.</p><h3>Multicolumn Sorting</h3><p>The .NET Framework defines the <i>IComparer</i> interface in the <i>Systems.Collections</i> namespace. It is used to specify how pairs of objects are compared for sorting and searching purposes. For instance, <i>IComparer</i> is used by the static methods <i>Sort</i> and <i>BinarySearch</i> of the .NET Framework class <i>Array</i>.</p><p>The default sort behavior of the <i>ListView</i> class is case sensitive based on item text, the text displayed in the left-most column of the grid. By creating a class that implements the <i>IComparer</i> interface, it is possible to alter this behavior. <a name="rl6"></a><a href="#l6">Listing Six</a> contains the <i>ListViewItemComparer</i> class, which derives from <i>IComparer</i>. Note that it has a custom constructor that takes an array of sort columns, a corresponding array of sort orders, and a reference to the plug-in parser interface. Its implementation of the interface method <i>Compare</i> iterates over the sort columns starting with the most dominant sort column, using the sort order and data type of each, to determine which <i>ListViewItem</i> is greater.</p><p>The data type of a field determines how to properly compare two items on that field. The parser holds the attributes of all of the fields and exposes them via the plug-in parser interface. Hence, the call to the interface method <i>GetSortDataType</i> is needed.</p><h3>Conclusion</h3><p>Among other improvements over MFC and other older frameworks, .NET represents a consistent programming model that hides the details of Win32 API programming and offers a rich class library. Although the details of filtering and parsing were beyond the scope of this article, there are many ways to present a UI for filtering the rows of a grid and to perform the filtering task. Likewise, there are numerous techniques for parsing events in a log file. Each format imposes constraints that emphasize one technique over others. The classes in the .NET namespace <i>System.Text.RegularExpressions</i> unleash the power of regular expressions. They can be applied wherever a pattern can be identified in the text. It can be advantageous to have several related log files open at the same time for browsing/searching. A multidocument extension is a planned enhancement for LogChipper.</p><p><b>DDJ</b></p>		<br><br><b><a name="l1"></a>Listing One</b><br><pre>/********************************************************This file is part of the LogChipper(tm) software product.Copyright (C) 2004 Ivden Technologies, Inc. All rights reserved.********************************************************/public interface ILogViewParser{   void Initialize(string sFileName, Mutex sortParseMutex);   void SetListViewColumnInfo(ref ListViewColumnInfo lvColumnInfo);   int FormatGridColumns(ListView listViewMain,ListView listViewSort);   bool ParseLineIntoGrid(string line, ListView listViewMain,       ListView listViewSort,SortOrder order,ref int nNewRow);   void GetAllHeadings(string[] sHeadings);   SortDataType GetSortDataType(int iCol);   string GetColumnHeading(int iCol);   int GetColumnWidth(int iCol);   void DisplayHeading(ListView listView,int iCol,string adornedValue);   void GetPluginMenuItems(MenuItem[] menuItems);}</pre><a href="#rl1">Back to article</a><br>			<br><br><b><a name="l2"></a>Listing Two</b><br><pre>/********************************************************This file is part of the LogChipper(tm) software product.Copyright (C) 2004 Ivden Technologies, Inc. All rights reserved.********************************************************/System.Runtime.Remoting.ObjectHandle handle =     Activator.CreateInstanceFrom(sPluginFile + ".dll", "LogViewPlugin.Parser"); m_LogViewParser = (LogViewInterfaces.ILogViewParser)handle.Unwrap();m_LogViewParser.Initialize(sFormatFile + ".xml", m_SortParseMutex);m_nColumns = m_LogViewParser.FormatGridColumns(listViewMain, listViewSort);m_lvColumnInfo = new ListViewColumnInfo();m_lvColumnInfo.SetSortColumns(m_anSortCols);m_lvColumnInfo.SetSortOrders(m_anSortOrders);m_LogViewParser.SetListViewColumnInfo(ref m_lvColumnInfo);if (m_nColumns &gt;= 1){    m_sFormatFileName = sFormatFile;    menuFormat.MenuItems.Clear();    MenuItem[] menuItems = null;    m_LogViewParser.GetPluginMenuItems(ref menuItems);    int nMenuItems = menuItems.Length;    for (int iItem = 0; iItem &lt; nMenuItems; iItem++)    {        menuFormat.MenuItems.Add(iItem, menuItems[iItem]);    }}</pre><a href="#rl2">Back to article</a><br>			<br><br><b><a name="l3"></a>Listing Three</b><br>(a)<pre>/********************************************************This file is part of the LogChipper(tm) software product.Copyright (C) 2004 Ivden Technologies, Inc. All rights reserved.********************************************************/m_HeaderMenuItems = new MenuItem[3];m_HeaderMenuItems[0] = new MenuItem("&amp;Numeric Tags", new System.EventHandler(                                         HeaderMenu_NumericTags_OnClick));m_HeaderMenuItems[1] = new MenuItem("&amp;Alphabetic Labels",                  new System.EventHandler(HeaderMenu_AlphaLabels_OnClick));m_HeaderMenuItems[2] = new MenuItem("&amp;Both",                   new System.EventHandler(HeaderMenu_Both_OnClick));m_MenuItems = new MenuItem[1];m_MenuItems[0] = new MenuItem("&amp;Header Format", m_HeaderMenuItems);</pre>(b)<pre>private voidHeaderMenu_AlphaLabels_OnClick(object sender, System.EventArgs e){    if (m_headerFormat != HeaderFormat.Alpha)    {        m_headerFormat = HeaderFormat.Alpha;        UpdateColumnHeadings(m_asColLabels);    }}</pre><a href="#rl3">Back to article</a><br>			<br><br><b><a name="l4"></a>Listing Four</b><br><pre>/********************************************************This file is part of the LogChipper(tm) software product.Copyright (C) 2004 Ivden Technologies, Inc. All rights reserved.********************************************************/&lt;?xml version="1.0" encoding="utf-8" ?&gt;&lt;configuration&gt;    &lt;appSettings&gt;        &lt;add key="PluginAssembly_1" value="LogViewPlugin_FIX_4_1" /&gt;        &lt;add key="PluginFormatFile_1" value="Fix_4_1_LogFormat" /&gt;        &lt;add key="UserDataRootFolder" value="c:\Temp" /&gt;    &lt;/appSettings&gt;&lt;/configuration&gt;</pre><a href="#rl4">Back to article</a><br>			<br><br><b><a name="l5"></a>Listing Five</b><br>(a)<pre>/********************************************************This file is part of the LogChipper(tm) software product.Copyright (C) 2004 Ivden Technologies, Inc. All rights reserved.********************************************************/// Restore selected columns, their widths and order// and selected sort columns and their sort order.RestoreViewSettings();// Populate list view.m_bInitialLoadInProgress = true;m_bLoadInProgress = true;m_thPopulateList = new Thread(new ThreadStart(PopulateListThreadFunc));m_thPopulateList.Priority = ThreadPriority.Lowest;m_thPopulateList.Start();</pre>(b)<pre>while (!m_bStopRequested){    int nNewRow = -1;    while (((line = sr.ReadLine()) != null) &amp;&amp;        !m_bStopRequested &amp;&amp;        (m_bInitialLoadInProgress || m_bDynamicUpdate))    {        if (m_bStopRequested)        {            m_bStopRequested = false;            m_bLoadInProgress = false;            return;        }        while (m_bLoadPaused)        {            Thread.Sleep(100);            if (m_bStopRequested)            {                m_bStopRequested = false;                m_bLoadInProgress = false;                return;            }        }        m_SortParseMutex.WaitOne();        nNewRow = -1;        if (m_bAutoScroll)        {            listViewMain.BeginUpdate();        }        bool bParse = m_LogViewParser.ParseLineIntoGrid(line,            listViewMain, listViewSort, listViewSort.Sorting, ref nNewRow);        if (m_bAutoScroll)        {            listViewMain.EndUpdate();        }        if (!bParse)        {            m_SortParseMutex.ReleaseMutex();            break;        }        if (m_bAutoScroll &amp;&amp; (nNewRow &gt;= 0))       {            listViewMain.EnsureVisible(nNewRow);        }        m_SortParseMutex.ReleaseMutex();    }}</pre><a href="#rl5">Back to article</a><br>			<br><br><b><a name="l6"></a>Listing Six</b><br><pre>/********************************************************This file is part of the LogChipper(tm) software product.Copyright (C) 2004 Ivden Technologies, Inc. All rights reserved.********************************************************/class ListViewItemComparer : IComparer{    private int m_nSortColumns;    private ArrayList m_anSortCols;    private ArrayList m_anSortOrders;    private LogViewInterfaces.ILogViewParser m_LogViewParser;    public ListViewItemComparer()     {    }    public ListViewItemComparer(ArrayList anSortCol,ArrayList anSortOrder,                               LogViewInterfaces.ILogViewParser logViewParser)    {        m_nSortColumns  = anSortCol.Count;        m_anSortCols    = anSortCol;        m_anSortOrders  = anSortOrder;        m_LogViewParser = logViewParser;    }    public int Compare(object x, object y)     {        int nRet = 0;        for (int iCol = 0; iCol &lt; m_nSortColumns; iCol++)        {            nRet = CompareSingleColumn(x,y,(int)m_anSortCols[iCol],                                             (SortOrder)m_anSortOrders[iCol]);            if (nRet != 0)            {                break;            }        }        return nRet;    }    public int CompareSingleColumn(object x, object y,                                                    int iCol, SortOrder order)    {        int nRet = 0;        string s1, s2;        SortDataType type = m_LogViewParser.GetSortDataType(iCol);        switch (type)        {            case    SortDataType.AlphaNoCase:                nRet = String.Compare(                   ((ListViewItem)x).SubItems[iCol].Text,                    ((ListViewItem)y).SubItems[iCol].Text, true);                break;            case    SortDataType.AlphaCase:                nRet = String.Compare(                    ((ListViewItem)x).SubItems[iCol].Text,                    ((ListViewItem)y).SubItems[iCol].Text);                break;            case    SortDataType.Date:            case    SortDataType.Time:                s1 = ((ListViewItem)x).SubItems[iCol].Text;                s2 = ((ListViewItem)y).SubItems[iCol].Text;                if ((s1.Length == 0) || (s2.Length == 0))                {                    nRet = String.Compare(s1, s2);                    break;                }                try                {                    DateTime dt1 = DateTime.Parse(s1);                    DateTime dt2 = DateTime.Parse(s2);                    nRet = DateTime.Compare(dt1, dt2);                }                // If neither object has valid date format, compare as strings.                catch                 {                    // Compare the two items as a string.                    nRet = String.Compare(s1, s2);                }                break;            case    SortDataType.Number:                double d1 = 0;                double d2 = 0;                s1 = ((ListViewItem)x).SubItems[iCol].Text;                s2 = ((ListViewItem)y).SubItems[iCol].Text;                if ((s1 != null) &amp;&amp; (s1.Length &gt; 0))                {                    d1 = Convert.ToSingle(s1);                }                if ((s2 != null) &amp;&amp; (s2.Length &gt; 0))                {                    d2 = Convert.ToSingle(s2);                }                nRet = (d1 &lt; d2) ? -1 : 1;                break;        }        if(order == SortOrder.Descending)        {            nRet *= -1;        }        return nRet;    }}</pre><a href="#rl6">Back to article</a><br>			</body></html>