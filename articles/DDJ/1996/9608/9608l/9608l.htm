<HTML>
<META NAME="year" CONTENT="1996">
<HEAD>
<!-- This document was built using HyperWriter Professional by NTERGAID Inc. -->
<TITLE>August 1996: C Programming</TITLE></HEAD>
<body bgcolor="FFFFFF">
<P>

<h1>Hermits, Shortcuts, and Uninstall</h1><P>

<P>

<h3>Al Stevens</h3><P>

<P>

There's good news. The &quot;Computer Careers&quot; column of the May 6, 1996 ComputerWorld, by Lynn Haber, is titled, &quot;Damn, they're hot!&quot; and it's about you. The column reports on a nationwide shortage of C++ programmers. Demand runs high, and someone with two to five years experience programming C++ can command $70,000 on either coast and $65,000 in the central part of the country-according to the report. That should be good news.<P>

There's bad news, too. Many of the applicants for the choice C++ positions are C programmers who have learned only enough about the C++ syntax to get through an interview. They inadvertently misrepresent themselves as top guns, and the interviewers are not technically qualified to qualify the applicants. Mind, I'm not opposed to those folks getting jobs, but hiring them as senior developers on a C++ project is a mistake. Managers must know how to determine where in the project a newly hired programmer fits best. It's in your best interest to help your boss properly assign qualified people. You are going to be working side-by-side with those new programmers. A ringer could affect your productivity and bring down the whole shebang.<P>

I've sat in on some employment interviews for senior C++ positions recently. If you ask an applicant if he or she knows C++ inside-out, the answer is always yes. They will discuss projects they've worked on and programs they've written. Interviewers are usually impressed. The applicants usually aren't lying. They either aren't aware of what they don't know, or they count on their ability to learn fast. But many of them reveal only a superficial knowledge of C++ when faced with what ought to be some elementary questions. As for learning fast, it is my considered opinion that it takes at least a year of both programming and reading all the current literature for a seasoned C programmer to become moderately fluent in C++, and it takes longer to become an expert. I don't think anyone ever knows the language wall-to-wall.<P>

Here are a few questions that I use to indicate whether someone understands some fundamental differences between C and C++:<P>

<P>
<ul>
<li>How do you link a C++ program to C functions?</li>
<li>Explain the scope-resolution operator.</li>
<li>What are the differences between a C struct and a C++ struct? A C++ class?</li>
<li>How many ways are there to initialize an int with a constant?</li>
<li>How does throwing and catching exceptions differ from using setjmp and longjmp?</li>
</ul>
<P>

This line of questioning is meant to get a feel for the person's overall understanding. If an applicant claims to have done extensive class design, here are some questions that reveal how well they understand that technology:<P>

<P>
<ul>
<li>What is your reaction to the line of code delete this;?</li>
<li>What is a default constructor?</li>
<li>What is a conversion constructor?</li>
<li>What is the difference between a C++ struct and a C++ class?</li>
<li>When should you use multiple inheritance?</li>
<li>What is a virtual destructor?</li>
<li>Explain the ISA and HASA class relationships. How would you implement each in a class design?</li>
<li>When is a template a better solution than a base class?</li>
</ul>
<P>

Suppose an applicant claims to have kept up with the language advances proposed by the ANSI committee. Ask these questions to see how in touch they really are:<P>

<P>
<ul>
<li>What is a mutable member?</li>
<li>What is an explicit constructor?</li>
<li>What is the Standard Template Library?</li>
<li>Describe run-time type information.</li>
<li>What problem does the namespace feature solve?</li>
<li>Are there any new intrinsic (built-in) data types?</li>
</ul>
<P>

The purpose of all this is to determine an applicant's skill level. I usually mix the questions up so that it's not obvious where I'm heading. I ask the questions verbally in a relaxed, conversational manner. You have to be careful these days with anything resembling a written test, particularly on a government project. For some reason, the Labor Department doesn't want you disqualifying anyone based on their inability to demonstrate that they can do the job. I'll discuss what I think are reasonable answers to these questions next month. I'd like to hear your ideas on this subject.<P>

<h3>Herman's Hermits</h3><P>

I've been using this column to chronicle the development of a C/C++ training CD-ROM, which is being marketed by DDJ and which I take pleasure in plugging shamelessly at every turn. I have told you about the development of Quincy 96, an IDE front end to the GNU C/C++ compilers; Herman, a text viewer for the text of the books that provided the CD-ROM's content; and the Setup program. This month, I'll finish the Setup program, discuss the Uninstall program, and thereby bring to an end this project and the endless Pournellean plugs that accompany its every discussion.<P>

First, however, I want to do some follow-up to an issue that I raised during the discussion of Herman. I ran afoul of the Win32/MFC API when trying to implement a rich-text format (RTF) viewer that also displays graphics in the documents. That discussion, the program, and my speculations about MFC and OWL generated some interesting mail from readers. It seems that a lot of you spend altogether too much time away from polite society, squinting at your screens, hammering at your keyboards, neglecting friends and family, and dealing with programming issues such as those raised by Herman. You are therefore and heretofore dubbed &quot;the Hermits,&quot; and here are some of your delightful letters.<P>

This first note comes from Ed Diener in response to my concern that all my MFC wrangling could be done with a few lines of OWL code:<P>

Actually, with OWL you don't have to write a single line of code. When you start the Borland 5.0 IDE, the TMindProbe class is automatically activated, which sets a periodic timer that picks up your brain waves and, if at any time you are thinking about the Windows 95 Rich Text Edit Control, it automatically writes the functionality into whatever you are currently working on. This is an undocumented feature of BC++ 5.0. Of course, true-blue OWL programmers will tell you that, given the state of the Borland documentation which has been unanimously voted worst programming tool documentation for the 10th straight year, all features of BC++ 5.0 are undocumented but take my word for it, this one really is.<P>

Not even Mike Swaine could come up with better satire. Ed takes my preference for MFC over OWL very much to heart. He goes on to say:<P>

At work as a consultant on a BC++ 16-bit Windows project, all the programmers want to go to Visual C++ and MFC for the 32-bit version. I'm the only Borland fanatic left. When I ask is it because Borland wastefully supports the C++ Standard Library while Microsoft cleverly doesn't, they shake their heads no. When I ask is it because MFC neatly ropes you into the Doc/View architecture while Borland doesn't, thereby obviously giving you enough rope with which to hang yourself with if you so desire, they again shake their heads no. When I ask if it's because OWL encapsulates the entire confusing Window's API while MFC selectively encapsulates only the most important portions, they again say no. When I ask if it's because Borland confuses you by using in OWL the obviously arcane C++ features of virtual base classes and multiple inheritance while Microsoft has righteously avoided this mess with their much cleaner and simpler architecture, they say no once more. What is it I cry, beg, plead, cajole, etc. It's this Ed, they say. The DDJ C++ column writer, Al Stevens, has declared MFC the best and the standard, and that's reason enough for us.<P>

What finer endorsement could I ask? John B. Williston sends his reminiscences about learning and doing Windows programming:<P>

When I learned C, the standard C library seemed quite functional; it was a rare thing indeed if I ran into some undocumented problem with Microsoft's implementation. Thus, when I got my first Windows/386 SDK, I assumed the same would be true. I quickly discovered just how wrong I was.<P>

Windows is supposed to be a black box; unfortunately, I found that my value as a Windows developer was not in my knowledge of the API but rather in my knowledge of all the hidden gotchas. I became the local guru and quickly found myself answering all kinds of esoteric questions.<P>

When I got my copy of MSC7, I took an immediate liking to MFC. It was much cleaner in so many ways than the schizophrenic C/C++ mixture I was coding. Soon after Visual C++ was released, however, MFC went the way of the Windows API: It did a great deal for you, but changing its default behavior was not for the faint of heart.<P>

So, here I sit today armed with VC++ and MFC 4.1; my IDE has SourceSafe, Visual Test, and MSDN a mere mouse click away. To this day, I still end up hacking my way through the MFC underbrush every time I want to depart in the slightest way from its positively draconian feature list. I keep asking myself if this really is progress.<P>

Probably not, but it's interesting and keeps us working. J.D. Robinson reported experiences similar to those that I discussed and came up with a less complex solution than mine:<P>

The CRichEdit fiasco is something I just went through, writing the mail program I'm using right now. Not that this is any better a solution than yours, but it seemed more straightforward to me at the time.<P>

CRichEditDoc wouldn't work at all for me, mainly because I, too, had a splitter window that needed it [to be] a generic CDocument class. But noticing that the only thing CRichEditView really complained about was an assertion on GetDocument(), I simply replaced the call with CView::GetDocument().<P>

Not using CRichEditDoc eliminates much of the OLE capability of the Doc/View set of CRichEdit, but I don't need that. I just need, like you did, the capability to stream in and out formatted text.<P>

I wish I'd thought of that. Thomas Kaufmann is adapting Herman for use in a commercial application. He sent a message asking permission to use Herman (permission granted, you may use any of the code I publish), adding that he had made a few minor changes to the code to make Herman look more like Microsoft InfoViewer. Thomas included modified versions of Herman's table of contents, CListView class, and some open and closed book icons to add to the display. Much appreciated, and the changes are now in the version of Herman that I use.<P>

Not all the messages are positive. In balance, here's one from Sergey I. Yevtushenko, a reader who disapproves of the direction I've taken:<P>

Over last 5 years I'm reading your articles in DDJ. Even more: one of the my first book in C programming was your Programming in Turbo C (sorry for possible mistake, because I'm read unofficial Russian version of this book, they was very wide used in ex-SU [the former Soviet Union] for teaching C yourself). Every time I'm was impressed with quality of your code and design of your programs and libraries. This was. But now you sell yourself to Microsoft, and forget about rest of the world of programming. I'm very sorry. You loose! at least one reader in face of mine.<P>

That's sad, but if you think Microsoft bought me, or that I'm for sale to anyone, read what I have to say about the completeness of the Win32/MFC API and documentation in the next discussion.<P>

<h3>Adding to the Windows 95 Start Menu</h3><P>

You'd think that a hot-shot GUI API like Win32 would include functions for all routine operations. Take, for example, the business of adding items to the Windows 95 Start menu. That procedure is commonly in the province of a Setup program, and most applications use one of the setup program managers to build a Setup program from a script. Consequently, programmers don't have to worry about details such as how things get on the Start menu. When I decided to write my own setup program (discussed in last month's column), I ran smack dab into that concern. The Setup program I published last month did not add things to the Start menu, because I did not yet know how.<P>

Adding to the Start menu's Programs submenu is fairly simple. The whole thing is done with subdirectories. The WINDOWS\START MENU\PROGRAMS subdirectory is where all the Start\Programs items occur. To add submenus, you just add subdirectories. The Win32 API includes the _mkdir function for that purpose. The hard part is what goes into those subdirectories. You'd think that you could put executable files there, but Windows 95 ignores them when it displays the menus that cascade off the Start menu. The Start menu needs so-called &quot;shortcut&quot; files, which are links to the real executables. You will be surprised, no doubt, to learn that the procedure for building those links is not that well-documented. You can find a little bit of information in the documentation if you know exactly what you are looking for, but most people would not know where to start looking. When you do find the right reference, the information is incomplete and inaccurate. Perhaps Microsoft figured that everyone would use InstallShield or the Setup SDK. Even so, there are other times when programmers need to build shortcuts. Shortcuts can link to documents and other objects in addition to executable files. We need an easier way to build them.<P>

Windows 3.1 programmers have a different problem. Windows 3.1 does not support the link concept, so you can't build shortcuts to documents. Setup programs need to add groups and items to the Program Manager, which involves a cryptic and convoluted DDE interface to Program Manager. There should be an API function that encapsulates that procedure, too. I haven't found one, but, working mostly with Windows 95, I haven't searched all that diligently for a Windows 3.1 solution.<P>

<h3>Programmer's Guide to Microsoft Windows 95</h3><P>

I looked everywhere for help with the Windows 95 Start menu. Fortunately, being a famous and revered columnist, I am on the review copy mailing lists of most trade publishers, so my library of Windows 95 programming books (and every other kind of obscure programming book) is extensive. I finally found a reference to the Start menu in a book titled Programmer's Guide to Microsoft Windows 95, published in 1995 by Microsoft Press. The book has no author credits other than to say that due to the courtesy of some authors, the book contains articles previously published in other Microsoft publications. I'm sure that Microsoft paid them all a little extra taste for their courteous contribution to this book. I'm sure.<P>

One of the book's articles, titled &quot;Installing Applications,&quot; says, &quot;To add an icon to the Start menu, your installation program should create a link to your application's executable file and place the link in the directory named \WINDOWS\STARTMEN\PROGRAMS... An installation can create a link by using the IShellLink interface.&quot;<P>

There is an error in this statement, one that cost me some time I might add, thank you very much to whomever wrote the article. Apparently, early Windows 95 betas named that subdirectory STARTMEN, because my Windows 95 installation, which saw first light as a Chicago beta, has such a subdirectory. The shipping version of Windows 95 changed the name to &quot;Start menu.&quot; I fooled around in STARTMEN for a while before it hit me what was wrong. This book must predate that decision.<P>

Nonetheless, that clue got me pointed in the right direction. The IShellLink interface is the secret. Another of the book's articles, titled &quot;Shell Links,&quot; discusses the IShellLink interface and provides an example program. The source code has errors and is missing some stuff, such as some necessary #include statements, but between the example, Visual C++'s on-line help, and the error messages that the example produced when compiled, I was able to work out a procedure that worked.<P>

<h3>The Missing .Lnk</h3><P>

Microsoft's Win32 and MFC documentation has an annoying deficiency. It seldom tells you what header files you need to include when you use one of the API functions. The documentation has another equally annoying deficiency. It seldom (if ever) tells you which library files you need to include in the link when you use one of the API functions.<P>

I had to use Borland's grep utility against the VC++ header files to find references to the functions and globals that the example program uses. Then, as those header files generated their own errors for lack of other header files, I used grep iteratively until I had the list of header files needed to get a clean compile of a program that uses IShellLink.<P>

Linking the program that used IShellLink resulted in numerous unresolved references. I tried using LIB/LIST on the .Lib files to see which functions are in which libraries, but, for most of the files, that procedure lists only the names of the DLLs that support the library's functions. Odd, indeed. My only recourse was to generate a list of all the library files, link the program, and then selectively remove items from the list and relink until I had pared the list down to only the required files.<P>

My late friend Jim Weir would look into the eye of someone who had done something questionable, pretend not to know who was responsible, and say, &quot;What incredibly stupid moron came up with such an obviously idiotic idea?&quot; I'd like to put Jim eye-to-eye with whomever at Redmond decided that Win32 and MFC documentation do not require header and library file references.<P>

If you want to provide a useful service to MFC programmers, build a program that interactively reports the header and library files that a particular Win32 API call uses. Integrate that program into the Visual C++ editor. Don't count on building an empire from the sales, though. If you sell a lot of copies, the feature will surely be included in a future version of Visual C++.<P>

<h3>The MakeShortCut and AddToStartMenu Functions</h3><P>

<a href="9608l.htm#000f_026b">Listing One</A> contains two functions that I hereby submit ought to have been in the Win32 API all along. The MakeShortCut function makes a shortcut with the name specified in the second parameter. The shortcut is to the object specified in the third parameter and is placed in the subdirectory specified in the first parameter. The AddToStartMenu function adds an entry to the Start menu by making the appropriate subdirectory and calling MakeShortCut to build and copy the shortcut into the subdirectory. The first parameter names the submenu to be added to the Start/Programs menu. If the submenu already exists, the existing one is used. The second parameter contains a name for the program to be displayed in the menu selection. The third parameter is a path to the executable program file.<P>

<a href="9608l.htm#000f_026b">Listing One</A> shows the header files that you need to include in order to use IShellLink. To link a program that uses these functions, you must add UUID.LIB and OLE32.LIB to the Object/library modules list on the Link page of the Project Settings in Developer Studio. Depending on your original project build options, either library might already be included. My Setup program uses none of the optional features, so these additions are necessary.<P>

<h3>Uninstall</h3><P>

Having written a custom Setup program, I move next to the problem of uninstalling an application's installation. The problems faced by an uninstall program are simpler than those faced by Setup. You have to delete the application's files, delete any .INI files that the application added to the \WINDOWS subdirectory, and remove the application's entries on the Start menu. My application makes no changes to the registry and adds no DLLs to the WINDOWS\SYSTEM directory, so those issues do not apply.<P>

I wrote a simple dialog-based MFC program that has a Yes and a No button, which are the ID_OK and ID_CANCEL buttons with Yes/No captions. If you click Yes, the program uninstalls the application.<P>

The only problem to be solved is determining where Setup installed the application. To that purpose, I modified Setup to add a DDJTUTOR.INI file with an entry that specifies the installation subdirectory. The Uninstall program reads that parameter. A side problem would occur if someone deleted or tampered with that file. The program published does not try to deal with that. A more bullet-proof program would at least ensure that the subdirectory contains the files that the application expects to have deleted.<P>

<a href="9608l.htm#000f_026c">Listings Two</A> and <a href="9608l.htm#000f_026d">Three</A> are Uninstall.h and Uninstall.cpp, two unremarkable source-code files that implement and launch the application.<a href="9608l.htm#000f_026e"> Listings Four</A> and <a href="9608l.htm#000f_026f">Five</A> are UninstallDlg.h and UninstallDlg.cpp, which implement the uninstallation by overriding the OnOK function from the base CDialog class. The foundation of uninstallation is found in the Remove member function. The Remove function deletes all the files in a subdirectory by scanning for them and calling the Delete member function to delete each file. If a file is a subdirectory, the Remove function calls itself instead.<P>

The dialog consists of the Yes and No buttons, a CProgressCtrl control to report the progress of the uninstallation, and a static text control to report the name of the file being deleted.<P>

Uninstall cannot, unfortunately, delete its own .exe file or remove the subdirectory in which the Uninstall.exe file resides. The Uninstall program posts a message to that effect and advises the user to remove those things manually. If anyone knows how an executing program can unlock its own .exe file long enough to delete itself, I'd like to know about it. I'll call it the &quot;Kevorkian algorithm.&quot;<P>

<P>

<P>

<a name="000f_026b"><B>Listing One</B><PRE><P>

#include &quot;stdafx.h&quot; // built by VC++ Developer Stdio for your app

#include &lt;WINNETWK.H&gt;
#include &lt;SHLOBJ.H&gt;
#include &lt;WINNLS.H&gt;
#include &lt;direct.h&gt;

void MakeShortCut(LPCSTR lpszPathLink, LPCSTR lpszDesc,
                              LPCSTR lpszPathObj)
{
    CoInitialize(0);
    HRESULT hres;
    IShellLink *psl;
    hres = CoCreateInstance(CLSID_ShellLink, 0,
                 CLSCTX_INPROC_SERVER, IID_IShellLink, (void**)&amp;psl);
    if (SUCCEEDED(hres))    {
        IPersistFile* ppf;
        psl-&gt;SetPath(lpszPathObj);
        psl-&gt;SetDescription(lpszDesc);
        hres = psl-&gt;QueryInterface(IID_IPersistFile, (void**) &amp;ppf);
        if (SUCCEEDED(hres))    {
            WORD wsz[MAX_PATH];
            int nMbwc = MultiByteToWideChar(CP_ACP, 0,
                           lpszPathLink, -1, wsz, MAX_PATH);
            hres = ppf-&gt;Save(wsz, TRUE);
            ppf-&gt;Release();
        }
        psl-&gt;Release();
    }
    CoUninitialize();
}
void AddToStartMenu(LPCSTR lpszProgram, LPCSTR lpszDesc,
                            LPCSTR lpszPathObj)
{
    char szPathLink[MAX_PATH];
    GetWindowsDirectory(szPathLink, MAX_PATH);
    strcat(szPathLink, &quot;\\Start Menu\\Programs&quot;);
    // --- just in case there is no Programs submenu
    _mkdir(szPathLink);
    strcat(szPathLink, &quot;\\&quot;);
    // --- create Start Menu\Programs subdirectory for the shortcut
    strcat(szPathLink, lpszProgram);
    _mkdir(szPathLink);
    // --- create the shortcut path
    strcat(szPathLink, &quot;\\&quot;);
    strcat(szPathLink, lpszDesc);
    strcat(szPathLink, &quot;.lnk&quot;);
    MakeShortCut(szPathLink, lpszDesc, lpszPathObj);
}
</PRE><P>

<a name="000f_026c"><B>Listing Two</B><PRE><P>

// ---- Uninstall.h
#ifndef UNINSTALL_H
#define UNINSTALL_H
#include &quot;resource.h&quot;
class CUninstallApp : public CWinApp
{

public:
    CUninstallApp() { }
    BOOL InitInstance();
};
#endif

</PRE><P>
<a name="000f_026d"><B>Listing Three</B><PRE><P>

// --- Uninstall.cpp
#include &quot;stdafx.h&quot;
#include &quot;Uninstall.h&quot;
#include &quot;UninstallDlg.h&quot;
CUninstallApp theApp;
BOOL CUninstallApp::InitInstance()
{
#ifdef _AFXDLL
    Enable3dControls();
#else
    Enable3dControlsStatic();
#endif
    CUninstallDlg dlg;
    m_pMainWnd = &amp;dlg;
    dlg.DoModal();
    return FALSE;
}

</PRE>
<a name="000f_026e"><B>Listing Four</B><PRE><P>

// --- UninstallDlg.h
#ifndef UNINSTALLDLG_H
#define UNINSTALLDLG_H

class CUninstallDlg : public CDialog
{
    CProgressCtrl m_ctlProgress;
    CString m_strDoing;
    void Remove(const CString&amp; strPath);
    void Delete(const CString&amp; strFile);
    void DoDataExchange(CDataExchange* pDX);
    void OnOK();
public:
    CUninstallDlg(CWnd* pParent = NULL);
};
#endif
</PRE><P>

<a name="000f_026f"><B>Listing Five</B><PRE><P>

// --- UninstallDlg.cpp
#include &quot;stdafx.h&quot;
#include &lt;direct.h&gt;
#include &lt;io.h&gt;
#include &lt;sys\stat.h&gt;
#include &quot;Uninstall.h&quot;
#include &quot;UninstallDlg.h&quot;

CUninstallDlg::CUninstallDlg(CWnd* pParent):
                    CDialog(IDD_UNINSTALL_DIALOG, pParent)
{

    m_strDoing = &quot;&quot;;
}

void CUninstallDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    DDX_Control(pDX, IDC_PROGRESS, m_ctlProgress);
    DDX_Text(pDX, IDC_DOING, m_strDoing);
}
void CUninstallDlg::OnOK()
{
    // ---- set up the progress indicator
    int bQuincyInstalled = GetPrivateProfileInt(&quot;Setup&quot;, &quot;Quincy&quot;, 0,
                                                    &quot;DDJTutor.ini&quot;);
    // --- Quincy installed, range different than Quincy not installed
    m_ctlProgress.SetRange(0, bQuincyInstalled ? 300 : 20);
    m_ctlProgress.SetStep(1);

    char path[MAX_PATH];    // where the tutorial was installed
    if (GetPrivateProfileString(&quot;Setup&quot;, &quot;Path&quot;, &quot;&quot;, path,
                    MAX_PATH, &quot;DDJTutor.ini&quot;) != 0) {
        // ---- remove the DDJTUTOR subdirectory
        //      and all its files and subdirectories
        Remove(path);
        char msg[MAX_PATH + 200];
        sprintf(msg,
            &quot;Uninstall is complete. &quot;
            &quot;%s\\Programs\\Bin\\Uninstall.exe still exists. &quot;
       &quot;You may remove that file and those subdirectories manually.&quot;,
            path);
        // ---- remove the Shortcuts from the start menu
        GetWindowsDirectory(path, MAX_PATH);
        CString strWindir(path);
        Remove(strWindir + &quot;\\Start Menu\\Programs\\DDJ Tutorial&quot;);
        // ---- remove the .ini files from the windows subdirectory
        Delete(strWindir + &quot;\\ddjtutor.ini&quot;);
        Delete(strWindir + &quot;\\herman.ini&quot;);
        Delete(strWindir + &quot;\\quincy.ini&quot;);
        m_strDoing = &quot;&quot;;
        UpdateData(FALSE);
        // --- report the completion
        AfxMessageBox(msg);
    }
    CDialog::OnOK();
}
// ---- delete a subdirectory and all its files
void CUninstallDlg::Remove(const CString&amp; strPath)
{
    m_strDoing = &quot;Deleting &quot; + strPath;
    UpdateData(FALSE);
    // ------ scan for files to delete
    struct _finddata_t fileinfo;
    CString strSub = strPath + &quot;\\*.*&quot;;
    long hFile = _findfirst(strSub.GetBuffer(0), &amp;fileinfo);
    while (hFile != -1) {

        // ---- build file specification
        CString strFile(strPath);
        strFile += &quot;\\&quot;;
        strFile += fileinfo.name;
        if (fileinfo.attrib &amp; _A_SUBDIR)    {
            // --- this is a subdirectory
            if (*fileinfo.name != '.')
                Remove(strFile);
        }
        else
            // --- this is a file
            Delete(strFile);
        if (_findnext(hFile, &amp;fileinfo) == -1)
            hFile = -1;
    }
    _rmdir(strPath);
}
// ------ delete a file
void CUninstallDlg::Delete(const CString&amp; strFile)
{
    // ---- post the file name to the dialog
    m_strDoing = strFile;
    UpdateData(FALSE);
    // ---- step the progress indicator
    m_ctlProgress.StepIt();
    // ---- just in case someone write-protected the file
    _chmod(strFile, _S_IWRITE);
    // ---- delete the file
    remove(strFile);

}
</PRE>

</BODY></HTML>
