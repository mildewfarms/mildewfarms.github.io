<HTML> <HEAD> 
<META NAME="year" CONTENT="1996">
<!-- This document was built using HyperWriter Professional byNTERGAID Inc. --> 
<TITLE>December 1996:  Lua; An Extensible Embedded Language</TITLE>
</HEAD> <body bgcolor="FFFFFF"> <h1>Lua: an Extensible Embedded Language</h1><P>

<h1></h1><P>

<h2>A few metamechanisms replace a host of features</h2><P>

<P>

<h3>Luiz Henrique de Figueiredo, Roberto Ierusalimschy, and Waldemar
Celes</h3><P>

<P>

<P> <i>The authors are researchers at TeCGraf-Grupo de Tecnologia em Computacao
Grafica in Rio de Janeiro. They can be contacted at
lua@icad.puc-rio.br.</i></p><hr><P>

<P>

In recent years, a multitude of little languages have been proposed for extending
and customizing applications. In general, these extension languages should have
the following attributes:<P>
<ul>
<li>Clear and simple syntax (since it is not the main language for most of its
users).</li> <li>Small size and small implementation (so the cost of adding it to
the host will not be too high). </li> <li>Good data-description facilities (to
make it useful as a configuration language).</li> <li>Adequate extensibility (to
allow its use in high abstraction levels--for interfacing with users in diverse
domains).</li>
</ul>
Since extension languages are not for writing large pieces of
software, mechanisms for supporting programming-in-the-large, like static type
checking and information hiding, are not essential.<P>

Lua, the extensible, embedded language we present here, satisfies these
requirements. Its syntax and control structures are simple and familiar. Lua is
small--the whole implementation is less than 6000 lines of ANSI C. Besides the
facilities common to most procedural languages, Lua has special features that
make it a powerful high-level extensible language: <P>
<ul>
<li>Ability to define and manipulate functions as first-class values, which
greatly simplifies the implementation of object-oriented facilities. </li>
<li>Associative arrays--powerful language constructs that implement most data
containers. </li> <li>Garbage collection, negating the need for explicit managing
of memory allocations--a major source of programming errors. </li> <li>A fallback
mechanism, allowing extension of the semantics of the language. </li>
<li>Reflexive facilities, allowing the creation of highly polymorphic parts.</li>
</ul>
Lua is a general-purpose embedded programming language designed to support
procedural programming with data-description facilities. Although it is not
in the public domain (TeCGraf retains the copyright), Lua is freely available for
both academic and commercial purposes at http://www.inf.puc-rio.br/~roberto/
lua.html. The distribution also includes a standard library of mathematical
functions (<I>sin, cos,</I> and so on), I/O and system functions, and
string-manipulation functions. This optional library adds some 1000 lines of code
to the system. Also included are a debugger and a separate compiler that produces
portable binary files containing bytecodes. The code compiles without change in
most ANSI C compilers, including gcc (on AIX, IRIX, Linux, Solaris, SunOS, and
ULTRIX), Turbo C (on DOS), Visual C++ (on Windows 3.1/95/NT), Think C (MacOS),
and CodeWarrior (MacOS).<P>

All external identifiers are prefixed with <I>lua</I> to avoid name clashing when
linking with applications. Even the code generated by yacc passes through a sed
filter to comply with this rule, so that it is possible to link Lua with
applications that use yacc for other purposes.<P>

<h3>The Lua Implementation</h3><P>

Lua is provided as a small library of C functions to be linked to host
applications. For example, the simplest Lua client is the interactive,
stand-alone interpreter in <a href="9612c.htm#00ef_0084">Listing One</A>. In this
program, the function <I>lua_dostring</I> calls the interpreter over a section of
code contained in a string. Each chunk of Lua code may contain a mixture of
statements and function definitions.<P>

The header file lua.h defines Lua's API, which has about 30 functions. Besides
<I>lua_dostring</I>, there is a <I>lua_dofile</I> function to interpret Lua code
contained in files, <I>lua_getglobal</I> and <I>lua_setglobal</I> to manipulate
Lua global variables, <I>lua_call</I> to call Lua functions, <I>lua_register</I>
to make C functions accessible from Lua, and so on.<P>

Lua has a syntax somewhat similar to Pascal. To avoid dangling
<I>els</I><I>e</I>s, control structures like <I>i</I><I>f</I>s and
<I>whil</I><I>e</I>s finish with an explicit <I>end</I>. Comments follow the Ada
convention, starting with "--" and run until the end of the line. Lua supports
multiple assignment; for example, <I>x, y = y, x</I> swaps the values of <I>x</I>
and <I>y</I>. Likewise, functions can return multiple values.<P>

Lua is a dynamically typed language. This means that values have types but
variables don't, so there are no type or variable declarations. Internally, each
value has a tag that identifies its type; the tag can be queried at run time with
the built-in function <I>type</I>. Variables are typeless and can hold values of
any type. Lua's garbage collection keeps track of which values are being used,
discarding those that are not. <P>

Lua provides the types <I>nil</I>, <I>string</I>, <I>number</I>, <I>user
data</I>, <I>function</I>, and <I>table</I>. <I>nil</I> is the type of the value
<I>ni</I><I>l</I>; its main property is that it is different from any other
value. This is handy to use as the initial value of variables, for instance. The
type <I>number</I> represents floating-point real numbers. <I>string</I> has the
usual meaning. Type user data<I> corresponds to a generic void</I>* pointer in C,
and represents host objects in Lua. All of these types are useful, but the
flexibility of Lua is due to functions and tables, the product of two key lessons
from Lisp and Scheme:<P>

<P>
<ul>
<li>Functions should be first-class values.</li> <li>Languages should have a
single and strong unifying data constructor (lists in Lisp, tables in Lua).</li>
</ul>
<P>

Function values in Lua can be stored into variables, passed as parameters to
other functions, stored in tables, and the like. <P>

When you declare a function in Lua (see<a href="9612c.htm#00ef_0085"> Listing
Two</A>), the function body is precompiled into bytecodes, creating a function
value. This value is assigned to a global variable with the given name. C
functions, on the other hand, are provided by the host program through an
appropriate call to the API. Lua cannot call C functions that have not been
registered by their host. Therefore, the host has complete control over what a
Lua program can do, including any potentially dangerous access to the operating
system.<P>

<h3>Tables</h3><P>

Tables are for Lua what lists are for Lisp: powerful data-structuring mechanisms.
A table in Lua is similar to an associative array. Associative arrays can be
indexed with values of any type, not just numbers.<P>

Many algorithms become trivial when implemented with associative arrays, because
the data structures and algorithms for searching them are implicitly provided by
the language. Lua implements associative arrays as hash tables.<P>

Unlike other languages that implement associative arrays, tables in Lua are not
bound to a variable name. Instead, they are dynamically created objects that can
be manipulated much like pointers in conventional languages. In other words,
tables are objects, not values. Variables do not contain tables, only references
to them. Assignment, parameter passing, and function returns always manipulate
references to tables, and do not imply any kind of copy. While this means that a
table must be explicitly created before it is used, it also allows tables to
freely refer to other tables. So, tables in Lua can be used to represent
recursive data types and to create generic graph structures, even those with
cycles.<P>

Tables simulate records simply by using field names as indices. Lua makes this
easier by providing <I>a.name</I> as syntactic sugar for
<I>a</I><I>[&quot;name&quot;]</I>. Sets also can be easily implemented by storing
their elements as indices of a table. Note that tables (and therefore sets) need
not be homogeneous; they can store values of all types simultaneously, including
functions and tables.<P>

Lua provides a constructor, a special kind of expression to create tables, that
is handy for initializing lists, arrays, records, etc. See <a href="9612c.htm#00ef_007d">Example 1</A>.<P>

<h3>User-Defined Constructors</h3><P>

Sometimes you need finer control over the data structures you are building.
Following the philosophy of providing only a few general metamechanisms, Lua
provides user-defined constructors. These constructors are written
<I>nam</I><I>e</I><I>{...},</I> which is a more intuitive version of
<I>nam</I><I>e</I><I>({...})</I>. In other words, with such a constructor, a
table is created, initialized, and passed as a parameter to a function. This
function can do whatever initialization is needed, such as dynamic type checking,
initialization of absent fields, and auxiliary data-structure update, even in the
host program.<P>

User-defined constructors can be used to provide higher-level abstractions. So,
in an environment with proper definitions, you can write
<I>window</I><I>1=</I><I>Windo</I><I>w</I><I>{</I><I>x</I><I>=200,
</I><I>y</I><I>=</I><I>300,
colo</I><I>r</I><I>=&quot;blu</I><I>e</I><I>&quot;}</I> and think about
"windows," not plain tables. Moreover, because constructors are expressions, they
can be nested to describe more complex structures in a declarative style, as in<a href="9612c.htm#00ef_02ef"> Listing Four</A>.<P>

<h3>Object-Oriented Programming</h3><P>

Because functions are first-class values, table fields can refer to functions.
This is a step toward object-oriented programming, and one made easier by simpler
syntax for defining and calling methods.<P>

A method definition is written as<a href="9612c.htm#00ef_007e"> Example 2(a)</A>,
which is equivalent to <a href="9612c.htm#00ef_007f">Example 2(b)</A>. In
other words, defining a method is equivalent to defining a function, with a
hidden first parameter called <I>self</I><I> </I>and storing the function
in a table field.<P>

A method call is written as <I>receiver: method(params),</I> which is translated
to <I>receiver.method(receiver,params)</I>. The receiver of the method is passed
as the first argument of the method, giving the expected meaning to the parameter
<I>self</I>.<P>

These constructions do not provide information hiding, so purists may (correctly)
claim that an important part of object orientation is missing. Moreover, Lua does
not provide classes; each object carries its own method-dispatch tables.
Nevertheless, these constructions are extremely light, and classes can be
simulated using inheritance, as is common in other prototype-based languages,
such as Self. <P>

<h3>Fallbacks</h3><P>

Because Lua is an untyped language, many abnormal run-time events can happen:
arithmetic operations being applied to nonnumerical operands, nontable values
being indexed, nonfunction values being called. In typed, stand-alone languages,
some of these conditions are flagged by the compiler; others result in aborting
the program at run time. It's rude for an embedded language to abort its host
program, so embedded languages usually provide hooks for error handling.<P>

In Lua, these hooks are called "fallbacks" and are also used for handling
situations that are not strictly error conditions, such as accessing an absent
field in a table and signaling garbage collection. Lua provides default fallback
handlers, but you can set your own handlers by calling the built-in function
<I>setfallback</I> with two arguments: a string identifying the fallback
condition (see <a href="9612c.htm#00ef_0083">Table 1</A>), and the function to be
called whenever the condition occurs. <I>setfallback</I> returns the old fallback
function, so you can chain fallback handlers if necessary.<P>

<h3>Inheritance via Fallbacks</h3><P>

One of the most interesting uses of fallbacks is in implementing inheritance in
Lua. Simple inheritance allows an object to look for the value of an absent field
in another object called its "parent;" in particular, this field can be a method.
This mechanism is a kind of object inheritance, in contrast to the more
traditional class inheritance adopted in Smalltalk and C++.<P>

One way to implement simple inheritance in Lua is to store the parent object in a
distinct field, <I>parent </I>for instance, and set an "index" fallback function;
see<a href="9612c.htm#00ef_02f0"> Listing Five</A>. This code defines a function
<I>In</I><I>herit</I> and sets it as the index fallback. Whenever Lua attempts to
access a field that is absent in an object, the fallback mechanism calls the
function <I>Inherit</I>. This function first checks whether the object has a
field <I>parent </I>containing a table value. If so, it attempts to access the
desired field in the parent object. If the field is not present in the parent,
the fallback is automatically called again. This process is repeated "upwards"
until a value for the field is found or the parent chain ends. When better
performance is needed, the same inheritance scheme can be implemented in C using
Lua's API.<P>

<h3>Reflexive Facilities</h3><P>

Being an interpreted language, Lua provides some reflexive facilities. One
example is the function <I>type,</I> already mentioned. Other powerful reflexive
functions are <I>next</I>, which traverses a table, and <I>nextvar</I>, which
traverses all global variables. The function <I>next</I> gets two arguments, a
table and an index in the table, and returns a "next" index in some
implementation-dependent order. (Recall that tables are implemented as hash
tables.) It also returns the value associated with the index in the table.
(Recall that functions in Lua can return multiple values.) The function
<I>nextvar</I> has similar behavior, but it traverses the global variables
instead of the indices of a table.<P>

An interesting example using reflexivity is dynamic typing. As noted before, Lua
has no static typing. However, sometimes it is useful to check if a given value
has the correct type to prevent weird behavior in a program. It's easy to check
simple types with <I>type</I>. But for tables, we must check whether all fields
are present and correctly filled.<P>

Using Lua's data-description facilities, you can use values to describe types: A
single type is described by its name, and a table type is described by a table
that maps each field to its required type (<a href="9612c.htm#00ef_02f1">Listing
Six</A>). Given such descriptions, you can write a single, polymorphic function
that checks whether a value has a given type; see<a href="9612c.htm#00ef_02f2"> Listing Seven</A>.<P>

Reflexive facilities also allow a program to manipulate its own environment. For
instance, a program can create a "protected environment" in which to run another
piece of code. This situation is common in agent-based applications, when a host
runs untrusted code received through the Internet (for instance, Web pages with
executable content, a trendy thing in these days of Java). Some extension
languages have to provide specific support for safe execution, but Lua is
flexible enough to do this using the language itself. <a href="9612c.htm#00ef_02f3">Listing Eight</A> shows how the whole global
environment can be saved in a table. A similar function restores a saved
environment. Because all functions are first-class values assigned to variables,
it is trivial to remove a function from the global environment. <a href="9612c.htm#00ef_02f4">Listing Nine</A> shows a function that runs a piece
of code in a protected environment.<P>

<h3>Binding Tk to Lua</h3><P>

A natural use of Lua is in the description of GUIs--where you need facilities to
describe hierarchies of objects (widgets) and to bind user actions to them. Lua
is suitable for such tasks because it combines data-description mechanisms with
simple, powerful, and extensible semantics. Indeed, we have developed several UI
toolkits with Lua.<P>

Although Tk is a versatile GUI toolkit, Tcl isn't the kind of language that
everyone feels comfortable with. Since we regard Lua as an alternative to Tcl, we
decided to implement a Tk/Lua binding, allowing access to Tk widgets from Lua.<P>

As far as possible, we preserved Tk's philosophy, including widget names,
attributes, and commands. Everyone knows how tempting it is to try to improve an
existing API, but in the long run, leaving it alone is better for Tk users,
because they do not have to learn new concepts. (It's also better for us, because
we don't have to write a new manual!) <P>

<h3>Creating Tk/Lua Widgets</h3><P>

We have mapped all Tk widgets to Lua. You create a widget describing its
attributes, using Lua table constructors. For instance, <a href="9612c.htm#00ef_0080">Example 3(a</A>) creates a button and stores it in
<I>b</I>; <I>b</I> is now an object that represents the button. After this
definition, you can use ordinary Lua syntax to manipulate the object. Hence, the
assignment <I>b.labe</I><I>l</I><I>=&quot;Hello world from Lua!&quot; </I>changes
the button's label and updates its image if it is already displayed on the
screen. A text-entry widget limited to 20 characters can be created with
<I>e</I><I>=</I><I>entr</I><I>y</I><I>{widt</I><I>h</I><I>=20}</I>. After this
widget is mapped on a displayed window, <I>e.current</I> contains the current
value assigned by the user to the widget. (We use the current field to store the
widget value, instead of using global variables as in Tcl/Tk.)<P>

Widgets are not automatically mapped on a window. Unlike the Tk/Tcl environment,
there isn't the concept of a current window in Tk/Lua. You must create a window
(which can be the main window or a top-level widget) to hold the other widgets,
and then explicitly map it onto the screen; see<a href="9612c.htm#00ef_0081">
Example 3(b)</A>.<P>

In this way, users can freely describe their dialogs, even cross-referencing
widgets and mapping them when necessary. We have also eliminated the need for
packing widgets explicitly, because it is more natural to specify layouts in a
descriptive manner. Thus, the window (main and top-level) and frame widgets are
used as containers that automatically pack their contents. For instance, to show
a message with two bottom buttons, you can write<a href="9612c.htm#00ef_0082">
Example 3(c)</A>. Besides all regular Tk widgets, we have also implemented two
additional canvases, one using a simplified API to Xlib, and another using
OpenGL.<P>

Almost all functions provided by these libraries were mapped to Lua. So you can
create sophisticated graphical applications that use direct manipulation on
custom widgets--solely in Lua.<P>

<h3>Accessing Widget Commands</h3><P>

All Tk widget commands are implemented as object methods in Tk/Lua. Their names,
parameters, and functionality were preserved. If <I>lb</I> represents a listbox
widget, then <I>lb:inser</I><I>t</I><I>(&quot;New item&quot;)</I> inserts a new
item in the list, following the Tk <I>insert </I>command for listboxes. On the
other hand, the most-used Tk widget command, <I>configure</I>, is no longer
needed because its effect is now obtained with simple assignments.<P>

The main and top-level widgets inherit the methods from the window manager. If
<I>w</I> represents a window, then <I>w:iconif</I><I>y</I><I>()</I> has its usual
effect.<P>

<h3>Behind the Scenes</h3><P>

Implementing Tk/Lua wasn't hard. Using the C interface to Tcl/Tk, we created a
service provider and registered it to be accessed from Lua. The Lua code that
implements the binding uses an object-oriented approach, with the index fallback,
as mentioned earlier. Each widget instance inherits from a class object, with the
widget class at the top of the hierarchy. This class provides standard methods
used by all widgets.<a href="9612c.htm#00ef_02f5"> Listing Ten</A> shows the
definition of this generic class and its method to set the focus to a widget. It
also shows the button class definition.<P>

As you now know, each widget is created with a table constructor. The constructor
sets the instance class, creates the widget, and stores it in a global array.
However, we also use a small trick--instead of returning the new table, the
constructor returns the widget location as a numeric ID (<a href="9612c.htm#00ef_02f6">Listing Eleven</A>).<P>

Hence, when Lua tries to index a widget, as in <I>b.label</I>, it calls a
fallback, because numbers cannot be indexed. This trick gives us complete control
over widget semantics. For instance, if <I>b</I> is a button (actually, <I>b</I>
stores an ID) and you set <I>b.label = &quot;New label,&quot;</I> then the
fallback is responsible for calling the appropriate service command to update the
widget.<P>

<a href="9612c.htm#00ef_02f7">Listing Twelve</A> shows the Tk/Lua "settable"
fallback function. This fallback is called at every attempt to index a nontable
value. First, we check whether the first parameter corresponds to a valid widget
ID. If it does, then we retrieve the widget table by accessing the global array.
Otherwise, we dispatch the occurrence to the previously registered fallback.<P>

The widgets in table <I>tklua_IDtable</I> have an internal field, called
<I>tkname</I>, that stores the corresponding Tk widget name. This name is used to
invoke Tk commands. We check whether there is a corresponding Tk widget and
whether the indexing value is a valid Tk attribute. If so, we ask the service
provider to change the widget attribute (calling the registered C function
<I>tklua_configur</I><I>e</I>). The assignment <I>h</I><I>[</I><I>f]=</I><I>v</I>
assures us that we can use the widget table to store values besides Tk
attributes. <P>

Implementing the "gettable" fallback is similar. In addition to these two
fallbacks, Tk/Lua also uses the index fallback to implement inheritance (<a href="9612c.htm#00ef_02f0">Listing Five</A>) and the "function" fallback to call
widget commands or window-manager commands.<P>

<h3>Conclusion</h3><P>

Extension languages are always interpreted, in one way or another. Simple
extension languages can be interpreted directly from source code. On the other
hand, embedded languages are usually powerful programming languages with complex
syntax and semantics. A more-efficient implementation technique for embedded
languages is now standard: Design a virtual machine suited to the needs of the
language, compile extension programs into bytecodes for this machine, and then
simulate the virtual machine by interpreting the bytecodes. We have chosen this
hybrid architecture for implementing Lua because lexical and syntactical analysis
are done only once, resulting in faster execution. Also, it allows extension
programs to be provided in precompiled bytecode form only, resulting in faster
loading and safer environments.<P>

<P>

<P>

<P>

<P>

<P>

<h4><a name="00ef_007d">Example 1: The table definitions in (a) are equivalent to
(b).</h4><P>

<P>

<pre>(a)   t = {}  -- empty table t[1] = i t[2] = i*2 t[3] = i*3 t[4] = i+j

(b)   t = {i, i*2, i*3, i+j} s = {a=x, b=y}</pre>

<P>

<P>

<h4><a name="00ef_007e"><a name="00ef_007f">Example 2: The method definition in
(a) is equivalent to (b).</h4><P>

<pre> (a)   function object:method(params) ... end

(b)   function object.method(self, params) ... end</pre>

<P>

<h4><a name="00ef_0082"><a name="00ef_0080"><a name="00ef_0081">Example 3: (a)
Creating and storing a button; (b) explicitly mapping a window onto the screen;
(c) showing a message with two bottom buttons.</h4><P>

<pre> (a)   b  = button{label = &quot;Hello world!&quot; command =
&quot;exit(0)&quot; }

(b)   w = toplevel{b} w:show()

(c)   b1 = button{label=&quot;Yes&quot;, command=&quot;yes=1&quot;} b2 =
button{label=&quot;No&quot;, command=&quot;yes=0&quot;} w  =
toplevel{message{text=&quot;Overwrite file?&quot;}, frame{b1, b2;
side=&quot;left&quot;}; side=&quot;top&quot; }</pre>

<P>

<P>

<h4><a name="00ef_0083">Table 1: Fallback conditions.</h4><P>

<pre>
<PRE>
String        Condition

&quot;arith&quot;       Arithmetic on invalid operands.

&quot;order&quot;       Order comparison on invalid operands.

&quot;concat&quot;      String concatenation on invalid operands.

&quot;getglobal&quot;   Reading the value of a global variable that has 
              not been defined.

&quot;index&quot;       Retrieving the value of an index not present in      
              a table.

&quot;gettable&quot;    Reading the value of an index in a nontable       
              value.

&quot;settable&quot;    Writing the value of an index in a nontable 
              value.

&quot;function&quot;    Calling a nonfunction value.

&quot;gc&quot;          Called during garbage collection for 
              each tablbeing collected.

&quot;error&quot;       Called when a fatal error occurs.</PRE>

</pre>

<P>

<P>

<a name="00ef_0084"><H3>Listing One</H3><P><PRE>

#include &lt;stdio.h&gt; #include &quot;lua.h&quot;

int main() { char line[BUFSIZ]; while (fgets(line,sizeof(line),stdin)!=0)
lua_dostring(line); return 0; }

</PRE><P>
<a name="00ef_0085"><H3>Listing Two</H3><P><PRE>

function map(list, func) local newlist = {} local i = 1 while list[i] do
newlist[i] = func(list[i]) i = i+1 end return newlist end

</PRE><P>

<H3>Listing Three</H3><P><PRE>

list = {} i = 4 while i &gt;= 1 do list = {head=i,tail=list} i = i-1 end

</PRE>

<a name="00ef_02ef"><a name="00ef_02ef"><H3>Listing Four</H3><P><PRE>

S = Separator{ drawStyle = DrawStyle{style = FILLED}, material =  Material{
ambientColor  = {0.377, 0.377, 0.377}, diffuseColor  = {0.800, 0.771, 0.093},
emissiveColor = {0.102, 0.102, 0.102}, specularColor = {0.0, 0.0, 0.0} },

transform = Transform{ translation = {64.293, 20.206, 0.0}, rotation    = {0.0,
0.0, 0.0, 0.0} }, shape = Sphere{radius = 10.0} }
</PRE>

<a name="00ef_02f0"><H3>Listing Five</H3><P><PRE>

function Inherit(t,f) if f == &quot;parent&quot; then  -- avoid loops return nil
end local p = t.parent if type(p) == &quot;table&quot; then return p[f] else
return nil end end

setfallback(&quot;index&quot;, Inherit)
</PRE>

<a name="00ef_02f1"><H3>Listing Six</H3><P><PRE>

TNumber=&quot;number&quot; TPoint={x=TNumber, y=TNumber} TColor={red=TNumber,
blue=TNumber, green=TNumber} TRectangle={topleft=TPoint, botright=TPoint}
TWindow={title=&quot;string&quot;, bounds=TRectangle, color=TColor}
</PRE>


<a name="00ef_02f2"><a name="00ef_02f2"><H3>Listing Seven</H3><P><PRE>

function checkType(d, t) if type(t) == &quot;string&quot; then -- t is the name
of a type return (type(d) == t) else -- t is a table, so d must also be a table
if type(d) ~= &quot;table&quot; then return nil else -- d is also a table; check
its fields local i,v = next(t,nil) while i do if not checkType(d[i],v) then
return nil end i,v = next(t,i) end end end return 1 end

</PRE>
<a name="00ef_02f3"><H3>Listing Eight</H3><P><PRE>

function save() -- create table to hold environment local env = {} -- get first
global var and its value local n, v = nextvar(nil) while n do -- save global
variable in table env[n] = v -- get next global var and its value n, v =
nextvar(n) end return env end
</PRE>

<a name="00ef_02f4"><H3>Listing Nine</H3><P><PRE>

function runProtected(code) -- save current environment local oldenv = save() --
erase &quot;dangerous&quot; functions readfrom,writeto,execute = nil,nil,nil --
run untrusted code dostring(code) -- restore original environment restore(oldenv)
end
</PRE>

<a name="00ef_02f5"><H3>Listing Ten</H3><P><PRE>

widgetClass = {} function widgetClass:focus() if self.tkname then
tklua_setFocus(self.tkname) end end buttonClass = { parent = widgetClass,
tkwidget = &quot;button&quot; }
</PRE>

<a name="00ef_02f6"><H3>Listing Eleven</H3><P><PRE>

function button(self) self.parent = classButton tklua_ID = tklua_ID + 1
tklua_IDtable[tklua_ID] = self return tklua_ID end
</PRE>

<a name="00ef_02f7"><H3>Listing Twelve</H3><P><PRE>

function setFB(id, f, v) local h = tklua_IDtable[id] if h == nil then return
old_setFB(id,f,v) end if h.tkname and h:isAttrib(f) then
tklua_configure(h.tkname,f,v) end h[f] = v end old_setFB =
setfallback(&quot;settable&quot;,setFB)


</PRE><P>



</BODY></HTML>
