<HTML>
<META NAME="year" CONTENT="1996">
<HEAD>
<!-- This document was built using HyperWriter Professional by NTERGAID Inc. -->
<TITLE>December 1996:  Undocumented Corner</TITLE></HEAD>
<body bgcolor="FFFFFF">
<h1>Inside MFC's <I>CSplitterWnd</I></h1><P>

<P>

<h3>George Shepherd and Scot Wingo</h3><P>

<P>

<P>
<i>Scot is a cofounder of Stingray Software. He can be contacted at ScotWi@aol.com. George is a senior computer scientist with DevelopMentor and can be contacted at 70023.1000@compuserve.com. They are the coauthors of MFC Internals (Addison-Wesley, 1996).</i></p><hr><P>

<P>

C<I>SplitterWnd is one of the most complicated and confusing of all MFC classes. This month, we'll examine the undocumented areas of </I>CSplitterWnd<I>; in our next column, we'll show how to apply this knowledge in your MFC applications. Before diving into the undocumented areas of </I>CSplitterWnd<I>, let's take a look at the anatomy of a splitter window.</I><P>

Like a real-world window, a splitter window (see <a href="19970429.htm">Figure 1</A>) contains panes; in MFC, there can be two or four panes. Panes are usually <I>CViews</I>, but <I>CSplitterWnd</I> is flexible enough that these can be any <I>CWnd</I> derivative. Users create a pane by grabbing the split box and dragging it to place a splitter bar. When there are two splitter bars, the point where the bars meet is called a "splitter intersection." <P>

Splitter windows internally maintain the panes in rows and columns. Since splitter windows use views as panes, when users change the document data the results are automatically updated in each pane. If you use <I>CWnd</I> derivatives as panes, this synchronization will be up to you.<P>

It is important to note that splitter windows have their own scrollbars. Splitter windows need their own scrollbar logic because the scrollbars often affect two panes at once. The bottom horizontal scrollbar scrolls both pane 1 and pane 2.<P>

<h3>How to Use <I>CSplitterWnd</I></h3><P>

Dynamic splitters let users create "splits" on the fly (as with Word, Excel, Visual C++, for example), while static splitters provide an always-present split that the user can move (as with Microsoft Explorer, Exchange, and the like).<P>

To create a static splitter window in your MFC application: <P>

1.Add a <I>CSplitterWnd</I> data member to your child-frame derivative (this will vary depending on whether you are using MDI or SDI); for example, <I>CSplitterWnd m_wndSplitter;.</I><P>

2.In the <I>CMyChildFrame::OnCreateClient()</I> handler, add a call to <I>CSplitterWnd::Create()</I>. <I>Create()</I> takes several arguments. The first is a pointer to the parent frame (usually <I>this</I>). The second and third arguments specify the maximum number of rows and columns. The fourth specifies a minimum allowable pane size. The fifth argument is a pointer to a <I>CCreateContext</I>. <a href="9612n.htm#012e_0420">Example 1</A> creates a splitter window with a maximum of two rows and two columns. The minimum pane size is 10x10 and the context pointer is passed through without change.<P>

<P>

Dynamic splitters in MFC are limited to 2x2, so the row and column argument are mostly used to restrict the rows and columns by specifying 1.<P>

That's all that is needed to add dynamic splitter windows to MFC applications. When users create a split, MFC automatically takes care of filling the splitter with the panes (views) that are wired together with the splitter window.<P>

To use static splitter windows, call <I>CreateStatic()</I> instead of <I>Create()</I>. It is also up to you to create the views for each static window since MFC does not know the type of the view to create. You create new panes by calling <I>CSplitterWnd::CreateView()</I>. <P>

Static splitter windows do not have the 2x2 restrictions of dynamic splitter windows. <P>

<a href="9612n.htm#012e_0305">Table 1 </A>is a list of the interesting <I>CSplitterWnd</I> members. Some are documented, others aren't. <P>

<h3>Inside <I>CSplitterWnd</I></h3><P>

<I>CSplitterWnd</I> is implemented entirely in MFC and is not a wrapper around a common control. Thus <I>CSplitterWnd</I> is one of the largest and most interesting of the MFC user-interface classes. <P>

<I>CSplitterWnd</I> is declared in AFXEXT.H. <a href="9612n.htm#012e_0421">Listing One</A> implements specific aspects of the declaration. In <a href="9612n.htm#012e_0421">Listing One</A>, we've retained numerous members in the declaration that are above the <I>// Implementation</I> section. While these members are documented, they are also important to understand the <I>CSplitterWnd</I> implementation. MFC does a great job of "virtualizing" <I>CSplitterWnd</I> so that you can create <I>CSplitterWnd</I> derivatives and change the default <I>CSplitterWnd</I> behavior. Once you understand more about how <I>CSplitterWnd</I> is implemented, this will be even easier. <P>

All of <I>CSplitterWnd</I> lives in the WINSPLIT.CPP MFC source file. You may want to open that file and refer to it in the following discussion.<P>

<h3><I>CSplitterWnd</I> Initialization</h3><P>

The <I>CSplitterWnd</I> constructor initializes <I>m_cxSplitter</I>, <I>m_cySplitter</I>, <I>m_cxBorderShare</I>, <I>m_cyBorderShare</I>, <I>m_cxSplitterGap</I>, <I>m_cySplitterGap</I>, <I>m_cxBorder</I>, and <I>m_cyBorder</I> to the values previously detailed. Both <I>Create()</I> and <I>CreateStatic()</I> eventually call <I>CreateCommon()</I>. <P>

<I>Create()</I> (see<a href="9612n.htm#012e_0422"> Listing Two</A>) begins with assertions that force the <I>CSplitterWnd</I> to be created with either or both <I>nMaxCols</I> and <I>nMaxRows</I> as 2. If maximum rows and columns are both 1, there would be no point in having a splitter window. Since dynamic splitters can only have two rows and columns, there are only three valid ways to call create--1,2; 2,1; or 2,2 as the maximum columns and rows. If the arguments make it through the assertion gauntlet, <I>Create()</I> stores the <I>nMaxRows</I>/<I>nMaxCols</I> arguments in corresponding data members. Next, <I>Create()</I> initializes the current number of rows and columns to 1. (<I>m_nRows</I> and <I>m_nCols</I> must always be 1 or 2 in dynamic splitters.) A splitter window with one column and row is like a window with one view. After initializing the current and maximum rows/columns, <I>Create()</I> passes the parent window pointer, minimum size, style, and ID to <I>CreateCommon()</I>.<P>

After calling <I>CreateCommon()</I>, <I>Create()</I> stores the <I>CRuntimeClass</I> information for the pane view in <I>m_pDynamicViewClass</I>. <I>Create()</I> then passes the pointer in a call to <I>CreateView()</I>. Finally, <I>Create()</I> stores the <I>sizeMin</I> values in the <I>m_pColInfo/ m_pRowInfo</I> for the current pane (0,0). This is a little strange because we haven't seen these arrays allocated yet. This must be happening in <I>CreateCommon()</I> or <I>CreateView()</I>. Let's compare <I>Create()</I> to <I>CreateStatic()</I>. <P>

In the pseudocode for <I>CreateStatic()</I> (<a href="9612n.htm#012e_0423">Listing Three</A> ), the initial assertions reveal that static splitter windows have a limit of 16 rows and columns (that's 256 panes!). The assertions also check that there is more than one row or column.<P>

After testing its arguments, <I>CreateStatic()</I> sets <I>m_nRows</I>/<I>m_nMaxRows</I> (these are always equal in static splitter windows) to the <I>nRows</I> argument. <I>CreateStatic()</I> does the same for the column counterparts of these data members.<P>

Finally, <I>CreateStatic()</I> calls <I>CreateCommon(),</I> passing the parent pointer, a size of (0,0), the style, and the integer ID. Unlike <I>Create()</I>, <I>CreateStatic()</I> does not call <I>CreateView()</I>. It is up to the static splitter window user to create all the views since the run-time information is not known by <I>CreateStatic()</I>. <P>

<I>Create()</I> and <I>CreateStatic()</I> are similar except for the restrictions they place on their arguments. Also, <I>Create()</I> calls <I>CreateView()</I>, while <I>CreateStatic()</I> does not. Since both functions call <I>CreateCommon()</I>, let's take a look at the other initializations this member function is performing. <P>

<I>CreateCommon()</I> (see <a href="9612n.htm#012e_0424">Listing Four</A>) first creates a temporary style holder, <I>dwCreateStyle</I>, which contains the original <I>dwStyle</I> argument, minus the WS_HSCROLL and WS_VSCROLL style bits. <I>CreateCommon()</I> does this because it does not want the Window's window to have scrollbars--the scrollbars need to be managed by the splitter window, not the Window's window.<P>

After making adjustment to the style flags, <I>CreateCommon()</I> subtracts the WS_BORDER flag if the application is running under Windows 95 (Windows 95 draws the border, not MFC).<P>

Next, <I>CreateCommon()</I> calls <I>AfxDeferRegisterClass()</I> and calls <I>CWnd::CreateEx()</I> with no extended styles, <I>_afxWndMDIFrame</I> (the MDI frame window class; no erase-background handling), the handle of the parent from <I>pParentWnd,</I> and <I>nID</I> as the identifier. After calling <I>CreateEx()</I>, <I>CreateCommon()</I> allocates and initializes both the <I>m_pColInfo</I> and <I>m_pRowInfo</I> arrays using <I>m_nMaxCols</I>/<I>Rows</I> as the size of the array.<P>

<I>CreateCommon()</I> iterates through both the row and column <I>CRowColInfo</I> arrays. Both <I>nMinSize</I> and <I>nIdealSize</I> are set to the <I>sizeMin</I> argument. <I>nCurSize</I> is initialized to -1, which indicates that it should be set when the pane's size is initialized (<I>RecalcLayout()</I>).<P>

After initializing both the column and row <I>CRowColInfo</I> arrays, <I>CreateCommon</I> calls <I>SetScrollStyle()</I> to initialize <I>m_bHasHScroll</I> and <I>m_bHasVScroll</I>, then returns True.<P>

<I>CreateView()</I> (see <a href="9612n.htm#012e_0425">Listing Five</A>) initially stores the <I>sizeInit</I> argument in the <I>CRowColInfo</I> corresponding array indexes. Next, <I>CreateView()</I> sets a local flag, <I>bSendInitialUpdate</I> to False. <P>

If for some reason the <I>CCreateContext</I> pointer is NULL, <I>CreateView()</I> creates a local <I>CCreateContext()</I> and does its best to initialize each element based on sane values. It calls <I>GetActivePane()</I> to determine the <I>m_pLastView</I> <I>CView</I> pointer. Once <I>CreateView()</I> has the <I>m_pLastView</I>, it can determine the other <I>CCreateContext</I> fields by calling <I>GetDocument()</I> and then <I>CDocument::GetDocTemplate()</I>. After it has found these elements, <I>CreateView()</I> points the <I>pContext</I> pointer to them and sets <I>bSendInitialUpdate</I> to True so that they will be initialized correctly later in the function.<P>

Next, <I>CreateView()</I> calls <I>CreateObject()</I> to create a pane (<I>CWnd</I> derivative) object from the <I>CRuntimeClass</I> information. After creating the pane object, <I>CreateView()</I> sets the styles and position rectangle, which are passed to a <I>Create()</I> call. The <I>IdFromRowCol()</I> function calculates the ID of the pane, based on the row and column. The formula is <I>AFX_IDW_PANE_FIRST + row </I>x<I> 16 + col</I>. If it is row 0 and column 5, the ID is <I>AFX_IDW_PANE_FIRST + 5</I>. If it is row 5 and column 0, the ID is <I>AFX_IDW_PANE_FIRST + 80</I>, and so on. This formula guarantees that all 256 possible panes will have a unique identifier in the AFX_IDW_PANE_FIRST to AFX_IDW_ PANE_LAST range.<P>

If the call to <I>Create()</I> fails, <I>CreateView()</I> returns False, indicating failure. If <I>Create()</I> succeeds, <I>CreateView()</I> sends a WM_INITIALUPDATE to the pane if the <I>bSendInitialUpdate</I> flag is set. The flag is only set if <I>CreateView()</I> has to find the <I>CCreateContext</I> information on its own. Finally, <I>CreateView()</I> returns True.<P>

That's all the logic for initializing and creating a splitter window. After the splitter window has been created with <I>Create()</I> or <I>CreateStatic()</I> and the panes have been created, splitter window action takes place in response to window messages and user interactions.<P>

<h3><I>CSplitterWnd</I> Pane Management</h3><P>

Two <I>CSplitterWnd</I> members, <I>SplitRow()</I> and <I>SplitColumn()</I>, are called to dynamically create a pane. <I>SplitColumn()</I> takes one argument--the location of the split. <I>SplitColumn()</I> is called when you create a vertical split.<a href="9612n.htm#012e_0426"> Listing Six,</A> the <I>SplitColumn()</I> pseudocode, is available electronically.<P>

<I>SplitColumn()</I> is not allowed for static splitter windows, so it first asserts that the current splitter window is dynamic by checking the SPLS_DYNAMIC_SPLIT flag.<P>

<I>SplitColumn()</I> subtracts the size of the border from the column size and sets the local <I>colNew</I> variable to the number of columns. <I>SplitColumn()</I> then sets the local <I>cxNew</I> (the new column width) to the results of calling <I>CanSplitRowCol()</I>. <I>CanSplitRowCol()</I> calculates the new width of the pane based on the column information, the <I>cxBefore</I> value and the width of a splitter. If users have created a split smaller than the minimum pane size, <I>CanSplitRowCol()</I> will return -1, indicating that the pane could not be created. <I>SplitColumn()</I> checks for this and returns False if the pane can not be created. <I>CanSplitRowCol()</I> generates a Trace statement in the debug build. (If you run the Scribble tutorial with splitter windows in debug mode and create a small split, you will see <I>CanSplitRowCol()</I> reject the new pane size and revert the splitter window to an unsplit window.)<P>

After approval from <I>CanSplitRowCol()</I>, <I>SplitColumn()</I> creates the scrollbar for the control if <I>m_bHasHScroll</I> is True. The <I>m_bHasHScroll</I> and <I>m_bHasVScroll</I> flags are both set in <I>SetScrollStyle()</I> based on the WS_VSCROLL/WS_HSCROLL style bits. Remember that <I>SetScrollStyle()</I> was called by <I>CreateCommon()</I>. Once the scrollbars are created, <I>SplitColumn()</I> increments the number of columns, <I>m_nCols</I>, by 1.<P>

The next block of code in <I>SplitColumn()</I> creates the new pane. This is a For loop that iterates over the number of columns. <I>SplitColumn()</I> does this because if there are two rows and users creates a new column, then two (not one) new panes need to be created.<P>

As the <I>SplitColumn()</I> For loop iterates through the rows creating a new pane for each one, it calls <I>CreateView()</I> with a size based on <I>cxNew</I> for width and the current height of the row for height. If the <I>CreateView()</I> fails, <I>SplitColumn</I> cleans up and returns False. <P>

Once the For loop completes, <I>SplitColumn()</I> updates the <I>CRowColInfo</I> array elements for the current and previous columns with the post-split column widths. <I>SplitColumn()</I> concludes by calling <I>RecalcLayout()</I> to force a redraw of all of the splitter window panes and gadgets.<P>

When examining the <I>CSplitterWnd</I> source code, you see that at the bottom of almost every member function that has anything to do with pane layout is a call to <I>RecalcLayout()</I>, which controls the placement of every splitter window component. Understanding <I>RecalcLayout()</I> key to understanding how splitter windows work and are updated. In general, <I>RecalcLayout(</I><I>)</I>:<P>

<P>

1. Gets the client rectangle by calling <I>::GetClientRect()</I> and also the inside rectangle by calling <I>CSplitterWnd::GetInsideRect()</I>.<P>

2. Calculates the row and column layouts in <I>m_pColInfo</I>/<I>m_pRowInfo</I> by calling <I>LayoutRowCol(),</I> which calculates where the rows and columns are located based on the size argument and the size hints stored in the <I>CRowColInfo</I> argument. <I>RecalcLayout()</I> calls <I>LayoutRowCol()</I> twice, once for columns with the inside rectangle width and once for rows with the inside rectangle height. <P>

3.Next, <I>RecalcLayout()</I> calls <I>::BeginDeferWindowPos()</I> to setup a <I>Begin</I>/<I>Defer</I>/ <I>End WindowPos</I> call trio. <I>RecalcLayout()</I> uses the number of rows and columns to calculate the number of windows that will be moved. The handle returned by <I>::BeginDeferWindowPos()</I> is stored in a local AFX_SIZEPARENTPARAMS structure called <I>layout</I>.<P>

4. <I>RecalcLayout()</I> next calculates the size of the scrollbars and changes their position (including the size box) by calling a helper, <I>DeferClientPos()</I> which tweaks the sizes and then calls <I>AfxRepositionWindow()</I> passing along the pointer to the AFX_SIZEPARENTPARAMS structure. <I>AfxRepositionWindow()</I> lives in WINCORE.CPP. It performs more checks and finally calls <I>DeferWindowPos</I> using the handle in the AFX_SIZEPARENTPARAMS structure. <P>

5. After repositioning the scrollbars, <I>RecalcLayout</I> iterates through the panes and calls <I>DeferClientPos()</I> for each of with the size information from the corresponding <I>CRowColInfo</I> array element with some minor adjustments for splitter gaps, and so on.<P>

6. Once the scrollbars and panes have been repositioned, <I>RecalcLayout()</I> calls <I>::EndDeferWindowPos()</I> to move all windows at once.<P>

7. Finally, <I>RecalcLayout()</I> calls <I>DrawAllSplitBars()</I> with a NULL DC to invalidate the splitter bars and force a redraw in the new positions. The splitter bars will be drawn relative to the new row and column positions. <P>

<h3><I>CSplitterWnd</I> Drawing</h3><P>

The <I>DrawAllSplitBars()</I> member function does all of the actual drawing. This function takes a DC pointer, <I>ESplitType</I> enumeration, and rectangle. <P>

First, <I>DrawAllSplitBars()</I> iterates through the columns and draws vertical splitter bars for <I>m_nCols -1</I>. <I>DrawAllSplitBars()</I> calculates the splitter bar dimensions using the width of the splitter, <I>CRowColInfo</I> for the column, and some of the other cosmetic data members.<P>

Next, <I>DrawAllSplitBars()</I> iterates through the rows and performs the identical operations as above, except using the height of the splitter window and the row information to draw the row splitter bars.<P>

Finally, if the program is running on Windows 95, <I>DrawAllSplitBars()</I> draws a 3-D border around each pane. It does this so that the splitter bars and the border merge instead of looking like they were drawn by different programs.<P>

<I>OnDrawSplitter()</I> does splitter-window drawing. <a href="9612n.htm#012e_0427">Listing Seven</A>, is the pseudocode for this member function.<P>

<h3>WINSPLIT.CPP</h3><P>

If the CDC pointer passed to <I>OnDrawSplitter()</I> is NULL, the caller wants to invalidate the rectangle. In this case <I>OnDrawSplitter()</I> calls <I>CWnd::RedrawWindow()</I> with the rectangle and the RDW_INVALIDATE flag set.<P>

On the other hand, if the CDC pointer is not NULL, <I>OnDrawSplitter</I> switches on the <I>ESplitType</I> argument. Remember from the <I>CSplitterWnd</I> header that this is an enumeration of the various splitter window components (for example, <I>splitBorder</I>, <I>splitIntersection</I>, <I>splitBox</I>, and so on).<P>

Before looking at the different cases of the switch statement, notice that after the switch <I>OnDrawSplitter()</I> calls <I>Fill<P>
SolidRect()</I> with the local rectangle variable and button face color. Knowing this, you can deduce that the switch statement at the beginning of <I>FillSolidRect()</I> is adding some "dressing" to the filled rectangle. <P>

The first case in the switch is <I>splitBorder</I>. The only call to <I>OnDrawSplitter()</I> with type <I>sizeBorder</I> is made by <I>DrawSplitBars()</I> if the application is running on Windows 95. <P>

When <I>OnDrawSplitte</I><I>r</I><I>()</I> draws the border, it makes two calls to <I>CDC::Draw3dRect(</I><I>)</I>--the first draws the outside of the border and the second draws the inside of the border using an offset by CX_BORDER, CY_BORDER. This creates a window border affect for the inside of the pane. The second case is for <I>splitIntersection</I> which just breaks out of the switch statement.<P>

The <I>splitBox</I> type is the third case.<a href="1997042a.htm"> Figure 2(a)</A> shows a close up of a Windows 95 split and indicates which part of the <I>splitBox</I> is drawn by each GDI call. <P>

If the application is running on Windows 95, <I>OnDrawSplitter()</I> draws a 3-D splitbox by making two calls to the <I>CDC::Draw3dRect()</I> member function. The first call draws the outside border and the second draws the inside border. Notice in Figure 2(a) how <I>Draw3dRect()</I> uses the two argument colors to draw the top and left rectangle sides in one color, and the bottom and right rectangle sides in another. The result is the Windows 95 "chiseled" 3-D look. For Windows 95, the <I>splitBox</I> case breaks and falls through to the <I>FillSolidRect()</I> call after the switch block. The <I>FillSolidRect()</I> call completes the splitbox by filling in its center area.<P>

If the application is running on Windows NT (or Win32s), the <I>splitBox</I> case falls through to the <I>splitBar</I> case.<a href="1997042b.htm"> Figure 2(b) s</A>hows the Windows NT splitbox. Note the black outline is there to provide contrast for the button. This border is not drawn by <I>OnDrawSplitter()</I>. <P>

For <I>splitBar</I>, <I>OnDrawSplitter()</I> draws some 3-D shading only if it is not running on Windows 95. Remember that this code will be the same for splitboxes and splitbars on NT and Win32s. The NT <I>splitBox</I> and <I>splitBar</I> case draws one 3-D rectangle and then deflates the rectangle in preparation for the <I>FillSolidRect()</I> call. <a href="1997042a.htm">Figure 2(b)</A> shows the results of each GDI call on the appearance of the splitter. <P>

Now you almost have the complete <I>CSplitterWnd</I> picture. Remember that <I>DrawAllSplitBars()</I> takes care of drawing the splitter bars and the splitter border. The only components you haven't seen drawn are splitboxes. The splitboxes are not drawn in <I>OnDrawSplitter()</I>, but are instead drawn in <I>CSplitterWnd::OnPaint()</I>. <a href="9612n.htm#012e_0428">Listing Eight</A> is pseudocode for <I>OnPaint()</I>.<P>

<I>OnPaint()</I> prepares to draw by getting the client rectangle and the inside rectangle. Then <I>OnPaint()</I> calls <I>OnDrawSplitter()</I> to draw both the horizontal and vertical splitboxes.<P>

After drawing the splitboxes, <I>OnPaint()</I> calls <I>DrawAllSplitBars()</I> to draw the split bars and the split border.<P>

Finally, if the application is not running on Windows 95, <I>OnPaint()</I> does lots of work to draw splitter bar intersections. <P>

<h3>Conclusion</h3><P>

In the next column we will apply the knowledge presented here and show you how to use a <I>CWnd</I> as a <I>CSplitterWnd</I> pane, programmatically create/remove splits, how to customize the look-and-feel of the splitter windows and more.<P>

<P>

<h4><a name="012e_0420"><B>Example 1: </B>Creating a splitter window.</h4><P>

<pre>BOOL CChildFrame::OnCreateClient(LPCREATESTRUCT , CCreateContext* pContext) 
{
     return m_wndSplitter.Create(this,2, 2, CSize(10, 10), pContext);
}

</pre>

<P>

<P>

<B><FONT FACE="TMS RMN" SIZE=2>Figure 1:</B> Typical splitter window.</FONT><P>

<P>

<B><FONT FACE="TMS RMN" SIZE=2>Figure 2:</B> (a) Windows 95 splitbox, (b) Windows NT splitbox.</FONT><P>

<P>

<P>

<P>

<h4><a name="012e_0305">Table 1: <B>(a) Encapsulated data types; (b) creation/layout data members; (c) cosmetic data members; (d) tracking data members; (e) general member functions; (f) layout member functions; (g) drawing member functions; (h) hit-test member functions; (i) tracking member functions; (j) message handlers.</B></h4><P>

<P>

<pre>
     Data Type/Function                Description
     
(a)  ESplitType                        Defines the type of splitter to be drawn. Valid types are splitBox, splitBar,
                                         splitIntersection, and splitBorder.
     CRowColInfo                       Internal structure that maintains the minimum, ideal, and current size of a
                                         row/column. For rows, values refer to height; for columns, fields refer to width. 

(b)  m_pDynamicViewClass               Pointer to the CRuntimeClass information for the view (pane) to be dynamically
                                         created by CSplitterWnd.  Specified in Create() for dynamic splitters and CreateView() for static splitters.

     m_nMaxRows/m_nMaxCols             Maximum number of rows/columns as specified in the call to Create() 
                                         or CreateStatic(). 
     m_nRows/m_nCols                   Number of rows and columns currently being displayed in the CSplitterWnd.

     m_bHasHScroll/m_bHasVScroll       Flags indicate if there is a horizontal or vertical scrollbar.
     m_pColInfo                        Array of CRowInfo with one element for each column in CSplitterWnd. Value is fixed
                                         in static splitter windows and varies in dynamic splitter windows.
     m_pRowInfo                        Array of CRowColInfo with one element for each row in the CSplitterWnd. Value is
                                         fixed in static splitter windows; varies in dynamic splitter windows.

(c)  m_cxSplitter/m_cySplitter         Width and height of splitbox and splitter. Value is 7 for Windows 95, 4 for NT.
     m_cxBorderShare/m_cyBorderShare   Values are 0 if splitter window is drawing the border (Windows 95), or 1 if border is
                                         drawn by Windows NT.
     m_cxSplitterGap/m_cySplitterGap   Gap between splitbox/split bar and the scrollbar/border. On NT, value is 6; on
                                         Windows 95, value is 7.
     m_cxBorder/m_cyBorder             Border width of the splitter border. Value is 0 on NT; 2 on Windows 95. 

(d)  m_bTracking                      If True, user is dragging one splitter bar.
     m_bTracking2                     If True, user is dragging two splitter bars (m_bTracking will be true, too). If user drags
                                        the intersection point, both split bars must be tracked.
     m_ptTrackOffset                  &quot;Pick&quot; size of the hit testing. Hit testing is not limited to the exact width/height of a
                                        splitbox/split bar. m_ptTrackOffset gives the user some.
     m_rectLimit                      Size of a pane during tracking, used to determine the height of the tracking split bar.
     m_rectTracker                    Rectangle used to draw the split bar when tracking. 
     m_rectTracker2                   Rectangle used to draw the second split bar when tracking (if user is dragging two via an intersection).
     m_htTrack                        Set by the CSplitterWnd hit-tracking mechanism to an enumeration that describes
                                        the splitter window component that was &quot;hit.&quot; 

(e)  CreateCommon()                   Called by Create() and CreateStatic() once they have initialized the dynamic and
                                        static specific members of CSplitterWnd. 
     CreateScrollBarCtrl()            Creates scrollbar with the specified style and identifier.
     DoScroll()                       Responds to scrollbar messages. DoScroll() synchronizes the appropriate panes.
     DoScrollBy()                     Scrolls appropriate panes by a specified amount. 
     DoKeyboardSplit()                Called to cause the window to split. 
     CanActivateNext()                Called to find out if next pane can be activated--if it can be given focus. Called by
                                        class CView. 
     ActivateNext()                   Used to activate next pane. Usually called when a pane is deleted to change the focus before dying.

(f)  RecalcLayout()                   Positioning for the splitter window. Called after a pane is created and also after it is destroyed.
     TrackRowSize()                   Updates m_pRowInfo array information for specified row. Also determines if there is
                                        enough room for the row and if not, deletes it (dynamic only).
     TrackColumnSize()                Same as above, but for a column.
     GetSizingParent()                Retrieves a sizable parent window (Windows 95 only). 

(g)  DrawAllSplitBars()               Drives the splitter window drawing process by making calls to OnDrawSplitter for
                                        each of the splitter window components to be drawn.
     OnDrawSplitter()                 OnDrawSplitter() draws the different splitter window components. OnDrawSplitter() is
                                        virtual, so you can modify the appearance of the splitter windows if you want to.
     OnPaint()                        Called in response to a WM_PAINT message. 

(h)  HitTest()                        Takes a point and returns hit-test value for it.
     GetInsideRect()                  Similar to GetClientRect(), except it takes into account shared scrollbars.
     GetHitRect()                     Retrieves hit rectangle for specified splitter-window component. 
     SetSplitCursor()                 Uses hit testing to determine which cursor to display. If the mouse is over a splitbox
                                        or split bar, SetSplitCursor() displays sizing arrows. If mouse is over an intersection,
                                        displays four-way arrows.

(i)  StartTracking()                  Starts tracking operation based on hit-test value. Called by DoKeyboardSplit() and
                                        OnLButtonDown(). 
     StopTracking()                   Stops tracking operation. Called by ONLButtonDblClk(), OnLButtonUp(), and other
                                        functions that want to stop tracking for various reasons. 
     OnInvertTracker()                Inverts tracker during rubber banding.
 
(j)  OnNcCreate()                     CSplitterWnd handles WM_NCCREATE message so that it can remove WS_EX_
                                        CLIENTEDGE extended style bit. CSplitterWnd draws 3-D border so that splitters can
                                        appear to be part of border.
     OnPaint()                        Draws splitter-window components.
     OnDisplayChange()                Called when users change the monitor resolution. OnDisplayChange() calls
                                        RecalcLayout() to update the splitter windows for the new setting.
     OnSize()                         Calls RecalcLayout() when the user resizes the splitter window. 
     OnMouseMove()                    Performs hit testing on splitter-window components.
     OnLButtonDown()                  Performs hit testing; if users click on a splitter-window component, starts tracking.
     OnLButtonDblClk()                Hit tests double click; if users double click on splitbox, automatically splits the
                                        window in half. If users double click splitter bar, split is removed. 
     OnLButtonUp()                    Stops tracking.
     OnKeyDown()                      Provides sequences that control splitter-window tracking.
</pre>

<P>

<a name="012e_0421"><H3>Listing One</H3>
<PRE>class CSplitterWnd : public CWnd
{
DECLARE_DYNAMIC(CSplitterWnd)
// Construction ** omitted.
// Attributes **omitted.
// Operations 
public:
virtual void RecalcLayout();    // call after changing sizes
// Overridables **some omitted.
protected:
enum ESplitType { splitBox, splitBar, splitIntersection, splitBorder }; 
virtual void OnDrawSplitter(CDC* pDC, ESplitType nType, const CRect&amp; rect); 
virtual void OnInvertTracker(const CRect&amp; rect);
public:
virtual BOOL CreateScrollBarCtrl(DWORD dwStyle, UINT nID);
public:
// high level command operations - called by default view implementation 
virtual BOOL CanActivateNext(BOOL bPrev = FALSE); 
virtual void ActivateNext(BOOL bPrev = FALSE); 
virtual BOOL DoKeyboardSplit();
// synchronized scrolling
virtual BOOL DoScroll(CView* pViewFrom, UINT nScrollCode, BOOL bDoScroll = TRUE);
virtual BOOL DoScrollBy(CView* pViewFrom, CSize sizeScroll, 
BOOL bDoScroll = TRUE);
// Implementation  **some omitted for brevity
public:
struct CRowColInfo {
          int nMinSize;       // below that try not to show
          int nIdealSize;     // user set size
          int nCurSize;       // 0 =&gt; invisible, -1 =&gt; nonexistent
     };
protected:
CRuntimeClass* m_pDynamicViewClass; 
int m_nMaxRows, m_nMaxCols;
// implementation attributes which control layout of the splitter
     int m_cxSplitter, m_cySplitter;         // size of splitter bar
     int m_cxBorderShare, m_cyBorderShare;   // space on either side of splitter
     int m_cxSplitterGap, m_cySplitterGap;   // amount of space between panes
     int m_cxBorder, m_cyBorder;             // borders in client area
// current state information
int m_nRows, m_nCols;
BOOL m_bHasHScroll, m_bHasVScroll;
CRowColInfo* m_pColInfo;
CRowColInfo* m_pRowInfo;
// Tracking info - only valid when 'm_bTracking' is set 
BOOL m_bTracking, m_bTracking2;
CPoint m_ptTrackOffset;
CRect m_rectLimit;
CRect m_rectTracker, m_rectTracker2; 
int m_htTrack;
// implementation routines
BOOL CreateCommon(CWnd* pParentWnd, SIZE sizeMin, DWORD dwStyle, UINT nID); 
int HitTest(CPoint pt) const; 
void GetInsideRect(CRect&amp; rect) const; 
void GetHitRect(int ht, CRect&amp; rect); 
void TrackRowSize(int y, int row); 
void TrackColumnSize(int x, int col); 
void DrawAllSplitBars(CDC* pDC, int cxInside, int cyInside); 
void SetSplitCursor(int ht);
CWnd* GetSizingParent();
// starting and stopping tracking
virtual void StartTracking(int ht);
virtual void StopTracking(BOOL bAccept);
afx_msg BOOL OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message); 
afx_msg void OnMouseMove(UINT nFlags, CPoint pt); 
afx_msg void OnPaint(); 
afx_msg void OnLButtonDown(UINT nFlags, CPoint pt); 
afx_msg void OnLButtonDblClk(UINT nFlags, CPoint pt); 
afx_msg void OnLButtonUp(UINT nFlags, CPoint pt); 
afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags); 
afx_msg void OnSize(UINT nType, int cx, int cy); 
afx_msg void OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar); 
afx_msg void OnVScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar); 
afx_msg BOOL OnNcCreate(LPCREATESTRUCT lpcs); 
afx_msg void OnSysCommand(UINT nID, LPARAM lParam); 
afx_msg void OnDisplayChange();
DECLARE_MESSAGE_MAP()
};
</PRE>

<a name="012e_0422"><H3>Listing Two</H3>
<PRE>BOOL CSplitterWnd::Create(CWnd* pParentWnd, int nMaxRows, int nMaxCols, 
SIZE sizeMin, CCreateContext* pContext, DWORD dwStyle, UINT nID)
{
ASSERT(nMaxRows &gt;= 1 &amp;&amp; nMaxRows &lt;= 2);
ASSERT(nMaxCols &gt;= 1 &amp;&amp; nMaxCols &lt;= 2);
ASSERT(nMaxCols &gt; 1 || nMaxRows &gt; 1);       // 1x1 is not permitted
m_nMaxRows = nMaxRows;
m_nMaxCols = nMaxCols;
m_nRows = m_nCols = 1;      // start off as 1x1
if (!CreateCommon(pParentWnd, sizeMin, dwStyle, nID))
return FALSE; 
m_pDynamicViewClass = pContext-&gt;m_pNewViewClass;
if (!CreateView(0, 0, m_pDynamicViewClass, sizeMin, pContext))
DestroyWindow(); // will clean up child windows return FALSE;
     m_pColInfo[0].nIdealSize = sizeMin.cx;
m_pRowInfo[0].nIdealSize = sizeMin.cy;
return TRUE;
}</PRE>

<a name="012e_0423"><H3>Listing Three</H3>
<PRE>BOOL CSplitterWnd::CreateStatic(CWnd* pParentWnd, int nRows, int nCols, 
DWORD dwStyle, UINT nID)
{
ASSERT(nRows &gt;= 1 &amp;&amp; nRows &lt;= 16);
ASSERT(nCols &gt;= 1 &amp;&amp; nCols &lt;= 16);
ASSERT(nCols &gt; 1 || nRows &gt; 1); 
ASSERT(!(dwStyle &amp; SPLS_DYNAMIC_SPLIT)); 
m_nRows = m_nMaxRows = nRows; 
m_nCols = m_nMaxCols = nCols;
if (!CreateCommon(pParentWnd, CSize(0, 0), dwStyle, nID))
return FALSE;
return TRUE;
}</PRE>


<a name="012e_0424"><H3>Listing Four</H3>
<PRE>BOOL CSplitterWnd::CreateCommon(CWnd* pParentWnd,SIZE sizeMin, DWORD dwStyle, UINT nID) 
{
DWORD dwCreateStyle = dwStyle &amp; ~(WS_HSCROLL|WS_VSCROLL); 
if (afxData.bWin4)
dwCreateStyle &amp;= ~WS_BORDER;
if (!AfxDeferRegisterClass(AFX_WNDMDIFRAME_REG))
return FALSE;
if (!CreateEx(0, _afxWndMDIFrame, NULL, dwCreateStyle, 
0, 0, 0, 0, pParentWnd-&gt;m_hWnd, (HMENU)nID, NULL))
return FALSE;       // create invisible
m_pColInfo = new CRowColInfo[m_nMaxCols];
for (int col = 0; col &lt; m_nMaxCols; col++){
m_pColInfo[col].nMinSize = m_pColInfo[col].nIdealSize = sizeMin.cx;
m_pColInfo[col].nCurSize = -1; // will be set in RecalcLayout
     }
m_pRowInfo = new CRowColInfo[m_nMaxRows];
for (int row = 0; row &lt; m_nMaxRows; row++){
m_pRowInfo[row].nMinSize = m_pRowInfo[row].nIdealSize = sizeMin.cy;
m_pRowInfo[row].nCurSize = -1; // will be set in RecalcLayout
     }
SetScrollStyle(dwStyle);
return TRUE;
}</PRE>


<a name="012e_0425"><H3>Listing Five</H3>
<PRE>BOOL CSplitterWnd::CreateView(int row, int col, CRuntimeClass* pViewClass, 
SIZE sizeInit, CCreateContext* pContext)
{
m_pColInfo[col].nIdealSize = sizeInit.cx;
m_pRowInfo[row].nIdealSize = sizeInit.cy;
BOOL bSendInitialUpdate = FALSE;
CCreateContext contextT;
if (pContext == NULL) {
CView* pOldView = (CView*)GetActivePane();
if (pOldView != NULL &amp;&amp; pOldView-&gt;IsKindOf(RUNTIME_CLASS(CView))){
contextT.m_pLastView = pOldView; 
contextT.m_pCurrentDoc = pOldView-&gt;GetDocument(); 
if (contextT.m_pCurrentDoc != NULL)
contextT.m_pNewDocTemplate = 
contextT.m_pCurrentDoc-&gt;GetDocTemplate();
          }
pContext = &amp;contextT;
bSendInitialUpdate = TRUE;     
     }
CWnd* pWnd = (CWnd*)pViewClass-&gt;CreateObject();
DWORD dwStyle = AFX_WS_DEFAULT_VIEW;
if (afxData.bWin4)
dwStyle &amp;= ~WS_BORDER;
// Create with the right size (wrong position)
CRect rect(CPoint(0,0), sizeInit);
if (!pWnd-&gt;Create(NULL, NULL, dwStyle, rect, this, IdFromRowCol(row, col), 
pContext)) 
return FALSE;
// send initial notification message
if (bSendInitialUpdate)
pWnd-&gt;SendMessage(WM_INITIALUPDATE);
return TRUE;
}</PRE>


<a name="012e_0426"><H3>Listing Six</H3>
<PRE>BOOL CSplitterWnd::SplitColumn(int cxBefore)
{
ASSERT(GetStyle() &amp; SPLS_DYNAMIC_SPLIT);
cxBefore -= m_cxBorder;
int colNew = m_nCols;
int cxNew = CanSplitRowCol(&amp;m_pColInfo[colNew-1], cxBefore, m_cxSplitter); if (cxNew == -1)
return FALSE;   // too small to split
// create the scroll bar first (so new views can see that it is there)
if (m_bHasHScroll &amp;&amp;
!CreateScrollBarCtrl(SBS_HORZ, AFX_IDW_HSCROLL_FIRST + colNew))     { TRACE0(&quot;Warning: SplitRow failed to create scroll bar.\n&quot;); return FALSE;
     }

m_nCols++;  // bump count during view creation
// create new views to fill the new column (RecalcLayout will position)
for (int row = 0; row &lt; m_nRows; row++)     {
CSize size(cxNew, m_pRowInfo[row].nCurSize);
if (!CreateView(row, colNew, m_pDynamicViewClass, size, NULL))     {
TRACE0(&quot;Warning: SplitColumn failed to create new column.\n&quot;);
// delete anything we partially created 'col' = # columns created 
while (row &gt; 0)
DeleteView(--row, colNew); 
if (m_bHasHScroll)
GetDlgItem(AFX_IDW_HSCROLL_FIRST + colNew)-&gt;DestroyWindow();
m_nCols--;      // it didn't work out return FALSE;
          }
     }
// new parts created - resize and re-layout
m_pColInfo[colNew-1].nIdealSize = cxBefore;
m_pColInfo[colNew].nIdealSize = cxNew;
RecalcLayout();
return TRUE;
}
</PRE>

<a name="012e_0427"><H3>Listing Seven</H3>
<PRE>void CSplitterWnd::OnDrawSplitter(CDC* pDC, ESplitType nType, const CRect&amp; rectArg)
{
if (pDC == NULL) 
RedrawWindow(rectArg, NULL, RDW_INVALIDATE|RDW_NOCHILDREN); return;
     CRect rect = rectArg;
switch (nType)     {
case splitBorder:
pDC-&gt;Draw3dRect(rect, afxData.clrBtnShadow, afxData.clrBtnHilite); 
rect.InflateRect(-CX_BORDER, -CY_BORDER); 
pDC-&gt;Draw3dRect(rect, afxData.clrWindowFrame, afxData.clrBtnFace);
return;
case splitIntersection:
break;
case splitBox:
if (afxData.bWin4){
pDC-&gt;Draw3dRect(rect, afxData.clrBtnFace,
afxData.clrWindowFrame); 
rect.InflateRect(-CX_BORDER, -CY_BORDER); 
pDC-&gt;Draw3dRect(rect, afxData.clrBtnHilite,
afxData.clrBtnShadow); 
rect.InflateRect(-CX_BORDER, -CY_BORDER); 
break;
          }
// fall through...  
case splitBar:
if (!afxData.bWin4){
pDC-&gt;Draw3dRect(rect, afxData.clrBtnHilite, 
afxData.clrBtnShadow); 
rect.InflateRect(-CX_BORDER, -CY_BORDER);
               }
break;
default:
ASSERT(FALSE);  // unknown splitter type
     }
pDC-&gt;FillSolidRect(rect, afxData.clrBtnFace);
}

</PRE>
<a name="012e_0428"><H3>Listing Eight</H3>
<PRE>void CSplitterWnd::OnPaint()
{
CPaintDC dc(this);
CRect rectClient;
GetClientRect(&amp;rectClient);
rectClient.InflateRect(-m_cxBorder, -m_cyBorder);
CRect rectInside;
GetInsideRect(rectInside);
if (m_bHasVScroll &amp;&amp; m_nRows &lt; m_nMaxRows)
OnDrawSplitter(&amp;dc, splitBox, CRect(rectInside.right + afxData.bNotWin4,
rectClient.top, rectClient.right, rectClient.top + m_cySplitter));
     if (m_bHasHScroll &amp;&amp; m_nCols &lt; m_nMaxCols)
OnDrawSplitter(&amp;dc, splitBox,
CRect(rectClient.left, rectInside.bottom + afxData.bNotWin4,
rectClient.left + m_cxSplitter, rectClient.bottom));
     DrawAllSplitBars(&amp;dc, rectInside.right, rectInside.bottom);
if (!afxData.bWin4) {
// draw splitter intersections (inside only)
GetInsideRect(rectInside); 
dc.IntersectClipRect(rectInside);
CRect rect;
rect.top = rectInside.top;
for (int row = 0; row &lt; m_nRows - 1; row++) {
rect.top += m_pRowInfo[row].nCurSize + m_cyBorderShare;
rect.bottom = rect.top + m_cySplitter;
rect.left = rectInside.left;
for (int col = 0; col &lt; m_nCols - 1; col++) {
rect.left += m_pColInfo[col].nCurSize + m_cxBorderShare; 
rect.right = rect.left + m_cxSplitter;
OnDrawSplitter(&amp;dc, splitIntersection, rect); 
rect.left = rect.right + m_cxBorderShare;
          }
rect.top = rect.bottom + m_cxBorderShare;
     }
     }
}

</PRE>
</BODY></HTML>
