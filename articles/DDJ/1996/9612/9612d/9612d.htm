<HTML>
<META NAME="year" CONTENT="1996">
<HEAD>
<!-- This document was built using HyperWriter Professional by NTERGAID Inc. -->
<TITLE>December 1996:  Virtual Audio Through Ray Tracing</TITLE></HEAD>
<body bgcolor="FFFFFF">
<P>

<h1><FONT FACE="Font8856" SIZE=6>Virtual Audio Through Ray Tracing</FONT></h1><P>

<h2>Calculating early reflections through ray tracing of simple rooms</h2><P>

<P>

<h3></h3><P>

<h3>Tom Zudock</h3><P>

<P>

<P>
<i>Tom is an engineer with Motorola's Digital Signal Processing Division. He can be contacted at tomz@dsp.sps.mot.com.</i></p><hr><P>

<P>

Recordings are often referred to as "virtual audio" because of their use in virtual-reality applications. When I heard my first virtual-audio recording, I was amazed that a pair of headphones with transducers just an inch from my ear could generate a sound source I perceived to be three feet over my head. Perception is the key. By understanding how we hear and what cues we use to identify the location of sounds, we can digitally process sound that will be perceived as virtual audio.<P>

Surprisingly, it is not difficult to have crude control over virtual-audio sounds via signal processing. If your goal is simply to have general control over distance and position, simple models of the system can be used with respectable results. However, accurate placement of virtual-sound sources in 3-D space requires careful system design and implementation.<P>

When I began developing the virtual-sound project presented in this article, I focused on maintaining a simple model. Still, a full description of the virtual-audio model and the programming involved is beyond the scope of a single article. I'll limit my discussion to the early reflections generated by a sound source reaching listeners in a simple room.<P>

<a href="199700f3.htm">Figure 1</A> models a virtual-audio signal-processing system. The shaded region indicates the portion of the model I'll discuss here. The inputs to the model are the sound-source position, listening position, dimensions of the room, and monophonic sound source to be processed. The output is stereo audio presented to listeners over headphones. In the first stage, the impulse response of the room, based on early reflections, is determined. To use this information in a binaural model, the angle of incidence of each reflection must be known. From these two pieces of information and a model of the human head, time delays and attenuations of the sound reaching each ear can be imposed upon the monophonic audio to generate two channels of audio. Believe it or not, it really is that simple.<P>

In this article, I will calculate the early reflections used to create an impulse response. The impulse response is used to process monophonic audio data and generate a monophonic output. Although not discussed here, further incorporating a simple model of the human head provides the means to generate a full 3-D virtual-audio image.<P>

<h3>The Room Model</h3><P>

<a href="199700f4.htm">Figure 2</A> illustrates a rectangular room with a sound source and a listener located at specified coordinates. By restricting the room shape to rectangular, you can simplify the early reflection calculations. <P>

In <a href="199700f5.htm">Figure 2,</A> I modeled sound as linear rays ("sound rays") that travel from the sound source to the listener. Clearly, the behavior of sound is more complex than this computational simplification.<a href="199700f6.htm"> Figure 2</A> depicts two sound rays--one traveling directly from the sound source to the listener, and another reflecting off one wall before reaching the listener. The latter reflection path is referred to as a "first-order reflection" since it made contact with one surface before reaching the listener. <a href="199700f7.htm">(Figure 2</A> is two dimensional, although my final solution covers three dimensions.)<P>

To generate the room response based on the early reflections, relative arrival times and attenuations are needed. Both of these quantities are derived from the distance traveled by a sound ray. Hence, the first step in generating the room response is <P>
to determine the distance traveled by each sound ray. Consider the lower-left corner of the room to be the origin of the Cartesian plane. Calculating the distance traveled by the reflections off the surfaces of the room may be facilitated by using <P>
the image model method (see Durand Begault's <I>3</I><I>-D Sound For Virtual Reality and Multimedia</I>, Academic Press, 1994, ISBN 0-12-084735-3). A mirror image of the room and the sound source is created. A direct path from the mirrored sound source in the mirrored room represents the full distance traveled by the reflection; see <a href="199700f8.htm">Figure 3</A>.<P>

The importance of this technique is that the total distance traveled by the reflected sound ray is simply the distance from the mirrored source's position, MS, to the listener's position, L.<P>

There are, of course, many more sound rays that reach the listener by reflecting off multiple surfaces of the room. By repeating the mirroring technique in both the x- and y-dimensions, direct rays from the mirrored sound sources may be drawn. In <a href="199700f9.htm">Figure 4</A>, the mirrored rooms contain a number representing the order of the reflection that emanates from that mirrored room and the direct path for two second-order reflections from mirrored sound sources.<P>

By extending this concept in the z-dimension, reflections off the ceiling and floor can be determined. In this scenario, the model becomes a cube subdivided into a collection of mirrored rooms. To determine the distance traveled by a reflected ray, the coordinates of the mirrored sound source must first be determined.<P>

To find the general solution for computing the position of mirrored sources, I'll reexamine a single dimension and calculate the mirrored source coordinates by hand. <a href="199700fa.htm">Figure 5(a)</A> shows a one-dimensional string of rooms, and <a href="199700fb.htm">Figure 5(b)</A> shows the x-coordinates of several mirrored sound sources. The calculations of the x-coordinate of the mirrored sources may be generalized to one formula as in <a href="199700fc.htm">Figure 5(c)</A>. The first term is self evident. The second term will be <I>X</I><I>R</I> for <I>N</I> odd, and zero for <I>N</I> even. The third term will be -<I>X</I><I>S</I> for <I>N</I> odd, and +<I>X</I><I>S</I> for <I>N</I> even. This formula applies to the y- and z-dimensions as well. Simply replace x with y and z.<P>

With these equations, the coordinates of mirrored sounds in three dimensions can be calculated. The total distance traveled by each sound ray (see <a href="199700fd.htm">Figure 3</A>) is simply the distance from the mirrored sound source (<I>X</I><I>M</I><I>S</I>, <I>Y</I><I>M</I><I>S</I>, <I>Z</I><I>M</I><I>S</I>) to the listener's position.<P>

<h3>Generating the Room Response</h3><P>

Generating the room response requires knowledge of the travel times and attenuations of each ray at the listening position. Since the result will be a digital filter, the arrival time will ultimately be calculated in terms of the number of samples delayed. Hence, it will be quantized to a discrete value. The delay time at the listening position is, of course, zero (since the distance is zero).<P>

When determining the attenuation for a particular sound ray, it is the level of that sound ray relative to other sounds that is of interest. First, choose a particular distance to use as a reference (say, one meter). The relative sound level is simply the square of the ratio of the two distances.<P>

Finally, each time a sound ray contacts a wall, it is attenuated. In reality, the attenuation is frequency dependent and varies based upon angle of incidence and the characteristics of the surface. To simplify matters, assume the walls simply scale the sound ray by a fraction. Thus, the sound level is determined by <a href="199700fe.htm">Figure 6(b)</A>.<P>

<h3>The Room Response</h3><P>

Using the knowledge of the arrival times and the relative levels of the sound rays, the room response (based upon the early reflections) can be generated. The room response is the sum of the delayed and attenuated versions of the sound emitted by the source.<a href="199700ff.htm"> Figure 6(c)</A> shows how the <I>Gain</I> and <I>Delay</I> information can be used to compute the final sound. This equation is simple to implement. Only three arrays are needed: one each for gain values, delay values, and samples. The array of samples must be at least as large as required by the greatest delay time. The amount of computation required is low, but the memory required is relatively high.<P>

<h3>Implementation</h3><P>

Since I wanted the program to be versatile enough to change many of the key parameters without having to modify the source code and rebuild it, I decided to use a parameter file; see <a href="9612d.htm#00f2_0086">Example 1</A>. All times are in seconds and all distances are in meters. Many of the parameters are obvious, such as the input gain, the room dimensions, the wall reflectivity, and the listener coordinates. The flag on the second line indicates an open or closed sound-source path. For an open path, when the sound source reaches its last coordinate, it stays there. For a closed path, the source continually repeats the cycle. The number of mirrored rooms per dimension is also indicated. For a value of 5, there are 125 rooms total, 124 of which are mirrored rooms. The remainder of the parameter file provides the sound-source coordinates. Each coordinate is paired with a time duration to expire while at that position. Each position specified in this sample file updates on a one-second interval.<P>

To facilitate 3-D space positions, I used two data structures: <I>point</I> and <I>position</I> (see<a href="9612d.htm#00f2_0087"> Listing One</A>). The <I>point</I> structure contains 3-D coordinates. The <I>position</I> structure pairs a <I>point </I>with a time value and a pointer to the next <I>position</I>. In this manner, it is easy to create and traverse a list of positions, staying at one position until its time has elapsed.<P>

Only a few parts of the entire program are associated with the signal processing. The signal processing is performed in the main program and two other functions are used in association. <a href="9612d.htm#00f2_0088">Listing One</A> includes their function prototypes, while <a href="9612d.htm#00f2_008c">Listing Two </A>presents the variable declarations. The complete source code is available electronically.<P>

<a href="19970100.htm">Figure 7 </A>is a flow chart of the core program, while <a href="9612d.htm#00f2_0089">Example 2</A> is its code. Before entering the steady-state operation of the program, the linked list of positions is created, memory is allocated for buffers and coefficients, and the impulse response for the first position in the list is calculated.<P>

The processing loop executes until the entire input-data file has been processed. Once inside the loop, the first order of business is to examine the sound-source position list. The list is first checked to see if the end has been reached (for a closed path the list is circular, so this never occurs). Then, it's just a matter of time! When the specified time has expired, the pointer in the position list advances, and a new room response is calculated. No problem. Processing thereafter ensues, using the new room response.<P>

The remainder of <a href="9612d.htm#00f2_008a">Example 2</A> essentially implements <a href="19970101.htm">Figure 6(c)</A> to produce the processed output. The <I>TapDelay</I> and <I>TapGain</I> arrays contain values for every reflection. The <I>OutputIndex</I> is calculated as a delay from the current index into the sample array using the values in the <I>TapDelay</I> array. Before using the <I>OutputIndex</I>, it is tested and adjusted for modulo behavior to stay within the range of the sample array's size. Finally, the <I>Output</I> is the summation of delay and attenuated input samples. This is a finite impulse-response filter. The remainder of the main program is little more than file I/O and modulo index incrementing.<P>

Calculating the impulse response of the room is really the central focus of this article. <a href="9612d.htm#00f2_008b">Example 3 </A>is the core of this calculation. To see the function in its entirety, refer to Listing Three. The <I>TapDelay</I> and <I>TapGain</I> arrays will be filled with the delays and gains for each reflection. As shown earlier, these are used in the main program to calculate the output.<P>

Each loop represents one dimension; hence, three of them cover three dimensions. Each combination of <I>i</I>, <I>j</I>, and <I>k</I> represents a mirrored room in 3-D space. <a href="19970103.htm">Figure 8</A> shows how the looping values <I>i</I>/<I>j</I>/<I>k</I>, correspond to mirrored rooms.<P>

The steps to calculate the room response parameters are simple. You first mirror the sound source into a mirrored room using the looping variables. This is done by implementing the equation in <a href="19970102.htm">Figure 5(c)</A>, ultimately providing the mirrored sound-source coordinates. The <I>TapDelay</I> for this sound ray is then determined using <a href="19970104.htm">Figure 6(a)</A>. The values for <I>F</I><I>S</I><I> </I>(sampling frequency) and <I>V</I><I>S</I> (velocity of sound) are constants.<P>

All that remains is initializing the <I>TapGain</I> array. The distance is known, but the reflection order must also be incorporated to account for attenuation that occurs at each room surface. In the two-dimensional mirrored room model in <a href="19970105.htm">Figure 4</A>, the order can be determined graphically by counting the number of line segments the sound ray crossed moving from the mirrored sound source to the listening position. In three dimensions, this concept expands to be the number of planes crossed. The reflection order is computed and then used in the calculation for <I>Ta</I><I>p</I><I>Gain,</I> which is an implementation of <a href="19970106.htm">Figure 6(b).</A><P>

With the <I>TapDelay</I> and <I>Ta</I><I>p</I><I>Gain</I> arrays fully initialized, the function is complete and processing of audio using this newly generated room response is handled by the main program discussed earlier.<P>

<h3>Conclusion</h3><P>

A simple model of the human head, combined with the early reflections model presented here, will yield extracranial sound images that are really quite astounding. I encourage you to read Durand Begault's book for more on this topic. Beyond that, it is up to you to decide on the level of control needed to yield the desired result. But be careful, once you get started, this kind of programming is addictive.<P>

<h3>References </h3><P>

                    Begault, Durand R. <I>3-D Sound For Virtual Reality and Multimedia</I>. San Diego, CA: Academic Press, 1994.<P>

Handel, Stephen. <I>Listening</I>. Cambridge, MA: MIT Press, 1989.<P>

Woram, John. <I>Sound Recording Handboo</I><I>k</I>. Valley Forge, PN: Howard W. Sams &amp; Company, 1988.<P>

<P>

<P>

<P>

<B>Figure 5: </B>(a) Mirrored rooms in the x-dimension only; (b) calculating the positions of the mirrored sound sources; (c) single equation for the position of a mirrored sound source.<P>

<P>

<P>

<P>

<h4><B><a name="00f2_0086">Example 1: </B>File of input parameters.</h4><P>

<pre>
0.5               # Input gain for data file (float)
1                 # Open Path = 0 Closed Path = 1 (int)
6    5    4       # Room Dimensions (X,Y,Z) (float)
0.95              # Reflectivity of walls (float)
11                # Number of rooms per dimension, 1 or greater
2    3    2       # Listener coord (X,Y,Z) (float)
2    2    2    1  # Source coord and time at coord (X,Y,Z,t) (float)
3    2    2    1  # Source coord and time at coord (X,Y,Z,t) (float)
4    3    2    1  # Source coord and time at coord (X,Y,Z,t) (float)
3    4    2    1  # Source coord and time at coord (X,Y,Z,t) (float)
2    4    2    1  # Source coord and time at coord (X,Y,Z,t) (float)

</pre>

<P>

<P>

<h4><B><a name="00f2_0089"><a name="00f2_008a">Example 2: </B>Processing portion of main program.</h4><P>

<P>

<pre>// get params from file, init variables, make position list
CurrentSource = InputParameters(PositionFile,Room,Source,
                               Listener,ReflCoef,InGain,NR);
AllocateMemory(Fs,Room,NR,Samples,TapDelay,TapGain,BufSize);

// calculate the response for the first position
CalcImpResp(TapDelay,TapGain,Room,CurrentSource-&gt;Coord,
            Listener,ReflCoef,Fs,NR);
        
while (feof(InFileBin)==0) {

// test for final position, test elapsed time...
// ... advance position and calc new response if time
  if (CurrentSource-&gt;NextSource!=NULL) {
    if ((CurrentSource-&gt;Time) &lt;= (ElapsedSamps/Fs)){
      CurrentSource = CurrentSource-&gt;NextSource;
      CalcImpResp(TapDelay,TapGain,Room,CurrentSource-&gt;Coord,
                  Listener,ReflCoef, Fs, NR);
      ElapsedSamps=0;
    }
  }
  fread(&amp;Sample,sizeof(Sample),1,InFileBin);
  Samples[SamplesIndex] = (float) InGain*Sample;
  // calculate output using all taps
  Output = 0;
  for (int i = 0;i &lt; NR*NR*NR;i++) {
    OutputIndex = SamplesIndex-TapDelay[i];
    (OutputIndex &lt; 0) ? OutputIndex+=BufSize:OutputIndex;
    Output += Samples[OutputIndex]*TapGain[i];
  }
  Sample = (short) Output;
  fwrite(&amp;Sample,sizeof(Sample),1,OutFileBin);
  SamplesIndex++;                // increment modulo index
  (SamplesIndex &gt;= BufSize) ? SamplesIndex=0:SamplesIndex;
  ElapsedSamps++;
}                                // end while loop

</pre>

<h4><B><a name="00f2_008b">Example 3: </B>Subroutine to calculate the room's impulse response.</h4><P>

<pre>
for (int i=-NR/2;i&lt;=NR/2;i++) {   // loop through all 3 dimensions
   for (int j=-NR/2;j&lt;=NR/2;j++) {
      for (int k=-NR/2;k=&lt;NR/2;k++) {
        // calc x,y,z sound source coords in mirrored room
        MirrSource.X = (i)*Room.X 
                      +fabs(((i)%2)*Room.X)
                      +pow(-1,(i))*Source.X;
        MirrSource.Y = (j)*Room.Y 
                      +fabs(((j)%2)*Room.Y)
                      +pow(-1,(j))*Source.Y;
        MirrSource.Z = (k)*Room.Z 
                      +fabs(((k)%2)*Room.Z)
                      +pow(-1,(k))*Source.Z;
        // calculate distance to listener
        Dist = sqrt(pow(MirrSource.X-Listener.X,2)
                   +pow(MirrSource.Y-Listener.Y,2)
                   +pow(MirrSource.Z-Listener.Z,2));
        // calculate delayed arrival time of reflection
        TapDelay[(i+NR/2)*NR*NR+(j+NR/2)*NR+(k+NR/2)]=Dist/Vs*Fs;
        ReflOrd = abs(i)+abs(j)+abs(k);
        // calculate attenuation for the reflection
        TapGain[(i+NR/2)*NR*NR+(j+NR/2)*NR+(k+NR/2)]=
                pow(RefDist/Dist,2.0)*pow(ReflCoef,ReflOrd);
      }
   }
}</pre>

<P>

<P>

<P>

<P>

<P>

<a name="00f2_0088"><a name="00f2_0087"><H3>Listing One</H3><PRE><P>

// structure for a point in 3 dimensional space
struct point {
  double X;
  double Y;
  double Z;
};

// structure for a point paired with time duration
struct position {
  point Coord;
  double Time;
  position *NextSource;
};

void
CalcImpResp(
    long *,
    double *,
    point &amp;,
    point &amp;,
    point &amp;,
    double,
    double,
    int);

position *
InputParameters(
    File *,
    point &amp;,
    point &amp;,
    point &amp;,
    double &amp;,
    double &amp;,
    int &amp;);

</PRE>
<a name="00f2_008c"><H3>Listing Two</H3>
<PRE>
short          Sample;         // variable for reading from file
int            NR;             // num of mirrored rooms per dimension
long           FileSize;       // number of samples to process
long           BufSize;        // size of sample array
long           *TapDelay;      // pointer to array of tap delays
long           SamplesIndex;   // current index into sample array
long           OutputIndex;    // index into sample array for output
unsigned long  ElapsedSamps=0; // elapsed time since new position 
float          *Samples;       // pointer to array of input samples
double         Output;         // the value of the current output
double         Fs;             // the sampling frequency
double         *TapGain;       // pointer to array of tap gains
double         ReflCoef;       // the reflectivity of the walls
double         InGain;         // a fixed gain applied to the input
position       *CurrentSource; // current source in positions list 
point          Room;           // coords for the room size
point          Source;         // coords of current sound source
point          Listener;       // coords of the listener

</PRE>
<P>
<H3>Listing Three</H3>

<PRE>/******************************************************************************
CalcImpResp

This subroutine calculates the time delays (in samples) and attenuations for the early reflections in the room.
******************************************************************************/

void
CalcImpResp
  (long * TapDelay,
  double * TapGain,
  point &amp; Room,
  point &amp; Source,
  point &amp; Listener,
  double ReflCoef,
  double Fs,
  int NR)
{
  double Dist;                     // distance travelled by sound ray
  double ReflOrd;                  // reflection order of sound ray
  point MirrSource;                // mirrored source x,y,z coords
  double DistSquared;              // Square of distance
  for (int i=-NR/2;i&lt;NR/2;i++) {   // loop through all 3 dimensions
     for (int j=-NR/2;j&lt;NR/2;j++) {
        for (int k=-NR/2;k&lt;NR/2;k++) {
          // calc x,y,z sound source coords in mirrored room
          MirrSource.X = (i)*Room.X 
                         +fabs(((i)%2)*Room.X
                         +pow(-1,(i))*Source.X;
          MirrSource.Y = (j)*Room.Y 
                          fabs(((j)%2)*Room.Y)
                         +pow(-1,(j))*Source.Y;
          MirrSource.Z = (k)*Room.Z 
                         +fabs(((k)%2)*Room.Z) 
                         +pow(-1,(k))*Source.Z;
          // calculate distance to listener
          Dist = sqrt (pow(MirrSource.X-Listener.X,2) 
                       +pow(MirrSource.Y-Listener.Y,2)
                       +pow(MirrSource.Z-Listener.Z,2));
          // calculate delayed arrival time of reflection
          TapDelay[(i+NR/2)*NR*NR+(j+NR/2)*NR+(k+NR/2)]=Dist/Vs*Fs;
          ReflOrd = abs(i)+abs(j)+abs(k);
          // calculate attenuation for the reflection
          TapGain[(i+NR/2)*NR*NR+(j+NR/2)*NR+(k+NR/2)]=
                  pow(RefDist/Dist,2.0)*pow(ReflCoef,ReflOrd);
        }
</PRE>

</BODY></HTML>
