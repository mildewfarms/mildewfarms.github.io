<HTML>
<META NAME="year" CONTENT="1996">
<HEAD>
<!-- This document was built using HyperWriter Professional by NTERGAID Inc. -->
<TITLE>FEB96: CGI and the World Wide Web</TITLE></HEAD>
<body bgcolor="FFFFFF">
<h1>CGI and the World Wide Web<a name="00b1_002d"><a name="00b1_002d"><a name="00b1_002b"><a name="00b1_0000"></h1><P>

<h2>Debugging CGI gateways</h2><P>

<h3>G. Dinesh Dutt</h3><P>

<P>
<i><a name="00b1_002c"><a name="00b1_0000">Dinesh is an engineer with Hinditron-Tektronix
Instruments Limited, Bombay, India. He can be contacted at brat@htilbom.ernet.in.</i></p><hr><P>

Much of the usefulness of the World Wide Web stems from the ability of Web servers to interact with
external programs. The technology that currently makes this possible is the Common Gateway Interface
(CGI). A common application of CGI, for instance, might involve a user querying a database via a form. Once
the form is filled out, a CGI script (or program) passes the request from the Web server to the external
database, gets the database output, and sends it back to the user.<P>

More specifically, CGI identifies how the Web server should supply input to the external programs, along
with the format of output to be returned. The server, in turn, gets inputs from a client such as a Web
browser. Since inputs are normally made available via the clients, I'll assume for this article that the
interaction occurs between the client and the gateway (external programs), instead of between the server
and gateway. Currently, HTTP servers are the only Web servers that support CGI. This means that CGI is
supported on all familiar platforms--UNIX, Macintosh, and Windows. <P>

The basic tools you need to use CGI are a language that produces executables (shell scripts, Tcl, Perl, or C,
for instance) and access to a CGI-enabled HTTP server. This article is based on UNIX, Perl 4.036, the NCSA
HTTPD 1.4 and CERN HTTPD 3pre6 servers, and CGI 1.1, but it applies to other servers, languages, and
platforms. For the sake of example, I'll build a simple form-based application (for information on forms, see
&quot;Coding with HTML Forms,&quot; by Andrew Davison, <I>Dr. Dobb's Journal</I>, June 1995) that
uses the form in <a href="9602a3f1.gif">Figure 1</A>. <a href="9602c.htm#00b1_003f">Listing
One</A> presents the HTML code that generates this form. As you can see, this form consists of a text box
and two radio buttons, only one of which can be selected. This provides a gateway with Author and Title
inputs. Input is passed to the gateway when the user clicks the Submit button. <P>

<h3><a name="00b1_002e">Data Input<a name="00b1_002e"></h3><P>

There are several ways in which input is passed to gateways, including forms-based methods and ISINDEX.
While each method supplies inputs differently, they all use environment variables to pass information. The
environment variables in Perl are available via the %ENV associative array. REQUEST_METHOD is one such
variable that indicates the method used to submit the input. (See <a href="9602c.htm#00b1_003c">Table
1</A> for a description of additional environmental variables CGI uses.)<P>

In <a href="9602c.htm#00b1_003a">Example 1(a)</A>, the form has an ACTION METHOD set to GET, so
the input is available to the gateway in the environment variable QUERY_STRING. With forms where the
ACTION METHOD is set to POST, input is available via <I>stdin</I> (standard input). The CGI specification
states that the server need not supply an end-of-file (EOF) for the input available via <I>stdin</I>. Instead,
the HTTP server provides the size of the input in the environment variable CONTENT_LENGTH. The first
gotcha comes here, when gateways try to read this input. Since the input is not terminated with an EOF
marker, the gateway must never read more than the CONTENT_LENGTH or it will wait for further input that
will never come. This hangs the gateway and the client awaiting the results. <a href="9602c.htm#00b1_003a">Example 1(b)</A> reads <I>stdin</I> to secure the input.<P>

When input is supplied via the ISINDEX interface, the input is made available via the command-line
arguments array ARGV. You can use standard command-line-argument parsing code to extract the inputs.
The REQUEST_METHOD variable is set to GET in this case, too. Information supplied via ISINDEX is sent as
part of the link, separated by a &quot;?&quot;; for example, <I>http://amadeus.org/play?Jupiter</I>,
where <I>Jupiter</I> is made available via command-line arguments ($ARGV[0], in this case). But
remember, the arguments cannot have blank spaces between them--even if you &quot;quote&quot; the
spaces. To pass arguments with spaces in them, replace each space with its equivalent hexadecimal ASCII
code prefixed by %; for example, <I>http:// amadeus.org/play?41st%20Symphony</I> will make the
gateway receive &quot;41st Symphony&quot; as its first argument.<P>

<h3><a name="00b1_002f">Making Sense of the Input<a name="00b1_002f"></h3><P>

If you were to simply print out the input, the result would be gibberish. One way to see what the gateway
receives is to use the test-cgi program that's supplied with the NCSA HTTPD. For example, to examine
what QUERY_STRING (which is using the GET submission method) looks like to the gateway, you can set the
ACTION to be &quot;test-cgi&quot;(prefixed by the proper http://your-server:port/cgi-bin/) in the
example form <I>name=The+Fountainhead</I><I>&amp;</I><I>keyword=title</I>.<P>

The inputs are presented to the server as a list of <I>name=value</I> pairs, with each pair separated by a
&quot;&amp;&quot; character. This format also converts blank spaces to &quot;+&quot; and converts all
special characters to their hexadecimal ASCII code. There are standard libraries available in many
languages to decode the input and present it in an understandable format. <a href="9602c.htm#00b1_0041">Listing Two</A> presents CGIGetInput, one such decoder written in
Perl.<P>

CGIGetInput understands both GET and POST methods and returns the inputs in an associative array (name
supplied by the caller), with each input-field name being the key and the value of the field being the value of
the array element. You can use the decoded output for processing. For instance, the debugcgi.cgi script of
<a href="9602c.htm#00b1_0043">Listing Three</A> uses this routine. <P>

However, in case of ISINDEX, the data format is different from the aforementioned cases. The name part is
entirely absent and the data is as submitted by the user with all hexadecimal symbols converted to their
ASCII equivalents. For instance, in the aforementioned example, the gateway gets &quot;41st
Symphony&quot; even though we said &quot;41st%20Symphony.&quot;<P>

<h3><a name="00b1_0030">Talking Back <a name="00b1_0030"></h3><P>

When the gateway needs to communicate with the server after processing, it can return the type of the
forthcoming output via the Content-type header. For an HTML document, this would be &quot;Content-type:
text/html.&quot; If you do not specify the type of the data returned, the browser returns a &quot;500
Server Error&quot; message to the user. The error logs of the server contain the reason &quot;malformed
header from script.&quot; This happens because HTTP first sends some metainformation about the object
that it's about to return--type, size, title, expiration date, and so on. If this information isn't forthcoming,
the server is unable to parse the input and returns the aforementioned error message. The valid types that
can be used in place of <I>text/html</I> are those that are supported by the browser/HTTP server. This is
given by the HTTP_ACCEPT environment variable. (Remember, not all browsers support all environment
variables.) For plain ASCII texts, <I>text/html</I> can be replaced by <I>text/plain</I>.<P>

Another effect of the processing could be a request to fetch another document. To do this, the URL of the
document is returned in the format <I>print ''Location: http://amadeus.org/Mozarts_Life.html\n\n'';</I>
which tells the server that it must retrieve the supplied URL and return that to the client. You could also
use the <I>PrintHeader</I> routine supplied in cgi-parse; see <a href="9602c.htm#00b1_0041">Listing
Two</A>. <a href="9602c.htm#00b1_003b">Example 2</A> provides typical calling sequences.<P>

<h3><a name="00b1_0031">Yet Another Input Method <a name="00b1_0031"></h3><P>

Another method for obtaining input information makes use of the PATH_INFO environment variable. To
illustrate, assume that you have a document that is available in both French and English. Depending on the
user's choice of language, the correct document must be served. If you have a CGI script called
&quot;document-disher,&quot; for instance, a link could be specified as:<P>

<pre>http://mymachine.org/cgi-bin/document-disher/French/Mon_Document
http://mymachine.org/cgi-bin/document-disher/English/My_Document</pre>

In this case, the CGI script could make use of the extra path information available at the end of the
pathname to retrieve the correct lingual document. <P>

The server also provides an environment variable PATH_TRANSLATED, which contains a complete, legal
filename based on PATH_INFO. Consequently, this &quot;multilingual&quot; document gateway could simply
print the contents of the file specified in PATH_TRANSLATED if the paths are configured properly.<P>

<h3><a name="00b1_0032">Which Input Method? <a name="00b1_0032"></h3><P>

The input method you use depends on your application. GET can be used when there's little information to be
supplied; for instance, a form like <a href="9602a3f1.gif">Figure 1</A>, that supplies only a keyword
and the type of the keyword. If your form involves more data, the contents of the environment variables
may be truncated. Consequently, you should use the POST method for large inputs. (The Mosaic forms
tutorial recommends use of the POST method only.) The ISINDEX approach to input, on the other hand, lends
itself to querying and works well when you don't know if forms are being used or when you have to support
browsers that don't support forms.<P>

Also, keep in mind that you can mix different input methods to some extent:<P>

<pre>http://mymachine.org/cgi-bin/documentdisher/French/Mon_Document?Speak
http://mymachine.org/cgi-bin/getfc?791+793</pre>

When forms are used as the method to submit input, people might want to pass information not modifiable by
the user (the form name, for example). You can do this by adding a ? followed by the form name to the URL
of the action link (or via PATH_INFO). While it's okay to do so, your script must &quot;know&quot; that the
input would be available in two different ways and read both of them; for example, by manually changing
the REQUEST_METHOD variable from within the script. However, the correct way to pass information
that's not modifiable by the user (again, the name of the form) when using forms is via hidden fields,
specified via the <I>TYPE=&quot;hidden&quot;</I> attribute in the form field. <P>

<h3><a name="00b1_0033">Debugging Gateways <a name="00b1_0033"></h3><P>

A gateway is like any other program in that you will need to be able to debug it. One of the basic problems
with CGI is that the scripts seem to work when used normally, but fail when called from within a Web
browser. The lack of error messages makes this doubly confusing.<P>

One way to debug gateways is to simulate the behavior of the HTTP server by setting all the relevant
environment variables (QUERY_STRING with the METHOD set to GET, for instance) and executing the script
to see if the decoding of information is correct. However, this does not test the changed environment under
which the gateway works once it's invoked by the WWW server.<P>

Consequently, I've written a program that reports errors in your gateway's execution, including those
caused by wrong assumptions about the environment. Using this program (which has its own forms-based
interface; see <a href="9602a3f2.gif">Figure 2</A>), it should be fairly easy for you to debug your
gateways, and the gateway need not even be written in Perl.<P>

The test script/form as shown in <a href="9602c.htm#00b1_0045">Listing Four</A> works as follows:
<P>

<ol>1.     Replace the action URL in the debug form (see <a href="9602c.htm#00b1_0047">Listing
Five</A>) with the correct path to debugcgi.cgi in your machine. Ensure that the cgi-parse.pl file is put in
the @INC of the debugcgi.cgi script and is made world readable. The debugcgi.cgi script needs to be world
readable and executable. </ol><P>

<ol>2.     Change the paths to the actual location for Perl (replace /usr/local/bin/perl). </ol><P>

<ol>3.     If you use forms to supply input, strip off the &lt;FORM&gt; and &lt;/FORM&gt; lines from your
form and attach the resulting body of the form to the debug form provided. For ISINDEX interfaces, supply
the arguments in the ISINDEX area of the form. </ol><P>

<ol>4.     Bring up a browser on this form. </ol><P>

<ol>5.     Enter the full pathname of the script invoked by the form to test and also supply the METHOD used
to submit information. </ol><P>

<ol>6.     Supply the input to your form. </ol><P>

<ol>7.     Click on Submit. </ol><P>

If everything is okay with your form, you are notified accordingly, and the output from the form is
displayed. (The program currently lacks support to handle pure image outputs.) If not, an error message is
displayed and the cause of the error reported, including any parsing errors for a script. All errors
resulting from a change in the environment (user to the server) are trapped and reported. Let's take a look
at some of the common errors encountered in writing gateways.<P>

One of the more common errors is to not provide all of the required environment to the script. When
testing, the script is running with its user id set to your id, so it has access to your entire environment,
files, and databases. However, when running under the server's control, it runs with the user id set to that
of the server, usually &quot;nobody,&quot; so it doesn't inherit your environment. Thus, executables
accessible during testing might not be found in actual use. Similarly, files readable during testing might
suddenly become unreadable. The necessary files should be world readable and world executable, and if they
need to be written to, world writable.<P>

Another common error occurs when you do not send the <I>Content-type</I> line as the first line of the
output returned by CGI. Make sure the first two lines of the form are the <I>Content-type </I>line followed
by a blank line; otherwise, the &quot;malformed header&quot; error appears. The <I>Content-type</I>
field needs to be set to the type of the object being returned.<P>

Also, by printing a <I>Content-type </I>line at the very beginning or before printing an error message, you
can redirect the errors to the user; otherwise, error messages end up in the daemon's error log.<P>

You should also ensure that your HTTP server supports CGI Version 1.1 and that the server is running with
the ability to recognize and execute CGI scripts. Many sites turn off CGI since it can be a security hole if
not properly configured. In the case of NCSA HTTPD, the directive <I>ScriptAlias</I> gives the paths that
can contain scripts. Also, if the <I>AddType</I> directive is defined as <I>AddType
application/x-httpd-cgi.cgi</I>, then a script ending in .cgi can be recognized anywhere the server has
access. Both directives are to be present in the srm.conf file. For the CERN server, scripts are configured
via the <I>Exec</I> directive.<P>

The script must be placed in the proper directory, and the server must be capable of recognizing a file with
a specific suffix, such as &quot;.cgi,&quot; as a script to be executed. <P>

A simple problem with the CERN server is caused by its parsing policy. If the path to your script is
passed/rejected before it encounters the desired <I>Exec</I> rule, the script will not be executed, but its
contents are returned as a document (in case of a reject, an error message is returned, not the script as a
document). To prevent this, ensure that the <I>Exec</I> rules come first for those directories containing
scripts. <P>

When troubleshooting, view the error log file for the HTTPD server you're using. The location of this file is
difficult to predict; it varies from a standard/var/httpd/logs/error_log to
/usr/lcal/dolphin/httpd/logs/error_log. <a href="9602c.htm#00b1_0038">Figure 3</A> shows the
contents of my server's <I>error_log</I> when problems occurred. One problem immediately apparent from
this log is that some of the errors do not indicate which script was the cause of the error message. The
&quot;Can't open 1057&quot; error is one such example. These errors are normally system related, such
as a call to an external program via <I>system()</I>. To properly trap and report system errors, include
the name of the script. It might make sense to print the contents of the environment variable
HTTP_REFERER (if available), which contains the the URL specified to get to this script.<P>

Furthermore, when using forms with the POST method, you must not expect an EOF; instead you must
access the CONTENT_LENGTH environment variable to get the number of bytes to read and then read only
that much. Otherwise, your script will hang. One nice feature of CERN HTTPD Version 3 is the ability to
specify a timeout period. If the script doesn't terminate within that time frame, it's killed. This is specified
via the <I>ScriptTimeOut</I> directive, and has a default value of five minutes. <P>

If you're mixing output from your script with output from external programs called from within the script,
you should unbuffer the output or else the output could be in some nonpredictable order. Also, unbuffering
STDOUT seems to improve performance, as the server gets output from the gateway immediately instead
of waiting until the buffer is full. <P>

<h3><a name="00b1_0034">Sending Output to the Browser <a name="00b1_0034"></h3><P>

In every case, the gateway spews out data without having to bother with HTTP reply-header format and
conventions. The server looks at this output and adds headers conforming with the HTTP protocol before
sending it to the client. If you wish to save the overhead of your server parsing the output, you may do so
by prepending the appropriate HTTP response headers.<P>

To prevent the server from parsing the output of such scripts, the scripts should have names that begin
with &quot;nph-&quot;. For example, NCSA HTTPD comes with a script called &quot;test-cgi.&quot; The
same script that talks directly to the browser is named &quot;nph-test-cgi.&quot; <P>

The main difference between such scripts and ordinary scripts is in the extra two lines that are prepended
to the output. The first is the status-code line and the second is the server: line that specifies the server
name and version. You need to look at the draft on HTTP to know all the valid status codes. For example, the
nph-test-cgi script returns the headers in <a href="9602c.htm#00b1_0039">Figure 4</A>.<P>

<h3><a name="00b1_0035">Customized Responses to Problems <a name="00b1_0035"></h3><P>

The NCSA HTTPD 1.4 server lets you customize the error message returned. For example, you could
customize the returned error message for a &quot;500 Server Error&quot; by calling a script that would
present a more informative message. To do this, examine the srm.conf file which contains these lines at the
end:<P>

<pre>ErrorDocument 302 /cgi-bin/redirect.cgi
ErrorDocument 403 /errors/forbidden.html</pre>

This means that the redirect.cgi script will be invoked when a redirect error occurs. <P>

<h3><a name="00b1_0036">Security<a name="00b1_0036"></h3><P>

Security is a crucial issue when writing CGI scripts because you are in effect allowing other users to
execute programs on your machine based on their inputs. Many of the problems encountered in writing CGI
scripts in this respect are similar to those encountered when writing UNIX setuid scripts. Consequently,
you should always follow the simple rule: Do not trust the client input at all. For example, do not blindly use
the client input to construct commands for the system to execute or supply as input to <I>eval</I>. Do not
even print the value input to your script (except during testing, of course) as hackers can use clever
sequences to break into the system.<P>

Further security is possible via the authentication mechanisms provided by most servers, which require
the user to key in a username and password. Only if this validates is the user allowed to execute the script.
Details on how to configure the server to do this are beyond the scope of this article. Refer to your server
manuals for details.<P>

<h3><a name="00b1_0037">Conclusion<a name="00b1_0037"></h3><P>

The net is a rich source of CGI information and numerous, freely available programs to ease your job of
writing and debugging gateway applications. Refer to the list of web sites in <a href="9602c.htm#00b1_003d">Table 2</A> for more information on CGI.<P>

<h4><B><a href="9602a3f1.gif">Figure 1</A>:</B> Typical Mosaic form.</h4><P>

<h4><B><a href="9602a3f2.gif">Figure 2</A>:</B> Forms-based interface of the debugcgi
program.</h4><P>

<h4><a name="00b1_0038"><B>Figure 3:</B> Error messages for server's error_log.<a name="00b1_0038"></h4><P>

<pre>panic: realloc at /usr/local/bin/rfc2html line 93, &lt;RFC&gt; line 1003.
Can't open 1057: No such file or directory
/usr/local/bin/rfc2html did not return a true value at<P>
/usr/local/etc/httpd/cgi-bin/rfc2html line 52, &lt;&gt;
line 14.
[Mon May 22 09:59:15 1995] httpd: malformed header from script</pre>

<h4><a name="00b1_0039"><B>Figure 4:</B> Headers returned by the nph-test-cgi script.<a name="00b1_0039"></h4><P>

<pre>HTTP/1.0 200 OK
Content-type: text/plain
Server: NCSA/1.3</pre>

<h4><a name="00b1_003a"><B>Example 1:</B> (a) Accessing the contents of QUERY_STRING; (b) reading input via stdin. <a name="00b1_003a"></h4><P>

<pre>(a)
if ($ENV{'REQUEST_METHOD'} eq &quot;GET&quot;) {
   $input = $ENV{'QUERY_STRING'};   
}

(b)
if ($ENV{'REQUEST_METHOD'} eq &quot;POST&quot;) {
  if (!defined ($ENV{'CONTENT_LENGTH'})) {  
     print &quot;Error: CONTENT_LENGTH not set\n&quot;;
     exit;
  }
  read (STDIN, $buffer, $ENV{'CONTENT_LENGTH});
}</pre>

<h4><a name="00b1_003b"><B>Example 2:</B> Typical calling sequences.<a name="00b1_003b"></h4><P>

<pre># Using the cgi-parse.pl, 
&amp;PrintHeader;       # Print just the default<P>
text/html;
&amp;PrintHeader (&quot;text/plain&quot;) # Print type to be<P>
text/plain.
# Redirect request to get new document
&amp;PrintHeader (&quot;http://amadeus.org/Mozarts_Life.html&quot;,1);</pre>

<h4><a name="00b1_003c"><B>Table 1:</B> Environment variables used by CGI. <a name="00b1_003c"></h4><P>

<pre>
Variable                 Description

HTTP_REFERER             Contains the exact URL in which the
                         script was invoked; for example,
                         http://www.halcyon.com/ htbin/browser-
                         survey. In some older versions of
                         browsers, this is called as
                         REFERER_URL.
                          
HTTP_USER_AGENT          Gives the name of the browser through
                         which the script was invoked. Using
                         this, one could serve different
                         browsers different documents, one with
                         or without netscapisms.
                         
REMOTE_USER              If authentication is enabled, this
                         returns the name for which the
                         authentication succeeded, the server
                         must support it.
                         
REMOTE_ADDR/REMOTE_HOST  Remote machine making the request. If
                         the hostname is unavailable, only the
                         address is set.
                         
SERVER_PROTOCOL          States the protocol and the version of
                         the protocol being used. Currently
                         HTTP 1.0 and HTTP 0.9 for older
                         servers.
                         
GATEWAY_INTERFACE        Name of the gateway interface being
                         used and the version number (currently
                         CGI 1.1).
                         
AUTH_TYPE                Protocol-specific authentication
                         supported by the server. Currently,
                         the only valid value is &quot;Basic.&quot;
                         
SERVER_SOFTWARE          Name of the server: NCSA 1.4, for
                         example, for the NCSA server version
                         1.4.
</pre>

<h4><a name="00b1_003d"><B>Table 2:</B> Web sites for information on CGI.<a name="00b1_003d"></h4><P>

NCSA's documentation on CGI<P>

<pre>http://hoohoo.ncsa.uiuc.edu/cgi/intro.html</pre>

CGI specification<P>

<pre>http://hoohoo.ncsa.uiuc.edu/cgi/interface.html</pre>

The HTTP draft<P>

<pre>http://info.w3.org/hypertext/WWW/Protocols/HTTP/HTTP2.html</pre>

CGI FAQ <P>

<pre>http://www.halcyon.com/hedlund/cgi-faq/</pre>

Yahoo index for CGI material<P>

<pre>http://akebono.stanford.edu/yahoo/Computers/World_Wide_Web/CGI___Common<P>
_Gateway_Interface/</pre>

Virtual library material on CGI<P>

<pre>http://www.charm.net/~web/Vlib/Providers/CGI.html</pre>

CGI-related newsgroups<P>

<pre>news://comp.infosystems.www.authoring.cgi</pre>

Currently available gateways<P>

<pre>http://www.w3.org/hypertext/WWW/Tools/Filters.html
http://www.nr.no/demo/gateways.html
http://www.halcyon.com/hedlund/cgi-faq/gateways.html
http://www.cis.ohio-state.edu:80/hypertext/about_this_cobweb.html</pre>

Language libraries for decoding forms input and other useful things<P>

<pre>http://wsk.eit.com/wsk/dist/doc/libcgi/libcgi.html - C
http://www.bio.cam.ac.uk/web/form.html - Perl
http://www.lbl.gov/~clarsen/projects/htcl/http-proc-args.html - Tcl</pre>

Survey of which browsers support which variables<P>

<pre>http://www.halcyon.com/htbin/browser-survey</pre>

<P>

<h4><a name="00b1_003e"><a name="00b1_003f">Listing One<a name="00b1_003f"></h4><pre>
&lt;FORM ACTION=&quot;http://yourmachine:urport/cgi-bin/testcgi.cgi&quot; METHOD=&quot;POST&quot;&gt; 
&lt;H1&gt;Illustration Form&lt;/H1&gt; 
 &lt;P ALIGN=JUSTIFY&gt; 
This form is used as a illustration to the article on CGI. 
&lt;HR&gt; 
&lt;INPUT TYPE=&quot;text&quot; NAME=&quot;name&quot; VALUE=&quot;&quot;&gt; 
Title&lt;BR&gt; 
&lt;OL&gt; 
&lt;LI&gt; &lt;INPUT TYPE=&quot;radio&quot; NAME=&quot;keyword&quot; VALUE=&quot;author&quot;&gt; 
Author 
&lt;LI&gt; &lt;INPUT TYPE=&quot;radio&quot; NAME=&quot;keyword&quot; VALUE=&quot;title&quot; CHECKED&gt; 
Title. 
&lt;/OL&gt; 
&lt;HR&gt; 
&lt;INPUT TYPE=&quot;submit&quot; VALUE=&quot;Submit Form&quot;&gt; 
Submit Button&lt;BR&gt; 
&lt;INPUT TYPE=&quot;reset&quot; VALUE=&quot;Clear Values&quot;&gt; 
Reset Button. 
 &lt;P&gt; 
&lt;/FORM&gt; 
</pre>
<h4><a name="00b1_0040"><a name="00b1_0041">Listing Two <a name="00b1_0041"></h4><pre>
###############################################################################
##                                CGI-PARSE.PL                               ##
## A library to read and parse the input available from forms as per the     ##
## CGI 1.1 specification.                                                    ##
## This code is in the public domain for people to do whatever they wish to  ##
## with it. But, maintain this copyright notice and don't say you wrote it.  ##
## This work is distributed in the hope that its useful. But, the author is  ##
## not liable for any any incurred damages, directly or indirectly due to    ##
## the use or inability to use this software.                                ##
###############################################################################
###############################################################################
## CGIGetInput                                                               ##
## This is a small function which decodes the forms input. It looks at the   ##
## REQUEST_METHOD environment variable to decide where to get the input from.##
## The user can invoke this subroutine thus :                                ##
##              &amp;CGIGetInput (*cgi_in);                                      ##
## and the input is returned in an associative array called cgi_in, with the ##
## key being the name of field and its value being the value of the field    ##
## as supplied by user. If the field does not have any input, the entry in   ##
## the associative array will be undefined.                                  ##
###############################################################################
sub CGIGetInput {
    local (*input) = @_;
    local ($buffer,@nv_pairs);
    if ($ENV{'REQUEST_METHOD'} eq &quot;GET&quot;) {
    $buffer = $ENV{'QUERY_STRING'};
    }
    elsif ($ENV{'REQUEST_METHOD'} eq &quot;POST&quot;) {
    read (STDIN, $buffer, $ENV{'CONTENT_LENGTH'});
    }
    else {
    return -1;
    }
    @nv_pairs = split (/\&amp;/,$buffer);
    foreach $nvp (0..$#nv_pairs) {
    $nv_pairs[$nvp] =~ tr/+/ /;
        ($key, $keyword) = split (/=/, $nv_pairs[$nvp], 2);
    $key =~ s#%(..)#pack(&quot;c&quot;,hex($1))#ge;
    $keyword =~ s#%(..)#pack(&quot;c&quot;,hex($1))#ge;
    $input{$key} .= '\0' if (defined ($input{$key}));
        $input{$key} .= $keyword;
    }
    return 1;
}
###############################################################################
## &amp;PrintHeader (type/URL, is_it_a_URL)                                      ##
## This function prints the default header. If a type is specified, that is  ##
## printed, else the default text/html is printed. If the second parameter is##
## 1, then the Location header is printed instead of the text/html header.   ##
##                                                                           ##
## Example invocations :                                                     ##
##      &amp;PrintHeader (&quot;text/plain&quot;, 0)                                       ##
##              &amp;PrintHeader (&quot;http://www.halcyon.com/hedlund/cgi-faq/&quot;,1)   ##
##              &amp;PrintHeader (&quot;&quot;,0)                                          ##
###############################################################################
sub PrintHeader {
    local ($toprint, $url_p) = @_;
    if ($toprint eq &quot;&quot;) {
    print &quot;Content-type: text/html\n\n&quot;;
    }
    elsif ($url_p) {
    print &quot;Location: $toprint\n\n&quot;;
    }
    else {
    print &quot;Content-type: $toprint\n\n&quot;;
    }
}
1;
</pre>
<h4><a name="00b1_0042"><a name="00b1_0043">Listing Three<a name="00b1_0043"></h4><pre>
###############################################################################
##                               DEBUGCGI.PL                                 ##
## This is a simple script which sets up a test environment for CGI script   ##
## to be executed and then traps the common errors. The PATH is set to the   ##
## minimal set by most systems, for example. All error messages are trapped  ##
## and made available to the user.                                           ##
##                                                                           ##
## This code is in the public domain for people to do whatever they wish to  ##
## with it. But, maintain this copyright notice and don't say you wrote it.  ##
## This work is distributed in the hope that its useful. But, the author is  ##
## not liable for any any incurred damages, directly or indirectly due to    ##
## the use or inability to use this software.                                ##
###############################################################################
$tmpdir = &quot;/tmp/&quot;;      # The directory under which the error file will
                # be created.
require &quot;cgi-parse.pl&quot;;
%cgi_input = ();
&amp;CGIGetInput(*cgi_input);
$script = $cgi_input{'DebugCgi-ScriptName'};
$method = $cgi_input{'DebugCgi-Method'};
$cmdargs = $cgi_input {'DebugCgi-CmdArgs'};
delete ($cgi_input {'DebugCgi-ScriptName'});
delete ($cgi_input {'DebugCgi-Method'});
delete ($cgi_input {'DebugCgi-CmdArgs'});
$inp = &quot;&quot;;
foreach $elem (keys %cgi_input) {
    $cgi_input{$elem} = $cgi_input{$elem};
    $cgi_input{$elem} =~ s# #+#g;
    $cgi_input{$elem} =~ s#([^+A-Za-z0-9])#sprintf(&quot;%%%02x&quot;,ord($1))#ge;
    $cgi_input{$elem} =~ s#%3d#=#g;
    $inp .= &quot;$elem=$cgi_input{$elem}&amp;&quot;;
}
# Encode the input in the form used by HTTP.
#Turn off the include path. The script must use its own @INC and environment.
if (! -e $script) {
    &amp;PrintErrHeader;
    print &quot;&lt;B&gt;Script &lt;EM&gt;$script&lt;/EM&gt; does not exist&lt;/B&gt;&lt;BR&gt;&quot;;
    &amp;PrintErrTrailer;
    exit (2);
}
if (! -r $script &amp;&amp; ! -x $script) {
    &amp;PrintErrHeader;
    print &quot;&lt;B&gt;Script &lt;EM&gt;$script&lt;/EM&gt; is not readable/executable by 
                                                               server&lt;/B&gt;&lt;BR&gt;&quot;;
    &amp;PrintErrTrailer;
    exit (2);
}
#Set the request method.
$error_file = $tmpdir.$^T;
$ENV{'REQUEST_METHOD'} = $method;
if ($method eq &quot;GET&quot;) {
    $ENV{'QUERY_STRING'} = $inp;
    open (OUTPUT, &quot;$script $cmdargs 2\&gt;/tmp/errors |&quot;) || 
                                         &amp;cry (&quot;unable to pipe script $! \n&quot;);
}
elsif ($method eq &quot;POST&quot;) {
    $ENV{'CONTENT_LENGTH'} = length($inp);
    open (OUTPUT, &quot;echo \&quot;$inp\&quot; | $script $cmdargs 2&gt;$error_file |&quot;) || 
                                         &amp;cry (&quot;unable to pipe script $! \n&quot;);
}
else {
    &amp;PrintHeader;
    print &quot;Unknown method: $method\n&quot;;
    exit (3);
}
$_ = &lt;OUTPUT&gt;;
if (!/^Content-type: / &amp;&amp; !/^Location: /) {
    if (-s $error_file) {
    open (ERRF, &quot;&lt; $error_file&quot;) || &amp;cry (&quot;testcgi.cgi - 
                                             Unable to open error file $!\n&quot;);
    &amp;PrintHeader;
    print &quot;&lt;HTML&gt;&lt;BODY&gt;\n&quot;;
    @errors = &lt;ERRF&gt;;
    &amp;PrintErrHeader;
    print &quot;&lt;B&gt;Script &lt;EM&gt;$script&lt;/EM&gt; has an execution 
                                                      error !!!&lt;/B&gt;&lt;BR&gt;&lt;BR&gt;&quot;;
    print &quot;@errors \n&quot;;
    &amp;PrintErrTrailer;
    unlink ($error_file);
    exit (4);
    }
    &amp;PrintErrHeader;
    print &quot;The script &lt;EM&gt;$script&lt;/EM&gt; has an error :&lt;BR&gt;&lt;BR&gt;&quot;;
    print &quot;It does not output the Content-type/Location header.&lt;BR&gt;&quot;;
    print &quot;Here's what it printed as the first line.\n&quot;;
    print &quot;&lt;PRE&gt;\n&quot;;
    print;
    print &quot;&lt;/PRE&gt;\n&quot;;
    &amp;PrintErrTrailer;
    exit (3);
}
$format = m#^Content-type:[ \t]*text/html#;
$_ = &lt;OUTPUT&gt;;
if (!/^$/) {
    &amp;PrintErrHeader;
    print &quot;The script &lt;EM&gt;$script&lt;/EM&gt; has an error :&lt;BR&gt;&lt;BR&gt;&quot;;
    print &quot;The second line it outputs must be a blank, instead I got &lt;PRE&gt;\n&quot;;
    print;
    print &quot;&lt;/PRE&gt;&quot;;
    &amp;PrintErrTrailer;
    exit (3);
}
&amp;PrintHeader;
print &quot;&lt;HTML&gt;&lt;BODY&gt;&lt;H3&gt;Script &lt;I&gt;$script&lt;/I&gt; seems OK !&lt;/H3&gt; \n&quot;;
print &quot;&lt;P ALIGN=Justify&gt; Here is its output:&lt;BR&gt;\n&quot;;
print &quot;&lt;PRE&gt;\n&quot; if (!$format) ;
print $ENV{'PATH_INFO'},&quot;\n&quot;;
while (&lt;OUTPUT&gt;) {
    print;
}
print &quot;&lt;/PRE&gt;&quot; if (!$format);
print &quot;&lt;/BODY&gt;&lt;/HTML&gt;&quot;;
exit (0);
sub cry {
    local ($message) = @_;
    &amp;PrintHeader;
    print &quot;&lt;HTML&gt;&lt;BODY&gt;&lt;H2&gt;Debugcgi Error !!&lt;/H2&gt;&quot;;
    print &quot;DebugCGI encountered an error during execution. 
                                                    The error is: &quot;, $message;
    print &quot;\n&lt;BODY&gt;&lt;HTML&gt;&quot;;
    exit;
}
sub PrintErrHeader {
    &amp;PrintHeader;
    print &quot;&lt;HTML&gt;&lt;BODY&gt;&lt;H3&gt;Script Error !!&lt;/H3&gt;&quot;;
}
sub PrintErrTrailer {
    print &quot;&lt;/BODY&gt;&lt;/HTML&gt;\n&quot;;
}
</pre>
<h4><a name="00b1_0044"><a name="00b1_0045">Listing Four<a name="00b1_0045"></h4><pre>
 
###############################################################################
##                                TESTCGI.PL                                 ##
## This is a script which sets up a test environment for the CGI script      ##
## to be executed and then traps the common errors. The PATH is set to the   ##
## minimal set by most systems, for example. All error messages are trapped  ##
## and made available to the user. Thus, he does not have to wonder why for  ##
## error cases.                                                              ##
## This code is in the public domain for people to do whatever they wish to  ##
## with it. But, maintain this copyright notice and don't say you wrote it.  ##
## This work is distributed in the hope that its useful. But, author is not  ##
## liable for any any incurred damages, directly or indirectly due to use    ##
## or inability to use this software.                                        ##
###############################################################################
 
$tmpdir = &quot;/tmp/&quot;;  # Directory under which the error file will be created.
require &quot;cgi-parse.pl&quot;; 
sub Usage { 
  print &quot;Usage: testcgi [-f filename containing input] -m METHOD scriptname\n&quot;;
  print &quot;       where METHOD is GET/POST\n&quot;; 
  exit (0); 
} 
%cgi_input = (); 
&amp;CGIGetInput(*cgi_input); 
&amp;PrintHeader; 
 
$script = $cgi_input{'TestCgi-ScriptName'}; 
$method = $cgi_input{'TestCgi-Method'}; 
delete ($cgi_input {'TestCgi-ScriptName'}); 
delete ($cgi_input {'TestCgi-Method'}); 
 
$inp = &quot;&quot;; 
foreach $elem (keys %cgi_input) { 
    $cgi_input{$elem} = $cgi_input{$elem}; 
    $cgi_input{$elem} =~ s# #+#g; 
    $cgi_input{$elem} =~ s#([^+A-Za-z0-9])#sprintf(&quot;%%%02x&quot;,ord($1))#ge; 
    $cgi_input{$elem} =~ s#%3d#=#g; 
    $inp .= &quot;$elem=$cgi_input{$elem}&amp;&quot;; 
} 
# Encode the input in the form used by HTTP. 
 
#Turn off the include path. The script must use its own @INC and environment. 
@INC=(); 
$ENV{'PATH'} = &quot;/bin:/usr/bin/:/etc:&quot;; 
 
#Set the request method. 
$error_file = $tmpdir.$^T; 
$ENV{'REQUEST_METHOD'} = $method; 
if ($method eq &quot;GET&quot;) { 
 $ENV{'QUERY_STRING'} = $inp; 
 open (OUTPUT,&quot;$script 2\&gt;/tmp/errors |&quot;) || die &quot;unable to pipe script $! \n&quot;;
} 
elsif ($method eq &quot;POST&quot;) { 
    $ENV{'CONTENT_LENGTH'} = length($inp); 
    open (OUTPUT,&quot;echo \&quot;$inp\&quot; | $script 2&gt;$error_file |&quot;) || die 
                                                &quot;unable to pipe script $! \n&quot;;
} 
else { 
    print &quot;Unknown method: $method\n&quot;; 
    exit (3); 
} 
print &quot;&lt;HTML&gt;&lt;BODY&gt;\n&quot;; 
$_ = &lt;OUTPUT&gt;; 
if (!/^Content-type: / &amp;&amp; !/^Location: /) { 
    if (-s $error_file) { 
    open (ERRF, &quot;&lt; $error_file&quot;) || die 
                                &quot;testcgi.cgi - Unable to open error file $!\n&quot;;
    print &quot;&lt;HTML&gt;&lt;BODY&gt;\n&quot;;     
    @errors = &lt;ERRF&gt;; 
    print &quot;&lt;H3&gt;Script $script has an execution error !!!&lt;/H3&gt;\n&quot;; 
    print &quot;@errors \n&quot;; 
    unlink ($error_file); 
    exit (4); 
    } 
    print &quot;&lt;H3&gt;Script $script has an error !!!&lt;/H3&gt;\n&quot;; 
    print &quot;It does not output the Content-type/Location header.\n&quot;; 
    exit (3); 
} 
$format = m#^Content-type:[ \t]*text/html#; 
$_ = &lt;OUTPUT&gt;; 
if (!/^$/) { 
    print &quot;Your second line must be a blank\n&quot;; 
    exit (3); 
} 
print &quot;&lt;H3&gt;Script $script Seems OK&lt;/H3&gt; \n&quot;; 
print &quot;&lt;P ALIGN=Justify&gt; Here is its output \n&quot;; 
print &quot;&lt;PRE&gt;\n&quot; if (!$format) ; 
while (&lt;OUTPUT&gt;) { 
    print; 
} 
print &quot;&lt;/PRE&gt;&quot; if (!$format); 
print &quot;&lt;/BODY&gt;&lt;/HTML&gt;&quot;; 
exit (0); 
</pre>
<h4><a name="00b1_0046"><a name="00b1_0047">Listing Five<a name="00b1_0047"></h4><pre>
 
&lt;!-- &lt;FORM ACTION=&quot;mailto:brat&quot; METHOD=&quot;POST&quot;&gt; --&gt; 
&lt;FORM ACTION=&quot;http://yourmachine:urport/cgi-bin/testcgi.cgi&quot; METHOD=&quot;POST&quot;&gt; 
&lt;H1&gt;Test CGI Form&lt;/H1&gt; 
 &lt;P ALIGN=JUSTIFY&gt; 
This form is used as a front-end to testcgi. 
&lt;HR&gt; 
&lt;INPUT TYPE=&quot;text&quot; NAME=&quot;TestCgi-ScriptName&quot; VALUE=&quot;&quot;&gt; 
Script Name&lt;BR&gt; 
&lt;INPUT TYPE=&quot;text&quot; NAME=&quot;TestCgi-Method&quot; VALUE=&quot;POST&quot;&gt; 
Method&lt;BR&gt; 
&lt;!-- Insert the form to be tested minus the FORM header and trailer --&gt; 
&lt;!-- and the Submit and clear buttons --&gt; 
&lt;HR&gt; 
&lt;INPUT TYPE=&quot;submit&quot; VALUE=&quot;Submit Form&quot;&gt; 
Submit Button&lt;BR&gt; 
&lt;INPUT TYPE=&quot;reset&quot; VALUE=&quot;Clear Values&quot;&gt; 
Reset Button. 
 &lt;P&gt; 
&lt;/FORM&gt;
</pre>
<P>

<P>

<P>

<P>

<P>

<P>

<P>

<P>

<P>

<P>

</BODY></HTML>
