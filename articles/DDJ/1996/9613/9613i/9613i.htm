<HTML>
<META NAME="year" CONTENT="1996">
<HEAD>
<!-- This document was built using HyperWriter Professional by NTERGAID Inc. -->
<TITLE>SP 96: PATTERNS AND SOFTWARE DESIGN</TITLE></HEAD>
<body bgcolor="FFFFFF">
<h1>PATTERNS AND SOFTWARE DESIGN<a name="0284_00da"><a name="0284_00da"><a name="0284_00d8"><a name="0284_0000"></h1><P>

<h2>The Courier Pattern</h2><P>

<h3>Richard Helm and Erich Gamma</h3><P>

<P>
<i><a name="0284_00d9"><a name="0284_0000">Richard is an architect with the IBM Consulting Group's Object Technology Practice in Sydney, Australia. Erich is an architect and object technologist at IFA in Zurich, Switzerland. They are coauthors of Design Patterns: Elements of Reusable Object-Oriented Software (Addison-Wesley, 1994).</i></p><hr><P>

In previous columns, we've stressed the importance of ensuring that objects that send a request assume only that objects receiving those requests support a particular interface, but not anything about the receiving objects' concrete class (that is, its implementation). This ensures that senders are decoupled from receivers, and results in a characteristic design where the definition of operations refers only to abstract--not concrete--classes. Several design patterns from our book <I>Design Patterns: Elements of Reusable Object-Oriented Software</I> involve decoupling senders and receivers of requests; the Observer pattern discussed in our &quot;Patterns and Software Design&quot; column (<I>Dr. Dobb's Sourcebook</I>, September/October 1995) is one of them. <P>

As <a href="9613d4f1.gif">Figure 1</A> illustrates, the Observer pattern decouples <I>Subjec</I><I>t</I>s from their dependent <I>Observe</I><I>r</I>s by defining an interface for signaling changes in the <I>Subject</I>. When decoupling senders and receivers, a common design issue is the kind of information passed between them. The simplest solution is to pass no information at all. <a href="9613i.htm#0284_00e2">Listing One</A> implements a <I>Notify()</I> operation that doesn't pass any information. Since no information is passed to the <I>Observer</I> and its <I>Update</I> operation, the <I>Observer</I> has to find out what changed by asking the <I>Subject</I> for its current state. In other words, it has to &quot;pull&quot; the state from the subject. When it is expensive for the <I>Observer</I> to determine what changed, the pull approach can be also be expensive. Clearly, there needs to be a way for the <I>Subject</I> to pass more-specific change information. The challenge, then, is making a concrete subject pass specific information about what changed to its concrete observers, given that the interface between subjects and observers is defined by the abstract classes <I>Subject</I> and <I>Observe</I><I>r</I>. <P>

One way to solve this is by adding a <I>void</I><I>*</I> as a parameter to a tag that identifies the information passed in the <I>void</I><I>*.</I> For example, you could change the <I>Update</I> operation of <I>Observer</I> to <I>Update(longwhatChanged, void</I><I>* </I><I>info)</I>. This approach is not particularly type safe, and a <I>void</I><I>*</I> in a higher-level class interface is not particularly elegant.<P>

Chain of Responsibility is another pattern that decouples the sender from the receiver. It does this by passing a request along a chain of potential receivers. As <a href="9613d4f2.gif">Figure 2</A> suggests, event handlers are a good use of this pattern. With the Chain of Responsibility pattern, objects at the front of the chain try to handle requests (events) generated by some initial sender. If they cannot, they pass the request along to the next object in the chain, hoping that some object down the line will eventually be able to handle it. Chain of Responsibility requires that each object in the chain have an interface for handling the request. Again, the problem is, how can a sender pass arbitrary information to its candidate receivers, or how can new types of events be handled by the chain of objects? Defining a fixed interface for a fixed set of events such as <I>HandleMouseEvent</I> or <I>HandleTimerEvent</I> is not a viable solution when the set of events is extensible. For example, if the system were extended to support drag-and-drop events, you would have to change existing classes and add a <I>HandleDropEvent</I> operation.<P>

The Mediator pattern also decouples objects by having them refer to each other indirectly through a <I>Mediator</I> object (see <a href="9613d4f3.gif">Figure 3</A>). The <I>Mediator</I> object is responsible for routing requests between <I>Colleague</I> objects. In the Mediator pattern, <I>Colleague</I> objects do not send requests directly to each other but instead go through an intermediary <I>Mediator</I>. This nicely decouples <I>Colleagu</I><I>e</I>s from each other, but also means that <I>Colleagu</I><I>e</I>s can only communicate with each other via the fixed <I>Mediator</I> interface. Again, you have the problem of defining an interface that enables concrete colleagues to pass specific information to one another.<P>

To summarize, decoupling objects by defining them in terms of interfaces defined in abstract classes is often the basis for reusable, object-oriented designs. But  the objects may become so decoupled from each other that their interfaces do not allow for the passage of specific information. The Courier pattern is one solution to this problem. <P>

<h3><a name="0284_00db">The Courier Pattern<a name="0284_00db"></h3><P>

Courier patterns allow objects to pass arbitrary requests and information through a fixed interface. The key to the Courier pattern is to package the information to be sent between objects as an object itself and pass this &quot;message object&quot; as an argument to requests. <P>

Let's begin by exploring the Courier pattern in the context of the Observer pattern. Assume that a <I>TextSubject</I> class defines an editable text buffer, and a <I>TextObserver</I> somehow displays the <I>TextSubject</I> (<a href="9613d4f1.gif">Figure 1</A>). The <I>TextObserver</I> class receives notifications about changes in its <I>TextSubject</I>. Implementing a <I>TextObserver</I> using the interface defined for the <I>Observer</I> class in <a href="9613d4f1.gif">Figure 1</A> would require that, when the <I>TextSubject</I> changes in any way, the <I>TextObserver</I> has to retrieve the complete text buffer from the <I>TextSubject</I>. There is no way for the <I>TextObserver</I> to determine what changed in the <I>TextSubject</I> using just the <I>Update()</I> interface. Ideally, the <I>TextSubject</I> would be able to inform its Observer exactly what about itself changed. Using the Courier pattern, we would package this information into an object and send that to the <I>TextObserver</I>. <P>

We first define a message object using the <I>Notification</I> class. In this case, we define it as an empty class; see <a href="9613i.htm#0284_00e4">Listing Two</A>. Then we change the <I>Notify</I> and <I>Update</I> interfaces of <I>Subject</I> and <I>Observe</I><I>r</I>; see <a href="9613i.htm#0284_00e6">Listing Three</A>.<P>

A <I>TextSubject</I> that wants to pass additional information to its Observers can now define a <I>TextChangeNotification</I> subclass that stores additional information about the changed text range. Assume in <a href="9613i.htm#0284_00e8">Listing Four</A> that there is already a <I>TextRange</I> class that can be used to specify a range of changed text. Now the <I>TextSubject</I> can pass a <I>TextChangeNotification</I> to notify its observers; see <a href="9613i.htm#0284_00ea">Listing Five</A>. Finally, a <I>TextObserver</I> can use this additional change information to optimize how it updates itself; see <a href="9613i.htm#0284_00ec">Listing Six</A>.<P>

Other kinds of notification requests (text deletion, style changes) could be easily added and handled in a similar way.<P>

In the Courier pattern, notification requests are represented as objects. The recipient of the request must analyze the message object and handle it appropriately. First, the notification object has to be decoded to identify its concrete class (we did this using the run-time, type-identification mechanism provided by C++). Then the appropriate code to handle this request must be determined and executed. In some situations, if the recipient class cannot handle the request, it may have to defer it to its parent classes. This adds run-time overhead.<P>

<h3><a name="0284_00dc">Participants<a name="0284_00dc"></h3><P>

As <a href="9613d4f4.gif">Figure 4</A> shows, the key participants in the Courier pattern are:<P>
<ul>
<li><I>Message</I> class (<I>Notification</I> in <a href="9613i.htm#0284_00ec">Listing Six</A>), which defines the message passed to a <I>Recipient</I>. It can represent requests and also define parameters and return values of the request. The <I>TextChangeNotification</I> represented a text-change request and also carried the request parameters (the range of text that changed). The interface to <I>Message</I> must allow clients to determine the kind of message (this can also be done by language mechanism). </li>
<li><I>Sender</I>, which creates a concrete <I>Message</I> and sends it to a <I>Recipient</I>.</li>
<li><I>Recipient</I> class (<I>Observer</I>), which defines the interface to <I>Handle</I> messages; for example, <I>Handle(Message</I>&amp;<I>)</I>. The <I>Recipient</I> must decode the <I>Message</I>, determine which code to execute, and retrieve any parameters from the <I>Message</I>. </li>
<li><I>ConcreteRecipients</I> (<I>TextObserver</I>), which receives <I>Messag</I><I>e</I>s and decodes them in the implementation of their <I>Handle</I> operation.</li>
<li><I>ConcreteMessages</I> (<I>TextChangeNotification</I>), which defines the actual contents of a particular <I>Message</I>.</li>
<li><I>Intermediary</I> classes, which forward <I>Messag</I><I>e</I>s from the initial <I>Sender</I> on to their ultimate <I>Recipient</I>.</li>
</ul>
Note that in <a href="9613d4f4.gif">Figure 4</A>, only the <I>Sender</I> and the <I>ConcreteRecipient</I> know about the <I>ConcreteMessage</I>.<P>

<h3><a name="0284_00dd">Applicability<a name="0284_00dd"></h3><P>

When should you use the Courier pattern? The first situation is when a fixed interface defined between abstract classes is insufficient to pass all information required to recipients that are concrete subclasses of these abstract classes. <P>

A second situation is when the requests to be sent between objects cannot be anticipated in advance, and you need to provide hooks to allow the interface to be extended for new requests. This occurs in event handlers implemented using Chain of Responsibility when you want to extend the kinds of events the handlers can process.<P>

In the third situation, the class and the interface of the receiver are unknown to classes sending requests, because the requests are sent via a third object. In Mediator and Chain of Responsibility, the class and even the interface of the class of object receiving requests are unknown to the sender. Rather than having the intervening object modifying or adapting the requests passing through it so it can be received by the ultimate recipient, we instead define a single <I>Handle(Message</I>&amp;<I>)</I> interface to allow the <I>Messag</I><I>e</I>s to be passed to the final <I>Recipient</I> unchanged.<P>

Most uses of Courier are for more-loosely decoupling classes than is possible through interfaces defined by abstract classes. Another situation in which Courier can be very useful is during initial system prototyping and development. <P>

One problem with statically typed languages (such as C++) is that you must explicitly specify the interfaces to abstract classes in their declaration. You also have to duplicate much of this interface declaration (certainly for the virtual functions) in all subclasses inheriting from these abstract classes. Yet, as systems evolve, their interfaces change. This is especially true of newer systems, where it usually takes a few design iterations to find the major abstractions and specify their interfaces correctly. Changing interfaces to classes in C++ can be a costly operation. Not only do all subclass declarations and definitions need to be rewritten, but a significant amount of compile time may be spent in all clients implemented in terms of this interface.<P>

For systems being prototyped or evolving rapidly, an alternative is to use the Courier pattern to send requests between classes in a system. Because Courier allows interfaces of classes to be changed just by modifying class implementations (or more precisely, the dispatching code in their <I>Handle(Message</I>&amp;<I>)</I> operations), there is much less cost in changing interfaces. You simply have to add new <I>Message</I> subclasses and the appropriate dispatching code.<P>

When the interfaces eventually begin to &quot;harden,&quot; the implicit dispatching provided by the Courier pattern can be replaced by direct requests to operations defined explicitly by the classes. The bodies of these operations will be what was previously the bodies of the If statements in the <I>Recipien</I><I>t</I>'s dispatching operations.<P>

<h3><a name="0284_00de">Advantages and Disadvantages<a name="0284_00de"></h3><P>

The Courier pattern offers a number of benefits:<P>
<ul>
<li>Sending <I>Message</I>s to a <I>Recipient</I> class requires few assumptions about the <I>Recipien</I><I>t</I>'s interface. It only has to define an interface to handle messages. This allows the <I>Sender</I> and <I>Recipient</I> to remain loosely coupled. </li>
<li>It permits message-sending strategies such as broadcasting messages to all possible <I>Recipien</I><I>t</I>s without caring about the class or interface of the receivers (only that they implement a <I>Handle</I> message). <I>Receive</I><I>r</I>s not interested in a particular message can simply ignore it. This avoids base classes becoming bloated with an interface that supports all possible operations. All a base class has to provide is a <I>Handle(Message</I>&amp;<I>)</I> operation. </li>
<li>Adding a new kind of message does not require changing existing classes. Simply define a new <I>Message</I> class and implement the code that decodes and executes the message.</li>
</ul>
The Courier pattern also has some inherent disadvantages:<P>
<ul>
<li>The cost of <I>Message</I> dispatching. Decoding the <I>Message</I> to determine its class, retrieving any parameters, and finding the operation to perform must be done explicitly with conditional statements defined in the recipient. This is inelegant and can be less efficient than using the language's dispatching mechanisms directly. </li>
<li>There is no guarantee that a <I>Message</I> can be handled by a <I>Recipient</I>. The compiler will not check that <I>Messag</I><I>e</I>s are valid for a <I>Recipient</I>, that the message is decoded correctly, or that the operation to be performed by the <I>Recipient</I> is the correct one.</li>
<li>The implementation of the <I>Handle</I> operation determines completely what a <I>Recipient</I> can do. It is not possible to infer any semantics about a <I>Recipient</I> from its interface.</li>
</ul>
<h3><a name="0284_00df">Implementation Issues<a name="0284_00df"></h3><P>

One of the challenges when implementing Courier patterns is identifying the <I>Message</I> classes. To be able to handle a <I>Message</I>, a <I>Recipient</I> must be able to identify the kind of <I>Message</I> it receives. The <I>Message</I> can define an accessor function that returns an identifier for the class as a constant or a string. This requires that the sender and receiver agree on the encoding. Alternatively, the receiver can use the language-supported, run-time type information, as we have in the Observer example. In this case, there is no need for special <I>Message</I> encoding conventions. <P>

A second issue is acknowledging <I>Message</I> receipt. Senders sometimes need to know whether a <I>Message</I> was handled or not. For example, when propagating a message along a chain of responsibility, the sender can stop propagating the request once it is handled. To provide this kind of information, the <I>Handle(Message</I>&amp;<I>)</I> operation can return a Boolean.<P>

Another implementation issue involves handling requests, which requires identifying the message, then performing the appropriate action. Message handling is often distributed across a base recipient class and its subclasses. The base class can handle a more-general message, and the subclasses can handle more-specific messages. To enable this kind of message handling the derived class has to invoke the inherited <I>Handle</I> operation when it receives a message that it does not handle, as in <a href="9613i.htm#0284_00ee">Listing Seven</A>.<P>

The <I>Recipien</I><I>t</I>'s message dispatch code is essentially boilerplate code. Where possible, the burden of having to create this boilerplate should be removed from the client. One way is to have a code generator (often called a &quot;wizard&quot;) that generates the code based on some specification.<P>

<h3><a name="0284_00e0">Self-Dispatching Messages<a name="0284_00e0"></h3><P>

One potential problem with implementing Courier patterns is that all the dispatching code is in the <I>Recipient</I>. An alternative solution is to make <I>Messag</I><I>e</I>s self dispatching. <P>

When we perform the dispatching, we have different <I>Recipients</I> and different <I>Messag</I><I>e</I>s. Code that actually gets executed when a message is received depends on both the concrete classes (more strictly speaking, the type) of both the <I>Recipient</I> and  <I>Message</I> objects. There are languages (CLOS, for example) that support operations (multi-methods-methods) that can be dispatched on more than one parameter type. In such languages, message dispatching would be handled by language directly and not implemented programmatically by the programmer. However, languages such as C++ and Smalltalk dispatch operations on the type of only one object--the object receiving the request. <P>

One technique to dispatch operations on multiple classes in such languages is &quot;double dispatch.&quot; We use a variation of this technique in <a href="9613i.htm#0284_00f0">Listing Eight</A>. (The only implementation we're aware of that uses this technique is the Input System of the Taligent Frameworks.) <P>

The <I>Messag</I><I>e</I>s dispatch themselves. To do so, the base <I>Message</I> class defines a <I>Dispatch</I> function that takes a <I>Handler</I> as a parameter. The <I>Handler</I> class itself has the interface in <a href="9613i.htm#0284_00f0">Listing Eight</A>. The <I>Message</I> base class implements the <I>Dispatch</I> function by simply calling <I>HandleMessage</I> on the handler passed to it; see <a href="9613i.htm#0284_00f2">Listing Nine</A>. A <I>Sender</I> uses these classes in <a href="9613i.htm#0284_00f4">Listing Ten</A>. So far this appears not very useful, as we've only introduced an additional level of dispatching. But <I>Sender</I> need know nothing about the concrete classes of the <I>Message</I> or the <I>MessageHandler</I>. <P>

Next, we define abstract classes that specify an interface for classes that wish to handle particular kinds of messages. Let's take a <I>TimerMessage</I> class defined as in <a href="9613i.htm#0284_00f6">Listing Eleven</A>. For a <I>TimerMessage</I>, we define the <I>TimerMessageHandler</I> class in <a href="9613i.htm#0284_00f8">Listing Twelve</A>. These handler classes for specific messages are used as <I>mixin</I> classes. A class that wants to handle a <I>TimerMessage</I> has to inherit from the <I>TimerMessageHandler</I> class and implement the pure virtual <I>HandleTimerMessage</I> function; see <a href="9613i.htm#0284_00fa">Listing Thirteen</A>. Since the <I>Sender</I> sees only <I>Messag</I><I>e</I>s and <I>MessageHandle</I><I>r</I>s, you may wonder how a particular <I>Message</I> finds its way to the specific <I>MessageHandler</I>. We first request a message to dispatch itself to a particular handler, then the message requests the handler to handle it. Consider the implementation of <I>Dispatch</I> for <I>TimerMessage</I>. It uses run-time type information to check whether the handler is a <I>TimerMessageHandler</I>. If it is, the message is delivered as a <I>TimerMessage</I> by calling <I>HandleTimerMessag</I><I>e</I>; see <a href="9613i.htm#0284_00fc">Listing Fourteen</A>. <I>Dispatch</I> invokes its inherited operation that delivers the <I>Message</I> as an ordinary message. The handler can use the less efficient, but more general, <I>HandleMessage</I> operation to handle the message.<P>

The <I>Sende</I><I>r</I>'s<I> first</I> dispatch shows that the message is in fact a <I>TimerMessage</I>. The message then works out the type of the handler to call the appropriate operation for it, in this case <I>HandleTimerMessage</I>.<P>

This technique frees the client code from dispatching messages by delegating the dispatching logic to the <I>Message</I> itself. However, it does have some drawbacks:<P>
<ul>
<li>Each different message kind needs a corresponding <I>Handler</I> class, so the number of classes is increased by two for each new message kind.</li>
<li>A class that handles many different message kinds has a <I>HandlerClasses</I> list. </li>
<li>When a class wants to handle an additional message kind, its interface has to be changed, since an additional handler class has to be mixed in.</li>
</ul>
<h4><B><a href="9613d4f1.gif">Figure 1</A>: </B>Observer pattern decouples Subject<I>s</I> from their dependent Observer<I>s</I>.</h4><P>

<h4><B><a href="9613d4f2.gif">Figure 2</A>:</B> Using the Chain of Responsibility pattern for event handlers.</h4><P>

<h4><B><a href="9613d4f3.gif">Figure 3</A>:</B> The Mediator pattern; (a) with no Mediator; (b) with Mediator.</h4><P>

<h4><B><a href="9613d4f4.gif">Figure 4</A>:</B> Key participants in the Courier pattern.</h4><P>

<P>

<h4><a name="0284_00e1"><a name="0284_00e2">Listing One<a name="0284_00e2"></h4><pre>
class Observer {
public: 
    //...
    virtual void Update();
};
class Subject {
public:
    void Attach(Observer*);
    void Detach(Observer*);
    void Notify();
private:
    List&lt;Observer*&gt; _observers;
};
void Subject::Notify ()
{
    ListIterator&lt;Observer*&gt; i(_observers);
    for (i.First(); !i.IsDone(); i.Next() ) {
        i.CurrentItem()-&gt;Update();
    }
}
</pre>
<h4><a name="0284_00e3"><a name="0284_00e4">Listing Two<a name="0284_00e4"></h4><pre>
class Notification {
public:
    virtual ~Notification();
protected:
    Notification();
};
</pre>
<h4><a name="0284_00e5"><a name="0284_00e6">Listing Three<a name="0284_00e6"></h4><pre>
class Subject {
public:
    // ...
    void Notify(Notification&amp;);
};
class Observer {
public:
    // ...
    void Update(Notification&amp;);
};
</pre>
<h4><a name="0284_00e7"><a name="0284_00e8">Listing Four<a name="0284_00e8"></h4><pre>
class TextChangeNotification: public Notification {
public:
    TextNotification(TextRange range);
    TextRange GetRange() const;
    //...
private:
    TextRange _range;
};
</pre>
<h4><a name="0284_00e9"><a name="0284_00ea">Listing Five<a name="0284_00ea"></h4><pre>
void TextSubject::ReplaceText (TextRange range)
{
    // Change the Text...
    // ... and tell all Observers
    Notify(TextChangeNotification(range));
}
</pre>
<h4><a name="0284_00eb"><a name="0284_00ec">Listing Six<a name="0284_00ec"></h4><pre>
void TextObserver::Update(Notification&amp; notification)
{
    TextChangeNotification *changeNotification;
    changeNotification =        
        dynamic_cast&lt;TextChangeNotification*&gt;(&amp;notification);
    if (changeNotification) {
        TextRange range = changeNotification-&gt;GetRange()
        // do an incremental update using _text-&gt;GetText(range);
    } else {
        // do a full update using _text-&gt;GetText();
    }
}
</pre>
<h4><a name="0284_00ed"><a name="0284_00ee">Listing Seven<a name="0284_00ee"></h4><pre>
void Recipient::Handle(Message&amp; m)
{
    MyMessage *myMessage = dynamic_cast&lt;MyMessage*&gt;(&amp;m);
    if (myMessage) {
        HandleMyMessage(myMessage);
        return;
    }
    OtherMessage *otherMessage = dynamic_cast&lt;OtherMessage*&gt;(&amp;m);
    if (otherMessage) {
        HandleOtherMessage(otherMessage);
        return;
    }
    // unknown message, pass it to the base class BaseHandler
    BaseRecipient::Handle(m);
}
</pre>
<h4><a name="0284_00ef"><a name="0284_00f0">Listing Eight <a name="0284_00f0"></h4><pre>
class MessageHandler {
public:
    virtual void HandleMessage(Message&amp; message);
    //...
};
</pre>
<h4><a name="0284_00f1"><a name="0284_00f2">Listing Nine<a name="0284_00f2"></h4><pre>
class Message {
public:
    virtual void Dispatch(MessageHandler&amp; handler);
    //...
};
void Message::Dispatch(MessageHandler&amp; handler)
{
    handler.HandleMessage(*this);
}
</pre>
<h4><a name="0284_00f3"><a name="0284_00f4">Listing Ten<a name="0284_00f4"></h4><pre>
void Sender::Operation() {
    Message *aMessage;
    MessageHandler *aHandler;
    // .. dispatch the message...
    aMessage-&gt;Dispatch(aHandler);
}
</pre>
<h4><a name="0284_00f5"><a name="0284_00f6">Listing Eleven<a name="0284_00f6"></h4><pre>
class TimerMessage: public Message {
public:
    TimerMessage(long);
    int GetTime() const;
    virtual void Dispatch(MessageHandler&amp; handler);
    //...
};
</pre>
<h4><a name="0284_00f7"><a name="0284_00f8">Listing Twelve<a name="0284_00f8"></h4><pre>
class TimerMessageHandler : public MessageHandler {
public:
    virtual HandleTimerMessage(TimerMessage&amp; message) = 0;
};
</pre>
<h4><a name="0284_00f9"><a name="0284_00fa">Listing Thirteen<a name="0284_00fa"></h4><pre>
class MyHandler: 
    public SomeBaseClass, 
    public TimerMessageHandler {
public:
    virtual void HandleTimeMessage(TimerMessage&amp; message);
    //...
};
</pre>
<h4><a name="0284_00fb"><a name="0284_00fc">Listing Fourteen<a name="0284_00fc"></h4><pre>
void TimerMessage::Dispatch(MessageHandler&amp; handler)
{
    TimerMessageHandler* timerHandler;
    timerHandler = dynamic_cast&lt;TimerMesageHandler&gt;(&amp;handler);
    if (timerHandler)
        timerHandler-&gt;HandleTimerMessage(*this);
    else
        Message::Dispatch(handler);
}
End Listings
</pre>
<P>

<P>

<P>

<P>

<P>

<P>

<P>

<P>

<P>

<P>

</BODY></HTML>
