<HTML>
<META NAME="year" CONTENT="1996">
<HEAD>
<!-- This document was built using HyperWriter Professional by NTERGAID Inc. -->
<TITLE>MAR96: Building Parsers with Leopurd</TITLE></HEAD>
<body bgcolor="FFFFFF">
<h1>Building Parsers with Leopurd<a name="0104_004c"><a name="0104_004c"><a name="0104_004a"><a name="0104_0000"></h1><P>

<h2>A portable parser for the rest of us</h2><P>

<h3>Thor Mirchandani</h3><P>

<P>
<i><a name="0104_004b"><a name="0104_0000">Thor is a consultant in Winston-Salem, NC. He
specializes in object technology and development of distributed systems using C/C++ and
PowerBuilder.</i></p><hr><P>

Whether it's from a user, script file, or serial line, input often must be broken into logical parts before it
can be processed. Many programmers resort to nested conditions involving string comparisons, but the
resulting code can be hard to understand and maintain. Sometimes a brute-force approach is not sufficient,
and trusty old yacc is used to generate a &quot;real&quot; parser. The advantage of this approach is that
only the grammar must be maintained; the disadvantage is that yacc generates table-driven parsers that
are difficult to read and modify manually. In this article, I'll present leopurd, a program that generates a
maintainable, table-free parser from an input grammar.<P>

<h3><a name="0104_004d">Top-Down and Bottom-Up Parsers<a name="0104_004d"></h3><P>

The two types of parsers in widespread use are top-down and bottom-up. All parsers read language tokens
from an input stream and examine them against a set of production rules. Each rule has a left side--the
target--and a right side describing a valid way to reach the target. More than one production rule can be
associated with each target. <P>

A typical bottom-up parser determines which production rule to apply for a given input sequence by
implementing rules as lookup tables. When the parser receives the first token, it tags all rules that can
begin with that token. As it reads more tokens, it eliminates candidate rules until only one remains. This
process involves guesswork and backtracking. The code implementing table-driven, bottom-up parsers is
illegible and difficult to modify, and parser speed often is slower than that of top-down parsers. However,
plenty of tools generate bottom-up parsers automatically, and such parsers can always be generated for an
unambiguous grammar that requires no more than one token look ahead. Bottom-up parsers include those
generated by yacc, bison, and similar programs.<P>

Most handcoded parsers are of the top-down variety, and start with the top-level rule in the grammar.
They examine input to see if they can complete this rule. If not, other functions are called to parse any
candidate rules. As each rule is completed, the corresponding function executes action code associated with
the rule and returns control to the caller. Top-down parsers are easier to modify and optimize than
table-driven parsers--the parser can often be made both smaller and faster. However, no standardized
tools exist for generating top-down parsers, and some grammars cannot be implemented correctly as
top-down parsers. (Fortunately, most popular computer languages can be easily parsed this way.)<P>

The leopurd parser combines the best features of both top-down and bottom-up parsers. It builds legible,
maintainable, optimizable top-down parsers from standard grammars similar to yacc grammars. Leopurd
generates two C source files from an input grammar: yyleo.h, containing definitions and function
prototypes; and yyleo.c, containing the parser source code and any user-supplied code.<P>

<h3><a name="0104_004e">The Leopurd Grammar<a name="0104_004e"></h3><P>

Leopurd's input grammar describes the syntax of the parser input. The syntax of a language tells you only if
a sentence is valid; the sentence's meaning is the realm of semantics. Leopurd supports a subset of the yacc
definition language, but it lacks a literal block, associativity, %type and %union statements in the definition
section, and C action statements in the rules section. Future versions of leopurd should be fully compatible
with yacc.<P>

A grammar file has three sections, separated by double percent signs (%%). The first section is the
definition section, where you define the unique parts of a language--the language's terminal tokens. A
definition begins with <I>%token</I>, followed by one or more terminal-token identifiers, which can be
names or single characters within single quotes. <a href="9603c.htm#0104_0053">Example 1</A>
defines four unique tokens for a simple calculator.<P>

The rules section defines the syntax of the language, showing the order in which tokens may appear in a
sentence. The left side of a production rule is an abstract (nonterminal) symbol. The right side is a
combination of nonterminal and terminal symbols, arranged the way they appear in a sentence. More than
one right side can be assigned to each left side if separated by a pipe symbol (|). A semicolon terminates a
group of rules for a single left side. Every nonterminal symbol referenced in a right side must be defined in
a left side somewhere in the grammar.<P>

<a href="9603c.htm#0104_0054">Example 2</A> defines the abstract symbol &quot;expression&quot;
to be a sum or difference followed by an equal sign. The second rule illustrates how recursion is used. It
defines a <I>sum</I> to be a NUMBER followed by '+' and another NUMBER, or a NUMBER followed by '+' and
another <I>sum</I>. The abstract symbol <I>difference</I> is defined similarly. Both the rules and
definition sections may contain any amount of whitespace.<P>

A right side can be empty. Unlike yacc, leopurd requires that you define the special token EMPTY if your
grammar uses empty production rules, as shown in the productions for <I>sum</I>. A nonterminal symbol
that matches EMPTY by some rule is said to be &quot;nullable.&quot; <P>

The final part of the grammar, the user section, is copied verbatim to the output file yyleo.c and can be any
legal C code. Here you can put code used by the parser, such as a scanner, error handler, symbol table,
global variables, and a <I>main()</I> function for testing the parser; see <a href="9603c.htm#0104_0055">Example 3</A>.<P>

<h3><a name="0104_004f">Code Generation<a name="0104_004f"></h3><P>

Leopurd generates C code to implement a top-down recursive descent parser from an input grammar. The
entry point to the parser is the function <I>yyparse()</I>. The parsing target for <I>yyparse()</I> is the
top-most nonterminal symbol in the grammar. Since there can be only one <I>yyparse()</I>, there can be
only one top-level target.<P>

Because error handling varies widely between applications, leopurd generates only the prototype of the
error handler, <I>yyerror().</I><P>

Leopurd also generates prototypes for the functions <I>next()</I> and <I>match()</I>. A call to
<I>next()</I> causes the next token to be read from the input stream. A subsequent call to <I>match()</I>
evaluates whether the argument matches the token read from input. These functions are highly dependent on
the nature of the input and are left up to you to implement.<P>

Two functions are generated for each nonterminal symbol: <I>&lt;name&gt;_parse()</I> and
<I>&lt;name&gt;_action()</I>. The <I>&lt;name&gt;_parse</I> functions are generated completely by
leopurd and perform the actual parsing of the nonterminal symbol <I>&lt;name&gt;</I>.<P>

The <I>&lt;name&gt;_action()</I> functions are placeholders for the language's semantics. Leopurd
generates a function skeleton, to which you add actions to be taken upon successful parsing of the token.
Separating syntax and semantics in this way increases portability and maintainability, and simplifies
testing and debugging.<P>

<h3><a name="0104_0050">Recursive-Descent Parsing <a name="0104_0050"></h3><P>

An abstract, top-down parser parses a sentence by building a parse tree, in which each node represents a
token. After a tree is built, the parser traverses the tree in postorder, executing code associated with each
node. If the parser cannot generate a tree, it flags an error and returns. <P>

Recursive-descent parsers generate parse trees implicitly by calling parse functions recursively. Upon a
successful parse, the leaf function returns. As each parse function returns, its action code executes. <P>

Parsing starts with the <I>yyparse()</I> function, which gets the first token from the input by calling
<I>next()</I>. yyparse() then determines which production rule to use by calling <I>match()</I>. When a
match is found, the parser does one of two things: If it expects a terminal token, it gets the next token and
checks it by calling <I>match(</I><I>)</I>; if it expects a nonterminal symbol, it calls the symbol's
<I>&lt;name&gt;_parse()</I> function. This process continues until an error is encountered, in which case
<I>yyerror()</I> is called or the production rule is parsed successfully. Upon success, the last
<I>&lt;name&gt;_parse()</I> function calls <I>&lt;name&gt;_action()</I>, which executes code associated
with <I>&lt;name&gt;</I>. After <I>&lt;name&gt;_action()</I> returns, the process continues until the
whole parse tree is unwound. Finally, any actions associated with <I>yyparse()</I> are executed, and
<I>yyparse()</I> returns.<P>

Since functions return in the reverse of the order in which they are called, the
<I>&lt;name&gt;_action()</I> code of leaf nodes exe-cutes before code closer to the root. Thus, a
production far down in the grammar has precedence over one further up. This is how the grammar's
structure determines operator precedence. (Right-recursive rules result in right-association for
operations.)<P>

How does the parser determine which production rule to select? How do you determine which tokens to
match against? For terminal tokens, the parser just matches against the token itself. For nonterminals, it
must know which terminal tokens can legally begin a particular nonterminal. That set of tokens for a
nonterminal n is called &quot;first of n&quot; and is written FIRST(n). <P>

For a nullable nonterminal, you must determine which terminal tokens can legally come after the empty
nonterminal. That set of tokens is called &quot;follow of n&quot; and written FOLLOW(n). Finding the
FIRST() and FOLLOW() sets is an iterative process. Once the sets are defined, leopurd knows which tokens
to match in each rule.<P>

The resulting parser will operate properly only if the FIRST() and FOLLOW() sets unambiguously determine
which production rule to choose at each step. The grammar in <a href="9603c.htm#0104_0053">Example
1</A> and <a href="9603c.htm#0104_0054">Example 2</A> is riddled with such problems.<P>

Leopurd produces a trace of terminal and nonterminal tokens, production rules, and FIRST() and FOLLOW()
sets. The trace is directed to <I>stdout</I>, and can be captured in a file for debugging or grammar
verification.<P>

<h3><a name="0104_0051">A Parser Example<a name="0104_0051"></h3><P>

<a href="9603c.htm#0104_0058">Listing One</A> shows a grammar for a calculator which can evaluate
addition and subtraction expressions. When an equal sign (=) is parsed, the expression is evaluated. <P>

The user section defines the functions <I>yyerror()</I>, <I>next()</I>, and <I>match()</I>, which are
declared by leopurd, and a <I>main()</I> function that can read input from a file or standard input. <P>

The function <I>yylex()</I> is the scanner/lexical analyzer, which recognizes tokens in the input stream
and returns their values. The global variable <I>yytext</I> points to the first character of the current
token. The token's length is stored in <I>yyleng</I>.<P>

When run with the grammar in <a href="9603c.htm#0104_0058">Listing One</A>, leopurd produces
output on <I>stdout</I> similar to <a href="9603c.htm#0104_005a">Listing Two</A>. Listings <a href="9603c.htm#0104_005c">Three</A> and <a href="9603c.htm#0104_005e">Four</A>
are the generated files, yyleo.h and yyleo.c. <P>

The <I>&lt;name&gt;_parse()</I> functions implement a ready-to-roll parser. The top-level parse
function, <I>statement</I>, is renamed to <I>yyparse()</I>. If the top-level nonterminal uses recursion
(like the production rule in <a href="9603c.htm#0104_0056">Example 4</A>), a redefinition of
<I>statement_parse()</I> in yyleo.h maps it to the <I>yyparse()</I> function. Also, although no explicit
rule says so, the FOLLOW() of the top-level nonterminal always includes &quot;end of input.&quot;<P>

By contrast, the <I>&lt;name&gt;_action()</I> functions are stub functions, sufficient for yyleo.c to
compile cleanly. They should be fleshed out manually to provide the semantics of the language.<P>

The &quot;raw&quot; parser generated by leopurd sacrifices efficiency for clarity, so you may need to
hand-optimize the resulting code. One such inefficiency is duplicated code, such as the duplicated handling of
matches on '-' and '+' in <I>predicate_parse()</I> in <a href="9603c.htm#0104_005e">Listing Four</A>.
This problem could be solved in the grammar by defining a new nonterminal &quot;operator&quot; to match
either '+' or '-'. However, a new nonterminal costs a function call at run time, so manual optimization might
be preferable. Some grammars result in multiple recursive calls to the same function (&quot;tail
recursion&quot;). Such calls can be replaced with a loop, resulting in better performance and stack-space
savings. The first if statement in each parse function, which tests for matches on the FIRST() and FOLLOW()
sets, often can be eliminated completely.<P>

<h3><a name="0104_0052">Source Code<a name="0104_0052"></h3><P>

The complete C source code for the current version of leopurd is available electronically (see
&quot;Availability,&quot; page 3). LITE.H contains definitions common to all source files. It defines the
symbol LIST, resulting in visible run-time trace on <I>stdout</I>. For leopurd to run quietly, you must
undefine LIST. The scanner is found in LITE1.C. LITE2.C contains functions to parse the definition and user
sections. The rules section is parsed by functions in LITE3.C. LITE4.C contains functions that calculate
FIRST() and FOLLOW() sets and build the parser.<P>

Leopurd itself is constructed around several top-down parsers. The source code also shows ways to
implement the <I>next()</I>, <I>match()</I>, and <I>yyerror()</I> functions, as well as a simple scanner,
<I>yylex()</I>.<P>

The code generator in LITE5.C produces ANSI C output. It is relatively easy to modify to produce code for
other languages. <P>

The source code is ANSI C compliant, with the exception of calls to <I>strdup()</I>, a non-ANSI function
supported by many compilers. They can be replaced with calls to <I>malloc()</I>, <I>strlen()</I>, and
<I>strncpy()</I>. Leo-purd compiles cleanly using Borland C++ and Turbo C under MS-DOS, and on many
UNIX platforms.<P>

<h4><a name="0104_0053"><B>Example 1:</B> Definition section for a simple calculator.<a name="0104_0053"></h4><P>

<pre>%token NUMBER
%token '+' MINUS
%token '='
%%</pre>

<h4><a name="0104_0054"><B>Example 2:</B> Rules section for a simple calculator.<a name="0104_0054"></h4><P>

<pre>expression: sum '=' |
        difference '='
        ;
sum:    NUMBER '+' NUMBER |
        NUMBER '+' sum |
        EMPTY
        ;
difference:
        NUMBER MINUS NUMBER |
        NUMBER MINUS difference
        ;
%%</pre>

<h4><a name="0104_0055"><B>Example 3:</B> Code section for a simple calculator.<a name="0104_0055"></h4><P>

<pre>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
static int line_number=0;
/* print an error message */
void yyerror(char *msg_str){
    printf(&quot;Error! line %d: %s\n&quot;,
line_number,msg_str);
}
int main(){
    int rc;
    while(!(rc=yyparse()));
    exit(rc);
}</pre>

<h4><a name="0104_0056"><B>Example 4:</B> A recursive top-level production rule.<a name="0104_0056"></h4><P>

<pre> statement:
  while '(' expression ')' statement ;</pre>

<P>

<h4><a name="0104_0057"><a name="0104_0058">Listing One<a name="0104_0058"></h4><pre>
%token NO_TOKEN
%token EOI
%token NUMBER 
%token EMPTY
%%
statement:  expression '='
        ;
expression: factor predicate |
        EMPTY
        ;
predicate:  '+' factor predicate |
        '-' factor predicate |
        EMPTY
        ;
factor:     NUMBER |
        '(' expression ')'
        ;
%%
/***** user section *****/
#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;
#include &lt;string.h&gt;
int yylex(void);
#define INLEN 256
int look=NO_TOKEN;
static FILE *fp;
char *yytext=&quot;&quot;;
int yyleng;
/**** error function ****/
void yyerror(char *str){
    printf(&quot;Error! %s\n&quot;,str);
}
/**** look ahead to next token ****/
void next(void){
    look=yylex();
}
/**** match token ****/
int match(int token){
    if(look==NO_TOKEN)
        next();
    /**** uncomment to trace matches 
    printf(&quot;matching %d %d\n&quot;,look,token); /* */
    return token==look;
}
/**** keep parsing input until an error occurs ****/
int main(int argc,char *argv[]){
    int rc;
    if(argc==1) fp=stdin;
    else if(NULL==(fp=fopen(argv[1],&quot;rb&quot;)))
        return printf(&quot;File Error!\n&quot;);
    while(!(rc=yyparse()));
    printf(&quot;%s\n&quot;,(rc==2)?&quot;Success!&quot;:&quot;Error&quot;);
    return fclose(fp);
}
/**** this is the scanner function ****/
int yylex(void){
    static char inbuf[INLEN]={'\0'};
    static char *p=inbuf;
    do{
        /* need another line */
        if(!*p){
            if(!fgets(inbuf,INLEN,fp))
                return EOI;
            p=inbuf;
        }
        /* strip leading whitespace */
        while(isspace(*p)) p++;
    }while(!*p);
    yytext=p;
    yyleng=1;
    switch(*p++){
        case '+': return (int)'+';  /* single char operator ret. by value*/
        case '-': return (int)'-';
        case '*': return (int)'*';
        case '/': return (int)'/';
        case '(': return (int)'(';
        case ')': return (int)')';
        case '=': return (int) '=';
        default:
            if(isdigit(*yytext)){   /* a number */
                while(isdigit(*p)){
                    p++;
                    yyleng++;
                }
                return NUMBER;
            }
            else printf(&quot;Unknown token: %c!\n&quot;,*yytext);
    }
    return NO_TOKEN;
}
/*** end of user section ****/
</pre>
<h4><a name="0104_0059"><a name="0104_005a">Listing Two<a name="0104_005a"></h4><pre>
EMPTY 1003
NUMBER 1002
EOI 1001
NO_TOKEN 1000
predicate 1007
factor 1006
expression 1005
statement 1004
factor:
  '('  expression  ')'
  NUMBER
predicate:
  EMPTY
  '-'  factor  predicate
  '+'  factor  predicate
expression:
  EMPTY
  factor  predicate
statement:
  expression  '='
predicate: (nullable) 
FIRST(): '-' '+' 
FOLLOW(): ')' '=' 
factor: 
FIRST(): '(' NUMBER 
FOLLOW(): '-' '+' ')' '=' 
expression: (nullable) 
FIRST(): '(' NUMBER 
FOLLOW(): ')' '=' 
statement: 
FIRST(): '(' NUMBER '=' 
FOLLOW(): 
Top level non-terminal : statement
</pre>
<h4><a name="0104_005b"><a name="0104_005c">Listing Three<a name="0104_005c"></h4><pre>
#define YYSTYPE int
int match(int);
void next(void);
void yyerror(char *);
#define NO_TOKEN 1000
#define EOI 1001
#define NUMBER 1002
#define EMPTY 1003
#define statement 1004
#define expression 1005
#define factor 1006
#define predicate 1007
int predicate_parse(void);
int predicate_action(void);
int factor_parse(void);
int factor_action(void);
int expression_parse(void);
int expression_action(void);
#define statement_parse yyparse
int yyparse(void);
int yyparse_action(void);
</pre>
<h4><a name="0104_005d"><a name="0104_005e">Listing Four<a name="0104_005e"></h4><pre>
#include &quot;yyleo.h&quot;
#include &lt;stdlib.h&gt;
/***** user section *****/
#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;
#include &lt;string.h&gt;
int yylex(void);
#define INLEN 256
int look=NO_TOKEN;
static FILE *fp;
char *yytext=&quot;&quot;;
int yyleng;
/**** error function ****/
void yyerror(char *str){
    printf(&quot;Error! %s\n&quot;,str);
}
/**** look ahead to next token ****/
void next(void){
    look=yylex();
}
/**** match token ****/
int match(int token){
    if(look==NO_TOKEN)
        next();
    /**** uncomment to trace matches 
    printf(&quot;matching %d %d\n&quot;,look,token); /* */
    return token==look;
}
/**** keep parsing input until an error occurs ****/
int main(int argc,char *argv[]){
    int rc;
    if(argc==1) fp=stdin;
    else if(NULL==(fp=fopen(argv[1],&quot;rb&quot;)))
        return printf(&quot;File Error!\n&quot;);
    while(!(rc=yyparse()));
    printf(&quot;%s\n&quot;,(rc==2)?&quot;Success!&quot;:&quot;Error&quot;);
    return fclose(fp);
}
/**** this is the scanner function ****/
int yylex(void){
    static char inbuf[INLEN]={'\0'};
    static char *p=inbuf;
    do{
        /* need another line */
        if(!*p){
            if(!fgets(inbuf,INLEN,fp))
                return EOI;
            p=inbuf;
        }
        /* strip leading whitespace */
        while(isspace(*p)) p++;
    }while(!*p);
    yytext=p;
    yyleng=1;
    switch(*p++){
        case '+': return (int)'+';  /* single char operator ret. by value*/
        case '-': return (int)'-';
        case '*': return (int)'*';
        case '/': return (int)'/';
        case '(': return (int)'(';
        case ')': return (int)')';
        case '=': return (int) '=';
        default:
            if(isdigit(*yytext)){   /* a number */
                while(isdigit(*p)){
                    p++;
                    yyleng++;
                }
                return NUMBER;
            }
            else printf(&quot;Unknown token: %c!\n&quot;,*yytext);
    }
    return NO_TOKEN;
}
/*** end of user section ****/
int predicate_parse(void){
    if((!match('-'))&amp;&amp;(!match('+'))&amp;&amp;(!match(')'))&amp;&amp;(!match('='))){
        yyerror(&quot;predicate&quot;);
        exit(1);
    }
    else if(match('-')){
        next();
        if(factor_parse()){
            yyerror(&quot;factor&quot;);
            return 1;
        }
        if(predicate_parse()){
            yyerror(&quot;predicate&quot;);
            return 1;
        }
    }
    else if(match('+')){
        next();
        if(factor_parse()){
            yyerror(&quot;factor&quot;);
            return 1;
        }
        if(predicate_parse()){
            yyerror(&quot;predicate&quot;);
            return 1;
        }
    }
    else if(match(')')||match('=')){
        return 0;
    }
    else return 1;
    predicate_action();
    return 0;
}
int predicate_action(void){
    return 0;
}
int factor_parse(void){
    if((!match('('))&amp;&amp;(!match(NUMBER))){
        yyerror(&quot;factor&quot;);
        exit(1);
    }
    else if(match('(')){
        next();
        if(expression_parse()){
            yyerror(&quot;expression&quot;);
            return 1;
        }
        if(match(')'))
            next();
        else{
            yyerror(&quot;')'&quot;);
            return 1;
        }
    }
    else if(match(NUMBER)){
        next();
    }
    else return 1;
    factor_action();
    return 0;
}
int factor_action(void){
    return 0;
}
int expression_parse(void){
    if((!match('('))&amp;&amp;(!match(NUMBER))&amp;&amp;(!match(')'))&amp;&amp;(!match('='))){
        yyerror(&quot;expression&quot;);
        exit(1);
    }
    else if(match('(')||match(NUMBER)){
        if(factor_parse()){
            yyerror(&quot;factor&quot;);
            return 1;
        }
        if(predicate_parse()){
            yyerror(&quot;predicate&quot;);
            return 1;
        }
    }
    else if(match(')')||match('=')){
        return 0;
    }
    else return 1;
    expression_action();
    return 0;
}
int expression_action(void){
    return 0;
}
int yyparse(void){
    if((!match('('))&amp;&amp;(!match(NUMBER))&amp;&amp;(!match('='))&amp;&amp;(!match(EOI))){
        yyerror(&quot;statement&quot;);
        exit(1);
    }
    else if(match(EOI)){
        return 2;
    }
    else if(match('(')||match(NUMBER)||match(')')||match('=')){
        if(expression_parse()){
            yyerror(&quot;expression&quot;);
            return 1;
        }
        if(match('='))
            next();
        else{
            yyerror(&quot;'='&quot;);
            return 1;
        }
    }
    else return 1;
    yyparse_action();
    return 0;
}
int yyparse_action(void){
    return 0;
}
</pre>
<P>

<P>

<P>

<P>

<P>

<P>

<P>

<P>

<P>

<P>

</BODY></HTML>
