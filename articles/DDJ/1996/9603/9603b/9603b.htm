<HTML>
<META NAME="year" CONTENT="1996">
<HEAD>
<!-- This document was built using HyperWriter Professional by NTERGAID Inc. -->
<TITLE>MAR96: Dylan's Creole Interface</TITLE></HEAD>
<body bgcolor="FFFFFF">
<h1>Dylan's Creole Interface<a name="0102_004a"><a name="0102_004a"><a name="0102_0048"><a name="0102_0000"></h1><P>

<h2>Interfacing a little language to a big database</h2><P>

<h3>Edward Cessna</h3><P>

<P>
<i><a name="0102_0049"><a name="0102_0000">Ed, a senior software engineer with the Harlequin
Group, can be contacted at eec@harlequin.com.</i></p><hr><P>

Dylan is an object-oriented dynamic language originally developed by Apple Computer, with input from
Harlequin and Carnegie Mellon University. From the outset, the Dylan language design has been in the public
domain. But because the term &quot;Dylan&quot; is trademarked, anyone implementing the language must
obtain Apple's permission to use the name. Several organizations have announced commercial-quality Dylan
releases, including Harlequin's forthcoming DylanWorks, a dynamic development environment and native
compiler that produces fast, compact executables. DylanWorks will initially be released for Windows 95 and
Windows NT, and provides full interoperability with OLE and Win32 functionality.<P>

Likewise, Carnegie Mellon University is developing an integrated Dylan development environment for UNIX
called &quot;Gwydion.&quot; This is on the heels of &quot;Mindy,&quot; a byte-code compiler for UNIX,
Mac, OS/2, and Windows. Other experimental Dylan implementations include Marlais, an experimental
Dylan interpreter written in C for UNIX, Macintosh, and Windows; and Thomas, a Dylan interpreter written
in Scheme. The current version of Apple's implementation, Apple Dylan, is an integrated development
environment for the Macintosh available as a &quot;technology release.&quot; The environment generates
stand-alone applications and libraries for 68K Macs, native PowerPC, and fat binaries. The environment is
not PowerPC native, and runs emulated on PowerPCs.<P>

The Dylan programming environment includes Creole, a foreign-function interface that allows Dylan
programs to call routines written in other languages--and routines in another language to call Dylan
routines. The Creole specification (designed by David Moon), which is also in the public domain, is the basis
for the foreign-function interface used in Apple Dylan, DylanWorks, and Gwydion. Creole provides access to
the Macintosh toolbox and third-party libraries needed to develop an application or application component
for the Macintosh. In this article, I'll describe how to interface the prealpha version of Dylan with Version
4.02 of the Sybase RDBMS library. There are no technical reasons for my choosing the Sybase RDBMS; I
simply have access to it. Mileage and integration steps may vary depending on the version of Sybase or
implementation of Dylan or Creole.<P>

Two Dylan concepts--generic functions and methods--are considered functions (C++, on the other hand, has
many--operators, virtual, overloaded, member functions, and the like). A generic function is polymorphic
and consists of a set of zero or more methods that define its behavior. When a generic function is called, it
picks one of its methods (according to argument type) and applies this method to the arguments passed to
the generic function. This is more efficient than it sounds because Dylan optimizes function calls. Methods
are specialized functions that work on just one set of argument types. This triad is a simple class
hierarchy: <I>&lt;</I><I>function&gt;</I> is the base class for both
<I>&lt;</I><I>generic-function&gt;</I> and <I>&lt;method&gt;</I>.<P>

<h3><a name="0102_004b">Creole Overview<a name="0102_004b"></h3><P>

Creole is neither a separate application nor a mode of Apple Dylan. It can be viewed as an extension to the
Dylan language that adds a statement, <I>define interface</I>, which describes the interface to C functions,
structures, unions, global variables, and macros. Creole also adds classes, functions, and macros to
support the interaction between Dylan and C code. For Creole to perform this, it has five primary concepts
at the language level: interface importation, access paths, cross-language calls, name mapping, and type
mapping. <P>

Interface importation involves importing a C header file. Creole imports declarations for functions,
variables, types, constants, structures, and unions. The fields of a structure and union are variables to
Creole. C macros are functions if the macro accepts parameters; otherwise they are constants. Creole
maps C variables and structures and <I>union</I> fields into Dylan <I>getter</I> and <I>setter</I> function
pairs. These pairs act as an interface for a variable or &quot;slot&quot; (similar to a C++ class member
variable).<P>

A <I>define interface</I> statement, which imports a header file, has a number of options that control
Creole's default importation behavior. These options allow selective importing of declarations within a C
header file, explicit type-mapping control, and explicit name mapping to avoid name conflicts.<P>

For each imported item, Creole creates a corresponding object or function. Each imported structure or
union becomes a class and the fields of the structure or union become slots with corresponding
<I>getter</I> and <I>setter</I> functions. Each imported C function becomes a Dylan method with a
parameter list that corresponds to the C- function parameter list. The parameter types for the Dylan
method can be controlled by Creole's type-mapping support.<P>

If one header file includes another, Creole does not import the declarations within the second header. A
separate <I>#include</I> clause or <I>define interface</I> statement can be used to import this second
header file.<P>

An access path is a mechanism that loads C functions into memory, making the functions' addresses known
to the Dylan program. Creole supports four high-level access paths: inline machine code, external module,
and two shared libraries--Apple's Shared Library Manager (ASLM) and Code Fragment Manager (CFM). In
addition, there are two low-level access paths called &quot;direct pointer&quot; and &quot;PowerPC
transition vectors.&quot; The inline machine-code access path is for accessing the toolbox and
operating-system traps. The Sybase library is an MPW C object library. The only access path available to C
object libraries (if the source code is not available) is the external module path. MPW is required to use this
access path.<P>

A Dylan routine can call C functions (or vice versa). Creole records the calling sequence, argument, and
result type during importation of a function declaration. Creole creates a corresponding Dylan function that,
when invoked, calls the C function, translates arguments and results, and manages the differences between
the two languages' run-time environments. Type mapping controls the translation of the arguments and
results between languages.<P>

Name conflicts can occur because of differences between C and Dylan. Structures and unions within C have
local scope; Dylan has no corresponding feature. C is case sensitive, Dylan is not. Creole has a set of
name-translation rules that maps a specific set of C naming conventions into Dylan naming conventions. <P>

Type mapping translates a type in the imported interface to a Dylan class. Type mapping applies to
cross-language call arguments, cross-language call results, imported variables, and fields of imported
structure and union types. Every C type is mapped to a Dylan type.<P>

To understand how Creole does type mapping, you must understand the type categories that Creole uses.
These categories are statically typed pointers, untyped pointers, and by-value types. Statically typed
pointers are pointers to objects with a type that cannot be determined at run time. Examples of this are
pointers to C <I>struc</I><I>t</I>s. The type of such a pointer is declared statically in the interface. The
run-time object does not contain any type information.<P>

Untyped pointers do not point to an object. An example in C is <I>void</I><I>*</I> (and char<I>*</I> in old
C code). All untyped pointers are mapped to an instance of <I>&lt;machine-pointer&gt;</I>. The C type
information is not retained.<P>

Examples of by-value types are <I>number</I>, <I>character</I>, <I>string</I>, and <I>Boolean</I>.<P>

<h3><a name="0102_004c">The Application Nub<a name="0102_004c"></h3><P>

A unique aspect of Apple Dylan is the strong separation between the development environment and the
application. The development tools are all part of the environment, whereas the code under development is
executed within the Application Nub--essentially an empty Dylan application. The environment downloads
code and data into the Application Nub via Apple Events. The use of Apple Events allows you to run the
environment and Application Nub on separate machines.<P>

With other dynamic programming languages (Lisp and Smalltalk, for instance), it is nearly impossible to
separate the application from the development environment. That's why applications developed in these
languages have large disk and RAM footprints. Apps developed in Dylan have footprints comparable to those
in C++.<P>

<h3><a name="0102_004d">Dylan Meets Sybase<a name="0102_004d"></h3><P>

The basic procedure for integrating the Sybase library (or any other C library) into a Dylan program is to
import the header files and statically link the library into the Application Nub. Supposedly, that's all there
is to it. Nothing is this easy, however. In C, you can write ambiguous declarations of variables and
functions--and that's a problem for Dylan. More specifically, Sybase's header files, like some UNIX header
files, are full of ambiguous declarations. <P>

If you are accessing a shared library (ASLM or CFM), you do not have to rebuild the Application Nub. You
simply install the shared library into the system and start calling the desired routines from the listener or
your Dylan code.<P>

Creole requires that imported header files should be mutually independent: One header file should not
require another header file to be included prior in order to work properly. All supporting declarations must
be defined either within the imported header file or within another header included in the imported header
file.<P>

Unfortunately, Sybase commits a first-order violation of this rule; most of Sybase's header files must be
preceded by sybfront.h. The simple way around this (until Creole has direct support for dependent headers)
is to modify the Sybase files to explicitly include sybfront.h. Fortunately, Macintosh header files and
standard C library header files are mutually independent. For example, the Macintosh header file
Quickdraw.h depends upon the files types.h and QuickdrawText.h, and if you look in Quickdraw.h, you'll see
that these files are explicitly included.<P>

Before creating your first <I>define interface</I> statement, Sybase's header files (sybfront.h, syblogin.h,
sybdb.h, sybtoken.h, and sybfront.h) must be copied to the project folder. First, create a new module and
name it &quot;sybase-dbms&quot;. To import the entire contents of sybdb.h, create a source record in the
module <I>sybase-dbms</I> with the <I>define interface</I> statement in <a href="9603b.htm#0102_0054">Example 1(a)</A>. When you compile this statement, there will be
warnings like <a href="9603b.htm#0102_0054">Example 1(b)</A> since this <I>define interface</I>
statement is a little simplistic. <P>

Sybase uses the pattern of <a href="9603b.htm#0102_0055">Example 2(a)</A> for most structure
definitions. Since Dylan is case insensitive, both <I>dbprocess</I> and DBPROCESS are mapped to the same
Dylan object, <I>&lt;dbprocess&gt;</I>. As any C programmer knows, <I>typedef DBPROCESS</I> is
essentially a name for <I>struct dbprocess</I>; hence, both <I>dbprocess</I> and DBPROCESS represent the
same object. Therefore, you need to import only one of them. <a href="9603b.htm#0102_0055">Example 2(b)</A> shows what happens when you implicitly import
<I>dbprocess</I>. Issuing the compile command generates the error in <a href="9603b.htm#0102_0055">Example 2(c)</A>.<P>

The define statement in <a href="9603b.htm#0102_0055">Example 2(b)</A> is explicitly telling Creole
just to import the declaration of <I>dbprocess</I>. However, Creole does not know the data types--except
built-in data types--of the fields that comprise <I>dbprocess</I>. For example, <I>dbfile</I>, the first field
of <I>dbprocess</I>, is typed <I>struct servbuf</I><I>*</I> and Creole does not know what a
<I>servbuf</I> is. The structure definition for <I>dbprocess</I> has a number of fields, most of which are
immaterial. Using Creole's <I>struct</I> clause, you can explicitly import only those fields that you have an
interest in. For now, you will not import any fields; see <a href="9603b.htm#0102_0055">Example
2(d)</A>. Another compile yields no error or warning message. Creole has created a class by the name
<I>&lt;dbprocess&gt;</I>. If you type <I>&lt;dbprocess&gt;</I> in the listener, Dylan will respond with
<I>#&lt;the class sybase-dbms<img src="dot12.gif">dbprocess&gt;&gt;</I>. This object (classes are objects) can then be
inspected by selecting the Inspect Listener Result menu item from the Debug menu.<P>

<h3><a name="0102_004e">Sybase from the Listener<a name="0102_004e"></h3><P>

C functions linked into the Application Nub can be invoked directly from the listener and send their results
back to the listener--a portal into the run time. Dylan expressions can be entered into the listener: They
will be compiled, downloaded, and executed within the run time. Values returned by the execution of the
entered expression will be printed in the listener.<P>

To illustrate, I'll import types, functions, and macro definitions necessary to invoke the basic Sybase
functions from the listener. Once everything is imported, I will initialize Sybase's db-library, create and
initialize a login record, create and open a connection to a database process on the server, close a database
connection, and exit (cleanup) db-library from the listener.<P>

The first function to import is <I>dbinit</I>, which initializes the Sybase library and has the prototype
<I>RETCODE dbinit(void)</I>, where RETCODE is <I>typede</I><I>f</I>ed as an <I>int</I>. <a href="9603b.htm#0102_0056">Example 3(a)</A> is the corresponding <I>define interface</I> statement.
Compiling this generates the warning message in <a href="9603b.htm#0102_0056">Example
3(b)</A>. Creole is saying that the declaration for the <I>dbinit</I> function has been imported, but it has
no idea where the object code of the function is. For now, you will specify the location of the function using
the <I>external-module</I> clause, which specifies the access path; see <a href="9603b.htm#0102_0056">Example 3(c)</A>.<P>

The next function to import is <I>dblogin</I>, which creates a login record for use in <I>dbopen</I> and has
the prototype <I>LOGINREC</I><I>*</I><I> dblogin(void)</I>. Since LOGINREC has not been imported, it goes
on to the import list. In LOGINREC, defined in syblogin.h, the macros DBSETLHOST, DBSETLUSER,
DBSETLPWD, and DBSETLAPP set the host name, user name, user password, and application name fields,
respectively.<P>

Examining the LOGINREC macros reveals the fields that must be imported: <I>lhostname</I>,
<I>lhostnlen</I>, <I>lusername</I>, <I>lusernlen</I>, <I>lpw</I>, <I>lpwnlen</I>, <I>lhostproc</I>,
<I>lhplen</I>, <I>lappname</I>, <I>lappnlen</I>, <I>lservname</I>, <I>lservnlen</I>, <I>lprogname</I>, and
<I>lprognlen</I>.<P>

The declarations of the various character fields (for example, <I>char lhostname[MAXNAME</I><I>]</I>)
depend upon the size specifier MAXNAME, where MAXNAME is a <I>#define</I> constant defined in sybdb.h.
Note that MAXNAME is defined in sybdb.h but is needed in syblogin.h, where LOGINREC is defined--syblogin.h
does not include sybdb.h. This creates another dependency between header files: syblogin.h requires sybdb.h
to be previously included. To handle this dependency, you can hard-code the constant in either syblogin.h or
through the <I>define</I> clause for the <I>#include</I> statement (for example, <I>#include
&quot;syblogin.h&quot;, define: {&quot;MAXNAME&quot; =&gt; 3</I><I>0</I><I>}</I>).<P>

You now need to import both the macros that set the fields of a LOGINREC and the function
<I>dbsetlname</I>, which these macros call. Creole creates inline functions for these macros.
<I>dbsetlname</I> has the prototype <I>RETCODE dbsetlname(LOGINREC</I><I>* </I><I>lptr,
char</I><I>*</I><I> name, int type)</I>. The second parameter, <I>name</I>, could cause a run-time
problem if you try to pass a string as the second argument. <I>name</I> has a C type of
<I>char</I><I>*</I>, but Creole treats it as an untyped pointer. C programmers know that <I>name</I> is
probably a null-terminated string, but it could also be a pointer to a single character or to an array of
characters. There is no way for Creole (or even the C compiler) to determine the complete data type of this
argument. The behavior of the program determines the semantics of name.<P>

You can avoid these problems if header files are structured properly. Pointer types (that is,
<I>cha</I><I>r</I><I>*</I>) should be <I>typed</I><I>e</I><I>f</I>ed and these <I>typedef</I>s should be
used in place of the pointer types. If you defined a <I>typedef</I> for <I>SybString (typedef
char</I><I>*</I><I> SybString;)</I> in the Sybase header files and replaced all references to
<I>char</I><I>*</I> with <I>SybString</I>, you would only have to tell Creole once that a <I>SybString</I>
maps to a <I>&lt;c-string&gt;</I>. A good example of this is <I>StringPtr</I> and <I>StringHandle</I>
defined in types.h.<P>

When Creole reads the declaration for <I>dbsetlname</I>, it creates the function <I>dbset-lname(lptr ::
&lt;LOGINREC&gt;, name :: &lt;machine-pointer&gt;, type :: &lt;integer&gt;) =&gt; return-code ::
&lt;integer&gt;</I>. If you passed a string for the <I>name</I> argument within a <I>dbsetlname</I> call,
you would get a type mismatch: A string, typed <I>&lt;c-string&gt;</I> is not a
<I>&lt;machine-pointer&gt;</I>. You need to explicitly define the type for <I>name</I> via the
<I>function</I> clause of the <I>define interface</I> statement.<P>

<a href="9603b.htm#0102_005b">Listing One</A> presents two <I>define interface</I> statements: one
for sybdb.h and one for syblogin.h. Next, the <I>dbopen</I> function is imported, which creates a database
process on the server and opens a connection to the process. The prototype for this function is
<I>DBPROCESS</I><I>*</I><I> dbopen(LOGINREC</I><I>*</I><I> password, char</I><I>*</I><I>
servername)</I>. There is nothing new to import, other than the function name. <I>dbopen</I> has the same
problem as <I>dbsetlnam</I><I>e</I>: the argument <I>servername</I> is an untyped pointer and a program
needs to pass it a string. Using the function clause solves this.<P>

The last functions to import are <I>dbclose</I> and <I>dbexit</I>. <I>dbclose</I> has the prototype <I>void
dbclose(DBPROCESS</I><I>*</I><I> dbproc)</I>, and <I>dbexit</I> has the prototype <I>void
dbexit(void)</I>. With both functions, the only symbols you need to import are the function names. <a href="9603b.htm#0102_005d">Listing Two</A> thus becomes the <I>define interface</I> statement for
sybdb.h.<P>

<h3><a name="0102_004f">Building the Application Nub<a name="0102_004f"></h3><P>

In rebuilding the Application Nub using the external access path, you create a source record that calls the
<I>write-external-modules</I> function. When compiled, this function generates an assembly file that
contains the definition of the external modules. The name of the generated file is the name passed to this
function; <I>external-modules.a</I> would suffice.<P>

The first step to building the new Application Nub is to bring up the project from within Dylan and
compile--without connecting to the Application Nub--each of the <I>define interface</I> statements then
compile the <I>write-external-modules</I> function call. If you try to compile the <I>define interface</I>
statements while connected to the standard Application Nub, Apple Dylan will complain that it cannot find
your external modules, since the standard Application Nub does not have the Sybase code linked in. After
you make a custom Application Nub that includes both the Sybase code and the external module that makes it
accessible to Dylan, this problem will disappear.<P>

Once the external modules file has been generated, you need to modify the makefile (supplied with Apple
Dylan) for the Application Nub to include the Sybase library (libsybdb.o). Next, launch MPW (Version 3.3 or
later), build the Application Nub, and move the custom Application Nub to your project folder. <P>

Before connecting to the new Application Nub, copy (or make an alias of) the Apple Dylan file Kernel.dl to
your Extensions folder or to your project folder. Now you can go back into Apple Dylan and connect to the
Application Nub. In the prealpha version of Apple Dylan, the Application Nub must be named
&quot;Application Nub.&quot; Apple Dylan looks for this file by name.<P>

After the needed functions and types have been imported and the Application Nub has been rebuilt with the
Sybase library, Sybase calls can be made by hand (from the listener). Before typing into the listener, set
the module to <I>sybase dbms</I>; see <a href="9603b.htm#0102_0057">Example 4</A>.<P>

<h3><a name="0102_0050">Sybase Error and Message Handlers<a name="0102_0050"></h3><P>

Before importing functions to do queries, you can optionally install error and message handlers for Sybase
to invoke. If handlers are not installed, Sybase will write error messages to the console (generally
considered a bad practice for a commercial app) and exit.<P>

Installing the error and message handler is straightforward using <I>dberrhandle</I> and
<I>dbmsghandle</I>. Importing these functions is another story, starting with how <I>dberrhandle</I> and
<I>dbmsghandle</I> are declared. In the Sybase file sybdb.h, <I>dberr-handle</I> is declared as <I>int
(</I><I>*</I><I>dberrhandle(int (</I><I>*</I><I>handler)()))();</I>. <I>dbmsghandle</I> has a similar
declaration problem.<P>

Creole can't handle this declaration because the type information for the parameters of the function the
handler points to is insufficient. You must therefore create a header file with an enhanced declaration of
<I>dberrhandle</I> and <I>dbmsghandle</I>, plus a separate <I>define interface</I> statement that imports
their definitions. You could modify the header files directly, but it is probably better not to modify a
third-party header file. <a href="9603b.htm#0102_005f">Listing Three</A> shows the sybfix.h
<I>include</I> file. In <a href="9603b.htm#0102_0061">Listing Four</A>, the corresponding
<I>define interface</I> statement adds <I>callback</I>, a new clause that defines a Dylan macro. When
invoked, the macro creates a C-callable function, or &quot;alien method,&quot; which obeys C-calling
sequences and can be passed to a C program. The <I>callback</I> clause's argument-type allows explicit
typing of an ambiguous argument. The fifth, sixth, and seventh arguments of the <I>msgHandler </I>callback
macro are declared as pointers to a <I>char</I><I>*</I>. Dylan does not know that these arguments are
strings and, without the argument typing, sees them as untyped pointers.<P>

To install the callbacks, you can create the handlers as normal Dylan methods and assign the results of the
callback macros to a variable that is then passed to <I>dberrhandle</I> or <I>dbmsghandle</I>.<P>

The message handler takes arguments whose data type match the declaration in the sybfix.h file. There is
nothing elegant about this message handler--it prints the value of the various parameters to the listener.
The release of Dylan I'm using doesn't support printing to the listener, so I use the warning-signaling
mechanism. The <I>signal</I> method is a Dylan version of <I>printf</I> that takes an arbitrary number of
arguments, where the first argument is the format string that controls the printing of the remaining
arguments. Since <I>signal</I> is part of the signaling mechanism, it prints the word &quot;warning&quot;
before the formatted string; see <a href="9603b.htm#0102_0063">Listing Five</A>. sybfront.h must be
imported before the message handler can be compiled without warnings. This method uses the constant
<I>$int_continue</I> defined in this header file. This and other constants can be imported using the <I>define
interface</I> statement in <a href="9603b.htm#0102_0065">Listing Six</A>.<P>

You can create the <I>callback</I> routine once the message handler is defined. The use of the callback
macro seems strange because the Dylan macro system is incomplete; macro use may change once the
system is finalized. <a href="9603b.htm#0102_0067">Listing Seven</A> sets up an alien-callable alien
method that calls the message handler. The error-handler function and <I>ErrHandler</I> callback are
performed similarly; see <a href="9603b.htm#0102_0069">Listing Eight</A>.<P>

<h3><a name="0102_0051">Querying Sybase<a name="0102_0051"></h3><P>

The next step is to query the database. <a href="9603b.htm#0102_006b">Listing Nine</A> lists the
function declarations that must be imported to issue a query to Sybase. <I>dbcmd</I> needs a function
clause: The second argument has a C type of <I>char</I><I>*</I>. <I>dbbind</I> does not need a function
clause to augment the type information for <I>destvar</I>; you will be passing an untyped-pointer
argument.<P>

To import the constants NO_MORE_RESULTS, NO_MORE_ROWS, NTBSTRINGBIND, DBNOERR, and INTBIND,
take <a href="9603b.htm#0102_006d">Listing Ten</A> as the final <I>define interface</I> statement. I'll
query against a sample table of viruses and mortality rates. The mortality rates in <a href="9603b.htm#0102_0059">Table 1</A> were distilled from <I>The Cambridge World History of
Human Disease</I>. I took liberties in summarizing the mortality rates for each virus. In some cases, the
rates were presented in terms of a range; in others, the rates were presented for hospitalization or no
care. If there were more than one number, I took the lower one. This gives everything needed to write a
program (or a method) that queries the database and returns. The <I>oh-oh</I> method connects to the
fictitious morbidity database on server &quot;Oahu&quot; as user &quot;virologist&quot; with password
&quot;Aiea.&quot; Once the connection has been established, <I>oh-oh</I> issues a query to the database
asking for a list of viruses where the mortality rate is greater than 50 percent. <a href="9603b.htm#0102_006f">Listing Eleven</A> shows the results of this query, which are
displayed in the listener using the <I>signal</I> facility. To run <I>oh-oh</I>, invoke it from the listener. <a href="9603b.htm#0102_0058">Example 5</A> shows how this method runs.<P>

<h3><a name="0102_0052">Conclusion<a name="0102_0052"></h3><P>

For more information on Dylan and Creole, refer to Dylan Interim Reference Manual available at
cambridge.apple.com via ftp or on the Dylan Web page located at http://www.cambridge.apple.com.<P>

<h3><a name="0102_0053">For More Information<a name="0102_0053"></h3><P>

Apple Computer<P>

1 Infinite Loop <P>

Cupertino, CA 95014 <P>

http://www.apple.com<P>

<P>

Harlequin Inc.<P>

1 Cambridge Center<P>

Cambridge, MA 02142<P>

http://www.harlequin.com<P>

<P>

Carnegie-Mellon University<P>

5000 Forbes Avenue<P>

Pittsburgh, PA 15213<P>

http://cmu.edu<P>

<h4><a name="0102_0054"><B>Example 1:</B> (a) Using the define interface statement to import the
contents of sybdb.h; (b) compiling the statement in (a) generates this message.<a name="0102_0054"></h4><P>

<pre>(a)
define interface<P>
#include &quot;sybdb.h&quot;<P>
end interface;

(b)
Warning in a Creole interface: &quot;dbprocess&quot; and &quot;DBPROCESS&quot; both map to Dylan variable &lt;dbprocess&gt;; one will be lost.</pre>

<h4><a name="0102_0055"><B>Example 2:</B> (a) Typical Sybase structure definition; (b) implicitly importing dbprocess; (c) Error message generated when compiling (b); (d) using Creole's struct clause.<a name="0102_0055"></h4><P>

<pre>(a)
struct dbprocess<P>
{<P>
   &lt;wonderful field declarations removed&gt;<P>
};<P>
typedef struct dbprocess DBPROCESS;

(b)
define interface<P>
   #include &quot;sybdb.h&quot;,<P>
   import: {&quot;dbprocess&quot;};<P>
end interface;

(c)
Fatal Error in a Creole interface: No type mapping known for &quot;struct servbuf*&quot;. Cannot import variable &quot;dbprocess::dbfile&quot; because there is no type mapping from &quot;struct servbuf*&quot; to a Dylan class. You should use define interface to import the file or use type: {&quot;struct servbuf*&quot; =&gt; your-class} to add an explicit type mapping.

(d)
define interface<P>
   #include &quot;sybdb.h&quot;,<P>
   import: {&quot;dbprocess&quot;};<P>
   struct &quot;dbprocess&quot;, import: {};<P>
end interface;</pre>

<h4><a name="0102_0056"><B>Example 3:</B> (a) The define interface statement that initializes the Sybase library; (b) compiling generates this message; (c) specifying the location of the function using the external-module clause.<a name="0102_0056"></h4><P>

<pre>(a)
define interface<P>
   #include &quot;sybdb.h&quot;, import: {&quot;dbinit&quot;, &quot;dbprocess&quot;};<P>
   struct &quot;dbprocess&quot;, import: {};<P>
end interface;

(b)
Warning in a Creole interface: No access path to &quot;dbinit&quot; exists. On the 68k we can only call things via inline machine code or one of the access paths to external object code, which are External Modules, the Code Fragment Manager, and the Apple Shared Library Manager. This means that there is no way to call &quot;dbinit&quot;. An attempted call will signal an error at runtime.

(c)
define interface<P>
   #include &quot;sybdb.h&quot;,<P>
      import: {&quot;dbinit&quot;, &quot;dbprocess&quot;},<P>
      external-module: syb-externals;<P>
   struct &quot;dbprocess&quot;, import: {};<P>
end interface;</pre>

<h4><a name="0102_0057"><B>Example 4:</B> Setting the module to sybase dbms before using the listener (boldface denotes user input).<a name="0102_0057"></h4><P>

<pre>Welcome to Apple Dylan!
Dylan&gt; <B>dbinit()</B>
1
Dylan&gt; <B>define variable login = dblogin()</B>
define login
Dylan&gt; <B>dbsetlhost(login, &quot;Oahu&quot;)</B>
1
Dylan&gt; <B>dbsetluser(login, &quot;tourist&quot;)</B>
1
Dylan&gt; <B>dbsetlpwd(login, &quot;Aiea&quot;)</B>
1
Dylan&gt; <B>dbsetlapp(login, &quot;example1&quot;)</B>
1
Dylan&gt; <B>define variable dbproc = dbopen(login, &quot;db&quot;)</B>
define dbproc
Dylan&gt; <B>dbproc</B>
#&lt;Dylan-User%&lt;dbprocess&gt; at: #x019FE7C0&gt;
Dylan&gt; <B>dbclose(dbproc)</B>
Dylan&gt; <B>dbexit()</B>
Dylan&gt;</pre>

<h4><a name="0102_0058"><B>Example 5:</B> Running the sample method (boldface denotes user input).<a name="0102_0058"></h4><P>

<pre>Welcome to Apple Dylan!
Dylan&gt; <B>oh-oh()</B>
Warning: Ebola Zaire 90
Warning: Ebola Sudan 52
Warning: Bubonic Plague 51
#f</pre>

<h4><a name="0102_0059"><B>Table 1:</B> Sample mortality rates from The Cambridge World History of Human Disease. <a name="0102_0059"></h4><P>

<pre>
Virus                           Mortality

Yellow Fever                    20

Typhoid Fever                   10

Smallpox Variola Major          25

Smallpox Variola Minor          1

Rocky Mtn. Spotted Fever        20

Relapsing Fever                 5

Marburg Fever                   NULL

Leptospirosis                   5

Legionnaires' Disease           15

Lassa Fever                     16

Influenza                       1

Ebola Sudan                     52

Ebola Zaire                     90
 
Bubonic Plague                  51

</pre>

<P>

<h4><a name="0102_005a"><a name="0102_005b">Listing One<a name="0102_005b"></h4><pre>
define interface
    #include &quot;sybdb.h&quot;,
        import:
            {&quot;dbinit&quot;, &quot;dbprocess&quot;, &quot;dbsetlname&quot;,
                // Parameterized Macros
                &quot;DBSETLHOST&quot;, &quot;DBSETLUSER&quot;, &quot;DBSETLPWD&quot;, &quot;DBSETLAPP&quot;,
                // Constant Macros
                &quot;MAXNAME&quot;},
        external-module: syb-externals;
    struct &quot;dbprocess&quot;, import: {};
    function &quot;dbsetlname&quot;,
        argument-type: {name =&gt; &lt;c-string&gt;};
end interface;
define interface
    #include &quot;syblogin.h&quot;,
        define: {&quot;MAXNAME&quot; =&gt; 30},
        import: {&quot;loginrec&quot;};
    struct &quot;loginrec&quot;,
        import:
            {&quot;lhostname&quot;, &quot;lhostnlen&quot;,
                &quot;lusername&quot;, &quot;lusernlen&quot;,
                &quot;lpw&quot;, &quot;lpwnlen&quot;,
                &quot;lhostproc&quot;, &quot;lhplen&quot;,
                &quot;lappname&quot;, &quot;lappnlen&quot;,
                &quot;lservname&quot;, &quot;lservnlen&quot;,
                &quot;lprogname&quot;, &quot;lprognlen&quot;};
end interface;
</pre>
<h4><a name="0102_005c"><a name="0102_005d">Listing Two<a name="0102_005d"></h4><pre>
define interface
    #include &quot;sybdb.h&quot;,
        import:
            {&quot;dbinit&quot;,
                &quot;dbprocess&quot;, &quot;dblogin&quot;, &quot;dbopen&quot;,
                &quot;dbclose&quot;, &quot;dbexit&quot;, &quot;dbsetlname&quot;,
                // Parameterized Macros
                &quot;DBSETLHOST&quot;, &quot;DBSETLUSER&quot;, &quot;DBSETLPWD&quot;, &quot;DBSETLAPP&quot;,
                // Constant Macros
                &quot;MAXNAME&quot;},
            external-module: syb-externals;
    struct &quot;dbprocess&quot;, import: {};
    function &quot;dbopen&quot;,
        argument-type: {servername =&gt; &lt;c-string&gt;};
    function &quot;dbsetlname&quot;,
        argument-type: {name =&gt; &lt;c-string&gt;};
end interface;
</pre>
<h4><a name="0102_005e"><a name="0102_005f">Listing Three<a name="0102_005f"></h4><pre>
#include &quot;sybfront.h&quot;
#include &quot;sybdb.h&quot;
typedef int (*ErrHandler)(DBPROCESS* dbproc, int severity, int dberr, 
                                  int oserr, char* dberrstr, char* oserrstr);
ErrHandler  dberrhandle(ErrHandler handler);
typedef int  (*MsgHandler)(DBPROCESS* dbproc, int msgno, int msgstate, 
                                  int severity, char* msgtext, char* srvname, 
                                  char* procname, unsigned short line);
MsgHandler  dbmsghandle(MsgHandler handler);
</pre>
<h4><a name="0102_0060"><a name="0102_0061">Listing Four<a name="0102_0061"></h4><pre>
define interface
    #include &quot;sybfix.h&quot;,
        import:
            {&quot;dberrhandle&quot;, &quot;dbmsghandle&quot;, &quot;ErrHandler&quot;,
                &quot;MsgHandler&quot;},
            external-module: syb-fix-externals;
            callback &quot;ErrHandler&quot;,
                argument-type: {5 =&gt; &lt;c-string&gt;},
                argument-type: {6 =&gt; &lt;c-string&gt;};
            callback &quot;MsgHandler&quot;,
                argument-type: {5 =&gt; &lt;c-string&gt;},
                argument-type: {6 =&gt; &lt;c-string&gt;},
                argument-type: {7 =&gt; &lt;c-string&gt;};
end interface;
</pre>
<h4><a name="0102_0062"><a name="0102_0063">Listing Five<a name="0102_0063"></h4><pre>
define method message-handler(dbproc :: &lt;dbprocess&gt;,
                              msgno :: &lt;integer&gt;,
                              msgstate :: &lt;integer&gt;,
                              severity :: &lt;integer&gt;,
                              msgtext :: &lt;c-string&gt;,
                              srvname :: &lt;c-string&gt;,
                              procname :: &lt;c-string&gt;,
                              line :: &lt;integer&gt;)
=&gt; action :: &lt;integer&gt;;
    ignore(dbproc);
    signal(&quot;~&Msg ~d, Level ~d, State ~d&quot;, msgno,
        severity, msgstate);
    if (size(srvname) &gt; 0)
        signal(&quot;Server '~a', &quot;, srvname);
    end if;
    if (size(procname) &gt; 0)
        signal(&quot;Procedure '~a', &quot;, procname);
    end if;
    if (line &gt; 0)
        signal(&quot;Line ~d&quot;, line);
    end if;
    signal(&quot;~&~a&quot;, msgtext);
    $int_continue;
end method;
</pre>
<h4><a name="0102_0064"><a name="0102_0065">Listing Six<a name="0102_0065"></h4><pre>
define interface
    #include &quot;sybfront.h&quot;,
        import:
            {&quot;INT_EXIT&quot;, &quot;INT_CONTINUE&quot;, &quot;INT_CANCEL&quot;, &quot;SUCCEED&quot;, &quot;FAIL&quot;};
end interface;
</pre>
<h4><a name="0102_0066"><a name="0102_0067">Listing Seven<a name="0102_0067"></h4><pre>
define variable message-handler-proc =
MsgHandler(dbproc(msgno, msgstate, severity, msgtext, srvname, 
                    procname, line), message-handler(dbproc, msgno, msgstate, 
                    severity, msgtext, srvname, procname, line));
</pre>
<h4><a name="0102_0068"><a name="0102_0069">Listing Eight<a name="0102_0069"></h4><pre>
define method error-handler(dbproc :: &lt;dbprocess&gt;, severity :: &lt;integer&gt;,
                            dberr :: &lt;integer&gt;, oserr :: &lt;integer&gt;,
                            dberrstr :: &lt;c-string&gt;, oserrstr :: &lt;c-string&gt;)
=&gt; action :: &lt;integer&gt;;
    ignore(dbproc);
    ignore(oserr);
    ignore(dberr);
    ignore(severity);
    if (dbproc = $null-machine-pointer | dbdead(dbproc))
        $INT_EXIT;
    else
        signal(&quot;DB-Library error:~&~a&quot;, dberrstr);
        if (oserr ~= $DBNOERR)
            signal(&quot;Operating-system error:~&~a&quot;, oserrstr);
        end if;
        $INT_CANCEL;
    end if;
end method;
define variable error-handler-proc = ErrHandler(dbproc(severity, dberr, oserr,
                       dberrstr, oserrstr),error-handler(dbproc, severity,
                       dberr, oserr, dberrstr, oserrstr));
</pre>
<h4><a name="0102_006a"><a name="0102_006b">Listing Nine<a name="0102_006b"></h4><pre>
RETCODE dbcmd(DBPROCESS* dbproc, char* cmdstring);
RETCODE dbsqlexec(DBPROCESS* dbproc);
RETCODE dbresults(DBPROCESS* dbproc);
RETCODE dbbind(DBPROCESS* dbproc, int column, int vartype, DBINT varlen, 
                                                              BYTE* destvar);
STATUS dbnextrow(DBPROCESS* dbproc);
</pre>
<h4><a name="0102_006c"><a name="0102_006d">Listing Ten<a name="0102_006d"></h4><pre>
    #include &quot;sybdb.h&quot;,
        import:
            {&quot;dbinit&quot;, &quot;dbsetlname&quot;, &quot;dbprocess&quot;, &quot;dblogin&quot;, &quot;dbopen&quot;,
             &quot;dbclose&quot;, &quot;dbexit&quot;, &quot;dbcmd&quot;, &quot;dbsqlexec&quot;, &quot;dbdead&quot;, &quot;dbbind&quot;,
             &quot;dberrhandle&quot;, &quot;dbmsghandle&quot;, &quot;dbnextrow&quot;, &quot;dbresults&quot;,
                // Parameterized Macros
                &quot;DBSETLHOST&quot;, &quot;DBSETLUSER&quot;, &quot;DBSETLPWD&quot;, &quot;DBSETLAPP&quot;,
                //  Message/Error Handler Types
                &quot;MHANDLEFUNC&quot;, &quot;EHANDLEFUNC&quot;,
                //  Constants
                &quot;MAXNAME&quot;, &quot;NO_MORE_RESULTS&quot;, &quot;DBNOERR&quot;, &quot;NO_MORE_ROWS&quot;
                // Binding Constants
                &quot;INTBIND&quot;, &quot;NTBSTRINGBIND&quot;},
     external-module: syb-externals;
  struct &quot;dbprocess&quot;, import: {};
  function &quot;dbopen&quot;, argument-type: {servername =&gt; &lt;c-string&gt;};
  function &quot;dbsetlname&quot;, argument-type: {name =&gt; &lt;c-string&gt;};
  function &quot;dbcmd&quot;, argument-type: {cmdstring =&gt; &lt;c-string&gt;};
end interface;
</pre>
<h4><a name="0102_006e"><a name="0102_006f">Listing Eleven<a name="0102_006f"></h4><pre>
oh-oh
define method oh-oh()
    if (dbinit() = #f)
        error(&quot;Unable to initialize Sybase.&quot;);
    end if;
    dberrhandle(error-handler-proc);
    dbmsghandle(message-handler-proc);
    let login = dblogin();
    dbsetlhost(login, &quot;Oahu&quot;);
    dbsetluser(login, &quot;virologist&quot;);
    dbsetlpwd(login, &quot;Aiea&quot;);
    dbsetlapp(login, &quot;macabre&quot;);
    let dbproc = dbopen(login, &quot;morbidity&quot;);
    dbcmd(dbproc, &quot;select name, mortality &quot;);
    dbcmd(dbproc, &quot;from virus &quot;);
    dbcmd(dbproc, &quot;where mortality &gt; 50&quot;);
    dbsqlexec(dbproc);
    for (result-code :: &lt;integer&gt; = dbresults(dbproc)
        then dbresults(dbproc), until result-code = $NO_MORE_RESULTS)
        if (result-code = $SUCCEED)
            //  &lt;c-string&gt; Virus Name
            with-stack-block(name(&lt;machine-pointer&gt;, 31),
            //  &lt;integer&gt; Mortality
            with-stack-block(
                    mortality(&lt;machine-pointer&gt;, 4),
                begin
                    dbbind(dbproc, 1, $NTBSTRINGBIND, 0, name);
                    dbbind(dbproc, 2, $INTBIND, 0, mortality);
                    while(dbnextrow(dbproc) ~= $NO_MORE_ROWS)
                        signal(&quot;~A ~A&quot;, c-string-at(name),
                            signed-long-at(mortality));
                    end while;
            end))));
        end if;
    end for;
    dbexit();
end method;
</pre>
<P>

<P>

<P>

<P>

<P>

<P>

<P>

<P>

<P>

<P>

</BODY></HTML>
