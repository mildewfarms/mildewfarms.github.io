<HTML>
<META NAME="year" CONTENT="1996">
<HEAD>
<!-- This document was built using HyperWriter Professional by NTERGAID Inc. -->
<TITLE>November 1996:  Letters</TITLE></HEAD>
<body bgcolor="FFFFFF">
<P>

<h3>Java and C++</h3><P>

Dear <I>DDJ</I>,<P>

After reading Al Stevens' narrative on C++ versus Java, I felt compelled to respond to a few points with
my pragmatic perspective as a developer of Java and C++ applications. I agree with his initial assessment
that templates are a sorely missed feature of Java, but container-class libraries were developed in C++
long before templates arrived. The containment of intrinsic types, which appears to be Al's primary issue
here, has generally been addressed by the JDK by inclusion of the java.lang classes which are primarily
wrappers for intrinsic types. It is these wrappers that allow intrinsics to be used in the java.util
classes--primarily container classes (<I>Vector</I>, <I>Stack</I>, <I>Dictionary</I>, <I>Hashtable</I>,
<I>Enumeration</I>).<P>

Al's next assertion that Java did not become a cult language because of JavaScript is a demonstration of a
lack of knowledge in this area; JavaScript was named as such after Java became popular. JavaScript was
originally called "LiveScript" by Netscape. It was realigned with Java after Java was a big hit. Java
became popular because it offered the first serious client-side interactive application development tool.
(Java wasn't the first web tool to do this; it just hit at the right time.) <P>

Java isn't for C programmers who lack object-oriented background. Java is an intensely object-oriented
language, compared to C++. There is no model for stand-alone functions in Java. <P>

Not having read <I>Java for C/C++ Programmers</I>, by Michael Daconta, I'll have to take Al's reading of
Daconta's assertion about variable argument lists on face value. All classes in Java are derived from a
single <I>Object</I> class; therefore, a <I>Vector</I> could easily be used for a variable argument list. In
fact, the <I>instanceof</I> operator makes this a likely scenario since each element of the vector could be
queried for the type of class that it is. So, Daconta may have the cause/effect relationship wrong, but the
observation is valuable nonetheless. And, in fact, it is the <I>instanceof</I> operator that offers real
type-safety.<P>

Al's comments about multiple inheritance are somewhat ambiguous in the column. Rather than trying to
guess what Daconta says about them and whether Al agrees, I'll just throw in that Java does not support
multiple inheritance directly but supports a similar and powerful paradigm of interface classes. Interface
classes do not support multiple inheritance like C++ does, but they do allow a class to declare on a
class-level functional interfaces that enable an object to be used polymorphically. In <a href="9611q.htm#00e3_02ee">Example 1(a)</A>, <I>Fish</I> and <I>Leopard</I> can be instantiated and
stored in a <I>Vector</I>. The vector can be enumerated and each animal can be queried for its name via
polymorphism: <I>System.out.println((Animal)o.getName());  // print out animal's name</I>. But a more
powerful implementation can be used as in Example 1(b). There is really nothing like this in C++. I have
actually used this language feature to implement a multicolumn listbox that contains owner-drawn cells
based on interface functions.<P>

Whether Bjarne Stroustrup really used references as a band-aid for pointers I can't comment on, but
pointers and references do not exist on a language level like they do in C++. Java variables can be defined
without being instantiated; see Example 1(c). Although there is a "null" value that can be assigned to an
object, the creation of objects and their assignment to variables is more like the C++ copy constructor than
anything else. Objects that have default constructors (no arguments) will automatically instantiate
themselves. Does this mean that Java supports pointers? Not at all. Objects can be instantiated and
assigned to a variable, but they can't be deleted like C++.<P>

Java does not have a preprocessor as part of the JDK. There is no reason that CPP can't be used with Java
to do exactly what Al suggests. There's not much to quibble with here, although I do think that Al overplays
the need for a CPP.<P>

Al casually tosses in a few jabs at Java by asserting that C++ is a superior programming language. Having
written several orders of magnitude more C++ code that I have Java code, my experience tells me that I
must disagree with Al. At its worst, Java as a language is about equal to C++. But in many respects it's
much better than C++ will ever be. The things I miss in Java are operator overloading, an object
destructor, and the ability to create an occasional global object. However, Java is significantly better than
C++ in many areas:<P>

<P>
<ul>
<li>Everything must be encapsulated in a class. No freestanding code allowed.</li>
<li>The <I>instanceof</I> operator.</li>
<li>Interface classes.</li>
<li>Exception handling that actually requires a "catch" for each "throw."</li>
<li>No pointers or reference variables (this is a religious war, more or less).</li>
<li>An excellent class library (not yet complete).</li>
<li>Public classes that provide a good component library model.</li>
</ul>
<P>

The Java language shows strong signs of maturity. The JDK still has bugs galore, but these will eventually
work themselves out. And unlike most of those on the Java bandwagon, my support for Java is purely on a
language basis. I like Java only because the nature of the language maps better to what I consider good
object-oriented programming. I am not as interested in the Java interpreter or portable bytecode.<P>

In fact, I look forward to the future where Java compilers produce native executables so that more of my
development efforts may be built in Java.<P>

Jeffrey Kay<P>

Falls Church, Virginia <P>

jkay@dev.infomkt.ibm.com<P>

<h3>The Juice of the Bean</h3><P>

Dear <I>DDJ</I>,<P>

If Michael Swaine writes software with the same literary verve he displayed in his "Ode to Java" in the
July 1996 "Swaine's Flames," he may well achieve Donald Knuth's ideal of software as literature. But...does
it compile?<P>

Russell Galvin<P>

Acton, Ontario<P>

russell@srgsoft.com    <P>

<h3>Will's Words</h3><P>

Dear <I>DDJ</I>,<P>

The article "Optimizing the Performance of VRML Worlds," by David R. Nadeau, Andrea L. Ames, and John
L. Moreland <P>
(<I>DDJ</I>, July 1996) was fascinating. However, whoever decided to use the quote from <I>Macbeth</I>
in Figure 8 shouldn't have done it from memory. Every edition of Shakespeare that I've been able to find
spells "caldron" without a "u," not the modern "cauldron." And the third line is obviously missing a word,
as it doesn't scan. It's not much better in Will's version: "Toad, that under <I>the</I> cold stone." Still, the
Bard's words are precious, and we shouldn't omit any. <P>

Neil J. Rubenking<P>

Neil_Rubenking@zd.com<P>

<h3>A Helping Hand</h3><P>

Dear <I>DDJ</I>,<P>

Near the end of his August 1996 editorial, Jonathan Erickson suggests that government, in particular the
federal government, should "help build an infrastructure to support cooperative research."<P>

I challenge him to read <I>Why Government Doesn't Work</I>, by Harry Browne, the Libertarian candidate
for President, and then present his views again as to why this particular government program that he is
encouraging has any more chance of succeeding than the hundreds of others that don't. I hope he'll see that
what he should be encouraging is exactly the opposite: Get the federal government out of R&amp;D
altogether, remove corporate (and individual) taxation and regulations and you'll see R&amp;D flourish like
never before.<P>

Did Microsoft or Intel need any help from the government to give us the PCs and software that are 100
times better and faster than they were in 1980? (see <I>Why Government Doesn't Work</I>, page 156).<P>

Joe M. Abbate<P>

jma@icanect.net<P>

<P>

<P>

<P>

<h4><a name="00e3_02ee"><B>Example 1: Java and C++.</B></h4><P>


<B>(a)<FONT FACE="B Bodoni Bold" SIZE=1></B></font>   
<pre>
      class Animal extends Object {
          String name;
          public Animal(String s) {
         name = s;
          }
          String getName() {
         return name;
          }
      }
      interface Swimmer {
          public abstract swim();
      }
      interface Runner {
          public abstract run();
      }
      class Fish extends Animal implements Swimmer {
          public Fish(String s) {
         super(s);
          }
          public swim() {
         ...
          }
      }
      class Leopard extends Animal implements Runner {
          public Leopard(String s) {
         super(s);
          }
          public run() {
         ...
          }
      }
      
<B>(b)<FONT FACE="B Bodoni Bold" SIZE=1></B></font>   
<pre>
      if (o instanceof Swimmer) {
          Swimmer sw = (Swimmer)o;
          sw.swim();
      }
        if (o instanceof Runner) {
           Runner rn = (Runner)o;
            rn.run();
      }

<B>(c)<FONT FACE="B Bodoni Bold" SIZE=1></B></font>   
<pre>
      Fish f;    // f is uninstantiated and undefined
       Leopard l = null;    // l is uninstantiated and set to null, sort of like C++
       Fish f = new Fish(&quot;Goldfish&quot;);    // instantiated 
</pre>

</BODY></HTML>
