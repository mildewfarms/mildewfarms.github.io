<HTML>
<META NAME="year" CONTENT="1996">
<HEAD>
<!-- This document was built using HyperWriter Professional by NTERGAID Inc. -->
<TITLE>SP 96: Designing Isometric Game Environments</TITLE></HEAD>
<body bgcolor="FFFFFF">
<h1>Designing Isometric Game Environments<a name="02d4_00f4"><a name="02d4_00f4"><a name="02d4_00f2"><a name="02d4_0000"></h1><P>

<h2>Looking at game engines from a new angle</h2><P>

<h3>Nate Goudie</h3><P>

<P>
<i><a name="02d4_00f3"><a name="02d4_0000">Nate is a computer engineering major at Lehigh University. He can be reached at nsg2@lehigh.edu.</i></p><hr><P>

Tile-based games have been around almost as long as two-dimensional (2-D) arrays. I can remember, for instance, sitting in front of a Commodore 64, carefully maneuvering a tiny &quot;pixelesque&quot; humanoid from square to square, thinking, &quot;Hey, this is great!&quot;<P>

As computer games became more sophisticated, however, simple, top-down, tile-based games gave way to bigger and better things. Why? Because someone decided to look at things from a slightly different angle. The emergence of the isometric point of view took tile-based games somewhere they had never been before--into the third dimension. After playing through a prime example of this isometric ingenuity (Microprose's award-winning <I>X-com</I>), I decided to create my own multilevel, isometric environment. As <a href="9615a2f1.gif">Figure 1</A> shows, the Axoview Engine 1.0 is the result of my efforts. In this article, I'll describe how I designed the engine, and provide an overview of its inner workings.<P>

<h3><a name="02d4_00f5">Putting Things in Perspective<a name="02d4_00f5"></h3><P>

You need to keep two things in mind when designing an isometric layout: <P>
<ul>
<li> Ease of visibility.</li>
<li> Ease of putting things together.</li>
</ul>
Of all the isometric possibilities, the axonometric perspective provides excellent vision clarity and allows for each cube to be easily broken down into unique components; see <a href="9615a2f2.gif">Figure 2(a)</A>. The multilevel, tile-based world is constructed entirely from axonometric cubes called &quot;cell blocks.&quot; As <a href="9615a2f2.gif">Figure 2(b)</A> illustrates, each cell block is composed of separate tiles: <P>
<ul>
<li>The base tile, which serves as a floor or ceiling.</li>
<li>X- and y-wall tiles, for walls, fences, and the like.</li>
<li>The prop tile, for stationary objects such as trees and chairs. </li>
</ul>
<h3><a name="02d4_00f6">Getting Coordinated<a name="02d4_00f6"></h3><P>

Cell blocks are arranged side-by-side on a 2-D grid, bearing a strong resemblance to a top-down tile layout. The cell-block grid, however, is rotated at 45 degrees. Now the origin of the rotated grid lies at the top-most (farthest) corner, and the x- and y-map grid axes increase downward and to the right or left, respectively, as in <a href="9615a2f3.gif">Figure 3</A>. Therefore, the x-wall of each cell block is the wall players come in contact with as they traverse the grid in the x-direction; likewise for the y-wall. This Cartesian gridmap of cell blocks is referred to as &quot;map coordinates.&quot;<P>

To locate various positions within each cell block, the map grid is further broken down into a uniform number of virtual partitions per cell block. For practical reasons, the number of partitions must be an integral power of 2. These virtual partitions are referenced using world coordinates. Consequently, each cell block has a local coordinate system (with the origin in the top corner of the cell block) created by the world-coordinate partitions. This &quot;grid within a grid&quot; is referenced using &quot;cell coordinates&quot; (see <a href="9615a2f3.gif">Figure 3</A>).<P>

Finally, a familiar coordinate system must be defined. The grid of pixels that makes up the screen display will be referred to as &quot;screen coordinates.&quot; <P>

<h3><a name="02d4_00f7">Base Tile Design<a name="02d4_00f7"></h3><P>

The base tile is most important because it is directly related to the layout of the cell-block grid. Its design hinges on two crucial choices: edge slope and edge length. For standard 320x200 VGA displays, a slope of 0.5 pixels produces the best results. This particular slope creates a series of two-pixel steps which go down and right in the x-direction, and down and left in the y-direction. The &quot;length&quot; of each edge is simply the number of two-pixel steps per edge. This length must correspond to the number of virtual cell-block partitions chosen earlier.<P>

By connecting the ends of four edges to form a diamond (the base tile), a graphic representation of the local cell-coordinate grid is formed; see <a href="9615a2f4.gif">Figure 4(a)</A>. Subsequently, by aligning adjacent base tiles so that the edges transfer smoothly in both the x- and y-directions (no disturbance in edge slope), a graphical representation of the rotated cell-block (map) grid is created. This also reveals an extra edge of &quot;padding&quot; along the bottom half of each base tile; see <a href="9615a2f4.gif">Figure 4(c)</A>. This padding completes the design of the base tile.<P>

The alignment of base tiles also provides several important cell-block dimension constants defined in Listings <a href="9615b.htm#02d4_0107">One</A> and <a href="9615b.htm#02d4_0109">Two</A>. <a href="9615a2f4.gif">Figure 4(b)</A> illustrates these dimensions.<P>

<h3><a name="02d4_00f8">Wall Tile Design<a name="02d4_00f8"></h3><P>

It should be noted that the base tile's edges of padding form slots between adjacent base tiles. This is a convenient place for some walls. The width of each wall tile is a function of the base tile width: <I>wall width = (base tile width/2)+2</I>. The height of the wall must be an even number; choose the height with user visibility in mind.<P>

<h3><a name="02d4_00f9">Prop Tile Design<a name="02d4_00f9"></h3><P>

Once the base and wall tiles are designed, the prop-tile dimensions are straightforward. The width of the prop tile is simply the same width as the base tile. The prop-tile height is equivalent to the height of the connected base and wall tiles decremented by 1.<P>

<h3><a name="02d4_00fa">Leveling Things Out <a name="02d4_00fa"></h3><P>

Multiple levels will be dealt with by stacking several identical cell-block grids directly on top of one another. The base tiles of one level should rest comfortably on the wall tiles of the level below. It should be noted that the base tile of a certain cell block will serve as the ceiling tile for the cell block directly below it. <P>

<h3><a name="02d4_00fb">Basic Engine Structures: The Tile Maps<a name="02d4_00fb"></h3><P>

With the abstract design of the engine out of the way, how do you represent the axonometric layout in memory? <P>

Generally, the axonometric world consists of a fixed number of levels. Each level consists of a 2-D grid of cell blocks, and each cell block consists of four unique tile components. This layout can be represented by four 2-D arrays (one array for each component). The first dimension of each array is a level index and the second is a cell-block location index (for the 2-D grid map). These tile maps are arrays of bytes, where each byte holds a unique tile-identification number. Therefore, every cell block in the world has a corresponding value in the <I>base_map</I>, <I>xwall_</I><I> </I><I>map</I>, <I>ywall</I> <I>_map</I>, and <I>prop_map</I>. See <a href="9615b.htm#02d4_0107">Listing One</A> for the tile-map declarations.<P>

<h3><a name="02d4_00fc">The <I>Tile</I> Class<a name="02d4_00fc"></h3><P>

Now that a means of storing tile layouts has been established, the tiles must be capable of organizing themselves. The <I>Tile</I> class organizes tile bitmap data through four data elements. The most important of these data elements is a pointer to an array of tile bitmaps. Each tile bitmap is accessed through an identification number (which works out well because that is exactly what is stored in the tile maps). The <I>Tile</I> class keeps track of the width and height of each individual bitmap (all bitmaps for an instance of the <I>Tile</I> class must have identical dimensions), and also of the size in bytes of each bitmap. The <I>Tile</I> class is declared in <a href="9615b.htm#02d4_010b">Listing Three</A>.<P>

Not surprisingly, the Axoview Engine declares four instances of the tile class: <I>base_tiles</I>, <I>xwall_tiles</I>, <I>ywall_tiles</I>, and <I>prop_tiles</I> (see <a href="9615b.htm#02d4_0107">Listing One</A>). To declare an instance of the <I>Tile</I> class, the class constructor requires three arguments: the number of tiles, the width of each tile, and the height of each tile. The constructor calculates the size of each bitmap (<I>width</I><I></I>x<I>height</I>), and, more importantly, allocates memory for each of the tile bitmaps (see <a href="9615b.htm#02d4_010d">Listing Four</A>).<P>

But how do the bitmaps make it to the big screen? The <I>Tile</I> class' member function <I>blit()</I> takes care of everything. You just need to be sure to pass it three things: the tile identification number, screen coordinates (where you would like the bitmap displayed), and a pointer to the off-screen buffer on which it should do the blitting. How exactly does the <I>blit()</I> function blit? The typical way of rendering a tile-based display would be to use the painter's algorithm. The painter's algorithm draws the tiles back to front, so that the tiles in the foreground cover the tiles beneath them (much like a painter would paint a picture). Standard bitmap transparency also would be applied, where each byte of the bitmap would be checked for transparency (usually a value of 0). If the byte were &quot;transparent,&quot; it would not be drawn to the off-screen buffer. While this method works, it can be highly inefficient, drawing several levels of cell-block tiles on top of each other, even though many of the tiles would not be seen at all. It turns out that there is a way to draw only what can be seen. I refer to it as the &quot;reverse painter's algorithm.&quot;<P>

<h3><a name="02d4_00fd">The Reverse Painter's Algorithm <a name="02d4_00fd"></h3><P>

The reverse painter's algorithm (RPA) eliminates the blitting of &quot;covered over&quot; portions of tile bitmaps--only the pixels that will be seen in the end are drawn. The algorithm can be broken into several steps. First, fill the entire off-screen buffer (destination viewport) with a string of transparent (zero) values as quickly as possible. Second, calculate the order in which the tiles would be drawn using the normal painter's algorithm and reverse it (draw tiles in the foreground first). The cell-block tile-display order becomes: prop, x-wall, y-wall, base. To draw from front to back according to the RPA, the top-most level of cell blocks should be drawn first. Therefore, draw each level from left to right across the screen, starting with the bottom-most row, and ending with the top-most row. A significant problem still remains to be addressed, however--can the <I>blit()</I> function keep the later-drawn background tiles from copying over the foreground tiles? <P>

<h3><a name="02d4_00fe">RPA-Style Drawing with <I>Tile::blit()</I> <a name="02d4_00fe"></h3><P>

To preserve speed, the <I>blit()</I> function performs all clipping outside of the main blitting loop. It first clips the edges of the tile bitmap to the viewport, adjusting the starting and ending coordinates appropriately, and calculates the necessary blitting offsets. It then loops through the unclipped portion of the tile bitmap and copies the &quot;permissible&quot; bytes to the off-screen buffer. <P>

It is here that the &quot;magic&quot; takes place. Instead of checking each byte of the bitmap (the source byte) for transparency, the <I>blit()</I> function checks the corresponding byte in the off-screen buffer (the target byte) for transparency (recall that the off-screen buffer was initially filled with transparent values). If the target byte is transparent (nothing has been drawn there yet), the blit is deemed &quot;permissible&quot; and the function copies the source byte to the target byte, as in <a href="9615a2f5.gif">Figure 5</A>. The only drawback to this method is that transparent source bytes may be needlessly copied over transparent target bytes. This drawback is negligible, however, when compared to the inefficiency of copying hundreds of tiles on top of one another. <a href="9615b.htm#02d4_010d">Listing Four</A> presents the full definition of <I>Tile::blit()</I>.<P>

<h3><a name="02d4_00ff">It Was a Time to be Rendered<a name="02d4_00ff"></h3><P>

The next step involves rendering the multilevel cell-block environment. The engine function <I>draw_tilesRPA()</I> assumes full responsibility for this task. The function <I>draw_tilesRPA()</I> requires five arguments:<P>
<ul>
<li>The pair of world coordinates around which the display should be centered.</li>
<li>The level that will serve as the top-most level.</li>
<li>The level around which the display should be centered.</li>
<li>A pointer to the off-screen buffer.</li>
</ul>
However, before <I>draw_tilesRPA()</I> can begin the process of rendering the layout to the screen, we need a method for converting world coordinates to screen coordinates (and vice versa).<P>

<h3><a name="02d4_0100">Going from World to Screen, and Back Again<a name="02d4_0100"></h3><P>

To convert from world coordinates to screen coordinates, you need to compare the local cell coordinates of a base tile with its local screen coordinates; see <a href="9615a2f6.gif">Figure 6</A>. This comparison shows that a change of +1 along the cell-coordinate x-axis is equivalent to the following screen-coordinate changes: +2 in the x-direction, and +1 in the y-direction. <a href="9615b.htm#02d4_0105">Table 1</A> lists similar comparisons.<P>

These comparisons suggest the pair of equations in <a href="9615b.htm#02d4_0104">Example 1(a)</A> for converting from a change in world (or cell) coordinates to a change in screen coordinates. Solving this pair of equations for the change in world (or cell) coordinates yields the pair of equations in <a href="9615b.htm#02d4_0104">Example 1(b)</A>, which convert from a change in screen coordinates to a change world coordinates. With these conversions at the ready, the rendering process may begin.<P>

<h3><a name="02d4_0101">Rendering with Function <I>draw_tilesRPA()</I><a name="02d4_0101"></h3><P>

The pair of world coordinates (x,y) passed to <I>draw_tilesRPA()</I> corresponds to the center of the viewport. However, the rendering process does not start in the center, but instead in the lower-left corner (RPA requirement). Therefore, the screen-to-world conversion formulas are used to find the world coordinates for the lower-left corner of the viewport. This is done by plugging the change in screen coordinates (distances from center of viewport to lower-left corner) into the formulas, then adding the equivalent change in world coordinates to the original pair of world coordinates (center of viewport). The resulting pair of world coordinates correspond to the lower-left corner of the viewport. This world-coordinate location is called the &quot;world intersection point;&quot; see <a href="9615a2f7.gif">Figure 7</A>. <P>

Because the rendering process starts on the top-most level (not necessarily the current level), the world intersection point must be adjusted to compensate for the difference in screen height between levels. This change along the screen y-axis is equivalent to the distance (in pixels) from the top of a wall tile to the top of its connected base tile (there is no change along the x-axis). Using the conversion formulas again, the equivalent level change in world coordinates is added to the world intersection point for each level that needs to be drawn above the current level. This centers the display around the current level.<P>

<h3><a name="02d4_0102">The Main Rendering Loop<a name="02d4_0102"></h3><P>

Now for the main looping procedure. Starting with the top-most level, the function calculates the map coordinates of the cell block that contains the world-intersection point. This is done by a technique I call &quot;binary masking,&quot; which uses the bitwise AND operator and a certain binary &quot;mask&quot; to retain (or clip) a wanted or unwanted power of 2 from a number (in this case, the world coordinates). Assuming that the coordinates are 16-bit integers, the binary mask is calculated as <I>Map Coordinate Mask = 0xfff</I><I>f</I><I>-- (# of cell partitions - 1)</I>. This technique works because the number of cell partitions was chosen to be an integral power of 2. The map location (cell block) that contains the world intersection point is called the &quot;intersection block&quot; (see <a href="9615a2f7.gif">Figure 7</A>).<P>

Next, the local cell coordinates of the world intersection point are calculated using the same binary-masking technique. However, in this case, a different power of 2 needs to be clipped. Therefore, the cell-coordinate mask is defined as <I>Cell Coordinate Mask = ( # of cell partitions - 1 );</I>. The world-to-screen conversion formulas are then used to find the screen offsets of the calculated cell coordinates. These screen offsets, once adjusted to the viewport, yield the screen coordinates of the intersection block.<P>

The function next finds the map and screen coordinates for the starting block (the place where the rendering process will finally begin). The starting block is found by dropping down a certain number of cell blocks from the intersection block to account for the fact that walls and props of off-screen base tiles may still be visible. Hence, the higher you make the walls, the farther down you have to move the starting block; see <a href="9615a2f7.gif">Figure 7</A>.<P>

The time to render has finally come. Using the starting block as a starting point, the tiles for each cell block are drawn from left to right (according to the RPA). Each tile is drawn through a call to the appropriate <I>Tile::blit()</I>, after getting the tile-identification number from the appropriate tile map. After each row is drawn, the starting block is moved alternatively up and to the left and up and to the right, as in <a href="9615a2f7.gif">Figure 7</A>. Once all the rows that fit into the viewport have been drawn, the process is done for the current level. The world intersection point is then adjusted for the next level down, and the main rendering process continues until all the levels have been drawn. That's all there is to it! The Axoview Engine is ready to display your worlds!<P>

<h3><a name="02d4_0103">Conclusion<a name="02d4_0103"></h3><P>

You can fill the tile maps with level layouts, fill the <I>Tile</I> class bitmaps with artwork, and create axonometric, multilevel environments (with applications beyond just game worlds). Moveable characters (and objects) could be implemented by incorporating an object map (with the same dimensions as the tile maps) that contains a linked list to all the objects currently in a cell block. These characters could then be moved around the world using standard, cell-oriented collision-detection techniques.<P>

Although the Axoview Engine was written specifically for Mode 13h in DOS (assembly-language files are available electronically; see &quot;Availability,&quot; page 3), it can easily be ported to any platform--in some cases with just a few changes to the <I>Tile</I> class' blitting function. Portability aside, however, a multitude of possible projects stem from the Axoview Engine as it now stands. Animated tile code could be thrown into the blitting algorithm, map rotation could be incorporated to allow the user to change the perspective, and so on. The possibilities are limited only by your imagination.<P>

<h4><B><a href="9615a2f1.gif">Figure 1</A>:</B> The Axoview Engine v1.0.</h4><P>

<h4><B><a href="9615a2f2.gif">Figure 2</A>:</B> (a) The axonometric cube (cell block); (b) component breakdown of the cell block.</h4><P>

<h4><B><a href="9615a2f3.gif">Figure 3</A>:</B> The axonometric map-coordinate grid.</h4><P>

<h4><B><a href="9615a2f4.gif">Figure 4</A>:</B> (a) Building the base tile from equal edges; (b) base-tile dimensions to remember; (c) the finished base tile.</h4><P>

<h4><B><a href="9615a2f5.gif">Figure 5</A>:</B> Reverse painter's algorithm tile-transparency blitting technique.</h4><P>

<h4><B><a href="9615a2f6.gif">Figure 6</A>:</B> Base-tile coordinate-conversion analysis.</h4><P>

<h4><B><a href="9615a2f7.gif">Figure 7</A>:</B> Main rendering process.</h4><P>

<h4><a name="02d4_0104"><B>Example 1:</B> (a) Equations for converting from a change in world (or cell) coordinates to a change in screen coordinates; (b) equations which convert a change in screen coordinates to a change in world coordinates.<a name="02d4_0104"></h4><P>

<pre>(a)
     dX(screen) = 2*dX(world) - 2*dY(world)
     dY(screen) = dX(world) + dY(world)

(b)
     dX(world) = [ dX(screen) + 2*dY(screen) ] / 4
     dY(world) = [ 2*dY(screen) - dX(screen ) ] / 4</pre>

<h4><a name="02d4_0105"><B>Table 1:</B> Cell-coordinates-to-screen-coordinates conversion.<a name="02d4_0105"></h4><P>

<pre>
Change in Cell          Change in Screen
Coordinates          Coordinate



dX     dY     dX     dY

+1     0     +2     +1

0     +1     -2     +1

     

+1     +1     0     +2

+1     -1     +4     0

-1     +1     -4     0

-1     -1     0     -2

-1     0     -2     -1

0     -1     +2     -1

</pre>

<P>

<h4><a name="02d4_0106"><a name="02d4_0107">Listing One<a name="02d4_0107"></h4><pre>
/********************************************************************
 AXOVIEW.H
 Header file for the Axoview Engine v1.0
 Contains engine constants, global data structures, and function prototypes.
 Written by Nate Goudie  1996
********************************************************************/
// Defines for Tile Totality Constants
#define  BASE_COUNT        7        // Number of base tiles
#define  WALL_COUNT        5        // Number of wall tiles
#define  PROP_COUNT        3        // Number of prop tiles
// Defines for Tile Bitmap Dimension Constants
#define  BASE_WIDTH        30       // Width of base tile
#define  BASE_HEIGHT       16       // Height of base tile
#define  WALL_WIDTH        17       // Width of wall tile
#define  WALL_HEIGHT       28       // Height of wall tile
#define  PROP_WIDTH        30       // Width of prop tile
#define  PROP_HEIGHT       33       // Height of prop tile
// Defines for Viewport Dimension Constants
#define  FULL_SCREEN_SIZE  64000    // Size of a full screen buffer
#define  VIEWPORT_X_START  0        // Starting X coord of viewport
#define  VIEWPORT_X_END    319      // Ending X coord of viewport
#define  VIEWPORT_Y_START  0        // Starting Y coord of viewport
#define  VIEWPORT_Y_END    199      // Ending Y coord of viewport
#define  VIEWPORT_WIDTH    320      // Horizontal width of viewport
#define  VIEWPORT_HEIGHT   200      // Vertical height of viewport
// Defines for Map Dimension Constants
#define  LEVEL_MAX         4        // Maximum number of levels
#define  XMAP_MAX          50       // Maximum X dimension of map
#define  YMAP_MAX          50       // Maximum Y dimension of map
#define  SCROLL_STEP       2        // World coordinate scroll step
#define  MAX_CELL_UNITS    8        // No. of cell units per map unit
#define  CELL_COORD_MASK   0x0007   // Cell coordinate mask
#define  MAP_COORD_MASK    0xfff8   // Map coordinate mask
#define  X_VPTM_OFFSET     10       // Viewport-to-map X offset
#define  Y_VPTM_OFFSET     90       // Viewport-to-map Y offset
// Defines for Cell Block Dimension Constants
#define  CELL_START_X      14       // Init X for cell -&gt; screen op
#define  CELL_START_Y      0        // Init Y for cell -&gt; screen op
#define  CELL_FULL_WIDTH   32       // X of cellA - X of adj cellB
#define  CELL_HALF_WIDTH   16       // Half the full width
#define  CELL_FULL_HEIGHT  16       // Height of base tile
#define  CELL_HALF_HEIGHT  8        // Y of cellA - Y of next cellB
#define  XWALL_XOFFSET     -1       // X offset for the cell's X-Wall
#define  YWALL_XOFFSET     +14      // X offset for the cell's Y-Wall
#define  WALL_YOFFSET      -20      // Y offset for the cell's walls
#define  PROP_YOFFSET      -18      // Y offset for the prop tile
#define  LEVEL_ADJUST      10       // Offset to move up/down a level
// Defines for view rectification of walls
#define  START_YS_OFFSET   32       // Initial Y screen offset
#define  START_XS_OFFSET    0       // Initial X screen offset
#define  START_YM_OFFSET    2       // Initial Y map offset
#define  START_XM_OFFSET    2       // Initial X map offset
#define  START_XADD        16       // Initial Xadd value
// Declare global data structures
unsigned char palette[256*3];   // array for the color palette
// Declare arrays for the tile maps
unsigned char base_map[LEVEL_MAX][XMAP_MAX*YMAP_MAX];
unsigned char xwall_map[LEVEL_MAX][XMAP_MAX*YMAP_MAX];
unsigned char ywall_map[LEVEL_MAX][XMAP_MAX*YMAP_MAX];
unsigned char prop_map[LEVEL_MAX][XMAP_MAX*YMAP_MAX];
// Declare instances of the Tile class
Tile  base_tiles(BASE_COUNT, BASE_WIDTH, BASE_HEIGHT),
      xwall_tiles(WALL_COUNT, WALL_WIDTH, WALL_HEIGHT),
      ywall_tiles(WALL_COUNT, WALL_WIDTH, WALL_HEIGHT),
      prop_tiles(PROP_COUNT, PROP_WIDTH, PROP_HEIGHT);
// Function prototypes
void draw_tilesRPA(int x, int y, int top_level, int current_level,
           unsigned char far *screenbuf);
int  load_files();
</pre>
<h4><a name="02d4_0108"><a name="02d4_0109">Listing Two<a name="02d4_0109"></h4><pre>
/********************************************************************
 AXOVIEW.CPP
 The Axoview Engine v1.0. An engine which renders free scrolling tile-based 
 environments in axonometric perspective. Main program and engine functions.
 Written by Nate Goudie  1996
********************************************************************/
#include    &lt;stdio.h&gt;
#include    &lt;dos.h&gt;
#include        &lt;conio.h&gt;
#include    &lt;alloc.h&gt;
#include    &lt;mem.h&gt;
#include        &lt;iostream.h&gt;
#include        &lt;process.h&gt;
#include    &quot;tile.h&quot;
#include    &quot;screen.h&quot;
#include        &quot;axoview.h&quot;
void main()
    {
    clrscr();
    // Allocate memory for the offscreen buffer
    unsigned char far *screenbuf;
    screenbuf=new unsigned char[FULL_SCREEN_SIZE];
    // Get old video mode number
    int oldmode=*(int *)MK_FP(0x40,0x49);
    // Create pointer to video memory
    char far *screen=(char far *)MK_FP(0xa000,0);
    // Clear video memory ( set each byte to 0 )
    memset(screen, 0, FULL_SCREEN_SIZE);
    // Call function to load files into memory, exit on error
    if(!load_files()) exit(1);
    // Call assembly routines to set graphics mode and palette
    setgmode(0x13);          // Set mode to 13h
    setpalette(palette);     // Set VGA palette
    // Initialize starting variables
    int bye=0;                   // Exit program flag
    int x=0,y=0;                 // Initial world coord position
    int tlevel=(LEVEL_MAX-1);    // Top level to display
    int clevel=0;                // Current level position
    // Main rendering loop
    do
       {
       // Clear the offscreen buffer: 1st Step in RPA
       memset(screenbuf, 0, FULL_SCREEN_SIZE);
       // Render the axonometric tile display
       draw_tilesRPA(x, y, tlevel, clevel, screenbuf);
       // Copy offscreen buffer to the screen
       memmove(screen,screenbuf,FULL_SCREEN_SIZE);
       // Check to see if user hit a key, and process if so
       if ( kbhit() )
       {
       int xmap, ymap;
       char ch;
       ch=getch();
         switch (ch)
           {
           case 0:
         ch=getch();
         switch (ch)
           {
           // Left Arrow Key - shift map to the right
           case 'M':
             x+=SCROLL_STEP;
             xmap=int(x &amp; MAP_COORD_MASK)/MAX_CELL_UNITS;
             if (xmap&gt;(XMAP_MAX-1)) x-=SCROLL_STEP;
             break;
           // Right Arrow Key - shift map to the left
           case 'K':
             x-=SCROLL_STEP;
             xmap=int(x &amp; MAP_COORD_MASK)/MAX_CELL_UNITS;
             if (xmap&lt;0) x+=SCROLL_STEP;
             break;
           // Up Arrow Key - shift map downward
           case 'P':
             y+=SCROLL_STEP;
             ymap=int(y &amp; MAP_COORD_MASK)/MAX_CELL_UNITS;
             if (ymap&gt;(YMAP_MAX-1)) y-=SCROLL_STEP;
             break;
           // Down Arrow Key - shift map upward
           case 'H':
             y-=SCROLL_STEP;
             ymap=int(y &amp; MAP_COORD_MASK)/MAX_CELL_UNITS;
             if (ymap&lt;0) y+=SCROLL_STEP;
             break;
           }
         break;
           case  27:
         bye=1;
         break;
           }
       // Clear the keyboard buffer (eliminates backup)
       while(kbhit()) ch=getch();
       }
       }
    while(!bye);
    // Restore the old video mode and clear the screen
    setgmode(oldmode);
    clrscr();
    return;
    }
/*******************************************************************
 Function:  draw_tilesRPA();
 Purpose:   Renders the axonometric tile display using the
        &quot;Reverse Painter's Algorithm&quot;
 Arguments: x, y          - pair of world coordinates on which
                display should be centered
        top_level     - topmost level to display
        current_level - level on which display should be
                centered
        screenbuf     - pointer to offscreen buffer
 Comments:  The destination viewport (screenbuf) must be cleared
        (set to 0 values) before this function is called
*******************************************************************/
void draw_tilesRPA(int x, int y, int top_level, int current_level,
           unsigned char far *screenbuf)
    {
    // Add viewport-to-map offsets corresponding to the distances
    // from the center to the lower left corner of the viewport
    x+=X_VPTM_OFFSET;
    y+=Y_VPTM_OFFSET;
    // Adjust world position to compensate for levels which must
    // be drawn above the current_level position
    for ( int k=current_level; k&lt;top_level; k++ )
      { x+=LEVEL_ADJUST; y+=LEVEL_ADJUST; }
    // Begin rendering process, starting with topmost level
    for ( int level=top_level; level&gt;=0; level-- )
      {
      // Calculate map location (map coordinates)
      int mapx=int(x &amp; MAP_COORD_MASK)/MAX_CELL_UNITS;
      int mapy=int(y &amp; MAP_COORD_MASK)/MAX_CELL_UNITS;
      // Calculate location within cell (cell coordinates)
      int cellx=(x &amp; CELL_COORD_MASK);
      int celly=(y &amp; CELL_COORD_MASK);
      // Set up initial values for conversion from cell
      // coordinates to screen coordinates
      int xpos=CELL_START_X;
      int ypos=CELL_START_Y;
      // Calulate x and y screen coordinates using the
      // cell-to-screen conversion formulas
      xpos+=(2*cellx-2*celly);
      ypos+=cellx+celly;
      // Adjust screen coordinates to the viewport
      xpos=(VIEWPORT_X_START-xpos);
      ypos=(VIEWPORT_Y_END-ypos);
      // Make adustments to the map and screen coordinates
      // (go below the viewport) to ensure that the walls/objects
      // of offscreen base tiles may still be visible (drawn)
      mapy+=START_YM_OFFSET;
      mapx+=START_XM_OFFSET;
      xpos+=START_XS_OFFSET;
      ypos+=START_YS_OFFSET;
      // Set initial x increment value
      int xadd=START_XADD;
      // Hold on to starting values of map coordinates
      int mxhold=mapx, myhold=mapy;
      // Create temporary holding variables for the screen position
      int tempx=xpos, tempy=ypos;
      // Loop through and draw tiles: left-&gt;right, bottom-&gt;top
      do
    {
    mapx=mxhold; mapy=myhold;     // Set to starting map values
    tempx=xpos;                   // Get starting x value for run
    do
      {
      // Check if current map position is in bounds, if not, skip
      if ((mapx&gt;=0)&amp;&amp;(mapx&lt;XMAP_MAX)&amp;&amp;(mapy&gt;=0)&amp;&amp;(mapy&lt;YMAP_MAX))
        {
        // Calculate current map coordinate location
        int loc=(XMAP_MAX*mapy)+mapx;
        // Get tile index values from the tile maps
        int prop_index=prop_map[level][loc];
        int xwall_index=xwall_map[level][loc];
        int ywall_index=ywall_map[level][loc];
        int base_index=base_map[level][loc];
        // Blit cell block tiles to screen in &quot;reverse&quot; order
        // if not of index 0 ( indicates nothing there )
        // 1st=Prop, 2nd=Xwall, 3rd=Ywall, 4th=Base
        if(prop_index) prop_tiles.blit(prop_index-1,
               tempx, tempy+PROP_YOFFSET, screenbuf);
        if(xwall_index) xwall_tiles.blit(xwall_index,
                tempx+XWALL_XOFFSET, tempy+WALL_YOFFSET,
                screenbuf);
        if(ywall_index) ywall_tiles.blit(ywall_index,
                tempx+YWALL_XOFFSET, tempy+WALL_YOFFSET,
                screenbuf);
        if((base_index)||(level==0)) base_tiles.blit(base_index,
                     tempx, tempy, screenbuf);
        }
      tempx+=CELL_FULL_WIDTH;  // Incr x position for next x move
      mapx+=1; mapy-=1;        // Incr map values for next x move
      }
    while ( tempx &lt;= (VIEWPORT_X_END+1) );
    tempy-=CELL_HALF_HEIGHT;   // Move y position up for next row
    xadd=-xadd;                // Flip xadd orientation
    xpos+=xadd;                // Add inc to x position
    if(xadd&gt;0)                 // If xadd is positive,
        myhold-=1;             //   decrease starting y map pos
    else                       // If xadd is negative,
        mxhold-=1;             //   increase starting y map pos
    }
      while ( tempy &gt;= (VIEWPORT_Y_START-CELL_FULL_HEIGHT) );
      // Adjust world coordinates in order to draw the next level
      x+=-LEVEL_ADJUST; y+=-LEVEL_ADJUST;
      }
    return;
    }
/*******************************************************************
 Function:  load_files();
 Purpose:   Reads files and loads data for engine into memory
 Arguments: none
 Comments:  returns 1 if successful
        returns 0 if error is encountered
*******************************************************************/
int load_files(void)
    {
    int j;
    // Load palette, and load in straight tile bitmaps
    FILE *in;
    if ((in = fopen(&quot;pics.wad&quot;, &quot;rb&quot;)) == NULL)
    {
    fprintf(stderr, &quot;Cannot find file: PICS.WAD \n&quot;);
    return(0);
    }
    fread(palette, sizeof(palette), 1, in);
    for (j=0; j&lt;BASE_COUNT; j++)
    fread(base_tiles.image[j], base_tiles.size, 1, in);
    for (j=0; j&lt;WALL_COUNT; j++)
    fread(xwall_tiles.image[j], xwall_tiles.size, 1, in);
    for (j=0; j&lt;WALL_COUNT; j++)
    fread(ywall_tiles.image[j], ywall_tiles.size, 1, in);
    for (j=0; j&lt;PROP_COUNT; j++)
    fread(prop_tiles.image[j], prop_tiles.size, 1, in);
    fclose(in);
    // Load in data for tile map arrays
    if ((in = fopen(&quot;map.wad&quot;, &quot;rb&quot;)) == NULL)
    {
    fprintf(stderr, &quot;Cannot find file: MAP.WAD \n&quot;);
    return(0);
    }
    fread(base_map, sizeof(base_map), 1, in);
    fread(xwall_map, sizeof(xwall_map), 1, in);
    fread(ywall_map, sizeof(ywall_map), 1, in);
    fread(prop_map, sizeof(prop_map), 1, in);
    fclose(in);
    return(1);
    }
</pre>
<h4><a name="02d4_010a"><a name="02d4_010b">Listing Three<a name="02d4_010b"></h4><pre>
/********************************************************************
 TILE.H
 Header file for the Tile class of the Axoview Engine v1.0
 Contains the Tile class declaration.
 Written by Nate Goudie  1996
********************************************************************/
class Tile
    {
    // Make everything public
    public:
    char far **image;       // Pointer to array of tile bitmaps
    int width,height;       // Width and height of tile bitmap
    int size;               // size of tile bitmap (in bytes)
    //Constructor for tile class:
    Tile(int num_tiles,int w,int h);
    // Function to draw tile into offscreen buffer
    void blit(int tile_num,int x,int y,
        unsigned char far *screen);
    };
</pre>
<h4><a name="02d4_010c"><a name="02d4_010d">Listing Four<a name="02d4_010d"></h4><pre>
/********************************************************************
 TILE.CPP
 The Tile class for the Axoview Engine v1.0
 - a class to handle the containment and drawing of tiles
 Contains the Tile class functions.
 Written by Nate Goudie  1996
********************************************************************/
#include    &lt;stdio.h&gt;
#include    &lt;alloc.h&gt;
#include    &lt;mem.h&gt;
#include    &quot;tile.h&quot;
// Declare constants for the viewport clipping
#define XMIN 0
#define XMAX 319
#define YMIN 0
#define YMAX 199
#define SCREENWIDTH 320
#define SCREENHEIGHT 200
/*******************************************************************
 Function:  Tile::Tile();
 Purpose:   The Tile class constructor
 Arguments: num_tiles     - number of tiles (bitmaps)
        w             - width of the tile in pixels (bytes)
        h             - height of the tile in pixels (bytes)
 Comments:  Will compute size of each tile in bytes, and will
        allocate memory for the tile bitmaps
*******************************************************************/
Tile::Tile(int num_tiles,int w,int h)
    {
    width=w;
    height=h;
    // Calculate size of tile bitmap
    size=w*h;
    // Allocate memory for tile bitmaps
    image=new char far *[num_tiles];
    for (int j=0; j&lt;num_tiles; j++)
    image[j]=new char[size];
    }
/*******************************************************************
 Function:  Tile::blit();
 Purpose:   Tile class function which blits the indicated tile
         bitmap to an offscreen buffer using the
         &quot;Reverse Painter's Algorithm&quot;.
         Handles clipping and tile transparency.
 Arguments: tile_num      - index of tile bitmap to display
         x, y          - offscreen coordinates where the tile
                 should be drawn
         screen        - pointer to offscreen buffer
 Comments:  The destination buffer (screen) must be 320x200.
*******************************************************************/
void Tile::blit(int tile_num, int x, int y, unsigned char far *screen)
    {
    int txstart=0, txend=width, tystart=0, tyend=height;
    // Perform clipping before main loop
    // Clip tile to viewport and set boundaries to blit through
    if (x&lt;XMIN)
    txstart=XMIN-x;
    if (y&lt;YMIN)
    tystart=YMIN-y;
    if ((x+width-1)&gt;XMAX)
    txend=XMAX-x+1;
    if ((y+height-1)&gt;YMAX)
    tyend=YMAX-y+1;
    // Calculate tile and buffer starting offsets
    int toffset = (tystart*width)+txstart;
    int poffset = (y+tystart)*SCREENWIDTH+(x+txstart);
    // Calculate next row increments
    int toffinc = ((width-txend)+txstart);
    int poffinc = (SCREENWIDTH-(txend)+txstart);
    // Dereference one of the pointers to the tile bitmap for speed
    char far *tileimage = image[tile_num];
    // Now loop through and copy the tile bitmap to the screen buffer
    for(int row=0; row&lt;(tyend-tystart); row++)
    {
    for(int column=0; column&lt;(txend-txstart); column++)
        {
        // Get pixel from the offscreen buffer
        int dest_pixel=screen[poffset];
        // Check if it is transparent (0), if so, copy
        // the tile bitmap's pixel over it
        if (!dest_pixel)
        screen[poffset] = tileimage[toffset];
        poffset++; toffset++;
        }
    // Jump to start of next row
    toffset+=toffinc;
    poffset+=poffinc;
    }
    return;
    }
End Listings
</pre>
<P>

<P>

<P>

<P>

<P>

<P>

<P>

<P>

<P>

<P>

</BODY></HTML>
