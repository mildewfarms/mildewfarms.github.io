<HTML>
<META NAME="year" CONTENT="1996">
<HEAD>
<!-- This document was built using HyperWriter Professional by NTERGAID Inc. -->
<TITLE>SP 96: RAMBLINGS IN REAL TIME</TITLE></HEAD>
<body bgcolor="FFFFFF">
<h1>RAMBLINGS IN REAL TIME<a name="0312_00fe"><a name="0312_00fe"><a name="0312_00fc"><a name="0312_0000"></h1><P>

<h2>Quake's Hidden-Surface Removal</h2><P>

<h3>Michael Abrash</h3><P>

<P>
<i><a name="0312_00fd"><a name="0312_0000">Michael is the author of Zen of Graphics Programming, Second Edition, and Zen of Code Optimization. He is currently pushing the envelope of real-time 3-D on Quake at id Software. He can be contacted at mikeab@idsoftware.com.</i></p><hr><P>

Okay, I admit it. I'm sick and tired of classic rock. Admittedly, it's been a while--about 20 years--since I was excited to hear anything by the Cars or Boston, and I was never particularly excited about Bob Seger or Queen--to say nothing of Elvis--so some things haven't changed. But I knew something was up when I found myself changing the station on the Allman Brothers and Steely Dan and Pink Floyd and, God help me, the Beatles (just stuff like &quot;Hello Goodbye&quot; and &quot;I'll Cry Instead,&quot; though, not &quot;Ticket to Ride&quot; or &quot;A Day in the Life;&quot; I'm not that far gone). It didn't take long to figure out what the problem was; I'd been hearing the same songs for a quarter of a century, and I was bored.<P>

I tell you this to explain why, when my daughter and I drove back from dinner the other night, the radio in my car was tuned, for the first time ever, to a station using the slogan &quot;There is no alternative.&quot;<P>

Now, we're talking here about a ten-year-old who worships the Beatles and has been raised on a steady diet of oldies. She loves melodies, catchy songs, and good singers, none of which you're likely to find on an alternative rock station. So it's no surprise that when I turned on the radio, the first word out of her mouth was &quot;Yuck!&quot;<P>

What did surprise me was that after listening for a while, she said, &quot;You know, Dad, it's actually kind of interesting.&quot;<P>

Apart from giving me a clue as to what sort of music I'll hear blasting through our house when she's a teenager, her quick uptake on alternative rock reminded me of something that it's easy to forget as we become older: It's essential to keep an open mind, and to be willing--better yet, eager--to try new things. Programmers tend to become attached to familiar approaches, and are inclined to stick with whatever is currently doing the job adequately, but in programming there are always alternatives.<P>

Not that I should have needed any reminding, considering the ever-evolving nature of <I>Quake</I>.<P>

<h3><a name="0312_00ff">Creative Flux<a name="0312_00ff"></h3><P>

In my January/February column, I described the creative flux that led to John Carmack's decision to use a precalculated, potentially visible set (PVS) of polygons for each possible viewpoint in <I>Quake</I>, the game we're developing at id Software. The precalculated PVS meant that instead of having to spend a lot of time searching through the world database to find out which polygons were visible from the current viewpoint, we could simply draw all the polygons in the PVS from back to front (getting the ordering from the world BSP tree; check out my May/June, July/August, and November/December 1995 columns for a discussion of BSP trees). This draws the correct scene with no searching at all, letting the back-to-front drawing perform the final stage of hidden-surface removal (HSR). This was a terrific idea, but it was far from the end of the road for <I>Quak</I><I>e</I>'s design.<P>

<h3><a name="0312_0100">Drawing Moving Objects<a name="0312_0100"></h3><P>

For one thing, there was still the question of how to sort and draw moving objects properly; in fact, this is the question I've been asked most often since the January/ February column came out, so I'll take a moment to address it. The primary problem is that a moving model can span multiple BSP leaves, and the leaves that are touched vary as the model moves. That, together with the possibility of multiple models in one leaf, means there's no easy way to use BSP order to draw the models in correctly sorted order. When I wrote the January/February column, we were drawing sprites (such as explosions), moveable BSP models (such as doors), and polygon models (such as monsters) by clipping each into all the leaves it touched, then drawing the appropriate parts as each BSP leaf was reached in back-to-front traversal. However, this didn't solve the issue of sorting multiple moving models in a single leaf against each other, and also left some ugly sorting problems with complex polygon models.<P>

John solved the sorting issue for sprites and polygon models in a startlingly low-tech way: We now z-buffer them. (That is, before we draw each pixel, we compare its distance, or z value, with the z value of the pixel currently on the screen, drawing only if the new pixel is nearer than the current one.) First, we draw the basic world--walls, ceilings, and the like. No z-buffer testing is involved at this point (the world visible-surface determination is done in a different way, as we'll soon see); however, we do fill the z-buffer with the z values (actually, 1/z values, also discussed later) for all the world pixels. Z-filling is a much faster process than z-buffering the entire world, because no reads or compares are involved, just writes of z values. Once drawing and z-filling the world are done, we can simply draw the sprites and polygon models with z-buffering and get perfect sorting all around.<P>

Whenever a z-buffer is involved, two questions inevitably arise: What's the memory footprint, and what's the performance impact? The memory footprint at 320x200 is 128 KB, not trivial but not a big deal for a game that requires 8 MB. The performance impact is about 10 percent for z-filling the world, and roughly 20 percent (with lots of variation) for drawing sprites and polygon models. In return, we get a perfectly sorted world, and the ability to do additional effects, such as particle explosions and smoke, because the z-buffer lets us flawlessly sort such effects into the world. All in all, the use of the z-buffer vastly improved the visual quality and flexibility of the <I>Quake</I> engine, and also simplified the code quite a bit, at an acceptable memory and performance cost.<P>

<h3><a name="0312_0101">Leveling and Improving Performance<a name="0312_0101"></h3><P>

As I said before, in the <I>Quake</I> architecture, the world itself is drawn first--without z-buffer reads or compares, but filling the z-buffer with the world polygons' z values--and then the moving objects are drawn on top of the world, using full z-buffering. Thus far, I've discussed how to draw moving objects. For the rest of this column, I'm going to talk about the other part of the drawing equation: How to draw the world itself, where the entire world is stored as a single BSP tree, and never moves.<P>

As you may recall from the January/ February column, we're concerned with both raw performance and level performance. That is, we want the drawing code to run as fast as possible, but we also want the difference in drawing speed between the average scene and the slowest-drawing scene to be as small as possible. It does little good to average 30 frames per second (fps) if 10 percent of the scenes draw at 5 fps, because the jerkiness of those scenes is extremely obvious by comparison, and highly objectionable. It's better to average 15 fps 100 percent of the time.<P>

The precalculated PVS was an important step toward both faster and more level performance, because it eliminated the need to identify visible polygons, a relatively slow step that tended to be at its worst in the most complex scenes. Nonetheless, in some spots in the game, the precalculated PVS contains five times more polygons than are actually visible; together with the back-to-front HSR approach, this created hot spots where the frame rate bogged down visibly as hundreds of polygons were drawn back to front, most of which were immediately overdrawn by nearer polygons. Raw performance in general was also reduced by the typical 50 percent overdraw resulting from drawing everything in the PVS. So, although drawing the PVS back to front as the final HSR stage worked and was an improvement over previous designs, it was not ideal. Surely, John thought, there's a better way to leverage the PVS than back-to-front drawing. And indeed there is.<P>

<h3><a name="0312_0102">Sorted Spans<a name="0312_0102"></h3><P>

The ideal final HSR stage for <I>Quake</I> would reject all the polygons in the PVS that are actually invisible, and draw only the visible pixels of the remaining polygons, with no overdraw--that is, with every pixel drawn exactly once--all at no performance cost, of course. One way to do that (although certainly not at zero cost) would be to draw the polygons from front to back, maintaining a region describing the currently occluded portions of the screen and clipping each polygon to that region before drawing it. That sounds promising, but it is in fact nothing more or less than the beam tree approach I described in the January/February column, an approach that we found to have considerable overhead and serious leveling problems.<P>

We can do much better if we move the final HSR stage from the polygon level to the span level and use a sorted-spans approach. In essence, this approach consists of turning each polygon into a set of spans, as shown in <a href="9615d1f1.gif">Figure 1</A>, and then sorting and clipping the spans against each other until only the visible portions of visible spans are left to be drawn, as shown in <a href="9615d1f2.gif">Figure 2</A>. This may sound a lot like z-buffering (which is simply too slow for drawing the world, although it's fine for smaller moving objects, as described earlier), but there are crucial differences. In contrast with z-buffering, only visible portions of visible spans are scanned out pixel by pixel (although all polygon edges must still be rasterized). Better yet, the sorting that z-buffering does at each pixel becomes a per-span operation with sorted spans, and because of the coherence implicit in a span list, each edge is sorted against only some of the spans on the same line, and clipped only to the few spans that it overlaps horizontally. Although complex scenes still take longer to process than simple scenes, the worst case isn't as bad as with the beam tree or back-to-front approaches, because there's no overdraw or scanning of hidden pixels, because complexity is limited to pixel resolution, and because span coherence tends to limit the worst-case sorting in any one area of the screen. As a bonus, the output of sorted spans is in precisely the form that a low-level rasterizer needs: a set of span descriptors, each consisting of a start coordinate and a length.<P>

In short, the sorted spans approach meets our original criteria pretty well: Although it isn't zero-cost, it's not horribly expensive, it completely eliminates both overdraw and pixel scanning of obscured portions of polygons, and it tends to level worst-case performance. We wouldn't want to rely on sorted spans alone as our hidden-surface mechanism, but the precalculated PVS reduces the number of polygons to a level that sorted spans can handle quite nicely.<P>

So we've found the approach we need; now it's just a matter of writing some code and we're on our way, right? Well, yes and no. Conceptually, the sorted-spans approach is simple, but it's surprisingly difficult to implement, with a couple of major design choices to be made, a subtle mathematical element, and some tricky gotchas that we'll see in the next column. Let's look at the design choices first.<P>

<h3><a name="0312_0103">Edges versus Spans<a name="0312_0103"></h3><P>

The first design choice is whether to sort spans or edges (both of which fall into the general category of &quot;sorted spans&quot;). Although the results are the same both ways--a list of spans to be drawn, with no overdraw--the implementations and performance implications are quite different, because the sorting and clipping are performed using very different data structures.<P>

With span sorting, spans are stored in x-sorted, linked-list buckets, typically with one bucket per scan line. Each polygon, in turn, is rasterized into spans, as shown in <a href="9615d1f1.gif">Figure 1</A>, and each span is sorted and clipped into the bucket for the scan line the span is on, as shown in <a href="9615d1f2.gif">Figure 2</A>, so that at any time each bucket contains the nearest spans encountered thus far, always with no overlap. This approach involves generating all spans for each polygon, in turn, with each span immediately being sorted, clipped, and added to the appropriate bucket.<P>

With edge sorting, edges are stored in x-sorted, linked-list buckets according to their start scan line. Each polygon, in turn, is decomposed into edges, cumulatively building a list of all the edges in the scene. Once all edges for all polygons in the view frustum have been added to the edge list, the whole list is scanned out in a single top-to-bottom, left-to-right pass. An active edge list (AEL) is maintained. With each step to a new scan line, edges that end on that scan line are removed from the AEL, active edges are stepped to their new x coordinates, edges starting on the new scan line are added to the AEL, and the edges are sorted by the current x coordinate.<P>

For each scan line, a z-sorted active polygon list (APL) is maintained. The x-sorted AEL is stepped through in order. As each new edge is encountered (that is, as each polygon starts or ends as we move left to right), the associated polygon is activated and sorted into the APL, as shown in <a href="9615d1f3.gif">Figure 3</A>, or deactivated and removed from the APL, as shown in <a href="9615d1f4.gif">Figure 4</A>, for a leading or trailing edge, respectively. If the nearest polygon has changed (that is, if the new polygon is nearest, or if the nearest polygon just ended), a span is emitted for the polygon that just stopped being the nearest, starting at the point where the polygon first became nearest and ending at the x coordinate of the current edge, and the current x coordinate is recorded in the polygon that is now the nearest. This saved coordinate later serves as the start of the span emitted when the new nearest polygon ceases to be in front.<P>

Don't worry about following all of that; this is just a quick overview of edge sorting to help make the rest of this column clearer. There will be a more thorough discussion in my next column.<P>

The spans generated with edge sorting are exactly the same spans that ultimately emerge from span sorting; the difference lies in the intermediate data structures used to sort the spans in the scene. With edge sorting, the spans are kept implicit in the edges until the final set of visible spans is generated, so the sorting, clipping, and span emission is done as each edge adds or removes a polygon, based on the span state implied by the edge and the set of active polygons. With span sorting, spans are immediately made explicit when each polygon is rasterized, and those intermediate spans are then sorted and clipped against the other spans on the scan line to generate the final spans, so the states of the spans are explicit at all times, and all work is done directly with spans.<P>

Both span sorting and edge sorting work well, and have been employed successfully in commercial projects. We've chosen to use edge sorting in <I>Quake</I> partly because it seems inherently more efficient, with excellent horizontal coherence, which makes for quick sorting, in contrast with the potentially costly sorting into linked lists involved in span sorting. A more important reason, though, is that with edge sorting we're able to share edges between adjacent polygons, and that cuts the work involved in sorting, clipping, and rasterizing edges nearly in half, while also shrinking the world database quite a bit.<P>

One final advantage of edge sorting is that it makes no distinction between convex and concave polygons. That's not an important consideration for most graphics engines, but in <I>Quake</I>, edge clipping, transformation, projection, and sorting has become a major bottleneck, so we're doing everything we can to get the polygon and edge counts down, and concave polygons help a lot in that regard. While it's possible to handle concave polygons with span sorting, that can involve significant performance penalties.<P>

Nonetheless, there's no cut-and-dried answer as to which approach is better. In the end, span sorting and edge sorting amount to the same functionality, and the choice between them is a matter of whatever you feel most comfortable with. In the next column, I'll go into considerable detail about edge sorting, complete with a full implementation. I'm going the spend the rest of this column laying the foundation for next time by discussing sorting keys and 1/<I>z</I> calculation. In the process, I'm going to have to make a few forward references to aspects of edge sorting that I haven't covered in detail; my apologies, but it's unavoidable, and all should become clear by the end of the next column.<P>

<h3><a name="0312_0104">Edge-sorting Keys<a name="0312_0104"></h3><P>

Now that we know we're going to sort edges, using them to emit spans for the polygons nearest the viewer, the question becomes telling which polygons are nearest. Ideally, we'd just store a sorting key in each polygon, and whenever a new edge came along, we'd compare its surface's key to the keys of other currently active polygons, and easily tell which polygon was nearest. That sounds too good to be true, but it is possible. If, for example, your world database is stored as a BSP tree, with all polygons clipped into the BSP leaves, then BSP walk order is a valid drawing order. So, for example, if you walk the BSP back to front, assigning each polygon an incrementally higher key as you reach it, polygons with higher keys are guaranteed to be in front of polygons with lower keys. This is the approach <I>Quake</I> used for a while, although a different approach is now being used, for reasons I'll explain shortly.<P>

If you don't happen to have a BSP or similar data structure handy, or if you have lots of moving polygons (BSPs don't handle moving polygons very efficiently), another way to accomplish our objectives would be to sort all the polygons against one another before drawing the scene, assigning appropriate keys based on their spatial relationships in viewspace. Unfortunately, this is generally an extremely slow task, because every polygon must be compared to every other polygon. There are techniques to improve the performance of polygon sorts, but I don't know of anyone who's doing general polygon sorts of complex scenes in real time on a PC.<P>

An alternative is to sort by z distance from the viewer in screenspace, an approach that dovetails nicely with the excellent spatial coherence of edge sorting. As each new edge is encountered on a scan line, the corresponding polygon's z distance can be calculated and compared to the other polygons' distances, and the polygon can be sorted into the APL accordingly.<P>

Getting z distances can be tricky, however. Remember that we need to be able to calculate z at any arbitrary point on a polygon, because an edge may occur and cause its polygon to be sorted into the APL at any point on the screen. We could calculate z directly from the screen x- and y-coordinates and the polygon's plane equation, but unfortunately this can't be done very quickly, because the z for a plane doesn't vary linearly in screenspace; however, 1/z <I>does</I> vary linearly, so we'll use that instead. (See Chris Hecker's series of columns on texture mapping over the past year in <I>Game Developer</I> magazine for a discussion of screenspace linearity and gradients for 1/z.) Another advantage of using 1/z is that its resolution increases with decreasing distance, meaning that by using 1/z, we'll have better depth resolution for nearby features, where it matters most.<P>

The obvious way to get a 1/z value at any arbitrary point on a polygon is to calculate 1/z at the vertices, interpolate it down both edges of the polygon, and interpolate between the edges to get the value at the point of interest. Unfortunately, that requires doing a lot of work along each edge, and worse, requires division to calculate the 1/z step per pixel across each span.<P>

A better solution is to calculate 1/z directly from the plane equation and the screen x and y of the pixel of interest. The equation is <I>1/z = (a/d)x' - (b/d)y' + c/d,</I> where <I>z</I> is the viewspace z coordinate of the point on the plane that projects to screen coordinate (<I>x',</I><I>y</I><I>'</I>) (the origin for this calculation is the center of projection, the point on the screen straight ahead of the viewpoint), [<I>a b </I><I>c</I>] is the plane normal in viewspace, and <I>d</I> is the distance from the viewspace origin to the plane along the normal. Division is done only once per plane, because <I>a</I>, <I>b</I>, <I>c</I>, and <I>d</I> are per-plane constants.<P>

The full 1/z calculation requires two multiplies and two adds, all of which should be floating point to avoid range errors. That much floating-point math sounds expensive but really isn't, especially on a Pentium, where a plane's 1/z value at any point can be calculated in as little as six cycles in assembly language.<P>

For those of you who are interested, here's a quick derivation of the 1/z equation. The plane equation for a plane is <I>ax+ by + cz-d = 0</I>, where <I>x</I> and <I>y</I> are viewspace coordinates, and <I>a</I>, <I>b</I>, <I>c</I>, <I>d</I>, and <I>z</I> are defined above. If you substitute <I>x=x'z</I> and <I>y</I><I>=</I><I>-y'z</I> (from the definition of the perspective projection, with <I>y</I> inverted because <I>y</I> increases upward in viewspace but downward in screenspace), and do some rearrangement, you get <I>z = d / (ax' - by' + c)</I>. Inverting and distributing yields <I>1/z = ax'/d - by'/d + c/d</I>. You'll see 1/z sorting in action next time.<P>

<h3><a name="0312_0105"><I>Quake</I> and z Sorting<a name="0312_0105"></h3><P>

I mentioned that <I>Quake</I> no longer uses BSP order as the sorting key; in fact, it uses 1/z as the key now. Elegant as the gradients are, calculating 1/z from them is clearly slower than just doing a compare on a BSP-ordered key, so why have we switched <I>Quake</I> to 1/z?<P>

The primary reason is to reduce the number of polygons. Drawing in BSP order means following certain rules, including the rule that polygons must be split if they cross BSP planes. This splitting increases the numbers of polygons and edges considerably. By sorting on 1/z, we're able to leave polygons unsplit but still get a correct drawing order, so we have far fewer edges to process and faster drawing overall, despite the added cost of 1/z sorting.<P>

Another advantage of 1/z sorting is that it solves the sorting issues (mentioned before) involving moving models that are themselves small BSP trees. Sorting in world BSP order wouldn't work here, because these models are separate BSPs, and there's no easy way to work them into the world BSP's sequence order. We don't want to use z buffering for these models because they're often large objects such as doors, and we don't want to lose the overdraw-reduction benefits that closed doors provide when drawn through the edge list. With sorted spans, the edges of moving BSP models are simply placed in the edge list (first clipping polygons so they don't cross any solid world surfaces, to avoid complications associated with interpenetration), along with all the world edges, and 1/z sorting takes care of the rest.<P>

<h3><a name="0312_0106">Onward to Next Time<a name="0312_0106"></h3><P>

There is, without a doubt, an awful lot of information in the preceding pages, and it may not all connect yet in your mind. The code and accompanying explanation next time should help; if you want to peek ahead, the code should be available electronically (see &quot;Availability,&quot; page 3) and from ftp.idsoftware.com/mikeab/ddjdsort.zip by the time you read this column. You may also want to take a look at <I>Computer Graphics: Principles and Practice</I>, by James Foley and Andries van Dam (Addison-Wesley, 1992) or <I>Procedural Elements of Computer Graphics</I>, by David F. Rogers (McGraw-Hill, 1985). <P>

As I write this, it's unclear whether <I>Quake</I> will end up sorting edges by BSP order or 1/z. Actually, there's no guarantee that sorted spans in any form will be the final design. Sometimes it seems like we change graphics engines as often as they play Elvis on the '50s oldies stations (but, one would hope, with more aesthetically pleasing results!), and no doubt we'll be considering the alternatives right up until the day we ship.<P>

<h4><B><a href="9615d1f1.gif">Figure 1</A>:</B> Span generation.</h4><P>

<h4><B><a href="9615d1f2.gif">Figure 2</A>:</B> The spans from polygon A from <a href="9615d1f1.gif">Figure 1</A>, sorted and clipped with the spans from polygon B, where polygon A is at a constant z distance of 100 and polygon B is at a constant z distance of 50 (B is closer).</h4><P>

<h4><B><a href="9615d1f3.gif">Figure 3</A>:</B> Activating a polygon when a leading edge is encountered in the AEL.</h4><P>

<h4><B><a href="9615d1f4.gif">Figure 4</A>:</B> Deactivating a polygon when a trailing edge is encountered in the AEL.</h4><P>

</BODY></HTML>
