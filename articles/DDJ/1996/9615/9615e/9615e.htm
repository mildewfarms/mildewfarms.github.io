<HTML>
<META NAME="year" CONTENT="1996">
<HEAD>
<!-- This document was built using HyperWriter Professional by NTERGAID Inc. -->
<TITLE>SP 96: A MIDI Class in C++</TITLE></HEAD>
<body bgcolor="FFFFFF">
<h1>A MIDI Class in C++<a name="0304_00fa"><a name="0304_00fa"><a name="0304_00f8"><a name="0304_0000"></h1><P>

<h2>Using VisualAge C++ collection classes</h2><P>

<h3>George Wright</h3><P>

<P>
<i><a name="0304_00f9"><a name="0304_0000">George has been a member of the information systems/decision sciences department at Loyola College in Baltimore since 1987. He can be reached at geo@loyola.edu.</i></p><hr><P>

The musical instrument digital interface (MIDI) specification spells out a compact, digital representation of a piece of music. The MIDI file format was established under the auspices of the International MIDI Association to standardize the way keyboards and synthesizers send and receive musical data. By the mid-1980s, PCs were being used to control synthesizers, and MIDI programming began to evolve. Most of us who have programmed for MIDI have built on the work of Jim Conger and Michael Czeiszperger, authors of numerous books and articles on the subject. Their work was the inspiration for this article.<P>

In connection with one MIDI project, I needed to convert some old MIDI routines in C to C++. Because the hierarchical structure of a MIDI file lends itself to the object paradigm, implementing MIDI object classes seemed to be the ideal approach. The abstraction of the object classes greatly simplifies the programming (once the classes are written, of course).<P>

Given MIDI classes with basic functionality, application programs for MIDI-file manipulation are greatly simplified. Quick-and-dirty programs of three or four lines can read in a MIDI file, display it as a human-readable musical score, add a missing key signature, extract a particular track to another MIDI file, or transpose the key of the file (with appropriate key-signature changes for scoring programs). In this article, I'll present MIDI classes and several example programs.<P>

<h3><a name="0304_00fb">MIDI Files and Events<a name="0304_00fb"></h3><P>

A MIDI file consists of a collection of one or more tracks. Format 0 MIDI files have all events in one track; format 1 MIDI files (the most common) have multiple tracks. The &quot;conductor track&quot; in a format 1 file contains all necessary information on tempo, key signature, title, copyright notice, and the like. The conductor track is usually track 1. Other tracks contain musical information, usually one track per instrument represented in the piece of music. Each instrumental or channel track consists of many events. Channel events produce, change, or stop a musical note. Such events include a note-on event, a note-off event, an event signaling action of a pedal or lever, an event modifying the sustain or volume of a note, or a pitch-changing event.<P>

Along with the usual channel events, there are other events called &quot;metaevents,&quot; which include the information events in the conductor's track, instrument names, lyrics, and cue points. System-exclusive events signal the beginning or continuation of a series of arbitrary bytes, of meaning only to the particular device receiving them. No matter what the type, each MIDI event consists of a time, type signature, and series of data bytes. <P>

<a href="9615e.htm#0304_0107">Listing One</A> presents the event header file, EVENT.H. Note that the <I>MIDI event</I> class has three private data members. The <I>m_DeltaTime</I> member is the elapsed time since the last event in the same track. The time is measured in arbitrary ticks. Actual elapsed time depends on the tempo established in the conductor's track. Member <I>m_EventType</I> is one of an enumeration of types: <P>

<ul>
<li><I>Channel</I> is an event on a certain channel, such as a note. </li>
<li><I>Meta</I> is a metaevent, such as text.</li>
<li><I>SysEx</I> is an event exclusive to a certain type of MIDI equipment.</li>
<li><I>SysExCont</I> is a continued system exclusive.</li>
<li><I>Undefined</I> is an unknown type of event.</li>
<li><I>Error</I> indicates an error condition. </li>
</ul>

Member <I>m_Data</I> is an array of bytes of type <I>CByteArray</I>. The class <I>CByteArray</I> takes advantage of the collection classes that are available with IBM's VisualAge C++ for OS/2. Using the statement, <I>typedef ISequence &lt;char&gt; CByteArray </I>allows you to take advantage of the <I>ISequence</I> template. This gives you access to an efficient implementation of an abstract class with a complete, systematic combination of basic properties; see <a href="9615e.htm#0304_0101">Figure 1</A>. Using the <I>ISequence</I> template gives you a byte array with a full set of methods for adding, locating, testing, and removing the data bytes of a MIDI event.<P>

<a href="9615e.htm#0304_0107">Listing One</A> shows the usual complement of methods for an abstract class: constructors, destructors, operations, and member <I>get</I> and <I>set</I> functions. The workhorse functions--<I>WriteData()</I> and <I>ReadData(</I><I>)</I>--handle MIDI event I/O to and from a stream. There's also a <I>Printf()</I> function that outputs a formatted, readable MIDI event dump to <I>cout</I>. The implementation of the event functions appears in <a href="9615e.htm#0304_0109">Listing Two</A>. <I>ReadData()</I> is the most elaborate, because it has to cope with the wide variety of MIDI events, plus some other wrinkles. For one thing, different channel events have different numbers of data bytes involved. This is easily handled (after Czeiszperger) with a static table of additional bytes needed.<P>

Another wrinkle with reading (and writing) MIDI events is the concept of running status. This concept is used to cut down on the number of bytes that must be transmitted in the MIDI stream. If running status is set, the byte indicating the type of event is skipped. It's assumed that the current event type is the same as the last. Since most of the events are four bytes long, this usually yields a 25 percent savings. When the high bit in the high-order byte is set, it indicates running status is set.<P>

A third wrinkle is apparent in the private methods of the <I>event</I> class. The <I>GetVar</I>, <I>PutVar</I>, <I>ReadVar</I>, and <I>WriteVar</I> functions are necessary to deal with variable-length numbers. In the interest of efficiency, the MIDI specification requires that the number of bytes used to represent a number be minimal. Only the number of bytes needed to represent a number is used. In a variable-length number, the last byte has the most-significant bit (MSB) cleared; all other bytes have it set. As a variable-length number is read, bytes are read until one with the MSB cleared is found. The 7-bit values are then reassembled into 8-bit bytes.<P>

Also apparent in <a href="9615e.htm#0304_0109">Listing Two</A> is the heavy use of the <I>ISequence</I> collection class methods as member functions of the <I>m_Data</I> byte array. Functions such as <I>numberOfElements()</I>, <I>elementAtPosition()</I>, and <I>addAsLast()</I> all come from the <I>ISequence</I> template in <a href="9615e.htm#0304_0101">Figure 1</A>. <P>

The last line of code in <a href="9615e.htm#0304_0107">Listing One</A>, <I>typedef ISequence &lt;CEvent&gt; CEventArray;</I> again makes use of the <I>ISequence</I> template to generate a new class, <I>CEventArray</I>. The <I>CEventArray</I> class, to be used as a member of each MIDI track, has all the functionality declared in <a href="9615e.htm#0304_0101">Figure 1</A>.<P>

<h3><a name="0304_00fc">MIDI Tracks<a name="0304_00fc"></h3><P>

A MIDI track consists of a header, track length, and number of events. The <I>track </I>class defined in track.h (available electronically; see &quot;Availability,&quot; page 3) represents a MIDI track. Every MIDI track has a track signature, MTrk. Since all tracks have the same signature, you can represent the header as a static member. I make use of the <I>String</I> class, also included with VisualAge C++, to store the track header. The <I>String</I> class is similar to string-handling routines commonly found in C++ textbooks. Track length is stored as an unsigned 32-bit integer. The declaration uses UINT32, <I>typedef</I>ed as an unsigned <I>long</I>. The events that make up the rest of the track are handled compactly by the <I>CEventArray</I> type, <I>typedef</I>ed to an <I>ISequence</I> of <I>CEven</I><I>t</I>s.<P>

track.h also shows the usual constructors, destructors, operators, <I>get</I> and <I>set</I> functions, and utility functions. These are implemented in the MIDI track class implementation; see track.cpp (available electronically). Implementation of the <I>track </I>class is much shorter than the implementation of the <I>event </I>class, because you're able to build on the event code as well as on the <I>ISequence</I> code.<P>

<I>ReadTrack</I>, the <I>track </I>class member function for reading a MIDI track, simply clears an event buffer, calls <I>ReadData</I> for the event buffer, adds the event to the <I>CEventArray</I> member, and loops until no more events remain. The <I>WriteTrack</I> function steps through the <I>CEventArray</I>, calling the event <I>WriteData</I> function for each. Both the <I>ReadTrack</I> and <I>WriteTrack</I> functions make use of utility functions for reading and writing 32-bit unsigned integers. These functions, adapted from David Charlap (see &quot;The BMP File Format, Part I,&quot; <I>Dr. Dobb's Journal</I>, March 1995), are available electronically. They let you handle 16- and 32-bit quantities without worrying about the underlying byte-ordering of the host platform. The track implementation closes with another invocation of the <I>ISequence</I> template. This gives all the functionality of <a href="9615e.htm#0304_0101">Figure 1</A> for a collection of MIDI tracks.<P>

<h3><a name="0304_00fd">MIDI Files<a name="0304_00fd"></h3><P>

The file midi.cpp (available electronically) shows the definition of the MIDI file object. The file midi.h (also available electronically) contains the private members of the object. Each MIDI file begins with the header MThd. The <I>m_MThd</I> member is stored as a static <I>String</I> object, since you only need one copy no matter how many MIDI files you have. The header length <I>m_HeaderLength</I> can also be stored as static, because it never varies from file to file.<P>

The MIDI file specification defines three formats, called simply &quot;0,&quot; &quot;1,&quot; and &quot;2.&quot; A piece of music can be stored in a MIDI file of any of the three formats and still sound the same when the file is played. It's just a matter of how the data is stored internally. In type 0 format, all information is stored in a single, multichannel track. Type 1 format, the most common, stores several simultaneous tracks with the same tempo and time signature. Type 2 allows for multiple tracks, each with its own tempo and time signature. Only types 0 and 1 are supported by this code.<P>

The number of tracks in the file is stored in <I>m_TrackCount</I>. The member <I>m_Division</I> contains information about timing. If the most significant of the 16 bits is cleared, the remaining 15 bits indicate the resolution of a quarter note in ticks per quarter note. If the MSB is set, the rest of the high byte is the Society of Motion Picture and Television Engineers (SMPTE) frame rate, and the low byte is the resolution of a frame in ticks per frame. SMPTE timing is a standardized time code used in the analog world of tape and video recording. In such applications, SMPTE timing can synchronize MIDI events to external events, such as actions on an accompanying video tape track. SMPTE timing is not supported in this code. The last member of the MIDI object is <I>m_TrackArray</I>, the collection of one or more tracks. The data type is the <I>CTrackArray</I> class, generated from the <I>ISequence</I> template in track.cpp, the track implementation.<P>

The MIDI object implementation (midi .cpp) mimics the track implementation in that most operations call corresponding methods for constituent tracks. The MIDI object is the only one that has methods to read from and write to disk. <I>Export</I> simply writes the header items and then steps through the <I>CTrackArray</I> in <I>m_TrackArray</I>, calling the <I>WriteTrack</I> function for each track. The <I>Import</I> function uses <I>m_TrackCount</I> to loop through clearing each track buffer, calling <I>ReadTrack</I>, and calling <I>ISequenc</I><I>e</I><I>::addAsLast</I> to install the track into <I>m_TrackArray</I>.<P>

<h3><a name="0304_00fe">Using the Classes<a name="0304_00fe"></h3><P>

Once all the up-front work of class definition is done, the MIDI file becomes an abstract data type (ADT). This leads to very short application programs. The musical fragment in <a href="9615a5f2.gif">Figure 2</A> shows the power of the MIDI ADT. This is the file Czeiszperger treats in detail (see &quot;References&quot;) as an example. (For the sake of convenience, I've changed Czeiszperger's type 0 file to a type 1 MIDI file.) <a href="9615a5f2.gif">Figure 2</A> shows no key signature, suggesting that the fragment is in the key of C major or the key of A minor. A closer look at the second measure shows a D-minor chord. It's probably either a fragment of a piece in A minor with an unresolved subdominant D-minor chord or a piece in D minor with a missing key signature.<P>

Might there be any text metaevents in the MIDI file that would provide you with a clue as to the proper key signature? <a href="9615e.htm#0304_0103">Example 1</A> will print the contents of the MIDI file named &quot;cz.mid,&quot; the file that appears in score in <a href="9615a5f2.gif">Figure 2</A>. <a href="9615e.htm#0304_0102">Figure 3</A> is a partial listing of the result, showing only track 1, where you would expect to find a key signature. The track contains a time signature, a tempo, and a title, but there is no key signature. This isn't a surprise. Many MIDI files, never intended for scoring as in <a href="9615a5f2.gif">Figure 2</A>, lack the proper key signature. This isn't a problem during playback, of course, since each note has its proper pitch value. It is a problem, however, when the file is scored. In the absence of the right key signature, the scoring program simply places an accidental for every sharp and flat note.<P>

Assume the Czeiszperger piece is in D minor with a missing key signature, to wit, one flat. We'd like to add the key signature to the MIDI file so that, when scored, it would follow common notational conventions. <a href="9615e.htm#0304_0104">Example 2</A> will read a file named &quot;cz.mid,&quot; add the one-flat key signature, set the minor flag, and write the result to a file named &quot;czkey.mid.&quot; The key signature addition is accomplished by the call to <I>CMidi::AddKeySignature()</I> with the number of sharps (a positive integer) or flats (a negative integer) and the minor flag (0 for major key, 1 for minor key) as arguments. The file midi.cpp shows that the MIDI-level function for adding a key signature always adds the key signature to track 1. The MIDI-level function then passes the argument to the track-level function.<P>

The add is done in <I>CTrack::AddKeySignature()</I>. As can be seen in track.cpp (available electronically), the track-level key signature function builds a 4-byte array consisting of the proper event type, proper data length, number of sharps or flats, and minor flag. The byte array is placed into an event constructed to add the key signature at 0 delta time. The new event is then placed at the beginning of the track, and the track length is adjusted accordingly. <a href="9615a5f4.gif">Figure 4</A> shows the result. Any decent scoring package will pick up the one-flat key signature. It should also add the cancel sign for the treble-clef B natural accidental in the first measure. (I used Voyetra's Orchestrator Plus to prepare the figures, and it did both.)<P>

A more common and more difficult requirement is transposition. This problem frequently arises when orchestrating a MIDI piece for play by live performers. Perhaps the key is wrong for a singer's vocal range. Perhaps no bassoon is available, so the bassoon part must be transposed for baritone sax. Transpositions, along with appropriate key signature changes, can be accomplished easily with the functionality of the MIDI ADT.<P>

To continue with our example, the code of <a href="9615e.htm#0304_0105">Example 3</A> transposes the MIDI file czkey.mid down one half step. Once again, follow the strategy of calling a function only at the MIDI file level. In midi .cpp, <I>CMidi::Transpose()</I> defines a cursor (part of the template code of <a href="9615e.htm#0304_0101">Figure 1</A>) to iterate over each track in the MIDI file. For each track, the track level transpose function is called. In track.cpp, <I>CTrac</I><I>k</I><I>:: Transpose()</I> behaves similarly. It defines a cursor to iterate over each event, calling the event-level function.<P>

The work of transposition is accomplished in <a href="9615e.htm#0304_0109">Listing Two</A>'s <I>CEvent::Transpose()</I>. This function begins with key signature data in a static array. Standard key signatures are used. (Some composers write in nonstandard keys--such as Db minor instead of C# minor--which require more accidentals than the standard keys. This code doesn't support nonstandard keys.)<P>

Only two types of events are affected by transposition, the key signature metaevent and the note on/off channel events. Each event is checked to see if it is one of these two types. If the event is a key signature, the current signature is found in the table, and then the new signature is found at the requested transposition offset. The key signature doesn't change, of course, if the transposition is one or more octaves, a multiple of 12 half steps. If the event is a note-on or a note-off, the transposition offset is applied to the note value. Since note values can't be lower than 0 (C five octaves below middle C) or higher than 127 (G six octaves above middle C), transpositions beyond these ranges are set to the highest or lowest possible octave. The transposition of <a href="9615a5f4.gif">Figure 4</A> by the code of <a href="9615e.htm#0304_0105">Example 3</A> appears in <a href="9615a5f5.gif">Figure 5</A>. The four sharps of C# minor appear, and the appropriate accidental has been added in the treble clef, first measure.<P>

<h3><a name="0304_00ff">Conclusion<a name="0304_00ff"></h3><P>

In developing the <I>event</I>, <I>track</I>, and <I>MIDI file</I> classes, collection class templates are an enormous help. The collection classes supplied with IBM's VisualAge C++ provided efficient, function-rich code for handling the <I>file</I>/<I>track</I>/<I>event</I> hierarchies in MIDI files. The code I present here is sufficiently complete to allow you to expand the functionality to other MIDI file processing, such as normalization of all note velocities (volumes).<P>

The catch is efficiency. While the template code is sparse and easy to code at high levels of abstraction, the overhead of the underlying code is concealed. Large MIDI files bring correspondingly long run times. VisualAge C++'s trace facility showed that a lot of time was spent allocating memory for <I>event</I> arrays and deallocating it when destructors were called. This may be partially because I used VisualAge's <I>Equality Sequence</I> template, which has the richest set of functionality available. Now that I have a better idea what functions I need for the MIDI ADT, it may be possible to choose a simpler and more efficient template.<P>

The next step is to try the MIDI ADTs on other platforms. A prototype port to Visual C++ 1.5 and Microsoft Foundation Classes (MFC) under Windows was successful in principle, but memory was exhausted by MIDI files of more than 2000 bytes. Another drawback was that VC++ 1.5 does not support templates. However, my next project is to try Visual C++ 4.0 under Windows NT. The MFC distributed with Version 4.0 includes template support and isn't limited to the medium memory model. <P>

<h3><a name="0304_0100">References<a name="0304_0100"></h3><P>

Charlap, D. &quot;The BMP File Format, Part 1.&quot; <I>Dr. Dobb's Journal</I>, March 1995.<P>

Conger, J. <I>C Programming for MIDI</I>. New York, NY: M&amp;T Books, 1989.<P>

------. &quot;MIDI Programming in C, Part One: MIDI Input and Output.&quot; <I>Electronic Musician</I>, September 1989.<P>

------. &quot;MIDI Programming in C, Part Three: Patch Librarian Basics.&quot; <I>Electronic Musician</I>, November 1989.<P>

------. &quot;MIDI Programming in C, Part Two: MIDI Data Debugger.&quot; <I>Electronic Musician</I>, October 1989.<P>

------. <I>MIDI Sequencing in C</I>. New York, NY: M&amp;T Books, 1989.<P>

Czeiszperger, M.S. &quot;Introducing Standard MIDI Files,&quot; <I>Electronic Musician</I>, April 1989.<P>

Murray, R.B. <I>C++ Strategy and Tactics</I>. Reading, MA: Addison-Wesley, 1993.<P>

Pohl, I. <I>C++ for C Programmers</I>, Second Edition. Redwood City, CA: Benjamin/Cummings, 1994.<P>

Wyatt, D. Standard MIDI files 0.06. Available at http://www.id.ethz.ch:80/~parish/ midi/midi_file_format.txt, March 1988.<P>

<h4><a name="0304_0101"><B>Figure 1:</B> IBM's Sequence declarations.<a name="0304_0101"></h4><P>

<pre>template &lt; class Element &gt;
class ISequence {
public:
  class Cursor : ICursor {
    Element&amp; element  ();
    void setToLast ();
    void setToPrevious  ();
    Boolean operator==  (Cursor const&amp; cursor);
    Boolean operator!=  (Cursor const&amp; cursor);
  };
                ISequence            (INumber numberOfElements = 100);
                ISequence            (ISequence &lt; Element &gt; const&amp;);
ISequence &lt; Element &gt;&amp;
                operator =           (ISequence &lt; Element &gt; const&amp;);
                ~ISequence           ();
Boolean         add                  (Element const&amp;);
Boolean         add                  (Element const&amp;, ICursor&amp;);
void            addAllFrom           (ISequence &lt; Element &gt; const&amp;);
Element const&amp;  elementAt            (ICursor const&amp;) const;
Element&amp;        elementAt            (ICursor const&amp;);
Element const&amp;  anyElement           () const;
void            removeAt             (ICursor const&amp;);
INumber         removeAll            (Boolean (*property)
                                             (Element const&amp;, void*),
                                             void* additionalArgument = 0);
void            replaceAt            (ICursor const&amp;, Element const&amp;);
void            removeAll            ();
Boolean         isBounded            () const;
INumber         maxNumberOfElements  () const;
INumber         numberOfElements     () const;
Boolean         isEmpty              () const;
Boolean         isFull               () const;
ICursor*        newCursor            () const;
Boolean         setToFirst           (ICursor&amp;) const;
Boolean         setToNext            (ICursor&amp;) const;
Boolean         allElementsDo        (Boolean (*function) (Element&amp;, void*),
                                             void* additionalArgument = 0);
Boolean         allElementsDo        (IIterator &lt;Element&gt;&amp;);
Boolean         allElementsDo        (Boolean (*function)
                                             (Element const&amp;, void*),
                                             void* additionalArgument = 0) const;
Boolean         allElementsDo        (IConstantIterator &lt;Element&gt;&amp;) const;
Boolean         isConsistent         () const;
void            removeFirst          ();
void            removeLast           ();
void            removeAtPosition     (IPosition);
Element const&amp;  firstElement         () const;
Element const&amp;  lastElement          () const;
Element const&amp;  elementAtPosition    (IPosition) const;
Boolean         setToLast            (ICursor&amp;) const;
Boolean         setToPrevious        (ICursor&amp;) const;
void            setToPosition        (IPosition, ICursor&amp;) const;
Boolean         isFirst              (ICursor const&amp;) const;
Boolean         isLast               (ICursor const&amp;) const;
long            compare              (ISequence &lt; Element &gt; const&amp;,
                                             long (*comparisonFunction)
                                             (Element const&amp;,
                                             Element const&amp;)) const;
void            addAsFirst           (Element const&amp;);
void            addAsFirst           (Element const&amp;, ICursor&amp;);
void            addAsLast            (Element const&amp;);
void            addAsLast            (Element const&amp;, ICursor&amp;);
void            addAsNext            (Element const&amp;, ICursor&amp;);
void            addAsPrevious        (Element const&amp;, ICursor&amp;);
void            addAtPosition        (IPosition, Element const&amp;);
void            addAtPosition        (IPosition, Element const&amp;, ICursor&amp;);
void            sort                 (long (*comparisonFunction)
                                              (Element const&amp;,
                                              Element const&amp;));
};</pre>

<h4><B><a href="9615a5f2.gif">Figure 2</A>:</B> Czeiszperger's MIDI example.</h4><P>

<h4><a name="0304_0102"><B>Figure 3:</B> Listing of Track 1 in readable form.<a name="0304_0102"></h4><P>

<pre>--------------- Track 1 --------------
Header Signature: MTrk
    Track Length: 53
Delta Time: 0
 Data Size: 6
      Type: time signature, (type 58).
      Data: 58 4 3 2 18 8
Delta Time: 0
 Data Size: 5
      Type: set tempo, (type 51).
      Data: 51 3 7 a1 20
Delta Time: 0
 Data Size: 32
      Type: text, (type 1).
      Data: TYPE 1 MIDI FILE
Delta Time: 0
 Data Size: 2
      Type: end of track, (type 2f).
      Data: 2f 0</pre>

<h4><B><a href="9615a5f4.gif">Figure 4</A>:</B> MIDI example with D minor key signature added.</h4><P>

<h4><B><a href="9615a5f5.gif">Figure 5</A>:</B> MIDI example transposed to C<I>#</I> minor.</h4><P>

<h4><a name="0304_0103"><B>Example 1:</B> Code to print a MIDI file in readable form.<a name="0304_0103"></h4><P>

<pre>#include &quot;midi.h&quot;
void main(void)
{
  CMidi tempmidi;
  tempmidi.Import(&quot;cz.mid&quot;);
  tempmidi.Printf(); // method to print in readable form
}</pre>

<h4><a name="0304_0104"><B>Example 2:</B> Code to add a D minor key signature.<a name="0304_0104"></h4><P>

<pre>#include &quot;midi.h&quot;
void main(void)
{
   CMidi tempmidi;
   tempmidi.Import(&quot;czkey.mid&quot;);
   tempmidi.Transpose(-1);
   tempmidi.Export(&quot;czcsmin.mid&quot;);
}</pre>

<h4><a name="0304_0105"><B>Example 3:</B> Code to transpose down one-half step.<a name="0304_0105"></h4><P>

<pre>#include &quot;midi.h&quot;
void main(void)
{
   CMidi tempmidi;
   tempmidi.Import(&quot;cz.mid&quot;);
   tempmidi.AddKeySig(-1, 1); // 1 flat, minor = 1 =&gt; d minor
   tempmidi.Export(&quot;czkey.mid&quot;);
}</pre>

<P>

<h4><a name="0304_0106"><a name="0304_0107">Listing One<a name="0304_0107"></h4><pre>
// event.h---declares event class
#ifndef __C_EVENT_H_____LINEEND____
#define __C_EVENT_H_____LINEEND____
#include &lt;iglobals.h&gt;
#include &lt;iseq.h&gt;
#include &lt;fstream.h&gt;
const int TRUE = 1;
typedef ISequence &lt;char&gt; CByteArray;
enum EventType {Channel, Meta, SysEx, SysExCont, Undefined, Error};
class CEvent
{                      
public:
   CEvent();
   CEvent(const unsigned long&amp; time, const EventType&amp; TypeVal,
      const CByteArray&amp; Data);
   CEvent(const CEvent&amp; Event);
   ~CEvent();
                  CEvent&amp;   operator = (const CEvent&amp; Event);
                  int       operator == (const CEvent&amp; Event) const;
                  int       operator != (const CEvent&amp; Event) const;
                  void      Clear(void);
                  int       GetDataLength(void) const;                  
   const unsigned long&amp;     GetDeltaTime(void) const;
   const          EventType GetEventType(void) const;
                  void      Printf(void) const;
                  int       ReadData(ifstream&amp;);
                  CEvent&amp;   SetDeltaTime(const unsigned long&amp; time);
                  CEvent&amp;   SetEventType(const EventType&amp; TypeVal);
                  void      Transpose(const int);
                  void      WriteData(ofstream&amp;) const;
   
private:
   unsigned long       m_DeltaTime;
            EventType  m_EventType;
            CByteArray m_Data;
            
            int        GetVar(const CByteArray&amp;, unsigned long *) const;
            int        PutVar(CByteArray&amp;, const int,
                          const unsigned long);
            int        ReadVar(ifstream&amp; ins, unsigned long *);
            void       WriteVar(ofstream&amp;, unsigned long) const;
};
typedef ISequence &lt;CEvent&gt; CEventArray;
#endif
</pre>
<h4><a name="0304_0108"><a name="0304_0109">Listing Two<a name="0304_0109"></h4><pre>
// event.cpp---implements event class. Based on code from Michael Czeiszperger.
#include &quot;event.h&quot;
#include &lt;iomanip.h&gt;
CEvent::CEvent() : m_DeltaTime(0l), m_EventType(Undefined), m_Data() {}
CEvent::CEvent(const unsigned long&amp; DeltaTime,
   const EventType&amp; TypeVal, const CByteArray&amp; Data) :
   m_DeltaTime(DeltaTime), m_EventType(TypeVal),
   m_Data(Data) {}
CEvent::CEvent(const CEvent&amp; Event)
{  
   if (this != &amp;Event)
   {  
      int ElementCount = Event.m_Data.numberOfElements();
      m_DeltaTime = Event.m_DeltaTime;
      m_EventType = Event.m_EventType;
      for (int i = 1; i &lt;= ElementCount; i++)
         m_Data.addAsLast(Event.m_Data.elementAtPosition(i));
   }
}
CEvent::~CEvent()
{ m_Data.~ISequence(); }
                                         
CEvent&amp; CEvent::operator=(const CEvent&amp; Event)
{ 
   if(this != &amp;Event)
   {                        
      int ElementCount = Event.m_Data.numberOfElements();
      if (m_Data.numberOfElements() &gt; 0) // Old data?
         m_Data.removeAll();
      m_DeltaTime = Event.m_DeltaTime;
      m_EventType = Event.m_EventType;
      for (int i = 1; i &lt;= ElementCount; i++)
         m_Data.addAsLast(Event.m_Data.elementAtPosition(i));
   }
   return *this;
}
int CEvent::operator==(const CEvent&amp; Event) const
{
   int ByteCount;
   if (this == &amp;Event)
      return 1;
   if (m_DeltaTime != Event.m_DeltaTime || 
      m_EventType != Event.m_EventType)
      return 0;
   ByteCount = m_Data.numberOfElements();
   if (ByteCount != Event.m_Data.numberOfElements())
      return 0;
   for (int i = 1; i &lt;= ByteCount; i++)
   {
      if (m_Data.elementAtPosition(i) != 
         Event.m_Data.elementAtPosition(i))
         return 0;
   }
   return 1;
}
int CEvent::operator!=(const CEvent&amp; Event) const
{ return !(*this == Event); }
void CEvent::Clear(void)
{ m_DeltaTime = 0l; m_EventType = Undefined; m_Data.removeAll(); }
const unsigned long&amp; CEvent::GetDeltaTime() const
{ return m_DeltaTime; }
const EventType CEvent::GetEventType() const
{ return m_EventType; }
void CEvent::Printf() const 
{             
            int  byte, chan, i, size;
      const int  LINELENGTH = 60;
   unsigned long DataLength;
   
   cout &lt;&lt; endl
        &lt;&lt; &quot;Delta Time: &quot; &lt;&lt; dec &lt;&lt; m_DeltaTime;
   size = m_Data.numberOfElements();
   cout &lt;&lt; endl
        &lt;&lt; &quot; Data Size: &quot; &lt;&lt; dec &lt;&lt; size &lt;&lt; endl;
   if (!size)
      return;
   cout &lt;&lt; &quot;      Type: &quot;;
   byte = m_Data.elementAtPosition(1);
   switch ((int)m_EventType)
   {
      case (int)Channel:        //--- channel event ----------------
         chan = (byte &amp; 0xf) + 1;
         switch (byte &amp; 0xf0)
         {
            case 0x80: cout &lt;&lt; &quot;Note off, channel &quot; &lt;&lt; chan &lt;&lt; &quot;, &quot;;
               break;
            case 0x90: cout &lt;&lt; &quot;Note on, channel &quot; &lt;&lt; chan &lt;&lt; &quot;, &quot;;
               break;
            case 0xa0: cout &lt;&lt; &quot;Pressure, channel &quot; &lt;&lt; chan &lt;&lt; &quot;, &quot;;
               break;
            case 0xb0: cout &lt;&lt; &quot;Parameter, channel &quot; &lt;&lt; chan &lt;&lt; &quot;, &quot;;
               break;
            case 0xe0: cout &lt;&lt; &quot;Pitchbend, channel &quot; &lt;&lt; chan &lt;&lt; &quot;, &quot;;
               break;
            case 0xc0: cout &lt;&lt; &quot;Program, channel &quot; &lt;&lt; chan &lt;&lt; &quot;, &quot;;
               break;
            case 0xd0: cout &lt;&lt; &quot;Channel pressure, channel &quot; &lt;&lt; chan &lt;&lt;
               &quot;, &quot;; break;
              default: cout &lt;&lt; &quot;Unknown event, &quot;; break;
         }
         cout &lt;&lt; &quot;(type &quot; &lt;&lt; hex &lt;&lt; byte &lt;&lt; &quot;).&quot; &lt;&lt; endl;
         if (size &gt; 1)
         {  
            cout &lt;&lt; &quot;      Data: &quot;; 
            CByteArray::Cursor cursor(m_Data);
            forCursor(cursor)
               cout &lt;&lt; hex &lt;&lt; (int)m_Data.elementAt(cursor) &lt;&lt; &quot; &quot;;
            cout &lt;&lt; endl;
         }
         break;
      case (int)Meta:               //--- meta event -------------------
         switch (byte)
         {       
            case  0x0: cout &lt;&lt; &quot;sequence number, &quot;; break;
            case  0x1: cout &lt;&lt; &quot;text, &quot;; break;
            case  0x2: cout &lt;&lt; &quot;copyright, &quot;; break;
            case  0x3: cout &lt;&lt; &quot;sequence/track name, &quot;; break;
            case  0x4: cout &lt;&lt; &quot;instrument name, &quot;; break;
            case  0x5: cout &lt;&lt; &quot;lyric, &quot;; break;
            case  0x6: cout &lt;&lt; &quot;marker, &quot;; break;
            case  0x7: cout &lt;&lt; &quot;cue point, &quot;; break;
            case 0x20: cout &lt;&lt; &quot;MIDI channel prefix, &quot;; break;
            case 0x2f: cout &lt;&lt; &quot;end of track, &quot;; break;
            case 0x51: cout &lt;&lt; &quot;set tempo, &quot;; break;   
            case 0x54: cout &lt;&lt; &quot;SMPTE offset, &quot;; break;
            case 0x58: cout &lt;&lt; &quot;time signature, &quot;; break;
            case 0x59: cout &lt;&lt; &quot;key signature, &quot;; break;
            case 0x7f: cout &lt;&lt; &quot;sequencer-specific, &quot;; break;
              default: cout &lt;&lt; &quot;Unknown meta event, &quot;; break;
         }
         cout &lt;&lt; &quot;(type &quot; &lt;&lt; hex &lt;&lt; byte &lt;&lt; &quot;).&quot; &lt;&lt; endl;
         if (size &gt; 1)
         {                
            cout &lt;&lt; &quot;      Data: &quot;;  
            if (0x0 &lt;= byte &amp;&amp; byte &lt;= 0x5)  // if text
               for (i = 3; i &lt;= size; i++)   // print char bytes
                  cout &lt;&lt; (char)m_Data.elementAtPosition(i);
            else for (i = 1; i &lt;= size; i++) // dump hex bytes
               cout &lt;&lt; hex &lt;&lt; (int)m_Data.elementAtPosition(i) &lt;&lt; &quot; &quot;;
            cout &lt;&lt; endl;
         }
         break;
      case (int)SysEx:              //--- sysex event ------------------
      case (int)SysExCont:
         if (size &gt; 1)
         {
            i = GetVar(m_Data, &amp;DataLength);
            cout &lt;&lt; &quot;    Length: &quot; &lt;&lt; DataLength &lt;&lt; endl;
            cout &lt;&lt; &quot;SysEx Data: &quot;;  
            for (i = 1; i &lt;= size; i++)
            {
               cout &lt;&lt; hex &lt;&lt; m_Data.elementAtPosition(i) &lt;&lt; &quot; &quot;;
               if (((i * 2) % LINELENGTH) == 0)
                  cout &lt;&lt; &quot;\n            &quot;;
            }
         }
         break;
      default:
         cerr &lt;&lt; &quot;Unexpected event type: &quot; &lt;&lt; (int)m_EventType
            &lt;&lt; &quot;.  Aborting.&quot; &lt;&lt; endl;
         exit (1);
         break;
   }
}  
int CEvent::ReadData(ifstream&amp; ins)
{  
   unsigned char c, c1;
   static   int  ChanType[]    = {0,0,0,0,0,0,0,0,2,2,2,2,1,1,2,0};
   static   int  EventLength   = 0;
            int  i;
   unsigned long Length;
            int  LengthLength  = 0;
            int  Needed;
   static   int  NoMerge       = 0;    
   static   int  Running       = 0;
   static   int  Status        = 0;
   static   int  SysExContinue = 0;                
   EventLength = ReadVar(ins, &amp;m_DeltaTime);     
   c = (char)ins.get(); 
   EventLength++;
   if (SysExContinue &amp;&amp; c != 0xf7)
   {
      cerr &lt;&lt; &quot;Didn't find expected continuation of sysex. Aborting.&quot; 
         &lt;&lt; endl;
      exit (1);
   }
   if ((c &amp; 0x80) == 0)
   {
      if (Status == 0)      
      {
         cerr &lt;&lt; &quot;Unexpected running status---&quot; &lt;&lt; endl;
         cerr &lt;&lt; &quot;Status = &quot; &lt;&lt; hex &lt;&lt; Status &lt;&lt; &quot;, Running = &quot; &lt;&lt; dec
            &lt;&lt; Running &lt;&lt; &quot;.  Aborting.&quot; &lt;&lt; endl;
         exit(1);
      }
      Running = 1;
   }             
   else 
   {
      Running = 0;
      Status = c;
   }
   Needed = ChanType[(Status &gt;&gt; 4) &amp; 0xf]; 
   if ( Needed ) // channel event?
   {
      m_EventType = Channel;
      m_Data.addAsLast(Status);
      if ( Running )
         c1 = c;
      else
      {
         c1 = ins.get(); 
         EventLength++;
      }
      m_Data.addAsLast(c1);
      if (Needed &gt; 1)
      {
         m_Data.addAsLast(ins.get()); 
         EventLength++;
      }
   }
   else
   {
      switch (c)
      {                                                              
         case 0xff:  // meta event
            m_EventType = Meta;
            m_Data.addAsLast(ins.get()); 
            EventLength++;
            LengthLength += (int)ReadVar(ins, &amp;Length);
            PutVar(m_Data, EventLength+1, Length);
            EventLength += LengthLength;
            for (i = 1; i &lt;= (int)Length; i++)
            {
               m_Data.addAsLast(ins.get());
               EventLength++;
            }
            break;
         case 0xf0:  // start of system exclusive 
         case 0xf7:  // system exclusive continuation
            if (c == 0xf0)
            {
               m_EventType = SysEx;
               SysExContinue = (NoMerge == 0) ? 0 : 1;
            }
            else
               m_EventType = SysExCont;
            m_Data.addAsLast(Status);
            EventLength += ReadVar(ins, &amp;Length);
            for (i = 1; i &lt;= (int)Length; i++) 
               m_Data.addAsLast(ins.get());
            break;
         default:
            cerr &lt;&lt; &quot;Unexpected event type &quot; &lt;&lt; hex &lt;&lt; (int)c 
               &lt;&lt; &quot;.  Aborting.&quot; &lt;&lt; endl;
            exit (1);
            break;
      }
   }
   return EventLength;
}
   
CEvent&amp; CEvent::SetDeltaTime(const unsigned long&amp; Time)
{ m_DeltaTime = Time; return *this; }
CEvent&amp; CEvent::SetEventType(const EventType&amp; TypeVal)
{ m_EventType = TypeVal; return *this; }
void CEvent::Transpose(const int steps)
{
   //             major:  C Db   D Eb   E  F    F# G Ab   A  Bb   B
   //             minor:  A Bb   B C    C# D    Eb E F    F# G    G#
   //            sharps:         2      4       6  1      3       5
   //             flats:    5      3       1         4       2
   static int keysig[] = {0,0xfb,2,0xfd,4, 0xff,6, 1,0xfc,3, 0xfe,5 };
   // key signature == ff 59 02 sf mi: +sf == count sharps,
   // -sf == count flats, mi == 0 =&gt; major, mi == 1 =&gt; minor
   if (m_EventType == Meta)
   {
      if (m_Data.elementAtPosition(1) == 0x59)
      {
         int i, keyshift, sharpflat;
         CByteArray::Cursor cursor(m_Data);
         keyshift = steps % 12;                    // no change for octaves
         m_Data.setToPosition(3, cursor);          // position at sf
         sharpflat = m_Data.elementAtPosition(3);
         if (sharpflat == -6)
            sharpflat = 6;
         for (i = 0; i &lt; 12; i++)
            if (keysig[i] == sharpflat)
               break;
         if (i == 12)
         {
            cerr &lt;&lt; &quot;Unexpected key signature &quot; &lt;&lt; sharpflat
               &lt;&lt; &quot;.  Aborting.&quot; &lt;&lt; endl;
            exit (1);
         }
         m_Data.elementAt(cursor) = keysig[(i+keyshift)%12];
      }
   }
   else if (m_EventType == Channel)
   {
      int byte = m_Data.elementAtPosition(1) &amp; 0xf0;
      if (byte == 0x80 || byte == 0x90)         // note off or on
      {
         CByteArray::Cursor cursor(m_Data);
         m_Data.setToPosition(2, cursor);       // position at note
         m_Data.elementAt(cursor) += steps;
         if (m_Data.elementAt(cursor) &lt; 0)      // lower than C-5?
            m_Data.elementAt(cursor) += 12;     // then raise an octave
         else if (m_Data.elementAt(cursor) &gt; 0x7f)  // higher than G6?
            m_Data.elementAt(cursor) -= 12;     // then lower an octave
      }
   }
}
void CEvent::WriteData(ofstream&amp; outs) const
{     
   static int CurrentChanType = 0;            
   static int Running = 0;
                                                 
   WriteVar(outs, m_DeltaTime);
   if (m_EventType != Channel)
   {
      Running = CurrentChanType = 0;
      if (m_EventType == Meta)
         outs.put((char)0xff);
   }
   else
   {
      if (CurrentChanType == m_Data.elementAtPosition(1))
         Running = 1;
      else
      {
         Running = 0;
         CurrentChanType = m_Data.elementAtPosition(1);
      }
   }  
   for (int i = Running+1; i &lt;= m_Data.numberOfElements(); i++)
      outs.put(m_Data.elementAtPosition(i));
}
int CEvent::GetDataLength(void) const
{ return m_Data.numberOfElements(); }
int CEvent::GetVar(const CByteArray&amp; Data, unsigned long *Value) const
{
   int c;
   int count = 0;
   
   c = (char)Data.elementAtPosition(count++);
   *Value = (long)c;
   if (c &amp; 0x80)
   {
      *Value &amp;= 0x7f;
      do
      {
         c = Data.elementAtPosition(count++);
         *Value = (*Value &lt;&lt; 7) + (c &amp; 0x7f);
      } while (c &amp; 0x80);
   }                     
   return count;
}
int CEvent::PutVar(CByteArray&amp; Data, const int Position,
   const unsigned long Value)
{
   unsigned long Buffer, TempVal;
            int  i = 0;
   
   Buffer = Value &amp; 0x7f;
   TempVal = Value;
   while ((TempVal &gt;&gt;= 7) &gt; 0)
   {
      Buffer &lt;&lt;= 8;
      Buffer |= 0x80;
      Buffer += (TempVal &amp; 0x7f);
   }                           
   while(TRUE)
   {  
      Data.addAsLast((char)Buffer);
      i++;
      if (Buffer &amp; 0x80)
         Buffer &gt;&gt;= 8;
      else
         break;
   }
   return i;
}
int CEvent::ReadVar(ifstream&amp; ins, unsigned long *Value)
{            
   int c;
   int count = 0;
   
   c = ins.get();
   count++;
   *Value = (long)c;
   if (c &amp; 0x80)
   {
      *Value &amp;= 0x7f;
      do
      {
         c = ins.get();
         count++;
         *Value = (*Value &lt;&lt; 7) + (c &amp; 0x7f);
      } while (c &amp; 0x80);
   }                     
   return count;
}
   
void CEvent::WriteVar(ofstream&amp; ofs, unsigned long Value) const
{
   unsigned long buffer;
   
   buffer = Value &amp; 0x7f;
   while ((Value &gt;&gt;= 7) &gt; 0)
   {
      buffer &lt;&lt;= 8;
      buffer |= 0x80;
      buffer += (Value &amp; 0x7f);
   }                           
   while(TRUE)
   {
      ofs.put((char)buffer);
      if (buffer &amp; 0x80)
         buffer &gt;&gt;= 8;
      else
         break;
   }
}
End Listings&gt;&gt;
&lt;&lt;
</pre>
<P>

<P>

<P>

<P>

<P>

<P>

<P>

<P>

<P>

<P>

</BODY></HTML>
