<HTML>
<META NAME="year" CONTENT="1996">
<HEAD>
<!-- This document was built using HyperWriter Professional by NTERGAID Inc. -->
<TITLE>Visual Tools 96: Visual Development</TITLE></HEAD>
<body bgcolor="FFFFFF">
<P>

<h1>Visual Development Tools for Java</h1><P>

<P>

<P>

<h2>GUI building for Java applets and applications</h2><P>

<P>

<h3>Steve V. Yalovitser</h3><P>

<P>

<P>
<i>Steve is a principal of Deductive Systems Inc., a company specializing in Java-product development. He
can be contacted at root@deductive.com.</i></p><hr><P>

<P>

As any programming language matures, it needs to have certain categories of tools available to make the
language more accessible to legacy environments. One category many developers look for is
visual-development tools for GUI building. In this article, I will compare and contrast my experiences with
three different Java-based visual-development environments: Rogue Wave's JFactory, Symantec's Cafe,
and Autodesk's Hyperwire.<P>

My application development was done entirely on a 486/66, running either Windows 95 or NT 3.5.1.
Hyperwire targets Intel platforms only. Rogue Wave's JFactory targets both Intel and Sparc platforms, and
Cafe targets Intel platforms and MacOS. Consequently, I tested my applications on an HP712, running
HP-UX 9.0.5; a SPARCStation LX, running Solaris 2.4; and a 486/66, running Windows NT 3.5.1 and
Windows 95.<P>

<h3>The Development Environments</h3><P>

Symantec's Cafe for Windows (see <a href="19970281.htm">Figure 1)</A> is a visual environment that
allows you to create applets and applications for delivery to any Java-supported environment without
recompilation. Cafe includes several tools: a project system (which manages the Java source files
belonging to your project), class editor, hierarchy editor, visual-design tool (which provides
drag-and-drop resource editing), GUI debugger (with multiple independent thread debugging), programmable
source editor (with Java syntax highlighting), AppExpress (a visual tool for creating a default Java applet
or application), output window (for viewing the compilation results and error messages), Java source-code
parser, and help file (with the Java API methods for easy lookup from within the source editor).<P>

Hyperwire (see <a href="19970282.htm">Figure 2</A>), from Autodesk's Kinetix division, is a visual,
icon-based authoring tool for creating Java applets. Hyperwire's interface provides WYSIWYG displays of
your applet's interface, as well as the logic behind it. Hyperwire includes a library of sophisticated applets;
tools and templates for creating sprite-based animations; and ready-to-use buttons for creating form,
search, and switching functionality. Hyperwire lets you visually connect Java objects.<P>

Rogue Wave's JFactory is a visual-development environment (see<a href="19970283.htm"> Figure
3)</A> that lets you assemble Java applets from preexisting interface components. JFactory then
generates the corresponding source code, allows you to test it, compiles the applet, and executes the
finished product. JFactory includes tools such as a window- and dialog-design tool (for object alignment,
spacing, and positioning, as well as drag-and-drop capability for adding components and images) and a menu
designer (for creating menu bars, pop-up menus, and individual menu items). The environment also provides
a project manager, import and export capabilities, user-inserted source code, object manager (for setting
up specific properties for interface objects), object library, clipboard, source editor, and
context-sensitive pop-up menus.<P>

<h3>The Comparison Criteria</h3><P>

I set several criteria for gauging Intranet application development:<P>

<P>
<ul>
<li>Could the tool generate Java applications instead of applets?</li>
<li>Which business GUI objects (excluding images, animators, geometries, and so on) were actually
usable?</li>
<li>Which layout managers are supported?</li>
<li>How scalable was the design environment?</li>
<li>Could the designed components be reused easily?</li>
</ul>
<P>

For developing Internet apps, I settled on the following criteria: <P>
<ul>
<li>How cross platform was the environment and how accurate from one platform to another was the
generated code?</li>
<li>How much code was actually generated, and how long did it take to download?</li>
<li>What media-related components were available?</li>
<li>Did the generated code behave properly in a Netscape browser?</li>
<li>What clipping controls were available?</li>
</ul>
<P>

I decided upon the following three common criteria:<P>
<ul>
<li>Did the environment support component containment and containment nesting?</li>
<li>What was the callback methodology of the environment, and what was the level of code needed to hook
up components?</li>
<li>What did the application store at exit to reference the GUI description?</li>
</ul>
<h3>Intranet Applications</h3><P>

JFactory and Cafe can generate application code. Hyperwire is constrained to applets because all classes
generated from Hyperwire derive from <I>OpusApplet</I>, a custom subclass of <I>Applet</I>. Java
provides a set of generic GUI objects. I classified the following as business-related components:<P>
<ul>
<li>Button (CheckBox, Radio).</li>
<li>List.</li>
<li>Menu/MenuBar.</li>
<li>Dialog/FileDialog.</li>
<li>ScrollBar(Vert/Horiz).</li>
<li>TextArea.</li>
<li>TextField.</li>
<li>Label.</li>
</ul>
<P>

JFactory and Cafe support all of these components, while Hyperwire supports only Button, TextField, and
Label. Cafe is the only tool that provides support for layout managers, including CardLayout, FlowLayout,
and BorderLayout. JFactory provides its own layout manager; it is the only one you can use. Hyperwire
does not provide layout managers; instead, it has its own position-based layout scheme.<P>

Scalability was an issue in both JFactory and Cafe. Scalability was measured by growing the number of
visual components from 1 to 80, nesting them where possible. As <a href="19970284.htm">Figure
4(a)</A> shows, JFactory became increasingly unresponsive after about 80 components. Cafe crashed
consistently after 70 components; see <a href="19970285.htm">Figure 4(b)</A>. Hyperwire,<a href="19970286.htm"> Figure 4(c)</A>, maintained the same performance, but it performed consistently
slower than the other two for anything except the extreme component numbers.<P>

All three development tools provide some level of reuse. JFactory has the most intuitive component-reuse
mechanism. It gives users an object-library directory and the ability to import a set of componentsDialog,
Panel, Menu, and Windowinto any application. Cafe gives you the ability to reuse components within an
application, but no real way to export built objects to other applications. Hyperwire currently gives you the
ability to export applications you develop into other applications.<P>

<h3>Internet Applications</h3><P>

Of the three visual environments, Hyperwire is the only one that is hosted solely on Windows 95/NT. Cafe
is hosted on Windows 95/NT and MacOS, while JFactory is available for Windows, OS/2, Solaris, and
HP-UX. JFactory also provides a platform-independent layout manager. Cafe and Hyperwire depend on Java
to provide platform-independent layout, which works in most cases, but not when exact-pixel-count
precision is necessary. In particular, Cafe actually does not have any pixel-position-based layout
capability: Layout is only through placement/alignment. As<a href="9616a.htm#0229_0127"> Listings
One</A>, <a href="9616a.htm#0229_03b0">Two</A>, and <a href="9616a.htm#0229_03b1">Three </A>illustrate, the three tools differ widely in the code they
generate. JFactory (<a href="9616a.htm#0229_0127">Listing One</A>) includes its own layout
manager with any code it generates. It creates its own named subclass of every component. Cafe (<a href="9616a.htm#0229_0127"><a href="9616a.htm#0229_03b0">Listing Two</A></A>)
generates named components of the "main" component (like frame/window/dialog) that you are editing, and
the rest of the code uses vanilla components. Hyperwire (<a href="9616a.htm#0229_03b1">Listing
Three</A>) needs four different packages to operate. Though the code it generates is sparse (and
practically unreadable), it needs to load approximately 10 to 15 custom classes.<P>

In general, Cafe code is the closest to vanilla Java code, and Hyperwire is the farthest from it. Java
includes support for drawing, images, and primitive sound. Hyperwire has the most impressive support for
media components. It provides shape primitives, sound primitives, sprite animations (both pathed and
stationary), and .JPG and .GIF image support. JFactory provides support for images and animations. It
generates the required ImageTracker code. Cafe does not provide support for any media components. All
the code generated by the development tools runs in Netscape Navigator, JFactory being the only one to
maintain layouts within pixel widths. None of the packages support direct clipping or graphics
manipulation.<P>

<h3>Common Issues</h3><P>

Java provides a container class and the ability to nest containers. JFactory is the only environment that did
not support this. Cafe provided it via a layout method, where a component layered over a panel became
contained by it. Hyperwire provided an abstract visual container that behaved like a separate canvas.<P>

Callbacks have an enormous impact on the coding style used within an application. As <a href="19970287.htm">Figure 5(a)</A> illustrates, JFactory provides two choices, either a direct hookup
of an application event with the opening of a JFactory-designed component, or a protected application code
block where the user could insert code. Cafe only provides a callback stub, which the user must fill in;
see<a href="19970288.htm"> Figure 5(b)</A>. Hyperwire provides a visual way of hooking up application
events and messages sent to other components; see<a href="19970289.htm"> Figure 5(c)</A>. All three
tools generate their own proprietary files for storing the GUI design. JFactory and Hyperwire provide a
way of importing those stored files directly into an application.<P>

<h3>Summary</h3><P>

These three tools represent the spectrum of methodologies. Hyperwire gives you a complete abstraction
from the language, as well as a set of custom widgets to augment the standard media widgets available in
Java. However, the code Hyperwire generates has very little resemblance to Java. Because of the many
references to custom widgets, it is difficult to integrate Hyperwire-generated code into other applications.
The monolithic nature of the code is the trade off for Hyperwire's incredible set of widgets and event
handling.<P>

Cafe provides a full Java development environment, including browsers and compilers, but with its
rudimentary visual interface builder, it is possibly not the best choice for Java GUI building. Its
methodology is at the other end of the spectrum from Hyperwire, in that it provides only rudimentary
positioning and component nesting. It is up to you to populate the callbacks.<P>

The JFactory builder is a purely visual GUI builder/code generator. As such, it covers all the default Java
components, providing a method of reusing the built components. It also provides pixel-position-based
layout. The layout manager JFactory provides is royalty free and can be easily adapted for other uses.<P>

<P>

<P>

<P>

<B>Figure 1:</B> Cafe development environment.<P>

<P>

<B>Figure 2:</B> Hyperwire development environment.<P>

<P>

<B>Figure 4(a):</B> Scalability for JFactory.<P>

<P>

<B>Figure 3:</B> JFactory development environment.<P>

<P>

<B>Figure 4(b):</B> Scalability for Cafe.<P>

<P>

<B>Figure 4(c):</B> Scalability for Hyperwire.<P>

<P>

<B>Figure 5(a):</B> Callbacks for JFactory.<P>

<P>

<B>Figure 5(b):</B> Callbacks for Cafe;.<P>

<P>

<B>Figure 5(c):</B> Callbacks for Hyperwire.<P>

<P>

For More Information<P>

<P>

Symantec Corp.<P>

175 W. Broadway<P>

Eugene, OR 97401<P>

800-441-7234<P>

http://Cafe.symantec.com<P>

<P>

Autodesk/Kinetex<P>

111 McInnis Parkway<P>

San Rafael, CA 94903<P>

800-879-4233<P>

http://www.ktx.com<P>

<P>

Rogue Wave Software<P>

260 S.W. Madison Avenue<P>

Corvallis, OR 97333<P>

800-487-3217<P>

http://www.roguewave.com<P>

<P>

<P>

<a name="0229_0127"><H4>Listing  One</H4>
<pre>
// drdobbs.java -
// Version - 1.0
// 4/25/96 - 4:12:07pm
// zpb_begin Revisions
// zpb_end

import java.awt.*;
import java.util.*;
import java.applet.Applet;
import LogFontLayout;  // Fixed position layout based on font size

// zpb_begin UserImports
// zpb_end

class SampleGenCodePane1 extends Canvas {
    private static Applet applet;

   // zpb_begin SampleGenCodePane1UserVars
    // zpb_end

    public SampleGenCodePane1(Applet app) {
        applet = app;

        // zpb_begin SampleGenCodePane1Constructor
        // zpb_end
    }
    public void paint(Graphics g) {
        Dimension d = size();
        g.drawRect(0,0,d.width-1,d.height-1); // border
        // zpb_begin SampleGenCodePane1Paint
        // zpb_end
    }

    // zpb_begin SampleGenCodePane1UserMethods
    // zpb_end
}

public
class drdobbs extends Applet {

    private static Applet applet;
    Label pStatic1;
    Button pButton1;
    Checkbox pRadioButton1;
    CheckboxGroup pRadioButton1Group;
    SampleGenCodePane1 pPane1;

    // Initial size in logical units
    Dimension initialSize = new Dimension(291, 172);
    // zpb_begin SampleGenCodeUserVars
    // zpb_end

    public     void init() {
        applet = this;

        // zpb_begin AppletInit
        // zpb_end

        setBackground(Color.lightGray);
        setFont(new Font(&quot;Helvetica&quot;, Font.PLAIN, 12));
        LogFontLayout lfLayout = new LogFontLayout(this);
        setLayout(lfLayout);

        pButton1 = new Button(&quot;Button&quot;);
        add(&quot;32 19 66 48&quot;, pButton1);
        pStatic1 = new Label(&quot;Text&quot;);
        add(&quot;133 20 22 42&quot;, pStatic1);
        pRadioButton1Group = new CheckboxGroup();
        pRadioButton1 = new Checkbox(&quot;Radio&quot;,
pRadioButton1Group, false);
        add(&quot;207 22 35 24&quot;, pRadioButton1);

       pPane1 = new SampleGenCodePane1(applet);
        add(&quot;74 83 79 50&quot;, pPane1);

        // zpb_begin SampleGenCodeConstructor_2
        // zpb_end

        // Size in logical units
        resize(getLayout().preferredLayoutSize(this));

        // zpb_begin SampleGenCodeConstructor_3
        // zpb_end
    }

    public Dimension minimumSize() {
        // zpb_begin SampleGenCodeMinimumSize
        // zpb_end

        LayoutManager layoutMgr = getLayout();
        if (layoutMgr instanceof LogFontLayout) {
            // Convert from logical units to absolute coordinates
            int w = initialSize.width;
            int h = initialSize.height;
            LogFontLayout layout = (LogFontLayout)layoutMgr;
            return new Dimension(layout.duX(w), layout.duY(h));
        }
        return new Dimension(initialSize);
    }

    public boolean handleEvent(Event e) {

        // zpb_begin SampleGenCodeHandleEvent
        // zpb_end

        return super.handleEvent(e);
    }
    public Frame getFrame(Container c) {         // zpb_begin
AppletGetFrame
        // zpb_end
        if (c instanceof Frame || c == null)
            return((Frame)c);
          else
            return(getFrame(c.getParent()));
    }
    public boolean action(Event evt, Object obj) {
        if (evt.target == pButton1) {
            // zpb_begin SampleGenCodeButton1Clicked
            // zpb_end
        }

        // zpb_begin SampleGenCodeAction
        // zpb_end

        return true;
   }

    // zpb_begin SampleGenCodeAppletUserMethods
    // zpb_end
}
// zpb_begin UserClasses
// zpb_end

</pre>
<a name="0229_03b0"><H4>Listing  Two</H4>
<pre>
/*
This class is a basic extension of the Applet class. It would generally
be
used as the main class with a Java browser or the AppletViewer. But an
instance
can be added to a subclass of Container.  To use this applet with a browser
or
the AppletViewer, create an html file with the following code:

    &lt;HTML&gt;
    &lt;HEAD&gt;
    &lt;TITLE&gt;SampleGenCode window&lt;/TITLE&gt;
    &lt;/HEAD&gt;
    &lt;BODY&gt;

    &lt;APPLET CODE=&quot;SampleGenCode.class&quot; WIDTH=332
HEIGHT=169&gt;&lt;/APPLET&gt;

    &lt;/BODY&gt;

    &lt;/HTML&gt;

    You can add controls to Simple with Cafe Studio.
    (Menus can be added only to subclasses of Frame.)
 */

import java.awt.*;

public class SampleGenCode extends java.applet.Applet {

    public void init() {

     //{{INIT_CONTROLS      setLayout(null);
     addNotify();
    
resize(insets().left+insets().right+380,insets().top+insets().bottom+281);
     panel1=new Panel();
     panel1.setLayout(null);
     add(panel1);
     panel1.reshape(insets().left + 49,insets().top + 128,203,75);
     group1= new CheckboxGroup();
     button1=new Button(&quot;Button&quot;);
     add(button1);
     button1.reshape(insets().left + 14,insets().top + 15,88,26);
     label1=new Label(&quot;Label&quot;);
     add(label1);
     label1.reshape(insets().left + 126,insets().top + 15,70,105);
     check1=new Checkbox(&quot;Radio button&quot;,group1,
false);
     add(check1);

     check1.reshape(insets().left + 231,insets().top + 60,105,38);
     check2=new Checkbox(&quot;Radio button&quot;,group1,
false);
     panel1.add(check2);
     check2.reshape(42,30,105,18);
     //}}

        super.init();
    }
    public boolean handleEvent(Event event) {
        return super.handleEvent(event);
    }
    //{{DECLARE_CONTROLS
    Panel panel1;
    CheckboxGroup group1;
    Button button1;
    Label label1;
    Checkbox check1;
    Checkbox check2;
    //}}
}

</pre>
<a name="0229_03b1"><H4>Listing  Three</H4>
<pre>
import java.util.Vector;
import java.applet.Applet;
import java.awt.*;
import java.util.Hashtable;
import opusmeta.*;
import opusjava.*;
/****************************************************************************\
**  (C) Copyright 1996 by Autodesk, Inc.                                   
**
**  The information contained herein is confidential, proprietary          
**
**  to Autodesk,  Inc.,  and considered a trade secret as defined          
**
**  in section 499C of the penal code of the State of California.          
**
**  Use of  this information  by  anyone  other  than  authorized          
**
**  employees of Autodesk, Inc.  is granted  only under a written          
**
**  non-disclosure agreement,  expressly  prescribing  the  scope          
**
**  and manner of such use.                                                 **
\****************************************************************************/

/****************************************************************************\
**                                                                          **
**  This Java source file contains machine generated code which            
**
**  will instantiate a HyperWire object network in Javaese.  Because       
**
**  the code is generated procedurally within HyperWire, it might appear   
**
**  somewhat odd (repetitive, cryptic, etc.).                              
**
\****************************************************************************/

final public class Hyperwire extends OpusApplet
  {
  Hashtable plugInMetaData = new Hashtable();

/****************************************************************************\
**  The following are the resetting methods.  There is one method          
**
**  for each module instance.  The method is called when the               
**
**  module is initialized and whenever the module needs to be              
**
**  reset.  These are NOT public methods.  To reset a module               
**
**  from the plug-in, or wherever, call the public                         
**
**  resetModule( Nodule aModule ) method with the module                   
**
**  you want to reset.                                                      **
\****************************************************************************/

  private final void resetModule0( Nodule aModule )
    {
    AppletBundle ab = ( AppletBundle ) aModule.getBundle();
    OpusPlugInProperties ap = (OpusPlugInProperties)
((OpusBasicPlugIn)
                                         aModule.getPlugIn()).getProperties();
    ab.setUserData( OpusString.from( &quot;nil&quot; ) );
    ab.setBaseFlags( 3 );
    ab.setAttributesChanged( false );
    ab.setIsClickable( false );
    ab.setIsEnabled( true );
    ab.setMouseNotify( true );
    ab.setIsVisible( true );
    ab.setRect( ( new Rectangle( 0, 0, 640, 480 ) ) );
    ab.setRepaintWhenOff( true );
    ab.setRepaintWhenOn( true );
    ab.setReferencePoint( new ReferencePoint ( 8 ) );
    ab.setConstrainChildren( true );
    ab.setBackdrop( new Backdrop( ( new Color ( 255, 255, 255 ) ) )
);
    ab.setAppletInfo( &quot;Another fine Opus generated applet.
        \\nGenerated on 04/25/96 at 04:19:13 PM\\nTo supply your
own
        message here, edit the applet comment.&quot; );
    {
    String pInfoInitializer[][] =
        {
        };
    ab.setParameterInfo( pInfoInitializer );
    }
    }
  private final void resetModule1( Nodule aModule )
    {
    VisualBundle ab = ( VisualBundle ) aModule.getBundle();     
    OpusPlugInProperties ap = ( OpusPlugInProperties ) ( ( OpusBasicPlugIn
)
                                       aModule.getPlugIn() ).getProperties();
    BmpButtonPlugIn aPlugIn = ( BmpButtonPlugIn )
aModule.getPlugIn();

    ab.setUserData( OpusString.from( &quot;nil&quot; ) );
    ab.setBaseFlags( 2 );
    ab.setAttributesChanged( false );
    ab.setRect( ( new Rectangle( 78, 124, 59, 49 ) ) );
    ab.setIsClickable( true );
    ab.setIsDragOnTop( false );
    ab.setRepaintWhenOn( true );
    ab.setRepaintWhenOff( true );
    ab.setResetWhenOn( false );
    ab.setReferencePoint( new ReferencePoint ( 8 ) );
    ab.setIsMoveable( false );
    ab.setIsSelectable( false );
    ab.setIsVisible( true );
    aPlugIn.setUpImageRef( ( new ImageReference(
&quot;3sync1.JPG&quot;, null,
                                  true, false, true, new Point ( 59,49 ) ) ) );
    aPlugIn.setDownImageRef( ( new ImageReference( &quot;&quot;, null,
true, false,
                                  true, new Point ( 0,0 ) ) ) );
    }
  private final void resetModule2( Nodule aModule )
    {
    VisualBundle ab = ( VisualBundle ) aModule.getBundle();
    LabelProperties ap = ( LabelProperties ) ( ( OpusBasicPlugIn )
                                        aModule.getPlugIn() ).getProperties();
    ab.setUserData( OpusString.from( &quot;nil&quot; ) );
    ab.setBaseFlags( 2 );
    ab.setAttributesChanged( false );
    ab.setRect( ( new Rectangle( 229, 78, 100, 139 ) ) );
    ab.setIsClickable( true );
    ab.setIsDragOnTop( false );
    ab.setRepaintWhenOn( true );
    ab.setRepaintWhenOff( true );
    ab.setResetWhenOn( false );
    ab.setReferencePoint( new ReferencePoint ( 8 ) );
    ab.setIsMoveable( false );
    ab.setIsSelectable( false );
    ab.setIsVisible( true );
    ap.setString( &quot;Text&quot; );
    ap.setForeColor( ( new Color ( 0, 0, 0 ) ) );
    ap.setBackColor( ( new Color ( 255, 255, 255 ) ) );
    ap.setFont( new Font( &quot;MS Sans Serif&quot;, 0, 11 ) );
    ap.setHorizontalAlign( 1 );
    ap.setTransparent( true );
    ap.setVerticalAlign( 4 );
    ap.setXMargin( 6 );
    ap.setYMargin( 6 );
    }
  private final void resetModule3( Nodule aModule )
    {
    VisualBundle ab = ( VisualBundle ) aModule.getBundle();
    OpusPlugInProperties ap = ( OpusPlugInProperties ) ( ( OpusBasicPlugIn
)
                         aModule.getPlugIn() ).getProperties();     
     BmpButtonPlugIn aPlugIn = ( BmpButtonPlugIn )
aModule.getPlugIn();

    ab.setUserData( OpusString.from( &quot;nil&quot; ) );
    ab.setBaseFlags( 2 );
    ab.setAttributesChanged( false );
    ab.setRect( ( new Rectangle( 448, 111, 59, 49 ) ) );
    ab.setIsClickable( true );

    ab.setIsDragOnTop( false );
    ab.setRepaintWhenOn( true );
    ab.setRepaintWhenOff( true );
    ab.setResetWhenOn( false );
    ab.setReferencePoint( new ReferencePoint ( 8 ) );
    ab.setIsMoveable( false );
    ab.setIsSelectable( false );
    ab.setIsVisible( true );
    aPlugIn.setUpImageRef( ( new ImageReference(
&quot;3sync1.JPG&quot;, null,
                                true, false, true, new Point ( 59,49 ) ) ) );
    aPlugIn.setDownImageRef( ( new ImageReference( &quot;&quot;,
null,
                                true, false, true, new Point ( 0,0 ) ) ) );
    }
  private final void resetModule4( Nodule aModule )
    {
    VisualContainerBundle ab = ( VisualContainerBundle )
aModule.getBundle();
    VisualContainerProperties ap = ( VisualContainerProperties )
                   ( ( OpusBasicPlugIn ) aModule.getPlugIn()
).getProperties();
    ab.setUserData( OpusString.from( &quot;nil&quot; ) );
    ab.setBaseFlags( 2 );
    ab.setAttributesChanged( false );
    ab.setIsClickable( false );
    ab.setIsEnabled( true );
    ab.setMouseNotify( true );
    ab.setIsVisible( true );
    ab.setRect( ( new Rectangle( 146, 213, 200, 217 ) ) );
    ab.setRepaintWhenOff( true );
    ab.setRepaintWhenOn( true );
    ab.setReferencePoint( new ReferencePoint ( 8 ) );
    ab.setConstrainChildren( true );
    ab.setBackdrop( new Backdrop( ( new Color ( 255, 255, 255 ) ) )
);
    ab.setIsMoveable( false );
    }
  private final void resetModule5( Nodule aModule )
    {
    VisualBundle ab = ( VisualBundle ) aModule.getBundle();
    OpusPlugInProperties ap = ( OpusPlugInProperties )
                   ( ( OpusBasicPlugIn ) aModule.getPlugIn()
).getProperties();
    BmpButtonPlugIn aPlugIn = ( BmpButtonPlugIn )
aModule.getPlugIn();

    ab.setUserData( OpusString.from( &quot;nil&quot; ) );
    ab.setBaseFlags( 2 );
    ab.setAttributesChanged( false );
    ab.setRect( ( new Rectangle( 42, 0, 59, 49 ) ) );
    ab.setIsClickable( true );
    ab.setIsDragOnTop( false );
    ab.setRepaintWhenOn( true );     ab.setRepaintWhenOff( true );
    ab.setResetWhenOn( false );
    ab.setReferencePoint( new ReferencePoint ( 8 ) );
    ab.setIsMoveable( false );
    ab.setIsSelectable( false );
    ab.setIsVisible( true );
    aPlugIn.setUpImageRef( ( new ImageReference(
&quot;3sync1.JPG&quot;, null,
                              true, false, true, new Point ( 59,49 ) ) ) );
    aPlugIn.setDownImageRef( ( new ImageReference( &quot;&quot;, null,
true, false,
                               true, new Point ( 0,0 ) ) ) );
    }
  private final void resetModule6( Nodule aModule )
    {
    VisualContainerBundle ab = ( VisualContainerBundle )
aModule.getBundle();
    VisualContainerProperties ap = ( VisualContainerProperties )
                  ( ( OpusBasicPlugIn ) aModule.getPlugIn()
).getProperties();
    ab.setUserData( OpusString.from( &quot;nil&quot; ) );
    ab.setBaseFlags( 2 );
    ab.setAttributesChanged( false );
    ab.setIsClickable( false );
    ab.setIsEnabled( true );
    ab.setMouseNotify( true );
    ab.setIsVisible( true );
    ab.setRect( ( new Rectangle( 0, 17, 200, 200 ) ) );
    ab.setRepaintWhenOff( true );
    ab.setRepaintWhenOn( true );
    ab.setReferencePoint( new ReferencePoint ( 8 ) );
    ab.setConstrainChildren( true );
    ab.setBackdrop( new Backdrop( ( new Color ( 255, 255, 255 ) ) )
);
    ab.setIsMoveable( false );
    }
/****************************************************************************\
**  Method:  public void resetModule( Nodule aModule )                     
**
**  Purpose:                                                                **
**  Resets aModule back to its initial state.                               **
\****************************************************************************/
  public void resetModule( Nodule aModule )
    {
    switch ( aModule.getID() )
      {
      case 0:
        resetModule0( aModule );
        break;
      case 1:
        resetModule1( aModule );
        break;
      case 2:
        resetModule2( aModule );
        break;
      case 3:
        resetModule3( aModule );
        break;
      case 4:
        resetModule4( aModule );
        break;       case 5:
        resetModule5( aModule );
        break;
      case 6:
        resetModule6( aModule );
        break;

      default:
        break;
      }
    }
/****************************************************************************\
**  Method:  void instantiateModules()                                      **
**  Purpose:                                                                **
**  Instantiates the nodules, run-reps and models and links up             
**
**  the module hierarchy.                                                   **
\****************************************************************************/


  protected void instantiateModules()
    {
    Nodule aNodule;
    RunRepresentation aRunRep;
    Nodule rootAppletModule;

    moduleEnumeration = new Nodule[7];
    nModules = 0;

/*****************************************************************************\
**                                                                           **
**  Step: 1                                                                  **
**  Task: Instantiate the modules.  Builds                                  
**
**        a mapping array which maps module IDs (ints) to their             
**
**        corresponding module references.                                  
**
**                                                                           **
\*****************************************************************************/
        // Get the appropriate meta data for module of type: Title
Module
  if( plugInMetaData.get( &quot;AppletModuleMetaData&quot; ) ==
null)
    { plugInMetaData.put( &quot;AppletModuleMetaData&quot;,
                                           (new AppletModuleMetaData() ) ); }
        // Instantiate Module of Type: Title Module PathName: /Title
Module
  newModule( ( new AppletPlugIn() ), &quot;Title Module&quot;,
               (PlugInMetaData) plugInMetaData.get(
&quot;AppletModuleMetaData&quot;) );
        // Get the appropriate meta data for module of type: Button
  if( plugInMetaData.get( &quot;BmpButtonMetaData&quot; ) ==
null)
    { plugInMetaData.put( &quot;BmpButtonMetaData&quot;, (new
BmpButtonMetaData() ) ); }
        // Instantiate Module of Type: Button PathName: /Title
Module/Button
  newModule( ( new BmpButtonPlugIn() ), &quot;Button&quot;,
(PlugInMetaData)
                                    plugInMetaData.get(
&quot;BmpButtonMetaData&quot;) );
        // Get the appropriate meta data for module of type: Label
  if( plugInMetaData.get( &quot;LabelMetaData&quot; ) == null)
    { plugInMetaData.put( &quot;LabelMetaData&quot;, (new LabelMetaData()
) ); }
        // Instantiate Module of Type: Label PathName: /Title
Module/Label
  newModule( ( new LabelPlugIn() ), &quot;Label&quot;,
(PlugInMetaData)
                                       plugInMetaData.get( &quot;LabelMetaData&quot;)
);         
// Get the appropriate meta data for module of type: Button
  if( plugInMetaData.get( &quot;BmpButtonMetaData&quot; ) ==
null)
    { plugInMetaData.put( &quot;BmpButtonMetaData&quot;, (new
BmpButtonMetaData() ) ); }
        // Instantiate Module of Type: Button PathName: /Title
Module/Button1
  newModule( ( new BmpButtonPlugIn() ), &quot;Button1&quot;,
(PlugInMetaData)
                                    plugInMetaData.get(
&quot;BmpButtonMetaData&quot;) );
        // Get the appropriate meta data for module of type: Visual
Container
  if( plugInMetaData.get( &quot;VisualContainerMetaData&quot; ) ==
null)
    { plugInMetaData.put( &quot;VisualContainerMetaData&quot;,
                                         (new VisualContainerMetaData() ) ); }
        // Instantiate Module of Type: Visual Container PathName:
        //                                  /Title Module/Visual Container1
  newModule( ( new VisualContainerPlugIn() ), &quot;Visual
Container1&quot;,
             (PlugInMetaData) plugInMetaData.get(
&quot;VisualContainerMetaData&quot;) );
        // Get the appropriate meta data for module of type: Button
  if( plugInMetaData.get( &quot;BmpButtonMetaData&quot; ) ==
null)
    { plugInMetaData.put( &quot;BmpButtonMetaData&quot;, (new
BmpButtonMetaData() ) ); }
        // Instantiate Module of Type: Button PathName:
        //                  /Title Module/Visual Container1/Button2
  newModule( ( new BmpButtonPlugIn() ), &quot;Button2&quot;,
(PlugInMetaData)
                                    plugInMetaData.get(
&quot;BmpButtonMetaData&quot;) );
        // Get the appropriate meta data for module of type: Visual
Container
  if( plugInMetaData.get( &quot;VisualContainerMetaData&quot; ) ==
null)
    { plugInMetaData.put( &quot;VisualContainerMetaData&quot;,
                                    (new VisualContainerMetaData() ) ); }
        // Instantiate Module of Type: Visual Container PathName:
        //                   /Title Module/Visual Container1/Visual
Container
  newModule( ( new VisualContainerPlugIn() ), &quot;Visual
Container&quot;,
             (PlugInMetaData) plugInMetaData.get(
&quot;VisualContainerMetaData&quot;) );
/***************************************************************************\
**  Step: 2                                                               **
**  Task: Setup links from each parent container to its submodules.      
**
\***************************************************************************/
    aNodule = fromID(0);
    linkChildModule( aNodule, 1 );
    linkChildModule( aNodule, 2 );
    linkChildModule( aNodule, 3 );
    linkChildModule( aNodule, 4 );
    aNodule = fromID(4);
    linkChildModule( aNodule, 5 );
    linkChildModule( aNodule, 6 );
    aNodule = fromID(6);
/****************************************************************************\
**  Step: 3                                                                **
**  Task: Call a little recursive method which fixes up all the module    
**
**        backpointers in the hierarchy.                                   **
\****************************************************************************/
    mRootModule = fromID( 0 );
    mRootModule.setOwner( null );
    fixupModuleBackpointers( mRootModule );
    }
/****************************************************************************\
**  Method:  void instantiateWiring()                                       **
**  Purpose:                                                                **
**  Instantiates the wiring network.                                        **
\****************************************************************************/
  protected void instantiateWiring()
    {
    Nodule senderModule;
    Nodule receiverModule;
    Interface senderInputInterface;
    Interface senderOutputInterface;
    Interface receiverInterface;
    UserMessageTableEntry mte;
    WireMessage aWire[] = new WireMessage[32];
    portEnumeration = new UserMessageTableEntry[0];
/****************************************************************************\
**  Step: 1                                                                 **
**  Task: Instantiate the interface ports for the modules.                 
**
\****************************************************************************/

/****************************************************************************\
**  Step: 2                                                                 **
**  Task: Instantiate the wires.                                            **
\****************************************************************************/
    }
  }

</pre>

</BODY></HTML>
