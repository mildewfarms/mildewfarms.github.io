
<html>
<head>
<title>September, 2005: Finding Binary Clones  With Opstrings &amp;  Function Digests:  Part III</title>
</head>

<body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000">
<!--Copyright &#169; Dr. Dobb's Journal-->

<h1>Finding Binary Clones  With Opstrings &amp;  Function Digests:  Part III</h1>
<p><i>Dr. Dobb's Journal</i> September, 2005</p>
<h2>Implementation  and testing </h2>


<h3>By Andrew Schulman</h3>


<I>Andrew is a software litigation consultant who works on the technical aspects of cases involving copyright, patents, trade secrets, antitrust, and privacy. He can be contacted at undoc@sonic.net or http://www.undoc.com/.</I>

<hr>





<p>Can a few extracts from a piece of binary code be sufficient to identify that piece of code in a large database? As discussed in the two previous parts of this article, a piece of binary code's noteworthy features can be extracted and placed into an opstring, an ordered set of instruction mnemonics or operations ("ops"). Noteworthy features include atypical instructions, system or API calls, branch-target locations (places the code may jump to), and the use of unlikely "magic" numbers.</p>

<p>In x86 Win32 code, one such opstring would be:<i> "test, jz, call, test, jz, call, ret, loc, [HeapFree], loc, ret"</i>. Using an algorithm such as MD5, this can be turned into a function digest such as 65E482BF6A2F391D84D243D9E02244D7. If the function's name is known, either from debug symbols or from a Win32 DLL export table, the function digest and name can be added to a function database. The "<i>test,jz,..</i>." example and its MD5 signature happen to correspond to one implementation of the <i>free</i> C runtime library (RTL) function. If, in some other program, a function were encountered with a digest of 65E482BF6A2F391D84D243D9E02244D7, it could with a fair degree of certainty be identified as <i>free</i>. How much certainty is one of the subjects of this third and final article on binary code lookup and comparison.</p>

<p>Generating additional symbolic information for otherwise anonymous code&#151;using symbols from one file to ID code in a different file&#151;can tell you, when staring at code in a debugger, that some function is the <i>free</i> memory-deallocation function; this beats trying to read and understand the code. </p>

<p>However, that is a fairly limited use. Given a large database with MD5 signatures for every function in every Win32 file preinstalled on a typical PC or on the Windows XP CD, you can measure the amount of code duplication in the system, classify modules by sorting them into sets based on how much code they share in common, identify code that should perhaps be moved into a shared library, or find multiple instances of flawed code.</p>
<h3>Excluding Boilerplate</h3>

<p>I had a different purpose when I started this project: Not to use or study the contents of the function database, but instead to filter it out as noise. The function database was intended merely as a list of "boilerplate" code&#151;stereotyped verbiage&#151;that could be ignored when comparing binary modules in copyright infringement litigation.</p>

<p>Almost all litigation happens outside a courtroom. At least in the U.S., the majority of legal cases never reach trial (the system would collapse if more than a handful did). Cases are settled based on each side's estimation of the "value" of the case, determined in part by what each side learns about both sides to the case. Modern rules of "discovery" require each side to turn over to the other side ("produce") certain types of information, such as potentially relevant internal corporate e-mails and other documents (for typical examples, see http://www.usdoj.gov/atr/cases/ms_exhibits.htm).  </p>

<p>In software copyright litigation, this includes each side's source code. Each side's expert compares the two sets of source code, looking for literal similarities that shouldn't be there, and for signs of nonliteral copying. (Each source tree may consist of millions of lines of code, so this process must be automated. It's a bit harder than it sounds. Hints: diff is not the right tool; associative arrays are nearly essential.)</p>

<p>Even open-source software is faced with issues like these: What percentage does GNU represent of a typical Linux distribution? Is a commercial vendor reusing open-source code without abiding by the GPL (see gpl-violations.org)? Has a contributor used copyrighted code?</p>

<p>Binary comparison is useful in part because source is sometimes unavailable. Not surprisingly, litigants sometimes resist turning over their source code ("the crown jewels") to the other side, even with court protective orders limiting who may see the source code. Also, a litigant only sees the other side's source code after it becomes an actual litigant. Thus, a software copyright complaint will generally be issued before the plaintiff has seen the defendant's source code. In the U.S., complaints can be filed "upon information and belief," and can later be amended. Still, a plaintiff should try confirming their suspicions. Meanwhile, a potential defendant might also have concerns ("I wonder if my programmers have been 'borrowing' code from their previous jobs"). If and when both sides' source code becomes available, the binary comparison is a double check, and may pinpoint specific source-code areas to investigate.</p>

<p>When detecting similarities in code&#151;be it source or binary&#151;there must be a baseline for comparison. Comparing any two otherwise-unrelated source-code trees, written in the same programming language and/or targeting the same operating system, yields some exact matches that nonetheless don't reflect copying, such as<i> return 0; </i>and<i> for (int i=0; i&lt;count; i++) </i>in C code. Such lines need to be excluded from any source-code comparison. They are, in the context of such a comparison, noise, mere boilerplate: Everyone uses these phrases, so their presence is uninformative. (However, while boilerplate code is generally excluded from such percentages, boilerplate code that is merely a small part of a larger block of nonboilerplate code is generally included in the overall matching percentage.)</p>

<p>You generally "normalize" each line of source code by ignoring all white space (though in one case, a developer had used combinations of spaces and tabs as Morse-coded copyright notices). If you suspect juvenile forms of plagiarism, you might normalize all variable names; one of the benefits of comparing binary code is that the compiler eliminates names for you. You probably would not exclude comments because shared misspellings and errors may indicate copying (see Bob Zeidman's "Detecting Source-Code Plagiarism," <i>DDJ</i>, July 2004). </p>

<p>Lines can be normalized as each line of code is inspected, but filtering out boilerplate is different: You can't tell, just by looking at it, that something is standard verbiage. You need a boilerplate database, constructed at some earlier point by running through lots of other code&#151;the baseline code you're not going to compare&#151;and pulling out the most frequently occurring lines, like <i>int i;</i> and <i>return 0. </i></p>

<p>Similarly, binary-code comparison needs a baseline&#151;a database of boilerplate functions that, if found in the programs under comparison, should be ignored. The original purpose of Opstring was to build this database, by generating MD5 digests for every function included with Windows XP. This database contains MD5 signatures for C RTL functions, compiler startup code, standard sample code from Microsoft's software development kits, Visual Studio "wizard" code, and so on. Microsoft's debug symbol packages (see http://www .microsoft.com/whdc/devtools/debugging/ symbolpkg.mspx) provide names for the functions in nearly every XP DLL. Even without these names, while I don't necessarily know what each function is, my binary-code copying-detection program knows to ignore any copies of that function encountered in the two sets of binaries under comparison. (Additional code may need to be excluded from consideration, even if it's not found in the standard function database; see <i>Computer Associates v. Altai.</i>)</p>
<h3>Does "Structurally Similar"  Really Mean "Clone"?</h3>

<p>As noted, the function database contains MD5 digests of opstrings, each of which is a string of the noteworthy features of a function. For example, the C source code in <a name="rf1"></a><a href="0509if1.html">Figure 1</a>(a), compiled to produce something like the code in <a name="rf1"></a><a href="0509if1.html">Figure 1</a>(b), yields the opstring in <a name="rf1"></a><a href="0509if1.html">Figure 1</a>(c) and the MD5 digest in <a name="rf1"></a><a href="0509if1.html">Figure 1</a>(d).</p>

<p>The instruction mnemonics have been extracted from the disassembly, the common<i> mov, push,</i> and <i>pop</i> instructions discarded, and the remaining mnemonics placed into the string, along with "loc" pseudo-ops, indicating the targets of the <i>jz</i> and <i>jnz</i> instruction. The operands have been ignored. </p>

<p>While <a name="rf1"></a><a href="0509if1.html">Figure 1</a>(c) plainly abbreviates the code in <a name="rf1"></a><a href="0509if1.html">Figure 1</a>(b), it is less clear that <a name="rf1"></a><a href="0509if1.html">Figure 1</a>(c) truly represents <a name="rf1"></a><a href="0509if1.html">Figure 1</a>(b), much less its source in <a name="rf1"></a><a href="0509if1.html">Figure 1</a>(a). After all, wouldn't a lot of other code, looking nothing like <a name="rf1"></a><a href="0509if1.html">Figure 1</a>(a) or <a name="rf1"></a><a href="0509if1.html">Figure 1</a>(b), also abbreviate to <a name="rf1"></a><a href="0509if1.html">Figure 1</a>(c)? </p>

<p>It turns out that the answer is no in this particular case. A database of about 775,000 function digests, representing most of the binary code in Windows XP SP2, did not contain a match for the function digest in <a name="rf1"></a><a href="0509if1.html">Figure 1</a>(d). Even having discarded so much of the function, what's left are reasonably reliable indicators of the function's identity.  </p>

<p>Knowing that the opstring algorithm ignores <i>mov, push, </i>and <i>pop</i>, you could easily construct a function that differed from <a name="rf1"></a><a href="0509if1.html">Figure 1</a>(a) but that yielded the same opstring as in <a name="rf1"></a><a href="0509if1.html">Figure 1</a>(c). For example, <a name="rf1"></a><a href="0509if1.html">Figure 1</a>(e) appears to be a false positive, but only under a literal definition of "clone," in which even obvious cut-and-paste variations are treated as nonmatches. As noted in Part II of this series, Opstring was written to ignore minor differences. In other words, this is a feature, not a bug. It is important to have a uniform method for generating the function database, but a testing version of Opstring (available electronically; see "Resource Center," page 3) does provide command-line options to control what is included or excluded in an opstring, allowing for different definitions of "clone."  </p>

<p>If two opstrings match, then&#151;given a minimum opstring length&#151;the binary code from which they were generated (and, to a lesser extent, the overlying source code) will be sufficiently similar that someone eyeballing them would regard them, perhaps not as identical, but as a good match, such that one could be a cut-and-paste variation of the other. In other words, we are backing into a working definition of "clone," based on what this tool can find. A binary-code "clone" can be defined as a match found by Opstring. </p>

<p>Obviously, not all tools are worth listening to. A "tool" that hashed any piece of code, of whatever length, to a single byte, would "tell" us which of the only 256 types of code in existence a given function fell into. Like classifying people by their astrological signs, it would provide only the illusion of usefulness. There's a similar danger here, because we're usually looking at compiler output (rather than hand-written assembler), and one can expect great regularity, even given infinite possible source-code input, because the compiler acts as a funnel, narrowing infinite varieties of source into a relatively small number of microprocessable structures.</p>
<h3>Testing for False Positives</h3>

<p>Where symbolic names are available, one test for false positives checks for ostensibly matching functions that have significantly different names. Multiple function names mapped to the same function digest (MD5 signature) may indicate that the opstrings from which the signatures are created are not good indicators of the function's identity. In my first test, nearly half of the named signatures appearing more than once had more than one name. However, browsing through the test program's output showed that nearly all the mismatches were C++ mangled/decorated names that differed from each other in only minor respects, such as <i>?Unlock@Perimeter@@QAEXXZ </i>versus <i>?Unlock@RWLock@@QBEXXZ,</i> or ?<i>Remove@foo </i>versus<i> ?Update@foo </i>versus<i> ?Set@foo.</i> These functions tended to be shorter than the system average. In many cases, the seemingly mismatched names were all located in a single file, indicating that indeed the functions were related, despite the different names. I also found many cases where, despite having used Microsoft's symchk utility, PDB symbols and code were misaligned. </p>

<p>When I reran the test, this time looking only for cases where code appears in more than one file and where a given symbol is used in more than one file (to eliminate PDB misalignments), ignoring all nonalpha characters, and looking only at the first five characters of the function name, the result was still that almost 3 percent of the signatures had one or more names that apparently mismatched the others in its first five characters. </p>

<p>Of the apparent mismatches, many were C RTL functions, such as <i>isdigit</i>, <i>islower</i>, and <i>ispunct</i> mapping to the same signature. That Opstring currently treats, say, <i>islower</i> and <i>isupper</i> as the same function may reduce its ability to supply exact symbolic names to disassembly listings, but does not undercut its ability to find code clones. <a name="rf2"></a><a href="0509if2.html">Figure 2</a> shows what some of the remaining apparent mismatches look like (the first column is the opstring length). </p>

<p>I did find one genuine mismatch, so surely there must be others, especially in signatures based on shorter opstrings. <a name="rf3"></a><a href="0509if3.html">Figure 3</a>(a) shows the offending opstring, <a name="rf3"></a><a href="0509if3.html">Figure 3</a>(b) lists a few of the 30 functions whose code abbreviates to this opstring; Figures 3(c) and 3(d) are two examples of the actual code. Even here, given that the code in <a name="rf3"></a><a href="0509if3.html">Figure 3</a>(c) is called "Cleanup" and calls <i>CoTaskMemFree</i> twice, and that the code in <a name="rf3"></a><a href="0509if3.html">Figure 3</a>(d) calls C++ <i>operator delete</i> ("YAXPAX" in Microsoft C++) twice, the functions perhaps aren't totally unrelated. But clones, probably not.</p>

<p>Even though many of the mismatches are only apparent, some clearly are real; the 3 percent given earlier is probably a reasonable upper bound on the false-positive rate. This was based on a minimum opstring length of 12, and the false-positive rate can be reduced simply by requiring longer opstrings. A minimum length of 40 brings the false-positive rate down to about 1 percent.</p>

<p>This raises the question of the ideal minimum length for an opstring. The Opstring program discards any function whose opstring is shorter than the desired minimum. The average opstring length in XP is about 55. As seen in <a name="rf1"></a><a href="0509if1.html">Figure 1</a>, even a fairly small C function yielded an opstring whose length was 15. As a rough back-of-the-envelope figure, say there are about four  "ops" per line of nonblank, noncomment C code. A minimum opstring length of 20 or 25 then represents a function definition, curly braces, some variable definitions, and five or six lines of actual code. </p>
<h3>False Negatives</h3>

<p>Different compilers can take the same source code and produce fairly different binary code. The same compiler, with different optimization settings, can do the same thing. Likewise, a single piece of source code that uses preprocessor macros or C++ templates can generate disparate binary code. Given a<i> template&lt;class T&gt;</i> class <i>Stack</i>, with <i>Push</i> and <i>Pop</i> methods, consider the difference between <i>Stack&lt;int&gt;, Stack&lt;float&gt;,</i> and <i>Stack&lt;class Foo&gt;.</i> The developer wrote <i>Push</i> and <i>Pop</i> once, but the compiler generates three different pieces of code for each. To still detect the underlying similarities between these three different binary versions of <i>Stack::Push</i>, based on the instruction mnemonics, would likely require boiling away so many differences among the three versions that unacceptably high false positives would result. </p>

<p>One approach to reduce false negatives is to match on something other than function boundaries. In addition to using branch targets for the "loc" pseudo-op, they could act as delimiters for the blocks of code from which to generate opstrings. With smaller blocks of code to consider, naturally more matches would be found. But considering each branch target as a separate block of code will result in many blocks of code that fall below the minimum length that avoids false positives. One solution is to consider both functions as a whole, and the branch-target blocks within them.</p>

<p>Another approach is to ignore boundaries entirely. The self-similarity within a file or group of files found using the DotPlot method (see "Dotplot: A Program for Exploring Self-Similarity in Millions of Lines of Text and Code," by Kenneth Church and Jonathan Helfman; http://imagebeat.com/dotplot/rp.jcgs.pdf). DotPlot is typically a visual technique in which duplication appears as diagonal lines, but the diagonals can be produced nonvisually (and thus selected by another program) by comparing every element of a string with every other element, using nested <i>for</i> loops. Church and Helfman describe several easy-to-implement optimizations that  allow most comparisons to be skipped, by ignoring high-frequency tokens (much as Opstring ignores high-frequency instruction mnemonics). The frequency with which tokens appear can also be used to do weighted matching. </p>

<p>All of this can be applied to binary code, once this code has been turned into some form of text, like an opstring. One of the benefits of opstrings, apart from generating MD5 digests, is that they allow textual methods such as DotPlot to be applied, in effect, to binaries. Using the DotPlot method and a hacked version of Opstring, I located large tracts of duplicated code, crossing function boundaries, in Windows programs. However, even with the Church/Helfman optimizations, the program was significantly slower than comparisons with MD5 digests.</p>

<p>Apart from redefining what gets matched with what, we can also allow nonexact matching. By modifying the Levenshtein edit-distance algorithm (see "Finding String Distances," by Ray Valdes; <i>DDJ</i>, April 1992) to work with ops rather than characters, we could find identical functions by finding those whose opstrings have an edit distance of zero, then locate slight variations by selecting those pairs with small edit distances, for instance, only a small number of insertions, deletions, or substitutions needed to turn one opstring into the other. As with the DotPlot method, this too is significantly slower than comparing MD5 digests.</p>
<h3>Implementation</h3>

<p>The Opstring program (available electronically; see "Resource Center," page 3) is implemented in the AWK programming language, which simplifies text manipulation (if desired, the AWK code can be translated into Perl with a2p). Even though Opstring digests binary files, it's a text-manipulation tool that depends on an external disassembler, DumpPE. AWK splits each line of text input into space-delimited fields, designated as <i>$1, $2</i>, and so on. The entire input line is<i> $0</i>, and the number of fields is <i>NF</i>. In DumpPE disassembly output such as in <a name="rf1"></a><a href="0509if1.html">Figure 1</a>(b), opcode bytes appear in<i> $2</i>, the instruction mnemonic in <i>$3</i>, and operands in<i> $4</i>. A function label or branch target appears in <i>$2</i>. To aid reading the code listing, <a name="rf4"></a><a href="0509if4.html">Figure 4</a> presents pseudocode.</p>

<p>When Opstring sees a function boundary, it outputs the previously collected filename, function name, and opstring, then sets up for the next opstring. When Opstring sees an instruction, it adds it to the opstring. All else is commentary. </p>

<p>Opstring could work directly on PE files, but it makes more sense, and not only for ease of implementation, to simply create a wrapper around an existing disassembler, DumpPE (http://www.tbcnet.com/~clive/dumppe.htm). While Opstring is currently overly tied to the DumpPE output format in particular, and Wintel code in general, there is little reason it couldn't be generalized for other disassemblers and other instruction sets. (Java and .NET IL come to mind, though there are decent decompilers for both of these, allowing somewhat higher level comparison methods.)</p>

<p>Microsoft's dumpbin is an obvious choice. Its <i>-disasm</i> option produces reasonable disassemblies of Win32 executable files. Newer versions use symbols in a PDB file. However, its output format is inconvenient to work with (each opcode byte is output followed by a space, making the location of the instruction mnemonic difficult to locate), and more importantly it does not identify branch targets. To use Opstring with dumpbin output, which is similar to that of the Linux objdump utility, I've written a converter (available electronically) that makes a first pass over a listing, looking for calls and jumps, to construct a pseudosymbol table that is then used to output function and branch-target labels on the second pass. </p>

<p>IDA Pro from DataRescue (http://www.datarescue.com/) is the gold standard in disassemblers. Its numerous features already include one of the side benefits that I've listed for opstrings and function digests&#151;identification of runtime library functions. IDA Pro's FLIRT ("Fast Library Identification and Recognition Technology") identifies functions using the first 32 bytes of a function, marking all variant bytes, and a CRC of the remaining bytes. Provision is made for the fact that functions such as <i>_strupr</i> and <i>_strlwr</i> share identical code. An IDA Pro external plug-in could presumably employ a database of opstring-style function signatures.</p>

<p>However, IDA Pro is designed largely for interactive use (it even includes a runtime debugger to help with encrypted or obfuscated code that is difficult to untangle when looking at a static listing). To build the database itself, however, which is the purpose of Opstring, interactivity is less useful. Thousands of disassemblies are generated, briefly used by another program, and then discarded. The end result is the function signature. </p>

<p>Clive Turvey's DumpPE is a good choice as the supplier of function names, branch targets, and instruction mnemonics to opstring. It makes two passes over the code to find branch targets, uses symbols from a PDB file, identifies functions and branch targets that are indirectly accessed via pointer tables, and identifies the names of Windows API calls.</p>

<p>A key problem is finding the start and end of each block to be compared, which generally will be a function. Opstring relies on DumpPE to find function starts; DumpPE gets these from entry points (especially from the PE file's export table), from any debug symbols, and from its first pass through the code.</p>

<p>Finding function ends is more difficult; this is the halting problem. As seen in the pseudocode, the program doesn't find function ends at all. It simply relies on seeing the next function, or the end of the disassembly. Function returns or unconditional jumps do not necessarily signal the end of a function, because code often contains multiple returns or jumps per function.</p>

<p>Because Opstring continues to add to the current opstring as long as it thinks it is inside the same function, it is crucial to filter out as much junk as possible. As seen in the pseudocode, opstring ignores NOPs, debugger invocations (INT 3), data that looks like code, and anything that will take the opstring length beyond a reasonable length. Any opstring that doesn't contain at least one <i>jmp</i> or <i>ret</i> is discarded, and any opstring of the maximum length is chopped back to the location of its first <i>jmp</i> or <i>ret</i>. </p>

<p>When Opstring has generated the opstrings for a file, they can be turned into MD5 digests with the MkMD5Db program (available electronically). This is little more than a wrapper around the standard MD5Init, MD5Update, and MD5Final functions originally written by Colin Plumb in 1993. MkMD5Db expects the name for an item specified on a line beginning with<i> '!'</i>, followed by one or more lines to be digested, and a blank line. Opstring, of course, outputs this format. </p>
<h3>Preliminary Results</h3>

<p>I noted in Part I that while this technique can be used for all sorts of things, these articles only construct the technique itself, deferring the actual use of it to some later time. While it is in the true spirit of software to construct tools and then move onto something else, without putting the tool to much use, it would be good to glimpse this hammer actually encountering some nails. </p>

<p>I took a Windows XP CD, expanded all files in the \I386 directory, and then discarded those that were not Win32 PE files. The result was 11,913 files (primarily DLLs), totaling 304 MB. I ran the following command on this directory:</p>

<blockquote>
for %f in (\pefiles\*.*) do dumppe -disasm <br>
   | awk -f opstring.awk <br>
 | mkmd5db &gt;&gt; xp_i386.db<br>

</blockquote>

<p>This ran in about half an hour on a cheap laptop computer. The resulting file contained just over 500,000 function signatures, of which 44,000 different signatures appeared more than once (and, on average, was used 3.8 times; thus, about 123,000 signatures were duplicates). The small program funcdupe.awk (available electronically) pulls an entire function database into an associative array and then generates these numbers. It also factors in opstring lengths to calculate a duplication percentage. For Windows XP, the result was 17 percent. </p>

<p>Considering that this includes startup and runtime library code that is included in many programs, 17 percent doesn't sound very high. On the other hand, considering that Windows is built around shared libraries (DLLs), and is supposed to comprise the very operating system itself, and not merely a loose collection of applications, this duplication rate could also be viewed as high. One study of source-code duplication in large systems reports a range (excluding comments and blank lines) from 8.7 percent in GCC, to 29 percent in a web-based message board written in Python, to 36.4 percent for a Smalltalk database server, and 59 percent for a COBOL payroll system ("A Language Independent Approach for Detecting Duplicated Code," by Stephane Ducasse et al., http://www.bauhaus-stuttgart.de/clones/Duploc_ICSM99_IEEECopyright.pdf). </p>
<h3>Previous Work</h3>

<p>Given that cut and paste comprises a lot of what developers do, it is not surprising that clone detection is a rich field of research, and even has its own annual "Detection of Software Clones" workshop, held in conjunction with the IEEE's annual Working Conference on Reverse Engineering (WCRE). For an excellent overview, see "Detecting Duplicated Code" in <i>Object-Oriented Reenginering Patterns</i>, by Serge Demeyer et al. (Morgan Kaufmann, 2002).</p>

<p>Over 10 years ago, Brenda Baker described "parameterized string matching" for the purpose of finding sections of code that are identical except for a systematic change of parameters. Initially this involved source rather than binary code, but has been extended to Java bytecodes (see http://cm.bell-labs.com/who/bsb/). Other key contributions are discussed in Parts I and II of this article.</p>

<p>Inspecting binary executable files has been particularly important to the antivirus industry. Binary signatures, with provision made for wildcards, are used to scan for known viruses (see<i> Art of Computer Virus Research and Defense</i>, by Peter Szor; Addison-Wesley Professional, 2005). It seems odd that the software used by millions every day isn't analyzed with the same rigor as malware. In large part, Opstring takes malicious-code analysis, as used by antivirus researchers, and tries to appropriate it to analysis of commercial software. </p>


<p><b></b></p>
<p><b>DDJ</b></p>




</body>
</html>