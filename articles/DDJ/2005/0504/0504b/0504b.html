
<html>
<head>
<title>April, 2005: A Conversation with Guy Steele Jr.</title>
</head>

<body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000">
<!--Copyright &#169; Dr. Dobb's Journal-->


<h1>A Conversation with Guy Steele Jr.</h1>

<h2>A Sun Fellow &amp; Distinguished Engineer takes time out to chat</h2>
<h3>By Jack J. Woehr</h3>
<I>Jack is a DDJ contributing editor and independent consulting team mentor residing in Fairmount, Colorado. He can be contacted at http://www.softwoehr.com/softwoehr/.</I>

<hr>

<p><b>DDJ</b>: What was it like getting a degree at Harvard in 1975? GS: Interesting, because I was also involved at MIT at the same time. I actually had a very unusual opportunity. After graduating from Boston Latin School, I applied to Harvard and MIT and Princeton and accepted Harvard's offer. Then two months later, I heard that William Martin [http://www.cdm.csail.mit.edu/people/wam.html] was looking for LISP programmers at MIT. As a teenager I had hung out at the MIT AI lab, so I had a pretty good idea who Martin was. I went and applied for the job and I got it.</p>



<p><b>DDJ:</b> How did you get it?</p>

<p><b>GS:</b> I was na&iuml;ve enough to go over there on the Fourth of July and put my head in Bill Martin's door and said, "I hear you're looking for LISP programmers." I wasn't 18 yet. Bill looked at me seriously and said, "You'll have to take my LISP quiz." He reached in a file drawer and pulled out a three- or four-page quiz and sat me down in his office, and I spent an hour or two doing this quiz. He graded it and said, "You're the first person who has ever gotten it 100 percent right. You're hired."</p>



<p><b>DDJ:</b> How did you know that much about LISP?</p>

<p><b>GS:</b> MIT has a program where college students teach high-school students on Saturday mornings. I'd been involved in that for three or four years. I was familiar with MIT's facilities because the people there were sort of tolerant of young kids hanging around the computer labs. And I'd read the blue-and-white book [John McCarthy et al.,<i> LISP 1.5 Programmer's Manual</i>, MIT Press, 1962]. During my senior year at Latin School, I coded a complete implementation of LISP for the IBM 1130 from scratch. I had a pretty good idea what was going on.</p>

<p>So I was hired programming LISP at MIT and started full-time in the summer of 1972. That fall I entered Harvard. I arranged my classes so I'd spend mornings at Harvard and my afternoons working part-time at MIT. The beautiful thing is that I had access to two separate faculties with two different points of view of computer science.</p>



<p><b>DDJ:</b> What was the difference?</p>

<p><b>GS:</b> I'd say that at Harvard I found a bit more emphasis on theory and at MIT a bit more of an emphasis on the pragmatics of getting things done. I'd listen to what my professor said at Harvard, and in the afternoons I might talk to someone at MIT: "At Harvard, they say this." "Oh, that's not right. This is..." The next day, I'd go back to Harvard, "This is what the guys at MIT say..."</p>

<p>It also worked out financially. I made just about enough money at MIT to pay for my tuition at Harvard!</p>



<p><b>DDJ:</b> Did you actually learn Latin at Boston Latin School?</p>

<p><b>GS:</b> Five years with an option for six. But instead of the Classics track, I took the Science track, so I took physics instead of Latin in the sixth year. I also took four years of German.</p>



<p><b>DDJ:</b> And you play chess. And you sing. There are more than a few computer programmers who are into languages, chess, and music!</p>

<p><b>GS:</b> Common themes programmers are interested in.</p>



<p><b>DDJ:</b> After school, what did you do?</p>

<p><b>GS:</b> After I graduated from MIT I took a professorship at Carnegie Mellon because I decided I wanted to learn to build compilers at the feet of Bill Wulf [http://www.cs.virginia.edu/~wulf/resumes/resume.html). Very shortly after I arrived, he left to start a compiler company called Tartan Laboratories. I worked at Carnegie Mellon for about two-and-a-half years, and among other things, did the first draft of the Common LISP specification. But I decided I still really wanted to learn to build compilers at the feet of Bill Wulf, so I took a leave of absence and went to work at Tartan Labs for a very good two years, and learned about compilers. We developed wonderful technology so that we could retarget compilers quickly to new architectures as they came out.</p>

<p>As my leave of absence was ending, I was still involved at Carnegie Mellon and showed up for a seminar given by Danny Hillis [http://www.edge.org/digerati/hillis/] about the CM-1 Connection Machine [http://mission.base.com/tamiko/cm/]. He went on quite enthusiastically about artificial intelligence and neural networks but thought the CM-1 was less suited for numerical programming. Whenever you tell me that you can't make a computer do something, it's a red flag. I believe the Turing hypothesis. The only question is the efficiency of the calculation. I believe in crunching the numbers, doing the calculations, and finding out whether an assertion is true or not.</p>

<p>So while Danny finished the lecture, I scribbled calculations on the back of an envelope. Okay, suppose you did the arithmetic bit serially, like the PDP-8S? A 32-bit floating-point multiply you have to multiply two 24-bit significands, that's going to take 600 time steps. For the additions, a logarithmic number of shifts, each will take 24 time steps...It turned out that a floating-point add would take about 1/2 a millisecond and a multiply a millisecond. Sounds terrible, but you've got 64,000 processors.</p>



<p><b>DDJ:</b> So you could do 64,000 of these calculations in a millisecond.</p>

<p><b>GS:</b> That's up in the range of 100 million operations a second, equivalent to a Cray 1, which was the supercomputer of the day. So after the lecture, I went up to Danny and said, "You said this is a terrible numeric machine, but I can tell it's approximately the equivalent of a Cray 1." And he replied, "Can we have dinner tonight?"</p>



<p><b>DDJ:</b> And from then until you came to Sun Microsystems in 1994, you were at Thinking Machines Corporation.</p>

<p><b>GS:</b> That was a lot of fun. I was there for just shy of 10 years. I was initially in charge of software development. I moved aside into a programming language development role when we hired on another manager. I'm really more of a technologist than a manager.</p>



<p><b>DDJ:</b> Whatever happened to the Connection Machine?</p>

<p><b>GS:</b> Thinking Machines went Chapter 11 in 1994. No one to my knowledge is still using the technology. Abstractly, the ideas behind the Connection Machine have permeated the industry and are well understood at IBM, Cray, and Sun.</p>

<p><b>DDJ:</b> How do those ideas find their representation today?</p>

<p><b>GS:</b> I'm hesitating, because after arriving at Sun, I was not active in high-performance computing for about eight years. I'm back into it now because of the High Productivity Computing Systems Project [http://research.sun.com/sunlabsday/docs/talks/1.01_Mitchell.pdf], which emphasizes overall productivity, not just performance.</p>



<p><b>DDJ:</b> What's the difference?</p>

<p><b>GS:</b> Performance means shortening the time for the computer to solve the problem. Productivity means shortening the time between posing the problem to the programmer and having the answer. It's important to make the programmer efficient as well as the program.</p>



<p><b>DDJ:</b> And how does one do that?</p>

<p><b>GS:</b> We have ideas for improvements to programming languages which might make programmers more productive by relieving them of more of the mechanical and administrative burdens of getting a program to work. We're looking at automated testing, more rigorous type systems, new languages. At Sun, we're looking at the conjecture that making programming languages closer to traditional mathematical notation can make things easier for the scientific programmer.</p>



<p><b>DDJ:</b> APL or Mathematica?</p>

<p><b>GS:</b> APL looks rather strange to a working mathematician or physicist. Fortran is a little bit like math, but not a lot. Where did the asterisk for multiplication come from? Fortran was invented on machines intended for accounting. What if we tried very hard to make a programming language look like mathematics and took advantage of Unicode? We're finally getting good support for full mathematical character sets in text editors.</p>

<p>We're designing a programming language called "Fortress." Kind of a takeoff on Fortran...</p>



<p><b>DDJ:</b>...wedded to the zeitgeist of our troubled times!</p>

<p><b>GS:</b> Well, we did have in mind a programming language with greater security through a stronger type system. We're trying to take some of the security features of Java, and mathematical notation, and good ideas already in Fortran and roll them all together.</p>



<p><b>DDJ:</b> How did you end up at Sun?</p>

<p><b>GS:</b> A number of companies sent interviewers to Thinking Machines. Sun made job offers to several dozen employees and I was one. I was hired as a Distinguished Engineer, which is the second-highest rung on the technical ladder at Sun. The top rung is Sun Fellow, to which I was promoted about two years ago [on March 6, 2003].</p>



<p><b>DDJ:</b> Your citation from <i>Dr. Dobb's</i> describes you as a "relatively quiet yet influential contributor to the world of programming," citing your many publications and remarking on the breadth and depth of your contributions.</p>

<p><b>GS:</b> I've had the good fortune to be in the right place at the right time on a number of projects. Also, I like to write and many engineers don't, so I've often been called upon to write the English specification of a programming language: Common LISP, Scheme, Java, High Performance Fortran.</p>



<p><b>DDJ:</b> How's Scheme doing these days, and who is using it?</p>

<p><b>GS:</b> There's a committee actively working on revising the specification for this millennium. I'm on the steering committee, not actively involved in the editing process. Scheme is used pretty heavily in universities, and is one of the working programming languages for research conferences, such as ACM's Principles of Programming Languages Conference. Scheme is particularly good at modeling things that programming language designers worry about, such as the scopes of variables. For some purposes, Haskell has taken over the role Scheme used to have.</p>



<p><b>DDJ:</b> Regarding variable scoping, Dr. Ron Rivest, with whom I spoke some years ago ["A Conversation with Ron Rivest", <i>DDJ</i>, September 1997; http://www.ddj.com/articles/1997/9710/], said that Java had some difficulties with closures.</p>

<p><b>GS:</b> If your programming style involves extensive use of closures, then Java is syntactically a lot more awkward. The design of the language does not make it particularly easy.</p>



<p><b>DDJ:</b> Design flaw in Java? Tradeoff?</p>

<p><b>GS:</b> There was a conscious design decision for object-oriented rather than closure-oriented programming.</p>

<p>Interestingly, when anonymous inner classes were introduced into Java, we had a full implementation that made them act like closures. In particular, if you did up-level references to variables, you could assign as well as read. We got push-back from users, "We don't want this, we prefer an implementation in which you can only read the up-level variables." In order to support the full-blown closure implementation, it was necessary to do heap allocation implicitly. At that time, the users were still a little nervous about heap allocation and garbage collection. They felt more comfortable if places where heap allocation took place in Java were always explicitly flagged by the new keyword. Nowadays, heap allocation in Java is better understood and that feature could be added easily, but there's no call for it.</p>

<p>I have a theory that programming languages have lifetimes. Java will probably be around another 20 years. It's time for a new programming language to come along.</p>

<p><b>DDJ:</b> Fortran was called "automatic programming," then we had "structured programming," then "declarative programming," "functional programming," "object-oriented programming"...Is Fortress introducing some new model? Or is it just a new object-oriented language?</p>

<p><b>GS:</b> There's a difference between a new programming language and some advance that creates a major paradigm shift. Fortress has a new object-oriented type structure, multiple inheritance, and the traits idea [S. Ducasse, N. Schaerli, O. Nierstrasz, R. Wuyts, and A. Black, "Traits: A Mechanism for Fine-Grained Reuse,"<i> Transactions on Programming Languages and Systems</i>, 2004; http://www.iam.unibe.ch/~scg/Archive/Papers/Duca04wtoplastraitnotfinal.pdf]. Traits are a way of getting better code reuse in object-oriented programming. Imagine Java interfaces but you can put code in them: not field declarations, just code.</p>



<p><b>DDJ:</b> Does Fortress look like Java and C++?</p>

<p><b>GS:</b> We're doing a research prototype rather than a product prototype, so we feel free to try out a bunch of crazy ideas. Syntactically, we're trying more to be inspired by mathematics than by Java. The object organization is Java-inspired. Array handling is Fortran and APL inspired. Other influences are MatLab and Mathematica. We're also trying to add checking of dimensional units such as kilograms, meters, and feet. We had a paper [E. Allen, D. Chase, V. Luchangco, J.W. Maessen, G.L. Steele Jr., "Object-Oriented Units of Measurement," OOPSLA 2004, http://www.pag.csail.mit.edu/reading-group/allen04measurement.pdf] in the last OOPSLA about that.</p>



<p><b>DDJ:</b> How does one compose a Fortress program? Rich keyboard? Dragging sigmas in a visual editor?</p>

<p><b>GS:</b> We're hoping to do some user productivity studies on that open question. We've got an ASCII encoding of the language, and also a presentation form for an IDE using Unicode. We're in the middle of a three-year research project and haven't ruled anything out.</p>



<p><b>DDJ:</b> Is Fortress going to be open source?</p>

<p><b>GS:</b> As a research issue, we are thinking very hard about organizing a language that would support open-source growth.</p>



<p><b>DDJ:</b> Coming up through academia, it would be easy to adopt the contemplative life. You seem to be a very active person.</p>

<p><b>GS:</b> I'm interested in being involved. In particular, I was interested in raising a family, and have just become an empty-nester as my youngest, Matthew, enters MIT. Now I'm trying to assess my life and allocate the balance of my time. I enjoy my work at Sun very much, but maybe I'll do more singing again!</p>



<p><b>DDJ:</b> Did the Golden Age of Programming end with the 20th century?</p>

<p><b>GS:</b> The set of concerns has certainly changed. I'm reluctant to identify what I did when I was young as the Golden Age. I don't see myself as an old fogey. I'm very excited with what's going on now. The things that excited me back then, like making the best use of every last bit in a word, are less important nowadays. There are wonderful bit-hacking algorithms in <i>Hacker's Delight</i> [Henry S. Warren, Jr., <i>Hacker's Delight</i>, Addison-Wesley 2004, ISBN 0201914654]. I'm glad someone put them together. Compiler writers need to know this stuff, but not everybody.</p>



<p><b>DDJ:</b> It seems to me that the best programmers I hire do know computing machinery down to the bits and gate level, often from embedded control experience. People who start with high-level languages frequently get frustrated because they don't understand why certain limits impinge on their perfect world of high-level language.</p>

<p><b>GS:</b> I had the opportunity to take courses which tackle all levels of how a computer works, from high-level languages down to quantum mechanics. I've taken signals and systems courses, basic electrical engineering courses, architecture courses...I had the good fortune to be in on the first VLSI class that Lynn Conway [Carver Mead and Lynn Conway, <i>Introduction to VLSI Systems</i>, Addison-Wesley, 1980 ISBN 0201043580] taught at MIT. The very best programmers will be so fanatical that they spent their youth learning all this stuff top-to-bottom. But people have different balances and strengths. You can't expect every programmer to have done this.</p>



<p><b>DDJ:</b> Some people go through life tossing out visions like rice at a wedding, others seem to pick up the individual grains of rice and examine them under a microscope and actually make the vision work.</p>

<p><b>GS:</b> And I'm more the second kind of guy. On the Connection Machine, Danny Hillis had a grand vision for a version of LISP that could operate on vectors. I sat down and cranked through the mechanics of "What does that mean for how the if statement works, what does that mean for how lambda behaves?" Gerald Sussman [http://library.readscheme.org/page1.html] was the great visionary on Scheme. I made sure the parts fit together and made it work.</p>

<p>I'm in the best position at work when I have a visionary and a manager to work with. What I'm best at, is when an idea comes from somewhere, to combinatorially work through the consequences of it, and make sure the details are nailed down. Not that I truly compare myself to either, but I'm more like Edison than Einstein.</p>


<p><b>DDJ</b></p>




</body>
</html>