<HTML>
<META NAME="year" CONTENT="1988">
<HEAD>

<TITLE>NOV88: STRUCTURED PROGRAMMING</TITLE></HEAD>
<body bgcolor="FFFFFF">
<h1>STRUCTURED PROGRAMMING<a name="020e_0003"><a name="020e_0003"></h1><P>
<h2><a name="020e_0001"><a name="020e_0000">Examining Turbo Pascal 5.0</h2><P>
<h3>Kent Porter</h3><P>
<a name="020e_0002"><a name="020e_0000">Now in its fifth year, Turbo Pascal remains the hottest name in the Pascal game, and the new Turbo Pascal 5.0 shows that Philippe and friends down Scotts Valley way intend to keep it there. TP5 introduces the much-rumored and long-awaited debugger and reintroduces overlays, plus a host of other user-demanded enhancements, and TP5 now comes in a couple of different pricing packages geared toward both casual and serious programmers.<P>
Borland rolled out TP5 around Labor Day, along with Turbo C 2.0 and TASM, the new (and also much-rumored) Turbo Assembler. Unlike the other Borland language products, TASM has no integrated environment. It's strictly a command-line assembler, but it comes with a standalone debugger. The debuggers integrated with Turbo C and Turbo Pascal are identical to each other, and that's good news for those of us who switch around between languages. The freestanding debugger can also be used with high-level languages.<P>
As for TP5, you still have your choice between the integrated and commandline compilers. The environment has been enhanced to accommodate the debugger, which is seamlessly folded in. In most other respects, the environment is pretty much the same: a little culture shock for those upgrading from TP4.<P>
And what about a linker, you ask? Well, that's part of the compiler, as in the earlier release. No, Version 5.0 still doesn't produce .OBJ files, so you can't export Turbo Pascal object modules to other languages or systems. This is because both Versions 4.0 and 5.0 produce a proprietary object module format called a Turbo Pascal unit, which has the filename extension .TPU. You can import externally generated .OBJ files--for example, those produced by TASM--into TP5 programs, but you can't export .TPU object modules to other language systems because they don't understand the format.<P>
Borland contends that the .OBJ format is inherently inefficient and that the Turbo Pascal compiler owes its impressive speed to a more efficient object form. And indeed, the source-to-.EXE time for equivalent programs in TP5 and TC2 (the latter uses .OBJ files) is faster for Pascal. Still, .TPU files remain the only way to modularize Turbo Pascal programs, and there are sure to be grumbles.<P>
Virtually all the rest of the news about TP5 is good. In addition to the big item--the debugger--there are a lot of smaller but telling improvements to the product. For example, the help subsystem has been expanded to include language help that's context-sensitive. Pressing F1 brings help for the environment state you're in or the menu selection currently highlighted, as before. For language help, you position the cursor on an occurrence of the identifier in source code, then press Ctrl-F1. A description of the language element in question appears in a popup screen with a brief description and an example. This is a whole lot easier than looking it up in the manual. Additionally, if a compile-or run-time error crops up, you can get a diagnosis of the probable cause(s) by pointing to it and pressing F1. This is help that's truly helpful.<P>
Other enhancements include dead code and data removal, 8087 emulation so that you can take advantage of all REAL types even if the machine lacks a coprocessor, and constant cascading. The following was illegal in all previous releases of Turbo Pascal (and still is in most other Pascal implementations):<P>
<pre>CONST BuffLength = 256;
               HalfLength = BuffLength DIV 2;
               DblLength = BuffLength * 2;</pre><P>
This C-like handling of constants is legal in TP5. Also C-like is TP5's new ability to handle procedural types, variables, and parameters, thus allowing you to pass, say, a function name as an argument to another subprogram and then, within that subprogram, invoke the parametric function via its variable name. The TP5 linker is also able to resolve circular unit references. This eliminates the irksome problems that TP4 sometimes produced when two or more units were heavily interdependent.<P>
The awkwardly thick manual of TP4 has been divided into two with Version 5.0: a User's Guide and a Reference Guide. The 350-page User's Guide covers installation and use of the product. The Reference Guide devotes almost 500 pages to programming issues and a comprehensive description of the Turbo Pascal language. The built-in identifiers are arranged in alphabetic order, and nearly every entry includes a programming example.<P>
Among other behind-the-scenes enhancements are support for EMS 3.2 or higher for editing and debugging large files, an expanded graphics library, and a word- or byte-alignment option (word alignment yields better .EXE execution time).<P>
Borland has added an INSTALL program with options for floppy and harddisk installation. The hard-disk setup also lets you choose between a first-time install and an upgrade from TP4. There are scads of new examples and also some documentation text files that come in compressed format along with an unpacking utility; you can choose whether or not to explode the compressed files at installation time. INSTALL recommends a default subdirectory structure for various kinds of modules (.PAS, .TPU, .EXE, and so on). This is good for those of us who were too lazy to set up our own under earlier releases. I must have 400 files in my old \TP directory, which is absurd, but I'll bet I'm not the only one. The default structure helps one manage files more sensibly.<P>
Now let's get to the really good stuff.<P>
<h3><a name="020e_0004">Seamless Debugging<a name="020e_0004"></h3><P>
Interactive debugging is an integral part of the TP5 environment. Unlike Microsoft's Codeview, which is a separate utility, the Turbo debugger is built in. You know it's there because there are new keystrokes to learn and because some of the menus have new selections that pertain to debugging. You don't have to exit to the debugger from the Turbo Pascal or Turbo C environment as you do in order to use CodeView.<P>
This makes debugging a natural part of the program development process rather than an extension of it, and surely that's how the gods of computing intended for it to be. You can set breakpoints, test, edit, recompile, watch variables, change them, or step through the source code watching it execute and ironing out the wrinkles.<P>
An example of this seamless debugging is the sticky breakpoint. Let's say you set a breakpoint at line 253 in the source. As you work your way through the code, you discover a bug at line 194. You stop and edit, removing three lines, then recompile. The break at line 253 is still set, but since you've removed three lines, it's now at line 250, and execution will halt when it gets there. The breakpoint is sticky because it sticks with the source line to which it was originally attached, even if the line moves.<P>
The integrated debugger adds about a dozen new command keystrokes to the environment, plus half a dozen menu selections without shortcuts. In working with it, I've found seven that are essential and that give some idea of the debugger's capabilities:<P>
<pre>* Ctrl-F2     Reset program to starting condition

* Ctrl-F3     View the calling stack (by subprogram name)

* F4          Run from currently executing source line to cursor row

* Ctrl-F4     Evaluate expression or view/change variable

* Alt-F5      Toggle to the user screen

* F7          Single-step, tracing into subprograms

* F8          Single-step, stepping over subprograms</pre><P>
There are other shortcuts as well. Additionally, you can use selections from the Break/Watch menu (or Ctrl-F7) to set up a watch window that continuously displays the current value of one or more variables as the program runs. The watch window at the bottom of the display grows and shrinks dynamically according to the number of variables being watched at the moment. This ensures that you always have the maximum edit/debug window size. You can set up watch expressions using format specifiers that show, for example, monetary notation for REALs, hex format, and the layout of complex records.<P>
Any time the debugger halts the program being debugged, the current source line (the one that will be executed next) is highlighted by a cyan background on the color monitor or by reverse video on a monochrome display. If you want to examine a variable, evaluate an expression, or even test a program function, you press Ctrl-F4. This pops up a three-part dialog box. When the cursor is on a variable name, the top box shows the identifier and the middle box shows its current value.<P>
<a href="19880210.htm">Figure 1</A>, page 113, shows such a display. You can move to the lower box and key a different value if you want. This is useful for testing rarely-occurring values, for fixing bad data and resuming, or for finding out how the program behaves if unexpected values occur. You can also type an identifier into the top box, which might be an expression including a function with arguments. The debugger will actually execute the function and resolve the expression, showing its result in the second box. Additionally, you can edit the expression in the top box in order to do such things as chasing pointers through a linked list; the second box displays the contents of the object pointed to by the expression. Operation of the right-arrow key transfers additional source text from the cursor position into the top box, enabling you to expand the code to be evaluated without having to retype it.<P>
<a href="19880211.htm">Figure 1</A>: Using the Turbo Pascal 5.0 debugger to view the contents of a variable while execution is halted at the IF statement<P>
Capabilities such as this, and especially the ability to fix errors, recompile, and resume the session without disrupting the debugging setup, make the integrated Turbo debugger an unparalleled environment for program development. The only things one could wish for are a function key template--I keep a 3 x 5 card next to the keyboard as a cheat sheet--and mouse support.<P>
You can also use the standalone debugger that comes with TASM and with the bundled Turbo Pascal 5.0 professional package to debug Pascal and mixed-language programs. The free-standing debugger has more capabilities than the one integrated into the environment, but it lacks interactive compiling/assembling and sticky breakpoints. In other words, it operates in a manner analogous to CodeView.<P>
The other major improvement in TP5 is overlays.<P>
<h3><a name="020e_0005">Getting Smart About Overlays<a name="020e_0005"></h3><P>
In one respect, the earlier update from Turbo Pascal 3.0 to Version 4.0 represented a step backwards: TP3 supported overlays, while TP4 did not. Version 3.0 provided only COM files with a maximum code size of 64K, making overlays a necessity for larger programs. Because Version 4.0 removed this restriction with .EXE files, making it possible to write code that occupied the entire available memory of the PC, Borland apparently assumed that the need for overlays had gone away. They were wrong, as a chorus of protest from Turbo Pascal programmers swiftly proved.<P>
Version 5.0 redresses the grievance with dividends, because it not only restores overlays to Turbo Pascal but makes them smart. In TP3, the programmer had to manually isolate chunks of code, ensuring that any given overlay only called subroutines within itself and not subroutines within another overlay. This was because only one overlay was in residence at a time, loaded by the root module of the application. Therefore communication among overlays was possible only by passing information through global or common variables owned by the root, which held values deposited there by the departing overlay and picked up by the one newly loaded. This placed a heavy burden of responsibility on the programmer and made overlay programming the sanctum sanctorum of gurus.<P>
Not so in TP5. It uses Least Recently Used (LRU) algorithms to manage unit-based overlays on a subroutine-by-subroutine basis, and additionally takes advantage of EMS (if present) to further reduce overlay swapping.<P>
You must still decide if overlays are necessary, but this is usually apparent from the sheer amount of source code and certainly so if a developing program suddenly starts crashing due to out-of-memory conditions. In such cases, it's necessary to recompile units with the $O+ directive and to USE the TP5 Overlay unit in the root module. A certain amount of additional planning and programming is required. The TP5 Reference Guide covers the whole subject in six pages--about 20 percent of which is example code--that should serve as an indicator of relative difficulty. The compiler takes care of the rest, managing overlay memory, bringing in subroutines as called, and, if low on memory, placing them atop the least recently used subroutines. This technique often allows enormous programs to execute at a speed close to that of a machine with unlimited memory.<P>
Turbo Pascal 5.0 thus overcomes the major complaints about TP4--no debugging and no overlays--while enhancing the package with numerous new features. All this has a price.<P>
<h3><a name="020e_0006">Redressing the Package<a name="020e_0006"></h3><P>
The lackluster packaging of TP3 and the dark, brooding colors of TP4 have been replaced in TP5 with yellow. A brighter color scheme reflects the livelier product inside; it might also serve to deflect attention from the price increase. With TP5, the base price rises to $149.95.<P>
Sigh. Like many of us, I bought my first copy of TP2--list price $49.95--from a discounter for about $35. A first-timer will now have to spend three or four times that amount from the same source.<P>
On the other hand, look how much more he or she will get: interactive debugging, .EXE programs of unlimited size, highly advanced graphics, some 230 built-in procedures and functions, and a source-to-executable performance increase of at least tenfold since Version 2.0. The price may be going up, but the deliverables are still outrunning it. Turbo Pascal remains a bargain.<P>
Borland's new Professional package is an even better buy for the truly serious programmer. For $250, you get the base-line Turbo Pascal 5.0 compiler, plus TASM, and the standalone debugger. TASM supports all the Microsoft MASM dialects (along with their infamous inconsistencies) via metacommands, along with its own &quot;ideal&quot; syntax that assembles several times faster than MASM. TASM and the debugger sell by themselves for $150.<P>
The math isn't hard to work out. TP5 + TASM = $300, priced at $250. If you bought TP4, listed at $100, you can upgrade to the Pro pack for another hundred bucks: several times the development ease and software at a fraction of the price. For those not interested in the assembler, a straight upgrade from TP4 to TP5 is $49.95.<P>
Go for it. As a jaded reviewer, I don't impress easily, but TP5 is a superlative package for Pascal programmers.<P>

<P>
<P>
</pre></BODY></HTML>
