<HTML>
<META NAME="year" CONTENT="1988">
<HEAD>

<TITLE>NOV88: RUNNING LIGHT</TITLE></HEAD>
<body bgcolor="FFFFFF">
<h1>RUNNING LIGHT<a name="01e2_0003"><a name="01e2_0003"></h1><P>
<h3><a name="01e2_0001"><a name="01e2_0000">Ron Copeland, senior editor</h3><P>
<a name="01e2_0002"><a name="01e2_0000">I believe that the most successful programmers in the next decade will be those who carry in their toolkits, among their shiny metric and non-metric algorithms, a rich set of paradigms.<P>
Mike Swaine DDJ editor-who-is-elsewhere<P>
The best software is software that is hand-crafted by artisan programmers--DDJ's bread and butter. Handcrafted has always been a synonym for the best in any category. It has also been true that, historically, while an artisan class (in any trade) was being loudly praised and greatly revered, it was also being systematically eliminated in favor of some type of mass production technology.<P>
While it may be unpopular to say so, one man, one vision continues to be the best way to develop the best software. Unfortunately, in the main, neither economic necessity nor the economies of scale are apt to show any mercy in the continuing battle of quality over quantity. Ways of getting more from fewer are likely to remain a survival-oriented company's dominant goal. But while competitive pressure makes strong demands, fortunately, consumers will always favor the best.<P>
What's obviously needed is some way to cater to economic reality while getting the best from the best. Everybody wins. Sounds good, but how?<P>
Approaches to writing software have always embodied the balance between flexibility and complexity on the one hand, and rigid but focused simplicity on the other. It's either hard and powerful, or easy and simple. On the easy side high-level languages now offer elaborate object-oriented systems that can automatically generate applications from examples or from iconic connections. The down side is that by focusing programming power in certain directions high-level languages limit, in differing degrees, the number of directions that can be chosen--reducing the freedom to excel, to innovate.<P>
On the flip side, languages based on the linguistic approach have the discreet expressive power to precisely thread the eye of a needle without touching the sides. But in a large programming project under stringent deadlines, this kind of power, coupled with unlimited creativity, can easily become a logistical nightmare.<P>
In the past, procedural languages have served programmers well. There is ample evidence to support this. The bulk of today's software is visually enticing and heartily robust, with functions steadfastly following form. We must make sure that this remains the case.<P>
The prototyping pundit himself, Ted Lewis of Oregon State University, differentiates between these two approaches by reducing them to the nature of their approach to a problem. He describes these approaches as &quot;telling&quot; versus &quot;showing.&quot;<P>
Simply, Ted defines telling as issuing a discreet set of instructions. This involves two symbolic transductions: from the idea to its componential representations, then back again. Showing he defines as manipulating 'objects' directly. Showing only involves a single translation--from the idea directly to its implementation. Showing is usually regarded by learning and communications theorists as the least dissonance-inducing form of communication.<P>
Right now, showing a computer what to do is a less evolved technology than telling it what to do via a programming language. Its promise is largely unfulfilled. But it's clear that there are real advantages to be gained from object-oriented programming in languages like Smalltalk, C++, and Object-Pascal. (Even Philippe Kahn seems to think so, or so he hinted at a recent press conference where he talked about products forthcoming from Borland in 1989.) In a more applied sense, similar advantages are gained from graphics specification/manipulation tools such as HOOPS and RenderMan.<P>
Indeed, perhaps the ideal approach is a model that supports and embodies the desirable features of both, either from within a single programming environment or by supporting a multiple compiler integrated/integrating environment. Both Borland and Microsoft have indicated ongoing commitments to supplying a multiple language environment at some point in the foreseeable future, as well as indicating their strategic commitment to object-oriented language development. Time will tell.<P>
We live in interesting times. (This is a Chinese curse, by the way.) Right now we're caught smack in the middle of the paradigmic shift. Not a comfortable place to be, but then again, it's certainly not boring.<P>
Ron Copeland senior editor<P>

<P>
<P>
</pre></BODY></HTML>
