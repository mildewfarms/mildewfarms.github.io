<HTML>
<META NAME="year" CONTENT="1988">
<HEAD>

<TITLE>JUN88: EXAMINING ROOM</TITLE></HEAD>
<body bgcolor="FFFFFF">
<h1>EXAMINING ROOM<a name="012e_0003"><a name="012e_0003"></h1><P>
<h2><a name="012e_0001"><a name="012e_0000">Peabody For Turbo C</h2><P>
<h3>Ron Copeland</h3><P>
<p><i><a name="012e_0002"><a name="012e_0000">Ron Copeland, associate editor for DDJ, is the coordinator for this  review section. He welcomes your feedback on products worth reviewing.</i></p><hr><P>
<B>Product</B>: Peabody for Turbo C<P>
<B>Target</B>: IBM PC XT, PC AT, PS/2, and compatibles<P>
<B>Requires</B>: Hard disk, DOS 2.1 or later, 640K recommended<P>
<B>Pricing</B>: $100<P>
<B>Vendor</B>: Copia International Ltd., 1964 Richton Dr., Wheaton, IL 60187,  312-665-9830<P>
Peabody is one of those programmer's tools that, five minutes after you start exploring it, you wonder how you ever lived without it. A direct  competitor to the Norton Guides, Peabody is an online language database  for programmers. Peabody also includes some other reference materials  and utilities to help developers.<P>
<a href="19880130.htm">Figure 1</A> show the old Validation Options for PC/Forms<P>
Like the Norton Guides, Peabody comes in various language flavors. The one I used for this review was Turbo C. There are also references for Microsoft and Lattice C, Turbo Pascal 4.0, and DOS.<P>
Peabody is intended chiefly to function as a TSR. You could run it as  a standalone application, though I don't know why you would except for  familiarization. Additionally, there's a mode called &quot;tandem&quot; in which  Peabody becomes a temporary TSR. For tandem mode, you type a command  such as PEABODY TC. This brings up Peabody in standalone mode, but  Peabody starts Turbo C as a child process and then hovers in the  background pretending to be a TSR. Similarly, you can run Peabody in  tandem with Brief using the command PEABODY B filename.ext. An exit  from the child also ends Peabody and removes it from memory.<P>
This is an attractive feature, because Peabody takes a lot of memory  for a TSR: 115,120 bytes. That's 60 percent more than the Norton Guides  consume. On the other hand, Norton is a pure TSR and doesn't have a  tandem mode; it's either resident or it's not. Peabody's tandem approach makes more sense, since you probably only want to activate the  reference system while actually programming, and any other time the  resident software wastes memory that could be used for other things.<P>
The disk space requirements for Peabody and the Norton Guides are about the same, with both taking around 700K. The Peabody reference database is a little bigger: 542K versus 516K for Norton.<P>
Peabody uses a minimum of four hot keys. For the Turbo C version:<P>
<ul>
<li>Ctrl-Tab brings up the database table of contents</li>
<li>Alt-LShift serves as the Hyper-key</li>
<li>LShift-Tab redisplays the most recent frame</li>
<li>Ctrl-Backspace tags the current Peabody window as a &quot;sticky frame&quot;</li>
</ul>
These default hot keys are reassignable with a configuration utility called PBSETUP. Each additional Peabody database you install brings along its own default Hyperkey; Turbo Pascal, for example, uses LShift-Ctrl.<P>
Hyperkeys and sticky frames are features that programmers are sure to  love (although it sure would be swell if Peabody included  cut-and-paste, as well). The Hyperkey performs an automatic lookup of  the language keyword at the current cursor position. For example, say you've forgotten some of the details of the Turbo C cputs() function.  You position the cursor on cputs() in the source listing, then press Alt  LShift, and shazam! Peabody opens a frame explaining cputs().<P>
Norton does the same thing without a special hot key by automatically  positioning the expand menu at the keyword indicated by the text cursor.<P>
The Peabody frame is thoughtfully located where it won't overlay the keyword you're worried about. Successive presses of Enter bring up a stack of frames discussing general features, implementation or  version-specific issues, and a short program example. That's what  <a href="19880131.htm"> Figure 1</A>, previous page, shows. You  can go backward through the stack by pressing Esc and forward again  with Enter, removing and adding frames with single keystrokes. Sure  beats turning pages in a manual.<P>
A sticky frame is one that remains on screen after you return to edit mode; Norton has no equivalent. When the frame you want to retain is on  top of the stack, you press Ctrl-backspace to tag it, then deactivate  the Peabody session with CtrlEsc. All the Peabody frames except the  sticky one disappear. You can move the sticky frame elsewhere with the cursor keys and revert to edit mode with Esc. This is tantamount to  leaving an open manual next to the keyboard for further reference as  you write the code. Any Peabody hot key evaporates the sticky frame.<P>
<a href="8806d.htm#012e_0004">More Details.</A> <a href="8806d.htm#012e_0005">More Details.</A><P>
<pre><a name="012e_0004"><a name="012e_0004">
C-INDEX +
By Neil Freeman


C-INDEX +

Product:

C-INDEX+, Version 3.1

Target:

IBM PC, PC AT, PS/2, and compatibles

Requires:
</pre><P>
Unix System V Xenix System V.PC; any operating system that can run Lattice C, Version 3.1; Computer Innovations C86, Version 2.30; Microsoft C 3.0, Version 3.0 or 4.0 including OS/2; Consulair C, Version 4.5<P>
<pre>
Pricing:

$395

Vendor:
</pre><P>
Trio Systems, 2210 Wilshire Blvd., Ste. 289, Santa Monica, CA 90403; 213-394-0796<P>
If you'd like to cut down the time required to create and implement systems that need sophisticated file-handling techniques while optimizing the amount of code and storage space needed for those systems, you should consider using C-INDEX+ from Trio Systems. C-INDEX+ is a full B-TREE data file management library of individually written functions. Designed specifically for C programmers, these functions can be used in any application requiring fast file creation, update, access, and maintenance schemes.<P>
C-INDEX+ handles variable length single- or multiple-key file access of any storage file of fixed or variable length records. It also stores the file index information inside the data file itself. This index storage feature cuts down on the number of data files that are open in an application by eliminating index files. File records utilizing the C-INDEX + functions can be retrieved sequentially, randomly, or by record number. Aside from the physical storage limits of your particular computer system, the only limitations in Version 3.1 are that single records can't be more than 10K and files can't be larger than 32 Mbyte. There are no limits on the number or format type of records in any one file, the number of fields, or the number of files that can be open at any one time.<P>
One of the other interesting features of this system is that no reorganization of files for the removal of deleted records is necessary. All data space is automatically reclaimed by the system as long as you use variable length records. Error handling is very easy to build into your programs because each function supplied in C-INDEX+ handles the error value for you. You merely decide what you want to do when an error is found.<P>
Both single-key and multi-key functions are supplied with the system.The single-key functions include: single and multiuser file creation, file open and file close, file buffer control, add records, change records, delete records, search and retrieve records, multiuser semaphore functions, and multiuser entry locking functions.<P>
The multi-key functions include: single and multiuser file creation,file open and file close, add records, update records, delete records, search and retrieve records, and record locking functions. In the event of any unusual file problems, such as unexpected power outages or disk problems during file reads or writes, Trio Systems has also included a rebuild utility and an index integrity check utility to aid the programmer in the reconstruction of a suspected corrupted file. In this release, local-area networks are also supported with full byte record locking and semaphore (lock flags) functions.<P>
I tested this product in three areas, first to compare functions that I have written and used in my own programs, second for its portability to other compilers, and third to find out what I could do with the least amount of program code and the most amount of C-INDEX + code. In the first area of the comparison, it was immediately apparent why Trio has one product and has been working to constantly improve it. The efficiency of the C-INDEX + code cut my program size down substantially from what it had been when I used my own functions. Converting my existing code to include the C-INDEX+ functions was time consuming because all the function calls had to be restructured or changed. When I wrote a program from scratch, however, the time differential for coding was minimal as I became more familiar with the function parameters required. In addition, when the files were recreated for the newly coded program, the storage space savings was about 25 percent due mainly to the lack of index files. Handling multikey indices and the related record add, change, and delete functions was a far easier task with C-INDEX +.<P>
I chose the Mix C and the ALCOR C systems to test Trio's portability claim because neither of these systems were on the list of directly or indirectly supported C compilers. Since C-INDEX+ is written to very close to K&amp;R C standards, the modification time was minimal. Mix and ALCOR do not include librarian programs, which caused me to take some time making modifications, but I eventually found that this was not a major problem and successfully moved the code to both of those systems. The Trio Systems' claim that their code is portable to other systems is a valid one.<P>
In the third area of my evaluation, the creation of the smallest amount of code, I wrote a small database system with minimal screens and data entry needs in just under 150 lines of code. The approximate breakdown of that code was as follows: 30 lines for variable definition, 30 lines for screens, 40 lines for error handling, 30 lines for C-INDEX +, and 20 lines for miscellaneous. The database stored social security numbers and names and was at best a very small skeleton of a program. I did not need to write any file handling routines, which showed me how many functions are supplied in C-INDEX+. Everything I needed was included in the system.<P>
Although this product is extensively documented, it includes tutorial programs, and requires only calls to the various functions supplied, the user should be familiar with the C language record and pointer structures. In other words, I do not consider this to be a product for the casual C programmer but rather a product that contains a complex and very useful set of library functions for the experienced C programmer.<P>
I heartily recommend this product to programmers who would like to cut down on development time in the data management area of their programs. Record and file handling have always been a problem in the programming arena and CINDEX+ makes it almost effortless. With the inclusion of source code, the experienced C programmer can usually handle any adaptations to the system that might be necessary in a specific application.<P>
by Neil Freeman<P>
<P>
<pre><a name="012e_0005"><a name="012e_0005">
T-DebugPLUS 4.0
By Kent Porter


T-DebugPLUS 4.0

Product:

T-DebugPLUS 4.0

Target:

IBM PC, XT AT PS/2 and compatibles

Requires:
</pre><P>
DOS 2.0 or later; 256K of free memory; Turbo Pascal 4.0; hard disk, color monitor.  Extended/expanded memory recommended<P>
<pre>
Pricing:

$45; with source for $90

Vendor:
</pre><P>
Turbo Power Software, 3109 Scotts Valley Dr., Ste. 122, Scotts Valley, CA 95066; 408-438-8608<P>
Like many programmers, I suspect, I tend to prefer PRINT statements for running down bugs. And up until now, there hasn't been a choice with Turbo Pascal 4.0. I'd been striving for days to trap one of those ugly intermittent bugs, just about ready to give up on it, when the new T-Debug 4.0 arrived for review. Five minutes after doing the tutorial, I'd found my bug. It made a believer out of me.  <a href="19880132.htm">Figure 2</A>: T-Debug divides the display into two basic windows for source and commands<P>
The new T-Debug (despite the official name, this is how the manual refers to it) is a dressed-up version of the earlier Turbo 3.0 debugger. It does for Turbo 4.0 what CodeView does for the Microsoft languages, just as well and just as quickly.<P>
Installation is a painless process that consists of copying a half-dozen files from the delivery diskette, running a utility that patches the two Turbo compilers and TPMAP so that they'll support mapping of local variables, and running a setup program for T-Debug. The whole thing takes about a minute.<P>
To prepare programs for the debugger, you compile with mapping turned on (the /$T+ switch for TPC, or an Options menu selection in the environment). This tells the compiler to produce a map (.TPM) file, which T-Debug uses to find identifiers, symbols, entry points, and so forth. Compiling with the map option doesn't affect the size of the .EXE file.<P>
Unlike the earlier T-Debug for Turbo 3.0, the new debugger is a standalone program. So if you use the Turbo environment, you'll have to leave it and run T-Debug separately. T-Debug needs about 250K of memory in addition to the memory requirements of the program you're debugging.<P>
If you're debugging a large application, either extended memory or EMS may be necessary. T-Debug uses whichever is present. If  you don't have one or the other, the debugger still works, but it could run out of memory.<P>
Another recommended option is a color monitor. T-Debug makes effective use of colors, as the screen snapshot shows: register values are in red, the next line to execute is highlighted by a blue bar, commands are yellow, and so on.<P>
T-Debug is a command-driven debugger. The lower third of the screen is reserved for dialog, and it scrolls to give a transcript of the last half-dozen interactions. Typical of debuggers, it employs a terse command structure. For example, B sets a breakpoint and -B releases it, G runs the program to the next breakpoint, T traces, and so forth. Many take modifiers: T 5 traces the next five lines of source code, as an example, and G RTN executes the current subroutine up to the point of return. The E command examines a variable or constant. Say you have a variable called COLOR; you can type: E COWR and T-Debug reports its current value in hex, binary, and decimal, as well as its memory address. The E command is type-sensitive, so Boolean values appear as TRUE or FALSE and characters show up as such.<P>
The command set is quite rich, including such things as the ability to map the heap, determine memory usage, examine the stack, and decompose Pascal source into assembly language. There are also half a dozen commands for defining and managing macros, a powerful feature of the debugger.<P>
Another powerful command set involves watchpoints. If you tell TDEBUG to watch a variable, it opens a window in the center of  the screen. This is just below the register's window in the screen shot. You can watch up to eight variables (12 with EGA and VGA displays).<P>
Additionally, you can set conditional breakpoints which automatically halt the program if a variable changes or reaches a specified value.<P>
Some of the commands are mapped to function keys, which removes the tiresome need to type a command and press Enter each time you want to execute it. For example, F7 is the same as T (singlestep). The F3 key recalls commands from a LIFO stack, displaying them so that you can edit them if necessary and re-execute by pressing Enter.<P>
The only real complaint I have about T-Debug is that it lacks a concise reference to its many commands and function key assignments. The manual isn't terribly large---81 pages including the index---but it's a nuisance to thumb through looking for a specific command.  There is on-line help, but you still have to scroll to find what you want. I finally made my own cheat sheet. The vendor should have done it for me.<P>
T-Debug will work with dual monitors, which is an important consideration if you do a lot of graphics programming. If you only have one display, T-Debug maintains two screens: its own, and the output of the program. You toggle between them with F10. I had no difficulty tracing a graphics program on the EGA and switching back and forth between text and the drawing. However, there are some gotchas, and the manual devotes nearly four pages to a lucid discussion of them.<P>
On that subject, I encountered a bug when running the EGA in 43-line text mode. Every time I switched from the T-Debug screen to the program's display, the monitor went into 25-line mode and displayed the T-Debug command area in the upper left quadrant. It didn't do any harm, but it was distracting.<P>
T-Debug works fast and well, and it has a well-rounded set of features. If you write software in Turbo Pascal 4.0, you need this debugger.<P>
by Kent Porter<P>
<P>
The overlapping frames are a mixed blessing. Peabody's use of frames  takes less total real estate per unit of information than Norton s quarter- to full-screen panels. That's necessary to  implement  sticky frames, and it leaves more of your source code visible. On the other hand, the small frames crowd and fragment the information. Norton gives  you most or all of the information at a glance in a single, relatively uncluttered window. Overall, this makes Norton more visually appealing,  but the ability to hang on to and move sticky frames as you edit your  source code gives Peabody a distinctive advantage.<P>
From the table of contents level (Ctrl-Tab), Peabody furnishes a  hierarchy of menus that successively narrow down to the item you want to  look up. You can get into the database by subject or keyword, and also  by library functions, operators, data types, ASCII characters, and other  categories. Norton provides similar paths, but by the alternative means  of pull-down menus and cross-references. The outcome is largely the  same, but the methods differ. Neither approach seems clearly superior;  they're simply different ways of doing the same thing.<P>
Peabody offers a useful utility that lets you examine memory or a  file from within the environment in standard dump format. You can also  view a directory, which is handy if you're using an editor that doesn't  have a temporary exit to the DOS shell.<P>
The content of the Peabody reference database for Turbo C seems  reasonably complete. The only thing that's missing is the graphics  subsystem introduced with Turbo C 1.5. This is a curious omission  inasmuch as Peabody dues furnish information about the txt extensions in 1.5. I found no factual errors in the lookup material, whereas I did in  Norton; that doesn't mean that Peabody has no mistakes, but just that I  didn't notice them if they do exist.<P>
In general, Peabody is an extremely useful, well-rounded  programmer's aid that deserves a strong recommendation. For any serious  programmer, it will quickly pay for itself in the productivity gains  that come from not having to take your hands off the keyboard to look up stuff.<P>
                             By Kent Porter<P>

<P>
<P>
</pre></BODY></HTML>
