<HTML>
<META NAME="year" CONTENT="1988">
<HEAD>

<TITLE>SP 88: GLOSSARY</TITLE></HEAD>
<body bgcolor="FFFFFF">
<h1>GLOSSARY<a name="026d_0002"><a name="026d_0002"></h1><P>
<h3><a name="026d_0001"><a name="026d_0000"></h3><P>
<h3><a name="026d_0003">A<a name="026d_0003"></h3><P>
Action diagram -- A program logic notation combining graphics and text to allow a design to move smoothly from high levels to low levels of detail.  Brackets are the basic structuring device and are used in conjunction with pseudocode or compilable program statements.<P>
Artificial intelligence (AI) -- A variety of advanced computing approaches, many focused on the notion of symbolic computing, i.e., processing symbols with complex semantics as well as numerical data.  Many techniques having their roots in AI have moved into the mainstream of computing, even though the field of AI itself has so far failed to develop as early commercial developers had hoped.  Among the concepts tracing their ancestry to AI are: object-oriented systems, expert systems, knowledgebases, heuristic search algorithms, symbolic programming (a la Lisp), rule-based processing, inference engines, and machine learning.  In the context of CASE, AI usually refers to the use of a knowledgebase that contains rules for software design in addition to the objects themselves, and the use of rule-based processing and expert systems to provide more sophisticated automation of the software development process.<P>
Automatic code generation -- The ability of a CASE toolset to produce compilable or executable code for a particular target environment based on high-level specifications.  At the present time, the meaning of &quot;high level&quot; varies widely depending on the type of software and application domain.  In general, more constrained applications, such as on-line business systems approach full code generation, while more complex applications such as transaction processing, process control, and real-time systems achieve less than 70 percent with the remainder coded by hand.  Most CASE vendors are working to extend the linkages between front/back-end (code generation) tools.<P>
<h3><a name="026d_0004">B<a name="026d_0004"></h3><P>
Back-end tools -- Tools targeted for the implementation, testing, verification, or reverse engineering of software (in contrast to front-end tools for requirements definition, analysis, and software design).<P>
Baseline -- 1. A specification or product that has been formally reviewed and agreed upon, that thereafter serves as the basis for further development, and that can be changed only through formal change control procedures.  2. A configuration identification document or a set of such documents formally designated and fixed at a specific time during a configuration item's life cycle.  Baselines, plus approved changes from those baselines, constitute the current configuration identification [IEEE].<P>
<h3><a name="026d_0005">C<a name="026d_0005"></h3><P>
CASE tool -- A software program that provides partial or total automation of a single function within the software life cycle, e.g., a structured analysis or entity-relationship diagram editor, a data dictionary consistency checker, a syntax-directed editor, or a compiler.<P>
Change control -- A formal process, often aided by automated tools, of managing the changes in source code from one software version to the next.  A change control system defines a check-in/check-out process for approved software modules and limits authorization to make changes to the &quot;official&quot; code.  It also provides an archive mechanism that makes it possible to retrieve any previous version of a software system as it evolves.<P>
Code skeleton -- The &quot;outer skin&quot; of a software module that defines its interface to the rest of the system.  Software skeleton typically includes the module name, parameters, data definitions, package definition (if applicable), and return mechanism.  In some cases, some basic logical structures are also included.  The skeleton may be executable but will act only as a &quot;dummy&quot; with no functionality until the programmer inserts the processing algorithm by conventional source code editing.<P>
Completeness -- The state of a software system in which each baseline requirement is demonstrably met by one or more identifiable design components.<P>
Compliance matrix -- A two-dimensional table indicating the cross referencing between requirements and design components in order to establish that all requirements are satisfied by the software design (completeness) and to indicate which modules are critical to the implementation of specific requirements.<P>
Compliance -- The degree to which a software system meets the specified requirements (also correctness).<P>
Computer-aided software engineering (CASE) -- The creation of software systems using a well-defined design technique and development methodology, supported by computer-based design automation tools.<P>
Concurrency -- The simultaneous (or apparently simultaneous) execution of multiple software modules that communicate to satisfy system functional requirements.<P>
Configuration control -- The management, often with the aid of automated tools, of the set of related modules that make up a complete software system.  Configuration control is typically done at the file level, acting as a counterpart to change control.  It also enforces change authorization and check-in/check-out procedures.  In addition, a configuration control system often automates the process of converting the set of modules into one, linked executable image (i.e., the &quot;build&quot; process) and maintains the list of included modules and parameters relevant to the configuration process.<P>
Configuration item -- Hardware or software, or an aggregation of both, which is designated by the contracting agency for configuration management [DoD].  Consistency checking.  Verifying the design elements do not violate any of the rules of the design technique being employed. For example, level balancing of data flow diagrams is a form of consistency checking for the Yourdon-Constantine notation.  Control flow diagram (CFD).  A graphical notation that expresses the relationship between control algorithms and data processing algorithms in a program.<P>
<h3><a name="026d_0006">D<a name="026d_0006"></h3><P>
Data dictionary (DD) -- A structured listing of the data flows within a program and their breakdown into basic elements.  Typically, a variation of BNF is used to indicate the construction of basic elements into composite data flows.<P>
Data flow diagram (DFD) -- A graphical notation that expresses the flow and transformation of data within a program.  The symbology is essentially that of directed graphs.<P>
Decision table -- A method to define all possible alternative responses to input conditions in a program.  Decision tables are effective when all possible responses are mutually exclusive.<P>
Decomposition diagram -- A graphical notation showing the functional breakdown of a system from the most general, down to a level of detail representing individual program modules.<P>
Diagramming tool -- Any CASE tool that allows interactive editing of a graphical design notation on a computer screen.  Most diagramming tools also incorporate design rule checking, either interactively or in batch mode, upon invocation by the designer.<P>
DoD-STD-2167 -- A formal Department of Defense standard defining the deliverables and the development process to be used in building &quot;mission critical&quot; defense software systems.<P>
<h3><a name="026d_0007">E<a name="026d_0007"></h3><P>
Entity-relationship (ER) diagrams -- A design notation developed by Peter Chen that expresses the data structure of a system in terms of the actual entities of concern in the real system under analysis and the relationships among those entities.<P>
Expert systems -- A software system that uses rule processing to deal with incomplete, inaccurate, or contradictory data and to solve problems using heuristics rather than deterministic algorithms.  Expert systems are typically composed of two parts: a knowledgebase that contains data and rules and an inference engine that responds to the environment by scanning the rules in the knowledgebase for ones that relate to the current input and taking actions prescribed by the matching rules.  Sophisticated search algorithms that limit the range of possible rules that must be considered are crucial elements in expert system technology.<P>
<h3><a name="026d_0008">F<a name="026d_0008"></h3><P>
Fifth generation (5GL) technology -- Computer technologies concerned with developing systems that produce results normally associated with human intelligence such as robotics, natural language processing, automatic theorem proving, knowledge engineering and expert systems [McCLURE].<P>
Formalism -- A language and discipline for analyzing a system or part of a system, or specifying a software design.  For example, Yourdon, Gane &amp; Sarson, Ward-Mellor, Boeing-Hatley, Constantine, Chen, Bachman, and so on.<P>
Fourth generation (4GL) language -- A high-level, non-procedural, end-user-oriented programming language typically tied to an online database management system that allows users to define database query, report, and transaction-oriented applications with fewer statements than required for traditional languages such as Cobol.<P>
Framework -- A software system designed to integrate a diverse set of CASE tools into an integrated environment with a consistent user interface.  Some frameworks provide a variety of data-management services such as translation among the various tools, version control, and configuration control.  Some frameworks can also mediate between the CASE tools and the operating system to provide more portability across a variety of platforms.<P>
Front-end tools -- CASE tools that address the requirements definition, analysis, and high-level design of software systems.  Most front-end tools tend to combine graphical and textual specification languages and provide automatic checking for adherence to design rules.<P>
Full CASE environment -- An integrated environment on one or more computing platforms that provides automation for the entire software life cycle as well as the related management and support activities such as project planning, estimating and management, documentation, configuration control, version control, reusable code library maintenance, team communications, and so forth.<P>
<h3><a name="026d_0009">G<a name="026d_0009"></h3><P>
Gane-Sarson notation -- A structured analysis and design notation developed by Chris Gane and Trish Sarson that is functionally similar to the Yourdon notation.<P>
<h3><a name="026d_000a">H<a name="026d_000a"></h3><P>
Hatley notation -- A design notation, developed by Derek Hatley, for describing the architectural, behavioral, and information processing characteristics of a real-time system.<P>
Heuristics -- Decision and transformation criteria based not on deterministic algorithms but rather on an assortment of rules that could apply to a range of possible scenarios, i.e., &quot;rules-of-thumb.&quot;<P>
<h3><a name="026d_000b">I<a name="026d_000b"></h3><P>
Inference engine -- The &quot;executing&quot; portion of an expert system that responds to external input by searching for rules and data in an associated knowledgebase that relate to the current state of the system, and producing output and intermediate results as prescribed by the relevant rules.<P>
Information engineering (IE) -- An interlocking set of formal techniques in which enterprise models, data models, and process models are built up in a comprehensive knowledgebase and are used to create and maintain data processing systems [KNO].<P>
Internal consistency -- 1. No two statements in a document contradict one another; 2. A given term, acronym, or abbreviation means the same thing throughout the document; 3. A given item or concept is referred to by the same name or description throughout the document.<P>
<h3><a name="026d_000c">J<a name="026d_000c"></h3><P>
Jackson notation -- A structured analysis and design notation based on tree structures that describe the structure of data and program modules and also indicate sequence and iterative properties of the system.<P>
<h3><a name="026d_000d">K<a name="026d_000d"></h3><P>
Knowledgebase -- An information repository that contains definitions of the objects that comprise a software system design representation and the relationships among objects as well as the syntactic and process rules that define a correct design within the design methodology in use.<P>
<h3><a name="026d_000e">L<a name="026d_000e"></h3><P>
Level balancing -- Verification of a multi-level data flow diagram to ensure that all inputs and outputs entering and leaving a parent module have corresponding inputs and outputs on the corresponding child diagram.<P>
Life cycle -- The series of states that a software system goes through from initial concept through retirement.  The traditional &quot;waterfall&quot; model recognizes the states of requirements definition, requirements analysis, system design, implementation, testing, and maintenance. More recently, less linear variations of the waterfall model seem appropriate to some situations, such as business systems that continue to evolve for many years and complex engineering systems that require extensive prototyping before a design can be finalized. These tend to be better described by a &quot;spiral&quot; or iterative life cycle.<P>
<h3><a name="026d_000f">M<a name="026d_000f"></h3><P>
Methodology companion -- A CASE tool that provides computerized assistance for a particular software development methodology such as Information Engineering, Data Structured Systems Design, Spectrum, AGS, PMG, DoD-STD-2167, and so forth.<P>
Methodology -- A well-defined development process that provides for controlled and orderly progress toward completion of a software system that meets all specified requirements within specified budget and schedule constraints.<P>
Mini-spec(ification) -- Used in the Yourdon-Constantine notation to describe the logical and algorithmic content of a basic program module.<P>
<h3><a name="026d_0010">O<a name="026d_0010"></h3><P>
Object-oriented database -- A network database that encapsulates not only data elements, or &quot;objects,&quot; but the relationships to other objects and the processing rules unique to each object.  Typically, object-oriented databases implement many of the concepts found in object-oriented languages such as Smalltalk: information hiding, inheritance, classes, abstract data types, and messages.<P>
Object-oriented design (OOD) -- A design technique that incorporates the concepts of object-oriented programming such as information hiding, inheritance, classes, abstract data types, and messages.  OOD is becoming popular in the Ada segment because Ada, the DoD-required programming language for &quot;mission critical&quot; defense systems, is based on object-oriented principles.  Buhr notation is one graphical approach to OOD, although it implements only a subset of all OOD principles.<P>
<h3><a name="026d_0011">P<a name="026d_0011"></h3><P>
Process activation table (PAT) -- A tabular specification of conditions that result in the activation of a data transformation process, typically used for real-time systems design.<P>
<h3><a name="026d_0012">R<a name="026d_0012"></h3><P>
Rapid prototyping -- Using CASE tools to successively refine a software design by quickly generating a working prototype and feeding back prototype test results to improve the design specification.<P>
Real-time system -- A software system that interacts closely with an external physical environment and that must respond to external physical events in the time frame dictated by the characteristics of the external system.<P>
Repository -- An information storage facility.  In the context of CASE, repository refers to a central design database that contains all the information relevant to the design and implementation of a software system, including design representations, design rules, and management information.<P>
Requirement -- 1. A condition or capability needed by a user to solve a problem or achieve an objective.  2. A condition or capability that must be met or possessed by a system or system component to satisfy a contract, standard, specification, or other formally imposed documents.  The set of all requirements forms the basis for subsequent development of the system or system component [IEEE].<P>
Requirements allocation -- The process of partitioning requirements into separate configuration items and associating them with specific design elements within the system architecture.<P>
Requirements management -- A rigorous method for establishing, maintaining, and reporting the correspondence between a system's requirements specification and its architecture, components, modules, interfaces, test approaches, and test data throughout the software life cycle.<P>
Reusability -- The ability to use an existing software module to satisfy the requirements of a new system.  Reusability implies the ability to design generic modules that are easily modified to meet similar but different requirements, and the ability to save and restore a large number of such modules in a widely accessible library and to identify the applicability of specific modules to newly-defined functions (i.e., an indexing facility).<P>
Reverse engineering -- The process of transforming existing source code into higher-level design representations automatically or semi-automatically.<P>
<h3><a name="026d_0013">S<a name="026d_0013"></h3><P>
Screen painter -- A CASE tool that allows a designer to define application input, query and edit screens, perform data edit functions and some simple calculations without having to actually write the required code.  Typically this is done through a menu-driven session in which the user defines and places the desired fields and fills in table defining data attributes and ranges and computed data definitions.<P>
Software engineering -- 1. The systematic approach to the development, operation maintenance, and retirement of software [IEEE].  2. A discipline for creating software programs that includes a design notation, a design process, and well-defined stages and deliverables throughout the development process.<P>
Software ICs -- Software modules that perform generic functions and that are designed in such a way to be easily incorporated into specific software systems.  To be generally useful, a software IC must have a carefully design external interface and must be robust enough to adapt to a wide range of specific applications.  Object-oriented design shows great promise in making the software IC concept generally useful.<P>
Software life cycle -- The sequential stages that a software program or group of programs (system) pass through from initial concept through retirement.  The top-down, or waterfall, life cycle model recognizes the phases of requirements definition, analysis, design, implementation, verification and testing, and maintenance.  New models, however, such as the rapid prototyping or iterative model, have advantages over the traditional approach in some cases.<P>
Software quality -- A planned and systematic pattern of actions necessary to provide adequate confidence that the item or project conforms to established technical requirements [IEEE].<P>
Software workstation -- A complete environment including hardware and software whose function is to provide computerized assistance for the production, maintenance and project management of software system [MARTIN].<P>
State transition diagram (STD) -- A graphical notation for showing the behavioral characteristics of a software program.  State transition diagrams express program behavior as a series of states and their related outputs, along with all the possible transitions between states and the conditions that can cause these transitions.<P>
Statecharts -- A variant of state transition diagrams developed by David Harel to describe the behavioral design of a real-time system.  Statecharts incorporate a rich textual/logical language in addition to the typical graphical state diagram notion.<P>
Structure chart (SC) -- A graphical notation that shows the structural decomposition of a software system into related modules indicating calling relationships and parameters passed between modules.  Structure charts visually show characteristics of a system such as coupling and cohesion and provide a convenient system overview when working at the detailed coding level.<P>
Structured analysis (SA) -- A top-down software analysis technique that stresses complete definition of the requirements of a system before the design is initiated.  SA usually employs a successive refinement process and graphical notation to express system requirements.<P>
Structured design (SD) -- A top-down software design technique that employs successive refinement to define the structure and external specifications of a system using graphical notation.<P>
Synchronization -- A mechanism to ensure multiple software modules that respond to or depend on the results of each other will communicate at the appropriate times.<P>
<h3><a name="026d_0014">T<a name="026d_0014"></h3><P>
Task -- A single-threaded module that performs a specific function in a larger system of related modules.  The notion of &quot;task&quot; is only useful in a system that has multiple modules executing concurrently.<P>
Technique -- A language and discipline for analyzing a system or part of a system, or specifying a software design.  For example, Yourdon, Gane &amp; Sarson, Ward-Mellor, Boeing-Hatley, Constantine, Chen, Bachman, etc.<P>
Toolkit -- A set of integrated tools that automates a major step in the software development life cycle, such as system analysis, program design or software implementation; or a major functional task, such as software maintenance or configuration control.<P>
Traceability -- The ability to show the correspondence between a specific requirement and the project deliverables that satisfy that requirement.  The ability to indicate the specific requirement(s) fulfilled by a given project deliverable.  When applied to a hierarchical set of design documents, traceability has five elements: 1. The document in question contains or implements all applicable stipulations of the predecessor document.  2. A given term, acronym, or abbreviation means the same thing in the documents.  3. A given term or concept is referred to by the same name or description in the documents.  4. All material in the successor document has its basis in the predecessor document (no untraceable material has been introduced).  5. The documents do not contradict one another [IEEE].<P>
<h3><a name="026d_0015">V<a name="026d_0015"></h3><P>
Validation -- The process of evaluating software at the end of the software development process to ensure compliance with software requirements [DoD].<P>
Verification -- 1. The process of determining whether or not the products of a given phase of the software development cycle fulfill the requirements established during the previous phase.  2. The act of reviewing, inspecting, testing, checking, auditing, or otherwise establishing and documenting whether or not items, processes, services, or documents conform to specified requirements [DoD].<P>
<h3><a name="026d_0016">W<a name="026d_0016"></h3><P>
Ward-Mellor notation -- An extension of the Yourdon-Constantine notation, developed by Paul Ward and Stephen Mellor, that incorporates constructs required to model real-time systems.<P>
WarnierOrr diagram -- A system decomposition and program structure notation, developed by Jean Warnier and Kenneth Orr, using vertical brackets to group data and logic elements hierarchically.<P>
Workbench -- 1. An assembly of integrated sets of tools whose function is to automate the production and maintenance of software systems as well as the software project management activities.  CASE toolkits are combined into CASE workbenches to automate tasks across the entire life cycle [McCLURE].  2. An integrated set of tools that automates the entire spectrum of activities performed in a particular job classification, for example, analysis and design, programming and project management workbenches.<P>
<h3><a name="026d_0017">Y<a name="026d_0017"></h3><P>
Yourdon-Constantine notation -- A top-down, structured design technique using data-flow diagrams, data dictionaries, mini-specs, and structure charts to represent the design process from requirements analysis through program modular design.<P>
<h3><a name="026d_0018">References<a name="026d_0018"></h3><P>
IEEE &quot;IEEE Standard Glossary of Software Engineering Terminology,&quot; IEEE Std. 729 - 1983.<P>
DoD &quot;Department of Defense Military Standard, DoD-STD-2167,&quot; Department of Defense.<P>
MARTIN James and McClure, Carma, &quot;The Latest Look In Programmer Productivity Tools,&quot; Business Software Review, May, 1986.<P>
McCLURE Carma, &quot;Proceedings of the Computer-Aided Software Engineering Symposium,&quot; Digital Consulting Inc., Fall, 1987, p. J-11.<P>
KNO &quot;Information Engineering: A Management White Paper,&quot; KnowledgeWare Inc., 1986.<P>
<P>
<P>
</pre></BODY></HTML>
