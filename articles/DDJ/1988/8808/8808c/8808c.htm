<HTML>
<META NAME="year" CONTENT="1988">
<HEAD>

<TITLE>AUG88: AN AID TO DOCUMENTING C</TITLE></HEAD>
<body bgcolor="FFFFFF">
<h1>AN AID TO DOCUMENTING C<a name="0179_0003"><a name="0179_0003"></h1><P>
<h2><a name="0179_0001"><a name="0179_0000">The only thing more painful than debugging your program is documenting it. This utility takes some of the sting out of documenting C projects.</h2><P>
<h3>Stewart Nutter</h3><P>
<p><i><a name="0179_0002"><a name="0179_0000">Stewart Nutter is a senior programmer for York International Inc. He may be reached at 111 W Gay St., Red Lion, PA 17356.</i></p><hr><P>
Did you ever get caught between a code deadline and the need for revised documentation? All too often, large programming projects reach completion with a large discrepancy between the design documentation and the final actual program. With C's ability to divide a big task into small tasks or modules, keeping the documentation up to date can be a headache. In addition, with the creation of each new module, the effort to revise the documentation can triple. In the crunch to get the program done on time, the master design documentation never seems to get updated.<P>
Like many DDJ readers, I've faced this documentation problem myself. I recently wrote a large program in C that eventually had more than 750,000 bytes of source code. Not only were there more than 220 different source-code modules, but there were lots of assembly code modules and screen files as well. As you might guess, many of the modules weren't specified in the original design. This became a major problem because I wrote the program for another company that planned to maintain it from my documentation. The way the various modules fit together was important, and the best way I could show the relationships was by drawing a tree structure. The problem I faced was that detailing over 220 modules is very time-consuming and, given the project deadline, I probably wouldn't finish.<P>
Here is my solution: a utility to document the source-code modules. Like many programs, this one was based on a philosophy of laziness. My thinking has always been that to do something once is fine, but if the task is boring or repetitious, then it's time for a computer. It was obvious from the circumstances that I needed a program that would do the tedious tree charting for the project.<P>
A quick look through magazines for exactly what I needed did not produce results. But after examining an ad for a program that showed the control flow of a single source-code module, I quickly realized that I could use the same concept for every module and function of a C project. After thinking about it, I came up with an outline of my utility program. The following list are features that I wanted in my charting program:<P>
<ul>
<li>It should take as input a list of filenames.</li>
<li>It should output a list of all functions, in the order called, starting with main.</li>
<li>The program should count the number of times each function is invoked.</li>
<li>The program should maintain the module's filename that contains the function's source code.</li>
<li>It should count the number of lines and characters in each module.</li>
<li>It should identity the functions not used in the project.</li>
<li>It should create a function index.</li>
</ul>
I eventually wound up writing a program to satisfy this list. The rest of this article details the operation of my program, which I call cp (for C printer).<P>
<a href="1988017b.htm">Figure 1</A> on opposite page, shows a greatly trimmed printout from the program. In this case, I used the utility to document the various functions and modules in the source code for the cp program itself. <a href="1988017c.htm">Figure 1</A> gives an example of the first and largest part of any report: the module relationships. The generated report also contains statistics for the sizes of the modules, with function indexes including a list of functions not used.<P>
<a href="1988017d.htm">Figure 1:</A> Sample output from the C printer program. Following this function map come reports on the module sizes and function lists indexed by both module and page number.<P>
The cp program itself is broken into three files: cp.c (the main module), cpfuncts.c (containing the support functions), and cpheader.h (the header module). <a href="8808c.htm#0179_000b"> Listing One</A>, <a href="8808c.htm#0179_000e"> Listing Two</A>, and <a href="8808c.htm#0179_000f">Listing Three</A> begin with op.c, chheader.h, an cpfuncts.c, respectively.<P>
<h3><a name="0179_0004">How the Program Works<a name="0179_0004"></h3><P>
The cp program starts by scanning the module files contained in the source-list file for every function either called or defined. (The source-list file is simply an ASCII text file that contains the names of the modules used in the project, one name per line.) After the scan, the program stores all the gathered information in an array of module structures. Each entry in the module structure contains the following information:<P>
<ul>
<li>A pointer to the name of the module.</li>
<li>A pointer to the name of the defined function.</li>
<li>A pointer to a sequential list of different function structures that are called.</li>
<li>The number of different functions that are called by the defined function.</li>
<li>A pointer to a linked list of page references.</li>
<li>The number of times the defined function is used in the program.</li>
</ul>
As the program reads each source file, the program keeps a structured list of module names, recording the number of lines and characters, for statistical purposes.<P>
After finding a called function, the program adds the function's name to the sequential list of functions. The list is maintained in a first-come-first served order. Prior to placing a function in the list, the program checks for duplicate entries. If the function is already in the list, then the used count is incremented for be duplicate entry.<P>
The program continues until it has read all the source files. It then sorts the list of defined functions by function name. The printout is started by searching the sorted list for the function main. If the function main was found, the program prints each function in the called function list. If a called function name is found in the defined module list, then the usage count is checked. All defined functions that are used only once are then recursively passed to the print function. When the program completely prints main, the print routine prints the defined functions that are used more than once. While each function is printed, a linked list of page references is updated.<P>
As you can see in the sample printout, the program prints each function inside a text box. Printed in the lower-left corner of the box is a word or description about the function. If the function is a root function or a defining function, then the program prints the name of the module where the function is defined. If the function is defined somewhere in the list of code modules and is currently a called function, then the word defined is printed. The program prints the word library if the function is not defined in any of the source modules. The word recursive is printed if the function is calling either itself or one of its parent functions. The program checks for a recursion depth of 50. If the function being printed is a root function, then the program prints the number of called functions. Otherwise, the number of times each called function is used is printed.<P>
<h3><a name="0179_0005">Just the Stats, Madam<a name="0179_0005"></h3><P>
After printing all the functions, the program prints statistical data collected during the scan of the modules. The first list contains the name each module with its number of lines and bytes. At the end of the list is the total byte count and the total number of lines. The second list contains the names of all functions that were defined in the list of code modules. The functions are printed in ascending order, with the name of the module file where the function is defined and the number of times the function was used in the program. The third list is an index or a cross reference to the pages where each module is used or defined in the printout. The last list contains the names of all the functions that are not used or called in the program, along with the module where the unused function is defined.<P>
The header file cpheader.h (<a href="8808c.htm#0179_000e"> Listing Two</A>) contains the definitions of the structures and the global variables. Each source file that includes the header must define the constant MAINMODULE. If MAINMODULE equals zero, then the global variables are stated as external; if MAINMODULE does not equal zero, then the variables are declared. In the file that contains main the constant MAINMODULE is defined as 1 so that the global variables will be initially defined. The other files should define MAINMODULE as 0 so the variables will be externals. The constant MAXFNCTS, in the header file, is the total number of different called functions used in each function. The constant MAXMODULES is the total number of different files that make up the program.<P>
The main file cp.c contains the main function, which checks for command-line inputs, opens the sourcelist file, displays error messages, and prints the data to the destination device. Each file is opened in main and the filename is passed to the function xref.<P>
The function xref looks through the module file looking for functions. Functions to xref are text words followed by an open parenthesis. Defined functions occur when the open brace count is 0. When the open brace count is greater than 1, the function is a called function. Defined functions are differentiated from function declarations because a semicolon follows a function declaration.<P>
<h3><a name="0179_0006">Supporting Characters<a name="0179_0006"></h3><P>
The module file cpfuncts.c (<a href="8808c.htm#0179_000f">Listing Three</A>) contains functions called by main and xref. The function getnext processes each character from the source-module file, and rejects any character between quotation marks, apostrophes, or comments.<P>
The function getchars either reads a character from the file or from a last-in-first-out buffer. The buffer contains characters that were read once and need to be reread. If there are no more characters to read, the program returns an end-of-file character.<P>
If a character that was read from the source file needs to be reread, the function pushc will place the character into a last-in-first-out buffer. The function checks for room in the buffer prior to putting the character into the buffer.<P>
The function addlist adds the name of the called function to the defined function's list. The function checks to see if the called function is one of C's reserved keywords or if the called function is already in the list before adding it. If the called function already exists in the list, then addlist increments the usage count.<P>
The function find_mod searches the sorted list of defined functions for the supplied function name. The function find_mod returns the index number of the defined function if it is in the list; otherwise, find_mode returns -1 to indicate that it was not found.<P>
The function doprint starts the printout with a defined function's index. This function is the &quot;meat and potatoes&quot; of the printer program: do print prints all the called functions of the supplied function index. If a called function is defined only once in the source files, then doprint calls itself with the new defined function index. It also knows whether the function is defined, a library function, or a recursive call. Each time that doprint is called, it checks a recursion list. If the new function is not in the list, it is then added to the end of the list. When do print exits, it removes the last entered item from the recursion list.<P>
The function getstats checks for the use of each defined function in the source files. The function getstats scans the list of used functions collected by the function xref when each used function is found in the defined function list, (find_mod) the used count for the defined function is incremented.<P>
The function pagebreak checks the count of printed lines to see if enough lines have been printed to print both a formfeed and a new page header. The function forces the printing of a new page by setting the line value to 99, which is greater than the number of lines allowed per page.<P>
The function recur_chk checks through a list of parent functions for the current function name. If the function is in the list, then the current function is a recursive function. The recursion list is a first-in-last-out list of function names.<P>
The function setpage adds the page number to the linked list of structures containing page data for the supplied function name. The last entry in the list contains a NULL pointer to the next entry.<P>
The function strcheck checks a character set for valid characters in a function name. If the character is a valid function-name character, strcheck returns a value of 1; if not, strcheck returns a value of 0.<P>
<h3><a name="0179_0007">Construction Details<a name="0179_0007"></h3><P>
I used Microsoft's C compiler version 4.0 and its make utility program. I then compiled the program using the large memory model. As far as I can tell, there aren't any dangerous dependencies on Microsoft C in the code, so translating it to another version of C should be straightforward.<P>
I controlled the project with Microsoft's make utility; the make file is shown in <a href="8808c.htm#0179_0008">Example 1</A>, on page 48. (If you don't have make then you'll have to enter the appropriate command lines yourself.) The make utility compares the dates of the independent files, which are to the right of the colon, to the dependent file, which is left of the colon. If any of the independent files are newer than the dependent file--implying that you've edited one of them--then the program executes the list of commands that follows. To link the resulting object files, type on the command<P>
<pre>     line      link cp + cpfuncts;</pre><P>
<h4><a name="0179_0008"><a name="0179_0008"><B>Example 1:</B> A sample make file for cp, specifying large model and maximum optimization.</h4><P>
<pre>
cp.obj : cp.c cpheader.h
     cl -Ox -AL cp.c -c

cpfuncts.obj : cpfuncts.c cpheader.h
     cl -AL -Ox cpfuncts.c -c

cp.ex. : cp.obj cpfuncts.obj
     link cp+cpfuncts;
</pre><P>
<P>
To use the program, you must create a file that contains a list of all your C source filenames. You do not need to sort the file: cp sorts the file itself so it can tell how far along it is during the processing. For example, the program cp.exe is created from the two source files cp.c and cpfuncts.c. <a href="8808c.htm#0179_0009">Example 2</A>, on page 48, shows the contents of the list file. The command line in this example should have the following information: cp mylist outfile. mylist is the file that contains the names of the sourcecode files. outfile is the name of the output file or device. If the cp program is called without any arguments on the command line then it will display the proper usage for the program. The program defaults to an output file name of prn if no file name is given on the command line. To invoke cp for the example program, type<P>
<pre>     cp cplist cplist.prn &lt;Enter&gt;</pre><P>
The program cp will read the file cplist for the list of filenames and will output the printout to the file cplist.prn.<P>
<h4><a name="0179_0009"><a name="0179_0009"><B>Example 2:</B> Sample file list created for cp.c.</h4><P>
<pre>
     cp.c
     cpfuncts.c


</pre><P>
<P>
<h3><a name="0179_000a">Revisions and Improvements<a name="0179_000a"></h3><P>
It's difficult to resist the urge to improve a program while you're actually programming, and it's even harder once you've started testing the results. I found this program to be no different. Since I finished the first version of cp, I've added a number of improvements, including these:<P>
<ol>1.     Support for Microsoft Windows C programs.</ol><P>
<ol>2.     The ability to enter a starting function name, instead of just main from the command line. For example, in a windows program, main would be named WinMain.</ol><P>
<ol>3.     Command-line arguments for page width and length.</ol><P>
<ol>4.     The saving of the first comment of each module to be printed as a short module description list.</ol><P>
<ol>5.     A command-line switch to print the statistical information only.</ol><P>
Feel free to use the program at home or in your business, but please don't distribute it for profit. Programs like this are tools to increase your productivity and should be freely shared. Please direct any questions, comments, improvements, or bugs to the address at the beginning of the article. If you need a reply, include a self-addressed stamped envelope.<P>


_AUTOMATIC MODULE CONTROL IN C_
by
Stewart Nutter


<a name="0179_000b"><a name="0179_000b">
<a name="0179_000c"></pre><B>[LISTING ONE]</B><pre><a name="0179_000c">


/* print a visual tree representation of a 'C' program */
/* cp.c */

/***********************************************************

  cprinter - print a visual tree representation
             of a 'C' program

  copyright 1987, Stewart A. Nutter

  Please do not distribute this for profit. For
  individual use only.

  written by: Stewart A. Nutter

 **********************************************************/

#define MAINMODULE 1
#include &quot;cpheader.h&quot;

main( argc, argv )

char **argv;
int argc;

{
char szName[20];             /* input file name */
int iRet;
int l, i, j, k;              /* index variables */
int sflag;
int pcnt;
int tmp;
int pmax;                    /* max number of xref columns */
int index;
FILE *stream;
struct Pages *p;
long int total;              /* total number of bytes */
long int ltotal;             /* total number of lines */

pFlist = Flist;
pMlist = Mlist;
pMnames = Mnames;

for ( i=0; i&lt;50; i++ )     /* clear out the recursion list */
   rlist[i] = NULL;

printf( &quot;\ncp - ver. 1.3, (C) 1987, 1988  Stewart A. Nutter&quot; );
printf( &quot;\n     written by Stewart A. Nutter\n&quot; );

/* no arguments - print instructions */

if ( argc &lt; 2 )
   {
   printf( &quot;\ncp listfile [ outfile ] [ /l:xx /w:yy /t:main /s:z ]\n&quot; );
   printf( &quot;     outfile            = \&quot;prn\&quot; \n&quot; );
   printf( &quot;     l: page length     = 66       [0, 50-255]\n&quot; );
   printf( &quot;     w: page width      = 80       [80-255]\n&quot; );
   printf( &quot;     m: left margin     = 8        [0-30]\n&quot; );
   printf( &quot;     r: right margin    = 8        [0-30]\n&quot; );
   printf( &quot;     t: target function = \&quot;main\&quot;\n&quot; );
   printf( &quot;     s: statistics only = 0        [0=all, 1=stats only]\n&quot; );
   printf( &quot;\n&quot; );
   printf( &quot;Notes: 1. Maximum recursive function displacement of 50.\n&quot; );
   printf( &quot;       2. Maximum number of functions calls is %d.\n&quot;, MAXFNCTS );
   printf( &quot;       3. Maximum number of modules is %d.\n&quot;, MAXMODULES );
   exit( 0 );
   }


if ( ( stream = fopen( argv[1], &quot;r&quot; ) ) == NULL )
   {
   fprintf( stderr, &quot;\n%s&quot;, strerror( errno ) );
   exit( 1 );
   }

/* an output file name was given? */

index = 2;

if ( argc &gt; 2 &amp;&amp; argv[index][0] != '/' )
   {
   output = fopen( argv[2], &quot;w+&quot; );
   index++;
   }
else
   output = fopen( &quot;prn&quot;,&quot;w+&quot; );  /* prn device by default */

for ( i=index; i&lt;argc; i++ )
   {
   if ( argv[i][0] == '/' &amp;&amp; strlen( argv[i] ) &gt; 3 &amp;&amp; argv[i][2] == ':' )
      {
      switch ( argv[i][1] )
         {
         case 'l' :              /* change the page length */
            tmp = atoi( &amp;argv[i][3] );
            if ( ( tmp &gt; 50 &amp;&amp; tmp &lt; 256 ) || tmp == 0 )
              pl = tmp;
            break;

         case 'm' :              /* change the left margin */
            tmp = atoi( &amp;argv[i][3] );
            if ( tmp &gt;= 0 &amp;&amp; tmp &lt;= 30 )
              lm = tmp;
            break;

         case 'r' :              /* change the rignt margin */
            tmp = atoi( &amp;argv[i][3] );
            if ( tmp &gt;= 0 &amp;&amp; tmp &lt;= 30 )
              rm = tmp;
            break;

         case 's' :              /* set the stats only? */
            stats = atoi( &amp;argv[i][3] );
            break;

         case 't' :              /* change the target function */
            strcpy( target, &amp;argv[i][3] );
            break;

         case 'w' :              /* change the width */
            tmp = atoi( &amp;argv[i][3] );
            if ( tmp &gt; 79 &amp;&amp; tmp &lt; 256 )
              pw = tmp;
            break;

         }
      }
   else
      {
      printf( &quot;\nUnknown argument: %s&quot;, argv[i] );
      exit( 1 );
      }
   }

if ( output == NULL )
   {
   fprintf( stderr, &quot;\n%s&quot;, strerror( errno ) );
   exit( 1 );
   }

width = pw - lm - rm;
if ( width &lt; 40 )
   {
   fprintf( stderr, &quot;\nThe page width is too narrow.&quot; );
   exit( 1 );
   }

printf( &quot;\n&quot; );


/* read the input file for file names */

while ( !feof( stream ) )
   {
   szName[0] = '\0';
   fgets( szName, 19, stream );
   if ( ( l = strlen( szName ) ) &gt; 1 )
      {
      if ( szName[l - 1] == '\n' )
         szName[l - 1] = '\0';    /* remove newline char */
      xref( szName );
      }
   }

/* pointer list for sort */

for ( i=0, pMlist=Mlist; i&lt;Mqty; i++ )
   {
   pm[i] = pMlist++;
   }

printf( &quot;\n\nSorting the function list...\n&quot; );

sflag = 1;
while ( sflag )                 /* sort the function names */
   {
   sflag = 0;
   for ( i=0; i&lt;Mqty-1; i++ )
      {
      if ( strcmp( pm[i]-&gt;function, pm[i+1]-&gt;function )&gt;0 )
         {
         sflag = 1;
         pMlist = pm[i];
         pm[i] = pm[i+1];
         pm[i+1] = pMlist;
         }
      }
   }
i = find_mod( target );  /* must start with the target function */

if ( i &gt;= 0 )                   /* 'main' must exist */
   {
   depth = 0;

   printf( &quot;Checking for usage...\n&quot; );

/* check how many times each function is used */

   getstats( );
   depth = 0;
   bfr[0] = 0;

   printf( &quot;Starting the printout...\n&quot; );

   line = 0;
   if ( stats == 0 )
      {
      pm[i]-&gt;used = 1;   /* set so main shows up in the list */
      doprint( i );  /* print the non-library functions */

      for ( i=0; i&lt;Mqty; i++ )  /* print defined functions now */
         {
         fprintf( output, &quot;\n&quot; );
         line++;
         if ( pm[i]-&gt;used &gt; 1 ) /* must be used more than once */
            {
            doprint( i );          /* print the tree structure */
            }
         }
      }

/* print statistics on the modules */

   line = 9999;                 /* force a new page */
   pMnames = Mnames;
   pagebreak( );
   leftmargin( output );
   fprintf( output, &quot;Module statistics :\n&quot; );
   line++;
   total = 0L;
   ltotal = 0L;
   for ( i=0; i&lt;Mcnt; i++ )  /* print module names &amp; sizes */
      {
      pagebreak( );
      leftmargin( output );
      fprintf( output,
              &quot;%-12s - %5u lines, %6ld bytes\n&quot;,
              pMnames-&gt;name, pMnames-&gt;length,
              pMnames-&gt;size );
      total += pMnames-&gt;size;
      ltotal += pMnames-&gt;length;
      line++;
      pMnames++;
      }
   fputc( '\n', output );
   leftmargin( output );
   fprintf( output,
           &quot;Total source size = %ld bytes in %ld lines for %d modules\n&quot;,
           total, ltotal, Mcnt );

/* print the used function page index */

   line = 9999;                 /* force a new page */
   pagebreak( );
   leftmargin( output );
   fprintf( output, &quot;Function index :\n&quot; );
   line++;
   for ( i=0; i&lt;Mqty; i++ )    /* print used function names */
      {
      pMlist = pm[i];
      if ( pMlist-&gt;used &gt; 0 )
         {
         pagebreak( );
         leftmargin( output );
         fprintf( output,
                 &quot;%-25s - %-12s - used =%d \n&quot;,
                 pMlist-&gt;function, ( pMlist-&gt;name )-&gt;name,
                 pMlist-&gt;used );
         line++;
         }
      }

/* print the function page cross reference */

   if ( stats == 0 &amp;&amp; pl &gt; 0 )     /* print everything */
      {
      pmax = ( int )( width - 27 )/5;
      line = 9999;                 /* force a new page */
      pagebreak( );
      leftmargin( output );
      fprintf( output, &quot;Function cross reference :\n&quot; );
      line++;
      for ( i=0; i&lt;Mqty; i++ )  /* print used function names */
         {
         pMlist = pm[i];
         if ( pMlist-&gt;used &gt; 0 )
            {
            pagebreak( );
            leftmargin( output );
            fprintf( output, &quot;%-25s- &quot;, pMlist-&gt;function );
            p = pMlist-&gt;pg;
            if ( p != NULL )
               {
               pcnt = 0;
               while ( p-&gt;next != NULL )
                  {
                  fprintf( output, &quot;%4d,&quot;, p-&gt;pg );
                  p = p-&gt;next;
                  pcnt++;
                  if ( pcnt &gt;= pmax )
                     {
                     fputc( '\n', output );
                     leftmargin( output );
                     fprintf( output, &quot;%27s&quot;, &quot; &quot; );
                     line++;
                     pcnt = 0;
                     }
                  }
               fprintf( output, &quot;%4d\n&quot;, p-&gt;pg );
               line++;
               }
            else
               fprintf( output, &quot;\n&quot; );
            }
         }
      }

/* print statistics on all unused modules */

   line = 9999;                 /* force a new page */
   pagebreak( );
   leftmargin( output );
   fprintf( output, &quot;Un-used function list :\n&quot; );
   line++;
   pcnt = 0;
   for ( i=0; i&lt;Mqty; i++ )  /* print unused function names */
      {
      pMlist = pm[i];
      if ( pMlist-&gt;used == 0 )
         {
         pagebreak( );
         pcnt++;
         leftmargin( output );
         fprintf( output,
                 &quot;%-25s - %-12s \n&quot;,
                 pMlist-&gt;function, ( pMlist-&gt;name )-&gt;name );
         line++;
         }
      }
   if ( pcnt == 0 )
      {
      leftmargin( output );
      fprintf( output,
              &quot;No un-used functions in the list.\n&quot; );
      }

/* print module comments */

   line = 9999;                 /* force a new page */
   pMnames = Mnames;
   pagebreak( );
   leftmargin( output );
   fprintf( output, &quot;Module comments :\n&quot; );
   line++;
   for ( i=0; i&lt;Mcnt; i++ )  /* print module names &amp; comments */
      {
      pagebreak( );
      leftmargin( output );
      fprintf( output,
              &quot;%12s -%s\n&quot;,
              pMnames-&gt;name, pMnames-&gt;cmt );
      line++;
      pMnames++;
      }
   fprintf( output, &quot;%c&quot;, 0x0c );         /* ending formfeed */
   }
}



/* process the file for function names */

xref( fname )

char *fname;

{
int done;               /* loop termination flag */
int brace_cnt;          /* count of the open braces */
int open_paren;         /* open paranthisis count */
int ret;                /* return value */
int indx;               /* for/next index */
int dflg;               /* function definition flag */
static int wflg = 0;
char c;                 /* character read from disk file */
char buffer[50];        /* temporary buffer */
char bufr[256];         /* temporary buffer */
register char *p;       /* fast character pointer */
FILE *stream;           /* module file pointer */
struct Mod_list *cptr;  /* pointer to the module list structure */
static char back[] =
   {8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8};

printf( &quot;%cProcessing file: %-12s   &quot;, 0x0d, fname );

if ( ( stream = fopen( fname, &quot;r&quot; ) ) == NULL )
   return( -1 );

pp = pc;
if ( ( pMnames-&gt;name = strdup( fname ) ) == NULL )
   {
   fprintf( stderr, &quot;Ran out of memory.\n&quot; );
   exit( 1 );
   }
pMnames-&gt;length = 0;
pMnames-&gt;size = 0L;

buffer[0] = 0;
p = buffer;

open_paren = 0;
brace_cnt = 0;
firstcmt = 0;
filecmt[0] = 0;
done = 0;
ret = 0;
while ( !ret )
   {
   c = getnext( stream );
   switch ( c )
      {
      case '{'  :
         brace_cnt++;   /* increment the open brace count */
         break;
      case '}'  :
         brace_cnt--;   /* decrement the open brace count */
         break;
      case '('  :
         if ( open_paren == 0 ) /* first open paren only */
            {
            open_paren = 1;
            }
         wflg = 1;
         break;
      case ' ' :              /* skip tabs and spaces */
      case '\t' :
         do
            {
            c = getnext( stream );
            }
         while ( c == '\t' || c == ' ' );
         if ( c != '(' )
            wflg = 1;
         pushc( c );
         break;
      case 0x1a :            /* end of the file indicator */
         ret = 1;
         wflg = 1;
      default :

/* the character must be a variable character */

         if ( strcheck( c ) )
            {
            *p++ = c;
            *p = 0;
            }
         else
            wflg = 1;
         break;
      }
   if ( wflg )
      {
      if ( buffer[0] &amp;&amp; ( buffer[0] &lt; '0' || buffer[0] &gt; '9' ) )
         {
         done = 1;
         }
      else
         {
         p = buffer;
         buffer[0] = 0;
         open_paren = 0;
         }
      wflg = 0;
      }

/* if done != 0 there is a token */

   if ( done )
      {
      done = 0;
      *p = 0;

      if ( open_paren )               /* functions start with an open paren */
         {
         open_paren = 0;
         if ( brace_cnt == 0 )        /* and no braces */
            {
            dflg = 0;
            for ( indx=0; indx&lt;256 &amp;&amp; dflg==0; indx++ )
               {
               c = getnext( stream );
               if ( c == ';' )
                  dflg = 1;
               else if ( c == '\n' )
                  dflg = 2;
               bufr[indx] = c;
               }
            if ( dflg == 0 )
               {
               fprintf( stderr, &quot;\nSyntax error: &quot; );
               fprintf( stderr, &quot;Module description.\n&quot; );
               bufr[indx] = 0;
               fprintf( stderr, &quot;\n%s\n&quot;, bufr );
               exit( 1 );
               }

/* put the characters back to be read */

            while ( indx )
               {
               pushc( bufr[indx-1] );
               indx--;
               }

/* this is a function definition */

            if ( dflg == 2 )
               {
               printf( &quot;%-40s%s&quot;, buffer, back );
               pMlist-&gt;name = pMnames;
               pMlist-&gt;qty = 0;
               pMlist-&gt;ptr = pFlist;

               /* allocate memory for name */

               if ( ( pMlist-&gt;function = strdup( buffer ) )
                    == NULL )
                  {
                  fprintf( stderr, &quot;\nRan out of memory.&quot; );
                  exit( 1 );
                  }
               pMlist-&gt;used = 0;
               pMlist-&gt;pg = NULL;
               cptr = pMlist;
               pMlist++;
               Mqty++;
               if ( Mqty &gt; MAXMODULES )
                  {
                  fprintf( stderr,
                          &quot;Too many new functions\n&quot; );
                  exit( 1 );
                  }
               }
            }
         else
            {
            cptr-&gt;qty += addlist( cptr-&gt;ptr,
                                 buffer, cptr-&gt;qty );

            }
         }
      p = buffer;
      *p = 0;
      }
   }
fclose( stream );
pMnames-&gt;cmt = strdup( filecmt );
pMnames++;   /* point to the next function data structure */
Mcnt++;               /* count of the different functions */
return( ret );
}


<a name="0179_000e"><B>[LISTING TWO]</B><pre>

cp.obj : cp.c cpheader.h
   cl -Ox -AL cp.c -c

cpfuncts.obj : cpfuncts.c cpheader.h
   cl -Ox -AL cpfuncts.c -c

cp.exe : cpfuncts.obj cp.obj
   link cp+cpfuncts/st:4096;


<a name="0179_000f"><a name="0179_000f">
<a name="0179_0010"></pre><B>[LISTING THREE]</B><pre><a name="0179_0010">


/* function module for the program 'cp'
   the cp program must be compiled with the large model */

/***********************************************************

 cpfuncts.c - function module for the program 'cp'

 copyright 1987, Stewart A. Nutter

 written by: Stewart A. Nutter

 ***********************************************************/


#define MAINMODULE 0
#include &quot;cpheader.h&quot;

/* getnext - get the next character from the stream */

getnext( stream )

FILE *stream;

{
register char c;
static int qflag=0, cflag=0, eflag=0;
static int dflag=0, aflag=0, ncnt=0;
static int fp;
int b, done;

done = 1;
do
   {
   if ( ( qflag | cflag | eflag | dflag | aflag ) == 0 )
      done = 1;
   c = getchars( stream );

/* process escape sequence characters */

   if ( eflag &amp;&amp; c != 0x1a )
      {
      if ( c &gt;= '0' &amp;&amp; c &lt;= '7' &amp;&amp; ncnt &lt; 3 )
         ncnt++;
      else
         {

/* had less than the 3 octal digits */

         if ( ncnt &lt; 3 &amp;&amp; ncnt &gt; 0 )
            pushc( c );
         ncnt = 0;
         eflag = 0;
         }
      }
   else if ( cflag &amp;&amp; c != 0x1a )  /* skipping a comment */
      {
      if ( firstcmt == 1 )
         {
         if ( c != '\n' &amp;&amp; strlen( filecmt ) &lt; ( width - 14 ) )
            {
            filecmt[fp] = c;
            fp++;
            filecmt[fp] = 0;
            }
         else
            {
            do       /* remove extraneous spaces and tabs */
               {
               b = getchars( stream );
               }
            while ( b == ' ' || b == '\t' );
            pushc( b );
            filecmt[ fp++ ] = ' ';
            filecmt[ fp ] = '\0';
            }
         }
      if ( c == '*' )
         {
         b = getchars( stream );
         if ( b == '/' )
            {
            firstcmt = 2;     /* done with the comment */
            if ( fp &gt; 0 )
               filecmt[fp - 1] = 0; /* terminate the line */
            cflag = 0;
            }
         else
            pushc( b );
         }
      }
   else if ( qflag &amp;&amp; c != 0x1a )  /* skipping a string */
      {
      if ( c == 0x27 )
         eflag = 1;
      else if ( c == '\&quot;' )
         {
         pushc( 0x1b );
         qflag = 0;
         }
      }
   else if ( dflag &amp;&amp; c != 0x1a )  /* defines/includes etc. */
      {
      if ( c == '\n' )
         dflag = 0;
      }
   else if ( aflag &amp;&amp; c != 0x1a )  /* skip a character */
      {
      if ( c == 0x27 )
         {
         aflag = 0;
         pushc( 0x1b );
         }
      else if ( c == '\\' )
         eflag = 1;
      }
   else
      {
      switch ( c )
         {
         case '\&quot;' :
            qflag = 1;
            break;
         case 0x27 :
            aflag = 1;
            break;
         case '#' :
            dflag = 1;
            break;
         case '/' :
            b = getchars( stream );
            if ( b == '*' )
               {

               /* this is the first comment of the file */

               if ( firstcmt == 0 )
                  {
                  firstcmt = 1;
                  filecmt[0] = 0;
                  fp = 0;
                  }
               cflag = 1;
               }
            else
               {
               pushc( b );
               }
            break;
         }
      }
   if ( aflag || dflag || qflag || eflag || cflag )
      done=0;
   }
while ( !done &amp;&amp; c != 0x1a );
if ( c == 0x1a )
   {
   ncnt = 0;
   aflag = 0;
   dflag = 0;
   qflag = 0;
   eflag = 0;
   cflag = 0;
   }
return( c );
}


/* getchars - read inputs from the file */

getchars( stream )

FILE *stream;

{
register char c;

if ( pp != pc )
   c = *--pp;
else
   {
   c = fgetc( stream );
   if ( c == EOF )
      c = 0x1a;
   if ( c == 0x0a )
      {
      pMnames-&gt;length++;
      pMnames-&gt;size++;     /* count the unseen &lt;cr&gt; */
      }
   pMnames-&gt;size++;
   }
return( c );
}

/* pushc - save the char. in a last in first out stack */

pushc( c )

char c;

{
if ( ( pp - pc ) &lt; 1000 )
   *pp++ = c;
else
   {
   fprintf( stderr, &quot;\nProgram syntax error:&quot; );
   fprintf( stderr, &quot; Too many pushed characters.\n&quot; );
   exit( 1 );
   }
}


/* addlist - add the name to the list if different */
/*           and if not one of the 'c' key words */

#define KEYS 5

addlist( p, buf, cnt )

struct Func_list *p;
char *buf;
int cnt;

{
int i, ret;
static char *keywords[KEYS] =
   {
   &quot;while&quot;,
   &quot;if&quot;,
   &quot;for&quot;,
   &quot;switch&quot;,
   &quot;return&quot;,
   };

for ( i=0; i&lt;KEYS &amp;&amp; strcmp( buf, keywords[i] )!=0; i++ )
   ;

if ( i &lt; KEYS )
   return( 0 );

for ( i=0; i&lt;cnt &amp;&amp; strcmp( buf, p-&gt;name ); i++ )
   p++;

if ( i == cnt )
   {
   ret = 1;
   if ( ( pFlist-&gt;name = strdup( buf ) ) == NULL )
      {
      fprintf( stderr, &quot;Ran out of memory.\n&quot; );
      exit( 1 );
      }
   pFlist-&gt;used = 1;
   pFlist++;            /* point to the next empty cell */
   Fqty++;
   if ( Fqty &gt; MAXFNCTS )
      {
      fprintf( stderr, &quot;Too many functions.\n&quot; );
      exit( 1 );
      }
   }
else
   {
   ret = 0;
   p-&gt;used++;
   }
return( ret );
}


/* find_mod - return the index of the linked list for
              the indicated function. A -1 means that
              the function name was not found in the list */

find_mod( buf )

char *buf;

{
int lo, hi, mid;
int d;

lo = 0;
hi = Mqty - 1;
mid = ( hi + lo )/2;

while ( 1 )
   {
   d = strcmp( buf, pm[mid]-&gt;function );
   if ( d == 0 )
      break;

   if ( lo &gt;= hi )
      {
      mid = -1;
      break;
      }

   if ( d &lt; 0 )
      {
      hi = mid - 1;
      }
   else
      {
      lo = mid + 1;
      }
   mid = ( hi + lo )/2;
   }

return( mid );
}


/* doprint - print the function name and sub - functions */

static char lib[] = {&quot;(library)&quot;};
static char use[] = {&quot;Used=&quot;};
static char fct[] = {&quot;Functs=&quot;};

doprint( n )

int n;
{
int i, j, k, l, ret;
struct Mod_list *p;
struct Func_list *q;

l = n;
p = pm[l];

/* add function to list for recursion check */

rlist[depth] = p-&gt;function;

pagebreak( );

setpage( pm[l] );
ret = page - 1;
pblock( bfr, p-&gt;function, ( p-&gt;name )-&gt;name, fct, p-&gt;qty );

depth++;
strcat( bfr, &quot;   |&quot; );

k = p-&gt;qty;
for ( j=0, q = p-&gt;ptr; j&lt;k; j++, q++ )
   {
   pagebreak( );
   i = find_mod( q-&gt;name );

   if ( recur_chk( q-&gt;name ) )
      {
      leftmargin( output );
      fprintf( output, &quot;%s\n&quot;, bfr );
      if ( i &gt;= 0 )
         setpage( pm[i] );
      pblock( bfr, q-&gt;name, &quot;(recursive)&quot;, &quot;&quot;, 0 );
      line++;
      }
   else
      {
      if ( i &gt;= 0 )
         {
         if ( pm[i]-&gt;used == 1 )
            {

/* got a new function */

            leftmargin( output );
            fprintf( output, &quot;%s\n&quot;, bfr );
            line++;
            doprint( i );          /* used only once */
            }
         else
            {

/* a previously defined function */

            leftmargin( output );
            fprintf( output, &quot;%s\n&quot;, bfr );
            setpage( pm[i] );
            pblock( bfr, q-&gt;name, &quot;(defined)&quot;,
                    use, q-&gt;used );
            line++;
            }
         }
      else
         {

/* a library function */

         leftmargin( output );
         fprintf( output, &quot;%s\n&quot;, bfr );
         pblock( bfr, q-&gt;name, lib, use, q-&gt;used );
         line++;
         }
      }
   }

/* remove the function from the recursion list */

rlist[depth] = NULL;
bfr[strlen( bfr )-4] = 0;
depth--;
return( ret );
}


/* getstats - get the number of times each
              function is used */

getstats( )

{
register int i;
int j;
register struct Func_list *p;

p = Flist;

for ( i=0; i&lt;Fqty; i++ )
   {
   j = find_mod( p-&gt;name );  /* see if the name exists */
   if ( j &gt;= 0 )
      pm[j]-&gt;used += p-&gt;used;
   p++;
   }
}


/* pblock - print a function block */

pblock( pre, fptr, mptr, sptr, cnt )

char *pre, *fptr, *sptr, *mptr;
int cnt;

{
leftmargin( output );
fprintf( output, &quot;%s %s\n&quot;, pre, tline );
leftmargin( output );
fprintf( output, &quot;%s-+%-25s|\n&quot;, pre, fptr );
leftmargin( output );
fprintf( output, &quot;%s |%-12s %8s%3d |\n&quot;,
        pre, mptr, sptr, cnt );
leftmargin( output );
fprintf( output, &quot;%s %s\n&quot;, pre, tline );
line += 4;

}


/* pagebreak - check for a page break and if so
               then print the page header */

pagebreak( )

{
   int i;
   static char title[] = { &quot;C PRINTER  - (c) 1987, 1988  rev. 1.2&quot; };

if ( pl == 0 &amp;&amp; line == 9999 )
   {
   fprintf( output, &quot;\n\n\n\n&quot; );
   line = 0;
   }
else if ( pl != 0 )
   {
   if ( line &gt; ( pl - 11 ) )
      {
      fprintf( output, &quot;%c&quot;, 0x0c );
      line = 0;
      }
   if ( line == 0 )
      {
      leftmargin( output );

      fprintf( output, &quot;%s&quot;, title );
      for ( i=strlen( title ); i&lt;width-10; i++ )
         fputc( ' ', output );
      fprintf( output, &quot;Page:%4d\n&quot;, page );

      leftmargin( output );
      for ( i=0; i&lt;width; i++ )
         fputc( '-', output );
      fprintf( output, &quot;\n\n&quot; );
      line = 3;
      page++;
      }
   }
}


/* recur_chk - check if the function just called
               is one being processed */

recur_chk( buf )

char *buf;

{
register char **p;
int ret;

p = rlist;

while ( *p != NULL &amp;&amp; strcmp( *p, buf ) )
   {
   p++;
   }

if ( *p == NULL )
   ret = 0;   /* the function was not in the list */
else
   ret = 1;   /* found it */

return ret;
}


/* setpage - put the current page number
             into the linked page list */

setpage( ptr )

struct Mod_list *ptr;

{
struct Pages *p;

p = ptr-&gt;pg;
if ( p == NULL )
   {
   p = ( struct Pages * )malloc( sizeof( struct Pages ) );
   if ( p == NULL )
      {
      fprintf( stderr,
              &quot;Ran out of memory for page # list.\n&quot; );
      exit( 1 );
      }
   ptr-&gt;pg = p;
   p-&gt;next = NULL;
   p-&gt;pg = page - 1;
   }
else
   {
   while ( p-&gt;next != NULL )
      p=p-&gt;next;
   p-&gt;next = ( struct Pages * )malloc( sizeof( struct Pages ) );
   if ( p-&gt;next == NULL )
      {
      fprintf( stderr,
              &quot;Ran out of memory for page # list.\n&quot; );
      exit( 1 );
      }
   p = p-&gt;next;
   p-&gt;next = NULL;
   p-&gt;pg = page - 1;
   }
}


/* strcheck - check if the character is
              in the variable name set */

strcheck( c )

char c;

{
if ( ( c &gt;= 'A' &amp;&amp; c &lt;= 'Z' ) || ( c &gt;= 'a' &amp;&amp; c &lt;= 'z' ) ||
     c == '_' || ( c &gt;= '0' &amp;&amp; c &lt;= '9' ) )
   return( 1 );
else
   return( 0 );
}


stop( )
{
printf( &quot;hello&quot; );
}


/* print the left margin for the printout */

leftmargin( output )

   FILE *output;                    /* the output device pointer */

{
   register int i;

for ( i=0; i&lt;lm; i++ )
   fputc( ' ', output );
}


<a name="0179_0011"><a name="0179_0011">
<a name="0179_0012"></pre><B>[LISTING FOUR]</B><pre><a name="0179_0012">

#include &lt;malloc.h&gt;
#include &lt;conio.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

#define MAXFNCTS   4000    /* maximum number of functions */
#define MAXMODULES 500     /* number of different files */

struct Func_list           /* function statistics */
   {
   char *name;             /* function name */
   int used;               /* times used in function */
   };

struct Pages               /* linked list of pages */
   {
   int pg;                 /* page number */
   struct Pages *next;     /* pointer to next page */
   };

struct Module              /* module statistics */
   {
   char *name;             /* pointer to the module name */
   char *cmt;              /* module comment/description */
   unsigned int length;    /* lines in the module */
   long size;              /* bytes in the module */
   };

struct Mod_list            /* module control stucture */
   {
   struct Module *name;    /* pointer to module file name */
   char *function;         /* name of function in file */
   struct Func_list *ptr;  /* pointer to the first function */
   int qty;                /* different functions called */
   struct Pages *pg;       /* point to the page list */
   int used;               /* times the function is used */
   };

#if MAINMODULE != 0

struct Module Mnames[MAXMODULES], *pMnames;
struct Mod_list Mlist[MAXMODULES], *pMlist, *pm[MAXMODULES];
struct Func_list Flist[MAXFNCTS], *pFlist;
char *rlist[50];           /* recursion function list */
int Mqty = 0, Fqty = 0, Mcnt = 0;
int page=1, line=0, depth=0;
int fline;
int firstcmt;
char bfr[300];
char tline[] = {&quot;+-------------------------+&quot;};
char dbl[] = {&quot;  &quot;};
char vbar[] = {&quot;| &quot;};
char hbar[] = {&quot;+-&quot;};
FILE *output;
char pc[1000] = {0,0,0,0,0,0,0,0,0,0};
char *pp;
char filecmt[300];
int pw = 80;               /* page width */
int pl = 66;               /* page length */
int lm = 8;                /* left margin */
int rm = 8;                /* right margin */
int width;                 /* the printable page width */
char target[40] = &quot;main&quot;;  /* target function */
int stats = 0;

#else

extern struct Module Mnames[MAXMODULES], *pMnames;
extern struct Mod_list Mlist[MAXMODULES], *pMlist;
extern struct Mod_list *pm[MAXMODULES];
extern struct Func_list Flist[MAXFNCTS], *pFlist;
extern char *rlist[];       /* recursion function list */
extern int Mqty, Fqty, Mcnt;
extern int page, line, depth;
extern int fline;
extern int firstcmt;
extern char bfr[];
extern char tline[];
extern char dbl[];
extern char vbar[];
extern char hbar[];
extern FILE *output;
extern char pc[];
extern char *pp;
extern char filecmt[];
extern int pw;                    /* page width */
extern int pl;                    /* page length */
extern int lm;                    /* left margin */
extern int rm;                    /* right margin */
extern int width;                 /* the printable page width */
extern char target[];             /* target function */
extern int stats;

#endif


<P>
<P>
</pre></BODY></HTML>
