<HTML>
<META NAME="year" CONTENT="1988">
<HEAD>

<TITLE>APR88: EXAMINING ROOM</TITLE></HEAD>
<body bgcolor="FFFFFF">
<h1>EXAMINING ROOM<a name="00cb_0003"><a name="00cb_0003"></h1><P>
<h3><a name="00cb_0001"><a name="00cb_0000">Ron Copeland</h3><P>
<p><i><a name="00cb_0002"><a name="00cb_0000">Ron Copeland, associate editor, is the coordinator for this review section. He welcomes your feedback on products worth reviewing.</i></p><hr><P>
<h3><a name="00cb_0004">Turbo Professional 4.0<a name="00cb_0004"></h3><P>
<B>Product</B>: Turbo Professional 4.0<P>
<B>Target</B>: PC or PS/2 and compatibles<P>
<B>Requires</B>: DOS 2.0 or later; Turbo Pascal 4.0 or later; hard disk recommended<P>
<B>Pricing</B>: $99<P>
<B>Vendor</B>: Turbo Power Software, 3109 Scotts Valley Dr., Ste. 122 Scotts Valley, CA 95066; (408) 438-8608<P>
If you want to protect your reputation as a guru, don't let anybody know you use the Turbo Professional 4.0 library. The guys down at Turbo Power Software have made the hard stuff so easy that it's bound to reduce your fellow programmers' awe of your coding prowess.<P>
Imagine! You can create a pop-up window with a one-liner, and with other one-liners you can rearrange a stack of windows to bring the selected one to the top, make any of them go away, and write to the active window. Or you can similarly manipulate EMS and pull-down menus, insert chained interrupt handlers, and manage TSRs.<P>
All kidding aside, Turbo Professional 4.0 is a superbly crafted toolbox for serious programmers using Turbo Pascal 4.0. Consisting of some 300 functions and procedures spread across 25 Pascal units, it truly does render the difficult accessible. Some of these routines address defects in Turbo Pascal 4.0--lack of a BCD type, for example--while others simplify the dirty work of advanced applications development. My particular favorite, the unit on TSR management, removes the mysteries and perils from this most frustrating kind of program. There are even functions for changing the hot key on the fly and disabling a TSR. The manual has six lucid pages of discussion that make TSRs make sense. The 426-page manual does a workmanlike job of explaining how all these abstractions of complexity fit together and operate, and what the parameters mean.<P>
There isn't room here to cover all the goodies in this package, so I'll list the major categories and discuss a few particulars. These are the groupings of routines:<P>
<ul>
<li>Screen: Virtual screens, popups, pulldowns, input editing</li>
<li>Strings: Manipulations, formatting, long ASCIIZ, DOS command line parser</li>
<li>Low-level: Sugar-coated DOS and ROM BIOS calls</li>
<li>Interrupts and TSRs: TSR and TSR management, 8087 TSR support, critical error handler</li>
<li>Sorting: In-memory non-recursive quicksort of up to 64K elements</li>
<li>Memory: EMS and extended memory management</li>
<li>Macros: Keyboard macros and an editor</li>
<li>Large arrays: In RAM, EMS, and virtual memory</li>
<li>BCD: 18-digit precision for arithmetic and transcendentals</li>
<li>Other: Runtime error recovery, inline macros</li>
</ul>
Additionally, the package includes about a dozen demo programs that really are useful, such as a programmer's calculator (a TSR written with the library), time management/billing utilities, and a GREP-like text finder.<P>
Turbo Professional comes on three diskettes, only one of which (the TPU disk) you need to copy to your Turbo Pascal 4.0 directory in order to use the software. The other two disks contain the demo programs and archived source code for the entire library, along with an unarchiving utility.<P>
You harness the horsepower of this programming engine with the USES statement. All the units have the name pattern TP* .TPU, which makes them easy to identity. There are some unit dependencies, and several depend on Pascal's DOS unit as well. Appendix A in the manual lists them. As an example, to do virtual screens, the directive is<P>
<pre>     USES DOS, TPCRT, TPScreen;</pre><P>
The syntax of some of the calls is a little awkward, but that doesn't diminish their power. For example, to initialize and work with a pop-up window, the call is<P>
<pre>     IF NOT MakeWindow (win1,...)      THEN           {Error occurred}      ELSE           {Do
window stuff}</pre><P>
(MakeWindow is a function taking 12 arguments.) If MakeWindow is successful, you can pop it up with<P>
<pre>     BoolResult := SetTopWindow (win1);</pre><P>
where BoolResult becomes TRUE if the operation works. Getting rid of the most recently popped window is a different matter:<P>
<pre>     winPtr := EraseTopWindow;</pre><P>
which returns a pointer to the window erased. The extensive use of such value-returning functions rather than more intuitive procedures gives the library a C-like feel.<P>
The BCD module brings 18-digit precision to Pascal. This is much better than the 11-maybe precision of the REAL type and not subject to roundoff errors or the unexpected appearance of E notation. BCD is usually associated with business programming, but Turbo Professional makes it viable for scientific applications as well by including trig and exponential functions.<P>
Inclusion of the source code with Turbo Professional is a nice touch. If you think certain routines ought to work differently, you can change them. Some are written in Pascal, but most are in assembler, so you'll need MASM or something like it if you plan to do much rewriting. Of course you can also add functionality to suit.<P>
I have only one complaint about Turbo Professional. I never did figure out how to work the Menu Maker utility, and the documentation didn't help. That problem aside, for serious developers who work in Turbo Pascal 4.0, Turbo Professional is an outstanding productivity aid that will pay for itself many times over.<P>
by Kent Porter<P>
<h3><a name="00cb_0005">Brief<a name="00cb_0005"></h3><P>
<B>Product</B>: Brief Version 2.01<P>
<B>Target</B>: PC or PS/2 and compatibles<P>
<B>Requires</B>: DOS 2.0 or later; 192K minimum<P>
<B>Pricing</B>: $195<P>
<B>Vendor</B>: Solution Systems 541 Main St., Ste. 410 South Weymouth, MA 02190 (617) 337- 6963<P>
One might fairly describe Solution Systems' Brief as the quintessential programmer's editor. Unfortunately, that doesn't tell you much. So maybe I'd better tell you why I think it's so terrific.<P>
To begin with, it's chock full of the features that programmers routinely require. And in the event that you find it wanting in a specific function or feature, Brief has its own C-like language for writing macros or otherwise tailoring it to your requirements.<P>
Although Brief isn't copy protected, it's necessary to run an installation program to configure it. There are scads of options: colors, cursor shapes, tab settings, 25- versus 43- versus 50-line mode, backup files, and what not. This process uncovers some intriguing features. For example, you can set up Brief to save your work automatically every so many seconds or minutes, thus minimizing the impact of a power failure. For another, you can establish different parameters for each language you use.<P>
Brief does all the usual editing things: line insert/delete, search and replace, block move/copy, etc. Most editing commands are accomplished by ALT-key sequences.<P>
Brief gives you plenty of room to work in; maximum size of a text buffer is 32 Mbyte (DOS limit), with the maximum number of buffers limited only by available RAM. Macro size is also plentiful with a 32K limit and the maximum number of macros limited by available RAM.<P>
A particularly nice feature is the Undo command, ALT-U. Since Brief maintains an internal change stack, by default, this stack keeps track of the most recent 30 changes. And if you wish, you can increase it as high as 300. So, if you find that some program modification is headed down the primrose path, just start hitting ALT-U to back out the changes you've made. Brief &quot;undoes&quot; them in LIFO order.<P>
The real stuff of Brief is its multifile and windowing capabilities. The program comes up in full-screen edit mode, where one file owns the entire screen. You can load any number of files and move among them either in carousel fashion or via direct jumps using ALT commands, with each in full-screen mode. Alternatively, you can split the screen into resizable tiled windows and put a different file in each one, or different parts of the same file in two or more windows. If several windows contain the same source code, a change in one immediately appears in all.<P>
The import of this is that if two modules are related, you can look at both on the same screen, jumping between to reconcile their differences. Or, in a single program, you can display a structure definition in one window while you write its initialization code in another, which displays a different part of the file. In a complex application, this feature alone can save an astronomical amount of time simply by eliminating the need to save and load files, scroll around, and print listings that will immediately become out of date.<P>
Also, Briefs cut-and-paste and copy operations span multiple buffers using a clipboard concept. This lets you take a function out of PROG1 and insert it into PROG2 with half a dozen keystrokes.<P>
On the negative side, moving among windows is awkward. You press the F1 key, then a cursor arrow indicating which direction you want to go. You have to repeat this in every window you pass through between origin and destination. It would have been better if they'd numbered the windows so you could do F1-window number.<P>
Brief lets you set up and select language-specific environments. For example, indentation conventions are different for Assembler than for block-structured languages such as Pascal, C, and Modula-2, as is case sensitivity (Pascal and Assembler aren't, C and Modula arel. The default filename extensions also differ. The setup program builds parameter sets for each language. In it you can also specify the compiler command line, enabling you to invoke the compiler from within Brief. This effects a Turbo/Quick-style &quot;environment,&quot; although of course there isn't the same degree of interaction between editor and compiler that characterize true integrated environments. Still, it saves time when you don't have to drop out of the editor to compile, then reenter it to fix errors.<P>
I use Brief a lot, and aside from the window-changing problem mentioned earlier, there's only one thing about it that really annoys me. That is that you can't use the gray asterisk to type the multiplication symbol; you must use Shift-8. Brief regards the gray asterisk as a synonym for ALT-U (Undo). I should probably reconfigure the keyboard, which Brief lets you do, but I haven't gotten around to it.<P>
Brief comes on two floppies and with two spiral-bound manuals in a slipcase: a 161-page editor reference and a 195-page macro language guide. Both contain comprehensive tutorials written in English. The 36 page editor tutorial gets you productive with this excellent programmer's tool in about an hour.<P>
Like I said, it's terrific.<P>
by Kent Porter<P>
<h3><a name="00cb_0006">Guidelines C ++<a name="00cb_0006"></h3><P>
<B>Product</B>: Guidelines C ++, Version 1.2<P>
<B>Target</B>: PC and compatibles<P>
<B>Requires</B>: DOS 2.1 or later; 800K of hard disk space; 640K of RAM; and Microsoft C Version 3.0 or later<P>
<B>Pricing</B>: $295; owners of previous versions $25<P>
<B>Vendor</B>: Guidelines, P.O. Boa 749, DDJR Orinda, CA 94563 (415) 254-9393 or (415) 254-9183<P>
If you've been programming in C or a while, enjoyed structures and pointers to functions, and realized that there is something someone could do to structure the programming even more, you've likely already postulated a language like C++. C++ is still fairly new (sort of like C was in 1987), not terribly popular (yet), and extremely powerful.<P>
C ++ is an object-oriented language, which means, in short, that more emphasis is placed on the design of objects and object manipulators than on functions and procedures. Like C, C++ was developed by AT&amp;T. Version 1.2 is their third release following Version 1.0 and 1.1. Guidelines' C ++ for MS-DOS Version 1.2 is ported from the AT&amp;T release of the same number.<P>
It's important to note that the C ++ translator is not a compiler, but rather works in conjunction with one. A C ++ program is first preprocessed, then translated to C, then compiled by a C compiler. C ++ is, though not strictly, a superset of C and most C programs will flow through the preprocessor and translator unchanged. In fact, some of the extensions to C that the ANSI committee has adopted were introduced in C++.<P>
I found this package easy to install and flexible enough to deal with such things as alternate drives and directories than those recommended. I would have liked the option to install the package in the same directories as the C compiler it worked with, but it's easy to rearrange the directories later.<P>
Several subdirectories are created within the main program directory. The LIB directory holds the libraries, one each for the five standard memory models. The INCLUDE directory contains all of the AT&amp;T supplied headers, modified only enough to avoid conflict with the Microsoft headers. The SZAL directory holds information for each memory model about the size and alignment of different sized objects, none of which you should ever need worry about. The SCR directory contains a directory for each of the chapters in the Stroustmp book, plus the source code for a batch file builder. The DOC directory contains documentation on the C ++ preprocessor and the C ++ translator, as well as a copy of the tutorial chapter of the manual.<P>
The last directory created is the BIN directory which contains the .EXE files for the C ++ preprocessor and translator, as well as the batch file builder. Also in the BIN are 24 batch files (built with batch file builder) that take .CPP files to .CI (preprocessing done), to .CC (translator output), to .OBJ (compilation complete), or to .EXE for each of the five memory models plus a default.<P>
Batch files are provided to allow the translator more working memory. Of course, MAKE could be used to invoke all of the appropriate programs individually, but more memory is absorbed by the MAKE utility than by the built-in batch file processor.<P>
The Bjarne Stroustrup book, The C++ Programming Language, is included but may be omitted to save $10. The AT&amp;T release notes are also provided which document differences between C and C++ as well as the differences between 1.0, 1.1, and 1.2 of C ++. An installation guide and tutorial (really a series of examples) round out the documentation.<P>
Free support is by mail only, unless you pay $50 per year to have access to telephone technical support. I'd prefer that they allowed some sort of phone access for a short period after acquisition (NOT registration). On the other hand, $50 doesn't seem unreasonable, and in the worst case, you can think of the price of the package as $345 and purchase the first year at the same time as the package.<P>
Finally, from my contact with them, Guidelines seemed like reasonable people and I suspect that they would allow some simple questions to be answered without charge. At least they answered the questions I had during installation. I found few glitches in the package, none serious, just annoying. I liked the fact that all of the chapter directories included a makefile, however, the makefile .SUFFIXES command was not quite complete lacking the .EXE extension. This &quot;bug&quot; has been reported and will likely be fixed long before you get yours. Overall, I liked the package, and given sufficient free time to learn yet another language, I'll use it regularly.<P>
by Richard Relph<P>
For example, I prepared the minimal dynalink module shown in <a href="8804d.htm#00cb_0007">Example One</A>, and compiled it with IBM C/2 using the options -c -Gs --ALu which, literally translated, mean compile only, no stack checks, large model with no dependency on AS. Then I tried to link the object module with the definition file<P>
<pre>     LIBRARY APROC      EXPORTS aproc</pre><P>
which requests linking a dynamic link library. The link reported an unresolved external of __acrtused, which I recognized as an entry point into the C setup routines. When I supplied the C runtime library, the link pulled in all of the C setup code and generated an unresolved extern for __main! I circumvented this by adding the line<P>
<pre>     void __acrtused(){}</pre><P>
to my module. This satisfied the external reference, and in fact the generated code did not actually call the dummy __acrtused function.<P>
<h4><a name="00cb_0007"><a name="00cb_0007"><B>Example </B>1</h4><P>
<pre>
     int far parcel aproc(char far *argl)
     {
     char locv[8];
               locv[2] = *argl;
               return(locv[2]);
     }
</pre><P>
<P>
Thus finagled, the module did link and would have worked as a dynamic link package. But when I changed it to use a floating point number, as shown in <a href="8804d.htm#00cb_0008">Example Two</A>, the link failed with many unresolved externs in the float libraries. These float routines are known not to be reentrant, so they can't be used in dynamic link code. Neither can the C library routines for file I/O.<P>
<h4><a name="00cb_0008"><a name="00cb_0008"><B>Example 2</B></h4><P>
<pre>
     void __arctused(){}
     static double bignum = 0.0;
     int far pascal aproc (char far *argl)
     {
               bignum += * argl;
               return(bignum);
     }

</pre><P>
<P>
In short, it is possible to build dynamic link packages using the official OS/2 C compilers. You have to know the ins and outs of the compiler very well, restrict the code to integer arithmetic, and do all I/O by way of calls on OS/2 system functions instead of the C library (this last is no great hardship, as the OS/2 system functions are quite complete). With other languages and compilers, good luck!<P>

<P>
<P>
</pre></BODY></HTML>
