<html><head><title>Sep01: The Delphi XML  SAX2 Component &  MSXML 3.0</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>The Delphi XML  SAX2 Component &amp;  MSXML 3.0</h1><p><i>Dr. Dobb's Journal</i> September 2001</p><h2>Using the parser's C++ COM interfaces</h2><h3>By Danny Heijl</h3><I>Danny is a systems programmer at Cevi NV. He can be contacted at <a href="mailto:danny.heijl@andora.be">danny.heijl@andora.be.</a></I><hr><a name="rs1"><a href="0109ds1.htm">An Expat TSAXParser Implementation</a><hr><p>SAX parsers are designed for speedy processing of large XML documents, but with minimal memory use because they use a callback function technique. In this article, I show how to use the C++ COM interfaces of Microsoft's MSXML 3.0 SAX2 parser (<a href="http://msdn.microsoft.com/xml/general/xmlparser.asp">http://msdn.microsoft.com/xml/general/xmlparser.asp</a>) with Borland Delphi (<a href="http://community.borland.com/delphi/">http://community.borland.com/delphi/</a>). I also present <i>TSAXParser</i>, a Delphi component that uses these interfaces, but shields you from their complexities without sacrificing speed or functionality. All it takes to parse an XML file using <i>TSAXParser</i> is a mouse click to drop the component on a form, select a few event handlers in the object inspector, and then call the <i>Parse </i>method. The complete source code for this component (along with a demo application) is available electronically; see "Resource Center," page 5. For background information on SAX parsers in general, and the MSXML 3.0 SAX2 parser in particular, see "Parsing XML," by David Cox (<i>DDJ</i>, January 2001) and "Programmer's Toolchest," by Eldar Musayev (<i>DDJ</i>, February 2001).</p><p>For speed and simplicity, I decided to use the MSXML's native C++ COM interfaces, not the Visual Basic IVBSAX wrappers. Microsoft provided the IVBSAX wrappers in MSXML 3.0 to support Visual Basic and other COM-enabled languages that can't handle the C++ COM interfaces and data types. I will explain how you can implement and use these C++ COM interfaces with Borland Delphi. You can implement these C++ COM interfaces as normal classes; you don't need full-featured COM objects.</p><DDJADVERTISEMENT INLINE><h3>Importing the MSXML Type Library</h3><p>Before using MSXML3.DLL in Delphi, you have to import its type library (Microsoft XML 3.0). This generates an Object Pascal source (MSXML 2_TLB.pas) that gives the Delphi IDE and compiler access to the COM objects and interfaces inside the DLL.</p><p>A key difference between the DOM parser in MSXML and the SAX2 parser is that the SAX parser exposes COM interfaces that have no corresponding implementation in MSXML3.DLL. You have to implement these COM interfaces instead of instantiating and using existing COM objects. You then pass a reference to your implementation to the parser, so that it can callback the functions you implemented at the appropriate moment in the parsing process. </p><h3>Importing the Type Library Wizard</h3><p>My decision to use the lightweight C++ ISAX interfaces that descend from <i>IUnknown</i> instead of the VB wrappers that descend from <i>IDispatch</i> immediately caused some trouble with the Delphi Import Type Library wizard. The wizard generates Pascal code based on the information present in the type library. While this works well for the <i>IDispatch</i>-type VB interfaces, it has problems with the data types of the C++ interfaces. <A NAME="re1"><A HREF="0109de1.htm">Example 1</A>(a) shows how a method argument of type <i>unsigned short </i>* in the type library, which corresponds to a <i>const wchar_t</i><i> </i>* in the MSXML 3.0 SDK, <A NAME="re1"><A HREF="0109de1.htm">Example 1</A>(b), is incorrectly converted to Word by the import wizard, <A NAME="re1"><A HREF="0109de1.htm">Example 1</A>(c). Either <i>pWord</i> or <i>pWideChar</i> would have been acceptable, since both represent pointers to a 16-bit word. I decided to edit MSXML2_TLB.PAS to make the argument definitions correspond closely to those in the SDK; see <A NAME="re1"><A HREF="0109de1.htm">Example 1</A>(d). This permits the use of the native Delphi data types and (wide) string functions. The modified file is included with the source code. </p><h3>Implementing the C++ COM Interfaces</h3><p>The abstract C++ interfaces in the SAX2 parser (abstract meaning that there is no corresponding implementation in MSXML3.DLL) derive from <i>IUnknown</i>. The workhorse SAX interface that has to be implemented is <i>ISAXContentHandler</i>, which handles most XML events. <A NAME="rl1"><A HREF="#l1">Listing One</A> is a (corrected) Object Pascal version of the <i>ISAXContentHandler</i> interface definition.</p><p>When all you need is a single in-process instance of the class, Delphi offers a straightforward way of implementing interfaces that derive from <i>IUnknown</i>. The <i>TInterfacedObject</i> class implements <i>IUnknown</i> and is designed to be used in these circumstances. <A NAME="re2"><A HREF="0109de2.htm">Example 2</A>(a) is a (partial) class definition for <i>ISAXContentHandler </i>using <i>TInterfacedObject</i>. All it takes to instantiate such a class is to call the <i>Create </i>class constructor, <A NAME="re2"><A HREF="0109de2.htm">Example 2</A>(b), without the hassle of COM class factories and globally unique identifiers. (The C++ examples in the MSXML SDK use the same approach.) The complete definition of a <i>TSAXContentHandler</i> class that implements the <i>ISAXContentHandler</i> interface as it is used in the <i>TSAXParser</i> component is available electronically; see Resource Center, page 5. </p><p>Once the class implementing the interface has been defined, all that remains to be done is provide an implementation for each method. It's important to realize that a class that implements an interface has to provide an implementation for all the methods defined in that interface, even if these implementations don't do anything at all. </p><h3>An Example Implementation </h3><p>In <A NAME="rl2"><A HREF="#l2">Listing Two</A>, which includes the <i>ContentHandler</i>'s <i>startElement()</i> function, the parameters passed to the function are pointer/size pairs to the namespace URI, the <i>localname</i>, the qualified name of the current element, and a pointer to an <i>ISAXAttribute</i> interface. The <i>ISAXAttribute </i>interface gives access to the attributes of this element. (This interface is implemented in MSXML2.DLL, so you don't have to provide an implementation for it.) </p><p>First of all, the function checks whether the application has set the <i>OnStartElement </i>event method. If not, the function immediately returns S_OK and parsing continues. If the event handler has been set, the first thing that happens is a call to the <i>GetLineColumn</i> procedure to retrieve the current line and column position in the XML document. This is done by the <i>ISAXLocator</i> interface, saved earlier when you called the <i>putDocumentLocator()</i> interface implementation. For performance reasons, the application can disable <i>GetLineColumn</i> by setting the <i>UpdateLocation</i> property to False. </p><p>Next, the <i>pWideChar</i> C++ COM-style parameters (<i>pURI, pName, pLocalName</i>) are converted to Delphi <i>AnsiStrings</i>, and the attributes are retrieved using the <i>getName()</i>, <i>getValue()</i>, and <i>getType()</i> methods of the <i>ISAXAttribute</i><i>'</i>s interface parameter. The properties of each attribute are stored in a <i>TSXPAttribute</i> object containing the name, value, and type of the attribute, and all attributes of this element are stored in a list (<i>TSXPAttributeList</i>, derived from <i>Tlist</i>) for easy access by the application. The <i>OnStartElement</i> event procedure of the application is then called with the converted arguments and the attribute list. If <i>OnStartElement</i> does not raise an exception, S_OK is returned and parsing continues; otherwise, <i>TSAXContentHandler.StartElement()</i> returns E_FAIL and you abort parsing.</p><h3>The <i>out</i> Parameters </h3><p>Contrary to normal COM memory allocation practices, you should not use <i>CoTaskMemFree()</i> to free the <i>out </i>parameter strings returned by functions such as <i>ISAXAttributes.getValue()</i>, with the exception of the <i>getProperty()</i> functions. Most of the time, the SAX2 functions in MSXML2.DLL do not allocate memory for passing a copy of the string parameters to the event handlers, but instead return a pointer and size pair pointing directly to the data in your input buffer. After all, SAX parsers should be fast. </p><h3>The <i>TSAXParser</i> Component</h3><p>After playing around with the MSXML SAX2 parser in Delphi, I found it tedious to write variations of the same code each time I wanted to test some other feature of the parser. I realized that it would be easier to have a native Delphi component that would:  </p><p></p><ul>  <li>Generate the event handlers needed with a simple mouse click in the object inspector.  <li>Let me completely ignore the event handlers I don't need.  <li>Give access to all (or at least most) events and properties of the <i>ISAXXMLReader, ISAXContentHandler, ISAXLexicalHandler, ISAXDTDHandler, ISAXDeclhandler, ISAXAttributes, ISAXLocator, </i>and <i>ISAXErrorHandler</i> interfaces from a single component.</ul><p>And all this preferably without having to deal with any COM stuff, of course. </p><p>This is what <i>TSAXParser</i> is designed to do. The way the component works is straightforward. The unit that contains <i>TSAXParser</i> also contains an implementation for the <i>ISAXContentHandler</i>, <i>ISAXLexicalHandler</i>, <i>ISAXDeclHandler</i>, <i>ISAXDTDHandler</i>, and <i>ISAXErrorHandler </i>interfaces. These classes are instantiated and "owned" by the <i>TSAXParser</i> component. The only purpose of the event handlers in these interface implementations is to convert the COM C++ data types to Pascal format, and to call the corresponding event methods of the application, if any, that have been set by means of <i>TSAXParser</i>. In terms of the "if any," you do not have to provide dummy implementations for the events that don't interest you! The parser-generated events are silently ignored if you didn't provide an event handler. The complete definition of the <i>TSAXParser</i> class is available electronically.</p><p>The constructor of <i>TSAXParser</i> creates an instance of the SAX2 reader, immediately followed by the creation of the five handler classes. These are handed over to the reader. <A NAME="re3"><A HREF="0109de3.htm">Example 3</A> is code for the constructor of <i>TSAXParser</i>.</p><p>A close look at the <i>TSAXParser</i> class definition reveals that the customary private fields you expect for storing the event method properties are missing. The property access methods in <A NAME="re4"><A HREF="0109de4.htm">Example 4</A> show why: The properties are not stored in <i>TSAXParser</i>, but directly in the handler classes created in the constructor. This way the address of any <i>TSAXParser</i> event handler created in the object inspector is immediately stored in the corresponding ISAX handler. All that is left for you to do is write code in the event handlers you decide to implement. </p><p>While <i>TSAXParser</i> controls access to the event method properties of the handler classes, these classes also maintain a couple of properties on behalf of the <i>TSAXParser</i> that owns them: Every handler can continually update the <i>Line</i> and <i>Column </i>properties before calling the corresponding Delphi event method. It uses the <i>ISAXLocator</i> interface that is made available by <i>ISAXContentHandler.PutDocumentLocator() </i>for this purpose. This gives a Delphi application using <i>TSAXParser</i> automatic access to the current line and column number in the document being parsed. </p><p>Because the <i>ISAXLocator getLine()/getColumn()</i> methods are slow, I disabled this feature by default. I found that retrieving line/column information for each event adds about 15 percent overhead to the parsing process. You can enable this automatic location update at any time (or in the Object Inspector if you wish) by setting the <i>UpdateLocation</i> property to True. Even if <i>UpdateLocation</i> is False, you can still request a snapshot update of the <i>Line/Column</i> properties by a call to the <i>GetLocation</i> procedure. </p><p><A NAME="rf1"><A HREF="0109df1.htm">Figure 1</A> shows the classic example file Bookshop.xml after parsing by a demo application (sxpdemo.dpr, available electronically). Each line shows the current line number in the xml file, an indentation representing the element nesting, the ISAX handler that caused the event (coded as <i>CH</i>, <i>DTDH</i>,<i> LexH</i>, or <i>DeclH</i>), and the formatted arguments as they were received by the event handler.   </p><h3>A Minimal Filter Application</h3><p><A NAME="rl3"><A HREF="#l3">Listing Three</A> is a complete filter application that scans the Bookshop XML example file for <i>&lt;book&gt;</i> elements with the attributes "<i>genre=fiction</i>" and "<i>in_stock=yes.</i>" If such an element is found, all elements found between the <i>&lt;book&gt;</i> and the next <i>&lt;/book&gt;</i> tag are shown in a memo field. </p><p>The application consists of a form with a <i>TSAXParser</i> component, <i>Tmemo</i> control, Boolean to preserve state information, and a few lines of code inside the <i>FormCreate</i>, the <i>SXPStartElement</i>, <i>SXPCharacters</i>, and <i>SXPEndElement</i> event handlers.<i></p><p>FormCreate</i> writes a title line to the memo and fires up the parser. <i>SXPStartElement</i> checks for a <i>&lt;book&gt;</i> tag; when it finds one, it checks the <i>genre </i>and <i>in_stock</i> attributes (note that <i>TSXPAttributes.GetItem()</i> is case insensitive). If <i>genre </i>and <i>in_stock</i> match the search condition, the state flag is set. <i>SXPEndElement</i> resets the flag when it finds a <i>&lt;/book&gt;</i> tag, and <i>SXPCharacters</i> dumps all elements to the memo while the state flag is set. It doesn't get any easier than that. <A NAME="rf2"><A HREF="0109df2.htm">Figure 2</A> shows the filter demo. </p><p>Install the <i>TSAXParser</i> component (found in MSSAXParser.pas) before you run the demo application. Installing <i>TSAXParser</i> also installs the DOM components in MSXML2_TLB.pas. MSAXParser.dcr and MSXML2_TLB.dcr contain icons for some of these components. <i>TSAXParser</i> shows up as the SXP icon in the XML tab on the component palette.</p><h3>Conclusion</h3><p>Using Delphi to implement the C++ COM interfaces of the Microsoft SAX2 parser lets you achieve maximum speed when parsing XML documents. The <i>TSAXParser</i> component presented here shields you from those COM interfaces, and makes using the MS SAX2 parser a trivial exercise. The work that <i>TSAXParser</i> does behind the scenes on your behalf comes at a price: You lose some of the flexibility you get when using the COM interfaces directly, and there is a small speed penalty (but <i>TSAXParser</i> still beats an equivalent VB application). The ease of use makes such a component an attractive proposition. And you can always fall back on the bare COM interfaces when speed is important.</p><p></p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>// *********************************************************************//// Interface: ISAXContentHandler// Flags:     (16) Hidden// GUID:      {1545CDFA-9E4E-4497-A8A4-2BF7D0112C44}// *********************************************************************//ISAXContentHandler = interface(IUnknown)['{1545CDFA-9E4E-4497-A8A4-2BF7D0112C44}']function  putDocumentLocator(          const pLocator: ISAXLocator): HResult; stdcall;function  startDocument: HResult; stdcall;function  endDocument: HResult; stdcall;function  startPrefixMapping(          const pwchPrefix: pWideChar;          cchPrefix: SYSINT;          const pwchUri: pWideChar;          cchUri: SYSINT): HResult; stdcall;function  endPrefixMapping(          const pwchPrefix: pWideChar;          cchPrefix: SYSINT): HResult; stdcall;function  startElement(          const pwchNamespaceUri: pWideChar;          cchNamespaceUri: SYSINT;          const pwchLocalName: pWideChar;          cchLocalName: SYSINT;          const pwchQName: pWideChar;          cchQName: SYSINT;          const pAttributes: ISAXAttributes): HResult; stdcall;function  endElement(          const pwchNamespaceUri: pWideChar;          cchNamespaceUri: SYSINT;          const pwchLocalName: pWideChar;          cchLocalName: SYSINT;          const pwchQName: pWideChar;          cchQName: SYSINT): HResult; stdcall;function  characters(          const pwchChars: pWideChar;          cchChars: SYSINT): HResult; stdcall;function  ignorableWhitespace(          const pwchChars: pWideChar;          cchChars: SYSINT): HResult; stdcall;function  processingInstruction(          const pwchTarget: pWideChar;          cchTarget: SYSINT;          const pwchData: pWideChar;          cchData: SYSINT): HResult; stdcall;function  skippedEntity(          const pwchName: pWideChar;          cchName: SYSINT): HResult; stdcall;end;</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>// ISAXContentHandler.StartElement callback functionfunction  TSAXContenthandler.startElement(                         const pwchNamespaceUri: pWideChar;                         cchNamespaceUri: SYSINT;                         const pwchLocalName: pWideChar;                         cchLocalName: SYSINT;                         const pwchQName: pWideChar;                         cchQName: SYSINT;                         const pAttributes: ISAXAttributes): HResult; stdcall;var  strNamespaceURI: string;  strLocalName: string;  strQName: string;  Attribute: TSXPAttribute;  i: integer;  nAttributes : integer;  pURI, pLocalName, pQname, pValue, pType: pWideChar;  URIsize, Localsize, Qsize, Typesize, size: integer;begin  if Assigned(FOnStartElement) then begin    GetLineColumn;    // convert element name and URI to string    try      if pwchNamespaceUri &lt;&gt; Nil then       strNamespaceURI :=WideCharLenToString(pwchNamespaceUri,cchNamespaceUri)      else        strNamespaceURI := '';      if pwchLocalName &lt;&gt; Nil then        strLocalName := WideCharLenToString(pwchLocalName, cchLocalName)      else        strLocalName := '';      if pwchQName &lt;&gt; Nil then        strQName := WideCharLenToString(pwchQName, cchQName)      else        strQName := '';      // build the attribute list      try        if pAttributes &lt;&gt; Nil then begin          with pAttributes do begin            getLength(nAttributes);            FAttributeList.Capacity := nAttributes;            for i := 0 to nAttributes - 1 do begin              getName(i, pURI, URIsize, pLocalName, Localsize, pQName, Qsize);              getValue(i, pValue, size);              getType(i, pType, Typesize);              Attribute := TSXPAttribute.Create;              with Attribute do begin                URI       := WideCharLenToString(pURI, URIsize);                LocalName := WideCharLenToString(pLocalName, Localsize);                QName     := WideCharLenToString(pQName, Qsize);                Value     := WideCharLenToString(pValue, size);                AttType   := WideCharLenToString(pType, Typesize);              end;              FAttributeList.Add(Attribute);            end; // for          end; // with        end; // if pAttributes &lt;&gt; Nil        // now call the application event handler        FOnStartElement(strNamespaceUri,strLocalName,strQName,FAttributeList);      finally        // clean up the attributes list        for i := 0 to FAttributeList.Count - 1 do begin          TSXPAttribute(FAttributeList.Items[i]).Free;        end;        FAttributeList.Clear;      end;      Result := S_OK;    except      Result := E_Fail;    end;  end else begin    Result := S_OK;  end;end;</pre><P><A HREF="#rl2">Back to Article</A></P><H4><A NAME="l3">Listing Three</H4><pre>unit filterform;interfaceuses  Windows, Messages, SysUtils, Classes, Graphics, Controls, Forms,  Dialogs, StdCtrls, MSSAXParser;type  TfrmFilter = class(TForm)    SXP: TSAXParser;    Memo1: TMemo;    procedure SXPStartElement(const NamespaceURI, Localname,      QName: String; const Attributes: TSXPAttributeList);    procedure SXPEndElement(const NamespaceURI, Localname,      QName: String);    procedure SXPCharacters(const Chars: String);    procedure FormCreate(Sender: TObject);  private    { Private declarations }  public    { Public declarations }    bWanted: boolean;    strElement: string;  end;var  frmFilter: TfrmFilter;implementation{$R *.DFM}procedure TfrmFilter.SXPStartElement(const NamespaceURI, Localname,  QName: String; const Attributes: TSXPAttributeList);var  attr: TSXPAttribute;begin  if bWanted then begin    strElement := LocalName;    exit;  end;  if CompareText(Localname, 'book') &lt;&gt; 0 then exit;  if not Assigned (Attributes) then exit;  attr := Attributes.GetItem('genre');  if (attr = Nil) or (CompareText(attr.Value, 'fiction') &lt;&gt; 0) then exit;  attr := Attributes.GetItem('in_stock');  if (attr = Nil) or (CompareText(attr.Value, 'yes') &lt;&gt; 0) then exit;  bWanted := true;end;procedure TfrmFilter.SXPEndElement(const NamespaceURI, Localname,  QName: String);begin  if CompareText(LocalName, 'book') = 0 then begin    if bWanted then      Memo1.Lines.Add('--------------------------------------------');    bWanted := false;  end;end;procedure TfrmFilter.SXPCharacters(const Chars: String);begin  if bWanted then    if Trim(Chars) &lt;&gt; '' then      Memo1.Lines.Add(Format('%-20s %s', [strElement, Chars]));end;procedure TfrmFilter.FormCreate(Sender: TObject);begin  Memo1.Lines.Add('Fiction books currently in stock :');  Memo1.Lines.Add('==================================');  SXP.Parse;end;end.</pre><P><A HREF="#rl3">Back to Article</A></P></body></html>