<html><head><title>Sep01: A Portable Distributed Event-Logging Facility</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>A Portable Distributed Event-Logging Facility</h1><p><i>Dr. Dobb's Journal</i> September 2001</p><h2>Monitoring the state of applications</h2><h3>By Ivan Kiselev</h3><I>Ivan is a founding partner of APP Design Group Inc. He can be contacted at <a href="mailto:ikk@appdg.com">ikk@appdg.com.</a></I><hr><p>Every enterprise scale application needs an event-logging facility that can be used in design, development, and deployment. Why? Well, for one thing, each application component &#151; a user-interface program, batch job, mid-tier service, or whatever &#151; generates various log messages (or, more generally, run-time events). These events need to be recorded to monitor the state of the application or for postmortem analysis. However, application events are not generated equal and have to be dispatched according to their types.</p><p>There are several extreme solutions to the problem. For instance, at a low level, there are OS or network facilities such as UNIX's syslog, NT's event log, and SNMP-based services that are not readily available for applications and, usually, are considered to be a domain of hard-core system administrators. At a higher level, however, there are numerous language-specific logging toolkits. For instance, the most widely known for Java are JLog (<a href="http://www.alphaworks.ibm.com/">http://www.alphaworks.ibm.com/</a>) and log4j (<a href="http://jakarta.apache.org/">http://jakarta.apache.org/</a>) that are not designed for use with other languages, which is especially limiting in a distributed enterprise environment. In the midrange, the OMG Notification Service Specification (see "Notification Service Specification, Version 1.0," <a href="http://www.omg.org/">http://www.omg.org/</a>) possesses all the traits of the architecture designed by a committee &#151; being very complete, it is not that suitable for anything budget conscious and/or time constrained. (Does it sound familiar?)</p><DDJADVERTISEMENT INLINE><p>In this article, I present a distributed portable event-logging facility that is simple, flexible, relatively platform independent, and available to applications written in several languages (including scripts). <A NAME="rl1"><A HREF="#l1">Listings One</A> through <A NAME="rl8"><A HREF="#l8">Eight</A>, which implement the logger, were extracted from my company's APPAnvil toolkit (<a href="http://www.appdesigngroup.com/">http://www.appdesigngroup.com/</a>) and were significantly simplified for presentation purposes. I've tested the examples on Windows NT 4.0 SP6 using JDK 1.3, VisiBroker for Java Version 4.0, and Perl Version 5.005_03 from ActiveState, Build 522. The complete source code and related files (including make and IDL files) are available electronically; see "Resource Center," page 5. </p><p>This general-purpose event-logging facility has three major parts:</p><ul>  <li>Event production.   <li>Event transportation to the log service.   <li>Event dispatch (storage, alerts, displaying, and so on).</ul><p>As is often the case in the distributed world, the appropriate place to start a design is not the beginning (event production) nor the end (event dispatch), but the middle (transportation). </p><p>I settled on CORBA as the transport method because CORBA implementations are available on many hardware and operating-system platforms, it can be directly accessed from Java and C++, and CORBA implementations usually take care of low-level networking (connection maintenance, redundancy, fail over capabilities, and so on). </p><p>The simplified event-logging interface in <A NAME="re1"><A HREF="0109be1.htm">Example 1</A> contains a minimally usable amount of information about a remote event, namely:</p><ul>  <li>A name of the machine that generated the event.  <li>An event type.  <li>Event source, usually a place in a program from which an event originated (for example, an application name combined with a class name and a method name).  <li>A human-readable text message.</ul><p>Having an event type as a string instead of an enumeration provides flexibility for managing the event set without changing the interface. For example, event types can be added or removed and nothing has to be recompiled. (For the sake of brevity, I omit many implementation details throughout the article. These details are mostly about proper initialization, error handling, configuration, usability, and resilience.) </p><p><A NAME="rf1"><A HREF="0109bf1.htm">Figure 1</A> presents the general architecture of this facility. The core of it is the <i>EventLogService </i>that implements the <i>EventLog</i> interface and provides actual event logging.</p><h3>Client Side</h3><p>Accessing the interface in <A NAME="re1"><A HREF="0109be1.htm">Example 1</A> is straightforward from any language that has direct CORBA mapping (Java or C++, for instance). Consider a Java implementation. First of all, it would be extremely inconvenient if an application needed to make a CORBA connection every time an event needed to be logged. It would not only tax performance, but lead to code bloat. Second, it pays to integrate event logging into the exception class hierarchy; then everything thrown is logged automatically. These considerations lead to the implementation in <A NAME="rl1"><A HREF="#l1">Listing One</A>, which is a wrapper class that maintains a static connection to the Event-Log service. <A NAME="rl2"><A HREF="#l2">Listing Two</A> is an example of how you might use the interface. Events can be logged either by calling a static <i>Log.log()</i> method or by throwing a <i>Log</i> exception (or its heirs). The <i>Log()</i> and <i>Log(String)</i> constructors provide the full compatibility with the <i>Exception</i> class when no logging is required by the derived classes. </p><p>Event logging becomes more interesting for languages that do not have direct CORBA interfaces. There are two possibilities:</p><ul>  <li>Build a bridge between a programming environment, which is not CORBA compliant, and a C++ or Java program using whatever appropriate method for each combination.  <li>Come up with some general bridge that will handle most of the cases and provide a somewhat less elegant solution for the environments not supported by this bridge.</ul><p>Since the second approach would seem more economical, I'll consider it first. This general-purpose bridge translates some proprietary event protocol into CORBA calls. The simplest approach is to select a protocol that can be implemented by most programming languages and implement a bridge just for it. On the network level, the UDP looks particularly suitable &#151; it is easy, fast, and widely available for most modern programming environments. On the application level, delimited ASCII string suffices for our purposes. <A NAME="rl3"><A HREF="#l3">Listing Three</A> is the implementation of the UDP bridge, which starts as a service that listens for a well-known UDP port. As soon as an event message is received, it is parsed and resubmitted to the <i>EventLog</i> via a regular CORBA interface.</p><p><A NAME="rl4"><A HREF="#l4">Listing Four</A> includes an example of the Perl module that is a client to the UDP bridge. This module, in effect, is an interface to the <i>EventLog</i> for any Perl script.</p><p>The last resort for a programming environment that cannot support even UDP (Windows NT batch files, for instance) is a command-line utility that can. In this case, a batch script executes a command-line utility that sends a UDP message, and the message, in turn, is translated to the CORBA call by the UDP bridge application. <A NAME="rl5"><A HREF="#l5">Listing Five</A> provides an example of such utility, this one written in Perl (since there already is the client interface for Perl). The obvious question is: Why not write a command-line program that will make CORBA calls directly? You can, but it takes much longer to initialize and connect the ORB than to send a UDP message.</p><h3>Server Side</h3><p>The <i>EventLogService</i> is implemented in Java; see <A NAME="rl6"><A HREF="#l6">Listing Six</A>. Leaving C++ versus Java flames aside, there is one Java feature that makes it a top choice for this job &#151; run-time typing that allows, in this situation, for flexible event dispatch (portability is another positive factor). By default, <A NAME="rl6"><A HREF="#l6">Listing Six</A> dumps all the messages it receives into a text file unless there is a custom event handler. All event handlers should implement the <i>LogCapable</i> interface given in <A NAME="rl7"><A HREF="#l7">Listing Seven</A>. </p><p>On start-up, the service receives a list of event types and their respective handlers. For example:</p><blockquote><p>java EventLogService DISCARD=BlackHole 		      [TYPE=HandlerClass]</p></blockquote><p>where DISCARD is an event type that will be processed by the handler class <i>BlackHole</i>, which simply ignores everything it receives; see <A NAME="rl8"><A HREF="#l8">Listing Eight</A>. These handler classes get instantiated and loaded into the dispatch table. At run time, the handlers are invoked according to the event types. An unlimited number of event handlers may be created: from a simple e-mail sender to the SNMP trap generator.</p><h3>Conclusion</h3><p>The <i>EventLogService</i> facility I've presented here combines several techniques to achieve programming language independence, portability, and flexible event routing. The solution is CORBA based but, in addition to IDL mappings, its language support is extended by the UDP bridge and the companion command-line utility. The portability is provided by the tool selection: The server side of the facility will run anywhere where Java and CORBA are supported and the minimal requirement for a client is to be able to send a UDP message. The run-time features of Java help a lot in a flexible dispatch; a similar functionality would have been a lot quirkier in a strongly typed language.</p><h3>Acknowledgment</h3><p>Thanks to Alexander Galyaev and Xiaotie Shen who greatly contributed to the development of the concepts discussed in this article.</p><p></p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>public class Log extends Exception{  private static EventLog remoteLog = null; // Stub for remote service  private static String hostName = ""; // How this machine is called  static  {    try    {      hostName = java.net.InetAddress.getLocalHost().getHostName();    }    catch(java.net.UnknownHostException e){}  }  public Log() { super(); }  public Log(String message) { super(message); }  public Log(String eventSource, String messageType, String message)  {    super(message);    Log.log(eventSource, messageType, message);  }  // Actually logs an event.  public static void log(String eventSource, String messageType,                                                     String aMessage)  {    if( null == remoteLog )    {      org.omg.CORBA.ORB orb = org.omg.CORBA.ORB.init(new String[0], null);      remoteLog = EventLogHelper.bind(orb);    }    try    {      synchronized(remoteLog)      {        remoteLog.log(hostName, messageType, eventSource, aMessage);      }    }    catch(Throwable e) {}  }}</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>public class TestEventLogService{  public static void main(String args[])  {    try    {      // Just log some stuff as we go ...      Log.log("main", "UNKNOWN", "Message of unknown type");      Log.log("main", "DISCARD", "Message to be discarded");      // Or throw it as an exception      throw new Log("main", "ERROR", "Error message");    }    catch(Exception e) {}  }}</pre><P><A HREF="#rl2">Back to Article</A></P><H4><A NAME="l3">Listing Three</H4><pre>import java.util.*;import java.net.*;public class UDPBridge{  public static final int PORT=16500;  public static final String DOMAIN="ALL-SYSTEMS.MCAST.NET";  public static final String DELIMITER="|";  private static byte[] buf = new byte[65509];  static public void main(String[] args)   {    try    {      // Create a UDP socket      MulticastSocket ms = new MulticastSocket(PORT);      ms.joinGroup(InetAddress.getByName(DOMAIN));      // Initialize CORBA connection      org.omg.CORBA.ORB orb = org.omg.CORBA.ORB.init(new String[0], null);      EventLog remoteLog = EventLogHelper.bind(orb);      while(true)       {        // Receive the message        DatagramPacket dp = new DatagramPacket(buf, buf.length);        ms.receive(dp);        // Parse the event        String s = new String(dp.getData(), 0, 0, dp.getLength());        StringTokenizer t = new StringTokenizer(s, DELIMITER);        // Send the event message to the Event Log Service        String remoteHost = dp.getAddress().getHostName();        remoteLog.log(remoteHost,           t.nextToken(), t.nextToken(), t.nextToken());      }    }    catch(Exception e) {}  }}</pre><P><A HREF="#rl3">Back to Article</A></P><H4><A NAME="l4">Listing Four</H4><pre>package Log;use Socket;use Sys::Hostname;my($iaddr, $proto, $paddr, $host, $port);$port = 16500;$host = "ALL-SYSTEMS.MCAST.NET";$iaddr = gethostbyname($host);$proto = getprotobyname('udp');$paddr = sockaddr_in($port, $iaddr);socket(SOCKET,PF_INET, SOCK_DGRAM, $proto) or die "Socket: $!";connect(SOCKET, $paddr) or die "Connect: $!";sub log{  defined(send(SOCKET, join('|', @_), 0)) or die "Send: $!";}1;</pre><P><A HREF="#rl4">Back to Article</A></P><H4><A NAME="l5">Listing Five</H4><pre>use Log;Log::log($ARGV[0], $ARGV[1], $ARGV[2]);</pre><P><A HREF="#rl5">Back to Article</A></P><H4><A NAME="l6">Listing Six</H4><pre>import java.io.*;import java.util.*;import java.text.*;public class EventLogService extends _EventLogImplBase{  private static PrintWriter out = null;  private static DateFormat dateFormat =       new SimpleDateFormat("yyyy-MM-dd-HH-mm-ss");  private static Hashtable dispatcher = new Hashtable();  public synchronized void log(String aHost,       String aType, String aSource, String aMessage)  {    try    {      // Dispatch according to the type      LogCapable handler = (LogCapable) dispatcher.get(aType);      if( null != handler )      {        handler.log(aHost, aType, aSource, aMessage);        return;      }      // Write the log string to the log file      // for all types without custom handlers       out.println(aHost+"|"+ dateFormat.format(new Date())+             "|"+aSource+"|"+aType+"|"+aMessage);    }    catch(Exception e) {}  }  public EventLogService(String name) {super(name);}  // This method will start the event log service.  public static void main(String[] args)  {    try    {      // Create the type dispatch table      for(int i=0; i&lt;args.length; i++)      {        String typeName = args[i].substring(0, args[i].indexOf('='));        String className = args[i].substring(args[i].indexOf('=')+1);        LogCapable handler = (LogCapable)           Class.forName(className).newInstance();        dispatcher.put(typeName, handler);      }      // Initialize the ORB.      org.omg.CORBA.ORB orb = org.omg.CORBA.ORB.init(args, null);      // Create the service object.      EventLogService service = new EventLogService("log");      // Open the log file      out = new PrintWriter(new BufferedWriter(               new FileWriter("logfile.log")), true);      // Initialize the BOA.      com.inprise.vbroker.CORBA.BOA boa =         ((com.inprise.vbroker.CORBA.ORB)orb).BOA_init();      boa.obj_is_ready(service);      // Wait for incoming requests      boa.impl_is_ready();    }    catch(Throwable e) {}  }}</pre><P><A HREF="#rl6">Back to Article</A></P><H4><A NAME="l7">Listing Seven</H4><pre>public interface LogCapable{  public void log(String aHost, String aType, String aSource,                                                     String aMessage);}</pre><P><A HREF="#rl7">Back to Article</A></P><H4><A NAME="l8">Listing Eight</H4><pre>public class BlackHole implements LogCapable{  public synchronized void log(String aHost,            String aType, String aSource, String aMessage)  {    // Nothing!  }}</pre><P><A HREF="#rl8">Back to Article</A></P></body></html>