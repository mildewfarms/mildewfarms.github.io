<html><head><title>Sep01: SOAP:  Simplifying  Distributed Development</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>SOAP:  Simplifying  Distributed Development</h1><p><i>Dr. Dobb's Journal</i> September 2001</p><h2>Putting the Simple Object Access  Protocol to work</h2><h3>By Neil Gunton</h3><I>Neil is a web site developer who can be contacted at <a href="mailto:neil@nilspace.com">neil@nilspace.com.</a></I><hr><p>I was developing a noncommercial community web site (<a href="http://www.crazyguyonabike.com/">http://www.crazyguyonabike.com/</a>) using Embperl (<a href="http://perl.apache.org/embperl/">http://perl.apache.org/embperl/</a>), which works on top of mod_perl and Apache. In the process, I decided to add a spellchecker for the message boards and journals people were writing. Since I wanted to stay in the open-source arena, I settled on a Perl Lingua::Ispell module (<a href="http://www.redhat.com/swr/i386/perl-Lingua-Ispell-0.05-6.i386.html">http://www.redhat.com/swr/i386/perl-Lingua-Ispell-0.05-6.i386.html</a>), which encapsulates the ispell (or aspell) program. Lingua::Ispell works by spawning the ispell process once, then using pipes to feed it input. This is nice because it uses an external process, but doesn't need to launch that process for every call.</p><p>However, I found I could not practically use Lingua::Ispell directly from my Embperl pages because of an obscure problem related to how mod_perl/apache handles the spawning of subprocesses (see <a href="http://perl.apache.org/guide/performance.html#Forking_and_Executing_Subprocess">http://perl.apache.org/guide/performance.html#Forking_and_Executing_Subprocess</a>). I found that zombie subprocesses were being left for every call I made, and Lingua::Ispell was having to restart ispell every time, which is not how things are supposed to work in production systems. And even if it did work, every copy of Apache would be launching its own ispell subprocess, which seemed inefficient.</p><DDJADVERTISEMENT INLINE><p>Consequently, I decided to write a spelling server that would remain persistent and accept connections from my Embperl scripts. Traditionally, the lowest common denominator for writing servers and daemons is sockets and IPC. However, I wanted to avoid this since it can get tricky, and I wanted to use one of the higher level libraries that have been developed. One option was CORBA, but it has always been a pain because of its complexity. That's when I turned to SOAP.</p><h3>A Brief Overview of SOAP</h3><p>The Simple Object Access Protocol (SOAP), currently in Version 1.2, was developed as an open RPC protocol using XML, targeting much the same problem set as CORBA, DCOM, and Java RMI. SOAP has been picked up by the World Wide Web consortium's XP (XML Protocol) project (<a href="http://www.w3.org/TR/2001/WD-soap12-20010709/">http://www.w3.org/TR/2001/WD-soap12-20010709/</a>) and, perhaps most visibly, Microsoft .NET has adopted it as its central RPC standard. For the time being, SOAP remains an independent, open standard. Even if Microsoft tries to "embrace and extend" the protocol, a core set of functionality will likely work between any SOAP client and server. A superset of Microsoft-specific stuff will be necessary to interact fully with Microsoft products, but not essential for the basic RPC that SOAP is designed for.</p><p>One advantage of SOAP is that it works over existing protocols, such as HTTP. One of the biggest problems with CORBA is that IIOP needed its own ports, and so firewalls were a huge issue. (None of the big banks I worked with were anywhere near ready to poke holes in their bastions for a new, untested protocol.)</p><p>The other advantage is that SOAP is not a binary protocol. Some people see this as a liability, since there are inevitably issues with the amount of data that must be transmitted and parsed (XML is infamous for being more verbose than other data formats). However, the fact that the protocol is text based harks back to the simplicity of HTTP and HTML, and makes applications easier to debug. Also, interoperability is improved as issues such as Big-endian, Little-endian, and byte ordering go away completely. This means SOAP clients running on Windows clients should not care that the SOAP server it's talking to is running on Linux.</p><h3>SOAP::Lite</h3><p>SOAP::Lite is an open-source package written by Paul Kulchenko (<a href="http://www.soaplite.com/">http://www.soaplite.com/</a> and <a href="http://www.cpan.org/">http://www.cpan.org/</a>), which encapsulates SOAP clients and servers in Perl. (According to the author, the "Lite" refers to the ease of use, not the functionality.) I use Perl for all my web work because it is such a mature language, rock solid in its reliability, and flexible. Throw in the sheer number of available open-source modules and it's a world-class platform. </p><p>When you get SOAP::Lite, you have a couple of additional packages to install before using it &#151; the XML::Parser bundle (<a href="http://search.cpan.org/">http://search.cpan.org/</a>), and the Expat toolkit (<a href="http://expat.sourceforge.net/">http://expat.sourceforge.net/</a>). If you're going to use SOAP::Lite from Apache and mod_perl, then there is a gotcha. The problem is that Apache comes with an Expat (Lite) module, which conflicts in the symbol tables with the Expat module XML::Parser uses. So you need to edit the Apache configuration file (src/Configuration), look for the rule<i> EXPAT = default,</i> and change it to <i>EXPAT = no</i>. Then rebuild Apache and all should be well. If you installed Apache from RPM, then you'll have to get the sources and build it manually. Embperl and mod_perl require access to the Apache source when being built anyway, so this isn't too unusual.</p><p>SOAP::Lite can be used to implement a server and client without your having to know anything at all about XML. Even though XML is fundamental to the toolkit, it is all under the covers (where it belongs). All you have to do is set up the daemon (see <A NAME="rl1"><A HREF="#l1">Listing One</A>) and the client (<A NAME="rl2"><A HREF="#l2">Listing Two</A>). </p><h3>The Server</h3><p>The server uses the package SOAP::Transport::HTTP::Daemon, which contains all the functionality needed to implement a daemon; see <A NAME="rl1"><A HREF="#l1">Listing One</A> for the server code.</p><p>The first thing you do is create the daemon object, giving it a port to listen on and an address (localhost in this example, and port 81). You also tell the daemon to use <i>objects_by_reference</i>, a directive that specifies a package that is to be used in a persistent way. This means that between calls to the server, the package is not reinitialized. The <i>objects_by_reference</i> is actually more powerful than this, but all you need out of it for your purposes is the ability to have the package (Spelling) variables persist between calls. You need this because the Lingua::Ispell package maintains the pipe to ispell in a variable. If it were reinitialized on each call, then Lingua::Ispell would lose track of ispell and restart it each time.</p><p>You then tell the daemon to dispatch calls to the package (Spelling) and ask it to handle connections. That's pretty much it. There is no more SOAP-specific stuff in the server code. You have the package definition, which contains a single subroutine, <i>check()</i>. This is in the form of an object method (for example, <i>$self</i> is the first parameter). The other parameter is the text being spellchecked.</p><p>The <i>check() </i>method calls Lingua::Ispell, then parses the resulting terms, which are all the unrecognized words. You then replace these terms in the text with HTML, which makes the words red, by placing FONT tags around them. Ignore terms that appear within HTML tags or Embperl code blocks, otherwise the HTML will get corrupted. There are probably much more efficient ways to do the pattern matching than the three separate statements that I have here, but this works pretty well.</p><p>And that's that for the server. When you run it, the daemon sits and waits for connections. I have had the same daemon up and running for days, and it seems stable. It is not multithreaded, it would be an exercise for you to convert the daemon into a more ambitious preforking version (there is example code to do this included with SOAP::Lite). For me, the current form is sufficient because spellchecking happens on a relatively infrequent basis (only when someone is posting a message or explicitly requesting a spellcheck on their journal). If the site were to expand, then I would utilize load balancing by having multiple web server machines, each with its own spellcheck server.</p><h3>The Client</h3><p>The client code is even simpler. As you'll see from <A NAME="rl2"><A HREF="#l2">Listing Two</A>, all you do is specify the address and port of the server, and the function to call. You can see that the package you are calling is given as part of the address; this is how the server knows where to dispatch the call. </p><p>I have added extra logic as a safeguard just in case the server is not running; this is a directive to catch errors and undefine the result string. If this happens, then the text we are spellchecking is simply left unchanged. Thus, it's a kind of failsafe mechanism.</p><p>The <i>proxy</i> part of the call specifies the server that we are using. The beauty of SOAP is that you can use HTTP, FTP, or even MAILTO URLs here. SOAP can use any of these protocols. The <i>uri</i> directive specifies the specific service (in this case, the Spelling package), which we are calling on the server. Each server may have multiple services available. The <i>on_fault</i> part says how we are to handle errors; in this case, you simply say that <i>$result</i> is undefined.</p><p>When you have made the call, then you call <i>result()</i> on the return object to get the actual result of the function call. This can be more automated, using autodispatch, though I haven't done that here. According to the documentation, the call can end up looking like a normal Perl call.</p><h3>Conclusion</h3><p>As an added bonus, thanks to SOAP, I am using XML now on my web server without knowing anything (and caring less) about XML, schemas, XSLT, XPath, XLink, or any of the other technologies I've been avoiding. SOAP is hiding everything, and it can truly be said that SOAP results in cleaner code.</p><p>You can see a demo of the server/client discussed in this article at <a href="http://www.crazyguyonabike.com/">http://www.crazyguyonabike.com/</a> spellcheck/. There is a simple form that lets you type some text and see the unrecognized words marked in red.</p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>#!/usr/local/bin/perl -wuse SOAP::Transport::HTTP;my $daemon = SOAP::Transport::HTTP::Daemon    -&gt; new (LocalAddr =&gt; 'localhost', LocalPort =&gt; 81)    -&gt; objects_by_reference(qw(Spelling))    -&gt; dispatch_to('Spelling');  print "Contact to SOAP server at ", $daemon-&gt;url, "\n";  $daemon-&gt;handle;package Spelling;sub check{    my ($self, $text) = @_;    use Lingua::Ispell;    $Lingua::Ispell::path = "/usr/bin/ispell";    $dummy = '__TERM__';    for $word (Lingua::Ispell::spellcheck ($text))    {        if ($word-&gt;{type} eq 'miss' )        {            # First replace any terms found inside HTML or Embperl             #                                  brackets with dummy term            $text =~ s{([\&lt;\[])([^\&gt;\]]*?)(\b$word-&gt;{term}\b)}{$1$2$dummy}g;            # Now mark up the remaining terms with red font            $text =~ s{(^|[^\&gt;\&amp;])(\b$word-&gt;{term}\b)}{$1\&lt;FONT                                               COLOR=\"red\"\&gt;$2\&lt;\/FONT\&gt;}g;            # Restore the dummy terms            $text =~ s{$dummy}{$word-&gt;{term}}g;        }    }    return $text;}1;</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>sub check_spelling{        my ($self, $textref) = @_;        # Check spelling        use SOAP::Lite;        my $soap = SOAP::Lite           -&gt; uri('http://localhost/Spelling')           -&gt; proxy('http://localhost:81')           -&gt; on_fault (sub {undef $result});        $result = $soap-&gt;check($$textref);        $$textref = $result ? $result-&gt;result() : $$textref;}</pre><P><A HREF="#rl2">Back to Article</A></P></body></html>