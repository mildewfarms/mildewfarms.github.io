<html><head><title>Jan01: Letters</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Letters</h1><p><i>Dr. Dobb's Journal</i> January 2001</p><p><b><i>SET Realities</p><p></i></b>Dear <i>DDJ</i>,</p><DDJADVERTISEMENT INLINE><p>Having been involved in the first year or so of creation of the SET credit card protocol, I enjoyed the article "The SET Standard and E-Commerce" by William Stallings (<i>DDJ</i>, November 2000). The article gives a nice and readable overview of the protocol.</p><p>However, I'm afraid the closing section, "SET in Practice" is a bit lacking and overly optimistic. In reality, SET adoption has been very slow and limited &#151; and it seems that chances of SET being widely deployed, as is, are rather slim. There are multiple reasons for this. I think the most important is that SET requires implementation by all parties &#151; cardholder, merchant, and their respective banks. There isn't a migration path, whereby a party would receive some benefit by implementing before others &#151; on the contrary.</p><p>As a result, there recently have been new efforts to provide secure credit card solutions, which will have a reasonable, gradual adoption path. For example, by combining credit-card security with micropayments (as IBM does), by providing simple, if limited, solutions based on complementing SSL based transactions with direct authorization from the cardholder to the issuing bank, and other approaches. A more in-depth overview is available in http://www .hrl.il.ibm .com/mpay/course/ course.html.</p><p>Amir Herzberg</p><p>amir@il.ibm.com</p><p><b><i>CueCat </p><p></i></b>Dear <i>DDJ</i>,</p><p>While we're as happy as the next hacker to play with the CueCat (see "Editorial," by Jonathan Erickson, <i>DDJ</i>, November 2000), as an eight-year old barcode software company, my hit on Digital Convergence and the CueCat is a little different than the prevailing SlashDot/Open Source/Linux crowd perspective. I did take the time to elaborate my views recently: see http://www.azalea.com/qtools/ AzaleaQToolsUpdate.pdf.</p><p>We want lots of CueCats out in the real world &#151; that is the nonwarehouse, shipping industry, overnight delivery world. Yes, we want barcode scanners in homes across the land. Then and only then can the real games begin. AzaleaQTools will evolve into something constructive, not attacking Digital Convergence. I don't care if their business plan is flawed or if ultimately they succeed or fail. All I know is they are well funded enough to distribute millions of "free and low-cost bar code scanners" before their 15 minutes of fame is up.</p><p>Jerry Whiting</p><p>jwhiting@azalea.com </p><p>Dear <i>DDJ</i>,</p><p>I got a CueCat as part of my <i>Wired</i> magazine subscription, and I am of the opinion that Digital Convergence will be bankrupt shortly, due to its general incompetence, and lack of support from the advertising community.</p><p>In the first place, Digital Convergence was too cheap in manufacturing the CueCat. It failed to incorporate the necessary adaptors to achieve effective hardware compatibility with AT keyboards or laptops, the way a cheap mouse would. The odds are very much against many prospective users trucking down to Radio Shack to buy the things, as recommended in the brochure, so, right off the top, the user base is severely limited. Furthermore, the user base is limited in particular ways, with an emphasis on the kind of cheap "family computer" sold by Radio Shack, than on the kind of "heavy iron" favored by people who use computers in their work, and who are most demographically desirable to advertisers. The failure to provide a Linux driver is part of a broader pattern.</p><p>Parenthetically, I remember that some years ago, in 1994, I considered buying a Radio Shack computer, but had to turn them down because their computers did not support 5-1/4 inch floppies, which of course had been the generally prevailing standard a couple of years earlier. In short, we're talking about a group of companies who "just don't get it."</p><p>Looking at the last couple of issues of <i>Wired</i>, I find that large numbers of advertisers have declined to play ball with Digital Convergence at all. I don't suppose an advertiser can get a barcode number for free, or for a nominal registration charge? Furthermore, I noted that practically all the advertisers who had barcodes also had other contact information, typically URLs and voice phone numbers. They were hedging their bets, and are quite willing to concede anonymity sooner than be bypassed. About the only notable exception to this policy were the makers of the Altoids candies. I don't think Digital Convergence can survive as an appendage to Altoids, even assuming that Altoids themselves survive.</p><p>Altoids are a rather strange product, if you think about it. They are candies marketed as if they were whiskey. That has been tried. About 30 years ago, there was a beverage known as "bitter lemon." It failed. The whole point of whiskey is to get looped. In short, how wonderful that all these people found each other!</p><p>Andrew D. Todd</p><p>u46A8@wvnvm.wvnet.edu</p><p>Dear <i>DDJ</i>,</p><p>I was reflecting on Jonathan Erickson's "Editorial" (<i>DDJ</i>, November 2000), especially the phrase "customers who still believe in concepts such as ownership and private property," and I identified a recent trend among capitalists &#151; regarding our privacy and our right to it.</p><p>These new wireless technologies are so popular among venture capitalists lately because they were sold to them largely as a means to keep track of users' habits and profiles &#151; and target them precisely. Also considering the future of ".Net" and the new trends in software licensing (ASPs, downloaded Java style, CORBA, and "adware"), it only makes it clearer that we are bound to be almost naked in the eyes of these companies when it comes to our privacy. The open-source community needs to enforce and educate others on cryptography, the importance of privacy, and what is done with the data mined from the casual computer user &#151; and suggest solutions that are practical. </p><p>Jose Melo de Assis Fonseca</p><p>jfonseca@matarese.com</p><p><b><i>C++ Namespaces</p><p></i></b>Dear <i>DDJ</i>,</p><p>I am a big fan of C++ and I feel that Stroustrup and the Standards committee do a fantastic job with the highly challenging job they have of improving the language standard while keeping compatibility with old C++ code. In some cases they have failed, but most C++ code will still compile on the latest compilers.</p><p>However, in Herb Sutter's "Migrating to Namespaces" (<i>DDJ</i>, October 2000), we're told that we need to learn about namespaces right away because modern compilers, which have namespace facilities, will not compile old C++ code written in ignorance of them. Herb then gives us an example of some old code that is apparently broken. The code includes <i>&lt;iostreams.h&gt;</i> and does not use the <i>std::</i> qualifier to access names in the <i>std:: namespace</i>.</p><p>What Herb forgets is that including <i>&lt;iostreams.h&gt;</i> automatically dumps all the names defined in std into the global namespace (with a using directive) &#151; a technique used explicitly so the addition of namespaces does not break old code. The other header, <i>&lt;iostreams&gt;</i>, does not have the using directive and is appropriate for new code, or when you are migrating old code. So the code that Herb claims is broken is not, and will compile correctly on any conformant C++ compiler (or, rather, any C++ compiler with conformant header files).</p><p>Using namespaces is definitely a good thing for new projects, and upgrading old projects to use namespaces is no doubt desirable, but those of us working on legacy C++ projects have nothing to fear in upgrading to a modern, namespace- supporting compiler. Our old code will still compile and link exactly as we expect it to, with no extra effort on our behalf, and we can reap the other benefits of a more up-to-date compiler, such as better back-end optimization.</p><p>Eddie Edwards</p><p>eddie@naughtydog.com</p><p><b><i>C++ Aliasing</p><p></i></b>Dear <i>DDJ</i>,</p><p>Mark Mitchell's article "Type-Based Alias Analysis" (<i>DDJ</i>, October 2000) was refreshing reading after having programmed for some 12 years in an aliasing-free concurrent language. However, I have some points to add:</p><p></p><ul>  <li>Mark does not directly state that aliasing can also happen in pointerless languages. When an object in such a language is used by its name only, it may still be treated by reference by the compiler, thus opening for aliasing errors.  <li>Aliasing-free code could be fast, but aliasing of objects could be fatal! In the Java example below <i>x=x+(x-x)</i> may correctly be <i>x</i> but fatally zero when <i>c1</i> is aliased.</ul><blockquote><pre> class thing ?  // By Peter Welch, Univ. of Kent at  		           Canterbury, UK    int x;    public thing (int v) ?x = v;?    public static void harmless (thing t1, 				   thing t2) ?   t1.x = t1.x + t2.x;   t1.x = t1.x - t2.x;    ?   ?   class alias ?    public static void main (String args[]) ?   thing c1 = new thing(10);   thing c2 = new thing(20);   thing.harmless (c1,c2); // c1.x=10 c2.x=20   thing.harmless (c1,c1); // c1.x=0 has  			     become 0!    ?		?</pre></blockquote><ul>  <li>Aliasing may also be a wanted trait. Passing by reference and doubly linked lists are examples.  <li>Mark mentions that the C9X "restrict" does not prohibit the programmer from making aliasing errors. With occam the compiler takes me at the subtlest places, where I would not have imagined problems &#151; but then there is no "restrict"-type decoration, all variables are verified for aliasing errors, and the compiler can, therefore, always assume aliasing-free code.  <li>I have just recently learned (at a SIG at the CPA 2000 conference; wotug.ukc .ac.uk/cpa2000) that if you could control aliasing in an object-oriented language, you could also control garbage collection. An object free of aliasing can be deallocated in unit-time once it goes out of scope for the single only referencer of that particular object.</ul><p>Oyvind Teig</p><p>oyvind.teig@autronica.no</p><p></p><p></p><p><b>DDJ</b></p><hr></body></html>