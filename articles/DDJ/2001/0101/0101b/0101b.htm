<html><head><title>Jan01: Programming in Ruby</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Programming in Ruby</h1><p><i>Dr. Dobb's Journal</i> January 2001</p><h2>A freely available pure object-oriented language</h2><h3>By Dave Thomas and Andy Hunt</h3><I>Dave and Andy are consultants and coauthors of Programming Ruby and The Pragmatic Programmer, both from Addison-Wesley. They can be contacted at http:// www.pragmaticprogrammer.com/. </I><hr><a name="rs1"><a href="0101bs1.htm">Ruby Resources</a><br><a name="rs2"><a href="0101bs2.htm">Designing Ruby</a><hr><p>Take the pure object orientation of Smalltalk, but remove the quirky syntax and reliance on a workspace. Add in the convenience and power of Perl, but without all the special cases and magic conversions. Wrap it up in a clean syntax based in part on Eiffel, and add a few concepts from Scheme, CLU, Sather, and Common Lisp. You end up with Ruby. </p><p>Thanks in part to the energy of its creator, Yukihiro Matsumoto (Matz), Ruby is already more popular than Python in its native Japan. Ruby is a pure, untyped, object-oriented language &#151; just about everything in Ruby is an object, and object references are not typed. People who enjoy exploring different OO programming paradigms will enjoy experimenting with Ruby: It has a full metaclass model, iterators, closures, reflection, and supports the run-time extension of both classes and individual objects.</p><DDJADVERTISEMENT INLINE><p>The freely available Ruby (http://www.ruby-lang.org/) is being used worldwide for text processing, XML and web applications, GUI building, in middle-tier servers, and general system administration. Ruby is used in artificial intelligence and machine-learning research, and as an engine for exploratory mathematics.</p><p>Ruby's simple syntax and transparent semantics make it easy to learn. Its direct execution model and dynamic typing let you develop code incrementally: You can typically add a feature and then try it immediately, with no need for scaffolding code. Ruby programs are typically more concise than their Perl, Python, or C++ counterparts, and their simplicity makes them easier to understand and maintain. When you bump up against some facility that Ruby is lacking, you'll find it easy to write Ruby extensions using both Ruby and low-level C code that adds new features to the language. </p><p>We came across Ruby when we were looking for a language to use as a prototyping and specification tool. We've used it on all of our projects since. We have Ruby code performing distributed logging, executing within an X Windows window manager, precompiling the text of a book, and generating indexes. Ruby has become our language of choice.</p><h3>Everything's an Object</h3><p>Everything you manipulate in Ruby is an object, and all methods are invoked in the context of an object. (In our examples here, we'll sometimes show the result of evaluating an expression to the right of an arrow (->). This is not part of the Ruby syntax.)</p><blockquote><p>"gin joint".length	-> 9</p><p>"Rick".index("c")	-> 2</p><p>-1942.abs 	-> 1942</p><p>sam.play(aSong)  -> "duh dum, da dum de  			       dum ..."</p></blockquote><p>In Ruby and Smalltalk jargon, all method calls are actually messages sent to an object. Here, the thing before the period is called the "receiver," and the name after the period is the method to be invoked.</p><p>The first example asks a string for its length, and the second asks a different string to find the index of the letter "c." The third line has a number calculate its absolute value. Finally, we ask the object "sam" to play us a song. It's worth noting a major difference between Ruby and most other languages. In Java, for example, you'd find the absolute value of some number by calling a separate function and passing in that number. In Ruby, the ability to determine absolute values is built into numbers &#151; they take care of the details internally. You simply send the message <i>abs</i> to a <i>number </i>object and let it do the work.</p><blockquote><p>number = Math.abs(number) // Java</p><p>number = number.abs // Ruby</p></blockquote><p>The same applies to all Ruby objects: In C, you'd write <i>strlen(name)</i>; while in Ruby, it's <i>name.length</i>. This is part of what we mean when we say that Ruby is a genuine OO language.</p><p>The parentheses on method calls are optional unless the result would be ambiguous. This is a big win for parameterless methods, as it cuts down on the clutter generated by all those () pairs.</p><h3>Classes and Methods</h3><p>As <A NAME="re1"><A HREF="0101be1.htm">Example 1</A> shows, Ruby class definitions are remarkably simple: The keyword <i>class </i>is followed by a class name, the class body, and the keyword <i>end </i>to finish it all off. Ruby features single inheritance: Every class has exactly one superclass, which can be specified as in <A NAME="re2"><A HREF="0101be2.htm">Example 2</A>. A class with no explicit parent is made a child of class <i>Object</i> &#151; the root of the class hierarchy and the only class with no superclass. If you're worried that a single inheritance model just isn't enough, never fear. We'll be talking about Ruby's mix-in capabilities shortly.</p><p>Returning to the definition of class <i>Song </i>in <A NAME="re1"><A HREF="0101be1.htm">Example 1</A>, the class contains two method definitions, <i>initialize</i> and <i>to</i>_<i>s</i>. The <i>initialize</i> method participates in object construction. To create a Ruby object, you send the message <i>new</i> to the object's class, as in the last line of <A NAME="re1"><A HREF="0101be1.htm">Example 1</A>. This <i>new</i> message allocates an empty, uninitialized object, and then sends the message <i>initialize</i> to that object, passing along any parameters that were originally given to <i>new</i>. This makes <i>initialize</i> roughly equivalent to constructors in C++ and Java.</p><p>Class <i>Song</i> also contains the definition of the method <i>to_s</i>. This is a convenience method; Ruby sends <i>to_s</i> to an object whenever it needs to represent that object as a string. By overriding the default implementation of <i>to_s</i> (which is in class <i>Object</i>), you get to control how your objects are printed (for example, by tracing statements and the debugger), and when they are interpolated in strings. In <A NAME="re2"><A HREF="0101be2.htm">Example 2</A>, we create a subclass of class <i>Song</i>, overriding both the <i>initialize</i> and <i>to_s</i> methods. In both of the new methods we use the <i>super</i> keyword to invoke the equivalent method in our parent class. In Ruby, <i>super</i> is not a reference to a parent class; instead, it is an executable statement that reinvokes the current method, skipping any definition in the class of the current object. By default, all methods (apart from <i>initialize</i>) are publicly accessible; they can be invoked by anyone. Ruby also supports private and protected access modifiers, which can be used to restrict the visibility of methods to a particular object or a particular class, respectively. Ruby's implementation of "private" is interesting: You cannot invoke a private method with an explicit receiver, so it may only be called with a receiver of <i>self, </i>the current object.</p><h3>Attributes, Instance  Variables, and Bertrand Meyer</h3><p>The <i>initialize</i> method in class <i>Song</i> contains the line <i>@title = title</i>. Names that start with single "at" signs (@) are instance variables &#151; variables that are specific to a particular instance or object of a class. In our case, each <i>Song</i> object has its own title, so it makes sense to have that title be an instance variable. Unlike languages such as Java and C++, you don't have to declare your instance variables in Ruby; they spring into existence the first time you reference them. Another difference between Ruby and Java/C++ is that you may not export an object's instance variables; they are available to subclasses, but are otherwise inaccessible. (This is roughly equivalent to Java's "protected" concept.) Instead, Ruby has attributes: methods that get and set the state of an object. You can either write these attribute methods yourself, as in <A NAME="re3"><A HREF="0101be3.htm">Example 3</A>, or use the Ruby shortcuts in <A NAME="re4"><A HREF="0101be4.htm">Example 4</A>.</p><p>It's interesting to note the method called <i>title=</i> in <A NAME="re3"><A HREF="0101be3.htm">Example 3</A>. The equals sign tells Ruby that this method can be assigned to &#151; it can appear on the left side of an assignment statement. If you were to write <i>aSong.title = "Chicago,"</i> Ruby translates it into a call to the <i>title=</i> method, passing <i>"Chicago"</i> as a parameter. This may seem like some trivial syntactic sugar, but it's actually a fairly profound feature. You can now write classes with attributes that act as if they were variables, but are actually method calls. This decouples users of your class from its implementation &#151; you're free to change an attribute back and forth between some algorithmic implementation and a simple instance variable. In <i>Object-Oriented Software Construction</i> (Prentice Hall, 2000), Bertrand Meyer calls this the "Uniform Access Principle."</p><h3>Blocks and Iterators</h3><p>Have you ever wanted to write your own control structures, or package up lumps of code within objects? Ruby's block construct lets you do just that. A block is simply a chunk of code between braces, or between <i>do</i> and <i>end</i> keywords. When Ruby comes across a block, it stores the block's code away for later; the block is not executed. In this way, a block is similar to an anonymous method. Blocks can only appear in Ruby source alongside method calls.</p><p>A block associated with a method call can be invoked from within that method. This sounds innocuous, but this single facility lets you write callbacks and adaptors, handle transactions, and implement your own iterators. Blocks are also true closures, remembering the context in which they were defined, even if that context has gone out of scope. </p><p>The method in <A NAME="re5"><A HREF="0101be5.htm">Example 5</A> implements an iterator that returns successive Fibonacci numbers (the series that starts with two 1s, where each term is the sum of the two preceding terms). The main body of the method is a loop that calculates the terms of the series. The first line in the loop contains the keyword <i>yield</i>, which invokes the block associated with the method, in this case passing as a parameter the next Fibonacci number. When the block returns, the method containing the yield resumes. Thus, in our Fibonacci example, the block will be invoked once for each number in the series until some maximum is reached.</p><p><A NAME="re6"><A HREF="0101be6.htm">Example 6</A> shows this in action. The call to <i>fibUpTo</i> has a block associated with it (the code between the braces). This block takes a single parameter &#151; the name between the vertical bars at the start of the block is like a method's parameter list. The body of the block simply prints this value.</p><p>If you write your own collection classes (or any classes that implement a stream of values), you can benefit from the real beauty of Ruby's iterators. Say you've produced a class that stores objects in a singly linked list. The method <i>each</i> in <A NAME="re7"><A HREF="0101be7.htm">Example 7</A> traverses this list, invoking a block for each node. This is a Visitor Pattern in three lines of code. The choice of the name, <i>each</i>, was not arbitrary. If your class implements an <i>each</i> method, then you can get a whole set of other collection-oriented methods for free, thanks to the <i>Enumerable</i> mix-in.</p><h3>Blocks and Closures</h3><p>Ruby blocks can be converted into objects of class <i>Proc</i>. These <i>Proc</i> objects can be stored in variables and passed between methods just like any other object. The code in the corresponding block can be executed at any time by sending the <i>Proc</i> object the message <i>call</i>.</p><p>Ruby <i>Proc </i>objects remember the context in which they were created: the local variables, the current object, and so on. When called, they recreate this context for the duration of their execution, even if that context has gone out of scope. Other languages call <i>Proc </i>objects <i>closures.</i></p><p>The following method returns a <i>Proc</i> object:</p><blockquote><p>def times(n)</p><p>  return Proc.new {|val| n * val} </p><p>end</p></blockquote><p>The block multiplies the method's parameter, <i>n</i>, by another value, which is passed to the block as a parameter. The following code shows this in action: </p><blockquote><p>double = times(2)</p><p>double.call(4) 	-> 8</p><p>santa = times("Ho! ")</p><p>santa.call(3) 	-> "Ho! Ho! Ho! "</p></blockquote><p>The parameter <i>n</i> is out of scope when the <i>double</i> and <i>santa</i> objects are called, but its value is still available to the <i>closures.</i></p><h3>Modules, Mix-ins,  and Multiple Inheritance</h3><p>Modules are classes that you can't instantiate: You can't use <i>new</i> to create objects from them, and they can't have superclasses. At first, they might seem pointless, but in reality, modules have two major uses.</p><ul>  <li>	Modules provide namespaces. Constants and class methods may be placed in a module without worrying about their names conflicting with constants and methods in other modules. This is similar to the idea of putting static methods and variables in a Java class. In both Java and Ruby you can write <i>Math.PI</i> to access the value of p (although in Ruby, <i>PI</i> is a constant, rather than a final variable, and you're more likely to see the notation <i>Math::PI</i>).  <li>	Modules are also the basis for mix-ins, a mechanism by which you add canned behavior to your classes.</ul><p>Perhaps the easiest way to think about mix-ins is to imagine that you could write code in a Java interface. Any class that implemented such an interface would receive not just a type signature; it would receive the code that implemented that signature as well. We can investigate this by looking at the <i>Enumerable</i> module, which adds collection-based methods to classes that implement the method <i>each</i>. <i>Enumerable</i> implements the method <i>find</i> (among others). <i>find</i> returns the first member of a collection that meets some criteria. This example shows <i>find </i>in action, looking for the first element in an array that is greater than four.</p><blockquote><p>[1,3,5,7,9].find {|i| i &gt; 4 } -> 5</p></blockquote><p>Class <i>Array</i> does not implement the <i>find</i> method. Instead, it mixes in <i>Enumerable</i>, which implements <i>find</i> in terms of <i>Array</i>'s <i>each</i> method; see <A NAME="re8"><A HREF="0101be8.htm">Example 8</A>. Contrast this approach with both Java and C#, where it is up to the class implementing the collection to also provide a considerable amount of supporting scaffolding.</p><p>Although a class may have only one parent class (the single inheritance model), it may mix in any number of modules. This effectively gives Ruby the power of multiple inheritance without some of the ambiguities that can arise. (And in cases where mixing in modules would cause a name clash, Ruby supports  method renaming.) </p><h3>Other Good Stuff</h3><p>Other Ruby highlights include:</p><p></p><ul>  <li>	Classes and modules are never closed. You can add to and alter all classes and modules (including those built into Ruby itself).  <li>	Dynamic loading. Ruby modules (both source and binary) may be loaded dynamically, both explicitly and on demand.  <li>	Reflection. As well as supporting reflection into both classes and individual objects, Ruby lets you traverse the list of currently active objects.  <li>	Marshaling. Ruby objects can be serialized and deserialized, allowing them to be saved externally and transmitted across networks. A full distributed-object system, DRb, is written in about 200 lines of Ruby code.  <li>	Libraries. Ruby has a large (and growing) collection of libraries. All major Internet protocols are supported, as are most major databases. Extending Ruby is simple compared to adding extensions to Perl.  <li>	Threads. Ruby has built-in support for threads, and doesn't rely on the underlying operating system for thread support.  <li>	Object specialization. You can add methods to individual objects, not just classes. This is useful when defining specialized behavior for objects (for example, determining their response to GUI events).  <li>	Exceptions. Ruby has a fully object-oriented, extensible exception model.  <li>	Garbage collection. Ruby objects are automatically garbage collected using a mark-and-sweep algorithm. The choice of mark-and-sweep simplifies programming and makes writing extensions easier (no reference counting problems).  <li>	Active developer community. The Ruby development community is still a bazaar: small, intimate, and bustling. Changes are discussed openly and are made efficiently. </ul><h3>Some Real Examples</h3><p>At this point, we'll present two larger Ruby programs. The first is a basic web server that echoes back the headers it receives. It's written as two classes; see <A NAME="rl1"><A HREF="#l1">Listing One</A>. <i>WebSession</i> is a convenience class that provides two methods for writing to a TCP connection. The <i>standardPage</i> method is interesting. At a minimum, it writes a standard page header and footer. If called with a block, however, it inserts the value returned by that block as the page body. This kind of wrapping functionality is a natural use for Ruby's blocks.</p><p>The <i>WebServer</i> class uses Ruby's TCP library to accept incoming connections on a given port. For each connection, it spawns a Ruby thread that reads the header and writes the contents back to the client. The code in the thread is wrapped in a <i>begin</i>/<i>end</i> block, used in Ruby to handle exceptions. In this case, we use an ensure clause to make sure that the connection to the client is closed, even if we encounter errors while handling the request.</p><p>The second program packs a number of features into a small space. At its core, it represents the list of songs in an MP3 collection as an array, providing all the existing array functionality plus the ability to shuffle the entries randomly. If the array is sorted, then the entries will be ordered by song title. Each entry in the array is an object of class <i>Song</i>. As well as providing a container for the song title, album, and artist, this class implements the general comparison operator, &lt;=&gt;. This operator is used when sorting containers containing songs: In this case, we compare song titles. There are two common approaches to making our <i>MP3List</i> act as if it were an array: delegation or subclassing. <A NAME="rl2"><A HREF="#l2">Listing Two</A> shows the approach using delegation. The library module <i>delegate </i>provides a class <i>SimpleDelegator</i>, which handles all the details of forwarding method calls from class <i>MP3List </i>to the delegate. We create the array containing the songs, then invoke <i>SimpleDelegator</i>'s <i>initialize </i>method (using <i>super(songlist)</i>) to set up the delegation. From that point on, <i>MP3List</i> will act as if it were an array. When users shuffle a song list, we create a new array containing the entries of the original in a random order, and use <i>SimpleDelegator</i>'s __<i>setobj__</i> method to delegate to that new array.</p><p><A NAME="rl3"><A HREF="#l3">Listing Three</A> shows an alternative implementation of <i>MP3List</i> in which we subclass the built-in <i>Array</i> class and add our own <i>shuffle!</i> method. Why the exclamation mark? Ruby convention is to append a "!" to methods that change their object (or are otherwise dangerous), and to append a question mark to predicate method names.</p><h3>Conclusion</h3><p>Programming in Ruby is an immensely satisfying experience &#151; the language is able to represent high-level concepts concisely, efficiently, and readably. It's easy to learn, and at the same time it is deep enough to excite even the most jaded language collector. Download a copy and try it for yourself. </p><p></p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>require "socket"class WebSession  def initialize(connection)    @connection = connection  end  def write(string)    @connection.write string  end  def standardPage(title)    write "HTTP/1.1 200 OK\r\n"    write "Content-Type: text/html\r\n\r\n"    write "&lt;html&gt;&lt;head&gt; &lt;title&gt;#{title}&lt;/title&gt; &lt;/head&gt;\n"    write yield if block_given?    write "&lt;/body&gt;&lt;/html&gt;"  endendclass WebServer  def initialize(port)    @listen = TCPServer.new('localhost', port || 8080);  end  def run    loop do      Thread.start(@listen.accept) do |aConnection|        begin          session = WebSession.new(aConnection)                    request = []          loop do             line = aConnection.gets.chomp("\r\n")            break if line.length == 0            request &lt;&lt; line          end          session.standardPage("Your Request") {            "&lt;h1&gt;Your request was:&lt;/h1&gt;\n" +            request.join('&lt;br&gt;') +            "&lt;p&gt;Thank you for testing our system."          }        ensure          aConnection.close        end  # begin      end    # Thread    end      # loop  end        endWebServer.new(ARGV[0]).run</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>require 'delegate'require 'find'class Song  attr_reader :title, :album, :artist  def initialize(filename)    @artist, @album, @title = filename.split("/")[-3..-1]    @title.chomp!(".mp3")  end  def &lt;=&gt;(anOther)    title &lt;=&gt; anOther.title  end  def to_s    "'#{@title}'  #{@artist}--'#{@album}'\n"  endendclass MP3List &lt; SimpleDelegator  def initialize(base)    songlist = Array.new    Find.find(base) do |entry|      if entry =~ /\.mp3$/        if !block_given? or yield entry            songlist &lt;&lt; Song.new(entry)        end      end    end    super(songlist)  end  def shuffle!    newlist = Array.new    length.times do      newlist &lt;&lt; delete_at(rand(length))    end    __setobj__(newlist)    self  endendbase = ARGV[0] || "/mp3"list = MP3List.new(base + "/Hatfield And The North")puts "Original:  ", list.sortputs "Shuffled:  ", list.shuffle!puts "5 entries: ", list[0..4]puts "Filtered: "list = MP3List.new(base) { |x| x =~ /Woke Up This Morning/ }puts list</pre><P><A HREF="#rl2">Back to Article</A></P><H4><A NAME="l3">Listing Three</H4><pre>class MP3List &lt; Array  def initialize(base)    super()    Find.find(base) do |entry|      if entry =~ /\.mp3$/        if !block_given? or yield entry            self &lt;&lt; Song.new(entry)        end      end    end  end  def shuffle!    newlist = Array.new    length.times do      newlist &lt;&lt; delete_at(rand(length))    end    replace(newlist)  endend</pre><P><A HREF="#rl3">Back to Article</A></P></body></html>