<html><head><title>Jan01: Parsing XML</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Parsing XML</h1><p><i>Dr. Dobb's Journal</i> January 2001</p><h2>Your own  miniXML parser</h2><h3>By David Cox</h3><I>David is a software engineer at Xerox and teaches computer science at the Rochester Institute of Technology. He can be reached at guffy@rochester.rr.com.</I><hr><p>The XML specification describes how to create documents containing structured, hierarchical information. One of the promises of the XML specification is that these documents are easy to parse. Because I like doing things that are easy, I decided to create my own parser.</p><p>I started by downloading the XML specification from http://www.w3c.org/, then purchased a copy of Bob DuCharme's <i>XML: The Annotated Specification</i> (Prentice Hall, 2000). Like many specs, the XML one is short, to the point, and assumes a certain background. DuCharme's annotated spec explains in detail, and with examples, each section of the XML spec. It might also help to have a good general book on XML. However, I did not use one for this project.</p><DDJADVERTISEMENT INLINE><p>I then decided to code the parser in C++ using Visual C++ Version 5. I also used the Standard Template Library (STL) for strings and various containers. With these tools, I began writing a parser that I call "miniXML." (The complete source code for miniXML is available electronically; see "Resource Center," page 5.)</p><h3>Types of Parsers</h3><p>XML documents are text documents &#151; an array of characters. Another way of stating the same thing is to say that XML documents are one big string. The goal of an XML parser is to extract information from these strings. Two different ways of doing this have been developed.</p><p>One way is to use an event-driven approach. The parser begins reading the string and sends messages when certain events occur. For example, a message is sent when a start tag is encountered and another event when an end tag is reached. Programs that use these parsers have callback functions to process the events. When a message signals that a desired tag has been found, the program can examine the tag and its accompanying information in detail and act accordingly. The SAX parser is the model for this approach.</p><p>The second approach builds a tree to represent the XML document. Each tag of the document represents a node in the tree. Once built, a program can traverse the tree to process the document or to search for specific tags. Usually these trees reside in memory, limiting the size of XML documents that can be parsed by this approach. In contrast, event-driven parsers do not create a tree and can parse documents of any size.</p><p>The miniXML parser I present here uses the tree approach. While this limits its use to smaller documents, it is very fast. Many, if not most, applications use small documents to do things such as sending small XML documents over the Internet.</p><h3>Canonical XML</h3><p>miniXML works with canonical XML. This is the XML you are left with after an XML document is preprocessed. I liken this to a C compiler that first removes directives and macros, leaving only syntactically correct C code. With XML, preprocessing would include processing references to external files (external DTDs) and expansion of entity references. What is left over is still an XML document, but one that uses a simpler syntax. <A NAME="rf1"><A HREF="0101gf1.htm">Figure 1</A> shows this simpler syntax (known as canonical XML). Strictly speaking, XML documents are created using Unicode. However, I wrote miniXML to work only with XML documents written in ASCII.</p><p>Is canonical XML useful? Absolutely. <A NAME="re1"><A HREF="0101ge1.htm">Example 1</A>(a) is XML that conforms to this syntax. This is one continuous string, but for readability it can be displayed as <A NAME="re1"><A HREF="0101ge1.htm">Example 1</A>(b). Many real-world applications generate XML documents using this simpler syntax. For this reason, miniXML parses documents that conform to canonical XML. For more information on canonical XML, see http://www.jclark.com/xml/canonxml.html.</p><h3>Building Trees</h3><p>miniXML works by building a tree with nodes that are <i>Tag</i> objects. These pointers allow a tag to maintain two lists &#151; one of siblings and one of children. I use direct pointer manipulation rather than an STL container to maintain these two lists.</p><p>Each tag also contains a list of <i>Attribute</i> objects and a list of <i>Content</i> objects. For these I do use the STL. These lists are declared as:</p><blockquote><p>typedef std::list&lt;Attribute&gt; AttributeList;</p><p>typedef std::list&lt;Content&gt; ContentList;</p></blockquote><p>The code for building the tree is simple and uses techniques taught in any first-year data-structures course.</p><h3>Lexical Analysis</h3><p>In general, the goal of lexical analysis is to break a string of characters into a sequence of tokens. Tokens usually represent words separated by white space. However, at certain times, white space in an XML document is important. As a consequence, miniXML generates a sequence of tokens interspersed with strings of characters that include white space. </p><p>The <i>Lexan</i> class performs the role of lexical analyzer and provides two primary member functions. The first is called <i>NextToken, </i>which is called as needed to look for the next token in a string. The second is called <i>GetCharData,</i> which returns strings that can contain whitespace. These functions are called as needed to build the <i>Tag</i> tree.</p><p><i>GetCharData</i> works by collecting every character it encounters into a string until it reaches either the end of the XML document or encounters a start tag. <i>NextToken</i> works by reading characters until it recognizes that the characters represent one of the types of tokens in <A NAME="rt1"><A HREF="0101gt1.htm">Table 1</A>.</p><h3>The Parser</h3><p>A <i>Parser</i> object requests tokens or character data from a <i>Lexan</i> object. As the tokens and character data are returned, the <i>Parser</i> builds the tag tree.</p><p>The <i>Parser</i> uses a recursive descent technique. The member function, <i>Translate</i>, starts the process by getting the root tag of the XML document. The function <i>GetTag</i> follows the syntax by parsing the start tag, the content, and finally the end tag with calls to <i>StartTag()</i>, <i>Content()</i>, and <i>EndTag()</i>, respectively.</p><p>While parsing content, <i>Lexan</i> could return a <i>StartTag</i> token, signaling the beginning of another tag. If so, <i>Content()</i> recursively calls <i>GetTag</i> and adds the returned tag to the current tag's content list. If <i>Content()</i> encounters a <i>Comment</i> token, the entire comment is added to the content list as a <i>Comment</i> object. If you look at the header file, Parser.h, you will notice that the <i>Comment</i> class is a subclass of <i>Content</i>. Comments are viewed by miniXML simply as a type of <i>Content</i>.</p><p>Otherwise, all the characters encountered are collected into a single <i>Content</i> object, and that string is added to the content list. At this point, <i>Content()</i> switches modes from getting the next token to getting character data. Rather than calling <i>Lexan::NextToken</i>, <i>Content()</i> calls <i>Lexan::GetCharData()</i>. As soon as another start tag is encountered, the parser switches back to collecting tokens.</p><p>Parsing start and end tags proceed similarly. A start tag is defined syntactically as a tag name followed by zero or more attributes between a &lt; character and &gt; character. Consequently, the <i>StartTag()</i> function is written simply as shown in <A NAME="rl1"><A HREF="#l1">Listing One</A>. <i>Match</i> is a function that serves only to move the parser to the next token. From the parser's perspective it is telling <i>Match</i>, "I expect to match this token next. If it matches, great. Send it back to me. If it doesn't match, then there is trouble." <i>Match()</i> stores the next token in the class variable <i>m_lookahead</i>. Sometimes <i>Match()</i> is called to match a predefined token such as <i>m_equal</i> or <i>m_leftStartAngle</i>. The former is a token for the equals sign (=) and the latter is a token for the &lt; character. In these cases, if <i>m_lookahead</i> matches the predefined token, the parser moves on to the next token by getting it and storing it in <i>m_lookahead</i>.</p><p>In other cases, <i>Match()</i> is called to match <i>m_lookahead</i> with itself. This is really a trick to get <i>Match()</i> to move to the next token. The parser is telling <i>Match()</i>, "Okay, I am done with this token, go get the next one." <i>Match()</i> is just one of those little functions that, without an explanation, leads to a lot of head scratching.</p><p>Finally, use of the parser relies on traversing the resulting <i>Tag </i>tree. The <i>TagIterator</i> class assists with this task. A <i>TagIterator</i> object requires that you identify the tag that is the root of the tree. Once this is done, you can call the member functions <i>Begin()</i> and <i>Next()</i> to move through the tree. <A NAME="rl2"><A HREF="#l2">Listing Two</A> is a program to print each tag as you traverse the tree.</p><h3>Conclusion</h3><p>There are many applications for a small XML parser. I think that one of the more interesting uses is to specify a traditional Windows user interface in XML. Each tag would represent some element of the user interface and attributes would represent everything from font to size to position to color. A collection of tags would specify the entire interface for a window or dialog box, allowing an XML document to completely replace Windows resource files.</p><p>Other uses for XML, of course, abound. With small parsers such as miniXML, you can easily add these capabilities to your applications. Microsoft recently introduced the Simple Object Access Protocol (SOAP), a protocol that lets programs send XML over HTTP to invoke methods on remote objects. A small XML parser could serve as the engine for implementing this or a comparable (dare I say, homebrew) protocol. If your goal is something less extravagant, then you can easily use miniXML to send data messages formatted as XML over HTTP. By adding XML and HTTP capabilities to applications, software developers can begin to offer alternatives to traditional browsers that have significant value to their customers.</p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>void Parser::StartTag(Tag * t){    std::string buffer;    Match(m_leftStartAngle);    // match "&lt;"    TagName(buffer);            // match tag name    if (t) t-&gt;Name(buffer);     // save tag name    if (m_lookahead != m_rightStartAngle)    {        AttributeList(t);       // match attributes    }    Match(m_rightStartAngle);   // match "&gt;"}void Parser::EndTag(){    std::string tagName;    Match(m_leftEndAngle);      // match "&lt;/"    TagName(tagName);           // match tag name    Match(m_rightEndAngle);     // match "&gt;"}</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>#include &lt;parser.h&gt;#include &lt;tagiterator.h&gt;#include &lt;iostream&gt;void main(int argc, char *argv[]) {    Parser p;    ifstream xmlFile(argv[1]);    p.Translate(xmlFile);    Tag * root = p.GetRoot();    TagIterator ti(root);    Tag * next = ti.Begin();  // get the root of the tree    while (next)    {        next-&gt;Visit(ti.Level());  // Visit prints the tag        next = ti.Next();         // get the next tag in the tree    }    exit(0);}</pre><P><A HREF="#rl2">Back to Article</A></P></body></html>