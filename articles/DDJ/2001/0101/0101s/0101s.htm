<html><head><title>Jan01: Programmer's Bookshelf</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Beginning Perl &amp;  Windows 2000 Programming</h1><p><i>Dr. Dobb's Journal</i> January 2001</p><h3>By Lou Grinzo and Trudy Pelzer</h3><I>Lou is a freelance programmer and writer who specializes in Linux. He can be reached at lou@gizmodrome.com. Trudy is the coauthor of SQL-99 Complete, Really (CMP Books, 1999). She can be contacted at 71022.733@compuserve.com.</I><hr><h4><br><b><i>Beginning Perl</b><br>Simon Cozens</i><br>Wrox Press, 2000  646 pp., $39.99 ISBN 1-861003-14-5<br><i><br><b>Windows 2000 Systems  Programming Black Book</i></b><br><i>Al Williams</i><br>Coriolis Technology Press, 2000<br>615 pp., $49.99<br>ISBN 1-576102-80-7<br></h4><p>There are two groups of programmers in this world &#151; those who know enough about Perl, and those who don't. Thanks to Perl's rather exuberant personality, you can make a pretty good argument that the first group is the null set. </p><p>Which brings us to the obvious question: How does a reasonably educated programmer get up to speed with Perl? Simon Cozens's <i>Beginning Perl</i> is a respectable starting point, and it also weighs in at about 400 fewer pages than "the camel book"<i>Programming Perl</i>, third edition, by Larry Wall et al., (O'Reilly &amp; Associates, 2000). <i>Beginning Perl</i>'s stated audience, as well as its initial chapters, aim the book squarely at those new to programming. Of course, introducing someone to programming via Perl and its eccentricities is a disturbing concept, to say the least.</p><DDJADVERTISEMENT INLINE><p>Cozens approaches his topic in a big way, tackling everything from Chapter One's "First Steps in Perl" (with the obligatory "hello, world" program), up to CGI programming, debugging, database access, and module creation and use, plus a series of reference appendices. Throughout, he displays a writing style that's casual enough to be inviting, but without losing much in precision.</p><p>That reader-friendly style is repeatedly put to the test by the subject matter, and Cozens does a nice job of detailing the ins-and-outs of Perl's handling of variables and variable interpolation, lists, hashes, references, control statements, and more. The author was clearly on the lookout for opportunities to drop into a shadowed box and emphasize some small but critical syntactic point, such as when to use brackets ([]) and when to use curly brackets ({}), or how to deal with Perl's built-in variables. About the only way the publisher could have improved that aspect of the book would have been to prehighlight those snippets in bright yellow and dog-ear the pages.</p><p>Nowhere are Cozens's pedagogical and descriptive skills put to a greater test than in Chapter Five, "Regular Expressions." This is probably the one area where Perl most earns its reputation for source code that looks like your cat walked across the keyboard. Undaunted, Cozens plunges in, and does an admirable job of explaining and demonstrating the key issues and techniques.</p><p>Thanks to the continued webification of the world, Chapters 12 and 13 (covering CGI programming and database access, respectively) are of particular interest. Even though both chapters are largely quick introductions to concepts with some code samples, they will likely be heavily used as references.</p><p>My biggest complaint with this book is that Cozens handles the language and the ramifications of its use a bit too gently. In numerous places, he points out minor potholes that authors such as himself can easily fall into, and he typically makes solid recommendations to help avoid problems. But then he doesn't go far enough, and some of his advice is akin to telling people that they should handle nitroglycerin carefully because it will stain their clothes. While this might well be true (I haven't a clue, not being an explosives expert), it ignores a far more compelling and potentially dangerous issue. For instance, when discussing object-oriented programming, Cozens provides an example that shows how to set the attributes and values of an instance of an object by passing its constructor a hash (basically a 2D array). This technique might be handy, but it's the equivalent of letting code outside the object determine the number, name, type, and contents of an object's variables, something that should make just about any self-respecting programmer run screaming for the hills. Yet Cozens is remarkably sanguine about the prospects of people doing such things. Perhaps long use of the language has made him immune to such anything-goes Perlisms.</p><p>A close second to the first objection is the use of examples. <i>Beginning Perl</i> is peppered with example code, normally an excellent thing in this type of book, but Cozens falls into the trap of making virtually all the examples so short and tightly focused on the topic at hand that they never give readers the "30,000-foot view" of the language. Given the amount of nontrivial code being written in Perl today, I'm sure many readers would benefit from seeing several much longer examples that pulled together techniques from various sections of the book into a more coherent whole.</p><p><i>Beginning Perl</i> is a good book (its curious positioning as an introduction to programming aside), and it should provide just about anyone with a solid introduction to one of the hottest and most important languages on the Internet.  </p><p> &#151; L.G.</p><p>While there are now several "Windows 2000 Programming" titles on bookstore shelves, I picked up the <i>Windows 2000 Systems Programming Black Book</i> by Al Williams first because both the author and publisher have good reputations. I'd have to get another book, too, if I wanted to do "user programming" instead of "systems programming." Apparently, the distinction is that a user programming book covers the user interface as well, but Williams considers that "systems programming" mainly deals with threads, file I/O, IPC, memory management, security, the registry, and advanced Visual C++ topics such as ActiveX and ATL.</p><p>As a reference, this text has to compete with the online documentation that comes with the Windows SDK. For example, the following compares the two in discussing the <i>CreateFile </i>function. First from page 202 of Williams's book:</p><blockquote><p>dwShareMode: Set of bit flags that specifies how the object can be shared. If dwShareMode is 0, the object cannot be shared. Subsequent open operations on the object will fail, until the handle is closed. If you want to share the file, use any combination of FILE_SHARE_DELETE, FILE_SHARE_READ, or FILE_SHARE_WRITE.</p></blockquote><p>And now, the Windows NT SDK equivalent:</p><blockquote><p>dwShareMode: Set of bit flags that specifies how the object can be shared. If dwShareMode is 0, the object cannot be shared. Subsequent open operations on the object will fail, until the handle is closed. To share the object, use a combination of one or more of the following values: FILE_SHARE_DELETE (Windows NT only) subsequent open operations on the object will succeed only if delete access is requested. FILE_SHARE _READ subsequent open operations on the object will succeed only if read access is requested. FILE_SHARE_WRITE subsequent open operations on the object will succeed only if write access is requested.</p></blockquote><p>From examples like this, I conclude that Williams is adding very little in his description. On the other hand, Williams goes on to give a programming example &#151; the Windows document doesn't &#151; so if your preferred language is C rather than English, you could learn something new about <i>CreateFile </i>parameters.</p><p>In general, the examples are in Visual C++, with occasional ActiveX plus MFC use, and they are clear and solid. Of course, I could quibble about the assumptions. For example, one of the programs will not work unless <i>strlen() </i>returns a count in bytes (an unsafe assumption in this Unicode era). But quibbles aside, I'd rate the examples as one of the book's strengths.</p><p>Williams's writing is clear. Chapters begin with personal anecdotes &#151; a common feature in Coriolis books &#151; and proceed quickly to an in-depth discussion of the programming topic. Chapters end with a lengthy summary, and usually contain several examples. I do object to the book jacket's use of the words "complete reference," which isn't possible in a 600-page book. Thus, I noticed that the Winsock in-depth discussion said nothing about what happens if, say, the <i>recv </i>buffer is smaller than the message size. So, I'd be reckless to try a real Winsock project without reading another source. Williams is honest about this. "You'll have to look in the Winsock specification to find out more," he says. I think that a similar statement would apply to all of the topics he tackles.</p><p>I have above-average or average knowledge of C and Windows. So, if I gained something, then so should average people. Well, I did learn something: That you can share memory between processes using DLLs. Also, though my eyes tend to glaze-over when confronted with heaps of C example code, I appreciate the CD-ROM and will doubtless find a use for it sometime. As far as I can tell, the book says little about new features that are specific to Windows 2000 (I wish there were margin notes like "this will not work with Windows 95," as in other books). I searched in vain for coverage of AWE and other issues that are supposed to be important features of the new operating system.</p><p>So, all things considered, it's a good book to borrow from the library and go through for a refresher about generic Windows systems programming issues. As a reference, it cannot match or replace what's in your online documentation if you have a professional edition of Visual C++ or C++ Builder. You should shell out $49.99 if &#151; and only if &#151; you're building up a large collection.</p><p> &#151; T.P.</p><p><b>DDJ</b></p></body></html>