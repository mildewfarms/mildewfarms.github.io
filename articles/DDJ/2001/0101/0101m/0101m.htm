<html><head><title>Jan01: Programmer's Toolchest</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>The Network  Query Language</h1><p><i>Dr. Dobb's Journal</i> January 2001</p><h2>A scripting language for rapid development  of intelligent agents and connected apps</h2><h3>By David Pallmann</h3><I>David is CTO of NQL Inc., developer of NQL, and author of Programming Bots, Spiders, and Intelligent Agents in MS Visual C++ (1999, Microsoft Press). He can be reached at dpallmann@nqli.com.</I><hr><p>If you're going to introduce a new programming language, you'd better have some pretty good reasons for doing so. I created the Network Query Language (NQL) out of necessity, after repeated disappointment with existing programming languages. It's not that Visual Basic, C++, Java, or Perl are flawed in some way, they're all fine languages. It's merely that our focus has shifted. Software development has a different emphasis today than it did five years ago. The Internet and corporate networks are now key ingredients in solutions, and the Web's influence has changed how we approach many tasks. For the most part, programming languages haven't adapted to this change in direction.</p><p>NQL was created with the new class of connected applications in mind &#151; intelligent agents, bots, spiders, middleware, and web apps. There are four essential ingredients in developing these applications: communications, conversion, automation, and intelligent behavior. Surprisingly, you'll find little or no direct support for these capabilities in today's programming languages. You almost always have to add support in the form of modules, classes, or components to get the job done. Even after doing so, code often ends up being overly long and complex. There's also an integration problem. Since add-ons are generally ignorant of each other's existence and nature, they need a lot of help from programmers to work cooperatively. Clearly, there is a problem here. Most languages in use today lack the right building blocks and the right granularity for today's development needs.</p><DDJADVERTISEMENT INLINE><h3>Learning a Lesson from the Past</h3><p>Fortunately, we've seen this exact suite of problems in the past, and can learn a lesson from one of the great success stories of the computer industrySQL. During the 1970s, the focus on databases brought to light weaknesses in the programming languages of the day. While adequate for many things, they simply were far from ideal for database work. Database programs took too long to write. The code required was unnecessarily lengthy. Each database vendor's product had a proprietary means of being accessed. The skill level required for database work was too high.</p><p>Structured Query Language (SQL) was a solution to the database programming problem. Lengthy code was replaced with short SQL queries. Database programming became much faster and simpler. Differences between database products were hidden behind a layer of abstraction, making it possible for companies to switch database vendors or even intermix them without concern. With SQL, a junior- level programmer could do more database programming than in the past. Despite its name, SQL became more than just a query language; it eventually became possible to perform database actions as well. The success of SQL can't be denied. More than 25 years later, we take it for granted.</p><p>We can draw an exact parallel between the database programming problems of yesteryear and network/Internet programming problems of today. The symptoms are the same. Today's situation cries out for a similar solution to SQL. NQL was created to be that solution. While NQL is not grammatically similar to SQL, it shares SQL's characteristics: Programs are short, code is easy to write and read, development is rapid, and even less experienced people can use it.</p><h3>Introducing NQL</h3><p>NQL is a scripting language for developing connected applications. It has building blocks for bots and agents, and a strong emphasis on communications, data conversion, automation, and intelligent behavior. NQL is currently available for Windows 98/NT/2000. A Java edition of NQL is nearing release, which is initially being qualified for Linux, Macintosh, and Solaris. NQL Inc. is also contemplating porting NQL to PDA platforms such as Palm and Windows CE. Trial versions of NQL are available at http://www.nqli.com/.</p><p><A NAME="rl1"><A HREF="#l1">Listing One</A> is a sample script that retrieves news articles from the CNN main page and outputs headlines and links as XML. I'll trace through the script line-by-line later on, but even at first glance you should find it easy to follow.</p><p>NQL stresses simplicity. Statement keywords are made up of words found in the dictionary. Odd punctuation is avoided. The syntax of the language is simple: one statement per line. If a statement requires multiple parameters, they are separated by commas. String constants are enclosed in single quotes (') or double quotes ("). Lines beginning with // are single-line comments. Multiline /* and */ comments can also be used as in C, C++, and Java. </p><p>Like most languages, NQL supports standard control-flow statements including <i>if</i>, <i>for</i>, and <i>while</i>. Curly braces are used to enclose statement blocks. One of the control-flow statements is <i>thread</i>, which executes a block of code in a separate thread of execution.</p><p>NQL variables are not strongly typed and may contain any kind of data. You can require variables to be declared or not, as you see fit, and you can choose from three kinds of error handling: program halt, executing error-trapping code, or ignoring errors altogether. In addition to variables, NQL can also hold data on a stack. The stack is what allows NQL's statements to interact with each other smoothly.</p><p>NQL supports a range of communications' built-in protocols: HTTP and HTTPS for web access; FTP for moving files; MAPI, POP3, and SMTP for sending and reading e-mail; ODBC, JDBC, OLEDB, and ADO for database access; NNTP for reading newsgroups; LDAP for accessing directory servers; SNMP for network monitoring; and TELNET for interacting with legacy systems. Communications in NQL is accomplished with a small set of statement keywords designed to logically fit together. Differences in protocols are hidden. For example, the method of reading MAPI e-mail and the method of reading POP3 e-mail is the same. <A NAME="rl2"><A HREF="#l2">Listing Two</A>(a) reads unread e-mail, while <A NAME="rl2"><A HREF="#l2">Listing Two</A>(b) reads through the articles in a newsgroup. Finally, <A NAME="rl2"><A HREF="#l2">Listing Two</A>(c) logs on to a Linux system and captures a directory listing.</p><p>NQL scripts can work with many kinds of information, including text, web pages, XML, and multimedia types. NQL's variables and stack can hold string or binary information of arbitrary size. NQL has particularly strong support for XML, with direct capabilities for reading, parsing, and writing XML.</p><p>Because connected applications frequently need to be automated, NQL includes features for scheduling. Scripts can be set to execute at a specific date and time, and to run again at regular intervals. Scripts code can wait for a specific time to arrive, wait for a specific interval to pass, or repeat execution of a code block at regular intervals. Scripts can declare time limits.</p><p>For intelligent behavior, NQL supports practical outpouring of AI research, including fuzzy logic and neural networks. The use of fuzzy logic can greatly improve the decision making of agents. NQL's fuzzy logic support includes language constructs for declaring condition evaluation functions and performing logical operations on fuzzy values. Neural networks have great application in predictive systems and pattern recognition. NQL makes it simple to create, train, save, and run neural networks, as <A NAME="rl3"><A HREF="#l3">Listing Three</A> illustrates.</p><p>Paradoxically, NQL's compactness of code is due in part to two notions borrowed from assembly language: stacks and condition codes. A stack is a list of values, kind of like a stack of dinner plates. A new value may be pushed onto the stack. The top value on the stack may be popped off of the stack. Unlike variables, which hold information by name, a stack can hold lots of information as a temporary holding area. For connected applications, stacks can be useful for recursive operations such as crawling web sites. NQL uses the stack as a way to let multiple statements work on the same piece of information.</p><p>NQL allows every statement to set a success or failure condition. For example, a pattern match statement results in a successful condition if a match is found, or a failed condition if a match is not found. Condition codes allow NQL's statements to be combined with control-flow statements in a compact way.</p><h3>Listing One: Line by Line</h3><p>Going back to <A NAME="rl1"><A HREF="#l1">Listing One</A>, in line 1, a <i>get</i> statement retrieves a web page. Where does the web page go? On the stack. Line 2 is a <i>match</i> statement that searches for its pattern in the top item on the stack, which just happens to be the HTML web page that was just retrieved. If the pattern match was successful, three things happen: The variable names in the pattern (<i>link</i> and <i>headline</i>) are set to values from the web page; the HTML on the stack is shortened in anticipation of more pattern matching; and a success condition is set. Line 3 is a <i>while</i> statement, which may look a bit odd since no condition is specified. This means that the success/failure condition (set by the previous statement) is what determines whether the block of code is executed. In the code block, line 5 contains an <i>output</i> statement, which outputs the variables <i>headline</i> and <i>link</i> as XML. Line 6 is a <i>nextmatch</i> statement, which repeats the previous pattern match &#151; this time, on the remainder HTML on the stack, which will find the next match. Like the <i>match</i> statement in line 2, <i>nextmatch</i> sets variables and a success condition if it finds another match, and will shorten the HTML on the stack again. Thus, the <i>while</i> loop continues as long as there are matches. That's a lot of explanation, but the code itself is quite small and fairly clear, even to someone who hasn't previously been exposed to NQL.</p><h3>The <i>match</i> Statement</h3><p>The action of the <i>match</i> statement deserves some explanation. The pattern includes HTML tags and text, but may also contain wildcards. Although an asterisk may be used to indicate a wildcard area, it is more common to specify a variable name enclosed in curly braces. When a match occurs, variables are created automatically with these names that contain data from the pattern match. This is called "automatic variable mapping." Database queries also utilize automatic variable mapping, as <A NAME="rl4"><A HREF="#l4">Listing Four</A> shows. For each record retrieved, the fields are moved into variables and are ready for immediate use.</p><p>NQL is designed to play a role wherever it is needed. An NQL script can run on the desktop, on a middleware system, on a server, or on a web server as a CGI application. You can also combine NQL with another programming language. Virtually all languages, including VB, ASP, C++, and Java, can call NQL as a component. This lets you continue using your preferred development tools and still tap into the power of NQL when you need it.</p><p>NQL can be used to drive web applications. NQL program code and HTML can be interspersed, just as is the case with ASP and JSP. In this context, NQL provides mobile device support for Palm VIIs, Internet-enabled smart phones, and Pocket PCs. NQL has built-in features for recognizing these devices and responding appropriately in their native content language. This means that a single NQL script can be accessed through a myriad of devices. NQL can also detect these devices' serial numbers, which is handy for mapping them to specific user IDs.</p><h3>Conclusion</h3><p>NQL was designed for same-day agent development, and it delivers on that promise. The built-in functionality, simple grammar, and compact design create a rapid development environment for realizing connected applications. </p><p></p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>get "http://www.cnn.com"match '&lt;li&gt;&lt;a href="{link}"&gt;{headline}&lt;/a&gt;'while{    output headline, link    nextmatch}</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4>(a)<pre>openmailfirstunreadwhile{    ...do something with mail message...    nextmessage}closemail(b)<pre>opennews "news.server.com", "alt.news.topic"firstarticlewhile{    ...do something with newsgroup article...    nextarticle}closenews(c)<pre>openterm "linuxserver2"waitterm "login:"sendterm "jsmith\r"waitterm "password:"sendterm "johnny\r"waitterm "$ "cleartermsendterm "ls -l\r"waittermquiet 2gettermcloseterm ...do something with captured session data...</pre><P><A HREF="#rl2">Back to Article</A></P><H4><A NAME="l3">Listing Three</H4><pre>///////////////////////////////////////////////////////////////////////////// Script name: geology// Description: Demonstrates use of a neural network in the area of geology.//           Given indirect measurements, determines lithology.//           Inputs:  Gamma Ray, Neutron, and Density.// Inputs:   Gamma Ray log value, Neutron log value, and Density log value// Outputs:  Identification (Shale, Dolomite, Limestone, Sandstone)// Notes:    The first time the script is run, the network will be created,//             trained, and saved (in geology.nnf). Thereafter, running the//             script will process input and generate output.//           The file required for training is geology.trn (text data file).//           The file required for processing is geology.inp (text data file).//           Results are output to the file geology.out (text data file).//////////////////////////////////////////////////////////////////////////////if this is the first time this script is being run,//create, train, and save the neural networklookup "geology.nnf"else{  setneural 0.45, 0.90  createneural "backprop", 3, 4, 4  trainneural "geology.trn"  saveneural "geology.nnf"  closeneural  show "Network has been created and saved. Run script again to process data."  end}//open previously saved neural network and run it against real dataopenneural "backprop", "geology.nnf"processneural "geology.inp", "geology.out"closeneuralshow "Network has been run against input data. Processing is complete."</pre><P><A HREF="#rl3">Back to Article</A></P><H4><A NAME="l4">Listing Four</H4><pre>opendb "customers"select "SELECT Customers WHERE BALANCE &gt; 0.00;"while{    show CustID, Company, Addr1, Addr2, City, State, Zip, Phone    nextrecord}</pre><P><A HREF="#rl4">Back to Article</A></P></body></html>