<html><head><title>Jan01: Making C Extensions More Pythonic</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Making C Extensions More Pythonic</h1><p><i>Dr. Dobb's Journal</i> January 2001</p><h2>An object-oriented wrapper for Python</h2><h3>By Andrew Dalke</h3><I>Andrew is a consultant in Santa Fe, New Mexico. He can be contacted at dalke@ acm.org.</I><hr><p>It is relatively easy to turn C libraries into Python extensions, especially with automatic interface generators like SWIG (see http://www.swig.org/ and "SWIG and Automated C/C++ Scripting Extensions," by David Beazley, <i>DDJ</i>, February 1998). However, viewed from Python, the new extensions still feel like C libraries because they don't take advantage of features such as automatic garbage collection, classes, and exceptions. Extension users are thus forced to write more code to deal with the mismatch between the two language styles. In this article, I'll present PyDaylight (http://starship.python.net/crew/dalke/PyDaylight/), an object-oriented wrapper for Python that provides the low-level interface to the underlying C libraries. Wrappers like this let you build more "Pythonic" interfaces to existing C libraries.</p><p>During the past couple of years, I have been working with the Daylight toolkit (http://www.daylight.com/). Broadly speaking, Daylight lets you model, store, and analyze chemical structures using a computer. The toolkit is a set of C libraries for different aspects of chemical informatics. As a rough, nonchemistry analogue, some of the libraries correspond to a string library, a regular expression package, display widgets, and database clients.</p><DDJADVERTISEMENT INLINE><p>The toolkit API is a set of function calls and compile-time constants. Internal data structures are only exposed through opaque integer valued handles. This design is similar to many other C libraries, such as file descriptors in the Standard C Library, so the methods I describe are widely applicable.</p><p>I started using Daylight when working at Bioreason (http://www.bioreason.com/), which uses the toolkit as one component of its chemical knowledge discovery and management system. We needed a flexible system for rapid development and testing of new algorithms. Since I had had good experiences using Tcl and Perl in previous projects, I wanted to use a very high-level language. I had also found that nondeveloper programmers &#151; physicists, biologists, and chemists who program &#151; usually didn't leverage the benefits of either language. The problem seemed to be the difficulty in describing complex data structures, especially as combined with Tcl's quoting rules or Perl's syntax. Python appeared to be a cleaner language, so we started experimenting with it. We were helped by Roger E. Critchlow, Jr., then working at Daylight, who had written DaySWIG (http://www.daylight.com/meetings/mug98/Critchlow/dayscript/title.html) &#151; a program that massages the library header files into a SWIG interface file, then creates the <i>dayswig_python.so</i> Python extension module.</p><h3>Automatic Garbage Collection</h3><p>Thinking that Roger had already done the hard work, I proceeded to write my first program using the <i>dayswig_python.so </i>module. It worked fine on my small test set, so I tried it on our full chemical library. After the disk started thrashing, I realized the extension module must be leaking memory because of a missing <i>dt_dealloc</i> callthe equivalent to <i>free</i> for Daylight's opaque handles.</p><p>Python has automatic garbage collection based on reference counting. When an object's count goes to 0, a special method named "<i>__del__</i>" is called. This hook let me write a wrapper object (see <A NAME="rl1"><A HREF="#l1">Listing One</A>), which stores the handle and calls <i>dt_dealloc</i> on the handle when the object is no longer referenced. The result is that Python manages toolkit handles, rather than you.</p><p>The <i>__del__</i> method is tricky in that it may be called during program termination, when the interpreter is cleaning up. Modules are removed in a somewhat arbitrary order, so the <i>dayswig_python</i> module may be cleaned up before the wrapper object. If that happens, accessing <i>dayswig_python.dt_dealloc</i> creates a <i>NameError</i> exception because <i>dt_dealloc</i> no longer exists. Instead, an extra reference to the function is stored as a default parameter in the argument list. The reference will only be removed after all instances of the class are deleted. Using default arguments this way is a common technique, especially for performance reasons, but is best left to functions like <i>__del__</i> that aren't part of the public interface. </p><p>PyDaylight is a Python package that builds on the shared library produced by DaySWIG. It uses a <i>smart_ptr </i>class similar to that in <A NAME="rl1"><A HREF="#l1">Listing One</A>, so that toolkit handles are deallocated automatically. The toolkit functions still expect an integer, not a wrapper object, so the <i>smart_ptr </i>also implements the special method named <i>__int__</i>, which Python uses for implicit integer conversion. In general, C libraries might use a pointer for the handle. SWIG converts these into specially formatted strings, so the proper coercion would use the <i>__str__ </i>method.</p><h3>Attributes</h3><p>The handles are identifiers for objects in the toolkit's data model, such as molecules, atoms, and bonds. Properties, like the charge of an atom, are normally found through function calls, as in <A NAME="rl2"><A HREF="#l2">Listing Two</A>(a).</p><p>Python supports object-oriented programming, so it's more natural to access properties as attributes; see <A NAME="rl2"><A HREF="#l2">Listing Two</A>(b). Using attributes instead of accessor methods may surprise you if you're used to C++ and Java, and expect to see methods such as <i>getCharge</i> and <i>setCharge</i>. Those two languages use methods to separate interface from implementation. Python supports a different mechanism based on the special methods <i>__getattr__</i> and <i>__setattr__</i>.</p><p>During attribute lookup, the Python runtime checks if the attribute exists in the instance or class namespaces. If that fails, and the <i>__getattr__</i> method exists, it is called with the attribute name as the sole parameter. The method can execute arbitrary code and either return the appropriate value or raise an <i>AttributeError</i> to signify that the attribute does not exist. For the rare case of a write-only property, it should raise a <i>TypeError</i>.</p><p>When setting an attribute, the run time first checks if the method <i>__setattr__</i> exists. If it doesn't, the default action puts the name and value into the instance's namespace, called <i>__dict__</i>. If it does exist, the method is called with two parameters: the attribute name and its new value. Again, the method can execute arbitrary code to set the value. Special attribute names are forwarded to toolkit functions, or if the attribute is read-only, <i>TypeError</i> is raised. If an attribute name isn't special, the new <i>__setattr__</i> method should implement the default action of adding the name and value into <i>__dict__</i>.</p><p><A NAME="rl2"><A HREF="#l2">Listing Two</A>(c) shows a simple <i>Atom</i> class to get and set the atom's charge, and get the atomic symbol. It is another wrapper, so it stores the handle and implements integer coercion with <i>__int__</i>, with a call to the <i>int</i> function in case the handle is actually a <i>smart_ptr</i>.</p><h3>Dispatch Table</h3><p>Having a list of <i>if/elif</i> statements for all of the attributes is cumbersome and causes a lookup time linear in the number of attributes. The toolkit accessor functions have the same functional form with the handle as the first parameter, and for setter functions, the new value as the second. Python allows polymorphic parameters and return values, so the accessors can be listed in a dispatch table based on the attribute name. A table item's value is the tuple of the getter and the setter. <A NAME="rl3"><A HREF="#l3">Listing Three</A>(a) also raises the expected <i>TypeError</i> exception for read-only properties. The extension to write-only properties, which do exist in the toolkit, is not shown but is straightforward.</p><p>If a derived class's <i>__getattr__</i> fails, it should normally call the <i>__getattr__</i> of its parents. Python method calls are somewhat expensive and should be minimized, especially as lookups often occur inside inner loops. All of the PyDaylight base classes use a dispatch table, so for performance, a derived class can merge the parent's dispatch table with its own; see <A NAME="rl3"><A HREF="#l3">Listing Three</A>(b). That isn't a pure object-oriented design, but it does give a noticeable performance increase and is hidden from external users.</p><p>The actual PyDaylight code is more complicated, but faster than the example. The dispatch table is converted at module import time into a getter list and a setter list, respectively, which removes the overhead of subindexing the <i>get_set</i> tuple. Those lists are passed as default arguments so they can be looked up in constant time instead of resolving <i>self_properties</i>. This requires that each class implement its own <i>__getattr__</i> and <i>__setattr__</i> instead of using the base class methods, but has the advantage of reducing call time as they can be found without doing a full traversal of the class hierarchy.</p><h3>Listing Available Attributes</h3><p>Python has an introspection command called "dir," which lists all of the attributes of an object. That function is useful in an interactive environment to see what attributes are available from an object. Most objects store their attributes in their <i>__dict__</i> dictionary so the list of variables is available by calling <i>__dict__keys()</i>.</p><p>The <i>__getattr__</i> and <i>__setattr__</i> methods expose new attributes on demand and will not be in the list of keys. To support this case, <i>dir</i> uses the list of keys then checks for two special variables &#151; <i>__members__</i> and <i>__methods__</i>. The first lists all additional attributes and the second lists any methods that are created dynamically. All three lists are combined to produce the list of available attributes.</p><p>Because all instances of a class have the same attributes, I often use a class variable to store the list of keys from the dispatch table, as shown twice in <A NAME="rl3"><A HREF="#l3">Listing Three</A>.</p><h3>Other Special Methods for Objects</h3><p>There are three other special methods you should know about when making wrapper objects. The first is <i>__cmp__</i>, which defines how two objects are compared. In PyDaylight, two objects are equal if their handles are the same, so the base <i>__cmp__</i> method simply compares their integer values. Watch out for equivalency, as it may cause some confusion because two different Python objects can be wrappers around the same toolkit object. Modifying the nontoolkit attributes of one object does not affect the other. This is a problem with almost any wrapper system.</p><p>Python has a key/value container called a "dictionary." Any object can be a key as long as it defines a constant hash value such that if two objects are equal, they have the same value. The value is returned via the special method named <i>__hash__</i>. Toolkit handles have the right properties, so they are used as the hash values in the wrapper objects. If your library uses SWIG-style string encoded pointers, the built-in function <i>hash</i> can be used to return the string's hash value.</p><p>The final special method is <i>__nonzero__</i>, which is used in a Boolean context to tell if an object is True or False; for instance, if x: print "true." Objects are normally considered True unless <i>__nonzero__</i> exists and returns 0 or <i>__len__</i> exists and returns 0. </p><p>Even if your objects are always True, <i>__nonzero__</i> should be defined since lookup failure has the overhead of calling <i>__getattr__</i> to see if the method is created dynamically. During performance tuning, it's helpful to print <i>__getattr__</i> failures to see if there are extra lookups for special methods like these.</p><h3>Ownership and Lifetime</h3><p>In the toolkit data model, atoms are part of a molecule. Their handles are not stored in a <i>smart_ptr</i> object because their lifetime is determined by the molecule containing them. Molecule handles are different. In some cases, they are independent objects and need to be reference counted. In other cases, they are part of another object, called a "reaction," which determines their lifetimes. (Reactions contain reactant, agent, and product molecules.) The implementation difference is the handle passed to the molecule's constructor. In the first case it is a <i>smart_ptr</i> while in the second it is just the integer handle.</p><p>Ownership rules cause some complications with SMARTS match objects. A SMARTS pattern is to chemical graphs like a regular expression is to a string. It defines a subgraph that may match one or more parts of a compound. Each match, called a "path," can be queried to identify which atoms and bonds were part of the SMARTS pattern. Paths allocate new memory so a <i>smart_ptr</i> object is used to ensure proper garbage collection.</p><p>The path contains references to part of a molecule. If that molecule is deleted, the path is invalid and the toolkit automatically deletes it. The Python <i>smart_ptr</i> object doesn't know about this toolkit relationship. When the <i>smart_ptr</i> finally goes out of scope, it will try to delete the already deleted handle, and fail.</p><p>The Python class wrapper for the path data type knows how to enforce the dependency. The <i>Path</i> object stores the path handle and the molecule used when creating the match. Because instance variables, during cleanup, are normally removed in arbitrary order, <i>Path</i> objects define a <i>__del__</i> method; see <A NAME="rl4"><A HREF="#l4">Listing Four</A>, which removes the path handle first and then the molecule. This guarantees that the molecule will always exist longer than any match using that molecule.</p><h3>Lists and Iterators</h3><p>The toolkit has two types of list containers &#151; a stream and a sequence. Each is both a container and a single associated forward iterator. The difference is the container for a stream is owned by another toolkit object (for example, a list of atoms in a molecule), while the container for a sequence is owned by the caller.</p><p>The two lists allocate some memory, so they must be held by a reference counted object. A stream only owns its iterator so it can be held by a <i>smart_ptr</i>. A sequence may also own all of the data in the container, depending on the context. If the sequence does own its data, the elements must be deleted when the sequence is finished.</p><p>This calls for a new type of smart wrapper, which I call a "smart_list." It is identical to the <i>smart_ptr</i> except for the <i>__del__</i> method. This resets the sequence iterator then traverses the list, deallocating as it goes. When finished, it deallocates the sequence handle.</p><p>Python has its own list container with a different interface than streams or sequences. The easiest way to make toolkit lists work like Python lists is to copy each element into a new Python list; see <A NAME="rl5"><A HREF="#l5">Listing Five</A>. Since the items are usually object handles, the copy routine takes an optional converter function, which will likely be a class constructor.</p><p>Copying works best if the lists are small and there is no need for list modifications to affect the original stream. If those conditions don't hold, you need a class that implements the Python list behavior and translates it to the underlying toolkit calls. The description of list behavior is fully described in the Python documentation.</p><p>PyDaylight doesn't need the full behavior, only a list wrapper for iteration through streams and sequences. Classes can implement iteration by defining a <i>__getitem__</i> method, which takes the integer offset as its parameter. Python assumes lists are random access while the toolkit lists only offer forward iteration. Random access can be emulated by resetting the iterator and seeking forward to the right position, but this leads to unexpected performance characteristics such as order <i>N</i>**2 reverse traversal, so my interface tracks the current position and raises an exception if anything other than forward access is tried; see <A NAME="rl6"><A HREF="#l6">Listing Six</A>. Just like the list copy function, the list iterator takes an optional conversion function to turn toolkit handles into their wrapped form.</p><p>The class also implements a method named "next," which returns the next object from the list. This is not part of Python's list interface, but is a common idiom for forward iterators. It returns a <i>None</i> object at the end of the list rather than raising an exception.</p><p>It's helpful to know the size of the list.  A list class can make this known by implementing the <i>__len__</i> method. An empty list is considered to be False when in a Boolean context, so the <i>__nonzero__</i> method can be identical to the <i>__len__</i> method.</p><h3>Exceptions</h3><p>As with most C libraries, the Daylight library returns errors via out-of-range values and the corresponding error message via a global function. From long experience, few people check the return values of every function call, so errors have a tendency to hide and pop up unexpectedly elsewhere.</p><p>The problem arises because errors in C are implicitly ignored, which is usually the wrong action. Instead, most of PyDaylight checks the return values and raises an exception if there are any problems. The exception contains the relevant message from the global error function, which helps with debugging and diagnostics.</p><p>Checking every function return value does have some overhead because there are cases where it isn't needed. For those rare performance-critical regions of code, I bypass PyDaylight entirely and call the underlying toolkit calls directly.</p><p>Several classes of errors don't even need to be checked because Python ensures they will never occur. Some toolkit errors occur because the wrong object type was passed to a function. For example, <i>dt_ charge</i> takes an atom handle and passing it any other handle returns an error value. PyDaylight only calls <i>dt_charge</i> for <i>Atom</i> objects so it can never pass in the wrong data type. There is no need to check for an error.</p><h3>Conclusion</h3><p>PyDaylight improves upon the Daylight toolkit API by presenting it in a more modern form. Developers who have tried it find it much easier to use than the standard API, so people are able to get much more work done in less time. The techniques I used are appropriate for many other C libraries, and I hope they will be useful to you in migrating existing code to Python. Finally, I've also included a test suite (available electronically; see "Resource Center, page 5) for the code presented here. The test suite assumes you are working on a UNIX-based system and Python is in your path. To test the examples, simply enter "make test." If everything works correctly, the last line printed should read, "All tests passed successfully."</p><p></p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre># Wrapper object to garbage collect the toolkit handle when no longerneeded.import dayswig_pythonclass smart_ptr:    def __init__(self, handle):        self.handle = handle    def __del__(self, dt_dealloc = dayswig_python.dt_dealloc):        dt_dealloc(self.handle)    def __int__(self):        return self.handle</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>#  Getting and setting an atom's charge using (a) toolkit function callsand # (b) attributes. (C) shows how attributes are converted to function calls.# Part (a)print "The charge is", dt_charge(atom)dt_setcharge(atom, 1)# Part (b)print "The charge is", atom.chargeatom.charge = 1# Part (c)class Atom:    def __init__(self, handle):        self.handle = handle    def __int__(self):        return int(self.handle)    def __getattr__(self, name):        if name == "charge":            return dt_charge(self.handle)        elif name == "symbol":            return dt_symbol(self.handle)        raise AttributeError, name    def __setattr__(self, name, val):        if name == "charge":            dt_setcharge(self.handle, val)        elif name == "symbol":            raise TypeError, "readonly attribute"        else:            self.__dict__[name] = val</pre><P><A HREF="#rl2">Back to Article</A></P><H4><A NAME="l3">Listing Three</H4><pre>#  (a) Part of the dispatch table used in PyDaylight's base class.#  (b) A derived class which adds atom-specific attributes.# Part (a)dayobject_properties = {   "type": (dt_type, None),   "typename": (dt_typename, None),   "stringvalue": (dt_stringvalue, dt_setstringvalue),}class dayobject:    __members__ = dayobject_properties.keys()    _properties = dayobject_properties    def __init__(self, handle):        self.handle = handle        return int(self.handle)    def __getattr__(self, name):        get_set = self._properties.get(name, None)        if get_set is None:            raise AttributeError, name        return get_set[0](self.handle)    def __setattr__(self, name, val):        get_set = self._properties.get(name, None)        if get_set is None:            self.__dict__[name] = val        else:            set = get_set[1]            if set is None:                raise TypeError, "readonly attribute"            set(self.handle, val)# Part (b)atom_properties = dayobject_properties.copy()atom_properties.update( {    "charge": (dt_charge, dt_setcharge),    "symbol": (dt_symbol, None),    "weight": (dt_weight, dt_setweight),})class Atom(dayobject):    __members__ = atom_properties.keys()    _properties = atom_properties</pre><P><A HREF="#rl3">Back to Article</A></P><H4><A NAME="l4">Listing Four</H4><pre>#  Enforcing a toolkit dependency by deleting dependent objects first.class Path(dayobject):    def __init__(self, path, mol):        self.handle = path        self.mol = mol        #  .. more initialization code ..    def __del__(self):        del self.handle        del self.mol</pre><P><A HREF="#rl4">Back to Article</A></P><H4><A NAME="l5">Listing Five</H4><pre>#   Converting from toolkit streams and sequences to a Python list.def toList(seq, converter = None):    if not seq:        return []    dt_reset(seq)    result = []    while 1:        element = dt_next(seq)        if not element:            return result        if converter:            result.append(converter(element))        else:            result.append(element)</pre><P><A HREF="#rl5">Back to Article</A></P><H4><A NAME="l6">Listing Six</H4><pre>#  A list-like class for forward iteration through toolkit streams.class Iterator:    def __init__(self, handle, converter = None):        self.handle = handle        self._i = 0        self.converter = converter    def __len__(self):        return dt_count(self.handle, TYP_ANY)    __nonzero__ = __len__    def __getitem__(self, i):        if i != self._i:            raise IndexError, "forward iteration only"        element = dt_next(self.handle)        if not element:            raise IndexError, "list index out of range"        self._i = i + 1        if self.converter:             return self.converter(element)        return element    def next(self):        try:            return self.__getitem__(self._i)        except IndexError:            return None</pre><P><A HREF="#rl6">Back to Article</A></P></body></html>