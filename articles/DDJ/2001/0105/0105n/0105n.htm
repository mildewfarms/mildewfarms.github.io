<html><head><title>May01: Java Q&A</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>How Can I Simplify Java Data Access Objects?</h1><p><i>Dr. Dobb's Journal</i> May 2001</p><h3>By Terry Smith</h3><I>Terry develops enterprise banking solutions as a technical lead at Alltel Information Services in Little Rock, AR. He can be reached at terry.smith@alltel.com.</I><hr><a name="rs1"><a href="0105ns1.htm">Making a Statement with JDBC</a><hr><p>Writing a data access object (DAO) from scratch in Java can be a daunting task. More often than not, the result is a pile of dirty, down-in-the-trenches JDBC code that programmers prefer to run from &#151; rather than run on &#151; their machines. Then add 300-plus tables for an enterprise system &#151; each of which needs its own data object &#151; and the result is a nightmare. This is usually the point where a code generator is brought in. Whether a third-party or in-house tool is used, the outcome is invariably an even larger mountain of dirty, unreadable code that everyone avoids.</p><p>In this article, I explain the design decisions I made in constructing a DAO. I then present a method of encapsulating the DAO using support wrappers for Java's <i>PreparedStatement</i> and <i>ResultSet</i> objects. (The entire source code and related files for the DAO are available electronically; see "Resource Center," page 5.) Using them results in maintainable, clean code that makes writing a DAO a breeze. </p><DDJADVERTISEMENT INLINE><h3>Creating a Table</h3><p>The first step to writing a DAO is to have a database table. (Without a database table you can waste trillions of man-hours wondering why your object doesn't work.) Here I use a table called "Member" for storing registered members of an online community; see <A NAME="re1"><A HREF="0105ne1.htm">Example 1</A>. This table covers the basic data types used in most applications. The support classes are easily extendable. The primary key for Member is <i>MemberID</i>, a unique number generated in code. Both the <i>VARCHAR2</i> and <i>CHAR</i> string data types are represented. The <i>EmailBouncing </i>column is useful for flagging members who may have recently changed e-mail addresses. Oracle is the database I use here, and as typical with Oracle schemas, a <i>CHAR(1)</i> field with values of <i>T</i> and <i>F</i> is used to define a Boolean type. I also use Oracle's <i>Date</i> type to store the member's registration date. </p><h3>The DAO Interface</h3><p>For simplicity, my access object is a bean, but not a full-fledged Enterprise JavaBean (EJB). This doesn't mean that the data access code for an EJB is more complex. Rather, an EJB introduces details that are not of concern here. For example, my <i>insert</i> method has a method signature of <i>boolean create(StringBuffer ErrorMessages)</i> and returns False on failure; whereas, in EJB it would be <i>void ejbCreate</i> and throw an EJB exception on failure. With minor tweaks, everything presented here is easily transferable to EJBs.</p><p>The <i>Member</i> class begins with private member variables and public accessors and mutators. For the <i>MemberID</i> property, I use the <i>Long</i> wrapper class instead of the primitive <i>long</i> Java type, because its utility methods are useful for clients of the <i>Member</i> class. For the <i>EmailBouncing</i> property I use the <i>boolean</i> primitive type instead of the <i>Boolean</i> wrapper because the <i>Boolean</i> type offers little in terms of usefulness due to its limited number of methods. Of course, these choices are a matter of personal preference. <i>RegistrationDate</i> is exposed as a <i>java.util.Date.</i> It's important for clarity to fully qualify the package name, because there is also a <i>java.sql.Date</i> class. </p><p>With the addition of a constructor, the class now resembles Listing One(available electronically; see "Resource Center"). The constructor initializes <i>MemberID</i> to a unique <i>Long</i> by using <i>System.currentTimeMillis(),</i> which returns the number of milliseconds since midnight, January 1, 1970. In a distributed application with web servers hitting a single database server, you want to append the web server's IP address as well as other fields to guarantee a unique identifier. To keep things simple, I'm overlooking these details. I made <i>MemberID </i>a<i> NUMBER(14)</i> in the table. The <i>currentTimeMillis()</i> method currently returns a 12-digit number, but on Saturday, September 8, 2001 at 8:46:40 pm it rolls over and increases to a 13-digit number. Although I'm not superstitious, I'd rather add an extra digit and make the column a <i>NUMBER(14)</i> instead of 13. Then I can rest safe and sound until the year 5138.</p><p>With the basic class skeleton in place and without going further, it is time to write the test code. The first step is to override the <i>toString()</i> method inherited from <i>java.lang.Object</i>. This method should return a string that reflects the object's current state. Every Java class should override this method to aid debugging and testing. I've written <i>Member::toString()</i> so the call <i>System.out.println( memberInstance );</i> results in the output in <A NAME="re2"><A HREF="0105ne2.htm">Example 2</A> if called immediately after object creation.</p><p>Next is the actual test program. Every DAO test class should, at a minimum, insert a test row, find it again, update it, and then delete it. I could easily do this following my own conventions for checking return codes, displaying errors, and the like. Instead, my <i>MemberTester</i> class uses the JUnit testing framework. Written by industry-heavyweights Eric Gamma and Kent Beck, it is rapidly becoming the most popular unit testing tool for Java. A more detailed discussion of JUnit is beyond the scope of this article, but please refer to the MemberTester code available electronically and at http://www.JUnit.org/.</p><h3>Creating A <i>PreparedStatement</i></h3><p>Now it's time to get into the real code &#151; the JDBC calls. I begin with the <i>create()</i> method for inserting a new row into the table. The first step is to obtain a database connection. Every development project seems to obtain the database connection differently. Sometimes it's passed into the DAO method. In other cases, it is a single <i>Connection</i> instance or a connection pool object retrieved from either the <i>ServletContext</i> or the <i>EJBContext</i>. To avoid tying the examples presented here to the <i>ServletContext</i> or <i>EJBContext</i>, I'm using a basic <i>ConnectionPool</i> class. It implements the singleton pattern by exposing a static method for obtaining a single, shared instance. The details for writing a <i>ConnectionPool</i> are beyond the scope of this article, but nearly every book on Java server programming has its own implementation of one. I'm using one largely based on that presented in Marty Hall's <i>Core Servlets and Java Server Pages</i> (Prentice Hall, 2000) because it is one of the best I've seen. Retrieving a connection is straightforward:</p><blockquote><p>DBConnectionPool dbConnectionPool =</p><p>   DBConnectionPool.getInstance();</p><p>Connection dbConnection = dbConnection-		Pool.getConnection();</p></blockquote><p>Next is the process of constructing the database statement. Of the three statement types available in JDBC, I use prepared statements for executing the SQL statements, but not for the typical efficiency reasons. (For more on JDBC statements see the accompanying text box entitled "Make a Statement with JDBC.") A <i>PreparedStatement</i> is normally preferred when executing the same SQL statement "definition" multiple times, each time changing its parameters. With DAOs, however, it is rare to execute the same statement multiple times in such a manner. Normally one is created, used once, and destroyed within a single method call. Even in the case of <i>findXxx</i> methods, which return a collection, a single select is usually executed and followed by looping through the result set to build up the collection instead of making multiple selects. Nevertheless, a <i>PreparedStatement </i>still has advantages. First, building a SQL statement by setting the parameters one at a time is easier than concatenating a dynamic SQL statement. Prepared statements also take care of some of the irritating details for you that must be specially handled when building up dynamic SQL. For example, if a user's name includes a single quote ("O'Donnell," for example) and you try to concatenate that into your SQL in the following manner: <i>SQLStringBuffer.append(""" + m_First Name + ''', ");</i>, the SQL statement will fail due to syntax error. With Oracle, the same applies to an ampersand, which Oracle interprets as an escape character. Ampersands must be converted to "^&amp;." However, prepared statements will handle all of this for you. <A NAME="re3"><A HREF="0105ne3.htm">Example 3</A>(a) demonstrates constructing a prepared statement to insert into the Member table. </p><p>With the template constructed, the next step is to set the values for the placeholders. <A NAME="re3"><A HREF="0105ne3.htm">Example 3</A>(b) shows the typical JDBC code for setting a <i>Long</i> on a prepared statement. The code lets the <i>Long</i> attribute be null and results in a NULL value in the database instead of a zero. In this case, <i>MemberID</i> should never be null since it is the primary key for the table, but coding for the possibility allows for the creation of a reusable code block that can be moved into a support routine later. Listing Two (available electronically) shows the complete code for the <i>create()</i> method. Strings are handled like <i>long</i>s. For strings, the code passes <i>java.sql.Types.CHAR</i> to <i>Statement.setNull </i>on both <i>CHAR</i> and <i>VARCHAR2</i> database fields. There is a <i>java.sql.Types.VARCHAR </i>type, but passing <i>java.sql.Types.CHAR</i> in both instances will not affect the outcome (NULL is NULL after all). Doing so allows yet another reusable code block to be constructed. This one provides the additional benefit of encapsulating the code from the exact SQL string types used in the database. Next, the Boolean type <i>m_EmailBouncing</i> must be converted to either "Y" or "N" strings before insertion. The <i>Utilities.booleanToString</i> method takes care of the conversion. </p><p>Storing date types is an even more interesting problem. After a brief glance at the JDBC APIs, your first guess might be to convert the <i>java.util.Date</i> type of <i>RegistrationDate </i>into a <i>java.sql.Date </i>and then pass it to <i>PreparedStatement.setDate()</i>. You might be surprised to learn that <i>setDate()</i> only stores the date and not the time. (Similarly, <i>setTime()</i> only stores the time.) However, Oracle's <i>Date</i> type can store the date and the time in a single field. The best solution seems to be the <i>setTimestamp</i> method. Although it is designed to map to the TIMESTAMP SQL type, Oracle does not implement this type, relying solely on its <i>Date</i> type to store both the date and the time. Using <i>setTimestamp()</i> with an Oracle <i>Date</i> works perfectly. By calling <i>m_RegistrationDate'</i>s<i> getTime()</i>, the number of milliseconds since January 1, 1970 can be retrieved. This value is passed to the constructor of a <i>java.sql.Timestamp</i> instance, which in turn is passed to <i>setTimestamp()</i>.</p><h3>Reading From a <i>ResultSet</i></h3><p>With the <i>create()</i> method complete, the same code blocks used to set different data types into a <i>PreparedStatement</i> can be used in the <i>update()/delete()</i> methods, as well as on the select for the <i>findByEmail()</i> method. When reading values from the <i>ResultSet</i> in <i>findByEmail()</i>, you might think that a mirror image of <i>create()</i> can be performed just by replacing the <i>setXxx() </i>methods with <i>getXxx()</i> methods. Unfortunately, this doesn't work as you might expect. </p><p>The problem involves reading database NULL values with JDBC. <i>ResultSet.getInt() </i>returns zero if the value read was a database NULL. There are at least three possible solutions to this problem. The first possibility is to call the <i>wasNull()</i> method on the <i>ResultSet</i> after reading the data into a temporary variable. If it returns True, then the last value read was null, and you can set the <i>Integer</i> attribute to null. Otherwise, an <i>Integer</i> can be created using the temporary <i>int</i>. The second alternative is to use one of the <i>getBigDecimal</i> methods. The method with signature <i>getBigDecimal(int columnIndex, int scale)</i> is deprecated, and <i>getBigDecimal(int columnIndex)</i> is new with JDBC 2.0. The third solution is to use the <i>getObject()</i> method. If a column is null, <i>getObject()</i> always returns null. JDBC maps every data type in the SQL-92 standard to a <i>Java</i> data type. The <i>SQL NUMERIC</i> type (<i>NUMBER</i> in Oracle) maps to <i>java.math.BigDecimal</i>. Thus, the return value of <i>getObject()</i> is cast and stored into a variable of type <i>BigDecimal</i> using this solution. </p><p>Any of these styles (and I'm sure there are others) are valid and any one of them may be the best fit with your requirements. In this article I have chosen the third technique of using <i>getObject()</i>. Not wanting to tie myself to using JDBC 2.0 or higher drivers, I discarded the option of using <i>getBigDecimal</i>. (By the time you read this article, the number and variety of JDBC 2.0 drivers will have likely reached the saturation point and dismissed this as a concern.) Another consideration was consistency. In some implementations, when reading strings from a result set, <i>getString()</i> returns the empty string if a column is null. However, <i>getObject()</i> always returns null if a column is null. This may not be as much of a problem now as it was in the earlier days of JDBC, but using <i>getObject()</i> appears to be the safest method all around. Since I use <i>getObject()</i> for <i>Strings</i>, I use it for <i>Integers</i> also.</p><h3>The <i>EasyStatement</i> Wrapper</h3><p>With the basic code in place for using a <i>PreparedStatement </i>and reading from a <i>ResultSet</i>, a quick code review is in order. Listings Two and Three (both available electronically) point out a few glaring problems. First, the code is too long and complicated, especially for a table with only seven columns. Second, the common code blocks such as how to read and write a string to the database are repeated in code instead of being properly placed in support routines. Support routines would also solve another problem. Imagine if the DAOs for 300 tables were written like Listings Two and Three. Then, the decision is made to use <i>getBigDecimal()</i> for reading <i>long</i>s as described earlier. Search and replace you say? Did I mention that a dozen or more developers wrote the code for the various 300 data access objects?</p><p>What is needed is a wrapper object for <i>PreparedStatement</i> that will hide the implementation details. <i>EasyStatement</i> is just such an object; see Listing Four (available electronically). <i>EasyStatement</i> has only one constructor, and it takes a <i>Connection</i> object as the only parameter. Then the object's client calls <i>setSQL(String SQL), </i>at which point <i>EasyStatement</i> creates its internal <i>PreparedStatement</i> instance. It also sets its <i>internal m_ColumnIndex </i>variable to one. Having the column index handled internally by <i>EasyStatement</i> is very convenient. Then the client calls one of the overloaded <i>write(...)</i> methods. At this point, the client doesn't even need to know what data types are being set in the <i>PreparedStatement</i> nor how each of them needs to be handled. This has all been encapsulated away. Next, the client only needs to call either <i>executeUpdate</i> or <i>executeQuery</i>. All of this is demonstrated in the new code for the <i>create()</i> method in Listing Five (available electronically). It is important to note that <i>EasyStatement</i> does not commit or rollback the transaction. That is left to the DAO object because commit and rollback are logically tied to the connection, not to the statement.</p><h3>The <i>EasyResultSet</i> Wrapper</h3><p>The <i>executeUpdate</i> method on <i>EasyStatement</i> returns the number of rows affected by the update as would be expected; however, <i>executeQuery</i> returns an <i>EasyResultSet</i> instead of a normal <i>ResultSet</i>. <i>EasyResultSet</i> is as simple as <i>EasyStatement</i> (see Listing Six, available electronically). It encapsulates an internal <i>ResultSet </i>object and exposes <i>next()</i> and <i>close()</i> methods that are straight pass-throughs to that record set. Unlike <i>EasyStatement</i>, however, it does not have the benefit of method overloading. Instead, the client must call one of the <i>readString()</i>, <i>readInteger()</i>, <i>readLong()</i>, <i>readDate()</i>, or <i>readBoolean()</i> methods. Compared to Listing Three, it is not too much to ask for the results demonstrated in Listing Seven (also available electronically). </p><h3>Conclusion</h3><p>The <i>EasyStatement</i> and <i>EasyResultSet </i>wrappers can dramatically simplify data access code. They do so through simple applications of encapsulation. Their design pattern is easily extensible to other data types you may need to handle such as BLOBs, CLOBs, and the like. Using them will save you time, clean up your code, and make future enhancements easier.</p><p></p><p><b>DDJ</b></p></body></html>