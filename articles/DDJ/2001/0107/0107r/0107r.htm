<html><head><title>Jul01: Letters</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Letters</h1><p><i>Dr. Dobb's Journal</i> July 2001</p><h3><b>Open Source Cobol</h3><p>Dear <i>DDJ</i>,</b></p> <p>"News and Views" (<i>DDJ</i>, May 2001) correctly referenced TinyCobol (<a href="http://tiny-cobol.sourceforge.net/">http://tiny-cobol.sourceforge.net/</a>) as an open-source project creating a free Cobol compiler. There is another such project making good progress, called CobolforGCC (<a href="http://cobolforgcc.sourceforge.net/">http://cobolforgcc.sourceforge.net/</a>). The TinyCobol team, headed by Rildo Pragana, aimed for usability in the near term and they have succeeded! Development continues but the product is usable now. CobolforGCC, headed by Tim Josling, is concentrating on strict standards and completeness, with extensions as needed. It will be a few more months before it can be put to use in the field. <p>Steven Ellis</p><p>soellis@soltec.net</p><h3><b>Setting the Debian Record Straight</h3><p>Dear <i>DDJ</i>,</b></p><p>If Richard Stallman is concerned about widespread confusion, he has only himself to blame. In his April 2001 letter, he continues his crusade to rename an operating system. The proper name for a Linux distribution is whatever the creators wish to name it. But neither Richard Stallman nor Linus Torvalds created any Linux-based operating systems. That distinction goes to the other pioneers, those that actually took the available system components and wove them together into a whole operating system. Debian chooses to call their distribution "GNU/Linux." But most others choose to call theirs just plain "Linux." Home Depot doesn't get to name my kitchen extension and neither does Richard get to name the operating system built only partially from his components.</p><p>His claim that "GNU/Linux" is really the GNU System with a different kernel is preposterous. The goal of completing a free operating system was not accomplished by the GNU project. GNU released some excellent operating-system components, but it never released a finished operating system in any form. My current Linux OS is as much dependent upon components released by BSD, XFree86, Perl, and other projects as it is upon GNU components. Richard Stallman's current quest to rename Linux as "GNU/Linux" is as flawed as his earlier quest to rename it "LiGNuX."</p><p>But Richard was not content on naming semantics in his letter. He proceeded to distance himself and the Free Software Foundation from the Open Source community. As much as he might not like it, his foundation's software and licenses are indeed Open Source Software. He has long stated that he wished the English language had a more precise word than "free" for the idea he was trying to express. The English language does have a better word. That word is "open." The term "Open Source Software" more accurately describes GNU software than does the term "Free Software," and is less apt to be confused with other types of software, such as closed-source freeware and shareware.</p><p>Richard is correct, though, that there is a difference in philosophies between the Open Source and Free Software movements. Richard has a unique and particular philosophy of software, so he should not be dismayed when others don't volunteer to bang his drums.</p><p>David Johnson</p><p>david@usermode.org</p><h3><b>Back To Basics</h3><p>Dear <i>DDJ</i>, </b></p><p>I have some comments about DDJ's May 2001 issue. I'm not sure what was meant by Michael Swaine's "Programming Paradigms" column entitled "Roll Over, Kemeny and Kurtz." Was he suggesting that Kemeny roll over in his grave? (Kurtz is still teaching at Dartmouth, I believe). Michael's references to the history of the Basic language, are a bit "basic."</p><p>Given the roots of <i>DDJ</i>, you take a closer look at what Kemeny and Kurtz really gave to the computing world. First, Kemeny and Kurtz developed the first practical time-sharing system at Dartmouth in 1963 and the Basic programming language in 1964. Michael's statement that the "Basics of 1976 were clearly the same language" is true in one sense, but vastly wrong in another. The Dartmouth Basic was a compiled language that supported separately compiled subroutines and libraries, programmer-defined functions with their own variable name spaces, high level matrix math statements and many other capabilities. The 1976 era versions of Basic that you refer to were highly "de-featured."</p><p>In the early 1980s, Kemeny and Kurtz (and others) created True Basic, a language that is more similar to the REALBasic of 2001 than the others shown (no line numbers, long variable names, and so on). True Basic is still around today, but was never a big commercial success.</p><p>I would hope that the computing world remembers Kemeny as more than a side note in computing history. Kemeny worked for Richard Feynman on the Manhattan Project, along with John von Neumann. He later was the mathematics research assistant to Albert Einstein (because, as he said, Einstein wasn't very good at math). As a mathematics teacher he was, reportedly, brilliant and he later became the President of Dartmouth. He truly realized his dream of making computing easy enough to learn for even liberal arts undergraduates many years before the rest of the academic world and long before PCs.</p><p>Elsewhere in the same issue, <i>DDJ</i> awarded the 2001 Excellence in Programming Award to Anders Hejlsberg. This is a well-deserved award, and Turbo Pascal was a truly innovative product for its time. However, Kemeny and Kurtz, almost 20 years prior, I believe, deserved the recognition for creating the first integrated development environment. True, it did not have a full screen editor (in 1964 110-baud yellow-paper teletypes were the norm). However, the Dartmouth Time Sharing System and Basic programming language were every bit as integrated as Turbo Pascal. The same "Ready" command prompt allowed editing, viewing, running, and debugging of software. As a matter of fact, it was more "integrated" than Turbo Pascal ever was, since the OS prompt was one and the same with the language prompt (other integrated languages were also available). The RUN command started the compiler, linking was automatic, and the program execution followed, all automatically. It is too bad that most/all "copies" of the original Dartmouth Basic did not copy this well-thought out ease of use and integration, instead just copying the syntax of the language.</p><p>Mike Schmit</p><p>mschmit@ix.netcom.com</p><h3><b>Load Testing Web Sites</h3><p>Dear <i>DDJ</i>, </b></p><p>Thanks [for the] mention in the article "Load Testing Web Sites" (<i>DDJ</i>, March 2001). I'd like to add a note [to] Segue's SilkPerformer. There are actually two ways to control the number of users during a test: 1. Dynamic workload model. You can increase or decrease the number of VUs manually in any increment you wish. If you do not change the number, then the workload operates just like a steady state model with a constant number of users. Duration of this test is not specified in advance. 2. Increasing workload model. You decide on a specified increment you want your user load to increase by within a timeframe.</p><p>Jenny Jones</p><p>jjones@segue.com</p><h3><b>Open Source Hat Tricks</h3><p>Dear <i>DDJ</i>, </b></p><p>In a recent column (<i>DDJ</i>, May 2001), Al Stevens mentioned Eric Raymond's party trick of asking a room of developers how many people are paid to write software, and how many of those are paid salaries that are dependent on the "sale value" of that software. Presumably, this is meant to indicate that salaries are independent of the sales price of the software in question, and that even if the company gives their software away (that is, follows the guidelines laid down by the Open Source gang), the developers will still get paid.</p><p>Might I suggest that Eric take a slightly different tactic in future? He might instead ask how many salaried software developers work on projects [that] have budgets based on the sales value of the software they work on. And at the same time, he might ask whether or not this constrains the project's resources, time to market, and/or feature set. The money to pay those salaries has to come from somewhere—and sure, giving that software away might not do anything to an individual developer's salary, but it sure as hell will impact the number of developers a company will pay to work on a project—and even whether or not work on that project gets started at all.</p><p>Sure, it's not the Star Trek style utopian society that Eric appears to live in, but cash to pay for bills has to come from somewhere. Playing semantic parlor tricks is all well and good, and if people fall for it, so be it. But a little intellectual honesty would appear to be appropriate.</p><p>Simon Cooke</p><p>simoncooke@earthlink.net</p><h3><b>KDE Insider</h3><p>Dear <i>DDJ</i>, </b></p><p>I read Al Stevens's column (<i>DDJ</i>, March 2001) and saw that he has started dabbling in KDE. Excellent! I'm glad to hear that he thinks KDE is a very professional toolkit as that is one of our design goals. Many thanks for Al's comments.</p><p>I have spent more time looking at the KDE development stuff. I am disappointed that the class library does not use new-style casts, namespaces, STL, and so on. If there were good reasons for that decision earlier (absence of compliant compilers) those deficiencies should be removed by now.</p><p>Yes, this comes up every now and then. But given our goals, this is very difficult to achieve. The single biggest problem is that KDE is not just for Linux. KDE also is available for Solaris, HP-UX, AIX, all the BSDs, True64, and pretty much every other UNIX variant. As a result, we need to have a feature set that works on all of the various compilers. Unfortunately, while gcc 2.95.x works reasonably well, there are still a number of compilers (Solaris CC and HP-UX in particular) [that] have given us problems.</p><p>It may well be that by the time we release KDE 3.0, we will be able to drop the underperforming compilers.</p><p>One final note: We don't use the STL for performance reasons. The STL is a great idea and I'm sure there must be decent implementations of it somewhere, but the version in gcc (the de facto standard for most of our platforms) is horrible! Every time we used STL, performance dropped to a crawl. As a result, we use Qt's template classes (nicknamed the "QTL") in many cases and "hand-grown" code in others.<p><p>We have nothing against the STL, though. When the critical mass of compilers have a decent implementation, you'll start seeing it used more and more.</p><p>Kurt Granroth</p> <p>granroth@kde.org</p><p><b>DDJ</b></p></body></html>