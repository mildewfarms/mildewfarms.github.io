<html><head><title>Jul01: Programmer's Toolchest</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Android: Open-Source Scripting for Testing and Automation</h1><p><i>Dr. Dobb's Journal</i> July 2001</p><h2>Scripts for recording and playing back</h2><h3>By Larry Smith and Cameron Laird</h3><I>Cameron works for PhaseIt, a consulting firm. Larry is a contracting programmer and writer with more than 20-years experience in software development. They can be contacted at claird@neosoft.com and larry@smith-house.org, respectively.</I><hr><p>Android is a tool for recording and playing back scripts of X11 events. Created by Compaq developers who were testing GUI-based programs in various languages, Android watches you interact with a program, transcribing a script that replicates everything you do. It even records your corrections and hesitations. You can also direct it to take snapshots of a window for later comparison. In short, it is a personal assistant that's smart enough to "do what you mean" when drudge work is waiting. </p><p>You can play back such a script to replicate your previous session. Android also knows how to take snapshots of a new version of your program and compare them with those saved from your "baseline" scripting run. It issues warnings when any of the windows have changed. As a regression test tool, Android is invaluable &#151; and it's good for more than just testing.</p><DDJADVERTISEMENT INLINE><p>Of course, a number of other test-automation tools do a similar job. However, most others are limited to driving programs coded with just one particular widget set. Android works at the level of the X protocol using the XTEST extension. This extension lets Android create synthetic events indistinguishable from those generated by live users, so Android can do anything live users can &#151; and Android does it with any widget set, or even no widget set.</p><p>For instance, one of us (Larry) was once faced with the onerous task of transferring 40-some files from a Windows system to a PalmPilot. The PalmPilot software, sadly, imports memo files only one at a time. Larry fired up Android, had it start vncclient, and went through the motions of importing the first file. Then he wrote a loop around the relevant code, adding one additional cursor down to select the next file for insertion. Then he left for lunch. The files were all properly downloaded when he returned. Android is the first practical tool we know to script such "quick-n-dirty" hacks for GUI programs.</p><p>Android is an extension of John Ousterhaut's Tcl language. It is written in &#151; and runs with &#151; Expect, Don Libes's Tcl extension (<a href="http://starbase.neosoft.com/~claird/comp.lang.tcl/expect.html">http://starbase.neosoft.com/~claird/comp.lang.tcl/expect.html</a>) for controlling command-line-driven programs. However, the scripts Android generates run properly with <i>wish</i>, the standard Tcl/Tk shell, and they dynamically load Android's library for the XTEST extension, so they need no special environment and only one sharable library. Full source code and documentation for Android is available at <a href="http://server.open-hardware.org/download/contrib/Compaq/">http://server.open-hardware.org/download/contrib/Compaq/</a> and <a href="http://www.smith-house.org/open.html">http://www.smith-house.org/open.html</a>. The tool is provided under the standard GNU Programmers License (GPL) (with other licenses available by contract). </p><h3>A First Example</h3><p>Suppose, for instance, you are working on xcalc and you're happy with the primary keyboard window, and want to protect it and the logic that drives it while you tinker with other areas. We'll create a simple script that we run periodically to verify the main window works properly.</p><p>To create a test script, you only need to bring up Android in record mode: <i>$ android -record xcalc.tst</i>. Android is indifferent to the .tst extension. We make it a habit to use this extension, though, as a reminder that the content is a test script.</p><p>Android comes up in its Edit/Control window in <A NAME="rf1"><A HREF="0107if1.htm">Figure 1</A>. This is the skeleton of the script we're developing. The first line invokes <i>wish</i> from the shell. The following two lines are housekeeping: They close the default "wish" window, which isn't needed, and initialize the count for the number of comparison failures. The next line loads the Tcl library; this lets the script communicate with your X server using the XTEST protocol. The cursor is located at the blank line just before the code for the final report. This is where your real script goes.</p><p>To start your test program, use "Test/Start Program...". The first thing you see is a wait dialog announcing "starting monitor." Android uses the Xscope utility to watch your actions on the keyboard and mouse, and this is what is being started.</p><p>Xscope is a virtual X server. When run, it connects to the local X server and provides a new display &#151; usually <i>:1</i> &#151; that X clients can connect to. Xscope merely routes events sent to it to the real X server it is connected to, but in the process it spools text descriptions of each event to <i>stdout</i>.</p><p>Android's big value-add is the collection of regular expressions it uses to parse useful data out of Xscope's rather voluminous output. This information is distilled down into the list of <i>send_xevents</i> commands that can exactly replicate your session.</p><p>Xscope is also the source of one of Android's limitations &#151; it can only track things that are using Xscope. Your window manager, already started and talking directly to the X server, doesn't do this, so Android has problems tracking anything not started from Android itself.</p><p>Once Android properly launches Xscope, it presents you with <A NAME="rf2"><A HREF="0107if2.htm">Figure 2</A>. At this point you may specify the command line that starts your program. You should always remember to specify a <i>-geometry </i>option, or Android will add one for you. One drawback of working at such a low level is that Android works entirely with screen &#151; not window &#151; coordinates. If the window is not placed in the same place on the screen each time Android or one of its test scripts is run, the results probably won't match, generating bogus regression failures. Fortunately, these are easy to detect, since it is rare that a given test run will report 100 percent failures in the real world.</p><p>Sadly, Android cannot tell if you move a window &#151; the mouse actions that move a window are routed to the window manager rather than Xscope. Choose your geometry carefully because you'll have to live with it. </p><p>For the example test, enter: <i>/usr/X11R6/ bin/xcalc -geometry +</i>400<i>+</i>100. Immediately, the line: <i>exec /usr/X11R6/bin/xcalc -geometry +</i>400<i>+</i>100 &amp; appears in the script and xcalc's own window opens on the screen.</p><p>Remember that Android uses a monitor (Xscope) to watch you interact with the test program. Shouldn't there be a "<i>-display</i>" flag also? No. This line is for playback, and no monitor is needed then. Rest assured that the version of xcalc you are looking at was started with Xscope.</p><p>You can do whatever you like with the program at this point, but Android takes no action. Android's design default is not to record, to give you an opportunity to start and configure other programs that might be necessary for your test &#151; servers, for example. Once you're ready to record, choose Test/Track Events.</p><p>Once you do this, you will see <i>send_ xevents</i> commands appear in the Edit window as you perform xcalc actions. When you type "1+2=" using the mouse, the script window looks like <A NAME="rf3"><A HREF="0107if3.htm">Figure 3</A>.</p><p>While each <i>send_xevent</i> takes an arbitrary number of subcommands, Android usually generates them in triplets of <i>wait</i>, @, and an input event. <i>Wait</i> simply pauses for a time measured in milliseconds. @ moves to specified screen coordinates. <i>btnup/btndn</i> are common input events; the number following these tells which mouse button has traveled up or down.</p><p>Suppose you're concerned about a particular segment of source code exercised by a particular esoteric calculation. You want to confirm that the calculation survives changes you're making to xcalc. That's the function of Test/Take Snapshot. This selection brings up another dialog that names the test, then offers a crosshair cursor so the Android recorder can choose a specific window for the snapshot. The new code (see <A NAME="rl1"><A HREF="#l1">Listing One</A>) appears in the Script window. This is one complete test, as far as Android is concerned. Upon playback, Android takes a new snapshot and compares it to the one it just took. If they match, you're gold: The program still does what you expect it to for that input. If it changed, you get a failure.</p><p>Suppose you've finished the test sequence and it's time to tidy up by exiting the program and saving the script. Unfortunately, xcalc has no exit. If you click on the window decoration to close it, you bypass the monitor. This kind of gotcha is one reason Android simply extends Tcl &#151; you have the Tcl interpreter at your fingertips. It also illustrates the value of having Android write the script right in front of you. You can click in the Script window, add <i>exec killall xcalc</i>, and the script is done. Save it and quit in the usual way.</p><p>Now run the script with <i>./xcalc.tst</i>. The xcalc window pops up and the mouse moves itself about magically as the various commands are executed. When the snapshot is taken, you see a report line in the executing window telling you "Test 0: succeeded." After this, xcalc disappears.</p><p>Do not use the keyboard or mouse while the script is running. Android sends events to your X11 server. If you mess with the mouse or keyboard, your events will be mixed in with those that Android is producing. The result will likely not be what you intended.</p><h3>Scripting Options</h3><p>That's the Android story. The documentation file android.html details a few more bells and whistles. One enabled by default is "compress motion events," under the Options menu. This means that multiple motion events &#151; @here, @there, @someplace else, and so on &#151; are collapsed down to @(wherever the next significant event takes place). If you disable this option, Android mimics your every move, every hesitation, as you move about and type into the test program. A drawing package is one example of a program that needs this exact mimicry and should not "compress motion events."</p><p>"Auto Save" saves the script you are working on when you close or exit the program. Otherwise, you are prompted if you try to exit without saving.</p><p>The options "Compress Time in Playback" and "Real Time in Playback" set or clear the <i>compress_time</i> flag. The former sets an upper limit on the <i>wait</i> command, so large pauses (like a break for coffee) won't be seen. The "Real Time..." selection resets this variable, with the consequence that Android's delays are just as long as yours.</p><h3>Writing Scripts by Hand</h3><p>Android's ability to record user keyboard and mouse actions is its claim to fame. There are times, though, when you'll want to write scripts by hand. Well-designed scripts can be far more maintainable than those that Android typically generates.</p><p>Define, for instance, the button in <A NAME="re1"><A HREF="0107ie1.htm">Example 1</A>(a). To invoke it, you need only <A NAME="re1"><A HREF="0107ie1.htm">Example 1</A>(b). Android has all the facilities of Tcl as a scripting language, so it can "prettify" <A NAME="re1"><A HREF="0107ie1.htm">Example 1</A>(c). Human script authors use techniques like this to abstract out meaning in a script where Android proper would see and record only specific mouse motions.</p><p>Keep in mind that <i>send_events</i> can manage arbitrary subcommands; it is not limited to triplets. You can create long lists of commands or break them up as you see fit. <A NAME="re2"><A HREF="0107ie2.htm">Example 2</A>(a) has precisely the effect of <A NAME="re2"><A HREF="0107ie2.htm">Example 2</A>(b). This particular sequence can't be decomposed farther; it doesn't make sense to request <i>send_ xevents click; send_xevents </i>1.</p><p>Android recognizes several commands beyond those it uses for its own recordings. The aforementioned <i>click</i> command is one of them; it sends <i>btndn/btnup </i>events. Other timesavers for people writing or editing scripts include <i>keydn/keyup </i>commands, which send <i>keysyms</i> by name such as <i>keydn Insert; keyup Insert</i>. The <i>keysyms</i> supported on your system are usually in the /usr/include/X11/keysymdef.h file. Android uses <i>keysym</i> names in the form without the XK_ prefix.<i></p><p>keydn/keyup</i> pairs can become tiresome. Android simply abbreviates these with <i>key [keysym name]</i>, which sends the <i>keydn/keyup</i> events for you, in an example like <i>key Insert</i>.</p><p>You can send events to any X server with Android's display command. For instance, <i>send_xevent display :</i>0.1<i> click </i>1<i> </i>sends a mouse click of button 1 to your :0.1 display. You can freely intermix display commands in <i>send_xevents</i> lists and control any number of displays.</p><p>Android also provides a handy shorthand for typing strings &#151; the <i>type</i> command: <i>send_xevent type {Now is the time for all good men...} </i>which, as you can see, would save a lot of <i>keyup/keydn</i> events, as well as being much easier to edit and maintain. Type converts each of the characters in the given string (which should be delimited by "" or {}) to their equivalent keycodes and generates key press/release events for each in sequence. Strings may consist of upper- and lowercase letters, and the basic set of punctuation. Esoteric punctuation, special characters, and so on are not supported; these must be accessed by <i>keysym</i>. Android does recognize \<i>n</i>, \<i>t</i> and \\ sequences. <i>type {ls\n} </i>in an xterm window will execute an <i>ls</i> command, for example.</p><p>This ability to work at such a low level makes Android very handy for testing programs in various languages. It doesn't care about your locale, keyboard, or input method. All it cares about is grabbing your event stream and recording it, and comparing X window dumps. It's internationalized by nature. The Android extension adds a few other useful commands to Tcl beside <i>send_xevents</i>. Each of these is a command at the Tcl level, not a subcommand of <i>send_xevents</i>.</p><p>The <i>dispinfo</i> command provides information about the state of the keyboard and mouse at the present instant. <i>dispinfo modkeys</i> delivers a list of modifier keys presently in force. If users were to hold down the Shift-Ctrl keys at the same time, <i>dispinfo modkeys</i> returns {Shift Control}.</p><p>Find out where the mouse is using <i>dispinfo mouse x</i> and <i>dispinfo mouse y</i>. These commands could theoretically return inconsistent pairs of <i>x</i> and <i>y</i> if the mouse were to move in between calls; that is, it could give the 20 of 20,100 and the 130 of 30,130, providing the fictitious coordinate 20,130. To avoid this problem, <i>dispinfo mouse </i>caches coordinates and returns the <i>x</i> or <i>y</i> associated with the cache. You can refresh the cache with the current mouse coordinates using the <i>fresh</i><i> </i>specifier: <i>dispinfo fresh mouse x</i> gives you the latest x-coordinate, and <i>dispinfo mouse y</i> the corresponding y-coordinate.<i></p><p>dispinfo buttons</i> returns a list of all the mouse buttons that are pressed at the current moment. Query the state of any given mouse button using <i>dispinfo button n</i>; this returns a 1 if button <i>n</i> is pressed, and 0 if it is not, where <i>n</i> is the number of the mouse button you are interested in.</p><p>A final use of <i>dispinfo</i> is to find out what extensions you have installed in your X server. A simple call of <i>dispinfo installed</i> returns a blank-delimited list of all X11 extensions installed on the currently selected display.</p><p>Calling <i>dispinfo installed</i> with a list of extension names returns 1 if all the named extensions are present, and 0 if they are not all present; see <A NAME="re3"><A HREF="0107ie3.htm">Example 3</A>.</p><h3>Conclusion</h3><p>Android was written as a testing tool. It's flexible enough to lend itself to other uses, though. It makes a good marriage, for example, with the widely used open-source VNC "remote control" utility. Android can act through VNC (virtual network computing; see <a href="http://starbase.neosoft.com/~claird/comp.windows.misc/VNC.html">http://starbase.neosoft.com/~claird/comp.windows.misc/VNC.html</a>) to drive even the GUI-based programs of a Windows system. This is especially helpful for remote administration &#151; you can write a script that changes a parameter on your UNIX systems and restarts your daemons, and then have it turn around and use Android to perform the same manipulation on Windows, up to and including starting the reboot. This is an exceptionally handy way of restoring the command-line power of yesteryear to modern GUI interfaces.</p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>exec /usr/X11R6/bin/xwd -silent -out snapshot.tmp &amp;after 3000send_xevents @596,305 click 1after 3000set err 0set result [ catch {     exec cmp snapshot.tmp xcalc.tst.ss.0} err ]if { $result == 0 } {  puts "Test 0: succeeded First Test"} else {  puts "Test 0: failed    First Test ($err)"  incr failures}</pre><P><A HREF="#rl1">Back to Article</A></P></body></html>