<html><head><title>Aug01: A Tiny Perl Server Pages Engine</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>A Tiny Perl Server Pages Engine</h1><p><i>Dr. Dobb's Journal</i> August 2001</p><h3>By Andy Yuen</h3><I>Andy is a solution architect and can be reached at andyyuen@kardinia.com.</I><hr><p>Microsoft's Active Servers Pages (ASP) and Sun's Java Server Pages (JSP) are gaining popularity because they unite client-side HTML, server-side scripting, and component-based development to produce dynamic pages. ASP supports a number of host scripting languages including Perl. The Perl module Apache::ASP provides an ASP port to the Apache Web Server with Perl as the host scripting language. So why would you want to develop your own ASP-like server-side scripting facility if ASP is already available on Apache? The answer is simple &#151; out of necessity. In my case, I recently worked on a project to develop a performance reporting add-on to enterprise network/system management platforms including HP OpenView and Tivoli Netview. These products install their own web servers during the installation process. For example, HP OpenView installs an Apache Web Server when installed on HPUX and Solaris. (Either Microsoft Internet Information Server or Personal Web Server is used on Windows 2000 and NT.) However, the Apache Web Server installed does not have the mod_perl module that is required by Apache::ASP to work. This posed a serious problem because the add-on product needed to work out-of-the-box. Customers shouldn't be expected to install a large number of other Perl modules and devote considerable time reconfiguring and extending their platform environment to make an add-on product work. The problem gets worse as the latest version of Netview no longer uses Apache as the default web server. Writing different versions of a web-based application for different web servers is not an option because of the development and maintenance effort. My solution, which I call "Perl Server Pages" (PSP), is to develop a small footprint Perl-based cross-platform JSP-like facility &#151; with custom tag library support &#151; for generating dynamic pages. The only requirements are that your web server supports CGI and you have Perl 5.005 or later installed on your system. The complete source code and related files for both UNIX and Windows are available electronically; see "Resource Center," page 5. </p><p>Note that there is also an open-source project that is also called Perl Server Pages (<a href="http://psp.sourceforge.net/">http://psp.sourceforge.net/</a>). However, there is no connection between that project and the one I present here.</p><DDJADVERTISEMENT INLINE><h3>PSP Features</h3><p>PSP is modeled after JSP. It is neither an ASP nor a JSP port. PSP includes many JSP-like features and, most importantly, custom tag support. The latter gives you the ability to develop custom tag modules to encapsulate complex server-side behaviors and business rules into simple XML-like elements that content developers can use. </p><p>PSP shares the same basic elements with JSP; see <A NAME="rt1"><A HREF="0108gt1.htm">Table 1</A>. However, PSP only supports the directives in <A NAME="rt2"><A HREF="0108gt2.htm">Table 2</A>, although it does provide the built-in objects in <A NAME="rt3"><A HREF="0108gt3.htm">Table 3</A>. PSP does not provide built-in session and application objects like JSP. The limitations of PSP are described in a later section. <A NAME="rl1"><A HREF="#l1">Listing One</A> is a simple PSP page using some basic PSP elements to display fonts with varying sizes. </p><p>Like JSP, PSP lets you create custom tags. But unlike JSP, you are not required to provide an XML-based Tag Library Descriptor (TLD) with each tag library you develop. </p><p><A NAME="rl2"><A HREF="#l2">Listing Two</A> uses the custom tag <i>&lt;test::date&gt;</i>, which displays the current date and time according to the format specified in the format attribute. The <i>&lt;test::date&gt;</i> custom tag does not contain a tag body (an empty element) and it is terminated with a /. In general, a custom tag may or may not have a body. But it is always terminated either with a / or an explicit end tag.</p><p><A NAME="rl3"><A HREF="#l3">Listing Three</A> is a PSP page that shows a more complicated example using nested tags. It uses the custom tags <i>&lt;test:loop&gt;</i>, <i>&lt;test:if&gt;</i>, <i>&lt;test:condition&gt;</i>, <i>&lt;test:then&gt;</i>, and <i>&lt;test:else&gt;</i> to generate 10 random numbers, and displays either "head" or "tail" in an unnumbered list depending on whether the random number is greater than 0.5. </p><h3>Implementation</h3><p>PSP uses Perl's object-oriented features exclusively. Like JSP pages, PSP pages need to be translated before use. </p><p>The first thing that you need when implementing the PSP translator is a simple parser that can handle HTML and XML-like syntax. You don't need something complicated like HTML::Parser (<a href="http://search.cpan.org/doc/GAAS/HTML-Parser-3.25/Parser.pm">http://search.cpan.org/doc/GAAS/HTML-Parser-3.25/Parser.pm</a>) that knows which tags can contain other tags, and which start tags have corresponding end tags. Nor do you need a parser that creates a hierarchical tree of HTML content. All you need is a simple parser that recognizes a small number of tags (mostly start and end tags) and parses the elements into a list. HTML::SimpleParse (<a href="http://search.cpan.org/doc/KWILLIAMS/HTML-SimpleParse-0.10/SimpleParse.pm">http://search.cpan.org/doc/KWILLIAMS/HTML-SimpleParse-0.10/SimpleParse.pm</a>) appears to satisfy these requirements. But on closer examination, it presents two major problems. First, it is not easily extensible to pick out elements not already recognized by it. Second, it cannot handle tags with embedded &gt; in them (<i>&lt;test:something name="expr" value="x &gt; y" /&gt;</i>, for example). These problems have been documented by its author in the POD (Plain Old Document) for HTML::SimpleParse. </p><p>I got around the first problem by changing the module's <i>parse</i> method to include a couple of new tag types that I wanted it to handle. I renamed the module PSP::SimpleParse. To get around the second problem, I created a subclass named <i>PSP::Parser</i> to override the <i>text</i> method that sets the content of the text to be parsed. Before it calls its parent's <i>text</i> method, it replaces all single- and double-quoted strings with placeholders <i>~~NN~~</i>, where <i>NN</i> is a unique number. The strings are saved in a hash. SimpleParse's <i>parse</i> method is also overridden to reverse the transformation carried out by the <i>text</i> method. With these transformations, there is no need for SimpleParse to handle an embedded "&gt;." PSP expressions are another source for embedded "&gt;" because they can appear anywhere in an HTML document. The solution here is to replace "&lt;%=" with "&amp;<i>lt</i>;%=" and "%&gt;" with "%&amp;<i>gt</i>;". The PSP translator takes care of the PSP expression code generation.</p><p><A NAME="rf1"><A HREF="0108gf1.htm">Figure 1</A> is the class diagram for the PSP translator program that instantiates a <i>PSP::Translator</i> object to handle the translation, a <i>PSP::TransWriter</i> object to handle the translation output, and a <i>PSP::Writer</i> object to handle error messages. Both <i>PSP::TransWriter</i> and <i>PSP::Writer</i> buffer output until the <i>flush</i> method is called.<i></p><p>PSP::Translator</i>'s <i>translate</i> method invokes <i>PSP::Parser</i>'s <i>file</i> method to read in the PSP file, then its <i>parse</i> method to parse the text into a list. <i>Translate</i> then goes though each item in the list to pick out the six categories of tags that it needs to process: </p><ul>  <li>TYPE_STARTENDTAG_S, which includes most PSP elements &#151; declarations, directives, and scriptlets.  <li>TYPE_STARTENDTAG, which includes custom tags that don't have a body as in &lt;<i>test:date</i> /&gt;. The tag may contain PSP expressions that need to be processed.  <li>TYPE_STARTTAG, which includes all start tags: HTML and custom. Both kinds of tags may contain PSP expressions that need to be processed. The custom tags of this type all have a body.  <li>TYPE_ENDTAG, which includes all end tags: HTML and custom. HTML start tags are passed straight through. Only customer tags are handled specially.  <li>All other tags include text and other more exotic elements. Since PSP expressions can appear in them, these tags are checked for the presence of PSP expressions and handled appropriately, except for HTML comments.</ul><p>The translator relies on an external template file named "psp.tpl" (<A NAME="rl4"><A HREF="#l4">Listing Four</A>) to format its output into a proper Perl script. All fields, except the keywords enclosed in ~~ (~~BODY~~, for instance), are output as is. The keywords or placeholders are substituted by the content accumulated by the <i>PSP::TransWriter</i>. When a fatal error is encountered, <i>PSP::Translator</i>'s <i>errorPage</i> method is called to display an HTML error message before quitting. <i>errorPage</i> requires an external template file named "errpage.tpl." Like psp.pl, it uses placeholders (keywords enclosed in "~~") to mark where the error message should appear. These template files must be colocated in the same directory as the translators: pspt.pl and CGIpspt.pl (described later).</p><p>Translating the HTML and PSP basic elements into a Perl script is relatively straightforward compared to providing custom tag support. <A NAME="rl5"><A HREF="#l5">Listing Five</A> shows part of the translated output of the PSP page in <A NAME="rl2"><A HREF="#l2">Listing Two</A>. You may notice that there are a number of <i>$out-&gt;print</i> statements that print only blanks and new line characters in some translated pages. It is simple to eliminate these statements in the translator. The only reason why this is not done is that the output will not be intended if &lt;PRE&gt; and &lt;/PRE&gt; were used in a PSP. By eliminating blanks and new lines, preformatted text won't show up properly when displayed.</p><p>The translated Perl script relies on the following classes or Perl modules to run:</p><ul>  <li>CGI, the built-in objects <i>$request</i> and <i>$response</i> point to the one and the same CGI object. I use CGI.pm for <i>$request</i> and <i>$response</i> because it is something most Perl developers are familiar with. By using CGI, they don't have to learn yet another programming interface. For example, one uses CGI's <i>param</i> method to retrieve CGI parameters, <i>cookie</i> method to create cookies, <i>header</i> method to set the HTTP header, and so on.  <li><i>PSP::Writer</i>, a buffered output class. Since the output is buffered, you can change the HTTP header at any time using either the PSP include directive or <i>$out-&gt;header</i> and <i>$<i>response-&gt;header</i></i> methods to return an HTTP header. A header containing the content type text/HTML is returned by default.  <li><i>PSP::TagObjFactory</i>, a <i>PSP::TagObjFactory</i> object is created for you automatically. It is responsible for packaging the tag body and other information into a <i>PSP::Body</i> object and passing it to a user-provided custom tag handler constructor to create a tag handler object (more details on this later). The name of the custom tag handler class is derived from the custom tag name by adding an extra ":" &#151; for example, the tag handler class for handling the custom tag <i>&lt;test:date&gt;</i> is <i>test::date</i>.</ul><p>A tag handler class or Perl module must be derived from <i>PSP::TagHandler</i> for each custom tag. The <i>PSP::TagHandler</i> class has the following methods:</p><ul>  <li><i>new</i>, a constructor.   <li><i>doTagStart</i>, a method you should override to handle a custom tag. If the tag does not have a body, it should return a 0. If the tag has a body, you should put an initialization code here and return a 1. In which case, the <i>doBody</i> method will be invoked next.  <li><i>doBody</i>, a method you should override to handle the manipulation of the tag body. You should return a 0 when you are done. Or you can return a 1 if you want to process the body again.  <li><i>doTagEnd</i>, a method you should override to do any clean up after processing the custom tag.  <li><i>vars</i>, a method for you to create and share variables among related classes in nested custom tags. This method is particularly useful, if you intend to create a complete markup language (like ColdFusion), in creating and sharing variables and objects among the different language elements in your markup language.  <li><i>findAncestorWithClass</i>, a method to find the tag in which this one is nested. This method is mandatory in writing nested tags.   <li><i>errorPage</i>, a method to create an HTML error page and terminate the executing Perl script.</ul><p>Your custom tag may contain one or more attribute=value pairs as in <i>&lt;test:date format="%Y-%m-%d %a %H:%M:%S" /&gt;</i>. In such a case, you need to provide a method called <i>format</i>, which is exactly the same as the attribute name, to handle the storage and retrieval of the value. </p><p>Your custom tag handler can manipulate the tag body by using the <i>PSP::Body</i> class. It has the following methods:</p><ul>  <li><i>new</i>, a constructor.  <li><i>request</i>, which returns the in-built request object.  <li><i>response</i>, which returns the in-built response object.  <li><i>out</i>, which returns the <i>PSP::Writer</i> being used by the current tag handler.  <li><i>Body</i>, which returns a string containing the entire tag body.</ul><p>The <i>PSP::TagHandler</i> and <i>PSP::Body</i> classes provide a simple interface to create custom tags. <A NAME="rf2"><A HREF="0108gf2.htm">Figure 2</A> is the PSP engine class diagram.</p><p><A NAME="rl5"><A HREF="#l5">Listing Five</A> shows part of the translated PSP page for the simple PSP page that uses a custom tag to display the current date and time (<A NAME="rl2"><A HREF="#l2">Listing Two</A>). Please note that all variables with prefix <i>PSP_</i> are used internally by the PSP run time. You should not change them in any way.</p><p>Each custom tag handler is contained in its own block, that is, between { and } and uses two <i>PSP::Writers</i>, one for its enclosing tag and the other for the current tag. These writers are named <i>$<i>PSP_out</i></i> and <i>$out</i>, respectively. The tag handling code then:</p><p>1.	Pushes these objects onto the stack (<i>$PSP_stack</i>).</p><p>2.	Copies <i>$out</i> to <i>$PSP_out</i> and creates a new <i>$out PSP::Writer</i> object for handling the current tag's output. </p><p>3.	Stores the custom tag in the variable <i>$PSP_tag</i>.</p><p>4.	Creates a new tag object by using the built-in <i>PSP::TagObjFactory</i> object's <i>CreateTagObj</i> method. The tag handler class name is derived from the tag name. It simply inserts an extra : in the tag name. For example, the tag handler class is <i>test::date</i> for the custom tag <i>test:date</i>.</p><p>5.	Calls the newly created tag object's <i>doTagStart</i> method.</p><p>6.	Skips Step 7 if it returns a 0.</p><p>7.	Keeps calling the tag object's <i>doBody</i> method until it returns 0.</p><p>8.	Calls the tag object's <i>doTagEnd</i> method.</p><p>9.	Calls the built-in <i>PSP::TagObjFactory</i> object's <i>houseKeeping</i> method to update the ancestry so that nested tag handlers can find their ancestors by calling the inherited <i>findAncestorWithClass</i> method.</p><p>10.Restores the old values of <i>$PSP_out</i> and <i>$out</i> by popping them from the <i>PSP_stack</i>.</p><p>A more complicated piece of code results when nested tags are involved. But it always follows the same pattern; that is, another tag handling block is inserted within the <i>doBody</i> loop of the enclosing tag handling code. </p><h3>Examples</h3><p><A NAME="rl6"><A HREF="#l6">Listing Six</A> contains the tag handler class for the <i>&lt;test:date&gt;</i> custom tag used in <A NAME="rl2"><A HREF="#l2">Listing Two</A>. It overrides the <i>doTagStart</i> method of its superclass <i>PSP::TagHandler</i>. Since it supports the <i>format</i> attribute, it also implements the <i>format</i> method. When called with a value, it sets the class data member <i>'format'</i>. When called without a value, it returns the stored <i>'format'</i> value. This is the simplest tag handler you can build because it does not have a tag body.</p><p>Look at the tag handler classes used in the PSP page in <A NAME="rl3"><A HREF="#l3">Listing Three</A>. <A NAME="rl7"><A HREF="#l7">Listing Seven</A> contains the <i>test::loop</i> class. This time, <i>test::loop</i> overrides both its superclasses <i>doTagStart</i> and <i>doBody</i> methods. In <i>doBody</i>, it outputs its tag body and returns a 1 to repeat the operation for the number of times specified in the <i>'repts'</i> data member. Also note that it implements the tag attribute handling method <i>repts</i>.</p><p><A NAME="rl8"><A HREF="#l8">Listings Eight</A>, <A NAME="rl9"><A HREF="#l9">Nine</A>, and <A NAME="rl10"><A HREF="#l10">Ten</A> contain the <i>test::if</i>, <i>test::condition</i>, and <i>test::then</i> classes, respectively. The <i>test::if</i> is the simplest class possible. It is an empty class that uses the <i>PSP::TagHandler</i> class without modification.<i></p><p>Test::condition</i> overrides the <i>doTagStart</i> method to use the <i>findAncestorWithClass</i> method to check if it is enclosed inside the <i>&lt;test::if&gt;</i> tag. It calls <i>errorPage</i> to generate an HTML error message and terminates if an enclosing <i>&lt;test:if&gt;</i> tag is not found. <i>DoBody</i> retrieves the body; that is, the result in the evaluation of the specified condition, and saves it in the enclosing <i>test::if</i> object's hash for use by <i>test::then</i> and <i>test::else</i>.<i></p><p>Test::then</i>'s <i>doTagStart</i> is similar to that of <i>test::condition</i>. Its <i>doBody</i> method checks if a condition has been stored in the enclosing <i>test::if</i>'s hash. If yes, it retrieves it and outputs the entire tag body, provided that the retrieved condition is 1. If there is no condition stored in the enclosing <i>test::if</i> object's hash, it generates an HTML error message and terminates. The <i>test::else</i> class is almost the same as the <i>test::then</i> class. Hence, it is not listed.</p><h3>Deployment</h3><p>There are two ways to deploy PSP pages &#151; manual translation and automatic translation. </p><p>You can manually translate all PSP pages using pspt.pl into Perl scripts and work exclusively with the translated PSP pages. All your HTML hyperlinks (<i>href</i> and <i>action</i> properties in forms) should point to the translated .pl files. The advantage of this approach is that you are working with Perl scripts exclusively and do not have to worry about different web servers using different mechanisms to run a PSP page (discussed next).</p><p>In the automatic translation approach, you configure the web server to use the CGIpspt.pl script to run your PSP pages, that is, pages with the .psp extension. If you are using Microsoft web servers (PWS or IIS), you do this by adding a new string value to the Windows registry: </p><blockquote><p>\HKEY_LOCAL_MACHINE\SYSTEM\      CurrentControlSet\Services\w3svc\                   parameter\Script Map\.psp </p></blockquote><p>and give it a value: "C:\Perl\bin\Perl.exe C:\cgi-bin\CGIpspt.pl %s %s". If the physical path C:\cgi-bin has been mapped to the virtual directory /cgi, after restarting the web server, you can reference your PSP page as:</p><blockquote><p>http://hostname/cgi/whatever.psp</p></blockquote><p>Unfortunately, the mapping mechanism is quite different on Apache (even for Apache running on Windows platforms). You have to add the following entries in Apache's srm.conf file:</p><blockquote><p>AddHandler psp-script .psp</p><p>Action psp-script "C:/cgi-bin/CGIpspt.pl"</p></blockquote><p>After restarting the web server, you can reference your PSP page as:</p><blockquote><p>http://hostname/cgi/CGIpspt.pl/cgi/ 			whatever.psp</p></blockquote><p>The CGIpspt.pl script uses the environment variable PATH_TRANSLATED to get the translated path name of the specified PSP page. In both cases, PATH_TRANSLATED contains C:/cgi-bin/whatever.psp. This means that HTML and PSP pages that contain links need to have the links modified when moved from Apache to IIS or vice versa. This is a bit of a pain, but the problem can be resolved by writing a simple Perl script to automate the process.</p><p>Another potential problem is related to the placement of Perl and PSP modules (.pm files). You may need to change the "#!" and "use lib" statements in CGIpspt.pl, pspt.pl, and psp.tpl for your environment to make PSP work properly. Check the web-server log to get more information if PSP does not work.</p><p>CGIpspt.pl checks for the existence of the specified .psp file and displays an error message if it is not found. It then checks if a translated version, that is, a file by the same name but with file extension .pl, is already present in the same directory. If it is not present, CGIpspt.pl invokes a <i>PSP::Translator</i> object to create it. If it is present, CGIpspt.pl interprets it by using the <i>eval</i> function. Since <i>eval</i> uses the current environment to interpret the translated Perl script fed to it, all CGI parameters are available to the translated script. If you should change a PSP page, you need to remove its old translated .pl file before the changes will be picked up during subsequent invocations. During the development cycle, you may want to comment out the part in CGIpspt.pl where it checks for the presence of the .pl file so that it always translates the most current version.</p><p>For better control of the PSP installation process (no flames please), I depart from the CPAN way of installation using make. I've created two packages, one for Windows and the other for UNIX. Both packages are also available electronically. The Windows package uses the usual Windows setup.exe to install. It sets up the Windows registry for you automatically. This makes deployment easy if you are using Microsoft web servers. The UNIX version uses a shell script for installation. </p><h3>Limitations</h3><p>PSP unites client-side HTML and server-side scripting in a small package that consists of eight small Perl modules. Most of them are around one page in size. The small package is packed with features like custom tag support. Because of its small size and independence of web-server features, PSP pages can be moved easily among different platforms. However, portability does not come without cost.</p><p>Owing to its use of the CGI interface, PSP suffers from the same problems that plagued normal Perl CGI scripts (not counting using perl_mod with Apache):</p><ul>  <li>Each Perl script invocation spawns a new process. This may limit the scalability of the web site.   <li>No built-in session or state support. You have to rely on the usual mechanisms such as hidden fields, cookies, and URL rewriting to maintain state information.</ul><p>Other limitations, if you are deploying PSP using the automatic translation approach, include:</p><ul>  <li>CGIpspt.pl uses perl's <i>eval</i> function. This feature is considered unsafe by some, security wise.  <li>You need to give write access to your CGI directory or whatever directory you put the PSP translator and PSP pages in because the translator generates Perl scripts. This again may be considered a security risk.  <li>When deploying web applications consisting of HTML or PSP pages on different web servers, hyperlinks (<i>href</i> and <i>action</i> properties in forms) pointing to these pages may need to be changed due to different web servers using different mapping mechanisms. However, this can be resolved by using another Perl script to fix up the links.  <li>The translator and run-time error messages may not provide sufficient details to pinpoint the problem.  <li>The translator is not a validating parser for HTML or Perl. It does not detect any syntax problems related to HTML (such as missing end tags) or Perl.</ul><h3>Conclusion</h3><p>PSP provides a portable environment for developing dynamic web pages using features that are familiar to ASP and JSP developers such as declarations, directives, expressions, and scriptlets. It provides a simple, yet powerful custom tag support mechanism to encapsulate complex server-side behaviors and business rules into simple XML-like elements that content developers can use. The custom tag programming interface is similar to that of JSP, but does not require an XML-based tag library descriptor. These features, when paired with a wide array of Perl modules available on the Internet, make PSP a simple, yet powerful tool to use if the applications developed need to be deployed on different platforms running different web servers. The only requirements are that these web servers support the CGI interface and you must have Perl 5.005 or later installed on these systems. The PSP development is by no means complete. I will post new versions and extensions at <a href="http://www.playsport.com/psp_home/">http://www.playsport.com/psp_home/</a> as they are available.</p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"&gt;&lt;!-- Simple changing font size demo --&gt;&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;Simple Changing Font Size Demo&lt;/TITLE&gt;&lt;/HEAD&gt;&lt;BODY&gt;&lt;H3&gt;PSP Simple Changing Font Size Demo&lt;/H3&gt;&lt;P&gt;For loop incrementing font size from 1 to 5: &lt;P&gt;&lt;%-- You should not see this--%&gt;&lt;% for(1..5) { %&gt;    &lt;!-- iterated html text --&gt;    &lt;FONT SIZE="&lt;%= $_ %&gt;" &gt; Size = &lt;%= $_ %&gt; &lt;/FONT&gt; &lt;BR&gt;&lt;% } %&gt;&lt;/BODY&gt;&lt;/HTML&gt;</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"&gt;  &lt;HTML&gt;&lt;HEAD&gt;  &lt;TITLE&gt;Simple Custom Tag&lt;/TITLE&gt;  &lt;/HEAD&gt;  &lt;BODY&gt;  &lt;H3&gt;PSP Simple Custom Tag Demo&lt;/H3&gt;&lt;P&gt;  The curent date and time: &lt;test:date format="%Y-%m-%d %a %H:%M:%S" /&gt;  &lt;/BODY&gt;  &lt;/HTML&gt;</pre><P><A HREF="#rl2">Back to Article</A></P><H4><A NAME="l3">Listing Three</H4><pre>&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"&gt;&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;Nested Custom Tag Demo&lt;/TITLE&gt;&lt;/HEAD&gt;&lt;BODY&gt;&lt;H3&gt;PSP Nested Custom Tag Demo&lt;/H3&gt;&lt;P&gt;&lt;UL&gt;&lt;test:loop repts=10&gt;&lt;LI&gt;&lt;test:if&gt;  &lt;test:condition&gt;&lt;%= (rand &gt; .5) %&gt;&lt;/test:condition&gt;  &lt;test:then&gt;Head&lt;/test:then&gt;  &lt;test:else&gt;Tail&lt;/test:else&gt;&lt;/test:if&gt;&lt;/test:loop&gt;&lt;/UL&gt;&lt;/BODY&gt;&lt;/HTML&gt;</pre><P><A HREF="#rl3">Back to Article</A></P><H4><A NAME="l4">Listing Four</H4><pre>#!perl# ********************************************************************# This script is generated by the PSP translator based on a PSP file.# ********************************************************************# import sectionuse PSP::Writer;use PSP::TagObjFactory;use CGI;# custom tag modules import if any~~IMPORT~~# declaration section~~INIT~~# PSP initializationmy $out = new PSP::Writer;my $request = new CGI;my $response = $request;my $psp = new PSP::TagObjFactory($request, $response, "errPage.tpl");my @PSP_stack;my $PSP_out = $out;# header section~~HEADER~~# PSP body~~BODY~~# send buffered output to STDOUT$out-&gt;flush(\*STDOUT);</pre><P><A HREF="#rl4">Back to Article</A></P><H4><A NAME="l5">Listing Five</H4><pre>{push @PSP_stack, $out;push @PSP_stack, $PSP_out;$PSP_out = $out;$out = new PSP::Writer;my $PSP_tag;$PSP_tag = qq(&lt;test:date format="%Y-%m-%d %a %H:%M:%S" /&gt;);my $tagobj_0 = $psp-&gt;createTagObj($PSP_out, $out, $PSP_tag);if ($tagobj_0-&gt;doTagStart() == 1) {    my $pred_0 = 1;    while ($pred_0) {        $pred_0 = $tagobj_0-&gt;doBody();    }}$tagobj_0-&gt;doTagEnd();$psp-&gt;houseKeeping($PSP_out, $out);$PSP_out = pop @PSP_stack;$out = pop @PSP_stack;}</pre><P><A HREF="#rl5">Back to Article</A></P><H4><A NAME="l6">Listing Six</H4><pre>package test::date;use POSIX;use PSP::TagHandler;@ISA = qw(PSP::TagHandler);# constructorsub new {    my $class = shift;    my $self = $class-&gt;SUPER::new(@_);    $self-&gt;{'format'} = '%c';    return $self;}# handler for processing the start of a custom tagsub doTagStart {    my $self = shift;    my $out = $self-&gt;{'body'}-&gt;out();    my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime();    $out-&gt;print(strftime($self-&gt;{'format'},$sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst));    return 0;}# handler for the format attributesub format {    my $self = shift;    $self-&gt;{'format'} = shift if @_;    return $self-&gt;{'format'};}1;</pre><P><A HREF="#rl6">Back to Article</A></P><H4><A NAME="l7">Listing Seven</H4><pre>package test::loop;use PSP::TagHandler;@ISA = qw(PSP::TagHandler);# constructorsub new {    my $class = shift;    my $self = $class-&gt;SUPER::new(@_);    $self-&gt;{'repts'} = undef;    return $self;}# handler for processing the body of a custom tagsub doBody {    my $self = shift;    my $body = $self-&gt;{'body'};    my $out = $body-&gt;out;    # output the tag body only for the specified number    # of times    if ($self-&gt;{'repts'}--) {        $out-&gt;print($body-&gt;body);        return 3;    }    return 0;}# handler for the repts attributesub repts {    my $self = shift;    $self-&gt;{'repts'} = shift if @_;    return $self-&gt;{'repts'};}1;</pre><P><A HREF="#rl7">Back to Article</A></P><H4><A NAME="l8">Listing Eight</H4><pre>package test::if;use PSP::TagHandler;@ISA = qw(PSP::TagHandler);1;</pre><P><A HREF="#rl8">Back to Article</A></P><H4><A NAME="l9">Listing Nine</H4><pre>package test::condition;use PSP::TagHandler;@ISA = qw(PSP::TagHandler);# constructorsub new {    my $class = shift;    my $self = $class-&gt;SUPER::new(@_);   return $self;}# handler for processing the start of a custom tagsub doTagStart {    my $self = shift;    #check if enclosed in test::if    my $parent = $self-&gt;findAncestorWithClass("test::if");    if (defined($parent)) {        # save the parent object        $self-&gt;{'parent'} = $parent;        return 1;    }    $self-&gt;errorPage("errPage.tpl",         "&amp;lt;test:condition&amp;gt;                     not enclosed in &amp;lt;test:if&amp;gt;&amp;lt;test:if&amp;gt;");    return 0;}# handler for processing the body of a custom tagsub doBody {    my $self = shift;    my $body = $self-&gt;{'body'};    my $out = $body-&gt;out;    my $text = $body-&gt;body;    my $parent = $self-&gt;{'parent'};    # create condition variable in parent object    $parent-&gt;vars('condition', sprintf("%d", $text));    return 0;}1;</pre><P><A HREF="#rl9">Back to Article</A></P><H4><A NAME="l10">Listing Ten</H4><pre>package test::then;use PSP::TagHandler;@ISA = qw(PSP::TagHandler);# constructorsub new {    my $class = shift;    my $self = $class-&gt;SUPER::new(@_);    return $self;}# handler for processing the start of a custom tagsub doTagStart {    my $self = shift;    #check if enclosed in test::if    my $parent = $self-&gt;findAncestorWithClass("test::if");    if (defined($parent)) {        # save the parent object        $self-&gt;{'parent'} = $parent;        return 1;    }    $self-&gt;errorPage("errPage.tpl",         "&amp;lt;then:condition&amp;gt;                    not enclosed in &amp;lt;test:if&amp;gt;&amp;lt;test:if&amp;gt;");    return 0;}# handler for processing the body of a custom tagsub doBody {    my $self = shift;    my $body = $self-&gt;{'body'};    my $out = $body-&gt;out;    my $text = $body-&gt;body;    my $parent = $self-&gt;{'parent'};    # check if a condition has been set in the parent object    my $cond = $parent-&gt;vars('condition');    if (!defined($cond)) {        $self-&gt;errorPage("errPage.tpl",             "&amp;lt;test:then&amp;gt; without &amp;lt;test:condition&amp;gt;");    }    # output the tag body only if the condition is true    if ( $cond == 1) {        $out-&gt;print($text);    }    return 0;}1;</pre><P><A HREF="#rl10">Back to Article</A></P></body></html>