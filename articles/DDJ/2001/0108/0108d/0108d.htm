<html><head><title>Aug01: A JDBC Wrapper &#151; In Python!</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>A JDBC Wrapper &#151; In Python!</h1><p><i>Dr. Dobb's Journal</i> August 2001</p><h2>A framework for  simplifying database access</h2><h3>By C.K. Tan</h3><I>C.K. can be contacted at cktan@uwalumni.com.</I><hr><p>While generally straightforward, database access via JDBC can be verbose and mundane, making the likelihood of errors always a concern. To simplify the process and lessen the chance for errors, I'll present in this article a Python-based framework that wraps around JDBC. This framework (available electronically; see "Resource Center," page 5) is based upon a connection pool, transaction class, and JDBC code generator. For the purpose of illustration, I use an Oracle database with the table <i>EMPLOYEE(id number, name varchar(</i>50<i>), salary number(</i>9<i>, </i>2<i>), hired_date timestamp)</i>. </p><p><A NAME="rl1"><A HREF="#l1">Listing One</A> presents Insert/Update/Select/Delete queries on the EMPLOYEE table using regular JDBC calls. Contrast this to <A NAME="rl2"><A HREF="#l2">Listing Two</A>, in which I use the Python-based framework for the same queries. As you can see, the framework results in considerable code savings, not to mention improved type checking. The <i>execute()</i> method of update queries and the <i>getOneRow()</i> method of select queries takes a typed argument list. The framework also does away with the <i>getX(column#)</i>/<i>setX(column#)</i> methods in the base JDBC interface. These methods are the usual bug originators when modifications to existing queries neglect updates of the column number constants in the <i>getX</i>/<i>setX</i> methods. The framework also provides facilities to instrument the queries for performance measurement, and helps in organizing source code for both developers and DBAs.</p><DDJADVERTISEMENT INLINE><h3>Connection Pool </h3><p>The <i>DbConnection</i> class represents a database connection. Each <i>DbConnection</i> instance contains a <i>java.sql.Connection</i> object and a <i>hashtable</i> cache of prepared statements. A public static <i>init()</i> method must be called to initialize the framework. This method sets up a <i>DbConnection</i> pool, which is basically a stack of <i>DbConnection</i>s. The <i>init()</i> method takes as arguments the number of connections to put in the pool, the database user ID, database user password, JDBC connection URL, and the JDBC driver name. <A NAME="rl3"><A HREF="#l3">Listing Three</A> shows how I connect to an Oracle database and an IBM DB2 database.</p><h3><i>DbTrans </i></h3><p>The <i>DbTrans</i> class represents a database transaction. To start a new transaction (as in <A NAME="rl2"><A HREF="#l2">Listing Two</A>), I simply do a new <i>DbTrans()</i>. To complete the transaction, I call the <i>close()</i> method, passing it the <i>commit</i> or <i>abort</i> flag. It is important that each transaction gets closed because each new <i>Transaction</i> instance checks out a <i>DbConnection</i> from the connection pool just discussed. The <i>close()</i> releases the <i>DbConnection</i> back into the pool. If the <i>close()</i> method is not invoked, I eventually run out of <i>DbConnection</i>s in the pool. That is why I always use the <i>Transaction</i> class in the <i>try</i>...<i>finally</i> clauses, as in <A NAME="rl2"><A HREF="#l2">Listing Two</A>.</p><h3>The Python Scripts</h3><p>The mksel.py script generates SQL Select JDBC calls, while the mkupd.py script generates the SQL Insert/Update/Delete JDBC calls. The Select queries are treated differently from Insert/Update/Delete queries because Select queries return multivalue result sets vis-&agrave;-vis the single integer row count returned by the Insert/Update/Delete queries. </p><p>Each query is specified in a Python tuple: (<i>java-class-name</i>, <i>augmented-sql</i>). The <i>java-class-name</i> states the desired Java class of the query. The <i>augmented-sql</i> contains the SQL statement augmented with Java hints. A little parser works inside the scripts to parse the <i>augmented-sql</i> queries. Mainly, it looks for the pattern <i>[x:y]</i>, where <i>x</i> and <i>y</i> are strings enclosed in the square brackets and separated by the colon character. The <i>x</i> token is interpreted as a SQL expression. The <i>y</i> token is taken to be a Java type declaration. I have added a <i>bytes</i> type to mean <i>byte[]</i>. I have also handled the <i>boolean</i> type by mapping the value to the strings <i>t</i> or <i>f</i> in the database and back.</p><p>For example, <A NAME="rl4"><A HREF="#l4">Listing Four</A> shows the <i>SelectEmployeeById</i> query. First of all, notice that I named the query <i>SelectEmployeeById</i>. Also, each result row of the query contains the employee's ID (matched to a Java <i>long 'id'</i>), the employee's name (matched to a Java <i>String 'name'</i>), the employee's salary (matched to a Java <i>float 'salary'</i>), and employee's hire date (matched to a Java <i>Timestamp 'hireDate'</i>). Finally, the parameter to the query is a Java <i>long 'id'</i>.</p><p><A NAME="rl5"><A HREF="#l5">Listing Five</A> is the <i>InsertEmployee</i> query. Likewise, I named the query <i>InsertEmployee,</i> which takes as parameters a Java <i>long 'id'</i>, a Java <i>String 'name'</i>, a Java <i>float 'salary'</i>, and a Java <i>Timestamp 'hireDate'</i>.</p><p>Running the scripts result in the creation of the files SelectEmployeeById.java and InsertEmployee.java. You may want to read the generated code to get a deeper understanding of how it all works.</p><h3>Instrumentation </h3><p>The <i>Statistic</i> class associates a name to a set of numbers representing the invocation count, minimum execution time, maximum execution time, and total execution time. Internally, the <i>Statistic</i> class saves all its instances in a static sorted tree map based on the name; this map facilitates a search on all statistics in the system by name. To keep track of new statistics, I simply instantiate a <i>Statistic</i> object by giving it a name. The constructor of the <i>Statistic</i> class inserts the object into the <i>Statistic</i> map. From then on, I can add samples to the <i>Statistic</i> object by calling the <i>add()</i> method, or reset the <i>Statistic</i> object by calling the <i>clear()</i> method. The <i>Statistic</i> map is mainly used in finding instances of the <i>Statistic</i> object by name. This usually occurs when I need to dump some statistics to the screen.</p><p>The framework uses the <i>Statistic</i> class to instrument each database query. Because each query has a unique Java path name, I use this name to instantiate a static <i>Statistic</i> object for each query. For each invocation of the query, I calculate the elapsed time for the query and add this sample to the <i>Statistic</i> object. I usually code a <i>dump</i> function to print out all query statistics from time to time or on demand. The printout is helpful during debugging and performance evaluation as it shows how many times each query is invoked and how long it takes. The printout often points immediately to a subpar query that results in a full table scan in the database.</p><h3>Limitations</h3><p>There are, of course, limitations to the framework. When these times come, you can work around the problem by getting the raw JDBC <i>Connection</i> object from the <i>DbTrans</i> object and issue JDBC commands directly. An obvious limitation is the stored procedure. The framework does not support stored procedures because I did not find a need for it. Another limitation is in streaming. This concerns the <i>getXStream()</i> methods of the <i>java.sql.Statement</i> class. JDBC stipulates that when using streams, the stream content must be emptied before the next <i>getX()</i> method is invoked. I could not find a way to handle this gracefully, and thus, have elected not to handle it at all. Yet another limitation is when the query has a variable number of parameters. </p><h3>Conclusion </h3><p>I use Python primarily for its text processing capability and its readability. There is no question that the same thing could have been done with Perl or, for that matter, Java. But the code would not look as clean as Python.</p><p>A beneficial side effect that comes directly from the use of the framework is the fact that all your queries are now collected in the two Python scripts and not scattered all over; there are only two places to look for queries that have gone awry.</p><p>Generating the JDBC codes have resulted in considerable increase in productivity in the projects I was involved in. The ease of generating SQL queries, and the associated benefits that come with it, allow developers to quickly complete the data-access layer for any new project, and do so with less bugs. </p><h3>References</h3><p>The framework was written by the author and is published with permission from TaiLab Corp.</p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>PreparedStatement ins = null, upd = null, sel = null, del = null;Connection con = DriverManager.getConnection(url, "mylogin", "mypasswd");boolean commit = false;try {    Calendar c = Calendar.getInstance();    c.clear();    c.set(2000, 0, 1);    ins = con.prepareStatement(       "insert into EMPLOYEE(id, name, salary, hire_date) " +       "   values (?, ?, ?, ?)");    upd = con.prepareStatement(       "update EMPLOYEE set salary = ? " +       "   where id = ?");    sel = con.prepareStatement(       "select id, name, salary, hire_date " +       "  from EMPLOYEE " +       " where id = ?");    del = con.prepareStatement(       "delete from EMPLOYEE where id = ?");    ins.setLong(1, 1000);    ins.setString(2, "John Smith");    ins.setFloat(3, 100000);    ins.setTimestamp(4, new Timestamp(c.getTime().getTime()));    ins.executeUpdate();    System.out.println("inserted 1000 John Smith 100000");    upd.setFloat(1, 120000);    upd.setLong(2, 1000);    upd.executeUpdate();    System.out.println("updated 1000 120000");    sel.setLong(1, 1000);    ResultSet rs = sel.executeQuery();    try {        if (rs.next()) {            System.out.println("selected " + rs.getLong(1) + " "                       + rs.getString(2) + " "               + rs.getFloat(3) + " "               + rs.getTimestamp(4));        }        else {            System.out.println("error: cannot find employee id 1000");        }    }    finally {        rs.close();    }    del.setLong(1, 1000);    del.executeUpdate();    System.out.println("deleted 1000");        commit = true;}finally {    if (ins != null)        ins.close();    if (sel != null)        sel.close();    if (upd != null)        upd.close();    if (del != null)        del.close();    if (commit)        con.commit();    else        con.rollback();    con.close();}</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>boolean commit = false;DbTrans trans = new DbTrans();try {    Calendar c = Calendar.getInstance();    c.clear();    c.set(2000, 0, 1);    InsertEmployee.execute(trans, 1000, "John Smith", 100000,                                 new Timestamp(c.getTime().getTime()));    System.out.println("inserted 1000 John Smith 100000");    UpdateEmployeeSalaryById.execute(trans, 120000, 1000);    System.out.println("updated 1000 120000");    SelectEmployeeById.Row row = SelectEmployeeById.getOneRow(trans, 1000);    if (row != null) {    System.out.println("selected " + row.id + " " + row.name  + " "                                       + row.salary + " " + row.hireDate);    }    else {    System.out.println("error: cannot find employee id 1000");    }    DeleteEmployeeById.execute(trans, 1000);    System.out.println("deleted 1000");    commit = true;}finally {    trans.close(commit ? trans.COMMIT : trans.ROLLBACK);}System.out.println("Statistics dump:");Statistic.dump(System.out);</pre><P><A HREF="#rl2">Back to Article</A></P><H4><A NAME="l3">Listing Three</H4><pre>/* for oracle database */DbConnection.init(20, "dev1", "dev1",           "jdbc:oracle:thin:@192.168.123.7:1521:SAMPLEDB",          "oracle.jdbc.driver.OracleDriver");/* for db2 database */DbConnection.init(20, "dev1", "dev1", "jdbc:db2:SAMPLEDB",                             "COM.ibm.db2.jdbc.app.DB2Driver");</pre><P><A HREF="#rl3">Back to Article</A></P><H4><A NAME="l4">Listing Four</H4><pre>("SelectEmployeeById", '''\select [id:long id], [name:String name], [salary:float salary],                                          [hire_date:Timestamp hireDate]  from EMPLOYEE where id = [?:long id]''')</pre><P><A HREF="#rl4">Back to Article</A></P><H4><A NAME="l5">Listing Five</H4><pre>("InsertEmployee", '''\insert into EMPLOYEE(id, name, salary, hire_date) values ([?:long id], [?:String name], [?:float salary],                                        [?:Timestamp hireDate])''')</pre><P><A HREF="#rl5">Back to Article</A></P></body></html>