<html><head><title>Aug01: Programmer's Bookshelf</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>A C++ Duo</h1><p><i>Dr. Dobb's Journal</i> August 2001</p><h3>By Peter Roth</h3><I>Peter is president of Engineering Objects International, producers of commercial and custom Delphi and C++ components. He can be contacted at http://engineeringobjects.com/ and peteroth@erols.com.</I><hr><h4><br>C++Builder 5 Developer's Guide<br><br><i><br>Jarrod Hollingworth,  Dan Butterfield (editor),  Bob Swart, and Jamie Allsop</i><br>Sams, 2000<br>1393 pp., $60.00<br>ISBN 0672319721<br><br>C++ and Object-Oriented Numeric Computing for Scientists and Engineers <br><i>Daoqi Yang </i><br>Springer-Verlag, 2001 <br>440 pp., $49.95<br>ISBN 0387989900<br></h4><p>These days, software producers no longer print kilopages of documentation, but instead concentrate their efforts on online help. Given the breadth that software assumes these days, this is a reasonable approach. </p><p>Borland and RogueWave, for instance, produce the online help files for the Borland C++Builder toolset (RogueWave provided the STL for this version of BCB). The help files are comprehensive, and as far as I can tell, completely subsume any printed documentation. However, help files are not a book, with everything that implies.</p><DDJADVERTISEMENT INLINE><p>Product-related books are a form of printed documentation produced by third parties who, while not directly responsible for producing the software, are usually given access to the product prior to its release so the product and book launches occur nearly simultaneously.<i></p><p>C++Builder 5 Developer's Guide</i> is one of few Borland C++Builder books available at your bookseller, but before I say more about it, let me briefly introduce Version 5 of Borland C++Builder itself.</p><p>Borland C++Builder (BCB) is the integrated development environment and toolset Borland markets for C++ developers writing for Windows. The compiler is available alone as a free download from the Borland web site. This is the command-line compiler; you may also download the Turbo Debugger, but no other tool accompanies the download.</p><p>BCB was built to make Windows programming easier. It uses the Borland Delphi Visual Component Library (VCL), a framework that wraps the Windows API in a far more facile way than does MFC. The VCL is written in Object Pascal, the language of Borland's Delphi product. Hence, BCB is polyglot, compiling C, C++, and Object Pascal. </p><p>Borland has added a few extensions to the C++ language to make the use of the VCL easier. I use BCB to produce what I imagine to be standard C++ because I only use the extensions when accessing the VCL.<i></p><p>C++Builder 5 Developer's Guide</i>, by Jarrod Hollingworth, Dan Butterfield (editor), Bob Swart, and Jamie Allsop, has about 30 contributors, some of whom had about two years of C++ experience at the time of writing. The text is published with a CD-ROM, which contains the complete text of the book, a trial version of BCB 5, source-code examples, and the usual third-party promotional material.</p><p>Unfortunately, there are differences between the printed page and the CD-ROM version. In the print version, the front matter is labeled with Roman numerals, for instance, whereas the CD version counts pages as if the book started numbering all pages in Arabic. Hence, all the CD page numbers differ from the printed page by at least 42. Referring from one to the other is not straightforward. Further, there is no active index in the CD version, so the only way to find a topic is by using the Adobe Acrobat Reader <i>find</i> command. However, the second printing of the book included a number of corrections for the first printing, including modifications to the CD. For example, the navigation pane of the second printing has hyperlinks, letting you find a particular chapter or topic. </p><p>The C++ used in <i>C++Builder 5 Developer's Guide</i> is "a better C." There's not much devoted to templates, and the 15-page discussion of the Standard C++ Library appears on the CD-ROM only. I advise skipping the chapter, as it is incorrect on specifics and too shallow to do the subject justice.</p><p>Code quality is uneven, but that is to be expected in a work of this size, with a variety of experience among the authors. </p><p>In some cases &#151; and I never thought I'd see myself write this &#151; there are too many comments: Classes end with <i>};//TheClassName</i>, each member ends with <i>};//memberName</i>, and so on. This is just clutter. Sometimes, class membership is denoted by a leading underscore, a practice best avoided because it reduces potential clashes with the Standard Library. There is some bizarre formatting, a mix of tabs and spaces. You must have your tab stops set at 4, or else the sample code will be a pain to read.</p><p>BCB supports the use of more technologies than I will ever use. <i>C++Builder 5 Developer's Guide</i> is reflective of the product, and given finite time, there is no way to intelligently comment on everything. Having used Borland tools consistently since Turbo Pascal 2, I skimmed the chapters on the IDE, debugging, and building components, but these chapters will be of interest to someone just picking up the product. </p><p>Other areas addressed: COM, DCOM, COM+; communications, web and database programming; the use of Borland's MIDAS multitier product; ActiveX and CORBA technologies; and integrating applications with Microsoft Office. Given the page limitations and the number of topics covered, you should keep the "Guide" aspect of the title in mind; coverage is wide, but not deep.</p><p>The presentations I found most interesting were:</p><ul>  <li>TeamSource, the source-code control system used internally at Borland.   <li>Software distribution: what to ship, how to sell, where to advertise, and so on, in Chapter 28 (CD).  <li>Tips and tricks, Chapter 31 (CD) had a discussion of floating-point math that should be required reading for all newbies. It might minimize the newsgroup posts entitled "Why is 1/3+1/3+1/3!=1?"  <li>A real-world example, for engineers, in Chapter 31 (CD). I would have put this at the beginning of the book because it demonstrates how easily a Windows app can be generated with BCB.</ul><p>Appendix A is a convenient and useful compendium of reference material: web sites, books, magazines, newsgroups, and the like, related to C++ and BCB.</p><p>All in all, <i>C++Builder 5 Developer's Guide</i> is an uneven book, but it's the first one I'd recommend when you need a quick intro to a specific technology using BCB.</p><p>The first sentence of the Preface in <i>C++ and Object-Oriented Numeric Computing for Scientists and Engineers</i>, by Daoqi Yang, declares the aim of the book to be an easy and concise introduction to C++. Unfortunately, the text falls short. The first four tedious chapters discuss the minutiae of the language syntax. There is really nothing specific to C++ here, and the text could easily apply to any procedural language with a C syntax: "Here's how to iterate, let's use iteration to solve a numerical problem," and so on.</p><p>Chapter 5 introduces classes, and the book becomes more C++ specific at this point. The class concept is used to organize the solution of ordinary differential equations using the Euler and Runge-Kutta methods. But the introduction to classes is very brief, probably too brief. And the constructor initializer list is not mentioned.</p><p>In Chapter 6, operator overloading is demonstrated with a small complex number class followed by vector and matrix classes, and the algorithm and C++ code for the conjugate gradient solution of simultaneous equations is introduced. Memory management in the classes is based on a C pointer-to-double rather than on an STL vector or <i>valarray</i>. The chapter also includes a section on the efficiency gained by delaying evaluation, similar to the use of expression templates. </p><p>Up to this point, the example code has used a single error function to report program errors and terminate. In Chapter 7, the error processing changes from a function call to the printing of a message and continuing (not stopping)! It seems to me that this code could not have been tested with anything other than "good" data. <i>valarray</i> is described, but not used anywhere. (I would expect numeric work to use <i>valarray</i> more heavily, although I must admit to seeing very little written about it.) The chapter closes with some interesting work using expression templates that continues the discussion of delayed evaluation. The idea is to minimize the number of memory fetches and the number of temporaries. Good stuff, but I would think it more "advanced" than "introductory."</p><p>Class inheritance is introduced as another organizing principle in Chapter 8. A discussion of multiple inheritance is also included, which I believe is too much inheritance for an introductory text. Full, banded, and symmetric matrices are derived from the earlier matrix class.</p><p>And then the "concise" aim stated in the Preface seems to take over. Chapter 9 on exception handling is too short, at 12 pages. Exceptions are said to apply to "library writers," which means that students will tend to skip the whole idea of exceptions. Chapter 10 on containers and algorithms is too brief an introduction to the STL. In Chapter 11, the matrix library is redefined and incorporates solvers for various matrix forms.</p><p>There is little to no discussion of the problems inherent in floating-point computations, and there is no error analysis of the computations. Some way to estimate the error of each calculation would be preferable.</p><p>Although <i>C++ and Object-Oriented Numeric Computing for Scientists and Engineers</i> has a 2001 copyright date, the code "looks old," which probably reflects the lag time in writing the book.</p><p>Having cursed make on several systems, the line "the make utility...provides easy management of compiling source files..." brought back memories. Certainly, I would not expect many difficulties from make if I were only dealing with the few files involved in the examples.</p><p>There are also several irritations:</p><ul>  <li>Inconsistent use of <i>&lt;xxx&gt;</i> and <i>&lt;xxx.h&gt;.</i>  <li>Use of <i>j++</i> where <i>++j </i>is apropos.  <li>Using <i>namespace std;.</i>  <li>The early introduction (Chapter 2) of the <i>goto</i>.   <li>STL containers and algorithms ignored for the most part.  <li>Libraries of code are developed, yet they fail to use exceptions and use an <i>error</i> function instead.</ul><p>You might argue, "Yes, these are irritating, but many, if not most, programs written by engineers are short, one-off pieces designed to get an answer." However, I've had to deal with too many one-off engineering programs that became zombies: They should've been buried long ago, but they just would not die! The student learns from and forever emulates a poor style; later learning is hobbled because the bad way "works," and more zombie programs are unleashed. Argh!</p><p>If you are not familiar with C++, learn the language from <i>Accelerated C++: Practical Programming by Example</i>, by Andrew Koenig and Barbara E. Moo (Addison-Wesley, 2000).</p><p>If you are already familiar with C++ and need some numerical algorithms, the appropriate sections of <i>C++ and Object-Oriented Numeric Computing for Scientists and Engineers</i> may be worth the price. I, for example, enjoyed the discussions of delayed evaluation and the conjugate gradient method. However, one final caveat: You might be tempted to simply download the code from the author's web site (http://www.math.wayne .edu/~yang/) and plug it into a program. But if you do so, I suggest you rewrite most of it, at least to make it sturdy.</p><p><b>DDJ</b></p></body></html>