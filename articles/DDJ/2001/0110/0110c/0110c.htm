<html><head><title>Oct01: Precompiled Headers & Normal C++ Semantics</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Precompiled Headers &amp; Normal C++ Semantics</h1><p><i>Dr. Dobb's Journal</i> October 2001</p><h2>Performance and  compatibility</h2><h3>By Jeffrey Taylor</h3><I>Jeffrey is a C++ consultant who can be contacted at <a href="mailto:jtaylor@solidworks.com">jtaylor@solidworks.com</a>.</I><hr><p>To reduce the amount of time required to build a project, Microsoft's Visual C++ supports precompiled headers. When a header file is included by many C++ files in a project, the header file may be added to the precompiled header and compiled only once for the entire project, rather than once for every C++ file in that project. I have seen the use of precompiled headers halve the build time. Of course, each project will have unique characteristics, and the level of improvement may vary.</p><p>However, it is possible to arrange pre-compiled header files in a manner that is inconsistent with normal C++ semantics. Sun compilers, for instance, do not support precompiled headers. Nevertheless, when code is structured properly, precompiled headers can be used with Visual C++ and still be compatible with Sun's compilers.</p><DDJADVERTISEMENT INLINE><p>On Solaris, for instance, <A NAME="re1"><A HREF="0110ce1.htm">Example 1</A> prints "James Brown." While you might guess that when using the precompiled headers in Visual C++, the program would print "Charlie Daniels," in fact, it instead prints "Charlie Brown." This command line creates a precompiled header when using Visual C++:</p><blockquote><p>cl /c /Ycpch.h pch.cpp</p></blockquote><p>The <i>/Yc</i> option instructs Visual C++ to create a precompiled header, checkpointing the compilation state after pch.h is processed. In <A NAME="re1"><A HREF="0110ce1.htm">Example 1</A>, the precompiled data is kept in a file called "pch.pch" and includes the definition of <i>STR1</i> and all of iostream.h. Compilation continues after pch.h is processed, but later data is not written to pch.pch. In this example, the definition of <i>STR2</i> is not included in pch.pch.</p><p>The precompiled header data may be used with the following command:</p><blockquote><p>cl /Yupch.h main.cpp</p></blockquote><p>The<i> /Yu</i> option instructs Visual C++ that the source file will attempt to include pch.h. When the <i>include</i> statement is processed, the compiler uses the precompiled data in pch.pch rather than processing pch.h. In <A NAME="re1"><A HREF="0110ce1.htm">Example 1</A>, <i>STR1</i> is defined as "Charlie" in the precompiled header. <i>STR2</i> is defined as "Brown" from main.cpp. "Charlie Brown" is printed.</p><p>Within the Microsoft development environment, Visual C++ precompiled header specifications for a project can be viewed by pressing Project, Settings, the C/C++ tab, and finally, the category Precompiled Headers.</p><p>Typically, one C++ file in the project is set to "Create precompiled header file (.pch) through header &lt;some_filename.h&gt;." This is the first file built for the project. When the debug configuration is built, the data from the compilation of this file, up to and including "&lt;some_filename.h&gt;," is placed in a file named "WinDebug/your_project_name.pch."</p><p>Most files will be set to "Use precompiled header file (.pch) through header: &lt;some_filename.h&gt;." This tells Visual C++ that when it parses <i>#include &lt;some_filename.h&gt;,</i> it should disregard "some_filename.h" and insert the precompiled header.</p><p>To ensure compatibility, do not put anything in pch.cpp, except <i>#include &lt;pch.h&gt;</i>. As in <A NAME="re2"><A HREF="0110ce2.htm">Example 2</A>, move the definitions of <i>STR1</i> and <i>STR2</i> into pch.h using this approach. The performance benefits from the use of precompiled headers is not diminished, the code is easier to read, and the results are consistent with normal C++ semantics.</p><p>I was not able to find any documentation from Microsoft that specifically recommends the structure for precompiled header files. However, the comments that Visual C++ inserts into AppWizard projects are consistent with my approach. When Microsoft Visual C++ 6.0 creates a new Win32 Application project (A typical "Hello World" application), it creates a file called "stdafx.h" with the following text:</p><blockquote><p>// stdafx.h : include file for standard system //                                   include files,</p><p>// TODO: reference additional headers your //                      program requires here</p></blockquote><p>It creates a file, "stdafx.cpp," with the text:</p><blockquote><p>// stdafx.cpp : source file that includes just //                       the standard includes</p><p>#include "stdafx.h"</p><p>// TODO: reference any additional headers //                      you need in STDAFX.H </p><p>//                           and not in this file</p></blockquote><p>Clearly, my approach is consistent with Microsoft's architecture, yet still enables compatibility with Solaris.</p><p><b>DDJ</b></p></body></html>