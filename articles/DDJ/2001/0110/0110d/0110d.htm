<html><head><title>Oct01: C++ Set-Theoretic Operations on Virtual Containers</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>C++ Set-Theoretic Operations on Virtual Containers</h1><p><i>Dr. Dobb's Journal</i> October 2001</p><h2>Performing set operations on the fly</h2><h3>By Gregory Begelman, Lev Finkelstein, and Evgeniy Gabrilovich</h3><I>The authors are members of the Algorithms Group at Zapper Technologies. They can be contacted at <a href="mailto:gbegelman@hotmail.com">gbegelman@hotmail.com</a>, <a href="mailto:lev@cs.technion.ac.il">lev@cs.technion.ac.il</a>, and <a href="mailto:gabr@acm.com">gabr@acm.com</a>, respectively.</I><hr><p>The C++ Standard Template Library (STL) provides the set-theoretic operations <i>union, intersection, difference, </i>and <i>symmetric difference,</i> accessible through the header file <i>&lt;algorithm&gt;</i>. These operations (or "algorithms" in STL-ese) are applicable to sets, as well as to other sorted ranges with input iterators defined. Given two ranges of input iterators and an output iterator, set algorithms construct a new range implementing the desired operation. </p><p>When the result of a set operation is needed only for some interim manipulation (for sweeping over its elements once, for instance), two scenarios are possible with the conventional STL approach:</p><DDJADVERTISEMENT INLINE><ul>  <li>The outcome range is actually constructed in a temporary data structure, filled through an insert iterator (that is, an adaptor that implements the interface of an output iterator so that any element assigned to it is inserted into the underlying container). <A NAME="rl1"><A HREF="#l1">Listing One</A> illustrates this approach by computing an intersection of two sets of integers. An obvious drawback of this approach is the overhead to create (and eventually to deallocate) this auxiliary structure with all the element copying involved.  <li>The code fragment to be applied to the outcome range is encapsulated in an iterator-like object that satisfies all the assumptions of an output iterator. This object is passed as an output parameter to set operations, and thus gets invoked on each element of the resulting range as a callback function. <A NAME="rl2"><A HREF="#l2">Listing Two</A> implements this technique for the intersection operation. A disadvantage of this technique is that detaching the code from regular program flow and encapsulating it in an auxiliary object makes the implementation cumbersome (especially when the code fragment uses multiple external variables defined elsewhere).</ul><p>Consequently, we propose an alternative approach in which the output range is built in a "lazy" manner, its elements being computed only when needed; see <A NAME="rl3"><A HREF="#l3">Listing Three</A>. To this end, we define a virtual container featuring a constant input iterator, <i>const_iterator </i>(note that the use of "virtual" here has nothing to do with virtual functions). Successively incrementing this iterator virtually traverses the elements of the resulting range in the correct order without actually constructing the range. The iterator has to be constant, since otherwise modifying the elements it points to might invalidate the ordering of input ranges. (The complete source-code implementation of this technique is available electronically; see "Resource Center," page 5.)</p><p>Our approach provides template-based classes (virtual containers) <i>set_union_online</i>, <i>set_intersection_online</i>, <i>set_difference_online</i>, <i>set_symmetric_difference_online</i>, and <i>merge_online</i>. (The <i>inplace_merge</i> algorithm is not suitable for this treatment because its main purpose is to actually merge its input ranges in the same memory space where the original elements reside.) The differences in logic of these operations are realized in different imple- mentations of the increment (<i>op++()</i>) and dereference (<i>op</i>*<i>()</i>) operators of each container's iterator. </p><p>Apparently, the approaches of both <A NAME="rl2"><A HREF="#l2">Listings Two</A> and Three encapsulate the algorithm logic, but the latter has the advantage of doing so only once. While the callback function needs to be specifically designed for each application, we wrap the algorithms of the various set operations in smart iterators that can later be used elsewhere without the need for adaptation.</p><h3>Implementation</h3><p>To perform a set operation in <A NAME="rl3"><A HREF="#l3">Listing Three</A>, we first instantiate the appropriate virtual container, then use its iterator to run through the elements of the output range (we use an input iterator so that dereferencing it yields the desired elements as if the operation outcome range has actually been constructed). To facilitate this approach, the algorithm for computing the desired operation (<i>set_intersection</i>) needs to be encapsulated in the iterator itself. The iterator's increment/dereference operators are thus defined in terms of three auxiliary functions &#151; <i>_pre_increment()</i>, <i>_dereference()</i>, and <i>_find_next()</i> (the latter being used to identify the next element in the output range). These auxiliary functions realize the specific algorithm in hand. To prevent code duplication, we only implement the <i>preincrement</i> operator, which is then used to implement the postincrement version; see <A NAME="rl4"><A HREF="#l4">Listing Four</A>. The iterator template in <A NAME="rl4"><A HREF="#l4">Listing Four</A> only declares these auxiliary functions, while the full implementation is given later for each particular algorithm (<i>set_union_online</i>, <i>set_intersection_online</i>, and so on). </p><p>Our goal was to make the code compatible with a number of major C++ compilers. Consequently, since Microsoft's Visual C++ does not support partial template specialization, we opted for a slightly bulky, but portable, approach. The iterator template declares the three auxiliary functions for all available algorithms, but later each algorithm only implements those functions pertinent to its iterator proper. The linker eventually gets rid of all the unused declarations. This scheme operates a variant of the tag dispatching mechanism (see Generic Programming Techniques, <a href="http://www.boost.org/more/generic_programming.html">http://www.boost.org/more/generic_programming.html</a>), using the definitions of tags and supplementary macros of <A NAME="rl5"><A HREF="#l5">Listing Five</A>.</p><p>The parameters of the iterator class template are:</p><ul>  <li><i>class _T</i>, a value type.  <li><i>class _Iter1</i>, <i>class _Iter2</i>, iterator types for the two input ranges.  <li><i>class _StrictWeakOrdering</i>, a binary predicate for comparing the objects of the two input ranges.  <li><i>class _Tag</i>, an auxiliary class for distinguishing the implementations of various set operations through the tag dispatching mechanism.</ul><h3>Base Class for Virtual Containers</h3><p>All virtual containers implementing set operations derive from the base class in <A NAME="rl6"><A HREF="#l6">Listing Six</A>. The template parameters are mainly used to instantiate the smart iterator and are, therefore, identical to those of <A NAME="rl4"><A HREF="#l4">Listing Four</A>. The base class contains the functionality shared by all set operations; namely, the iterator access functions <i>begin()</i> and <i>end()</i>.</p><h3>Set Algorithms</h3><p><A NAME="rl7"><A HREF="#l7">Listing Seven</A> outlines the core implementation of set algorithms, using set intersection as an example. This code fragment first instantiates the container itself (using the symbolic <i>intersection_tag</i>), then implements the three auxiliary functions of the corresponding iterator:</p><p></p><ul>  <li><i>_pre_increment()</i>, which underlies the implementation of <i>op++()</i>, advances the current position in both of its input ranges, and scans them for the next element to be included in the intersection.  <li><i>_dereference()</i>, used in the dereference operator <i>op</i>*<i>()</i>, returns the element found earlier by the increment operator or the iterator constructor (should the dereference be invoked immediately upon the iterator construction).  <li><i>_find_next()</i>, which implements the essence of the set intersection algorithm, looks for the next element to be added to the resultant set.</ul><p><A NAME="rl7"><A HREF="#l7">Listing Seven</A> uses a set of auxiliary macros to instantiate all the templates involved; these are depicted in <A NAME="rl8"><A HREF="#l8">Listing Eight</A>. Implementation of other algorithms is mostly similar to that of set intersection. </p><h3>Discussion</h3><p>The implementation of set-theoretic operations for C++ we present here does not compromise computational efficiency or programming style. It also satisfies all the assumptions for STL set operations &#151; namely time complexity, stability (where applicable), and support for multisets.</p><p>Additional functionality might be obtained by instantiating the virtual containers developed here on reverse iterators. When the two input ranges are given by reverse rather than forward iterators, it becomes possible to traverse the outcome of set operations backwards &#151; a useful extension under certain circumstances.</p><p>Future extensions to this work can relax the requirements of uniformity on input/output ranges. For example, in some cases it may be necessary to merge sequences of records with different structures, performing a particular set operation based on (comparable) keys available in both kinds of records. Another extension can generalize over the type of output elements, creating a sequence of elements of some new type, different from that of input items.</p><h3>Acknowledgment</h3><p>Thanks to Alex Gontmakher for his helpful comments.</p><p></p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>void temp_intersection() {   vector&lt;int&gt; vec1, vec2, temp_result;   ... // prepare input sequences in 'vec1' and 'vec2'   set_intersection(vec1.begin(), vec1.end(), vec2.begin(), vec2.end(),     back_inserter(temp_result)); // build the result in a temporary container   for (int i = 0; i &lt; temp_result.size(); ++i) {      // do something   }}</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>class callback {      void do_something(int v) {         // do something      }public:      callback &amp;operator=(int v) { do_something(v); return *this;}      callback &amp;operator*() { return *this; }      // op++ for output iterators has a dummy implementation      callback &amp;operator++() { return *this; }      callback &amp;operator++(int) { return *this; }};void callback_intersection() {   vector&lt;int&gt; vec1, vec2;   ...   set_intersection(vec1.begin(), vec1.end(), 	        vec2.begin(), vec2.end(), callback());}</pre><P><A HREF="#rl2">Back to Article</A></P><H4><A NAME="l3">Listing Three</H4><pre>void online_intersection() {   vector&lt;int&gt; vec1, vec2;   ...   typedef set_intersection_online&lt;int,                                    vector&lt;int&gt;::iterator&gt; IntersectionOnline;   IntersectionOnline res(vec1.begin(), vec1.end(), vec2.begin(), vec2.end());   for (IntersectionOnline::const_iterator iter =         res.begin(); iter != res.end(); ++iter) {      // do something   }}</pre><P><A HREF="#rl3">Back to Article</A></P><H4><A NAME="l4">Listing Four</H4><pre>template&lt;class _T, class _Iter1,                    class _Iter2, class _StrictWeakOrdering, class _Tag&gt;class _const_set_online_iterator {public:   typedef _T value_type;     private:   // Iterators to the current and last elements of the input ranges   _Iter1 _current1, _last1;   _Iter2 _current2, _last2;   // Possible outcomes of comparing the current elements in the input ranges:   // FIRST      : _StrictWeakOrdering(*current1, *current2) == true   //                   or the second range has been exhausted                 // SECOND : _StrictWeakOrdering(*current2, *current1) == true   //                   or the first range has been exhausted   // EQUAL    : neither the first nor the second condition is true   enum compare_state { FIRST, SECOND, EQUAL };   // The comparison state is used in iterator increment and dereference   compare_state _compare;         compare_state get_compare_state() const {      if (_current1 == _last1) return SECOND;      if (_current2 == _last2) return FIRST;      if (_StrictWeakOrdering()(*_current1, *_current2)) return FIRST;      if (_StrictWeakOrdering()(*_current2, *_current1)) return SECOND;      return EQUAL;   }   // These functions need to be defined with the corresponding tag parameter:   // inline _const_set_online_iterator&amp; _pre_increment(const _Tag&amp;);   // inline void _find_next(const _Tag&amp;);   // inline const value_type _dereference(const _Tag&amp;) const;   //   // Since MS VC++ does not support partial template specialization we    // declare these functions for all possible tags. The implementation,    // however, is provided only for the pertinent tag.   INSTANTIATE_FOR_ALL_OPERATIONS(DECLARE_PRE_INCREMENT)   INSTANTIATE_FOR_ALL_OPERATIONS(DECLARE_DEREFERENCE)   INSTANTIATE_FOR_ALL_OPERATIONS(DECLARE_FIND_NEXT)      void find_next() {       _find_next(_Tag());    }public:   // The constructor takes two boundary elements for each of the input ranges   _const_set_online_iterator(const _Iter1&amp; current1, const _Iter1&amp; last1,                   const _Iter2&amp; current2, const _Iter2&amp; last2) :      _current1(current1), _last1(last1), _current2(current2), _last2(last2)   {      _compare = get_compare_state();                                 // update compare state for current elements      find_next();  // find the next element for which the predicate is true   }   // Basic operators   bool operator==(const _const_set_online_iterator&amp; rhs) const {      return ((_current1 == rhs._current1) &amp;&amp; (_current2 == rhs._current2));   }   bool operator!=(const _const_set_online_iterator&amp; rhs) const {      return !operator==(rhs);   }   _const_set_online_iterator&amp; operator++() {      return _pre_increment(_Tag());   }   _const_set_online_iterator&amp; operator++(int) {      _const_set_online_iterator temp = *this;      ++(*this);      return temp;   }   const value_type operator*() const {       return _dereference(_Tag());    }};</pre><P><A HREF="#rl4">Back to Article</A></P><H4><A NAME="l5">Listing Five</H4><pre>struct union_tag {};struct intersection_tag {};struct difference_tag {};struct symmetric_difference_tag {};struct merge_tag {};// Declaration of the pre-increment operator#define DECLARE_PRE_INCREMENT(tag)               \inline _const_set_online_iterator&amp; _pre_increment(const tag&amp;);// Declaration of the dereference operator#define DECLARE_DEREFERENCE(tag)                 \inline const value_type&amp; _dereference(const tag&amp;) const;// Declaration of 'find_next' function#define DECLARE_FIND_NEXT(tag)                    \ inline void _find_next(const tag&amp;);#define INSTANTIATE_FOR_ALL_OPERATIONS(MACRO)     \MACRO(union_tag)                                  \MACRO(intersection_tag)                           \MACRO(difference_tag)                             \MACRO(symmetric_difference_tag)                   \MACRO(merge_tag)</pre><P><A HREF="#rl5">Back to Article</A></P><H4><A NAME="l6">Listing Six</H4><pre>template&lt;class _T, class _Iter1, class _Iter2,                                  class _StrictWeakOrdering, class _Tag&gt;class _set_online {   _Iter1 _first1, _last1;   _Iter2 _first2, _last2;public:   typedef _T value_type;   typedef _const_set_online_iterator&lt;_T, _Iter1,                                     _Iter2, _StrictWeakOrdering, _Tag&gt;                 _const_iterator;   _set_online(_Iter1 first1, _Iter1 last1, _Iter2 first2, _Iter2 last2) :      _first1(first1), _last1(last1), _first2(first2), _last2(last2) {}   _const_iterator begin() const { return _const_iterator(_first1,                                                _last1, _first2, _last2); }   _const_iterator end() const { return _const_iterator(_last1,                                                _last1, _last2, _last2); }};</pre><P><A HREF="#rl6">Back to Article</A></P><H4><A NAME="l7">Listing Seven</H4><pre>INSTANTIATE_SET_ONLINE(set_intersection_online, intersection_tag)INSTANTIATE_PRE_INCREMENT(intersection_tag){   ++_current1;   ++_current2;   find_next();   return *this;}INSTANTIATE_DEREFERENCE(intersection_tag){   return *_current1;}INSTANTIATE_FIND_NEXT(intersection_tag){   if (_current1 == _last1 || _current2 == _last2) {      _current1 = _last1;      _current2 = _last2;      return;   }   while (_StrictWeakOrdering()(*_current1, *_current2) ||     _StrictWeakOrdering()(*_current2, *_current1))    {      while ((_current1 != _last1) &amp;&amp;         _StrictWeakOrdering()(*_current1, *_current2))         ++_current1;                  if (_current1 == _last1) {         _current2 = _last2;         return;      }      while ((_current2 != _last2) &amp;&amp;         _StrictWeakOrdering()(*_current2, *_current1))         ++_current2;      if (_current2 == _last2) {         _current1 = _last1;         return;      }   }}</pre><P><A HREF="#rl7">Back to Article</A></P><H4><A NAME="l8">Listing Eight</H4><pre>// Auxiliary macro for instantiating "virtual containers"#define INSTANTIATE_SET_ONLINE(classname, tag)          \template&lt;class _T,                                      \         class _Iter1,                                  \         class _Iter2 = _Iter1,                         \         class _StrictWeakOrdering = std::less&lt;_T&gt; &gt;    \class classname :                                       \   public _set_online&lt;_T, _Iter1, _Iter2, _StrictWeakOrdering, tag&gt;     \{                                                       \public:                                                 \   typedef _T value_type;                               \   classname (_Iter1 first1, _Iter1 last1, _Iter2 first2, _Iter2 last2) :  \      _set_online&lt;_T, _Iter1, _Iter2, _StrictWeakOrdering, tag&gt; \   (first1, last1, first2, last2)                       \   {}                                                   \};// Auxiliary macro for instantiating the pre-increment operator#define INSTANTIATE_PRE_INCREMENT(tag)                  \template&lt;class _T, class _Iter1, class _Iter2, class _StrictWeakOrdering,   \               class _Tag&gt;                              \inline _const_set_online_iterator&lt;_T, _Iter1, _Iter2,   \                                         _StrictWeakOrdering, _Tag&gt;&amp;      \   _const_set_online_iterator&lt;_T, _Iter1, _Iter2,       \                                       _StrictWeakOrdering, _Tag&gt;::       \_pre_increment(const tag&amp;)// Auxiliary macro for instantiating the dereference operator#define INSTANTIATE_DEREFERENCE(tag)                    \template&lt;class _T, class _Iter1, class _Iter2, class _StrictWeakOrdering,  \              class _Tag&gt;                               \inline const _const_set_online_iterator&lt;_T, _Iter1, _Iter2,                \                                 _StrictWeakOrdering, _Tag&gt;::value_type    \   &amp;_const_set_online_iterator&lt;_T, _Iter1, _Iter2,       \                       _StrictWeakOrdering, _Tag&gt;::      \_dereference(const tag&amp;) const// Auxiliary macro for instantiating the "find_next" function#define INSTANTIATE_FIND_NEXT(tag)                      \template&lt;class _T, class _Iter1, class _Iter2, class _StrictWeakOrdering,  \               class _Tag&gt;                              \inline void _const_set_online_iterator&lt;_T, _Iter1, _Iter2,              \                                     _StrictWeakOrdering, _Tag&gt;::        \_find_next(const tag&amp;)</pre><P><A HREF="#rl8">Back to Article</A></P></body></html>