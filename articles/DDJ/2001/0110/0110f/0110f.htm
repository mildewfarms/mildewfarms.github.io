<html><head><title>Oct01: Scripting with Java & Python</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Scripting with Java &amp; Python</h1><p><i>Dr. Dobb's Journal</i> October 2001</p><h2>Building a Python console window in a Java application</h2><h3>By Boudewijn Rempt</h3><I>Boudewijn is a senior developer at Tryllian in the Netherlands. He can be contacted at <a href="mailto:boud@rempt.xs4all.nl">boud@rempt.xs4all.nl</a>.</I><hr><p>There are any number of situations where you might want to add scripting capabilities to applications. Advanced users, for instance, often want to automate actions. Organizations, on the other hand, might want to create complete customized versions of their standard apps. Application scripting comes in many flavors &#151; simple key-recording macros, externally exposed APIs (such as COM or DCop), and complete embedded programming languages. In this article, I'll describe how I embedded a standard language, Python, into a Java application. To do so, I used a Python console window to expose an interface to the application in addition to the complete Python functionality to the application user. A console window such as this is great for quick execution of ad hoc scripts, as well as for controlled execution of larger user scripts.</p><h3>The Situation</h3><p>At Tryllian (where I work; <a href="http://www.tryllian.com/">http://www.tryllian.com/</a>), we created a toolkit for developing mobile intelligent agent systems. These agent systems consist of thousands of intelligent programs that travel from computer to computer. (Of course, those agents are not hosted by the operating system &#151; that would make them viruses!) An essential component of agent systems is a quasivirtual world where the agents can live. These virtual worlds (habitats) are large server applications that must be administered like any other server application (such as a database); see <A NAME="rf1"><A HREF="0110ff1.htm">Figure 1</A>. This is done using special management tools. </p><DDJADVERTISEMENT INLINE><p>Administrative tasks include the division of the agent world into smaller parts, where agents interested in the same topic can meet more selectively, checking load levels, tracing rogue agents, and correcting problems. Most of these tasks can be automated but are dependent upon the server tasks.</p><p>To give application administrators maximum flexibility, we included in the management tool a scripting facility called "pyconsole" in the form of a console window where scripts can be loaded and started, and small tasks programmed on-the-fly. (Admittedly, we were inspired by ObjectDomain's Jython console window; see <a href="http://www.objectdomain.com/">http://www.objectdomain.com/</a>.) While this solution is not suitable for every application, it works very well when the application is intended for programmers or technically advanced server administrators.</p><h3>Scripting for Java</h3><p>From completely new languages to tiny implementations of Scheme, there are more than a hundred scripting languages available for Java (see <a href="http://grunge.cs.tu-berlin.de/~tolk/vmlanguages.html">http://grunge.cs.tu-berlin.de/~tolk/vmlanguages.html</a>). However, the maturest scripting language is probably Jython (<a href="http://www.jython.org/">http://www.jython.org/</a>). </p><p>Recall that there are two Python implementations &#151; one in C, the other in Java. The Java implementation of Python has always been called "JPython," but because of some legal wranglings, the name has been changed to "Jython." This Java implementation closely tracks C Python; in fact, most of the C Python 2.0 constructs are available in Jython.</p><p>Jython includes a small Swing console application, written in Python, that begs to be included in Java applications. To do that, you must compile the Python code to Java, use the compiled classes in the Java application, and then find a way to communicate between the Jython interpreter running in the console window and the application. Furthermore, if the embedding application uses Java security features &#151; especially the <i>SecureClassLoader</i> &#151; further steps must be taken.</p><p>The Python sources that will form pyconsole.jar (available electronically; see "Resource Center," page 5) include:</p><ul>  <li>Console.py, the main console interface.  <li>Action.py, the implementation of <i>AbstractAction</i>.  <li>Keymap.py, which implements keyboard handling.  <li>Styles.py, text drawing styles.</ul><p>Of these, Console.py is the most interesting, since it is the part you need to change so that you can embed the console class into your application (just like any other Java Swing widget).</p><h3>Exposing the Application API</h3><p>Of course, one problem you face is exposing the application API and data model to the Python interpreter so that users can add functionality to their applications. Perhaps the best solution to this is to create a <i>facade</i> class that exposes only those parts of the application class model you want exposed to the scripting interface. You can expose methods that create new objects or return existing objects to the Python interpreter. However, if those objects include methods that return unexposed objects, you might have created a security risk.</p><p>I have found that the most comfortable way to hand this <i>facade</i> class over to the Python interpreter is to create a <i>Console</i> class constructor that has two parameters &#151; one of the type <i>Object</i> that receives the facade, and another of the type <i>java.lang.String</i> that receives the name of the facade; see <A NAME="re1"><A HREF="0110fe1.htm">Example 1</A>.</p><p>Console.py provides a dictionary called "locals" to which this object is added, with the name as <i>key</i>. This dictionary is used by the interpreter (in the class <i>PythonThread</i>) as a repository for added names available to the current interpreter action. The Python statement <i>exec</i> takes the form: </p><blockquote><p>exec compiled_code in dictionary</p></blockquote><p>Jython automatically has access to all public methods and variables present in the passed object; not just to the rather limited interface of the Java <i>Object</i> class. You don't need to cast the adapter <i>Object</i>: Python is as weakly typed as it gets, and doesn't try to hide anything from the user just because an object arrived as <i>Object</i> and not as <i>MyComplicatedFacade</i> (extends <i>Object</i>).</p><h3>Preparing Jython Code To Be Called From Java</h3><p>Any Jython code can be compiled to Java source code, which can then be compiled to bytecode that the Java virtual machine can run. However, if the resulting class files are to be used as a package from Java applications, it is necessary to help the compiler by adding signatures to all public functions.</p><p>These signatures are codes in the documentation strings of the Python functions that start with the keyword <i>@sig</i>, and give the entire function specification as if it were Java, complete with access modifiers and return values. You have to give the complete package location for every type, except for those in java.lang.</p><p>A second requirement is that you must make the Python class <i>Console</i> inherit the Java class <i>Object</i>; otherwise, Java classes won't be able to create a <i>Console</i> instance or call its methods. This exposes an interesting point of Jython programming &#151; creating a second object hierarchy. Python objects in Jython are not automatically Java objects; you can actually create objects that do not descend from Java's <i>Object</i> class.</p><h3>Compiling Jython Code to a Java JAR</h3><p>Jython can automatically create a JAR file for you when you give a command like <A NAME="re2"><A HREF="0110fe2.htm">Example 2</A>.</p><p>If you use the <i>--</i><i>package</i> option, you can create a package where there wasn't one before, making it easy to comply with standards. Of course, since this code was originally part of the Jython distribution, something might be said for an org.jython.pyconsole package hierarchy.</p><h3>Embedding a Jython Swing Component in a Java App</h3><p>Although the <i>Console</i> class already includes a main method so you can run it on its own, the real fun comes with embedding the console in an application. To do that, you can extend a JFrame, and in the constructor, create a new <i>Console</i>, passing the API <i>facade</i> and creating a new <i>JScrollPane</i> that you pass the text pane from the <i>Console</i>; see <A NAME="re3"><A HREF="0110fe3.htm">Example 3</A>.</p><h3>Security Problems</h3><p>There is a clever hack in the Jython libraries: the pawt library, which can be used by Jython programs to construct GUIs that run either with JDK Version 1.1 or 1.2 (and greater). This is done by constructing classes in bytecode on the fly. However, if the application uses the <i>SecureClassLoader</i> from the java.security package, using those classes will give an endless stream of security-related errors.</p><p>This is because the class does not come from a JAR file and, therefore, cannot be signed. Such a class does not have any permissions under a strict security regime &#151; it cannot be used to instantiate objects, for instance.</p><p>The solution is to eradicate all use of the pawt module and change those instances to direct calls to javax.swing. Jython simply uses the existing Java implementations instead of generating its own bytecode. The external appearance is the same, and nowadays, AWT is of less and less importance for standalone applications.</p><h3>Conclusion</h3><p>Apart from the potentially baffling security problems &#151; that are easy to avoid if you're aware of them &#151; it's easy to embed scripting functionality in a Java application. By doing so, you empower advanced users to make better use of the tools you provide.</p><p><b>DDJ</b></p></body></html>