<html><head><title>Oct01: Algorithm Alley</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Replacing a  Dictionary with a Square Root</h1><p><i>Dr. Dobb's Journal</i> October 2001</p><h3>By Tom Cargill</h3><I>Tom is a consultant based in Boulder, Colorado. He can be contacted at <a href="http://www.profcon.com/cargill/">http://www.profcon.com/cargill/</a>.</I><hr><p>In the widely used GIF format, images are compressed using a representation that can be produced by applying the Lempel-Ziv-Welsh algorithm (see "A Technique for High-Performance Data Compression," by T. Welsh, <i>IEEE Computer</i>, June 1984) to the pixels of the raw image. However, creating a GIF encoding does not require the use of the Lempel-Ziv-Welsh (LZW) algorithm. A GIF encoding that is produced by means other than LZW is still a GIF encoding. To emphasize the point, a GIF encoding might be produced (in principle) by generating all possible encodings, ordered by size, until one is found that decodes satisfactorily. Indeed, for some inputs, this theoretical approach yields better compression than LZW.</p><p>Deciding how to program the encoding of a GIF image is complicated (until 2003) by a patent (U.S. Patent 4,558,302. "High speed data compression and decompression apparatus and method") held by Unisys on the LZW algorithm. By all accounts, CompuServe was unaware of the patent when LZW was chosen for GIF. Programmers wishing to generate GIFs without addressing this legal issue must consider alternative algorithms. In <i>Compressed Image File Formats</i> (ACM Press, 1999), John Miano discusses an approach that is very simple, at the cost of negative compression:</p><DDJADVERTISEMENT INLINE><blockquote><p>The easiest way to implement a GIF encoder without using LZW is to simply encode each data byte using 9 bits and output a clear code after every 254 codes.</p></blockquote><p>Can you do better than 9 bits per pixel without infringing the patent?</p><h3>Line Drawing Images</h3><p>Recently, in programming a GIF generator, I had already started using Miano's approach when it struck me that, because all the images were line drawings, they would yield to a significantly more effective algorithm. Like Miano's, this algorithm uses none of the mechanisms of LZW. Unlike Miano's, it produces satisfactory compression for line drawings.</p><p>For these purposes, the crucial property of a line drawing is that most of it is empty; that is, it is dominated by long runs of background color. The dominance of background color runs makes a line drawing an ideal candidate for run-length encoding (see <i>Fundamentals of Interactive Computer Graphics</i>, by James D. Foley and Andries Van Dam, Addison-Wesley, 1982). While LZW does not produce an explicit run-length encoding, its generic dictionary mechanism naturally discovers and exploits runs in the input. LZW does not distinguish consecutive occurrences of the same value from other sequences of values; it merely exploits repeated sequences. When processing a line drawing, the contents of an LZW dictionary is therefore dominated by ever-longer runs of background color.</p><p>Though motivated by line drawings, the proposed algorithm works well on any image, or other data, that would compress well under run-length encoding. For example, an image with gradient block fill will compress well if the gradient runs vertically, but not if the gradient runs horizontally. A vertical gradient produces horizontal rows of uniform color that are, therefore, runs that can be exploited; a horizontal gradient produces runs in vertical columns, which cannot be exploited.</p><h3>An Alternative Algorithm</h3><p>The algorithm I propose here is derived by studying the input-output behavior of LZW over runs of a single input value, but without depending on its implementation in any way. The analysis is based on feeding runs into LZW and examining its output. For such inputs, LZW's output can be characterized by a simple formula based on the "triangle numbers." The proposed algorithm exploits this formula by inverting the underlying quadratic form into a closed expression that is based on a square root. In effect, LZW's dictionary is replaced by taking the square root of the length of a run.</p><h3>Analyzing LZW</h3><p>The basis of the proposed algorithm can be seen by looking at the output from LZW, as implemented in <A NAME="rl1"><A HREF="#l1">Listing One</A> &#151; a Java method called <i>compress</i> that's modeled on code from Miano. For simplicity of analysis, the input alphabet is restricted to the letters "a" through "z," and the dictionary codes are represented by strings such as "(12)." In practice, GIF literal values and dictionary codes are represented by variable-length bit fields, a complexity that's moot for the purposes of this article.</p><p>Note that this code embodies part of the algorithm that is protected by the LZW patent, which places legal constraints on its use. However, if you are not interested in the details of LZW, you can safely ignore all of the implementation of the <i>compress</i> method. All that matters is that it maps an input string to an output string. Indeed, a central point of this article is that there is no need to know LZW's implementation; it is to be replaced completely. </p><p>To illustrate the basic operation of the method, the call </p><blockquote><p>compress("mississippi")</p></blockquote><p>yields the result</p><blockquote><p>"miss(1)(3)ppi"</p></blockquote><p>The output starts with four literal values from the input, followed by the dictionary entry <i>(1), </i>which represents <i>is</i>. Next comes dictionary code <i>(3)</i>, representing <i>si</i>, followed by three more literal values. The 11-letter input has been compressed to 7 letters and 2 dictionary codes in the output. The degree of compression usually grows with the length of the input, until it reaches an asymptote.</p><p>The string <i>"mississippi"</i> is representative of arbitrary input that contains repeated sequences in an arbitrary manner. LZW happens to exploit the repeated <i>is</i> and <i>si </i>because of the particular behavior of its dictionary, as shown in the compress method. However, for encoding line drawings, we are interested in how LZW encodes runs of a single character. As presented here, we are interested in how the compress method encodes a string such as <i>"aaaaaaaaaaaaaaa."</i> Analyzing the numerical patterns in the input-output mapping of the <i>compress</i> method over such strings permits an equivalent closed-form implementation.</p><p><A NAME="rl2"><A HREF="#l2">Listing Two</A> shows the effects of LZW's dictionary mechanism on inputs that are runs of the same character. It prints the LZW encoding of the strings that are from 1 to 20 repetitions of the single character "a." <A NAME="rf1"><A HREF="0110of1.htm">Figure 1</A> is the output of <i>generateCompressMapping</i> (<A NAME="rl2"><A HREF="#l2">Listing Two</A>).</p><p>By observation, the output always begins with an instance of the underlying value in the run, in this case <i>a</i>. Then, for inputs with a length that is in the sequence 1, 3, 6, 10, 15,..., the "triangle numbers," the output is a uniformly increasing sequence of dictionary codes. The length of the sequence grows by one at each new triangle number. For an input length that is not a triangle number, the output is the same as the output of the preceding triangle number, with one additional value or code.</p><p>The triangle numbers are given by the formula <i>N</i>(<i>N</i>+1)/2, for <i>N</i>=1, 2, 3,... It is the square of <i>N</i> in this formula that results in a square root in the proposed algorithm.</p><p>For inputs that are runs, the proposed algorithm is constructed by inverting the underlying quadratic form, <i>N</i>(<i>N</i>+1)/2. For a given run length, it determines the largest triangle number that does not exceed the length. From that position in the triangle number sequence, and the difference between the run length and the triangle number, the output can be generated directly.</p><p>This algorithm, shown as the <i>encodeRun </i>method in <A NAME="rl3"><A HREF="#l3">Listing Three</A>, operates exclusively in terms of arithmetic &#151; there is no dictionary. Its key operation is a square root that determines the index within the triangle sequence (saved in the index variable). The square root arises from finding a root of a quadratic equation. The variable triangle holds the triangle number itself. The method's input parameters are the repeated value and the number of repetitions.</p><p>For the special case of runs of a single value, this method always yields the same result as the corresponding call to the <i>compress</i> method. For example, <i>compress("xxxxx")</i> and <i>encodeRun('x',5)</i> yield the same result, <i>"x(0)(0)."</i></p><h3>Applying the Algorithm</h3><p>Using the algorithm to encode GIF images is straightforward. For the purposes of this article, I have ignored details such as establishing the GIF color table and dealing with the resulting bit-field lengths. Focusing purely on the compression step that is usually performed by LZW, the modification is easy to code. For that compression step, an encoder merely breaks the input image into runs, and then processes each run with the algorithm shown as <i>encodeRun</i> (<A NAME="rl3"><A HREF="#l3">Listing Three</A>). </p><h3>Measurements </h3><p>In pathological cases, the proposed algorithm can match &#151; and even exceed &#151; the compression achieved by the conventional use of LZW when encoding a GIF image. However, for the kind of line drawings considered here, a GIF encoded by <i>encodeRun</i> is about four or five times the size of that generated by LZW.</p><p><A NAME="rf2"><A HREF="0110of2.htm">Figure 2</A> is a sequence diagram, a mixture of straight lines and text. This image is 457 X 308 pixels. For this, LZW generates a GIF that is 2164 bytes. An <i>encodeRun</i>-based encoder generates a GIF that is 9462 bytes. For further comparison, the trivial LZW-free encoding suggested by Miano requires about 9 bits per encoded pixel, or about 160 KB for this GIF.</p><h3>Conclusion</h3><p>Data that would compress well under a run-length encoding mechanism can be encoded in a manner that is compatible with LZW's output, but independent of its patented algorithm. The technique is useful for encoding line-drawing images in the GIF format. While the level of compression does not normally approach that of LZW, it significantly exceeds a previously published mechanism, and may be sufficient in many settings.</p><p></p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>String compress(String input) {  Properties dictionary = new Properties();  for( char letter = 'a'; letter&lt;='z'; ++letter )    dictionary.put(""+letter, ""+letter);  int generatedCode = 0;  String output = "";  String last = "";  for( int i=0; i&lt;input.length(); ++i ) {    String current = last + input.charAt(i);    if( dictionary.get(current)==null ) {      output += dictionary.get(last);      String newCode = "("+generatedCode+")";       dictionary.put(current, newCode);      ++generatedCode;      last = input.substring(i,i+1);    } else      last = current;  }  output += dictionary.get(last);  return output;}</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>void generateCompressMapping() {  String run = "";  for( int i=1; i&lt;=20; ++i ) {    run += 'a';    String compressed = compress(run);    System.out.println((i&lt;10?" ":"")+i+": "+compressed);  }}</pre><P><A HREF="#rl2">Back to Article</A></P><H4><A NAME="l3">Listing Three</H4><pre>String encodeRun(char input, int repetitions) {  String output = ""+input;  int index = ((int)Math.sqrt(8*repetitions+1)-1)/2;  for( int i=1; i&lt;index; ++i )    output += "("+(i-1)+")";  int triangle = index*(index+1)/2;  int remainder = repetitions-triangle;  if( remainder==1 )    output += input;  if( remainder&gt;1 )    output += "("+(remainder-2)+")";  return output;}</pre><P><A HREF="#rl3">Back to Article</A></P></body></html>