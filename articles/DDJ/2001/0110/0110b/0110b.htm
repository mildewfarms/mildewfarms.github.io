<html><head><title>Oct01: Extraction and Examination of Relations in C++</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Extraction and Examination of Relations in C++</h1><p><i>Dr. Dobb's Journal</i> October 2001</p><h2>Principles of good physical design, courtesy of Lakos and Martin</h2><h3>By Keith Paton</h3><I>Keith is a software engineering consultant, specializing in software auditing and automatic software inspection systems. He can be reached at <a href="mailto:paton@total.net">paton@total.net</a>.</I><hr><p>A software system has both a logical and physical design. The logical design is expressed in terms of logical entities (such as class, data member, and member function) and logical relations (such as inherits, uses, and contains). The physical design shows how the logical entities (such as classes and member functions) are assigned to files. </p><p>The speed of compilation, modifiability, testability, and maintainability of a software system all depend crucially on its physical design. For example, cyclic dependencies among components make for poorer testability and unnecessary include directives make for slower compiling. Both <i>Large Scale C++ Software Design</i>, by J. Lakos (Addison-Wesley, 1996) and <i>Designing Object-Oriented Applications</i>, by R.C. Martin (Prentice-Hall, 1996) define several principles of good physical design. </p><DDJADVERTISEMENT INLINE><p>In <i>Large Scale C++ Software Design</i>, for instance, Lakos shows how the physical design of a system does much to determine its speed of compilation and linking, modifiability, testability, and maintainability. He lays down several principles of good physical design to ensure that compilation and linking are not too slow, and that the software is easily modified, tested, and maintained. </p><p>Likewise, in <i>Designing Object-Oriented Applications</i>, Martin shows how the unnecessary use of the include directive can make a system unduly slow to compile and unduly hard to modify. He lays down several rules that define when you must use the include directive and when you can get away with just the forward declaration. </p><p>In this article, I'll describe how breaches of these principles can be detected automatically, provided that you can extract a set of key relationships among the entities of the system (such as classes and member functions). Examples of such relations include: </p><ul>  <li><i>A</i> inherits from <i>B.</i>  <li><i>A::f</i> uses a variable in class <i>B.</i>  <li><i>A::f</i> invokes a member function in class <i>B.</i></ul><p>To extract and manipulate these relationships, I built PDCHECK, an automatic code inspection tool that flags the places where the design contravenes the rules. PDCHECK extracts and examines relationships from C++ systems, and reports breaches of the Lakos and Martin guidelines. (For more information about PDCHECK availability, contact me at paton@total.net.) </p><p>PDCHECK starts by extracting key relations between the parts of a C++ system using Code Check, a rule-based expert system from Abraxas Software (<a href="http://www.abxsoft.com/">http://www.abxsoft.com/</a>). PDCHECK displays the relations both as matrices and as directed acyclic graphs as appropriate. PDCHECK then issues three types of reports: </p><ul>  <li>The Physical Organization Report assesses the assignment of the logical entities (classes and member functions) to the physical entities (.cxx files and .h files), and points out where this assignment fails to follow the design rules laid down by Lakos.   <li>The Include Report assesses each include directive according to the criteria established by Martin. If the include is necessary, PDCHECK explains why; if it is not necessary, PDCHECK explains whether to replace it with a forward declaration or to omit it entirely.   <li>The Metrics Report measures the six numerical properties defined by S.F. Chidamber and C.F. Kemerer in "A Metrics Suite for Object-Oriented Programs" (<i>IEEE Transactions on Software Engineering</i>, June 1994).</ul><p>PDCHECK is currently being extended to measure a wider range of metrics, including those defined by J. Bansiya and C. Davis in "Automated Metrics and Object-Oriented Development" (<i>DDJ</i>, December 1997). </p><h3>The Relations</h3><p>In this discussion, I'll use capital letters for classes and small letters for members. <A NAME="rt1"><A HREF="0110bt1.htm">Table 1</A> lists the relations you need in discussing the Lakos and Martin principles, whereas <A NAME="rt2"><A HREF="0110bt2.htm">Table 2</A> defines the relation <i>A</i> depends on <i>B</i>. All these relations are logical in that they make no mention of the files in which the entities are stored. You also need relations involving physical entities, such as:</p><p></p><ul>  <li>File a.cxx implements <i>A::f</i>.  <li>File a.h defines class <i>A.</i>  <li>File a.cxx includes file b.h.</ul><p>Lakos points out that the appropriate unit of physical organization of object-oriented software is not the class but the component, where the component is defined by amalgamating classes that lie on cycles. More formally, Lakos lays down that class <i>A</i> and class <i>B</i> must reside in the same file if and only if there is a cycle in the class-dependency graph that contains <i>A</i> and <i>B</i>. </p><p>For example, consider a system such as <A NAME="rf1"><A HREF="0110bf1.htm">Figure 1</A> with six classes. Now suppose that the designer has assigned these classes to files, as in <A NAME="rf2"><A HREF="0110bf2.htm">Figure 2</A>. On the left side of the diagram, the cycle (<i>A</i>,<i>B</i>,<i>C</i>) implies that these three should be in the same file &#151; yet they are in separate files. On the right side of the diagram, the three classes <i>D</i>, <i>E</i>, and <i>F</i> have no cycle and, therefore, should be in separate files &#151; yet they are in the same file. The designer has violated the Lakos guidelines twice in opposite senses. The three files in the left are too small and should be merged into one; the one file on the right is too big and should be split into three separate files.</p><p>You need to know where the design breaks the Lakos principles. PDCHECK tells you this in the Physical Organization Report; see <A NAME="rt3"><A HREF="0110bt3.htm">Table 3</A>.</p><p>You can see that this report tells you not only what is wrong (left column) but what to do to correct it (right column).  Even better, the corrections to the physical design can be made automatically. If you submit the Physical Organization Report to PDCHECK's companion system, PDMODIFY, it will create a new version of your system with these corrections made. The new system will therefore obey the Lakos principles.</p><h3>Include or Forward Declare</h3><p>You use the include directive to make the current file aware of the interface of a class; sometimes all the current file needs to know is that a class exists. <A NAME="rt4"><A HREF="0110bt4.htm">Table 4</A> shows this distinction. The first block of <A NAME="rt4"><A HREF="0110bt4.htm">Table 4</A> invokes a member function in class <i>B</i>, so the include is required. The second block of <A NAME="rt4"><A HREF="0110bt4.htm">Table 4</A>, on the other hand, merely passes onwards a pointer to an object in class <i>B</i>, so a forward declaration is sufficient.</p><p>Martin sums this up as: </p><blockquote><p>Following the multiple-inclusion protection should be the <i>#include</i> statements that describe the interface dependencies of this module. An interface dependency is a dependency upon the interface of the included class. Typically such a dependency only occurs for base classes, classes that are contained by value, or classes whose member functions are called within inline functions.</p></blockquote><p>For instance, consider the file a.h in <A NAME="re1"><A HREF="0110be1.htm">Example 1</A>. I have deliberately used an include directive for every class mentioned, although according to Martin's criteria, some are unnecessary. </p><p>You need to know which of your includes are really necessary and which can be replaced by a forward declaration. PDCHECK tells you this in the Include Directives Report; see <A NAME="rt5"><A HREF="0110bt5.htm">Table 5</A>.</p><p>You can see that this report assesses each include directive. If the include is required, the comment in the middle column tells you why; if the include is not required, the action in the right hand column shows you what forward declaration to use. Even better, each redundant include can be automatically downgraded to the appropriate forward declaration. If you submit the Include Directives Report to PDCHECK's companion system, PDMODIFY, it will create a new version of each offending file with these corrections made. The new version of the system will therefore obey the so-called "Martin parsimonious inclusion principle."</p><h3>Metrics</h3><p>Chidamber and Kemerer proposed the suite of metrics in <A NAME="rt6"><A HREF="0110bt6.htm">Table 6</A> for object-oriented systems. The values of these measurements (see <A NAME="rf3"><A HREF="0110bf3.htm">Figure 3</A>) depend on relations among the logical entities of the system. <A NAME="rf3"><A HREF="0110bf3.htm">Figure 3</A> also identifies which measurements require which relations. Thus, the measurement WMC requires the relation "class <i>A</i> defines function <i>f</i>" and the relation "<i>A::f</i> has cyclomatic complexity <i>c</i>."</p><h3>Dependence</h3><p>Chidamber and Kemerer's article deals only briefly with the relation <i>A</i> depends on <i>B</i>. A full treatment is provided in several books on object-oriented design, notably Lakos and Martin's, which shows that to compute the relation <i>A</i> depends on <i>B</i>, you need the following 13 relations: </p><p></p><ul>  <li><i>A</i> inherits from <i>B.</i>  <li><i>A</i> defines an object in class <i>B.</i>  <li><i>A</i> defines a pointer to an object in class <i>B.</i>  <li><i>A::f</i> returns an object in class <i>B.</i>  <li><i>A::f</i> returns a pointer to an object in class <i>B.</i>  <li><i>A::f</i> receives an object in class <i>B.</i>  <li><i>A::f</i> receives a pointer to an object in class <i>B.</i>  <li><i>A::f</i> defines an object in class <i>B.</i>  <li><i>A::f</i> defines a pointer to an object in class <i>B.</i>  <li><i>A::f</i> invokes a member function on an object in class <i>B.</i>  <li><i>A::f</i> invokes a member function on a pointer to an object in class <i>B.</i>  <li><i>A::f</i> uses an object in class <i>B.</i>  <li><i>A::f</i> uses a pointer to an object in class <i>B.</i></ul><p>Of these 13, only one (inherits) is required to measure the other five values. Thus, CBO is very demanding (see <A NAME="rt6"><A HREF="0110bt6.htm">Table 6</A> and <A NAME="rf3"><A HREF="0110bf3.htm">Figure 3</A>). Nonetheless, the coupling between classes is an important property and worth measuring accurately.</p><h3>Automation</h3><p>If, as programmers, we agree to adopt the principles laid down by Lakos and Martin, the next step is to ask if software can be automatically inspected to detect breaches of these principles. The answer is yes. That's what PDCHECK does. The tool carries out these steps:</p><p>1.	Extracts relationships.</p><p>2.	Reports breaches of the Lakos principles.</p><p>3.	Reports breaches of the Martin parsimonious inclusion principle.</p><p>4.	Shows how to correct breaches of the Martin parsimonious inclusion principle.</p><p>5.	Reports values of Chidamber and Kemerer metric suite.</p><p></p><p>Steps 2-5 are reasonably straightforward programming tasks and caused me no difficulty. Step 1, however, demands that the tool must parse the code in order to extract the relationships. This is a more specialized task. That's why I used Abraxas Software's Code Check, which parses the code and stops at every token to execute a set of rules supplied by the user. I created a special set of rules to extract exactly the relationships I needed. I have been writing rules for Code Check for many years in my consulting business and have found that they save both me and my clients time and money.</p><p>If you want to write this sort of automatic code inspection tool for yourself, it may be possible to obtain the same effect with such tools as YACC or Bison. </p><p>If you merely want to use such a tool without the bother of writing it, it may be possible to find other suitable tools by searching the Web.</p><h3>Conclusion</h3><p>Lakos and Martin define several principles of good physical design. Breaches of these principles can be detected automatically, provided that you can extract and manipulate a set of key relationships among the entities (such as classes and member functions) of the system. </p><p><b>DDJ</b></p></body></html>