<html><head><title>Jun01: An Information Assembly Line in Perl</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>An Information Assembly Line in Perl</h1><p><i>Dr. Dobb's Journal</i> June 2001</p><h2>All the news that's fit to print &#151; in Perl!</h2><h3>By Ray Snow</h3><I>Ray is principal engineer and manager at NewsEdge. He can be contacted at ray .snow@newsedge.com.</I><hr><p>For more than 10 years, NewsEdge (http://www.newsedge.com/) has been supplying organizations and web sites with sharply focused news. Drawn from 2000 sources and organized into 2000 standard topics, NewsEdge Review Topic stories are used by millions of people at over 1450 organizations. Web administrators see our news as a direct way to increase traffic and encourage repeated visits to intranet portals and public Internet sites.</p><p>Every day stories are culled, tagged, and sorted by software, then presented to a team of 40 editorial reviewers. Each reviewer is an expert in one or more fields and typically scans thousands of stories per day, selecting, ranking, and organizing them into appropriate categories. An automated system then marks up the stories in SGML, HTML, or XML, and packages them into feeds and distributes them via the Internet. Customers receive stories only from topics and sources they choose.</p><DDJADVERTISEMENT INLINE><p>In 1998, however, the packaging system (named "MakeFeed") began running out of steam. Built incrementally as the business grew, the system &#151; made up of hundreds of C, C++, and UNIX shell files &#151; could barely keep up with the demands of 250 customers. Consequently, we launched a software-development project to replace MakeFeed and we chose Perl as the implementation language. To illustrate how we use Perl in MakeFeed, I'll examine five specific problems. I chose these to show you how the programs communicate and to introduce you to Perl pattern matching.</p><h3>The Assembly Line</h3><p>Our first problem was to reduce the large number of programs. Although news feeds differ in their final appearances, their constructions have much in common: Topic-story pairings must be identified. Story text marked up. Feed directories created. These commonalities led to the concept of an assembly line of Perl processes linked together. Unlike a real assembly line, MakeFeed passes only the feed names from stage to stage, not the feeds themselves. But the metaphor of an assembly line proved useful in explaining the system to its users, so the term stuck.</p><p>The line consists of seven stages, each a Perl program, connected together in a UNIX pipeline. The Standard Output of one stage is connected to the Standard Input of another. Feeds are assigned unique names. The first stage, FeedPump, places the name of each feed onto the assembly line by pumping it out of its Standard Output. Each remaining stage then performs one major processing step and forwards the feed names to the next. The assembly-line stages are:</p><ul>  <li>FeedPump, which orders the feeds and schedules their production.  <li>BuildTrees, which builds topic/story hierarchies.  <li>MarkUp, which marks up stories in SGML, HTML, or XML.  <li>Index, which organizes story web pages by topic.  <li>CheckFeed, which checks feeds and stories for correctness.  <li>Aggregate, which aggregates web pages and ancillary files via ZIP or tar.  <li>SendFeed, which transfers finished feeds to Internet-accessible FTP pickup sites.</ul><p><A NAME="rl1"><A HREF="#l1">Listing One</A> shows main, the Bourne shell script that creates and starts the assembly line. Lines 5 through 11 run the seven stages. Each stage accepts the assembly-line name, <i>main</i>, as a parameter. FeedPump also accepts a second, in this case <i>All</i>, which tells it which feeds to pump. The 2<i>&gt;&gt;</i> on each line redirects and appends Standard Error to the corresponding log file; the <i>|\</i> at the end is a UNIX pipe symbol followed by the UNIX line-continuation backslash (\) character. Together these convert lines 5 through 11 into a single UNIX command. Including <i>main</i> itself, this results in eight separate UNIX processes.</p><h3>Bottlenecks and Substages </h3><p>Having created a pipeline, we then encountered bottlenecks. (This is the second problem.) Some feeds are bigger than others and monopolize a stage while their successors wait. To permit concurrency, we create child UNIX processes; represented in <A NAME="rf1"><A HREF="0106ef1.htm">Figures 1</A> and <A NAME="rf2"><A HREF="0106ef2.htm">2</A> by the smaller circles. Parent stages distribute feed names to their children by creating pairs of UNIX pipes. For each child, one output pipe in the parent is connected to the child's Standard Input and a corresponding input pipe to the child's Standard Output. This lets the child think it is part of the main data flow, when in reality its parent is selectively diverting the flow to it. This magic is performed via the UNIX <i>select()</i> system service. </p><p>What a parent cannot do to a feed in a generic way is done instead by one of its children. For instance the siblings, <i>MarkUpHtml</i> and <i>MarkUpXml</i>, tag their feeds in the appropriate mark up dialects. On the other hand, identical twins such as <i>SendFeed-</i>1 and <i>SendFeed-</i>2, two instances of the same program, simply divide up their labor (see <A NAME="rf1"><A HREF="0106ef1.htm">Figure 1</A>). In all cases when a big feed is assigned to one child, its siblings are free to handle smaller feeds. As a result small feeds can pass bigger ones and don't have to wait. </p><p>Substages provide another benefit &#151; modularity. Originally, MakeFeed handled only SGML and HTML. To add XML we simply added XML-specific substages to <i>BuildTrees</i>, <i>MarkUp</i>, and <i>Index</i>; see <A NAME="rf1"><A HREF="0106ef1.htm">Figure 1</A>. This year we plan to add WML (Wireless Markup Language) and expect it will be just as straightforward.</p><h3>A Sample Input Story</h3><p>In addition to its UNIX I/O behavior, we chose Perl for its string handling. Here I will again focus on <i>MarkUp</i> and its children, and on two problem areas: extracting metadata and cleaning up raw story text. But first, I present an example of a story file as it is presented to MakeFeed.</p><p><A NAME="rf3"><A HREF="0106ef3.htm">Figure 3</A> is a story doctored to contain some instructive problems. The extended ASCII character set, ISO Latin-1, is used. Each line of text ends in a carriage-return/line-feed (cr/lf). I added the line numbers and their following periods (.) and spaces. Line 6 occupies four physical lines only because the text has wrapped around the right margin of the paragraph. Editorial metadata has been added by other NewsEdge software upstream of MakeFeed. Lines 1 through 5 and 10 through 12 contain this metadata, which is delimited by a period (.) at the front and a cr/lf at the end.</p><h3>Invisible Characters</h3><p><A NAME="rf3"><A HREF="0106ef3.htm">Figure 3</A> contains many characters you cannot see, such as the cr/lf pair that terminates each line. But there are others. For instance, the story headline in line 3 begins not with the word "Wallenberg," but with three invisible ASCII BEL characters. This is a holdover from the time when news stories were typically sent to Teletype machines. Ringing the bell on this device served to call attention to a hot story. There is a series of 32 invisible characters at the beginning of the ASCII set, traditionally called "control characters." The problem of spotting and eliminating such characters is compounded by the fact that, depending on the software being used, some of them may be acceptable: Perl, for example, considers space, tab, line-feed, carriage-return, and form-feed legitimate and refers to them collectively as "whitespace."</p><p>This kind of annoyance, while it may seem minor to programmers outside the news industry, occupies much of our time. Today's electronic news systems were forged incrementally in earlier days, giving rise to such character anomalies. There are many others. </p><h3>Special Characters in SGML</h3><p>Technically, HTML and XML are dialects of SGML, and as such inherit four special metacharacters: less than (&lt;), greater than (&gt;), ampersand (&amp;), and quotation mark ("). Less than and greater than are used to delimit elements, sometimes called "tags." Quotation marks are used to delimit element attribute values, such as the font size in a <i>&lt;FONT&gt;</i> tag. Ampersand together with semicolon (;) are used to delimit character entities that are used in place of the four special characters. These are respectively <i>"</i>&amp;<i>lt;"</i>, <i>"</i>&amp;<i>gt;"</i>, <i>"</i>&amp;<i>amp;"</i>, and <i>"</i>&amp;<i>quot;"</i>, and are known as "the SGML Standard Entities." Except when quoting verbatim text as in an XML CDATA section, you must be careful to substitute entity for character in every case. This is called "escaping the characters." Managing this is surprisingly difficult. For instance, it will not do to simply replace all ampersands with <i>"</i>&amp;<i>amp;"</i>: The story, having previously been handled by other editorial systems, may already contain escaped characters. A blind ampersand replacement could then result in incorrect double entities, like <i>"</i>&amp;<i>amp;amp;"</i>.</p><p>It's worse than that. The four Standard Entities are not alone. Any contiguous series of characters beginning with ampersand and ending with semicolon is potentially a legal entity. For example, in HTML <i>"</i>&amp;<i>nbsp;"</i> is an entity for non-breaking space, which unlike its low-numbered ASCII cousin, <i>space</i>, is not eliminated or merged with other whitespace by a browser. That's not all; nonbreaking space, and all other legitimate single characters, can be represented in at least two other ways as numeric character entities, like <i>"</i>&amp;<i>#160;" </i>in decimal, and <i>"</i>&amp;<i>#xA0;"</i> in hexadecimal notation. (All three representations appear in line 8 of <A NAME="rf3"><A HREF="0106ef3.htm">Figure 3</A>.)</p><p>In addition, depending on the precise character set used to mark up the story, it may be necessary to replace all high-ASCII characters (Latin-1 characters numbered above 127 decimal) with corresponding entities. This may be the only way, short of a CDATA section, to display the text legibly in many browsers. For instance, we once had an XML parser crash because of the N-Tilde character (numbered 241) in the word "jalape&ntilde;o."</p><h3>Perl Special Characters </h3><p>Like SGML, Perl also has special characters, but they are not unfamiliar to UNIX programmers. The pound sign (#) is used to delimit Perl comments. Period (.), question mark (?), plus sign (+), braces ({}), and brackets ([]) are seven of many metacharacters in Perl regular expressions. Dollar sign ($) is used to delimit the name of any scalar quantity, including a large set of Perl global variables. Of these, one in particular, dollar underscore ($_), which contains the default input and pattern-searching character string, is convenient because its implicit use shortens many Perl commands. Four examples of this will be shown. Braces are used in some places where a scalar name may be difficult to identify. So <i>"$num"</i> and <i>"${num}"</i> are equivalent.</p><p>In Perl regular expressions, backslash-<i>s</i> (<i>\s</i>) represents a single whitespace character. Multiple consecutive whitespace characters are signified by backslash-<i>s</i>-plus (\<i>s</i>+). Characters may be specified by their decimal or hexadecimal ASCII numbers, as in \7 and \x07 for BEL. A set of alternate choices for matching is enclosed in brackets. So [&amp;<i>&lt;&gt;"</i>] matches the four SGML special characters. Period (.) represents one arbitrary character. Period-plus (.+) means one or more arbitrary characters. Finally parentheses, while useful for grouping, in the correct context also causes their contents to be remembered by Perl. So the expression, <i>"(.+)"</i>, matches one or more characters and stores them in the automatic Perl variable, Dollar-one (<i>"$1"</i>). A successful match of <i>"(.+) </i>announces <i>(.+),"</i> as in "Peter announces Paul," causes the variables <i>$1</i> and <i>$2</i> to contain "Peter" and "Paul," respectively.</p><p>A useful technique in Perl is to interpolate the value of a scalar variable into a character string. For example if <i>$num</i> contains 16, then the command <i>print "Replaced $num Ampersands. \n"</i>, causes the text "Replaced 16 Ampersands." to be sent to Standard Output, followed by a line-feed. As in other shell scripting languages, Perl recognizes backslash-<i>n</i> (\<i>n</i>) as the new-line character, typically line-feed under UNIX. Here backslash (\) is used to escape the <i>n</i> so Perl won't interpret it as just another <i>n</i> in the text. Multiple escaping backslashes may be needed in expressions destined to be parsed by Perl more than once. For example, if we are to search for the string,<i> ".begin" </i>stored in a variable, <i>$tag</i>, to be interpolated into a <i>match</i> command, the leading period must be escaped twice. Therefore, we initialize <i>$tag</i> to<i> "\\.begin"</i>.</p><p>If all this character talk seems idle, take a good look again at <A NAME="rf3"><A HREF="0106ef3.htm">Figure 3</A>, and start thinking about parsing it in Perl. That's where we're going next.</p><h3>Extracting the Headline</h3><p>I'm now ready to examine the third problem: How to extract the headline from the story in <A NAME="rf3"><A HREF="0106ef3.htm">Figure 3</A>. If its entire text is loaded into <i>$_</i>, then <A NAME="rl2"><A HREF="#l2">Listing Two</A> does the job of extracting the headline. Lines 1 and 2 create and initialize two scalar variables to the text, <i>".begin (header)"</i> and <i>".begin (text)".</i> Line 4 treats the entire story as a single string and searches for a substring containing the two tags. Between the tags it hopes to find whitespace, followed by an arbitrary amount of text, followed by more whitespace. <A NAME="rt1"><A HREF="0106et1.htm">Table 1</A> lists the components of the <i>match</i> command.</p><p>The Perl <i>match</i> command returns either a True or False value. The exclamation-point (!) in line 4 causes the <i>if</i> test to succeed if the <i>match</i> command fails, so if there is no <i>match</i>, the error message on line 6 is output to Standard Error. On the other hand, if the <i>match</i> succeeds, all of the text between the two tags, excluding any leading or trailing whitespace, is captured in the temporary local variable, <i>$</i>1, and then saved by assigning it in line 10 to the global variable named <i>$headline</i>. If the story is the one shown in <A NAME="rf3"><A HREF="0106ef3.htm">Figure 3</A>, then <i>$headline</i> contains the three invisible BEL characters followed by "Wallenberg monument inaugurated outside UN."</p><h3>Deleting Low-Numbered  ASCII Characters</h3><p>The fourth problem is how to get rid of the BEL characters. I will attack this more generally. Again, if the Perl variable, <i>$_</i>, is used to hold the entire story text, then <A NAME="rl3"><A HREF="#l3">Listing Three</A> deletes ASCII control characters that may be embedded invisibly. Line 1 contains a Perl <i>substitute</i> command, which returns the number of substitutions that were successfully performed. <A NAME="rt2"><A HREF="0106et2.htm">Table 2</A> lists the components of the <i>substitute </i>command.</p><p>By replacing the ASCII characters whose decimal values are 0 through 7, 11, 12, and 14 through 31 with nothing, the <i>substitute</i> command causes their deletion. Only backspace, tab, line-feed, and carriage return are allowed to remain. </p><h3>Replacing Special HTML Characters</h3><p>And now the final problem &#151; handling metacharacters. The sample story in <A NAME="rf3"><A HREF="0106ef3.htm">Figure 3</A> contains special characters in lines 6 and 8. Line 6 contains a single ampersand (&amp;), while line 8 contains two less-than signs, two greater-than signs, four HTML character entities, <i>"</i>&amp;<i>#160;"</i>, <i>"</i>&amp;<i>#xa0;"</i>, and two instances of <i>"</i>&amp;<i>nbsp;"</i>, each of which represents a nonbreaking space. Each of the four contains a leading ampersand that should not be escaped.</p><p>Once more, if the Perl variable, <i>$</i><i>_</i>, is used, then <A NAME="rl4"><A HREF="#l4">Listing Four</A> escapes only the single ampersand in line 11 and the less-thans and greater-thans in line 16. Lines 1 through 4 create a Perl hash (an associative array) named "<i>tbl</i>." A hash allows the fast lookup of values (on the right side of the equal signs) via their corresponding keys (on the left side of the equal-signs, enclosed in braces.) In this case, the keys are the SGML special characters, and their corresponding values are the appropriate Standard Entities.</p><p>In lines 6 through 8, I create regular expressions to match the insides of decimal, hexadecimal, and general character entities, respectively. Backslash <i>d</i> (<i>\d</i>) represents one decimal digit. Braces ({ and }) indicate minimal and maximal repetitions. So<i> "\d{1,3}"</i> matches 1, 2, or 3 decimal digits. Line 9 brings the expressions in lines 6 through 8 together creating a Perl regular expression that matches any one of them. (The pipe symbol (|) indicates alternation. So <i>"a|b|c"</i> indicates one and only one of the choices &#151; <i>a</i>, <i>b</i>, or <i>c</i>.)</p><p>In line 11, you have the first of two Perl substitute commands. Why two? To avoid the erroneous double escaping of ampersands. It is apparent, by looking at the replacement strings in lines 11 and 16, that you are handling ampersand first, and then separately handling less than, greater than, and quotation mark. <A NAME="rt3"><A HREF="0106et3.htm">Table 3</A> lists the components of the <i>substitute</i> command in line 11. (I'll postpone an explanation of the match target for the time being.) The replacement string is the value of the tbl Perl hash in line 3: The Standard Entity, <i>"</i>&amp;<i>amp;".</i> So all substitutions will result in this value. Line 16 contains the second Perl <i>substitute</i> command. <A NAME="rt4"><A HREF="0106et4.htm">Table 4</A> lists its components. </p><p>Notice the match string, <i>"([&lt;&gt;"])"</i>. This is a regular expression consisting of a set of characters to be matched. They are, respectively, less than, greater than, and quotation mark. Square brackets are used to delimit such a set. But then the entire regular expression is enclosed in parentheses. Recall that this means Perl will remember the matched text and store it in the automatic variable, <i>$1</i>. This is very convenient for our purpose because the replacement string, <i>$tbl{$1}</i>, is just the value in the Perl hash <i>tbl</i> that corresponds to <i>$1</i>. When <i>$1</i> is less than, the replacement string will be <i>"</i>&amp;<i>lt;"</i>, when it is greater than, <i>"</i>&amp;<i>gt;"</i>, and when it's quotation mark, <i>"</i>&amp;<i>quot;"</i> &#151; exactly as you desire. Here the hash semantics of Perl do the magic by working hand-in-hand with the <i>substitute</i> command.</p><h3>Look-Ahead Matching</h3><p>So what is the meaning of the match target &amp;<i>(?!${choices};) </i>in line 11? In Perl, an expression of the form, <i>x(?!y)</i>, where <i>x</i> is a character string and <i>y</i> is a regular expression is called a "zero-width negative look-ahead assertion." Such an assertion matches an occurrence of <i>x</i> immediately followed by anything except <i>y</i>. So, for example, <i>andy(?!hardy)</i> matches <i>andy</i> followed by anything but <i>hardy</i>. </p><p>The value of the variable, <i>$choices</i>, which was set in line 9, is the regular expression that tells Perl what to avoid. It is interpolated into the <i>match</i> command, and as a result legal decimal, hexadecimal, and general character entities are avoided while everything else is accepted. The result of executing lines 11 through 16 is first to escape all appropriate ampersands and then to escape all less thans, greater thans, and quotation marks. As a final result, line 8 in <A NAME="rf3"><A HREF="0106ef3.htm">Figure 3</A> is replaced with the string, </p><blockquote><p>&amp;lt;&amp;lt;News&amp;#160;Suppiler&amp;#xa0;X&amp;nbsp; &#151; &amp;nbsp;11-09-97&amp;gt;&amp;gt;</p></blockquote><p>which displays correctly in all browsers as:</p><blockquote><p>&lt;&lt;News Supplier X  &#151;  11-09-97&gt;&gt;</p></blockquote><h3>Conclusion</h3><p>These five solutions typify the kind of analysis we do to produce validly marked up web pages containing the news. Object-oriented methodologies and new technologies like XML, and its recently standardized sublanguage, NITF (News Industry Text Format), will reduce this burden. Until then, but probably even after, Perl will be in our toolbox.</p><p></p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre> 1. #!/bin/sh 2. # Assembly line "main" for Makefeed Version 3.1: 3. # ------------------------------------------------------- 4. 5.     FeedPump    main All 2&gt;&gt; main.FeedPump.log   |\ 6.     BuildTrees  main     2&gt;&gt; main.BuildTrees.log |\ 7.     MarkUp      main     2&gt;&gt; main.MarkUp.log     |\ 8.     Index       main     2&gt;&gt; main.Index.log      |\ 9.     CheckFeed   main     2&gt;&gt; main.CheckFeed.log  |\10.     Aggregate   main     2&gt;&gt; main.Aggregate.log  |\11.     SendFeed    main     2&gt;&gt; main.SendFeed.log</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>  1. $tag01 = "\\.begin \\(header\\)";          # Escape Period &amp; Parentheses. 2. $tag02 = "\\.begin \\(text\\)";            # Here too. 3. 4. if (! m/${tag01}\s+(.+)\s+${tag02}/m )     # Look for a match. 5.     { 6.     print STDERR "Can't find headline.\n"; # If not found, error. 7.     } 8. else 9.     {10.     $headline = $1;                    # If so, $1 contains the headline.11.     }</pre><P><A HREF="#rl2">Back to Article</A></P><H4><A NAME="l3">Listing Three</H4><pre> 1. my $num =  s/[\x00-\x07\x0b\x0c\x0e-\x1f]//g; 2. if ( $num &gt; 0 ) 3.    { 4.    print STDERR "Replaced $num ASCII Control Characters.\n"; 5.    }</pre><P><A HREF="#rl3">Back to Article</A></P><H4><A NAME="l4">Listing Four</H4><pre> 1. $tbl{"&lt;"}  = "&amp;lt;"   ; 2. $tbl{"&gt;"}  = "&amp;gt;"   ; 3. $tbl{"&amp;"}  = "&amp;amp;"  ; 4. $tbl{"\""} = "&amp;quot;" ; 5. 6. $dec_char_ent = "#\\d{1,3}";             # Like in "&amp;#160;". 7. $hex_char_ent = "#x[0-9A-Fa-f]{1,2}";    # Like in "&amp;#xa0;". 8. $gen_char_ent = "[0-9A-Za-z]{1,6}";      # Like in "&amp;nbsp;". 9. $choices      = "${dec_char_ent}|${hex_char_ent}|${gen_char_ent}";10.11. $num =  s/&amp;(?!${choices};)/$tbl{"&amp;"}/g ; # Escape SOME Ampersands; Not all.12. if ($num &gt; 0)13.     {14.     print STDERR "Replaced $num Ampersands (\"&amp;\").\n";15.     }16. $num =  s/([&lt;&gt;"])/$tbl{$1}/g ;  # Escape Less-Than, Greater-Than, &amp; Quote.17. if ($num &gt; 0)19.     print STDERR "Replaced $num special HTML charactors 20.                                      with SGML Standard Entities.\n";21.     }</pre><P><A HREF="#rl4">Back to Article</A></P></body></html>