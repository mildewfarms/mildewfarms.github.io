<html><head><title>Jun01: Programming in SDL & UML</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Programming in SDL &amp; UML</h1><p><i>Dr. Dobb's Journal</i> June 2001</p><h2>When two languages are better than one</h2><h3>By Morgan Bj&ouml;rkander</h3><I>Morgan is a methods specialist for Telelogic AB and can be contacted at mbj@ telelogic.com.</I><hr><p>Over the past few years, the Unified Modeling Language (UML) has become a general-purpose language for modeling software systems, and as such, it is often compared to blueprints within the construction industry. While similar in intent, the Specification and Description Language (SDL) is specifically targeted at capturing the architecture and behavior of event-driven, distributed systems in real-time environments. SDL started out as a specification language within the telecom industry some 20 years ago, but has evolved to a point where it is more often used as a full-fledged programming language. </p><p>Today, there are many indications that UML is heading in the same direction. While there are those who claim that you cannot program in a modeling language, when that language is used at a fine enough level of granularity, there is no longer any useful distinction between a specification and a program. In this article, I'll examine a combination of UML and SDL that forms a modeling paradigm for visual software engineering that is superior to either language by itself. In particular, I'll look at architectural and behavioral issues, which are two areas in which UML alone does not provide sufficient support. I'll then bridge this problem by plugging in relevant SDL constructs using UML's extensibility mechanism. </p><DDJADVERTISEMENT INLINE><p>SDL (see "ITU Recommendation Z.100: The Specification and Description Language [SDL]," ITU, Geneva, 2000 and http://www.sdl-forum.org/) is centered on the agent concept, which is an interface-based logical component that encapsulates both structure and behavior. There is a significant overlap with UML, which is one of the reasons a convergence of the languages makes sense. The effort to combine the two languages is being helped along through work in several related areas, including the action semantics for UML (see "Action Semantics for the UML-Request For Proposal," OMG, ad/98-11-01, and "Action Semantics for the UML-Joint Initial Submission," OMG, ad/2000-08-03) and the next major UML 2.0 revision (see "UML 2.0 Superstructure-Request For Proposal," OMG, ad/2000-08-09). Together, all of these activities inevitably lead toward making UML executable. The results I present here are based on standardization work performed within the Object Management Group (OMG) and the International Telecommunications Union (ITU-T) on UML and SDL.</p><h3>Structuring a System</h3><p>It is commonly said that UML is just C++ with pictures, and as such, difficulties often arise when scale becomes an issue. The overview of the system is easily lost, and the capability to model components and their interfaces is not as good as it could be. These failings may make it difficult to get a handle on the system, and to understand how the different parts interact with each other. There are, of course, several ways to manage these quandaries, one of which is to plug in the appropriate SDL constructs through the UML profile mechanism. This versatile mechanism also allows the creation of language mappings (from SDL, for example), each of which may then be used as an intrinsic part of UML. </p><p>The profile defines a number of useful predefined modeling elements and how they interact. The context of these elements is usually given as a virtual (or conceptual) metamodel as in <A NAME="rf1"><A HREF="0106gf1.htm">Figure 1</A>, where <i>Agent</i> and <i>Gate</i> are not already part of UML. (The metamodel is considered conceptual since it is used exactly like an ordinary UML metamodel, even though it also contains stereotypes that, in reality, belong at a lower metalevel. This is a distinction that can often be disregarded when used in practice.) </p><h3>Logical Components and Interfaces</h3><p>The agent can be thought of as a logical component with bidirectional interfaces that is responsible for encapsulating structure and behavior. From the outside, an agent can be viewed as a black box, and the only way to learn how it is decomposed is to look inside it. The behavior that it provides is only visible through its interfaces. An important feature of an agent is that it may be composed of other agents. Each logical component can thus be used as a building block to create more complex logical components.</p><p>An agent is a stereotype based on the UML <i>Class</i>, and as such, it appropriates all of its properties. Some of the properties have to be restricted through constraints; for example, the <i>class</i> attribute <i>isActive</i> must always be true for an agent. The agent also has additional properties that need to be expressed through tag definitions, such as <i>kind</i>, which determines the sort of agent we are dealing with and also controls the behavior of the agent's internal structure. Because the attributes used for generalization in UML are too limiting, it is also necessary to add a tag definition controlling <i>virtuality</i> to be able to handle inheritance properly. You can also take advantage of UML's ability to add new notation to stereotypes, as in <A NAME="rf2"><A HREF="0106gf2.htm">Figure 2</A>.</p><p>The notation to the left is the one used in UML, and lets operations and attributes of the agent be shown directly on the agent, which is useful if the agent only has one (implicit) interface, or if the union of all supported interfaces is to be shown. The notation to the right is more commonly used when dealing with more than one interface.</p><p>Gates are used to support bidirectional interfaces that specify contracts between agents. Communication is only allowed between pairs of implemented and required interfaces; that is, the contracts are an inherent part of the system. Each gate is owned by exactly one agent and may handle any number of interfaces in either direction. If the agent implements the behavior of an interface, it is said to realize the interface, and if it requires someone else to provide the behavior, it uses the interface. The gate is a stereotype of the UML <i>Classifier</i>, and its notation is also shown in <A NAME="rf2"><A HREF="0106gf2.htm">Figure 2</A>. The interfaces are shown within brackets, but their definitions have been omitted from the picture (they are defined as in UML). The lollipop symbol used for interfaces in UML corresponds to the special case when a gate implements only one interface.</p><h3>Substructures and Interconnections</h3><p>An agent provides behavior in the form of a state machine, but also may contain a substructure consisting of other agents. An important issue is how these agents are interconnected; that is, which roles they play as part of the substructure. For example, consider <A NAME="rf3"><A HREF="0106gf3.htm">Figure 3</A>, where the internal structure is essentially a collaboration diagram that has been extended to take advantage of the bidirectional interfaces. The gates provide connection points between the possible communication paths that could be established. The dashed line between <i>SCF</i> and <i>BCM</i> indicates that the <i>SCF</i> is capable of creating <i>BCM</i> instances. Note that the details of the agents <i>CallHandling</i> and <i>ServiceCtrl</i> are not known at this level of granularity, according to the black box principle. This way, it is easy to control the level of concern, and also to subdivide development into manageable units with a clear division of responsibility provided by the contracts between the logical components.</p><h3>Specializing Architecture</h3><p>Architecture reuse is a fairly advanced concept that, when used correctly, is extremely powerful. UML is somewhat lax in defining what gets inherited between, for example, two classes. For agents, both substructure and behavior get inherited, but there is also a constraint where only single inheritance is allowed (multiple inheritance is only allowed for interfaces). <A NAME="rf4"><A HREF="0106gf4.htm">Figure 4</A> is a simple example of agent inheritance.</p><p>When using inheritance like this, information may only be added to the structure or the behavior of the subtype. The entire substructure of the supertype is present in the subtype, but only the parts that are involved in the additions need to be shown. To make it clear that those parts already exist, they are dashed. This is useful when adding new connections, for example, between an existing agent and a new agent. Interfaces to existing agents cannot be added using this approach. Note that because of the inheritance, <i>Child</i> exhibits the two interfaces <i>All</i> and <i>Purge</i>.</p><p>It is possible to affect already existing parts of a supertype in a subtype, but this assumes the use of the tag definition, <i>virtuality</i>, that was mentioned earlier. Legal values for this tagged value are <i>none, virtual, redefined,</i> or <i>finalized</i>. <i>none</i> means that it is not allowed to redefine an inherited agent (as in the previous example). <i>virtual</i> and <i>redefined</i> indicate that the structure or behavior of an agent may be modified in a subtype, and <i>redefined</i> additionally indicates that the inherited agent already has been redefined one or more times. <i>finalized</i> means that it is not allowed to further redefine an agent in subtypes. <A NAME="rf5"><A HREF="0106gf5.htm">Figure 5</A> depicts the redefinition of an agent.</p><p>Previously, all gates used have been anonymous since there has been no need to name them. <A NAME="rf5"><A HREF="0106gf5.htm">Figure 5</A> is an example of a named gate that you reuse when adding the <i>Purge</i> interface (sometimes it is easier to simply add a new gate, as has been done for the interface <i>Alert</i>). The redefined <i>DataBase</i> inherits the virtual <i>DataBase</i> from the supertype and allows the realization of the interface <i>Purge</i>.</p><h3>Implementing Behavior</h3><p>With the action semantics for UML, the intention is to create an abstract specification of behavior at a level of detail that makes it possible to execute and verify UML models. However, at the same time, it should be clear that the action semantics does not support concrete programming by itself, which is further evidenced by the fact that no notation is provided for the action semantics. Also, the action semantics intentionally does not say anything about the execution engine that is required to drive the behavior.</p><p>There are several reasons for notation being left out of the action semantics &#151; the most important being that it would be nearly impossible to agree on a common one. Instead, the expectation is that those wanting to will provide mappings or profiles to existing or new languages on top of the action semantics to make it concrete, thereby offering a more complete package. Such a mapping has been created for SDL.</p><p>The core element of the action semantics for UML is the procedure, which consists of a number of actions (or statements) that, in most programming languages, are executed sequentially. A procedure must always have a context and may represent the body of a class operation or the behavior of a state transition; it can also be used to represent entry and exit actions of states. Although I focus on state transitions here, the principles also apply for the other cases.</p><p>State machines of UML are very state-centric, which means that the actions that occur during transitions tend to be overlooked (the problem is further augmented by the lack of a good notation). The notation in <A NAME="rf6"><A HREF="0106gf6.htm">Figure 6</A> accentuates the importance of transitions when coding, and is mapped on top of the action semantics. It is based on SDL, but bears a strong resemblance to the notation used in activity diagrams.</p><h3>Transitions and Statements</h3><p>The transitions consist of a number of statements that are enclosed by a symbol of some kind or another. The choice of symbol conveys information about what is going on, which is an important ingredient in graphical programming. Most symbols contain a single statement, with the exception of the task symbol. This symbol most commonly encloses assignments, but also may contain any number of other statements such as loops, decisions, and operation calls. The task symbol is also a scope of its own and may include local variables and the like. The statements themselves are similar to a number of programming languages (here, it happens to be SDL, but actions look just about the same in most common programming languages).</p><p>The decision, input, and output symbols are almost self explanatory. The rhomboid is used to specify deferred signals, and the asterisk represents a catchall for the signals and operations that are not explicitly triggered in the state. The call symbol is similar to the signal symbol, but is used for operations. In this case, the operation call is to the local operation <i>EjectMoney</i>. The signal <i>Message</i> that is sent in the output symbols is defined in the interface <i>Display</i>, and the attribute (local variable) GUI represents an object reference to an agent that implements that interface. </p><h3>Exceptions</h3><p>Exceptions are used to deal with unexpected error conditions and allow you to focus on correct behavior in the normal flow of control. Exceptions use a graphical notation similar to the one used for signals. An exception can be raised by any action and is then caught using an exception handler. Such exception handlers can be defined down to the statement level, but are more commonly defined at the symbol level, transition level, or state level. Exception handlers also can be defined at the agent level. Each exception handler is capable of catching any number of exceptions. If a raised exception is not caught, further execution of the system is undefined. You also distinguish between user-defined exceptions and standard exceptions (such as <i>DivisionByZero</i>).</p><p>The user-defined exception <i>CardStuck</i> in <A NAME="rf7"><A HREF="0106gf7.htm">Figure 7</A> is raised somewhere in the body of the operation <i>EjectCard</i>. An exception handler has been associated with the operation call and is capable of catching this exception.</p><h3>Specialization of Behavior</h3><p>Earlier, I discussed how to generalize structure. The same principles can be applied to behavior, and you even reuse the tag definition, <i>virtuality</i>. An agent that inherits another agent containing a state machine also inherits the state machine. If a transition in the supertype has been marked as virtual, it is possible to redefine that transition in the subtype; otherwise, it is only possible to add new transitions and states. <A NAME="rf8"><A HREF="0106gf8.htm">Figure 8</A> is an example of this kind of generalization. The redefined transition in the subtype completely replaces the virtual transition of the supertype.</p><h3>Conclusion</h3><p>The goal with programming in UML is to be able to generate complete applications. In C++, you do this by compiling and linking code. A side effect of programming in UML is that you become target-language independent. As in C++, the UML model  could be compiled, but it is easier and more flexible to use C++ or Java as intermediate formats (that are not really supposed to be changed manually) once the UML model has been syntactically and semantically analyzed for correctness. Using a programming language such as C++ as an intermediate format also enables integration with predefined C++ code, or use of a specific cross compiler.</p><p>An important aspect of programming in UML is to separate concerns. You do not want to mix the description of behavior and structure with the infrastructure on which a system is supposed to execute. In essence, you don't want to worry too much about the infrastructure on which the system is going to execute. If, for example, the application should use CORBA or COM+ as a transport mechanism, the relevant code for this can be automatically generated for the final application. This is where the use of different execution engines comes into play. Time can be spent more efficiently to figure out how the system is supposed to work rather than having to worry about lower level details, including how the system is to be distributed over a network. If you want to switch from using CORBA to using TCP/IP directly, all you have to do is to change the execution engine; the core behavior of the system has not changed. There are techniques to validate early on that the chosen infrastructure will be sufficient for your needs. </p><p>Debugging is performed at the UML level, but when using, for example, C++ as an intermediate format, it also is possible to access debug information at that level. Traditional round-trip engineering is not an issue when programming in UML, but reverse engineering of header files is useful when accessing, for example, predefined C++ libraries (C++ class implementations should never be reverse engineered). </p><p>Another big advantage with programming in UML is that the distance between the analyst, designer, and programmer is dramatically shortened because they all speak the same language. Fewer artifacts are required, and the risk of the programmers deviating from the design or racing ahead is eliminated. Not surprisingly, this also has a huge impact on the development process, which puts the code &#151; arguably the most valuable artifact &#151; into focus.</p><p>SDL has been successfully used as a programming language for years now, proving that it is indeed possible to program in a modeling language. UML is slowly but surely heading in the same direction.</p><p><b>DDJ</b></p></body></html>