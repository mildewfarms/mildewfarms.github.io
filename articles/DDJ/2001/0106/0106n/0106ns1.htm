<html><head><title>Jun01: Enumerating Combinations  Using BitSets</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h2>Enumerating Combinations  Using BitSets</h2><p>As an example of a problem that is easily solved with recursion and associated with solution sets that are very large, I've used the problem of enumerating all combinations of size <i>N</i> out of a set of size <i>M</i>. In Java, the cleanest way I can think of to solve this problem is to use <i>java.util.BitSet</i>.</p><p>A <i>BitSet</i> is essentially a vector of bits, each of which can be either set or unset at any given point. Such a structure is ideal for representing combinations and other subsets of items. If you consider an arbitrary subset of items from an underlying set, you can represent this subset as a <i>BitSet</i> with a length that is the same as the number of items in the underlying set. The original set is given an order, and every item in the underlying set has a corresponding bit in the <i>BitSet</i>. The subset that the <i>BitSet</i> represents contains all items that have their corresponding bit "on" and excludes all items that have their corresponding bit "off."<i></p><DDJADVERTISEMENT INLINE><p>BitSet</i>s thus yield a simple way of enumerating all possible, exponentially many groups of items out of a given set. The problem of enumerating all combinations of <i>N</i> items out of a set of size <i>M</i> becomes, then, a problem of finding all <i>BitSet</i>s of size <i>M</i> with exactly <i>N</i> "on" bits.</p><p>Consider the set with three elements. The three combinations of size 1 out of this set would be represented as <i>BitSet</i>s corresponding to 001, 010, and 100. Combinations of size 2 would be represented as 011, 101, and 110.</p><p>A trivial solution to the problem of listing combinations would be to enumerate in numerical order all possible <i>BitSet</i>s of length <i>M</i> and throw away all those that do not contain exactly <i>N</i> bits. This is wasteful, however; the solution in <A NAME="re1"><A HREF="0106ne1.htm">Example 1</A>, which essentially prunes the tree &#151; eliminating all enumerations that cannot yield successful results because they already contain enough "on" bits &#151; should run faster.</p><p> &#151; S.B.</p><a href="0106n.htm#rs1">Back to Article</a></body></html>