<html><head><title>Jun01: C++ Concept Checking</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>C++ Concept Checking</h1><p><i>Dr. Dobb's Journal</i> June 2001</p><h2>A better practice for template programming</h2><h3>By Jeremy Siek and  Andrew Lumsdaine</h3><I>Jeremy and Andrew work in the computer science department at Indiana University. They can be contacted at lums@cs.indiana.edu.</I><hr><p>Generic programming in C++ is characterized by the use of template parameters to represent abstract data types, that is, "concepts" as the term is used in the SGI STL documentation (see <i>Generic Programming and the STL</i>, by M.H. Austern, Addison-Wesley, 1999 and the SGI Implementation of the Standard Template Library, http://www.sgi.com/Technology/STL/). Unfortunately, the flexibility provided by templates generally comes at the expense of interface safety. In this article, we present a technique for reintroducing interface safety into template functions. </p><p>Consider <A NAME="re1"><A HREF="0106de1.htm">Example 1(a)</A>. If you have a function that operates on a stack of integers, you could use an object-oriented approach to describe the stack requirements using an abstract base class. A subsequent call <i>foo(y)</i> is only valid if the argument <i>y</i> bound to <i>x</i> is of a type derived from <i>Stack</i>. This ensures the type of <i>y</i> has at least <i>push()</i> and <i>pop()</i> member functions so that the calls to these functions inside of <i>foo()</i> are guaranteed to be well defined.</p><DDJADVERTISEMENT INLINE><p>With templates, interface safety becomes a much more nebulous issue. For example, suppose you have a function template declared as in <A NAME="re1"><A HREF="0106de1.htm">Example 1(b)</A>. In this case, the compiler lets an object of any type be passed as an argument to <i>bar()</i>, whether or not it is a stack (that is, has <i>push()</i> and <i>pop()</i> member functions). If an incorrect type is used, a compiler error will occur. However, the error will not be caught at the call site of <i>bar()</i>, but somewhere deep inside the implementation of <i>bar()</i>. What you need is a mechanism for template functions that provides interface safety in a manner reminiscent of abstract base classes. We do this by using several new C++ idioms to specify and then exercise requirements on template parameters. We use the term "concept" to mean a set of requirements and, therefore, call our resulting methodology "concept checking."</p><p>A group of us at SGI and the University of Notre Dame began working on concept checking mechanisms more than a year ago, producing the concept checks that are currently in the SGI STL distribution. This work was further developed (see "Concept Checking: Binding Parametric Polymorphism in C++," by J. Siek and A. Lumsdaine, <i>First Workshop on C++ Template Programming</i>, October 2000) and is now available in the form of the Boost Concept Checking Library (http://www.boost.org/libs/concept_check/concept_check.htm). In this article we cover two complementary aspects of concept checking &#151; concept checking and concept covering. Concept checking deals with properly expressing the requirements of a concept, verifying that template arguments meet these requirements, and providing appropriate error messages when user-supplied template arguments do not meet these requirements. Concept covering verifies that the stated requirements for a template are valid; that is, that they cover all the ways in which the template parameter is used without introducing unnecessary requirements.</p><h3>Concepts</h3><p>A concept is a set of requirements (valid expressions, associated types, semantic invariants, complexity guarantees, and so on) that a type must fulfill to be correctly used as an argument in a call to a generic algorithm. However, C++ has no explicit mechanism for representing concepts &#151; template parameters are merely place holders and express no constraints on the template argument. By convention, template parameters are given names corresponding to the concept that is required, but C++ compilers do not enforce compliance to the concept at the point where the template parameter is bound to an actual type.</p><p>Naturally, a compile-time error occurs if a generic algorithm is invoked with a type that does not fulfill at least the syntactic requirements of the concept. However, this error will not reflect that the type did not meet all requirements of the concept per se. Rather, the error may occur  at a point where an expression is not valid for the type, or where a presumed associated type is not available. The resulting error messages are largely uninformative and basically impenetrable.</p><p>What is required is a mechanism for enforcing "concept safety" at (or close to) the point of instantiation. The Boost Concept Checking Library (BCCL) uses Standard C++ constructs to enforce early concept compliance and provide more informative error messages upon non-compliance. The techniques described here only address the syntactic requirements of concepts (the valid expressions and associated types). These techniques do not address the semantic invariants or complexity guarantees that are also part of concept requirements (although this is an active topic in our research group).</p><h3>Extended Example</h3><p>It's happened to us all: One small mistake in using a Standard Library (SL) algorithm and the compiler produces pages of difficult to decipher error messages. Of course this problem is not specific to the SL, but it affects the use of any nontrivial template class or function. <A NAME="re2"><A HREF="0106de2.htm">Example 2</A> illustrates such an error. Here we call the <i>std::stable_sort()</i> algorithm from the SL, applying it to a linked list.</p><p>Attempting to compile this code with GNU C++ produces the compiler error in <A NAME="re3"><A HREF="0106de3.htm">Example 3</A>. In this case, the fundamental error is that <i>std::list::iterator </i>does not model the concept of <i>RandomAccessIterator</i>. The list iterator is only bidirectional, not fully random access (as would be a <i>std::vector::iterator</i>). Unfortunately, there is nothing in the error message to indicate this to users. The error may be obvious to C++ programmers who have enough experience with template libraries. However, for the uninitiated, there are several reasons why this message would be hard to understand.</p><ul>  <li>The location of the error. Line 5 of <A NAME="re2"><A HREF="0106de2.htm">Example 2</A> is not pointed to by the error message, even though GNU C++ prints up to four levels deep in the instantiation stack.  <li>There is no textual correlation between the error message and the documented requirements for <i>std::stable_sort()</i> and for <i>RandomAccessIterator</i>.  <li>The error message is overly long, listing functions internal to the SL that users do not (and should not) know or care about.  <li>With so many internal library functions listed in the error message, the user could easily infer the error is due to the library, rather than the user's own code.</ul><p><A NAME="re4"><A HREF="0106de4.htm">Example 4</A> illustrates what you might expect from a more informative message (and is in fact what the BCCL produces). This message rectifies several of the shortcomings of the previous error messages.</p><ul>  <li>The location of the error is specified in the error message.  <li>The message refers explicitly to concepts that the user can look up in the SL documentation <i>(RandomAccessIterator)</i>.  <li>The error message is much shorter and does not reveal internal STL functions.  <li>The presence of concept_check.hpp and <i>constraints()</i> in the error message alerts users that the error lies in the user code, not in the template implementation.</ul><h3>Concept Checking Classes</h3><p>To check a concept, we employ a special-purpose class (a concept checking class) that ensures that a given type (or set of types) models the given concept. An example of a concept checking class from the BCCL is the <i>EqualityComparableConcept </i>class that corresponds to the <i>EqualityComparable</i> requirements described in 20.1.1 of the C++ Standard, and to the <i>EqualityComparable</i> concept documented in the SGI STL.</p><blockquote><p>template &lt;class T&gt;</p><p>struct EqualityComparableConcept;</p></blockquote><p>The template argument <i>T</i> represents the type to be checked. That is, the purpose of <i>EqualityComparableConcept</i> is to make sure that the template argument given for <i>T</i> models the <i>EqualityComparable</i> concept. Each concept checking class has a member function named <i>constraints(), </i>which contains the valid expressions for the concept. To check whether some type is <i>EqualityComparable</i>, we need to instantiate the concept checking class with the type, then find a way to get the compiler to compile the <i>constraints()</i> function without actually executing the function. The BCCL defines two utilities that make this easy: <i>function_requires()</i> and BOOST_CLASS_REQUIRES. The <i>function_requires() </i>function can be used in function bodies and the BOOST_CLASS_REQUIRES<i> </i>macro can be used inside class bodies.</p><p>The <i>function_requires()</i> function takes no arguments, but has a template parameter for the concept checking class. This means that the instantiated concept checking class must be given as an explicit template argument; see <A NAME="rl1"><A HREF="#l1">Listing One(a)</A>. With this concept check inserted, if the class <i>foo</i> is not a model of <i>EqualityComparable</i> (it has not defined operators == and !=), then <i>function_requires()</i> will catch the error upfront, instead of allowing the error to occur somewhere inside the template function.</p><p>The BOOST_CLASS_REQUIRES macro can be used inside a class definition to check whether some type models a concept; see <A NAME="rl1"><A HREF="#l1">Listing One(b)</A>.</p><h3>Applications of Concept Checks</h3><p>One good application of concept checks would be to insert <i>function_requires()</i> at the top of <i>std::stable_sort()</i> to make sure the template parameter type models <i>RandomAccessIterator</i>. In addition, <i>std::stable_sort()</i> requires that the value type of the iterators be <i>LessThanComparable</i>, so you should also use <i>function_requires()</i> to check this; see <A NAME="rl2"><A HREF="#l2">Listing Two(a)</A>.</p><p>As an example of using BOOST_CLASS_REQUIRES, look at a concept check that could be added to <i>std::vector</i>. One requirement that is placed on the element type is that it must be <i>Assignable</i>. You can check this by inserting BOOST_CLASS_REQUIRES at the top of the definition for <i>std::vector</i>, as in <A NAME="rl2"><A HREF="#l2">Listing Two(b)</A>.</p><p>Although the concept checks are designed for use by generic library implementors, they can also be useful to end users. Sometimes you may not be sure whether some type models a particular concept. This can easily be checked by creating a small program and using <i>function_requires()</i> with the type and concept in question. The BCCL file stl_concept_checks.cpp provides an example of applying the concept checks to SL containers.</p><h3>Implementation</h3><p>Ideally, we would like to catch (and indicate) the concept violation at the point of instantiation. As mentioned in <i>D</i><i>esign and Evolution of C++</i>, by Bjarne Stroustrup (Addison-Wesley, 1994), the error can be caught by exercising all of the requirements needed by the function template. Exactly how the requirements (the valid expressions in particular) are exercised is a tricky issue, because we want the code to be compiled, but not executed. Our approach is to exercise the requirements in a separate function that is assigned to a function pointer. In this case, the compiler instantiates the function but will not actually invoke it. In addition, an optimizing compiler will remove the pointer assignment as dead code (though the run-time overhead added by the assignment would be trivial in any case). It might be conceivable for a compiler to skip the semantic analysis and compilation of the constraint functions in the first place, which would make our function pointer technique ineffective. However, this is unlikely because removal of unnecessary code and functions is typically done in later stages of a compiler. We have successfully used the function pointer technique with GNU C++, Microsoft Visual C++, and several EDG-based compilers (KAI C++, SGI MIPSpro). <A NAME="rl4"><A HREF="#l4">Listing Four</A> shows how this technique can be applied to the <i>std::stable_sort()</i> function.</p><p>There is often a large set of requirements that need to be checked, and it would be cumbersome for the library implementor to write constraint functions such as <i>stable_sort_constraints()</i> for every public function. Instead, we group sets of valid expressions together, according to the definitions of the corresponding concepts. For each concept, we define a concept checking class template where the template parameter is for the type to be checked. The class contains a <i>constraints()</i> member function, which exercises all of the valid expressions of the concept. The objects used in the <i>constraints()</i> function, such as <i>n</i> and <i>i</i>, are declared as data members of the concept checking class; see <A NAME="rl5"><A HREF="#l5">Listing Five</A>. You can still use the function pointer mechanism to cause instantiation of the constraints function, however, now it will be a member function pointer. To make it easy for library implementors to invoke the concept checks, we wrap the member function pointer mechanism in a function named <i>function_requires()</i>. <A NAME="rl6"><A HREF="#l6">Listing Six(a)</A> shows how to use <i>function_requires()</i> to make sure that the iterator is a <i>RandomAccessIterator</i>.</p><p>The definition of <i>function_requires() </i>is as follows: The <i>Concept</i> is the concept checking class that has been instantiated with the modeling type. We assign the address of the constraints member function to the function pointer <i>x</i>, which causes the instantiation of the constraints function and checking of the concept's valid expressions. We then pass <i>x</i> to the <i>ignore_unused_variable_warning()</i> function, and wrap everything in a loop to prevent <i>do</i>-<i>while</i> collisions; see <A NAME="rl6"><A HREF="#l6">Listing Six(b)</A>.</p><p>To check the type parameters of class templates, we provide the BOOST_CLASS_REQUIRES macro that can be used inside the body of a class definition (whereas <i>function_requires()</i> can only be used inside of a function body). This macro declares a nested class template, where the template parameter is a function pointer. We then use the nested class <i>type</i> in a <i>typedef</i>, see <A NAME="rl6"><A HREF="#l6">Listing Six(c)</A>, with the function pointer type of the constraint function as the template argument. We use the <i>type_var</i> and concept names in the nested class and typedef names to help prevent name collisions.</p><p>In addition, there are versions of BOOST_CLASS_REQUIRES that take more arguments to handle concepts that include interactions between two or more types. BOOST_CLASS_REQUIRES was not used in the implementation of the BCCL concept checking classes because several compilers do not implement template parameters of function pointer type.</p><h3>Creating Concept Checking Classes</h3><p>As an example of how to create a concept checking class, look at how to create the corresponding checks for the <i>RandomAccessIterator</i> concept. First, as a convention we name the concept checking class after the concept, and add the suffix "Concept." Next, we define a member function named <i>constraints()</i> in which we will exercise the valid expressions of the concept.<i> function_requires()</i> expects this function's signature to appear exactly as it appears in <A NAME="rl3"><A HREF="#l3">Listing Three</A>: a void non<i>const</i> member function with no parameters.</p><p>The first part of the <i>constraints()</i> function includes the requirements that correspond to the refinement relationships between <i>RandomAccessIterator</i> and the concepts that it builds upon: <i>BidirectionalIterator</i> and <i>LessThanComparable</i>. We could have instead used BOOST_CLASS_REQUIRES and placed these requirements in the class body, however, BOOST_CLASS_REQUIRES uses C++ features that are less portable.</p><p>Next we check that the <i>iterator_category</i> of the iterator is either <i>std::random_access_iterator_tag</i> or a derived class. After that, we write out some code that corresponds to the valid expressions of the <i>RandomAccessIterator</i> concept. <i>Typedef</i>s can also be added to enforce the associated types of the concept; see <A NAME="rl3"><A HREF="#l3">Listing Three</A>. </p><p>One potential pitfall in designing concept checking classes is using more expressions in the <i>constraints()</i> function than necessary. For example, it is easy to accidentally use the default constructor to create the objects that will be needed in the expressions (and not all concepts require a default constructor). This is the reason we write the <i>constraints()</i> function as a member function of a class. The objects involved in the expressions are declared as data members of the class. Since objects of the <i>constraints()</i> class template are never instantiated, the default constructor for the concept checking class is never instantiated. Hence, the data members' default constructors are never instantiated (C++ Standard Section 14.7.1 9).</p><h3>Concept Covering and Archetypes</h3><p>While it is important to select the minimal requirements (concepts) for the inputs to a component, it is equally important to verify that the chosen concepts cover the algorithm. That is, any possible user error should be caught by the concept checks and not slip through. Concept coverage can be verified through the use of archetype classes. An archetype class is an exact implementation of the interface associated with a particular concept. The run-time behavior of the archetype class is not important &#151; the functions can be left empty. A simple test program can then be compiled with the archetype classes as the inputs to the component. If the program compiles, then one can be sure that the concepts cover the component.</p><p><A NAME="rl7"><A HREF="#l7">Listing Seven</A> shows the archetype class for the <i>TrivialIterator</i> concept. Care must be taken to ensure that the archetype is an exact match to the concept. For example, the concept states that the return type of <i>operator</i>*<i>()</i> must be convertible to the value type. It does not state the more stringent requirement that the return type be <i>T</i>&amp; or <i>const </i><i>T</i>&amp;. The correct approach is to create an artificial return type that is convertible to <i>T</i>, as we have done here with <i>input_proxy</i>. The validity of the archetype class test is completely dependent on it being an exact match with the concept, which must be verified by careful (manual) inspection.</p><p>Generic algorithms are often tested by being instantiated with a number of common input types. For example, you might apply <i>std::stable_sort()</i> with basic pointer types as the iterators. Though appropriate for testing the run-time behavior of the algorithm, this is not helpful for ensuring concept coverage because C++ types never match particular concepts, they often provide much more than the minimal functionality required by any one concept. That is, even though the function template compiles with a given type, the concept requirements may still fall short of covering the function's actual requirements. This is why it is important to compile with archetype classes in addition to testing with common input types.</p><p><A NAME="rl8"><A HREF="#l8">Listing Eight</A> is an excerpt from the BCCL file stl_concept_covering.cpp that shows how archetypes can be used to check the requirement documentation for <i>std::stable_sort()</i>. In this case, it looks like the <i>CopyConstructible</i> and <i>Assignable</i> requirements were forgotten in the SGI STL documentation (try removing those archetypes). The Boost archetype classes have been designed so that they can be layered. In this example, the value type of the iterator is composed out of two archetypes. In <A NAME="rl8"><A HREF="#l8">Listing Eight</A>, template parameters named <i>Base</i> indicate where the layered archetype can be used.</p><h3>Requirement Minimization</h3><p>The process of deciding how to group requirements into concepts and deciding which concepts to use in each algorithm is perhaps the most difficult (yet most important) part of building a generic library. A guiding principle to use during this process is one we call the "requirement minimization principle" &#151; minimize the requirements on the input parameters of a component to increase its reusability. </p><p>There is natural tension in this statement. By definition, the input parameters must be used by the component in order for the component to accomplish its task (by "component" we mean a function or class template). The challenge then is to implement the component in such a way that makes the fewest assumptions (the minimum requirements) about the inputs while still accomplishing the task. The traditional notions of abstraction tie in directly to the idea of minimal requirements. The more abstract the input, the fewer the requirements. Thus, concepts are simply the embodiment of abstract data types in C++ template programming. When designing the concepts for some problem domain, it is important to keep in mind their purpose, namely to express the requirements for the input to the components. With respect to the requirement minimization principle, this means we want to minimize concepts.</p><p>Minimality in concepts is a property associated with the underlying semantics of the problem domain being represented. In the problem domain of basic containers, requiring traversal in a single direction is a smaller requirement than requiring traversal in both directions (hence the distinction between <i>ForwardIterator </i>and<i> BidirectionalIterator</i>). The semantic difference can be easily seen in the difference between the set of concrete data structures that have forward iterators versus the set that has bidirectional iterators. For example, singly linked lists would fall in the set of data structures having forward iterators, but not bidirectional iterators. In addition, the set of algorithms that one can implement using only forward iterators is quite different than the set that can be implemented with bidirectional iterators. Because of this, it is important to factor families of requirements into rather fine-grained concepts. For example, the requirements for iterators are factored into the six SL iterator concepts (trivial, input, output, forward, bidirectional, and random access).</p><h3>The Boost Concept Checking Library</h3><p>The Boost Concept Checking Library includes concept checking classes for all of the concepts used in the C++ Standard Library (plus a few more). In addition, other Boost libraries include concept checking classes for the concepts that are particular to those libraries. For example, the Boost Graph Library includes checks for the graph concepts and property map concepts that it provides. We encourage you to use concept checking as part and parcel of developing generic algorithms. When writing algorithms that use existing concepts, you should simply reuse the associated concept check. When introducing new concepts, you should develop corresponding concept checks for your own use and for users of your software.</p><h3>Looking to the Future</h3><p>Designing, implementing, and verifying concept checks for generic C++ libraries must presently be done manually. As a result, the process is time consuming and (likely to be) error prone. Implementors would benefit greatly if some or all of this process could be automated.</p><p>A first step would be to have a tool that statically analyzes a class or function template and records all the kinds of expressions that involve the template parameter types. Such a tool would ease the task of verifying concept coverage. A second step would pattern-match the set of all required expressions against a standard set (or library-defined set) of concepts, thereby summarizing the requirements in terms of concepts. This information could then be used in two ways. First, it could be used to create readable reports for library documentation. Second, it could be used to provide informative compiler error messages without the need to manually insert concept checks. Finally, we remark that there is much work to be done in the general area of generic programming. Outside of C++, there are a number of approaches one could take for designing a language that directly supports concepts.</p><h3>Acknowledgments</h3><p>Thanks to Alexander Stepanov for originating the idea of using function pointers to trigger the instantiation of concept checking code. Thanks also to Matthew Austern for establishing the concepts of the SGI STL; Beman Dawes for managing the Boost review of the BCCL; and to all the Boost members for reviewing BCCL. Parts of this work were performed while Jeremy was interning at SGI, and Andrew was on sabbatical at Lawrence Berkeley National Lab. This work was partially funded by NSF grant ACI-9982205. </p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4>(a)<pre>// In my library:template &lt;class T&gt;void some_function_template(T x){   function_requires&lt; EqualityComparableConcept&lt;T&gt; &gt;();   // ...};// In the user's code:class foo {//...};int main() {   foo f;   some_function_template(f);   return 0;}(b)<pre>// In my library:template &lt;class T&gt;struct some_class_template{   BOOST_CLASS_REQUIRES(T, EqualityComparableConcept);   // ...};// In the user's code:class foo {   //...};int main() {   some_class_template&lt;foo&gt; glc;   // ...   return 0;}</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two </H4>(a)<pre>template &lt;class RandomAccessIter&gt;void stable_sort(RandomAccessIter first, RandomAccessIter last){   function_requires&lt; RandomAccessIteratorConcept&lt;RandomAccessIter&gt; &gt;();   typedef typename std::iterator_traits&lt;RandomAccessIter&gt;::                                                  value_type value_type;   function_requires&lt; LessThanComparableConcept&lt;value_type&gt; &gt;();     ...}(b)<pre>namespace std {   template &lt;class T&gt;   struct vector {      BOOST_CLASS_REQUIRES(T, AssignableConcept);      ...   };}</pre><P><A HREF="#rl2">Back to Article</A></P><H4><A NAME="l3">Listing Three</H4><pre>template &lt;class Iter&gt;struct RandomAccessIteratorConcept{   void constraints() {      function_requires&lt; BidirectionalIteratorConcept&lt;Iter&gt; &gt;();      function_requires&lt; LessThanComparableConcept&lt;Iter&gt; &gt;();      function_requires&lt; ConvertibleConcept&lt;         typename std::iterator_traits&lt;Iter&gt;::iterator_category,         std::random_access_iterator_tag&gt; &gt;();      i += n;      i = i + n; i = n + i;      i -= n;      i = i - n;      n = i - j;      i[n];   }   Iter a, b;   Iter i, j;   typename std::iterator_traits&lt;Iter&gt;::difference_type n; };}</pre><P><A HREF="#rl3">Back to Article</A></P><H4><A NAME="l4">Listing Four</H4><pre>template &lt;class RandomAccessIterator&gt;void stable_sort_constraints(RandomAccessIterator i){   typename std::iterator_traits&lt;RandomAccessIterator&gt;      ::difference_type n;   i += n; // exercise the requirements for RandomAccessIterator   ...}template &lt;class RandomAccessIterator&gt;void stable_sort(RandomAccessIterator first, RandomAccessIterator last){   typedef void (*fptr_type)(RandomAccessIterator);   fptr_type x = &amp;stable_sort_constraints;   ...}</pre><P><A HREF="#rl4">Back to Article</A></P><H4><A NAME="l5">Listing Five</H4><pre>template &lt;class Iter&gt;struct RandomAccessIterator_concept{   void constraints()   {      i += n;      ...   }   typename std::iterator_traits&lt;RandomAccessIterator&gt;      ::difference_type n;   Iter i;   ...};</pre><P><A HREF="#rl5">Back to Article</A></P><H4><A NAME="l6">Listing Six</H4>(a)<pre>template &lt;class Iter&gt;void stable_sort(Iter first, Iter last){   function_requires&lt; RandomAccessIteratorConcept&lt;Iter&gt; &gt;();   ...}(b)<pre>template &lt;class Concept&gt;void function_requires(){   void (Concept::*x)() = BOOST_FPTR Concept::constraints;   ignore_unused_variable_warning(x);}(c)<pre>#define BOOST_CLASS_REQUIRES(type_var, concept) \   typedef void (concept &lt;type_var&gt;::* func##type_var##concept)(); \   template &lt;func##type_var##concept _Tp1&gt; \   struct concept_checking_##type_var##concept { }; \   typedef concept_checking_##type_var##concept&lt; \      BOOST_FPTR concept &lt;type_var&gt;::constraints&gt; \      concept_checking_typedef_##type_var##concept</pre><P><A HREF="#rl6">Back to Article</A></P><H4><A NAME="l7">Listing Seven </H4><pre>template &lt;class T&gt;struct input_proxy {   operator const T&amp;() {      return static_object&lt;T&gt;::get(); // Get a reference without constructing   }};template &lt;class T&gt;class trivial_iterator_archetype{   typedef trivial_iterator_archetype self;public:   trivial_iterator_archetype() { }   trivial_iterator_archetype(const self&amp;) { }   self&amp; operator=(const self&amp;) { return *this; }   friend bool operator==(const self&amp;, const self&amp;) { return true; }   friend bool operator!=(const self&amp;, const self&amp;) { return true; }   input_proxy&lt;T&gt; operator*() { return input_proxy&lt;T&gt;(); }};namespace std {   template &lt;class T&gt;   struct iterator_traits&lt; trivial_iterator_archetype&lt;T&gt; &gt;   {      typedef T value_type;   };}</pre><P><A HREF="#rl7">Back to Article</A></P><H4><A NAME="l8">Listing Eight </H4><pre>{   typedef less_than_comparable_archetype&lt;      sgi_assignable_archetype&lt;&gt; &gt; ValueType;   random_access_iterator_archetype&lt;ValueType&gt; ri;   std::stable_sort(ri, ri);}</pre><P><A HREF="#rl8">Back to Article</A></P></body></html>