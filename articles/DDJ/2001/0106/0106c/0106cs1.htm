<html><head><title>Jun01: Jini Puts RMI on Steroids</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h2>Jini Puts RMI on Steroids</h2><p>RMI has come a long way in the last three years. The addition of Jini and Java 2 to the programmer's toolbox corrects many of the deficiencies of earlier implementations of RMI. First, RMI used a simple, string-based Naming service that lets clients find remote services on particular hosts by name. The Jini Lookup Specification leverages Java's concept of interfaces and allows much more complex lookup queries to be built. Service instances can also be looked up by globally unique <i>ServiceID</i>s.</p><p>To use RMI service objects, the client had to know the network address of the service it was looking for. Jini's use of IP multicast eliminates this constraint and allows lookup services and services to be found without knowledge of where those services reside.</p><DDJADVERTISEMENT INLINE><p>RMI's Naming service allowed only stub references to Remote objects to be stored. Jini's Lookup service can store both references to Remote services and Serializable service objects that can be downloaded and executed locally on the client.</p><p>Systems built on RMI were subject to resource management problems in the event of host, process, and network failures. There were no established mechanisms for Service objects to tell when its clients had failed, leaving them holding resources for clients that no longer existed. Jini's Leasing specification and Java 2's Distributed Garbage Collection (which uses a leasing mechanism) have addressed this issue.</p><p>Finally, RMI did not provide a framework for remote events, nor was there support for distributed transactions. Jini's Remote Event and Transaction Specifications have addressed this.</p><p> &#151; B.P.</p><a href="0106c.htm#rs1">Back to Article</a></body></html>