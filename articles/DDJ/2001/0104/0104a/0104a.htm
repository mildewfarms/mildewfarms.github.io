<html><head><title>Apr01: JDSL: The Data Structures Library In Java</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>JDSL: The Data Structures Library In Java</h1><p><i>Dr. Dobb's Journal</i> April 2001</p><h2>Making advanced algorithms and data structures a programming reality</h2><h3>By Roberto Tamassia, Michael T. Goodrich, Luca Vismara, Mark Handy, Galina Shubina,  Robert Cohen, Beno&icirc;t Hudson, Ryan S. Baker, Natasha Gelfand, and Ulrik Brandes</h3><I>JDSL was developed primarily at the Center for Geometric Computing at Brown University, in collaboration with Algomagic Technologies. The authors can be contacted at jdsl@cs.brown.edu.</I><hr><p>Once mainly used as number processors to perform fast numerical computations, computers have evolved into information processors for storing, analyzing, searching, transferring, and updating large collections of structured information. For computer programs to perform these tasks effectively, the data they manipulate must be well organized, and the methods for accessing and maintaining those data must be reliable and efficient. In other words, programs need advanced data structures and algorithms. However, implementing advanced data structures and algorithms is not an easy task and presents some risks because of their complexity, proneness to subtle errors, and long development time. Consequently, programmers tend to ignore advanced data structures and algorithms, opting for simple, less efficient ones that are easier to implement and test. Clearly, the development of complex software applications &#151; in particular their rapid prototyping &#151; can benefit from libraries of reliable and efficient data structures and algorithms.</p><p>Various libraries are available for C++, including the Standard Template Library (STL; see <i>STL Tutorial and Reference Guide: C++ Programming with the Standard Template Library,</i> by D.R. Musser and A. Saini, Addison-Wesley, 1996), now part of the C++ Standard; the Library of Efficient Data Structures and Algorithms (LEDA; see <i>LEDA: A Platform for Combinatorial and Geometric Computing,</i> by K. Mehlhorn and S. N&auml;her, Cambridge University Press, 1999); and the Generic Graph Component Library (GGCL; see "The Generic Graph Component Library," by J. Siek, Lie-Quan Lee, and A. Lumsdaine, <i>DDJ</i>, September 2000).</p><DDJADVERTISEMENT INLINE><p>The situation with Java is different, however. A small library of data structures and algorithms, usually referred to as "Java Collections" (JC), is included in the Java 2 java.util package (http://java.sun.com/j2se/1.3/). Likewise, there's the Generic Library for Java (JGL) by ObjectSpace (http://www.objectspace.com/products/voyager/jgl.asp), which is patterned after STL. Both the JC and JGL provide implementations of basic data structures such as maps, sets, dictionaries, and sequences. JGL also provides a number of template-based algorithms for permuting data. The Graph Foundation Classes for Java (GFC) by IBM's alphaWorks (http://www.alphaworks.ibm.com/tech/gfc/), a framework for programming with graphs, is still in a preliminary stage. The GFC provides more advanced data structures (such as trees and graphs) and some graph drawing algorithms. However, none of these Java libraries provide a coherent framework &#151; capable of accommodating both elementary and advanced data structures and algorithms &#151; required by developers of complex software. </p><p>With this in mind, we designed and developed the Data Structures Library in Java (JDSL), a collection of Java interfaces and classes implementing fundamental data structures and algorithms such as:</p><ul>  <li>Sequences, trees, priority queues, search trees, and hash tables.  <li>Sorting and searching algorithms.  <li>Graphs.  <li>Graph traversals, topological sorting, shortest path, and minimum spanning tree.</ul><p>The library was designed so that each data structure is specified by an interface and each algorithm uses data structures only via the interface methods. Actual classes need only be specified when objects are instantiated. Programming through interfaces (rather than through actual classes) creates more general code. It lets different implementations of the same interface be used interchangeably, without having to modify the algorithm code. This way, users can choose the most appropriate implementation, in terms of time or space complexity, for the application at hand.</p><p>Initial JDSL development began in September 1996 at the Center for Geometric Computing at Brown University and Johns Hopkins University, and culminated with the release of JDSL 1.0 in 1998. A major part of the project in the first year was the experimentation with different models for data structures and algorithms, and the construction of prototypes. A significant reimplementation, documentation, and testing effort was carried out in 1999 in collaboration with Algomagic Technologies (http://www.algomagic.com/) leading to the current JDSL 2.0; this version was officially released in August 2000. The two JDSL releases were accompanied by the publication of the book <i>Data Structures and Algorithms In Java,</i> by Michael Goodrich and Roberto Tamassia (John Wiley &amp; Sons, 2001).</p><p>JDSL comes with extensive documentation, including detailed Javadoc, overview, tutorial with seven lessons, and several associated research papers. It is available free of charge for noncommercial use (see http://www.cs.brown.edu/cgc/jdsl/). Commercial licenses are also available. <A NAME="rt1"><A HREF="0104at1.htm">Table 1</A> compares the key features of JC, JGL, GFC, and JDSL, respectively. In our opinion, the main advantages of JDSL are the definition of a large set of data structure APIs in terms of Java interfaces (particularly the tree and graph APIs), availability of reliable and efficient implementations of those APIs, and availability of some fundamental graph algorithms.</p><p>A good library of data structures and algorithms should be able to integrate smoothly with other existing libraries. In particular, we have pursued compatibility with the Java Collections. JDSL supplements the JC and is not meant to replace them. No conflicts arise when using data structures from JDSL and JC in the same program. To facilitate the use of JDSL data structures in existing programs, we provided adapter classes to translate a Java Collection into a JDSL container and vice versa, whenever such a translation is applicable.</p><h3>JDSL Data Organization Concepts </h3><p>Data structures in JDSL are viewed as containers; that is, as an organized collection of objects (called the "elements" of the container). An element can be stored in many containers at the same time and stored multiple times in the same container. Each JDSL container element is an instance of<i> java.lang.Object; </i>this lets containers store heterogeneous elements. JDSL provides two general and implementation-independent ways to access (but not modify) elements stored in a container: individually, by means of accessors (<A NAME="rf1"><A HREF="0104af1.htm">Figure 1</A>); and globally, by means of iterators. An accessor abstracts the notion of membership of an element in a container, hiding the details of the implementation. It provides constant-time access to an element stored in a container, independently from its implementation. Every time an element is inserted in a container, an accessor associated with it is returned. Most operations on JDSL containers take one or more accessors as their operands.</p><p>We distinguish between two kinds of containers and accessors:</p><ul>  <li>Positional containers. Typical examples are sequences, trees, and graphs. In a positional container, some topological relation is established among the placeholders that store the elements (such as the predecessor-successor relation in a sequence, the parent-child relation in a tree, and the incidence relation in a graph). When inserting an element in the container, users decide what the relationship is between the new placeholder and existing ones (in a sequence, for instance, users may decide to insert an element before a given placeholder). A positional container does not change its topology, unless users specifically request a change. The implementation of these containers usually involves linked structures or arrays.  <li>Positions. The concept of position is an abstraction of the various types of placeholders in the implementation of a positional container (typically the nodes of a linked structure or cells of an array). Each position stores an element. Position implementations can store the following additional information: adjacent positions (for instance, the previous and next positions in a sequence, the right and left child and the parent in a binary tree, the list of incident edges in a graph); and consistency information (for instance, what container the position is in).  <li>	  A position can be directly queried for its element through method <i>element(),</i> which hides the details of where the element is actually stored, be it an instance variable or array cell. Instead, through the positional container, it is possible to replace the element of a position or swap the elements between two positions. As an element moves about in its container (or even from container to container), its position changes. Positions are similar to the concept of items used in LEDA.  <li>Key-based containers. Typical examples are dictionaries and priority queues. Each element stored in a key-based container has a key associated with it; keys are used as an indexing mechanism for associated elements. Each key of a key-based container is an instance of <i>java.lang.Object.</i> Typically, key-based containers are internally implemented using a positional container; for example, a possible implementation of a priority queue uses a binary tree (heap). The details of the internal representation, however, are completely hidden to users. Thus, users have no control over the organization of the positions that store the key/element pairs. It is the key-based container itself that modifies its internal representation based on the keys of the key/element pairs inserted or removed.   <li>Locators. The key/element pairs stored in a key-based container may change their positions in the underlying positional container due to some internal restructuring; say, after the insertion of a new key/element pair. For example, in the binary tree implementation of a priority queue, the key/element pairs move around the tree to preserve the top-down ordering of the keys, and thus their positions change. Hence, a different, more abstract type of accessor called a "locator" is provided to access a key/element pair stored in a key-based container. Locators hide the complications of dynamically maintaining the implementation-dependent binding between the key/element pairs and their positions in the underlying positional container implementation. A locator can be directly queried for its key and element, and through the key-based container, it is possible to replace the key and element of a locator. </ul><p>While accessors let users access single elements or key/element pairs in a container, iterators provide a simple mechanism for iteratively listing through a collection of objects. JDSL provides various iterators over the elements, keys, and accessors of a container (<A NAME="rf2"><A HREF="0104af2.htm">Figure 2</A>). They are similar to the iterators provided by the Java Collections. </p><p>All JDSL containers provide methods that return iterators over the entire container (for instance, all the nodes of a tree or all the locators of a dictionary). In addition, some methods return iterators over portions of the container (for instance, the children of a node of a tree or the locators with a given key in a dictionary). JDSL iterators can be traversed only forward; however, they can be reset to start a new traversal.</p><p>For simplicity, JDSL iterators have snapshot semantics &#151; they refer to the state of the container at the time the iterator was created, regardless of the possible subsequent modifications of the container. For example, if an iterator is created over all the nodes of a tree and then a subtree is cut off, the iterator still includes the nodes of the removed subtree.</p><h3>Decorations</h3><p>Another feature of JDSL is the ability to decorate individual positions of a positional container with attributes (that is, arbitrary objects). This mechanism is more convenient and flexible than either subclassing the position class to add new instance variables or creating global hash tables to store the attributes. Decorations are useful for storing temporary or permanent results of the execution of an algorithm. For example, in a depth-first search traversal of a graph, you can use decorations to (temporarily) mark the vertices being visited and to (permanently) store the computed DFS number of each vertex. We use instances of <i>java.lang.Object</i> for both the name and value of each attribute. </p><h3>Comparators</h3><p>When using a key-based container, users should be able to specify the comparison relation to be used with the keys. In general, this relation depends on the type of the keys and on the specific application for which the key-based container is used. Keys of the same type may be compared differently in different applications. One way to meet this requirement is to specify the comparison relation through a comparator object, which is passed to the key-based container constructor and then used by the key-based container every time two keys need to be compared. As <A NAME="rf3"><A HREF="0104af3.htm">Figure 3</A> shows, JDSL defines three comparator interfaces. A comparator interface is also defined in the Java 2 java.util package, but is not present in JDK 1.1. To maintain the backward compatibility of JDSL with the latter, the JDSL Comparator does not extend the Java Comparator.</p><h3>Algorithms</h3><p>JDSL views algorithms as objects that receive the input data as parameters of their <i>execute</i> method, and provide access to the output during or after the execution via additional methods. Most algorithms in JDSL are implemented by applying the template method pattern (see <i>Design Patterns,</i> by Erich Gamma et al., Addison-Wesley, 1995). The invariant part of an algorithm is implemented once in an abstract class, deferring the implementation of the steps that can vary to subclasses. These varying steps can be defined either as abstract methods (whose implementation must be provided by a subclass) or as hook methods (whose default implementation may be overridden in a subclass). In other words, algorithms perform generic computations that can be specialized to specific tasks by subclasses.</p><p>To illustrate the use of the template method pattern, we examine the JDSL implementation of Dijkstra's single-source shortest path algorithm. The algorithm refers to the edge weights by means of an abstract method that can be specialized depending on how the weights are actually stored or computed in the application at hand.</p><h3>JDSL Architecture </h3><p>JDSL currently consists of eight Java packages, each containing a set of interfaces and/or classes. The interfaces for the various containers are organized into two hierarchies &#151; one for the positional containers (<A NAME="rf4"><A HREF="0104af4.htm">Figure 4</A>) and another for the key-based containers (<A NAME="rf5"><A HREF="0104af5.htm">Figure 5</A>), with a common root given by interfaces <i>InspectableContainer</i> and <i>Container</i>. Most containers are described by two interfaces &#151; one that contains all the methods to query the container (its name is prefixed with <i>Inspectable</i>), and the other, extending the first, that contains all the methods to modify the container. Inspectable interfaces can be used as variable or parameter types to obtain an immutable view of a container (for instance, to prevent an algorithm from modifying the container it operates on).</p><p></p><ul>  <li><i>	jdsl.core.api</i>. Interfaces and exceptions that compose the API for the core containers (sequences, trees, priority queues, and dictionaries), and for the iterators on their elements, positions, and locators.  <li><i>jdsl.core.ref</i>. Implementations of the interfaces in <i>jdsl.core.api</i>. Most implementations have names of the form <i>{ImplementationStyle}{InterfaceName}.</i> For instance, <i>ArraySequence</i> and <i>NodeSequence</i> implement the <i>jdsl.core.api.Sequence</i> interface with a growable array and with a linked structure, respectively. Classes with names of the form <i>Abstract {InterfaceName} </i>implement some methods of the interface for the convenience of developers building alternative implementations.  <li><i>jdsl.core.algo.sorts</i>. Sorting algorithms that operate on the elements stored in a <i>jdsl.core.api.Sequence</i> object. They are parameterized with respect to the comparison rule used to sort the elements, provided as a <i>jdsl.core.api.Comparator</i> object.  <li><i>jdsl.core.algo.traversals</i>. Traversal algorithms that operate on <i>jdsl.core.api.InspectableTree</i> objects. A traversal algorithm performs operations while visiting the nodes of the tree, and can be extended applying the template method pattern.   <li><i>jdsl.core.util</i>. Currently contains a <i>Converter</i> class to convert JDSL data structures to Java Collections and vice versa.  <li><i>jdsl.graph.api</i>. Interfaces and exceptions that compose the API for the graph container, and for the iterators on its vertices and edges.  <li><i>jdsl.graph.ref</i>. Implementations of the interfaces in <i>jdsl.graph.api</i>; in particular, class <i>IncidenceListGraph</i> is an implementation of interface <i>jdsl.graph.api.Graph</i>.  <li><i>jdsl.graph.algo</i>. Basic graph algorithms, including depth-first search, topological sorting, shortest path, and minimum spanning tree, all of which can be extended by applying the template method pattern.</ul><h3>A Sample Application</h3><p>To illustrate how you can use JDSL, we present a sample application that uses concepts such as the graph and priority queue data structures, locators, decorations, and template method pattern. Specifically, we consider the problem of calculating a minimum-time flight itinerary between two airports. The flight network can be modeled using a directed graph: Each vertex of the graph represents an airport, and each directed edge represents a flight from the origin airport to the destination airport. The problem can be solved by computing a shortest path between two vertices of a directed weighted graph, or determining that a path does not exist. To this purpose, we can suitably modify the classical algorithm by Dijkstra (see "A Note on Two Problems in Connexion with Graphs," by E.W. Dijkstra, <i>Numerische Mathematik,</i> 1959), which takes as input a graph <i>G</i> with nonnegative edge weights and a distinguished source vertex <i>s,</i> and computes a shortest path from <i>s</i> to any reachable vertex of <i>G.</i> Dijkstra's algorithm maintains a priority queue <i>Q</i> of vertices: At any time, the key of a vertex <i>u</i> in the priority queue is the length of the shortest path from <i>s</i> to <i>u</i> found so far. The priority queue is initialized by inserting vertex <i>s</i> with key 0 and all the other vertices with key+<img src="infinity.gif"> (some very large number). The algorithm repeatedly executes the steps:</p><p>1.	Remove a minimum-key vertex <i>u</i> from the priority queue and mark it as finished, since a shortest path from <i>s</i> to <i>u</i> has been found.</p><p>2.	For each edge <i>e</i> connecting vertex <i>u</i> to an unfinished vertex <i>v</i>, if the path formed by extending a shortest path from <i>s</i> to <i>u</i> with edge <i>e</i> is shorter than the shortest known path from <i>s</i> to <i>v,</i> update the key of <i>v</i> (this operation is known as the "relaxation" of edge <i>e</i>). </p><p>JDSL includes an implementation of Dijkstra's algorithm that applies the template method pattern. The primitive operations of the algorithm are defined by some abstract or overridable methods. The invariant steps of the algorithm are implemented in a few unmodifiable methods that call the primitive operation methods. To specialize the algorithm to the application at hand, you must subclass the algorithm and define or override the primitive operation methods. The abstract class implementing Dijkstra's algorithm is <i>I</i><i>ntegerDijkstraTemplate</i> in package <i>jdsl.graph.algo</i> (see <A NAME="rl1"><A HREF="#l1">Listing One</A>; for brevity, we removed the Javadoc comments). The simplest way to run the algorithm is by calling <i>execute(g,source)</i>, which first initializes the various auxiliary data structures with <i>init(g,source)</i> and then repeatedly invokes <i>doOneIteration()</i>. The number of times <i>doOneIteration()</i> is invoked is controlled by <i>shouldContinue()</i>. Instead of calling <i>execute(g,source)</i>, another possibility is to call <i>init(g,source) </i>directly and then single-step the algorithm by explicitly calling<i> doOneIteration().</i></p><p>For an efficient implementation of the algorithm, it is important to access a vertex stored in the priority queue in constant time, whenever its key has to be modified. This is possible through the locator accessors provided by the priority queue. In <i>init(g,source),</i> each vertex <i>u</i> of the graph is inserted in the priority queue and a locator <i>uLoc</i> for the key/vertex pair is returned. Through <i>setLocator(u,uLoc),</i> each vertex <i>u</i> is decorated with its locator <i>uLoc; </i>variable<i> LOCATOR</i> is used as the attribute name. Later, in <i>doOneIteration()</i>, the locator is retrieved with <i>getLocator(v),</i> in order to access and possibly modify the key of vertex <i>v;</i> we recall that the key of <i>v</i> is the shortest known distance from <i>source</i> to <i>v</i>. In addition to its locator in the priority queue, every unfinished vertex <i>v</i> is also decorated with its last relaxed incident edge <i>uv</i> through <i>setEdgeToParent(v,uv)</i>; variable <i>EDGE_TO_PARENT</i> is used as the attribute name in this case. When a vertex is finished, this decoration stores the edge to the parent in the shortest path tree, and can be retrieved with <i>getEdgeToParent(Vertex)</i>.</p><p>Methods <i>runUntil()</i> and <i>doOneIteration()</i> are declared final and thus cannot be overridden. However, they invoke some methods, namely <i>shouldContinue(), vertexNotReachable(u), shortestPathFound(u,uDist), </i>and<i> edgeRelaxed(u,uDist,uv,uvWeight,v,vDist),</i> that may be overridden for special applications. For each vertex <i>u</i> of the graph, either<i> vertexNotReachable(u)</i> or <i>s</i><i>hortestPathFound(u,uDist) </i>is called exactly once, when <i>u</i> is removed from the priority queue and marked as finished. In particular, <i>shortestPathFound(u,uDist)</i> decorates <i>u</i> with <i>uDist</i>, the shortest distance from <i>source</i>; variable<i> DISTANCE</i> is used as the attribute name. Method <i>edgeRelaxed(u,uDist,uv,uvWeight,v,vDist)</i> is called every time an edge <i>uv</i> from a finished vertex <i>u</i> to an unfinished vertex <i>v</i> is examined. The only method whose implementation must be provided by a subclass is abstract method <i>weight(Edge), </i>which returns the weight of an edge. Finally, <i>distance(Vertex) </i>lets users query each finished vertex for the shortest distance from <i>source</i>.</p><p>JDSL also provides a specialization of Dijkstra's algorithm to the problem of finding a shortest path between two vertices of a graph. This algorithm is implemented by abstract class <i>IntegerDijkstraPathfinder </i>(see <A NAME="rl2"><A HREF="#l2">Listing Two</A>), which extends <i>IntegerDijkstraTemplate.</i> The execution of Dijkstra's algorithm is stopped as soon as the destination vertex is finished. To this purpose, <i>shouldContinue()</i> is overridden to return <i>true</i> only if the destination vertex has not been finished yet. Additional methods are provided in <i>IntegerDijkstraPathfinder</i> to test, after the execution of the algorithm, whether a path from the source vertex to the destination vertex exists, and in this case, to return it.</p><p>Our application for computing a minimum-time flight itinerary between two airports can be implemented as a specialization of <i>IntegerDijkstraPathfinder</i>, namely, class <i>FlightDijkstra</i> (see <A NAME="rl3"><A HREF="#l3">Listing Three</A>). The distance of each vertex represents, in this case, the time elapsed between the arrival at the corresponding airport and the beginning of the travel. All it takes to implement our application is to override <i>incidentEdges(), </i>so that only the outgoing edges of a finished vertex are examined, and to define <i>weight(Edge)</i>. The weighted graph representing the flight network is a directed graph. Each edge stores, as an element, an instance of <i>FlightSpecs</i>, an auxiliary class that provides the departure time and the duration of the corresponding flight. The weight of each edge is not determined before the execution of the algorithm, but depends on the computed shortest distance between the source and the origin of the edge. Namely, it is obtained by adding the duration of the flight corresponding to the edge and the connecting time at the origin airport for that flight. (In the sample application we ignore the minimum connecting time requirement, which could be accommodated with minor code modifications.) The algorithm is run by calling <i>execute(g,source,dest,startTime),</i> where <i>startTime</i> is the earliest time the passenger can begin traveling. Method <i>TimeTable.diff(int,int) </i>simply computes the difference between its two arguments modulo 24 hours. </p><p>As you can see, the availability in JDSL of a set of carefully designed and extensible algorithms and data structures makes it possible to implement moderately complex applications with a small amount of code, thus dramatically reducing the development time.</p><h3>Future Directions</h3><p>In the current version of JDSL, our emphasis has been on data structures, while only a basic repertory of algorithms has been provided. Future versions will include a wider selection of algorithms such as biconnected components, maximum flow, matching, and graph drawing algorithms. More complex data structures such as topological graphs and planar subdivisions, will be added as well. We also plan to make JDSL data structures thread-safe and serializable. Finally, future versions will include a package for testing whether the (user-provided) implementation of a data structure complies with the interface specification, and a data structure visualization package. </p><h3>Acknowledgments</h3><p>This work was supported in part by the U.S. Army Research Office under grant DAAH04-96-1-0013 and the National Science Foundation under grant CCR-9732327. </p><p></p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>package jdsl.graph.algo;import jdsl.core.api.*;import jdsl.core.ref.ArrayHeap;import jdsl.core.ref.IntegerComparator;import jdsl.graph.api.*;public abstract class IntegerDijkstraTemplate {// instance variables  protected PriorityQueue pq_;  protected InspectableGraph g_;  protected Vertex source_;  private final Integer ZERO = new Integer(0);  private final Integer INFINITY = new Integer(Integer.MAX_VALUE);  private final Object LOCATOR = new Object();  private final Object DISTANCE = new Object();  private final Object EDGE_TO_PARENT = new Object();  // abstract instance methods  protected abstract int weight (Edge e);  // instance methods that may be overridden for special applications  protected void shortestPathFound (Vertex v, int vDist) {    v.set(DISTANCE,new Integer(vDist));  }  protected void vertexNotReachable (Vertex v) {    v.set(DISTANCE,INFINITY);    setEdgeToParent(v,Edge.NONE);  }  protected void edgeRelaxed (Vertex u, int uDist, Edge uv, int uvWeight,		      Vertex v, int vDist) { }  protected boolean shouldContinue () {    return true;  }  protected boolean isFinished (Vertex v) {    return v.has(DISTANCE);  }  protected void setLocator (Vertex v, Locator vLoc) {    v.set(LOCATOR,vLoc);  }  protected Locator getLocator (Vertex v) {    return (Locator)v.get(LOCATOR);  }  protected void setEdgeToParent (Vertex v, Edge vEdge) {    v.set(EDGE_TO_PARENT,vEdge);  }  protected EdgeIterator incidentEdges (Vertex v) {    return g_.incidentEdges(v,EdgeDirection.OUT | EdgeDirection.UNDIR);  }  protected Vertex destination (Vertex origin, Edge e) {    return g_.opposite(origin,e);  }  protected VertexIterator vertices () {    return g_.vertices();  }  protected PriorityQueue newPQ () {    return new ArrayHeap(new IntegerComparator());  }  // output instance methods  public final boolean isReachable (Vertex v) {    return v == source_      || v.has(EDGE_TO_PARENT) &amp;&amp; v.get(EDGE_TO_PARENT) != Edge.NONE;  }  public final int distance (Vertex v) throws InvalidQueryException {    try {      return ((Integer)v.get(DISTANCE)).intValue();    }    catch (InvalidAttributeException iae) {      throw new InvalidQueryException(v+" has not been reached yet");    }  }  public Edge getEdgeToParent (Vertex v) throws InvalidQueryException {    try {      return (Edge)v.get(EDGE_TO_PARENT);    }    catch (InvalidAttributeException iae) {      String s = (v == source_) ? " is the source vertex"	: " has not been reached yet";      throw new InvalidQueryException(v+s);    }  }  // instance methods composing the core of the algorithm  public void init (InspectableGraph g, Vertex source) {    g_ = g;    source_ = source;    pq_ = newPQ();    VertexIterator vi = vertices();    while (vi.hasNext()) {      Vertex u = vi.nextVertex();      Integer uKey = (u == source_) ? ZERO : INFINITY;      Locator uLoc = pq_.insert(uKey,u);      setLocator(u,uLoc);    }  }  protected final void runUntil () {    while (!pq_.isEmpty() &amp;&amp; shouldContinue())      doOneIteration();  }  public final void doOneIteration () throws InvalidEdgeException {    Integer minKey = (Integer)pq_.min().key();    // remove a vertex with minimum distance from the source    Vertex u = (Vertex)pq_.removeMin();    if (minKey == INFINITY)      vertexNotReachable(u);    else {   // the general case      int uDist = minKey.intValue();      shortestPathFound(u,uDist);      int maxEdgeWeight = INFINITY.intValue()-uDist-1;      EdgeIterator ei = incidentEdges(u);      while (ei.hasNext()) {   // examine all the edges incident with u	Edge uv = ei.nextEdge();	int uvWeight = weight(uv);	if (uvWeight &lt; 0 || uvWeight &gt; maxEdgeWeight)	  throw new InvalidEdgeException	    ("The weight of "+uv+" is either negative or causing overflow");	Vertex v = destination(u,uv);	Locator vLoc = getLocator(v);	if (pq_.contains(vLoc)) {   // v is not finished yet	  int vDist = ((Integer)vLoc.key()).intValue();	  int vDistViaUV = uDist+uvWeight;	  if (vDistViaUV &lt; vDist) {   // relax	    pq_.replaceKey(vLoc,new Integer(vDistViaUV));	    setEdgeToParent(v,uv);	  }	  edgeRelaxed(u,uDist,uv,uvWeight,v,vDist);	}      }    }  }  public final void execute (InspectableGraph g, Vertex source) {    init(g,source);    runUntil();  }  public void cleanup () {    VertexIterator vi = vertices();    while (vi.hasNext()) {      vi.nextVertex().destroy(LOCATOR);      try {	vi.vertex().destroy(EDGE_TO_PARENT);	vi.vertex().destroy(DISTANCE);      }      catch (InvalidAttributeException iae) { }    }  }}   // class IntegerDijkstraTemplate</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>package jdsl.graph.algo;import jdsl.core.api.*;import jdsl.core.ref.NodeSequence;import jdsl.graph.api.*;import jdsl.graph.ref.EdgeIteratorAdapter;public abstract class IntegerDijkstraPathfinder  extends IntegerDijkstraTemplate {  // instance variables  private Vertex dest_;  // overridden instance methods from IntegerDijkstraTemplate  protected boolean shouldContinue () {    return !isFinished(dest_);  }  // output instance methods  public boolean pathExists () {    return isFinished(dest_);  }  public EdgeIterator reportPath () throws InvalidQueryException {    if (!pathExists())      throw new InvalidQueryException	("No path exists between "+source_+" and "+dest_);    else {      Sequence retval = new NodeSequence();      Vertex currVertex = dest_;      while (currVertex != source_) {	Edge currEdge = getEdgeToParent(currVertex);	retval.insertFirst(currEdge);	currVertex = g_.opposite(currVertex,currEdge);      }      return new EdgeIteratorAdapter(retval.elements());    }  }  // instance methods  public final void execute (InspectableGraph g, Vertex source, Vertex dest) {    dest_ = dest;    init(g,source);    if (source_ != dest_)      runUntil();  }}   // class IntegerDijkstraPathfinder</pre><P><A HREF="#rl2">Back to Article</A></P><H4><A NAME="l3">Listing Three</H4><pre>import jdsl.graph.api.*;import jdsl.graph.algo.IntegerDijkstraPathfinder;import support.*;public class FlightDijkstra extends IntegerDijkstraPathfinder {  // instance variables  private int startTime_;  // overridden instance methods from IntegerDijkstraPathfinder  protected int weight (Edge e) {    // the flightspecs for the flight along edge e    FlightSpecs eFS = (FlightSpecs)e.element();    int connectingTime = TimeTable.diff(eFS.departureTime(),                                        startTime_+distance(g_.origin(e)));    return connectingTime+eFS.flightDuration();  }  protected EdgeIterator incidentEdges (Vertex v) {    return g_.incidentEdges(v,EdgeDirection.OUT);  }  // instance methods  public void execute (InspectableGraph g, Vertex source, Vertex dest,                       int startTime) {    startTime_ = startTime;    super.execute(g,source,dest);  }}   // class FlightDijkstra</pre><P><A HREF="#rl3">Back to Article</A></P></body></html>