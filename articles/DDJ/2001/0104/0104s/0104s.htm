<html><head><title>Apr01: Algorithm Alley</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Suffix Arrays</h1><p><i>Dr. Dobb's Journal</i> April 2001</p><h3>By Jon Bentley</h3><I>Jon is a Member of Technical Staff at Bell Labs. He can be reached at jlb@research .bell-labs.com.</I><hr><p>Suffix trees are simple, yet powerful, data structures: Fill an array with pointers to every position in a string, sort the array, then quickly search the string for long phrases. A few lines of code suffice to implement this structure, which can be near optimal in time and space. In this column, I'll introduce the structure with a simple problem, then apply it to a more subtle task.</p><h3>Common Strings</h3><p>Given an input file of text, how can a program find the longest duplicated substring of characters? For instance, the longest repeated string in "Ask not what your country can do for you, but what you can do for your country" is " can do for you," with "your country" a close second. How would you write a program to solve this problem?</p><DDJADVERTISEMENT INLINE><p>If the input string is stored in <i>c[0..n-1], </i>a simple program could compare every pair of substrings with the following pseudocode:</p><blockquote><p>maxlen = -1</p><p>for (i = 0; i &lt; n; i++)</p><p>    for (j = 0; j &lt; n; j++)</p><p>        thislen = comlen(&amp;c[i], &amp;c[j])</p><p>        if thislen &gt; maxlen</p><p>            maxlen = thislen</p><p>            maxi = i</p><p>            maxj = j</p></blockquote><p>The <i>comlen</i> function returns the length that its two parameter strings have in common, starting with their first characters:</p><blockquote><p>int comlen(char *p, char *q)</p><p>    i = 0</p><p>    while *p &amp;&amp; (*p++ == *q++)</p><p>        i++</p><p>    return i</p></blockquote><p>Because the algorithm looks at all pairs of substrings, it takes time proportional to <i>n</i>2, at least.</p><p>Suffix arrays give a faster algorithm. The program processes at most MAXN characters, which it stores in the array <i>c</i>:<i></p><blockquote><p></i>#define MAXN 5000000</p><p>char c[MAXN], *a[MAXN];</p></blockquote><p>The suffix array is the array <i>a</i> of pointers to characters. As the program reads the input, it initializes <i>a</i> so that each element points to the corresponding character in the input string:</p><blockquote><p>while (ch = getchar()) != EOF</p><p>    a[n] = &amp;c[n]</p><p>    c[n++] = ch</p><p>c[n] = 0</p></blockquote><p>The final element of <i>c</i> contains a null character, which terminates all strings.</p><p>The element <i>a[0]</i> points to the entire string; the next element points to the suffix of the array beginning with the second character, and so on. On the input string "banana," the array will represent these suffixes:</p><blockquote><p>a[0]: banana</p><p>a[1]: anana</p><p>a[2]: nana</p><p>a[3]: ana</p><p>a[4]: na</p><p>a[5]: a</p></blockquote><p>The pointers in the array <i>a</i> together point to every suffix in the string, hence the name "suffix array."</p><p>If a long string occurs twice in the array <i>c,</i> it appears in two different suffixes. The program therefore sorts the array to bring together equal suffixes. The "banana" array sorts to the following:</p><blockquote><p>a[0]: a</p><p>a[1]: ana</p><p>a[2]: anana</p><p>a[3]: banana</p><p>a[4]: na</p><p>a[5]: nana</p></blockquote><p>The code then scans through this array comparing adjacent elements to find the longest repeated string, which, in this case, is "ana." The suffix array structure is that simple: Fill an array with pointers, and sort them. It has been used at least since the 1970s, though the term was introduced in the 1990s.</p><p>The program will sort the suffix array with the <i>qsort</i> function:</p><blockquote><p>qsort(a, n, sizeof(char *), pstrcmp)</p></blockquote><p>The <i>pstrcmp</i> comparison function adds one level of indirection to the library <i>strcmp</i> function. This scan through the array uses the <i>comlen</i> function to count the number of letters that two adjacent words have in common:</p><blockquote><p>for (i = 0; i &lt; n; i++)</p><p>    if comlen(a[i], a[i+1]) &gt; maxlen</p><p>        maxlen = comlen(a[i], a[i+1])</p><p>        maxi = i</p><p>printf("%.*s\en", maxlen, a[maxi])</p></blockquote><p>The <i>printf</i> statement uses the "*" precision to print <i>maxlen</i> characters of the string.</p><p>Suffix arrays represent every substring in <i>n</i> characters of input text using the text itself and <i>n</i> additional pointers. On typical text files of <i>n</i> characters, the algorithm runs in <i>O(nlogn) </i>time, due to sorting. The complete program in <A NAME="rl1"><A HREF="#l1">Listing One</A> found the longest repeated string in the 4,460,056 characters of the <i>King James Bible </i>in about 36 seconds on a 600-MHz Celeron processor (check out the seventh chapter of the "Book of Numbers").</p><h3>Markov Text</h3><p>How can you generate random text? A classic approach is to let loose that poor monkey on his aging typewriter. If the beast is equally likely to hit any lowercase letter or the space bar, the output might look like this: </p><blockquote><p>cbczqpbtvfbyak zfw ecrodtgdd bautfxqkdajxoc</p></blockquote><p>This is pretty unconvincing English text.</p><p>If you count the letters in word games (like <i>Scrabble</i> or <i>Boggle</i>), you notice that there are different numbers of the various letters. There are many more As, for instance, than there are Zs. A monkey could produce more convincing text by counting the letters in a document &#151; if A occurs 300 times in the text while B occurs just 100 times, then the monkey should be three-times more likely to type an A than a B. This moves a small step closer to English:</p><blockquote><p>saoo nte on sch wirT,hhths fewr loieseium rase</p></blockquote><p>Most events occur in context. Suppose that you wanted to generate randomly a year's worth of Fahrenheit temperature data. A series of 365 random integers between 0 and 100 wouldn't fool the average observer. You could be more convincing by making today's temperature a (random) function of yesterday's temperature: If it is 85 degrees today, it is unlikely to be 15 degrees tomorrow.</p><p>The same is true of English words: If this letter is a Q, then the next letter is quite likely to be a U. A generator can make more interesting text by making each letter a random function of its predecessor. You could, therefore, read a sample text and count how many times every letter follows an A, how many times they follow a B, and so on for each letter of the alphabet. When the generator writes the random text, it produces the next letter as a random function of the current letter. The Order-1 text was made by exactly this scheme: </p><ul>  <li>	Order-1. Hixt oftorawa opikie the wanos? sof I thincks my beehimofove, f fonemar  <li>	Order-2. ligs art myrrh lover comousalipper goodge shing spould bely, he not hart socks galhat is the  <li>	Order-3. Many of scarly of Israel. What spices. Thy love; and, and the like the us sword my belove; forth, and my spousalem, bund gold lilie art flook not.  <li>	Order-4. We hath banners. The foxes, as the lions? My belove, new and frankince's daughters of smote merchant? I would none throught handles of being house; </ul><p>This idea extends to longer sequences of letters. The Order-2 text was made by generating each letter as a function of the two letters preceding it (a letter pair is often called a "digram"). The digram TH, for instance, is often followed in English by the vowels A, E, I, O, U and Y, less frequently by R and W, and rarely by other letters. The Order-3 text is built by choosing the next letter as a function of the three previous letters (a trigram). In Order-4 text, most words are English, and you might not be surprised to learn that it was generated from the <i>King James Version </i>of the "Song of Solomon." (See the "Further Reading" section at the end of this column for more examples of randomly generated text.)</p><p>Readers with a mathematical background might recognize this process as a Markov chain. One state represents each <i>k</i>-gram, and the odds of going from one to another don't change, so this is a "finite-state Markov chain with stationary transition probabilities."</p><p>You can also generate random text at the word level. The dumbest approach is to spew forth the words in a dictionary at random. A slightly better approach reads a document, counts each word, and then selects the next word to be printed with the appropriate probability. More interesting text, though, is produced by using Markov chains that take into account a few preceding words as they generate the next word. Here is some random text produced from my book <i>Programming Pearls</i>:</p><ul>  <li>	Order-1. the STL also adds the same sequence of the large they didn't, they are those structures, design can sometimes decrease storage allocation is trivial program in increasing <i>y-</i>order,  <li>	Order-2. The 40-pass algorithm in Solution 4) to run out of order with its push-button encoding, sort by column then row, and then bring together all words with the <i>sizeof</i> structures. We therefore used a total of 96 megabytes.  <li>	Order-3. I despise having to use a binary search. These techniques apply to any piecewise-linear functions. 3. This C code implements the sorting algorithm, using the functions defined in Solution 2. </ul><p>The Order-1 text is almost readable aloud, while the Order-3 text consists of very long phrases from the original input, with random transitions between them. For purposes of parody, Order-2 text is usually juiciest. (See the "Further Reading" section for many more examples of word-level Markov text.)</p><h3>Automating Parody</h3><p>I first saw letter-level and word-level order-<i>k</i> approximations to English text in Shannon's 1948 classic <i>Mathematical Theory of Communication. </i>Shannon describes how he generated such text: </p><blockquote><p>To construct [order-1 letter-level text] for example, one opens a book at random and selects a letter at random on the page. This letter is recorded. The book is then opened to another page and one reads until this letter is encountered. The succeeding letter is then recorded. Turning to another page this second letter is searched for and the succeeding letter recorded, etc. A similar process was used for [order-1 and order-2 letter-level text, and order-0 and order-1 word-level text]. It would be interesting if further approximations could be constructed, but the labor involved becomes enormous at the next stage."</p></blockquote><p></p><p>Programs have been automating this laborious task since the early 1950s. Shannon's method scans the input text for the current <i>k</i>-gram to generate the next word; this approximation works well when <i>k</i> is small, but gives biased output when there are uneven gaps between <i>k</i>-grams. Fast machines can instead scan the complete input text to choose a truly random successor. A program at http://www .programmingpearls.com/ implements this approach, but it generates only a few outputs per second when processing the 4-million characters in the <i>King James Bible.</i></p><p>A suffix array lets a program search for the next phrase more efficiently. The Order-<i>k</i> C program will store at most 5 MB of text in the array <i>inputchars</i>:</p><blockquote><p>int k = 2;</p><p>char inputchars[5000000];</p><p>char *word[1000000];</p><p>int nword = 0;</p></blockquote><p>It will employ the array <i>word</i> as a suffix array pointing to the characters that start on word boundaries (a common modification). The variable <i>nword</i> holds the number of words. It reads the file with the following code:</p><blockquote><p>word[0] = inputchars</p><p>while scanf("%s", word[nword]) != EOF</p><p>    word[nword+1] =</p><p>       word[nword] + strlen(word[nword]) + 1</p><p>    nword++</p></blockquote><p>Each word is appended to <i>inputchars</i> (no other storage allocation is needed), and is terminated by the null character supplied by <i>scanf</i>.</p><p>After reading the input, the program sorts the <i>word</i> array to bring together all pointers that point to the same sequence of <i>k</i> words. The following function does the comparisons:</p><blockquote><p>int wordncmp(char *p, char* q)</p><p>    n = k</p><p>    for ( ; *p == *q; p++, q++)</p><p>        if (*p == 0 &amp;&amp; --n == 0)</p><p>            return 0</p><p>    return *p - *q</p></blockquote><p>It scans through the two strings while the characters are equal. At every null character, it decrements the counter <i>n</i> and returns equal after seeing <i>k</i> identical words. When it finds unequal characters, it returns the difference.</p><p>After reading the input, the program appends <i>k</i> null characters (so the comparison function doesn't run off the end), prints the first <i>k</i> words in the document (to start the random output), and calls the sort:</p><blockquote><p>for (i = 0; i &lt; k; i++)</p><p>    word[nword][i] = 0</p><p>for (i = 0; i &lt; k; i++)</p><p>    print word[i]</p><p>qsort(word, nword, sizeof(word[0]), sortcmp)</p></blockquote><p>The <i>sortcmp</i> function, as usual, adds a level of indirection to its pointers.</p><p>The space-efficient structure now contains a great deal of information about the <i>k</i>-grams in the text. If <i>k</i> is 1 and the input text is "of the people, by the people, for the people," the <i>word</i> array might look like this:</p><blockquote><p>word[0]: by the</p><p>word[1]: for the</p><p>word[2]: of the</p><p>word[3]: people</p><p>word[4]: people, for</p><p>word[5]: people, by</p><p>word[6]: the people,</p><p>word[7]: the people</p><p>word[8]: the people,</p></blockquote><p>For clarity, this picture shows only the first <i>k</i>+1 words pointed to by each element of <i>word</i>, even though more words usually follow. To find a word to follow the phrase "the," a program looks it up in the suffix array to discover three choices: "people," twice and "people" once.</p><p>The program may now generate nonsense text with the pseudocode in <A NAME="re1"><A HREF="0104se1.htm">Example 1</A>. The loop is initialized by setting <i>phrase</i> to the first characters in the input (recall that those words were already printed on the output file). The binary search locates the first occurrence of <i>phrase</i> (it is crucial to find the very first occurrence). The next loop scans through all equal phrases, selects one of them at random. If the <i>k</i>-th word of that phrase is of length zero, the current phrase is the last in the document, and an early exit is taken from the loop.</p><p>The complete pseudocode (see <A NAME="re2"><A HREF="0104se2.htm">Example 2</A>) implements those ideas, and also puts an upper bound on the number of words it generates. <A NAME="rl2"><A HREF="#l2">Listing Two</A> is the complete C program. (See "Further Reading" for a description of a more typical program for generating Markov text that doesn't use suffix arrays. The suffix array approach is about half the length in code, has similar run time, and uses an order of magnitude less memory.) </p><h3>Principles</h3><p>Need to search for phrases in a long string? Create an array of pointers to every relevant position in the string (every character or every word), and sort it. The resulting suffix array gathers together similar strings, and lets you look up a string using binary search. It requires only a few lines of code to build, <i>n</i> extra pointers of space, and a small and fast binary search to answer a query.</p><h3>Further Reading</h3><p>This column is based on Chapter 15 of the second edition of<i> Programming Pearls</i> (Addison-Wesley, 2000). The full column is available at http://www.programmingpearls.com/. It contains exercises, solutions, code, references to related work, and numerous examples of Markov text.</p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>/* Copyright (C) 1999 Lucent Technologies *//* From 'Programming Pearls' by Jon Bentley *//* longdup.c -- Print longest string duplicated M times */#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;stdio.h&gt;int pstrcmp(char **p, char **q){   return strcmp(*p, *q); }int comlen(char *p, char *q){   int i = 0;    while (*p &amp;&amp; (*p++ == *q++))        i++;    return i;}#define M 1#define MAXN 5000000char c[MAXN], *a[MAXN];int main(){   int i, ch, n = 0, maxi, maxlen = -1;    while ((ch = getchar()) != EOF) {        a[n] = &amp;c[n];        c[n++] = ch;    }    c[n] = 0;    qsort(a, n, sizeof(char *), pstrcmp);    for (i = 0; i &lt; n-M; i++)        if (comlen(a[i], a[i+M]) &gt; maxlen) {            maxlen = comlen(a[i], a[i+M]);            maxi = i;        }    printf("%.*s\n", maxlen, a[maxi]);    return 0;}</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>/* Copyright (C) 1999 Lucent Technologies *//* From 'Programming Pearls' by Jon Bentley *//* markov.c -- generate random text from input document */#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;char inputchars[4300000];char *word[800000];int nword = 0;int k = 2;int wordncmp(char *p, char* q){   int n = k;    for ( ; *p == *q; p++, q++)        if (*p == 0 &amp;&amp; --n == 0)            return 0;    return *p - *q;}int sortcmp(char **p, char **q){   return wordncmp(*p, *q);}char *skip(char *p, int n){   for ( ; n &gt; 0; p++)        if (*p == 0)            n--;    return p;}int main(){   int i, wordsleft = 10000, l, m, u;    char *phrase, *p;    word[0] = inputchars;    while (scanf("%s", word[nword]) != EOF) {        word[nword+1] = word[nword] + strlen(word[nword]) + 1;        nword++;    }    for (i = 0; i &lt; k; i++)        word[nword][i] = 0;    for (i = 0; i &lt; k; i++)        printf("%s\n", word[i]);    qsort(word, nword, sizeof(word[0]), sortcmp);    phrase = inputchars;    for ( ; wordsleft &gt; 0; wordsleft--) {        l = -1;        u = nword;        while (l+1 != u) {            m = (l + u) / 2;            if (wordncmp(word[m], phrase) &lt; 0)                l = m;            else                u = m;        }        for (i = 0; wordncmp(phrase, word[u+i]) == 0; i++)            if (rand() % (i+1) == 0)                p = word[u+i];        phrase = skip(p, 1);        if (strlen(skip(phrase, k-1)) == 0)            break;        printf("%s\n", skip(phrase, k-1));    }    return 0;}</pre><P><A HREF="#rl2">Back to Article</A></P></body></html>