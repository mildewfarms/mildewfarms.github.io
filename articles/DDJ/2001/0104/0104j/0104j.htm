<html><head><title>Apr01: Programmer's Toolchest</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>SCRAM: Software Configuration, Release, and Management</h1><p><i>Dr. Dobb's Journal</i> April 2001</p><h2>Software configuration for distributed development</h2><h3>By Chris Williams </h3><I>Chris works at CERN, the European Laboratory for Particle Physics. He can be contacted at christopher.williams@cern.ch.</I><hr><a name="rs1"><a href="0104js1.htm">SCRAM Documents</a><hr><p>The development of large-scale software projects across geographical boundaries requires rigorous configuration management. SCRAM, short for "Software Configuration, Release, and Management," is a flexible and scalable software-development tool designed for such a task. SCRAM provides configuration management, distribution, and software build services to ensure consistent and easy to use development environments that work in a multiplatform environment. This enables autonomous development groups to work together.</p><p>SCRAM is currently used in several projects here at CERN, the European Laboratory for Particle Physics. Projects range in size from one to more than 100 developers spread over some 50 different institutions in 35 countries. SCRAM (available at http://cmsdoc.cern.ch/cgi-cmc/scrampage/) is released under the GNU public license and is open to all. It is written mostly in Perl 5, but requires GNU make and a bash shell for the BuildSystem. System function calls are kept to a minimum, so porting to nonUNIX platforms, if required, should not be too big a problem. </p><DDJADVERTISEMENT INLINE><h3>Configuration Management</h3><p>One key function of configuration management is the art of keeping track of what you are working with. This means your compiler, operating system, external product libraries, environment, and the version of the source code. Only once all the components, known as "the configuration," are known is it possible to ensure that all developers are working on the correct thing and within the projects constraints. </p><p>In large projects, this can become a complex and tedious business and so SCRAM was developed to help out. The principle behind the tool is simple, if you don't explicitly ask for it, you don't get it. You create a toolbox with a well-defined set of tools, and then restrict yourself to that toolbox. In this way, nothing can sneak into your configuration (for example, because your system manager had installed something "useful" in /usr/lib) without you and your coworkers being able to reproduce it.</p><h3>Source-Code Repositories</h3><p>A source-code repository manager is a specialized tool for storing and versioning your source code. SCRAM is not a source-code repository manager. However, SCRAM requires that you have a source-code repository of some sort to define the source associated with a given release. The only manager SCRAM knows about is CVS (Concurrent Versioning System) (http://www.loria.fr/~molli/cvs-index.html), although it should be trivial to add others if required. (For more information on CVS, see "CVS Version Control and Branch Management," by Michael Simpson, <i>DDJ</i>, October 2000.) I run a CVS server with ssh access for my developers. It has been modified slightly to allow development group managers to manage their own repository access rights.</p><h3>SCRAM Projects</h3><p><A NAME="rf1"><A HREF="0104jf1.htm">Figure 1</A> shows the main components required to define a SCRAM project. A project consists of a set of documents (see the accompanying text box entitled "SCRAM Documents"), which describe the structure and distribution of the project, external product requirements, and the BuildSystem configuration. </p><h3>BootStrap Documents</h3><p>The BootStrap document is used to describe a project's contents, structure, and the servers from which source code and other components can be downloaded. </p><p>Using this BootStrap document as a guide, SCRAM can easily recreate a copy of the project on any site. Typically, there may be several BootStrap files for any release, depending on the target user group. One aimed at developers may contain instructions for all the source code to be downloaded from the repository, others may be aimed more at the end user and only export binaries and libraries.</p><p>Web-based click-to-install functionality is made available by attaching a mime-type when distributing the BootStrap document so that your browser can automatically route it through SCRAM. Currently, this is limited in that SCRAM cannot automatically install other products on which a project may depend. It can, however, give you information and URL pointers to point you in the right direction and tell you exactly what you need.</p><h3>Project Areas</h3><p>All the components that make up a software project such as source code, libraries, binaries, environment, and the like, are assembled together in a directory structure called a "Project Area." There are two types of Project Area &#151; the central release area (CRA) and the developer area (DA); see <A NAME="rf2"><A HREF="0104jf2.htm">Figure 2</A>.</p><p>Typically, a single central release area, containing all the code, binaries, and so on, corresponding to a fixed release of the project is installed at each development site. It is a central release area that is created by SCRAM when it reads the BootStrap document. Once installed, the central release area remains untouched and serves as a reference point and source for all developers and users at the site. </p><p>Once the CRA is installed, developers are free to create a developer area based on a particular CRA in their own workspace. Each developer area provides an independent sandbox in which he can make incremental changes to every aspect of the base release, without affecting anybody else.</p><p>It is important to realize that the project area is the defining context for the SCRAM tool. This lets developers easily shift between different projects or different versions of the same project by simply moving to a different area. As each Project Area has its own environment, there's no need for messy and error prone editing of .cshrc or .profile to  accommodate different or even conflicting project requirements. </p><h3>Run-Time Environments</h3><p>A slight exception to the general rule is the run-time environment &#151; the environmental variable settings required when you wish to run a binary generated by the project. These do not become a part of your environment by simply entering the Project Area, you have to ask for it explicitly. This allows you full control over your environment, depending on your task inside the directory. An administrator, for example, who just wants to delete files or perform other administrative tasks may well not take kindly to having their entire environment redefined.</p><p>A history mechanism exists to record the changes made by SCRAM to your environment. Should you switch to a different project area, the environment is easily purged of the effects from the previous area.</p><p>Run-time environments for specific applications or use cases can be described in special Runtime Documents. SCRAM can read these and convert to bash and csh forms as required. The document format should  encourage proper documentation of these variables and their settings.</p><h3>Specifying Requirements</h3><p>The Requirements Document, which is downloaded by the BootStrap document, is used to define the tools that go into your project toolbox. It can also contain information concerning distribution and access of the tools, such as special licensing arrangements and so on.</p><p><A NAME="rf3"><A HREF="0104jf3.htm">Figure 3</A> illustrates how you would fill your toolbox. Requirements are specified by the name and version of the product, each of which needs to be associated with a tool description document &#151; a ToolDoc. </p><p>The ToolDoc, which is also automatically downloaded and parsed by SCRAM, contains information about the tool, such as:</p><ul>  <li>Product structure (where to find libraries, include files).  <li>Standard installation locations.  <li>Library names and link ordering.  <li>Dependencies.  <li>Platform specifics (special compiler flags).  <li>Documentation links.</ul><p>This information is used by SCRAM to integrate the tool into the project environment as well as to provide information for the human user. </p><p>During the setup phase, SCRAM probes your system, looking for the specified tool. If it can't find it, it will ask you where it is. This information will be stored in the project area, so that it can be easily looked up whenever the tool is to be used. SCRAM is smart enough to check other central release areas it knows about for tool-specific information, so once you have told SCRAM about a tool, you rarely have to tell it again.</p><p>ToolDocs can be maintained independent of any given project, ideally by experts on the tool. By using well prewritten ToolDocs, you can easily integrate new tools into your build environment. You do not have to worry about platform specifics, dependencies, include paths, link lines, and so on.</p><h3>Sharing Requirement Configurations </h3><p>It is a requirement in many of our projects that they use the same components, such as databases and other tools. What these should be has to be agreed upon and enforced across all the projects concerned. </p><p>To simplify the management of this constraint, a separate Requirements Document is maintained independently that specifies the agreed configuration. Each project includes this configuration in their own Requirements Document using the SCRAM document preprocessing functionality activated with a simple <i>&lt;INCLUDE url=...&gt;</i> tag. Functions exist to refine this selection to that appropriate for the project; that is, remove unused components.</p><h3>Displaying Requirements on the Web</h3><p>As the Requirements are specified in an XML-like document format, it is relatively easy to write a CGI script that converts this to HTML. Example CGI scripts are provided in the SCRAM distribution; these check out the appropriate version of the Requirements Document from a CVS server, perform the HTML conversion, and display the requirements for any given release of a project. <A NAME="rf4"><A HREF="0104jf4.htm">Figure 4</A> is an example of such a page. </p><p>There is no maintenance overhead to have such a page and the chances of a transcription error are greatly reduced. Such a page is useful as it lets people see what they need to have on their system before they try to install a project. </p><h3>The BuildSystem</h3><p>The SCRAM BuildSystem was developed primarily to support large C/C++ and Fortran projects. Its underlying philosophy is to separate the logical aspects of the build from the implementation details. As an example, you would simply ask for a library to be built from a set of sources; you do not need to worry about how to actually build a library on the various platforms.</p><p>I only intend to give an outline of the concepts and functionality currently provided by the BuildSystem. For more details and examples, see http://cmsdoc.cern.ch/cgi-cmc/scrampage/. </p><ul>  <li>BuildFiles are SCRAM documents. You can think of them as extended makefiles where each tag produces a make macro. Where the BuildSystem fails to provide the functionality you want, you can add your own with standard GNU make.  <li>CRA aware (Incremental Builds). When working in a developer area, the BuildSystem will only build components that have changed in relation to the CRA. All libraries, binaries, includes, and the like, will be taken from the CRA if a copy does not exist in the local developer area. In this way, you only have to check out and build those things you wish to actually change.  <li>Toolbox. The SCRAM BuildSystem has direct access to the project Toolbox and therefore knows about all the tools you have asked for. If you need a tool, you just ask for it by name and SCRAM will do the rest.  <li>SubSystem Interfaces. Large projects are generally split into subsystems that present a certain high-level functionality to other subsystems in the project. SCRAM lets you define an interface for your subsystem. In this way, anyone else can use your subsystem by asking for it by name in a similar way to asking for a tool from the toolbox. With an interface, no detailed knowledge of the subsystem, such as its component libraries and link ordering, is required by the subsystem users.  <li>Map functionality to directory structure. <A NAME="rf5"><A HREF="0104jf5.htm">Figure 5</A> illustrates how BuildFiles can be mapped to the source directory structure. Here, all the directories immediately below "src" are mapped onto the same SubSystem BuildFile. At the level below, nearly all are mapped to the same Package BuildFile except one, which will have the functionality defined by the Package B BuildFile. The names "subsystem" and "package" are completely arbitrary and are only used for illustration. At the third level, pattern matching on the directory name is used to separate the src functionality from the test functionality.  <li>Build Classes. The concept of a Build Class is best illustrated with the library class example in <A NAME="rf6"><A HREF="0104jf6.htm">Figure 6</A>. To build a library you request the library class in your BuildFile. SCRAM then generates many targets for building all sorts of libraries, such as archives, shared objects, debug versions, and profiled versions. You would also define the default library(s) to build, if not specified explicitly on the command line.  <li>Repository-friendly BuildSystem. When anything is built, the date stamps of all the source files are recorded. SCRAM will only rebuild if the current date stamps differ from those recorded, <i>(a!=b).</i> This is very different to "make," which will only rebuild if the date of the source code is newer than that of the final product <i>(a&gt;b).</i> Source-code repositories will set the date stamp of any checked-out files to the time at which it was checked into the repository. The distinction is therefore very important.</ul><h3>Future Directions</h3><p>SCRAM, naturally enough, meets the needs of the projects in which it was born. There are many minor improvements to be made to facilitate use, but the main task is to revamp the BuildSystem, so that it becomes a much more flexible and powerful tool. </p><p>The plug-and-play interface between the BuildSystem and a ToolDoc for complex generation tools such as compilers has not yet developed to a very sophisticated level. All the hard-coded rules for the build classes such as libraries, binaries, and so on, should be replaced and moved into a ToolDoc description to improve modularity and flexibility.</p><p>Take, for example, your C++ compiler. You would ask for it as you would any other tool in SCRAM, through the toolbox mechanism. The C++ ToolDoc would, among other things, describe that it can make shared objects, and this is a type suitable for inclusion in the library build class. </p><p>By plugging in tools in this way, the functionality of a build class, and even the types of classes available can grow to whatever is required. All this happens without touching your BuildFiles as the logic of the build still remains the same. You still need libraries; it's just now possible to produce many different types, such as instrumented or debuggable versions.</p><p>Switching between compilers and adding new languages would become a trivial matter of loading the appropriate ToolDoc into your toolbox.</p><p>SCRAM versions have a major version of 0; for instance, V0_18_0. The major SCRAM Version, V1_0_0, is reserved for the SCRAM release that has the functions described earlier.</p><p>Other improvements to the BuildSystem will be autologging and active error reporting of builds. Automated statistics gathering, noting such things as average compilation times, number of errors in regression testing, and so forth should also be implemented for use in the software process improvement phase.</p><p><b>DDJ</b></p></body></html>