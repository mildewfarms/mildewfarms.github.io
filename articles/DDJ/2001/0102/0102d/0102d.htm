<html><head><title>Feb01: J.A.D.E.: The Java Addition to the Default Environment</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>J.A.D.E.: The Java Addition to the Default Environment</h1><p><i>Dr. Dobb's Journal</i> February 2001</p><h2>An open-source library for Java developers</h2><h3>By Jean-Marie Dautelle</h3><I>Jean-Marie is a senior software engineer at Raytheon. He can be contacted at jean-marie@dautelle.com.</I><hr><p>The Java Addition to the Default Environment (J.A.D.E. for short) is an open-source library (available at http://jade.dautelle.com/) that fills gaps in the JDK core library. Among the extensions J.A.D.E. 1.0 includes are XML support for all Java classes, generic matrix classes, automatic error calculation on all operations (including numeric errors), more than 400 measurement units for almost 40 different quantities, automatic unit simplification and verification, and support for enumerated types.</p><p>The reasons I developed the J.A.D.E. package include:</p><DDJADVERTISEMENT INLINE><ul>  <li>	To eliminate more interface errors. If a method expects a Length, it gets a Length &#151; not some float type that is supposed to be in inches. (This is the kind of problem that led to the 1999 Mars Climate Orbiter fiasco.)  <li>	Quantities for which precision is unknown are not very useful (especially if they are the solutions of a possibly singular system of linear equations).  <li>	To eliminate conversion errors. The U.K. gallon is different from the U.S. gallon, which is also different for liquid or dry products.  <li>	To introduce a Matrix class generic enough to resolve systems of linear equations involving any element: Real, Complex, Big Numbers, Quantities, and the like.</ul><p>In this article, I'll focus on one of J.A.D.E.'s most useful components &#151; XML support. </p><h3>XML and Java</h3><p>In <i>Java and XML</i> (O'Reilly &amp; Associates, 2000), Brett McLaughlin wrote: "Java revolutionized the programming world by providing a platform-independent programming language. XML takes the revolution a step further with a platform-independent language for interchanging data." The question programmers are faced with is how to put the two together. </p><p>There are already many open-source libraries available to parse XML documents. For example, using JDOM (http://www.jdom.org/) you can represent XML documents as Java objects. Plus, Sun is currently leading a project that is code-named "Adelard" to generate Java classes from XML Schema. </p><p>Unfortunately, the starting point for all of these tools is the XML document. More often than not, it is the other way around &#151; you have Java classes and you want to provide persistency to your existing classes using XML. Here's how J.A.D.E. addresses this particular issue.</p><h3>Creating Objects from XML</h3><p>Say you wrote a package to represent two-dimensional areas. Your package possibly includes classes such as <i>Point</i>, <i>Ellipse</i>, <i>Polygon</i>, and <i>Area</i>. As an enhancement, you decide to add the capability to load an area from an XML file. </p><p>Using J.A.D.E., all you need to do is to provide an XML constructor for all XML elements involved in the construction process (in this case the geometrical objects). An XML constructor is nothing more than a Java constructor with two parameters--one for the attributes and the other for the child elements. When the XML document is parsed, your constructor is called with the parameters set according to the element's attributes and content. The attributes are simple properties of the object being created (represented by a <i>String</i>), whereas the content is the list of all nested elements that have been created recursively.</p><p>Once you have written the XML constructors (see <A NAME="rl1"><A HREF="#l1">Listing One</A>), this code lets you create an area from a file.</p><blockquote><p>Constructor constructor = new Constructor("org.apache.xerces.parsers.SAXParser");<br>Area area = (Area) constructor.create(file);</p></blockquote><p>As you can see, you need a SAX 2.0 parser at run time. The binary distribution of J.A.D.E. includes a subset of the Xerces 1.2.0 parser developed by the Apache Software Foundation, but any SAX 2.0 parser will do (for a list of SAX 2.0 parsers go to http://www.megginson.com/SAX/). SAX 1.0 parsers will not work because J.A.D.E. supports namespaces and SAX 1.0 does not. Namespaces map directly to Java packages. <A NAME="rl2"><A HREF="#l2">Listing Two</A> shows the XML representation of an area without a namespace and <A NAME="rl3"><A HREF="#l3">Listing Three</A> shows the same area represented using a default namespace; both can be used interchangeably. Also, you may notice that because the class <i>Area</i> may contain instances of itself, the XML representation of an area may include nested area elements.</p><h3>How Does it Work?</h3><p>Under the hood, the document handler uses the Reflection API to dynamically create instances of the elements being parsed. How this API works is beyond the scope of this article (for more information read the Reflection API Tutorial at http://web2.java.sun.com/docs/books/tutorial/reflect/index.html).</p><p>It is interesting to note that the constructive approach used by J.A.D.E. works even on immutable objects. Another approach using interface (factory method pattern) has been studied but rejected because of its lack of support for these immutable objects. </p><h3>Saving Objects in XML</h3><p>In addition to converting XML documents to Java objects, you can also do the reverse. Using J.A.D.E., the instances of a class can be saved in XML format if the class implements the interface <i>com.dautelle .xml.Representable</i>. Basically, the class has to provide two methods: <i>getAttributes()</i> and <i>getContent()</i>.</p><p>It is up to you to decide what is going to be an XML attribute and what is going to be a child element. Don't forget, however, that if the XML representation of your class is consistent with its XML constructor, then you will be able to save and retrieve any of your Java objects. <A NAME="rl4"><A HREF="#l4">Listing Four</A> shows the implementation of <i>com.dautelle .xml.Representable</i> for geometrical objects.</p><p>Writing a representable object is a two-step process. First, you will need to create an <i>ObjectWriter</i>. This can be done via: </p><blockquote><p>ObjectWriter ow = new ObjectWriter();</p></blockquote><p>Or if you want to use namespaces, you may pass the mapping between the package names and the namespace prefix as argument:</p><blockquote><p>Properties namespaces = new Properties();<br>namespaces.setProperty("com.dautelle.geom2d", "geom2d");<br>ObjectWriter ow = new ObjectWriter(namespaces);</p></blockquote><p>The second step is to perform the actual writing. The XML encoding to be used depends on the output type:</p><ul>  <li>	UTF-8 encoding (1 byte per character) for java.io.OutputStream: <blockquote><p>FileOutputStream out = new FileOutputStream(file);<br>ow.write(area, out); // UTF-8 encoding.</p></blockquote>  <li>	UTF-16 (2 bytes per character) for java.io.Writer:<blockquote><p>StringWriter sw = new StringWriter();<br>ow.write(area, sw); // UTF-16 encoding.</p></blockquote></ul><h3>Conclusion</h3></blockquote><p>While Java has an excellent API, you cannot always count upon Sun to offer everything you need (or you may wait a very long time). The J.A.D.E. library aims to complement the core JDK. It is open source and will hopefully grow with the contribution of all of you who want to continue to make Java a better platform.</p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>package com.dautelle.geom2d;public class Point {  double x;  double y;  // XML constructor.  public Point(Attributes attributes, Elements content) {    x = attributes.getDouble("x");    y = attributes.getDouble("y");  }}public abstract class Surface {}public class Ellipse extends Surface {  Point center;  double width;  double height;   // XML constructor.  public Ellipse(Attributes attributes, Elements content) {    center = (Point) content.get(0);    width = attributes.getDouble("width");    height = attributes.getDouble("height");  }}public class Polygon extends Surface {  Point [] vertices;  // XML constructor.  public Polygon(Attributes attributes, Elements content) {    vertices = new Point[content.size()];    content.toArray(vertices);  }}public class Area extends Surface {  Surface [] surfaces;  // XML constructor.  public Area(Attributes attributes, Elements content) {    surfaces = new Surface[content.size()];    content.toArray(surfaces);  }}</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>&lt;?xml version='1.0'?&gt;&lt;com.dautelle.geom2d.Area&gt;  &lt;com.dautelle.geom2d.Ellipse width="1.0" height="20.0"&gt;    &lt;com.dautelle.geom2d.Point x= "0.0" y="0.0"/&gt;  &lt;/com.dautelle.geom2d.Ellipse&gt;  &lt;com.dautelle.geom2d.Polygon&gt;    &lt;com.dautelle.geom2d.Point x= "-1.0" y="-1.0"/&gt;    &lt;com.dautelle.geom2d.Point x= "0.0" y="1.0"/&gt;    &lt;com.dautelle.geom2d.Point x= "1.0" y="-1.0"/&gt;  &lt;/com.dautelle.geom2d.Polygon&gt;  &lt;com.dautelle.geom2d.Area&gt;    &lt;com.dautelle.geom2d.Ellipse width="1.0" height="20.0"&gt;       &lt;com.dautelle.geom2d.Point x= "0.0" y="0.0"/&gt;    &lt;/com.dautelle.geom2d.Ellipse&gt;  &lt;/com.dautelle.geom2d.Area&gt;&lt;/com.dautelle.geom2d.Area&gt;</pre><P><A HREF="#rl2">Back to Article</A></P><H4><A NAME="l3">Listing Three</H4><pre>&lt;?xml version='1.0'?&gt;&lt;Area xmlns="java:com.dautelle.geom2d"&gt;  &lt;Ellipse width="1.0" height="20.0"&gt;    &lt;Point x= "0.0" y="0.0"/&gt;  &lt;/Ellipse&gt;  &lt;Polygon&gt;    &lt;Point x= "-1.0" y="-1.0"/&gt;    &lt;Point x= "0.0" y="1.0"/&gt;    &lt;Point x= "1.0" y="-1.0"/&gt;  &lt;/Polygon&gt;  &lt;Area&gt;    &lt;Ellipse width="1.0" height="20.0"&gt;       &lt;Point x= "0.0" y="0.0"/&gt;    &lt;/Ellipse&gt;  &lt;/Area&gt;&lt;/Area&gt;</pre><P><A HREF="#rl3">Back to Article</A></P><H4><A NAME="l4">Listing Four</H4><pre>package com.dautelle.geom2d;import com.dautelle.xml.*;public class Point extends Representable {  double x;  double y;  public Attributes getAttributes() {    Attributes attributes = new Attributes();    attributes.add("x", x);    attributes.add("y", y);    return attributes;  }  public Representable[] getContent() {    return null;  }}public abstract class Surface extends Representable {}public class Ellipse extends Surface {  Point center;  double width;  double height;   public Attributes getAttributes() {    Attributes attributes = new Attributes();    attributes.add("width", width);    attributes.add("height", height);    return attributes;  }  public Representable[] getContent() {    return new Representable[] { center };  }}public class Polygon extends Surface {  Point [] vertices;  public Attributes getAttributes() {    return null;  }  public Representable[] getContent() {    return vertices;  }}public class Area extends Surface {  Surface [] surfaces;  public Attributes getAttributes() {    return null;  }  public Representable[] getContent() {    return surfaces;  }}</pre><P><A HREF="#rl4">Back to Article</A></P></body></html>