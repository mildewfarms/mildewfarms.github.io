<html><head><title>Feb01: A Java 2 Network Class Loader</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>A Java 2 Network Class Loader</h1><p><i>Dr. Dobb's Journal</i> February 2001</p><h2>Dynamically  loading classes</h2><h3>By Lorenzo Bettini and Donato Cappetta</h3><I>Lorenzo is a Ph.D. student in computer science at University of Florence, Italy. He can be contacted at bettini@dsi.unifi.it. Donato is a software engineer at Intrage S.p.A., an Italian web company. He can be contacted at cappetta@infomedia.it.</I><hr><p>Java is useful for writing distributed applications, thanks to its independence from the underlying operating system and computer architecture, not to mention all the classes that the Java library provides &#151; especially those in the java.net package. Moreover, Java provides a means to synchronize multiple threads, which is useful in distributed applications.</p><p>But when it comes to distributed applications, one useful feature is that Java loads classes dynamically (that is, at run time, when they are needed), so it is possible for a program to load classes that hadn't even been created when the program was first written. Typically, Java automatically loads classes dynamically, but the language also lets you write customized class loaders if you want to load classes from another source (instead of the ordinary paths in the CLASSPATH).</p><DDJADVERTISEMENT INLINE><p>In this article, we present <i>NetworkClassLoader</i>, which lets you load classes from a (possibly remote) server. This server can be seen as an application server that provides its applications to every client that requires them. We'll implement in Java a mechanism similar to those of the Java-enabled browsers. In this scenario, a client can require the main class for an application residing on a server. Then, whenever a new class or a resource is needed by the application, it is automatically requested to the remote server, provided it is not present in the local file system of the client. Thus, when a new version of an application has to be installed, it will only have to be installed or updated in the server filesystem.</p><h3>How to Write Your Own Class Loader</h3><p>In his article "Java Custom Class Loaders" (<i>DDJ</i>, June 2000), Brian Roelofs presented specific steps for creating customized class loaders. Consequently, we will simply provide an overview of the main parts of this process: Whenever a class A is needed during the execution of your program (if it's not already loaded), the class loader that first loaded the class that needs class A, say class B, is required to load class A. If your class loader has loaded class B, then it is up to your class loader to load class A and to return a <i>Class</i> object for that class. Actually, the classes that can be found in the local filesystem should be loaded by the ordinary Java class loader, also called the "primordial class loader." It could be dangerous to load a class in a java.lang package from another source because those classes gain many access privileges. Moreover, loading two classes belonging to the same package from different sources could cause some run-time errors (the main trick to show that "Java is not type safe" was to load classes compiled in different moments that would cause a type error if loaded together). Additionally, loading the same class twice would produce a run-time error. So before loading a class that is not found in the local filesystem, the class loader's class cache should be checked to test if that class is already there; that is, if it has already been loaded. In Java 1.1, it was your job to take care of all these problems. Indeed, you had to inherit from <i>java.lang .ClassLoader</i> and implement the abstract method <i>loadClass</i>, which is called when a class is to be loaded. This method has to perform the following steps:</p><p>1.	Check if the class has already been loaded by inspecting the class cache of the class loader.</p><p>2.	Check to see whether the class can be loaded by the system class loader. </p><p>3.	In case the previous tests have failed, try to load the class from a known source.</p><p>4.	Define the class; that is, create a <i>Class</i> object from the byte code (obtained at the previous step).</p><p>5.	Check whether the class has to be resolved (linked), and in that case, resolve it.</p><p>6.	Return the <i>Class</i> object to the caller.</p><p>As you can see, step 3 is the one that you want to customize, while the other ones are standard (and, therefore, should be executed exactly that way to provide a correct and safe implementation).</p><p>In Java 2, you are fortunately free of many of these burdens. The main part of the customization is not the loading of a class, but fetching the raw data to create a <i>Class</i> object from somewhere (a particular location in the filesystem, for example, the Internet). In fact, the only method that has to be redefined is <i>findClass(String className)</i>, which is called if a class is found in neither the loader cache nor in the local filesystem (that is, by the primordial class loader). This method is an implementation of the pattern Template Method: The base class implements the main algorithm, allowing you to customize certain steps without having to worry about the algorithm itself. Thus, <A NAME="re1"><A HREF="0102ee1.htm">Example 1</A> is a typical implementation of this method.</p><p>With this new model, you can also chain together many class loaders: The constructor of <i>ClassLoader</i> can also be passed another <i>ClassLoader</i> that will become its parent class loader. Requests to load classes are delegated to the parent. If the parent fails to load them, it will delegate them to the child by calling <i>findClass</i>. This could also be seen as an implementation of the Decorator pattern. <i>findClass</i> should always throw an exception if it cannot find the class so that another class loader can have a chance to find it.</p><h3>The Architecture of the System</h3><p><i>NetworkClassLoader</i> is the client part of our client-server system, while the classes are stored in and provided by the class server (<i>ClassServer</i>).</p><ul>  <li>	The server is basically a multithreaded server that continuously listens on a certain port for incoming connections. Upon receiving a connection request, it spawns a concurrent thread, which will take care of that connection. It provides classes to the clients upon request.  <li>	The client instantiates a network class loader, specifying the Internet address (host and port) of the class server. Whenever a class that cannot be loaded by the system class loader is needed, it will request it to the server.</ul><p>The classes of our system are contained in the package <i>loader.</i></p><h3>The Client</h3><p>The client program has to create a <i>NetworkClassLoader</i> (<A NAME="rl1"><A HREF="#l1">Listing One</A>). It typically loads the first class (which is not supposed to be in the local filesystem) through this loader's method <i>loadClass</i> and then it creates a new instance by using the method <i>newInstance</i> of the <i>Class</i> object returned by the loader:</p><blockquote><p>ClassLoader loader = new NetworkClassLoader(hostName, port);<br>Class c = loader.loadClass(className);<br>Object main = c.newInstance();</p></blockquote><p>The Internet address of the remote <i>ClassServer</i> is passed to the constructor of <i>NetworkClassLoader</i>. <i>className</i> is a <i>String</i> that specifies the name of the class to be loaded. The object created by <i>newInstance</i> is not assigned to a reference of class <i>className</i>. This cannot be done because it is assumed that the class we are trying to load from the Internet is not present in our class path. In any case, it is still impossible to assign such an object to a reference of the same type. You could force the loader to load the class from the Internet, even if it's present in the local class path. But in this case, the class of the reference would be loaded by the system class loader (that is, from the local filesystem), while the object would be instantiated by a <i>Class</i> loaded by <i>NetworkClassLoader</i>. The problem is that two classes loaded by different class loaders are incompatible (due to security reasons, these classes will belong to different namespaces).</p><p>If using an <i>Object</i> is too restrictive (because even after the instantiation, it is necessary to set some attributes of the object), you could use a common superclass (or an interface). For instance, if there is an interface, <i>AppFoo,</i> that is present in the local filesystem, and the class that we are going to load from the Internet, say <i>RealApp</i>, is known to implement this interface, it would then be possible to execute this code:</p><blockquote><p>Class c = loader.loadClass("RealApp");<br>AppFoo app = (AppFoo) c.newInstance();<br>app.setTitle("My Application");<br>app.openFile("foo.txt");<br>...<br>app.run();</p></blockquote><p>In fact, <i>AppFoo</i> (class or interface) would be loaded by the system class loader, so it would be common both to the reference and to the object created through the <i>Class</i> object returned by <i>NetworkClassLoader</i>.</p><p>We'll now examine the method <i>findClass</i>. In our implementation, the byte array with the contents of a .class file is downloaded from the network, and so the method <i>findClass</i> (see <A NAME="rl1"><A HREF="#l1">Listing One</A>) looks something like this:</p><blockquote><p>if (!connected)<br>&nbsp;&nbsp;connect();<br>&nbsp;&nbsp;classBytes = loadClassFromServer(className);<br>&nbsp;&nbsp;classClass = defineClass(className, classBytes, 0, classBytes.length);<br>&nbsp;&nbsp;return classClass;</p></blockquote><p>The first time, a connection is established (method <i>connect</i>) with the <i>ClassServer</i>. To request a class's byte code to the server, we send a <i>ResourceRequest</i>, through serialization, with the name of the class. The bytecode (byte array) will be returned in a <i>ResourcePacket</i>. If an error occurs in the server, it is communicated in the response packet. Then the byte array is transformed in a <i>Class</i> object by calling the method <i>defineClass,</i> implemented in the superclass.</p><h3>The Server</h3><p><i>ClassServer</i> is essentially a multithreaded server that listens for incoming connections on a predefined port. Every time a connection request is received, a new thread (<i>WorkerClassServer</i>) is spawned, and the server keeps on listening for connections. Thus, many clients can be served concurrently. In fact, every client will be served by a distinct <i>WorkerClassServer</i>. <i>WorkerClassServer</i> (available electronically; see "Resource Center," page 5) reads a <i>ResourceRequest</i> from the socket connected to the client, loads the contents of the .class file (method <i>getClassBytes</i>) for the requested class, and then it sends back a <i>ResourcePacket</i> with the byte array (the contents of the file). The name of the class is specified in the standard Java format (package names are separated by dots), but it is transformed in a local filesystem path by using the underlying operating-system file path separator (obtained through the property file.separator).</p><p>A cache of .class file contents is shared by all <i>WorkerClassServer</i>, so if a class is requested by two clients, it is loaded from the filesystem only once.</p><p>The file is searched in the local class path by calling the static method <i>ClassLoader.getSystemResourceAsStream(className)</i>, which returns an <i>InputStream</i> associated with the file searched in the paths specified in the class path.</p><h3>Resources</h3><p>Loading classes is not the only responsibility of a class loader &#151; it also locates resources requested by classes. These resources are typically image files, audio files, or everything a class requests through the method <i>Class.getResource(String name),</i> which returns a URL object<i>.</i> For instance, you can load a GIF image for an icon like this:</p><blockquote><p>ImageIcon image = new ImageIcon(get		Class().getResource("openFile.gif"));</p></blockquote><p>Or you can play a .au file like this</p><blockquote><p>AudioClip audioClip = Applet.newAudioClip(getClass().getResource("spacemusic.au"));<br>audioClip.play();</p></blockquote><p>The resource name is automatically changed by prepending the package name and converting every "." into "/". Quoting from the Sun Java documentation: "The rules for searching resources associated with a given class are implemented by the defining class loader of the class." After the modification to the name of the resource, <i>Class.getResource</i> invokes the homonymous method of its own class loader. Instead of redefining this method, the delegation model is once again used. If the resource is not found by the parent class loader, the method <i>findResource(String name)</i> is invoked. This is the method that the customized class loader has to redefine in order to find the resource and return a URL for it.</p><p>In our implementation, the resource is requested to the class server (again by means of a <i>ResourceRequest</i>), and if obtained, it is saved on the local file system as a temporary file. Then the URL of the newly stored resource is returned so that the parent class loader is able to return the resource to the class. Even in this case a table of resources is kept so that an already stored resource is not requested again to the server. As we use the method<i> File.createTempFile</i>, those temporary files will be stored in the system's temporary file directory and automatically removed when the JVM terminates.</p><h3>Requesting and Getting a File </h3><p>The loader will request a class or a (binary) resource to the server by means of <i>ResourceRequest</i>, and will receive the response (and possibly the byte array) by means of <i>ResourcePacket</i>. Upon requesting a file, the type of the file (only CLASS or BINARY in our implementation) has to be specified. This differentiation is necessary because the server translates class file paths by replacing "." with "/" and by appending ".class," while resource paths are left unchanged (the right path is already provided by <i>Class.getResource</i>). If there is a problem, the class server may specify the error in <i>ResourcePacket</i> (for instance, the requested class or resource is not available on the server, or the request is not valid).</p><h3>An Example</h3><p>To test <i>NetworkClassLoader</i>, we've provided a TestApp in the package <i>loaderapp. </i>This is a simple application (using the Swing library) that uses images and sounds. To test the application on a single machine, you need to locate the loaderapp package where the class server can find it, but the client cannot. For instance, the loader classes can be put in a directory in the CLASSPATH (say, "myclasses"), while the loaderapp classes are put into a temp directory (say,<i> "</i>temp"). By making sure that the current directory (.) is included in the CLASSPATH, you can launch the class server from the temp directory and the client from a different directory. Images and audio files have to be placed in the same place where the .class files of loaderapp are placed. Two classes are provided to launch the class server and <i>NetworkClassLoader</i>, respectively: <i>loader.RunServer</i> and <i>loader.RunLoader</i>. The server can also be passed the port number for incoming connections. <i>RunLoader</i> is simply an application that takes the address and port number of the server and the name of the class to be loaded as parameters. It creates a <i>NetworkClassLoader</i>, and once the class is loaded, an instance of that class is created. Obviously, the <i>NetworkClassLoader</i> could be instantiated directly in your own application. (Additionally, many <i>NetworkClass Loader</i>s, communicating with different servers, could be instantiated by the same application.)</p><p>For example, the server could be started like this: <i>java loader.RunServer 9999.</i> The loaderapp.TestApp could be loaded (and thus started) by this: <i>java loader.RunLoader localhost 9999 loaderapp.TestApp</i>. The loader prints all the classes that are loading on the screen (including system classes), and it specifies which ones are loaded from the server; the loader does the same with resources. The class server, on the other side, prints all class and resource requests. You will notice that both classes and resources are requested only once to the server. Moreover, the loader will print class names using indentation, thus showing that loading a class A may require loading many other classes before the loading of A is completed. <A NAME="rf1"><A HREF="0102ef1.htm">Figure 1</A> shows the application frame and two terminals: The upper one is executing the server, and the other is executing the loader. The printing of class and resource names is the only reason why we also redefine the method <i>loadClass</i>.</p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>package loader;import java.io.*;import java.net.*;import java.util.Hashtable;public class NetworkClassLoader  extends ClassLoader {    private String hostName = null;    private int serverPort;    private Socket socket = null;    private ObjectInputStream is = null;    private ObjectOutputStream os = null;    private boolean connected = false;    private int tab = -1; // just to print with indentation    private Hashtable resourceTable = new Hashtable(); // key name, value File    public NetworkClassLoader() {        this("localhost", 5050);    }    public NetworkClassLoader(String hostName, int serverPort) {        super();        this.hostName = hostName;        this.serverPort = serverPort;    }    protected Class findClass(String className)        throws   ConnectClassServerException, JavaPackageException,                 ClassNotFoundException, ClassFormatError {        byte[] classBytes = null;        Class classClass = null;        // try with the network server        try {            // connect to the ClassServer            if (!connected)                connect();            classBytes = loadClassFromServer(className);        } catch (IOException ioe){            disconnect();            throw new ConnectClassServerException(ioe.toString());        }        // convert the byte array into a Class and put it in the cache.        classClass = defineClass(className,classBytes,0,classBytes.length);        if (classClass == null)            throw new ClassFormatError(className);        Print(className + " loaded from the SERVER");        return classClass;    }        //end loadClass()    protected URL findResource(String name)    {      URL resourceURL;      try {          File localResourceFile = (File) resourceTable.get(name);          // we have to download it          if (localResourceFile == null) {              Print("findResource: " + name + " at the SERVER");              byte[] resourceBytes = loadResourceFromServer(name, "BINARY");              if (resourceBytes == null) {                  Print("Resource " + name + " not found on server!");                  return null;              }              localResourceFile=createLocalResourceFile(name,resourceBytes);              resourceTable.put(name, localResourceFile);              Print("stored locally: " + localResourceFile);          }          return getLocalResourceURL(localResourceFile);      } catch (Exception e) {          Print("Exception " + e);      }      return super.findResource (name);    }    protected URL getLocalResourceURL(File file) throws MalformedURLException    {        return file.toURL();    }    protected File createLocalResourceFile(String name, byte[] bytes)         throws MalformedURLException, FileNotFoundException, IOException    {        File resFile = File.createTempFile            ("__temp_res_", "_" + createLocalResourceName(name));        resFile.deleteOnExit();        FileOutputStream fostream = new FileOutputStream(resFile);        fostream.write(bytes, 0, bytes.length);        fostream.close();        return resFile;    }    protected String createLocalResourceName(String name)    {        return name.replace('/', '_');    }    public synchronized Class loadClass(String name, boolean resolve)        throws ClassNotFoundException    {        ++tab;        Print("Loading class " + name);        Class result =  super.loadClass(name, resolve);        --tab;        return result;    }    protected void Print(String s)    {        for (int i = 0; i &lt; tab; ++i )            System.out.print(" ");        System.out.println(s);    }    protected void connect() throws UnknownHostException, IOException {        System.out.println("Connecting to the ClassServer "                                           + hostName + ":" + serverPort);        socket = new Socket(hostName, serverPort);        connected = true;        os = new ObjectOutputStream(new                            BufferedOutputStream(socket.getOutputStream()));        os.flush();        is = new ObjectInputStream(new                            BufferedInputStream(socket.getInputStream()));        System.out.println("Connected");    }        //end connect()    protected void disconnect(){        try {            connected = false;            os.close(); os = null;            is.close(); is = null;            socket.close(); socket = null;        } catch (Exception e) {            e.printStackTrace();        }    }        //end disconnect()    protected byte[] loadClassFromServer(String className)        throws ClassNotFoundException, SocketException, IOException    {        byte[] classBytes = loadResourceFromServer(className, "CLASS");        if (classBytes == null)            throw new ClassNotFoundException(className);        return classBytes;    }   //end loadClassFromServer()    protected byte[] loadResourceFromServer(String resourceName, String type)        throws FileNotFoundException, ClassNotFoundException,               SocketException, IOException    {        byte[] fileBytes = null;        // load the file data from the connection        // send the name of the file        sendRequest(resourceName, type);                // read the packet        ResourcePacket resourcePacket = (ResourcePacket) is.readObject();                if (! resourcePacket.isOK())            throw new FileNotFoundException(resourcePacket.getError());        fileBytes = resourcePacket.getResourceBytes();        return fileBytes;    }   //end loadResourceFromServer()    protected void sendRequest(String name, String type)    throws IOException    {        os.reset();        os.writeObject(new ResourceRequest(name, type));        os.flush();    }}  //end class NetworkClassLoader</pre><P><A HREF="#rl1">Back to Article</A></P></body></html>