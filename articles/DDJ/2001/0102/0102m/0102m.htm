<html><head><title>Feb01: Programmer's Toolchest</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>SAX2: A Simple  API for XML</h1><p><i>Dr. Dobb's Journal</i> February 2001</p><h2>XML without overhead in Visual Basic</h2><h3>By Eldar A. Musayev</h3><I>Eldar works in Microsoft's MSXML group. He can be contacted at eldarm@microsoft.com.</I><hr><p>Just as Perl became the duct tape for the Web, XML is becoming the duct tape for e-business. As a universal data format, XML glues together disparate e-business systems that, in the process of conducting everyday business, need to perform hundreds of transactions per second without outages or crashes. Such systems need XML processors that provide high performance with a small footprint. That's what SAX offers. </p><p>In this article, I'll describe SAX, then show how you can use it in Visual Basic applications via the Microsoft XML (MSXML) parser.</p><DDJADVERTISEMENT INLINE><h3>SAX: What Is it?</h3><p>SAX stands for the "Simple API for XML." Developed in collaboration by the members of the XML community (see http://www.megginson.com/), SAX is a simple, efficient, and high-performance alternative to the Document Object Model (DOM), a widely supported XML API developed by the WWW Consortium. Unlike DOM, SAX considers XML not as text or an object, but as a stream of events, such as:</p><p></p><ul>  <li>Characters; events that happen when the parser reads the content of an element.  <li>Start/end elements; an event that happens when the parser reads element tags.  <li>Processing instructions; an event that happens when the parser reads processing instructions.</ul><p>Since an application receives these events as the parser reads the document, there is never a moment when the whole document is in memory. As a result, SAX delivers better performance and a smaller footprint for large files.</p><h3>How Does it Work?</h3><p>To use SAX, you create event handlers, plug them into the parser, and call the parser. After that, the parser calls the necessary event handlers while parsing XML documents. <A NAME="rf1"><A HREF="0102mf1.htm">Figure 1</A> illustrates how this relationship works.</p><p>The SAX2 API currently has five event handler interfaces, each responsible for a separate group of events:</p><ul>  <li><i>ContentHandler</i>, which reports events related to the content of an XML document.  <li><i>DTDHandler</i>, which reports some events related to a document type definition (DTD).  <li><i>ErrorHandler</i>, which reports encountered errors.  <li><i>LexicalHandler</i>, which reports more fine-grained lexical events, like comments, that the content handler ignores.  <li><i>DeclHandler</i>, which reports declarations within a DTD.</ul><p>To use these interfaces, you just implement the ones you need within your code and register them with the parser.</p><p>Another interesting SAX feature is <i>XMLFilter</i>, which is both a reader and a group of event handlers. <i>XMLFilter</i> receives events from the reader, does some work based upon those events, and then passes selected events to the next handler. Hence, each event calls a number of event handlers chained one after another. This lets you break XML processing in logical components, such as check inventory, compute tax, or charge credit card, as in <A NAME="rf2"><A HREF="0102mf2.htm">Figure 2</A>.</p><h3>Down to the Code</h3><p>In the following discussion, I'll implement a simple application that performs a keyword search based upon the component approach that SAX and <i>XMLFilter</i> provide. The complete Visual Basic source code for this application is available electronically; see "Resource Center," page 5. There you will find three different implementations of this task, showing three different ways to handle and connect SAX components.</p><p>To keep the code manageable, the application's task is to search an XML document (see <A NAME="rl1"><A HREF="#l1">Listing One</A>) for those <i>&lt;book&gt;</i> elements whose title attribute contains the specified keyword, and then output a list of those books. Notice that in the XML document, most of a book's details are attributes of the <i>&lt;book&gt;</i> element. The one exception is the book's description, which forms the <i>&lt;book&gt;</i> element's content.</p><p>As far as coding goes, this application  has three clear phases: reading the XML document, filtering the document's contents by keyword, and outputting the results. Each of these phases correlates to a separate SAX component in the sample applications that are available electronically. (For these sample applications, you need the October 2000 MSXML Microsoft XML Parser 3.0 release, available at http://msdn.microsoft.com/xml.)</p><h3>Using Visual Basic</h3><p>The first thing you need to do is create the necessary SAX components: a reader, filter, and writer. For the reader, you can use the MSXML SAXXMLReader. You will need to implement the filter and writer components yourself, as described later.</p><blockquote><p>Dim reader As New SAXXMLReader</p><p>Dim filter As New KeywordOnly</p><p>Dim writer As New PrintOut</p></blockquote><p>Having created the components, you now need to set parameters and connect these components to each other:</p><blockquote><p>TextBox1.text = ""</p><p>filter.searchKey = TextKey.text</p><p>Set filter.IVBSAXXMLFilter_parent = reader</p><p>Set filter.IVBSAXXMLReader_contentHandler 			        = writer</p></blockquote><p>Alternatively, you could set the <i>parent</i> and <i>contentHandler</i> properties using type casting. In fact, type casting is a more proper way of setting these properties because it really sets the properties of the filter interface instead of setting them via a pseudoproperty of an implemented class. This code uses type casting to set the parent property:</p><blockquote><p>Dim chf As IVBSAXXMLFilter</p><p>Set chf = contentHandler</p><p>Set chf.parent = reader</p></blockquote><p>Electronically available source code (see "Resource Center," page 5) provides implementation for both direct setting of properties (the "complete filter" example) and use of type casting (the "complete filter type casting" example).</p><p>Type casting, though more correct, also requires more coding. Type casting requires three lines of code to set the property; while using a pseudoproperty takes only one.</p><p>Why do you need to set the <i>parent</i> property for the filter? Because of the filter's dual functionality: as a content handler for the reader, and reader for the writer. Setting the <i>parent</i> property not only sets the filter as the content handler for the reader, but also lets the filter represent itself as a proxy reader by redirecting its own calls, such as "<i>parse()</i>," to the real reader.</p><p>Once you have created all the objects, linked them together, and set the parameters, you can parse the document:</p><blockquote><p>  On Error GoTo Uh_Oh</p><p>  filter.IVBSAXXMLReader_parseURL 					TextFile.text</p><p>Exit Sub</p><p>Uh_Oh:</p><p>  TextBox1.text = TextBox1.text &amp; </p><p>    "*** Error in XML file with the list of 				   books *** "</p></blockquote><p>MSXML implements its SAX interfaces based upon COM/OLE, and COM/OLE interfaces start with "I." So, MSXML added prefixes to the original SAX interface names: "I" for the high-performance COM interfaces used by C++, and "IVB" for the automatable interfaces used by Visual Basic and scripting.</p><p>Yet, MSXML uses no prefixes for its classes because those classes usually implement both interfaces (that is, there is no need for a separate "VB" prefix). A single coclass works for both C++ and Visual Basic.</p><p>However, there are two names for each of these coclasses. This naming has nothing to do with programming languages, but instead with versioning control. For example, both C++ and Visual Basic can use either the <i>SAXXMLReader</i> and <i>SAXXMLReader30</i> coclass. The difference is that <i>SAXXMLReader</i> coclass is version independent and <i>SAXXMLReader30</i> isn't. Version independence means that the <i>SAXXMLReader</i> coclass automatically uses the latest installed version of MSXML, while the version-dependent <i>SAXXMLReader30</i> coclass continues to use only MSXML 3.0.</p><h3>Implementing the <i>ContentHandler</h3><p>The </i>PrintOut class implements the content handler and prints everything out. To implement the content handler, open Visual Basic and create a class module named <i>PrintOut</i>. </p><p>Now, let Visual Basic know which interface you are going to implement: <i>Implements IVBSAXContentHandler</i>. Next, add dummy implementations for all the necessary methods. To do that, just select the interface from the <i>Object</i> list (shown in the red circle in <A NAME="rf3"><A HREF="0102mf3.htm">Figure 3</A>) and then select each of the methods, one-by-one, from the <i>Procedure </i>list (highlighted with a red arrow in <A NAME="rf3"><A HREF="0102mf3.htm">Figure 3</A>).</p><p>You can now implement the output. In <A NAME="rl2"><A HREF="#l2">Listing Two</A>, you direct the output to a text box on the form. This output happens only from the <i>startElement</i> and <i>characters</i> methods.</p><h3>Getting Attribute Values</h3><p>In the original SAX specification, the content handler returns Null if an attribute is not found. However, in Visual Basic, an empty string and Null are identical. Thus, MSXML's implementation of this interface raises a trappable error instead of returning Null.</p><p>To trap and process this error, the example code uses the <i>attrVal</i> helper method. This helper method (function) also provides some small conveniences like a default value and a prefix/suffix.</p><h3>Implementing the Filter</h3><p>The main function of the filter is to receive SAX events and pass the selected ones on. Sometimes, it may change the content of XML as well, but in this example it does not.</p><p>The filter should implement three interfaces (specifying a library is not necessary, but somewhat useful for readability):</p><blockquote><p>Implements MSXML2.IVBSAXContentHandler</p><p>Implements MSXML2.IVBSAXXMLFilter</p><p>Implements MSXML2.IVBSAXXMLReader</p></blockquote><p>The only property of the filter interface is <i>parent; </i>see <A NAME="rl3"><A HREF="#l3">Listing Three</A>. While it does not matter here whether you make the <i>setter</i> and <i>getter</i> <i>private</i> or <i>public</i>, making them <i>public</i> puts them in the interfaces pop-up list that appears when you implement interfaces in Visual Basic.</p><p>You use similar code (see <A NAME="rl4"><A HREF="#l4">Listing Four</A>) for the SAX reader property, <i>contentHandler</i>. You then set all other methods of the SAX reader interface to delegate the call to the parent (if there is a parent); see <A NAME="rl5"><A HREF="#l5">Listing Five</A>. Also, you need to set the content handler to track elements, and turn the pass-through flag on for elements with selected keyword and off after exiting the element; see <A NAME="rl6"><A HREF="#l6">Listing Six</A>. Finally, you need to set all other content handler methods to simply pass the event to the next content handler (provided that handler exists); see <A NAME="rl7"><A HREF="#l7">Listing Seven</A>.</p><h3>Shortcut Filter Creation</h3><p>There is a shortcut for implementing all filter/reader methods. This shortcut also helps to avoid type casting in the main program. For this shortcut, you implement only the content handler and add the <i>contentHandler</i> property directly to the <i>KeywordOnly</i> class (that is, <i>'Set reader.contentHandler = filter'</i>). The code for such implementation is also available electronically as a "simple filter" example (see "Resource Center," page 5). However, the convenience of this shortcut comes at a price:</p><p></p><ul>  <li>If you need other handlers (like a <i>LexicalHandler</i> or <i>ErrorHandler</i>), you will have to set them manually.  <li>You cannot pass your new filter as a parameter to a function that is expecting a reader to be passed to it.</ul><h3>Conclusion</h3><p>The same MSXML SAX parser may be used in C++, with even greater gains in performance, by using a separate set of interfaces (<i>ISAXContentHandler</i>, <i>ISAXDTDHandler</i>, and others). However, a complete description of this would require a separate article. </p><p>SAX is often a simple and efficient way to read XML. One of the most compelling reasons to use SAX is when you cannot afford the load to the system associated with using the DOM. For example, there is no way to use the DOM (at least not directly) if your documents are so huge (many megabytes in size) that they just don't fit into memory. Sometimes they may fit, but not enough for multithreaded processing of several copies at the same time, which is usual for web-based applications.</p><p>Another reason to choose SAX may not be necessity, but comparison. Suppose your Windows 2000 web server processes a high volume of average-sized XML messages. For MSXML, using SAX is normally several times faster than using the DOM. For relatively simple applications, the faster processing achieved by using SAX can translate into the ability to serve twice as many clients at the same time.</p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>&lt;?xml version="1.0"?&gt;&lt;booklist&gt;&lt;book  title="Building Microsoft Exchange Applications (Solution Developer Series)"  author="Peter J. Krebs"  ISBN="157231334X"  instock="no"&gt;This book will guide programmers and non-programmers to create a professional mail-enabled or groupware application in less than a day with Microsoft Exchange.&lt;/book&gt;  ...  &lt;/booklist&gt;</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>Private Sub IVBSAXContentHandler_startElement(...parameters skipped ...)            Form1.TextBox1.text = Form1.TextBox1.text _                 &amp; vbNewLine &amp; attrVal(attributes, "title") _                &amp; attrVal(attributes, "author", "", " by ", "") _                 &amp; vbNewLine &amp; " -- " _... other attributes ...                &amp; attrVal(attributes, "instock", " No inventory data.",_                                                       ", In stock: ", ".")End Sub Private Sub IVBSAXContentHandler_characters(strChars As String)        Form1.TextBox1.text = Form1.TextBox1.text &amp; textEnd Sub</pre><P><A HREF="#rl2">Back to Article</A></P><H4><A NAME="l3">Listing Three</H4><pre>Private parent As MSXML2.IVBSAXXMLReaderPublic Property Set IVBSAXXMLFilter_parent _                              ( ByVal RHS As MSXML2.IVBSAXXMLReader)     Set parent = RHS    Set RHS.contentHandler = MeEnd PropertyPublic Property Get IVBSAXXMLFilter_parent() As MSXML2.IVBSAXXMLReader     IVBSAXXMLFilter_parent = parentEnd Property</pre><P><A HREF="#rl3">Back to Article</A></P><H4><A NAME="l4">Listing Four</H4><pre>Public ch As IVBSAXContentHandlerPrivate Property Set _IVBSAXXMLReader_contentHandler(ByVal RHS As MSXML2.IVBSAXContentHandler)    Set ch = RHSEnd PropertyPublic Property Get IVBSAXXMLReader_contentHandler() _                                         As MSXML2.IVBSAXContentHandler        IVBSAXXMLReader_contentHandler = chEnd Property</pre><P><A HREF="#rl4">Back to Article</A></P><H4><A NAME="l5">Listing Five</H4><pre>Public Sub IVBSAXXMLReader_parseURL(ByVal strURL As String)    If Not IsEmpty(parent) Then: parent.parseURL strURLEnd Sub</pre><P><A HREF="#rl5">Back to Article</A></P><H4><A NAME="l6">Listing Six</H4><pre>Private PutItOut As BooleanPrivate Sub IVBSAXContentHandler_startElement(... attributes skipped...)     Dim i As Integer, s As String    If strQName = "book" Then        On Error GoTo noTitle        s = attributes.getValueFromQName("title")        If InStr(s, searchKey) &gt; 0 Then            PutItOut = True        End IfnoTitle:        On Error GoTo 0                If PutItOut Then            If Not IsEmpty(ch) Then              ch.startElement strNamespaceURI,strLocalName,strQName,attributes            End If        End If    End IfEnd SubPrivate Sub IVBSAXContentHandler_endElement(strNamespaceURI As String, _                                 strLocalName As String, strQName As String)    If PutItOut And Not IsEmpty(ch) Then        ch.endElement strNamespaceURI, strLocalName, strQName    End If    If strQName = "book" Then        PutItOut = False    End IfEnd Sub</pre><P><A HREF="#rl6">Back to Article</A></P><H4><A NAME="l7">Listing Seven</H4><pre>Private Sub IVBSAXContentHandler_characters(text As String)    If PutItOut And Not IsEmpty(ch) Then        ch.characters text    End IfEnd Sub</pre><P><A HREF="#rl7">Back to Article</A></P></body></html>