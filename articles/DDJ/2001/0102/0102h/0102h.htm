<html><head><title>Feb01: Exploring Perl Libraries</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Exploring Perl Libraries</h1><p><i>Dr. Dobb's Journal</i> February 2001</p><h2>Viewing library  module data</h2><h3>By Robert Kiesling</h3><I>Robert is the maintainer of the Linux Frequently Asked Questions with Answers FAQ on the Internet. He can be contacted at rkiesling@mainmatter.com.</I><hr><p>Much of the time it takes to learn an object-oriented, GUI-centric language (with its overhead of event-driven and graphical objects) is spent learning about the class libraries. Perl is an exception. It trades off some of the facilities of more general-purpose languages for speed and simplicity of internal data. Still, you can get a reasonable picture of an object's member classes, methods, and globals, despite the apparent lack of a mechanism for viewing the data.</p><p>The Perl API can include a hierarchy of object types and a well-defined API, but these can be traded off for the execution speed of lower-level data structures. This flexibility, almost paradoxically, gives you the ability to tinker with library and application code while it is executing.</p><DDJADVERTISEMENT INLINE><p>Even though the Perl libraries do not necessarily present an object-oriented API or code base, the language can still effectively implement or simulate a class-based environment. The Perl library modules I present here (available electronically; see "Resource Center," page 5), let you view library module data within the Perl interpreter itself (using the Tk::Browser module) and look up the source code and documentation for these modules; see <A NAME="rf1"><A HREF="0102hf1.htm">Figure 1</A>.</p><h3>Perl Library Structure</h3><p>In Perl, a module is simply a single file in Perl's library directories. A package is synonymous with a module, but its inheritance and directory hierarchies are qualified relative to the Perl interpreter's search path. A package is declared at the beginning of most source modules using the <i>package</i> keyword: <i>package Lib::Module;</i>. This declaration identifies the package file's path name, relative to the Perl interpreter's @INC search path. More significantly, however, it tells the interpreter to create and use an additional symbol table hash (a "stash") that bears the package's name.</p><p>Like all Perl hash tables, a stash contains a number of key/value pairs, which may refer to any of Perl's recognized data types as well as file handles and other stashes.</p><p>The stashes follow the naming convention for packages: the hierarchical name of the module with the elements separated by double colons (::). The interpreter maintains each module's stash separately, identified by the package name with double colons appended to it. The package, Lib::Module, for example, uses the stash <i>Lib::Module::</i>. Each stash can be accessed from the calling package by using the <i>typeglob</i> reference to the package handle. In addition, the default stash, or <i>main::</i>, contains references to all of the other stashes that are in effect.</p><p>In Perl terms, each hash reference is a <i>typeglob</i>, which refers to one of the standard data types. A reference to a client stash would simply be another hash; see <A NAME="rl1"><A HREF="#l1">Listing One</A>(a). The default stash effectively provides a class membership to a package even if the package doesn't explicitly declare one; contains data accessible to all library modules; and keeps track of which modules have been loaded at run time. The syntax of stash <i>typeglob</i>s is somewhat like that of a file-handle reference, but the stashes are still hash objects. Using the <i>exists</i> operator, you can test for the presence of a variable name in a given stash, as in <A NAME="rl1"><A HREF="#l1">Listing One</A>(b).</p><p>When actually looking up the elements of a symbol table, they are dereferenced through a <i>typeglob</i> that refers to the symbol table entry. An entry often consists of more than one data type: An array like that in <A NAME="rl1"><A HREF="#l1">Listing One</A>(c), for example, contains data of type SCALAR, which typically will be the array's name, as well as data of type ARRAY. It is necessary to escape the colons with backslashes so that the interpreter does not treat them as operators. Also, the entry is treated as a SCALAR when simply looking up the variable name, as a HASH when retrieving the entry's data reference, and as an ARRAY when retrieving the data itself.</p><p>Symbol table <i>typeglobs</i> can have up to eight key values for the standard data types SCALAR, ARRAY, and HASH; see <A NAME="rl1"><A HREF="#l1">Listing One</A>(d). A stash entry can also refer to the following: CODE, the interpreted bytecode of the program itself; IO, a file handle; PACKAGE, the name of the package that is using the data; the symbol's NAME; and FORMAT, a reference to the routine that formats the data. If not used, the values are undefined, with the exception of SCALAR, which is always present, even if it is simply an empty string.</p><p>Perl defines the type of data lexically; stronger type checking does not occur unless you're writing to the data. But this can also contribute to confusion when performing multiple dereferences, accessing variables with similar names, and resolving language syntax ambiguities.</p><h3>Static Library Declarations</h3><p>The standard Exporter.pm library module lets one module's routines refer to another module's data without relying on the run-time binding of data and subroutines to a particular module. Exporter.pm provides an interface for exporting variables and functions to another module; see <A NAME="rl2"><A HREF="#l2">Listing Two</A>(a). The receiving module, <A NAME="rl2"><A HREF="#l2">Listing Two</A>(b), can then specify which symbols it needs from the original module. Variables and subroutines named in the @EXPORT array appear in the receiving module's symbol table as if they were declared in that module. The symbol names in @EXPORT_OK get exported only if the calling module requests them.</p><p>When a Perl module processes a <i>use &lt;modulename&gt;</i> statement, it calls a subroutine named <i>import</i>, which is defined by default in Exporter.pm. The difference between the statements <i>require &lt;modulename&gt;</i> and <i>use &lt;modulename&gt;</i> is that the <i>require</i> statement imports all of the symbols of its argument into the calling module's symbol table namespace. All of the subroutine and variable names act as if they were defined in the calling module. This can lead to duplicate variable and subroutine names unless care is taken to export only those symbols that a module needs.</p><p>However, you can use a variable or function of another module by calling it statically, as in <A NAME="rl2"><A HREF="#l2">Listing Two</A>(c). This calling convention creates another symbol table hash for <i>ExtraModule::</i>, if one does not already exist. The Perl interpreter then looks for the <i>readfile()</i> subroutine in ExtraModule's namespace, not in the namespace of the calling module.  </p><p>The disadvantage of importing data statically is that the Perl interpreter can completely bypass the Exporter.pm routines, which do version and name checking. It is possible to import data from another similarly named module, subroutine, or variable without the interpreter being aware of it.</p><p>Static symbol declarations can interfere with the use of the <i>SUPER::</i> keyword in programs, which use method calls and superclass data. Any subroutine or variable imported in this manner must be fully qualified. The Perl interpreter makes no attempt to look up the name in any of the existing symbol table hashes except the one specified, or in <i>%main::</i> if no package name qualification is made. This is one way a package can override the interpreter's data-hiding mechanism.</p><p>In fact, in Perl terminology, a client module's symbol table is referred to as the "INNER namespace," relative to the calling module's, which is referred to conceptually as the "OUTER symbol table." Thus, a fully qualified data reference may have the name syntax of <i>*OUTER::INNER::symbolname</i>.</p><p>The conceptual view of Perl's module evaluation is that the client namespace of one package can be contained within the namespace of another, even though Perl's import mechanisms go to some pains to make each module believe it has its own stash. A call to a client package does not need to return, and the client package does not have a view of the calling package's stash, nor does the client package know how it was loaded.</p><p>The <i>use</i> statement checks for the module's availability when the program is first byte-compiled and the interpreter resolves external data references. Perl's AutoLoader and DynaLoader modules let references be resolved without actually loading the module. The success of a static symbol-name lookup depends on the called module's availability when the main program is executed. This can easily cause misleading results when examining the main program's stash, as the reference handles are lexically resolved.</p><p>Similarly, the scope of a variable declared with <i>my</i> extends only to the subroutine, loop, or conditional construct in which it is declared. The scope is lexical in nature, and the variable is not, under normal circumstances, visible in the stash of a client subroutine.</p><h3>The <i>require</i> Statement and Scoping</h3><p>Instead of importing data references, the <i>require</i> statement evaluates the called module immediately so that a complete, separate symbol table hash is created in the <i>main::</i> stash. This is the method by which modules such as Tk::Browser.pm and Devel::Symdump.pm can view unrelated modules' stashes. Instead of generating private variables, the entire namespace of the evaluated module is created as a separate environment, and compile-time pragmas may be determined independently of the calling module's run-time environment.</p><p>The use of <i>my</i> to declare variables relaxes a "use strict vars" pragma. Otherwise, variables must be declared or statically qualified. A <i>typeglob</i> declaration that refers to a symbol table hash must be declared as local, so that its scope extends to a subsequently created stash; see <A NAME="rl3"><A HREF="#l3">Listing Three</A>(a). The <i>eval "require package"</i> method of symbol-table creation is the same as that used by the standard base.pm module, which imports and evaluates modules when they are byte compiled, as with the <i>use base &lt;packagename&gt;;</i> statement.</p><p>To create a complete stash context, the interpreter must know which stash you're interested in. You state this with the <i>package</i> keyword, then you declare the package space with a <i>use &lt;package&gt;</i> keyword. In many programs, a <i>use</i> statement is sufficient, because Perl's AutoLoader module can load functions on demand. However, because you want to view the entire stash without waiting for a program to execute, you must load the entire package with the <i>require</i> keyword. </p><p>When used together, the three statements provide a method to simulate a switch to a different, possibly unrelated, package; see <A NAME="rl3"><A HREF="#l3">Listing Three</A>(b). When examining a symbol table space with a <i>Tk::Browser, </i>these statements must be called in the Tk::Bowser.pm module, so that the stash of the client module is visible to the <i>Tk::Browser </i>stash. Conversely, when examining a symbol table, all that is necessary to avoid confusing one stash context with another is to match the stash's handle:</p><blockquote><p>if( $key =~ /VERSION/) &amp;&amp; ($package =~ /New::Package/) {</p></blockquote><h3>Classes and Object References</h3><p>The basic mechanisms for creating objects in Perl are the <i>bless()</i> and <i>tie()</i> functions. Each creates an association between an object reference (almost always a hash variable) and a module package. Once an object is blessed, any references to the object or its hash keys is referred to the package. Objects are most commonly blessed when they are constructed. Perl constructors, like those in other other object-oriented languages, are commonly named "new," although a package is free to follow its own naming conventions. In <A NAME="rl4"><A HREF="#l4">Listing Four</A>(a), the constructor is called as a method. It returns the object, which is now registered with Perl, as a reference to a <i>Lib::Module</i> object. In effect, <i>bless</i> creates the new variable in the called package's symbol table, instead of the calling package's. The calling package receives a reference to the newly created object, but it refers only to the called package's newly created variable. </p><p>The main program does not need to explicitly name the object's class. The reference to the object knows which package it belongs to and the program will call the appropriate function as an object method; see <A NAME="rl4"><A HREF="#l4">Listing Four</A>(b). While the symbol table value of <i>*m{PACKAGE}</i> will be <i>Tk::Browser</i>, the value of <i>ref( $m)</i> will be the name of its member package &#151; in this example, <i>Lib::Module. </i>Of course, you still need to specify the package that contains the constructor routine, where the <i>bless</i> function registers package membership. In contrast, using an unblessed reference, you still could call a function statically, as in <A NAME="rl4"><A HREF="#l4">Listing Four</A>(c).</p><p>Another method of static module loading is via the <i>require</i> statement, which loads a package's symbols into the calling program's namespace. </p><p>The <i>tie()</i> function provides a set of function references (for example, READ, STORE, and PRINT) in the object's package. They provide a facility for user-defined functions of common assignment and retrieval functions. The exact functions a data type recognizes are described in the perltie(1) manual page (http://www.frognet.net/help/manpages/docs/perltie.html).</p><h3>Inheriting Multiply</h3><p>There are two main mechanisms for specifying a package's class membership: the well-documented <i>@ISA</i> array and the less well-known <i>use base</i> statement. The first specifies how the Perl interpreter should go about looking up symbols. The <i>use base</i> statement is invoked when the program is byte compiled, and reads another module's code into the symbol space before the main module's code is interpreted. (This is similar to the <i>require</i> statement.)</p><p>If you had a Tk module that exported symbols as well as derived some of its functions from the main widget class, you would need to specify both of its superclasses:</p><blockquote><p>package Tk::NewWidget;<br>@ISA=qw(Exporter Tk::Widget);</p></blockquote><p>This adds references to the <i>Exporter::</i> and <i>Tk::Widget::</i> stashes to the main stash. In effect, it provides a search path to look up symbol names from either module, even if the module does not implement an object class of its own. Perl does not require an object hierarchy to import modules, but may import symbol names statically.</p><p>In practice, Perl class hierarchies tend to be only one or two levels deep. The language resolves inconsistencies in external symbol name resolution by providing a UNIVERSAL abstract superclass that provides packages with default mechanisms for class membership and name resolution; namely, the <i>can</i> and <i>isa</i> functions. Either of these may be called as a class method or statically. The client module need not declare a class membership at all.</p><p>Unlike other object-oriented languages, Perl does not enforce an inheritance construct. Because even relatively low-level features of the language are available to a program script, each module can use the data suited to the application, provided that the programmer is aware of the potential issues and difficulties that this flexible approach can incur.</p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre><b>(a)</b>*main::MainWindow:: =&gt;   { InitBindings =&gt; *MainWindow::InitBindings     viewable =&gt; *MainWindow::viewable    ::_configure =&gt; *MainWindow::_configure     *etc*  }<b>(b)</b>if( exists  ${*IO\:\:File\:\:}{VERSION} ) {    my( $version_name, $module_version ) =            %{*IO\:\:File\:\:}{VERSION};}<b>(c)</b>my ($array_key, $array_val) = %{*Module\:\:array};my $array_name = ${*{$array_val}{SCALAR}};my $array_contents = @{*{$array_val}{ARRAY}};<b>(d)</b>foreach ( my ($key, $val) = %{*Module\:\:} ) {  local (*entry) = $val;  if( defined *entry{ARRAY}) {     foreach( @{*entry{ARRAY}} ) {print "$_, "; }  }   if( defined *entry{HASH}) {     foreach( my ($key_1, $val_1) = %{*entry{HASH}}) {       print "$key_1=&gt;$val_1, ";    }  }  if( defined *entry{SCALAR}) {     print ${*entry{SCALAR}}."\n";  }</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre><b>(a)</b>package extraModule;require Exporter;@EXPORT=qw(readData);@EXPORT_OK=qw(VERSION ISA);sub readData{    ... _program code_ ...}<b>(b)</b>package mainModule;use extraModule qw(VERSION ISA readData);<b>(c)</b>my $extra_data = ExtraModule::readfile( $filename );</pre><P><A HREF="#rl2">Back to Article</A></P><H4><A NAME="l3">Listing Three</H4><pre><b>(a)</b>my %keylist;# Create a new namespace for package $pkg.unless( exists ${"$pkg\:\:"}{VERSION} ) {     eval "package $pkg";    eval "use $pkg";    eval "require $pkg"; }while( my ($key, $val) = each %{*{"$pkg\:\:"}} ) {    if( defined $val ) {        local (*v) = $val;        # test for $pkg to make sure we get the right stash.    if( ($val =~ /$pkg/) &amp;&amp; ($val =~ /VERSION/ ) ) {        $m -&gt; {version} = ${*v{SCALAR}};    }    if( ($val =~ /$pkg/) &amp;&amp; ($val =~ /ISA/ ) ) {        $m -&gt; {superclasses} = "@{*v{ARRAY}}";        }    $keylist{$key} = $val;    }}<b>(b)</b>eval "package Lib::Module";eval "use Lib::Module";eval "require Lib::Module";</pre><P><A HREF="#rl3">Back to Article</A></P><H4><A NAME="l4">Listing Four</H4><pre><b>(a)</b>package Lib::Module;sub new {    my $proto = shift;    my $class = ref( $proto ) || $proto;    my $self = {    children =&gt; [],    parents =&gt; '',    pathname =&gt; '',    basename =&gt; '',    packagename =&gt; '',    version =&gt; '',    superclasses =&gt; undef,      baseclass =&gt; '' };    bless( $self, $class);    return $self;}<b>(b)</b>package Tk::Browser;use Lib::Module;my $m = new Lib::Module; $m -&gt; module_info( $packname );<b>(c)</b>package Tk::Browser;my $m = &amp;Lib::Module::module_info( $packname );</pre><P><A HREF="#rl4">Back to Article</A></P></body></html>