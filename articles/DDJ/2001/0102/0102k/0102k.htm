<html><head><title>Feb01: Module Design Guidelines for Real-Time Systems</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Module Design Guidelines for Real-Time Systems</h1><p><i>Dr. Dobb's Journal</i> February 2001</p><h2>Team programming  can work &#151; if you  follow the rules</h2><h3>By David Janik</h3><I>David is an engineer for Tellabs and can be contacted at david.janik@tellabs.com.</I><hr><p>A  common problem faced by programming teams is the ability to produce consistent, reliable, and maintainable modules. One solution to this is to develop a set of coding convention guidelines that are adhered to by all team members. Typical coding conventions deal with syntax issues at the lowest level. However, the module guidelines I present in this article deal with module issues at the level above the syntax &#151; that is, at a level of abstraction above the specific source code. These guidelines are therefore intuitive and maintainable, and promote reuse. Ultimately, development teams that follow guidelines such as these produce modules that are cohesive, decoupled, and encapsulated. For instance, we've used these guidelines in producing team-developed firmware for a 12-channel DS3/STS1 card of a digital cross-connect system. The card consists of several ASIC devices and is controlled by an internal LAN connection. In truth, the guidelines are generic for any C language module, including nonreal-time scenarios. However, the example queue and interrupt routines presented here show how you can apply the guidelines to real-time systems.</p><p>The module convention is modeled after the class data type from object-oriented programming languages. There are three sections to this convention:</p><DDJADVERTISEMENT INLINE><ul>  <li>Protected data, the module-visible data structure. The visibility is only within the module. This does not include the local variables used within a function.  <li>External functions &#151; "methods," "services," or "callable functions" other modules will invoke. External functions are the API for the other modules in the system to use. External functions can invoke their own internal functions, access their own protected data, and invoke the external functions of other modules.  <li>Internal functions, the "private" functions of a module. Internal functions have access to their own protected data and can invoke another module's external functions.</ul><p><A NAME="rf1"><A HREF="0102kf1.htm">Figure 1</A> is a simple model of module ABC showing the relationship between the <i>abc_ProtectedData</i>, <i>abc_InternalFunctions</i>, and <i>abcExternalFunctions</i>. It also shows the calling relationship between modules ABC and XYZ. Module ABC's internal or external functions can call only external functions of module XYZ. This module model convention facilitates data encapsulation. Module cohesion and decoupling characteristics are realized from the software architecture.</p><p><A NAME="rf1"><A HREF="0102kf1.htm">Figure 1</A> also illustrates the simple naming convention. External functions have the module name as a prefix (<i>xyzExternalFunction()</i>, for instance), while internal functions and protected data have the module name prefix and the underscore character (<i>xyz_internalFunction()</i> and <i>xyz_protectedData</i>, respectively). The intent of this naming convention is to intuitively identify exactly where the function or data resides when reading the source code. Consequently, there is no need to <i>grep</i> or <i>cscope</i> for a function.</p><h3>Module Model Source Files</h3><p>There are three types of source file structures associated to this module model:</p><ul>  <li>Simple. All the source code for external functions, internal functions, internal task function, and protected data structure reside in a single file, such as <A NAME="rl1"><A HREF="#l1">Listing One</A>(a). The prototypes of the external functions and any <i>#define</i>s, <i>enum</i>s, and the like, needed by the external functions, reside in a file like <A NAME="rl1"><A HREF="#l1">Listing One</A>(b). The application-specific header file, <A NAME="rl1"><A HREF="#l1">Listing One</A>(c), is the last file and defines any application-specific information the module  needs to work for the particular application.  <li>	   <A NAME="re1"><A HREF="0102ke1.htm">Example 1</A> is an example of where the module source files would reside in a typical source directory. The application directory contains four subdirectories. For this application, three modules are required.  <li>Divided. The difference between simple and divided file structures is that the external functions, internal functions, and protected data are separated into different files. All the source code for the external functions reside in one file, like that in <A NAME="rl2"><A HREF="#l2">Listing Two</A>(a). The internal functions reside in another file, such as <A NAME="rl2"><A HREF="#l2">Listing Two</A>(b). The internal function prototypes and any other <i>#define</i>s, <i>enum</i>s, and the like, needed to use the internal functions reside in a file like <A NAME="rl2"><A HREF="#l2">Listing Two</A>(c). The protected data structure resides in a file such as <A NAME="rl2"><A HREF="#l2">Listing Two</A>(d), while the prototypes of the external functions (and any <i>#define</i>s, <i>enum</i>s, and so on) reside in a file like <A NAME="rl2"><A HREF="#l2">Listing Two</A>(e). Finally, the application-specific header file is the same as the simple file model; see <A NAME="rl2"><A HREF="#l2">Listing Two</A>(f). <A NAME="re2"><A HREF="0102ke2.htm">Example 2</A> illustrates where the module source files would reside in a typical source directory for divided file structures.  <li>Distributed. The distributed file structure further divides the external functions into related files; see <A NAME="rl3"><A HREF="#l3">Listings Three</A>(a) and Three(b). Also, the internal functions are divided into related files, as in <A NAME="rl3"><A HREF="#l3">Listings Three</A>(d) and Three (f) (ex: abc_task.c, abc_utilities.c). The internal function prototypes and any other <i>#define</i>s, <i>enum</i>s, and so on, needed to use the internal functions reside in the files, as in <A NAME="rl3"><A HREF="#l3">Listings Three</A>(e) and Three(g) (abc_task.h, abc_utilities.h). The Protected data structure resides in another file, as in <A NAME="rl3"><A HREF="#l3">Listing Three</A>(h) (abc_map.h). The prototypes of the external functions and any <i>#define</i>s, <i>enum</i>s, and the like, reside in the file (abc.h) see <A NAME="rl3"><A HREF="#l3">Listing Three</A>(c). The application-specific header file is the same as the SIMPLE file model (abc_appSpec.h), see <A NAME="rl3"><A HREF="#l3">Listing Three</A>(i). <A NAME="re3"><A HREF="0102ke3.htm">Example 3</A> shows the file structure for distributed modules. </ul><p><A NAME="rl3"><A HREF="#l3">Listing Three</A> illustrates the simple file naming convention. The external functions have the module name as a prefix (abcMessage.c). Internal functions and protected data have the module name prefix and the underscore letter (abc_task.c, abc_map.h). The intent of the XXX_appSpec.h file is to group all the application-specific parameters into one file. This makes the module easier to reuse by only modifying one source file. Also note that there is no nesting of header files.</p><h3>Module Types: Passive and Active</h3><p>The two types of modules are passive and active. A passive module type is one where there are no real-time operating system (RTOS) tasks running. It is a simple function call and return. A passive module can use a semaphore to control access to its protected data.</p><p>An active module, on the other hand, is a module type that has at least one RTOS task created. The active module may be driving data into passive modules periodically or waiting for a message to be put onto its queue:</p><ul>  <li>Tasks. A task is a function with an infinite loop. There are two basic types of tasks &#151; periodic and asynchronous. The periodic task has an associated RTOS timer that wakes at a defined frequency. The asynchronous task waits on a queue, event, mailbox, and so on. The asynchronous task wakes when a message is posted to the queue, event, mailbox, and the like. Typically, another task or interrupt routine will post a message. When the task runs, it will read the queue, event, mailbox, or whatever, and process the message. The task function is an internal function for the module.  <li>Queues, events, and mailboxes. A message processing task needs a queue so other tasks can post a message to it. Some system designs have the queue as public or global and is visible to all modules. The structure of the message also needs to be global to all modules that post a message to the queue; see <A NAME="rf2"><A HREF="0102kf2.htm">Figure 2</A>.</ul><p>For the module model presented here, the queue is a protected data structure and not visible to the other modules. The other modules will call external functions of a module and these functions will post a message to the task queue; see <A NAME="rf3"><A HREF="0102kf3.htm">Figure 3</A>.</p><p>Modules ABC and XYZ do not have access to the queue <i>pdq_queue</i> since it is a protected data structure of module PDQ. Module ABC calls the external function <i>pdqService1(),</i> which puts a message onto the queue <i>pdq_queue</i>. Also, module XYZ calls external function <i>pdqService2()</i>, which puts a different message onto the queue <i>pdq_queue</i>.</p><p>The advantages of this type of design are cleaner interface to the PDQ module, maintainability, the format and message content for the queue may change without affecting modules ABC or XYZ, and data encapsulation (the only functions posting messages to the PDQ queue are within the PDQ module).</p><h3>Interrupt Service Routines</h3><p>The Interrupt Service Routine (ISR) can be internal or external functions, depending on how the hardware is designed. If the hardware has an interrupt controller device and all the interrupts go through this device, then all of the ISRs will be external functions &#151; except the low-level driver module associated to the interrupt controller device. This will be an internal function that the interrupt vector points to. If the hardware has separate interrupt vectors for each device, then all of the ISRs will be internal functions. Each interrupt vector points to the associated internal function ISR. <A NAME="rf4"><A HREF="0102kf4.htm">Figures 4</A> and <A NAME="rf5"><A HREF="0102kf5.htm">5</A> illustrate the two models.</p><h3>Conclusion</h3><p>By following the guidelines for firmware development I've presented here, the modules created will be more robust, maintainable, and reusable because they will have the object-oriented properties of being cohesive, decoupled, and data encapsulated.</p><p></p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre><b>(a)</b>/* Name: abc.c          *//* Description:         *//* Developer:           */#include abc.h#include abc_appSpec.h#include pdq.h          /* prototype for pdqAction() */#include rtos.h         /* prototype for rtosStartTask() *//*** Protected Data             ***/typedef{   int mode;   int *device;}abc_structabc_struct abc_data[ABC_INSTANCES];/*** Internal Functions Prototypes ***/int abc_instanceCheck(int instance);int abc_messageCheck(int message);/*** Internal Functions ***/int abc_instanceCheck(int instance){   int result = ABC_ERROR;   if (instance &lt; ABC_INSTANCE)   {      result = ABC_OK;   }   return (result);}/*** ***/int abc_messageCheck(int message){   int result = ABC_ERROR;   if (message == ABC_MESSAGE_1 || message == ABC_MESSAGE_2)   {      result = ABC_OK;   }   return (result);/*** External Functions ***/int abcInit(){   int i;   for (i=0; i&lt;ABC_INSTANCES; i++)   {      abc_data[i].mode   = 0;      abc_data[i].device = (int *)(ABC_BASE_ADDRESS + (0x100 * i);   }   rtosStartTask(abc_task, ABC_PRIORITY);   return (ABC_OK);}/***  ***/int abcModeGet(int instance, int *mode){   int result = ABC_ERROR;   if (abc_instanceCheck(instance) == ABC_OK)   {      *mode = abc_data[instance].mode;      if (*mode == 1)      {         pdqAction(*abc_data[instance].device);         abc_data[instance].mode = 0;      }      result = ABC_OK;   }   return (result);}/*** ***/int abcMessageSend(int instance, int message){   int result = ABC_ERROR;   if (abc_instanceCheck(instance) == ABC_OK)   {      if (abc_messageCheck(message) == ABC_OK)      {         *abc_data[instance].device = message;         result = ABC_OK;      }   }   return (result);}<b>(b)</b>/* Name: abc.h          *//* Description:         *//* Developer:           */#define ABC_ERROR       1#define ABC_OK          0#define ABC_MESSAGE_1   1#define ABC_MESSAGE_2   2int abcInit(void);int abcModeGet(int instance, int *mode);int abcMessageSend(int instance, int message);<b>(c)</b>/* Name: abc_appSpec..h            *//* Description:                    *//* Developer:                      */#define ABC_INSTANCES      10#define ABC_BASE_ADDRESS   0x1230#define ABC_IRQ            7#define ABC_PRIORITY       5#define ABC_PAUSE          100       /* 1 second */</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre><b>(a) </b>/* Name: abc.c          *//* Description:         *//* Developer:           */#include abc.h#include abc_appSpec.h#include abc_internal.h#include abc_map.h#include pdq.h          /* prototype for pdqAction() */#include rtos.h         /* prototype for rtosStartTask() *//*** Protected Data             ***/abc_struct abc_data[ABC_INSTANCES];   /* declare Protected Data Structure *//*** External Functions ***/int abcInit(){   int i;   for (i=0; i&lt;ABC_INSTANCES; i++)   {      abc_data[i].mode   = 0;      abc_data[i].device = (int *)(ABC_BASE_ADDRESS + (0x100 * i);   }   rtosStartTask(abc_task, ABC_PRIORITY);   return (ABC_OK);}/***  ***/int abcModeGet(int instance, int *mode){   int result = ABC_ERROR;   if (abc_instanceCheck(instance) == ABC_OK)   {      *mode = abc_data[instance].mode;      if (*mode == 1)      {         pdqAction(*abc_data[instance].device);         abc_data[instance].mode = 0;      }      result = ABC_OK;   }   return (result);}/*** ***/int abcMessageSend(int instance, int message){   int result = ABC_ERROR;   if (abc_instanceCheck(instance) == ABC_OK)   {      if (abc_messageCheck(message) == ABC_OK)      {         *abc_data[instance].device = message;         result = ABC_OK;      }   }   return (result);}<b>(b)</b>/* Name: abc_internal.c     *//* Description:             *//* Developer:               */#include abc_appSpec.h#include abc_internal.h#include abc_map.h#include rtos.h         /* prototype for rtosPause() *//*** Internal Functions ***/int abc_instanceCheck(int instance){   int result = ABC_ERROR;   if (instance &lt; ABC_INSTANCE)   {      result = ABC_OK;   }   return (result);}/*** ***/int abc_messageCheck(int message){   int result = ABC_ERROR;   if (message == ABC_MESSAGE_1 || message == ABC_MESSAGE_2)   {      result = ABC_OK;   }   return (result);}/*** ***/int abc_task(){   int instance = 0;   for(;;)   {      rtosPause(ABC_PAUSE);      if (*abc_data[instance].device != 0)      {         abc_data[instance].mode = 1;      }      instance++;      if (instance &gt;= ABC_INSTANCE)      {         instance = 0;      }   }}<b>(c) </b>/* Name: abc_internal.h     *//* Description:             *//* Developer:               *//*** Internal Functions ***/int abc_instanceCheck(int instance);int abc_messageCheck(int message);int abc_task(void);<b>(d) </b>/* Name: abc_map.h      *//* Description:         *//* Developer:           *//*** Protected Data             ***/typedef{   int mode;   int *device;}abc_structextern abc_struct abc_data[ABC_INSTANCES];<b>(e)</b> /* Name: abc.h          *//* Description:         *//* Developer:           */#define ABC_ERROR       1#define ABC_OK          0#define ABC_MESSAGE_1   1#define ABC_MESSAGE_2   2int abcInit(void);int abcModeGet(int instance, int *mode);int abcMessageSend(int instance, int message);<b>(f)</b>  /* Name: abc_appSpec..h    *//* Description:            *//* Developer:              */#define ABC_INSTANCES      10#define ABC_BASE_ADDRESS   0x1230#define ABC_IRQ            7#define ABC_PRIORITY       5#define ABC_PAUSE          100 /* 1 second */</pre><P><A HREF="#rl2">Back to Article</A></P><H4><A NAME="l3">Listing Three</H4><pre><b>(a) </b>/* Name: abcControl.c       *//* Description:             *//* Developer:               */#include abc.h#include abc_appSpec.h#include abc_utilities.h#include abc_map.h#include abc_task.h#include pdq.h          /* prototype for pdqAction() */#include rtos.h         /* prototype for rtosStartTask() *//*** Protected Data             ***/abc_struct abc_data[ABC_INSTANCES];   /* declare Protected Data Structure *//*** External Functions ***/int abcInit(){   int i;   for (i=0; i&lt;ABC_INSTANCES; i++)   {      abc_data[i].mode   = 0;      abc_data[i].device = (int *)(ABC_BASE_ADDRESS + (0x100 * i);   }   rtosStartTask(abc_task, ABC_PRIORITY);   return (ABC_OK);}/***  ***/int abcModeGet(int instance, int *mode){   int result = ABC_ERROR;   if (abc_instanceCheck(instance) == ABC_OK)   {      *mode = abc_data[instance].mode;      if (*mode == 1)      {         pdqAction(*abc_data[instance].device);         abc_data[instance].mode = 0;      }      result = ABC_OK;   }   return (result);}<b>(b)</b> /* Name: abcMessage.c       *//* Description:             *//* Developer:               */#include abc.h#include abc_appSpec.h#include abc_utilities.h#include abc_map.h/*** External Functions ***/int abcMessageSend(int instance, int message){   int result = ABC_ERROR;   if (abc_instanceCheck(instance) == ABC_OK)   {      if (abc_messageCheck(message) == ABC_OK)      {         *abc_data[instance].device = message;         result = ABC_OK;      }   }   return (result);}<b>(c)</b> /* Name: abc.h          *//* Description:         *//* Developer:           */#define ABC_ERROR       1#define ABC_OK          0#define ABC_MESSAGE_1   1#define ABC_MESSAGE_2   2int abcInit(void);int abcModeGet(int instance, int *mode);int abcMessageSend(int instance, int message);<b>(d)</b> /* Name: abc_utilities.c   *//* Description:            *//* Developer:              */#include abc_utilities.h#include abc_appSpec.h#include abc_map.h/*** Internal Functions ***/int abc_instanceCheck(int instance){   int result = ABC_ERROR;   if (instance &lt; ABC_INSTANCE)   {      result = ABC_OK;   }   return (result);}/*** ***/int abc_messageCheck(int message){   int result = ABC_ERROR;   if (message == ABC_MESSAGE_1 || message == ABC_MESSAGE_2)   {      result = ABC_OK;   }   return (result);}<b>(e)</b> /* Name: abc_utilities.h        *//* Description:                 *//* Developer:                   *//*** Internal Functions ***/int abc_instanceCheck(int instance);int abc_messageCheck(int message);<b>(f)</b> /* Name: abc_task.c     *//* Description:         *//* Developer:           */#include abc_task.h#include abc_appSpec.h#include abc_map.h#include rtos.h         /* prototype for rtosPause() *//*** Internal Functions ***/int abc_task(){   int instance = 0;   for(;;)   {      rtosPause(ABC_PAUSE);      if (*abc_data[instance].device != 0)      {         abc_data[instance].mode = 1;      }      instance++;      if (instance &gt;= ABC_INSTANCE)      {         instance = 0;      }   }}<b>(g)</b> /* Name: abc_task.h     *//* Description:         *//* Developer:           *//*** Internal Functions ***/int abc_task(void);<b>(h) </b>/* Name: abc_map.h      *//* Description:         *//* Developer:           *//*** Protected Data             ***/typedef{   int mode;   int *device;}abc_structextern abc_struct abc_data[ABC_INSTANCES];<b>(i)</b>  /* Name: abc_appSpec..h    *//* Description:            *//* Developer:              */#define ABC_INSTANCES      10#define ABC_BASE_ADDRESS   0x1230#define ABC_IRQ            7#define ABC_PRIORITY       5#define ABC_PAUSE          100 /* 1 second */</pre><P><A HREF="#rl3">Back to Article</A></P></body></html>