<HTML>
<META NAME="year" CONTENT="1990">
<HEAD>

<TITLE>SEP90: A GENERIC ONE-PASS ASSEMBLER</TITLE></HEAD>
<body bgcolor="FFFFFF">
<h1>A GENERIC ONE-PASS ASSEMBLER<a name="01d8_0003"><a name="01d8_0003"></h1><P>
<h2><a name="01d8_0001"><a name="01d8_0000">Symbol management is the key to one-pass assembly</h2><P>
This article contains the following executables: IVES.ARC<P>
<h3>William E. Ives</h3><P>
<p><i><a name="01d8_0002"><a name="01d8_0000">William is a software design engineer in the Colorado Telecommunications division of Hewlett Packard, 5070 Centennial Blvd., Colorado Springs, CO 80919.  William's Internet address is wei@hpctdlb.hp.com.</i></p><hr><P>
The one thing most programmers are interested in when developing code in assembly language is fast assembly turnaround time.  A one-pass assembler facilitates this by avoiding the delays associated with multipass assemblers, and thus is able to out-perform them.  This performance increase has some cost, the foremost being optimization.  But even this can be minimized by proper symbol management.<P>
This article describes one approach to a generic one-pass assembly.  The ideas presented can be applied to most of the current assembly languages.<P>
<h3><a name="01d8_0004">Symbols<a name="01d8_0004"></h3><P>
A symbol is an alphanumeric shorthand used by programmers to reference a value that the symbol is tied to at some time during assembly.  As an example, consider the symbol THERE in the following code fragment:<P>
<pre>        JMP THERE

  ...   THERE ADD #1,DO</pre><P>
The assembler must interpret the value of THERE as being the address of the ADD instruction. It must then generate the machine code for the JMP instruction with the resolved address. Notice that #1 and DO are not considered symbols because their values or meanings are implied within the assembly language.  In this case #1 means the immediate value of one, and D0 means data register zero.<P>
As shown above, a symbol can be tied to an address by a line label.  Most assemblers also provide a method of defining symbols through an assembler EQUATE pseudocommand.<P>
<pre>  ONE EQUATE 1</pre><P>
Here, the EQUATE does not assemble to any machine code, but rather instructs the assembler to tie the value 1 to the symbol ONE.<P>
Once the symbols are either tied to values or resolved, the job of the assembler is to use these values to generate machine code for those instructions whose operands reference symbols.  For example, the JMP instruction shown earlier would normally have a base opcode followed by a target address within its machine code.  The assembler fills in the target address portion of the machine code once the symbol THERE is resolved.<P>
<h3><a name="01d8_0005">Forward References<a name="01d8_0005"></h3><P>
Assemblers traditionally pass through code using a location counter to keep track of the address of each instruction.  As each instruction is processed, the location counter is incremented based upon the number of bytes required to hold the machine code of the instruction.  This forces the sequential location of machine code for each instruction with no &quot;undefined&quot; bytes between instructions.  In addition, it leaves space in the final machine code to go back and fill in resolved symbols such as THERE.<P>
This is a problem, however, when the amount of space to be reserved for forward referenced symbols is unknown.  This is especially apparent on processors that offer multiple forms of the same instruction.  For example, the JMP instruction might come in either form: 16-bit or 32-bit target address.  The question is how much space is left in the machine code if the assembler does not yet know the value of the target address (THERE).<P>
Multipass assemblers address this dilemma by resolving symbols on the first pass through, adjusting instruction addresses appropriately, then generating machine code on additional passes.  With this approach, most multipass assemblers handle both the forward references and machine code optimization.  Although this method generates optimal machine code, it is often time-consuming and thus tedious for the programmer who is looking for a fast turnaround time.<P>
A one-pass assembler addresses this same problem by passing through the code only once, leaving space for the forward referenced symbols, then filling in these spaces as the symbols are resolved.  This process is called &quot;back-patching.&quot;  By making the assembly language deterministic with assembler defaults or directives, the one-pass assembler knows how much space to leave for forward referenced symbols.  This may not result in optimal code, but does result in improved assembly time.<P>
The directives or defaults needed to make this possible depend heavily on the actual processor and its addressing modes.  For example, the 6809 constant offset program counter for the relative mode has an 8-bit and a 16-bit form.  This can be made deterministic by defaulting to the larger size (16-bit) and allowing the user to force the 8-bit offset by using an assembler directive (SHORT).  The code in <a href="9009e.htm#01d8_0006">Figure 1</A>  demonstrates this.<P>
<h4><a name="01d8_0006"><a name="01d8_0006">Figure 1: Example of the SHORT directive to generate an 8-bit offset</h4><P>
<pre>
  0000  A6 8D 0003       LDA FORWARD, PCR ; 16-bit offset
                         SHORT
  0004  A6 8C 00         LDA FORWARD, PCR ; 8-bit offset
  0007  01     FORWARD   FCB 1  ;Force constant byte
</pre><P>
<P>
An example for the 68000 involves the absolute addressing mode, which can be either a 16-bit or 32-bit address.  Whenever a forward referenced symbol is used for these modes, the current assembler default is used.  This default size can be changed from word to long by the directives shown in <a href="9009e.htm#01d8_0007">Figure 2</A>.<P>
<h4><a name="01d8_0007"><a name="01d8_0007">Figure 2: Changing the default addressing mode on the 68000</h4><P>
<pre>
                    ABS_SHORT               ;set default to absolute word
  0000  2038  000A  MOVE.B DO, LABEL
                    ABS_LONG                ;set default to absolute long
  0004  2039  0000  MOVE.B DO, LABEL
        000A
  000A  01      LABEL DC.B 1 ;define constant byte
</pre><P>
<P>
The 68000 branch commands must also be deterministic because they come in byte and word forms.  This is done by defaulting to the word offset unless the instruction is qualified by a size specifier of .B, as shown in <a href="9009e.htm#01d8_0008">Figure 3</A>.<P>
<h4><a name="01d8_0008"><a name="01d8_0008">Figure 3: Making a branch command deterministic using the .B size specifier</h4><P>
<pre>
  0000  6004               BRA.B  TARGET  ;8 bit offset of 4
  0002  6000  0002         BRA    TARGET  ;16 bit offset of 2
  0006  6000  FFFE TARGET  BRA    TARGET  ;16 bit offset of -2
</pre><P>
<P>
These limitations might seem unreasonable at first, but the default assembler settings can be used so that minimal effort is required on the part of the programmer.  The programmer can use the directives to override the defaults for optimization; this need be done only for forward references because backward references can automatically be optimized.  This approach is not at all uncommon in many of today's commercial assemblers.  For example, those familiar with Microsoft's Macro Assembler will recognize the directive, jmp short there, which tells the assembler that the jump reference is within the current code segment.<P>
<h3><a name="01d8_0009">Symbol Management<a name="01d8_0009"></h3><P>
Once an assembly language is made deterministic, symbol management becomes the key to the assembly process.  First, each line is parsed, and any symbols are extracted from it.  Then a machine code size determination is made based on assembler defaults and directives.  If all of an instruction's operand symbols are resolved, the machine code can be immediately generated. Otherwise, all information associated with the instruction and its unresolved symbols is saved (in an operand reference list) for later assembly through backpatching.  In either case, the location counter is incremented by the size of the machine code, and the next source line is similarly processed.<P>
The symbols for each line are processed immediately after they are parsed from the line. The two types of symbols are the line label and any operand symbols.  Each type of symbol is associated with a list: A label with the resolved value list and an operand symbol with the reference list.  The line label is resolved to the current value of the location counter.  The label and its value are added to the label list so that future references to the label can be resolved.  Then, any previous references to the line label are taken from the operand reference list.  These are resolved, and machine code generation is done for each of their instructions through backpatching.  A flowchart of this is shown in <a href="199001da.htm">Figure 4</A>.<P>
The operand symbol management was described earlier.  A flowchart for this is shown in <a href="199001db.htm">Figure 5</A>.  An example of assembling a generic piece of assembly code using these two flowcharts is shown in <a href="199001dc.htm">Figure 6</A>.<P>
Note that at any given time the operand reference lists contain only those forward references not yet resolved.  In this respect, it does rely on memory being available for expansion, but the list size is always at a minimum for the code being assembled.  Again, this is the trade-off of space versus time.<P>
<h3><a name="01d8_000a">Multiple Modules<a name="01d8_000a"></h3><P>
The above management model can easily be expanded to support multiple module assembly.  This is done by introducing a global directive to export symbols from a module and an external directive to import symbols.  In addition, two new lists are added: A global label list and an external reference list.  These are similar to the label list and operand reference list, respectively.<P>
The new flowcharts are shown in Figure 7 and <a href="199001dd.htm">Figure 8</A>.  The major difference to note in the label symbol management flowchart (<a href="199001dd.htm">Figure 8</A>) is the order in which the various label lists are searched.  By searching the external and global lists first, this flowchart precludes the possibility of mistakenly placing a global label in the local label list.  This order of searching also provides the scoping rules between local and global symbols.<P>
The operand symbol management flowchart (Figure 7) shows another point of interest.  If a global label has not been resolved before it is referenced as an operand symbol, the reference is added to the local operand reference list.  This is done because a global symbol must be resolved before the end of a module.  Thus, any references to it can be treated just like local references.<P>
<h3><a name="01d8_000b">Linking<a name="01d8_000b"></h3><P>
As with any multiple module assembly, a linker must be used to create the final assembly program.  Here, again, the one-pass symbol management approach is used because linking is just a matter of resolving external references across modules and generating machine code through backpatching.  Of course, linking involves much more, but a detailed discussion is beyond the scope of this article.<P>
One feature of linking is relocation, which is not too difficult to add to the current model because it merely involves treating all symbols as relative to the base of the module.  Once the module base address is known, all symbols for the module are resolved.  Another advanced feature is arithmetic expression support.  This can be added by using expression trees in place of the symbols.  Resolution then becomes the resolution of the entire tree for each instruction's operand.  Unfortunately, each of these adds overhead and slows down the assembler.  If these advanced features are used extensively, the trade-off may be worthwhile.<P>
<h3><a name="01d8_000c">A One-Pass Assembler<a name="01d8_000c"></h3><P>
<a href="9009e.htm#01d8_000d">Listings One</A> through Nine provide a simple one-pass assembler for a generic assembly language.  <a href="9009e.htm#01d8_000d">Listing One</A> (page 92) provides the main driver; <a href="9009e.htm#01d8_000f">Listing Two</A> (page 92) contains the procedures to handle assembly; <a href="9009e.htm#01d8_0011">Listing Three</A> (page 96) is the error handler module; <a href="9009e.htm#01d8_0013">Listing Four</A> (page 97) contains the procedures to handle the instruction set; <a href="9009e.htm#01d8_0015">Listing Five</A> (page 98) is the listing module; <a href="9009e.htm#01d8_0017">Listing Six</A> (page 100) is the math module, <a href="9009e.htm#01d8_0019">Listing Seven</A>  (page 100) is the parser module; <a href="9009e.htm#01d8_001b">Listing Eight</A> (page 102) provides the procedures for pseudocommand assembly; and <a href="9009e.htm#01d8_001d">Listing Nine</A> (page 103) is the symbol table module.<P>
Because of space considerations, all comments have been removed from the code.  Fully commented code, further test cases, and an executable version of the assembler are available from DDJ.  (For more information see page 3.)<P>
This code can easily be modified to build a full-featured assembler by adding an advanced parser, instruction opcode lookup facility, and error trapping.  In all, symbol management is the key to one-pass assembly.  And, although such an assembler may not create optimal code, it does have the fastest development turnaround time.<P>

_A GENERIC ONE-PASS ASSEMBLER_
by William E. Ives

<a name="01d8_000d"><a name="01d8_000d">
<a name="01d8_000e"></pre><B>[LISTING ONE]</B><pre><a name="01d8_000e">


/**************************************************************************

  Main driver for generic assembler.
  Copyright 1988 by Michigan Technological University

  Written by : William E. Ives

  Version : 1.0
  Date     : Feb 1, 1989

 **************************************************************************/

#include &lt;stdio.h&gt;
#include &lt;conio.h&gt;
#include &lt;string.h&gt;
#include &lt;time.h&gt;
#include &lt;dir.h&gt;

#include &quot;68defs.h&quot;
#include &quot;68err.h&quot;
#include &quot;68parse.h&quot;
#include &quot;68list.h&quot;
#include &quot;68assem.h&quot;
#include &quot;68symtab.h&quot;

void assembler_print_errors ( char * message , char * add_mess )
{
 printf(&quot; %s %s \n&quot;,message,add_mess );
}

main()
{
 int     error_count, warning_count ;
 FILE   * outfile ;
 FILE   * in_file ;
 char     fn[MAXPATH],outname[MAXPATH], temp[MAXPATH], *ptr;

 /* Following used to parse a path into its components. */
 char drive[MAXDRIVE] , dir[MAXDIR], file[MAXFILE], ext[MAXEXT];

 error_count = 0 ;
 warning_count = 0 ;

 e_printf = assembler_print_errors ;

 puts(&quot; Generic Assembler. Version 1.0\n&quot;);
 puts(&quot; Written by : William E. Ives&quot;);
 puts(&quot; Copyright (c) 1988 by Michigan Technological University.\n&quot;);

 printf(&quot; Absolute or Relative assembly ? (A/R) &quot;);
 fn[0] = getche();
 putchar('\n');
 am_assem_class = (( fn[0] == 'a')||(fn[0] == 'A')) ?
        am_absolute : am_relative ;

 printf(&quot; Enter source file name [.ASM] =&gt;&quot;);
 fn[0]=MAXPATH-1;
 ptr=cgets(fn);
 strcpy(fn,ptr);
 putchar('\n');

 fnsplit( fn,drive,dir,file,ext);

 /* assign list file name.*/

 if ( ! ( *ext ) )
    fnmerge( fn, drive,dir,file,&quot;.ASM&quot;);

 fnmerge( outname,drive,dir,file,&quot;.LST&quot;);

 printf(&quot; Enter name of list file [%s] =&gt;&quot;,outname);
 temp[0]=MAXPATH-1;
 ptr = cgets(temp);
 putchar('\n');
 if ( temp[1] ) strcpy(outname,ptr);

 in_file = fopen( fn,&quot;r&quot;);
 if ( in_file == NULL ) {
    e_message(0,30, fn );
    return 30 ;
    }

 puts(&quot; Assembling..&quot;);

 e_hold_messages = TRUE ;
 am_pass1( in_file , &amp;error_count, &amp;warning_count );
 e_hold_messages = FALSE ;

 fclose(in_file);

 printf(&quot; Total Errors %d    Total Warnings %d \n&quot;,
     error_count, warning_count );

 puts(&quot; Writing listing file.\n&quot;);
 outfile = fopen( outname,&quot;w&quot;);
 if ( outfile == NULL ) {
    e_message(0,30, outname );
    return 30 ;
    }
 l_printlisting( outfile ,TRUE );
 fprintf(outfile,&quot;\n Total Errors %d    Total Warnings %d \n&quot;,
       error_count, warning_count );

 fprintf(outfile,&quot;\n\n Name of file :%s\n&quot;,fn);
 fclose(outfile);

 return 0 ;

} /* main */




<a name="01d8_000f"><a name="01d8_000f">
<a name="01d8_0010"></pre><B>[LISTING TWO]</B><pre><a name="01d8_0010">


/*
     68000 Assembly Module.
    This module contains those procedures needed to handle
    assembly.
*/

  #include &lt;stdio.h&gt;
  #include &lt;stdlib.h&gt;
  #include &lt;string.h&gt;
  #include &lt;ctype.h&gt;

  #include &quot;68defs.h&quot;
  #include &quot;68err.h&quot;
  #include &quot;68parse.h&quot;
  #include &quot;68list.h&quot;
  #include &quot;68assem.h&quot;
  #include &quot;68symtab.h&quot;
  #include &quot;68pseudo.h&quot;
  #include &quot;68instr.h&quot;

  #define LINELEN 80
  #define LOCAL near pascal

  void p_assem_line ( char       * line      ,
            char         label[MAXSYMLEN]   ,
            char         command[MAXSYMLEN],
            p_size_type   * size      ,
            char       * numterms      ,
            am_term_type ** termlist      ) ;


 unsigned long int    am_location_counter = 0L     ;
 char            am_end_found     = FALSE ;
 char            am_trunc_lines     = TRUE  ;

 /* These globals are used for relative symbol/term resolution by linker*/
 unsigned long int    am_relbase     = 0L     ;
 char            am_relknown     = FALSE ;


           /* size of absolute address in words. */
           /* 1 - abs short, 2 - abs long.   */
 char            am_abs_address_size  = 1;

 am_term_type       * am_term_list_head = NULL , * am_term_list_tail = NULL ;
 am_assem_type         am_assem_class   = am_absolute ;



/**************************************************************************
   Function am_resolve_symbol

     This function resolves a symbol list if it is possible
     If the symbol list is resolved it deletes every symbol
     node but the first one which contains the sum.
     It also compresses the symbol list as much as possible even
     if all symbol are not resolved.
       It compresses relative symbols by maintaining a count of
     relative symbols.   It adds or subtracts from this count
     according to the operator for the symbol.   If when the list
     is fully compressed, the relative count is not zero, then
   if the relative base is known, the final sum is
      computed by adding in relcount*am_relbase
   else
      relflag '*' is put into symbol[0]  and
      relcount is put into symbol[1] of the first symbol node.

     Globals
   am_relknown : flag indicating that relative symbol base value is
            known.
   am_relbase  : the known relative base.
     Variable parameters :
   symlist : the symbol list.

     Return value
   The number of symbols still left unresolved.
 *************************************************************************/
 int am_resolve_symbol( p_sym_type * symlist )
 {
   register int   symcount = 0 ;
   unsigned long  sum = 0L ;
   char      rel , relcount = 0 ;
   p_sym_type   * symbol , * temp , * prev ;

   temp = NULL ;
   prev = NULL ;
   symbol = symlist ;
   while ( symbol ) {

      rel = ( symbol-&gt;sym[0] == '*'  ) ;  /* set relative flag.*/

      if ( !rel &amp;&amp; symbol-&gt;sym[0]  ) {       /* if there is a symbol.*/
   symcount++ ;
   prev = symbol ;
   symbol = symbol-&gt;next ;
   }
      else {           /* there is a value. perform calculations */
   if ( symbol-&gt;operator == '+' ) {
      if ( rel ) relcount += symbol-&gt;sym[1] ;
      sum += symbol-&gt;val ;
      }
   else {
      if ( rel ) relcount -= symbol-&gt;sym[1] ;
      sum -= symbol-&gt;val ;
      symbol-&gt;operator = '+';
      }

   if ( !temp ){        /* if temp == null */
      temp = symbol ;
      prev = symbol ;
      symbol = symbol-&gt;next ;
      }
   else {
      prev-&gt;next = symbol-&gt;next ;
      free(symbol);
      symbol = prev-&gt;next ;
      }
   }
      }

   /* if there were no unresolved symbols but relatives didn't cancel then*/
   if ( !symcount &amp;&amp; relcount )
      if ( am_relknown ) {
    sum += ( relcount * am_relbase ) ;   /* resolve relative if known.*/
    relcount = 0;
    }
      else
    /* set symcount to 1 so that caller knows that chain is not resolved.*/
    symcount=1 ;

   if ( temp ) {
      temp-&gt;val = sum ;
      temp-&gt;operator = '+' ;
      if ( !relcount ) temp-&gt;sym[0] = 0 ;
      else {
    temp-&gt;sym[0] = '*' ;
    temp-&gt;sym[1] = relcount ;
    }
      }
   if ( prev )   prev-&gt;next = NULL ;

   return symcount ;

 } /* am_resolve_symbol */



/**************************************************************************
   Function am_resolve_term

     This function resolves a term list if it is possible.  It only
     resolves the terms until any the following conditions occur :
    - the first term class was am_first_instr_term and
      the next term is not am_other_instr_term
    - the terms classes are all am_data_terms and the
      datatermcount has been reached or am_first_instr_term
      has been reached.
    - the next term is NULL


     Variable parameters :
   termlist : The term list
   datatermcount : The number of data terms to resolve if the
         term class is am_data_term.
         This parameter is ignored if the first term
         was am_first_instr_term.
     Return value
   The number of terms still left unresolved.
 *************************************************************************/
 int am_resolve_term ( am_term_type * termlist , char   datatermcount )
 {
   register int    termcount = 0 ;
   am_term_type  * term ;
   char       okay , count ;

   term = termlist ;
   okay = TRUE ;
   count = 1 ;
   while ( term &amp;&amp; okay ) {
      if ( am_resolve_symbol(term-&gt;symptr ) ) termcount++ ;
      term = term-&gt;next ;
      count++ ;
      if ( term )
    okay = ( termlist-&gt;class == am_first_instr_term &amp;&amp;
         term-&gt;class == am_other_instr_term ) ||
      ( termlist-&gt;class == am_data_term &amp;&amp;
        term-&gt;class == am_data_term  &amp;&amp;
        count       &lt;= datatermcount   ) ;
      }

   return termcount ;

 } /* am_resolve_term */



/**************************************************************************
   Function am_delete_terms

      If the input parameter 'ALL' is set to TRUE (1) then
   this function frees all terms and associated symbols in a term list
   until null is encountered.
   The variable 'termlist' is set to NULL upon completion.
      If the input parameter 'ALL' is set to FALSE (0) then
   this function frees only one term and associated symbols.
   The variable 'termlist' is set to 'termlist-&gt;next' upon completion.

   Input
       all : boolean flag indicating how many terms to delete ( see above )
   Variable parameter
       termlist : a pointer variable which points to the termlist.


 **************************************************************************/
 void am_delete_terms ( am_term_type ** termlist , char   all )
 {
  am_term_type * term ;
  p_sym_type   * sym  ;

  term = *termlist ;
  if ( all ) {
     while ( term = *termlist ) {

       if (  ((term-&gt;modereg &gt;&gt; 8) == 7) &amp;&amp;
        ((term-&gt;modereg &amp; 15)==10 ) ) {
     free(term-&gt;symptr);           /* free the string. */
     term-&gt;symptr = NULL ;
     }

       while ( sym = term-&gt;symptr ) {
     term-&gt;symptr = term-&gt;symptr-&gt;next ;
     free(sym) ;
     }
       *termlist = term-&gt;next ;
       free(term);
       }
    }
  else {
    if ( term ) {

      if (  ((term-&gt;modereg &gt;&gt; 8) == 7) &amp;&amp;
       ((term-&gt;modereg &amp; 15)==10 ) ) {
    free(term-&gt;symptr);          /* free the string. */
    term-&gt;symptr = NULL ;
    }

      while ( sym = term-&gt;symptr ) {
    term-&gt;symptr = term-&gt;symptr-&gt;next ;
    free(sym) ;
    }
      *termlist = term-&gt;next ;
      free(term);
      }
    }

 } /* am_delete_terms */



/**************************************************************************
   Procedure am_add_terms_to_list

      This procedure links the list of terms into the global list
      of terms.
      This global list is used for all terms associated with data
      or instructions which contain forward/external references which
      are not yet resolved.

   Note : Term list is implemented as a non-circular doubly linked list.

   Globals :
     am_term_list_head : points to the head of the term list.
     am_term_list_tail : points to the tail of the term list.

   Variable parameter
       termlist : A pointer variable which points to the termlist to
        be linked in.  It is set to NULL when all the terms
        are transfered.


 **************************************************************************/
 void am_add_terms_to_list ( am_term_type ** termlist  )
 {
  am_term_type * term ;

  if ( ! (*termlist) ) return ;      /* if NULL then leave. */

  if ( !am_term_list_tail )  {        /* list is empty */
     am_term_list_head = *termlist ;
     am_term_list_head-&gt;prev = NULL ;
     }
  else {
     am_term_list_tail-&gt;next = *termlist ;
     am_term_list_tail-&gt;next-&gt;prev = am_term_list_tail ;
     }

  for ( term = *termlist ; term ; term = term-&gt;next )  /* set tail */
      am_term_list_tail = term ;

  *termlist = NULL;
  return ;       /* return used to avoid compilier warning. */

 } /* am_add_terms_to_list */



/**************************************************************************
   Procedure am_remove_terms_from_list

      This procedure removes the links from the global list of terms
      associated with the passed in termptr . It then deletes the terms
      by calling am_delete_terms.
      If the termptr points to a term with class am_first_instr_term
      then this routine will remove all terms for the instruction.
      If the termptr points to a term with class am_data_term
      then this routine will ONLY the ONE term.

   Note : Term list is implemented as a non-circular doubly linked list.

   Globals :
     am_term_list_head : points to the head of the term list.
     am_term_list_tail : points to the tail of the term list.

   Variable parameter
       termlist : A pointer variable which points to the termlist to
        be removed.  It is set to NULL when all the terms
        are deleted.

 **************************************************************************/
 void am_remove_terms_from_list ( am_term_type ** termlist  )
 {
  am_term_type * term ;
  char       i    ;

  if ( ! (*termlist) ) return ;      /* if NULL then leave. */

  term = *termlist ;
  i = 1 ;
  if ( term-&gt;class == am_first_instr_term ) {
     if ( term-&gt;next )
   if ( term-&gt;next-&gt;class == am_other_instr_term )
                /* remove both instr terms*/
      i = 2 ;
     }

  if ( term == am_term_list_head )
     am_term_list_head = ( i == 1 ) ? term-&gt;next : term-&gt;next-&gt;next ;
  else
     term-&gt;prev-&gt;next = ( i == 1 ) ? term-&gt;next : term-&gt;next-&gt;next ;

  if ( ( term == am_term_list_tail ) ||
       ( ( i == 2 ) &amp;&amp; ( term-&gt;next == am_term_list_tail )) )
     am_term_list_tail = term-&gt;prev  ;
  else
    if ( i == 1 )
      term-&gt;next-&gt;prev = term-&gt;prev ;
    else
      if ( term-&gt;next-&gt;next ) term-&gt;next-&gt;next-&gt;prev = term-&gt;prev ;

  if ( i == 1 )
     term-&gt;next = NULL ;
  else
     term-&gt;next-&gt;next = NULL ;

  am_delete_terms( &amp;term, TRUE );

  *termlist = NULL;
  return ;       /* return used to avoid compilier warning. */

 } /* am_remove_terms_from_list */


/*************************************************************************
    Procedure am_backfill

      This procedure updates the fields within the opcode.
      It determines actual post words for entire instruction, and
      places the opcode and post words into the listing.

      It expects all terms and symbols to be resolved.

      Input Parameter :
     termlist - will be resolved when finished creating final opcode.

  ************************************************************************/
  void   am_backfill(  am_term_type  * termlist )

  {
   char       i,j,k, reg    ;
   am_term_type *  term ;
   unsigned int    opcode ;
   l_line_type   *  lptr ;

   lptr = termlist-&gt;lineptr ;
   opcode = termlist-&gt;opcode;   /* get opcode */

   /* write opcode to listing */
   l_writetoline(1,opcode,0,lptr);

   term = termlist ;
   j =   ( term-&gt;index == 0 ) ? 2 : 1 ;
   reg = ( opcode &amp; 7 ) ;

   for (i=1,k=2 ; i &lt;= j &amp;&amp; term ; i++ ) {
     switch ( reg ) {
       case 1 :     /* abs.l */
     l_writetoline(k,term-&gt;symptr-&gt;val&gt;&gt;16,0,lptr);
     k++ ;
       case 0 :     /* abs.w */
     l_writetoline(k,term-&gt;symptr-&gt;val &amp; 0xFFFF ,0,lptr);
     k++ ;
     break ;
       }
      term = term-&gt;next ;
      reg = ((opcode&gt;&gt;9)&amp;7) ;
     }

  } /* am_backfill */


/**************************************************************************
   Function am_readln

     This function reads in one source line from a file until the end-of-line
     or the end-of-file is encountered.

       - it only read up to 'linelen' number of charcters and discards
    the rest of the line.
       - expands TABS to 8 space charcters.
       - returns a blank flag indicating if the first 'linelen' characters
    are blank or not.
       - builds a separate string the same as the first but in uppercase
    in parameter line1.
     NOTE : characters within single or double qoutes are not affected.

     Typical calling method : ( for echo of exact file contents )
       while   ( readln(in_file,LINELEN-1,line,line1,&amp;blank) != EOF )
         printf(&quot;%s\n&quot;,line);

     Input
    in_file  : the file to be read.
    linelen  : the max number of characters to be read not counting NULL.
     Variable
    line     : the line read in.
    line1     : the line read in converted to uppercase
    blank     : flag indicating whether or not the line is blank.

     Returns
       0 : line read okay.
       EOF : end of file was encountered.

 *************************************************************************/
static int LOCAL am_readln ( FILE * infile, int linelen,
              char * line  , char * line1, char * blank )
{
   int    ch, ch1 , i  ;
   char  dqoute, sqoute ; /* flags for tracking double &amp; single quotes */

   /* if either flag is true then no conversion of case will take place.*/
   dqoute = sqoute = FALSE ;
   *blank = TRUE ;
   i = 0 ;
   while ( ch=ch1=fgetc(infile) ) {
      if ( ch == '\t' ) {                 /* expand tabs into 8 spaces */
    for ( ch = 0 ; ch &lt; 8 ; ch ++, i++ ) {
       if ( i &lt; linelen ) {
          line[i] = line1[i] = ' ';
          line[i+1] = line1[i+1]= NULL;
          }
       }
    continue ;
    }

      if ( !isprint(ch) ) break ;

      if ( ch == '\'' ) { if ( !dqoute ) sqoute = !sqoute ; }
      else if ( ch == '&quot;' ) { if ( !sqoute ) dqoute = !dqoute ; }
      else if (!( dqoute || sqoute ))  ch1 = toupper(ch) ;

      if ( i&lt; linelen ) {
     line[i]= ch ;
     line1[i]= ch1 ;
     if ( *blank ) *blank = ( ch == ' ' );
     line[i+1] = line1[i+1] = NULL ;
     }

      i++;
      }

   if ( i )   return 0 ;
   return ch ;

} /* am_readln */


/**************************************************************************
   Function am_pass1

     This function assembles an entire file and creates the listing
     and associted data structures as it does so.

     Input parameters :
       in_file  : the file containing the source assembly code
             which has already been opened for reading.


 *************************************************************************/

 void am_pass1 ( FILE * in_file , int  * error_count , int  * warning_count )

 {
  int         i  ;
  ps_pseudos      pseudo_class ;
  char         label[MAXSYMLEN], command[MAXSYMLEN] ;
  char         sizeinwords , blank ;
  p_size_type      size  ;
  p_sym_type    * sym    ;
  char         numterms ;
  am_term_type    * termlist, *term ;
  unsigned int      opcode ;
  unsigned int      index  ;
  char         prev_warnings = 0 ;
  char         line[LINELEN], linehold[LINELEN] ;
  l_line_type    * lptr  ;


  e_error.state = 0 ;
  e_error.warnings = 0 ;

  while ( !am_end_found &amp;&amp; !e_error.out_of_memory &amp;&amp;
     ( am_readln(in_file,LINELEN-1,line,linehold,&amp;blank) != EOF )) {

     if ( blank ){                  /* skip blank lines */
   l_addline( l_neither, 0, &quot;&quot;, &amp;lptr );
   continue ;
   }

     if ( line[0] == '*' || line[0] == ';' ) {   /* skip comment lines */
   l_addline( l_neither, 0, line, &amp;lptr );
   continue ;
   }

     *error_count += e_error.state ;  /* count up total number of errors */
     e_error.state = 0 ;
     label[0]   = 0 ;
     command[0] = 0 ;
     size   = p_unknown ;
     numterms   = 0 ;
     sizeinwords= 0 ;
     termlist   = NULL ;

     p_assem_line ( linehold, label, command, &amp;size, &amp;numterms, &amp;termlist );

     if ( e_error.state ) {
   /* add errors to listing and go on to next line */
   l_addline( l_neither, 0, line, &amp;lptr);
   am_delete_terms(&amp;termlist, TRUE );
   l_add_errors(lptr);
   continue ;     /* skip to next source line. */
   }

     /* if command is psuedo then handle it. */
     if ( ps_lookup_pseudo ( command, &amp;pseudo_class ) ) {
   ps_pseudo( label, pseudo_class, numterms, &amp;termlist, line);
   if ( ( e_error.warnings &gt; prev_warnings ) || e_error.state )
      l_add_errors(l_line_head-&gt;prev);
   prev_warnings = e_error.warnings ;
   continue ;   /* skip to next source line. */
   }

     if ( am_location_counter &amp; 1 ) {
   e_message(0,22,NULL);        /* location counter is odd */
   l_addline(l_neither, 0, line, &amp;lptr);
   prev_warnings = e_error.warnings ;
   l_add_errors(lptr);
   am_location_counter++; /* adjust counter so this error does not repeat*/
   continue ;
   }

     /* its either an instruction or an error */

     if ( numterms &gt; 2 ) {
   e_message(0,15,NULL) ;            /* too many terms on line.*/
   l_addline(l_neither, 0, line, &amp;lptr);
   prev_warnings = e_error.warnings ;
   l_add_errors(lptr);
   continue ;
   }

     /* set size and initial opcode. */
     i = 1 ;
     switch ( numterms ) {
      case 0 :         /* make source and dest empty */
      i = is_validate ( &amp;size , command, 7, 5, 7, 5,
         &amp;opcode , &amp;sizeinwords, termlist , &amp;index );

      break;
      case 1 :         /* make source empty */
      i = is_validate ( &amp;size , command, 7, 5,
         termlist-&gt;modereg &gt;&gt; 8,
         termlist-&gt;modereg &amp; 15,
         &amp;opcode , &amp;sizeinwords, termlist , &amp;index );

      break;
      case 2 :
      i = is_validate ( &amp;size , command,
         termlist-&gt;modereg &gt;&gt; 8,
         termlist-&gt;modereg &amp; 15,
         termlist-&gt;next-&gt;modereg &gt;&gt; 8,
         termlist-&gt;next-&gt;modereg &amp; 15,
         &amp;opcode , &amp;sizeinwords, termlist , &amp;index );

      break;
      }

     if ( i ) {
       /* error occured while validating. attach it to listing and
     go on to next line */
       l_addline(l_neither, 0, line, &amp;lptr);
       prev_warnings = e_error.warnings ;
       l_add_errors(lptr);
       continue ;
       }

     /* do assembly if possible */

     /* process line label if there is one */
     if ( label[0] )
       if (sym_add_label_symbol(label,am_location_counter,am_assem_class)){
     l_addline(l_neither, 0, line, &amp;lptr);
     l_add_errors(lptr);
     prev_warnings = e_error.warnings ;
     am_delete_terms(&amp;termlist, TRUE) ;
     continue ;            /* skip to next source line. */
     }

     /* resolve already known symbols */
     for ( term = termlist ; term ; term = term-&gt;next )
       for ( sym = term-&gt;symptr ; sym ; sym = sym-&gt;next )
     if ( sym-&gt;sym[0] )
        sym_add_operand_symbol( sym, term, TRUE );


     l_addline( l_firstinstr, sizeinwords, line, &amp;lptr   );

     if ( e_error.out_of_memory ) {
   am_delete_terms(&amp;termlist,TRUE);
   break ;
   }

     /* its either an instruction or an error */
     if ( e_error.warnings &gt; prev_warnings )
   l_add_errors(lptr);
     prev_warnings = e_error.warnings ;

     if (termlist) {
   termlist-&gt;lineptr = lptr ;      /* hold onto line.*/
   if ( termlist-&gt;next )
      termlist-&gt;next-&gt;lineptr = lptr ;
   termlist-&gt;index   = index     ;  /* hold onto index.*/
   termlist-&gt;opcode  = opcode    ;  /* hold onto opcode.*/
   }

     l_writetoline(0,am_location_counter,0,lptr);
     l_writetoline(sizeinwords,0,3,lptr);      /* put '?' in listing.*/

     /* are all terms knowm? */
     if ( ! am_resolve_term(termlist,0) ) {
   am_backfill( termlist );

   if ( e_error.warnings &gt; prev_warnings )
      l_add_errors(lptr);
   prev_warnings = e_error.warnings ;

   am_location_counter += ( sizeinwords &lt;&lt; 1 ) ;
   am_delete_terms(&amp;termlist, TRUE) ;
   }
     else {
   am_add_terms_to_list( &amp;termlist );
   am_location_counter += ( sizeinwords &lt;&lt; 1 ) ;
   }

     }

  if ( e_error.out_of_memory ) {
   l_add_errors(l_line_head-&gt;prev);
   *error_count += e_error.state ;
   }

  /* Make sure all local and global symbols are resolved */
  e_error.state = 0 ;
  *error_count +=  sym_process_unresolved_locals() ;

  *warning_count = e_error.warnings ;

  /* Add symbol table to listing */
  sym_add_symtabtolisting();

 } /* am_pass1 */



<a name="01d8_0011"><a name="01d8_0011">
<a name="01d8_0012"></pre><B>[LISTING THREE]</B><pre><a name="01d8_0012">

/*
  68000 error handler module

*/

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#include &quot;68defs.h&quot;
#include &quot;68err.h&quot;


 struct e_struct e_error = { 0,0,0,0,FALSE, NULL, NULL };

 char e_hold_messages = TRUE ;
 e_printf_type e_printf ;

 /* Global error list array. */

 err_type   err_list[MAXERRORS] =
    {{ 1  , 0,&quot;Error 1. Unexpected end of line.&quot; ,NULL,NULL },
     { 2  , 0,&quot;Error 2. Unexpected symbol.&quot;,NULL,NULL },
     { 3  , 0,&quot;Error 3. Unexpected token char.&quot;,NULL,NULL },
     { 4  , 0,&quot;Error 4. Symbol/Literal contains invalid char.&quot;,NULL,NULL },
     { 10 , 0,&quot;Error 10. Command op size invalid.&quot;,NULL,NULL },
     { 11 , 0,&quot;Error 11. Invalid address mode.&quot;,NULL,NULL },
     { 12 , 0,&quot;Error 12. Unrecognized command.&quot;,NULL,NULL },
     { 13 , 0,&quot;Error 13. Command operands required.&quot;,NULL,NULL},
     { 14 , 0,&quot;Error 14. Forward references not allowed here.&quot;,NULL,NULL},
     { 15 , 0,&quot;Error 15. Too many operands.&quot;,NULL,NULL},
     { 16 , 0,&quot;Error 16. Line label required.&quot;,NULL,NULL},
     { 17 , 0,&quot;Error 17. Label found in external list.&quot;,NULL,NULL},
     { 18 , 0,&quot;Error 18. Label already resolved.&quot;,NULL,NULL},
     { 19 , 0,&quot;Error 19. Operand symbol already resolved.&quot;,NULL,NULL},
     { 21 , 0,&quot;Error 21. Address collision.&quot;,NULL,NULL},
     { 22 , 0,&quot;Error 22. Location counter is odd.&quot;,NULL,NULL},
     { 23 , 0,&quot;Error 23. Unresolved symbol.&quot;,NULL,NULL},
     { 30 , 0,&quot;Error 30. File not found or unable to open.&quot;,NULL,NULL },
     { 31 , 0,&quot;Error 31. Unexpected end of file.&quot;,NULL,NULL },
     { 33 , 0,&quot;Error 33. Disk full while writing file.&quot;,NULL,NULL},
     { 41 , 0,&quot;Error 41. Out of Dynamic memory.&quot;,NULL,NULL },
     { 50 , 0,&quot;Warning 50. Symbol too long. Truncated.&quot;,NULL,NULL},
     { 52 , 0,&quot;Warning 52. Value out of range.&quot;,NULL,NULL},
     { 70 , 0,&quot;Warning 70. Expression/Syntax imprecise.&quot;,NULL,NULL},
     { 71 , 0,&quot;Warning 71. Command op size not specified.&quot;,NULL,NULL},
     { 72 , 0,&quot;Warning 72. Line label not allowed. Ignored.&quot;,NULL,NULL},
     { 73 , 0,&quot;Warning 73. Command operands not allowed. Ignored.&quot;,NULL,NULL},
     { 74 , 0,&quot;Warning 74. Symbol already in global list. Ignored.&quot;,NULL,NULL},
     { 75 , 0,&quot;Warning 75. Symbol already in external list. Ignored.&quot;,NULL,NULL},
     { 100, 0,&quot;FSE 100. Invalid return from next_token.&quot;,NULL,NULL} };



/***************************************************************************
 Function e_message
      This function looks up the code in the errlist array, retrieves
      the standard message from the array, and inserts the message into
      the current errptr list .  It puts the additional message
      in the add_message field.

   Error code map :
     0..49  errors.
     50..99 warnings
     100..  fatal software errors.

 **************************************************************************/
 void  e_message( char    pos    ,
        char    code    ,
        char * add_mess)
 {
  err_type   * temp ;
  int          i    ;

  char * tmp;

  temp = NULL ;
  if ( e_hold_messages ) {
     temp = ( err_type * ) malloc ( sizeof(err_type) ) ;
     if ( !temp ) code = 41 ;  /* change code to that of 'out of memory' */
     }

  i = 0 ;
  while (( i &lt; MAXERRORS ) &amp;&amp; ( err_list[i].code != code )) i ++ ;

  if ( code == 41 )
     e_error.out_of_memory = TRUE ;

  if ( temp ) {
     temp-&gt;message = ( i &lt;= MAXERRORS ) ? err_list[i].message : NULL ;
     if ( *add_mess )
   temp-&gt;add_mess = ( char * ) strdup ( add_mess ) ;
     else
   temp-&gt;add_mess = NULL ;

     temp-&gt;code    = code ;
     temp-&gt;position= pos ;
     temp-&gt;next = NULL ;

     if ( !e_error.errptr ) {
   e_error.errptr = temp ;
   e_error.last   = temp ;
   }
     else {
       e_error.last-&gt;next = temp ;
       e_error.last = temp ;
       }
     }

  tmp = ( char * ) ( i &lt; MAXERRORS ) ? err_list[i].message : NULL ;

  if ( e_error.curpos )
    pos += e_error.curpos ;

  e_printf( tmp, add_mess );

  if ( ( code &lt; 50 ) || ( code &gt;= 100 ) ) {
     e_error.errors++ ;
     e_error.state++ ;
     }
  else
     e_error.warnings++;

 } /* e_message */



/***************************************************************************
 Procedure e_delete_errors
      This procedure deletes all the errors currently attached to
      e_error.errptr .

 **************************************************************************/
 void e_delete_errors()
 {
  err_type  * temp ;

  while ( e_error.errptr ) {
     temp = e_error.errptr-&gt;next ;
     if ( e_error.errptr-&gt;add_mess )
   free( e_error.errptr-&gt;add_mess ) ;
     free( e_error.errptr );
     e_error.errptr = temp ;
     }
 } /* e_delete_errors */



<a name="01d8_0013"><a name="01d8_0013">
<a name="01d8_0014"></pre><B>[LISTING FOUR]</B><pre><a name="01d8_0014">


/*
     68000 Instruction Set Module.
    This module contains those procedures needed to handle
    the instruction set.
*/

  #include &lt;stdio.h&gt;
  #include &lt;stdlib.h&gt;
  #include &lt;string.h&gt;

  #include &quot;68defs.h&quot;
  #include &quot;68err.h&quot;
  #include &quot;68parse.h&quot;
  #include &quot;68list.h&quot;
  #include &quot;68assem.h&quot;
  #include &quot;68instr.h&quot;

  #define LOCAL near pascal


  /************************************************************************
    is_validate
      This procedure validates an instruction. It first looks up the
      instruction mnemonic in the is_array, then determines if the
      source and destination are valid for the particular instruction.

      Input parameters :
     size     : size of the operation. i.e   ADD.W
     command : the instruction mnemonic string.
      Variable parameters
     opcode  : the base operation code determined

     termlist : updates sizeofreserve field

     index   : the instruction array index for the instruction
      Return code :
     0       : instruction addr mode is valid.
     otherwise : error occured. Returned in error list.
   ************************************************************************/

  int   is_validate ( p_size_type *  size   ,
            char     *  command,
            char        smode  ,
            char        sreg   ,
            char        dmode  ,
            char        dreg   ,
            unsigned int * opcode ,
            char      * total_size ,
            am_term_type * termlist ,
            unsigned int * index    )

  {

    /* error if destination is not specified */
    if ( (dmode==7) &amp;&amp; ( dreg==5 ) ) {
   e_message(0,11,&quot; Destination operand required.&quot;);
   return 11 ;
   }

    *total_size = 1 ;
    /* lookup command */
    if (  ! strcmp(command,&quot;MOVE&quot;)  ) {
       /* error if source is not specified */
       if ( (smode==7) &amp;&amp; ( sreg==5 ) ) {
     e_message(0,11,&quot; Source operand required.&quot;);
     return 11 ;
     }
       if ( *size == p_unknown ) {
     /* assign default size if it's unknown */
     e_message(0,71,&quot; Assumed Long.&quot;);
     *size = p_long ;
     }

       termlist-&gt;sizeofreserve=am_abs_address_size ;
       termlist-&gt;next-&gt;sizeofreserve=am_abs_address_size ;
       *total_size += ( am_abs_address_size &lt;&lt; 1 );

       *opcode =  (dreg &lt;&lt; 9 ) | ( dmode &lt;&lt;6 ) | ( smode &lt;&lt;3 ) | sreg ;
       *opcode |= ( *size == p_long )? 0x2000: (*size==p_word)? 0x3000:0x1000;
       *index = 0;
       }
    else if (  ! strcmp(command,&quot;JMP&quot;)  ) {
       *opcode =  0x4EC0 | ( dmode &lt;&lt; 3 ) | dreg ;
       termlist-&gt;sizeofreserve=am_abs_address_size ;
       *total_size += am_abs_address_size ;
       *index = 1 ;
       }
    else {
       e_message(0,12,command);
       return 12 ;
       }

    return 0 ;

  } /* is_validate */




<a name="01d8_0015"><a name="01d8_0015">
<a name="01d8_0016"></pre><B>[LISTING FIVE]</B><pre><a name="01d8_0016">


/*
    68000 listing module.
*/

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;time.h&gt;
#include &lt;ctype.h&gt;

#include &quot;68defs.h&quot;
#include &quot;68err.h&quot;
#include &quot;68list.h&quot;


 /* These are considered module level variables. */
 l_line_type *   l_line_head = NULL ;
 char        *   l_header    =
  &quot; Generic Assembler Version 1.0 :                            &quot;;
 char        *   l_blanks    = &quot;                        &quot; ;
 int      l_number_of_lines = 0 ;

/****************************************************************************
  Function l_addline
     This funciton adds a line at the end of the line listing.
     It does this according to the class of the line :
   l_firstinstr : It creates a node for the text of the
             line to be held in.  It concats a blank
             leader before the text to hold the address
             and opcode. If there are more than two words
             in the instruction, then an additional
             line node in created.
   l_data        : It creates a node,and concats a blank leader onto
             the text line.

   Form of instruction line :
        blanks      line text
   addres |      |
first-&gt; 000000    0000 0000 0000 Lable   command  operand text
   0--------------------23
other-&gt;     0000 0000
   0--------------------23
  NOTE :
     This routine copys the line text, so that the caller may reuse the
     line, or discard it with out affecting the listing.

  Input parameters :
     class   : the class of line to be added.
     numofwords : number of words in the instrcuction if its an
        instruction line.
     line   : the text of the line to be placed in the listing.

  Variable parameters :
     lineptr   : pointer to the line which was added to the listing.

  Return
     0   : line added okay.
     41 : out of memory

 **************************************************************************/
 int  l_addline( l_lclass_type     class      ,
       char        numofwords ,
       char      * line        ,
       l_line_type   ** lineptr    )
{
 l_line_type  * curline , * tcurline ;
 register int   i ;
 long      secs ;

 *lineptr = NULL ;
 curline = NULL ;
 curline = ( l_line_type * ) malloc ( sizeof(l_line_type) ) ;

 if ( !curline ) {
    e_message(0,41,&quot; Listing &quot; ) ; /* out of memory */
    return 41 ;
    }

 curline-&gt;lclass = class ;
 curline-&gt;linenum = ( class != l_firstinstr ) ? 0 :l_number_of_lines++ ;

 if ( !l_line_head ) {
    l_line_head = ( l_line_type * ) malloc ( sizeof(l_line_type));
    if (!l_line_head){
      e_message(0,41 ,&quot; Listing &quot; ) ; /* out of memory */
      return 41 ;
      }
    l_line_head-&gt;line = l_header ;
    time(&amp;secs);
    strcpy ( ((l_line_head-&gt;line)+32), asctime( localtime(&amp;secs) ) );
    i = strlen(l_line_head-&gt;line);
    for(;!isprint(l_line_head-&gt;line[i]);i--) l_line_head-&gt;line[i]=0;
    l_line_head-&gt;lclass = l_data ;
    l_line_head-&gt;linenum = 0 ;
    l_line_head-&gt;next = l_line_head ;
    l_line_head-&gt;prev = l_line_head ;
    }

 curline-&gt;line = ( char * ) malloc(  25 + strlen(line) );
 if ( !(curline-&gt;line) ) {
    e_message(0,41 ,&quot; Listing &quot; ) ; /* out of memory */
    free(curline);
    return 41 ;
    }

 curline-&gt;next = l_line_head ;
 curline-&gt;prev = l_line_head-&gt;prev ;
 l_line_head-&gt;prev = curline ;
 curline-&gt;prev-&gt;next = curline;


 if ( class != l_neither ) {
    memset( (curline-&gt;line) ,'0', 6 );
    memset( ((curline-&gt;line)+6),' ',18 );
    }
 else
    memset( (curline-&gt;line) ,' ',24);

 strcpy( ((curline-&gt;line)+24) ,line);

 tcurline = curline ;

 if ( numofwords &gt; 3 ) {
    /* allocate post lines for either instr or data */
    i = (numofwords - 3) / 3 ;
    if ( (numofwords - 3) % 3  ) i++ ;
    for ( ; i ; i-- ) {
       curline = ( l_line_type * ) malloc ( sizeof(l_line_type) ) ;
       if ( !curline ) {
     e_message(0,41 , NULL ) ; /* out of memory */
     return 41 ;
     }
       curline-&gt;next = l_line_head ;
       curline-&gt;prev = l_line_head-&gt;prev ;
       l_line_head-&gt;prev = curline ;
       curline-&gt;prev-&gt;next = curline;

       curline-&gt;line = strdup( l_blanks );
       if ( !(curline-&gt;line) ) {
     e_message(0,41 , NULL ) ; /* out of memory */
     return 41 ;
     }

       curline-&gt;lclass = ( class == l_firstinstr ) ? l_otherinstr:l_data ;
       curline-&gt;linenum =( class == l_firstinstr ) ? l_number_of_lines++ : 0 ;

       }

    }

 *lineptr = tcurline ;
 return 0 ;

} /* l_addline */



/****************************************************************************
  Function l_writetoline
     This funciton writes to a line in the listing, assuming it's
     already been created.
     It does this by refering to specific elements in the address opcode
     field by identifiers such as :
       0 : write 6 hex degit address field
       1 : write the 4 hex degit opcode/data field  for word 1 .
       2 : write the 4 hex degit opcode/data field  for word 2 .
       etc..
     It takes the data to be written ( whether address/data/opcode ) from
     the unsigned long parameter called :
   VALUE
     The option specifies special operations as follows :
       0 : write only one number as specified by spec .
       1 : write question marks in field for only one field specified by spec.
       2 : write repeated number over all post words up to the
      field specified by spec. ( spec 0 is ignored. )
       3 : write repeated question marks over all post words up to the
      field specified by spec. ( spec 0 is ignored. )
       4 : write only one byte at location specified by spec.

  Input parameters :
     spec   : the specification number as described above.
     value   : the value to be written on the line.
     option   : flag indicated if question marks are to be printed.
     line   : pointer to the listing node containing the first line.

 **************************************************************************/
 void   l_writetoline( int      spec      ,
             unsigned long   value      ,
             char      option      ,
             l_line_type    * line      )
{
 register int  i       ;
 char        * curline ;


 if ( !line ) return ;

 if ( !spec ) {
    if ( option )
       strnset(line-&gt;line,'?',6);
    else {
       sprintf(line-&gt;line,&quot;%06X&quot;,value);
       *(line-&gt;line+6) = ' ' ;
       }
    }
 else {
    i = ( spec - 1 ) / 3 ;
    for (  ; i ; i-- , line = line-&gt;next ) {
   if ( option == 2 ) {
      sprintf(line-&gt;line+6,&quot;   %04X %04X %04X&quot;,( int ) value,
         ( int ) value, ( int ) value );
      *(line-&gt;line+23) = ' ';
      }
   else if ( option == 3 )  {
      sprintf(line-&gt;line+6,&quot;   ???? ???? ????&quot; );
      *(line-&gt;line+23) = ' ';
      }
   }

    i = ( spec - 1 ) % 3  ;
    curline = line-&gt;line + 9 ;
    for ( ; i ; i-- , curline += 5 ) {
   if ( option == 2 )  {
      sprintf( curline,&quot;%04X&quot;,( unsigned int ) value);
      *(curline+4) = ' ';
      }
   else if ( option == 3 )
      strnset( curline,'?',4 );
   }
    if ( ( option == 0 ) || ( option == 2 ) )  {
       sprintf(curline,&quot;%04X&quot;, ( unsigned int ) value ) ;
       *(curline+4)=' ';
       }
    else if ( option == 4 ) {
       sprintf(curline,&quot;%02X&quot;, ( unsigned char ) value );
       *(curline+2)=' ';
       }
    else
       strnset(curline,'?',4);
    }

} /* l_writetoline */


/****************************************************************************
  Function l_add_errors
     This funciton writes all the error messages attached to e_error.errptr
     to the listing, then deletes the error list.
  Input
     lptr  : pointer to the line in the listing after which the
        errors should be attached.

 **************************************************************************/
 void   l_add_errors ( l_line_type * lptr )
 {
  l_line_type   * tlptr ;
  err_type   * error ;
  char        relink_list ;
  char        message_buf[100] ;

  if ( !lptr )   /* if lptr == NULL */
      lptr = l_line_head-&gt;prev ;

  /* if lptr at end of list do not bother relinking listing.*/
  relink_list = ( lptr-&gt;next != l_line_head ) ;

  for ( error = e_error.errptr ; error ; error = error-&gt;next ) {
     strcpy( message_buf , error-&gt;message ) ;
     strcpy( message_buf+strlen(error-&gt;message), error-&gt;add_mess );
     l_addline(l_neither, 0, message_buf , &amp;tlptr );
     if ( relink_list ) {
   /* unlink the  line */
   tlptr-&gt;next-&gt;prev = tlptr-&gt;prev ;
   tlptr-&gt;prev-&gt;next = tlptr-&gt;next ;

   /* link the line into listing after the source line at lptr */
   tlptr-&gt;next = lptr-&gt;next ;
   tlptr-&gt;next-&gt;prev = tlptr ;
   tlptr-&gt;prev = lptr ;
   lptr-&gt;next = tlptr ;
   }
     }
  e_delete_errors() ;

 } /* l_add_errors */


/****************************************************************************
  Function l_printlisting
     This funciton writes all the listing lines into the text file
     passed in as outfile. It assumes the file was already opened
     for text output. It will stop writing if an error occurs
     while writing.
  Input
     outfile : the already opened file that the listing is written to.
     withheader : TRUE if list header is to be written first.
        FALSE if list header not to be written at all.
  Return
     0 : okay.
     33: error while writing to file.

 **************************************************************************/
int  l_printlisting( FILE * outfile, char withheader )
{
 l_line_type * curline ;

 if ( withheader )
    fprintf(outfile,&quot;%s\n&quot;,l_line_head-&gt;line);

 for ( curline = l_line_head-&gt;next ; curline != l_line_head ;
       curline = curline-&gt;next ) {
      if ( (curline-&gt;lclass != l_neither)&amp;&amp;(curline-&gt;lclass != l_data) ) {
   if ( fprintf(outfile,&quot;%3d %s\n&quot;,curline-&gt;linenum,
           curline-&gt;line) == EOF ) {
      e_message(0,33,NULL);
      return 33 ;
      }
   }
      else if ( fprintf(outfile,&quot;    %s\n&quot;, curline-&gt;line) == EOF ) {
    e_message(0,33,NULL);
    return 33 ;
    }
      }
 return 0 ;

} /* l_printlisting */


/****************************************************************************
  Function l_delete_listing
     This funciton deletes the entire listing, and resets all of
     its associated pointers back to their default values.
  Input
     deletehead : TRUE if head is to be deleted too.
        FALSE if head to be left alone.
     resetcount : TRUE if l_number_of_lines should be reset.


 **************************************************************************/
void l_delete_listing( char deletehead , char resetcount )
{
 l_line_type * curline, * tline ;

 if ( resetcount ) l_number_of_lines = 0 ;

 if ( l_line_head )  {
    l_line_head-&gt;prev-&gt;next = NULL ;
    curline = l_line_head-&gt;next ;

    l_line_head-&gt;next = l_line_head ;
    l_line_head-&gt;prev = l_line_head ;
    if ( deletehead ) {
       free(l_line_head);
       l_line_head = NULL ;
       }
    while ( curline ) {
     tline = curline-&gt;next ;
     if ( curline-&gt;line ) free( curline-&gt;line );
     free( curline );
     curline=tline ;
     }
    }

} /* l_delete_listing */



<a name="01d8_0017"><a name="01d8_0017">
<a name="01d8_0018"></pre><B>[LISTING SIX]</B><pre><a name="01d8_0018">


/*
    68000 math module.
*/

#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;ctype.h&gt;

#include &quot;68defs.h&quot;
#include &quot;68err.h&quot;
#include &quot;68parse.h&quot;


/****************************************************************************
  Function strtolong
     This funciton converts a string of base to a long integer.

     It behaves the way that STRTOL is supposed to.

     Example
       num = strtolong(&quot;101&quot;, &amp;endptr, 2);
       gives num = 5 ;

  Input parameters :
     str  : the string of valid numberic ascii characters
     endptr : if no error points to end of string .
         if error it points to error location in string.
     base : the base of the string : either 2, 8, 16, or 10
 **************************************************************************/
 unsigned long int strtolong ( register char   *  str     ,
                char      ** endptr ,
                char         base   )

{
   unsigned long int  sum  = 0L ;
   register char shift ;

   switch ( base ) {
     case 10 : for (; *str ; str++)
       if ( isdigit(*str) )
          sum = ( sum * 10 ) + ( *str - '0' ) ;
       else {
          *endptr = str ;
          return 0 ;
          }
          *endptr = str ;
          return sum ;
     case 2  : shift = 1 ; break ;
     case 8  : shift = 3 ; break ;
     case 16 : shift = 4 ; break ;
     }

   for (; *str ; str++ )
      if ( isdigit ( *str ) &amp;&amp;
     (  ( base == 10 ) || ( base == 16 ) ||
        ( (base == 2) &amp;&amp; ( *str == '0' || *str == '1' ) ) ||
        ( (base == 8) &amp;&amp; ( *str &lt;= '7' &amp;&amp; *str &gt;= '0' ) ) ) )
    sum  = (  sum &lt;&lt; shift  ) | ( *str - '0' ) ;
      else if ( isxdigit (*str) &amp;&amp; ( base == 16 ) )
    sum  = ( sum &lt;&lt; shift ) | ( toupper(*str) - 'A' + 10 ) ;
      else {
    *endptr = str ;
    return 0 ;
    }

   *endptr = str ;
   return sum ;

} /* strtolong */



/***************************************************************************
 Function m_symtoval

    This function converts a valid numerical symbol string to its
    corresponding long value. It follows the format below :
   All symbols which start with an 0..9,%,@,$,&quot; are numerical symbols.
   All others are ordinary symbols.

   Numeric
       $ddd  -Hex    %ddd - Binary     @ddd - Octal    ddd - Decimal
        daaH     dddB         dddO     dddD
                  dddQ

       '4444' - Quoted literal of max 4 Ascii characters.


     0   : a valid number is returned
     4   : an invalid char was found in symbol
     otherwise its not a valid number, although it may be a valid symbol.

 ***************************************************************************/
int    m_symtoval( char * sym , unsigned long int  * value )

{
  char     symbol[MAXSYMLEN] ;
  char     ch , * last , base ;


  strncpy( symbol, sym, MAXSYMLEN );  /* make a local pass by value symbol*/
  symbol[MAXSYMLEN-1] = 0 ;

  last = symbol+strlen(symbol)-1 ;
  *value = 0L ;

  if ( isdigit( ch=*symbol ) )
     switch ( toupper( *last )   ) {
       case 'H' : *last = 0 ; base = 16 ; break ;
       case 'B' : *last = 0 ; base = 2  ; break ;
       case 'Q' :
       case 'O' : *last = 0 ; base = 8  ; break ;
       case 'D' : *last = 0 ;
       default   :  base = 10 ; break ;
       }
  else {
     switch ( ch ) {
   case '$' : symbol[0] = '0' ; base = 16 ; break ;
   case '@' : symbol[0] = '0' ; base = 8 ; break ;
   case '%' : symbol[0] = '0' ; base = 2 ; break ;
   case '\'':
         /* scan line until next ' */
         last = strchr( symbol+1, '\'');
         if ( !(*last) ) {
            e_message(0,51,&quot;End quote expected.&quot;);
            last = symbol+5 ;
            }
         *last = 0 ;
         if ( last - symbol  &gt; 5 ) {
             e_message(0,51,NULL);
             symbol[5] = 0 ;
             }
         for ( last = symbol+1 ; *last ; last++ )
             *value = ( *value &lt;&lt; 8 ) | *last ;
         return 0 ;
   default  : return 1 ;
   }
     }

     *value = ( unsigned long int ) strtolong( symbol, &amp;last , base );
     if ( *last ) e_message(0,4,NULL);
     return  ( *last  ) ? 4 : 0 ;

} /* m_symtoval */





<a name="01d8_0019"><a name="01d8_0019">
<a name="01d8_001a"></pre><B>[LISTING SEVEN]</B><pre><a name="01d8_001a">


/*
    68000 parser module.
*/


#include &lt;stdio.h&gt;
#include &lt;alloc.h&gt;
#include &lt;string.h&gt;
#include &lt;ctype.h&gt;

#include &quot;68defs.h&quot;
#include &quot;68err.h&quot;
#include &quot;68parse.h&quot;
#include &quot;68list.h&quot;
#include &quot;68assem.h&quot;
#include &quot;68math.h&quot;

#define LOCAL near pascal

   typedef enum { symbol, token, none } p_tok_type ;

   typedef enum {  pn_sym   ,        /* sym */
         pn_empty ,        /* empty parse node. */
         pn_error        /* error */
      } p_addr_type ;

   typedef struct {
         p_addr_type    p_nodeclass;/* tag field */
         char     regnum   ;
         p_sym_type *  symptr  ; /* symbol list, if any. */
        } p_node_type ;



    char     symchars[38] = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890_&quot; ;

    p_sym_type     curtoksym ;      /* current token symbol from next_token */
    char     curtok ;      /* current token character from next_token*/


 /* Function prototypes for local functions */

 static p_tok_type LOCAL next_token( char * line     , int  * line_offset  ,
                 int    line_len );

 static int LOCAL  p_symbol ( char *     line      , int  * line_offset   ,
               int     line_len , char   symknown     ,
               char     preop    , p_sym_type ** symptr ,
               p_node_type * p_node   );

 static p_size_type LOCAL p_dotsize ( char * line    ,
                  int  * line_offset ,
                  int    line_len ,
                  int    prev_offset );
 static void LOCAL p_parse_line ( char *   line     , int  * line_offset    ,
              int      line_len , p_node_type *  p_node ,
              char *   done     );




/************************************************************************

 Function next_token  - get next token

    This function returns the next token in the text line from
    the current line offset.  If rest of line is blank, or if
    line offset is at end of line, then it returns an end of line
    indicator.

    Input parameters :
       line       - the line to be parsed.
       line_offset  - the current offset into the line.
       line_len     - the line length. ( so as to avoid calling strlen )

    Calls :
      p_symtype : to reclassify symbols .

    Warnings : e_message called as warnings occur.
      50 : Symbol too long

    Globals :
      curtoksym
      curtok

    Return value :
      symbol : symbol found.  Is located in curtoksym.
      token  : token found.   Token character is in curtok.
      none   : end of line found.

 *************************************************************************/
  static p_tok_type LOCAL next_token( char * line     , int  * line_offset  ,
                  int    line_len )

{
  char          * tokpos, * tline ;
  int          symlen  ;


  (*line_offset) += strspn( line + *line_offset , &quot; \t&quot;);  /* skip blanks */

  if ( *line_offset &gt;= line_len )
     return none ;

  tline = line + *line_offset ;

  if ( *tline == '\'') {
     tokpos = strchr( tline+1, '\'');      /* scan for next quote.*/
     if ( *tokpos )            /* if found set tok one further. */
   tokpos++ ;            /* if not , set to shortest of   */
     else               /* (5 forward or the end)       */
   tokpos = ( tokpos - tline &gt; 5 ) ? tline + 5 : tokpos ;
     }
  else
    tokpos = strpbrk( tline, &quot;.;-+()#/, \&quot;\t&quot;);


  if ( tokpos != tline ) {
     /* return symbol between start of line and tokpos. */
     if ( !(*tokpos) ) tokpos = line + line_len ;  /* correct for NULL */
     symlen = tokpos - tline ;
     (*line_offset) += symlen;
     if ( symlen &gt;= MAXSYMLEN ) e_message(*line_offset,50,NULL);
     symlen = ( symlen &gt;= MAXSYMLEN ) ? MAXSYMLEN - 1 : symlen ;
     strncpy( curtoksym.sym, tline, symlen ) ;
     curtoksym.sym[symlen] = 0 ;

     if ( isalpha(curtoksym.sym[0] ) )
   if ( strspn( curtoksym.sym, symchars ) == symlen )
      return symbol ;
   else {
      e_message(*line_offset,4,NULL);
      return symbol ;
      }

     e_error.curpos = *line_offset ;
     if ( ( !m_symtoval(curtoksym.sym,&amp;curtoksym.val ) ) &amp;&amp;
     ( !e_error.state ) )
     curtoksym.sym[0] = 0 ;
     e_error.curpos = 0 ;

     return  symbol ;
     }
  else
     {
     /*  the token is at the start of the line. */
     curtok = *tline ;
     (* line_offset ) ++ ;
     return token ;
     }

} /* next_token */



/***************************************************************************

 Function p_symbol  - parse symbol

    This function parses a symbol into its components following the
    diagram :

       symbol --&gt; operator ---&gt;
     ^          |
     |-----------------|

       symbol    - any valid non-key word of SYMMAXLEN length or less.
       operator  -  plus  '+'
          minus '-'

       If an unrecognized operator is encountered, the symbol chain
     is assumed to have come to an end.  The last token is then
     un-read, so that it can be re-read by subsequent parse code.

    Input parameters :
       line       - the line to be parsed.
       line_offset  - the current offset into the line.
       line_len     - the line length. ( so as to avoid calling strlen )
       symknown     - flag ( TRUE or FALSE ) which indicates whether
            the initial symbol was already parsed.

    Note : calls e_message to print errors as it recurses up.

    Warnings : e_message called as warnings occur.
      51 : literal too long

    Return code :
      0 : okay
      1 : Unexpected eoln
      2 : Unexpected symbol.
      3 : Unexpected token char.
      41  : Out of dynamic memory.
      100 : Invalid return from next token.
 **************************************************************************/
 static int LOCAL  p_symbol ( char *     line      , int  * line_offset   ,
               int     line_len , char   symknown     ,
               char     preop    , p_sym_type ** symptr ,
               p_node_type * p_node   )
{
  p_tok_type   tok ;
  int          i ;


  if ( symknown )
     tok = symbol ;
  else
     tok = next_token( line , line_offset , line_len) ;

  switch ( tok ) {
     case symbol : /* Symbol was found */
         *symptr = ( p_sym_type * ) malloc ( sizeof(p_sym_type));
         if ( ! (*symptr) ) {   /* if *symptr == NULL */
            e_message(0,41,&quot; Parser &quot;);
            return 41 ;
            }

         memcpy( (*symptr) , &amp;curtoksym, sizeof(p_sym_type) );
         (*symptr)-&gt;operator = preop ;
         (*symptr)-&gt;next = NULL ;

         i = *line_offset ; /* hold onto line offset */

         tok = next_token( line , line_offset , line_len);
         switch ( tok ) {
           case token :
           switch ( curtok ) {
              case '+' :
              case '-' :
             i = p_symbol( line, line_offset,
                  line_len, FALSE, curtok,
                  &amp;( (*symptr)-&gt;next ), p_node);
             return i ;
              default  :
             /* un-get the token. */
             *line_offset = i ;
             return 0;
             }
           case symbol : e_message(*line_offset,2,NULL);
               return 2 ;
           case none    : return 0 ;
           default    : e_message(*line_offset,100,&quot;p_symbol&quot;);
               return 100 ;
           }
     case token  : e_message(*line_offset,3,NULL);
         return 3 ;
     case none    : e_message(*line_offset,1,NULL);
         return 1 ;
     default    : e_message(*line_offset,100,&quot;p_symbol&quot;);
         return 100 ;
     }

} /* p_symbol */



/**************************************************************************
 Function p_dotsize
    This function parses a dot size field and returns the size as a type.
    It expects that the current token is a token/delemeter and not a symbol

    If the curtok is not a '.' it unreads it and returns p_unknown.
    If the curtok is a '.' it follows :
   .B  -- returns p_byte
   .W  -- returns p_word
   .L  -- returns p_long
   . anything else -- returns p_unknown, and unreads the last token
            excluding the period.  It also prints out the
            warning that the period was ignored.

 **************************************************************************/
 static p_size_type LOCAL p_dotsize ( char * line    ,
                  int  * line_offset ,
                  int    line_len ,
                  int    prev_offset )
{
  p_tok_type  tok     ;

  if ( curtok == '.' ) {
    prev_offset = *line_offset ;
    tok = next_token( line , line_offset, line_len);
    if ( (tok == symbol )&amp;&amp;
    ( curtoksym.sym[1] == NULL ) )
       switch ( curtoksym.sym[0] ) {
     case 'B': return p_byte ;
     case 'W': return p_word ;
     case 'L': return p_long ;
     }
    e_message(prev_offset,70,&quot; '.' ignored.&quot;);
    *line_offset = prev_offset ;
    return p_unknown ;
    }
  else {
    *line_offset = prev_offset ;
    return p_unknown ;
    }
} /* p_dotsize */



/***************************************************************************

 Function parse_line - parse line

    This function parses a line into its components following the
    diagram :

     &lt;---------------------------feedback------------|
    |                       |
    |  symbol ---&gt; p_symbol  ------------------&gt;','--|
                 |----&gt;';'----&gt;
                 |----&gt;eoln---&gt;
                 |----&gt;error--&gt;

       symbol          - any valid key word of SYMMAXLEN length or less.
       string literal  - quoted string. &quot;example of string.&quot;
       eoln          - end of line reached
       error          - error in parsing

    Input parameters :
       line       - the line to be parsed.

 **************************************************************************/
 static void LOCAL p_parse_line ( char *   line     , int  * line_offset    ,
              int      line_len , p_node_type *  p_node ,
              char *   done     )
{
  p_tok_type   tok ;

  tok = next_token( line , line_offset , line_len) ;
  p_node-&gt;p_nodeclass = pn_empty ;
  p_node-&gt;symptr = NULL ;

  switch ( tok ) {
     case symbol :
         p_node-&gt;p_nodeclass = pn_sym ;
         p_symbol(line, line_offset, line_len , TRUE,
             '+',&amp;(p_node-&gt;symptr),p_node );
         break;
     case token  : switch ( curtok ) {
            case ';' : *done = TRUE ;  /* Comment found */
             break;
            default  : e_message(*line_offset,3,NULL);
             *done = TRUE ;
             break;
            }
         break ;
     case none    : *done = TRUE ;   /* End of line found */
         break ;
     default    : e_message(*line_offset,100,NULL);
     }

  *done = ( e_error.state ) ? TRUE:*done ;

  if ( ! *done ) {
  tok = next_token( line , line_offset , line_len) ;
  switch ( tok ) {
     case symbol :
      e_message(*line_offset,2,curtoksym.sym); /* Unexpected symbol */
      *done = TRUE ;
      break ;
     case token  :
      switch ( curtok ) {
         case ',' : break;
         case ';' : *done = TRUE ;              /* Comment found */
          break;
         default  : e_message(*line_offset,3,&quot; ',' or ; exp.&quot;);
          *done = TRUE ;
          break;
         }
      break ;
     case none    : *done = TRUE ;   /* End of line found */
         break ;
     default    : e_message(*line_offset,100,NULL);
         *done = TRUE ;
     }
  }

  if ( e_error.state ) p_node-&gt;p_nodeclass = pn_error ;

} /* p_parse_line */



/***************************************************************************
   Function p_assem_line

     This function returns parses one line into a list of terms.

     Input parameters :
   line  : the line of source text to be parsed.

     Variable parameters
   label    : the label found for the line.
   command  : the command found on the line.
   size    : the size specification of the command. ie. MOVE.B is p_byte.
   numterms : the number of terms parsed.
   termlist : the term list in order of parsing

 **************************************************************************/
 void p_assem_line ( char      * line          ,
           char        label[MAXSYMLEN]  ,
           char        command[MAXSYMLEN],
           p_size_type   * size          ,
           char      * numterms          ,
           am_term_type ** termlist          )

 {
  register int    i   ;
  int       line_offset = 0, line_len;
  char       done   ,  mode,  reg ;
  am_term_type * term , * prev ;
  p_tok_type    tok   ;
  p_node_type    p_node ;        /* current parse node. */

  e_error.state = 0 ;

  /* clear the parameters */
  label[0] = 0 ;
  command[0] = 0 ;
  *size = p_unknown ;
  *numterms = 0 ;
  *termlist = NULL ;

  line_len = strlen(line) ;

  /* read the line label */
  if ( isalpha( line[0] ) ) {
      /* scan the line to remove the label string. */
      tok = next_token( line , &amp;line_offset , line_len) ;
      if (tok == symbol)
    strncpy( label,curtoksym.sym,MAXSYMLEN );
      }

  /* read the command */
  i = line_offset ;
  tok = next_token( line , &amp;line_offset , line_len) ;
  switch ( tok ) {
     case symbol : strncpy(command,curtoksym.sym,MAXSYMLEN);
         /* check for size identifier */
         i = line_offset ;
         tok = next_token( line , &amp;line_offset , line_len) ;
         switch ( tok ) {
            case symbol : line_offset = i ; break ;
            case token  : *size = p_dotsize(line,&amp;line_offset,
                        line_len,i);
                break;
            case none   : line_offset = i ; break ;
            }
         break ;
     case token  :
     case none    : line_offset = i; break ;
     }

  i = 0 ;
  done = FALSE ;
  while ( ! done ) {
     p_parse_line( line, &amp;line_offset,line_len,&amp;p_node,&amp;done);
     if ( e_error.state ) break ;
     if ( p_node.p_nodeclass == pn_empty ) break ;

     switch ( p_node.p_nodeclass ) {
   case  pn_sym   : mode = 7 ;
          reg = ( am_abs_address_size == 1 )?0:1 ; break ; /* sym   */
   case  pn_empty : mode = 7 ; reg = 5    ; break ; /* empty/none*/
   case  pn_error : mode = 7 ; reg = 11    ; break ; /* error  */
   }

     term = ( am_term_type * ) malloc ( sizeof( am_term_type ) ) ;
     if ( !term ) {
    e_message(0,41,&quot;Parser&quot;);   /* not enough memory */
    break ;
    }

     term-&gt;modereg = ( mode &lt;&lt; 8 ) | reg ;
     term-&gt;symptr = p_node.symptr ;
     term-&gt;next = NULL ;
     term-&gt;prev = NULL ;
     term-&gt;sizeofreserve = 0 ;
     term-&gt;postword = 0 ;
     term-&gt;class = am_other_instr_term ;

     (*numterms)++ ;
     if ( !(*termlist) )  /* if termlist = NULL */
       *termlist = term  ;
     else {
       term-&gt;prev = prev ;
       prev-&gt;next = term ;
       }
     prev = term ;

     } /* while */

  if ( *termlist )
     (*termlist)-&gt;class = am_first_instr_term ;

 } /* p_assem_line */




<a name="01d8_001b"><a name="01d8_001b">
<a name="01d8_001c"></pre><B>[LISTING EIGHT]</B><pre><a name="01d8_001c">


  /*
     68000 Pseudo Module.
    This module contains those procedures needed to handle
    psuedo command assembly.
  */

  #include &lt;stdio.h&gt;
  #include &lt;stdlib.h&gt;
  #include &lt;string.h&gt;

  #include &quot;68defs.h&quot;
  #include &quot;68err.h&quot;
  #include &quot;68parse.h&quot;
  #include &quot;68list.h&quot;
  #include &quot;68assem.h&quot;
  #include &quot;68symtab.h&quot;
  #include &quot;68pseudo.h&quot;


  typedef struct  {  char      pseudo[10];
           ps_pseudos    index  ;
        } ps_pseudo_type ;

  ps_pseudo_type  ps_pseudo_array [7] =
             { { &quot;ABS_LONG&quot;  , ps_abslong } ,
               { &quot;ABS_SHORT&quot; , ps_absshort} ,
               { &quot;END&quot;       , ps_end     } ,
               { &quot;EQU&quot;       , ps_equate  } ,
               { &quot;EXTERN&quot;    , ps_extern  } ,
               { &quot;GLB&quot;       , ps_global  } ,
               { &quot;ORG&quot;       , ps_origin  } } ;



/***************************************************************************
   Function ps_lookup_pseudo

     This function looks up a pseudo command in the pseudo array and
     returns the psuedo class type if it is a valid pseudo command.

     Input parameter :
   pseudo   : the pseudo command being looked up.
     Variable parameter :
   pseudo_class : the class which is returned.

     Return code
   0 : pseudo not found.
   1 : pseudo found.

 **************************************************************************/
 int ps_lookup_pseudo ( char      * pseudo     ,
         ps_pseudos * pseudo_class )
 {
  ps_pseudo_type * indx ;

  if ( indx = ( ps_pseudo_type * ) bsearch( pseudo, ps_pseudo_array, 7,
                 sizeof(ps_pseudo_type),strcmp) ){
     *pseudo_class = indx-&gt;index ;
     return 1 ;
     }
  else
     return 0 ;

 } /* ps_lookup_pseudo */


/***************************************************************************
   Function ps_one_symbol_only

     This function returns true if the symbol list contains only one
     symbol, and no literals.  Otherwise, it returns false.

     For an empty list it returns false.

     Used by am_pseudo for EXTERNAL and GLOBAL operand validation.

     Input parameter :
   symlist : the symbol list

 **************************************************************************/
 int ps_one_symbol_only ( p_sym_type * symlist )
 {
   if ( symlist )
      if ( symlist-&gt;next )
    return FALSE ;
      else
    if ( symlist-&gt;sym[0] )
       return TRUE ;
    else
       return FALSE ;
   else
     return FALSE ;
 } /* ps_one_symbol_only */



/***************************************************************************
   Function ps_validate_pseudo

     This function validates the pseudo commands depending on the
     parameters passed in as listed below :
    Note : each action is based on a TRUE value for the variable.
    locationeven    : If location counter not even then error.
    onetermonly    : If number of terms not equal to one then an
            error results.
    zeroterms    : If number of terms &gt;= 1 then error.
    labelrequired    : If there is no label then error.
    ignorlable    : If there is a label then warning.
    forwardsallowed : If symbols are forward referenced then no error
            else error
    stringsallowed  : If a term is found which is a string then
             no error is issued.
    onesymbolonly    : Each term can only have one unresolved symbol
            in it or an error will result.

  Input parameters :
    label     : pointer to label found on current line.
    numterms : the number of terms in the termlist.

  Variable parameter
    termlist : Pointer to the term list.  The termlist is
          deleted in the event of an error.

  Note : On any error, the termlist is completely deleted, and
    the appropriate error message is in the error list created
    by e_message.

  Return code
     0   : validated.
     other : error in validation.

 **************************************************************************/
 int  ps_validate_pseudo ( char     * label    ,
            char       numterms ,
            am_term_type ** termlist ,
            char       onetermonly     ,
            char       zeroterms     ,
            char       forwardsallowed,
            char       labelrequired  ,
            char       ignorlabel     ,
            char       stringsallowed ,
            char       onesymbolonly  )

 {
  am_term_type * term ;
  p_sym_type   * sym  ;
  int       i   , mode, reg  ;



  if ( ( onetermonly &amp;&amp; ( numterms &gt; 1 )) ||
       ( zeroterms   &amp;&amp; ( numterms     )) ) {
     e_message(0,15,NULL) ;          /* requires one operand */
     i = 15 ;
     goto deleteterms ;
     }

  if ( onetermonly &amp;&amp; ( numterms == 0 ) ) {
     e_message(0,13,NULL) ;          /* requires at least one operand */
     return 13 ;
     }

  if ( labelrequired &amp;&amp; !(*label) ) {
     e_message(0,16,NULL) ;         /* label required */
     i = 16 ;
     goto deleteterms ;
     }

  if ( ignorlabel &amp;&amp; *label )
     e_message(0,72,NULL ) ;          /* label ignored. */

  if ( numterms )
     /* validate each term */
     for  ( term = *termlist ; term ; term= term-&gt;next ) {
   mode = term-&gt;modereg &gt;&gt; 8 ;
   reg  = term-&gt;modereg &amp;  15 ;
   if (  ( mode == 7 ) &amp;&amp; ( reg &lt;= 1 ) ) {
      if ( onesymbolonly ) {
         if ( ! ps_one_symbol_only(term-&gt;symptr)  ) {
       e_message(0,11,NULL)  ; /* illegal term */
       i = 11 ;
       goto deleteterms ;
       }
         sym_add_operand_symbol( term-&gt;symptr, term, FALSE );
         if ( ( term-&gt;symptr-&gt;sym[0] == '*' ) ||
         ( !term-&gt;symptr-&gt;sym[0] )) {
         e_message(0,19,NULL);
         i = 19 ;
         goto deleteterms ;
         }
         }
      else {
         for ( sym = term-&gt;symptr ; sym ; sym = sym-&gt;next ) {
       if ( sym-&gt;sym[0] )
          sym_add_operand_symbol( sym, term, FALSE );

       }
         /* compress symbol chain and hold onto number of unresolved */
         /* symbols in postword                 */
         term-&gt;postword = am_resolve_symbol(term-&gt;symptr) ;

         if ( ( ! forwardsallowed ) &amp;&amp; ( term-&gt;postword ) ) {
       e_message(0,14,NULL) ;    /* cannot forward reference */
       i = 14 ;
       goto deleteterms ;
       }
         }
      }
   else {
      if ( ! ( stringsallowed &amp;&amp; ( mode == 7 ) &amp;&amp; ( reg == 10 ) )) {
        e_message(0,11,NULL)  ; /* illegal term */
        i = 11 ;
        goto deleteterms ;
        }
      }
   }


  return 0 ;


  deleteterms :        /* label for exit with deletion of terms */
             /* i will contain the error code returned*/

  if ( numterms )            /* delete all terms */
    am_delete_terms( termlist, TRUE );

  return i ;


 } /* ps_validate_pseudo */




/***************************************************************************
  Function ps_pseudo

     This function handles all the pseudo commands for the assembler.

  Input parameters :
    label     : pointer to label found on current line.
    index     : the pseudo index
    size     : the size specification of the pseudo command. ( ie .B )
    numterms : the number of terms in the termlist.

  Variable parameter
    termlist : Pointer to the term list.  The termlist is
          deleted except for those terms which are not
          resolved for the particular pseudos which allow
          forward references.
  Globals :
   am_location_counter : updated when pseudo requires it.
   am_end_found       : set to TRUE if 'end' pseudo is encountered.
   am_abs_address_size : set to 1 for abs_short, 2 for abs_long.

  Note : On any error, the termlist is completely deleted, and
    the appropriate error message is in the error list created
    by e_message.

  Return code
     0   : pseudo handled okay.
     other : error occured.

 **************************************************************************/
 int  ps_pseudo ( char      * label    ,
        ps_pseudos     index    ,
        char        numterms ,
        am_term_type ** termlist ,
        char      * line      )
 {
  am_term_type * term  ;
  int       i     ;
  l_line_type  * lptr  ;

  switch ( index ) {
     case ps_abslong : case ps_absshort :
     case ps_even    : case ps_end   :
     l_addline( l_neither , 0, line, &amp;lptr); /* add line to listing */
     if ( *label ) e_message(0,72,NULL)   ; /* label ignored. */
     if ( numterms ) e_message(0,73,NULL)   ; /* operands ignored. */
     switch ( index ) {
        case ps_abslong  : am_abs_address_size = 2 ; break ;
        case ps_absshort : am_abs_address_size = 1 ; break ;
        case ps_even     : if ( am_location_counter &amp; 1 )
               am_location_counter++ ;
            break;
        case ps_end      : am_end_found = TRUE ; break ;
        }
     am_delete_terms( termlist, TRUE ) ;
     return 0 ;

     case ps_equate :
     l_addline(l_neither,0,line,&amp;lptr) ;
     /* requires one term only. label required. */
     if ( i = ps_validate_pseudo ( label, numterms, termlist,
            TRUE,FALSE,FALSE,TRUE,FALSE,FALSE,FALSE))
        return i ;

     /* add label and value to symbol table */
     i = sym_add_label_symbol( label, (*termlist)-&gt;symptr-&gt;val,
                am_absolute ) ;
     am_delete_terms( termlist, TRUE ) ;
     return i ;

     case ps_extern :
     l_addline(l_neither,0,line,&amp;lptr) ;
     /* one or more terms. label ignored. one symbol per each term */
     if ( i = ps_validate_pseudo ( label, numterms, termlist,
            FALSE,FALSE,FALSE,FALSE,TRUE,FALSE,TRUE))
        return i ;

     /* Add each symbol to the external symbol list. */
     for ( term = *termlist ; term ; term = term-&gt;next )
         if ( i = sym_add_extern(term-&gt;symptr-&gt;sym) ) {
       am_delete_terms( termlist, TRUE );
       return i ;
       }

     am_delete_terms( termlist, TRUE );
     return 0 ;

     case ps_global :
     l_addline(l_neither,0,line,&amp;lptr) ;
     /* one or more terms. label ignored. one symbol per each term */
     if ( i = ps_validate_pseudo ( label, numterms, termlist,
             FALSE,FALSE,FALSE,FALSE,TRUE,FALSE,TRUE))
        return i ;

     /* Add each symbol to the global symbol list. */
     for ( term = *termlist ; term ; term = term-&gt;next )
         if ( i = sym_add_global(term-&gt;symptr-&gt;sym) ) {
       am_delete_terms( termlist, TRUE );
       return i ;
       }

     am_delete_terms( termlist, TRUE );
     return 0 ;

     case ps_origin :
     l_addline(l_neither,0,line,&amp;lptr) ;
     /* requires one term only. label ignored. */
     if ( i = ps_validate_pseudo ( label, numterms, termlist,
                TRUE,FALSE,FALSE,FALSE,TRUE,FALSE,FALSE))
        return i ;
     am_location_counter = (*termlist)-&gt;symptr-&gt;val ;
     am_delete_terms( termlist, TRUE );
     return 0 ;
     }

  return 0 ;

 } /* ps_pseudo */



<a name="01d8_001d"><a name="01d8_001d">
<a name="01d8_001e"></pre><B>[LISTING NINE]</B><pre><a name="01d8_001e">


  /*
     68000 Symbol table Module.
    This module contains those procedures needed to handle
    the symbol table.
  */

  #include &lt;stdio.h&gt;
  #include &lt;stdlib.h&gt;
  #include &lt;string.h&gt;

  #include &quot;68defs.h&quot;
  #include &quot;68err.h&quot;
  #include &quot;68parse.h&quot;
  #include &quot;68list.h&quot;
  #include &quot;68assem.h&quot;
  #include &quot;68symtab.h&quot;


  /* Module level variable */
  sym_label_type    *  sym_glb_lab_head = NULL ;
  sym_label_type    *  sym_local_lab_head = NULL ;

  sym_operand_type  *  sym_ext_ref_head = NULL ;
  sym_operand_type  *  sym_local_ref_head = NULL ;


  /* Local prototypes */

  sym_operand_type * sym_lookup_extern( char  *  symbol );
  sym_label_type   * sym_lookup_local ( char  *  symbol );
  int           sym_addtolocaloplist ( p_sym_type     * symptr  ,
                   am_term_type  * termptr ) ;


/***************************************************************************
  Function sym_add_symtabtolisting

     This function is meant to be called at the end of assembly.
     It adds the symbol tables to the listing if there are any
     global, external, or local symbols .

     The symbol table is of the following form :

       Symbol        Value    Class
       ----------    ------    ------
       MYSYMBOL      000000    Global  Relative
       MYSYMBOL1     00FFFF    Global  Absolute
       MYSYMBOL2     ??????    Global  Unknown
       MYSYMBOL3     001ABC    Local    Relative
       MYSYMBOL4     ??????    Extern  Unknown

  Calls
     l_addline : to add the text lines to the listing.

 **************************************************************************/
  void sym_add_symtabtolisting()
  {
    register  sym_label_type   * labptr ;
    sym_operand_type * refptr ;
    l_line_type      * lptr  ;
    char        * message_buf , * chptr , count ;
    int           i ;


    if ( sym_glb_lab_head || sym_local_lab_head || sym_ext_ref_head ) {
       l_addline(l_neither, 0,&quot;&quot;,&amp;lptr);
       l_addline(l_neither, 0,
        &quot; Symbol                Value     Class &quot;,&amp;lptr);
       l_addline(l_neither, 0,
        &quot; ----------------      ------    -------&quot;,&amp;lptr);
       }
    else
       return ;

    message_buf = &quot;                                                      &quot; ;

    for (count = 1 ; count &lt;= 2 ; count++ ) {
       if ( count == 1 ) {
     strncpy(message_buf+33,&quot;Global &quot;,7);
     labptr = sym_glb_lab_head ;
     }
       else {
     strncpy(message_buf+33,&quot;Local  &quot;,7);
     labptr = sym_local_lab_head ;
     }

       for ( ; labptr ; labptr= labptr-&gt;next ) {

     i = strlen( labptr-&gt;symbol );
     strncpy( message_buf + 1, labptr-&gt;symbol, i );
     for ( chptr = message_buf + i + 1 ; i &lt; MAXSYMLEN ; i++, chptr++ )
          *chptr = ' ' ;

     if ( labptr-&gt;relative == '?' ) {
        strncpy( message_buf + 23 ,&quot;??????&quot;,6 );
        strncpy( message_buf + 43,&quot; Unknown  &quot;, 10 );
        }
     else {
        sprintf( message_buf+ 23 ,&quot;%06lX&quot;,labptr-&gt;val );
        message_buf[29] = ' ' ;
        if ( labptr-&gt;relative == '*' )
      strncpy( message_buf + 43,&quot; Relative &quot;, 10 );
        else
      strncpy( message_buf + 43 ,&quot; Absolute &quot;, 10 );
        }
     l_addline(l_neither, 0, message_buf , &amp;lptr );

     }
       }

    strncpy( message_buf + 23, &quot;??????&quot;,6 );
    strncpy( message_buf + 33, &quot;Extern &quot;,7);
    strncpy( message_buf + 43, &quot; Unknown  &quot;, 10 );
    for ( refptr = sym_ext_ref_head ; refptr ; refptr= refptr-&gt;next ) {
   i = strlen( refptr-&gt;symbol );
   strncpy( message_buf + 1, refptr-&gt;symbol, i );
   for ( chptr = message_buf + i + 1 ; i &lt; MAXSYMLEN ; i++, chptr++ )
        *chptr = ' ' ;
   l_addline(l_neither, 0, message_buf , &amp;lptr );
   }

  } /* sym_add_symtabtolisting */



/***************************************************************************
  Function sym_process_unresolved_locals

     This function is meant to be called at the end of assembly.
     It checks the local reference list to see if any unresolved
     symbols are left in it. If there are , it generates an unresolved
     symbol error for each symbol, then deletes the local reference list.

     It also manually places the errors into the listing following the
     lines where the unresolved symbol was referenced, as well as calls
     l_addline to add the error message(s) at the end of the listing.

     Returns the total number of unresolved symbols.

 **************************************************************************/
  int  sym_process_unresolved_locals()
  {
    int           i  ;
    sym_ref_type     * reflistptr ;
    sym_operand_type * refptr ;
    sym_label_type   * glbptr ;
    l_line_type      * lptr , * temp_lptr;
    err_type        * error ;
    char          message_buf[100] ;

    i = 0 ;

    /* Process global label list first */
    for ( glbptr = sym_glb_lab_head ; glbptr ; glbptr= glbptr-&gt;next ) {

       if ( glbptr-&gt;relative != '?' )   /* if its known then go to next one */
     continue ;

       e_message(0,23, NULL );
       i ++ ;

       error = e_error.errptr ;
       strcpy( message_buf , error-&gt;message ) ;
       strcpy( message_buf+strlen(error-&gt;message), glbptr-&gt;symbol );

       l_addline(l_neither, 0, message_buf , &amp;lptr );

       e_delete_errors() ;
       }

    /* Process the local reference list. */
    for ( refptr = sym_local_ref_head ; refptr ; refptr= refptr-&gt;next ) {
       e_message(0,23, refptr-&gt;symbol );
       i ++ ;

       error = e_error.errptr ;
       strcpy( message_buf , error-&gt;message ) ;
       strcpy( message_buf+strlen(error-&gt;message), refptr-&gt;symbol );

       l_addline(l_neither, 0, message_buf , &amp;lptr );
       l_addline(l_neither, 0, message_buf , &amp;lptr );

       /* unlink the second redundant line */
       lptr-&gt;next-&gt;prev = lptr-&gt;prev ;
       lptr-&gt;prev-&gt;next = lptr-&gt;next ;

       /* link the second line into listing where symbol was first referenced */
       temp_lptr = refptr-&gt;list-&gt;termptr-&gt;lineptr ;
       lptr-&gt;next = temp_lptr-&gt;next ;
       lptr-&gt;next-&gt;prev = lptr ;
       lptr-&gt;prev = temp_lptr ;
       temp_lptr-&gt;next = lptr ;

       e_delete_errors() ;
       }

    /* delete the local reference list */
    while ( refptr = sym_local_ref_head ) {
   while ( reflistptr = refptr-&gt;list ) {
      refptr-&gt;list = refptr-&gt;list-&gt;next ;
      free( reflistptr );
      }
   sym_local_ref_head = refptr-&gt;next ;
   free( refptr );
   }

    return i ;

  } /* sym_process_unresolved_locals */


/***************************************************************************
  Function sym_delete_all_tables
     This function deletes all the symbol tables.
  Globals
     sym_glb_label_head, sym_local_lab_head
     sym_ext_ref_head  , sym_local_ref_head   : all set to NULL when
                  the tables are deleted.

 **************************************************************************/
 void sym_delete_all_tables( void )
 {
  sym_operand_type * refptr ;
  sym_label_type   * labptr ;
  sym_ref_type      * reflistptr ;

  /* delete the global label list */
  while ( labptr = sym_glb_lab_head ) {
      sym_glb_lab_head = labptr-&gt;next ;
      free( labptr );
      }

  /* delete the local label list */
  while ( labptr = sym_local_lab_head ) {
      sym_local_lab_head = labptr-&gt;next ;
      free( labptr );
      }

  /* delete the local reference list */
  while ( refptr = sym_local_ref_head ) {
      while ( reflistptr = refptr-&gt;list ) {
    refptr-&gt;list = refptr-&gt;list-&gt;next ;
    free( reflistptr );
    }
      sym_local_ref_head = refptr-&gt;next ;
      free( refptr );
      }

  /* delete the external reference list */
  while ( refptr = sym_ext_ref_head ) {
      while ( reflistptr = refptr-&gt;list ) {
    refptr-&gt;list = refptr-&gt;list-&gt;next ;
    free( reflistptr );
    }
      sym_ext_ref_head = refptr-&gt;next ;
      free( refptr );
      }

 } /* sym_delete_all_tables */


/***************************************************************************
  Function sym_resolve_back

     This function resolves all back references of a particular
     label symbol passed to it.

  Input :
     symptr : pointer to label symbol node with value already resolved.


 **************************************************************************/
  void sym_resolve_back( sym_label_type  *  symptr )
  {
    unsigned int       i  ;
    sym_operand_type * temp, * prev ;
    sym_ref_type     * refptr , * refhead , * tempref ;
    p_sym_type        * sym ;
    am_term_type     * termptr ;
    int           warnings ;

    prev = NULL ;
    for ( temp = sym_local_ref_head ;
     temp &amp;&amp; strncmp(temp-&gt;symbol,symptr-&gt;symbol, MAXSYMLEN ) ;
     prev = temp , temp = temp-&gt;next );

    if ( !temp ) return ;
                  /* if there are back references */
    if ( prev )          /* remove the operand node from list.*/
       prev-&gt;next = temp-&gt;next ;
    else
       sym_local_ref_head = temp-&gt;next ;
    refhead = temp-&gt;list ;
    free( temp ) ;

    refptr = refhead ;
    while ( refptr ) {
   termptr = refptr-&gt;termptr ;
   for ( sym = termptr-&gt;symptr ; sym ; sym= sym-&gt;next )
       if ( ! strncmp( sym-&gt;sym, symptr-&gt;symbol, MAXSYMLEN ) ) {
          /* if the symbol is in the symbol list of the term */
          /* then resolve it. */
          sym-&gt;val = symptr-&gt;val ;
          sym-&gt;sym[0] = symptr-&gt;relative ;
          sym-&gt;sym[1] = 1 ; /* for relative '*' put in count after it */
          }
   refptr = refptr-&gt;next ;
   }

    /* compress ref list so that only unique termlists are refered to. */
    refptr = refhead ;
    while ( refptr ) {
   termptr = refptr-&gt;termptr ;
   if ( termptr )
   switch ( termptr-&gt;class ) {
     case am_first_instr_term :
        /* get rid of any term pointers which refer to the */
        /* next term if its class is am_other_instr   */
        /* this works since instructions can have only 2 terms */
        if ( termptr-&gt;next )
      if ( termptr-&gt;next-&gt;class == am_other_instr_term ) {
         for ( tempref = refhead; tempref ; tempref=tempref-&gt;next)
             if ( tempref-&gt;termptr == termptr-&gt;next )
           tempref-&gt;termptr = NULL ;
         }
        break ;
     case am_other_instr_term :
        /* back up to first_instr_term and do same as in case above*/
        if ( termptr-&gt;prev )   /* there should always be a prev term */
      if ( termptr-&gt;prev-&gt;class == am_first_instr_term ) {
         for ( tempref = refhead; tempref ; tempref=tempref-&gt;next)
             if ( tempref-&gt;termptr == termptr-&gt;prev )
           tempref-&gt;termptr = NULL ;
         }
        refptr-&gt;termptr = termptr-&gt;prev ; /* set ptr to first term */
        break ;
     case am_data_term :
        /* resolve only one data term at a time. no compression */
        break;
     }
   refptr = refptr-&gt;next ;
   }

    /* resolve terms and dispose of reference list. */
    refptr = refhead ;
    while ( refptr ) {
       termptr = refptr-&gt;termptr ;
       tempref = refptr-&gt;next ;
       free(refptr);
       refptr = tempref ;
       if ( !termptr ) continue ;

       i=am_resolve_term( termptr,( termptr-&gt;class == am_data_term)?1:0);

       if ( !i ) {              /* if all resolved */
     warnings = e_error.warnings ;
     am_backfill( termptr );

     if ( e_error.warnings &gt; warnings )
        l_add_errors( termptr-&gt;lineptr );

     warnings = e_error.warnings ;
     am_remove_terms_from_list(&amp;termptr) ;
     }

       }

  } /* sym_resolve_back */



/***************************************************************************
  Function sym_lookup_global

     This function looks up a symbol in the global label list.
     If the symbol is found, it returns a pointer to its label node,
     otherwise it returns NULL.

  Input :
     symbol : pointer to global symbol string.

  Returns :
     described above.

 **************************************************************************/
  sym_label_type * sym_lookup_global( char  *  symbol )
  {
    sym_label_type * temp ;

    for ( temp = sym_glb_lab_head ;
     temp &amp;&amp; strncmp(temp-&gt;symbol,symbol, MAXSYMLEN ) ;
     temp = temp-&gt;next );
    return temp ;

  } /* sym_lookup_global */


/***************************************************************************
  Function sym_add_global

     This function will add a symbol to the global list if the
     symbol is not already in the global list.

     The symbol string is copied into the label node on success.

  Note : The relative field of the label node is set to '?' which
    denotes that the symbol does not yet have a value.

  Input :
     symbol : pointer to the symbol string of MAXSYMLEN or less.

  Globals :
     sym_glb_lab_head : head pointer is updated when symbol is added
         to global list.
  Warnings issued :
     74  : Symbol already in global list. Ignored.

  Returns :
     0 : symbol was added okay.
     41: not enough memory to add to list.

 **************************************************************************/
  int  sym_add_global( char  *   symbol )
  {
   sym_label_type * temp ;

   if ( sym_lookup_global( symbol ) ) {
      e_message(0,74,NULL) ;         /* WARNING symbol already in glb list.*/
      return 0 ;
      }
   if ( temp = ( sym_label_type * ) malloc ( sizeof(sym_label_type) ) ) {
      strncpy( temp-&gt;symbol, symbol, MAXSYMLEN );
      temp-&gt;relative = '?' ;
      temp-&gt;next = sym_glb_lab_head ;
      temp-&gt;val = 0L ;
      sym_glb_lab_head = temp ;
      return 0 ;
      }
   e_message(0,41,NULL) ; /* out of memory */
   return 41 ;

  } /* sym_add_global */



/***************************************************************************
  Function sym_lookup_extern

     This function looks up a symbol in the external label list.
     If the symbol is found, it returns a pointer to its operand node,
     otherwise it returns NULL.

  Input :
     symbol : pointer to external symbol string.

  Returns :
     described above.

 **************************************************************************/
  sym_operand_type * sym_lookup_extern( char  *  symbol )
  {
   sym_operand_type * temp ;

   for ( temp = sym_ext_ref_head ;
    temp &amp;&amp; strncmp(temp-&gt;symbol,symbol, MAXSYMLEN ) ;
    temp = temp-&gt;next );
   return temp ;

  } /* sym_lookup_ext */



/***************************************************************************
  Function sym_add_extern

     This function will add a symbol to the external list if the
     symbol is not already in the external list.

     The symbol string is copied into the operand node on success.

  Input :
     symbol : pointer to the symbol string of MAXSYMLEN or less.

  Globals :
     sym_ext_ref_head : reference head pointer is updated when symbol is added
         to external list.
  Warnings issued :
     75  : Symbol already in external list. Ignored.

  Returns :
     0 : symbol was added okay.
     41: not enough memory to add to list.

 **************************************************************************/
  int  sym_add_extern( char  *   symbol )
  {
    sym_operand_type * temp ;

    if ( sym_lookup_extern( symbol ) ) {
       e_message(0,75,NULL) ;      /* WARNING symbol already in extern list.*/
       return 0 ;
       }
    if ( temp = ( sym_operand_type * ) malloc ( sizeof(sym_operand_type) ) ) {
       strncpy( temp-&gt;symbol, symbol, MAXSYMLEN );
       temp-&gt;next = sym_ext_ref_head ;
       temp-&gt;list = NULL ;
       sym_ext_ref_head = temp ;
       return 0 ;
       }
    e_message(0,41,NULL) ; /* out of memory */
    return 41 ;

  } /* sym_add_extern */



/***************************************************************************
  Function sym_lookup_local

     This function looks up a symbol in the local label list.
     If the symbol is found, it returns a pointer to its label node,
     otherwise it returns NULL.

  Input :
     symbol : pointer to local symbol string.

  Returns :
     described above.

 **************************************************************************/
  sym_label_type * sym_lookup_local( char  *  symbol )
  {
    sym_label_type * temp ;

    for ( temp = sym_local_lab_head ;
     temp &amp;&amp; strncmp(temp-&gt;symbol,symbol, MAXSYMLEN ) ;
     temp = temp-&gt;next );
    return temp ;

  } /* sym_lookup_local */



/***************************************************************************
  Function sym_add_label_symbol

     This function will add a label symbol to a local label list,
     or resolve an already defined global label following the
     algorithm :

    if label already in extern label list then error
    else
       if label already in global label list then
          if its already resolved then error
          else
        resolve it and all back references in local op list.
       else
          if label in local label list then error
          else
       resolve it and all back references in local op list.

     If the relative field is set to am_relative then the label is
     treated as a relative label, otherwise it is treated as an
     absolute label.

  Note : The relative field is set to '*' if relative or 0 for absolute.

  Input :
     symbol   : pointer to the symbol string of MAXSYMLEN or less.
     val      : the long value of the symbol.
     relative : specifies whether or not to treat the label as relative.

  Globals :
     sym_local_lab_head : Local label head pointer is updated when symbol is
           added to label list.

  Returns :
     0 : okay.
     17: Cannot resolve an external symbol locally.
     18: symbol was already resolved.
     41: not enough memory to add to list.

 **************************************************************************/
  int  sym_add_label_symbol ( char       * symbol ,
               unsigned long   val    ,
               am_assem_type   relative )
  {
    sym_label_type  * temp ;

    if ( sym_lookup_extern( symbol ) ) {
       e_message(0,17,NULL) ;      /* label symbol already in extern list.*/
       return 17;         /* cannot resolve locally. */
       }

    if ( temp = sym_lookup_global( symbol ) ) {   /* in global list */
       if ( temp-&gt;relative == '?' ) {  /* not resolved yet. */
     temp-&gt;relative = ( relative == am_relative ) ? '*' : 0 ;
     temp-&gt;val = val ;
                /* resolve back references */
     sym_resolve_back( temp );
     return 0 ;
     }
       else {
     e_message(0,18,NULL) ;  /* symbol already resolved */
     return 18 ;
     }
       }

    if ( sym_lookup_local( symbol ) ) {
       e_message(0,18,NULL) ;      /* symbol already resolved in local list.*/
       return 18 ;
       }

    if ( temp = ( sym_label_type * ) malloc( sizeof(sym_label_type)) ) {
       strncpy( temp-&gt;symbol, symbol, MAXSYMLEN );
       temp-&gt;relative = ( relative == am_relative ) ? '*' : 0 ;
       temp-&gt;next = sym_local_lab_head ;
       temp-&gt;val  = val ;
       sym_local_lab_head = temp ;
               /* resolve back references */
       sym_resolve_back( temp );
       return 0 ;
       }
    else {
       e_message(0,41,NULL) ;  /* out of memory */
       return 41 ;
       }

  } /* sym_add_label_symbol */



/***************************************************************************
  Function sym_add_operand_symbol

     This function will add a attempt to resolve a symbol contained
     within a symbol node, or set the reference pointers in the
     reference lists accordingly depending on whether or not the
     symbol's value is known. It follows this algorithm :

    if symbol already in extern label list then
       add reference to it into the extern list.
    else
       if symbol already in global label list then
          if its already resolved then
        resolve it
          else
        add reference to the symbol to local op list.
       else
          if symbol in local label list then
        resolve it
          else
        add reference to the symbol to local op list.

  Input :
     symptr   : pointer to the symbol node.
     termptr  : pointer to term list that contains the symbol node.
     addref   : boolean flag indicating whether or not a reference
      pointer should be set up if the symbol is not yet
      resolved.
       if TRUE then reference pointers will be set up.
       if FALSE then reference pointers will not be set up.
  Note   : If addref is set to FALSE then no error can result since
     no memory allocation is attempted. Therefore the caller
     need not check the return code.
  Calls :
     sym_addtolocaloplist : This adds the refernece pointers for later
             resolution to the local operand list.

  Returns :
     0 : okay.
     41: not enough memory to add to list.

 **************************************************************************/
  int  sym_add_operand_symbol ( p_sym_type    * symptr   ,
            am_term_type  * termptr ,
            char      addref   )
  {
    sym_operand_type * temp  ;
    sym_ref_type     * temp2 ;
    sym_label_type   * temp3 ;

    if ( temp = sym_lookup_extern( symptr-&gt;sym ) ) {  /* in extern list */
       if ( ! addref ) return 0 ;
       if ( temp2 = ( sym_ref_type * ) malloc( sizeof(sym_ref_type)) ) {
     temp2-&gt;termptr = termptr ;
     temp2-&gt;next = temp-&gt;list ;
     temp-&gt;list = temp2 ;
     return 0 ;
     }
       else {
    e_message(0,41,NULL) ;   /* not enough memory */
    return 41 ;
    }
       }

    if ( temp3 = sym_lookup_global( symptr-&gt;sym ) ) {   /* in global list */
       if ( temp3-&gt;relative == '?' )   /* not resolved yet. */
     if ( ! addref ) return 0 ;
     else return sym_addtolocaloplist( symptr, termptr ) ;
       else {
     symptr-&gt;val = temp3-&gt;val ;            /* resolve the symbol */
     symptr-&gt;sym[0] = temp3-&gt;relative ;
     symptr-&gt;sym[1] = 1 ; /* set relative count to 1 */
     return 0 ;
     }
       }

    if ( temp3 = sym_lookup_local( symptr-&gt;sym ) ) {
       symptr-&gt;val = temp3-&gt;val ;           /* resolve the symbol*/
       symptr-&gt;sym[0] = temp3-&gt;relative ;
       symptr-&gt;sym[1] = 1 ;   /* set relative count to 1 */
       return 0 ;
       }
    else
       if ( ! addref ) return 0 ;
       else return sym_addtolocaloplist( symptr, termptr ) ;

  } /* sym_add_operand_symbol */



/***************************************************************************
  Function sym_addtolocaloplist

     This function will add a symbol reference to the local operand
     list. If the symbol already has referneces in the local operand
     list, it creates a new reference node only. If the symbol has no
     previous references, it creates the symbol operand node as well
     as its first reference node.

  Input :
     symptr   : pointer to the symbol node.
     termptr  : pointer to term list that contains the symbol node.

  Globals :
     sym_local_ref_head : updated when symbol has never been referenced
           before, and a new operand node was created.

  Returns :
     0 : okay.
     41: not enough memory to add to list.

 **************************************************************************/
  int  sym_addtolocaloplist ( p_sym_type    * symptr  ,
               am_term_type  * termptr )
  {
    sym_operand_type  * temp ;
    sym_ref_type      * temp2 ;

    for ( temp = sym_local_ref_head ;
     temp &amp;&amp; strncmp(temp-&gt;symbol,symptr-&gt;sym, MAXSYMLEN ) ;
     temp = temp-&gt;next );
    if ( temp )
       if ( temp2 = ( sym_ref_type * ) malloc( sizeof(sym_ref_type)) ) {
     temp2-&gt;termptr = termptr ;
     temp2-&gt;next = temp-&gt;list ;
     temp-&gt;list = temp2 ;
     return 0 ;
     }
       else {
     e_message(0,41,NULL) ; /* not enough memory */
     return 41 ;
     }
    else
       if ( temp = ( sym_operand_type * ) malloc (sizeof(sym_operand_type)) )
     if ( temp2 = ( sym_ref_type * ) malloc( sizeof(sym_ref_type)) ) {
        strncpy( temp-&gt;symbol, symptr-&gt;sym, MAXSYMLEN );
        temp-&gt;next = sym_local_ref_head ;
        temp-&gt;list = temp2 ;
        sym_local_ref_head = temp ;
        temp2-&gt;termptr = termptr ;
        temp2-&gt;next = NULL ;
        return 0 ;
        }
     else {
        free(temp);
        e_message(0,41,NULL);  /* not enough memory */
        return 41 ;
        }
       else {
     e_message(0,41,NULL);  /* not enough memory */
     return 41 ;
     }


  } /* sym_addtolocaloplist */



<P>
<P>
</pre></BODY></HTML>
