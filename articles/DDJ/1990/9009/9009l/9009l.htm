<HTML>
<META NAME="year" CONTENT="1990">
<HEAD>

<TITLE>SEP90: PROGRAMMER'S BOOKSHELF</TITLE></HEAD>
<body bgcolor="FFFFFF">
<h1>PROGRAMMER'S BOOKSHELF<a name="01ec_0003"><a name="01ec_0003"></h1><P>
<h2><a name="01ec_0001"><a name="01ec_0000">Microprocessors From the Programmer's Perspective</h2><P>
<h3>Andrew Schulman</h3><P>
<a name="01ec_0002"><a name="01ec_0000">Like everyone else, programmers generally prefer high-end machines.  Many PC programmers, however, mastered instruction sets, addressing modes, and registers on the 8088 or 68000, never really coming to grips with the ins-and-outs of the fundamentally different, though backward compatible, chips such as the 80386 or 68030.  Although they use 80386s, many PC programmers are still 8088 programmers at heart, possessing a surprising ignorance of high-end microprocessor architecture.<P>
Then there are basic questions such as, What is RISC?  Are the Intel 80486 and Motorola 68040 RISC chips?  What is the architecture of the new IBM System/6000 family or the Sun SPARCstations?  and How do you program one of those things?<P>
To address questions like these, Robert Dewar and Matthew Smosna's Microprocessors: A Programmer's View provides a solid introduction to the new chips.  As the subtitle indicates, this book is for programmers, not hardware design engineers; there are no descriptions of pins here, but instead, lots of code examples.<P>
After an opening chapter on general issues -- register sets, addressing modes, and instruction formats -- the authors present an in-depth look at the Intel 80386 (three chapters) and Motorola 68030 (two chapters).  This is followed by one chapter each on the most important Reduced Instruction Set Computer (RISC) architectures: MIPS, Sun SPARC, Intel i860, IBM (both the ROMP architecture found in the IBM RT, and the RIOS used in the new System/6000 family), and INMOS transputer.<P>
The RISC microprocessors require less explanation than the more conventional Intel or Motorola offerings, simply because the RISC chips really do have a simpler architecture.  As Dewar and Smosna point out, one reason for this is that RISC manufacturers started with a clean slate while Intel and Motorola were largely driven by the need for backward compatibility.<P>
Microprocessors also contains a lot of anecdotal material, and reflects a knowledge of the real world that is surprising in a treatise on computer architecture.  One section, &quot;A Sad Story,&quot; talks about how Intel thinks INT 5 means one thing, how IBM thinks it means another, and how this led to the IBM PCjr not using the Intel 80188 chip.  Another story, which comes in the middle of a discussion of the 256-byte instruction cache on the 68020, describes a misaligned loop in Peter Norton's SI benchmarking program for the PC.  A brief digression on patent law describes how DEC patented the use of the instruction pointer (IP) as a general register.<P>
<h3><a name="01ec_0004">A Background in Compilers<a name="01ec_0004"></h3><P>
Dewar and Smosna are both professors at the NYU Courant Institute of Mathematical Sciences. Between them, they have over 25 years experience working on compilers, including the well-respected Realia COBOL and Alsys Ada for the IBM PC, the SPITBOL compiler, and NYU's SETL language.<P>
Why is a background in compilers useful when writing a book on the new hardware?  Because, for better or for worse, most code that is run on high-end processors is generated by compilers.  Thus, compiler writers determine to a large extent which features of a microprocessor are used.  The fundamental observation that inspired the original RISC research was that only a small subset of the instruction set and addressing modes of most processors is commonly executed.  Who better than a compiler writer to tell us which features are important and which ones, however interesting sounding, will never be used.<P>
If an instruction exists and almost no one uses it, can its real estate on the chip be put to better use?  For example, it is difficult for a compiler to take advantage of many of the niftier features of the 80386 instruction set.  The 80386 has a special three-operand form of the IMUL instruction that can manipulate 64-bit integers, but there is no corresponding C data type for 64-bit integers, so the instruction is hardly ever used -- even in code that needs to manipulate 64-bit integers!  (In their wonderfully idiosyncratic style, Dewar and Smosna explain all this with an anecdote involving the typesetting firm owned by one of their brothers-in-law.)<P>
So, just because a microprocessor has an instruction to work with 64-bit integers, it doesn't mean that code that handles 64-bit integers will in fact use the instruction.  More likely, existing code will never be changed to take advantage of the new &quot;hardware support&quot; for 64-bit integers.<P>
Furthermore, say the authors, code shouldn't often be changed to use a new feature.  &quot;Do not assume that an instruction should be used just because it is there.&quot;  By way of example they provide an in-depth look at the Intel ENTER and LEAVE instructions.<P>
&quot;Hardware support&quot; for a feature sounds like it should always be better than &quot;doing it in software.&quot;  Dewar and Smosna present a cogent argument that this ain't necessarily so.  Again, the 80386 provides many examples.  The authors discuss how &quot;simply&quot; by executing a FAR JMP whose target is a task state segment (TSS), one performs a 386 context switch.  Sounds terrific.  Why does multitasking software for the 386 ignore this magnificent hardware support, and instead do context switches in software?  Because the hardware-supported context switch can easily take 300 clock cycles!<P>
<h3><a name="01ec_0005">Why RISC?<a name="01ec_0005"></h3><P>
This entire discussion of complex instructions that hardly anyone uses directly leads into the authors' discussion of RISC.  Quoting Dan Prener of IBM, the authors note that RISC is not a reduced set of instructions, but a set of reduced instructions.<P>
The goal of RISC is to execute one instruction per clock cycle.  This requires not only simplified instructions, but also optimal use of the processor's instruction pipeline.  As Dewar and Smosna explain, while a single instruction may have a latency of five clock cycles, if the instruction fetch, decode, and execution can be broken into five stages that can be overlapped with similar stages for other instructions, then average throughput can equal one instruction per clock cycle.<P>
The key way that RISC reduces the complexity of the instruction set is by introducing a &quot;load/store&quot; architecture.  The only instructions that interface with memory are LOAD (read memory-to-register) and STORE (write register-to-memory).  All other instructions are register-to-register.  This greatly reduces the number of addressing modes, which, in turn, simplifies the processor's instruction decode unit.<P>
But a load/store architecture isn't just aesthetically pleasing.  It also provides the opportunity for a potentially large performance boost.  Access times for memory will always be slower than clock speeds for microprocessors.  Caches only partially deal with this problem. Because a load/store architecture gates all memory access through two instructions, we can boost performance by introducing a new rule: The memory operand to a LOAD is not yet available when the instruction following the LOAD starts executing.  With this rule, the processor can start executing that instruction before the read from memory has completed.  The only requirement is, of course, that this next instruction not need the result of the LOAD.<P>
What then do we do with the instruction after a LOAD?  Many pages in Dewar and Smosna's book are devoted to this topic.  Obviously, we can insert a NOP, but then we are back where we started.  In fact, a good optimizing compiler can usually reorganize code so that useful things can be done in the slot after a LOAD.  But this means that good optimizing compilers are necessary to take advantage of RISC architecture.  Rather than try to hide them, RISC exposes hardware features such as the speed difference between processors and memory.  RISC programming means mastering the concept of software pipelining.  Good compilers are needed so that most programmers will not have to remember that a LOAD from memory is a physical act that actually takes time.<P>
The various RISC architectures explored in this book differ greatly in the extent to which they hide or expose the instruction pipeline.  The MIPS chips, for example, based on the Stanford RISC research, rely on software conventions rather than hardware interlocks for handling what is called the &quot;load delay slot.&quot;  In fact, MIPS originally stood for &quot;Microprocessor without Interlocked Pipeline Stages.&quot;<P>
The Intel i860 is even more non-transparent.  As explained by Dewar and Smosna, i860 programming looks as though it consists almost entirely of pipeline manipulation.  For a good example, look in the index to Dewar and Smosna under &quot;Breadcrumbs,&quot; and read the indicated page.  (I'm not kidding!)<P>
On the other hand, the RIOS architecture used in the IBM System/6000 sounds a lot easier to deal with.  According to Dewar and Smosna, RIOS has an advantage over chips like the i860 that &quot;with just a little knowledge of what is going on -- basically little more than the rule that you should not use results you just computed -- the programmer can write code that compiles in a highly efficient manner, without needing a sophisticated optimizing compiler.&quot;<P>
The authors conclude that, &quot;Rather than thinking of RISC as a clearly defined characteristic of microprocessors, it is better to think of RISC a being a term for a collection of design techniques used to improve performance.&quot;<P>
Often processor's niftiest features are difficult to take advantage of in a high-level language.  Chip underutilization is a major problem in our industry.  It is often said that software lags behind hardware.  The RISC solution is to design simpler chips.  Another solution is to make heavier use of assembly language.  Another solution, in the case of the underutilization of the 80386, is to use a DOS extender, so that one is using the machine as something other than a &quot;fast XT.&quot;<P>
Dewar and Smosna are wonderfully opinionated.  Following their lengthy discussion of the rather baroque protection mechanism on the 80386, the authors forthrightly state, &quot;The previous section is virtually incomprehensible.  You probably have to read it several times to understand it, and it is still easy to get the DPLs, CPLs, and RPLs hopelessly mixed up.&quot;  The title of this section is &quot;Is All This Worthwhile?&quot;  A discussion of the insane number of addressing modes on the Motorola 68030 asks, &quot;Had enough of this?&quot;  As computer books seem to be becoming more and more homogenized, it was a pleasure to read Microprocessors, a piece of technical writing which maintains the authors' voices from beginning to end.<P>
<P>
<P>
</pre></BODY></HTML>
