<HTML>
<META NAME="year" CONTENT="1990">
<HEAD>

<TITLE>FEB90: LETTERS</TITLE></HEAD>
<body bgcolor="FFFFFF">
<h1>LETTERS<a name="005a_0001"><a name="005a_0001"></h1><P>
<h3></h3><P>
<h3><a name="005a_0002">Standardizing the Standardizing Process<a name="005a_0002"></h3><P>
Dear DDJ,<P>
Apparently columnist Al Stevens got a little carried away in his November 1989 column when he compared the ANSI standardization process to democracy.<P>
Surely Mr. Stevens knows that a committee is, at best, only a representative democracy.  As we in the U.S. are reminded every couple of years, one democratic problem lies in determining who gets to be on the committee.  Since I do not remember voting for these people, I wonder whose interests they really represent.<P>
Actually, I commend the C standardization committee for the extent to which they have discussed their issues in print; there has even been some serious discussion of comments from outsiders.  In contrast, I was recently involved with comments to the ANSI X3J9 Extended Pascal standardization committee.  Since I have read no articles whatsoever on Pascal standardization issues, I wonder how many Pascal programmers realize that such a standard is now virtually complete.<P>
My introduction to Extended Pascal was a note in IEEE Computer (Sept. 1988, p. 70) which mentioned that a draft standard was available (for $35).  After receiving the draft I became concerned about its content.  In fact, I assumed that no group of responsible professionals would consider releasing such a document as an example of their work.  But I did submit comments; that was in October 1988.<P>
In June, 1989, I received a package which included copies of all the various comments received, with The Committee's formal response to each point.  Apparently I got in on the tail end of the feedback process, since most of the comments were from various other nations' standards organizations, as well as some individuals who were commenting on previous responses.  The Committee did decide to make some changes.  But my earlier assumption was wrong: For the most part, the draft was allowed to stand.<P>
After an eight-month delay for The Committee to get its responses together, the commentors were given &quot;fifteen working days&quot; to accept or reject their individual responses.  Note that the Extended Pascal draft standard is a voluminous, excruciatingly detailed specification, and not everyone can simply drop what they are doing to analyze responses, generate objections, and construct a formal response to The Committee.  I did just that, however, and perhaps I was the only one who did, for the response letter that I finally received this September addressed my objections only, and seemed appallingly condescending.<P>
As an engineer myself, I would be the first to admit that some engineers seem to vie with one another to produce the most complex and oblique specification possible.  I guess if nobody can understand the spec, then nobody can criticize it; of course, then nobody can help find the bugs in it, either.  And I have seen some really awful specifications, with special mention going to IEEE Std 488-1975.  But the extended Pascal draft standard, which purported to describe a structured programming language, was itself so unstructured as to be almost unreadable.<P>
The creation of a specification need not differ from the creation of a program; each must eventually describe a derivative logical system that actually works.  A complex system must have a detailed description, of course, but not necessarily a complex organization; that's the whole point of structured programming.  In fact, if a system can only be understood in a complex way, how can anyone use it reliably?  Simple systems can be reliable, but complex systems always contain errors, unless they can be exhaustively tested by an impartial mechanism, and even then, you never really know.<P>
Some of my comments included the lack of exception handling, the lack of alphanumeric Goto labels, the complete lack of any comment nesting at all, and the lack of multiple integer and real data types corresponding to word sizes and IEEE reals.  I wanted additional C-like looping enhancements such as Break and Continue to avoid the use of unstructured mid-loop Gotos, but The Committee preferred Goto instead.  And I was especially concerned over the specification of a single Complex data type with a deliberately undefined implementation. There are two common representations for complex numbers, and each is best suited for different types of computation.  The inability to force a particular representation seemed to be a serious programming limitation and a &quot;numerical analysis nightmare.&quot;  But the particular issues involved are not really the point.<P>
The point in that we have a standardization process functioning largely behind closed doors, without a broad base of general input from the real users of the system under definition.  The real users of a Pascal system are individual Pascal programmers.  Where are all the comments from these users?  When were they contacted?  How are they being kept informed?  Why were no standardization discussions printed in popular programming magazines?  Although I am a member of IEEE, I cannot imagine that this organization is the appropriate sponsor of a programming language standard; a better-suited organization would seem to be the software-oriented ACM.<P>
This experience has taught me a lot about what a standard really means.  First of all, there is no reason to think that voting should produce a good standard.  Design should be an exercise in consistency and correctness, something not conferred by a winning vote.  Indeed, voting for Clarity seems unpopular, possible (cynically) because if a normally intelligent person could simply read the standard, they might not need an expert consultant to help interpret it.<P>
And, when you think about it, democratic voting is itself an adversarial process (indeed, a form of ritualized combat).  There may be a substantial minority which is firmly opposed to the outcome, and in scientific or engineering disputes, the minority view may well be correct.  Moreover, as in the case of our national political parties, those in the minority have an honorable duty to continue their opposition, if they feel it to be right, against the day when their arguments may prevail.  Thus, it is important that not everyone change the way they do things simply because a particular design is voted &quot;standard.&quot;  And there is certainly no reason to force programming classes to use a particular language selected by some elitist committee.<P>
At one time there was some discussion in DDJ of Borland's Turbo Pascal with respect to the Pascal &quot;standard.&quot;  I used to wonder why Turbo Pascal did not provide a Standard Pascal mode, but, after studying the Extended Pascal draft standard, now I know: Standard Pascal is a turkey.   Although I do have some differences with the Turbo Pascal design, it is a fine language for program expression; it is also clearly described in a structured manner.  Perhaps Turbo Pascal represents the product for the loyal opposition.<P>
Our standards process could be based on the more democratic and obviously more successful Japanese approach of building a widely held consensus, in which case the standards would carry some real weight.   But in this Pascal standardization effort, we instead see Ugly American political domination in action.  We see back room maneuvering for ANSI institutional support of a particular design, essentially without regard for, or input from, most of the real potential users.  This is not democracy, and it may be time for a change.<P>
Terry Ritter, P.E.<P>
Blue Jean Computer Engineering<P>
Austin, Texas<P>
<h3><a name="005a_0003">Container Object Fix<a name="005a_0003"></h3><P>
Dear DDJ,<P>
I really am glad to see the number of OOPS articles that have been in DDJ recently.  I especially appreciated Anders Hejlsberg's article on container objects (&quot;Container Object Types in Turbo Pascal,&quot; Nov. 1989), but have found several errors in the code listings:<P>
In Listing one, function ListNode.Prev, change the two references to Self to reference the address of Self (@Self) as follows:<P>
<pre>
P:=@Self;
while P^.Next&lt;&gt;@Self do P:=P^.Next;</pre><P>
The code will not compile without the above changes, as self is a listnode object type while P is a ListNodePtr type.<P>
In Listing two, change the with statement in procedure GetIdent by adding an address operator to Name as follows:<P>
<pre>with IdentRefPtr(Idents.Search(@Name,NewIdent))^ do</pre><P>
The first parameter to search (the key) should be a pointer.<P>
One useful addition to the list methods is a procedure to concatenate two lists.  The circular list type in the contain unit can be efficiently concatenated by swapping the two lists last.next pointer.<P>
In a circular list representation, last.next points to the first list element.  Given the list {a,b,c}, a.next-&gt;b, b.next-&gt;c, and c.next-&gt;a.  Last is a pointer to c.  To concatenate list {d, e, f}, all we need to do is make f.next point to a and c.next point to d.  In other words, the last^.next pointers of the two lists need to be swapped.  Then the last variables of the lists need to be adjusted.<P>
<pre>  
  	unit Concat;
  	interface

  	Uses Contain; {from DDJNov. '89 type
  	CatListPtr = ^CatList; CatList = object(List)
        procedure cat(L: CatListPtr); end;
  	implementation
  	Procedure CatList.Cat(L: CatListPtr);
  	{Concatenate list L to the list invoking the method 
  	- L is appended to the END of the list being acted on.}

Var P: ListNodePtr; {temporary} Begin
    {swap the two pointers}
    P:= Last^.Next;
    Last^.Next:= L^.Last^.Next;
    L^.Last^.Next:= P;

   {adjust pointers}   
   Last := L^.Last;
   L^.Last := NIL; End; END.</pre><P>
Eric Friedman<P>
Glenview, Illinois<P>
<h3><a name="005a_0004">Delving into Drive Paths<a name="005a_0004"></h3><P>
Dear DDJ,<P>
I have been able to make a great deal of use of the information in Mr. James' article, &quot;Undocumented DOS,&quot; June, 1989.  In the process, I have determined a more precise definition of the Drive Path Table that he presented.  Perhaps some of your readers will find this information as useful as I have.<P>
The Drive Path Table is as follows.  (Note that some of the following information is in direct conflict with the information presented by Mr. James.)<P>
The number of entries in the Drive Path Table is set by the LASTDRIVE=xx command in your CONFIG.SYS file.  To access the Drive Path Table for a particular drive, start with the drive number (0 = A, 1 = B,...) and make sure it is less than the LASTDRIVE=xx value; if it is not less, the drive number is invalid.  (See Mr. James' article, Table 2, byte 21H.)  If the drive number is valid, multiply it by 51H and add that value to the Drive Path Table pointer (same article, same table, offset 16H).  The resulting 32-bit value points at the Drive Path Table entry for that drive.<P>
For normal drives, the pathname field contains the current default pathname (e.g. C:\MY_PATH), the flags field has the value 4000H, and the root-length field has the value 2.<P>
For unused drives, the flags field has the value 0.  All remaining fields are set to all 0s or all 1s, except the pathname field, which contains the drive letter, a colon, and a '\'.<P>
For drives created with the SUBST command, the pathname field contains the target path, the flags field has the value 5000H, and the root-length field is set to the length of the target path.  For example, after executing the command SUBST E: C:\BIN the pathname field for drive E would be &quot;C:\BIN&quot;, and the root-length field would have the value 6.<P>
Now, if you change directories on drive E (e.g. CD E:NEXT) the pathname field is updated (C:\BIN\NEXT) but the root-length field remains unchanged at 6.<P>
If you use the JOIN command on a drive, the pathname field contains the path to which the drive is joined, the flags field contains the value 6000H, and the root-length field is set to 2.  For example, after the command JOIN A: C:\DRIVEA the pathname field for drive A would be &quot;C:\DRIVEA&quot;.  Because drive A is no longer a valid drive, you cannot change the current default directory of this drive.  If you CD to C:\DRIVEA\ANYPATH, that pathname is stored in the Drive Path Table entry for drive C, not A.<P>
For network drives, the pathname field contains the network name, followed by the network path; the network name is preceded by two back-slashes.  The flags field contains the value 0C000H, and the root-length field is set to the length of the combined network name and path strings.  For example, after the command NET USE F: \\MYNET\MYPATH the pathname field for drive F would contain &quot;\\MYNET\MYPATH&quot;, and the root-length field would contain the value 14.<P>
<a href="9002m.htm#005a_0005">More Details.</A><P>
<pre><a name="005a_0005"><a name="005a_0005">
  Offset    Size     Description
  --------------------------------------------------------
  0         byte     pathname: an ASCIIZ string.
            [67]
  43H       word     flags:
                     8000H a network drive.
                     4000H this entry is valid.
                     2000H a JOIN drive.
                     1000H a SUBST drive.
  45H       dword    pointer to the drive parameter block.
  49H       word     block/track/sector information.
  4BH       dword    unused (set to 0FFFFFFFFH)
  4FH       word     root length.
</pre><P>
Now, if you change directories on drive F (e.g. CD F:NEXT) the pathname field is updated (\\MYNET\MYPATH\NEXT) but the root-length field remains unchanged at 14.<P>
For network drives, the last few fields of the Drive Path Table are redefined slightly.  Beginning at offset 45H, the Drive Path Table becomes:<P>
<pre>
  45H   dword   unused (set to 0)
  49H   dword   pointer to a
                network drive table
  4DH   word    saved parameter
  4FH   word    root length
</pre><P>
<P>
The pointer at offset 49II points into a linked list of network devices (drives and printers).<P>
The saved-parameter field stores a user-defined value.  This value is selected when the drive is created.  (See INT 21H function 5F03H.)  I suppose it would be used by someone writing a network driver, who needed to keep track of additional information about the drive.<P>
When accessing the Drive Path Table, you should be aware of the ASSIGN command.  If the ASSIGN command has been invoked, it will automatically translate drive letters that are passed through the conventional INT 21H function calls.  But, it will NOT translate these drive letters as you access the Drive Path Table directly.<P>
In DOS 3.xx, you can determine whether ASSIGN is installed (ASSIGN is a TSR) like this:<P>
<pre>
MOV    	AX,0600H
INT   	2FH   
OR     	AL,AL   
JZ		NOTINSTALLED   
88</pre><P>
If ASSIGN is installed, you can get a pointer to its translation table like this:<P>
<pre>
MOV  	AH,19H    
INT  	21H  
PUSH   	AX; save the current default drive
MOV  	AX,0601H  
INT  	2FH   
POP    	DX; restore the drive
MOV  	AH,0EH    
INT  	21H   
MOV 	AL,ES:[0103H+drivenumber1] ;drivenumber: 1=A, 2=B, . . .</pre><P>
The translation table is always 26 bytes.  By default, each drive is assigned to itself (e.g. entry 1=1, entry 2=2, . . .).  After an assignment such as ASSIGN A=C, entry 1 gets the value 3, and then all attempts to access drive A are routed to drive C.<P>
Thus, whenever you access the Drive Path Table, you should index the drive number into the ASSIGN translation table, if it exists.  And if you use the pathname field, you should reverse-assign the drive letter therein.<P>
Reverse-assigning a drive letter means scanning the ASSIGN translate table to find a drive number that, when translated, will result in the drive letter that appears in the Drive Path Table pathname field.  And be prepared that you may not be able to find such a drive number.<P>
For DOS 2.xx, I do not know of a reliable way of determining whether the ASSIGN command is installed.  The ASSIGN command tries to detect itself, but the method it uses is not the elegant INT 2FH interface, and it fails under certain circumstances.<P>
To detect itself, DOS 2.xx ASSIGN looks at the first few bytes pointed at by the INT 21H interrupt vector.  If those bytes match the first few bytes of ASSIGN's INT 21H handler (80, FC, 0C, 76, 2D, 80, FC, 50), ASSIGN decides that it is already installed.  Rather than installing a second copy of itself, ASSIGN updates the installed translation table, and exits quietly.  (To access the installed translation table, ASSIGN uses the segment value from interrupt vector 21H and an offset value of 0103H.)<P>
The problem is that, after installing ASSIGN, if you install any TSR that also has an INT 21H handler, this detection scheme falls.  In fact, if you run the ASSIGN command again under these circumstances, it will install itself a second time.  This will likely cause strange results, because the drives may be translated multiple times.<P>
If, when working with drives, your program uses exclusively one method or the other (that is, either conventional interfaces or undocumented interfaces, but not both) then you probably need not worry about the ASSIGN command.<P>
If you must use both interfaces, and you want your program to work correctly in DOS v2.xx, you should warn the program's users about the restrictions regarding the DOS 2.xx ASSIGN command.<P>
In summary, the Drive Path Table allows access to information that would not otherwise be available to normal programs (i.e. the JOIN and SUBST information.)<P>
Michael Cook<P>
Mitel Semiconductor<P>
Kanata, Ontario<P>
<h3><a name="005a_0006">Graphics For the Rest of Us<a name="005a_0006"></h3><P>
Dear DDJ,<P>
I found the interview with David Parker in Michael Swaine's column entitled &quot;Parker's Perceptions&quot; in the October 1989 DDJ especially interesting since I'm a very satisfied user of his &quot;AcroSpin&quot; graphics software.  I'd known nothing about the person behind it!<P>
Swaine says &quot;it seems to have a good product,&quot; and I can testify that it does indeed.  My colleagues and I need to do 3-D graphics in a variety of languages, on a number of different IBM PC compatible machines.  We also cannot afford fancy hardware; my own machine doesn't even have a hard drive.<P>
AcroSpin is the only product I've seen that does the things I need on the hardware I've got.  On all our PC's at this institution, I've yet to encounter one that has some kind of graphics and cannot run AcroSpin.  It's clean, simple, and does exactly what the manual says it'll do.<P>
Matthew D. Healy<P>
Zoology graduate student<P>
Duke University, North Carolina<P>
<h3><a name="005a_0007">FPCA '89 Proceedings<a name="005a_0007"></h3><P>
Dear DDJ,<P>
I very much enjoyed Ronald Fischer's report on functional programming and FPCA '89.  I must take issue with Mr. Fischer on one point.  He states that &quot;Scheme is a deviation of Lisp that doesn't offer lazy evaluation.&quot;  Scheme certainly does offer delayed (lazy) evaluation, via the DELAY and FORCE primitives.  See, for instance, Chapter 3 of Abelson, Sussman, and Sussman's Structure and Interpretation of Computer Programs for a superb introduction to streams and delayed evaluation in Scheme.<P>
I was disappointed that the article did not mention how to obtain the conference proceedings.  Could you provide this information?<P>
David Cabana<P>
Tampa, Florida<P>
<P>
<P>
</pre></BODY></HTML>
