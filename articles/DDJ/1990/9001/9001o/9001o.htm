<HTML>
<META NAME="year" CONTENT="1990">
<HEAD>

<TITLE>JAN90: LETTERS</TITLE></HEAD>
<body bgcolor="FFFFFF">
<h1>LETTERS<a name="001d_0001"><a name="001d_0001"></h1><P>
<h3></h3><P>
<h3><a name="001d_0002">Stymied by C<a name="001d_0002"></h3><P>
Dear DDJ,<P>
I thoroughly enjoy Jeff Duntemann's &quot;Structured Programming&quot; column in DDJ.  It's always easy to enjoy someone I agree with!  Besides having a fondness for structured programming and Turbo Pascal, I also share his coolness towards C.  Which brings me to the main reason for this letter.  I have a software project where I must use some C routines provided for me in .LIB files.  I have Microsoft QuickC out of necessity, and Turbo Assembler/Turbo Pascal 5.5 out of preference.  What I would like to do is somehow hook the canned C routines from Turbo Pascal. The kind of applications I'll be working on lend themselves well to objects, as does my way of thinking.  My hope is that there is some way to build a TP unit that has TP procedures/functions that actually are calling the C functions.  Once this unit is established I could happily turn my back once again on C.  What I'd have is a reusable unit with the C hidden an arm's length away.<P>
Is a hook like this possible?  Perhaps some assembly interface calling the C and in turn being called by the TP code?  I don't have access to the C library source code itself but maybe I could write enough C code to call the canned functions with built-in hooks?  I've done more in TP than either C or assembly but have dabbled in both.  I have worked with externals written in assembly and called from Turbo Pascal, modifying already written code, but need a little hand holding if this is the route to go with this problem.  I'd really appreciate any help Jeff could offer.<P>
Dale Lucas<P>
Cedar Rapids, Iowa<P>
Jeff responds: Without being able to modify and recompile your C libraries, you're stuck. It's a matter of who cleans up whose messes.  When C code calls a C function, the caller sets up the stack frame, calls the function, and then (when the function returns control to the caller) the caller cleans up the stack by removing parameters.<P>
Pascal, on the other hand, requires that the function (or procedure) clean up the stack before returning control to the caller.  The caller assumes that it receives a clean stack after each call.  The two systems are completely incompatible, although, some C compilers, including Microsoft's, allow you to specify Pascal calling conventions as an option.  If you could recompile your C code, you could invoke this option and make the two worlds coexist peaceably.<P>
C does what it does to allow the number of parameters passed to a function to vary from one call to the next.  To each his own; some people eat fugu and deserve whatever they get.  I take some comfort in nothing that operating system API calls use the Pascal calling conventions; evidently OS architects draw the line at risking the system's neck for this kind of silliness.<P>
But that doesn't solve your problem.  If you only have .LIBs, well, shucks, you have two choices:<P>
<ul>
<li>Become a sadomasochist, embrace the C language, and work twice as hard as you need to in order to get your work done for the rest of your career.  On the plus side, this entitles you to wear a T-shirt reading, &quot;Look what a big tough macho hacker I am!&quot;</li>
<li>Give your gracious benefactor his C code back and recode the routines from the interface spec in Pascal.  Dimes to donuts you'll spend less time recording the C routines in Pascal than you would recoding your app in C.</li>
</ul>
Maybe I'm only half-a-hacker ... I like to take a little time now and then to neck with my wife, build radios, and throw the rag for Mr. Byte.  I get my C in orange juice.  I'd advise you to do the same.<P>
<h3><a name="001d_0003">DDJ Passes the Acid Test<a name="001d_0003"></h3><P>
Dear DDJ,<P>
Many times during the last year I was on the verge of deciding to let my subscription to DDJ lapse, as it had apparently turned into a fanzine for 386 and DOS groupies.  One more article on cute tricks in C, how to write TSRs, and the 640K barrier would have done it.<P>
Then Michael Swaine's interview with Hal Hardenbergh made me give it one more month.  The September issue made me give it another year, and I have sent in my renewal.  Five out of six articles were of interest to non-DOS, non-PC programmers!<P>
For 1990, please make at least half the articles in any issue independent of platform and language, i.e., of interest and value to programmers on any machine using any language.<P>
If you wonder where I am coming from, I am a chemist; I write about 10,000 lines of code a year for my research, in Pascal (by preference), C (by necessity), and (ugh!)  Fortran.  I use a VAX station and a networked VAX cluster for programming, PCs for document processing, and Macintoshes for making slides and figures.  I am currently using neural nets and simulated annealing.  I am sure you have many readers who, like me, do no programming on PCs, but who are always on the lookout for new programming techniques and useful algorithms.<P>
Ernest W. Robb<P>
Glen Rock, New Jersey<P>
DDJ responds: You've hit on what DDJ is really all about, Ernest -- sharing new programming techniques and handy algorithms -- and we'd like to hear from anyone who has some to share.<P>
<h3><a name="001d_0004">DFS At Work<a name="001d_0004"></h3><P>
Dear DDJ,<P>
I read Rabindra Kar's article &quot;Data-Flow Multitasking&quot; in the November 1989 issue of Dr. Dobb's Journal and enjoyed it very much.  The title of the article attracted my attention first because, as part of my job for the past three years, I designed and was principal developer of a data analysis system based on what he termed data-flow multitasking (I've been calling it data-flow processing).  Currently this system consists of 58 fittings (programs which tap into a data flow) with support libraries consisting of 264 functions.  Fittings may be written in either C or Fortran, and the system runs under Unix and VMS.<P>
This system (which I call the Data-Flow System or DFS) takes a slightly different approach to establishing the aggregate task.  Instead of making each processing element of the task a function in an application, each element is itself an application which can be &quot;connected&quot; to any other element.  The main reason for this approach was to make it easier for the user to construct aggregate tasks without the need to deal with a programming language.  This approach also allows fittings to be written in the programming language which best implements the task.<P>
The variety of fittings in this system is quite broad.  There are fittings for reading and writing data, analysis, dataflow management, and data visualization.  It is also easy for a user to develop a new fitting to match any special needs.  The DFS also has several different interfaces; they include a batch type interface, an interpreter, and a fully menu-driven interface.  We have also developed a specialized interface which a user can navigate through and create an SQL query.  This query is then integrated into an aggregate task, which extracts the data from one or more data nodes in a network (a distributed data base) and then presents the data locally for viewing.<P>
The system I've described is in use where I work (The Institute of Geophysics and Planetary Physics at UCLA)and at several other locations which are involved with space physics research.  I'd be happy to supply more information if anyone's interested.  I must compliment Robin on the clarity of his presentation and the succinct way in which he described the concept.  It was a very good article.<P>
Todd King<P>
Los Angeles, California<P>
<h3><a name="001d_0005">C Dynamic Strings<a name="001d_0005"></h3><P>
Dear DDJ,<P>
Just finished Al Stevens's column in the October issue, with special interest in his item on dynamic strings in C.  The ease of string manipulation in Basic is one of the reasons I keep using it and haven't switched entirely to C (besides the fact that I still have to keep the old Z80 Radio Shack alive for my wife).<P>
A few years ago I picked up Alcor C for the R/S.  Never did anything big with it because I couldn't fit much into a 30K workspace anyway....  When I saw Al's item on strings I dug up the old manual because I remembered that Alcor had dynamic strings in those old days using a structure defined in stdio, along with a couple of conversion functions and extensions of printf and scanf.  Their implementation was a simple structure with a length byte and a char array, but it worked.<P>
Alcor C is still around.  I think it's MIX C now; at least the company is in the same town and still lowballs everybody on price.  It was available back then for Apple II, CP/M, and Radio Shack machines.  I got it originally as a learning tool, which it served well as.  It was not industrial strength; any word on the condition if MIX these days?  At the price ($19.95 last I saw) it must be worth something.<P>
Al, keep up the good writing.  By the way, this comes via US Mule because I couldn't find a CompuServe address for you or DDJ.  I did find the DDJ Forum, but no listing for Al to send a message.<P>
Michael Brady<P>
Fresno, California<P>
Thanks, Michael.  Al's CIS address is 71101, 1262; DDJ's is 76704,50.<P>
<h3><a name="001d_0006">And New Wave Begat....<a name="001d_0006"></h3><P>
Dear DDJ,<P>
In regard to Michael Swaine's column titled &quot;Unbundled Integration,&quot; in the August 1989 issue of Dr. Dobb's Journal, I would like to make the following observations.  The &quot;most interesting&quot;feature of the Apple System Version 7.0 release, the InterApplication Communications architecture (IAC) is indeed an interesting development.  Over a year ago, Hewlett-Packard demonstrated this capability as a feature of its NewWave environment.  (I guess imitation really is the sincerest form of flattery, especially when the imitator has pending legal action against the imitatee for imitating the imitator!)  NewWave is part of the user interface proposed by the Open Software Foundation as Motif.<P>
HP's term for dynamic cut-and-paste is &quot;shared links.&quot;  With NewWave, a user &quot;shares&quot; and &quot;establishes a view to&quot; data, while an IAC user &quot;publishes&quot;and &quot;subscribes to&quot; data.  It probably makes little difference to a user which set of new terms must be learned to use this feature, but I think I'd prefer almost any set of terms that doesn't remind me of the recent spate of renewal notices I seem to keep getting from computer industry publications, in direct proportion to the number of years for which I've renewed my subscriptions to them!  The important thing to remember is that it looks like the folks responsible for these windowing environments are making good on yet another implied promise -- software that remains integrated even after one program changes.  More power to them all and the Flames of Swaine!<P>
Lawrence T. Prevatte, III<P>
Cape Canaveral, Florida<P>
<h3><a name="001d_0007">Finite State's Rights<a name="001d_0007"></h3><P>
Dear DDJ,<P>
Donald Smith's article (October 1989), &quot;Finite State Machines for XModem,&quot;was a timely help. I recently proposed an FSM design to a client who had not heard of FSM.  Donald's article added credibility to my proposal.<P>
I have used FSMs to manage communication protocols, to manage user interfaces, and to implement control logic.  Using FSMs often, I implemented a translator and C library called &quot;The State Machine,&quot; which is just what Donald suggested as a coding technique. Interestingly, the code that this translator generates looks remarkably similar to Donald's hand-coded state machine.  I have developed an example, &quot;MENUS,&quot; which uses an FSM to control the navigation about a menu-driven user interface.  The state diagram that was the original design document for this example was directly encoded into a language called &quot;State Transition Description Language&quot;(STDL).  The state machine has a number of unique features: It aids memory reduction and improved productivity by supporting encapsulation with both macros and callable substates.  The capability to call substates is very useful when implementing user interfaces with submenus.  Debugging is simplified by a trace option which can generate a log of all state transitions that occur during execution.  This option can be turned off to minimize memory requirements.  Actions are C functions which can have any number of arguments.  An event or stimulus is defined by a Boolean C function.  The state machine comes with several predefined action and event functions.<P>
There are many parallels between the implementation philosophy of the state machine and the mini-interpreters described by Abrash and Illowsky in their article (September 1989), &quot;Roll Your Own Minilanguages with Mini-Interpreters.&quot;<P>
For those with a champagne budget, there is a sophisticated CASE tool available from i-Logix called &quot;Statemate.&quot;  It has several powerful features: Statemate is a graphic tool.  State diagrams are drawn interactively.  The tool integrates a data base and an interpreter that supports complex events and actions.  Documentation can be generated automatically from the data base.  State diagrams can be executed using Statemate's simulator or they can be executed from C or Ada code generated by Statemate's prototyper.  FSMs defined by Statemate can be decomposed.  This capability is based upon a rigorous mathematical theory developed by David Harel.  It is important for complex systems which would otherwise explode into hundreds of states.<P>
Rob Buck<P>
Aerosoft<P>
Fairfield, Iowa<P>
<h3><a name="001d_0008">Graphics For the Rest of Us<a name="001d_0008"></h3><P>
Dear DDJ,<P>
I found the interview with David Parker in Michael Swaine's column entitled &quot;Parker's Perceptions&quot; in the October, 1989 DDJ especially interesting since I'm a very satisfied user of his &quot;AcroSpin&quot; graphics software.  I'd known nothing about the person behind it!<P>
Swaine says &quot;it [Acrobits] seems to have a good product,&quot; and I can testify that it does indeed.  My colleagues and I need to do 3-D graphics in a variety of languages, on a number of different IBM PC compatible machines.  We also cannot afford fancy hardware; my own machine doesn't even have a hard drive.<P>
AcroSpin is the only product I've seen that does the things I need on the hardware I've got.  On all our PCs at this institution, I've yet to encounter one that has some kind of graphics and cannot run AcroSpin.  It's clean, simple, and does exactly what the manual says it'll do.<P>
Matthew D. Healy<P>
Zoology graduate student<P>
Duke University, North Carolina<P>
<h3><a name="001d_0009">Down Those Hallowed Halls<a name="001d_0009"></h3><P>
Dear DDJ,<P>
Funny how time alters everything.  When Jeff Duntemann opened his September 1989 &quot;Structured Programming&quot; column with a mention of his high school days, I had to pull out my copy of the Lane Arrowhead '70 and look him up.  If he still has his copy, he can find me on pages 27 and 126.  He must have picked up on computers in college.<P>
OOPs, it still leaves me in the dark.  I guess for my PUNishment, I will have to rewrite Fortran into Basic.  I enjoyed his column.  Take care.<P>
Thomas Kocourek<P>
Carrollton, Georgia<P>
<h3><a name="001d_000a">Magnitude, Made to Order<a name="001d_000a"></h3><P>
Dear DDJ,<P>
In Michael Swaine's November editorial on innumeracy, his accusation of an error in John A. Paulos's book, Innumeracy, is based on a misunderstanding of the term &quot;order of magnitude.&quot; He starts off okay, by stating his deduction that Paulos uses the expression &quot;order of magnitude&quot; to mean &quot;a power of ten.&quot;  He goofs when he asserts that magnitude (plural) means &quot;powers of one hundred.&quot;  This is wrong.  Any scientist will tell you that scientists use the term &quot;orders of magnitude&quot; to mean &quot;powers of ten,&quot; for example:<P>
If quantity A is ten times greater than quantity B, then A is said to be one order of magnitude greater than B.  If A is one hundred times greater than B, then A is said to be two orders of magnitude greater than B.<P>
Getting back to the example of the malaria safety index that Swaine cited, for the malaria index to be &quot;orders&quot; of magnitude lower in most of the world than in the United States merely means that the actual risk of malaria (defined as the total population count divided by the number of people in that population who catch malaria) is at least one hundred times higher (i.e. at least two orders of magnitude higher) than in the United States.  (Remember that on Paulos's scale, the lower the index number, the greater the risk.)  By using the correct definition of &quot;orders of magnitude&quot; we see that Paulos's assertion is indeed within the realm of plausibility.<P>
Swaine's misunderstanding of the term &quot;order of magnitude&quot; is understandable, because written definitions of this term in dictionaries (even scientific ones) are hard to come by. The use of orders of magnitude in calculations has been spread by word-of-mouth among scientists and has not been exposed to the general public (except by Carl Sagan in his Cosmos series).  Despite the mistake, I thank Mr. Swaine for addressing the issue of innumeracy in his editorials.<P>
Gregory B. Goslen<P>
Research Triangle Park, N. Carolina<P>
<h3><a name="001d_000b">Zortech Heard From...<a name="001d_000b"></h3><P>
Dear DDJ,<P>
We read with interest Al Stevens's column on C++ in the October issue of DDJ.  Imagine our surprise, when on pg. 128 we read the statement: &quot;...not until Borland and Microsoft introduce C++ compilers, complete with integrated development environments and hotshot debuggers, can PC developers get serious about it.&quot;<P>
Are you actually saying that only a couple of vendors are allowed to produce a C++ system for MS-DOS?  That sort of statement belongs in company marketing literature, not in a well-respected publication like DDJ, where developers look for impartial editorial content.<P>
Zortech has over 50,000 users now, including virtually every major corporation.  Many are switching to the Zortech C++ compiler as their preferred development tool.  How much more serious can developers get than to switch from C to C++ for their next generation products? This is happening now, and we would be delighted to provide Al with a list of major corporations who are developing with Zortech C++.<P>
Incidently, the &quot;integrated environment and hot-shot debugger&quot; requested by Al is now available with the release of Zortech C++ V2.0 Developer's Edition.  It is a full-blown development system including the world's first MS-DOS C++ Source-Level Debugger, AT&amp;T C++ V2.0 compatibility, and many other enhancements.  Our entire company is focused on C++.  It isn't a sideline for us and doesn't play second fiddle to other languages, wordprocessors, spreadsheets, or database packages.<P>
Walter Bright<P>
Director of Technologies<P>
Zortech Inc.<P>
<h3><a name="001d_000c">The Foot Bone's Connected to the Head Bone<a name="001d_000c"></h3><P>
Dear DDJ,<P>
The correct answer to the question posed to Michael Swaine in New Orleans (December 1989 DDJ), &quot;Where you got your shoes?&quot; is &quot;You got your shoes on your feet!&quot;<P>
I had to tell you...<P>
Harold O. Koenig<P>
Scottsville, Virginia<P>
<h3><a name="001d_000d">Disrobing the Emporer<a name="001d_000d"></h3><P>
Dear DDJ,<P>
Thank you for publishing Mr. Guthery's informative article, &quot;Are the Emporer's New Clothes Object-Oriented?&quot; in the December 1989 issue.  Amidst all of the hype, it's good to see some reason appear.  Now, I can say: &quot;OOPS!  Did they really do that?&quot;  Rather than being an advance, object-oriented programming seems to be regressive.<P>
Regressive?  Yes, it's a return to &quot;spaghetti code&quot; and violates the basic tenets of writing well-structured programs.  It was this type of violation by the excessive use of GOTOs that led to Dykstra's letter to the ACM in 1969 and the ensuing interest in structured programming.<P>
In well-structured programs, the structure is a tree whose nodes are the program modules. Each node in a tree may have one and only one father, but, of course, may have has many children as necessary to do the job.  As defined in the literature, an object is a module that may receive a message (be called) from any number of sources and may send messages to (call) other objects.  Thus, an object is a structural node that may have more than one father -- a rather unnatural situation!  Can you imagine the difficulties when trying to debug a module entered from who-knows-where?<P>
Instead of coming up with new buzz words like OOP, the language of developers should heed our desires for more granularity in the libraries associated with various compilers.  This was pointed out admirably by Bruce W. Tonkin in his &quot;Examining Room&quot;column on PDQ in the same issue.<P>
If you keep coming up with articles like the two I've mentioned, I'm afraid I'll have to subscribe to DDJ.  Thanks.<P>
Dan W. Crockett<P>
Queen Valley, Arizona<P>
<P>
<P>
</pre></BODY></HTML>
