<HTML>
<META NAME="year" CONTENT="1990">
<HEAD>

<TITLE>NOV90: SOFTWARE PATENTS</TITLE></HEAD>
<body bgcolor="FFFFFF">
<h1>SOFTWARE PATENTS<a name="023f_0003"><a name="023f_0003"></h1><P>
<h2><a name="023f_0001"><a name="023f_0000">Is this the future of programming?</h2><P>
<h3>by The League for Programming Freedom</h3><P>
<p><i><a name="023f_0002"><a name="023f_0000">This article is a position paper of the League for Programming Freedom, an organization opposed to software patents and interface copyrights and whose members include, among others, Marvin Minsky, John McCarthy, and Robert S. Boyer.  Richard Stallman and Simson Garfinkel helped prepare this article for publication.  You can contact the League through Internet mail (league @ prep.ai.mit.edu) or at 1 Kendal Square #143, P.O. Box 9171, Cambridge, MA 02139.</i></p><hr><P>
Software patents threaten to devastate America's computer industry.  Newly granted software patents are being used to attack companies such as Lotus and Microsoft for selling programs that they have independently developed.  Soon new companies will be barred from the software arena -- most major programs will require licenses for dozens of patents, and this will make them infeasible.  This problem has only one solution: Software patents must be eliminated.<P>
<h3><a name="023f_0004">The Patent System and Computer Programs<a name="023f_0004"></h3><P>
The Framers of the United States Constitution established the patent system so that inventors would have an incentive to share their inventions with the general public.  In exchange for divulging an invention, the patent grants the inventor a 17-year monopoly on the use of the invention.  The patent holder can license others to use the invention, but may also refuse to do so.  Independent reinvention of the same technique by others does not give them the right to use it.<P>
Patents do not cover specific computer programs; instead, they cover particular techniques that can be used to build programs, or particular features that programs can offer.  Once a technique or feature is patented, it may not be used in a program without the permission of the patent holder -- even if it is implemented in a different way.  Since a program typically uses many techniques and provides many features, it can infringe many patents at once.<P>
Until recently, patents were not used in the software field.  Software developers copyrighted individual programs or made them trade secrets.  Copyright was traditionally understood to cover the implementation details of a particular program; it did not cover the features of the program, or the general methods used.  And trade secrecy, by definition, could not prohibit any development work by someone who did not know the secret.<P>
On this basis, software development was extremely profitable and received considerable investment, without any prohibition on independent software development.  But this scheme of things is no more.  A few U.S. software patents were granted in the early 1980s, stimulating a flood of applications.  Now many patents have been approved and the rate is accelerating. Many programmers are unaware of the change and do not appreciate the magnitude of its effects.  Today the lawsuits are just beginning.<P>
<h3><a name="023f_0005">Absurd Patents<a name="023f_0005"></h3><P>
The Patent Office and the courts have had a difficult time with computer software.  The Patent Office refused until recently to hire computer science graduates as examiners, and in any case does not offer competitive salaries for the field.  Patent examiners are often ill-prepared to evaluate software patent applications to determine if they represent techniques that are widely known or obvious -- both of which are grounds for rejection.  Their task is made more difficult because many commonly used software techniques do not appear in the scientific literature of computer science: Some seemed too obvious to publish while others seemed insufficiently general.<P>
Computer scientists know many techniques that can be generalized to widely varying circumstances.  But the Patent Office seems to believe that each separate use of a technique is a candidate for a new patent.  For example, Apple has been sued because the HyperCard program allegedly violates patent number 4,736,308, a patent that covers displaying portions of two or more strings together on the screen -- effectively scrolling with multiple subwindows.  Scrolling and subwindows are well-known techniques, but combining them is apparently illegal.<P>
The granting of a patent by the Patent Office carries a presumption in law that the patent is valid.  Patents for well-known techniques that were in use many years before the patent application have been upheld by federal courts.<P>
For example, the technique of using exclusive-or to write a cursor onto a screen is both well-known and obvious.  (Its advantage is that another identical exclusive-or operation can be used to erase the cursor without damaging the other data on the screen.)  This technique can be implemented in a few lines of a program, and a clever high-school student might well reinvent it.  But it is covered by patent number 4,197,590, which has been upheld twice in court even though the technique was used at least five years before the patent application. Cadtrak, the company that owns this patent, collects millions of dollars from large computer manufacturers.<P>
English patents covering customary graphics techniques, including airbrushing, stenciling, and combination of two images under control of a third, were recently upheld in court, despite the testimony of the pioneers of the field that they had developed these techniques years before.  (The corresponding United States patents, including 4,633,416 and 4,602,286, have not yet been tested in court, but they probably will be soon.)<P>
All the major developers of spreadsheet programs have been threatened on the basis of patent 4,398,249, covering &quot;natural order recalc,&quot; the recalculation of all the spreadsheet entries that are affected by the changes the user makes, rather than recalculation in a fixed order. Currently Lotus alone is being sued, but a victory for the plaintiff in the case would leave the other developers little hope.  (The League for Programming Freedom has found prior art that may defeat this patent, but this is not assured.)<P>
<a href="9011e.htm#023f_0017">More Details.</A><P>
Nothing protects programmers from accidentally using a technique that is patented -- and then being sued for it.  Taking an existing program and making it run faster may also make it violate half a dozen patents that have been granted, or are about to be granted.<P>
Even if the Patent Office learns to understand software better, the mistakes it is making now will follow us into the next century, unless Congress or the Supreme Court intervenes to declare these patents void.<P>
However, this is not the whole of the problem.  Computer programming is fundamentally different from the other fields that the patent system previously covered.  Even if the patent system were to operate &quot;as intended&quot; for software, it would still obstruct the industry it is supposed to promote.<P>
<h3><a name="023f_0006">What is &quot;Obvious&quot;?<a name="023f_0006"></h3><P>
The patent system will not grant or uphold patents that are judged to be obvious.  However, the system interprets the word &quot;obvious&quot; in a way that might surprise computer programmers. The standard of obviousness developed in other fields is inappropriate for software.<P>
Patent examiners and judges are accustomed to considering even small, incremental changes as deserving new patents.  For example, the famous Polaroid vs. Kodak case hinged on differences in the number and order of layers of chemicals in a film -- differences between the technique Kodak was using and those described by previous, expired patents.  The court ruled that these differences were unobvious.<P>
Computer scientists solve problems quickly because the medium of programming is tractable. They are trained to generalize solution principles from one problem to another.  One such generalization is that a procedure can be repeated or subdivided.  Programmers consider this obvious -- but the Patent Office did not think that it was obvious when it granted the patent on scrolling multiple strings as described above.<P>
Cases such as this cannot be considered errors.  The patent system is functioning as it was designed to do -- but with software, it produces outrageous results.<P>
<h3><a name="023f_0007">Patenting What is too Obvious to Publish<a name="023f_0007"></h3><P>
Sometimes it is possible to patent a technique that is not new precisely because it is obvious -- so obvious that no one would have published a paper about it.<P>
For example, computer companies distributing the free X Window System (developed by MIT) are now being threatened with lawsuits by AT&amp;T over patent number 4,555,775, covering the use of &quot;backing store.&quot;  This technique is used when there are overlapping windows; the contents of a window that is partly hidden are saved in off-screen memory, so they can be put back quickly on the screen if the obscuring window disappears (as often happens).<P>
The technique of backing store was used in an earlier MIT project, the Lisp Machine System, before AT&amp;T applied for the patent.  The Lisp Machine developers published nothing about this detail at the time, considering it too obvious.  It was mentioned years later when the programmers' reference manual explained how to turn it on and off.<P>
The Lisp Machine was the first computer to use this technique only because it had a larger memory than earlier machines that had window systems.  Prior window system developers must have dismissed the idea because their machines had insufficient memory space to spare any for this purpose.  Improvements in memory chips made development of backing store inevitable.<P>
Without a publication, the use of backing store in the Lisp Machine System may not count as prior art to defeat the patent.  So the AT&amp;T patent may stand, and MIT may be forbidden to continue using a method that MIT used before AT&amp;T.<P>
The result is that the dozens of companies and hundreds of thousands of users who accepted the software from MIT with the understanding that it was free are now faced with possible lawsuits.  (They are also being threatened with Cadtrak's exclusive-or patent.)  The X Window project was intended to develop a window system that all developers could use freely.  This public service goal seems to have been thwarted by patents.<P>
<h3><a name="023f_0008">Why Software is Different<a name="023f_0008"></h3><P>
Software systems are much easier to design than hardware systems of the same number of components.  For example, a program of 100,000 components might be 50,000 lines long and could be written by two good programmers in a year.  The equipment needed for this costs less than $10,000; the only other cost would be the programmers' living expenses while doing the job. The total investment would be less than $100,000.  If done commercially in a large company, it might cost twice that.  By contrast, an automobile typically contains under 100,000 components; it requires a large team and costs tens of millions of dollars to design.<P>
And software is also much cheaper to manufacture: Copies can be made easily on an ordinary workstation costing under $10,000.  To produce a hardware system often requires a factory costing tens of millions of dollars.<P>
Why is this?  A hardware system has to be designed using real components.  They have varying costs; they have limits of operation; they may be sensitive to temperature, vibration, or humidity; they may generate noise; they drain power; they may fail either momentarily or permanently.  They must be physically assembled in their proper places, and they must be accessible for replacement in case they fail.<P>
Moreover, each of the components in a hardware design is likely to affect the behavior of many others.  This greatly complicates the task of determining what a hardware design will do: Mathematical modeling may prove wrong when the design is built.<P>
By contrast, a computer program is built out of ideal mathematical objects whose behavior is defined, not modeled approximately, by abstract rules.  When an if statement follows a while statement, there is no need to study whether the if statement will draw power from the while statement and thereby distort its output, nor whether it could overstress the while statement and make it fail.<P>
Despite being built from simple parts, computer programs are incredibly complex.  The program with 100,000 parts is as complex as an automobile, though far easier to design.<P>
While programs cost substantially less to write, market, and sell than automobiles, the cost of dealing with the patent system will not be less.  The same number of components will, on the average, involve the same number techniques that might be patented.<P>
<h3><a name="023f_0009">The Danger of a Lawsuit<a name="023f_0009"></h3><P>
Under the current patent system, a software developer who wishes to follow the law must determine which patents a program violates and negotiate with each patent holder a license to use that patent.  Licensing may be prohibitively expensive, as in the case when the patent is held by a competitor.  Even &quot;reasonable&quot; license fees for several patents can add up to make a project infeasible.  Alternatively, the developer may wish to avoid using the patent altogether; but there may be no way around it.<P>
The worst danger of the patent system is that a developer might find, after releasing a product, that it infringes one or many patents.  The resulting lawsuit and legal fees could force even a medium-size company out of business.<P>
Worst of all, there is no practical way for a software developer to avoid this danger -- there is no effective way to find out what patents a system will infringe.  There is a way to try to find out -- a patent search -- but searches are unreliable and in any case too expensive to use for software projects.<P>
<h3><a name="023f_000a">Patent Searches are Prohibitively Expensive<a name="023f_000a"></h3><P>
A system with 100,000 components can use hundreds of techniques that might already be patented.  Since each patent search costs thousands of dollars, searching for all the possible points of danger could easily cost over a million.  This is far more than the cost of writing the program.<P>
The costs don't stop there.  Patent applications are written by lawyers for lawyers.  A programmer reading a patent may not believe that his program violates the patent, but a federal court may rule otherwise.  It is thus now necessary to involve patent attorneys at every phase of program development.<P>
Yet this only reduces the risk of being sued later -- it does not eliminate the risk.  So it is necessary to have a reserve of cash for the eventuality of a lawsuit.<P>
When a company spends millions to design a hardware system, and plans to invest tens of millions to manufacture it, an extra million or two to pay for dealing with the patent system might be bearable.  However, for the inexpensive programming project, the same extra cost is prohibitive.  Individuals and small companies especially cannot afford these costs.  Software patents will put an end to software entrepreneurs.<P>
<h3><a name="023f_000b">Patent Searches are Unreliable<a name="023f_000b"></h3><P>
Even if developers could afford patent searches, these are not a reliable method of avoiding the use of patented techniques.  This is because patent searches do not reveal pending patent applications (which are kept confidential by the Patent Office).  Since it takes several years on the average for a software patent to be granted, this is a serious problem: A developer could begin designing a large program after a patent has been applied for, and release the program before the patent is approved.  Only later will the developer learn that distribution of the program is prohibited.<P>
For example, the implementors of the widely used public domain data compression program compress followed an algorithm obtained from IEEE Computer magazine.  They and the user community were surprised to learn later that patent number 4,558,302 had been issued to one of the authors of the article.  Now Unisys is demanding royalties for using this algorithm. Although the program is still in the public domain -- using it means risking a lawsuit.<P>
The Patent Office does not have a workable scheme for classifying software patents.  Patents are most frequently classified by end results, such as &quot;converting iron to steel,&quot; but many patents cover algorithms whose use in a program is entirely independent of the purpose of the program.  For example, a program to analyze human speech might infringe the patent on a speedup in the Fast Fourier Transform; so might a program to perform symbolic algebra (in multiplying large numbers); but the category to search for such a patent would be hard to predict.<P>
You might think it would be easy to keep a list of the patented software techniques, or even simply remember them.  However, managing such a list is nearly impossible.  A list compiled in 1989 by lawyers specializing in the field omitted some of the patents mentioned in this article.<P>
<h3><a name="023f_000c">Obscure Patents<a name="023f_000c"></h3><P>
When you imagine an invention, you probably think of something that could be described in a few words, such as &quot;a flying machine with fixed, curved wings&quot; or &quot;an electrical communicator with a microphone and a speaker.&quot;  But most patents cover complex detailed processes that have no simple descriptions -- often they are speed-ups or variants of well-known processes that are themselves complex.<P>
Most of these patents are neither obvious nor brilliant; they are obscure.  A capable software designer will &quot;invent&quot; several such improvements in the course of a project. However, there are many avenues for improving a technique, so no single project is likely to find any given one.<P>
For example, IBM has several patents (including patent 4,656,583) on workmanlike, albeit complex, speed-ups for well-known computations performed by optimizing compilers, such as register coloring and computing the available expressions.<P>
Patents are also granted on combinations of techniques that are already widely used.  One example is IBM patent 4,742,450, which covers &quot;shared copy-on-write segments.&quot; This technique allows several programs to share the same piece of memory that represents information in a file; if any program writes a page in the file, that page is replaced by a copy in all of the programs, which continue to share that page with each other but no longer share with the file.<P>
Shared segments and copy-on-write have been used since the 1960s.  This particular combination may be new as a specific feature, but is hardly an invention.  Nevertheless, the Patent Office thought that it merited a patent, which must now be taken into account by the developer of any new operating system.<P>
Obscure patents are like land mines: Other developers are more likely to reinvent these techniques than to find out about the patents, and then they will be sued.  The chance of running into any one of these patents is small, but they are so numerous that you cannot go far without hitting one.  Every basic technique has many variations, and a small set of basic techniques can be combined in many ways.  The patent office has now granted more than 2000 software patents -- 700 in 1989 alone.  We can expect the pace to accelerate.  In ten years, programmers will have no choice but to march on blindly and hope they are lucky.<P>
<h3><a name="023f_000d">Patent Licensing has Problems, too<a name="023f_000d"></h3><P>
Most large software companies are trying to solve the problem of patents by getting patents of their own.  Then they hope to cross-license with the other large companies that own most of the patents, so they will be free to go on as before.<P>
While this approach will allow companies such as Microsoft, Apple, and IBM to continue in business, it will shut new companies out of the field.  A future start-up, with no patents of its own, will be forced to pay whatever price the giants choose to impose.  That price might be high: Established companies have an interest in excluding future competitors.  The recent Lotus lawsuits against Borland International and the Santa Cruz Operation (although involving an extended idea of copyright rather than patents) show how this can work.<P>
Even the giants cannot protect themselves with cross-licensing from companies whose only business is to buy patents and then threaten to sue.  For example, the New York-based Refac Technology Development Corporation, a company that represents Forward Reference Systems (owners of the patent for natural order recalc), recently sued Lotus Corporation.  Natural order recalc is Refac's first foray into the software patent arena; for the past 40 years, the company has negotiated licenses in the fastener and electronic component industries.  The company employs no programmers or engineers.<P>
Refac is demanding -- in the neighborhood of -- five percent of sales of all major spreadsheet programs.  If a future program infringes on 20 such patents -- and this is not unlikely, given the complexity of computer programs and the broad applicability of many patents -- the combined royalties could exceed 100 percent of the sales price.<P>
<h3><a name="023f_000e">The Fundamental Question<a name="023f_000e"></h3><P>
According to the Constitution of the United States, the purpose of patents is to &quot;promote the progress of science and the useful arts.&quot;  Thus, the basic question at issue is whether software patents, supposedly a method of encouraging software progress, will truly do so, or will retard progress instead.<P>
So far we have explained the ways in which patents will make ordinary software development difficult.  But what of the intended benefits of patents: More invention, and more public disclosure of inventions?  To what extent will these actually occur in the field of software?<P>
There will be little benefit to society from software patents because invention in software was already flourishing before software patents, and inventions were normally published in journals for everyone to use.  Invention flourished so strongly, in fact, that the same inventions were often found again and again.<P>
<h3><a name="023f_000f">In Software, Independent Reinvention is Commonplace<a name="023f_000f"></h3><P>
A patent is an absolute monopoly; everyone is forbidden to use the patented process, even those who reinvent it independently.  This policy implicitly assumes that inventions are rare and precious, because only in those circumstances is it beneficial.<P>
The field of software is one of constant reinvention; as some people say, programmers throw away more &quot;inventions&quot; each week than other people develop in a year.  And the comparative ease of designing large software systems makes it easy for many people to do work in the field.  A programmer solves many problems in developing each program.  These solutions are likely to be reinvented frequently as other programmers tackle similar problems.<P>
The prevalence of independent reinvention negates the usual purpose of patents.  Patents are intended to encourage inventions and, above all, the disclosure of inventions.  If a technique will be reinvented frequently, there is no need to encourage more people to invent it; because some of the developers will choose to publish it (if publication is merited), there is no point in encouraging a particular inventor to publish it -- not at the cost of inhibiting use of the technique.<P>
<h3><a name="023f_0010">Overemphasis of Inventions<a name="023f_0010"></h3><P>
Many analysts of the American and Japanese industry have attributed Japanese success at producing quality products to the fact that they emphasize incremental improvements, convenient features, and quality rather than noteworthy inventions.<P>
It is especially true in software that success depends primarily on getting the details right.  And that is most of the work in developing any useful software system.  Inventions are a comparatively unimportant part of the job.<P>
The idea of software patents is thus an example of the mistaken American preoccupation with inventions rather than products.  And patents will further reinforce this mistake, rewarding not the developers who write the best software, but those who were first to file for a patent.<P>
<h3><a name="023f_0011">Impeding Innovation<a name="023f_0011"></h3><P>
By reducing the number of people engage in software development, software patents will actually impede innovation.  Much software innovation comes from programmer's solving problems while developing software, not from projects whose specific purpose is to make invention and obtain patents.  In other words, these innovations are byproducts of software development.<P>
When patents make development more difficult, and cut down on development projects, they will also cut down on the byproducts of development -- new techniques.<P>
<h3><a name="023f_0012">Could Patents Ever be Beneficial?<a name="023f_0012"></h3><P>
Although software patents are in general harmful to society as a whole, we do not claim that every single software patent is necessarily harmful.  Careful study might show that under certain specific and narrow conditions (necessarily excluding the vast majority of cases) it is beneficial to grant software patents.<P>
Nonetheless, the right thing to do now is to eliminate all software patents as soon as possible, before more damage is done.  The careful study can come afterward.<P>
Clearly, software patents are not urgently needed by anyone, except patent lawyers.  The prepatent software industry had no problem that was solved by patents; there was no shortage of invention and no shortage of investment.  Complete elimination of software patents may not be the ideal solution, but it is close, and is a great improvement.  Its very simplicity helps avoid a long delay while people argue about details.  If it is ever shown that software patents are beneficial in certain exceptional cases, the law can be changed again at that time -- if it is important enough.  There is no reason to continue the present catastrophic situation until that day.<P>
<h3><a name="023f_0013">Software Patents are Legally Questionable<a name="023f_0013"></h3><P>
It may come as a surprise that the extension of patent law to software is still legally questionable.  It rests on an extreme interpretation of a particular 1981 Supreme Court decision, Diamond vs. Deihr.  (See &quot;Legally Speaking&quot; in Communications of the ACM, August 1990.)<P>
Traditionally, the only kinds of processes that could be patented were those for transforming matter (such as for transforming iron into steel).  Many other activities which we would consider processes were entirely excluded from patents, including business methods, data analysis, and &quot;mental steps.&quot;  This was called the &quot;subject matter&quot; doctrine.<P>
Diamond vs. Deihr has been interpreted by the Patent Office as a reversal of this doctrine, but the court did not explicitly reject it.  The case concerned a process for curing rubber -- a transformation of matter.  The issue at hand was whether the use of a computer program in the process was enough to render it unpatentable, and the court ruled that it was not.  The Patent Office took this narrow decision as a green light for unlimited patenting of software techniques, and even for the use of software to perform specific well-known and customary activities.<P>
Most patent lawyers have embraced the change, saying that the new boundaries of patents should be defined over decades by a series of expensive court cases.  Such a course of action will certainly be good for patent lawyers, but it is unlikely to be good for software developers and users.<P>
<h3><a name="023f_0014">One Way to Eliminate Software Patents<a name="023f_0014"></h3><P>
We recommend the passage of a law to exclude software from the domain of patents.  That is to say that, no matter what patents might exist, they would not cover implementations in software; only implementations in the form of hard-to-design hardware would be covered.  An advantage of this method is that it would not be necessary to classify patent applications into hardware and software when examining them.<P>
Many have asked how to define software for this purpose -- where the line should be drawn. For the purpose of this legislation, software should be defined by the characteristics that make software patents especially harmful:<P>
<ul>
<li>Software is built from ideal infallible mathematical components, whose outputs are not affected by the components they feed into.</li>
<li>Ideal mathematical components are defined by abstract rules, so that failure of a component is by definition impossible.  The behavior of any system built of these components is likewise defined by the consequences of applying the rules step by step to the components.</li>
<li>Software can be easily and cheaply copied.</li>
</ul>
Following this criterion, a program to compute prime numbers is a piece of software.  A mechanical device designed specifically to perform the same computation is not software, because mechanical components have friction, can interfere with each other's motion, can fail, and must be assembled physically to form a working machine.<P>
Any piece of software needs a hardware platform in order to run.  The software operates the features of the hardware in some combination, under a plan.  Our proposal is that combining the features in this way can never create infringement.  If the hardware alone does not infringe a patent, then using it in a particular fashion under control of a program should not infringe either.  In effect, a program is an extension of the programmer's mind, acting as a proxy for the programmer to control the hardware.<P>
Usually the hardware is a general-purpose computer, which implies no particular application.  Such hardware cannot infringe any patents except those covering the construction of computers.  Our proposal means that, when a user runs such a program into a general-purpose computer no patents other than those should apply.<P>
The traditional distinction between hardware and software involves a complex of characteristics that used to go hand in hand.  Some newer technologies, such as gate arrays and silicon compilers, blur the distinction because they combine characteristics associated with hardware with others associated with software.  However, most of these technologies can be classified unambiguously for patent purposes, either as software or as hardware, using the criteria above.  A few gray areas may remain, but these are comparatively small, and need not be an obstacle to solving the problems patents pose for ordinary software development.  They will end up being treated as hardware, as software, or as something in between.<P>
<h3><a name="023f_0015">Fighting Patents One by One<a name="023f_0015"></h3><P>
Until we succeed in eliminating all patenting of software, we must try to overturn individual software patents.  This is very expensive and can solve only a small part of the problem, but that is better than nothing.<P>
Overturning patents in court requires prior art, which may not be easy to find.  The League for Programming Freedom will try to serve as a clearing house for this information, to assist the defendants in software patent suits.  This depends on your help.  If you know about prior art for any software patent, please send the information to the League (see the accompanying text box.)<P>
If you work on software, you can personally help prevent software patents by refusing to cooperate in applying for them.  The details of this may depend on the situation.<P>
<h3><a name="023f_0016">Conclusion<a name="023f_0016"></h3><P>
Exempting software from the scope of patents will protect software developers from the insupportable cost of patent searches, the wasteful struggle to find a way clear of known patents, and the unavoidable danger of lawsuits.<P>
If nothing is changed, what is now an efficient creative activity will become prohibitively expensive.  The sparks of creativity and individualism that have driven the computer revolution will be snuffed out.<P>
To picture the effects, imagine that each square of pavement on the sidewalk has an owner and that pedestrians must obtain individual licenses to step on particular squares.  Think of the negotiations necessary to walk an entire block under this system.  That is what writing a program will be like in the future if software patents continue.<P>
<h3><a name="023f_0017"><a name="023f_0017"><a name="023f_0018">What You Can Do<a name="023f_0018"></h3><P>
The League for Programming Freedom is a grass-roots organization of programmers and users opposing software patents and interface copyrights.  (The League is not opposed to copyright on individual programs.)  Annual dues for individual members are $42 for employed professionals, $10.50 for students, and $21 for others.  We appreciate activists, but members who cannot contribute their time are also welcome.<P>
To contact the League, phone 617-243-4091, send Internet mail to: league@prep.ai.mit.edu or write to:<P>
<pre>
  The League for Programming
    Freedom
  1 Kendall Square #143
  P.O. Box 9171
  Cambridge, MA 02139
</pre><P>
In the United States, another way to help is to write to Congress.  You can write to your own representatives, but it may be even more effective to write to the subcommittees that consider such issues:<P>
<pre>
  House Subcommittee on
    Intellectual Property
  2137 Rayburn Bldg.
  Washington, DC 20515

  Senate Subcommittee on Patents,
    Trademarks and Copyrights
  United States Senate
  Washington, DC 20510
</pre><P>
To write your own representatives, use the following addresses:<P>
<pre>
  Senator name
  United States Senate
  Washington, DC 20510

  Representative name
  House of Representatives
  Washington, DC 20515
</pre><P>
<P>
<P>
<P>
</pre></BODY></HTML>
