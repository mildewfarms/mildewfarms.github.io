<html><head><title>Nov98: C Programming</title></head><body bgcolor="FFFFFF"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Undo/Redo Redux</h1><p><i>Dr. Dobb's Journal</i> November 1998</p><h3>By Al Stevens</h3><I>Al is a DDJ contributing editor. He can be contacted at astevens@ddj.com.</I><hr><p>I'm writing this column from an upscale adobe mountainside home in the eastern end of Santa Fe, New Mexico. This trip is a reunion with my two brothers -- we are usually separated by thousands of miles -- and I've been looking forward to it all year. The home belongs to one of brother Walter's friends, and we are house-sitting while she is away. This is a magnificent setting, quiet and serene. The mountainside and our small canyon are resplendent with piqon, juniper, cottonwood, chamisa, aspen, and an occasional Ponderosa pine. Even though it is now midsummer and most of the southwestern United States are reporting record-breaking temperatures, the temperature here stays in the lower 80s during the day and drops into the 60s at night, perfect for sleeping with the windows open and the covers piled on. Coyotes serenade us to sleep, and the thin air at 7000 feet provides the clearest, brightest view of the sky and stars you can imagine. A full moon tonight adds to the splendor; it's almost too bright to look at. Few places on this earth can compare to the foothills of the Sangre de Christo mountains in the summer.</p><p>It is no wonder that Santa Fe attracts a diverse community of artists, musicians, actors, poets, and writers. Walter is himself an artist and writer of considerable talent. Most of his friends are artists, too. Just up the mountain to the east, about 300 yards away and 50 feet above us, is the relatively new mansion of Ottmar Liebert, a guitarist of some prominence. His huge adobe spread offers a vast and magnificent view across the housetops and patios below, including ours, over the town of Santa Fe, to the purple mountains majesty of the west, a perfect setting to inspire Ottmar's soothing guitar improvisations played against new age backgrounds of bird calls, wind chimes, and gently pounding surf.</p><p>Brother Julian drove down from Montana in his camper. Judy and I made the cross country trek from Florida in our RV. Walter brought his motorhome up from where he keeps it parked out in the country so we could work on it. His friend's home has a flat spacious back yard that provides ample parking for our travel vehicles and is now cluttered with our tools and the debris from the repairs we have been making. It's also the site of our nightly parties, which can get loud and boisterous when beer flows and brothers have not seen each other for several years with all the outrageous stories to catch up on and reminiscences to share. It looks and sounds like a combination trailer park, heavy equipment repair depot, and fire department picnic. I'll bet Ottmar is thrilled with his new view.</p><h3>Undo Again</h3><p>Last year I published in this column a C++ class template library to implement the typical undo operations of interactive programs. I developed the library mainly for small musical notation programs, but I made it generic enough for most interactive applications. The library assumes that the user modifies a document class object and might want to undo those modifications in reverse order.</p><p>The applications where I use the library work well with it, but recently I began work on a more comprehensive musical notation program and found the library to be lacking in several ways. First, the library does not support a redo function, and I wanted to include that feature in my new program. Second, the library does not support a generic way to preserve and restore the user's view of the document at the time of the undos and redos. Finally, the library's classes are in the global namespace and might contribute to namespace pollution if used with other libraries.</p><p>I spent much of the time during the several day drive to Santa Fe thinking about the undo/redo situation and how I might reimplement it. I wanted to minimize as much as possible any changes in the public interface and was able to achieve that goal successfully, I think. There are some small but significant differences. First, the previous library supports undoable actions with a count of action items to record, whereas the current library supports the recording of only one undoable action. Both libraries support the use of a terminal action node, one that declares itself to represent the first of a sequence of undoable actions to be undone as a set when the user chooses the undo command; removing undo arrays did not represent any loss of functionality. The second difference is found in the use of a placement <i>new</i> operator function to allocate undo action memory. The new library uses the placement <i>new</i> operator notation to associate the undo container class with the undo action node being allocated. This permits the application to disable undo storage, perhaps while inserting objects into the document while reading from a file. Other differences in the library's public interface involve the requirement for the document class to provide functions that support view context switching in addition to the document functions that insert and delete object data in response to undo actions.</p><p>It doesn't take much code to implement a generic undo library, but some of the concepts that underpin this small amount of code are complex and enigmatic. Each time I work with this library after a long absence, particularly when I want to modify it, I have to make an effort to relearn how it works. Now that I've written this column, it won't be so difficult the next time. Read these discussions and refer to the code in <A NAME="rl1"><A HREF="9811l.htm#l1">Listings One</A> and <A NAME="rl2"><A HREF="9811l.htm#l2">Two</A> (at the end of this article) as you do. Eventually, it all comes clear.</p><h3>Undo = Stack</h3><p>Undo is a stack-oriented problem. The user performs an action that inserts, deletes, or replaces one or more objects in a document. The program pushes a node representing each action onto a stack data structure. The node records what is needed to undo the action.</p><p>An undo node on the stack represents either an insertion, a deletion, or a replacement of an object in the document. The node saves the data value deleted or replaced and where in the document the data value was prior to the action that could be undone. For insertions the node saves the object location. In the new library, the node saves the data value inserted, too, in order to support the redo feature.</p><p>When the user chooses the undo command, the program pops the most recent undo node from the stack and causes the action to be undone by calling cooperating member functions of the document class. To undo an insertion, the program deletes the object that was inserted. To undo a deletion, the program reinserts the deleted object. To undo a replacement, the program replaces the document's object value with the value that existed before the original replacement.</p><h3>One Do = Several Undos</h3><p>From the user's perspective, an undo action could involve several actions when viewed from the program's perspective. For example, suppose the user deletes a note from a musical score. The program might delete several objects as a result of that action -- the note itself, an accidental (flat, sharp, natural) associated with the note, ties to other notes, and so on. Then, after deleting all those objects, the program inserts a musical rest to replace the note in order to maintain the metric integrity of the measure. One action for the user translates into several actions for the program. The undo library does not automatically know about these associations. The application program must tell the undo library when an action being pushed is the first of such a sequence; the undo library flags that action's node as the first action in a sequence of pushes and the terminating action in a later sequence of pops. Subsequent actions in the sequence are not flagged when they are pushed. Consequently, when the user chooses the undo command, the program pops and undoes actions until it undoes the one that is flagged as the terminating action.</p><h3>Undo/Redo = Deque/Stack</h3><p>Redo is really just the opposite of undo. When the user executes the undo command, the action to be undone is popped from the undo stack and pushed onto the redo stack. I used the Standard C++ <i>std::deque</i> to implement the undo stack and <i>std::stack</i> to implement the redo stack. I'll explain why later.</p><p>When users perform an undoable action (a "do"), the program discards all redo actions; they might not be valid any longer. The user's change to the document would likely cause prior redo nodes to have invalid object position information.</p><p>An application should not collect an unlimited number of undo nodes in any one interactive session. Users can work all day with one document. If they don't make many mistakes and don't use the undo feature, the undo memory buffer can grow and, eventually, exhaust the memory pool from which it draws. The undo library uses a maximum number of undo actions to manage the undo buffer size. After the maximum number of dos have occurred, the program discards the oldest undo nodes as new nodes are pushed. I used the <i>std::deque</i> container for the undo stack because it allows you to reference and pop from both ends of the container. When the stack gets too deep, the program pops undo nodes from the front of the container and deletes them until the stack is at the required maximum depth. The redo stack does not need to be similarly maintained because it can never contain more nodes than the undo stack contained.</p><p>The undo node class uses a placement <i>new</i> operator function to allocate node space from this buffer. I used placement <i>new</i> so that the container could communicate its own object address to the node class's <i>new</i> operator. When a program wants to suppress adding undo nodes to the stack, it tells the node container class to disable undo operations. When the application instantiates objects of undo nodes and undo is disabled, the placement <i>new</i> operator function returns zero rather than a memory address. The undo system knows not to push zero pointers onto the undo stack.</p><h3>Document View Context</h3><p>One of the deficiencies of the original library is that it does not provide a generic interface to save and restore any document context other than document content when undo and redo actions are done. For example, the user views the document in a scrolling window and has an insertion cursor pointed somewhere. The user performs a change that is recorded in the undo container. Then the user scrolls elsewhere in the document before performing the undo command. Ideally, the program should restore the user's viewing context as it was prior to the action that is undone. To get a visual sense of the undo command, the program should return the document to its scrolled position when the original action took place. The undo operation might truncate the document such that the insertion cursor is no longer valid and that value should be restored as part of the document's context. Unless the application ensures that these viewing contexts are preserved and properly restored, the user does not see what is expected.</p><p>Viewing context is not the only kind of context that one might need to restore but it is sufficient to explain the concept. The new undo library includes calls to document-provided functions to get a parameterized context object when the undo nodes are constructed and to return that object to the document following undo and redo operations. It is up to the document class to provide the object's definition and do something meaningful with it.</p><h3>The <i>DDJCProgrammingColumnUndo</i> Namespace</h3><p>I enclosed the undo library in the <i>DDJCProgrammingColumnUndo</i> namespace. Nobody out there can tell me what namespace I am supposed or allowed to use, so I chose <i>DDJCProgrammingColumnUndo</i> quite arbitrarily. It's nice and long, and it has enough prefix data to associate it with this column, so I doubt that there will be any collisions. Unless, of course, I retire some day and a successor columnist coincidentally chooses the same name.</p><p>Long namespaces are unwieldy, so my applications use namespace aliases to get them down to something that fits on a line of code.</p><h3>The Undo/Redo Library</h3><p><A HREF="9811l.htm#l1">Listing One</A> is undo.h, the source-code file that implements the new undo library. There are two class hierarchies involved. The <i>UndoNode</i> class is templatized by the document class. <i>UndoNode</i> is the base class for all undo actions. <i>UndoNode</i> includes the <i>m_bTerminator</i> data member that indicates whether the node is a terminating node in a sequence of undo actions. The constructor and destructor are protected because the class is used only as a base class. <i>UndoItem</i> is the only class directly derived from <i>UndoNode</i>. <i>UndoItem</i> is parameterized on the document class, the type of the object involved in the undo, and the document context type. It contains a pointer to the object position in the document, a copy of the object inserted, deleted, or replaced, and a copy of the document's context object retrieved at the time the undoable action is added to the undo stack. The <i>UndoItem</i> constructor calls the document class's <i>GetUndoContext</i> function to initialize the parameterized context data member.</p><p><i>UndoInsertNode</i>, <i>UndoDeleteNode</i>, and <i>UndoReplaceNode</i> are derived from <i>UndoItem</i>. These classes are intended to be base classes for ones that the application derives to specialize the undo action node. Each of them contains <i>Undo</i> and <i>Redo</i> functions that the library calls to tell the node to undo or redo itself through cooperation with the document class and to tell the document class to restore its context saved at the time of the action. The library design depends on derived objects of these base classes being instantiated before the action that can be undone occurs. The constructors for <i>UndoDeleteNode </i>and <i>UndoReplaceNode</i> retrieve the data value that is going to be deleted from or replaced in the document. <i>UndoInsertNode</i> waits until the <i>Undo</i> function is called because the data value does not exist in the document before the insert action is taken and when the constructor is executed.</p><p>The second class hierarchy starts with the <i>UndoData</i> class, which is parameterized on the document class only. <i>UndoData</i> is meant to be a base class that the application derives from to incorporate the undo data structure into a document. It contains a reference to the document class instance so that the node classes can call the document's undo-related functions. <i>UndoData</i> also contains the undo and redo stacks and the public interface functions that an application calls to add undo nodes and perform undo and redo operations. </p><h3>Adding Undo to an Application</h3><p><A NAME="rl2"><A HREF="9811l.htm#l2">Listing Two</A> is songundo.h, the source code file from my notation application. This file represents the first step in integrating the undo library into an application. The code in this file is from my application; yours would be different. My application has only one object type that can be inserted, deleted, or replaced in a document. That type is named <i>Event</i>, and there is not much else you need to know about it. Other applications might use <i>char</i>, <i>std::string</i>, other intrinsic or class types, and any mix of them.</p><p>The first three classes in songundo.h are derived from <i>UndoInsertNode</i>, <i>UndoDeleteNode</i>, and <i>UndoReplaceNode</i>. (I'm not going to qualify every reference with the undo library's namespace in this discussion. You can see where that qualification is needed by looking at the code.) These derivations instantiate the base class by providing the types that are parameterized. These types are unique to my application. Observe that the calls to the base class constructors pass the object pointed to by a global variable named <i>pFakeBookDoc</i>. This variable is defined by my application and points to the instance of the document class. There are more elegant ways I could have done this, but this way works well enough.</p><p>The <i>UndoSongData</i> class is derived from <i>UndoData</i> parameterized by my application's document class. <i>UndoSongData</i>'s constructor provides the maximum undo count to the base class constructor. <i>UndoSongData</i> includes member functions that the application calls to store undoable actions. These member functions must each call <i>UndoData::AddUndoNode</i> passing the address of an object of one of the classes derived from <i>UndoInsertNode</i>, <i>UndoDeleteNode</i>, or <i>UndoReplaceNode</i>. This object should be instantiated by using the <i>UndoNode</i>'s placement <i>new</i> operator. The this pointer passed to the placement <i>new</i> operator identifies the <i>UndoData</i> derived class so that placement <i>new</i> can access <i>UndoData</i>'s enable/disable flag. The undo object address passed to the constructor by the placement <i>new</i> operator is the address in the document where the action is to take place. Observe that no data values are passed. The node constructors get them directly from the document.</p><p>With these classes defined, the next step is to incorporate them into the application. My notation program runs under Win32 as a GUI application, but the undo library is designed to be platform-independent. Here are the procedures:</p><p>1.	Build a document class that represents the document.</p><p>2.	Include an object of the class derived from <i>UndoData</i> as a data member in the document class. Specify to its constructor the buffer size. </p><p>3.	Provide the public member functions in <A NAME="re1"><A HREF="9811le1.htm">Example 1</A> in the document class. <i>T</i> represents the type of object to be inserted or deleted. The document class needs <i>Insert</i> and <i>Delete</i> functions for each such type. <i>C</i> represents the type of the object that records the document's context.</p><p>4.	As the user performs actions that change the document, call the appropriate member functions in the class derived from <i>UndoData</i>.</p><p>5.	When the user executes the application's undo command, call <i>UndoData::UndoLastAction()</i> through the class derived from <i>UndoData</i>.</p><p>6.	When the user executes the application's redo command, call <i>UndoData::RedoLastUndo()</i> through the class derived from <i>UndoData</i>.</p><p>7.	To determine if there are any undo or redo actions pending, perhaps to enable and disable the undo and redo commands on a menu or toolbar, call <i>UndoData::IsUndoDataStored()</i> and <i>UndoData::IsRedoDataStored()</i> through the class derived from <i>UndoData</i>. <i>UndoData::IsUndoDataStored()</i> only specifies whether there are undo nodes that can be undone. If the undo count has been exceeded, undo nodes were discarded. The <i>UndoData::WasUndoDataDiscarded</i> function reports that condition. A program can use a combination of <i>UndoData::IsUndoDataStored()</i> and <i>UndoData::WasUndoDataDiscarded</i> to determine if the document needs to be saved.</p><h3>Without Further Undo...</h3><p>Judy likes to watch those daytime do-it-yourself and craft shows where former beauty contest winners pretend to be handy around the house. They always have male sidekicks to do the heavy stuff. In virtually every show, the cast demonstrates some arcane procedure such as wiring a breaker box, adding a dormer, sawing a rabbet joint, or installing an attic ventilation fan. I'll close this explanation of an extremely complex subject the way they always end their demonstrations. "And that's all there is to it."</p><p><b>DDJ</b></p><<H4><A NAME="l1">Listing One</A></H4><pre>// --------- undo.h#ifndef UNDO_H#define UNDO_H<p></p>#include &lt;deque&gt;#include &lt;stack&gt;<p></p>namespace DDJCProgrammingColumnUndo {//------------------------------------------------------------------------------// UndoNode&lt;D&gt;: base class for all undo actions<p></p>template &lt;class D&gt; class UndoData;template &lt;class D&gt;class UndoNode{    bool m_bTerminator;     // undo action stream terminatorprotected:    explicit UndoNode(bool bTerminator) : m_bTerminator(bTerminator) { }public:    virtual ~UndoNode() { }    virtual void Undo(D&amp; rDoc) = 0;    virtual void Redo(D&amp; rDoc) = 0;    bool Terminator() const        { return m_bTerminator; }    void* operator new(size_t sz, UndoData&lt;D&gt;* pData);};//---------------------------------------------------------------------------// UndoItem: base template class for all undo actions// D = document class// T = atomic unit of undo action (string, char, etc.)// C = document context information// class D must provide these public functions://     void SetUndoContext(C);//     C GetUndoContext() const;//     void Delete(T* position);//     void Insert(T* position, T datum);//          position = where to delete from/insert into//          datum = T object to be inserted// classes T and C must support operator=//template &lt;class D, class T, class C&gt;class UndoItem : public UndoNode&lt;D&gt;{protected:    T*  m_pPosition; // document position of undoable action    C   m_Context;   // document view context (cursor, e.g.) at time of action    T   m_Datum;     // data value    UndoItem(D&amp; rDoc, T* pPosition, bool bTerminator) :            UndoNode&lt;D&gt;(bTerminator), m_pPosition(pPosition)        { m_Context = rDoc.GetUndoContext(); }};//---------------------------------------------------------------------------// base class for undoing insertion actions// instantiate derived class and add to UndoData stack before performing actiontemplate &lt;class D, class T, class C&gt;class UndoInsertNode : public UndoItem&lt;D,T,C&gt;{public:    UndoInsertNode(D&amp; rDoc, T* pPosition, bool bTerminator) :             UndoItem&lt;D,T,C&gt;(rDoc, pPosition, bTerminator)        { }    void Undo(D&amp; rDoc)    {        // --- save datum for undo/redo        m_Datum = *m_pPosition;        // ---- undo the insertion        rDoc.Delete(m_pPosition);        rDoc.SetUndoContext(m_Context);    }    void Redo(D&amp; rDoc)    {        rDoc.Insert(m_pPosition, m_Datum);        rDoc.SetUndoContext(m_Context);    }};//---------------------------------------------------------------------------// base class for undoing deletion actions// instantiate derived class and add to UndoData stack before performing actiontemplate &lt;class D, class T, class C&gt;class UndoDeleteNode : public UndoItem&lt;D,T,C&gt;{public:    UndoDeleteNode(D&amp; rDoc, T* pPosition, bool bTerminator) :         UndoItem&lt;D,T,C&gt;(rDoc, pPosition, bTerminator)    {        // --- save datum for undo/redo        m_Datum = *m_pPosition;    }   void Undo(D&amp; rDoc)    {        rDoc.Insert(m_pPosition, m_Datum);        rDoc.SetUndoContext(m_Context);    }    void Redo(D&amp; rDoc)    {        rDoc.Delete(m_pPosition);        rDoc.SetUndoContext(m_Context);    }};//----------------------------------------------------------------------------// base class for undoing replacement actions// instantiate derived class and add to UndoData stack before performing actiontemplate &lt;class D, class T, class C&gt;class UndoReplaceNode : public UndoItem&lt;D,T,C&gt;{public:    UndoReplaceNode(D&amp; rDoc, T* pPosition, bool bTerminator) :         UndoItem&lt;D,T,C&gt;(rDoc, pPosition, bTerminator)    {        // --- save datum for undo/redo        m_Datum = *m_pPosition;    }    void Undo(D&amp; rDoc)    {        T temp = *m_pPosition;        *m_pPosition = m_Datum;        m_Datum = temp;        rDoc.SetUndoContext(m_Context);    }    void Redo(D&amp; rDoc)        { Undo(rDoc); }};//----------------------------------------------------------------------------// base class for storing undo actions// application derives from this classtemplate &lt;class D&gt;class UndoData{    D&amp; m_rDoc;    bool m_bDiscardedUndos;    bool m_bUndoEnabled;    std::deque&lt;UndoNode&lt;D&gt;*&gt; m_UndoDeque;    std::stack&lt;UndoNode&lt;D&gt;*&gt; m_RedoStack;    void DeleteAllRedoActions();    int m_nMaxUndos;public:    UndoData(D&amp; rDoc, int nMaxUndos);    ~UndoData();    void AddUndoNode(UndoNode&lt;D&gt;*pUndoNode);// adds action that can be undone    void UndoLastAction();                  // undoes the most recent action    void RedoLastUndo();                    // redoes the most recent undo   void EnableUndo()        { m_bUndoEnabled = true; }    void DisableUndo()        { m_bUndoEnabled = false; }    bool IsUndoEnabled() const        { return m_bUndoEnabled; }    bool IsUndoDataStored() const        { return !m_UndoDeque.empty(); }    bool WasUndoDataDiscarded() const        { return m_bDiscardedUndos; }    bool IsRedoDataStored() const        { return !m_RedoStack.empty(); }    void DeleteAllUndoActions();       // call when saving, loading new, etc.};template &lt;class D&gt;UndoData&lt;D&gt;::UndoData(D&amp; rDoc, int nMaxUndos) : m_rDoc(rDoc),     m_bDiscardedUndos(false), m_bUndoEnabled(true), m_nMaxUndos(nMaxUndos){}template &lt;class D&gt;UndoData&lt;D&gt;::~UndoData(){    DeleteAllUndoActions();    DeleteAllRedoActions();}template &lt;class D&gt;void UndoData&lt;D&gt;::DeleteAllUndoActions(){    while (!m_UndoDeque.empty())    {        delete m_UndoDeque.back();        m_UndoDeque.pop_back();    }}template &lt;class D&gt;void UndoData&lt;D&gt;::DeleteAllRedoActions(){    while (!m_RedoStack.empty())    {        delete m_RedoStack.top();        m_RedoStack.pop();    }}template &lt;class D&gt;void UndoData&lt;D&gt;::AddUndoNode(UndoNode&lt;D&gt;* pUndoNode){    if (pUndoNode != 0) {        // --- clean up the undos saved for possible redos        DeleteAllRedoActions();        // --- prevent the undo deque from growing too large        if (m_UndoDeque.size() &gt;= m_nMaxUndos)  {          while (!m_UndoDeque.empty() &amp;&amp; (m_UndoDeque.size() &gt;= m_nMaxUndos ||                     m_UndoDeque.front()-&gt;Terminator() == false))    {                delete m_UndoDeque.front();                m_UndoDeque.pop_front();            }           m_bDiscardedUndos = true;        }        m_UndoDeque.push_back(pUndoNode);    }}template &lt;class D&gt;void UndoData&lt;D&gt;::UndoLastAction(){    bool bTerminal = false;    while (!bTerminal &amp;&amp; !m_UndoDeque.empty())  {        m_UndoDeque.back()-&gt;Undo(m_rDoc);        m_RedoStack.push(m_UndoDeque.back());        bTerminal = m_UndoDeque.back()-&gt;Terminator();        m_UndoDeque.pop_back();    }}template &lt;class D&gt;void UndoData&lt;D&gt;::RedoLastUndo(){    bool bTerminal = false;    while (!bTerminal &amp;&amp; !m_RedoStack.empty())  {        m_RedoStack.top()-&gt;Redo(m_rDoc);        m_UndoDeque.push_back(m_RedoStack.top());        m_RedoStack.pop();        if (!m_RedoStack.empty())            bTerminal = m_RedoStack.top()-&gt;Terminator();    }}// ---- operator placement new supports undo enable/disabletemplate &lt;class D&gt;void* UndoNode&lt;D&gt;::operator new(size_t sz, UndoData&lt;D&gt;* pData){    void* p = 0;    if (pData-&gt;IsUndoEnabled())        p = ::operator new (sz);    return p;}} // namespace DDJCProgrammingColumnUndo#endif</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>// ------- songundo.h<p></p>#ifndef SONGUNDO_H#define SONGUNDO_H<p></p>#include "undo.h"#include "FakeBookDoc.h"<p></p>namespace undo = DDJCProgrammingColumnUndo;<p></p>// --------------------------------------------------------------------------class UndoInsertEvent : public         undo::UndoInsertNode&lt;CFakeBookDoc, Event, CFakeBookDoc::ViewContext&gt;{public:    UndoInsertEvent(Event* pEvent, bool bTerminator) :         undo::UndoInsertNode&lt;CFakeBookDoc, Event, CFakeBookDoc::ViewContext&gt;            (*pFakeBookDoc, pEvent, bTerminator)        {   }};// --------------------------------------------------------------------------class UndoDeleteEvent : public         undo::UndoDeleteNode&lt;CFakeBookDoc, Event, CFakeBookDoc::ViewContext&gt;{public:    UndoDeleteEvent(Event* pEvent, bool bTerminator) :         undo::UndoDeleteNode&lt;CFakeBookDoc, Event, CFakeBookDoc::ViewContext&gt;            (*pFakeBookDoc, pEvent, bTerminator)        {   }};// --------------------------------------------------------------------------class UndoReplaceEvent : public         undo::UndoReplaceNode&lt;CFakeBookDoc, Event, CFakeBookDoc::ViewContext&gt;{public:    UndoReplaceEvent(Event* pEvent, bool bTerminator) :         undo::UndoReplaceNode&lt;CFakeBookDoc, Event, CFakeBookDoc::ViewContext&gt;            (*pFakeBookDoc, pEvent, bTerminator)        {   }};// --------------------------------------------------------------------------class UndoSongData : public undo::UndoData&lt;CFakeBookDoc&gt;{public:   explicit UndoSongData(int nMaxUndos) :                 undo::UndoData&lt;CFakeBookDoc&gt;(*pFakeBookDoc, nMaxUndos)        {   }   void AddInsertEventUndo(Event* pEvent, int nCount, bool bTerminator = true)   {        for (int i = 0; i &lt; nCount; i++)    {            AddUndoNode(new (this) UndoInsertEvent(pEvent++, bTerminator));            bTerminator = false;        }   }   void AddDeleteEventUndo(Event* pEvent, int nCount, bool bTerminator = true)    {        for (int i = 0; i &lt; nCount; i++)    {            AddUndoNode(new (this) UndoDeleteEvent(pEvent, bTerminator));            bTerminator = false;        }    }    void AddReplaceEventUndo(Event* pEvent, bool bTerminator = true)    {        AddUndoNode(new (this) UndoReplaceEvent(pEvent, bTerminator));    }};#endif</pre><P><A HREF="#rl2">Back to Article</A></P><HR><I>Copyright &copy; 1998, Dr. Dobb's Journal</I><BR>
</body></html>