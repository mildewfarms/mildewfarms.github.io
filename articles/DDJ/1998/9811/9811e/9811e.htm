<html><head><title>Nov98: The GEF General Exception-Handling Library </title></head><body bgcolor="FFFFFF"><!--Copyright &#169; Dr. Dobb's Journal--><h1>The GEF General Exception-Handling Library</h1><p><i>Dr. Dobb's Journal</i> November 1998</p><h2>Exception handling for C programmers</h2><h3>By Bruce W. Bigby</h3><I>Bruce is a software developer for Xerox. He can be contacted at bbigby@alum .MIT.edu.</I><hr>Sidebar:<a name="rs1"></a><a href="9811es1.htm">GEF and Programming by Contract</a><hr><p>GEF is a general exception-handling and contract-programming facility for C programmers. GEF, with its special control macros, and other support functions, allows you to separate the main purpose of a function from its exception-handling, contract-validation, and resource-reclamation code. GEF even lets you isolate cleanup code to its own block -- just like Java.</p><p>In addition, GEF is also thread safe. GEF supports the 1003.1c specification of PosixThreads and UNIX signals. However, you must ensure that the PosixThreads API function (<i>pthread_getspecific</i>) is async-safe for your platform. If you are not using GEF to handle asynchronous operating-system signals, you need not be concerned with the issue of async safety.</p><p>I developed GEF on a Linux 2.x system, using the LinuxThreads PosixThreads-compatible library for thread support. Later, I ported GEF to a Sun Ultra<sub></sub>1, running Solaris 2.5.1. With little effort, you should be able to port GEF to other C-development platforms as well. GEF source code and related files are available electronically from <i>DDJ</i> (see "Resource Center," page 3) or at http://home .rochester.rr.com/bigbyofrocny/. Also available electronically are sample programs that demonstrate the use of the GEF library.</p><h3>GEF Control Macros</h3><p>GEF provides seven control keyword macros: <i>gef_try</i>, <i>gef_invariants</i>, <i>gef_preconditions</i>, <i>gef_catch</i>, <i>gef_postconditions</i>, <i>gef_finally</i>, and <i>gef_end</i>. If you are familiar with Java or C++, you'll notice that these keywords are identical to those of the other languages, except GEF qualifies keywords with the prefix, "gef." This prevents code that uses GEF from conflicting with C++ exception handling. In fact, the names of all of GEF keywords and functions have either "gef" or "GEF" as a prefix. Control macros use the lowercase prefix, while initialization functions use uppercase.</p><p>The <i>gef_try</i> keyword macro introduces an exception-handling block, after which you can include the main body of your code. It is analogous to the C++ and Java <i>try</i> blocks. You can place any legal C statement after this block, and just like an <i>if</i> statement, if you are including more than one statement after the <i>gef_try</i>, you need to enclose the statements within braces.</p><h3>GEF and Programming by Contract</h3><p>GEF supports a number of control blocks that let you establish and enforce the requirements of using a function. A function may specify its contract of use via the exception-handler blocks, <i>gef_invariant</i>, <i>gef_preconditions</i>, and <i>gef_postconditions</i>.</p><p>GEF provides the <i>gef_invariants</i> block to let you specify the conditions of a function that must hold true immediately before the function begins to execute and after the function returns. In <A NAME="rl1"><A HREF="9811e.htm#l1">Listing One</A> (at the end of this article), <i>AddHighInt</i> is a function that adds an integer <i>i</i> to the top end of a dynamic array. The lower and upper bounds of any dynamic array may be negative or positive integers. However, at any point in time, the upper bound of an array minus its lower bound plus one must be equal to its size. This condition is an invariant, because the condition must be true at all times.</p><p>The function also states, as a precondition, that before the function executes, the value of the array's data pointer must not be NULL. This precondition guards against the problem of trying to store a value into an unallocated memory space. As a postcondition, the new upper bound of the array must be equal to its previous value plus one.</p><p>Together, <i>gef_invariants</i>, <i>gef_preconditions</i>, and <i>gef_postconditions</i> specify the contract to which the function, and its clients, must adhere to ensure proper operation.</p><h3>GEF Performance</h3><p><A HREF="9811e.htm#l1">Listing One</A> simply illustrates how to use GEF's features. If you think that a routine, such as <i>AddHighInt</i>, will be called frequently, then you may consider implementing it in a more efficient but equally robust manner to avoid having to use the <i>gef_try</i> statement, which can be relatively expensive.</p><p>My measurements have revealed that the overhead of executing a <i>gef_try</i>/<i>gef_end</i> block with nothing in it except a counter, requires about 2.6 msec on a P5 133-MHz PC, running Linux 2.0.30. On a 143-MHz Ultra-1 running under Solaris 2.5.1, the cost is between 2.9 msec and 3.3 msec.</p><p>I obtained these timings by executing in a loop a <i>gef_try</i>/<i>gef_end</i> block that was relatively empty except for the existence of a counter that increments continuously for 1 second.</p><p>I computed the iterations per second, and, based on the clock speed of the machine, computed a rough estimate of the number of instructions. The overhead of entering and exiting a <i>gef_try</i>/<i>gef_end</i> block can be from 2.6 to 2.9 msec. This is not terrible, but if you are implementing a low-level routine whose clients will invoke it many times, you may want to consider explicitly checking for assertion violations via <i>if-else</i> statements and throw an exception when necessary.</p><h3>GEF and Programming with Exceptions</h3><p>GEF supports a number of control statements for dealing with exceptions: <i>gef_throw</i>, <i>gef_retry</i>, and <i>gef_break</i>. The names are consistent with Java and C++, with the exception of the <i>gef_break</i> control statement. Although the <i>gef_retry</i> and <i>gef_break</i> statements must appear within the scope of a <i>gef_try</i>/<i>gef_end</i> pair, the <i>gef_throw</i> statement may appear anywhere in your program.</p><p>You can use the <i>gef_throw</i> control statement to raise an exception and transfer control to the appropriate <i>gef_catch</i> block. GEF automatically raises an exception when an assertion violation occurs. If you do not specify a callback function for assertion violations, GEF throws its own predefined exception; otherwise, GEF invokes your handler function. In such a case, GEF reports the line number and a string that represents the path to the source file in which the assertion violation occurred.</p><h3>GEF and Operating-System Signals</h3><p>You can also register functions that GEF will call when operating-system signals occur. GEF will only handle those OS signals that you specify during initialization. Signals that GEF can handle include UNIX's SIGALRM, SIGFPE, and SIGQUIT, among others. You must be careful when using GEF to handle asynchronous signals (such as SIGALRM) in a multithreaded program. </p><p>However, you may use GEF to handle synchronous operating-system signals without concern. For example, you may use GEF to catch floating-point errors on UNIX systems. Simply register the SIGFPE signal with GEF, and, if the signal occurs, GEF catches and delivers the signal to the appropriate exception handler in your program.</p><p>Typically, you will want to correct a problem that occurs during the execution of a function and retry the main body of code. The <i>gef_retry</i> statement lets you unconditionally transfer control to the <i>gef_try</i> block.</p><p>On occasion, a thread may reach a success point while executing within a <i>gef_catch</i> block. In such a case, you may use the <i>gef_break</i> statement to transfer control to the statement that appears immediately after the nearest <i>gef_end</i>.</p><p>Unlike GEF, the Eiffel programming language does not support a break statement for exception handlers. Eiffel's designers preferred that all operations terminate via the <i>try</i> block. As a result, Eiffel programmers often have to resort to setting and testing a Boolean to determine when to actually retry a block of code or to exit.  I found this restriction to be unnecessary, because what you end up implicitly implementing is a kind of break for an exception handler.</p><p><A NAME="rl2"><A HREF="9811e.htm#l2">Listing Two</A> illustrates how you might use exception handling instead of contracts. The <i>SquareRoot</i> function returns the square root of a number, provided that its value is not less than zero. If the value of the number is less than zero, then the <i>SquareRoot</i> function throws an EXCEPT_ARITHMETIC_VIOLATION exception. Actually, <i>SquareRoot</i> does not need to throw an exception if the number argument is less than 0.0. <i>SquareRoot</i> can rely upon the math library to call the global <i>matherr</i> function, which throws the proper exception if an arithmetic violation occurs.</p><p>The main function catches any exceptions and reports the error, if any, or the result to the console.</p><p>Unlike C++ and Java, if a thread reaches the end of a <i>gef_catch</i> block without handling an exception, GEF automatically rethrows the exception. In this respect, the <i>gef_catch</i> block is consistent with the rescue block of Eiffel. However, the difference between GEF's <i>gef_catch</i> and Eiffel's <i>rescue</i> is that Eiffel does not have the capability to report a specific error. In Eiffel, functions either succeed or fail. </p><p>The <i>gef_finally</i> block is simply a cleanup block. GEF always executes this block, regardless of whether an exception occurs. <A NAME="rl3"><A HREF="9811e.htm#l3">Listing Three</A>, for example, illustrates the use of the <i>gef_finally</i> block. The function, <i>PrintConcatenation</i>, accepts two strings (<i>s1</i> and <i>s2</i>) and a pointer to a FILE stream (<i>fp</i>). The function first acquires the memory (via <i>malloc</i>) into which it will store the concatenated string. It asserts that the resulting memory address not be NULL. The function continues by copying <i>s1</i> to the result and then concatenating <i>s2</i> to the result. The function subsequently prints a message to the specified stream (<i>fp</i>).</p><p>The last thing the function does is return the unneeded memory to heap storage in the <i>gef_finally</i> block. The code only frees the memory if the result is not NULL.</p><p>As a precondition, the function must ensure that <i>result</i> is NULL and that <i>s1</i> and <i>s2</i> are not NULL. Since the function relies upon a NULL test to determine when to free memory, the initial value of <i>result</i> must be NULL, indicating that it does not point to heap memory.</p><p>Every exception-handling block must end with a <i>gef_end</i> statement. The semicolon after the <i>gef_end</i> statement exists to ensure that syntax-aware editors (such as Emacs) will format your C code properly. However, it is not necessary.</p><h3>Other Features of GEF</h3><p><A NAME="rt1"><A HREF="9811et1.htm">Table 1</A> lists the current GEF statements and functions. For example, you may specify a callback function that GEF will use to delete exception objects. You will likely take advantage of this feature if your code is object oriented in nature.</p><p>For example, you may create an exception object in the heap and throw it, and, as soon as a function handles the exception, GEF will call your callback routine to dispose of the exception.</p><p>GEF disposes of exception objects when executing the <i>gef_retry</i> and <i>gef_break</i> statements from within a <i>gef_catch</i> block. Currently, GEF's default callback for deleting exception objects is a function that does nothing and returns. <A HREF="9811e.htm#l2">Listing Two</A> does not make use of this feature because it passes exceptions around as integers.</p><h3>C's <i>break</i> and <i>return</i> Statements</h3><p>You must be careful when you use the C language <i>break</i> and <i>return</i> statements. GEF maintains a parallel stack of checkpoints that enable it to perform nonlocal jumps when you throw an exception. If you exit the scope of an exception handler without passing through the <i>gef_end</i> code, GEF will become unsynchronized with your program, and your program will likely experience a most untidy fault. To avoid this problem, get in the habit of returning from a function at its end.</p><p>If you must use the C <i>return</i> statement, make sure that it is not within the scope of an exception handler. However, you need not worry about exception handlers of calling functions -- only the exception handlers in which you will be returning a value.</p><p>Likewise, also be careful when you use the C <i>break</i> statement. You may use the <i>break</i> statement, but make sure it doesn't transfer control of your program to a statement which resides outside of a <i>gef_end</i> statement. Substituting a C <i>break</i> statement for GEF's <i>gef_break</i> statement will frequently suffice. Make sure that what you are doing is safe and makes sense.</p><h3>Conclusion</h3><p>GEF is stable, mature, and flexible. I welcome suggestions on how to further increase its performance. Currently, however, the overhead of 2.6 msec is not bad for most applications. At the least, if you are writing C code that is not speed sensitive, you can utilize GEF to write more elegant and fault-tolerant C code. </p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</A></H4><pre>typedef struct {   int lowbound;   int highbound;   int size;   int **data;   int numberOfSlots;} *ArrayOfInt_t;staticvoidAddHighInt(ArrayOfInt_t self, int i) {   int old_highbound = self-&gt;highbound;   gef_try {      self-&gt;data[size++] = i;      self-&gt;highbound++;   } gef_invariants {      gef_assert(self-&gt;highbound - self-&gt;lowbound + 1 == self-&gt;size);   } gef_preconditions {      gef_assert(self-&gt;data != NULL);      gef_assert(self-&gt;numberOfSlots &gt; self-&gt;size);   } gef_postconditions {      gef_assert(self-&gt;highbound == old_highbound + 1);   } gef_end;}</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;math.h&gt;#include &lt;signal.h&gt;#include &lt;GEF.h&gt;<p></p>/* Define exception values for program */#define EXCEPT_FAILURE              0 /* This should never occur! */#define EXCEPT_OS_VIOLATION         1#define EXCEPT_INSUFFICIENT_MEMORY  2#define EXCEPT_ASSERTION_VIOLATION  3#define EXCEPT_ARITHMETIC_VIOLATION 4<p></p>staticvoidInsufficientMemory() {   gef_throw((void*) EXCEPT_INSUFFICIENT_MEMORY);}staticvoidAssertionViolation(char* fileName, int lineNumber) {   /* Can only transfer fileName and lineNumber info via a pointer to a */   /* structure.  For now, simply throw the integer value,              */   gef_throw((void*) EXCEPT_ASSERTION_VIOLATION);}staticvoidUnhandledException(void* exceptionID) {   fprintf(stderr, "\tUnhandled exception, %d, occurred, while executing                       process, %d.\n",((int) exceptionID), (int) getpid());}staticvoid*OSSignalToException(int signum) {   switch(signum) {   case SIGFPE:      return((void*) EXCEPT_ARITHMETIC_VIOLATION);   default:      return((void*) EXCEPT_OS_VIOLATION);   }}intmatherr(struct exception* e) {   /* This handler will catch all IEEE math violations */   gef_throw((void*) EXCEPT_ARITHMETIC_VIOLATION);}staticdoubleSquareRoot(double number) {   /* Check for number &lt; 0.0 for demonstration only. If math error occurs */   /* math library will call matherr, which will throw exception anyway. */   if (number &lt; 0.0) gef_throw((void*) EXCEPT_ARITHMETIC_VIOLATION);   return(sqrt(number));}intmain(int argc, char** argv) {   double number, answer;   int exitCode = 0;   sigset_t osSignalSet;   GEFAttr_t gefAttrs;   if (argc != 2) {      fprintf(stderr, "Usage: %s decimal\n", argv[0]);      exit(1);   }   /* Configure GEF for process. */   sigemptyset(&amp;osSignalSet); sigaddset(&amp;osSignalSet, SIGFPE);   GEFInitialize(osSignalSet);   /* Configure GEF for thread */   GEFAttr_Init(&amp;gefAttrs);   GEFAttr_SetAssertionViolation(&amp;gefAttrs, AssertionViolation);   GEFAttr_SetUnhandledException(&amp;gefAttrs, UnhandledException);   GEFAttr_SetOutOfMemory(&amp;gefAttrs, InsufficientMemory);   GEFAttr_SetOSSignalToException(&amp;gefAttrs, OSSignalToException);   GEFInitializeThread(gefAttrs);   gef_enable_assertions;   gef_try {      number = atof(argv[1]);      answer = SquareRoot(number);      printf("%f\n", answer);   } gef_preconditions {      gef_assert(argc == 2);   } gef_catch(exception) {     switch((int) exception) {     case EXCEPT_ARITHMETIC_VIOLATION:       fprintf(stderr,"%s: Cannot take square root of %f!\n",argv[0],number);       exitCode = 1;       gef_break;     default: break;     }   } gef_end;   GEFTerminate();   exit(exitCode);}</pre><P><A HREF="#rl2">Back to Article</A></P><H4><A NAME="l3">Listing Three</H4><pre>voidPrintConcatenation(char* s1, char* s2, FILE* fp) {   char* result = NULL;   gef_try {      result = malloc(strlen(s1) + strlen(s2) + 1);      gef_assert(result != NULL);      strcpy(result, s1);      strcat(result, s2);      fprintf(fp, "Concatenation of %s and %s is %s!\n", s1, s2, result);   } gef_preconditions {      gef_assert(result == NULL);      gef_assert(s1 != NULL);      gef_assert(s2 != NULL);   } gef_finally {      if (result != NULL) free((void*) result);      result = NULL;   } gef_end;}</pre><P><A HREF="#rl3">Back to Article</A></P><HR><I>Copyright &copy; 1998, Dr. Dobb's Journal</I><BR>
</body></html>