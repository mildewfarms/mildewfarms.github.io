<html><head><title>Nov98: Programmer's Bookshelf</title></head><body bgcolor="FFFFFF"><!--Copyright &#169; Dr. Dobb's Journal--><h1>No Engineers Were Harmed in the Production of this Book</h1><p><i>Dr. Dobb's Journal</i> November 1998</p><h3>By Gregory V. Wilson</h3><I>Greg is the author of Practical Parallel Programming (MIT Press, 1995), and coeditor with Paul Lu of Parallel Programming Using C++ (MIT Press, 1996). Greg can be reached at gvwilson@interlog.com.</I><hr><h4><i>Web Site Usability: A Designer's Guide</i><br>Jared M. Spool, Tara Scanlon, Will Schroeder, Carolyn Snyder, and Terri DeAngelo<br>User Interface Engineering, 1997<br>155 pp., $79.95<br>ISBN 0-96606-410-0<br><br><i>Information Architecture for the World Wide Web</i><br>Louis Rosenfeld and Peter Morville<br>O'Reilly & Associates, 1998<br>202 pp., $24.95<br>ISBN 1-56592-282-4<br><br><i>Official Guide to Programming with CGI.pm</i><br>Lincoln D. Stein <br>John Wiley & Sons, 1998<br>310 pp., $29.99<br>ISBN 0-471-24744-8<br><br><i>Jesse Liberty's Clouds to Code</i><br>Jesse Liberty<br>Wrox Press, 1997<br>392 pp., $40.00<br>ISBN 1-861000-95-2<br><br><i>Advanced Programming Language Design</i> <br>Raphael A. Finkel <br>Addison-Wesley, 1996<br>480 pp., $51.95<br>ISBN 0-8053-1191-2<br><br><i>Practical Software Configuration Management</i><br>Tim Mikkelsen and Suzanne Pherigo<br>Prentice Hall PTR, 1997<br>301 pp., $49.00<br>ISBN 0-13-240854-6</h4><p>No engineers were harmed in the production of <i>Web Site Usability: A Designer's Guide by </i>Jared Spool et al; according to the book's front page anyway. Having read the book twice in as many weeks, I want to ask the authors, "Yeah, but what about their egos?" This slim book, privately published by User Interface Engineering, is an empirical study of what makes web sites more or less usable. The authors tested nine sites, ranging from Disney and the '96 Olympics to Travelocity and Edmund's car and truck price guides, in a variety of simple ways. One test, for example, was to see how easy it was for people to figure out whether it was cheaper to fly to Nevada or England. Another was to find out whether you could buy a Honda Accord for under $15,000.</p><p>The results were startling. Disney and C|net, with their graphical menus and high-priced layout, fared worst; Edmund's, which pretty much sticks to point-form lists, did best. As they examined their findings more closely, the authors came to some surprising conclusions:</p><ul>  <li>Graphic design makes no measurable difference to usability.  <li>Text links are vital. They almost always become visible before image links, and they usually convey more information.  <li>Navigation and content are inseparable: If one group creates a standard appearance for pages, and another fills in the content, the results are probably going to be hard to use.  <li>The usability of web sites cannot be measured in the same way as the usability of software; there is, for example, much less correlation between success rate and enjoyment for web sites than for software packages.</ul><p>All of this is covered in the first 20 pages; the remaining 135 pages of the book examine these points, and many others, in more detail. The writing is clear, the observations are pointed and believable, and most of what Spool and his colleagues say can immediately be put into practice. In short, <i>Web Site Usability</i> is excellent value for the money, and an excellent example of how professionals should use empirical study, rather than guesswork and prejudice, to guide their work. My only complaint is that it's hard to figure out from the text how many (or how few) testers the editors actually used.</p><p>Louis Rosenfeld and Peter Morville's <i>Information Architecture for the World Wide Web</i> complements <i>Web Site Usability</i> nicely. An information architect is someone who is responsible for organizing data to make details findable, patterns apparent, and complex ideas clear. The card catalog in the library I worked in after school when I was a teenager, and the table of contents and index of a book, are the most venerable bits of information architecture around, but relational databases and the Web are catching up fast. The difference between good and bad information architecture is as hard to pin down as the difference between good and bad physical architecture, but it is also as immediately noticeable, and has at least as much influence on productivity and enjoyment. A well-structured web site is like a quiet, comfortable cafe; most, unfortunately, have more in common with reform school cafeterias.</p><p>Thankfully, the motherhood and blackberry pie part of <i>Information Architecture</i> is fairly short. Most of its 10 chapters are spent describing what information architects do, and how they can tell if they're doing it right. There's a whole chapter on "Designing Navigation Systems," which talks about how links should be structured, rather than how to change their color or make them say ouch! when they're clicked. There's another chapter on "Labeling Systems," and another on searching, which includes a discussion of how to understand the ways in which users actually conduct searches. This chapter even suggests that it doesn't always make sense to make pages searchable; while this is technologically heretical, it may make perfect sense from a usability point of view.</p><p><i>Information Architecture</i> closes off with a short case study, a six-page (unannotated) bibliography, and a brief but useful index. As with most organizational books, much of what it says will seem obvious in retrospect, but 10 minutes of random surfing ought to be enough to convince anyone that the Web would be in less danger of drowning in its own cancerous success if more designers -- and managers -- paid attention to this book's precepts.</p><p>Unlike the previous two books, Lincoln Stein's <i>Official Guide to Programming with CGI.pm</i> is chock full of technical details and Perl widgetry. CGI.pm is a Perl module for creating and processing HTML. Instead of dozens of lines of <i>print</i> statements and regular expressions, you can simply load CGI.pm and ask it for parameter values, button states, and the like. CGI.pm doesn't make web scripting painless -- it can't make any of the decisions that so concern the authors of <i>Web Site Usability</i> and <i>Information Architecture</i>, for example; but it's like having a power saw instead of a dull hand-held. After finishing its discussion of the basics of CGI.pm, some advanced features, ways of extending the module, and the reference guide, I had only one question: Who decided that this book was "official" and that others on the same subject were not? </p><p>I suspect the answer is "someone in marketing," and I further suspect I'd get the same answer if I asked who was responsible for calling the next book: <i>Jesse Liberty's Clouds to Code</i>. I lay awake for over an hour one night after noticing the possessive in the title, trying to figure it out; guess I should have checked whether they were serving decaf at dinner before having thirds...</p><p>That oddity aside, <i>Clouds to Code</i> is readable, enjoyable, and informative. It is a semifictionalized account of the design, development, and deployment of an automated calling system. There are no embarrassing "slice of life" dialogues, and no discussion of the office politics of the rich and infamous. Instead, Liberty describes how he and his colleagues set about creating a particular piece of software. The chapter titles reflect the project's progress: "Conceptualization," "Analysis," "High-Level Design," "Low-Level Design," "Implementation," "Getting to Feature Freeze" (which has sections ranging from "Prioritizing" to "Implementing the IPC in COM"), and "Delivering Version 1.0." Each chapter is a healthy mix of the abstract, such as how to get management buy-in when you have to cut features to meet a deadline, and the concrete. What's more, the concrete bits are refreshingly up-to-date: Diagrams, for example, are (mostly) done using the recently standardized Unified Modeling Language (UML).</p><p>Where Steve McConnell's <i>Rapid Development</i> is a survey, <i>Clouds to Code</i> shows what good software development looks like in practice. Its only weakness is an unavoidable one: Any concrete description of code development has to present real code. That code is inevitably going to be uninteresting to most people, and go stale pretty quickly. I would have devoured this book when I was 20 or 25; I still got a lot out of it at 35, and enjoyed getting a glimpse into a good craftsman's mind.</p><p>I didn't enjoy the last two books in this month's review as much as the first four, but that's not necessarily the books' fault. Raphael Finkel's <i>Advanced Programming Language Design</i> reminded me of a Victorian naturalist's description of his most recent expedition up the Orinoco. The book is dedicated to Finkel's father, "Who first tickled my interest in programming languages by announcing that he was learning a language that could be read and written, but not pronounced."</p><p>I was fascinated by some of the ideas in this book, such as how different notions of what a "type" is can have a profound influence on how easy or difficult it is to do certain things in a programming language, or how coroutines can be used to replace more traditional control structures. Some of it, however, fell under the heading of "more detail than I needed" -- figuring out how to achieve the appearance and effect of CLU iterators in C using macros might be a real intellectual challenge, but that doesn't mean it's worth sharing. And in some parts, such as the discussion of concurrent programming, I got the feeling that the author's descriptions were secondhand; his discussion was shallower and less incisive than the earlier parts of the book. While it's probably worth reading for ideas if you're designing a new language, it's probably not worth reading if you're simply curious.</p><p>Tim Mikkelsen and Suzanne Pherigo's <i>Practical Software Configuration Management</i> was a disappointment. It has always struck me as odd that there are hundreds of books about building compilers and operating systems, which relatively few programmers ever do, but very few on everyday activities like setting up and maintaining a code base or packaging software so that it can be installed by people who aren't intimately familiar with it. Based on its table of contents and the "Hewlett-Packard Professional Books" imprint on its cover, I had high hopes. Unfortunately, <i>PSCM</i> is slow moving and shallow. There is, for example, little discussion of how version control systems actually track changes, or of how they track and store branches when several versions of a program are being developed concurrently. While most users probably don't care, sooner or later every CVS administrator has to unbreak a repo, at which point that kind of information is suddenly worth its weight in overtime. <i>PSCM</i> also devotes far too much space to a feature-by-feature comparison of various commercial and public-domain tools. Yes, this information is valuable, but only if it's fresh; a web site updated twice a year would have been far more useful.</p><p><b>DDJ</b></p><HR><I>Copyright &copy; 1998, Dr. Dobb's Journal</I><BR>
</body></html>