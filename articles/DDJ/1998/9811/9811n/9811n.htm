<html><head><title>Nov98: Algorithm Alley</title></head><body bgcolor="FFFFFF"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Sorting Strings with Three-Way Radix Quicksort</h1><p><i>Dr. Dobb's Journal</i> November 1998</p><h3>By Jon Bentley and Robert Sedgewick</h3><I>Jon is a member of technical staff at Bell Labs. Robert is the William O. Baker Professor of Computer Science at Princeton University. They can be reached at jlb@ research.bell-labs.com and rs@cs.princeton .edu, respectively.</I><hr><p>Quicksort is a champion all-around sorting algorithm. Radix sort, however, is often faster for sorting strings because it decomposes a string into characters. This month, we'll examine a "three-way radix quicksort" algorithm that applies the general approach of quicksort character-by-character. A simple implementation of the algorithm is competitive with the most-efficient string-sorting programs we know. </p><p>We first described the algorithm in a 1997 paper entitled "Fast Algorithms for Sorting and Searching Strings" (<i>Proceedings of the 8th Annual ACM-SIAM Symposium on Discrete Algorithms,</i> January 1997). This "SODA" paper gives the theory behind the algorithm and extensive references. It also describes the algorithm's relationship to a data structure for storing strings. For more information, see "Ternary Search Trees," by Jon Bentley and Robert Sedgewick (<i>DDJ</i>, April 1998). </p><p>But why do you need yet another sorting function? Isn't the standard library <i>qsort</i> good enough? On most systems, it is indeed an efficient and powerful general-purpose tool. But the power of the general <i>compare</i> function comes at a price in performance. Experiments we've conducted show that our specialized string sort can be faster than <i>qsort by </i>a factor of four. If your strings contain 16-bit Unicode characters rather than standard eight-bit characters, the savings might be even more dramatic. </p><h3>Three-Way Quicksort </h3><p>Quicksort was first described by C.A.R. Hoare in 1962 (see "Quicksort," <i>Computer Journal 5</i>, 1, 1962). It is a textbook divide-and-conquer algorithm. To sort an array, you choose a partitioning element, permute the elements, placing smaller elements on one side and larger elements on the other, and then recursively sort the two subarrays. But what happens to elements equal to the partitioning value? Hoare's method uses two-way partitioning: As <A NAME="rf1"><A HREF="9811nf1.htm">Figure 1</A>(a) illustrates, it places lesser elements on the left and greater elements on the right, but equal elements may appear on either side. A three-way quicksort partitions the elements to leave equal items in the middle, as in <A HREF="9811nf1.htm">Figure 1</A>(b). </p><p>Once we have achieved this state, we can recur on the left and right subarrays and ignore the middle elements (which are already in place). <A NAME="rf2"><A HREF="9811nf2.htm">Figure 2</A> is a sketch of this in pseudocode, with a <i>qs</i> function that sorts the sequence <i>s</i> of length <i>n</i>. An efficient implementation of three-way partitioning (see "Engineering a Sort Function," by J.L. Bentley and M.D. McIlroy, <i>Software: Practice and Experience 23</i>, 1, 1993) uses the counterintuitive loop invariant in <A NAME="rf3"><A HREF="9811nf3.htm">Figure 3</A>(a). </p><p>You may think of the index <i>lt</i> as pointing above the elements that are less than the partitioning value <i>v</i>, and of <i>le</i> as indexing the equal elements that happen to fall on the lesser side. Similarly, <i>gt</i> indexes the elements that are greater than <i>v</i>, and <i>ge</i> indexes the equal elements on the greater side. The main partitioning loop has two inner loops. The first inner loop moves <i>lt</i> up: It scans over lesser elements, swaps equal elements to <i>le</i>, and halts on a greater element:</p><blockquote><p></p><p>for ( ; lt &lt;= gt &amp;&amp; a[lt] &lt;= v; lt++)</p><p>    if (a[lt] == v)</p><p>        swap(a, le++, lt); </p></blockquote><p>The <i>swap</i> function exchanges two elements of its first argument; we'll see its implementation shortly. The second inner loop moves <i>gt</i> down correspondingly. The main loop then swaps the elements to which <i>lt</i> and <i>gt </i>point, increments <i>lt</i> and decrements <i>gt</i>: </p><blockquote><p></p><p>swap(a, lt++, gt--); </p></blockquote><p>The loop terminates when <i>lt</i> and <i>gt</i> cross. </p><p>After the loop ends, the array is in the state shown in <A HREF="9811nf3.htm">Figure 3</A>(b). At this time, the equal elements on the edges are swapped to the middle of the array. There are <i>lt-le</i> lesser elements, and <i>le</i> equal elements on that side. We will use a vector swap function to move the smaller of those two sequences: </p><blockquote><p></p><p>r = min(le, lt-le); </p><p>vecswap(a, 0, lt-r, r); </p></blockquote><p>Similar code swaps the equal elements on the high end of the array. Once the equal elements are in their proper places, we can recur: </p><blockquote><p></p><p>iqs(a, lt-le); </p><p>iqs(a + n-(ge-gt), ge-gt); </p></blockquote><p>The first call sorts the first <i>lt-le</i> (lesser) elements at the bottom of array <i>a</i>. The second call sorts the <i>ge-gt</i> (greater) elements at the top of the array. </p><p><A NAME="re1"><A HREF="9811ne1.htm">Example 1</A> illustrates this algorithm with three-way quicksort code to sort an array of integers. The <i>swap</i> statement in the fifth line randomly chooses a partition value. The <i>swap</i> function exchanges two integers: </p><blockquote><p></p><p>void swap(int a[], int i, int j) </p><p>{   int t = a[i];</p><p>    a[i] = a[j];</p><p>    a[j] = t; </p><p>} </p></blockquote><p>To move the equal elements into the middle, we will employ a vector swap function that exchanges the sequences of <i>n</i> elements that begin at positions <i>i</i> and <i>j</i>: </p><blockquote><p></p><p>void vecswap(int a[], int i,            int j, int n) </p><p>{   while (n-- &gt; 0)</p><p>       swap(a, i++, j++); </p><p>} </p></blockquote><h3>Radix Sort </h3><p>Suppose that you want to sort a scrambled dictionary of 10,000 English words, each one of which is represented on a 3&times;5-inch index card. Your first step might be to put the cards into 26 smaller piles, one for the words that begin with the letter "a," one for "b," and so forth. You then sort each pile, perhaps using a similar approach but looking at the second letter of each word. After all 26 piles are sorted, you concatenate them to form the final sorted list. </p><p>This is the idea underlying radix sort. To sort a set of strings, we partition the set into "piles" based on their first characters. For an eight-bit character set, we usually implement the piles with an array of length 256. Radix sort then recurs on each pile, and finally concatenates the sorted piles to form the output. Turning this sketch into an efficient program requires careful choice of data structures (see "Engineering Radix Sort," by P.M. McIlroy, K. Bostic, and M.D. McIlroy, <i>Computing Systems 6</i>, 1, 1993). Radix sort can be blazingly fast because it inspects each character of each word at most once. </p><h3>An Algorithm for Sorting Strings </h3><p>A standard way to sort an array of pointers to strings in C is to call the <i>qsort</i> library function (historically implemented by quicksort); one of the parameters to the <i>qsort</i> function is the <i>strcmp</i> function to compare strings. This method does not exploit any structural properties of string keys. When it is used for huge files and long strings, it accesses the characters at the beginning of the strings much more frequently than necessary. We'll now turn to an algorithm that cuts down the number of characters accessed to nearly the absolute minimum used by radix sort. </p><p>Building on an insight of P. Shackleton, Hoare sketched a quicksort modification for sorting multiword keys (strings may be viewed as keys composed of many characters): </p><blockquote><p>When it is known that a segment comprises all the items, and only those items, which have key values identical to a given value over the first <i>n</i> words, in partitioning this segment, comparison is made of the <i>(n</i>+1)th word of the keys.</p></blockquote><p>We will use this idea to sort a set of C strings. Like regular quicksort, the algorithm partitions its input into sets less than, equal to, and greater than a given value. Like radix sort, when the current input contains equal initial characters, the algorithm moves on to the next character. </p><p>Three-way partitioning is the key to our implementation of Hoare's multiword quicksort. This recursive pseudocode in <A NAME="rf4"><A HREF="9811nf4.htm">Figure 4</A> sorts the sequence <i>s</i> of length <i>n</i> that is known to be identical in characters <i>0..depth</i>-1; it is originally called as <i>ssort(s, n, 0)</i>. </p><h3>A Simple String Sort Implementation </h3><p>We will now implement the three-way quicksort algorithm as a C function to sort strings. The primary sort function: </p><blockquote><p></p><p>void ssortmain(char *a[], int n) </p><p>{ ssort(a, n, 0); }</p></blockquote><p>is passed the array <i>a</i> of <i>n</i> pointers to character strings; its job is to permute the pointers so that the strings occur in lexicographic order. The <i>ssort</i> function in <A NAME="re2"><A HREF="9811ne2.htm">Example 2</A> is a straightforward extension of <A HREF="9811ne1.htm">Example 1</A>. It is passed both <i>a</i> and <i>n</i>, and the additional integer <i>depth</i> to tell which characters are to be compared. The algorithm terminates either when the vector contains at most one string or when the current depth "runs off the end" of a string by encountering a terminating null character. The <i>ssort</i> function uses several supporting functions; <A NAME="rl1"><A HREF="9811n.htm#l1">Listing One</A> (at the end of this article) contains the complete code. As in <A HREF="9811ne1.htm">Example 1</A>, <i>swap</i> exchanges a pair of vector elements, and <i>vecswap</i> exchanges a sequence of elements. The <i>ch</i> macro (for "character") accesses character <i>depth</i> of string <i>a[i]</i>: </p><blockquote><p></p><p>#define ch(i) a[i][depth] </p></blockquote><p>This simple code is but one implementation of three-way radix quicksort. <i>Algorithms in C</i>, Third Edition, by Robert Sedgewick (Addison-Wesley, 1998) implements the same loop invariant with substantially different code. </p><h3>Standard Quicksort Speedups </h3><p>Although quicksort is efficient for large arrays, simpler algorithms sometimes have less overhead for small arrays. <A HREF="9811ne2.htm">Example 2</A> uses the termination test: </p><blockquote><p></p><p>if (n &lt;= 1)  </p><p>    return; </p></blockquote><p>We replaced it with the standard speedup of terminating the recursion by switching to an insertion sort for small arrays (the constant 10 was determined experimentally): </p><blockquote><p></p><p>if (n &lt;= 10) {  </p><p>   inssort(a, n, depth);</p><p>   return; </p><p>} </p></blockquote><p>Because we know that all strings are equal through <i>depth</i> characters, the insertion sort can start comparisons there. (For this reason, we could not employ the further speedup of using a single insertion sort after the original quicksort.) The nine-line <i>inssort</i> function is in <A HREF="9811n.htm#l1">Listing One</A>. </p><p><A HREF="9811ne2.htm">Example 2</A> selects a random element as the partition value and swaps it to the beginning with the statement: </p><blockquote><p></p><p>swap(a, 0, rand() % n); </p></blockquote><p>Another well-known speedup finds a partitioning value near the center of the set by choosing the median of three elements: </p><blockquote><p></p><p>pm = med3(0, n/2, n-1); </p><p>swap(a, 0, pm); </p></blockquote><p>The <i>med3</i> function returns the index that has the median value of the three indices; its 10-line implementation is in <A HREF="9811n.htm#l1">Listing One</A>. We use an extension that selects the median of three medians-of-three for large arrays: </p><blockquote><p></p><p>pl = 0; </p><p>pm = n/2; </p><p>pn = n-1; </p><p>if (n &gt; 50) {</p><p>    d = n/8;</p><p>    pl = med3(pl, pl+d, pl+2*d);</p><p>    pm = med3(pm-d, pm, pm+d);</p><p>    pn = med3(pn-2*d, pn-d, pn); </p><p>} </p><p>pm = med3(pl, pm, pn); </p><p>swap(a, 0, pm); </p></blockquote><p>Another standard quicksort optimization saves space by replacing recursion with an explicit stack and sorting the smaller subfile first. Our string quicksort has excellent stack utilization on the average, and good utilization in the worst case, so we chose to avoid the extra code. We experimented with standard programming speedups and found that most were not needed with modern hardware and optimizing compilers. For instance, without optimization, rewriting the swap function as a macro gave a substantial speedup; with optimization enabled, it made no difference. Common subexpression elimination performed by compilers made it unnecessary to store the result of the character comparisons in the innermost loops. Similarly, we did not need to convert array indices to pointers. On less advanced systems, though, it might be profitable to incorporate such speedups in the source code. </p><h3>A Speedup for Equal Characters </h3><p>What happens when the input array contains identical keys at the specified depth? This case is not as far-fetched as it might seem: A few scans over 26-character alphabets quickly pares the input down to single (leading) characters. <A HREF="9811ne2.htm">Example 2</A> deals with this case rather gracelessly: It performs a <i>swap</i> to move each input pointer back to its current position. </p><p>Fortunately, we are able to handle this common case efficiently while introducing little overhead. Immediately after the partitioning value <i>v</i> is chosen, a new loop moves the <i>le</i> index up as far as possible. If it moves all the way to the end of the array, we recur for the next character and <i>return</i> from the function. In the very worst case (of the first element being unequal), the new code costs just three extra comparisons. After the loop and test, we set <i>lt</i> to <i>le</i>, and proceed as before: </p><blockquote><p></p><p>v = ch(0); </p><p>for (le = 1; le &lt; n &amp;&amp; ch(le) == v;         le++) </p><p>    ; </p><p>if (le == n) {</p><p>    if (v != 0)</p><p>       ssort2(a, n, depth+1);</p><p>   return; </p><p>} </p><p>lt = le; </p></blockquote><p>We tested this speedup on the extreme input of 100,000 equal keys, each of which consisted of 20 "0" characters. The new code was 20 percent faster on a MIPS R10000 and 40 percent faster on a Pentium Pro.</p><h3>Experiments </h3><p>We have tested many sort algorithms on many string inputs on many computers. Three-way radix quicksort performs well under a broad range of conditions. We sketch one small but representative experiment in this section; additional data may be found in our SODA paper and in Sedgewick's 1998 <i>Algorithms in C</i>.</p><p>We ran our simple experiments on two machines: a 250-MHz MIPS R10000 and a 200-MHz Pentium Pro. We compiled the identical source code under the highest optimization level available on each machine. We used two input files: one of 100,000 identical keys (each of 20 zeros) and a dictionary word list of 234,936 words (in 2,486,813 characters). We timed four different algorithms: the system <i>qsort</i> function calling <i>strcmp</i>, <A HREF="9811ne2.htm">Example 2</A>, the tuned version of three-way radix quicksort, and the fastest radix sort we know (from the paper by McIlroy, Bostic, and McIlroy). <A NAME="rt1"><A HREF="9811nt1.htm">Table 1</A> gives the number of seconds required by the various functions.</p><p>The one eternal truth contained in this table is that timing algorithms is difficult. The tuned sort is always faster than the simple <A HREF="9811ne2.htm">Example 2</A>; we have never seen it run more slowly. The simple sort is usually faster than the system sort (except when one system sort exploited the special case of equal keys). Our tuned sort appears to be quite competitive with the fast radix sort. The primary challenge in implementing a radix sort is the case when the number of distinct keys is much less than the number of bins, either because the keys are all equal or because there are not many of them. Three-way radix quicksort may be thought of as a radix sort that gracefully adapts to handle this case, at the cost of slightly more work when the bins are all full. We encourage you to experiment with the algorithms yourself. The code that we used for this experiment is available online; see "Resource Center," page 3. If your results differ from ours for an important class of inputs, we would be interested in knowing about it. </p><h3>Conclusion </h3><p>Traditional library sorts are usually effective general-purpose tools, but we can do better for some particular applications. Three-way partitioning (<A HREF="9811ne1.htm">Example 1</A>) works well when the number of distinct key values is small, and three-way radix quicksort (<A HREF="9811ne2.htm">Example 2</A>) can be very effective for string keys. </p><p>Three-way radix quicksort is well suited for 16-bit Unicode applications (for example, those written in Java). The algorithm exploits the fact that only a small fraction of possible character values are typically in ASCII strings. This fraction is even smaller for Unicode strings. </p><p>Many sorts involve keys with multiple fields. A sort must arrange items in order according to the first key, with all equal values in order by their second keys, and so forth. Dates, for instance, are usually sorted first by year, then by month, then by day of the month. Our SODA paper generalizes <A HREF="9811ne2.htm">Example 2</A> to a multikey quicksort; that algorithm might provide a useful basis for a general-purpose multikey sort program. </p><p><b>DDJ</b></p><H4><a name="l1"></a>Listing One</H4><pre>/* Support functions */<p></p>#ifndef min #define min(a, b) ((a)&lt;=(b) ? (a) : (b)) #endif<p></p>void swap(char *a[], int i, int j) {     char *t = a[i];      a[i] = a[j];      a[j] = t; }void vecswap(char *a[], int i, int j, int n) {     while (n-- &gt; 0)         swap(a, i++, j++); }<p></p>/* Simple version */ <p></p>#define ch(i) a[i][depth] <p></p>void ssort(char *a[], int n, int depth) {     int le, lt, gt, ge, r, v;      if (n &lt;= 1)         return;      swap(a, 0, rand() % n);      v = ch(0);      le = lt = 1;      gt = ge = n-1;      for (;;) {          for ( ; lt &lt;= gt &amp;&amp; ch(lt) &lt;= v; lt++)             if (ch(lt) == v)               swap(a, le++, lt);          for ( ; lt &lt;= gt &amp;&amp; ch(gt) &gt;= v; gt--)             if (ch(gt) == v)               swap(a, gt, ge--);          if (lt &gt; gt)             break;          swap(a, lt++, gt--);     }     r = min(le, lt-le);     vecswap(a, 0, lt-r, r);     r = min(ge-gt, n-ge-1);     vecswap(a, lt, n-r, r);     ssort(a, lt-le, depth);     if (v != 0)<p></p><p></p>         ssort(a + lt-le, le + n-ge-1, depth+1);     ssort(a + n-(ge-gt), ge-gt, depth); }<p></p>void ssortmain(char *a[], int n) {    ssort(a, n, 0); } <p></p>/* Faster version */<p></p>int med3func(char *a[], int ia, int ib, int ic, int depth) {   int va, vb, vc;    if ((va=ch(ia)) == (vb=ch(ib)))         return ia;    if ((vc=ch(ic)) == va || vc == vb)         return ic;    return va &lt; vb ?          (vb &lt; vc ? ib : (va &lt; vc ? ic : ia ) )        : (vb &gt; vc ? ib : (va &lt; vc ? ia : ic ) ); } #define med3(ia, ib, ic) med3func(a, ia, ib, ic, depth)<p></p>void inssort(char *a[], int n, int depth) {   int i, j;    for (i = 1; i &lt; n; i++)      for (j = i; j &gt; 0; j--) {         if (strcmp(a[j-1]+depth, a[j]+depth) &lt;= 0)             break;         swap(a, j, j-1);      } }  <p></p>void ssort2(char *a[], int n, int depth) {    int le, lt, gt, ge, r, v;     int pl, pm, pn, d;     if (n &lt;= 10) {        inssort(a, n, depth);        return;     }     pl = 0;     pm = n/2;     pn = n-1;     if (n &gt; 50) {        d = n/8;        pl = med3(pl, pl+d, pl+2*d);        pm = med3(pm-d, pm, pm+d);        pn = med3(pn-2*d, pn-d, pn);     }     pm = med3(pl, pm, pn);     swap(a, 0, pm);     v = ch(0);     for (le = 1; le &lt; n &amp;&amp; ch(le) == v; le++)       ;       if (le == n) {         if (v != 0)            ssort2(a, n, depth+1);         return;     }     lt = le;     gt = ge = n-1;     for (;;) {         for ( ; lt &lt;= gt &amp;&amp; ch(lt) &lt;= v; lt++)             if (ch(lt) == v)                 swap(a, le++, lt);         for ( ; lt &lt;= gt &amp;&amp; ch(gt) &gt;= v; gt--)             if (ch(gt) == v)                 swap(a, gt, ge--);         if (lt &gt; gt)             break;         swap(a, lt++, gt--);     }         r = min(le, lt-le);         vecswap(a, 0, lt-r, r);         r = min(ge-gt, n-ge-1);         vecswap(a, lt, n-r, r);         ssort2(a, lt-le, depth);         if (v != 0)             ssort2(a + lt-le, le + n-ge-1, depth+1);         ssort2(a + n-(ge-gt), ge-gt, depth); } <p></p>void ssort2main(char *a[], int n) { ssort2(a, n, 0); }</pre><P><A HREF="#rl1">Back to Article</A></P><p><b>DDJ</b></p><HR><I>Copyright &copy; 1998, Dr. Dobb's Journal</I><BR>
</body></html>