<html><head><title>Dr. Dobb's Journal July 1998: Java Q&A</title></head><body bgcolor="FFFFFF"><!--Copyright &#169; Dr. Dobb's Journal--><h1>How Do I Process Images with Java?</h1><p><i>Dr. Dobb's Journal</i> July 1998</p><h3>By Aaron Michael Cohen </h3><I>Aaron, who is a staff engineer at Intel where he develops video teleconferencing systems, is also the coauthor of Win32 Multithreaded Programming (O'Reilly &amp; Associates, 1997). He can be contacted at alcohen@ix.netcom.com, or http://www.netcom.com/~alcohen/.</I><hr><p>The Java API defines an abstract imaging model that can be used to display and manipulate both static images and sequences of images. The imaging model is defined in terms of the interactions between an abstract class, <i>Image</i>, and three interfaces: <i>ImageProducer</i>, <i>ImageConsumer</i>, and <i>ImageObserver</i>. These interfaces and their support classes are defined in the java.awt.image package.</p><p>The <i>Image</i> abstract class represents a platform-independent displayable image. Images can be created from image files loaded from the local file system or over a network using <i>getImage(URL url)</i> or <i>getImage(URL url, String name)</i>. These functions will only succeed with files using one of the supported file formats. Currently, JPEG and GIF file formats are universally supported.</p><p>Images can also be created with a call to the <i>createImage()</i> function of an AWT Component or available Toolkit object. There are several forms of the <i>createImage()</i> function:</p><ul><li><i>Image createImage(ImageProducer source)</i> creates an image from an object implementing the <i>ImageProducer</i> interface.  <li><i>Image createImage(int width, int height)</i> creates a blank image of a given size that can be drawn on using a <i>Graphics</i> object.  <li><i>Image createImage(byte[] imagedata)</i> creates an image from JPEG or GIF format data stored in an array. Only available in Java 1.1 or later.  <li><i>Image createImage(byte[] imagedata, int offset, int length)</i> creates an image from JPEG or GIF format data stored in <i>length </i>bytes of an array starting at the given offset. Only available in Java 1.1 or later.</ul><p>One of the <i>createImage()</i> methods lets you create an <i>Image </i>from an <i>ImageProducer</i>. You can retrieve the <i>ImageProducer</i> associated with an image by using the <i>ImageProducer getSource()</i> method of the <i>Image</i> class.</p><p>Drawing onto an image is accomplished by using the methods of the <i>java.awt.Graphics</i> class. Create a <i>Graphics</i> object associated with the image by using the <i>getGraphics()</i> method. Anyone who has programmed in Java even a little has written the code to draw an image into a existing <i>Graphics</i> context by calling <i>drawImage()</i> inside a <i>Component</i>'s paint() handler, so I will not cover that in more detail here. </p><p>An image also has properties such as width and height, which can be retrieved with methods defined in the <i>Image</i> base class. Java has the built-in capability to download and display images in the background. Because of this it is possible to call methods on an <i>Image</i> object before the necessary data is available. These methods require an <i>ImageObserver</i> as a parameter. For example, the <i>getWidth()</i> and <i>getHeight()</i> methods each require an object implementing the <i>ImageObserver</i> interface as a parameter. When the requested information cannot be returned immediately, these functions return -1.</p><p>The <i>ImageObserver</i> interface defines one method, <i>imageUpdate</i> (see <a name="re1"><a href="9807me1.htm">Example 1</A>). When an operation on an <i>Image</i> object cannot be completed immediately because the data is not yet available, a thread is created, which loads the data in the background. As the data is loaded, <i>imageUpdate()</i> of all registered image observers is called notifying the observer of progress. The <i>img</i> parameter refers to the image for which there is new information. The <i>infoflags</i> parameter is a set of flags that define what type of information is now available. The meaning of the rest of the parameters is dependent upon the content of <i>infoflags</i>. Returning <i>true </i>from <i>imageUpdate()</i> requests further information on the image. The function should return <i>false </i>if the <i>ImageObserver</i> is not interested in any further callbacks for this image. All AWT components implement the <i>ImageObserver</i> interface. The default behavior repaints the image when additional pixel data arrives. You usually do not have to override the default component implementation.</p><p>So where does the image data come from? Each <i>Image</i> is associated with an <i>ImageProducer</i>, which can be retrieved by calling the <i>getSource()</i> method on the <i>Image</i> object. The <i>ImageProducer</i> is responsible for delivering the image data upon request to <i>ImageConsumer</i> objects. An <i>ImageProducer</i> object makes calls on the methods of the <i>ImageConsumer</i> interface to inform the <i>ImageConsumer</i> of the image type, size, and pixel data. Both the <i>ImageProducer</i> and <i>ImageConsumer</i> interfaces are defined in the java.awt.image package. The relationship between the classes in the Java imaging model looks like <a name="rf1"><a href="9807mf1.htm">Figure 1</A>.</p><p>All of the methods of the <i>ImageProducer</i> class have to do with <i>ImageConsumer</i> objects registering as consumers with the producer object and requesting data. These methods are fairly straightforward:</p><ul><li><i>void addConsumer(ImageConsumer ic)</i> adds a consumer to the <i>ImageProducer</i>. The consumer will be delivered image data the next time new data is available.  <li><i>boolean isConsumer(ImageConsumer ic)</i> determines whether a consumer is currently registered with the <i>ImageProducer</i>.  <li><i>void removeConsumer(ImageConsumer ic)</i> removes the given consumer from the producer's list of consumers.  <li><i>void requestTopDownLeftRightResend(ImageConsumer ic)</i> requests the producer to resend its image data in top-down, left-to-right order. The producer may choose not to honor this request.  <li><i>void startProduction(ImageConsumer ic)</i> registers a consumer with the producer and deliver the current image data to the consumer as soon as possible.</ul><p></p><p>More interesting than the methods of the <i>ImageProducer</i> interface are the methods of the <i>ImageConsumer</i> interface, which an <i>ImageProducer</i> calls to deliver the image type, size, and pixel data to the consumer object. These methods can be described as follows:</p><ul><li><i>void setDimensions( int width, int height)</i> is called to notify the consumer of the image's size. This notification will be called before the first call to <i>setPixels()</i>.  <li><i>void setColorModel(ColorModel cm)</i> is called with a <i>ColorModel</i> parameter, which will be the color model of most, but not necessarily all, of the pixels delivered to the <i>setPixels()</i> method. This notification is optional. If called, it will be invoked before the first call to <i>setPixels()</i>.  <li><i>void setHints(int hintflags)</i> notifies the consumer of the order in which pixels will arrive, which the filter may use to optimize some operations. For example, the COMPLETESCANLINES flag will be set if each call to <i>setPixels()</i> will deliver entire unbroken scan lines (rows) of pixels, and the TOPDOWNLEFTRIGHT will be set if the pixels will be delivered in top to bottom, left to right order. This notification is optional. If called it will be before the first call to <i>setPixels()</i>.  <li><i>void setProperties(Hashtable props)</i> is used by the consumer to add some programmer-defined information to the image stream. This notification will be called before the first call to <i>setPixels()</i>.  <li><i>void setPixels()</i> passes the image pixels to the consumer by calling this method one or more times. Each call will deliver a rectangle of image pixels to the consumer. The layout of the pixels delivered will correspond to any information sent in an earlier call to <i>setHints()</i>. There are two versions of this method. One which receives 32-bit pixel data and another which receives eight-bit pixel data.  <li><i>void imageComplete(int status)</i> is called with a status parameter to inform the consumer that a complete static image has been delivered, one frame of a multiframe image has been delivered, or an error has occurred. This notification will be called after the last call to <i>setPixels()</i>.</ul><p></p><p>The <i>setPixels()</i> method requires more explanation. The full function prototypes of the two <i>setPixels()</i> functions look like <a name="re2"><a href="9807me2.htm">Example 2</A>. A portion of the image is delivered to an <i>ImageConsumer</i> with each call to <i>setPixels(),</i> which may be as large as the entire image, or as small as one pixel. The portion delivered in each call to <i>setPixels()</i> is a rectangle whose upper-left corner is at <i>x,y</i> and has a width of <i>w</i> and height of <i>h</i>. The data is passed in the array object pixels, which has valid data starting at position <i>offset</i>, and <i>scansize</i> elements between each row. What all this boils down to is that the sample in the pixels buffer which corresponds to the image <i>pixel(m,n)</i> is at array index <i>offset + (n-y)</i>*<i>scansize + (m-x)</i>. The only valid pixel array sample values are those that lie in the rectangle described by <i>w</i>, <i>h</i>, <i>offset</i>, and <i>scansize</i>. The producer will continue to call <i>setPixels()</i> until all of the image pixels have been delivered, or an error occurs.</p><h3><i>ColorModel</i>s</h3><p>The delivered image data may consist of 32- or 8-bit samples. A <i>ColorModel</i> is passed along with the image data in each call to <i>setPixels()</i> so that consumers can retrieve and manipulate the color information in the samples. The data in the pixels buffer is defined in terms of the <i>ColorModel</i> passed with the pixels. The <i>ColorModel</i> passed in the <i>setColorModel</i> call is only a hint to the consumer that the majority of pixels will use that model; you still need to check the <i>ColorModel</i> passed in each call to <i>setPixels()</i>.</p><p>The <i>ColorModel</i> abstract class defines a set of functions that an <i>ImageConsumer </i>uses to map a pixel value to red, green, blue, and alpha values. The functions <i>int getRed(int pixel)</i>, <i>int getGreen(int pixel)</i>, <i>int getBlue( int pixel)</i>, and <i>int getAlpha(int pixel)</i> return the components for the given pixel value. Each color component can take on a value between 0 and 255, inclusive, with 0 being the minimum of a component and 255 being the maximum. The alpha component quantifies the transparency of the pixel and ranges from 0, which lets an underlying image show through completely, to 255, which is opaque.</p><p>All <i>ColorModel</i> objects also define a function, <i>int getRGB(int pixel)</i>, which returns the color of a given pixel value in terms of the default color model, which is known as the <i>RGBDefault</i> color model. An instance of the <i>RGBDefault</i> color model is returned by calling the <i>ColorModel</i> static function, <i>getRGBdefault()</i>. The <i>RGBDefault</i> color model uses 32-bit data samples and allocates eight bits each for red, green, blue, and alpha with a bit layout of 0xAARRGGBB.</p><p>A <i>ColorModel</i> object that allocates a portion of the total bits in a sample to each color component is known as a <i>DirectColorModel</i>. A color model which uses the pixel value as an index into a palette of colors is called an <i>IndexedColorModel</i>. <i>DirectColorModel</i> objects implement functions that allow you to determine which bits of the pixel are allocated to each component. These are <i>int getAlphaMask()</i>, <i>int getRedMask()</i>, <i>int getGreenMask()</i>, and <i>int getBlueMask()</i>. The <i>RGBDefault</i> color model is a <i>DirectColorModel</i>.</p><p>In general, eight-bit samples correspond to palette-based color models and 32-bit samples correspond to direct color models such as 32-bit RGB. However, a <i>ColorModel</i> is a flexible representation that can be used to convert between pixel values and red, green, blue, and alpha components in any way that may be appropriate. For example, a topological map image could be stored as an array of <i>int</i>s with each sample representing the elevation of its location. A color model could then be created, which mapped the elevation to some standard topological map colors. This color model would be an indexed color model, however since the samples are stored as integers and not bytes, it could have many more than 256 entries and thus very fine shading of color to represent changes in geography.</p><h3>Image Processing</h3><p>Image processing with Java is accomplished using image filters, which are objects derived from the <i>ImageFilter</i> base class. The <i>ImageFilter</i> class implements the <i>ImageConsumer</i> interface to receive the pixel samples for the image to be processed. An <i>ImageFilter</i> has a protected member variable, <i>consumer</i>, which refers to the <i>ImageConsumer</i> downstream of the image filter. Essentially, an <i>ImageFilter</i> is an <i>ImageConsumer</i> that manipulates the incoming pixel data and forwards the results to another <i>ImageConsumer</i> object.</p><p>As the image filter processes the samples received in its <i>setPixels()</i> function, the filter sends the processed samples downstream by passing the samples to the <i>setPixels()</i> function of its consumer. The image filter can pass the pixels to its consumer as it receives and processes the samples, or the filter can save the raw or processed pixels in a buffer and send them all at once to the consumer when the filter's <i>imageComplete()</i> method is called. The default implementation in the <i>ImageFilter</i> base class is a null filter. For each call to <i>setPixels()</i>, the base class simply calls the corresponding function in the consumer without modifying the samples. The rest of the methods inherited from the <i>ImageConsumer</i> method are similarly forwarded to the downstream consumer.</p><p>The Java API includes a few built-in filters to handle common tasks. The <i>ReplicateScaleFilter</i> will stretch or shrink an image to a given size by dropping or duplicating samples. The <i>AreaAveragingScale</i> filter resizes an image using a bilinear interpolation algorithm. The <i>CropImageFilter</i> extracts a rectangular subimage from the original image.</p><h3>The <i>FilteredImageSource</i> class</h3><p>Given that you have an instance of an <i>ImageFilter</i> object, how do you apply it to an image? This is where the <i>FilteredImageSource</i> class comes in. An instance of the <i>FilteredImageSource</i> class is an <i>ImageProducer</i> that creates a new image source from a given <i>ImageProducer</i> and an <i>ImageFilter</i>. The resulting image source produces an image which has been processed by the image filter. </p><p><a name="re3"><a href="9807me3.htm">Example 3</A> should make this clear. First, an image is loaded from the local file system using the default toolkit. Then an <i>AreaAveragingScaleFilter</i> is created which will scale images to half the size of the original loaded image. Next, a <i>FilteredImageSource</i> object is created from the scaling filter and the <i>ImageProducer</i> of the original image. Finally, an <i>Image </i>object is created from the new <i>FilteredImageSource</i>. Basically the <i>FilteredImageSource</i> constructor adds an image consumer/source pair in between the original <i>ImageProducer</i> and any future consumers. This process can be repeated any number of times to create an image filter chain or "pipeline;" see <a name="rf2"><a href="9807mf2.htm">Figure 2</A>.</p><p>It is important to realize that the image data is not actually filtered until it is requested by a consumer. Typically this is done implicitly when the image is displayed by calling <i>drawImage()</i>, although any <i>ImageConsumer</i> can start the pipeline flowing by calling <i>startProduction()</i> on the <i>ImageProducer</i> at the end of the pipeline. Notice that downstream <i>FilteredImageSource</i> objects forward delivery requests upstream. Eventually the request arrives at an image source that has image data ready to deliver and this <i>ImageProducer</i> object invokes methods on its registered consumers to push image data through the pipeline.</p><h3>Image Filters</h3><p>There are an infinite variety of filtering operations that can be applied to images in order to enhance or modify them. For the purposes of image processing with Java, filters can be classified according to the information required in order to process each sample. Here, we will classify image filters as point operations, geometric operations, or neighborhood filters.</p><h3>Point Filters</h3><p>The simplest filters process each sample independent of the surrounding samples. These filters can be simple color modifications, or can be dependent upon the pixel's location in the image. In any case, a point operation filter only has knowledge of a single pixel at a time. Contrast enhancement, color inversion, and dither filters, among others, can be written this way. This type of filter is so common that the Java API includes a special base class, <i>RGBImageFilter,</i> which makes implementing point operation filters very easy.</p><p>The <i>RGBImageFilter</i> class implements all the necessary <i>ImageFilter</i> machinery to filter an image pixel by pixel. One abstract function, <i>int filterRGB(int x, int y, int rgb),</i> needs to be implemented. This function is called for each pixel in the image and passed the pixel location as well as the 32-bit default RGB color model sample value. The <i>filterRGB()</i> function in the derived class should return the processed pixel value using the 32-bit default RGB color model.</p><p><a name="rl1"><a href="9807m.htm#l1">Listing One</A> is the implementation of the <i>GreyOutImageFilter</i>, which demonstrates the use of the <i>RGBImageFilter</i> class. This filter simply replaces half of the original image pixels with grey using a checkerboard pattern. This is an effect which you may want to use to make an icon or button appear inactive. Notice how short the implementation is. All the hard work has been done for us in the base class. </p><p><i>GreyOutImageFilter</i> also demonstrates the proper way to handle the <i>canFilterIndexColorModel</i> protected member variable. For indexed color images, <i>RGBImageFilter</i> attempts to be more efficient by filtering only the color table, not the entire image. If the results of the filter are only dependent upon the color of each filter, the derived class should set this member to <i>true</i>. If the results depend upon the pixel location, as they do in the <i>GreyOutImageFilter</i>, then <i>canFilterIndexColorModel</i> must be set to <i>false</i>.</p><h3>Geometric Filters</h3><p>Another kind of filter moves pixels from one location in an image to another. These are known as geometric transformations. This is a very broad category and includes many types of filters including horizontal and vertical flipping, mirroring, and rotations. The Java API does not provide a specialized base class for implementing geometric operations like it does for point operations. We need to derive geometric transform filters from ImageFilter.</p><p><a name="rl2"><a href="9807m.htm#l2">Listing Two</A> implements a filter that rotates an image 90 degrees clockwise. An <i>m</i>&times;<i>n</i> pixel image is transformed into an <i>n</i>&times;<i>m</i> pixel image, with the pixel value occupying the original upper-left now occupying the upper-right corner.</p><p>The code is longer than that of the previous filter because we need to override several functions of the ImageFilter base class. To properly rotate the image, we need to save the width and height passed into <i>setDimensions()</i>, and pass appropriate hints to the base class <i>setHints()</i>. Notice that after processing these values, you invoke the superclass implementation. For all of the functions in the <i>ImageFilter </i>class except <i>setPixels(),</i> you should invoke the superclass implementation to properly initialize the base class, passing either the original parameters or values modified appropriately for your implementation. Calling the superclass also ensures that the information is passed along to downstream consumers.</p><p>Image rotation is accomplished by taking each row of the rectangle of pixels received in <i>setPixels()</i> and passing it to the consumer as a column. We do some coordinate transformation to ensure that the pixels wind up in the correct location. Since the filter typically passes a column of pixels to the consumer, we clear the COMPLETESCANLINES and TOPDOWNLEFTRIGHT flags before we pass the hints along.</p><h3>Neighborhood Filters</h3><p>The most complex kind of filter that we will deal with here is the neighborhood filter. Each output pixel is a function of several nearby input pixels. Image sharpeners, smoothers, high-pass filters, and general convolution all fit into this category. Usually the pixel neighborhood is a small window of pixels centered on the pixel being processed. Common window sizes are 3&times;3 and 5&times;5. There are also "separable" image filters which process an image, a row, and then a column at a time. In this case, the neighborhood is composed of nearby pixels in the same row or column as the target pixel.</p><p>The implementor of a neighborhood filter must decide how to handle the image boundaries where there is not a full window of pixels to process. Common strategies are to leave the boundary pixels unprocessed, or to fill in the missing window samples by reflecting the image over the edge. The primary reason why implementing neighborhood filters with the <i>ImageFilter</i> class becomes complicated is that each call to <i>setPixels()</i> may pass only a small subrectangle of the image. The pixels at the edges of the subrectangles will not be delivered along with the neighborhood pixels required to process them. The easiest strategy to work around this problem is simply to save the image pixels in a private buffer as they are delivered to <i>setPixels</i> and process the image all at once when <i>imageComplete()</i> is called. The fully processed image can then be delivered with a single call to the consumer's <i>setPixels()</i> method. </p><p>The <i>SharpenImageFilter</i> (available electronically; see "Resource Center," page 3) uses this method to implement a 3&times;3 sharpening filter. Notice that the image to be processed is separated into color components and stored in four arrays named red, green, blue, and alpha. This allows the filter to sharpen both direct and indexed color model images.</p><h3>Chaining Filters Together</h3><p>Applying an <i>ImageFilter </i>to a given <i>Image </i>with the <i>FilteredImageSource </i>creates an image pipeline. If another filter is then applied to the resulting image, the new <i>FilteredImageSource</i> is added to the front of the pipeline. Each time the image is processed it is pushed all the way through the pipeline. If an image is filtered, and then displayed, applying another filter to the image results in repeating processing that has already been done as the original image source is sent all the way from the beginning of the pipe, through the previous filters and finally through the newest filter. Therefore when applying <i>n </i>filters in sequence to an image and displaying each intermediate result, the image is actually processed <i>n(n + 1)/2</i> times.</p><p>The Java image processing API is flexible and written this way to handle changing source images. For example, if the original image source were video and not a still image, sending each frame though the entire pipeline would be the proper thing to do. However, it can be very inefficient when applying a series of filters to a still image in an interactive application.</p><p>To overcome this unnecessary overhead, the <i>BufferingFilteredImageSource</i> class (available electronically) can be used just like the <i>FilteredImageSource</i>. For still images, it buffers the result of applying its <i>ImageFilter </i>to the original image. When a downstream filter requests image data the <i>BufferingFilteredImageSource </i>delivers the samples from its internal buffer instead of forwarding the request upstream. For animated GIFs and other image sequences, it functions identically to the <i>FilteredImageSource</i>. Using this class makes applying a sequence of filters, one at a time, much more efficient since each filter is applied to an image only once.</p><p>To keep the implementation as simple as possible, the <i>BufferingFilteredImageSource</i> internally uses the <i>FilteredImageSource</i> class to actually perform the image filtering. An instance of <i>MemoryImageSource</i> is created and stored in the source member and functions as the <i>ImageProducer</i> for the buffered, filtered image. If the image is animated, then no buffering is done and the <i>FilteredImageSource</i> instance is used as the source instead. <i>BufferingFilteredImageSource</i> implements the <i>ImageProducer</i> interface simply by forwarding the calls to the source member object.</p><p>The only complexity in the implementation is the <i>BfisInternalConsumer</i> class that the <i>BufferingFilteredImageSource</i> uses to save the processed image in a buffer. The buffer is then used to create the <i>MemoryImageSource</i>. Since the <i>FilteredImageSource</i> object may deliver the filtered image synchronously or asynchronously, we need to allow for both cases. This is done by synchronizing the <i>BufferingFilteredImageSource</i> constructor with the <i>imageComplete()</i> function of the <i>BfisInternalConsumer</i> using the object and the <i>done </i>flag.</p><h3>The JIPTestApplet</h3><p>To demonstrate the filters and classes presented in this article, use the test applet, JIPTestApplet (also available electronically), along with JIPTestApplet.html, which is an HTML page used to demonstrate the applet. The applet can be configured to display and process up to ten images. The filters given in this article can be applied repeatedly using either the <i>FilteredImageSource</i> or <i>BufferingFilteredImageSource</i>. Applying several filters in succession to a still image will demonstrate the efficiency gained by using the <i>BufferingFilteredImageSource</i>. Using the <i>FilteredImageSource</i>, successive filter applications take longer and longer. Using the <i>BufferingFilteredImageSource</i>, each invocation takes the same amount of time. You can also use the test applet to explore the results of applying several filters to an image, for example, the <i>GreyOutFilter</i> followed by the <i>SharpenImageFilter</i>. </p><h3>Conclusion</h3><p>The Java image-processing model is powerful, flexible, and expandable, and can be used to create complex image-processing applications. Image processing is a computationally intensive activity. With a JIT compiler, Java performance is more than adequate for basic processing of moderate sized images. For interpreted Java virtual machines or complex multipass computations, the processing should be kept to small images.  </p><p><b>DDJ</b></p><H4><a name="l1">Listing One</H4><pre>import java.awt.Color;import java.awt.image.*;<p></p>public class GreyOutImageFilter extends RGBImageFilter {    // save the int value of the grey color...    protected int greyOutValue = Color.gray.getRGB();    public GreyOutImageFilter() {        // this filter is position dependent, so we can't filter        // by just changing the color table...        canFilterIndexColorModel = false;    }            public int filterRGB( int x, int y, int rgb) {        // set every other pixel to grey using a checkerboard pattern...        if (((x ^ y) &amp; 1) == 0) {            return greyOutValue;        }        else {            return rgb;        }    }        }    <p></p></pre><P><a href="#rl1">Back to Article</A></P><H4><a name="l2">Listing Two</H4><pre>import java.awt.image.*;<p></p>public class RotateClockwiseImageFilter extends ImageFilter {    protected int srcwidth, srcheight;    protected int destwidth, destheight;    public void setDimensions( int width, int height) {        // source height becomes destination width and vice-versa...        this.destwidth = height;        this.destheight = width;                // tell the consumer the size of the image that we will be sending...        super.setDimensions( this.destwidth, this.destheight);    }    public void setHints( int hints) {        // because this filter delivers pixels a scan column at a time,         // we need to clear COMPLETESCANLINES and TOPDOWNLEFTRIGHT hint         // bits and set the RANDOMPIXELORDER bit...        hints = (hints &amp; (~COMPLETESCANLINES) &amp;                                 (~TOPDOWNLEFTRIGHT)) | RANDOMPIXELORDER;         super.setHints(hints);    }            public void setPixels( int x, int y, int w, int h, ColorModel cm,                                int[] pixels, int offset, int scansize) {        // start is the offset into buffer of first pixel of current source         // row, which will become the top pixel in destination column...        int start = offset;                // destx is zero-indexed destination column of source pixel row...         int destx = destwidth - y - 1;                // send the pixels on to the consumer, each row of the source image        // becomes a 1-pixel wide column of pixels in destination image...        for (int j = 0; j &lt; h; j++) {            consumer.setPixels( destx, x, 1, w, cm, pixels, start, 1);            start += scansize;            destx--;        }                }            public void setPixels( int x, int y, int w, int h, ColorModel cm,                               byte[] pixels, int offset, int scansize) {        // start is the offset into the buffer of the first pixel of current        // source row, which will become top pixel in destination column...        int start = offset;                // destx is zero-indexed destination column of source pixel row...         int destx = destwidth - y - 1;                // send the pixels on to the consumer, each row of the source image        // becomes a 1-pixel wide column of pixels in destination image...        for (int j = 0; j &lt; h; j++) {            consumer.setPixels( destx, x, 1, w, cm, pixels, start, 1);            start += scansize;            destx--;        }                }        }</pre><P><a href="#rl2">Back to Article</A></P><HR><I>Copyright &copy; 1998, Dr. Dobb's Journal</I><BR>
</body></html>