<html><head><title>Dr. Dobb's Journal July 1998: Composing Reactive Animations</title></head><body bgcolor="FFFFFF"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Composing Reactive Animations</h1><p><i>Dr. Dobb's Journal</i> July 1998</p><h2>Programming for greater freedom of expression</h2><h3>By Conal Elliott</h3><I>Conal is a member of the Microsoft Research Graphics Group. He can be contacted at conal@microsoft.com.</I><hr>Sidebar: <i><a name="rs1"><a href="9807as1.htm">Models versus Presentations</a></i><hr><p>There's no question that computer graphics -- especially interactive graphics -- is an incredibly expressive medium with potential beyond imagination. However, few people are able to create interactive graphics, so what might be a widely shared medium of communication is instead a tool for specialists. The problem is that authors still have to worry about how to get a computer to present content, rather than focus on the nature of the content itself. For instance, behaviors such as motion and growth are generally gradual, continuous phenomena; moreover, many such behaviors go on simultaneously. Computers cannot directly accommodate either of these basic properties, because they do their work in discrete steps rather than continuously, and they only do one thing at a time. Graphics programmers consequently have to bridge the gap between <i>what</i> an animation is and <i>how</i> to present it on a computer.</p><p>If the kind of programming in use today (like that described in the accompanying text box "Models versus Presentations" on page 25) is unsuitable for most potential authors, then we need to move toward a different form of programming. Alternative forms must give authors freedom of expression to say what an animation is, while invisibly handling details of discrete, sequential presentation. In other words, these forms must be declarative ("what to be"), rather than imperative ("how to do").</p><p>In this article, I present one such approach to declarative programming of interactive content. Fran (short for "functional reactive animation") is a high-level vocabulary that lets you describe the essential nature of an animated model, while omitting details of presentation. And because this vocabulary is embedded in a modern functional programming language (Haskell), the animation models are reusable and composable in powerful ways. </p><p>Fran is freely available (with source code) as part of the Hugs implementation of Haskell for Windows 95/NT (http://www .haskell.org/hugs/). Newer versions of Fran may be found at http://www.research.microsoft.com/~conal/Fran/. The underlying ideas form the basis of Microsoft's DirectAnimation, a COM-based programming interface accessible through conventional languages like Java, Visual Basic, JavaScript, VBScript, and C++. DirectAnimation is built into Internet Explorer 4.0, so you may already have it. </p><p>There are three ways you can experience this article:</p><ul>  <li>In this printed version, examples have an accompanying sequence of snapshots. By scanning them from left to right, top to bottom (first row, second row, and so on), you'll get a sense of motion.  <li>On the Web (http://www.research.microsoft.com/~conal/Fran/ tutorial.htm), examples are illustrated by animated GIFs, showing animation over time, but not interactivity. That version of this article also contains additional discussion and several animations not in the printed version.  <li>Finally, you can run the examples and interact with or modify them. After installing Hugs (available at http://www .haskell.org/hugs/), double-click on the file tutorial.hs in the subdirectory lib\Fran\demos. At the &gt; prompt, type "main" and press Enter. The examples will begin running. Press Spacebar, "n," or right arrow to advance to the next animation, and "p" or left arrow for the previous one. If you want to display just a single animation (<i>leftRightCharlotte</i>, for instance), then close the animation window and enter "display leftRightCharlotte". You can alter the definition in an editor, save the result, enter ":r" to the Hugs prompt, and "$$" again to display the new version. For 2D examples having a user argument <i>u</i>, use <i>displayU</i> instead of <i>display</i>. Similarly, for 3D examples, use <i>displayG</i> if there is no user argument, and <i>displayGU</i> if there is a user argument.</ul><h3>The First Example</h3><p>I'll start with the animation in <a name="rf1"><a href="9807af1.htm">Figure 1</A> called <i>leftRightCharlotte, </i>which moves Charlotte from side to side. <a href="9807a.htm#l1">Listing One</A> efines a value called <i>leftRightCharlotte</i> to be the result of applying <i>moveXY</i> to three arguments. (In most other programming languages, you would instead say something like "moveXY(wiggle,0,charlotte)".)</p><table border="1" cellpadding="3" align="center"><tr>	<td><a name="l1"><h4>Listing One</h4><pre>leftRightCharlotte = moveXY wiggle 0 charlottecharlotte = importBitmap "../Media/charlotte.bmp"  </pre></td></tr></table><p>The function <i>moveXY</i> takes <i>x</i> and <i>y</i> values and an image, and produces an image moved horizontally by <i>x</i> and vertically by <i>y</i>. All values may be animated. In this example, the <i>x</i> value is given by <i>wiggle</i>, a predefined smoothly animated number. <i>Wiggle</i> starts out at 0, increases to 1, decreases back past 0 to -1, and then increases to 0 again -- all in the course of two seconds, and then it repeats, forever. The second line defines <i>charlotte</i> by importing a bitmap file, making it available for use on the first line as the second argument to <i>moveXY</i>.</p><p>Although this example isn't a masterpiece, it is nonetheless a complete animation program in just two short lines of code.</p><p>Similarly, <a name="rf2"><a href="9807af2.htm">Figure 2</A> and <a href="9807a.htm#l2">Listing Two</A> define an animation of Patrick moving up and down. To get the vertical movement, I've used a nonzero value for the second argument to <i>moveXY</i>. Rather than using <i>wiggle</i>, you use <i>waggle</i>, which is defined to be just like <i>wiggle</i>, but delayed by half a second.</p><table border="1" cellpadding="3" align="center"><tr>	<td><a name="l2"><h4>Listing Two</h4><pre>upDownPat = moveXY 0 waggle patpat = importBitmap "../Media/pat.bmp"  </pre><a name="l3"><h4>Listing Three</h4><pre>charlottePatDance =   leftRightCharlotte `over` upDownPat  </pre></td></tr></table><p><a name="rf3"><a href="9807af3.htm">Figure 3</A> and <a href="9807a.htm#l3">Listing Three</A> combine the two previous examples. The <i>over</i> operation glues two animations together, yielding a single animation, with the first one being over the second. Because I used <i>waggle</i> for <i>upDownPat</i> in this combined animation, Pat is at the center when Charlotte is at her extremes (and vice versa).</p><h3>Composition</h3><p>Composition is the principle of putting together simple things to make complex ones, then putting these together to make even more complex things, and so on. This building-block principle is crucial for making even moderately complicated constructions; without it, the complexity quickly becomes unmanageable.</p><p><a href="9807a.htm#l1">Listings One</A> through Three illustrate composition. I first built <i>leftRightCharlotte</i> out of <i>charlotte</i>, <i>wiggle</i>, and <i>moveXY</i>; then <i>upDownPat</i> out of <i>pat</i>, <i>moveXY</i>, and <i>waggle</i>. Finally, I built <i>charlottePatDance</i> out of <i>leftRightCharlotte</i> and <i>upDownPat</i>. A crucial point here is that when you make something out of building blocks, the result is a new building block in itself, and you can forget about how it was constructed.</p><p>There is a more powerful version of composition, based on defining functions. <a href="9807a.htm#l4">Listing Four</A>, for instance, defines <i>hvDance</i> (for "horizontally and vertical dance"), which combines any two images, in the way that <i>charlottePatDance</i> combines <i>charlotte</i> and <i>pat</i>. Now you can give a new definition for the dancing couple that gives exactly the same animation: <i>charlottePatDance = hvDance charlotte pat</i>.</p><table border="1" cellpadding="3" align="center"><tr>	<td><a name="l4"><h4>Listing Four</h4><pre>hvDance im1 im2 =    moveXY wiggle 0 im1  `over`     moveXY 0 waggle im2</pre></td></tr></table><p>Having defined this generalized dance animation, you can go on to more exotic compositions. For example, you can take an animation produced by <i>hvDance</i>, shrink it, and put the result back into <i>hvDance</i> twice to make it dance with itself. As <a name="rf4"><a href="9807af4.htm">Figure 4</A> and <a href="9807a.htm#l5">Listing Five</A> show, the result is pleasantly surprising. This example gives you a hint of how powerful it is to be able to define new animation functions. For instance, you could try <i>charlottePatDance</i>, stretched by a wiggly amount; see <a href="9807a.htm#l6">Listing Six</A>(a). To prevent negative scaling, you take the absolute value of <i>wiggle</i>. Next, use <i>hvDance</i> again, but give it wiggly sized <i>charlotte</i> and <i>pat</i>. For visual balance, use <i>wiggle</i> and <i>waggle</i>; see <a href="9807a.htm#l6">Listing Six</A>(b). Next, put Pat in orbit around a growing and shrinking Charlotte. To get a circular motion, use <i>moveXY</i>, with <i>wiggle</i> for <i>x</i> and <i>waggle</i> for <i>y</i>; see <a href="9807a.htm#l6">Listing Six</A>(c).</p><table border="1" cellpadding="3" align="center"><tr>	<td><a name="l5"><h4>Listing Five</h4><pre>charlottePatDoubleDance = hvDance aSmall aSmall   where    aSmall = stretch 0.5 charlottePatDance  </pre><a name="l6"><h4>Listing Six</h4><pre><b>(a)</b>dance1 = stretch (abs wiggle) charlottePatDance <b>(b)</b>dance2 = hvDance (stretch wiggle charlotte)                   (stretch waggle pat)<b>(c)</b>patOrbitsCharlotte =   stretch wiggle charlotte  `over`    moveXY wiggle waggle pat</pre></td></tr></table><p>As you may have surmised, <i>wiggle</i> and <i>waggle</i> are related to <i>sine</i> and <i>cosine</i> and defined as:</p><blockquote><p>waggle = cos (pi * time) </p><p>wiggle = sin (pi * time)</p></blockquote><p>The animated number <i>time</i> is a commonly used "seed" for animations and has the value <i>t</i> at time <i>t</i>. Thus, for instance, the value of <i>wiggle</i> at time <i>t</i> is equal to <i>sin(<img src="pi12.gif">t)</i>.</p><h3>Rate-Based Animation</h3><p>Up to now, the positions of animations have been specified directly. For instance, the definition of <i>leftRightCharlotte</i> says that Charlotte's horizontal position is <i>wiggle</i>.</p><p>In the physical universe, objects move as a consequence of forces. As Newton explained, force leads to acceleration, acceleration to velocity, and velocity to position. With computer animation, you have the freedom to ignore the laws of our universe. However, since animations are usually intended to be viewed by and interacted with by inhabitants of our own universe, they are often made to look and feel real by emulating Newtonian laws or simplifications and variations on them.</p><p>The key idea underlying Newton's laws and their variations is the notion of an instantaneous rate of change. Fran makes this notion available in animation programs. To illustrate rate-based animation, you can make Becky move from the left edge of the viewing window, toward the right, at a rate of one distance unit per second; see <a name="rf5"><a href="9807af5.htm">Figure 5</A> and <a href="9807a.htm#l7">Listing Seven</A>.</p><table border="1" cellpadding="3" align="center"><tr>	<td><a name="l7"><h4>Listing Seven</h4><pre>velBecky u = moveXY x 0 becky   where    x = -1 + atRate 1 u</pre></td></tr></table><p>The local definition of <i>x</i> here (introduced as a <i>where</i> clause), follows a style you'll see in the following definitions. To express an animated value that starts out with a value <i>x0</i> and grows at a rate of <i>r</i>, you say <i>x0 + atRate r u. </i>Here <i>u </i>is a "user", which is a Fran value that contains all user input and display update events. Rate-based animations require a user argument in order to give <i>atRate </i>a way of knowing when to start and how precisely to calculate value from rate. Unlike previous examples, this one can be displayed with <i>displayU</i>. To see this example, enter <i>displayU velBecky</i>. </p><p>In <a href="9807a.htm#l7">Listing Seven</A>, Becky has a constant velocity, but with a little more effort you can give Becky a constant acceleration by providing a constant value for the rate of change of the velocity; see <a href="9807a.htm#l8">Listing Eight</A>. In the definition of <i>v</i>, the "0 +" is unnecessary, but emphasizes that the initial velocity is zero. </p><table border="1" cellpadding="3" align="center"><tr>	<td><a name="l8"><h4>Listing Eight</h4><pre>accelBecky u = moveXY x 0 becky    where     x = -1 + atRate v u     v =  0 + atRate 1 u</pre><a name="l9"><h4>Listing Nine</h4><pre>mouseVelBecky u = move offset becky   where    offset = atRate vel u    vel    = mouseMotion u</pre></td></tr></table><p>The notion of "rate" is useful not just in one dimension, but in two and three dimensions as well. In <a href="9807a.htm#l9">Listing Nine</A>, I control Becky's 2D velocity with the mouse. When you hold the mouse cursor at the center of the view window, Becky stays still. As you move away from the center, imagine an arrow from the window's center to the mouse cursor. Becky moves in that direction and her speed will be equal to the arrow's length. This kind of imaginary arrow is referred to as a "vector" and is the same type of quantity as a two- or three-dimensional offset, velocity, or acceleration. In 2D, a vector can be thought of as having horizontal and vertical (X and Y) components, or as having a magnitude (length) and direction. This time, I use <i>move</i>, a variant of <i>moveXY</i> that takes a 2D offset vector. (If a vector <i>v</i> is <i>x</i> units horizontally and <i>y</i> units vertically, then "move v im" is equivalent to "moveXY x y im.") The offset vector starts out as the zero vector, and grows at a rate equal to <i>mouseMotion</i>, which is the offset of the mouse cursor relative to the origin of 2D space (which you see in the center of the view window).</p><p>In the real world, the position of an object may affect its speed or acceleration. In <a href="9807a.htm#l10">Listing Ten</A>, Becky is chasing the mouse cursor. The further away it is, the faster she moves. The only difference from <a href="9807a.htm#l9">Listing Nine</A> is that the velocity is determined by where the mouse cursor is relative to Becky's own position, as indicated by the vector subtraction.</p><p>For fun, you can generalize the <i>beckyChaseMouse</i> function in the same way that <i>hvDance</i> generalized <i>charlottePatDance</i> earlier; see <a href="9807a.htm#l11">Listing Eleven</A>. Then <i>chaseMouse becky</i> is equivalent to <i>beckyChaseMouse</i>, as you can verify by typing <i>displayU (chaseMouse becky)</i> at the Hugs prompt. </p><table border="1" cellpadding="3" align="center"><tr>	<td><a name="l10"><h4>Listing Ten</h4><pre>beckyChaseMouse u = move offset becky    where    offset = atRate vel u    vel    = mouseMotion u - offset</pre><a name="l11"><h4>Listing Eleven</h4><pre>chaseMouse im u = move offset im   where    offset = atRate vel u    vel    = mouseMotion u - offset </pre></td></tr></table><p>For more fun, try the same, but replace  <i>becky</i> with some of the animations that appeared earlier (<i>leftRightCharlotte</i>, <i>charlottePatDance</i>, and <i>patOrbitsCharlotte</i>); see <a name="rf6"><a href="9807af6.htm">Figure 6</A> and <a href="9807a.htm#l12">Listing Twelve</A>. </p><p>Next make a chasing animation that acts like it is attached to the mouse cursor by a spring. The definition is similar to <i>beckyChaseMouse</i>. In <a href="9807a.htm#l13">Listing Thirteen</A>, however, the rate is itself changing at rate <i>accel</i> (acceleration). This acceleration is defined like the velocity was in the previous example, but this time, some drag is also added. This tends to slow down Becky by adding some acceleration in the direction opposite to her movement. (Increasing or decreasing the "drag factor" of 0.5 in <a href="9807a.htm#l13">Listing Thirteen</A> creates more or less drag.) The operator *^ multiplies a number by a vector, yielding a new vector that has the same direction as the given one but a scaled magnitude.</p><table border="1" cellpadding="3" align="center"><tr>	<td><a name="l12"><h4>Listing Twelve</h4><pre>danceChase u =   chaseMouse (stretch 0.5 charlottePatDance) u </pre><a name="l13"><h4>Listing Thirteen</h4><pre>springDragBecky u = move offset becky   where    offset = atRate vel u    vel    = atRate accel u    accel  = (mouseMotion u - offset) - 0.5 *^ vel </pre></td></tr></table><p>As usual, these declarative animation programs are straightforward because they say what the motion is, in high-level, continuous terms, without struggling to accommodate the discreteness of the computer used to present them. In contrast, imperative animation programs must explicitly simulate rate-based animation by making lots of discrete steps -- accumulating approximations to the continuously varying forces, accelerations, and velocities -- to approximate motion. Doing an accurate and efficient job of all this approximation work is a tricky task. With systems like Fran, you just describe the continuous motion in terms of continuously varying rates, and trust Fran to do a good job with the approximation. (Not good enough to fly an airplane or control dangerous machinery, but good enough for an effective illustration or game.)</p><h3>Composition-in-Time</h3><p>Operations such as <i>over</i> and <i>move</i> support the principle of composition-in-space. Composition-in-time is equally valuable. <a name="rf7"><a href="9807af7.htm">Figure 7</A> and <a href="9807a.htm#l14">Listing Fourteen</A>, for instance, define an orbiting animation, and then combine it with a version of itself delayed by one second. Instead of delaying, you can speed it up; see <a href="9807a.htm#l15">Listing Fifteen</A>. You can even delay or slow down animations involving user input. In <a href="9807a.htm#l6">Listing Sixteen</A>, one Jake tracks the mouse cursor, while the other follows the same path, but delayed by one second.</p><table border="1" cellpadding="3" align="center"><tr>	<td><a name="l14"><h4>Listing Fourteen</h4><pre>orbitAndLater = orbit `over` later 1 orbit    where    orbit = moveXY wiggle waggle jake</pre><a name="l15"><h4>Listing Fifteen</h4><pre>orbitAndFaster = orbit `over` faster 2 orbit     where    orbit = move wiggle waggle jake</pre><a name="l16"><h4>Listing Sixteen</h4><pre>followMouseAndDelay u =  follow `over` later 1 follow   where    follow = move (mouseMotion u) jake </pre></td></tr></table><p>Next you can build an animated sentence, following the mouse's motion path. As a preliminary step, use <i>delayAnims dt anims = overs (zipWith later [0, dt ..] anims)</i> to define a <i>delayAnims</i> function, which takes a time delay <i>dt</i> and a list <i>anims</i> of animations, and yields an animation. Each successive member of the given animation list is delayed by the given amount after the previous member. The definition of <i>delayAnims</i> introduces a few new Fran elements. The Fran <i>overs</i> function is like <i>over</i>, but applies to a list of animations rather than just two. Animations earlier in the list are placed over ones later in the list. The notation <i>[0, dt ...]</i> means the infinite list of numbers 0, <i>dt</i>, 2 <i>dt</i>, 3 <i>dt</i>, and so on. Finally, <i>zipWith</i> applies to a given two-argument function the successive values from two given lists. You use it here to delay the first animation in <i>anims</i> by 0 seconds, the second by <i>dt</i> seconds, the third by 2<i>dt</i> seconds, and so on. Finally, <i>overs</i> combines them into a single animation. <a name="rf8"><a href="9807af8.htm">Figure 8</A> and <a href="9807a.htm#l17">Listing Seventeen</A> present a simple use of <i>delayAnims</i>. Next, use <i>delayAnims</i> (<a href="9807a.htm#l18">Listing Eighteen</A>) to define <i>mouseTrailWords</i> that makes animated sentences.</p><table border="1" cellpadding="3" align="center"><tr>	<td><a name="l17"><h4>Listing Seventeen</h4><pre>kids u =   delayAnims 0.5     (map (move (mouseMotion u))          [jake, becky, charlotte, pat]) </pre><a name="l18"><h4>Listing Eighteen</h4><pre>trailWords motion str =  delayAnims 1 (map moveWord (words str))  where     moveWord word = move motion (                      stretch 2 (                        withColor blue (stringIm word) )) </pre></td></tr></table><p>The Haskell <i>words</i> function takes a string apart into a list of separate words. The Haskell <i>map</i> function takes a function (<i>moveWord</i>) and a list of values (the separated words) and makes a new list by applying the function to each member of the list. The Fran <i>stringIm</i> function makes a picture of a string. I define the function <i>moveWord</i> locally to be the result of making a picture of the given word, using the Fran <i>stringIm</i> function, and moving it to follow the mouse. <i>delayAnims</i> then causes each of these mouse-following word pictures to be delayed by different amounts. <a name="rf9"><a href="9807af9.htm">Figure 9</A> and <a href="9807a.htm#l19">Listing Nineteen</A> is a use of <i>trailWords</i> following a specified path, while <a href="9807a.htm#l20">Listing Twenty</A> follows the mouse.</p><table border="1" cellpadding="3" align="center"><tr>	<td><a name="l19"><h4>Listing Nineteen</h4><pre>flows u = trailWords motion              "Time flows like a river"   where     motion = 0.7 *^ vector2XY (cos time)                               (sin (2 * time)) </pre><a name="l20"><h4>Listing Twenty</h4><pre>flows2 u = trailWords (mouseMotion u)              "Time flows like a river" </pre></td></tr></table><h3>Reactive Animation</h3><p>The animations presented to this point can be called "nonreactive" since they always do the same thing. A "reactive" animation, on the other hand, involves discrete changes due to events. To illustrate, you can make a circle that starts off red and changes to blue when the left mouse button is pressed.</p><table border="1" cellpadding="3" align="center"><tr>	<td><a name="l21"><h4>Listing Twenty-One</h4><pre>redBlue u = buttonMonitor u `over`             withColor c circle   where    c = red `untilB` lbp u -=&gt; blue </pre></td></tr></table><p>An informal reading of the last line of <a href="9807a.htm#l21">Listing Twenty-One</A> (also see <a name="rf10"><a href="9807af10.htm">Figure 10</A>) is that the color <i>c</i> is red until you press the left mouse button, then becomes blue. For a more literal reading, you must understand that there are really two new binary infix operators here -- <i>untilB</i> and -<i>=&gt;</i> -- which can be used separately or together. Implied parentheses are around <i>lbp u -=&gt; blue</i>. The <i>-=&gt;</i> operator, which can be read as "handled by value," takes an event (<i>lbp u</i>) and a value (<i>blue</i>), and yields a new event. In this case, the new event happens when the left button is pressed, and has value <i>blue</i>. The <i>untilB</i> operator takes an animation of any type (the color-valued constant animation <i>red</i>), and an event (<i>lbp u -=&gt; blue</i>), whose occurrence provides a new animation of the same type.</p><h3>Cyclic Reactivity</h3><p>To make <a href="9807af10.htm">Figure 10</A> more interesting, you can switch between red and blue every time the left button is pressed. As <a href="9807a.htm#l22">Listing Twenty-Two</A> shows, you do this with the help of a <i>cycle</i> function that takes two colors (<i>c1</i> and <i>c2</i>) and gives an animated color that starts out as <i>c1</i>. When the button is pressed, it swaps <i>c1</i> and <i>c2</i> and repeats (using recursion).</p><table border="1" cellpadding="3" align="center"><tr>	<td><a name="l22"><h4>Listing Twenty-Two</h4><pre>redBlueCycle u = buttonMonitor u `over`                  withColor (cycle red blue u)                            circle   where    cycle c1 c2 u =     c1 `untilB` nextUser_ lbp u ==> cycle c2 c1 </pre></td></tr></table><p><a href="9807a.htm#l22">Listing Twenty-Two</A> uses the operator ==&gt;, which is a variant of -=&gt;. This operator (which can be read as "handled with function") takes an event and function <i>f</i>. It works like -=&gt;, but gets event values by applying <i>f</i> to event values from the event given to it. In this case, <i>f</i> is the <i>cycle</i> function applied to just two arguments, leaving the third (a user) to be filled in automatically (using ==&gt;). The <i>nextUser_</i> function turns <i>lbp</i> into an event whose occurrence information is a new user, corresponding to the remainder of the user <i>u</i>. The color arguments get swapped each time "around the loop."</p><p>For variety, <a href="9807a.htm#l23">Listing Twenty-Three</A> uses three colors, and changes the circle's size smoothly. </p><table border="1" cellpadding="3" align="center"><tr>	<td><a name="l23"><h4>Listing Twenty-Three</h4><pre>tricycle u =    buttonMonitor u `over`    withColor (cycle3 green yellow red u) (       stretch (wiggleRange 0.5 1)        circle )   where    cycle3 c1 c2 c3 u =     c1 `untilB` nextUser_ lbp u ==>      cycle3 c2 c3 c1</pre></td></tr></table><h3>Selection</h3><p><a name="rf11"><a href="9807af11.htm">Figure 11</A> and <a href="9807a.htm#l24">Listing Twenty-Four</A> present a flower that starts out in the center and moves to the left or right when the left or right mouse button is pressed, returning to the center when the button is released. </p><p>The function <i>bSign</i> is defined to be -1 when the left button is down, +1 when the right button is down, and 0 otherwise (thanks to <i>selectLeftRight</i>). You can use <i>bSign</i> to control the rate of growth of an image. In <a name="rf12"><a href="9807af12.htm">Figure 12</A> and <a href="9807a.htm#l25">Listing Twenty-Five</A>, pressing the left (or right) button causes the image to shrink (or grow) until released. Put another way, the rate of growth is 0, -1, or 1, according to <i>bSign</i>. A simple change to the <i>grow</i> function (<a href="9807a.htm#l26">Listing Twenty-Six</A>) causes the image to grow or shrink at a rate equal to its own size. <i>selectLeftRight</i>, used to define <i>bSign</i>, is also the key ingredient in defining <i>buttonMonitor</i> (<a href="9807a.htm#l27">Listing Twenty-Seven</A>), which gives button feedback.</p><table border="1" cellpadding="3" align="center"><tr>	<td><a name="l24"><h4>Listing Twenty-Four</h4><pre>jumpFlower u = buttonMonitor u `over`                moveXY (bSign u) 0 flowerflower = stretch 0.4            (importBitmap "../Media/rose medium.bmp") bSign u = selectLeftRight 0 (-1) 1 u</pre><a name="l25"><h4>Listing Twenty-Five</h4><pre>growFlower u = buttonMonitor u `over`                stretch (grow u) flower  grow u = size  where    size = 1 + atRate rate u    rate = bSign u</pre><a name="l26"><h4>Listing Twenty-Six</h4><pre>growFlowerExp u = buttonMonitor u `over`                   stretch (grow' u) flower grow' u = size  where    size = 1 + atRate rate u    rate = bSign u * size </pre><a name="l27"><h4>Listing Twenty-Seven</h4><pre>buttonMonitor u =   moveXY 0 (- height / 2 + 0.25) (    withColor textColor (     stretch 2 (     stringBIm (selectLeftRight "(press a button)" "left" "right" u))))   where    (width,height) = vector2XYCoords (viewSize u)</pre></td></tr></table><p><i>stringBIm</i> turns an animated string into an image animation, which here gets enlarged, colored white, and moved down by a little less than half the window height.</p><p><i>selectLeftRight</i> can itself be defined in terms of more basic functions, as in <a href="9807a.htm#l28">Listing Twenty-Eight</A>. You use the conditional function <i>condB</i> to say that if the left button is down, use the left value, or if the right button is down, use the <i>none</i> value; otherwise use the <i>none</i> (<i>constantB</i>, which turns constants -- nonanimations -- into animations that never change).</p><table border="1" cellpadding="3" align="center"><tr>	<td><a name="l28"><h4>Listing Twenty-Eight</h4><pre>selectLeftRight none left right u =    condB (leftButton u) (constantB left) (      condB (rightButton u) (constantB right) (        constantB none ))</pre></td></tr></table><h3>3D Animation</h3><p>Declarative animation applies to 3D as well, and the 2D operations I've used to this point -- <i>importBMP</i>, <i>moveXY</i>, and <i>stretch</i> -- have 3D counterparts. As a first 3D example, <i>sphere = importX "../Media/sphere2.x" </i>defines a sphere in which the function <i>importX</i> brings in a 3D model in "X-file" format, as used by Microsoft's DirectX. It is just as easy to import a teapot; see <a name="rf13"><a href="9807af13.htm">Figure 13</A> and <a href="9807a.htm#l29">Listing Twenty-Nine</A>. I used <i>stretch3</i> (a 3D counterpart to <i>stretch</i>) because the imported model was too small. <a href="9807a.htm#l30">Listing Thirty</A> colors the teapot and makes it spin around the z- (vertical) axis. </p><p>Next, you can use the mouse to control the teapot's orientation. To do this, define <i>mouseTurn</i> to turn a given geometry <i>g</i> around the x-axis according the mouse's vertical movement, and around the z-axis according the mouse's horizontal movement, scaled by <img src="pi12.gif">. Finally, as <a name="rf14"><a href="9807af14.htm">Figure 14</A> and <a href="9807a.htm#l31">Listing Thirty-One</A> show, you apply <i>mouseTurn</i> to a green teapot. </p><table border="1" cellpadding="3" align="center"><tr>	<td><a name="l29"><h4>Listing Twenty-Nine</h4><pre>teapot =   stretch3 2 (importX "../Media/tpot2.x") </pre><a name="l30"><h4>Listing Thirty</h4><pre>redSpinningPot =  turn3 zVector3 time (    withColorG red teapot) </pre><a name="l31"><h4>Listing Thirty-One</h4><pre>mouseTurn g u =   turn3 xVector3 y (    turn3 zVector3 (-x) g)  where    (x,y) = vector2XYCoords (pi *^ mouseMotion u) mouseSpinningPot u =   mouseTurn (withColorG green teapot) u </pre></td></tr></table><p>You can also make teapots spin by controlling the rotation angle with the <i>grow</i> function, as in the growing flower examples. First, define <i>spinPot</i>, see <a href="9807a.htm#l32">Listing Thirty-Two</A>, that takes (animated) color and angle and yields a colored, turning teapot. Then make a pot that spins one way when the left button is pressed, and the other way when the right button is pressed, using the <i>grow</i> function, and giving feedback with <i>buttonMonitor</i>; see <a name="rf15"><a href="9807af15.htm">Figure 15</A> and <a href="9807a.htm#l33">Listing Thirty-Three</A>. <i>renderGeometry</i>, used here with a convenient default camera, turns a 3D animation into a 2D animation. </p><table border="1" cellpadding="3" align="center"><tr>	<td><a name="l32"><h4>Listing Thirty-Two</h4><pre>spinPot potColor potAngle =  turn3 zVector3 potAngle (    withColorG potColor teapot) </pre><a name="l33"><h4>Listing Thirty-Three</h4><pre>spin1 u = buttonMonitor u `over`           renderGeometry (spinPot red (grow u))                           defaultCamera </pre></td></tr></table><p>Additional spinning teapots will all have the general form of using the button monitor and rendering with the default camera. Rather than having to write several definitions, give the pattern a name. In <a href="9807a.htm#l34">Listing Thirty-Four</A>, <i>withSpinner</i> takes a function as its first argument, and applies that function to the result of the <i>grow</i> function applied to the user argument. With this definition, you can write <i>spin1</i> more simply; see <a href="9807a.htm#l35">Listing Thirty-Five</A>. Another use of <i>withSpinner</i> is to make the color vary in hue and use the value from <i>grow</i> to determine the time-varying speed of rotation, so that the mouse buttons cause the turning to accelerate and decelerate (see <a href="9807a.htm#l36">Listing Thirty-Six</A>). </p><table border="1" cellpadding="3" align="center"><tr>	<td><a name="l34"><h4>Listing Thirty-Four</h4><pre>withSpinner f u =   buttonMonitor u `over`   renderGeometry (f (grow u) u)                  defaultCamera </pre><a name="l35"><h4>Listing Thirty-Five</h4><pre>spin1 = withSpinner spinner1  where    spinner1 angle u = spinPot red angle </pre><a name="l36"><h4>Listing Thirty-Six</h4><pre>spin2 = withSpinner spinner2  where    spinner2 potAngleSpeed u =      spinPot (colorHSL time 0.5 0.5)              (atRate potAngleSpeed u)</pre></td></tr></table><p>In addition to visible geometry, you can add lights to a 3D model. In <a href="9807a.htm#l37">Listing Thirty-Seven</A>, you combine a white sphere, which is visible but does not emit light, and a point light source, which is invisible but emits light. You color the sphere/light pair white, shrink it, and give it motion. For convenience, you express the motion path in terms of spherical coordinates, saying that the distance from the origin of space (which is also the center of the teapot) is always 1.5 units, the longitude is <img src="pi12.gif"> times the elapsed time, and the latitude is twice <img src="pi12.gif"> times the elapsed time. Consequently, you get a motion that meanders about, but maintains a fixed distance from the center of the teapot. </p><table border="1" cellpadding="3" align="center"><tr>	<td><a name="l37"><h4>Listing Thirty-Seven</h4><pre> sphereLowRes = importX "../Media/sphere0.x" movingLight =    move3 motion (     stretch3 0.1 (      withColorG white (       sphereLowRes `unionG` pointLightG)))  where   motion = vector3Spherical 1.5              (pi*time) (2*pi*time) potAndLight =   withColorG green teapot `unionG` movingLight </pre></td></tr></table><p>Just for fun, replace the single moving light with five. A simple change suffices, if you add <i>delayAnims3</i> -- a 3D variant of the 2D <i>delayAnims</i>. As <a href="9807a.htm#l38">Listing Thirty-Eight</A> shows, the difference is that in the 3D version, you use <i>unionGs</i> instead of <i>overs</i>. With this function, you make a list of five copies of the moving light (see <a href="9807a.htm#l39">Listing Thirty-Nine</A>), using the predefined Haskell function <i>replicate</i>, stagger them in time with <i>delayAnims3</i>, and combine them with a green teapot. Then slow down the animation to see it more clearly.</p><p>In <a href="9807a.htm#l40">Listing Forty</A> and <a name="rf16"><a href="9807af16.htm">Figure 16</A> (a moving trail of colored balls), you define a single ball having a spiral motion, which traces the surface of an unseen sphere of radius 1.5 with a longitude angle changing ten times as fast as the latitude angle (five versus one-half radians per second). From this one moving ball, you make ten balls, each a differently colored version, and then stagger them in time with <i>delayAnims3</i>. The coloring function <i>bColor</i> produces evenly spaced hues. </p><table border="1" cellpadding="3" align="center"><tr>	<td><a name="l38"><h4>Listing Thirty-Eight</h4><pre>delayAnims3 dt anims =   unionGs (zipWith later [0, dt ..] anims) </pre><a name="l39"><h4>Listing Thirty-Nine</h4><pre>potAndLights =   slower 5 (    withColorG green teapot `unionG`    delayAnims3 (2/5) (replicate 5 movingLight) )</pre><a name="l40"><h4>Listing Forty</h4><pre>spiral3D = delayAnims3 0.075 balls  where    ball   = move3 motion (stretch3 0.1 sphereLowRes)    balls  = [ withColorG (bColor i) ball             | i &lt;- [1 .. n] ]    motion = vector3Spherical 1.5 (10*time) time    n      = 20    bColor i =      colorHSL (2*pi * fromInt i / fromInt n) 0.5 0.5 </pre><a name="l41"><h4>Listing Forty-One</h4><pre>spiralTurn = turn3 zVector3 (pi*time) (unionGs (map ball [1 .. n]))  where    n = 40    ball i  = withColorG color (               move3 motion (                stretch3 0.1 sphereLowRes ))     where       motion = vector3Spherical 1.5 (10*phi) phi       phi    = pi * fromInt i / fromInt n       color  = colorHSL (2*phi) 0.5 0.5</pre></td></tr></table><p>As a final 3D example, <a href="9807a.htm#l41">Listing Forty-One</A> presents another spiral. This time you form a static spiral, then turn it about the z-axis. </p><h3>Related Work</h3><p>My interest in functional animation originally started with Kavi Arya's "A Functional Approach to Animation," <i>Computer Graphics Forum</i>, 5(4):297-311 (December, 1986). Although elegant, Arya used a discrete model of time. The TBAG system, on the other hand, used a continuous time model, and had a syntactic flavor similar to Fran's; see "TBAG: A High Level Framework for Interactive, Animated 3D Graphics Applications," by Conal Elliott, Greg Schechter, Ricky Yeung, and Salim Abi-Ezzi (<i>Proceedings of SIGGRAPH </i>'<i>94</i> July, 1994). Unlike Fran, reactivity was handled imperatively. Behaviors were created by means of constraint solving, and updated through constraint assertion and retraction. Concurrent ML introduced a first-class notion of events that can be constructed compositionally; see "CML: A Higher-order Concurrent Language," by John H. Reppy (<i>Proceedings of the ACM SIGPLAN '91 Conference on Programming Language Design and Implementation</i>, 1991). However, those events perform side-effects such as writing to buffers or removing data from buffers. In contrast, Fran event occurrences have associated values -- they help define what an animation is, but do not cause any side effects. </p><p>For examples of DirectAnimation, see http://www.microsoft.com/ie/ie40/demos and "Adding Theatrical Effects to Everyday Web Pages with DirectAnimation," by Salim AbiEzzi and Pablo Fernicola (<i>Microsoft Interactive Developer</i>, October 1997).</p><p>For background on Haskell, see <i>Introduction to Functional Programming</i>, by Richard Bird and Philip Wadler, (Prentice-Hall, 1987), "A Gentle Introduction to Haskell," by Paul Hudak and Joseph H. Fasel, <i>SIGPLAN Notices</i>, 27(5), May, 1992, and http://haskell.org/tutorial/index.html. </p><p>For information on Fran, refer to "Functional Reactive Animation," by Conal Elliott and Paul Hudak, <i>Proceedings of the 1997 ACM SIGPLAN International Conference on Functional Programming</i> (June, 1997), or the Fran web page at http://www.research .microsoft.com/mconal/Fran. </p><h3>Conclusion</h3><p>For interactive animation to expand into its potential as a medium of communication, it must become much easier to program. As this article illustrates, one step toward this goal is the replacement of imperative techniques ("how to do") with declarative ones ("what to be").</p><p>There are several features I haven't explored here, including sound, smooth flip-book animation, and cropping. There are also many opportunities for improvement: more features for 2D, sound, and 3D; improved efficiency; generation of animation "software components" to integrate with components written in more mainstream programming languages; and support for distributed, multiuser scenarios. </p><h3>Acknowledgments</h3><p>Todd Knoblock and Jim Kajiya helped to explore the basic ideas of behaviors and events. Sigbjorn Finne, Anthony Daniels, and Gary Shu Ling helped with the implementation during research internships. Alastair Reid made improvements to the Haskell code, and, along with Paul Hudak and John Peterson, provided helpful discussions about functional animation, how to use Haskell well, and lazy functional programming in general. Becky Elliott cut out the kid pictures, which appear with the kind permission of their owners Patrick, Charlotte, Becky, and Jake.</p><p><b>DDJ</b></p><HR><I>Copyright &copy; 1998, Dr. Dobb's Journal</I><BR>
</body></html>