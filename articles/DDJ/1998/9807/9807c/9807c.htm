<html><head><title>Dr. Dobb's Journal July 1998: A Windows 3D Model Viewerfor OpenGL</title></head><body bgcolor="FFFFFF"><!--Copyright &#169; Dr. Dobb's Journal--><h1>A Windows 3D Model Viewerfor OpenGL</h1><p><i>Dr. Dobb's Journal</i> July 1998</p><h2>Combining Win32 with OpenGL </h2><h3>By Jawed Karim </h3><I>Jawed studies computer science at the University of Illinois at Urbana-Champaign. He works part-time at the National Center for Supercomputing Applications, and can be contacted at jkarim@students.uiuc.edu. </I><hr><p>OpenGL is known in the UNIX world as the 3D API behind high-powered scientific applications. It has recently gained attention in the PC sector, thanks to the computer-game industry, which has embraced OpenGL as an API standard for 3D game programming. Furthermore, 3D hardware acceleration for PCs has extended the range of applications for OpenGL even further.</p><p>The OpenGL API is intuitive, easier to use, in my opinion, than Microsoft's Direct3D API, and is portable among platforms. In this article, I'll present a model viewer for use with OpenGL on Windows 95/NT. First, however, I'll describe the important parts of a Quake2 model viewer -- an OpenGL-based system written in C/C++ -- that displays wire-frame and texture-mapped models (see <a name="rf1"><a href="9807cf1.htm">Figure 1</A>) from Quake2 and provides a basic interface to modify their appearance. In the process, I'll focus on file formats (MD2 files for models, and PCX files for textures), passing the data contained in the files to OpenGL for rendering, and interfacing Win32 with OpenGL using an API called "WGL." The archive Q2M-SRC.ZIP contains the Quake2 Model Viewer source code, while Q2M-BIN.ZIP is the Quake2 Model Viewer EXE file. Both are available electronically; see "Resource Center," page 3.</p><h3>Reading the MD2 File Format</h3><p>The only official source of information about Quake2's MD2 format is code by John Carmack of id Software; this code writes 3D polygon mesh data to an MD2 file (available at ftp://ftp.idsoftware.com/). Anyone who has looked at this source code will notice that some of the <i>struct</i>s in Quake2 Model Viewer's md2.h (available electronically) are derived from it. Writing the MD2 reader basically involves converting John's code from reading MD2 files to writing them. <a name="rf2"><a href="9807cf2.htm">Figure 2</A> illustrates the binary structure of an MD2 file.</p><p>To display the textured Quake2 models, four specific types of information are needed (see <a name="rf3"><a href="9807cf3.htm">Figure 3</A>):</p><ul><li>3D vertex coordinates.  <li>A list of triangles consisting of those vertices.  <li>2D texture vertex coordinates (one for each 3D vertex).  <li>The texture image.</ul><p></p><p>All of the 3D vertices in the model are stored in one array. When the triangles (which are made up of those vertices) are defined, all that has to be stored for each vertex of a triangle is an index number to the big vertex array. The reason for this is simple: Since many of the vertices are shared between triangles, storing each vertex once saves memory. In addition, linear transformations can be performed on the entire array at once, thereby speeding rendering time. Since the texture image itself is not a part of the MD2 file, it can be read in from a conventional PCX file.</p><p>Before starting, you must know how much data to expect. The file's header section tells you the number of vertices, triangles, and texture coordinates contained in the file. Knowing when to stop, you can go into a loop and read the information in chunks. To store all the data, use the vertex structure in <a name="rl1"><a href="9807c.htm#l1">Listing One</A> </p><p>Each triangle is defined by its corners, <i>a</i>, <i>b</i>, and <i>c</i>. These values are indices to an array of type <i>make_vertex_list</i>, which is a list of all 3D vertices in the entire model. The remaining six integers represent the 2D texture coordinates for every vertex. <a name="rl2"><a href="9807c.htm#l2">Listing Two</A> is an example of a structure for holding this data. Using such a structure, the coordinates of the three vertices of the first triangle in the model can be referenced (see <a name="rl3"><a href="9807c.htm#l3">Listing Three</A>).</p><p>In a Quake2 model, the only things that differ from one frame to the next are the 3D coordinates of the triangle vertices; the vertex indices and texture coordinates remain the same. From frame to frame, each triangle still consists of the same three vertices -- only the vertices undergo linear transformations. To hold each frame in an array, you create another array of type <i>make_frame_list</i> (<a name="rl4"><a href="9807c.htm#l4">Listing Four</A>), each of which contains an array of vertex coordinates (Vertex 1, 2, and 3, respectively). There exists one copy of this array for each frame. Having filled all of the data structures, you can look up the coordinates of any polygon in any frame; see <a name="rl5"><a href="9807c.htm#l5">Listing Five</A> (the coordinates of polygon P in frame F).</p><h3>Texturing the Object</h3><p>Quake2's model textures reside as separate PCX files, either in the pak0.pak file or quake2/baseq2 directory. Since OpenGL itself does not provide a way to read the binary PCX graphics file format, you can read the PCX file and pass its data to OpenGL.</p><p><a name="rf4"><a href="9807cf4.htm">Figure 4</A> describes the PCX format. The three basic sections in the file are the header, pixel data, and palette data. You can use two arrays of type <i>unsigned char</i> to store the last two sections. The header contains some basic information about the particular file, such as the PCX version, and the file dimensions. If the file is actually a PCX Version 5 file, the first two bytes in the file must be equal to 10 and 5, respectively. Having determined the image dimensions from the header section, you dynamically allocate an array of type <i>unsigned char</i> of <i>size(width*height)</i> for the pixel data and read it into the buffer byte-by-byte. Because a Version 5 PCX file can support exactly 256 colors, the size of the palette section is always 768 bytes (3*256, or RBG*256).</p><p>When the <i>CImage::Read (char filename[])</i> function is finished, the <i>m_pixel_buffer</i> array is filled with all the pixels in the image, and <i>m_palette_buffer</i> contains consecutive RGB values for each of the colors.</p><p>How do you get the color of a specific pixel in the image? The pixel buffer simply contains index values of the palette buffer. <a name="rl6"><a href="9807c.htm#l6">Listing Six</A> shows two methods. The R, G, and B components of the first pixel (pixel zero) in the image are <a href="9807c.htm#l6">Listing Six</A>(a). However, because the palette array contains consecutive RBG values (RGBRGBRGBRGB...) for all the colors, the individual R, G, and B values at pixel position P are obtained by properly offsetting the array index; see <a href="9807c.htm#l6">Listing Six</A>(b). Finally, to be able to reference color values at specific (X,Y) coordinates in the texture, <i>P</i> is substituted by <i>X+Y*Width</i>, where <i>Width</i> is the width of the texture; see <a href="9807c.htm#l6">Listing Six</A>(c).</p><h3>OpenGL</h3><p>Once the necessary data is organized and stored in memory, you can start rendering using OpenGL. But first, some of OpenGL's texturing options must be set. In particular, you must specify how to treat textures when wrapped and indicate the "minification" and magnification filters (<a name="rl7"><a href="9807c.htm#l7">Listing Seven</A>).</p><p>In addition, back-face culling and texturing have to be explicitly enabled. Since you won't be looking at the backsides of polygons, you only have to enable front-side filling of polygons. Lastly, you specify the texture function (<a name="rl8"><a href="9807c.htm#l8">Listing Eight</A>).</p><p>OpenGL's <i>glTexImage2D()</i> is the function that actually textures the object. It expects to be passed, among other parameters, a pointer to an array containing successive RGBA values for each pixel in the texture (for example, RGBARGBARGBA...).</p><p>Thus, before calling <i>glTexImage2D()</i>, two changes must be made:</p><ul><li>1.	The pixel and palette data read from the PCX file must be copied into another array, of a format that <i>glTexImage2D()</i> can accept as a parameter.  <li>2.	Because OpenGL requires the dimensions of a texture to be powers of two, the texture has to be rescaled first using <i>gluScaleImage()</i>.</ul><p>Both of these steps are accomplished in <i>CImage::Image2GLTexture(),</i> which first creates a new array called <i>unScaled</i>, fills it with RGBA components, and rescales it to an appropriate size. The loop in <a name="rl9"><a href="9807c.htm#l9">Listing Nine</A> fills a new array with RGBA components of each pixel in the texture, again offsetting the array indices as in the PCX code.</p><p>Now the texture contained within <i>unScaled</i> can be rescaled to have dimensions that are powers of two. To prevent the texture from losing much quality while keeping the performance at a reasonable level, a power of two that is closest to the original dimension will be used. For example, if the original width is greater than 256 pixels, the new dimension should be 512 pixels. If the original width is 128 or greater (but less than 256), the rescaled dimension should be 256. After a series of <i>if</i> statements have determined a good fit for the new dimensions, a call to <i>gluScaleImage()</i> rescales the texture (<a name="rl10"><a href="9807c.htm#l10">Listing Ten</A>).</p><p>Finally, the <i>glTexture</i> array can be passed to OpenGL as follows: <i>glTexImage2D(GL_TEXTURE_2D,0,4,scaledWidth, scaledHeight,0,GL_RGBA,GL_UNSIGNED_BYTE, glTexture);</i>. <a name="rt1"><a href="9807ct1.htm">Table 1</A> provides a quick explanation of the parameters.</p><h3>Creating an OpenGL Rendering Context</h3><p>WGL provides an interface between the Win32 API and OpenGL. It sets up a palette for your rendering window and handles such things as double buffering. To do this, you usually need to use four or five of the fewer than 20 WGL functions. I have written a basic C++ wrapper class for the functions that is easy to use. Most of the code in the <i>COpenGLWindow</i> class is taken from Silicon Graphics' OpenGL Developer Tools CD-ROM for Windows 95/NT, which interestingly has become a collector's item since SGI's "Fahrenheit" deal with Microsoft. (SGI is cooperating with Microsoft on the next generation of OpenGL. Since the agreement, SGI's, OpenGL drivers for Windows 95/NT have disappeared from the SGI web site, and the SGI OpenGL Developer CD-ROM for Windows 95/NT is hard to come by. However, there are several web sites mirroring its contents, including http://jawed.ncsa.uiuc.edu/.)</p><p>The dimensions of the rendering window are passed to the constructor, but its window handle must be passed to the <i>OpenGLWindow::Create()</i> class member function to actually create the rendering context.</p><p>WGL does not physically create a window for you; that is Win32's responsibility. WGL creates an OpenGL rendering context for a window that has already been created. If you want a window to create and destroy its OpenGL rendering context as the window is created and destroyed, simply catch the WM_CREATE and WM_DESTROY messages in the window's window procedure. Then call <i>OpenGLWindow::Create()</i> and <i>OpenGLWindow::Destroy()</i>, respectively, as has been done in inter.c's <i>GraphicsProc</i> function (available electronically). The only other time you really need to use WGL is for a system palette change. Windows will indicate that such a change has been made by sending a WM_PALETTECHANGED message to every window, and then <i>OpenGLWindow::RedoPalette()</i> will take care of the change.</p><h3>Drawing the Entire Model</h3><p>Inter.cpp's <i>redraw()</i> function (available electronically) redraws the entire model in its current state by specifying all of the triangle vertex coordinates and texture mapping coordinates between <i>glBegin(GL_TRIANGLES)</i> and <i>glEnd()</i>. This requires three calls to <i>glTexCoord2f()</i> (two parameters) and <i>glVertex3f()</i> (three parameters) for every triangle. One thing to note about the <i>glTextCoord2f()</i> function is that OpenGL expects texture-mapping coordinates to be relative, not absolute. To obtain these coordinate values, divide the original texture mapping coordinates from the model by their maximum range in the texture. In other words, divide the <i>S</i> component by the texture map's width and divide <i>T</i> by the texture map's height. These values will fall between 0 and 1 and remain unchanged when the texture is resized. For instance, (0.5, 0.5) will always point to the center pixel of the texture, no matter whether the texture dimensions are 173&times;233 or 256&times;256. Of course, doing a floating-point divide three times per loop is inefficient. By storing these values ahead of time the loop's efficiency could be improved greatly.</p><p>Between frame redraws the rendering window's window procedure keeps track of mouse movements and mouse button activity by listening to WM_MOUSEMOVE, and WM_*BUTTON(UP/DOWN) messages. The movement increments are then temporarily stored in two arrays -- one for translational movements, and another one for rotations. At the beginning of each frame redraw the linear transformations are carried out using <i>glTranslate()</i> and <i>glRotate()</i>.</p><h3>Conclusion</h3><p>Although OpenGL is straightforward to use, simply knowing the API is not sufficient. Since OpenGL does not provide functions to read 3D model and texture files of your preferred format, a basic understanding of 3D concepts and some amount of manual data manipulation is also required. Combining Win32 with OpenGL makes it possible to develop applications with user-friendly interfaces and impressive 3D graphics. </p><p>Keep in mind that one of OpenGL's bonuses is portability. Porting your Win32 OpenGL applications to X under UNIX should not be much more difficult than cutting and pasting some of the graphics code. Of course, creating another interface from scratch will be necessary.</p><p><b>DDJ</b></p><H4><a name="l1">Listing One</H4><pre>typedef struct{     float x, y, z;  /* coordinates */} make_vertex_list;</pre><P><a href="#rl1">Back to Article</A></P><H4><a name="l2">Listing Two</H4><pre>typedef struct{    int a, b, c;    /* array indices */    int a_s, a_t,   /* (s, t) texture coordinates */    b_s, b_t,    c_s, c_t;} make_index_list;</pre><P><a href="#rl2">Back to Article</A></P><H4><a name="l3">Listing Three</H4><pre><b>(a)</b>(vertex_list[index_list[0].a].x, vertex_list[index_list[0].a].y,                                        vertex_list[index_list[0].a].z)<p></p><b>(b)</b>(vertex_list[index_list[0].b].x, vertex_list[index_list[0].b].y,                                         vertex_list[index_list[0].b].z)<p></p><b>(c)</b>(vertex_list[index_list[0].c].x, vertex_list[index_list[0].c].y,                                         vertex_list[index_list[0].c].z)</pre><P><a href="#rl3">Back to Article</A></P><H4><a name="l4">Listing Four</H4><pre>typedef struct{     make_vertex_list *vertex;} make_frame_list;</pre><P><a href="#rl4">Back to Article</A></P><H4><a name="l5">Listing Five:</H4><pre><b>(a)</b>frame_list[F].vertex[index_list[P].a].xframe_list[F].vertex[index_list[P].a].yframe_list[F].vertex[index_list[P].a].z<p></p><b>(b)</b> frame_list[F].vertex[index_list[P].b].xframe_list[F].vertex[index_list[P].b].yframe_list[F].vertex[index_list[P].b].z<p></p><b>(c)</b>frame_list[F].vertex[index_list[P].c].xframe_list[F].vertex[index_list[P].c].yframe_list[F].vertex[index_list[P].c].z</pre><P><a href="#rl5">Back to Article</A></P><H4><a name="l6">Listing Six</H4><pre><b>(a)</b>R: m_palette_buffer [ m_pixel_buffer[0]]G: m_palette_buffer [ m_pixel_buffer[1]]B: m_palette_buffer [ m_pixel_buffer[2]]<p></p><b>(b)</b>R: m_palette_buffer [3 * m_pixel_buffer[P]+0]G: m_palette_buffer [3 * m_pixel_buffer[P]+1]B: m_palette_buffer [3 * m_pixel_buffer[P]+2]<p></p><b>(c)</b>R: m_palette_buffer [3 * m_pixel_buffer[X + Y*Width]+0]G: m_palette_buffer [3 * m_pixel_buffer[X + Y*Width]+1]B: m_palette_buffer [3 * m_pixel_buffer[X + Y*Width]+2]</pre><P><a href="#rl6">Back to Article</A></P><H4><a name="l7">Listing Seven</H4><pre>glPixelStorei(GL_UNPACK_ALIGNMENT, 1);glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP);glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);</pre><P><a href="#rl7">Back to Article</A></P><H4><a name="l8">Listing Eight</H4><pre>glEnable(GL_CULL_FACE);glEnable(GL_TEXTURE_2D);glPolygonMode (GL_FRONT, GL_FILL);glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_DECAL);</pre><P><a href="#rl8">Back to Article</A></P><H4><a name="l9">Listing Nine</H4><pre>Glubyte *unScaled = new GLubyte [m_iWidth * m_iHeight * 4];for (j = 0; j &lt; m_iHeight; j++) {  for (i = 0; i &lt; m_iWidth; i++) {    unScaled[4*(j * m_iWidth + i)+0] =              (GLubyte) m_palette_buffer[3*m_pixel_buffer[j*m_iWidth+i]+0];    unScaled[4*(j * m_iWidth + i)+1] =              (GLubyte) m_palette_buffer[3*m_pixel_buffer[j*m_iWidth+i]+1];    unScaled[4*(j * m_iWidth + i)+2] =              (GLubyte) m_palette_buffer[3*m_pixel_buffer[j*m_iWidth+i]+2];    unScaled[4*(j * m_iWidth + i)+3] = (GLubyte) 255;  }}</pre><P><a href="#rl9">Back to Article</A></P><H4><a name="l10">Listing Ten</H4><pre>/* allocate memory for the new rescaled texture */glTexture = new GLubyte [m_iscaledWidth * m_iscaledHeight * 4];<p></p>/* use the OpenGL function to rescale */gluScaleImage (GL_RGBA, m_iWidth, m_iHeight, GL_UNSIGNED_BYTE, unScaled,              m_iscaledWidth, m_iscaledHeight, GL_UNSIGNED_BYTE, glTexture);<p></p>/* reclaim memory of the unscaled texture */delete [] unScaled;</pre><P><a href="#rl10">Back to Article</A></P><HR><I>Copyright &copy; 1998, Dr. Dobb's Journal</I><BR>
</body></html>