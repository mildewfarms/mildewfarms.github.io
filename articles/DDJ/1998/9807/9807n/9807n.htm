<html><head><title>Dr. Dobb's Journal July 1998: Algorithm Alley</title></head><body bgcolor="FFFFFF"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Image Segmentation for Image Recognition</h1><p><i>Dr. Dobb's Journal</i> July 1998</p><h3>By Lee Kamentsky</h3><I>Lee is a software engineer at CompuCyte Corporation. He can be contacted at leek@msn.com.</I><hr><p>Good ideas reappear in surprising places. When Lee first told me about his algorithm, I thought he was discussing an old flood-fill algorithm -- one that I remembered seeing long before it appeared in Kent Porter's "Graphics Programming" column (<i>DDJ</i>, June 1989). There are good reasons for the similarity: Both algorithms rely on a fundamental insight that applies to many data-analysis tasks -- where possible, work with groups of data, not with single elements.</p><p>Rather than studying a single pixel at a time, Lee's technique immediately bundles pixels into larger structures. As in many graphics problems, the natural unit is a horizontal line of pixels. By quickly moving the problem from one involving pixels to one involving lines, Lee reduces his work by an order of magnitude.</p><p> -- Tim Kientzle</p><p>Subtle variations of color and texture in photographic images make it difficult to clearly identify a foreground and a background. It's considerably simpler with "artificial" images, such as scanned text. The relatively high contrast makes it easier to separate pixels, but you still have to somehow identify regions of pixels and extract relevant information. In this article, I'll describe an algorithm that quickly reduces high-contrast images to a data set that lends itself to image recognition and analysis. This algorithm could be used to analyze black text on a white background, calibration marks on a surface, red Legos in a toybox, or a slide containing blots of a drug being tested by a pharmaceutical company.</p><p>The initial stage of image analysis usually consists of two steps -- thresholding and segmentation. Thresholding algorithms classify pixels as either foreground or background, or classify pixels according to their foreground class (green, red, and blue classes, for instance, or skin texture, hair texture, and clothing texture). Thresholding algorithms can extend past analyzing the raw brightness or color of a pixel. Some involve linear transforms such as convolution filters and FFTs. Others rely on nonlinear transforms such as image dilation.</p><p>Segmentation algorithms group similar pixels together into coherent units. Segmentation is often regarded as a backwater of image analysis. However, a good segmentation algorithm can yield easily analyzable, abstract objects with a minimum of processing. The algorithm I describe here has good performance. It visits each pixel exactly once, processing the pixels in their raster order, which maintains cache coherency, improves bus bandwidth and eliminates disk thrashing. It yields data structures representing connected groups of pixels; the data structures can be manipulated to extract information without revisiting each pixel.</p><p>The algorithm groups pixels into run-length encoded lines. It then groups the lines into structures I call "blobs." The blobs contain groups of lines that overlap. This yields an object that describes a set of four-connected (north, south, east, and west) pixels, none of which are connected to any pixel outside of the set. You can quickly find a blob's extent, position, center, or area. You can analyze the blob's topology and shape. You can revisit the pixels within the blob to determine their brightness, coloration, or texture. These techniques lend themselves to the tasks of optical-character recognition (OCR), scene recognition (where the scene consists of artificial, high-contrast objects), and automated chemical analysis.</p><h3>The Segmentation Algorithm</h3><p>Suppose you're trying to analyze black text against a white background. In this context, the segmentation algorithm looks at one raster at a time and breaks it down into a series of black lines. Each line is compared to the lines on the previous raster (the "old line list") and is either added to an existing blob or a new blob is created.</p><p>If a blob has lines on the old line list, those lines are open lines. I maintain a count of open lines for each blob. When the count falls to zero, that blob is finished and need no longer be considered. The bulk of the algorithm, then, consists of walking down the old line list and comparing new lines to see how to attach them to blobs.</p><p>The algorithm starts with the genesis of a new line. The application typically maintains a threshold and scans until it finds a pixel whose value is over the threshold. It then starts a line and scans until it hits a pixel under threshold. The application then builds a line consisting of the X start, X end, and the current Y. The line also contains a pointer to its blob (null signals that the line is unattached) and a pointer to the next line in the blob.</p><p>There are three possible relationships between the current old line and new line, as illustrated in <a name="rf1"><a href="9807nf1.htm">Figure 1</A>. </p><ul>  <li>The old line might end before the new line begins; see <a href="9807nf1.htm">Figure 1</A>(a).  <li>The new line might end before the old line begins; see <a href="9807nf1.htm">Figure 1</A>(b).  <li>	The two lines might overlap; see <a href="9807nf1.htm">Figure 1</A>(c). </ul><p>If the old line is wholly before the new line, it is finished. I decrement its blob's open line count and, if the open line count has reached zero, add the blob to the list of finished blobs. I then advance to the next old line in the list. If the new line is wholly before the old line, then we have finished attaching the new line. If no previous old line overlaps this new line, then the new line starts a new blob.</p><p>The third case involves overlapping old and new lines. Its implementation requires two parts: attaching and ending. You attach the new line to an old line in one of three ways. If the new line is not yet linked to a blob, we link it to the old line's blob. If the new line is already linked to the old line's blob, then you increment the blob's loop count (this is a signal that the blob split into two halves and these two halves have been rejoined by the new line, like at the bottom of the letter "O"). If the new line has already been linked to a blob other than the old line's blob, then the new line joins two blobs (like at the bottom of the letter "V"). You merge the two blob's line lists and discard one of the blobs.</p><p>Merging blobs is an important feature of any segmentation algorithm. <a name="rf2"><a href="9807nf2.htm">Figure 2</A> illustrates a particularly difficult example, in which three new lines combine four separate blobs. You need to compare the ends of the new and old lines after attaching the new line. If the old line ends first, you can move onto the next old line. If the new line ends first, then you have to increment the blob's open line count (lines can now be attached to both the old and the new line). You then move on to create the next new line.</p><p>The algorithm has one additional minor complexity: At the end of a raster, you either run out of new lines or old lines. If you run out of new lines, you run through a loop that ends the remaining old lines. You decrement the open line counts and finish any blobs whose open line count falls to zero. If you run out of old lines first, you must create new blobs for each new line until the end of the raster.</p><h3>Additional Features</h3><p>It's possible to augment this algorithm to collect additional information about each blob. I've already included the loop counts, since those are so easy to extract. The demonstration program makes use of the loop count to distinguish the loops in bullseyes: The bullseye rings must be closed to be recognized. You might also use the loop count to help in distinguishing letters; uppercase "B" and lowercase "g" are the only letters with two loops (assuming no malformations).</p><p>Another group of useful features are the image tops and bottoms. The tops are those lines that were not attached to any line above. The total number of tops is one more than the number of merges required to produce the blob. The bottoms are those lines that had no other line attached below them. The algorithm can find these by setting a flag when first considering an old line. The algorithm clears the flag if a new line attaches to the old line. You check the flag when finishing the old line; if it is still set, you have a bottom.</p><p>Numbers of tops and bottoms by themselves can be used to distinguish shapes. For instance, the letter "w" has three tops and two bottoms for both serif and sans-serif fonts, the small "m" has three tops and three bottoms. Positions of tops and bottoms are perhaps more telling; a top directly above a bottom may indicate a vertical line (in character recognition, this is typically the leftmost stroke of the letter). It's quite possible to build a neural network character recognizer that uses a number of loops, top position, and bottom position as its input features; this recognition engine is efficient and provides a confidence output along with its judgment.</p><p>Positional information can be recorded during segmentation. The algorithm can update the enclosing rectangle for the blob as it adds lines (the top of the blob is always one of its starting lines, the bottom is always the old line at which the line count drops to zero). The algorithm can also compute the blob centroid (if each pixel weighed the same, the centroid would be the blob's center of mass) and area. It may be more efficient, however, to compute these during a quick trip through the blob's line list after it has been finished.</p><h3>Optimizations</h3><p>Ironically, the two most expensive parts of the segmentation algorithm are outside of the algorithm proper. Thresholding is the most expensive, because it requires examining each individual pixel. Using table lookups or other techniques that examine several pixels at a time can help to speed this part. A quick optimization may be to check for all ones or all zeros. Typically, though, thresholding is sped up through hardware assist: The data is thresholded, run-length encoded, and transmitted in encoded form.</p><p>The second most expensive operation is allocation. Artifacts of image capture can often cause a jagged edge at the top of an object, The algorithm may create a blob initially for each of these jagged lines. Blob creation can be an expensive operation, even if the blobs are unlinked from a private heap. It's possible to modify the algorithm so that blobs are created only when a previously unattached new line is attached to a previously unattached old line. This delays blob creation past typical effects caused by aliasing. A single new line joining many unattached old lines will only create a single blob.</p><p>My implementation maintains an array of pointers to lines. This indirection can be eliminated by allocating all lines from a single array. You can then set an array index to the first line on the old line list and fetch subsequent old lines by incrementing the index. It's possible in many operating systems to reserve a large block of memory without actually allocating the backing store necessary to maintain the virtual memory image on disk (this is the <i>VirtualAlloc</i> function in Windows 95/NT). The algorithm can reserve the theoretical maximum size memory required for the worst case (which is half the number of pixels in the image times the size of a line). The algorithm can perform the actual allocation at the beginning of the raster, enlarging the array of lines to prepare for the worst case. This eliminates the need to check for "out of memory" when allocating lines during the course of a scan.</p><p>Finally, many processors have a sweet spot at 16 bytes when dealing with arrays of structures. (Typically, the bus is 32-bits wide and the bus bursts are four words long. A 16-byte structure makes optimum use of one burst.) The line structure consists of an X start, X end, Y coordinate, pointer to the next line in the blob, and pointer to the line's blob. That's 20 bytes if the algorithm uses 32-bit integers and pointers. Packing the X start and X end into two 16-bit words may provide a significant boost in speed.</p><h3>Applications</h3><p>The structures yielded by the segmentation algorithm lend themselves to a variety of uses. The lines provide compression for a number of tasks. First among these are tasks involving the relations of the blobs to each other and to the background. It's an easy matter to relate the blobs to their neighbors once they have been segmented; you can form agglomerations (such as lines of print or areas of half-tone dot images) that provide useful feature information. My most recent use of the algorithm has been a bullseye recognizer that detects a microscopic bullseye deposited at an exact spot on a microscope slide by photolithography. The segmentation algorithm quickly identifies the two rings and target of the bullseye by searching for the only three objects that have centroids that are close together (the middle of each ring corresponds with the middle of the bullseye).</p><p>It's possible to perform template matches using the algorithm data structures. (I've included a template matcher in <a name="rl1"><a href="9807n.htm#l1">Listing One</A>A template matcher can match blob against blob. This is done by relying on the line order within the blobs to efficiently find which parts of the image overlap the template. The resulting score gives a confidence measure that the template is the same shape as the image. Template matching can be used in OCR to discriminate between letters that have similar overall shapes (such as "A" and "R," which both have one loop, one top, and two bottoms).</p><p>The segmentation algorithm can be used to find and outline objects deposited on a substrate. For instance, a drug manufacturer might test thousands of variants of a drug at once using a robotic deposition tool that places the results of different reactions at different spots on a dish. The spots can be found using the segmentation algorithm and the chemical reaction can then be analyzed by measuring the intensity and color of the reactions in the spot. The algorithm can be used in other aspects of robotics; a few marks on an object can be used to track the object in real time and position it. Again, these algorithms work best in an artificial environment in which lighting and contrast are controlled to maximize the difference between foreground and background.</p><h3>Conclusion</h3><p>This segmentation algorithm rapidly identifies the boundaries of contiguous objects from their background. It makes efficient use of modern CPU resources and yields objects with data structures that have utility. I believe that it could serve as the core of a number of interesting image processing applications. I would like to see it used in novel ways, such as in identifying -- in real time -- high contrast objects placed in video scenes as markers for animated characters. It might also be used as the base segmentation algorithm for real-world imaging using sophisticated image processing techniques that enhance foreground. The algorithm can be extended to three dimensions by matching against two old line lists: one in the X-Y plane and one in the X-Z plane. This adaptation might be used in computer-aided tomagrophy to identify tumors. In any case, the algorithm is dependable and useful and should serve you well in appropriate applications.</p><p><b>DDJ</b></p><H4><a name="l1">Listing One</H4><pre>void CMonochromeBitmap::BuildBlobList(){  CLineVectorIterator clviNew,clviEnd;  AllocateLineBlock(clviNew,clviEnd);  m_pBlob.reserve(eBlobsPerBlock);<p></p>  // Create two vectors of pointers to lines to hold the new line list  // and the old line list. We initialize them to hold Width()/2 members.  // This is the maximum possible number of lines.  CLinePointerVector clpvRaster[2];  clpvRaster[0].reserve(Width()/2);  clpvRaster[1].reserve(Width()/2);  int nOldLineIndex = 0;  int nNewLineIndex = 1;  // At the start, the old line list has no members.  CLinePointerVectorIterator clpviOldEnd = clpvRaster[nOldLineIndex].begin();  for (int nY = 0; nY &lt; Height(); nY++) {    CLinePointerVector &amp;clpvOld = clpvRaster[nOldLineIndex];    CLinePointerVector &amp;clpvNew = clpvRaster[nNewLineIndex];    nOldLineIndex = nOldLineIndex ^ 1;    nNewLineIndex = nNewLineIndex ^ 1;    CLinePointerVectorIterator clpviOld = clpvOld.begin();    CLine *pLineOld;    if (clpviOld == clpviOldEnd)      pLineOld = NULL;    else      pLineOld = *clpviOld++;<p></p>    CLinePointerVectorIterator clpviNew = clpvNew.begin();    // Get the raster to process and set up for the first byte    const BYTE *pRaster = GetRaster(nY);    BYTE bBit = 0x80;    BYTE bByte = *pRaster++;    //  Set up the X extents.    int nX = 0;    const int nXEnd = Width();<p></p>    while(nX &lt; nXEnd) {      CBlob *pBlobOld;      // Search for the start of a line.      while((bByte &amp; bBit) == 0) {        if (++nX == nXEnd) goto linedone;        bBit = bBit &gt;&gt; 1;        if (bBit == 0) {          bBit = 0x80;          bByte = *pRaster++;        }      }      // Start a line.      if (clviNew == clviEnd) {        // need more memory for lines.        AllocateLineBlock(clviNew,clviEnd);      }      CLine &amp;lineNew = *clviNew++;      lineNew.m_nXStart = nX;      lineNew.m_pNextLineSameBlob = 0;      lineNew.m_nY = nY;<p></p>      // Put it on the new list.      *clpviNew++ = &amp;lineNew;      // Find the extent of the line.      do {        if (nX == nXEnd) break;        bBit = bBit &gt;&gt; 1;        if (bBit == 0) {          bBit = 0x80;          bByte = *pRaster++;        }        nX++;      } while (bBit &amp; bByte);      lineNew.m_nXEnd = nX - 1;      // Now finish all old lines wholly before our new line      if (pLineOld) {        while (pLineOld-&gt;m_nXEnd &lt; lineNew.m_nXStart) {          pBlobOld = pLineOld-&gt;m_pBlob;          if (--(pBlobOld-&gt;m_nOpenLines) == 0) {            AddBlob(pBlobOld);          }          if (clpviOld == clpviOldEnd) {            pLineOld = NULL;            break;          } else {            pLineOld = *clpviOld++;          }        }      }      // Do the first line that overlaps our new line      if (pLineOld &amp;&amp; pLineOld-&gt;m_nXStart &lt;= lineNew.m_nXEnd) {        pBlobOld = pLineOld-&gt;m_pBlob;        lineNew.m_pBlob = pBlobOld;        *(pBlobOld-&gt;m_ppLastLine) = &amp;lineNew;        pBlobOld-&gt;m_ppLastLine = &amp;(lineNew.m_pNextLineSameBlob);        // See if the new line ends the old line or vice-versa.        if (pLineOld-&gt;m_nXEnd &gt; lineNew.m_nXEnd) {          // the old line extends past the new line.          // the new line gives the old line's blob another open line.          pBlobOld-&gt;m_nOpenLines++;          continue;        } else {          // we close the old line and extend the blob at the          // same time. We continue to close old lines.          if (clpviOld == clpviOldEnd) {            pLineOld = NULL;          } else {            pLineOld = *clpviOld++;            while(pLineOld-&gt;m_nXEnd &lt;= lineNew.m_nXEnd) {              // End this line too. We have two cases:              CBlob *pBlobOther;              if ((pBlobOther = pLineOld-&gt;m_pBlob) == pBlobOld) {                // the old line is part of the new line's blob.                // This is just a loop.                pBlobOld-&gt;m_nLoops++;                pBlobOld-&gt;m_nOpenLines--;              } else {                // This is the merge case                pBlobOld-&gt;Merge(pBlobOther);                delete pBlobOther;                pBlobOld-&gt;m_nOpenLines--;              }              if (clpviOld == clpviOldEnd) {                pLineOld = NULL;                break;              } else {                pLineOld = *clpviOld++;              }            }            if (pLineOld &amp;&amp; pLineOld-&gt;m_nXStart &lt;= lineNew.m_nXEnd) {              // This last old line overlaps and ends the new line.              CBlob *pBlobOther = pLineOld-&gt;m_pBlob;              if (pBlobOther == pBlobOld) {                pBlobOld-&gt;m_nLoops++;              } else {                pBlobOld-&gt;Merge(pBlobOther);                delete pBlobOther;              }            }          }        }      } else {        // This is the case where no line overlaps the new line.        // Start a blob with this line.        CBlob *pBlobNew = lineNew.m_pBlob = new CBlob;        pBlobNew-&gt;m_nOpenLines = 1;        pBlobNew-&gt;m_pFirstLine = &amp;lineNew;        pBlobNew-&gt;m_ppLastLine = &amp;(lineNew.m_pNextLineSameBlob);        pBlobNew-&gt;m_nLoops = 0;      }    }linedone:    if (pLineOld) {      while (TRUE) {        // Finish all old lines.        CBlob *pBlobOld = pLineOld-&gt;m_pBlob;        if (--(pBlobOld-&gt;m_nOpenLines) == 0) {          AddBlob(pBlobOld);        }        if (clpviOld == clpviOldEnd) break;        pLineOld = *clpviOld++;      }    }    // Finally, record the end of the new list as the    // end of the old list to be.    clpviOldEnd = clpviNew;  }  // At the end, we've got one last raster of lines to finish.  CLinePointerVector &amp;clpvLast = clpvRaster[nOldLineIndex];  for (CLinePointerVectorIterator clpvi = clpvLast.begin();  clpvi != clpviOldEnd;) {    // Finish all old lines.    CBlob *pBlobOld = (*clpvi++)-&gt;m_pBlob;    if (--(pBlobOld-&gt;m_nOpenLines) == 0) {      AddBlob(pBlobOld);    }  }  // and finally, segmentation is complete}</pre><P><a href="#rl1">Back to Article</A></P><HR><I>Copyright &copy; 1998, Dr. Dobb's Journal</I><BR>
</body></html>