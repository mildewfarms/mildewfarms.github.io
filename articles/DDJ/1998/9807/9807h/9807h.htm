<html><head><title>Dr. Dobb's Journal July 1998: Internet Programming</title></head><body bgcolor="FFFFFF"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Rendering XML Documents Using XSL</h1><p><i>Dr. Dobb's Journal</i> July 1998</p><h2>Keeping content and format separate </h2><h3>By Sean McGrath</h3><I>Sean, chief technical officer and cofounder of Digitome Electronic Publishing (http:// www.digitome.com/) is a member of the World Wide Web Consortium's XML Special Interest Group. He is also the author of ParseMe.1st: SGML for Software Developers (Prentice-Hall, 1997) and XML By Example: Building E-commerce Applications (Prentice-Hall, 1998). Sean can be reached at sean@digitome.com.</I><hr><p>Central to the eXtensible Markup Language (XML) philosophy is that the structure and content of information should be captured without concern for how the information will be rendered on a computer display, paper, voice synthesis, and others. Responsibility for rendering XML has been delegated to a sister standard known as eXtensible Style Language (XSL). (For more information on XML, see my article "XML Programming in Python," <i>DDJ</i>, February 1998.) </p><p>Like XML, XSL is a World Wide Web Consortium (W3C) initiative. In August of 1997, a draft proposal for XSL was made available as a discussion document by the W3C (http://www.w3.org/TR/NOTE-XSL.html). Although, the working draft for XSL is just that, a number of XSL applications have already appeared. In particular, Microsoft has released MSXSL, a "technology preview" implementation that is freely available at http://www.microsoft.com/xml/. In this article, I will present an overview of XSL and illustrate how it can be used with MSXSL.</p><h3>The XSL Philosophy</h3><p>As <a name="rf1"><a href="9807hf1.htm">Figure 1</A> illustrates, the XSL philosophy can be summed up as "late binding of presentation semantics." In simple English, the idea is that information about how a document should look when rendered (presentation semantics) is separated from the document content and housed in a stylesheet. The process of creating a rendition of the content happens late  --  preferably right at the point that someone wants to view it (hence, late binding).</p><p>This late binding approach has some significant benefits:</p><ul>  <li>The look and feel of a document (or thousands of documents) can easily be changed simply by changing the stylesheet.   <li>Multiple renditions of the same content can be created from a single source. These renditions can include different output notations such as RTF, HTML, or Postscript. They can involve rearrangements of the content, creating multiple views of the information.   <li>The information content is "future proofed." Creating a new rendition to a new notation (or a notation yet to be invented), is a matter of applying the necessary stylesheet.   <li>Keeping the content free of rendering information makes it easier to process the content. That is, searching, harvesting, or rearranging the content can be performed without worrying about how the formatting information is intermingled with the content. </ul><p>There are a number of core concepts that are central to XSL, including: </p><p><b>Flow Objects.</b> In XSL, the process of transforming an XML document into a notation such as RTF, HTML, or Postscript, is expressed in terms of the construction of flow objects, which are pages, columns, paragraphs, table cells, and so on.</p><p><b>Platform-Independent Flow Objects.</b> XSL specifies a set of standard flow objects such as paragraph, page sequence, table, and the like. Using these platform-independent flow objects lets you create multiple output notations with a single XSL stylesheet. The type of notations that can be created is limited only by the back-end notations supported by the XSL processor. Strong candidates for XSL back ends include RTF, FrameMaker MIF, and TeX.</p><p>HTML-Specific Flow Objects. To facilitate the use of XSL stylesheets to generate HTML, XSL provides a set of HTML-specific flow objects. Given the vast amount of HTML-aware software in existence, it makes sense to use this software, while simultaneously retaining the advantages of XML over HTML as a data representation.</p><p><b>Construction Rules.</b> Flow-object construction in XSL is controlled by rules in the XSL stylesheet. These rules specify what flow objects are to be created and what they should contain. Flow objects can be thought of as containers for document content and/or other flow objects creating a tree-like hierarchy known as a "flow-object tree." Flow-object construction rules take the form of a pattern and action. The pattern part specifies the conditions under which the rule triggers. The action part specifies what flow objects to construct.</p><p><b>Characteristics.</b> Flow objects can have associated characteristics that differ depending on the type of flow object being constructed. A paragraph flow object, for example, might have margin and tab characteristics. A table cell might have border and spanning characteristics. The characteristics to be applied to flow objects can be controlled in the XSL style-sheet by means of style rules. Style rules take the same general form as construction rules, and consist of pattern and action components.</p><p><b>Scripting.</b> No stylesheet language that provides a fixed set of rendering capabilities can provide all the processing power needed. There comes a point where a "Turing Complete" programming language is the best way to get the job done. The XSL draft specifies ECMAScript (a standardized version of JavaScript -- ECMA 262) as a built-in scripting language. A number of mechanisms are provided in XSL for escaping to ECMAScript to perform calculations, define functions, and so on.</p><h3>Introducing MSXSL</h3><p>MSXSL is Microsoft's technology preview implementation of the XSL draft specification. Don't confuse it with MSXML, which is Microsoft's implementation of an XML parser. Indeed, MSXSL uses MSXML to parse and load XSL stylesheets.</p><p>MSXSL focuses on creating HTML from XML and, for the time being, only supports HTML flow objects. The simplest way to use MSXSL is via the provided command-line utility that takes the input XML file (-i), input stylesheet file (-s), and output HTML file (-o). For example, the command <i>C&gt;msxsl -i foo.xml -s foo.xsl -o foo.htm</i> processes the foo.xml file with respect to the foo.xsl stylesheet specification, then generates the foo.htm output file.</p><p>To illustrate how to use XSL and MSXSL, I'll return to the XML document (see <a name="rf2"><a href="9807hf2.htm">Figure 2</A>) presented in my February 1998 article.</p><h3>Sample #1: Getting Started</h3><p><a name="rl1"><a href="9807h.htm#l1">Listing One</A>(a) reates a simple stylesheet to convert the XML document in <a href="9807hf2.htm">Figure 2</A> to HTML. Some things to note about this stylesheet:</p><ul>  <li>It is an XML document and uses a set of element types -- <i>xsl, rule, root,</i> and so on -- defined by the XSL language. The tags for these elements appear in lowercase.   <li>It signifies the creation of HTML flow objects by using HTML tags -- BODY, TITLE, and so on. These tags appear in uppercase.   <li>It consists of a single flow-object construction rule. The pattern that triggers the rule is the root element (<i>&lt;root/&gt;</i>).   <li>The children element (<i>&lt;children/&gt;</i>) tells the XSL processor that all the children of the element that triggered the construction rule should be processed, and the results of processing these elements should be inserted into the output flow-object tree. </ul><p><a href="9807h.htm#l1">Listing One</A>(b) is the result of processing the XML document with this style-sheet. While it's hardly the world's most exciting HTML file, there are some important things to note:</p><ul>  <li>All the data content of the XML document (the content of the <i>Maker</i> and <i>Color</i> elements) has found its way into the output document. The default in XSL is that the content of elements that do not trigger construction rules simply flows over to the output document at the point where it is encountered.   <li>The attribute values (<i>Price</i>, <i>Units</i>, and <i>Type</i>) do not appear in the output document. This is also the result of the default behavior of XSL. </ul><h3>Sample #2: Rudimentary Formatting</h3><p><a name="rl2"><a href="9807h.htm#l2">Listing Two</A>(a) adds a few more construction rules to create slightly more pleasing HTML output, while <a href="9807h.htm#l2">Listing Two</A>(b) presents the result of processing the XML document with this stylesheet. Things to note about this stylesheet and the resultant HTML include:</p><ul>  <li>The pattern part of the flow-object construction rules use the <i>target-element</i> element, which can be used in a variety of ways to specify context-sensitive rules. Here, I used the simplest form in which the <i>target-element</i> is an empty element (denoted by the slash in <i>&lt;target<sub>element/&gt;</i></sub>).   <li>The same construction rule can be triggered for multiple element types by specifying multiple empty <i>target-element</i> elements. I've used this to cause the same rule to trigger on <i>Condition</i> and <i>Color </i>elements. The paragraph generated for the <i>Condition</i> element is empty because attribute values are not, by default, included in the output document.   <li>The stylesheet is an XML document and, thus, must be well-formed XML. This is why the HR flow object uses XML syntax to indicate it is an empty element (<i>&lt;HR/&gt;</i>). </ul><h3>Sample #3: Accessing Attribute Values</h3><p>The <i>Car</i> elements in <a href="9807hf2.htm">Figure 2</A> have attributes for price and currency information. These can be accessed in XSL by escaping to the ECMAScript scripting language. XSL provides an <i>eval</i> element that can be used to house script code. In <a name="rl3"><a href="9807h.htm#l3">Listing Three</A>(a), the rule is modified to let <i>Car</i> elements access the attribute information. <a href="9807h.htm#l3">Listing Three</A>(b) is the HTML from this modified stylesheet.</p><p>The CDATA section in the <i>eval</i> element is an XML construct that shields text from the attentions of the XML parser. The CDATA section begins with the "&lt;![CDATA[" string and ends at the "]]" string. It is a good idea to use CDATA sections to shield script code, since characters such as "&lt;" and "&amp;"  can have special meanings to an XML parser.</p><h3>Sample #4: Creating a Table</h3><p><a name="rl4"><a href="9807h.htm#l4">Listing Four</A>(a) is a stylesheet creating a simple HTML table layout of "car for sale" information. <a href="9807h.htm#l4">Listing Four</A>(b) is the result of applying this stylesheet to the XML file.</p><ul><li>All attribute values for the HTML flow objects must be quoted to make the stylesheet well-formed XML. The correct way to specify a table with a border is &lt;TABLE BORDER=''1''&gt;. The syntax &lt;TABLE BORDER=1&gt;, which is HTML valid, generates a parsing error in MSXSL; see <a name="re1"><a href="9807he1.htm">Example 1</A>.  <li>The first cell in each table row contains the relative number of the <i>Car</i> -- 1, 2, and so on. This number is automatically generated by the <i>childNumber()</i> function. The built-in XSL functions for automatic numbering are useful in creating stylesheets. </ul><p><a name="rf3"><a href="9807hf3.htm">Figure 3</A> shows what the generated HTML file looks like in Internet Explorer 4.0.</p><h3>Sample #5: Rearranging Content</h3><p>With XSL, it is possible to exert control over the order in which elements in the source document are processed. This allows document content to be selected and rearranged prior to creating the output. In <a name="rl5"><a href="9807h.htm#l5">Listing Five</A>(a), a table of car maker names is created; <a href="9807h.htm#l5">Listing Five</A>(b) shows the result of applying this stylesheet to the XML file.</p><p>Only the <i>Maker</i> element data has appeared in the output. This is because the <i>select-element</i> element indicates that only the <i>Maker</i> children of <i>Car</i> elements are processed. By default, the <i>select-element</i> element looks at the children of the current element to find matches. It is also possible to arrange for <i>select-element</i> to search all descendants by specifying the value <i>''Descendants''</i> to the optional <i>from</i> attribute: <i>&lt;select-elements from = ''Descendants''&gt;</i>. The <i>&lt;children/&gt;</i> element used in previous examples is shorthand for <i>&lt;select-elements from = ''Children''&gt;</i></p><h3>Sample #6: Scripting</h3><p>As a final example, the stylesheet in <a name="rl6"><a href="9807h.htm#l6">Listing Six</A>(a) uses ECMAScript to present all prices in Irish Punts in the generated HTML; <a href="9807h.htm#l6">Listing Six</A>(b). The <i>define-script</i> element is used to create global variables and functions, and the <i>eval</i> element is used to invoke functions and access global variables.</p><h3>XSL and CSS</h3><p>Although Cascading Style Sheets (CSS) can be used to render XML documents, XSL provides many more capabilities than CSS. With CSS, the document structure is essentially fixed and is simply mapped onto the available flow objects. With XSL, the document structure can be rearranged and can be processed multiple times. For example, with XSL is it possible to perform a traversal to generate a table of contents, then perform a second traversal to render the content proper. Also, XSL is programmable via ECMAScript, thus providing a Turing Complete environment in which to create rendering effects.</p><p>(On the other hand, CSS is simple and familiar to many HTML users, and work is underway at Hewlett-Packard to create an extended implementation of CSS, known as "Spice," which makes up for some of these deficiencies.)</p><h3>XSL and DSSSL</h3><p>XSL draws heavily on the concepts used in the Document Style and Semantics Specification Language ISO 10179 (DSSSL) Standard for SGML rendering. The DSSSL Standard uses a programming language based on Scheme as its expression language. Many of the DSSSL designers have been instrumental in the design of XSL, and work is underway to make the XML-based expression language of XSL formally a part of the DSSSL international Standard. Henry Thompson of the University of Edinburgh has developed the XSLJ conversion utility that converts XSL specifications into DSSSL specifications. These can then be used with implementations of the DSSSL Standard such as Jade (http://www.jclark.com/).</p><h3>Conclusion</h3><p>XSL is an important part of the overall vision of XML. The core XML effort has three separate strands -- XML itself, XML rendering (XSL), and XML hypertext linking (XLL). The speed with which companies such as Microsoft have moved to implement XSL has come as something of a surprise to many. Even in its current basic state, MSXSL is capable of real work and provides a glimpse of the capabilities you can expect in the next generation of web browsers, which should process and render XML directly.</p><h4>For More Information<br><br>XSL Draft Specification: http://www.w3.org/TR/NOTE-XSL.html<br>Microsoft's MSXSL XSL Processor Technology Preview: http://www.microsoft.com/xml/<br>XSL Discussion List and Archive: http://www.mulberrytech.com/xsl/xsl-list/<br>XSL-J (XSL to DSSSL Conversion Utility): http://www.ltg.ed.ac.uk/~ht/xslj.html<br>Jade DSSSL Engine: http://www.jclark.com/DSSSL Discussion List and Archive: http://www.mulberrytech.com/dsssl/dssslist/</h4><p><b>DDJ</b></p><H4><a name="l1">Listing One</H4><pre><b>(a)</b>C&gt;type cfs1.xsl&lt;!-- Ultra simple XSL stylesheet --&gt;&lt;xsl&gt; &lt;rule&gt; &lt;!-- Pattern --&gt; &lt;root/&gt; &lt;!-- Action --&gt; &lt;HTML&gt; &lt;HEAD&gt; &lt;TITLE&gt;Cars for sale - Example 1&lt;/TITLE&gt; &lt;/HEAD&gt; &lt;BODY&gt; &lt;children/&gt; &lt;/BODY&gt; &lt;/HTML&gt; &lt;/rule&gt;&lt;/xsl&gt;<p></p><b>(b)</b>C&gt;msxsl -i cfs.xml -s cfs1.xsl -o cfs1.htmC&gt;type cfs1.htm&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;Cars for sale - Example 1&lt;/TITLE&gt;&lt;/HEAD&gt;&lt;BODY&gt;ToyotaRedFordWhite&lt;/BODY&gt;&lt;/HTML&gt;</pre><P><a href="#rl1">Back to Article</A></P><H4><a name="l2">Listing Two </H4><pre><b>(a)</b>&lt;!-- Process Car elements by processing all children and then adding a horizontal rule --&gt;&lt;rule&gt; &lt;!-- Pattern --&gt; &lt;target-element type = "Car"/&gt; &lt;!-- Action --&gt; &lt;children/&gt; &lt;HR/&gt;&lt;/rule&gt;&lt;!-- Process Maker elements by prefixing some literal text and thenprocessing all children --&gt;&lt;rule&gt; &lt;!-- Pattern --&gt; &lt;target-element type = "Maker"/&gt; &lt;!-- Action --&gt; &lt;P&gt; Make of Car: &lt;children/&gt; &lt;/P&gt;&lt;/rule&gt;&lt;!-- Process both Condition and Color elements in the same way--simply create HTML paragraphs --&gt;&lt;rule&gt; &lt;!-- Pattern --&gt; &lt;target-element type = "Condition"/&gt; &lt;target-element type = "Color"/&gt; &lt;!-- Action --&gt; &lt;P&gt; &lt;children/&gt; &lt;/P&gt;&lt;/rule&gt;<p></p><b>(b)</b>C&gt;msxsl -i cfs.xml -s cfs2.xsl -o cfs2.htmC&gt;type cfs2.htm&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;Cars for sale - Example 2&lt;/TITLE&gt;&lt;/HEAD&gt;&lt;BODY&gt;&lt;P&gt; Make of Car: Toyota&lt;/P&gt;&lt;P&gt;&lt;/P&gt;&lt;P&gt;Red&lt;/P&gt;&lt;HR&gt;&lt;P&gt; Make of Car: Ford&lt;/P&gt;&lt;P&gt;&lt;/P&gt;&lt;P&gt;White&lt;/P&gt;&lt;HR&gt;&lt;/BODY&gt;&lt;/HTML&gt;</pre><P><a href="#rl2">Back to Article</A></P><H4><a name="l3">Listing Three</H4><pre><b>(a)</b>&lt;rule&gt; &lt;target-element type = "Car"/&gt; &lt;P&gt; Price = &lt;eval&gt;&lt;![CDATA[ getAttribute("Price") + " " + getAttribute("Units") ]]&gt;&lt;/eval&gt; &lt;/P&gt; &lt;children/&gt; &lt;HR/&gt;&lt;/rule&gt;<p></p><b>(b)</b>C&gt;msxsl -i cfs.xml -s cfs3.xsl -o cfs3.htmC&gt;type cfs3.htm&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;Cars for sale - Example 3&lt;/TITLE&gt;&lt;/HEAD&gt;&lt;BODY&gt;&lt;P&gt; Price = 10000 Dollars&lt;/P&gt;&lt;P&gt; Make of Car: Toyota&lt;/P&gt;&lt;P&gt;&lt;/P&gt;&lt;P&gt;Red&lt;/P&gt;&lt;HR&gt;&lt;P&gt; Price = 20000 Irish Punts&lt;/P&gt;&lt;P&gt; Make of Car: Ford&lt;/P&gt;&lt;P&gt;&lt;/P&gt;&lt;P&gt;White&lt;/P&gt;&lt;HR&gt;&lt;/BODY&gt;&lt;/HTML&gt;</pre><P><a href="#rl3">Back to Article</A></P><H4><a name="l4">Listing Four</H4><pre><b>(a)</b>C&gt;type cfs4.xsl&lt;xsl&gt; &lt;rule&gt;    &lt;!-- Pattern --&gt; &lt;root/&gt; &lt;!-- Action --&gt; &lt;HTML&gt; &lt;HEAD&gt; &lt;TITLE&gt;Cars for sale - Example 4&lt;/TITLE&gt; &lt;/HEAD&gt; &lt;BODY&gt; &lt;TABLE BORDER="1"&gt; &lt;TR&gt; &lt;TD&gt;Number&lt;/TD&gt; &lt;TD&gt;Price&lt;/TD&gt; &lt;TD&gt;Maker&lt;/TD&gt; &lt;TD&gt;Condition&lt;/TD&gt; &lt;TD&gt;Color&lt;/TD&gt; &lt;/TR&gt; &lt;children/&gt; &lt;/TABLE&gt; &lt;/BODY&gt; &lt;/HTML&gt; &lt;/rule&gt;&lt;rule&gt;&lt;!-- Pattern --&gt; &lt;target-element type = "Car"/&gt; &lt;!-- Action --&gt; &lt;TR&gt; &lt;!-- Automatically number the table rows --&gt; &lt;TD&gt;&lt;eval&gt;childNumber(this)&lt;/eval&gt;&lt;/TD&gt; &lt;TD&gt; &lt;eval&gt;getAttribute("Price") + " " + getAttribute("Units")&lt;/eval&gt; &lt;/TD&gt; &lt;children/&gt; &lt;/TR&gt;&lt;/rule&gt;&lt;rule&gt; &lt;!-- Pattern --&gt; &lt;target-element type = "Maker"/&gt; &lt;target-element type = "Color"/&gt; &lt;!-- Action --&gt; &lt;TD&gt; &lt;children/&gt; &lt;/TD&gt;&lt;/rule&gt;&lt;rule&gt; &lt;!-- Pattern --&gt; &lt;target-element type = "Condition"/&gt; &lt;TD&gt; &lt;eval&gt;&lt;![CDATA[ getAttribute("Type")          ]]&gt;&lt;/eval&gt; &lt;/TD&gt;&lt;/rule&gt;&lt;/xsl&gt;<p></p><b>(b)</b>C&gt;msxsl -i cfs.xml -s cfs4.xsl -o cfs4.htmC&gt;type cfs4.htm&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;Cars for sale - Example 4&lt;/TITLE&gt;&lt;/HEAD&gt;&lt;BODY&gt;&lt;TABLE BORDER="1"&gt;&lt;TR&gt;&lt;TD&gt;Number&lt;/TD&gt;&lt;TD&gt;Price&lt;/TD&gt;&lt;TD&gt;Maker&lt;/TD&gt;&lt;TD&gt;Condition&lt;/TD&gt;                                                        &lt;TD&gt;Color&lt;/TD&gt;&lt;/TR&gt;&lt;TR&gt;&lt;TD&gt;1&lt;/TD&gt;&lt;TD&gt;10000 Dollars&lt;/TD&gt;&lt;TD&gt;Toyota&lt;/TD&gt;&lt;TD&gt;Good&lt;/TD&gt;&lt;TD&gt;Red&lt;/TD&gt;&lt;/TR&gt;&lt;TR&gt;&lt;TD&gt;2&lt;/TD&gt;&lt;TD&gt;20000 Irish Punts&lt;/TD&gt;&lt;TD&gt;Ford&lt;/TD&gt;&lt;TD&gt;Good&lt;/TD&gt;&lt;TD&gt;White&lt;/TD&gt;&lt;/TR&gt;&lt;/TABLE&gt;&lt;/BODY&gt;&lt;/HTML&gt;</pre><P><a href="#rl4">Back to Article</A></P><H4><a name="l5">Listing Five</H4><pre><b>(a)</b>C&gt;type cfs5.xsl&lt;xsl&gt; &lt;rule&gt; &lt;root/&gt; &lt;HTML&gt; &lt;HEAD&gt; &lt;TITLE&gt;Cars for sale - Example 5&lt;/TITLE&gt; &lt;/HEAD&gt; &lt;BODY&gt; &lt;TABLE BORDER="1"&gt; &lt;children/&gt; &lt;/TABLE&gt; &lt;/BODY&gt; &lt;/HTML&gt; &lt;/rule&gt;&lt;rule&gt; &lt;target-element type = "Car"/&gt; &lt;TR&gt; &lt;select-elements&gt; &lt;target-element type = "Maker"/&gt; &lt;/select-elements&gt; &lt;/TR&gt;&lt;/rule&gt;&lt;rule&gt; &lt;target-element type = "Maker"/&gt; &lt;TD&gt; &lt;children/&gt; &lt;/TD&gt;&lt;/rule&gt;&lt;/xsl&gt;<p></p><b>(b)</b>C&gt;msxsl -i cfs.xml -s cfs5.xsl -o cfs5.htmC&gt;type cfs5.htm&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;Cars for sale - Example 5&lt;/TITLE&gt;&lt;/HEAD&gt;&lt;BODY&gt;&lt;TABLE BORDER="1"&gt;&lt;TR&gt;&lt;TD&gt;Toyota&lt;/TD&gt;&lt;/TR&gt;&lt;TR&gt;&lt;TD&gt;Ford&lt;/TD&gt;&lt;/TR&gt;&lt;/TABLE&gt;&lt;/BODY&gt;&lt;/HTML&gt;</pre><P><a href="#rl5">Back to Article</A></P><H4><a name="l6">Listing Six</H4><pre><b>(a)</b>C&gt;type cfs8.xsl&lt;xsl&gt;&lt;define-script&gt;&lt;![CDATA[// 1.5 Dollars to every Irish Poundvar ExchangeRate = 1.5;// Convert price into Irish Pounds based on the ExchangeRate variable// if units is Dollarsfunction getPriceInIrishPunts(price,units){ if (units == "Dollars") return price * ExchangeRate + " Irish Pounds"; else return price + " Irish Pounds";}]]&gt;&lt;/define-script&gt;&lt;rule&gt; &lt;!-- Pattern --&gt; &lt;root/&gt; &lt;!-- Action --&gt; &lt;HTML&gt; &lt;HEAD&gt; &lt;TITLE&gt;Cars for sale - Example 8&lt;/TITLE&gt; &lt;/HEAD&gt; &lt;BODY&gt; &lt;P&gt;&lt;B&gt;Note: Exchange Rate Used &lt;eval&gt;ExchangeRate+" Dollars per Irish Pound"&lt;/eval&gt; &lt;/B&gt;&lt;/P&gt; &lt;children/&gt; &lt;/BODY&gt; &lt;/HTML&gt;&lt;/rule&gt;&lt;rule&gt; &lt;!-- Pattern --&gt; &lt;target-element type = "Car"/&gt; &lt;!-- Action --&gt; &lt;P&gt; Price in Irish Punts= &lt;eval&gt;&lt;![CDATA[ getPriceInIrishPunts(getAttribute("Price"),getAttribute("Units")) ]]&gt;&lt;/eval&gt; &lt;/P&gt; &lt;children/&gt;&lt;/rule&gt;&lt;rule&gt; &lt;!-- Pattern --&gt; &lt;target-element type = "Make"/&gt; &lt;target-element type = "Color"/&gt; &lt;!-- Action --&gt; &lt;P&gt; &lt;children/&gt; &lt;/P&gt;&lt;/rule&gt;&lt;/xsl&gt;<p></p><b>(b)</b>C&gt;msxml -i cfs.xml -s cfs8.xsl -o cfs8.htmC&gt;type cfs8.htm&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;Cars for sale - Example 8&lt;/TITLE&gt;&lt;/HEAD&gt;&lt;BODY&gt;&lt;P&gt;&lt;B&gt; Note : Exchange Rate Used 1.5 Dollars per Irish Pound&lt;/B&gt;&lt;/P&gt;&lt;P&gt; Price in Irish Punts= 15000 Irish Pounds&lt;/P&gt;Toyota&lt;P&gt;Red&lt;/P&gt;&lt;P&gt; Price in Irish Punts= 20000 Irish Pounds&lt;/P&gt;Ford&lt;P&gt;White&lt;/P&gt;&lt;/BODY&gt;&lt;/HTML&gt;<p></p><p></p></pre><P><a href="#rl6">Back to Article</A></P><HR><I>Copyright &copy; 1998, Dr. Dobb's Journal</I><BR>
</body></html>