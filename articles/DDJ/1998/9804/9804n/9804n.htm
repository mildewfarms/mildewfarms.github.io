<html>
<META NAME="year" CONTENT="1998">
<head>
<title>Algorithm Alley</title>
</head>

<body bgcolor="FFFFFF">
<!--Copyright &#169; Dr. Dobb's Journal-->
<h1>Adaptive Delta Modulation</h1>

<p><i>Dr. Dobb's Journal</i> April 1998
</p>
<h2>Algorithms for audio compression</h2>

<h3>By Gary D. Knott</h3>

<I>Gary works at Civilized Software and can be contacted at knott@civilized.com.</I>

<hr>

<p>One common method of data compression is delta modulation, a technique that's typically used for sound and/or video digital radio transmissions and recordings as well as other types of signals. Delta modulation is a data-encoding technique that also compresses the sequence of sampled function values being encoded. It is particularly useful for transmitting fewer bits (over a network, for instance), and for archival storage. In this article, I'll review the basic delta-modulation algorithm, then examine variations that implement "adaptive delta modulation." For an assembly-language implementation of delta modulation, see "Audio Compression," by John W. Ratcliff (<i>DDJ</i>, July 1992). </p>

<p>The idea behind the delta modulation  representation of a signal <i>f </i>is quite simple. Given the initial value, <i>h</i>=<i>f</i>(<i>s</i><sub>0</sub>), a sampling interval <img src="alpha12.gif" alt="[alpha]" width="7" height="6">, and an increment value <img src="delta10.gif" alt="[delta]" width="9" height="10">, you can interpret a string of bits <i>b</i><sub>1</sub>, <i>b</i><sub>2</sub>,...<i>b<sub>n</i></sub> to obtain a specification of estimated signal values <i><img src="fcaret10.gif" alt="[f with hat]" align=absmiddle width="10" height="19"></i>(<i>t</i><sub>1</sub>), <i><img src="fcaret10.gif" alt="[f with hat]" align=absmiddle width="10" height="19"></i>(<i>t</i><sub>2</sub>),...<img src="fcaret10.gif" alt="[f with hat]" align=absmiddle width="10" height="19">(<i>t<sub>n</i></sub>), where <i>t<sub>i</i></sub>=<i>s</i><sub>0</sub>+<i>i</i><img src="alpha12.gif" alt="[alpha]" width="7" height="6"> for 0<img src="lteq12.gif" alt="[less than or equal to]" width="6" height="7"><i>i</i><img src="lteq12.gif" alt="[less than or equal to]" width="6" height="7"><i>n</i>, as follows: Each bit <i>b</i><sub>i</sub> indicates adding the constant <img src="delta10.gif" alt="[delta]" width="9" height="10"> if <i>b</i><sub>i</sub>=1 and subtracting <img src="delta10.gif" alt="[delta]" width="9" height="10"> if <i>b<sub>i</i></sub>=0 so that the equation in <a name="re1"><a href="9804ne1.htm">Example 1</A> holds. For example, consider <i>f</i>(<i>t</i>)=sin(<i>t</i>)+2cos(3<i>t</i>)exp(-<i>t</i>) if <i>t</i><img src="lteq12.gif" alt="[less than or equal to]" width="6" height="7">6; and <i>f(t)</i>=-.27614(1-exp(-2(<i>t</i>-6))) otherwise. <a name="rf1"><a href="9804nf1.htm">Figure 1</A> shows a graph of <i>f</i> on the interval [0,11].</p>

<p>Let <i>s</i><sub>1</sub>=<i>t<sub>n</i></sub>. Choosing the parameter values <i>s</i><sub>0</sub>=0, <i>s</i><sub>1</sub>=11, <img src="delta10.gif" alt="[delta]" width="9" height="10">=0.1, and <img src="alpha12.gif" alt="[alpha]" width="7" height="6">=0.1, you have <i>h</i>=2 and the delta modulation representation is the binary digital sequence</p>

<blockquote><p>
00000000000000111111000000000000000000<BR>
10000101010101111011111101010010101010<BR>
101010101010101010101010101010101.</p>
</blockquote>

<p>As <a name="rf2"><a href="9804nf2.htm">Figure 2</A> illustrates, this sequence specifies <i><img src="fcaret10.gif" alt="[f with hat]" align=absmiddle width="10" height="19"> </i>drawn with the traditional step-function interpolation that would be seen on an oscilloscope. The smooth curve is the true signal, and the stepped curve is the step-function form of <i><img src="fcaret10.gif" alt="[f with hat]" align=absmiddle width="10" height="19">. </i>Thus the function <i><img src="fcaret10.gif" alt="[f with hat]" align=absmiddle width="10" height="19"> </i>on the interval 0 to 11 is represented with 110 bits.</p>

<p>The encoding process computes the <i>i</i>th bit, <i>b<sub>i</i></sub>, by predicting <i>f</i>(<i>t</i><sub>i</sub>) to be some value <i>P<sub>i</i></sub>. Then, <i>b<sub>i</i></sub> is taken as 1 if <i>f</i>(<i>t<sub>i</i></sub>)&gt;<i>P<sub>i</i></sub> and 0 otherwise. The choice of <i>P<sub>i</i></sub> used here is merely the previous estimate value<i> <img src="fcaret10.gif" alt="[f with hat]" align=absmiddle width="10" height="19"></i>(<i>t<sub>i</i>-1</sub>).</p>

<p>In general, to obtain a reasonable estimate for <i>f</i>, the sampling interval, <img src="alpha12.gif" alt="[alpha]" width="7" height="6">, must be such that (<i>s</i><sub>1</sub>-<i>s</i><sub>0</sub>)/<img src="alpha12.gif" alt="[alpha]" width="7" height="6"> is greater than the Nyquist frequency, which is twice the frequency of the highest-frequency component present in the signal <i>f</i>, and <img src="delta10.gif" alt="[delta]" width="9" height="10"> must be small enough to track high-frequency oscillations without undue shape distortion. A practical way to choose <img src="alpha12.gif" alt="[alpha]" width="7" height="6"> and <img src="delta10.gif" alt="[delta]" width="9" height="10"> is to choose <img src="delta10.gif" alt="[delta]" width="9" height="10"> as the largest absolute error by which <i><img src="fcaret10.gif" alt="[f with hat]" align=absmiddle width="10" height="19"> </i>may deviate from <i>f</i>, then choose <img src="alpha12.gif" alt="[alpha]" width="7" height="6">=<img src="delta10.gif" alt="[delta]" width="9" height="10">/<i>W</i>, where <i>W</i>=max<i>s</i><sub>0</sub><img src="lteq12.gif" alt="[less than or equal to]" width="6" height="7"><i>t</i><img src="lteq12.gif" alt="[less than or equal to]" width="6" height="7"><i>s</i><sub>1</sub>|<i>df(t)/dt</i>|, the maximum absolute is slope of <i>f</i>. In <a href="9804nf2.htm">Figure 2</A>, <img src="alpha12.gif" alt="[alpha]" width="7" height="6"> is clearly too large for the chosen <img src="delta10.gif" alt="[delta]" width="9" height="10">; the result is the large error in the initial part of the signal, called "slope overload error," where the slope is too large in magnitude for <img src="delta10.gif" alt="[delta]" width="9" height="10">=0.1 and <img src="alpha12.gif" alt="[alpha]" width="7" height="6">=0.1 to track the signal.</p>

<p>Even when the signal is being appropriately followed, the estimate oscillates about it. This "granular" noise is unavoidable, although its size is controlled by <img src="delta10.gif" alt="[delta]" width="9" height="10">. Note that the error characteristics of the estimator are given by |<i>f</i>(<i>t</i>)-<i><img src="fcaret10.gif" alt="[f with hat]" align=absmiddle width="10" height="19"></i>(<i>t</i>)|&lt;<img src="delta10.gif" alt="[delta]" width="9" height="10"> for <i>s</i><sub>0</sub><img src="lteq12.gif" alt="[less than or equal to]" width="6" height="7"><i>t</i><img src="lteq12.gif" alt="[less than or equal to]" width="6" height="7"><i>s</i><sub>1</sub>, assuming a is small enough. This is an absolute error criterion rather than a relative error criterion, and <i><img src="fcaret10.gif" alt="[f with hat]" align=absmiddle width="10" height="19"> </i>behaves like a Chebychev approximation to <i>f</i>.</p>

<p>A delta modulation signal is sensitive to transmission error. Changing a burst of a dozen bits or so during transmission can destroy the validity of the remaining bits. However, higher sampling rates mean short burst errors are less harmful, and methods to periodically restart the delta-modulation process can be included in a practical transmission system. In general, delta modulation is a very efficient way to encode a signal. It is not clear how to define the notion of the efficiency of an approximation (as opposed to an exact encoding) in a precise information-theoretic manner, but this is an intriguing direction for investigation.</p>

<h3>Extending Delta Modulation</h3>

<p>You can extend the idea of basic delta modulation in several ways. One approach is to let the increment <img src="delta10.gif" alt="[delta]" width="9" height="10"> assume various values, depending upon the past tracking of the signal. If you output <i>m</i> 1s or 0s in a row (indicating a region of large absolute slope), you can increase <img src="delta10.gif" alt="[delta]" width="9" height="10">, replacing <img src="delta10.gif" alt="[delta]" width="9" height="10"> with 3<img src="delta10.gif" alt="[delta]" width="9" height="10">/2, for example. If you output <i>m</i> alternating 1s and 0s, you can then decrease <img src="delta10.gif" alt="[delta]" width="9" height="10">, say, to 2<img src="delta10.gif" alt="[delta]" width="9" height="10">/3. The new value of <img src="delta10.gif" alt="[delta]" width="9" height="10"> applies to the current bit being output, which forms the <i>m</i>th bit of the change-triggering pattern. This approach is called "adaptive delta modulation." Changing <img src="delta10.gif" alt="[delta]" width="9" height="10">, however, is not always an improvement. Indeed, the signal may be such that a closely tracking, but lagging, estimate becomes an oscillating estimate with greater absolute error when adaptive delta modulation is employed. For the signal in <a href="9804nf2.htm">Figure 2</A> with <img src="alpha12.gif" alt="[alpha]" width="7" height="6">=0.1 (too large), and <img src="delta10.gif" alt="[delta]" width="9" height="10"> varying within the limits 0.05 to 0.28 based on <i>m</i>=2, so that two zeros or ones in a row increase <img src="delta10.gif" alt="[delta]" width="9" height="10">, while two different values decrease <img src="delta10.gif" alt="[delta]" width="9" height="10"> -- you obtain the approximation in <a name="rf3"><a href="9804nf3.htm">Figure 3</A>.</p>

<p>Another approach is to allow the sampling interval, <img src="alpha12.gif" alt="[alpha]" width="7" height="6">, to change. This is not very useful for hardware, which is more conveniently designed to use a fixed clock rate, but for data compression for digital storage purposes, varying <img src="alpha12.gif" alt="[alpha]" width="7" height="6"> may allow fewer bits to be used to encode a given curve. You can increase <img src="alpha12.gif" alt="[alpha]" width="7" height="6"> when the previous <i>m</i> bits have alternated in value, but when <i>m</i> 1s or 0s in a row occur, you reduce <img src="alpha12.gif" alt="[alpha]" width="7" height="6"> to reestablish the fastest sampling rate. This permits large steps in slowly varying regions, but it allows relatively large deviations in the estimate to occur at turning points where <i>f</i> changes from being flat to sharply rising or falling. Choosing <i>m</i>=2 minimizes this effect, but it is still noticeable. Lagging tracking at turning points is the major flaw in most delta-modulation schemes. The step-function estimate of the signal is shown in <a name="rf4"><a href="9804nf4.htm">Figure 4</A>, where I replaced <img src="alpha12.gif" alt="[alpha]" width="7" height="6"> by 1.6<img src="alpha12.gif" alt="[alpha]" width="7" height="6"> up to a limit of 0.41 whenever the previous two bits were the same, and reset <img src="alpha12.gif" alt="[alpha]" width="7" height="6"> to 0.05 otherwise. I fixed <img src="delta10.gif" alt="[delta]" width="9" height="10">=0.1 (which is too small to be completely reasonable for the range of <img src="alpha12.gif" alt="[alpha]" width="7" height="6">). I now have as estimated points: (<i>s</i><sub>0</sub>,<i>f</i>(<i>s</i><sub>0</sub>)), (<i>t</i><sub>1</sub><i>, <img src="fcaret10.gif" alt="[f with hat]" align=absmiddle width="10" height="19"></i>(<i>t</i><sub>1</sub>)),...,(<i>t<sub>n</i></sub>,<i> <img src="fcaret10.gif" alt="[f with hat]" align=absmiddle width="10" height="19"></i>(<i>t<sub>n</i></sub>)) for some irregular mesh <i>s</i><sub>0</sub>&lt;<i>t</i><sub>1</sub>&lt;...&lt;<i>t<sub>n</i></sub>. If you allow <img src="delta10.gif" alt="[delta]" width="9" height="10"> and <img src="alpha12.gif" alt="[alpha]" width="7" height="6"> to both vary as described, with <img src="delta10.gif" alt="[delta]" width="9" height="10"> in the interval [0.05,0.28] and <img src="alpha12.gif" alt="[alpha]" width="7" height="6"> in the interval [0.05,0.41], you obtain the approximation in <a name="rf5"><a href="9804nf5.htm">Figure 5</A>. </p>

<p>To compute the bit <i>b<sub>i</i></sub>, which determines the point (<i>t<sub>i</i></sub>,<i> <img src="fcaret10.gif" alt="[f with hat]" align=absmiddle width="10" height="19"></i>(<i>t<sub>i</i></sub>)) when encoding the signal, <i>f</i>, you form an estimate of <i>f</i>(<i>t<sub>i</i></sub>), called "<i>P<sub>i</i></sub>," where <i>P<sub>i</i></sub> predicts <i>f</i>(<i>t<sub>i</i></sub>), given the previous estimate points (<i>t</i><sub>0</sub>, <i><img src="fcaret10.gif" alt="[f with hat]" align=absmiddle width="10" height="19"></i>(<i>t</i><sub>0</sub>)), (<i>t</i><sub>1</sub>,<i> <img src="fcaret10.gif" alt="[f with hat]" align=absmiddle width="10" height="19"></i>(<i>t</i><sub>1</sub>)),...,(<i>t<sub>i</i>-1</sub>,<i> <img src="fcaret10.gif" alt="[f with hat]" align=absmiddle width="10" height="19"></i>(<i>t<sub>i</i>-1</sub>)). Then if <i>P<sub>i</i></sub> is less than <i>f</i>(<i>t<sub>i</i></sub>), you output <i>b<sub>i</i></sub>=1; otherwise, for <i>P<sub>i</i></sub><img src="gteq.gif" alt="[greater than or equal to]" width="9" height="11"><i>f</i>(<i>t<sub>i</i></sub>), <i>b<sub>i</i></sub> is output as 0.</p>

<p>This same predictor must be used in decoding the bitstring, <i>b</i>, to compute <i><img src="fcaret10.gif" alt="[f with hat]" align=absmiddle width="10" height="19">;</i> this is why<i> P<sub>i</i></sub> depends on <i><img src="fcaret10.gif" alt="[f with hat]" align=absmiddle width="10" height="19"></i> values, and not on <i>f</i>-values. In this discussion, I've used the simple predictor <i>P<sub>i</i></sub>=<i><img src="fcaret10.gif" alt="[f with hat]" align=absmiddle width="10" height="19"></i>(<i>t<sub>i</i>-1</sub>). Other predictor schemes are possible and may provide better performance, allowing smaller <img src="delta10.gif" alt="[delta]" width="9" height="10"> and/or larger <img src="alpha12.gif" alt="[alpha]" width="7" height="6"> values to be used. Of course, other predictors do not necessarily have the property that <i>b<sub>i</i></sub>=1 iff <i><img src="fcaret10.gif" alt="[f with hat]" align=absmiddle width="10" height="19"></i>(<i>t<sub>i</i>-1</sub>)&lt;<i>f</i>(<i>t<sub>i</i></sub>).</p>

<p>In general, then, the decoding calculation for obtaining<i> <img src="fcaret10.gif" alt="[f with hat]" align=absmiddle width="10" height="19"></i>(<i>t<sub>i</i></sub>) is <img src="fcaret10.gif" alt="[f with hat]" align=absmiddle width="10" height="19">(<i>t<sub>i</i></sub>)=<i>P<sub>i</i></sub>+<img src="delta10.gif" alt="[delta]" width="9" height="10"><sub><i>i</i></sub>(2<i>b<sub>i</i></sub>-1) for 1<img src="lteq12.gif" alt="[less than or equal to]" width="6" height="7"><i>i<img src="lteq12.gif" alt="[less than or equal to]" width="6" height="7">n</i>, where <img src="delta10.gif" alt="[delta]" width="9" height="10"><sub><i>i</i></sub> is the particular value of the increment used when <i>b<sub>i</i></sub> is computed; <img src="delta10.gif" alt="[delta]" width="9" height="10"><sub><i>i</i></sub> is a function of <i>b</i><sub>1</sub>,<i>b</i><sub>2</sub>,...,<i>b<sub>i</i>-1</sub>.</p>

<p>You could choose <i>P<sub>i</i></sub> to be determined by extrapolation on the linear or quadratic curve passing through the previous two or three points of the estimate, but experimentation shows the error in this form of predictor to be worse than the simple constant form. A more promising approach is to use an extrapolation on a polynomial that fits the previous <i>k</i> estimate points in the least squares (or better yet, <i>L</i><sup>1</sup>-norm) sense. This works adequately, although the predictor is slow to track <i>f</i> on turning intervals. A more elaborate filter predictor might be worth exploring, but weighted averages of the previous <i>k</i> points and weighted averages of the linear predictors based on the <i>k</i> previous points taken two at a time also perform no better than the simple constant predictor. Thus, finding a better predictor seems difficult and the constant form seems to be the most practical choice as well as the simplest.</p>

<p>If a particularly good predictor is used, however, the adaptive variation of <img src="delta10.gif" alt="[delta]" width="9" height="10"> and <img src="alpha12.gif" alt="[alpha]" width="7" height="6"> becomes less useful. Indeed, with a perfect predictor <i>P<sub>i</i></sub>=<i>f</i>(<i>t<sub>i</i></sub>), the output is all 0 bits, and <img src="alpha12.gif" alt="[alpha]" width="7" height="6"> will stay at its minimum, while <img src="delta10.gif" alt="[delta]" width="9" height="10"> stays at its maximum. The resulting <i><img src="fcaret10.gif" alt="[f with hat]" align=absmiddle width="10" height="19"> </i>curve tracks below <i>f</i> with the maximum allowable error. Even using a merely good predictor means you should sharply decrease <img src="delta10.gif" alt="[delta]" width="9" height="10"> and perhaps increase <img src="alpha12.gif" alt="[alpha]" width="7" height="6">.</p>

<p><a name="re2"><a href="9804ne2.htm">Examples 2</A>(a) and 2(b) present algorithms for encoding and decoding an adaptive delta-modulation signal with <i>m</i>=2 and with the simple constant predictor function, <i>P<sub>i</i></sub>=<i><img src="fcaret10.gif" alt="[f with hat]" align=absmiddle width="10" height="19"></i>(<i>t<sub>i</i>-1</sub>), previously used. The constants <i>C</i>, <img src="delta10.gif" alt="[delta]" width="9" height="10"><sub><i>min</i></sub>, <img src="delta10.gif" alt="[delta]" width="9" height="10"><sub><i>max</i></sub>, <i>g</i>, <img src="alpha12.gif" alt="[alpha]" width="7" height="6"><sub><i>min</i></sub>, and <img src="alpha12.gif" alt="[alpha]" width="7" height="6"><sub><i>max</i></sub> that appear there are global parameters that may be "tuned" to the situation. I have used <i>C</i>=1.5, <img src="delta10.gif" alt="[delta]" width="9" height="10"><sub><i>min</i></sub>=0.05, <img src="delta10.gif" alt="[delta]" width="9" height="10"><sub><i>max</i></sub>=0.28, <i>g</i>=1.6, <img src="alpha12.gif" alt="[alpha]" width="7" height="6"><sub><i>min</i></sub>=0.05, and <img src="alpha12.gif" alt="[alpha]" width="7" height="6"><sub><i>max</i></sub>=0.41 in the examples.</p>

<p>There are many variations possible, based on different ranges for <img src="delta10.gif" alt="[delta]" width="9" height="10"> and <img src="alpha12.gif" alt="[alpha]" width="7" height="6">, and different formulas for changing them. For example signal <i>f</i>, I actually do about as well with even fewer bits than used above when I let <img src="delta10.gif" alt="[delta]" width="9" height="10"> assume just the values 0.1 and 0.2 and let <img src="alpha12.gif" alt="[alpha]" width="7" height="6"> assume just the values 0.1 and 0.2. Another idea is to compute <i>b</i> by the recipe: if <i>f</i>(<i>t</i>)&gt;<i>P</i>-<i>a</i>(<i>log</i>(1+|<i>f</i><sup>1</sup>(<i>t</i>)|)/<i>k</i>) then <i>b</i>&lt;-1 else <i>b</i>&lt;-0. This use of slope information can perhaps be marginally useful, even though it produces "lies" about the location of <i>f</i>. Some suggestions have been made that an "intelligent" encoder could hold <i>m</i> signal values in a memory, and carefully compute the best block of one or more output bits based on this look ahead. Perhaps just provisional output bits could be held, so that you would hold <i>m</i> bits in a local memory and output each bit based upon the <i>m</i>-1 future bits that have been provisionally computed and stored, but it seems difficult to make a useful scheme out of this idea.</p>

<p>Also, when you use <i>m</i>&gt;2 to adaptively change <img src="delta10.gif" alt="[delta]" width="9" height="10"> and/or <img src="alpha12.gif" alt="[alpha]" width="7" height="6">, you could use a 2<sup><i>m</i></sup>-bit decision tree to pick carefully chosen <img src="delta10.gif" alt="[delta]" width="9" height="10"> and <img src="alpha12.gif" alt="[alpha]" width="7" height="6"> modifications; this scheme does work well, but at a high cost in complexity.</p>

<p>The graphs presented here were produced with the Modeling Laboratory (MLAB), a program from Civilized Software for mathematical and statistical modeling (see http://www.civilized.com/). Originally developed at the National Institutes of Health, MLAB includes curve fitting, differential equations, statistics, and graphics as some of its major capabilities. <a name="rl1"><a href="9804n.htm#l1">Listing One</A> includes the statements required to do such computer experiments with MLAB. When invoked with an appropriate MLAB <i>Do </i>command, <a href="9804n.htm#l1">Listing One</A> produces matrices suitable for graphing. </p>

<p>It is worth noting that the step-function approximation form of drawing <i><img src="fcaret10.gif" alt="[f with hat]" align=absmiddle width="10" height="19"></i> is somewhat deceiving. A simple straight-line interpolation is a more reasonable presentation. For example, the (<img src="delta10.gif" alt="[delta]" width="9" height="10">, <img src="alpha12.gif" alt="[alpha]" width="7" height="6">)-varying estimate shown in <a href="9804nf5.htm">Figure 5</A> is generated again in <a name="rf6"><a href="9804nf6.htm">Figure 6</A> using linear connecting segments. Viewing a picture such as this suggests that you might estimate <i>f</i> more exactly if you compute the midpoints of the line segments in the graph of <i>f</i> that cross the graph of <i><img src="fcaret10.gif" alt="[f with hat]" align=absmiddle width="10" height="19"></i>. But this set of crossing points is only marginally useful when filtering is used. Generally, when possible, the input, <i>f</i>, should be prefiltered to pass only frequencies below an appropriate cutoff point. In any event, the output points, (<i>t</i>,<i><img src="fcaret10.gif" alt="[f with hat]" align=absmiddle width="10" height="19"></i>(<i>t</i>)), have both sampling and encoding error, and the output should be filtered to remove some of this noise. The filtering can be done with a distance-weighted smoothing transformation in software, or with an appropriate low-pass filter in hardware.</p>

<p><a name="rf7"><a href="9804nf7.htm">Figure 7</A> shows the smoothed variable <img src="delta10.gif" alt="[delta]" width="9" height="10"> and <img src="alpha12.gif" alt="[alpha]" width="7" height="6"> estimate. A doubly smoothed estimate would be even better in regions of slowly changing slope.</p>

<p><b>DDJ</b></p>


<H4><a name="l1">Listing One</H4>

<pre>FUNCTION F(T)=IF T&lt;=6 THEN SIN(T)+2*COS(3*T)*EXP(-T) ELSE = J-J*EXP(-2*(T-6));
J = -.27614; MINA = .05; MAXA = .41; MAXD = .28; MIND = .05;
T0 = 0; T1 = 11; D = MIND; A = MINA; G = 1.6; C = 1.5;
TYPE "SET T0,T1,A,D, ETC. AS DESIRED."; DO CONSOLE;
<p></p>
FUNCTION ADM(I)= IF T+A&lt;=T1 THEN (B:=((PV:=P(ME[I]:=OLDP(ADM)))&lt;=F(MT[I+1]:=
(T:=T+A))))+0*(A:=NEWA(X1:=X2,X2:=B))+0*(D:=NEWD()) ELSE 1000-I;
<p></p>
FUNCTION OLDP(B)=PV+D*(2*B-1);
FUNCTION P(H1)=H1;
<p></p>
FUNCTION NEWA(X1,X2)=IF X1=X2 THEN MINA ELSE MIN(G*A,MAXA);
FUNCTION NEWD()=IF X1=X2 THEN MIN(D*C,MAXD) ELSE MAX(D/C,MIND);
<p></p>
X2 = 1; ADM =.5; T = T0; IF T1 &lt;= T0 THEN TYPE ("null interval"); = PV = F(T0);
"PRE-ALLOCATE THE ARRAYS MT, ME.";
MT = 0^^360; ME[360] = 0; MT[1] = T0;MB = ADM ON 1:360;
<p></p>
N = MAXI(MB); IF N &gt;=360 THEN TYPE "TOO MANY POINTS.";
<p></p>
ME(N) = OLDP(B); ME = ME ROW 1:N; MT = MT ROW 1:N; MB = MB ROW = 1:(N-1);
SME = MESH(MT,MT)&amp;'ROTATE(MESH(ME,ME),1); DELETE SME ROW (1,N+N);
<p></p>
ME = MT&amp;'ME; MF = POINTS(F,MT);
"MB IS THE DELTA-MODULATION BIT-VECTOR, MF IS THE SAMPLED SIGNAL POINTS, ME IS
THE ESTIMATED SIGNAL POINTS, AND SME IS THE STEP-FUNCTION ESTIMATE.";
<p></p>
</pre>
<P>
<a href="#rl1">Back to Article</A>
</P>

<HR><I>Copyright &copy; 1998, Dr. Dobb's Journal</I><BR>

</BODY>
</html>
