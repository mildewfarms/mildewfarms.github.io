<html><head><title>Dr. Dobb's Journal August 1998: C Preprocessing With Tcl</title></head><body bgcolor="FFFFFF"><!--Copyright &#169; Dr. Dobb's Journal--><h1>C Preprocessing With Tcl</h1><p><i>Dr. Dobb's Journal</i> August 1998</p><h2>Sophisticated compile- time preprocessing</h2><h3>By Jonathan S. Arney</h3><I>Jonathan is a software engineer for AT&amp;T. You can reach him via e-mail at jarney@primenet.com.</I><hr><p>Traditionally, the C preprocessor (CPP) has been used to create macros and define constants in C programs. However, the C preprocessor cannot perform more complex compile-time operations such as unrolling a <i>while</i> loop.</p><p>The obvious solution is to use a preprocessing language that is more sophisticated than the traditional CPP. In this article, I'll introduce C pretty darn quick  (CPDQ), a utility that uses Tcl (Tool Control Language) to allow more sophisticated preprocessing than the traditional CPP.</p><h3>The CPDQ Preprocessor</h3><p>Tcl is a simple shell scripting language. A C API is available, making it easy to extend the language and embed the interpreter into other applications. The language itself is similar to other familiar shell languages in that it allows for setting variables, echoing them to an output device, and creating shell functions.</p><p><A NAME="re1"><A HREF="9808fe1.htm">Example 1</A>(a) is a script that sets the variable <i>a</i> to the value <i>abcdefg,</i> then echos that variable to standard output. <A HREF="9808fe1.htm">Example 1</A>(b) shows a function built with Tcl. Tcl also supports more sophisticated functions such as a TCP/IP interface and a comprehensive set of math functions.</p><p>The CPDQ preprocessor lets you write complex compile-time macros in Tcl. CPDQ consists of a simple parser that recognizes a delimiter (in this case, <i>#$</i>), and interprets the delimited code. Because the code interpretation is delegated to the Tcl libraries, the source code is short -- only 70 or so lines of C source code (see <A NAME="rl1"><A HREF="9808f.htm#l1">Listing One</A>). Compiling CPDQ requires linking in the Tcl libraries. You should consult Tcl documentation for information on how to compile programs using the Tcl libraries for your particular platform.</p><h3>A Simple Example</h3><p>CPDQ is used the same way any other UNIX-style filter is used. It reads from the standard input and writes to the standard output. The utility requires no command-line flags, start-up scripts, or RC files.</p><p>Using CPDQ is simple. Any Tcl scripts embedded into your C source code are executed at compile time. You can then compile the generated C source code just as you normally would.</p><p><A NAME="re2"><A HREF="9808fe2.htm">Example 2</A>(a) is a sample input file for use by CPDQ. The first line consists of a script delimiter that indicates the start of a Tcl script. Next, the value of <i>include_file</i> is set to <i>&lt;stdio.h&gt;</i>. The script then prints the value of <i>include_file</i> to standard output. The remainder of the file is left untouched by CPDQ and is printed to standard output, producing the code in <A HREF="9808fe2.htm">Example 2</A>(b) -- the familiar "Hello World" C program.</p><p>Because of the way in which the <i>#$</i> delimiter is parsed, the CPDQ utility will choke on C programs containing the literal <i>#$</i> string. Make sure that the <i>#$</i> string does not exist in your source code except where used as a CPDQ delimiter.</p><h3>Lookup Tables</h3><p>One possible use for CPDQ is implementing lookup tables. You may want to implement the cosine function, for example, as a lookup table when performance is an issue. However, placing the values in a lookup table by hand can be painstaking, and the size of the lookup table may make it difficult to maintain.</p><p><A NAME="re3"><A HREF="9808fe3.htm">Example 3</A>(a) is an implementation of a cosine lookup table. The script first declares a variable to hold the values in the lookup table, then populates it with the values of cosine from zero to 180 degrees. Next, a function is created for the purpose of looking up these values in the table. The final step is to embed the shell function in a program for calculating the values of cosine. CPDQ generates the code in <A HREF="9808fe3.htm">Example 3</A>(b).</p><h3>Generic Data Structures</h3><p><A NAME="rl2"><A HREF="9808f.htm#l2">Listing Two</A> presents a linked list implemented in C with a generic API that may be used regardless of the stored data type. However, there are certain drawbacks. In particular, the generic linked list in C does not handle compile-time typechecking, and it requires typecasting and a run-time data element size. All of these problems stem from the use of a generic pointer (<i>void</i> *) to store the data.</p><p>Compile-time typechecking notifies you of any inconsistencies in the way that data is used. Because <A HREF="9808f.htm#l2">Listing Two</A> uses a generic pointer to contain data, compile-time typechecking is impossible. If you use the wrong data type, the compiler will not inform you. This makes debugging more difficult, particularly when several linked lists containing different data types are used in the same routine.</p><p>Typecasting, which lets you define data of one type and use it as if it were another type, is the usual method for overriding generic pointers. <i>append()</i> and <i>walk()</i> in <A HREF="9808f.htm#l2">Listing Two</A> show the proper casting in this particular application. If you cast incorrectly, the compiler has no way of notifying you of the error.</p><p>Also, because of the generic data pointer, you must specify the size of the data, and the linked list must store this size along with the data to function properly. The "size" data pertaining to the contents of the list produces unwanted overhead in the linked list, and the additional housekeeping requirement increases the possibility of error.</p><p><A NAME="rl3"><A HREF="9808f.htm#l3">Listing Three</A> addresses the aforementioned concerns by implementing a linked list using CPDQ macros. For clarity, <A HREF="9808f.htm#l4">Listing Four</A> is the result of compiling <A HREF="9808f.htm#l3">Listing Three</A> using CPDQ.</p><p>First, rather than define a single linked-list data type using a generic pointer to store data, <A HREF="9808f.htm#l3">Listing Three</A> creates a specific linked-list implementation for each data type you want to store. Hence, the compiler can typecheck the linked list. Typecasting is no longer required, because the CPDQ macros automatically declare data of the appropriate type. Finally, the size of the list's contents is implicit in the declaration of the list. This removes the need for run-time data pertaining to data size, and removes unwanted data overhead.</p><p>One drawback of using CPDQ macros to implement the linked list is that the generated code gets bigger each time a new type of list is introduced. This is because every list that contains a unique data type causes the creation of a new type declaration and set of function calls to handle it.</p><h3>Conclusion</h3><p>Applications that are computationally intensive can benefit from these techniques by performing calculations at compile time rather than at run time. Using Tcl to implement these compile-time calculations keeps coding and maintenance times small, while generating efficient applications. Using Tcl as a preprocessor also lets you implement generic data structures and algorithms that are typesafe and efficient without having to invest significantly more programming time or maintenance. </p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>#include &lt;tcl.h&gt;#define modeCC		1#define modeCPDQ	2#define BUFFER_SIZE	512<p></p>char *read_to_delimiter(FILE *f, char *delimiter);int main(int argc, char **argv){	Tcl_Interp	*interp;	char	*s;	int	mode = modeCC;	FILE	*f,*fout;	f = stdin;	fout = stdout;	interp = Tcl_CreateInterp();	while (1) {		s = read_to_delimiter(f, "#$");		if (!*s) break;		switch (mode) {			case modeCC:				fputs(s, fout);				mode = modeCPDQ;				break;			case modeCPDQ:				if (Tcl_Eval(interp, s) != TCL_OK) {					fprintf(stderr, "%s\n", interp-&gt;result);					exit(2);				}				mode = modeCC;				break;		}		free(s);		fflush(fout);	}	Tcl_DeleteInterp(interp);}char *read_to_delimiter(FILE *f, char *delimiter){	char	*str, *ret;	len = BUFFER_SIZE;	ptr = 0;	ret = str = (char *)malloc(sizeof(char) * len);	i = 0;	while (1) {		*str = fgetc(f);		if (feof(f)) break;		if (*str == delimiter[i]) i++;		else i = 0;		if (delimiter[i] == '\0') {			str -= strlen(delimiter)-1;			break;		}		str++; ptr++;		if (ptr == len) {			len += BUFFER_SIZE;			str = (char *)realloc(ret, sizeof(char) * len);		}	}	*str = '\0';	return ret;}</pre><P><A HREF="#rl1">Back to Article</A></P><h4><A NAME="l2">Listing Two</h4><pre>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;struct list {	void	*data;	int	size;	struct list *next;	struct list *current_walk;};static struct list *allocate(void){	return (struct list *)malloc(sizeof(struct list));}struct list *open(int size){	struct list *newlist;	newlist = allocate();	newlist-&gt;size = size;	newlist-&gt;next = NULL;	return newlist;}int append(struct list *list, void *data){	struct list	*current_walk;	current_walk = list;	while (current_walk-&gt;next)		current_walk = current_walk-&gt;next;	current_walk-&gt;data = malloc(list-&gt;size);	memcpy(current_walk-&gt;data, data, list-&gt;size);	current_walk-&gt;next = allocate();	current_walk = current_walk-&gt;next;	current_walk-&gt;next = NULL;}int rewind(struct list *list){	list-&gt;current_walk = list;}void *walk(struct list *list){	void *temp_ptr;	temp_ptr = list-&gt;current_walk-&gt;data;	list-&gt;current_walk = list-&gt;current_walk-&gt;next;	return list-&gt;current_walk ? temp_ptr : NULL;}/* * Declare normal C data structure. */struct data_type_st {	char	last[30];	char	first[30];	char	grade[2];};int main(int argc, char **argv){	/*	 * Instantiate a list of structures.	 */	struct list *list_head;	struct data_type_st data;	struct data_type_st	*ptr;	/*	 * Open the list.	 */	list_head = open(sizeof(struct data_type_st));	/*	 * Append some data to the list.	 */	strcpy(data.first, "Laura");	strcpy(data.last, "Long");	strcpy(data.grade "A");	append(list_head, (void *)&amp;data);	strcpy(data.first, "Tom");	strcpy(data.last, "Novack");	strcpy(data.grade "D");	append(list_head, (void *)&amp;data);	strcpy(data.first, "Jason");	strcpy(data.last, "Steiner");	strcpy(data.grade "A");	append(list_head, (void *)&amp;data);	/*	 * Rewind the list to the top.	 */	rewind(list_head);	/*	 * Walk through the list and display the data from it.	 */	while (ptr = (struct data_type_st *)walk(list_head)) {		printf("Last Names %s\n", ptr-&gt;last);	}}</pre><P><A HREF="#rl2">Back to Article</A></P><h4><A NAME="l3">Listing Three</h4><pre>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#$############################################################################ Generic C interface macros.###########################################################################proc code {thing} {	puts stdout "$thing"}proc __get_type_id {type_name} {	set type_id ""	foreach i $type_name {		set type_id "$type_id\_$i"	}	return $type_id}set _type_lookup(0) ""proc __type_of {var_name} {	global	_type_lookup	return $_type_lookup($var_name);}proc __set_type {var_name type} {	global _type_lookup	set _type_lookup($var_name) $type}############################################################################ Define structure for list type.# and create the functions to work with it.###########################################################################proc list_def {type_name} {	set type_id [__get_type_id $type_name]	set list_type __list$type_id	code "struct $list_type {"	code "	$type_name		data;"	code "	struct $list_type	*next;"	code "	struct $list_type	*current_walk;"	code "};"	code ""	code "static struct $list_type *allocate$type_id\(void)"	code "{"	code "	return (struct $list_type *)malloc(sizeof(struct $list_type));"	code "}"	code ""	code "struct $list_type *open$type_id\(void)"	code "{"	code "	struct $list_type	*newlist;"	code "	newlist = allocate$type_id\();"	code "	newlist-&gt;next = NULL;"	code "	return newlist;"	code "}"	code ""	code "int append$type_id\(struct $list_type *list, $type_name *data)"	code "{"	code "	struct $list_type	*current_walk;"	code "	current_walk = list;"	code "	while (current_walk-&gt;next)"	code "		current_walk = current_walk-&gt;next;"	code "	memcpy(&amp;current_walk-&gt;data, data, sizeof($type_name));"	code "	current_walk-&gt;next = allocate$type_id\();"	code "	current_walk = current_walk-&gt;next;"	code "	current_walk-&gt;next = NULL;"	code "}"	code ""	code "int rewind$type_id\(struct $list_type *list)"	code "{"	code "	list-&gt;current_walk = list;"	code "}"	code ""	code "$type_name *walk$type_id\(struct $list_type *list)"	code "{"	code "	$type_name *temp_ptr;"	code "	temp_ptr = &amp;list-&gt;current_walk-&gt;data;"	code "	list-&gt;current_walk = list-&gt;current_walk-&gt;next;"	code "	return list-&gt;current_walk ? temp_ptr : ($type_name *)0;"	code "}"}############################################################################ List open function###########################################################################proc open {list} {	set type_id [__get_type_id [__type_of $list]]	code "$list = open$type_id\();"}############################################################################ List rewind function.###########################################################################proc rewind {list} {	set type_id [__get_type_id [__type_of $list]]	code "rewind$type_id\($list);"}############################################################################ List append function.###########################################################################proc append {list data} {	set type_id [__get_type_id [__type_of $list]]	code "append$type_id\($list, $data);"}# List walk function###########################################################################proc walk {list ptr} {	set type_id [__get_type_id [__type_of $list]]	code "ptr = walk$type_id\($list)"}############################################################################ List declaration###########################################################################proc list_decl {type list} {	set type_id [__get_type_id $type]	__set_type $list $type	code "struct __list$type_id	*$list;"}#$/* * Declare normal C data structure. */struct data_type_st {	char	last[30];	char	first[30];	char	grade[2];};#$############################################################################ Define a list of structures.###########################################################################list_def "struct data_type_st"#$int main(int argc, char **argv){	/*	 * Instantiate a list of structures.	 */	#$list_decl "struct data_type_st"	list_head#$	struct data_type_st data;	struct data_type_st	*ptr;	/*	 * Open the list.	 */	#$open list_head#$	/*	 * Append some data to the list.	 */	strcpy(data.first, "Lee");	strcpy(data.last, "Hall");	strcpy(data.grade "A");	#$append list_head &amp;data#$	strcpy(data.first, "John");	strcpy(data.last, "DeRaedt");	strcpy(data.grade "A");	#$append list_head &amp;data#$	strcpy(data.first, "Thom");	strcpy(data.last, "Suplica");	strcpy(data.grade "A");	#$append list_head &amp;data#$	/*	 * Rewind the list to the top.	 */	#$rewind list_head#$	/*	 * Walk through the list and display the data from it.	 */	while (#$walk list_head ptr#$) {		printf("Last Names %s\n", ptr-&gt;last);	}}</pre><P><A HREF="#rl3">Back to Article</A></P><h4><A NAME="l4">Listing Four</h4><pre>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;/* * Declare normal C data structure. */struct data_type_st {	char	last[30];	char	first[30];	char	grade[2];};struct __list_struct_data_type_st {	struct data_type_st		data;	struct __list_struct_data_type_st	*next;	struct __list_struct_data_type_st	*current_walk;};static struct __list_struct_data_type_st *allocate_struct_data_type_st(void){	return (struct __list_struct_data_type_st *)malloc(sizeof(struct __list_struct_data_type_st));}struct __list_struct_data_type_st *open_struct_data_type_st(void){	struct __list_struct_data_type_st	*newlist;	newlist = allocate_struct_data_type_st();	newlist-&gt;next = NULL;	return newlist;}int append_struct_data_type_st(struct __list_struct_data_type_st *list, struct data_type_st *data){	struct __list_struct_data_type_st	*current_walk;	current_walk = list;	while (current_walk-&gt;next)		current_walk = current_walk-&gt;next;	memcpy(&amp;current_walk-&gt;data, data, sizeof(struct data_type_st));	current_walk-&gt;next = allocate_struct_data_type_st();	current_walk = current_walk-&gt;next;	current_walk-&gt;next = NULL;}int rewind_struct_data_type_st(struct __list_struct_data_type_st *list){	list-&gt;current_walk = list;}struct data_type_st *walk_struct_data_type_st(struct __list_struct_data_type_st *list){	struct data_type_st *temp_ptr;	temp_ptr = &amp;list-&gt;current_walk-&gt;data;	list-&gt;current_walk = list-&gt;current_walk-&gt;next;	return list-&gt;current_walk ? temp_ptr : (struct data_type_st *)0;}int main(int argc, char **argv){	/*	 * Instantiate a list of structures.	 */	struct __list_struct_data_type_st	*list_head;	struct data_type_st data;	struct data_type_st	*ptr;	/*	 * Open the list.	 */	list_head = open_struct_data_type_st();	/*	 * Append some data to the list.	 */	strcpy(data.first, "Lee");	strcpy(data.last, "Hall");	strcpy(data.grade "A");	append_struct_data_type_st(list_head, &amp;data);	strcpy(data.first, "John");	strcpy(data.last, "DeRaedt");	strcpy(data.grade "A");	append_struct_data_type_st(list_head, &amp;data);	strcpy(data.first, "Thom");	strcpy(data.last, "Suplica");	strcpy(data.grade "A");	append_struct_data_type_st(list_head, &amp;data);	/*	 * Rewind the list to the top.	 */	rewind_struct_data_type_st(list_head);	/*	 * Walk through the list and display the data from it.	 */	while (ptr = walk_struct_data_type_st(list_head)) {		printf("Last Names %s\n", ptr-&gt;last);	}}</pre><P><A HREF="#rl4">Back to Article</A></P><HR><I>Copyright &copy; 1998, Dr. Dobb's Journal</I><BR>
</body></html>