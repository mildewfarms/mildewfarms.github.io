<html><head><title>Dr. Dobb's Journal August 1998: Plug-In Components for MFC</title></head><body bgcolor="FFFFFF"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Plug-In Components for MFC</h1><p><i>Dr. Dobb's Journal</i> August 1998</p><h2>Adding power and flexibility to MFC</h2><h3>By Stefan Hoenig</h3><I>Stefan is software architect at Stingray Software, a division of Rogue Wave Software, and author of Objective Grid, a grid extension for MFC. He can be contacted at stefan@stingray.com.</I><hr><p>Microsoft's Developer Studio is an integrated development environment that supports the creation of Windows applications with MFC. The ClassWizard tool lets you add a message handler for any window message to a derived window class. This gives you a degree of flexibility not possible in the Windows SDK. In the SDK, you had to specify a callback function for a window and filter out windows messages through a switch statement. ClassWizard and MFC message maps provide a type-safe, robust, and easy way to handle window messages. (MFC message maps let you designate which functions in a particular class will handle various messages for events like keystrokes or mouse clicks. Message maps contain one or more macros that specify which messages will be handled by which functions in a class. Message maps are tightly coupled with ClassWizard. ClassWizard automatically creates message-map entries in source files when you use it to associate message-handling functions with messages.)</p><p>However, MFC has its limitations when it comes to encapsulating different window functionality into separate objects. When you program with MFC, you often have to implement different window actions based on user events. For example, when a user presses a mouse button, the MFC window is set into a special context. In subsequent mouse messages, you check the context of the window and give graphical feedback to the user based on the mouse movements. Once the user releases the mouse button, you reset the window context and perform the user-specified action. Suppose you want to add support for more user actions. The easiest way is to add <i>if</i> statements for each context in your message handlers. However, this approach has a severe disadvantage: Each event handler is responsible for handling a variety of actions that are not related to each other. In short, it ignores encapsulation.  </p><p>Clearly, you want to avoid <i>if</i> statements and provide individual objects for each user action. In this article, I'll present an approach for encapsulating user actions into separate objects that support MFC message maps. These special objects, which I call "plug-in components," can be reused among different window and view objects without code duplication. For the purposes of illustration, I include a reusable MFC class called <i>CDDJIntelliMousePlugin</i> that can be attached to any <i>CWnd</i> or <i>CView</i> class. <i>CDDJIntelliMousePlugin</i> provides support for intelli-mouse scrolling, zooming, and panning. Code changes in the component source code are not necessary to use its functionality with different window and view classes.</p><h3>Existing Approaches</h3><p>While there are existing approaches that encapsulate user actions into separate objects and do not use <i>if</i> statements, these solutions lack support for the MFC message map. Consequently, most MFC developers avoid these approaches. </p><p>One approach is to add message handlers to the window class and forward each of these messages to the attached component object that is responsible for handling the user actions. <A NAME="rl1"><A HREF="9808k.htm#l1">Listing One</A> emonstrates how to delegate the WM_MOUSEMOVE message to an attached object.</p><p>The disadvantage of this approach is obvious. There is a tight coupling between the window class and user action component. Whenever you need to process a new message in the component, you have to add a message handler in the parent window class and forward it to the component. You might try to solve the problem by providing predefined message handlers for each window message, but this approach has the disadvantage that it results in a large number of messages, few of which will be used. </p><p>Another approach is to override the <i>WindowProc</i> method (entry point for all window messages sent to a window). In the overridden method, you can forward each window message to the attached user action component object. In the attached component, you implement a <i>switch</i> statement that provides handlers for the window messages you want to handle. <A NAME="rl2"><A HREF="9808k.htm#l2">Listing Two</A> is a typical event handler.</p><p>This approach lets you add messages in the user action component without changing the parent window class. However, it is a step backwards, akin to early C-like Windows SDK development in that it requires you to decode the WPARAM and LPARAM parameters into useful information. After decoding a few of these parameters, you'll wish you could still use the ClassWizard to add new messages.</p><h3>The Plug-in Approach </h3><p>An alternative to these techniques is the plug-in approach. To implement this approach, I had to:</p><ul><li>Determine one point of entry for searching the MFC message map and dispatching any window messages to the correct message handler in a derived class.  <li>Ensure that source code for user actions in existing window classes can be reused without making major changes.   <li>Avoid redundant calls to the default window procedure. Only the parent window object should call this method. </ul><p>To accomplish this, I had to deal with message dispatching. MFC message dispatching is implemented by <i>CWnd</i>'s <i>OnWndMsg</i> member function. <i>OnWndMsg</i> searches the window's message map and calls the correct message handler in a derived class. <i>OnWndMsg</i> correctly dispatches messages whether or not a valid window handle is attached to the <i>CWnd</i> object. <i>OnWndMsg</i> is completely independent of the <i>CWnd</i>'s <i>m_hWnd</i> attribute. It works correctly even if you've never called <i>CWnd::Create</i>. </p><p>With this knowledge, I could derive the plug-in component base class from <i>CWnd</i>. The entry point for window messages is the plug-in component's <i>HandleMessage</i> method.</p><p><A NAME="rl3"><A HREF="9808k.htm#l3">Listing Three</A> implements <i>HandleMessage</i>. The method calls the protected <i>CWnd::OnWndMsg</i> member that then searches the message map and calls the correct message handler. <A NAME="rl4"><A HREF="9808k.htm#l4">Listing Four</A> shows how messages are forwarded from the parent window class to the plug-in component. <i>m_pPlugin</i> is a pointer to a plug-in component object.</p><h3>Reuse of Existing Code</h3><p><i>CWnd</i> is a thin wrapper class for a window handle and provides member functions that rely on the <i>m_hWnd</i> attribute. For example, <i>CWnd::Invalidate</i> is a wrapper to the equivalent Windows SDK method and passes <i>m_hWnd</i> as a window handle. The member function is declared as an inline method in afxwin.inl (an MFC header file) as shown in <A NAME="rl5"><A HREF="9808k.htm#l5">Listing Five</A>. Other <i>CWnd</i> member functions are implemented in exactly the same way. If you port existing code to a plug-in component and call a <i>CWnd</i> member function, your application would assert if <i>m_hWnd</i> is not a valid window handle. To solve this problem, I needed to provide a valid window handle for the plug-in component's <i>m_hWnd</i> attribute. To do so, I had to take into consideration that <i>CWnd::OnWndMsg</i> disregards the value of the <i>m_hWnd</i> attribute so I can assign any value to it. Also, a plug-in component is not a real window object. The plug-in component should operate directly on the parent window object. It receives the same messages that the parent window object receives, and any window operations that are executed in the plug-in component need to affect the parent window.</p><p>Assigning the parent's window handle to the plug-in component's <i>m_hWnd</i> attribute is the ideal solution. Using the parent's window handle lets you port existing code to a plug-in component without changing any existing calls to <i>CWnd</i> member functions. All <i>CWnd</i> member functions now operate directly on the parent window.</p><p>You may question the legality of assigning the same window handle to different <i>CWnd</i> objects. In the case of <i>CWnd::Attach</i>, you cannot assign the same window handle to different <i>CWnd </i>objects. If you try to do this, MFC will assert. Internally, MFC allows one window object for each window handle. The window handles and <i>CWnd</i> objects are maintained in the window handle map. However, the plug-in approach does not require you to call <i>CWnd::Attach</i>. Instead, you only assign the window handle to <i>m_hWnd</i>, which is safe. However, be aware that whenever you call <i>CWnd::FromHandle(m_hWnd)</i>, MFC returns a pointer to the parent <i>CWnd</i> object because this is the window that is registered in the MFC window handle map.</p><h3>Default Window Procedure</h3><p>Recall that another requirement is to avoid redundant calls to the default window procedure of the parent window. The solution is to override the virtual <i>DefWindowProc</i> method for the plug-in component class and return immediately; see <A NAME="rl6"><A HREF="9808k.htm#l6">Listing Six</A>. Then, only the parent window is calling the default window procedure.</p><h3>The <i>CDDJPluginComponent</i> Class</h3><p>The <i>CDDJPluginComponent</i> class is the resulting base class for plug-in components (CDDJPluginComponent is available electronically; see "Resource Center," page 3). <A NAME="rl7"><A HREF="9808k.htm#l7">Listing Seven</A> shows the declaration of the <i>CDDJPluginComponent</i> class, and <A NAME="rl8"><A HREF="9808k.htm#l8">Listing Eight</A> shows its implementation. Here's an overview of the member functions and attributes:</p><ul><li><i>Plugin</i>. Call this method to attach the component to a window object. It assigns the window handle to the plug-in component's <i>m_hWnd</i> attribute.   <li><i>m_bExitMessage</i>. If you set <i>m_bExitMessage</i> to True, the window procedure returns after the plug-in component has processed the message. The source code for <i>WindowProc</i> (<A HREF="9808k.htm#l4">Listing Four</A>) illustrates how to process this attribute in the override of the <i>WindowProc</i> method in your parent window class.  <li><i>m_bSkipOtherPlugins</i>. Use this attribute to coordinate several plug-ins. If you want to attach several plug-ins to a window object, check this attribute in the <i>WindowProc</i> method of the parent window class.</ul><h3>Using the Plug-in Approach</h3><p>To illustrate how to use the plug-in approach, I describe the steps for implementing an "auto-scroll" component which checks whether users press the left mouse button. In response to this event, a timer starts and WM_VSCROLL messages are sent to the parent window. When a user moves the mouse up or down, the parent window scrolls in the given direction. Once the user releases the mouse button, the timer is killed and the auto-scroll operation ends. Other events (such as the WM_CANCELMODE message or pressing Esc) also stop the operation. The component can be reused and attached to any view or window class without changing its source code.</p><p>To implement the auto-scroll component:</p><ol><li>You create the MFC AppWizard and derive the view class from <i>CScrollView</i>. Name the view class <i>CMyView</i> (an implementation of <i>CMyView</i> is available electronically). After you generate the project, enlarge the scroll range specified in <i>OnInitialUpdate</i>. For example:  <blockquote><pre>CSize sizeTotal;sizeTotal.cx = sizeTotal.cy = 15000;SetScrollSizes(MM_TEXT, sizeTotal);</pre></blockquote><i>CDDJPluginComponent</i> is implemented in ddjplgin.h and ddjplgin.cpp (<A HREF="9808k.htm#l7">Listings Seven</A> and <A HREF="9808k.htm#l8">Eight</A>). Add ddjplgin.cpp to your project. In the stdafx.h file, include "ddjplgin.h."<br><br><li>Next, create the <i>CAutoScrollPlugin</i> class. Use ClassWizard to derive a class from a generic <i>CWnd</i> and name it <i>CAutoScrollPlugin</i>. After generating the class, you can derive it from <i>CDDJPluginComponent</i>. To do this, edit the header and implementation file and replace all occurrences of <i>CWnd</i> with <i>CDDJPluginComponent</i>. If you remove the existing ClassWizard (.clw) file from the project directory and press Ctrl-W, the ClassWizard file is regenerated. You can then add message handlers to the <i>CAutoScrollPlugin</i> class with ClassWizard. The final implementation of the <i>CAutoScrollPlugin</i> component is available electronically.<br><br>  <li>The next step is to add a pointer to the plug-in object in your view class. To do this, add a pointer in the class declaration:<blockquote><pre>class CMyView: public CScrollView{    ...   CDDJPluginComponent* m_pPlugin;</pre></blockquote>In myview.cpp, instantiate the auto-scroll component and call its <i>Plugin</i> method in the <i>OnInitialUpdate</i> routine:<pre><blockquote>m_pPlugin = new CAutoScrollPlugin;m_pPlugin-&gt;PlugIn(this);</blockquote></pre>Don't forget to include the header file for the <i>CAutoScrollPlugin</i> class in myview.cpp. Finally, override <i>WindowProc</i> and call the <i>HandleMessage</i> method of the plug-in component. </ul><h3>The Intelli-Mouse Example</h3><p>A real-world example for using this approach is the reusable <i>CDDJIntelliMousePlugin</i> component that can be attached to any <i>CWnd</i> or <i>CView</i> class. The implementation is similar to Microsoft Excel and Internet Explorer 4.0. The following features are provided:</p><ul><li>Scrolling by rolling the mouse wheel.  <li>Scroll horizontally by clicking Shift and rolling the mouse wheel.  <li>Zoom in and out by clicking Ctrl and rolling the mouse wheel.  <li>Auto-scrolling by clicking the mouse-wheel button, then dragging the mouse up, down, to the left, or to the right.  <li>Click-lock for the mouse-wheel button: Click and hold down the mouse button for a moment to lock your click. With click-lock, you can scroll easily by simply dragging the mouse. Its functionality is identical to auto-scroll, except you don't need to hold the mouse-wheel button. Click again to release click-lock. </ul><p>The <i>CDDJIntelliPlugin</i> class integrates in any advanced view that processes a lot of window messages. <A NAME="rf1"><A HREF="9808kf1.htm">Figure 1</A> shows the final <i>CDDJIntelliPlugin</i> intelli-mouse panning support at work in a grid view. The implementation of the intelli-mouse plug-in component is available electronically.</p><h3>Conclusion</h3><p>In this article, I presented a completely new approach for encapsulating window functionality into different objects. I was really excited when I discovered how easily this new approach can be implemented with MFC. It also made me wonder why the MFC team had never considered such a solution. Once I perfected the plug-in approach, I couldn't help but think of how the architectures of my past projects would have differed if I had known about this technique. At Stingray, we use this technique to produce granular and user-friendly components. This approach lets our library users plug only the functionality they need into derived window classes; any unused functionality does not need to be linked into the application, dramatically decreasing application size. </p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>void CMyView::OnMouseMove(UINT nFlags, CPoint point) {// forward this event to an attached objectm_pObject-&gt;OnMouseMove(nFlags, point);CView::OnMouseMove(nFlags, point);}</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>void CUserActionComponent::HandleMessage(UINT nMessage, WPARAM wParam, LPARAM lParam){    switch (nMessage)    {    case WM_MOUSEMOVE:        OnMouseMove(wParam, CPoint(LOWORD(lParam), HIWORD(lParam));        break;    }}}</pre><P><A HREF="#rl2">Back to Article</A></P><H4><A NAME="l3">Listing Three</H4><pre>BOOL CDDJPluginComponent::HandleMessage(UINT message, WPARAM wParam,                                         LPARAM lParam, LRESULT* pResult){    m_bSkipOtherPlugins = FALSE;    m_bExitMesssage = FALSE;    return CWnd::OnWndMsg(message, wParam, lParam, pResult);}</pre><P><A HREF="#rl3">Back to Article</A></P><H4><A NAME="l4">Listing Four</H4><pre>LRESULT CMyView::WindowProc(UINT message, WPARAM wParam, LPARAM lParam) {    if (m_pPlugin)    {        LRESULT lResult;m_pPlugin-&gt;HandleMessage(message, wParam, lParam, &amp;lResult);        if (m_pPlugin-&gt;m_bExitMesssage)            return lResult;    }    return CScrollView::WindowProc(message, wParam, lParam);}</pre><P><A HREF="#rl4">Back to Article</A></P><H4><A NAME="l5">Listing Five</H4><pre>_AFXWIN_INLINE void CWnd::Invalidate(BOOL bErase)    { ASSERT(::IsWindow(m_hWnd)); ::InvalidateRect(m_hWnd, NULL, bErase); }</pre><p><A HREF="#rl5">Back to Article</A></p><H4><A NAME="l6">Listing Six</H4><pre>LRESULT CDDJPluginComponent::DefWindowProc(UINT message, WPARAM wParam, LPARAM lParam){    // do nothing - this makes sure that calls to Default() will have no     // effect (and thus make sure that the same message is not process twice).    return 0;}</pre><P><A HREF="#rl6">Back to Article</A></P><H4><A NAME="l7">Listing Seven</H4><pre>// ddjplgin.h : interface of the CDDJPluginComponent class#ifndef _DDJPLGIN_H_#define _DDJPLGIN_H_class CDDJPluginComponent: public CWnd{    DECLARE_DYNAMIC(CDDJPluginComponent);public:    CDDJPluginComponent();    BOOL PlugIn(CWnd* pParentWnd);    virtual ~CDDJPluginComponent();public:    // Attributes     // Reserved for later usage with a PluginManager    BOOL m_bSkipOtherPlugins; // set to TRUE from within message handler if                                  // no other plugins should be                                  // called for this message    BOOL m_bExitMesssage;     // set to TRUE from within your message handler                                 // if no other plugins and also not the                                  // default window message should be called// Generated message map functionsprotected:    //{{AFX_MSG(CDDJPluginComponent)    //}}AFX_MSG    DECLARE_MESSAGE_MAP()public:    // for processing Windows messages    BOOL HandleMessage(UINT message, WPARAM wParam,                                    LPARAM lParam, LRESULT* pResult);protected:    // for handling default processing    virtual LRESULT DefWindowProc(UINT message, WPARAM wParam, LPARAM lParam);#ifdef _DEBUG    virtual void AssertValid() const;    virtual void Dump(CDumpContext&amp; dc) const;#endif};#endif //_DDJPLGIN_H_</pre><P><A HREF="#rl7">Back to Article</A></P><H4><A NAME="l8">Listing Eight</H4><pre>// ddjplgin.cpp : implementation of the CDDJPluginComponent class#include "stdafx.h"#include "resource.h"<p></p>#include "ddjplgin.h"<p></p>#ifdef _DEBUG#undef THIS_FILEstatic char BASED_CODE THIS_FILE[] = __FILE__;#endif<p></p>IMPLEMENT_DYNAMIC(CDDJPluginComponent, CWnd);<p></p>CDDJPluginComponent::CDDJPluginComponent(){    m_bSkipOtherPlugins = FALSE;    m_bExitMesssage = FALSE;}CDDJPluginComponent::~CDDJPluginComponent(){    // make sure Detach won't get called    m_hWnd = NULL;}BEGIN_MESSAGE_MAP(CDDJPluginComponent, CWnd)    //{{AFX_MSG_MAP(CDDJPluginComponent)    //}}AFX_MSG_MAPEND_MESSAGE_MAP()BOOL CDDJPluginComponent::PlugIn(CWnd* pParentWnd){    m_hWnd = pParentWnd-&gt;GetSafeHwnd();    return TRUE;}BOOL CDDJPluginComponent::HandleMessage(UINT message, WPARAM wParam,                                          LPARAM lParam, LRESULT* pResult){    m_bSkipOtherPlugins = FALSE;    m_bExitMesssage = FALSE;#if _MFC_VER &gt;= 0x0400    return CWnd::OnWndMsg(message, wParam, lParam, pResult);#else    *pResult = CWnd::WindowProc(message, wParam, lParam);    return TRUE;#endif}LRESULT CDDJPluginComponent::DefWindowProc(UINT message,                                            WPARAM wParam, LPARAM lParam){  // do nothing - this makes sure that calls to Default() will have no effect  // (and thus make sure that the same message is not process twice).  // Unused:    message, wParam, lParam;    return 0;}#ifdef _DEBUGvoid CDDJPluginComponent::AssertValid() const{    if (m_hWnd == NULL)        return;     // null (unattached) windows are valid    // should be a normal window    ASSERT(::IsWindow(m_hWnd));    // Regular CWnd's check the permanent or temporary handle map and compare    // the pointer to this. This will fail for a CDDJPluginComponent because     // several Plugin objects share the same HWND. Therefore we must not    // call CWnd::AsssertValid.}void CDDJPluginComponent::Dump(CDumpContext&amp; dc) const{    dc &lt;&lt; "PluginComponent";    // It is safe to call CWnd::Dump    CWnd::Dump(dc);}#endif</pre><P><A HREF="#rl8">Back to Article</A></P><HR><I>Copyright &copy; 1998, Dr. Dobb's Journal</I><BR>
</body></html>