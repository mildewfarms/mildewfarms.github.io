<html><head><title>Dr. Dobb's Journal August 1998: Embedded Systems</title></head><body bgcolor="FFFFFF"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Embedded Development Compilers</h1><p><i>Dr. Dobb's Journal</i> August 1998</p><h2>The right tool for the job</h2><h3>By Don Hair and Cesar Quiroz</h3><I>Don is director of compiler products for Microtec and can be reached at don_hair@mentorg.com. Cesar is Microtec's PowerPC compilers project manager and can be reached at cesar_quiroz@mentorg.com.</I><hr><p>Compilers designed for embedded application development are more than just cross compilers. Their feature sets are tailored to the development of ROMable, reentrant, and compact high-performance applications. These compilers typically offer more control of storage allocation, data alignment, structure layout, and size/performance trade-offs.</p><p>In this article, we'll examine the differences between native and embedded development systems. In the process, we'll discuss the unique features of embedded development compilers that make them different from native compilers.</p><h3>Embedded Systems</h3><p>Most of us have on occasion used a screwdriver to hammer in a nail. While we recognize that it isn't the most efficient tool in this case, it may be more readily available and it manages to do the job. However, we seek out a hammer when the task grows beyond a few nails. This is also true in embedded application development. You can get away with using a native compiler -- assuming you can match it to your system architecture -- but you quickly discover its shortcomings when developing large, complex, or deeply embedded applications.</p><p>To understand the differences between embedded and native compilers, you need to understand the differences between the systems you are designing. The term "embedded" has come to mean many things. Obviously, the microcontroller at the heart of an antilock braking system is embedded. But what about the Windows PC mounted inside a wide-bed plotter? While the latter configuration could be argued as embedded, the development needs do not match the typical scenario. Classic embedded systems generally: </p><ul><li>Are self contained and self starting.  <li>Are designed and tailored to perform a specific task.  <li>Have limited resources, especially when it comes to program storage.  <li>Are remotely deployed, making hardware and even software upgrades difficult. Many are completely isolated from any external interfaces.</ul><h3>Sections and Memory Mapping</h3><p>Embedded developers usually need control over individual data types. Embedded compilers tend to separate code, strings, constants, literals, and data (initialized or uninitialized) into individual sections. This simplifies the load ordering and locating of these data types within the system's memory map. Most compilers will also assist with even further separation by allowing you to locate individual data types from different modules in different locations. You can even specify new section names for specific data within a module.</p><p>Who needs all this? Embedded systems can incorporate many different types of memory. Consider a system that executes its main program from ROM. It also contains initialized and uninitialized data that will reside in RAM, and some configuration or setup tables stored in nonvolatile memory (NVRAM or battery backed-up CMOS RAM). Even if the system was designed so that memory appeared as one contiguous address block, your code must fit in ROM and the data in RAM. This means you must be able to place your various data in the proper locations. This is obviously easier to do if you can categorize it.</p><h3>System Startup Considerations</h3><p>This same ROM-based system has many startup implications that native application developers can safely ignore. C and C++ require initialization for global data and allow user-specified initializers. In a ROM-based system, everything with an initial value (strings, literals, constants, and initialized data) must be placed in ROM. Most of this data is read-only and can remain in ROM. Initialized data is usually the exception, as it must end up in RAM if you wish to change its initial value.</p><p>Moving initialized data into RAM is usually performed by startup code that moves this data to its final destination. However, some work must be done by the linker to ensure that references to this data are given the final run-time address location in RAM -- not the link-time or ROM location. The linker must also provide enough information to the startup code to find and copy this data to the correct location.</p><p>Additionally, the startup code must initialize the stack and heap pointers, and must know the location and size of the heap. Without the luxury of virtual memory, you have to allocate an adequate portion of the memory resource to serve as heap space. If you allocate too much, resources are wasted; too little, and the program fails at run time.</p><p>Even beyond the language requirements, a ROM-based system needs its hardware and software configuration initialized properly before it can run an application. This is true even for workstations. In fact, the boot code for a workstation is similar to the code to start an embedded system. You could even say a workstation is an embedded system at this level. It really isn't different from other embedded systems until it starts to load an operating system.</p><p>The aforementioned section-renaming capability can help with the tasks of initializing and locating interrupt vector tables. Other features such as data and bitfield alignment control make it possible to initialize I/O devices in C/C++.</p><h3>Data Alignment and Access</h3><p>Data alignment options are commonly implemented in structure layouts. This is where users expect more mapping control, since language rules enforce adherence to the relationship between data declaration and allocation ordering. </p><p>In the native world, data is aligned to simplify access by the supporting hardware, thereby maximizing performance. Additionally, committees form standardized interfaces to enable the sharing of binary objects within a system. These application binary interfaces (ABIs) regulate such things as object module format, register use and parameter passing, and data alignment.</p><p>ABIs also exist in the embedded world, often in modified form to reduce memory requirements. Still, embedded designers want more flexibility in data alignment. They often need to match the data layout to specific hardware requirements in order to share data between different CPU architectures, to directly map to hardware registers, to preserve existing formats when migrating old software, or simply to save space.</p><p>There are a couple of extensions (on top of standard C) worth noting in <A NAME="rl1"><A HREF="9808h.htm#l1">Listing One</A> First, the <i>packed</i> keyword is used by some compilers to indicate that the structure should not contain any padding for alignment. Second, the use of <i>char</i> and <i>short</i> types for bitfields adds flexibility in the way these bitfields are aligned and accessed.</p><p>Many desktop-development tools do not allow the use of <i>char</i> and <i>short </i>types for bitfields. Such tools would allocate 32 bits for the structure in <A HREF="9808h.htm#l1">Listing One</A>. Tools that do not support <i>packed</i> would optimize access of bitfields and might also need to allocate a padding byte between <i>field2</i> and <i>field3</i>, allowing them to align the short word on even addresses. Most desktop systems toolkits would access any field of the structure in <A HREF="9808h.htm#l1">Listing One</A> with a single byte read/modify/write operation.</p><p>With many embedded tools, each different bitfield type declaration tells the compiler to start a new allocation unit. In this case, <i>field3</i> would start in the next word (or byte if packed), even though it would fit in the current byte. This would introduce a single bit of padding between <i>field2</i> and <i>field3</i>. Bitfield types can also be used to indicate the desired memory access. For instance, any access of <i>field3</i> through <i>field7</i> should use a two-byte read/modify/write cycle, even though any of these fields can be accessed in a single byte. This allows users not only to map alignment, but also to control access to meet hardware needs. Obviously, this type of access is restricted to architectures that can handle it. Some architectures simply can't perform misaligned memory accesses.</p><p>The <i>packed</i> keyword is also useful for nonbitfield structures because it allows portability across architectures and provides space savings. In cases where the CPU architecture can perform misaligned memory accesses (such as with Motorola's 68020 and Intel's 80x86), additional compiler effort is not required beyond the necessary data allocation to access packed structures.</p><p>For architectures that can't handle misaligned memory accesses (such as Motorola's 68000 and AMD's 29000), the compiler takes one of two approaches. Some compilers attempt to analyze individual structures and determine their access requirements; misaligned accesses will be converted from single load/store operations to a series of byte and word moves. Other compilers simply perform single-byte moves whenever operating on potentially misaligned data.</p><p>For systems that produce recoverable exceptions for misaligned accesses, another possible method for handling packed structures is to generate code as if there were no alignment issues and perform corrections with an exception handler.</p><p>Consider the structure and code in <A NAME="rl2"><A HREF="9808h.htm#l2">Listing Two</A>. Code for systems that support misaligned accesses is straightforward, as shown in <A HREF="9808h.htm#l2">Listing Two</A>(b) (using Motorola 680x0 assembly syntax). Code for systems that can't support misaligned accesses can be optimized as in <A HREF="9808h.htm#l2">Listing Two</A>(c), or basically supported without optimization, as in <A HREF="9808h.htm#l2">Listing Two</A>(d). Each method has its advantage. Supporting optimized code generation for targets that don't support misaligned access becomes increasingly challenging as program complexity grows. We have not seen a compiler that can handle misaligned access for every situation.</p><p>Why? Consider <A NAME="rl3"><A HREF="9808h.htm#l3">Listing Three</A>, in which the code generated for <i>func()</i> cannot be optimal for both situations (unless it is inlined). The conservative approach would be to access members using byte moves. However, this appears to be inefficient when dealing with aligned data. Generating optimal code that uses word operations will fail when given the address of a misaligned structure. There are many cases like this. In some cases, the fact that a structure is packed or misaligned is hidden from the compiler. The result is code generation that causes exceptions at run time.</p><p>Such cases lend credibility to the run-time exception processing method. Code can be generated that is optimal for the best-case scenario, yet will still execute correctly in all other cases. The downside is the penalty paid in performance due to exception processing overhead. However, this method may actually perform better than other alternatives when faced with lots of code similar to the previous example.</p><p>Data alignment can also impact the size of global variable storage. Without some intervention, compilers typically reserve storage for globals in the order of declaration. This is more for convenience than by rule, but it can lead to a large amount of overhead to correctly align the data. The C code in <A NAME="rl4"><A HREF="9808h.htm#l4">Listing Four</A>(a) gives you the assembly code in <A HREF="9808h.htm#l4">Listing Four</A>(b) from most compilers (PowerPC syntax), which costs 16 bytes to store 11 bytes of actual data.</p><p>While 32 percent overhead is probably an extreme case, 10 to 20 percent is realistic. However, if the linker reorganized this data so that all eight-byte elements were allocated followed by four, then two, and finally one byte of data, a minimal amount of padding would be required (less than 1 percent).</p><p>Though data reorganization requires minimal overhead at link time, few linkers implement this feature. Good programming practices (ordering the data with overhead reduction in mind, for example) can also reduce requirements below 10 percent without toolkit interaction.</p><h3>Optimizations</h3><p>Every industrial strength compiler offers tradeoffs between the time it takes to compile a program and the quality of the code generated. Native compilers typically support a direct exchange of time spent compiling for time spent running: If you specify a high optimization level, compilation will take longer, but the code will be faster than it would be at a lower level of optimization.</p><p>Because of virtual memory, code size is rarely ever a consideration for native compilers. The effect of optimization on code size is then a side effect of the effort to increase run-time speed; sometimes, less code will run faster, so the code size shrinks as a consequence of the quest for speed.</p><p>On the other hand, inline expansion of function calls (inlining) speeds up execution at the cost of tolerating larger code sections. The tradeoff is especially clear in architectures in which the calling convention is expensive and is implemented by some complex instruction or instructions. This would be the case, for instance, with the VAX <i>call</i> instruction or with move-multiple instructions available in several architectures to save several registers at a time.</p><p>Embedded development compilers need to pay attention not only to the total code size but also to its interaction with data size, as it affects usage of ROM (frequently, a limiting factor), RAM (for run-time data), and stack (another limiting resource, as it needs to be preallocated in nonvirtual systems).</p><h3>Common Optimization Issues</h3><p>Both native and embedded development compilers face code explosion from inlining, and both offer ways to prevent inlining altogether, to prevent or enable it selectively (on a function by function basis), or to make it conditional based on the size of the compiled function.</p><p>The difference between how different compilers handle inlining is the size of the threshold: Native compilers can afford to inline aggressively because they expect that any paging costs will be recouped by otherwise faster execution. Embedded development compilers, on the other hand, need to set the threshold low, as running out of ROM is catastrophic. Similar considerations apply to other straight trades of size for speed, such as loop unrolling.</p><p>Another area of shared concern is the placement and allocation of compiler-generated data needed to support the compiled code. Examples of this class of data include jump tables needed for the implementation of <i>switch</i> statements, and class hierarchy representations for run-time type identification and for exception handling.</p><p>Native compilers investigate the density of the cases of a <i>switch</i> (that is, how many of the values between the least and the highest are actually used as targets) to decide between compiling the <i>switch</i> as a complex series of conditionals (cascaded <i>if</i>s) or as an indirect jump.</p><p>The latter alternative, when desirable, involves producing an array of labels (code pointers, for example). The parameters involved in deciding whether to use this optimization vary with the nature of the target system. A native system, with ample memory and the backing of virtual storage, may use the indirect jump approach (especially inside a loop) at the least provocation, to preserve agile control flow. This approach costs two conditionals to determine if the actual <i>switch</i> expression is in range, followed by one indirect jump, compared to an average of <i>N</i>/2 conditionals for the complex conditional approach (or <i>log N </i>for a binary-search implementation, not commonly seen in practice).</p><p>The same problem, addressed by an embedded development compiler, reveals additional aspects. The time costs are the same; however, the jump table has to be put in ROM (or somehow delivered to the embedded target along with the rest of the code). Having a big table full of null pointers to account for the unused cases is not acceptable. A big table would have to be fairly dense before it is tolerable (in that case, it would be optimal for this problem).</p><p>Embedded compilers either give you finer control over when they will rely on generating <i>switch</i> tables, or provide implementations with multiple indirect jumps (to select between dense subsets of the original range). For instance, assume a <i>switch</i> has target labels for 1, 2, 3, 4, 11, 12, 13, 14, 21, 22, 23, 24, and so on. You can generate a dense representation of the jumps and use conditionals to select a range before doing the final indirect jump.</p><p>Compilers could potentially further exploit the regular structure of this example, although we are not aware of any that do. An example would be to use arithmetic to reduce the first selection; in our case, select table <i>i</i> if the <i>switch</i> expression divided by 10 yields <i>i</i>, then do an indirect jump to the final destination, based on the remainder. Investing in this sort of optimization is justified only if you know that enough user code will see an improvement. </p><h3>Code versus Stack</h3><p>Some embedded applications do not take advantage of operating systems, so developers need to take responsibility for memory placement. Lacking a mechanism to reallocate or relocate memory sections at run time and a virtual addressing scheme that can be extended as needed, these applications depend on absolute addresses.</p><p>This includes allocating a given address range for the activation frames stack. Making a large initial allocation ensures that well-behaved programs don't run out of stack space, but could be wasteful if it forces you to require additional physical memory.</p><p>This requirement is addressed by two general facilities in the embedded development toolkit -- an optimization component to control the growth of the stack, and an assembler/linker/loader feature to estimate and report the stack requirements of nonrecursive code. The optimization component needs to balance two opposite goals: minimization of stack maintenance overhead versus minimization of total stack depth.</p><p>The stack maintenance overhead comes from having to lay out activation frames on function (or scope) entry, pushing them onto the stack, and then having to terminate them and pop them out of the stack at function (or scope) exit.</p><p>The semantic requirements (argument passing by copying values, and so on) can be satisfied by continuously grabbing stack space never to be reused. Of course, that doesn't work on finite memories, but suggests that one can postpone some of this work (the reclamation of stack frames) until a convenient moment. Time-saving techniques like stack frame popping combination (for example, allocating one frame not just for a function but for a subset of the call graph that is likely to be called as a unit) depends on this technique.</p><p>In <A NAME="rl5"><A HREF="9808h.htm#l5">Listing Five</A>, for instance, the compiler may determine that <i>g</i> is only called from <i>h</i>. So, a single frame created for <i>h</i> that preallocates room for <i>t</i>, <i>z</i>, <i>w</i> (on behalf of <i>h</i>), and <i>y</i> (on behalf of <i>g</i>) would do well. On entry to <i>h</i>, the single frame would be allocated. Upon call to <i>g</i>, it would find room already allocated for its local (<i>y</i>) without requiring any allocation overhead. On return from <i>g</i>, no extra overhead is incurred either. Only when returning from <i>h</i> do you have to spend effort popping up the stack frame.</p><p>This optimization reduces the size of the generated code and the execution time for the function. However, <i>z</i> and <i>w</i> are allocated storage, even if any execution of the function will require only one of them. To properly complete this optimization, you need to do the deallocations as soon as the locals involved become dead. This excludes combining pops for functions that may not be called at all (allocate a frame only if called, deallocate it as soon as possible).</p><p>In <A HREF="9808h.htm#l5">Listing Five</A>, it looks as if this optimization is not useful, saving a few bytes of stack here and there. Nevertheless, there are two cases to consider:</p><ul><li>If <i>z</i> is a big object (say, a large array), then you need to decide if it is wise to allocate storage for both <i>z</i> and <i>w</i> before you need them. For example, assume that only the first call to <i>h</i> allocates <i>z</i>, while later calls require just <i>w</i>. Then you may expose yourself to running out of stack in one of those later calls to <i>h</i>.  <li>In addition to the ostensible <i>local</i>s, you may use this mechanism to clean up temporaries created by the compiler in order to enforce the language semantics.</ul><p>Since the framing overhead includes calling destructors (in C++), combining pops may not be consistent with the language semantics if postponing the stack frame pop may result in the destructors being executed in the wrong order or in the wrong lexical context.</p><p>Obviously, you wouldn't generate code that pushes and pops the stack (by subtracting and adding from and to the stack pointer register) following the nested scopes contour of the source program. Instead, you would just keep track of available stack offsets "in the compiler's head."  For instance, you may allocate the same stack offset to both <i>z</i> and <i>w</i> in the previous example, confident that this won't result in a collision at run time.</p><h3>Linker/Loader Optimizations</h3><p>Virtual memory systems can afford to keep around both the inlined function calls and the body of the function -- even if there aren't any calls to the function -- for simplicity of implementation. Those pieces of dead code will effectively hide in shared libraries and will be paged out harmlessly. Embedded systems can't afford this luxury, so they require a clean-up mechanism to pick up whatever isn't needed elsewhere.</p><p>For instance, in <A NAME="rl6"><A HREF="9808h.htm#l6">Listing Six</A>, the call to <i>in_century</i> may be eliminated by inlining, but the body of the function (because it is not static) cannot. If what is shown is all there is in that translation unit, the compiler will generate code for this function, but that code may be wasted at run time if no other translation unit calls it.</p><p>Embedded systems can't afford to hide that sort of waste under the virtual memory rug. Fortunately, they have an asset often unavailable to native development tools: control of the linking/loading mechanism.</p><p>Native compilers use the linking/loading facilities of the underlying operating system. Not doing so would mean not having access to system-supplied (or third-party) libraries and debuggers. Therefore, native systems have traditionally put up with obsolete linking technology (six character monocase externals, for instance).</p><p>Embedded development systems provide their own linkers/loaders and can tailor them to remove inefficiencies like the one just discussed. This potential demands that the linkers do more than the traditional activities of concatenating together sections, and resolving and relocating cross-references.</p><p>Some embedded toolkits can perform final optimization at linking/loading time, as well as provide ways to trim down standard libraries to support the application's exact needs. For instance, an application that doesn't require floating-point support can save a large amount of code in the standard libraries if it can configure out that support.</p><p>It is likely that native systems will begin adopting optimizing linkers in the future. The overhead associated with C++ template usage, for instance, stems from the generation of unnecessary code "just in case."</p><p>Consider a class template that provides a number of standard methods. Say there is a method (perhaps a <i>print</i> method) that is not needed in a given application. After the program instantiates the class template a few times, it will create <i>print</i> methods for each instance, which are not needed at all. Recognizing this sort of dead code (the method is dead, even if the whole class isn't) generally requires waiting until link time. What is worse, keeping the dead method may force us to keep (or to instantiate afresh) other methods on its behalf. Imagine having to keep <i>stdio</i> around just because of those unneeded <i>print</i> functions.</p><h3>The <i>asm()</i> Pseudofunction</h3><p>The <i>asm()</i> pseudofunction is available in most compilers, and a standard syntactic feature of C++. However, it is extensively used in embedded application development and requires additional functionality to make it more useful. Effectively, these extensions to the barebones <i>asm("string")</i> syntax are required for successful embedded application development.</p><p>One common extension is to provide a mechanism to tell the compiler the extent of the effect of the <i>asm()</i> statements in their surrounding code. Consider the effect of optimizations on a program with lots of mixed C/C++ and <i>asm()</i> statements. The compiler wants to limit the amount of parsing required for <i>asm()</i> statements, yet it may not know the impact on register or variable use or how much code has been created by these statements. Moreover, in a well-designed modern compiler, the front end doesn't want to know about the syntax of the assembler at all. The pessimistic approach (any <i>asm()</i> is potentially capable of modifying every register, stack, and heap location) is unacceptable, because it produces extremely inefficient code, forcing the developer to write the entire function, or translation unit, in assembler directly.</p><p>Another example is the interpretation of high-level identifiers inside <i>asm()</i> statements. Most implementations allow users to manipulate program variables by name from <i>asm()</i> statements. This eliminates the need to know how the variable is accessed in the program. However, not all implementations are tuned for possible side effects of this feature.</p><p>With no other use of the local variable <i>i</i> in <A NAME="rl7"><A HREF="9808h.htm#l7">Listing Seven</A>, the compiler may optimize it away. This would lead to some unexpected behavior. One way to prevent this would be to remove any optimizations that perform propagation or remove unused variables. This would work, but it is highly undesirable. The correct alternative is for the compiler to understand the <i>asm()</i> syntax enough to realize that <i>i</i> is used in the fragment above.</p><p>Another problem impacts the variable <i>j</i>. Without understanding variable usage in the <i>asm()</i> statements, the compiler may wrongly assume that the previously initialized value of <i>j</i> is still valid (residing in a register). Alternatively, a conservative compiler may assume that it must reload every register-based variable after any <i>asm()</i>.</p><p>The impact of <i>asm()</i> statements on optimal register allocation and branch displacements is exposed in <A NAME="rl8"><A HREF="9808h.htm#l8">Listing Eight</A> (using 680x0 syntax). This example modifies the register <i>d0</i> in an <i>asm()</i> statement. In some implementations, this will corrupt one of the previously allocated register variables, unless the compiler is aware of the use in the <i>asm()</i> and allocates registers accordingly.</p><p>In this case, the size of the code in the <i>for</i> loop is unknown (assuming multiple instructions are allowed in a single <i>asm()</i> statement). For architectures that implement short displacement branching (such as the Motorola 680x0), it makes it difficult to determine what size displacement can be safely used.</p><p>These are just some of the considerations needed to make <i>asm()</i> more effective. Desktop implementations typically make you responsible for controlling and dealing with the side affects of <i>asm()</i> statements. However, most embedded compilers attempt to handle this with minimal loss of optimization. Some even allow users to specify the known side affects of an <i>asm()</i> statement so the compiler can generate optimal code.</p><h3>Interrupt Handlers</h3><p>Native application developers rarely need to implement interrupt handlers in their programs. Embedded developers want to implement interrupt handlers in C/C++. The main differences between an interrupt handler and a standard function are how they are called, how they return, and what program context is saved and restored around their activation.</p><p>Compilers generally reserve registers for global or subroutine usage. They assume that each nested function is allowed to use the subroutine registers without saving them. Interrupt functions are called out of context and, therefore, must save and restore any registers they use. Interrupt functions are also not directly called. Rather, they are entered through an exception vector table when a specific exception occurs. This process also saves specific information and requires that users return from the interrupt function in a specific fashion. Most of this is transparent and built into the architecture's exception processing model, making it easier than it sounds. However, having a method to generate these differences directly greatly simplifies developing interrupt handlers in a high-level language.</p><p>Some compilers distinguish these functions by adding the <i>interrupt</i> keyword to qualify a function name. They even provide options to treat interrupt functions as standard functions, making them callable to simplify debugging them.</p><h3>Conclusion</h3><p>The choice of appropriate compiler features is constrained by the type of embedded application. The required implementation techniques are not substantially different from those required for native applications, but the emphasis is different enough to warrant different tools. You can find many of the same features and optimizations present one by one in native development systems; it is the synergy of finding them together under the roof of one toolkit that makes embedded development compilers a breed apart.</p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>packed struct {    unsigned char field1:4;    unsigned char field2:3;    unsigned short field3:1;    unsigned short field4:5;    unsigned short field5:2;    unsigned short field6:4;    unsigned short field7:4;} s;  ...s.field5 = 3;</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre><b>(a)</b>packed struct {    char c;    int i;    char c1;    short s;} s; ...s.i = 0x11223344;<b>(b)</b>move.l  #$11223344,_s+1 ; move 4 bytes from s.i at an odd address<p></p><b>(c)</b>move.b  #$11,_s+1   ; move first byte of s.i at an odd addressmove.w  #$2233,_s+2 ; move next 2 bytes of s.i at an even addressmove.b  #$44,_s+4   ; move last byte from s.i at an even address<b>(d)</b>move.b  #$11,_s+1   ; move first byte of s.i at an odd addressmove.b  #$22,_s+2   ; move next byte of s.i at an even addressmove.b  #$33,_s+3   ; move next byte of s.i at an odd addressmove.b  #$44,_s+4   ; move last byte from s.i at an even address</pre><P><A HREF="#rl2">Back to Article</A></P><H4><A NAME="l3">Listing Three</H4><pre>void func (packed struct S *); ...packed struct S {    int i1;} s1; ...packed struct {    char c;    packed struct S s2;} s3; ...func (&amp;s3.s2);func (&amp;s1);</pre><P><A HREF="#rl3">Back to Article</A></P><H4><A NAME="l4">Listing Four</H4><pre><b>(a)</b>char c;int i;short s;float f;<b>(b)</b>        .sect   .bss        .align  4        .globl  cc:        .space 1        .align  4        .globl  ii:        .space 4        .align  4        .globl  ss:        .space 2        .align  4        .globl  ff:        .space 4</pre><P><A HREF="#rl4">Back to Article</A></P><H4><A NAME="l5">Listing Five</H4><pre>extern int f( int );static int g( int x ) {    int y = f( x );    return f( y );}int h( int a, int b ){    int t;    if (a &lt; b) {        int z = b - a;        t = 2*z;    } else {        int w = a*a - b;        t = w*w;    }    return g( t )+1;    }</pre><P><A HREF="#rl5">Back to Article</A></P><H4><A NAME="l6">Listing Six</H4><pre>int in_century( int year ) { return year % 100; }void print_date( int yy, int mm, int dd ){    printf( "%d-%d-%d", in_century( yy ), mm, dd );}</pre><P><A HREF="#rl6">Back to Article</A></P><H4><A NAME="l7">Listing Seven</H4><pre>int j, k;func() {    register int i;    ...    j = 1;    asm(" move.l `k`,`i`");    asm(" move.l `i`,`j`");    j++;}</pre><P><A HREF="#rl7">Back to Article</A></P><H4><A NAME="l8">Listing Eight</H4><pre>func() {    register int i, j, k, l, m;    ...    asm(" move.l #$100000,d0");    asm(" movec d0,vbr");    ...    for (i=0; i&lt;10; i++)                asm(" ...");}</pre><P><A HREF="#rl8">Back to Article</A></P><HR><I>Copyright &copy; 1998, Dr. Dobb's Journal</I><BR>
</body></html>