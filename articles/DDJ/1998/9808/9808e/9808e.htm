<html><head><title>Dr. Dobb's Journal August 1998: C++ Locales</title></head><body bgcolor="FFFFFF"><!--Copyright &#169; Dr. Dobb's Journal--><h1>C++ Locales</h1><p><i>Dr. Dobb's Journal</i> August 1998</p><h2>International programming gets easier</h2><h3>By Nathan Myers</h3><I>Nathan developed the facilities found in chapter 22 of the Draft C++ Standard mainly so he would be able to write portable C++ programs without bothering about locales. He can be contacted at http://www.cantrip.org/.</I><hr><p>To be usable, your program must use the right alphabet, menus and dates must be in the right language, and you must sort lists in the correct order. When user preferences match your own, this is easy. But software travels, and your software will have to adapt.</p><p>Where your program is running and how that relates to user needs is referred to as "locale." Keeping the locale separate from the program code is called "internationalization" -- something the Standard C++ library supports well.</p><h3>Challenges</h3><p>In supporting internationalization, the C++ Standard Library confronts many challenges. Your server programs may have many clients around the world, so the standard library must support more than one locale per program. You use (or will soon use) multithreading, so it must be reentrant. The ways your users' cultures and preferences differ are unlimited, so it must be extensible. Because you may not (yet) care about locales, it must be ignorable. Finally, because it is standard, it must be efficient, easy, and safe to use.</p><p>The Standard C++ library uses the full power of the language to fulfill these requirements, including new standard features not yet implemented in all compilers. (This article suggests how the C++ locale library may be used. It also shows how it might be implemented, so you can use the same techniques in your own programs.)</p><h3>The <i>locale</i> Object</h3><p>The Standard C (not C++) library's locale describes character encoding and the formats for a few value types: numbers, dates, money. These represent the edge of a vast continent of cultural and personal preferences. There are also time zones (including rules for summertime adjustments), measurements (feet, meters, cubits), paper sizes, window colors and fonts, citizenship, employer, e-mail addresses, sex, and shoe size. Of course, the C++ Standard cannot represent everything. Instead, it only implements (as examples) those categories found in the traditional C locale libraries. </p><p>The key to understanding the C++ <i>locale</i> is the facet -- a class interface for a service that may be obtained from a <i>locale</i> object. For example, the Standard C++ library facet <i>num_put&lt;&gt;</i> formats numeric values, while the <i>collate&lt;&gt;</i> facet provides ordering for string values. A facet is also an object contained in a <i>locale</i>. Each <i>locale</i> object contains a set of facets to provide these services.</p><p>The C++ <i>locale</i> is a simple object that can be passed around, copied, and assigned efficiently, just like any built-in value. If you don't care about the details of how to use it, you can pass it on to someone else who does. For example, functions that take a <i>locale </i>argument can declare a default argument value, <i>locale()</i>, which is a copy of the current global <i>locale</i>. Each <i>iostream </i>keeps a <i>locale </i>object on hand for use by the operators &gt;&gt; and &lt;&lt;, respectively. These measures give the locale facilities a low profile, so it won't intrude where its more-powerful features are not needed.</p><h3>A <i>Date</i> Class Example</h3><p>Imagine you have a simple <i>Date</i> class, as in <A NAME="rl1"><A HREF="9808e.htm#l1">Listing One</A>. (Don't let the <i>std::</i> namespace notation throw you; all the library components of Standard C++ are in the namespace "<i>std.</i>" The standard headers <i>iosfwd</i>  and <i>ctime </i>declare the standard names used in the example, and the "::" notation gives access to those names.)</p><p>This <i>Date</i> class provides month names, a constructor, stream operators, and a member <i>asCLibTime </i>that converts to a Standard C library <i>struct tm</i> (look up <i>strftime()</i> in your C manual) to help communicate with other libraries.</p><p>The formats users expect to see for dates vary. If you coded a format right into operators &gt;&gt; and &lt;&lt;, many users would be dissatisfied. Instead, you can delegate to the <i>locale</i> object kept by the stream, as shown in <A NAME="rl3"><A HREF="9808e.htm#l3">Listing Three</A> (which will be explained shortly). </p><h3>An Example Program</h3><p>How can users control the format of dates produced by an <i>operator&lt;&lt; </i>that uses locales? <A NAME="rl4"><A HREF="9808e.htm#l4">Listing Four</A> may be the simplest example possible.</p><p>The constructor call <i>locale("")</i> constructs a locale object representing the user's preferred formats. On many systems, the empty string tells the library to substitute whatever is in an environment variable (often LANG or LC_ALL). The common name for the American locale, for example, is <i>"en_US." </i>Thus, you (as a user) can choose the output format by setting LC_ALL before running the program (on POSIX systems<i> locale -a</i> lists the names of supported locales). </p><p>The call to <i>cout.imbue()</i> installs the newly constructed <i>locale</i> in <i>cout</i> for use by the various &lt;&lt; operators. The next line uses the definition from <A HREF="9808e.htm#l3">Listing Three</A>, which in turn uses the <i>time_put&lt;&gt;</i> facet of the newly imbued <i>locale</i>.</p><h3>Using Facets</h3><p>To use a facet of a <i>locale, </i>you call the Standard C++ library global function template <i>use_facet&lt;&gt;()</i>. <A NAME="rl2"><A HREF="9808e.htm#l2">Listing Two</A> shows the declaration of <i>use_facet&lt;&gt;()</i>, which is found in the standard header <i>locale</i>.</p><p>For a facet class <i>Stats</i> with an <i>int</i> member <i>shoesize()</i>, for example, and a <i>locale</i> object named <i>loc</i>, a call would be <i>int ss = use_facet&lt;Stats&gt;(loc).shoesize();</i>. This syntax for calling a function template, supplying the template parameter explicitly, is not yet implemented everywhere. It's called "explicit template function qualification," and it resembles the syntax for new cast expressions, such as <i>dynamic_cast&lt;&gt;</i>. In effect, <i>use_facet&lt;&gt;()</i> is like a safe cast. In the aforementioned example, the resulting reference is used immediately to call the member function <i>Stats::shoesize()</i>.</p><h3>An Example <i>operator&lt;&lt;</i></h3><p><A HREF="9808e.htm#l3">Listing Three</A> shows what the implementation of <i>operator&lt;&lt;</i> for <i>Date</i> might look like, using the real Standard C++ library facet <i>time_put&lt;&gt;</i>.</p><p>A lot is going on here. First, the header files <i>ctime, ostream,</i> and <i>locale </i>are the new standard headers, and <i>date.h </i>has the declarations from <A HREF="9808e.htm#l1">Listing One</A>. The line that begins with <i>using</i> lets you leave off the <i>std::</i> in front of standard names later in the function. The constructor for the local variable <i>cerberus</i> prepares the ostream for output; in a multithreaded environment, it might lock the stream. The local variable <i>tmbuf</i> gets filled in with the components of the date argument.  </p><p>The interesting part is in the next two lines: <i>os.getloc()</i> obtains the <i>locale</i> object kept by the ostream argument <i>os</i>. The call to <i>use_facet&lt;&gt;()</i> gets a reference to the facet <i>time_put&lt;char&gt;</i> of that <i>locale</i>. The line <i>put(...)</i> calls the facet member <i>time_put&lt;char&gt;::put</i>, which actually writes the characters out to the stream <i>os</i>.  </p><p>Finally, the local variable <i>cerberus</i> is destroyed (perhaps unlocking the stream) right before the stream <i>os</i> is returned. The header "date.h" didn't mention locales, but because of this code hidden in <i>operator&gt;&gt;, </i>a couple of lines in <i>main() </i>let you format dates appropriately for users anywhere in the world. (Without those lines in <i>main(), </i>you get the default "C" locale behavior.)</p><h3>Your Own Facet</h3><p>The standard facets are designed so you can derive from them to get finer control of locale behavior. However, this derivation is not the only way you can extend a <i>locale</i>. You can make your own facet, and construct a <i>locale</i> to hold it.</p><p>What makes the class <i>Stats</i> in <A NAME="rl5"><A HREF="9808e.htm#l5">Listing Five</A> a facet? It's derived from <i>locale::facet</i>, it has a public static member named <i>id</i> of type <i>locale::id</i>, and its member functions are <i>const</i>. That's all. It does not need a default constructor, copy constructor, or assignment operator, though it must be destroyable.</p><p>A facet class instance is only useful as part of a <i>locale. </i><A NAME="rl6"><A HREF="9808e.htm#l6">Listing Six</A> shows one way to make a facet instance part of a <i>locale</i>. The first line constructs a <i>locale</i> object <i>here </i>as a copy of the current global locale, with the addition of the newly created <i>Stats</i> facet. (In a real program, you would probably read the argument from a file.) This uses a template constructor that deduces the facet type from the pointer argument. (Support for template constructors, as for other member templates, is a recent addition to the language and is not yet implemented in all compilers.) The second line demonstrates its use, as in the earlier example. The <i>locale </i>library takes ownership of the facet object, so you never need to delete it, and it can't leak.</p><h3>Under the Hood</h3><p>How does this work? This can all be implemented in ordinary C++, and you can do the same when you need a container indexed by type. First, the <i>locale</i> object itself is efficient to copy and assign because it really contains only a pointer to a vector of facets, as in <A NAME="rl7"><A HREF="9808e.htm#l7">Listing Seven</A>. (Only the members used in examples here are listed.) All copies share the same vector. When a locale is copied, the reference count gets incremented.</p><p>The facet base class, <i>locale::facet</i> (<A NAME="rl8"><A HREF="9808e.htm#l8">Listing Eight</A>), is also reference counted. It has a virtual destructor so that when the count goes to zero, the <i>locale</i> can destroy derived class instances safely. The only tricky bit (besides getting the reference-counting code correct) is in the class <i>locale::id</i> (<A NAME="rl9"><A HREF="9808e.htm#l9">Listing Nine</A>).</p><p>Recall that each facet type contains a static member of type <i>locale::id</i>. Thus, there is one static instance per facet type. The member <i>index_</i> is set to zero by the loader, and remains zero until it is set to something else, regardless of when static constructors are executed. </p><p>When does the <i>index_</i> member get set? <A NAME="rl10"><A HREF="9808e.htm#l10">Listing Ten</A> shows the definition of the <i>locale </i>template constructor used in <A HREF="9808e.htm#l6">Listing Six</A>. The constructor begins by copying the implementation vector from <i>other </i>and fixing up all the reference counts. Then it sets <i>Facet::id.index_ </i>to assign the facet an identity if it has none yet, and (if necessary) grows the new vector to fit. Finally, it installs the new facet, still being careful to keep the reference counts right. Thus, the <i>id::index_</i> member is zero until it is actually used.</p><p>This template constructor can be instantiated only if the <i>Facet</i> parameter really qualifies as a facet in every way; otherwise, users get a compile or link error. This code, as in the other constructors shown, is not threadsafe; a threadsafe implementation would be messier, though it would do the same things.</p><h3>The Function Template <i>use_facet&lt;&gt;()</i></h3><p>The template <i>use_facet&lt;&gt;()</i>, declared in <A HREF="9808e.htm#l2">Listing Two</A> and called in several examples, is defined in <A HREF="9808e.htm#l11">Listing Eleven</A>. If the facet has not yet been assigned an identity, or if no instance of it (or anything derived from it) is found in the argument <i>locale</i>, <i>use_facet&lt;&gt;()</i> throws an exception. (The test, here, is tricky: If <i>index</i> is bigger than the vector, or if the resulting pointer is zero, then the facet is not present; the pointer at offset zero is always zero.)</p><p>The definition of the <i>locale </i>constructor from a character pointer involves reading <i>locale </i>description files and constructing many different facets, and is beyond the scope of this article.</p><h3>Conclusion</h3><p>The standard facets only scratch the surface of what programs need to know about users. The C++ Standard committee is closing up shop; it is time for people like you, contributing to POSIX working groups and ad hoc Internet interest groups, to standardize bindings for what now clog the preferences menu of every interactive application. Perhaps the most pressing need is for a standard time-zone facet which can check the current version of the TZ database on the Internet (ftp://elsie.nci .nih.gov/pub/).</p><h3>Acknowledgments</h3><p>Thanks to Chris Lopez and John Gilson for reviewing this article. </p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>#include &lt;iosfwd&gt; // istream, ostream#include &lt;ctime&gt;  // struct tmnamespace ChronLib {class Date {  long day;  // days since 1752-09-14public:  enum Month { jan, feb, mar, apr, may, jun, jul, aug, sep, oct, nov, dec };  Date(int year, Month month, int day);  void asCLibTime(struct tm*) const;  };std::ostream&amp;operator&lt;&lt; (std::ostream&amp; os, Date const&amp; date);std::istream&amp;operator&gt;&gt; (std::istream&amp; is, Date&amp; date);}</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>namespace std {  template &lt;class Facet&gt;    Facet const&amp;     use_facet(locale const&amp; loc);};</pre><P><A HREF="#rl2">Back to Article</A></P><H4><A NAME="l3">Listing Three</H4><pre>// date_insert.C#include &lt;ctime&gt;   // struct tm#include &lt;ostream&gt; // ostream#include &lt;locale&gt;  // use_facet#include "date.h" std::ostream&amp;ChronLib::operator&lt;&lt;(std::ostream&amp; os, Date const&amp; date){  using namespace std;  ostream::sentry cerberus(os);  if (!cerberus) return os;  struct tm tmbuf;  date.asCLibTime(&amp;tmbuf);  use_facet&lt; time_put&lt;char&gt; &gt;(os.getloc())    .put(os, os, os.fill(), &amp;tmbuf, 'x');  return os;}</pre><P><A HREF="#rl3">Back to Article</A></P><H4><A NAME="l4">Listing Four</H4><pre>#include &lt;iostream&gt; // cout#include &lt;locale&gt;   // locale#include "date.h" <p></p>int main()  {  using namespace std;  using ChronLib::Date;  cout.imbue(locale(""));  cout &lt;&lt; Date(1942, Date::dec, 7) &lt;&lt; endl;  return 0;}</pre><P><A HREF="#rl4">Back to Article</A></P><H4><A NAME="l5">Listing Five</H4><pre>//stats.h#include &lt;locale&gt;class Stats : public std::locale::facet { public:  static std::locale::id id;  Stats (int ss)       : shoeSize_(ss) {}  int shoeSize() const { return shoeSize_; } private:  Stats (Stats&amp;);           // not defined:  void operator=(Stats&amp;);   // not defined:  int shoesize_;};//stats.C#include "stats.h"std::locale::id Stats::id;</pre><P><A HREF="#rl5">Back to Article</A></P><H4><A NAME="l6">Listing Six</H4><pre>locale here(locale(), new Stats(48));int ss = use_facet&lt;Stats&gt;(here).shoesize();</pre><P><A HREF="#rl6">Back to Article</A></P><H4><A NAME="l7">Listing Seven</H4><pre>class locale { public:  class facet;  class id; ~locale() { if (imp_-&gt;refs_-- == 0) delete imp_; }  locale() : imp_(__global_imp) { ++imp_-&gt;refs; }  explicit locale(char const* name);  locale(locale const&amp; other)    : imp_(other.imp_) { ++imp_-&gt;refs_; }  locale&amp; operator=(locale const&amp; l);  template &lt;class Facet&gt;    locale(locale const&amp; other, Facet* f);  // other constructors  template &lt;class Facet&gt;    friend Facet const&amp; use_facet(locale const&amp;);private:  struct imp {    size_t refs_; // ref-counter    vector&lt;facet*&gt; facets_;    ~imp();    imp(imp const&amp;);  };  imp* imp_;};</pre><P><A HREF="#rl7">Back to Article</A></P><H4><A NAME="l8">Listing Eight</H4><pre>class locale::facet {  friend class locale;  friend class locale::imp;  size_t refs_;    //initially 0 = One reference protected:  explicit facet(int refs = 0);  virtual ~facet();};</pre><P><A HREF="#rl8">Back to Article</A></P><H4><A NAME="l9">Listing Nine</H4><pre>class locale::id {  friend class locale;  size_t index_;  static size_t mark_;};</pre><P><A HREF="#rl9">Back to Article</A></P><H4><A NAME="l10">Listing Ten</H4><pre>template &lt;class Facet&gt;locale::locale(locale const&amp; other, Facet* f) {  imp_ = new imp(*other.imp_);  imp_-&gt;refs_ = 0;  // one reference  size_t&amp; index = Facet::id.index_;  if (!index)     index = ++Facet::id.mark_;  if (index &gt;= imp_-&gt;facets_.size())    imp_-&gt;facets_.resize(index+1);  ++f-&gt;facet::refs_;  facet*&amp; fpr = imp_-&gt;facets_[index];  if (fpr) --fpr-&gt;refs_;  fpr = f;}</pre><P><A HREF="#rl10">Back to Article</A></P><H4><A NAME="l11">Listing Eleven</H4><pre>template &lt;class Facet&gt;  inline Facet const&amp; use_facet(locale const&amp; loc){  size_t index = Facet::id.index_;  locale::facet* fp;  if (index &gt;= loc.imp_-&gt;facets_.size() ||      (fp = loc.imp_-&gt;facets_[index]) == 0)    throw bad_cast();  return static_cast&lt;Facet const&amp;&gt;(*fp);}PREPROCESSING</pre><P><A HREF="#rl11">Back to Article</A></P><HR><I>Copyright &copy; 1998, Dr. Dobb's Journal</I><BR>
</body></html>