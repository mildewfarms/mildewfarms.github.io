<html><head><title>Dr. Dobb's Journal August 1998: Algorithm Alley</title></head><body bgcolor="FFFFFF"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Theorem Proving and Database Querying</h1><p><i>Dr. Dobb's Journal</i> August 1998</p><h3>By Sergei Savchenko</h3><I>Sergei is a graduate student at McGill University, School of Computer Science. He can be reached at savs@cs.mcgill.ca.</I><hr><p>Historically, the major objections to AI techniques have been performance related, but increasingly powerful hardware is slowly erasing that concern. Today, developers are more concerned that software be modular, flexible, and easily updated. One approach is to use general-purpose inference techniques that let your program derive a conclusion from a list of facts. This lets you simply edit a fact database when conditions change, without having to manually alter custom logic. As Sergei points out this month, this approach can also isolate your user interface from the technical details of the underlying implementation.</p><p> -- Tim Kientzle</p><p>The trend toward smarter software is most obvious in game-playing programs such as IBM's Deep Blue chess computer. However, users are increasingly insisting that all software be flexible, which makes artificial-intelligence techniques more important to all programmers. The typical objection to such techniques -- that they are resource intensive -- is less of an issue with today's more powerful hardware.</p><p>Automated theorem proving is one such technique that has been heavily used in research labs. Essentially, an automatic theorem prover takes a certain set of facts and builds a "proof" -- a series of steps for obtaining or validating a desired result or theorem.</p><p>Theorem provers can be used to efficiently query relational databases. The initial facts specify the layout of various databases, and the desired result is a particular query. The proof explains how to use the available databases to answer the query.</p><p>Database querying relies on a particular mathematical framework called "relational algebra," which I'll discuss in this article. First, however, I'll examine two other general-purpose mathematical frameworks and show how automated theorem provers work for those systems. </p><h3>Proving Theorems in Propositional Logic</h3><p>There are different ways to write logical statements, each with its own peculiar strengths and weaknesses. One of the simplest is propositional logic, which uses atoms -- usually represented by single letters -- to represent facts or propositions. Each proposition can be either true or false. Multiple propositions can be combined using logic functions. For example, "if it is raining then the ground is wet" can be expressed as <i>a-b</i>, where <i>a</i> stands for "it is raining," <i>b</i> for "the ground is wet," and - represents "consequence" or "if...then." I'll also use ~ for "not," &amp; for "and," | for "or," and = for "equivalence" ("if and only if").</p><p>To prove a theorem in propositional logic, you start with axioms you assume are true, and use a set of inference rules to derive the result you want. For example, if the statements "it is raining" (<i>a</i>) and "if it is raining then the ground is wet" (<i>a-</i>b) are axioms, you can easily prove the theorem "the ground is wet" (<i>b</i>).</p><p>A common approach to theorem proving is to rewrite all statements as groups of clauses combined with <i>and</i>. A clause is a group of atoms or negated atoms combined with <i>or</i>. This corresponds to conjunctive normal form, and any propositional statement can be written in this fashion. After rewriting everything in conjunctive normal form, you can replace each statement <i>a</i>&amp;<i>b </i>with two separate statements <i>a</i> and <i>b</i>. So every statement can be replaced with a set of clauses.</p><p><A NAME="rl1"><A HREF="9808o.htm#l1">Listing One</A> lists a set of standard transformations that can be used to transform any statement, while <A NAME="rl2"><A HREF="9808o.htm#l2">Listing Two</A> shows how these transformations reduce <i>(~(a-b)|c)</i> to the two clauses <i>(a|c)</i> and <i>(~b|c)</i>.</p><p>Once everything is in clause form, you can use a rule called "binary chaining" -- if you have clauses of the form <i>a|~b</i> and <i>b|c</i>, you can add a new clause <i>a|c</i>. Intuitively, this resolution rule is saying that if <i>b </i>follows from <i>a</i> and <i>c</i> follows from <i>b</i>, you can conclude that <i>c</i> follows from <i>a</i>. Similarly, if you have clauses <i>b</i> and <i>~b</i>, you've found a contradiction, and your search can stop.</p><p>Generally, it is easier to look for a proof by contradiction; that is, to negate the theorem and look for a resulting contradiction with the axiom set. If one is located, then the original theorem must be true. You may sometimes find a contradiction without using the clauses of the negated theorem. This signals that the axiom set is inconsistent and contains internal contradictions.</p><p>The general strategy, then, is to take the original axioms and the negated theorem, convert them into clause form, and resolve them until you find a contradiction (an empty clause). Although simple conceptually, the number of clauses can grow exponentially as you search. Instead of a breadth-first search where you search one level at a time, many provers use depth-first or iteratively deepening depth-first searches. In the first case, you keep reusing the clause you just found until nothing new can be created or the maximal preset depth has been reached. When you reach a dead end, backtrack and try another direction. Although this doesn't require a lot of space, it can take a long time to find easy proofs that happen to use clauses at the end of your list. Iteratively deepening depth-first search avoids this by doing a depth-first search with maximum depth one, then repeating with successively larger maximum depths. Consecutive iterations repeat a lot of work, but the space requirements are minimal and you can avoid fruitless deep searches.</p><p><A NAME="rl3"><A HREF="9808o.htm#l3">Listing Three</A> is the output of a sample prover that first transforms the statements into the clause form and then searches for a proof. This simplified prover demands that the input statements be fully bracketed. Also, the last logic statement represents the negated theorem. The program that generated this output is prop.cc (available electronically; see "Resource Center," page 3).</p><p>One way to narrow the search is to identify and delete redundant clauses. For example, if you have a clause <i>h</i> and a clause <i>h|g</i>, the second clause can be deleted, since the first one will always contribute to a shorter proof. (If <i>h</i> is true, <i>h|g</i> must also be true whatever <i>g</i> is.) A single clause <i>b|b</i> can be replaced with just <i>b</i> since this is logically equivalent. A clause <i>b|~b</i> (for instance, "it is raining or not raining") is always true and can be safely discarded.</p><h3>Proving Theorems in Predicate Logic</h3><p>With just propositional logic, you can't say "For all odd numbers <i>x, x </i>plus one is even." Predicate logic extends propositional logic with quantifiers ("for all" and "there exists"), quantification variables (<i>x</i> in the example just given), predicates ("<i>x </i>is even"), and functions ("<i>x</i> plus one"). For example, the earlier statement can be written (for all <i>x</i>) <i>{ o(x)-e(p(x)) }</i>. Here <i>o(x)</i> means "<i>x </i>is odd," <i>e(x)</i> means "<i>x </i>is even," and <i>p(x)</i> adds 1 to <i>x</i>.</p><p>An interesting detail is that predicate logic is usually written without constants. Instead, you can use functions that have no arguments, which are essentially the same. This reduces the number of different kinds of entities needed to handle predicate logic.</p><p>The basic theorem-proving approach used for propositional logic also works here. To reduce everything to conjunctive normal form, beside performing the same transformations as for propositional formulas, you also need to distribute nots over quantifiers:</p><ul><li><i>~(for all x) p(x)</i> is substituted by <i>(there exists x) ~p(x).</i>  <li><i>~(there exists x) p(x)</i> is substituted by <i>(for all x) ~p(x).</i></ul><p>The next step is to eliminate the quantifiers. "For all" can simply be dropped, since any statement <i>p(x)</i> is assumed to be true for all values of <i>x</i>. To remove "there exists", you add new constants. Saying "there exists an <i>x </i>such that <i>p(x)</i>" is the same as saying <i>"p(a)" </i>is true for some constant <i>a</i>. (This process is known as "Skolemization.")</p><p>Once everything is reduced to clauses, including the negated theorem, you can use binary chaining with a few twists. For instance, the clauses <i>a(v())|b(c())</i> and <i>~a(x)|c(x)</i> can be resolved to <i>b(c())|c(v())</i> if you first substitute <i>v()</i> for <i>x</i>. You have to consider possible variable substitutions when you check to see if two terms have something in common.</p><p>Unfortunately, binary chaining isn't sufficient. You also need to consider factoring. In propositional logic, factoring <i>b|b</i> to just <i>b</i> is easy. But in predicate logic, you again have to consider variable substitutions: <i>a(x)|a(b())</i> can be factored to <i>a(b())</i>.</p><p><A NAME="rl4"><A HREF="9808o.htm#l4">Listing Four</A> presents the output of another sample prover that uses predicate logic. The axioms in this example are: "For all <i>x </i>that are even, <i>x</i>+1 is odd" and "For all <i>x </i>that are odd, <i>x</i>+1 is even." The theorem that we want to prove and which is represented by the last negated statement can be rephrased as: "Is it true that for any even <i>a</i>, <i>a</i>+2 is also even?" For simplicity, any variable in the statements is assumed to be quantified universally ("for all"), whereas the existentially quantified variables must manually be turned into some constants.</p><p>Predicate logic does introduce theoretical problems. In propositional logic, you can always prove or disprove a theorem, since the search space is always finite. With predicate logic, the search space can be infinite, and so you can never be sure whether the theorem is False or whether you simply haven't checked far enough.</p><p>[<i>Editor's note</i>: A potentially infinite search space is not the only problem with automatic proofs in predicate logic. If it were, you could modify your program to carry out two proofs in parallel. One search tries to prove the theorem is true, the other tries to prove the theorem is false. You would eventually succeed. Unfortunately, even this isn't guaranteed to work. A subtle mathematical result called "G&ouml;del's Incompleteness Theorem" says that, in any reasonable system of mathematics, there are theorems which are true but which cannot be proved. Douglas R. Hofstadter's book <i>G&ouml;del, Escher, Bach</i> (Vintage Books, 1989) is an entertaining and accessible discussion of this important fact and its consequences.]</p><h3>Relational Algebra for Databases</h3><p>A relational database is a set of two-dimensional tables called "relations." Every relation contains a number of tuples (also called "records" or "rows") each associating some values to the fields ("columns" or "attributes") of the relation. The only constraint on the relation is that no two tuples may be exactly the same. For the purposes of this article, I will represent a relation as a sequence of its tuples. For instance, <i>A= c e : 1 1 : 1 2 : 2 2 : 3 3 :</i>, where <i>A</i> is the name of the relation, <i>c</i> and <i>e</i> names of the fields followed by colon-separated tuples representing values of <i>c</i> and <i>e</i> in every tuple.</p><p>These relations can be manipulated using relational algebra, which is a set of operators that take relations as arguments and produce relations as their result. Structured Query Language (SQL) is based on this type of algebra. Although powerful, relational algebra is often not used directly because it requires that you know the internal structure of the database -- the relations present, field structure of the relations and meanings of the fields -- when you formulate the query.</p><p>A similar problem occurs with object-oriented databases (OODBs). Queries are often more efficient with OODBs, but the underlying abstraction appears to be more complex than relational algebra and may require even more intimate familiarity with the internal structure of the database to build an efficient query expression.</p><p>An automated theorem prover can help address this problem. Users simply ask their questions, and the database uses its knowledge of the internal structure to arrive at an appropriate answer. To do this, I need to first develop a notation for relational algebra.</p><p>A database may contain many different relations describing various aspects of some domain. Operations in relational algebra create new relations from old ones. For example, the selection operator creates a new relation containing only the specified tuples. For instance, <A NAME="re1"><A HREF="9808oe1.htm">Example 1</A>(a) finds the tuples of <i>A</i> (the relation just shown) where the value of the field <i>c</i> is bigger than 1. </p><p>In this sample syntax, the select operator is represented by round brackets with the argument relation on the right. An intersection join is another relational algebra operator that combines two relations based on the contents of particular join fields. When the join fields agree, the relevant tuples are combined into a new tuple and placed into the result. For instance, <A HREF="9808oe1.htm">Example 1</A>(b) joins the two relations <i>A</i> and <i>B</i> along fields <i>c</i> and <i>x</i>. The join operator is represented here by the triangular brackets with the square brackets inside denoting the join fields. Also, the <i>x</i> field disappears in the result since it is the same as <i>c</i> and thus is redundant. Of course, the power of an algebra comes from the ability to combine simple expressions into more complex ones; for instance, you can combine <A HREF="9808oe1.htm">Examples 1</A>(a) and 1(b) to select only part of the intersection join result in <A HREF="9808oe1.htm">Example 1</A>(c).</p><h3>An Automated Prover for Relational Algebra</h3><p>The inherent disadvantage of using relational algebra expressions is that they must precisely describe how to obtain the answer. You have to know the structure of the database -- which relations and fields are present -- before you can write a query expression. Often, the internal structure of the database shouldn't be exposed to end users, but this prevents them from using relational algebra to query the database.</p><p>Automated provers are really a generalized way to ask questions and find answers. You want to use a database to store data and use a prover that can use information about the database structure to construct proper relational algebra query expressions based on the user's questions.</p><p>In <A NAME="rl5"><A HREF="9808o.htm#l5">Listing Five</A>, the relations <i>A</i> and <i>B</i> each have just one field (<i>x</i> and <i>y</i>, respectively). Assume that the first relation lists the parts of some product <i>A</i> and the second relation lists parts used for another product <i>B</i>. Symbolically, you can write <i>a(x)</i> to indicate that <i>x</i> is a component of <i>a</i>, and <i>a(.x)@A</i> to indicate that every part listed in relation <i>A</i> is a part of <i>a</i>. Similarly, <i>b(.x)@B</i> means that <i>b(x)</i> is true (<i>x</i> is a part of <i>b</i>) for each part listed in <i>B</i>. Here, the dot in front of <i>x</i> or <i>y</i> signifies that these are constants stored in the fields of a relation whose name follows the "@" sign.</p><p>As an example, consider asking the database which components are present in the product <i>a</i>. This question can be rephrased in a more formal language: For which <i>x a(x)</i>? This is your theorem; you negate it and consider it together with your axioms. In particular, <i>~a(x)</i> and <i>a(.x)@A</i> produce a contradiction. Although I haven't yet shown how relational expressions can be resolved when the clauses are resolved, it's clear that in this case the relational expression for the contradiction clause will be just <i>A</i>, which represents the answer to the question. Indeed the components for the product <i>a</i> can be fetched from the relation <i>A</i>.</p><p>For a more complex example, suppose you want to find all the common parts. I'll use <i>l(x)</i> to indicate that <i>x</i> is common to both <i>A</i> and <i>B</i>. The axiom <i>{{a(x)</i>&amp;<i>b(x)}-l(x)}</i> then indicates that any part <i>x</i> that is used in both <i>a</i> and <i>b</i> is a common part. You now need a proof of <i>l(y)</i>; that is, a sequence of steps that shows how the known facts produce <i>l(y)</i>. To solve this automatically, you negate your theorem and give it to an automated prover, which will attempt to find a sequence of steps leading to a contradiction. As it does so, it uses relational algebra to explain how each step is produced from the database. At the end, you have a contradiction, together with a relational expression describing how to fetch the solution from the database. Of course, this requires you maintain associated relational expressions with each clause you derive.</p><p>Suppose you have a clause <i>{a('</i>1'<i>)|c()}</i> with an empty relational part, where '1' is a constant. You can resolve this with <i>{~a(.x)|d()}@R</i> by restricting the field <i>x</i> of the relation <i>R</i> to only have the value '1.' To preserve this, the resolvent should be <i>{c()|d()}@(x='</i>1'<i>)R</i> where <i>(x=</i>'1'<i>)</i> is a selection operator applied to the relation <i>R</i> that restricts the field <i>x </i>to be equal to '1.' </p><p>Similarly, you can combine <i>{a(.x)|d()}@R</i> and <i>{~a(.y)|c()}@L</i>. Obviously, these can only be combined when the variables <i>x</i> and <i>y</i> agree. Put differently, it applies only to members of the intersection join of <i>R</i> and <i>L</i>, which gives the symbolic result <i>{d()|c()}@&lt;R[xy]L&gt;</i>.</p><p>Although other cases are possible, these examples demonstrate the most important situations. These rules let the prover track the relational expressions as it manipulates the logical ones. The user, on the other hand, only needs to be aware of the concepts described by the database.</p><p><A HREF="9808o.htm#l5">Listing Five</A> illustrates the solution to the question, "What are the interchangeable parts?" The prover uses the axioms to contradict the negated theorem. The relational expression corresponding to this proof joins the relations <i>a</i> and <i>b</i> to produce the list of components common to both products.</p><p><A NAME="rl6"><A HREF="9808o.htm#l6">Listing Six</A> demonstrates a more complex situation. The relation <i>A</i> lists product components that can be used in different environments. The first axiom says that each <i>e</i> is an environment and the corresponding <i>c</i> is a component. The relation <i>B</i> describes three systems: <i>a</i>, <i>b</i>, and <i>c</i>. Each of these contains one or more components in the <i>p</i> field, but only "top" components (where the t field is <i>t</i>) affect the environment in which the product can be used. This knowledge is represented by the second and third axioms. <A HREF="9808o.htm#l6">Listing Six</A> shows how a prover would answer the question, "Which systems can serve in environment 3?"</p><h3>Conclusion</h3><p>These examples demonstrate how a database application can be made smarter. One advantage is that the internal structure of the database can therefore be hidden from the user, and can even change without affecting the users. The concepts and examples I've presented only demonstrate the basic methods, ignoring many subtle details encountered during practical implementation. One such issue is familiar to programmers of Prolog (which is basically a theorem prover based on a subset of predicate logic called "Horn clauses"). Sometimes it suffices to find the first empty clause (for example, a contradiction); other times it may be necessary to identify all empty clauses. For example, add an axiom to <A HREF="9808o.htm#l5">Listing Five</A> that lets you find any manufacturing part (<i>{{a(x)|b(x)}-n(x)}</i>) and observe the reasoning performed by the sample prover.</p><h3>References</h3><p>Chang Chin-Liang and Richard Char-Tung Lee. <i>Symbolic Logic and Mechanical Theorem Proving</i>. San Diego, CA: Academic Press, 1973.</p><p>Jackson, Peter. <i>Introduction to Expert Systems</i>. Reading, MA: Addison-Wesley, 1990.</p><p>Dos Reis, Anthony J. "Theorem Proving Using Semantic Resolution." <i>Dr. Dobb's Journal</i>, April 1988.</p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>Step 1: Remove - and =     g-h is substituted by ~g|h    g=h is substituted by (~g|h)&amp;(g|~h)<p></p>Step 2: Distribute negation so only atoms are negated    ~(g|h) is substituted by ~g&amp;~h    ~(g&amp;h) is substituted by ~g|~h<p></p>Step 3: Distribute ors over ands    g|(h&amp;f) is substituted by (g|h)&amp;(g|f)    (h&amp;f)|g is substituted by (h|g)&amp;(f|g)<p></p></pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>(~(a-b))|c        (Eliminating "-");(~(~a|b))|c       (Distributing not);(a&amp;~b)|c          (Distributing | over &amp;);(a|c)&amp;(~b|c)      (Obtaining clauses).<p></p></pre><P><A HREF="#rl2">Back to Article</A></P><H4><A NAME="l3">Listing Three</H4><pre>Statement:              CNF:                     Clauses:---------------------------------------------------------------------k                       k                        (0) k(~a-b)                  (a|b)                    (1) a|b(k-l)                   (~k|l)                   (2) ~k|l((b&amp;l)-a)               ((~b|~l)|a)              (3) ~b|~l|a~a                      ~a                       (4) ~a<p></p>Proof:---------------------------------------------------------------------(0) k(1) a|b(2) ~k|l(3) ~b|~l|a(4) ~a(5) ~b|~l from (4) and (3)(6) ~b|~k from (5) and (2)(7) ~k|a from (6) and (1)(8) ~k from (7) and (4)(9) contradiction from (8) and (0)<p></p></pre><P><A HREF="#rl3">Back to Article</A></P><H4><A NAME="l4">Listing Four</H4><pre>Statement:              CNF:                     Clauses:---------------------------------------------------------------------{e(x)-o(p(x))}          {~e(x)|o(p(x))}          (0) ~e(x)|o(p(x)){o(x)-e(p(x))}          {~o(x)|e(p(x))}          (1) ~o(x)|e(p(x))~{e(a())-e(p(p(a())))}  {e(a())&amp;~e(p(p(a())))}   (2) e(a())                                                 (3) ~e(p(p(a())))Proof:---------------------------------------------------------------------(0) ~e(x)|o(p(x))(1) ~o(x)|e(p(x))(2) e(a())(3) ~e(p(p(a())))(4) ~o(p(a())) from (3) and (1)(5) ~e(a()) from (4) and (0)(6) contradiction from (5) and (2)<p></p></pre><P><A HREF="#rl4">Back to Article</A></P><H4><A NAME="l5">Listing Five</H4><pre>Relations:---------------------------------------------------------------------A = x : 1 : 2 : 3 : 4 : 5 :B = y : 1 : 5 : 7 :<p></p>Statement:              CNF:                     Clauses:---------------------------------------------------------------------a(.x)@A                 a(.x)@A                  (0) a(.x)@Ab(.y)@B                 b(.y)@B                  (1) b(.y)@B{{a(x)&amp;b(x)}-l(x)}      {{~a(x)|~b(x)}|l(x)}     (2) ~a(x)|~b(x)|l(x)~l(y)                   ~l(y)                    (3) ~l(y)<p></p>Result:---------------------------------------------------------------------A= x : 1 : 2 : 3 : 4 : 5 :B= y : 1 : 5 : 7 :(0) a(.x) @ A(1) b(.y) @ B(2) ~a(x)|~b(x)|l(x)(3) ~l(y)(4) ~a(x)|~b(x) from (3) and (2)(5) ~a(.y) from (4) and (1) @ B(6) contradiction from (5) and (0) @ &lt;B[yx]A&gt;&lt;B[yx]A&gt; = y : 1 : 5 :<p></p></pre><P><A HREF="#rl5">Back to Article</A></P><H4><A NAME="l6">Listing Six</H4><pre>Relations:---------------------------------------------------------------------A= c e : 1 1 : 1 2 : 2 2 : 3 3 :B= p s t : 1 a p : 2 a t : 2 b t : 2 c p : 3 c t :<p></p>Statement:              CNF:                     Clauses:---------------------------------------------------------------------{e(.e)-c(.c)}@A         {~e(.e)|c(.c)}           (0) ~e(.e)|c(.c)@At('t')                  t('t')                   (1) t('t'){{c(.p)&amp;t(.t)}-s(.s)}@B {{~c(.p)|~t(.t)}|s(.s)}  (2) ~c(.p)|~t(.t)|s(.s)@B~{e('3')-s(x)}          {e('3')&amp;~s(x)}           (3) e('3')                                                 (4) ~s(x)Result:---------------------------------------------------------------------A= c e : 1 1 : 1 2 : 2 2 : 3 3 :B= p s t : 1 a p : 2 a t : 2 b t : 2 c p : 3 c t :(0) ~e(.e)|c(.c) @ A(1) t('t')(2) ~c(.p)|~t(.t)|s(.s) @ B(3) e('3')(4) ~s(x)(5) ~c(.p)|~t(.t) from (4) and (2) @ B(6) ~c(.p) from (5) and (1) @ (t='t')B(7) ~e(.e) from (6) and (0) @ &lt;(t='t')B[pc]A&gt;(8) contradiction from (7) and (3) @ (e='3')&lt;(t='t')B[pc]A&gt;(e='3')&lt;(t='t')B[pc]A&gt; = e p s t : 3 3 c t :</pre><P><A HREF="#rl6">Back to Article</A></P><HR><I>Copyright &copy; 1998, Dr. Dobb's Journal</I><BR>
</body></html>