<html><head><title>Dr. Dobb's Journal August 1998: The Active Expressions Library</title></head><body bgcolor="FFFFFF"><!--Copyright &#169; Dr. Dobb's Journal--><h1>The Active Expressions Library</h1><p><i>Dr. Dobb's Journal</i> August 1998</p><h2>Parallel programming with C++ operator overloading</h2><h3>By Mauricio De Simone and Gregory V. Wilson</h3><I>Mauricio De Simone developed the Active Expressions library while at the University of Waterloo. He can be reached at mdesimon@interlog.com. Greg is the author of Practical Parallel Programming (MIT Press, 1995) and coeditor with Paul Lu of Parallel Programming Using C++ (MIT Press, 1996). Greg can be reached at gvwilson@interlog.com.</I><hr><p>Daniel Slotnick began work on the world's first parallel computer, the ILLIAC-IV, more than 30 years ago. Today, multiprocessor workstations and PCs are common, but parallel programs are still rare. The main reason for this is that they are hard to write. As soon as you create a second thread of control (never mind a 200th), you have to start dealing with synchronization, communication, resource allocation, deadlock, and a host of other headaches. According to John Reynders of the Los Alamos National Laboratory, the result is that the time spent writing and debugging a parallel program is often greater than the time it would have taken to calculate the same results using conventional hardware. </p><p>In fact, while parallel programming is intrinsically harder than sequential programming, many parallel programming systems make it harder still. Some systems use proprietary language extensions, or entirely new languages. Many of these are available on only one platform, or fail to keep up with the evolution of their base language, as in the case of some of the parallel dialects of C++ surveyed in <i>Parallel Programming Using C++</i> (Gregory V. Wilson and Paul Lu, editors, MIT Press, 1996). </p><p>Other systems (such as the POSIX threads standard and PVM) encapsulate parallelism, synchronization, and communication in libraries. These systems tend to be longer-lived and more portable than proprietary languages or dialects, but they also have drawbacks. For instance, they tend to be more cumbersome than language extensions: Even a "Hello world" program can require several dozen lines of obscure function calls. </p><p>Another drawback of many libraries is that programmers have to give up type safety. If a sending process has to package messages into byte blocks, for example, there is no way for the compiler to verify that the receiving process is unpacking those bytes correctly. Off-by-one and type-casting errors (such as sticking the first four bytes of a string into an integer by mistake) are both common and notoriously difficult to track down, especially in heterogeneous environments. </p><p>In this article, we'll describe the Active Expressions library, which combines the conciseness and "checkability" of language extensions with the portability and extensibility of a library. Active Expressions is written in C++, and makes heavy use of templates and operator overloading. It does not try to do everything (it would make more sense, for example, to do matrix algebra using Todd Veldhuizen's Blitz++ library) but its conciseness and performance are proof that you can sometimes have the best of both worlds. Active Expressions was developed by Mauricio De Simone while at the University of Waterloo; its implementation borrows ideas from ABC++, which was developed by Bill O'Farrell, Greg Wilson, and others at IBM. </p><p>The Active Expressions library has been used on a variety of UNIX platforms, and its run-time system handles both shared-memory systems and distributed-memory (or networked) machines (for more information, see http://www.interlog.com/ ~mdesimon/Ae/). Performance<b> </b>figures are available from the web site; as they show, Active Expressions is 5 to 10 percent slower than "naked" threads on shared-memory systems, but several times faster than PVM on LANs. </p><h3>Developing Active Expressions</h3><p>The development of Active Expressions began with a simple question: What does the expression <i>a | b | c</i> mean? In UNIX, it means "pipe the output of a to b, and the output of b to c." In C, it means "calculate the bitwise OR of a, b, and c." </p><p>Its meaning in C++ depends on the types of <i>a</i>, <i>b,</i> and <i>c</i> and on how the | operator has been overloaded. If the operands <i>a</i>, <i>b</i>, and <i>c</i> are threads (or C++ handles for threads) and if | has been defined to mean "run in parallel," then the expression can have the same meaning inside a C++ program as it has on the UNIX command line. What's more, if * (multiplication) is defined to mean "replicate," users can write expressions such as <i>producer | (20 * worker) | consumer</i> to create a task farm in which a single producer creates jobs, a pool of 20 workers execute jobs as they become available, and a consumer collates the results; see <A NAME="rf1"><A HREF="9808jf1.htm">Figure 1</A>. </p><p>Using overloaded operators to implement parallelism has several advantages over using either function libraries or language extensions. Since C++ selects overloaded operators based on argument types, Active Expressions can be made typesafe. At the same time, since the core of the library is just a set of classes and operators, a user can extend it to meet his application's needs. For example, the || operator can then be defined to mean "broadcast," and / to mean "concurrent," so that <i>source || (N * search) | (check / save)</i> creates the system in <A NAME="rf2"><A HREF="9808jf2.htm">Figure 2</A>, in which a source broadcasts instructions to N search engines, whose outputs are both checked and saved. </p><p>Active Expressions have three parts: the base classes from which users derive active components (like the <i>producer</i> and <i>consumer</i> in the examples), the overloaded operators that connect these components together, and the run-time system that makes it all go. Every Active Component (AC) belongs in one of the following categories: </p><ul><li><i>closed</i>. The AC does not accept input, and cannot generate output.   <li><i>input[T]</i>. The AC can accept objects of type T.   <li><i>output[T]</i>. The AC produces objects of type T.   <li><i>input/output[T1,T2]</i>. The AC can accept T1s, and produces T2s. </ul><p></p><p>The C++ Active Expressions library contains four template base classes -- <i>C_Ac</i>, <i>I_Ac&lt;Ti&gt;</i>, <i>O_Ac&lt;To&gt;</i>, and <i>IO_Ac&lt;Ti, To&gt;</i>. To create Active Components, you derive application-specific classes from these base classes, specifying the type of data each can accept or produce. These derived classes must override the pure virtual method <i>run()</i> to specify their behavior. This method is called by the run-time system, after a thread for the Active Component has been created. </p><p>For example, suppose that a task farm is going to be used to calculate the Mandelbrot Set. The producer encapsulates individual jobs in "tiles," shown in <A NAME="rl1"><A HREF="9808j.htm#l1">Listing One</A>. These tiles are passed to workers, which calculate colors for <i>xPixels*yPixels</i> covering the rectangle from <i>(xLo,yLo)</i> to <i>(xHi,yHi)</i> and store these pixels in pixel blocks; see <A NAME="rl2"><A HREF="9808j.htm#l2">Listing Two</A>. Note the use of the template array class <i>Array&lt;&gt;</i> to create an array of colors. <A NAME="rl3"><A HREF="9808j.htm#l3">Listing Three</A> shows the producer, worker, and consumer classes for this program.</p><h3>Defining Operators </h3><p>Active components can communicate with the outside world using files, sockets, or any other mechanism, but can only communicate with each other through their ports. Each component's ports are strongly typed: If a program tries to connect ports with different types, the compiler detects the mismatch and reports an error, just as it would report an error if the wrong type of argument was passed to a function call. </p><p>An input-only AC inherits a single port called <i>pin</i> from <i>I_Ac</i>. This port is an instance of the template class <i>I_Port&lt;Ti&gt;</i> and has an overloaded stream operator <i>operator&gt;&gt;</i> which can be used for reading. Similarly, output ports are derived from the base class <i>O_Port&lt;To&gt;</i>. An output-only AC has one such (output) port, while an input-output AC has one of each. Using these ports, we can flesh out the definition of the Mandelbrot Set Worker's <i>run() </i>method as shown in <A NAME="rl4"><A HREF="9808j.htm#l4">Listing Four</A>.</p><p>Active Components are just building blocks; the real power of the Active Expressions library lies in the operators that can be used to combine these components. In C++, if the function in <A NAME="rl5"><A HREF="9808j.htm#l5">Listing Five</A>(a) has been defined for types <i>Mulder</i>, <i>Scully</i>, and <i>Skinner</i>, then the assignment statement in <A HREF="9808j.htm#l5">Listing Five</A>(b) becomes <A HREF="9808j.htm#l5">Listing Five</A>(c). </p><p>Our first attempt to create Active Expressions uses standard operator overloading. The overloaded operators take Active Expressions as arguments, and return Active Expressions as results. These Active Expressions are not concurrent threads themselves, but rather passive proxies for threads. Executing the overloaded operators builds a parse tree in memory; evaluation of that parse tree then creates the parallel structure defined by the expression tree. </p><p>To make this more concrete, consider the pipe operator in <A NAME="rl6"><A HREF="9808j.htm#l6">Listing Six</A>(a), where <i>AeNode</i> is a simple class that holds pointers to operands of type <i>AeNode</i>; see <A HREF="9808j.htm#l6">Listing Six</A>(b). Given this definition, and assuming that the base classes for active components are all derived from <i>AeNode</i>, a structure such as <i>AeNode head = n1 | n2 | n3 | n4;</i> is compiled into <i>AeNode head = operator|(n1, operator|(n2, operator|(n3, n4)));</i>, which, if inlining is used, in turn becomes <i>AeNode head = *new AeNode(n1, *new AeNode(n2, *new AeNode(n3, n4)));</i>. </p><p>This structure holds the information needed to create a dataflow network, but does no type-checking. To get the safety that type-checking provides, you must use template classes, organized into the hierarchy; see <A NAME="rf3"><A HREF="9808jf3.htm">Figure 3</A>. Using this hierarchy, the definition of the pipe operator in <A HREF="9808j.htm#l5">Listing Five</A> can be changed to validate the types of connections, as in <A NAME="rl7"><A HREF="9808j.htm#l7">Listing Seven</A>(a). This operator is essentially the same as the one shown before, but its usage will only be triggered by connections between <i>O_AeNodes</i> and <i>I_AeNodes</i> (or <i>O_Acs</i> and <i>I_Acs</i>, if these are derived from their node counterparts). Three definitions of <i>operator|</i> are needed in addition to <A HREF="9808j.htm#l7">Listing Seven</A>(a) to handle the four kinds of connectivity that can arise; see <A HREF="9808j.htm#l7">Listing Seven</A>(b). The type of the result of each operator reflects the semantics of the result of the connection made. This ensures that the entire tree is constructed correctly. </p><p>The operators in <A HREF="9808j.htm#l7">Listing Seven</A> ensure correct connectivity, but not correct typing. To guarantee this, you must refine the class hierarchy one more time by templating all of the involved classes. Once this has been done, the operators will look like <A NAME="rl8"><A HREF="9808j.htm#l8">Listing Eight</A>. This, our final definition, checks both connectivity and typing at compile time. </p><h3>Implementing Operators</h3><p>Defining operators is only half the battle -- you must also implement them. For each operator, you define a class hierarchy that mimics the structure in <A NAME="rf4"><A HREF="9808jf4.htm">Figure 4</A>. Each category of this hierarchy is derived directly from the appropriate Active Expression node type. The pipe representative needs an extra template parameter (<i>Tcon</i>) that holds the type information for the connection that would otherwise be lost in the construction of the tree. These representative objects can be used as return values for the operators describe before; see <A NAME="rl9"><A HREF="9808j.htm#l9">Listing Nine</A>.</p><p>And that's all there is to it. For every operator, four implementations must be defined, and four accompanying classes derived to store descriptive information. A Perl script can be used to generate the required definitions for new operators. </p><h3>Returning to the Mandelbrot Set </h3><p>Let us return to the Mandelbrot Set task farm specified by the expression <i>producer | (20 * worker) | consumer</i>. When executed, this expression constructs a simple tree, but does not actually create or run any threads. For that to happen, the expression must be activated by assigning it to a variable of <i>type C_Ae</i> (a closed expression). The overloaded assignment operator <i>operator=</i> invokes the run-time system, which walks the expression tree, creating, connecting, and running threads as required. Thus, to actually calculate and display the Mandelbrot Set, you would use the code shown in <A NAME="rl10"><A HREF="9808j.htm#l10">Listing Ten</A>.</p><p>The same effect can also be achieved using the ! operator, which instantiates and runs an active expression <i>!(producer | (20 * worker) | consumer);</i>. (Because ! is sometimes called "bang," this is referred to as "banging an expression.") </p><p>The expression tree describing the concurrent system does not disappear once the expression finishes running. By calling the method <i>do()</i> on the handle <i>mandelbrot</i>, a program can rerun the Active Expression. An interactive task farm could therefore be written as in <A NAME="rl11"><A HREF="9808j.htm#l11">Listing Eleven</A>. The loop control in the code relies on a type conversion operator <i>const int()</i>, defined for <i>C_Ae,</i> which returns the error code produced by the most recent execution of the Active Expression, or 0 if no error occurred. </p><p>One advantage of delaying execution until the value of an active expression is required is that it lets you encapsulate concurrency in application-specific ways. A task farm, for example, can be encapsulated as in <A NAME="rl12"><A HREF="9808j.htm#l12">Listing Twelve</A>, which can then be used by you to write code like <i>!(databaseReader(inputFileName) || TaskFarm(p, w, c) | (check / save));</i>. </p><p>The greatest strength of library-based systems like Active Expressions is the ease with which they can be extended. For example, consider a dataflow loop like that shown in <A NAME="rf5"><A HREF="9808jf5.htm">Figure 5</A>. This introduces a new node type that has two pairs of ports. One pair connects the node to the rest of the program; the second pair connects the node to an input/output expression. This keeps data circulating as long as the value returned by the Boolean virtual method <i>loop()</i> (which the user must override) is True. <A NAME="rl13"><A HREF="9808j.htm#l13">Listing Thirteen</A> shows the base class for a loop. (The input and output types of the loop must be the same to allow for the possibility of zero traversals. The equivalent of a <i>do-while</i> loop can also be defined, with different input and output types.) </p><p>The expression to be looped is given to the node as a constructor argument, as in <i>result = something | loop(a|b|c) | somethingElse;</i>. Adding this class to the library took only a few minutes; adding support for other constructs, such as two-dimensional grids, took somewhat longer, but was still much easier than it would have been with most other systems. </p><h3>Conclusion</h3><p>Future work on Active Expressions will focus on three areas. The first, a port to Win32 and Microsoft Visual C++, is under way. The second is I/O: While it would clearly be useful to be able to connect active expressions directly to standard C++ streams, the semantics of this is tricky to define. For example, if N threads are reading concurrently, should the whole file be broadcast to each thread, should each get one record in order (assuming the file is record-based), should each get one segment of the file, or should reading be interleaved randomly?</p><p>The third area for future work is error handling. If a thread in a pool of workers throws an exception, should that exception cause the whole expression to terminate? Should it somehow be passed downstream? Or should it propagate to the outside world only after the expression as a whole has terminated? </p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>struct MandelTile{    float xLo, yLo, xHi, yHi;   // boundary coordinates of tile    int xPixels, yPixels;       // number of pixels in tile};</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>struct PixelBlock{    int xPixels, yPixels;       // number of pixels in tile    Array&lt;color&gt; pixels;        // 24-bit color, xPixels*yPixels long};</pre><P><A HREF="#rl2">Back to Article</A></P><H4><A NAME="l3">Listing Three</H4><pre>class Producer : public O_Ac&lt;MandelTile&gt;{    virtual void run(){        while (tiles to generate){            generate and output tiles        }    }};class Worker : public IO_Ac&lt;MandelTile, PixelBlock&gt;{    virtual void run(){        MandelTile tile;        PixelBlock block;        while (input stream open){            read a job spec into tile            calculate and output block        }    }};class Consumer : public IO_Ac&lt;MandelTile, PixelBlock&gt;{    virtual void run(){        PixelBlock block;        while (input stream open){            read pixels into block            display        }    }};</pre><P><A HREF="#rl3">Back to Article</A></P><H4><A NAME="l4">Listing Four</H4><pre>void Worker::run(){    MandelTile tile;    PixelBlock block;    while (! pin.eos()){        // eos() is the end-of-stream test        pin &gt;&gt; tile;        calculate        pout &lt;&lt; block;    }}</pre><P><A HREF="#rl4">Back to Article</A></P><H4><A NAME="l5">Listing Five</H4><pre><b>(a)</b>Skinner operator+(Mulder a, Scully b){    ...implementation...    return instance of Skinner;}<b>(b)</b>Mulder fox;Scully dana;Skinner walter; ...walter = fox + dana;<b>(c)</b>walter = operator+(fox, dana);</pre><P><A HREF="#rl5">Back to Article</A></P><H4><A NAME="l6">Listing Six</H4><pre><b>(a) </b>AeNode &amp; operator| (const AeNode&amp; lhs, const AeNode&amp; rhs){    return *(new AeNode(lhs, rhs));}<b>(b)</b>class AeNode{    public :        AeNode(const AeNode&amp; lhs, const AeNode&amp; rhs)        : _left(&amp;lhs), _right(&amp;rhs)        {}    protected :        AeNode * _left, * _right;}</pre><P><A HREF="#rl6">Back to Article</A></P><H4><A NAME="l7">Listing Seven</H4><b>(a)</b><pre>C_AeNode &amp; operator|(const O_AeNode &amp; lhs, const I_AeNode &amp; rhs){    return *new C_AeNode(lhs, rhs);}<b>(b) </b>O_AeNode&amp; operator|(const O_AeNode&amp; lhs, const IO_AeNode&amp; rhs){    return *new O_AeNode(lhs, rhs);}I_AeNode&amp; operator|(const IO_AeNode&amp; lhs, const I_AeNode&amp; rhs){    return *new I_AeNode(lhs, rhs);}IO_AeNode&amp; operator|(const IO_AeNode&amp; lhs, const IO_AeNode&amp; rhs){    return *new IO_AeNode(lhs, rhs);}</pre><P><A HREF="#rl7">Back to Article</A></P><H4><A NAME="l8">Listing Eight</H4><pre>template &lt;class T&gt;C_AeNode&amp;operator | (const O_AeNode&lt;T&gt;&amp; lhs, const I_AeNode&lt;T&gt;&amp; rhs){    return *new C_AeNode(lhs, rhs);} ...other variations defined similarly...</pre><P><A HREF="#rl8">Back to Article</A></P><H4><A NAME="l9">Listing Nine</H4><pre>template &lt;class T&gt;C_AeNode&lt;T&gt;&amp;operator | (const O_AeNode&lt;T&gt;&amp; lhs, const I_AeNode&lt;T&gt;&amp; rhs){    return *new C_Pipe&lt;T&gt;(lhs, rhs);}</pre><P><A HREF="#rl9">Back to Article</A></P><H4><A NAME="l10">Listing Ten</H4><pre>C_Ae mandelbrot;mandelbrot = producer | (20 * worker) | consumer;</pre><P><A HREF="#rl10">Back to Article</A></P><H4><A NAME="l11">Listing Eleven</H4><pre>{    // run first time    C_Ae mandelbrot = producer | (20 * worker) | consumer;    while ((mandelbrot == 0) &amp;&amp; (user isn't bored)){        get new parameters        producer.reset(new parameters);        mandelbrot.do();    }    // mandelbrot automatically destroyed here}</pre><P><A HREF="#rl11">Back to Article</A></P><H4><A NAME="l12">Listing Twelve</H4><pre>template &lt;class Job, class Result&gt;class IO_Ac&lt;Job, Result&gt; &amp;TaskFarm(    O_Ac&lt;Job&gt;&amp; producer,    IO_Ac&lt;Job,Result&gt;&amp; worker,    I_Ac&lt;Result&gt;&amp; consumer){  int n = 3 * number of processors in the system;  return producer | (n*worker) | consumer;}</pre><P><A HREF="#rl12">Back to Article</A></P><H4><A NAME="l13">Listing Thirteen</H4><pre>template&lt;class T&gt;class Loop_Ae{public :    // main-line ports    I_Port&lt;T&gt; pin;    O_Port&lt;T&gt; pout;    // looping ports    I_Port&lt;T&gt; loopIn;    O_Port&lt;T&gt; loopOut;    // run() pre-defined    virtual void run(){        while (! pin.eos()){            T data;            pin &gt;&gt; data;            while (loop()){                loopOut &lt;&lt; data;                loopIn  &gt;&gt; data;            }            pout &lt;&lt; data;        }    }    // user must override control    virtual const bool loop() = 0;};</pre><P><A HREF="#rl13">Back to Article</A></P><HR><I>Copyright &copy; 1998, Dr. Dobb's Journal</I><BR>
</body></html>