<html><head><title>Dec98: Java Q&A</title></head><body bgcolor="FFFFFF"><!--Copyright &#169; Dr. Dobb's Journal--><h1>How Do I Use Servlets?</h1><p><i>Dr. Dobb's Journal</i> December 1998</p><h3>By W. David Pitt</h3><I>David is a Java mentor working for CrossLogic Corp., an object technology consulting firm that specializes in distributed computing. He can be contacted at wpitt@ crosslogic.com.</I><hr><p>Java Servlets are web server plug-ins that allow dynamic web content to be created using Java on the server side. When an HTTP URL is issued, a Servlet-aware web server identifies and invokes the <i>Servlet</i> class, which executes on the server -- not in the client's process space. In other words, Java class files are not sent to the client machine; instead, Servlets are started in separate threads on the server. This is one benefit Servlets have over CGI, which starts an operating-system process for each client request. Moreover, all Servlets run under a single Java Virtual Machine (JVM), allowing an object state to be shared among multiple client requests; see <A NAME="rf1"><A HREF="9812mf1.htm">Figure 1</A>.</p><p>The Servlet interface requires the implementation of methods that are invoked at different times during the life cycle of  a <i>Servlet</i> instance; see <A NAME="rl1"><A HREF="9812m.htm#l1">Listing One</A> (located at the end of this article). The <i>init()</i> method is called the first time a <i>Servlet</i> class is invoked by a client when the bytecodes are moved into the VM. Operations such as database or resource connection/initialization are typically done at this point. Each client request results in a new instance of the <i>Servlet</i> class running in its own thread, and the invocation of the <i>service()</i> method. The <i>service()</i> method is where Servlet behavior is implemented. This instance and its thread live as long as the method is on the process stack. When the method returns, the thread is stopped and the instance garbage collected. Therefore, you are responsible for creating and synchronizing thread behavior against shared resources or objects. Servlets provide an opportunity for you to perform cleanup and housekeeping chores via the <i>destroy()</i> method. This method is invoked at the discretion of the web server. </p><p>In this article, I'll discuss two approaches to using Servlet technology to create server-based Java applications with the ability to interact with web-based clients using HTML or serialized Java objects. </p><p>You invoke Servlets by defining a URL that contains the Servlet's class name. A naming convention is applied to notify the web browser of the Servlet class name and path: After the address, the text pattern "Servlet" appears, along with a fully qualified Servlet class name, such as: </p><blockquote><p>http://127.0.0.1:8080/servlet/             simple.SimpleServlet</p></blockquote><p>Of course, the location to which the URL points must be a Servlet-aware web server. </p><p>Servlet behavior is implemented in the <i>service()</i> method. Information is passed and communicated to and from a client invoking a Servlet by arguments defined in this method. These arguments are of types <i>ServletRequest</i> and <i>ServletResponse</i>. Instances of these types are used to push and pull information from a client's web page. </p><p>Responding to a client page using a <i>ServletResponse</i> object is accomplished by requesting an output stream and putting MIME type or text content onto it. Likewise, information is obtained from a client page by obtaining an input stream from the request object and pulling information using the stream protocol. </p><p>When the Servlet is loaded and instantiated, the <i>init()</i> method is exercised. Resource allocation (such as connecting to a database) can be performed at this point. Subsequent calls to the Servlet will exercise the <i>service()</i> method only.</p><p>Before the JVM on the server shuts down, the <i>destroy()</i> method is called, allowing housekeeping chores to be performed.</p><h3>"Hello World" Servlet Using the JSDK</h3><p>The Java Server Development Kit (JSDK), freely available from JavaSoft (http://www.sunsoft.com/), provides Servlet support for web servers such as Microsoft's IIS, Netscape, and Apache. Additionally, the JSDK includes an HTTP web server written in Java and invoked as a Java application. This sample server lets you test Servlets from your machine without a web server. </p><p>Servlets must implement the Servlet interface. The JSDK provides a Servlet abstraction by supplying a hierarchy of <i>Servlet</i> classes (<A NAME="rf2"><A HREF="9812mf2.htm">Figure 2</A>), which implement general Servlet behavior. Specific Servlet behavior can be implemented by extending this hierarchy.</p><p><i>GenericServlet</i> implements basic <i>init()</i> and <i>destroy()</i> behavior requiring subclasses to implement only the <i>service()</i> method. These methods can be overridden if required. More specifically, the <i>HTTPServlet</i> class implements a protocol to process HTTP <i>post</i> and <i>get</i> commands.</p><p>A Servlet that simply displays "Hello World" in a client's browser space can be created by extending <i>GenericServlet</i> and overriding the <i>service()</i> method. A client's browser is accessed by obtaining an output stream from the <i>Response</i> object passed in as an argument. The specific instance of the Servlet is shared by all HTTP clients performing the request. Each request does not result in the <i>Servlet</i> class being run on an independent JVM, in a separate operation system process as with a CGI request. Instead, each request is given a more efficient thread; see <A NAME="rl2"><A HREF="9812m.htm#l2">Listing Two</A>.</p><h3>Invoking a Servlet</h3><p>The JSDK implements an <i>HTTPServer</i> class that you can use to test Servlets from your workstation. Assuming a JVM is installed, and your classpath set, you start the the server using: <i>Java HTTPServer -v -p 8080</i>. Once invoked, the <i>SimpleServlet</i> class is executed from a browser using the URL <i>http://127.0.0.1:8080/ servlet/simple.SimpleServlet</i>.</p><h3>Responding with Dynamically Generated HTML</h3><p>Since not all browsers reliably handle Java applets, Java on the client can be removed from the equation by having Servlets respond to clients by generating dynamic HTML. Having an HTTP connection to the client machine accommodates the generation and displaying of HTML from a Servlet.  </p><p>Responding to HTTP <i>post</i> and <i>get</i> requests from a Servlet is accomplished by subclassing from <i>HTTPServlet,</i> supplied with the JSDK. HTTP <i>get </i>requests are intercepted in a Servlet by overriding the <i>doGet()</i> method. Arguments to the method are the same as the <i>service()</i> method; they are of type <i>ServletRequest</i> and <i>ServletResponse</i>. A response of HTML text is communicated to the web server by setting the Servlet response object's <i>setContentType()</i> attribute to text/html; after that, it is simply a matter of putting valid HTML tags/text onto the output stream (<A NAME="rl3"><A HREF="9812m.htm#l3">Listing Three</A>). </p><h3>Retrieving Objects from a Servlet</h3><p>Another interesting way to apply Servlets involves streaming objects asynchronously from a Servlet to a client-side applet. This is accomplished using the serializing behavior built into the JDK. </p><p>An applet can communicate with a Servlet by using the networking programming support provided by the language. An HTTP connection is accomplished in Java using the URL object to invoke a Servlet (see <A NAME="rl4"><A HREF="9812m.htm#l4">Listing Four</A>). Instead of putting text or HTML on the <i>Response</i> objects stream passed into the <i>service</i> method (<A HREF="9812m.htm#l5">Listing Five</A>), Java objects are created and deflated (<A HREF="9812m.htm#l6">Listing Six</A>) into a byte array using serialization. The applet in turn inflates the byte array into objects (<A HREF="9812m.htm#l7">Listing Seven</A>). </p><p>It is not reasonable to assume that a client will require all available objects from a Servlet. In most cases, the applet will need to communicate some kind of query information to the Servlet. In the same fashion that objects are serialized and sent to an applet, the applet can serialize objects containing query information and append them to the HTTP stream sent to a <i>Servlet</i> instance. The Servlet can then inflate these objects and obtain query information.</p><h3>Conclusion</h3><p>Servlets let you implement browser-based applications to exploit Internet connectivity. Java's platform-independent thread-safe programming makes it an excellent language for server-side application development. Although the examples I've presented are simplistic, they should provide a starting point in creating interactive Internet applications.</p><p>The source files that implement the Servlets described here are available electronically (see "Resource Center," page 3). The Servlets can be accessed using the example <i>HTTPServer </i>provided with the JSDK or copied to a Servlet-enabled web server. The HelloWorld Servlet displays "Hello World" to an accessing browser. <i>EmployeeHTMLTableServlet </i>generates an HTML table and displays it in a web browser. The third Servlet communicates with <i>SerializingEmployeeApplet </i>by serializing objects and streaming to a client browser using an HTTP <i>get</i> command.</p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</A></H4><pre>public abstract interface Servlet {public abstract void destroy();public abstract javax.servlet.ServletConfig getServletConfig();public abstract java.lang.String getServletInfo();public abstract void init(javax.servlet.ServletConfig arg1)                                 throws javax.servlet.ServletException;public abstract void service(javax.servlet.ServletRequest arg1,               javax.servlet.ServletResponse arg2)                    throws javax.servlet.ServletException, java.io.IOException;}</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>package simple;import java.io.*;import javax.servlet.*;public class HelloWorldServlet extends GenericServlet {    public void service( javax.servlet.ServletRequest req,                                      javax.servlet.ServletResponse res){    try {    PrintStream out = new PrintStream(     res.getOutputStream());    out.println("Hello World");}    catch( java.io.IOException e) {System.out.println(e); }   }            }       </pre><P><A HREF="#rl2">Back to Article</A></P><H4><A NAME="l3">Listing Three</H4><pre>/* doGet method is called when an HTML form accesses this servlet using GETmethod where all information is encoded in QUERY_STRING environment variable.*/      public synchronized void doGet(HttpServletRequest httpServletRequest,                                 HttpServletResponse httpServletResponse)throws IOException  {    String  jobValue = null,     deptValue = null;    // We will be returning an HTML page    httpServletResponse.setContentType("text/html");    // Get the output stream            ServletOutputStream servletOutputStream =                 httpServletResponse.getOutputStream();    //  Start writing the HTML output           htmlHeader(servletOutputStream);    // Process the arguments    processArguments(httpServletRequest, servletOutputStream);    // Get Vector of Employee Objects    Vector aVector =  employeeObjects();    // Write Employee Objects to an HTML table    htmlResultTable(aCollection, servletOutputStream);    // Write ending HTML    htmlTrailer(servletOutputStream);    servletOutputStream.close();}</pre><P><A HREF="#rl3">Back to Article</A></P><H4><A NAME="l4">Listing Four</H4><pre>/* Retrieve Employees from Servlet. * @return Vector */public Vector getEmployeesFromServlet() {    URL url = null;    try{        //  Create the URL       String urlStr = "http://127.0.0.1:8080/servlet/proof.                                        servlet.SerializeEmployeesServlet";        url = new URL( urlStr + "?");           }   catch( MalformedURLException e) {            System.out.println(" URL: " + e.toString());            e.printStackTrace();            return null;            }    // Open the stream -- this starts the service() method in the servlet    InputStream inStream = null;    try{        inStream = url.openStream();    }   catch( IOException e){        System.out.println("EmpolyeeApplet Exception: " + e.toString());        e.printStackTrace();        return null;        }    // Get Vector of Employees...    Vector employees = null;        // Inflage Vector of Employee Objects    employees =             (Vector) inflate( inStream);        return employees;}</pre><P><A HREF="#rl4">Back to Article</A></P><H4><A NAME="l5">Listing Five</H4><pre>/* Create a Vector of Employees, deflate and stream back to applet */   public void service(HttpServletRequest req, HttpServletResponse res)                                       throws IOException, ServletException{    // Create the output stream for communicating with the Applet       FilterOutputStream objOut =                           new FilterOutputStream( res.getOutputStream());    byte[] errorDeflatedExam = null;        context = getServletContext();    if (context != null) {        context.log("LOG:ReqInfoServlet:service START");    }       // Process arguments sent on the URL request    processURLArguments(req);    // Get a deflated Employee Object    byte[] aDeflatedVector = (byte[]) buildDeflatedEmployees(employees);    //      Write it to the applet          objOut.write(aDeflatedVector);    objOut.close();    context.log("LOG:EmployeeServlet:service  Employees written");    context.log("LOG:ExamServlet:service END");}</pre><P><A HREF="#rl5">Back to Article</A></P><H4><A NAME="l6">Listing Six</H4><pre>/* Turn Vector into a byte array. * @return java.io.ObjectOutputStream * @param anExam COM.cl.onlineExam.domain.Exam */private byte[] buildDeflatedEmployees(Vector aVector) {    //  Deflate the object to an output stream    ObjectOutputStream objOut = null;    ByteArrayOutputStream bOut = null;    try {        bOut = new ByteArrayOutputStream();        objOut = new ObjectOutputStream(bOut);        objOut.writeObject(employees);        objOut.close();    } catch (java.io.IOException e) {        e.printStackTrace();        return null;        }           return bOut.toByteArray();}</pre><P><A HREF="#rl6">Back to Article</A></P><H4><A NAME="l7">Listing Seven</H4><pre>/* Inflate input stream */  Object inflate( InputStream in){    Object obj = null;    try{        while( in.available() == 0)        }   catch( IOException e){            System.out.println("Error in debug code: " + e.getMessage());        }        try{            ObjectInputStream objIn = new ObjectInputStream( in);            obj = objIn.readObject();        }   catch( IOException e){            responseTextArea.setText("Error inflating                                      object: " + e + " " + e.getMessage());        }   catch( ClassNotFoundException e){            responseTextArea.setText("Error finding                                       class: " + e.getMessage());        }        return obj;    }</pre><P><A HREF="#rl7">Back to Article</A></P><p><b>DDJ</b></p><HR><I>Copyright &copy; 1998, Dr. Dobb's Journal</I><BR>
</body></html>