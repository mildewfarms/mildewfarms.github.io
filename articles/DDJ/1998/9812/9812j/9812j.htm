<html><head><title>Dec98: Examining Microsoft's LDAP API</title></head><body bgcolor="ffffff"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Examining Microsoft's LDAP API</h1><p><i>Dr. Dobb's Journal</i> December 1998</p><h2>Here's a library that hides the details</h2><h3>By Sven B. Schreiber </h3><I>Sven is a developer in Herzogenaurach, Germany. He can be contacted at sbs@ orgon.com. </I><hr><p>The Lightweight Directory Access Protocol (LDAP) is a TCP-based protocol that facilitates remote access to X.500-type directory services. Many vendors support LDAP, including Microsoft, which started supporting LDAP with Version 5.0 of its Exchange Server directory. Incidentally, LDAP will become the core protocol of the Active Directory Services Interface (ADSI) of Windows NT 5.0.</p><p>In addition to LDAP, Exchange 5.5 supports the Network News Transfer Protocol (NNTP), Simple Mail Transfer Protocol (SMTP), Post Office Protocol v3 (POP3), and Interactive Mail Access Protocol v4 (IMAP4). All are based on open Internet standards and are defined in "Request for Comments" (RFC) documents. All RFCs are freely available at ftp://ds.internic.net/rfc/ or ftp://nic.ddn.mil/rfc/.</p><p>The abstract definition of LDAP Version 2 (LDAPv2) was published in 1995 in RFC 1777, and a companion API specification appeared shortly thereafter in RFC 1823. It wasn't until December 1997, however, that LDAPv3 was released (RFC 2251), adding lots of new features and further standardizing various protocol elements. News and documents on the progress of LDAP are available at Mark Wahl's web site (http:// www.critical-angle.com/ldapworld/). Wahl is the primary author of RFCs 2251-2253 and RFC 2256.</p><p>In this article, I'll provide an overview of how to use LDAP to access Microsoft's Exchange Server 5.x. To that end, I've included a general-purpose LDAP utility DLL that makes programming an Exchange directory browser straightforward, plus a demo program built upon that DLL (available electronically; see "Resource Center," page 3). There are a lot of details involving topics such as authentication, the X.500 Directory, parsing, server controls, paged results, version negotiation, and the like, that I do not address in this article. However, these topics (and others) are covered in a set of programmer's notes that are also available electronically.</p><h3>The LDAP API</h3><p>Writing an LDAP client does not necessarily involve banging directly on Windows sockets and packing/unpacking BER-encoded TCP data blocks. In RFC 1823, an API that hides all BER and WinSock minutiae beneath a simple surface is defined. The problem with RFC 1823, however, is that it is somewhat outdated. It relates to LDAPv2 and as such, it doesn't take into account the additional functionality introduced with LDAPv3/ RFC 2251.</p><p>At this writing, the official update to RFC 1823 is in the Internet-draft state (see ftp://ds.internic.net/internet-drafts/ draft-ietf-asid-ldap-c-api-00.txt). As the document name implies, the Access, Searching and Indexing of Directories (ASID) working group of the Internet Engineering Task Force (IETF) is in charge of this paper (see http://www.ietf.org/ for information about the task force, or http://www.ietf.org/ html.charters/asid-charter.html for a summary of ASID documents). Internet drafts are works in progress and should not be used as reference material. Thus, the LDAPv3 API should be regarded as tentative, and everything I say about it is subject to change.</p><p>A reference implementation of LDAP and the LDAP API is distributed by the University of Michigan -- this Umich Release is freely available at http://www .umich.edu/~dirsvcs/ldap/. At this writing, the current Version is 3.3 (ldap-3.3.tar.Z). A Windows 3.x/Win32 version for WinSock 1.1 is also available (winldap.zip).</p><p>Microsoft provides its implementation of RFC 1823 and the LDAPv3 API draft in the wldap32.dll system DLL. There are several versions around -- a file version number of 5.0.1515.0 or newer is okay. The necessary header and import library files are distributed as part of the Platform SDK, at http://www.microsoft.com/msdn/sdk/ platform.htm. The only files you will need are winldap.h and wldap32.lib. (A 16-bit version isn't available and probably never will be.) Get the files from the most-recent version of the SDK, since they might change due to ongoing LDAP enhancements.</p><p>Of course, issuing some calls into wldap32.dll isn't the whole story. The first problem you'll encounter is that documentation on Microsoft's LDAP implementation is practically nonexistent. This situation should change with forthcoming releases of DeveloperStudio, Platform SDK, and Back-Office Resource Kit (BORK). But don't expect too much clarification from RFC 1823 -- it's not aimed at a specific platform, so you can't expect much detail on the peculiarities of the Microsoft implementation.</p><p>Another problem is Exchange Server itself. Version 5.0 supports LDAPv2 only. Although the version-number leap from 5.0 to 5.5 looks small, the update is a huge step with respect to LDAP and other Internet protocols. Exchange Server 5.5 supports many recent LDAPv3 features, some of which are still under discussion -- search-result paging, for example (see draft-ietf-asid-ldapv3-simplepaged-02.txt and draft-ietf-asid-ldapv3-api-ext-00.txt in the ftp://ds.internic.net/internet-drafts/ directory of InterNIC for details on the respective protocol and API extensions). Thus, writing an LDAP client that works with both Exchange Servers 5.0 and 5.5 is tricky, because it must cope with two quite distinct LDAP versions and implementations.</p><p>As is customary with scarcely documented software, the best source of information is a C header file -- winldap.h in this case. The comments surrounding the definitions of data structures and API prototypes give insights, although they leave many questions unanswered. So the rest of the work remains dedicated to trial-and-error. To save you some time, the general-purpose LDAP utility DLL I present (LdapLib.dll) here makes programming an Exchange directory browser straightforward.</p><h3>Basic Framework</h3><p>The LDAP API library wldap32.dll uses the 32-bit WinSock DLLs wsock32.dll and ws2_32.dll shipping with Windows 95/NT to communicate with LDAP-capable servers. WinSock communication always requires a port where the server listens for incoming connection requests. In the case of LDAP, the default port number is 389. If the server supports the Secure Socket Layer (SSL), you should connect to port 636 instead. Exchange Server is SSL-capable. To LDAP enable an application, you must:</p><ol type="1" start="1">	<LI>Include winldap.h somewhere after #include <i>&lt;</i>windows.h&gt;.	<LI>Add wldap32.lib to the project's list of import libraries.</ol><p>The basic LDAP API calling sequence of a typical directory browser application is as follows:</p><ol type="1" start="1">	<LI>The application initiates an LDAP connection.	<LI>If successful, it binds to the server, passing in authentication data.	<LI>It then issues one or more search requests.	<LI>When done, it unbinds from the server.</ol><p>LDAPv2/RFC 1823 provided the APIs <i>ldap_open()</i> and <i>ldap_*bind*()</i> for the first two steps. (I use the wildcard character * to denote that multiple variants of a function are available.) The LDAPv3 API introduces the new API <i>ldap_init()</i>, while at the same time deprecating the use of <i>ldap_open()</i>. The difference between them is that <i>ldap_open()</i> immediately attempts to connect to the server, while <i>ldap_init()</i> doesn't. Since <i>ldap_init()</i> works perfectly with both Exchange Server versions, it seems safe to forget about <i>ldap_open()</i> altogether.</p><p><i>ldap_init()</i> doesn't do much more than return a connection handle; that is, a pointer to a structure of type "LDAP" used to track the status of an LDAP connection. In the LDAPv2 specification, parts of this structure were officially documented (see page 3 of RFC 1823) and could be directly accessed by clients. LDAPv3 discourages direct access, defining the LDAP structure as opaque (although parts of it are still LDAPv2 compatible). To read from and write to selected members of this structure, LDAPv3 adds the <i>ldap_get_option()</i> and <i>ldap_set_option()</i> APIs.</p><h3>The LDAPLIB Library</h3><p>Although the LDAP API works on a high abstraction level and saves you from many scary implementation details of the LDAP protocol, some gaps still remain. To fill them, the LdapLib.dll LDAP library presented here hides nasty LDAP details such as version negotiation and server authentication, transparently handles paged search results if appropriate, and the like.</p><p>The complete set of LdapLib project files, plus those of a console-oriented LDAP Directory Information Tree (DIT) dump utility (LdapDump.exe) that demonstrates the use of many of the APIs exported by LdapLib.dll, is available electronically. Both projects can be built with Microsoft Visual C/C++ 5.0. No linker options need to be set manually; they are included as <i>#pragma</i> directives in the header files.</p><p>At the core of the browsing functions in LdapLib.c is <i>LdapFindCollect()</i> that tests for LDAPv3 and, if available, uses Microsoft's paged results APIs. Otherwise, it falls back to the LDAPv2 standard API <i>ldap_search_st()</i>. <i>LdapFindCollect()</i> dynamically allocates and fills a linked list of LDAP_FIND structures (see <A NAME="rl1"><A HREF="9812j.htm#l1">Listing One</A>; located at the end of this article), where each list item corresponds to a result page. In the special case of LDAPv2, only a single list item is created.</p><p>This linked list approach enables other LdapLib.dll APIs, like <i>LdapFindNext()</i> and <i>LdapFindCount()</i>, to transparently handle search results with or without paging, by simply walking the LDAP_FIND list and evaluating all entries available from each list item. In this context, an LDAPv2 search result is equivalent to an LDAPv3 result that contains just a single page. To clean up the linked list, just call <i>LdapFindCleanup()</i> passing in its anchor (that is, the pointer to the first LDAP_FIND structure).</p><p>Since the source code of LdapLib.c is more than 1000 lines in length, it's impossible to reprint it here in its entirety. <A NAME="rl2"><A HREF="9812j.htm#l2">Listing Two</A> demonstrates another essential excerpt that handles LDAP initialization and binding (server authentication). <i>LdapConnect()</i> receives and initializes an LDAP_CONN structure, defined in <A HREF="9812j.htm#l1">Listing One</A>.</p><p>The arguments <i>ptServer</i>, <i>ptAccount</i>, and <i>ptPassword</i> are used in the authentication step (see the <i>ldap_bind_s()</i> call in <A HREF="9812j.htm#l2">Listing Two</A>). <i>ptServer</i> is the DNS name or IP address of the LDAP server. <i>ptAccount</i> specifies the ID of the user that should be logged in, and <i>ptPassword</i> is an optional password. If the latter is not NULL, "simple authentication" (LDAP_AUTH_SIMPLE) is used. Otherwise, the server is directed to use NT LAN Manager authentication (LDAP_AUTH_NTLM). <i>ptAccount</i> is either a single NT account name, or a domain\name pair. <i>LdapConnect()</i> calls the LdapLib.dll API <i>LdapNameFromAccount()</i> to convert the specified string to the DN format required by the LDAP protocol (<i>cn=&lt;name&gt;</i> or <i>dc=&lt;domain&gt;,cn =&lt;name&gt;</i>).</p><p>The remaining arguments -- <i>dPort</i>, <i>dVersion</i>, <i>dPage</i>, and <i>dTimeout</i> -- are connection options that may affect the behavior of subsequent LDAP requests. The easiest way to set them correctly is to pass in the corresponding LDAP_PRESET_* constants defined in LdapLib.h. This will select reasonable default values. <i>dPort</i> is the TCP port used to connect to the server, and its default value is 389. <i>dVersion</i> specifies the required LDAP version, with a default value of 2, corresponding to LDAPv2.</p><p>dPage indicates the maximum page size to be used in LDAPv3 search requests. To avoid a return code of LDAP_ADMIN_ LIMIT_EXCEEDED, this value should always be selected less or equal to the value entered for the "Maximum number of search results" option by the Exchange admin. It defaults to 100, which is the preset used by the Exchange Server setup and hence should be okay in most real-life scenarios. If <i>dPage</i> is set to 0, paged results are disabled, and the <i>LdapFindCollect()</i> API refrains from using paged results, even if it detects a server version of LDAPv3 or higher.</p><p>The <i>dTimeout</i> argument indicates the number of milliseconds the client is willing to wait on remote operations. It is used on the LDAP API calls <i>ldap_connect()</i>, <i>ldap_search_st()</i>, and <i>ldap_get_ next_page_s()</i>. Its default value is 10,000. This is just enough to avoid timing out on lengthy search operations on slow servers. The LDAP API requires an LDAP_TIMEVAL structure to specify timeout values. LdapLib.dll introduces scalar millisecond values instead (which are much easier to handle), and converts them transparently before all LDAP calls that involve a timeout.</p><h3>Conclusion</h3><p>If you need to traverse the directory tree of Exchange Server 5.x and evaluate the attributes attached to its entries, the LDAP interface is an alternative to Extended MAPI, the Exchange core interface. Since LDAP is being standardized in terms of Internet RFCs and drafts, it's an open Standard. However, many aspects of Microsoft's LDAP implementation are semidocumented, and writing LDAP clients is still an empirical task.</p><p><b>DDJ</b></p><H4><A NAME="l1"></A>Listing One</H4><pre>typedef struct _LDAP_CONN    {    PLDAP        pl;    DWORD        dPort;    DWORD        dVersion;    DWORD        dPage;    DWORD        dTimeout;    LDAP_TIMEVAL ltTimeout;    TBYTE atUser [N_DN];    }    LDAP_CONN, *PLDAP_CONN, **PPLDAP_CONN;#define LDAP_CONN_ sizeof (LDAP_CONN)<p></p>typedef struct _LDAP_FIND    {    struct _LDAP_FIND *plf;    struct _LDAP_FIND *plfNext;    PLDAP_CONN         plc;    PLDAPMessage       plm;    PLDAPMessage       plmNext;    DWORD              dEntries;    }    LDAP_FIND, *PLDAP_FIND, **PPLDAP_FIND;#define LDAP_FIND_ sizeof (LDAP_FIND)<p></p></pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two </H4><pre>DWORD EXPORT LdapConnect (PLDAP_CONN plc,                          PTBYTE     ptServer,                          PTBYTE     ptAccount,                          PTBYTE     ptPassword,                          DWORD      dPort,                          DWORD      dVersion,                          DWORD      dPage,                          DWORD      dTimeout)    {    DWORD dStatus = LDAP_OTHER;    plc-&gt;pl = NULL;    plc-&gt;dPort    = (dPort    != LDAP_PRESET_PORT    ?  dPort                                                     : gdPort);    plc-&gt;dVersion = (dVersion != LDAP_PRESET_VERSION ?  dVersion                                                     : gdVersion);    plc-&gt;dPage    = (dPage    != LDAP_PRESET_PAGE    ?  dPage                                                     : gdPage);    plc-&gt;dTimeout = (dTimeout != LDAP_PRESET_TIMEOUT ?  dTimeout                                                     : gdTimeout);    plc-&gt;ltTimeout.tv_sec  = (plc-&gt;dTimeout / 1000);    plc-&gt;ltTimeout.tv_usec = (plc-&gt;dTimeout % 1000) * 1000;<p></p>    LdapNameFromAccount (ptAccount, plc-&gt;atUser, sizeof (plc-&gt;atUser));    if ((plc-&gt;pl = ldap_init ((*ptServer ? ptServer : NULL), plc-&gt;dPort))        != NULL)        {        LdapVersionSet (plc, plc-&gt;dVersion);        if (((dStatus = ldap_connect (plc-&gt;pl, &amp;plc-&gt;ltTimeout))             != LDAP_SUCCESS)            ||            ((dStatus = ldap_bind_s (plc-&gt;pl, plc-&gt;atUser, ptPassword,                   (ptPassword != NULL ? LDAP_AUTH_SIMPLE : LDAP_AUTH_NTLM)))             != LDAP_SUCCESS))            {            LdapDisconnect (plc);            }        }    else        {        dStatus = LdapError ();        }    return dStatus;    }</pre><P><A HREF="#rl2">Back to Article</A></P><p><b>DDJ</b></p><HR><I>Copyright &copy; 1998, Dr. Dobb's Journal</I><BR>
</body></html>