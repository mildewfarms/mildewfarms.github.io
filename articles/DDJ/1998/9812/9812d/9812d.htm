<html><head><title>Dec98: Protocols for E-Commerce</title></head><body bgcolor="FFFFFF"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Protocols for E-Commerce</h1><p><i>Dr. Dobb's Journal</i> December 1998</p><h2>Paving the way for electronic business</h2><h3>By Taimur Aslam</h3><I>Jeremy is the CTO at BlueMoney Software. He can be reached at jeremey@ bluemoney.com.</I><hr>Sidebar: <a name="rs1"></a><a href="9812ds1.htm">Blind Signatures</a><br>Sidebar: <a name="rs2"></a><a href="9812ds2.htm">The BlueMoney Trust Model</a><br>Sidebar: <a name="rs3"></a><a href="9812ds3.htm">Cryptographic Basics</a><br><hr><p>We are accustomed to conducting business transactions using cash and credit cards, but these do not match the requirements of online services. Electronic transaction systems must be secure, have low overhead, and may need to protect user privacy.</p><p>The financial and technological community has created several payment models and protocols to address these issues. In this article, I'll discuss four different e<sub></sub>commerce techniques. Each was chosen to be representative of a class of transaction and payment models. For instance, iKP provides a model for secure credit card transactions, Millicent exemplifies a method for micropayments, and Netcash and Digicash present a model for anonymous transactions.</p><h3>iKP</h3><p>The iKP protocols were designed at IBM-Z&uuml;rich to provide secure credit card payments over an insecure network like the Internet. These protocols use the existing credit card infrastructure for clearing financial transactions. iKP formed the basis of the Secure Electronic Payment Protocol (SEPP), which was endorsed by Visa for secure credit payments. Ideas from SEPP and Secure Transaction Technology (STT) formed the basis for the Secure Electronic Transaction (SET) system developed by Visa and Mastercard. The SET protocol is emerging as the next-generation standard for smart cards and credit card payments.</p><p>The 1KP, 2KP, and 3KP protocols (together known as "iKP") use a trust model with five parties. The first of these is the Certification Authority (<i>CA</i>). The certification authority is a trusted entity who holds a public and secret key pair (<i>PKCA, SKCA</i>) and can sign other peoples' public keys as "(X, PKX)SKCA." For more information, see the accompanying text box entitled "Cryptographic Basics."</p><p>The acquirer (<i>A</i>) is a financial institution like a credit card company responsible for clearing and handling financial requests. The acquirer holds a public and secret key pair (<i>PKA, SKA</i>) in all iKP protocols and all merchants know <i>PKA</i>.</p><p>The issuer (usually a bank) is responsible for issuing credit cards to customers. The issuer receives transaction records from the acquirer to clear the transactions. The issuer and acquirer trust each other, and a secure infrastructure is in place between them.</p><p>The last two parties in iKP are the merchant (<i>M</i>) who provides goods or services and the customer (<i>C</i>) who purchases those goods and holds a valid credit or debit card from the issuer. In 2KP, merchants have their own signed key; in 3KP, merchants and customers each have signed keys.</p><p>The iKP protocols were designed to meet several requirements. The acquirer must have unforgetable proof that the payment was requested by a given merchant and authorized by the owner of the credit card. The merchant needs unforgeable proof that the customer has requested payment and the acquirer has authorized the payment. The customer needs unforgetable proof that the merchant is accredited by the acquirer, the acquirer has authorized the transaction, and the merchant has received payment. It must no be possible to charge something without proper approval from the customer.</p><p>Before the protocol starts, each entity already possesses certain information: The customer knows the certification authority's public key <i>{PKCA}</i>, the acquirer holds a signed public key and a secret key <i>{CERTA, SKA}</i>, and the merchant knows the acquirer's public key and has a certificate from the certification authority <i>{CERTA}</i> that attests to the validity of that key.</p><p>The protocol begins after the customer has chosen particular goods and has agreed on a price with the merchant.</p><ol><li>The customer generates two random numbers <i>{R0, SALT0}</i> and forms a customer <i>ID=H(R0, customer account number)</i>, where the customer account number is information that identifies a customer (such as a credit card number). The customer sends <i>SALT0</i>, customer ID, and any optional information to the merchant. This completes the initiate phase.<li>The merchant uses a timestamp (<i>DATE</i>) and a nonce, <i>NONCEM,</i> to unambiguously identify this transaction. The merchant then chooses a transaction ID (merchant's transaction ID), computes <i>H(transaction description, SALT0)</i>, constructs <i>Common={price, merchant's ID, merchant's transaction ID, DATE, NONCEM, customer ID, H(transaction description, SALT0)},</i> and computes <i>H(Common)</i>. The merchant sends <i>{H(Common), merchant's ID, merchant's transaction ID, DATE, NONCEM}</i> to the customer, thus completing the invoice stage of iKP.<li>Upon receiving the invoice from the merchant, the customer begins the payment mechanism. He forms CLEAR as: <i>{merchant's ID, merchant's transaction ID, DATE, NONCEM, H(Common)}</i>; recomputes <i>H(Common), </i>and compares it to the value sent by the merchant. The customer then creates S<i>LIP={price, H(Common), customer account number, RC}</i>, encrypts it using the acquirer's public key as <i>(SLIP)PKA</i>, and sends it to the merchant.<li>The merchant sends an authorization request to the acquirer and forwards <i>(SLIP)PKA, CLEAR,</i> and <i>H(transaction description, SALT0) </i>to the acquirer.<li>The acquirer decrypts <i>SLIP</i> and compares <i>H(Common)</i> in <i>SLIP</i> to <i>H(Common) </i>in CLEAR. The acquirer also reforms <i>Common</i>, computes <i>H(Common)</i>, and compares this to the other two <i>H(Common)</i> values. Finally, it submits an authorization request to an existing infrastructure such as a credit card issuer. On receiving a yes/no response, it encrypts the response and <i>H(Common)</i> with the acquirer's secret key, and sends the encrypted response to the merchant.<li>On receiving the signature from the acquirer, the merchant decrypts the received message using the acquirer's public key, retrieves the acquirer's response, and checks for a valid acquirer signature. It then forwards the response to the customer along with the acquirer's signature. This completes the confirm phase of the protocol.</ol><h3>Millicent </h3><p>Millicent was designed by Digital Equipment's Systems Research Center at Palo Alto, California, to provide a mechanism for secure micropayments. Typical electronic transactions amount to a few dollars, but for transactions that cost a few cents or a fraction of a cent, the cost of the protocol outweighs the cost of the transaction. Millicent addresses this problem by providing lightweight secure transactions that are suitable for micropayment transactions.</p><p>The trust model in Millicent defines three roles -- vendors, customers, and brokers. Brokers act as intermediaries between vendors and customers. A customer enters into a long-term relationship to buy digital money (scrip) from brokers, who are assumed to be large entities such as banks or credit card issuers. Brokers are most trusted in this model; customers are least trusted.</p><p>Millicent's security model requires that all transactions be protected and that fraud be detectable and traceable. However, fraud is not considered a major concern because Millicent is used for inexpensive transactions.</p><p>In Millicent, digital money is represented by scrip. Like cash, scrip has a defined value and can be used to purchase merchandise. However, scrip differs from typical cash in several respects. It has value only at a specific vendor, and can only be spent by the customer who obtained it from the broker. Each scrip is uniquely identified by a serial number and can only be spent once. Furthermore, scrip contains an expiration date and a digital signature that attests to its value and authenticity.</p><p>There are three secrets involved in producing, validating, and spending scrip. The customer is sent a <i>customer_secret </i>to prove ownership of the scrip he holds. The vendor uses the <i>master_customer_scrip</i> to derive the <i>customer_secret</i> from the customer's information sent to him. The third secret is the <i>master_scrip_secret,</i> which is used by vendors to prevent tampering and counterfeiting of digital money.</p><p>The following terminology is defined in Millicent.</p><ul>  <li><i>id_material={vendor_id, {master_scrip_secretid , id_sequence},{master_customer_secret,customer_id_sequence}}.</i>  <li><i>cert_material={properties, value, expiration_date}.</i>  <li><i>scrip_body={id_material, cert_material}.</i>  <li><i>cert=H(scrip_body, master_scrip_secret).</i>  <li><i>scrip={scrip_body, cert}.</i>  <li><i>SessionId </i>is a string that contains <i>N</i> (a session number), and is unique to the session. The vendor computes secret <i>X(N)</i> and keeps it as long as the session lasts. The session key <i>k</i> is <i>H(SessionId # X(N))</i>, where "#" denotes concatenation.</ul><p>The information that flows between a vendor and a customer is denoted as <i>Info</i>. Both parties can choose to encrypt all or portions of <i>Info</i> using <i>k</i>, the session key.</p><p><i>Coin</i>s for scrip are minted as follows. A <i>Coin </i>consists of a serial number and a string that denotes its value. A signature that attests to the value of the string is computed as: <i>H(SessionID # Info # Coin # X(N))</i>. <i>Coin</i>s minted by a broker should have the property that <i>X(N)=X(Z)</i> if and only if <i>N=Z</i>.</p><p>In the following transaction scenarios, assume that a customer already has established an account with a broker, and purchased scrip.</p><h3>Insecure Transactions </h3><p>1.	A customer sends scrip along with a transaction request to a vendor. Upon receiving the scrip, the vendor computes the certificate as: <i>H(scrip_body, master_scrip_secret)</i> and compares it to the certificate of the scrip. Any mismatch will indicate that the scrip has been tampered with, and the vendor can refuse to honor it. The vendor then checks for double spending by searching his database for the scrip's serial number. If the number is not found, the transaction is approved and the vendor records the scrip's serial number in his database to prevent customers from double spending in the future.</p><p>2.	During the second phase of the transaction, the vendor returns a brand new scrip to the customer. The new scrip has a value that is the difference of the original and the cost of the transaction. The new scrip, however, contains the same <i>customer_id</i>. Along with the new scrip, a response is also sent to the customer and may optionally be signed by the vendor to prove authenticity.</p><h3>Authentic and Private</h3><ol><li>The customer sends <i>{vendor_id, customer_id, (scrip, request)customer_secret}</i> to the vendor. The scrip and request are encrypted using the <i>customer_secret. </i>The vendor calculates the <i>customer_secret</i> using the <i>customer_id</i>, and performs all the steps described in the first step of the insecure transaction.<li>The vendor returns <i>{vendor_id, customer_id, (scrip', cert, reply)customer_secret}</i> to the customer. The returned <i>scrip'</i> is a brand new scrip and contains the new value of the scrip. Upon receipt of the vendor's response, the customer can retrieve <i>scrip'</i>, <i>cert</i>, and reply using <i>customer_secret</i>.</ol><h3>Authentic Only</h3><ol><li>The customer sends <i>{scrip, request, H(scrip, request, customer_secret)}</i> to a vendor. The message is sent in clear, but is protected by the <i>customer_secret</i> in the hash function. Upon receiving the request, the vendor calculates the hash function using a preselected message digest function. Other actions are similar to the first step of the insecure version.<li>The vendor returns <i>{scrip', reply, H(scrip', cert, reply, customer_secret)}</i>. Upon receiving this information, the customer can compute the message digest to ensure authenticity.</ol><h3>Digicash</h3><p>Digicash is unique in its implementation of electronic cash because it has attempted to preserve the anonymity and untraceability associated with cash transactions. At the heart of the anonymous transaction scheme is the idea of blind signatures.</p><p>The Digicash protocol requires two new components: A representative is a smart-card size computer containing memory and microprocessor. It can communicate with the outside world via card readers or terminals and is enclosed in a tamper-resistant package. An observer is issued by a certified authority that certifies the behavior of the representative in which it is embedded.</p><p>After a user acquires an observer, he places it in his smart-card representative and gets it validated by a trusted authority. The observer then generates a pair of public and private keys, blinds them by a random factor, and signs the result with a special secret key. The blinded keys and the signature are sent to the trusted authority who then signs the blinded keys. These signed keys serve as the user's pseudonym for future transactions.</p><p>The Digicash protocol is based on the interaction of the observer and representatives.</p><p>Suppose customer <i>A</i> wants to pay for some goods bought from <i>B</i>. Customer <i>A</i> withdraws money from a bank by connecting his representative to the bank's terminal. The observer witnesses this transaction and records which notes were withdrawn.</p><p>To spend the money, <i>A</i> sends the bank notes and his pseudonyms to <i>B</i>. The bank notes are signed by <i>A'</i>s observer using a secret key which states that these notes will only be spent at <i>B'</i>s shop at a particular time and date. This prevents <i>A</i> from double spending because the observer is programmed to sign any given note only once.</p><p>In addition to being used for financial transactions, observers and representatives can also be used for user authentication, proof of credentials, and other purposes.</p><h3>Netcash </h3><p>The Netcash protocol can also support anonymous transactions. Electronic currency in Netcash is denoted by coins that can be purchased using paper money or check.</p><p>The Netcash protocol assumes the existence of currency servers that can mint coins, and a Federal Insurance Corporation (FIC) that authenticates those servers. The currency servers also check for double spending, exchange of coins among customers, and exchange of electronic coins for physical cash.</p><p>When a server is commissioned, it must register with an FIC and get an insurance certificate to produce and manage electronic currency. To register, the server creates a pair of public and secret keys denoted by <i>PKCS</i> and <i>SKCS,</i> respectively. It sends the public key to an FIC, which returns a certificate of insurance encrypted under the FIC's secret key as: <i>{Certificate_Id, CS_name, PKCS, issue_date, expiration_date}SKFIC</i>. The currency server can now mint coins as: <i>{CS_name, server_Internet_address, expiry_date, serial_number, coin_value} SKCS, Certificate_Id</i>.</p><p>A customer buys coins by sending <i>{payment/check, secret_key, transaction} PKCS</i>. The currency server returns the coins in the amount enclosed as <i>{coins} secret_key</i>. The customer can now proceed to make payments in the Netcash protocol. To preserve the anonymity of a customer and to prevent vendors from cheating, coins can be customized so that they can only be used by a particular individual during a given period of time. For instance, a principal <i>A</i> can obtain a coin tuple <i>&lt;CB, CA, CX&gt;</i>, where <i>CB</i> and <i>CA</i> are intended for <i>B</i> and <i>A,</i> respectively, while <i>CX</i> is a generic coin that can be spent at any location. Coin <i>CB</i> contains<i> B'</i>s encrypted public key, and <i>B</i> must provide his secret key <i>SKB</i> before he can use it.</p><p>The Netcash protocol facilitates anonymity, prevents double spending, and keeps vendors from cheating.</p><ol><li>Suppose that customer <i>A</i>, wants to trade with <i>B.</i> To obtain the currency, <i>A</i> sends <i>{coins, Secret_key1, public key of B, expiration dateB, dateA, amount} PKCS</i> to the currency server. In this transaction, <i>dateB</i> and <i>dateA</i> denote <i>A'</i>s and <i>B'</i>s windows of operation.<li>The currency server mints a triple <i>&lt;CB, CA, CX&gt;</i> as described earlier and sends <i>{&lt;CB, CA, CX&gt;, , CX&gt;} Secret_key</i>. In this transaction, <i>&lt;,, CX&gt;</i> denotes the change returned.<li>To purchase goods from <i>B</i>, customer <i>A</i> sends <i>{CB, secret_key2, session_key, service_required} PKB</i>. <i>B</i> keeps track of the coin <i>CB</i> until it expires to prevent <i>A</i> from double spending it. This also prevents <i>B</i> from cheating, and if <i>B</i> did not issue a receipt, <i>A</i> can query the currency server to find whether <i>B</i> spent the coin. If <i>B</i> did spend the coin, the currency server will issue a receipt and return <i>B'</i>s public key. Otherwise, <i>A</i> can request a refund for the amount of <i>CB</i> before <i>CA'</i>s expiration because <i>CA</i> was minted to be used by <i>A</i>.<li>Finally, <i>B</i> returns <i>{{amount, transaction id, date} SKB} secret_key2,</i> and the transaction is complete.</ol><h3>Conclusion</h3><p>iKP provides secure transactions for credit card payments using the existing financial infrastructure for approvals and clearing. Millicent is a lightweight protocol suitable for micropayments. Netcash provides a real-time electronic payment scheme with provisions for secure anonymous exchanges over an insecure network. Digicash provides anonymous transactions using smart cards and blind signatures.</p><p>As the Internet continues to become more popular, e-commerce techniques will evolve to meet the challenges of online financial transactions. It is not yet clear whether a particular payment model will emerge as a de facto standard. It is quite likely that multiple standards will continue to coexist much as the different paper currencies coexist. However, as electronic commerce gains popularity, some potential challenges will have to be addressed. Prevention of money laundering and fraud is still an open issue, despite the security mechanisms of the protocols. The authentication infrastructure will have to be put in place to prevent fraudulent activities and boost consumer confidence. It is also not clear if and how online transactions can be taxed, since there are no geographical boundaries on the Internet.</p><h3>References</h3><p>Ballare, M. et al.<i> iKP: A Family of Secure Electronic Payment Protocols</i>. http://www .zurich.ibm.com/technology/security/extern/ecommerce/ikp_references.html.</p><p>Chaum, David. "Achieving Electronic Privacy." <i>Scientific American</i>, August 1992.</p><p>Glassman, Steve et al. "The Millicent Protocol for Inexpensive Electronic Commerce." <i>World Wide Web Journal, </i>4th WWW Conference Proceedings, p 603-618, December 1995. http://www.research.digital.com/SRC/staff/msm/bib.html.</p><p>Manasse, Mark S.<i> The Millicent Protocols for Electronic Commerce</i>. http://www .millicent.org/html/papers/mcentny.htm. </p><p>Medvinsky, G., and B.C. Neuman<i>. </i>"Netcash: A Design for Practical Electronic Currency on the Internet."<i> Proceedings of the First ACM Conference on Computer and Communications Security. </i>ACM Press, 1993.</p><p>Schneier, Bruce.<i> Applied Cryptography</i>. Second Edition. John Wiley &amp; Sons, 1996.</p><p><b>DDJ</b></p><HR><I>Copyright &copy; 1998, Dr. Dobb's Journal</I><BR>
</body></html>