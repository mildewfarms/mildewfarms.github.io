<html>
<META NAME="year" CONTENT="1998">
<head>
<title>Dr. Dobb's Journal January 1998: Reflecting on Beans</title>
</head>

<body bgcolor="FFFFFF">
<!--Copyright &#169; Dr. Dobb's Journal-->
<h1>Reflecting on Beans</h1>
<p><i>Dr. Dobb's Journal</i> January 1998 </p>


<h3>By Chris Howard</h3>
<HR>
<P>
JavaBeans, the platform-neutral component architecture for Java, was added in JDK 1.1. In the Windows world, a Java Bean is similar to an OCX or VBX control. A Bean is reusable and can be visually manipulated in a software-development tool such as Borland's JBuilder, IBM's VisualAge for Java, Sun's Java Workshop, Sybase's PowerJ, Symantec's Visual Cafe, and, to some extent, Microsoft's Visual J++. But how do those tools know how to manipulate a Bean? They do it through a process known as "reflection."
</P>

<p>In the past, a software component might publish an API in a separate definition file or use some other technique to inform an application of its interface: A Bean-aware application uses the Java Core Reflection API instead. This lets an application dynamically read the class and method definitions directly from the binary class file. With reflection, you can acquire interfaces and instances for any other object. Without reflection, JavaBeans wouldn't be possible.</p>


<P>
The Java Core Reflection API is a low-level interface, and while it can be used directly, there are some pitfalls. Determining a valid method for a Bean can be subject to some interpretation by third-party applications. An easier (and better) way to inspect Bean properties is the <i>Introspector</i> class, which uses the Reflection API internally to do its work.
</P>


<P>
The <i>Introspector</i> class understands Beans completely, so it won't make any mistakes interpreting Bean methods and properties. If all applications use the <i>Introspector</i> class to get a Bean's interface, they will all expose a consistent representation of the Bean's methods. The main function of the <i>Introspector</i> class is to return a <i>BeanInfo</i> class for any Bean passed as an argument to one of two <i>getBeanInfo(bean)</i> methods. One method merges all <i>BeanInfo</i> descriptions of every parent of the specified Bean; the other method lets you specify a class beyond which introspection should be ignored. Remember that every Java class is a legal Bean, so the inheritance chain could be quite long if you don't stop it. Eventually, it will stop at the <i>Object</i> class.
</P>

<P>
If a Bean does not specify a <i>BeanInfo</i> class, then one will be constructed automatically by the <i>Introspector</i> class and returned. Most Beans designed for third-party use in a Java IDE will implement a <i>BeanInfo</i> object. The information in a <i>BeanInfo</i> includes property, event, set, and method descriptors, as well as default values, and even a Bean icon that can be used by the IDE to represent the Bean.
</P>

<P>
You don't have to be writing an IDE to make use of the <i>Introspector</i> class. Any application can be a container for JavaBeans. This means you can structure your program in such a way that your application examines Beans, and can determine their use on the fly. A paint program, for instance, could implement drawing objects and graphics file formats as Beans. For your Java applications, it's something to reflect on.
</P>
<P>
 -- C.H.
</P>
<P>
<a href="9801c.htm#rs1">Back to Article</A>
</P>
<HR><I>Copyright &copy; 1998, Dr. Dobb's Journal</I><BR>

</BODY>
</html>
