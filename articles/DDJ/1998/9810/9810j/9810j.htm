<html><head><title>Oct98: Visual Basic 6 Filesystem Objects</title></head><body bgcolor="FFFFFF"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Visual Basic 6 Filesystem Objects</h1><p><i>Dr. Dobb's Journal</i> October 1998</p><h2>The devil is in the details</h2><h3>By Paul Lomax</h3><I>Paul is a Visual Basic consultant based in the UK. He is also the author of VB and VBA in a Nutshell: The Languages (O'Reilly &amp; Associates, 1998). He can be contacted at paul@vbnutshell.com.</I><hr><p>Microsoft's Visual Basic 6 (VB6) is not the revolutionary type of release we saw with VB4 and VB5. Consequently, it would be easy to overlook some of the important features VB6 offers. Much of the enhanced functionality in VB6 has been achieved by the use of external object models; one such improvement is the File-System Object Model (FSOM).</p><p>The FSOM first saw the light of day in the second release of VBScript, where it was limited to allowing server-side scripts to access and manipulate text files. For VB6, the FSOM has been extended and made available via the Scripting Run-Time Library -- which can now be directly referenced in a VB project.</p><h3>Reaching Out </h3><p>The FSOM relates to the drives -- and the folders and files therein -- connected to the local machine. This includes any drive that is part of the local computer -- hard disk, CD-ROM drives, removable media drive, or a drive connected via a network. Network drives do not have to be manually connected to the computer using Explorer or a log-on script. You can access any network drive at run time, given that the interactive user has permission to do so. <A NAME="rl1"><A HREF="9810j.htm#l1">Listing One</A> for instance, shows how you can obtain a reference to a <i>Drive</i> object on the network.</p><p>You can use the <i>Drive</i> object to determine what type of drive you are dealing with. Unfortunately, this information is not as rich as it could be. For example, you cannot determine if a network drive is a compressed network drive or a removable media network drive -- they all simply appear as generic network drives.</p><p>Once you have obtained a reference to a <i>Drive</i> object representing the drive you need to work with, you can quickly navigate through folders and subfolders on the drive and obtain information about the files within these folders.</p><p>You can use the FSOM to delete, create, and move folders and files. All the methods relating to moving and deleting folders are the same as the functionality in the Windows Explorer, where deleting or moving of a folder affects all the contents of that folder.</p><h3>Filesystem Objects versus Intrinsic File Functions</h3><p>Many of the intrinsic file system statements found in VB predate the "visual" of Visual Basic. The information they return is at best minimal because most of the file manipulation functionality is provided by statements (as opposed to Functions), which means that values denoting the success or failure of a particular operation are not returned.</p><p>The intrinsic filesystem statements in VB were written when it was unusual for a PC to have more than one drive, let alone access to CD-ROMs, removable media hard drives, and network drives of all types. Therefore, the concept of pointing the whole program at a single drive at any one time was adequate. </p><p>For an application running in Windows NT, where it may need to access several different drives on different machines (or even on different continents), the intrinsic VB file system statements are clearly inadequate. By representing any physical drive, folder, or file on the machine, LAN, or WAN by an object, your VB application can hold multiple references to a limitless array of filesystem components -- a far cry from the <i>ChDrive</i> statement.</p><p>The property values and information available to you from the FSOM are much richer than that you can obtain from the intrinsic functions. For example, you can return the date and time a file or folder was created and modified, and (if supported by the operating system) the date and time a file or folder was last accessed. </p><p>The FSOM gives you much greater functionality; for example, you can use the FSOM to generate valid windows-temporary-file names, or return an object representing special windows folders such as System32 and Temp as in <A NAME="rl2"><A HREF="9810j.htm#l2">Listing Two</A>.</p><p>Perhaps the only downside to the FSOM is the inability to work directly with VB Random Access and Binary files. The <i>File</i> object's <i>Open</i> method returns only a <i>TextStream</i> object. While you can always write code to manipulate the binary data within the file, you'll probably still find this sort of work easier with VB's <i>Open</i>, <i>Get</i>, and <i>Put</i> statements. You can create a <i>File</i> object representing any file type, and obtain property values from it, and move, copy, or delete it; however, you can only open it as a text file.</p><h3>Accessing the FSOM </h3><p>The FSOM is part of the Microsoft Scripting Runtime Library (SCRRUN.DLL). To use the objects within this library, you must first add a project-level reference to the library using the References Dialog Box, which (as in VB5) is under the Project menu.</p><p>Once you have a project-level reference to the Scripting Runtime Library, you can create an instance of the public "top of the tree" <i>FileSystemObject</i> object; see <A NAME="rl3"><A HREF="9810j.htm#l3">Listing Three</A>.</p><h3>Using the <i>FileSystemObject</i> Object </h3><p>The <i>FileSystemObject</i> is the only object that can be created as new. It sits at the top of the filesystem hierarchy, and also acts as a general-purpose object that allows you to manipulate drives, folders, and files without having to create individual objects for them, thereby relieving you of the chore of having to navigate down through the object model.</p><p>Many of the every-day tasks can be completed by simply creating an instance of the <i>FileSystemObject</i> object and calling one of its many methods. For example, to move a folder, you could use <A NAME="rl4"><A HREF="9810j.htm#l4">Listing Four</A>.</p><p>You can also use the <i>FileSystemObject</i> to skip down the object model, bypassing the normal hierarchical structure, and creating instances of the object you require. For example, to create an instance of a particular <i>Folder</i> object, you can simply call the <i>GetFolder</i> method in <A NAME="rl5"><A HREF="9810j.htm#l5">Listing Five</A>.</p><p>Another useful set of properties are available in the <i>FileSystemObject</i> to detect the existence of a drive, folder, or file. <A NAME="rl6"><A HREF="9810j.htm#l6">Listing Six</A> demonstrates how to test for the presence of a file. For more intensive work with the filesystem objects, you will probably need to resort to the individual objects within the model.</p><h3>Navigating through the FSOM </h3><p>If you have any experience of using any object model, then you'll find the FSOM relatively straightforward to use; see <A NAME="rf1"><A HREF="9810jf1.htm">Figure 1</A>.</p><p>However, there is one wrinkle in the way the object model is traversed. With object models in general, you usually create an instance of a collection object, which then leads to a single object, which can lead to another collection object, and so on. However, when you're dealing with the FSOM hierarchy, you may find it strange that the <i>Folder</i> object can only be instantiated via a <i>Folder</i> object. This is so because the first <i>Folder</i> object created from a <i>Drive</i> object is, in fact, the root folder of the drive. After its creation, you subsequently create a <i>Folder </i>object representing the subfolders in the root. </p><p>The <i>Folders</i> collection object is used to obtain a further <i>Folder</i> object representing the subfolders. The <i>Files</i> collection object is accessed via the <i>Folder</i> object, and in turn the <i>File</i> object is accessed via the <i>Files</i> collection. Both the <i>File</i> and <i>Folder</i> objects allow you to navigate back up the hierarchy by providing <i>ParentFolder</i> and <i>Drive</i> properties.</p><h3>The <i>Drives</i> Collection Object</h3><p>The <i>Drives</i> collection represents only those drives that are connected to the machine. Unfortunately, there isn't an <i>Add</i> method to allow you to connect a new network drive, however, this functionality is available via the <i>FileSystemObject</i>'s <i>GetDrive</i> method. Incidentally, adding a <i>Drive</i> in this manner does not add the drive to the <i>Drives</i> collection.</p><p>The <i>Drives</i> collection is keyed on the Drive letter; for example, <i>Drives.Item("C")</i>. Because <i>Item</i> is the default property you can simply use <i>Drives("C")</i>. </p><h3>The <i>Drive</i> Object</h3><p>The <i>Drive</i> object provides you with information about the size of the drive, its available space, serial number, volume name, and the filesystem being used on the drive. You can also determine if the drive is ready (a useful property when dealing with removable media drives) and return a value representing the type of drive; see <A NAME="rl7"><A HREF="9810j.htm#l7">Listing Seven</A>.</p><h3>The <i>Folder</i> Object</h3><p>The first <i>Folder</i> object you create from the <i>Drive</i> object is the <i>Root</i> <i>Folder</i> in <A NAME="rl8"><A HREF="9810j.htm#l8">Listing Eight</A>. Once you have created a root folder object (which is an identical type to any other <i>Folder</i> object except its <i>IsRootFolder</i> property is set to True), you can generate a <i>Folder</i> object, which represents the subfolders within the folder. </p><p>The <i>Folder</i> object itself contains <i>Move</i>, <i>Delete</i>, and <i>Copy</i> methods, which act both on the referenced folder and on all the files and subfolders contained within. Therefore, when you move a folder, you are moving the folder and the file/folder hierarchy below it. There are properties to determine the cumulative size of all files held within the folder, the date the folder was created, modified, and last accessed. </p><h3>The <i>Folders </i>Collection Object</h3><p>The <i>Folder</i> object is a collection of <i>Folder</i> objects. It is created using the <i>SubFolder</i> property of the <i>Folder</i> object. Yes, it does seem strange to create a collection object via a member of the same collection; see <A NAME="rl9"><A HREF="9810j.htm#l9">Listing Nine</A>.</p><p>The <i>Folders</i> collection has the usual <i>Count</i> and <i>Item</i> properties to return further <i>Folder</i> objects, the <i>Item</i> property takes either the ordinal number of the <i>Folder</i> or the folder's name.</p><p>The <i>Folders</i> collection also contains an <i>Add</i> method, which lets you create a new <i>Folder</i> within the subfolder. This isn't a virtual addition (that is, just within the <i>Folder</i> collection), it is a physical addition of a new folder on the drive, as in <i>Folders.Add "DataArchive"</i>. </p><h3>The <i>Files</i> Collection Object</h3><p>As you've probably guessed by now, the Files <i>object</i> is a collection of <i>File</i> objects, representing the files held within a particular folder. You create a <i>Files</i> object using the <i>Files</i> Unlike the Folders collection, the Files collection does not contain an Add method to create new files. In fact the only new files that can be created are <i>textStream </i>files, this is done using either the <i>Folder </i>or <i>FileSystemObject</i> object's <i>CreateTextFile</i> methods, or <i>OpenTextFile</i> method and passing True for the <i>Create</i> parameter. <A NAME="rl11"><A HREF="9810j.htm#l11">Listings Eleven</A> and <A NAME="rl12"><A HREF="9810j.htm#l12">Twelve</A> show these two methods.</p><h3>The <i>File</i> Object</h3><p>Many of the properties of the <i>File</i> object properties are exactly the same as those for the <i>Folder</i> object. It provides <i>Move</i>, <i>Copy</i>, and <i>Delete</i> methods, and timestamp properties for dates created, modified, and accessed; see <A NAME="rl13"><A HREF="9810j.htm#l13">Listing Thirteen</A>.</p><p>The <i>File</i> object also provides a <i>Type</i> property that returns a string based on the file description held in the registry for the particular file extension (if available). For example an .INI file returns "Configuration Settings," whereas an .FFA file returns "FFA File"</p><p>The only type of file that can be opened (and thereby either written to or read) is a text file, which returns the special object <i>TextStream</i>.</p><h3>The <i>TextStream</i> Object</h3><p>The <i>TextStream</i> object was the original reason for the FSOM. When VBScript was first released, all file-handling routines had been removed as they where considered unsafe for browser-side scripts. VBScript Version 2 introduced the <i>FileSystemObject</i> which had one sub object -- the <i>Text- Stream</i>, this allowed server-side scripts and ASPs to have some limited ability to create, write to, and read text files.</p><p>The <i>TextStream</i> object provides several methods to read a given number of characters, a complete line or the complete file, and similar methods to write back to the file as <A NAME="rl14"><A HREF="9810j.htm#l14">Listings Fourteen</A> and <A NAME="rl15"><A HREF="9810j.htm#l15">Fifteen</A>.</p><h3>Conclusion</h3><p>The FSOM is an important addition to VB developers' toolboxes. It is easy to use and it provides access to detailed information about drives, folders, and files.</p><p>The FSOM is well designed providing a top-level object that can be used for most quick tasks, like copying and moving files and folders. At the same time, it provides a complete logical hierarchy representing the complete filesystem on the local machine, the LAN and even the WAN. Its advanced functionality exceeds that of the now aging, intrinsic file-handling routines.</p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>Dim oOFS As FileSystemObjectDim oDrive As DriveSet oOFS = New FileSystemObject    Set oDrive = oOFS.GetDrive("\\NTWS3\C$")<p></p></pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>Dim oFSO As FileSystemObjectDim oFolder As Folder    Set oFSO = New FileSystemObject        Set oFolder = oFSO.GetSpecialFolder(SystemFolder)<p></p></pre><P><A HREF="#rl2">Back to Article</A></P><H4><A NAME="l3">Listing Three</H4><pre>Dim oFSO As FileSystemObject          Set oFSO = New FileSystemObject<p></p></pre><P><A HREF="#rl3">Back to Article</A></P><H4><A NAME="l4">Listing Four</H4><pre>Dim oFSO As FileSystemObjectDim oFolder As Folder    Set oFSO = New FileSystemObject    oFSO.MoveFolder("C:\Program Files\Data\", "C:\Archives\")<p></p></pre><P><A HREF="#rl4">Back to Article</A></P><H4><A NAME="l5">Listing Five</H4><pre>Dim oFSO As FileSystemObjectDim oFolder As Folder    Set oFSO = New FileSystemObject        Set oFolder = oFSO.GetFolder("C:\Program Files\Data\")<p></p></pre><P><A HREF="#rl5">Back to Article</A></P><H4><A NAME="l6">Listing Six</H4><pre>Dim oFSO As FileSystemObjectSet oFSO = New FileSystemObject    If Not oFSO.FileExists("d:\datafiles\newdata.dat") Then        MsgBox "The new data file cannot be found"    End If<p></p></pre><P><A HREF="#rl6">Back to Article</A></P><H4><A NAME="l7">Listing Seven</H4><pre>Dim oFSO As FileSystemObjectDim oDrive As DriveSet oFSO = New FileSystemObject    Set oDrive = oFSO.GetDrive("\\NTWS3\E$")        If oDrive.DriveType = CDRom Then            MsgBox "Sorry - can't write to this drive"        End If<p></p></pre><P><A HREF="#rl7">Back to Article</A></P><H4><A NAME="l8">Listing Eight</H4><pre>Dim oFSO As FileSystemObjectDim oDrive As DriveDim oFolder As FolderSet oFSO = New FileSystemObject    Set oDrive = oFSO.GetDrive("\\NTWS3\C$")        Set oFolder = oDrive.RootFolder<p></p></pre><P><A HREF="#rl8">Back to Article</A></P><H4><A NAME="l9">Listing Nine</H4><pre>Dim oFSO As FileSystemObjectDim oDrive As DriveDim oFolder As FolderDim oFolders As FoldersSet oFSO = New FileSystemObject    Set oDrive = oFSO.GetDrive("\\NTWS3\C$")        Set oFolder = oDrive.RootFolder            Set oFolders = oFolder.SubFolders<p></p></pre><P><A HREF="#rl9">Back to Article</A></P><H4><A NAME="l10">Listing Ten</H4><pre>Dim oFSO As FileSystemObjectDim oDrive As DriveDim oFolder As FolderDim oFiles As FilesSet oFSO = New FileSystemObject    Set oDrive = oFSO.GetDrive("\\NTWS3\C$")        Set oFolder = oDrive.RootFolder            Set oFiles = oFolder.Files<p></p></pre><P><A HREF="#rl10">Back to Article</A></P><H4><A NAME="l11">Listing Eleven</H4><pre>Dim oFSO As FileSystemObjectDim oTextStream As TextStreamSet oFSO = New FileSystemObject    Set oTextStream = oFSO.CreateTextFile("newfile.txt")<p></p></pre><P><A HREF="#rl11">Back to Article</A></P><H4><A NAME="l12">Listing Twelve</H4><pre>Dim oFSO As FileSystemObjectDim oTextStream As TextStreamSet oFSO = New FileSystemObject  Set oTextStream = oFSO.OpenTextFile("newfile.txt",ForWriting, Create:=True)<p></p></pre><P><A HREF="#rl12">Back to Article</A></P><H4><A NAME="l13">Listing Thirteen</H4><pre>Dim oFSO As FileSystemObjectDim oFile As File  Set oFSO = New FileSystemObject     Set oFile = oFSO.GetFile("c:\data\olddata.dat")        Debug.Print oFile.DateLastModified<p></p></pre><P><A HREF="#rl13">Back to Article</A></P><H4><A NAME="l14">Listing Fourteen </H4><pre>Dim oFSO As FileSystemObjectDim oTextFile As TextStreamDim sIncomingData As String Set oFSO = New FileSystemObject   Set oTextFile = oFSO.OpenTextFile("c:\data\textdata.txt", ForReading)      sIncomingData = oTextFile.Read(100)<p></p></pre><P><A HREF="#rl14">Back to Article</A></P><H4><A NAME="l15">Listing Fifteen</H4><pre>Dim oFSO As FileSystemObjectDim oTextFile As TextStreamDim sOutgoingData As String  sOutgoingData = "Some Text"   Set oFSO = New FileSystemObject     Set oTextFile = oFSO.OpenTextFile("c:\data\textdata.txt", ForAppending)       oTextFile.WriteLine sOutgoingData<pre><P><A HREF="#rl15">Back to Article</A></P><HR><I>Copyright &copy; 1998, Dr. Dobb's Journal</I><BR>
</body></html>