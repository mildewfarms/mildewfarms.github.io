<html><head><title>CareersFall98: Surviving the Technical Interview</title></head><body bgcolor="FFFFFF"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Surviving the Technical Interview</h1><p><i>Dr. Dobb's Journal</i> Fall 1998</p><h2>Useful tips and sample problems</h2><h3>By Jay Sutaria</h3><I>Jay is a software engineer at LinkExchange. He can be contacted at jay@ linkexchange.com.</I><hr><p>The technical interview is perhaps the most intimidating and mysterious event that job hunters experience in the quest for that "killer offer." The rigor and format of the technical interview varies from one company to the next, but there are some fundamental similarities. An interviewer presents you with a problem to be solved. The interviewer may leave the room and give you some time to work the solution out before returning. Or the interviewer may wait patiently while you study the problem and figure it out. The interviewer may even start quizzing you right away about aspects of the problem and approaches to solving it. Some of these problems can appear quite challenging, especially if you've never been through a technical interview before. To make matters worse, simply getting the answer to the problem may not be enough to land the job. On the other hand, getting the correct answer may not even be necessary.</p><p>What is an interviewer looking for in candidates during the technical interview? Interviewers recognize that this setting is, by its very nature, stressful. Otherwise competent candidates may be completely stumped by an interview problem only to discover an elegant, simple solution later that night. Interviewers may be interested in seeing how you work under stressful situations or how well you adapt. It is worth noting that interviewers are more interested in seeing how you work than seeing whether you can come up with the correct answer. In this article, I will deal with both how you can better showcase your skills and experience, and what kinds of problems you can expect to be asked.</p><h3>The Basic Rules</h3><p>These basic rules are often taught to programmers and are (or at any rate, should be) drilled into your head in computer-science classes. For some reason, however, they are easily forgotten during the technical interview. Being one of the few candidates careful and experienced enough to remember these important steps can make the difference between getting an offer and getting the cold shoulder.</p><p><b>Don't be afraid to ask for clarifications of the problem or the requirements for the solution.</b> You should never assume that you have been given all the data necessary to solve the problem to the satisfaction of the interviewer. This is especially likely to be the case when interviewing with IT consulting companies. In this environment, the client may need some prodding in order to provide a complete specification. So, the reasoning goes, ideal candidates will be willing to talk to the client to figure out the expected inputs, the desired outputs, the data ranges and data types, and the special cases. The ideal candidate will ask these questions rather than spend all the allotted time coming up with a solution that doesn't meet the client's needs.</p><p>The first thing to do, then, is to make sure that you and the interviewer agree on what the problem is and what an acceptable solution would be. Make all of your assumptions explicit and up-front, so the interviewer can correct you if you are mistaken.</p><p><b>Think out loud.</b> If the interviewer stays in the room after presenting the problem, he or she is interested in seeing how you analyze and approach a problem. Of interest are how possible solutions are considered and eliminated. And frankly, watching a candidate sit and stare at a problem isn't all that entertaining for the interviewer.</p><p><b>Always allow sufficient time for design.</b> The worst thing that you can do while attempting to solve a technical problem is to dive right into coding a solution and get about half way through it before realizing that the approach is all wrong. This is where a little forethought can save a great deal of effort and embarrassment. Don't worry about running out of time to answer the question before finishing the code for the solution. The idea, the algorithm, and the approach are the most important elements here.</p><p>If you're having trouble writing the code, offer to explain the algorithm. Stress and anxiety can make the technical interview more difficult than it needs to be. If you find yourself having difficulty with programming syntax or constructs, you should make sure that the interviewer knows that you understand the problem and its solution. While it's best to get both the algorithm and the implementation correct, it's far better to get points for demonstrating facility with one than fail to demonstrate either.</p><p><b>Be prepared to identify bottlenecks, possible optimizations, and alternative algorithms.</b> Just because you've found one solution that produces the correct output, doesn't mean the problem has been solved to the interviewer's satisfaction. Interviewers, hinting at possible improvements, may prod you at this point. Occasionally, you may take an approach that the interviewer didn't anticipate. At this point, an interviewer may ask you to take a more conventional approach. This doesn't mean that you've done anything wrong; very often, an interviewer may be leading you along a particular approach with a purpose in mind. The interviewer may be intending to ask follow-up questions or present new problems that build on a particular solution.</p><p><b>Initialize all variables, give variables descriptive names, and always use comments.</b> Interviewers may be watching your solutions to determine whether you follow good programming practices. Good programming practices make it easy to understand other people's code. This means that there aren't cryptic variables, functions with undocumented side effects, obfuscated algorithms, and sloppy (read: buggy) code. Just because you are being interviewed (and therefore, coding on a whiteboard or on a piece of paper) doesn't give you an excuse to be sloppy or lazy. Commenting code for an interview may seem like a waste of time, but some interviewers do look to see that candidates write comments while coding or before coding, rather than adding them in as an afterthought.</p><p><b>Check all boundary conditions.</b> Candidates forget to do this frighteningly often. In fact, practicing programmers sometimes forget to do this. That's how bugs get started. You should verify that your code properly handles cases where inputs are negative or zero, lists are empty, strings are empty, and pointers are NULL. This is also a good habit to have after you get the job.</p><p><b>Expect bad input from users.</b> Users rarely do as they are expected. You should protect your code, and return a descriptive error back to the user.</p><p><b>Display enthusiasm.</b> Don't underestimate the importance of your appearance and attitude during the interview. While your skills and experience may be the focus of the technical interview, looking bored or uninterested may do more to sabotage your chances than blowing an interview problem.</p><h3>Work Things Into Your Conversations</h3><p>In addition to these basic rules for the technical interview, there are some other things worth pointing out. Interviewers don't always have the chance to examine your r&eacute;sum&eacute; in advance. This means that the interviewer may not be aware of your past work experience. Don't hesitate to point out experiences working in teams (whether as a part of a past job, a class programming project, or a hobby), working on large projects (paying attention to time spent on design, implementation, and testing), dealing with customers to define requirements, and managing people and projects. Interviewers are interested in hearing about successes as well as failures. When these past experiences weren't successful, you should point out the lessons learned or wisdom gained as a result of these failures. Interviewers want to see that candidates who have had negative experiences are not going to repeat their mistakes.</p><h3>Typical Technical Questions</h3><p>When preparing for a technical interview, you should review basic structures (linked lists, binary trees, heaps) and algorithms (searching, sorting, hashing). Having a mastery of these topics will likely give you all the necessary knowledge to tackle the problems you will encounter during the technical interview.</p><p>Also, review the areas for which you're interviewing. If you're interviewing for a systems programming job, review the differences between threads and processes, OS  scheduling algorithms, and memory allocation. If you're interviewing for a job that requires experience with an object-oriented language, spend some time brushing up on object-oriented methodology.</p><p>Fortunately, some of the same problems come up with surprising frequency. Even if a given interviewer doesn't use any of the problems I present here, studying them should give you insight into solving other problems.</p><p><b>Problem: </b>Write a function that returns the factorial of a number. </p><p><b>Solution: </b>This is a typical, can-you-program warm-up question. <A NAME="re1"><A HREF="9814ce1.htm">Example 1</A> shows the iterative and recursive solutions. Notice that in both solutions, I check the input values and boundary conditions. Factorials of negative numbers are undefined, and the factorial of both 0 and 1 are 1. The functions in <A HREF="9814ce1.htm">Example 1</A> handle these cases correctly, and they initialize all variables.</p><p><b>Problem: </b>Write a function that computes the <i>n</i>th number in the Fibonacci sequence. </p><p><b>Solution: </b><A NAME="re2"><A HREF="9814ce2.htm">Example 2</A> contains both the iterative and recursive solutions. The iterative version maintains variables to hold the last two values in the Fibonacci sequence, and uses them to compute the next value. Again, boundary conditions and inputs are checked. The 0th number in the Fibonacci sequence is defined as 0. The first number in the sequence is 1. Return -1 if a negative number is passed.</p><p>The recursive version of the Fibonacci function works correctly, but is considerably more expensive than the iterative version. There are, however, other ways to write this function recursively in C that are not as expensive. For instance, you could maintain static variables or create a <i>struct</i> to hold previously computed results. </p><p><b>Problem: </b>Write an implementation of <i>strlen()</i>. </p><p><b>Solution: </b>Given a <i>char</i> pointer, <i>strlen()</i> determines the number of chars in a string. The first thing that your <i>strlen()</i> implementation ought to do is to check your boundary conditions. Don't forget the case where the pointer you are given is pointing to an empty string. What about the case where the pointer is equal to NULL? This is a case where you should state your assumptions. In many implementations, the real <i>strlen()</i> doesn't check to see if the pointer is NULL, so passing a NULL pointer to <i>strlen()</i> would result in a segmentation fault. Making it clear to your interviewer that you are aware of both of these boundary conditions shows that you understand the problem and that you have thought about its solution carefully. <A NAME="re3"><A HREF="9814ce3.htm">Example 3</A> shows the correct solution.</p><p><b>Problem: </b>Switch the integer values stored in two registers without using any additional memory. </p><p>To swap the values, you can carry out the following instructions: </p><blockquote>Reg_1 = Reg_1 + Reg_2;<br>Reg_2 = Reg_1 - Reg_2;<br>Reg_1 = Reg_1 - Reg_2;<br></blockquote><p><b>Problem: </b>You are given a list of <i>n </i>numbers from 1 to <i>n</i>-1, with one of the numbers repeated. Devise a method to determine which number is repeated. </p><p><b>Solution: </b>The sum of the numbers 1 to <i>n</i>-1 is (<i>n</i>)(<i>n</i>-1)/2. Add the numbers on the list, and subtract (<i>n</i>)(<i>n</i>-1)/2. The result is the number that has been repeated. </p><p></p><p><b>Problem: </b>You are presented with a linked list, which may have a "loop" in it. That is, an element of the linked list may incorrectly point to a previously encountered element, which can cause an infinite loop when traversing the list. Devise an algorithm to detect whether a loop exists in a linked list. How does your answer change if you cannot change the structure of the list elements? </p><p><b>Solution: </b>One possible answer is to add a flag to each element of the list. You could then traverse the list, starting at the head and tagging each element as you encounter it. If you ever encountered an element that was already tagged, you would know that you had already visited it and that there existed a loop in the linked list.</p><p>What if you are not allowed to alter the structure of the elements of the linked list? The following algorithm will find the loop:</p><ol type="1" start="1">	<LI>Start with two pointers <i>ptr1</i> and <i>ptr2</i>.	<LI>Set <i>ptr1</i> and <i>ptr2</i> to the head of the linked list.	<LI>Traverse the linked list with <i>ptr1</i> moving twice as fast as <i>ptr2</i> (for every two elements that <i>ptr1</i> advances within the list, advance <i>ptr2</i> by one element).	<LI>Stop when <i>ptr1</i> reaches the end of the list, or when <i>ptr1 = ptr2</i>.	<LI>If <i>ptr1</i> and <i>ptr2</i> are ever equal, then there must be a loop in the linked list. If the linked list has no loops, <i>ptr1</i> should reach the end of the linked list ahead of <i>ptr2</i>.</ol><p><b>Problem:</b> Given the time, devise an algorithm to calculate the angle between the hour and minute hands of an analog clock. </p><p><b>Solution: </b>The important realization for this problem is that the hour hand is always moving. In other words, at 1:30, the hour hand is halfway between 1 and 2. Once you remember that, this problem is fairly straightforward. Assuming you don't care whether the function returns the shorter or larger angle, <A NAME="re4"><A HREF="9814ce4.htm">Example 4</A> shows a solution to this problem.</p><p><b>Problem:</b> Devise an algorithm for detecting whether a given string is a palindrome (spelled the same way forwards and backwards). For example, "A man, a plan, a canal, Panama." </p><p><b>Solution: </b>For the sake of this problem, assume that the string has been stripped of punctuation (including spaces), and has been converted to a single case.</p><p>The most efficient way to detect whether a string is a palindrome is to create two pointers. Set one at the beginning of the string, and one at the end. Compare the values at those locations. If the values don't match, the string isn't a palindrome. Otherwise, move each pointer inward and repeat the comparison. Stop when the pointers are pointing to the same position in the string (if its length is an odd-number) or when the pointers have "crossed" (if the string's length is an even-number). <A NAME="re5"><A HREF="9814ce5.htm">Example 5</A> shows the correct solution.</p><p><b>Problem:</b> Given an eight-bit bitmap graphics file, devise an algorithm to convert the file into a two-bit ASCII approximation. </p><p><b>Solution: </b>Assume that the file format is one byte for every pixel in the file, and that the approximation will produce one ASCII character of output for each pixel.</p><p>This problem is easier to solve than it sounds. This is one of the tricks used in technical interview questions. Problems may be obscured or made to sound difficult. Don't be fooled! Take the time to think about the core of the problem. In this case, all you want is an algorithm for reading the values in a file and outputting characters based upon those values.</p><p>Eight-bit numbers can be in the range from 0 to 255. Two-bit numbers are in the range from 0 to 3. Basically, we want to divide the 256 numbers specified by an eight-bit number into four ranges, which can be indicated by a two-bit number. So, divide the range of 0 to 255 uniformly into four separate ranges: 0 to 63, 64 to 127, 128 to 191, and 192 to 255.</p><p>You then have to assign an ASCII character to each of those four ranges of numbers. For example, you could use "_", "~", "+", and "#". Then, the algorithm is as follows:</p><ol type="1" start="1"><li>Open the file.<li>For every byte in the file:	<ol type="a">		<li>Read in one byte.		<li>If the value is in the range 0..63, we'll print '_'.		<li>If the value is in the range 64..127, we'll print '~'.		<li>If the value is in the range 128..191, we'll print '+'.		<li>If the value is in the range 192..255, we'll print '#'.	</ol><li>Close the file.</ol><h3>Conclusion</h3><p>The specific details of your interview will, of course, depend on a number of factors -- the type of job you are applying for, the needs and expertise of the technical interviewer, and guidelines set forth by the organization seeking to hire you. Still, if you generalize and apply the tips I've presented here, you should be well on your way to getting the programming job that you want.</p><p><b>DDJ</b></p><HR><I>Copyright &copy; 1998, Dr. Dobb's Journal</I><BR>
</body></html>