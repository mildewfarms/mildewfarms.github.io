<html><head><title>CareersFall98: Becoming Sun Certified in Java</title></head><body bgcolor="FFFFFF"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Becoming Sun Certified in Java</h1><p><i>Dr. Dobb's Journal</i> Fall 1998</p><h2>Having credentials can open the door</h2><h3>By Barry Boone</h3><I>Barry is the author of Java Certification for Programmers and Developers (McGraw-Hill, 1997). His company, Blue Horse Software, publishes the </i>Java Teaching Kit<i> and maintains the http://www.learnjava.com web site. He is a Sun Certified Java Programmer and a Sun Certified Java Developer and can be contacted at barry@bluehorse.com.</I><hr><p>If you've been programming in Java for some time, you may think you're becoming an expert. You've wrestled with how to best use interfaces; you've mastered Java's event handling mechanism; you've even written one or two pure Java client/server applications. It might be time to consider becoming a Sun Certified Java Programmer.</p><p>When you need to prove you know Java like the back of your hand, you could whip out a laptop and program a cool workflow application. While that would be impressive, you could also pull out your business card and show the challenger a logo that says you've been certified by Sun as a Java programmer. That might be equally as impressive. (And a business card is a lot easier to carry around than a laptop.)</p><p>Branding yourself as a Sun Certified Java Programmer identifies you as someone who has taken the time to be recognized as an expert. Yes, there are plenty of people who have not been certified and who are also experts. You might be one of them. But it takes longer to prove you know what you say you know. And if you're trying to get your foot in the door for a job or assignment, having that credential can help create that opening.</p><p>I'll get to the technical challenges of becoming certified in a moment. But let's start by skipping right to the question that everyone asks -- is it worth it? Is it worth buying one of the study guides, studying for days or weeks, and finally paying $150.00 for the privilege of sweating through a tough, two-hour test that might be subtitled "Java trivial pursuit"? </p><p>My answer is: It depends on who you are. If you're about to make the leap into Java consulting or training, being certified is invaluable. I can tell you firsthand it has gotten me many assignments. If you want to stand out in the crowd of Java programmers, even within your own company, becoming certified is just what you need. On the other hand, if you are the chief technology officer for a global corporation, you might have all of the credentials you need. Or, if you're getting all the challenges and interesting assignments you want, then you might not want to bother -- at least not for the time being.</p><p>Either way, it certainly can't hurt you to be certified as a Java programmer if you want to show the world you are an expert. It can be a valuable credential, and you shouldn't scoff at the test before you've seen how difficult the test really is.</p><p>Many sharp Java programmers have gone down in a blaze of glory underestimating the test. The failure rate is high because the test is tough. To pass, you need lots of hands-on experience. You also need to study. I'll treat the rest of this article as a study guide. In fact, let's play a little Java trivial pursuit!</p><p>What are the colorful, little wedges you need to collect in your game board marker? The questions range over a wide area, including:</p><ul><li>Keywords  <li>Constructors  <li>Memory and garbage collection  <li>Data types and values  <li>Operators  <li>Control flow  <li>Exceptions  <li>Methods  <li>The <i>Math</i> and <i>String</i> classes  <li>Input/Output  <li>Threads  <li>Graphical user interfaces  <li>Event handling  <li>Passing arguments  <li>Embedding applets in web pages  <li>Inner classes</ul><p>Here are four examples to test your Java mettle.</p><h3>Invoking Methods</h3><p>Some questions are easy to answer -- if you only had a moment to create a program and run it through your Java virtual machine. However, you don't have this luxury when taking the test. Here's an example involving casting.</p><p><b>Question:</b> Given the classes in <A NAME="re1"><A HREF="9814ee1.htm">Example 1</A>, what appears in the standard output when you run the <i>Test </i>class in the JVM? Select the single correct answer:</p><p>a.	First the number 2, then the number 1.</p><p>b.	First the number 1, then the number 2.</p><p>c.	The number 1, then the number 1 again.</p><p>d.	The number 2, then the number 2 again.</p><p>e.	This code will not even compile, because you cannot declare an instance variable with the same name as an instance variable in a superclass.</p><p><b>Solution:</b> Answering this question involves knowing how Java invokes a method and accesses data. </p><p>When you invoke a method given an object reference, the method that Java invokes depends on the actual type of that underlying object. In this question, the actual data type is class B, even though the object reference is declared as class A. When you invoke <i>a.method()</i>, class B's method is actually invoked. This is probably what you would expect; the behavior depends upon the actual object type.</p><p>However, this is not the case for accessing data. Even though you created an instance of class B, you assigned it to a reference whose type is class A. When you look at <i>i</i>, you get the value for an instance of class A, which is 1. </p><p>So, the answer here is a.</p><p>The fact that the declared type of an object determines which variable it accesses is a feature, not a problem. This allows you to get at a variable anywhere in a class hierarchy, even if a variable with that same name is declared again lower down in the hierarchy. You don't have this same problem with methods, because methods can always invoke their superclass's behavior to climb back up the hierarchy. </p><p>For example, if you were to add these two lines to the end of the <i>main()</i> method:</p><pre>B b = (B)a;System.out.println(b.i);</pre><p>then, given what you've just learned, what gets written to the standard output? The answer is the number 2. Java goes to the declared data type, which now is class B. In the object whose data type is declared as class B, <i>i</i> is set to 2.</p><h3>Passing an Object as an Argument</h3><p>The certification test requires that you understand what's going on with objects and references to objects. </p><p><b>Question:</b> Given the definition in <A NAME="re2"><A HREF="9814ee2.htm">Example 2</A>(a) for a class named <i>Info</i>, what happens when you run the <i>main()</i> method for <i>Test</i> in <A HREF="9814ee2.htm">Example 2</A>(b), assuming <i>Info</i> and <i>Test</i> are both defined in the same package? Select the single correct answer.</p><p>a.	The <i>main()</i> method in <i>Test </i>ends prematurely because of a <i>NullPointerException</i>.</p><p>b.	The number "1" is written to the standard output.</p><p>c.	The number "2" is written to the standard output.</p><p>d.	The value "null" is written to the standard output.</p><p>e.	Nothing appears in the standard output.</p><p></p><p><b>Solution:</b> This question is a classic that cuts to the heart of how Java uses pointers without calling them pointers. When you pass a primitive data type to a method, you are passing that primitive data type by value. For example, if you wrote the <i>change()</i> method in <A HREF="9814ee2.htm">Example 2</A> as:</p><pre>static void change(int i) {   i *= 2;}</pre><p>and you invoked it like this:</p><pre>int i = 1;change(i);</pre><p>the value 1 would be doubled in <i>change()</i>, but the <i>i</i> in <i>change()</i> has nothing to do with the <i>i</i> passed to <i>change()</i>. That is, arguments are passed by value, and changing a parameter in <i>change()</i> does not affect the argument passed to <i>change()</i>.</p><p>This might seem straightforward enough, but the situation is trickier with objects. In the code in this question, the object reference is passed by value -- not the object itself. That is, the object is not copied, placed onto the stack, and passed to <i>change()</i>, as the case would be if the value passed to <i>change()</i> were an integer (or if this were C++ and you passed the object rather than a pointer to the object). Instead, the object reference is copied and passed to <i>change()</i>. Each reference has its own four bytes allocated to it and each reference points to the same underlying object. <A NAME="rf1"><A HREF="9814ef1.htm">Figure 1</A> shows the situation just after the call to <i>change()</i>. </p><p>The <i>change()</i> method doubles the value in the underlying object, as in <A NAME="rf2"><A HREF="9814ef2.htm">Figure 2</A>.</p><p>Finally, the reference in <i>change()</i> is set to null. But you still have a reference to the underlying object in the program that invoked <i>change()</i>; see <A NAME="rf3"><A HREF="9814ef3.htm">Figure 3</A>.</p><p>When you pop out of <i>change()</i>, the <i>Info</i> object has been updated, and you still have a reference to it. So, the correct answer is c.</p><h3>Constructors</h3><p>One of the most difficult aspects to the test is that some questions may have more than one right answer. Here is an example involving constructors.</p><p><b>Question:</b> Given the class definitions in <A NAME="re3"><A HREF="9814ee3.htm">Example 3</A> for A and B, what will happen when you try to invoke B's <i>main()</i> method? Choose all correct answers.</p><p>a.	The number 1 will appear in the standard output.</p><p>b.	The number 2 will appear in the standard output.</p><p>c.	The number 3 will appear in the standard output.</p><p>d.	The code will cause an <i>InstantiationException</i> to be thrown.</p><p>e.	The code will not compile.</p><p><b>Solution:</b> Let's trace through this code very carefully to see what the correct answer(s) might be. </p><p>You try to create a new instance of class B. You invoke a constructor with two <i>int</i> arguments. You have a constructor for B that takes two <i>int</i> arguments. So far, so good. </p><p>What happens next? B tries to invoke its superclass's constructor. Which constructor? The two argument constructor? No, sir! Since there is no explicit call to a constructor, class B invokes its superclass's <i>no-args</i> constructor. </p><p>The trouble is, there is no <i>no-args</i> constructor in class A in this case. Since you have overloaded the constructors in class A, Java does not provide a default, <i>no-args</i> constructor. The result is that this code does not even compile! The correct answer is e.</p><p>As you can see, even though you were instructed to "choose all correct answers," there was, in this case, only one right answer! Don't let this kind of thing throw you off on the real test.</p><h3>Input/Output</h3><p>Some questions require that you fill in the blank with your own solution. While this can be a snap if you had access to the APIs, you only have scratch paper to work with during the exam.</p><p><b>Question:</b> How can you create an object that translates characters from a text file written using the encoding "8859-6" into Unicode? In your answer, assume you have an <i>InputStream</i> object associated with this text file referenced by the variable <i>inStream</i>. Assume that the local encoding is "8859-7". You should also declare your new object and call it <i>obj</i> in the same line of code that you create this new object.</p><p><b>Solution:</b> Getting this question right means knowing a bit about the <i>Reader</i> and <i>Writer</i> classes, which are new in Java 1.1. In Java 1.0, there was a wide, nearly insurmountable gulf between local encoding (an example being eight-bit ASCII) and Unicode. If you are only ever working with files produced in a word processor in the United States, this is probably not a problem. The translation between ASCII to Unicode and back is trivial -- the upper eight bits in a Unicode representation of an ASCII value are 0, and the lower eight bits are the same as the ASCII value.</p><p>But here's the problem: Java is geared towards an international audience. If you're going to truly take advantage of Unicode, then you've got to be able to read files and write files based on any encoding in the world -- even if the files are different from the local encoding. This means you have to bridge the gap between the eight-bit world of operating systems and local files, and the 16-bit world of Java.</p><p>Here's an example: Suppose you have a file that is based on the encoding 8859-6, which happens to be Arabic. <A NAME="rf4"><A HREF="9814ef4.htm">Figure 4</A> shows what that character set looks like.</p><p>If you assume that the local encoding is ISO 8859-7, you'll get into trouble in your mapping to Unicode if you don't specify you want an ISO 8859-6-specific mapping. <A NAME="rf5"><A HREF="9814ef5.htm">Figure 5</A> shows what ISO 8859-7 looks like. You can see the characters are very different, and they would map to very different places in the Unicode character set, even though their local encoding uses the same bit patterns.</p><p>Luckily, this is not a problem in Java 1.1. If you want to specifically translate between a particular encoding and Unicode, you can use a class called <i>InputStreamReader</i> to do that for you. One of <i>InputStreamReader</i>'s constructors takes two arguments: the input stream, and the encoding to use. Knowing this, your task is easy. The solution is: </p><pre>InputStreamReader obj = new InputStreamReader(inStream, "8859-6");</pre><p>This will map the characters in the text file referenced through <i>inStream</i> to Unicode using the ISO 8859-6 encoding, even though the local encoding would have made Java map the characters to a different part of Unicode given the same bit patterns in the text file.</p><h3>What More is There?</h3><p>As you might be able to tell from these questions, it's unlikely that someone who is not an expert in Java can pass the certification tests. The questions are just too difficult. If you answered these questions without trouble, then you might want to consider becoming certified by Sun as an expert (you need a score of 70 percent or above to pass). If you found these questions tricky, you might want to set your sights on passing this test to reach a mastery of the language.</p><p>If answering 60 difficult multiple-choice and fill in the blank questions does not make you feel like an expert, there's always the second level of certification: the Developer test. Developer certification consists of two parts: completing an involved coding assignment (my test had a 30 page spec), and then answering five essay questions to justify your design and implementation decisions.</p><p>The idea behind this two-tiered approach is that the programmer test confirms you can implement code using Java. The developer test challenges you to design using the benefits of Java's object-oriented nature.</p><p>Whether you decide to pursue Java certification or not, just studying for the test can sharpen your skills and reveal features and facts about the language that you didn't know before. </p><p><b>For More Information</b><br>Sun Microsystems Inc.<br>Sun Educational Services<br>901 San Antonio Road<br>Palo Alto, CA 94303<br>800-422-8020<br>http://suned.sun.com/suned/	index.html<br></p><p><b>DDJ</b></p><HR><I>Copyright &copy; 1998, Dr. Dobb's Journal</I><BR>
</body></html>