<html><head><title>Sep98: Programmer's Bookshelf</title></head><body bgcolor="FFFFFF"><!--Copyright &#169; Dr. Dobb's Journal--><h1>The Dawning of the Age of Multithreading</h1><p><i>Dr. Dobb's Journal</i> September 1998</p><h3>By Jeff Cromwell</h3><I>Jeff is a programmer for Levi, Ray, and Shoup, and can be contacted at jcromwell@primary.net. </I><hr><h4><i>Multithreading Programming<br>Techniques in Win32: The <br>Complete Guide to Threads</i><br>Jim Beveridge and R. Wiener<br>Addison-Wesley, 1997 <br>368 pp., $39.95<br>ISBN 0-201-44234-5<br><br><i>Object-Oriented <br>Multithreading Using C++</i><br>Cameron and Tracy Hughes<br>John Wiley & Sons, 1997<br>512 pp., $49.99<br>ISBN 0-471-18012-2<br><br><i>Multithreading <br>Programming Techniques</i><br>Shashi Prasad<br>McGraw-Hill, 1997<br>400 pp., $49.95<br>ISBN 0-0791-2250-7</h4><p>It can finally be said that we are at the dawn of multithreaded client/server development. We live at a time in which it is necessary to build high-performance servers, develop sophisticated extensions for Internet/intranet servers, utilize the power of multiprocessor systems, construct high-performance OLE and COM objects, and enhance overall application responsiveness. In the coming years, there will be the need for high-performance video servers and complex real-time animation and simulation systems -- many under the auspices of virtual reality. As with any dawn, some of us have overslept. </p><p>The definition of a multithreading program, according to Beveridge and Wiener's <i>Multithreading Programming Techniques in Win32</i>, is one that allows tasks to be divided into components, where each task can operate independently from others. Although most programmers get chills at the mention of this topic, we must remember that even Visual Basic can create multithreaded server applications. The ability to build multithreaded applications is one of the most important skills you can add to your repertoire. Why? Simple economics. Threads are cheaper than processes in terms of initialization, termination, and efficiency. For example, consider a web server that can receive thousands of hits per day. It would be far more expensive to initialize and terminate each request as a separate process. What is needed is something more lightweight -- threads. Although UNIX, Windows NT, and web servers like Internet Information Server have inherent thread processes, an increasing number of client/server applications need to take advantage of the multithreading technology. To implement such a technology, developers need a reliable source of information.</p><h3>Multithreading in Win32</h3><p>Most of my time nowadays is spent developing Windows-based client/server applications in a variety of languages. Recently, I had to develop a multithreaded server in C++, and one of my reference sources was <i>Multithreading Programming Techniques in Win32: The Complete Guide to Threads</i>, by Jim Beveridge and R. Wiener. I selected this book because it received laudatory reviews on the Internet and because the authors wrote the book around a FAQ-style layout. Beveridge and Wiener ask and answer 56 questions, on topics from "How does a context switch work?" to "Why should I be careful of starting threads in <i>DllMain()?</i>" Each of these questions are answered and developed in three basic sections: "Threads in Action," "Multithreading Tools and Tricks," and "Multithreading in Real-World Applications." Although the last section on real-world examples is a bit terse, the first two are very helpful and easy to digest. For pedagogical purposes, the inclusion of a real-world web-server application would have been helpful. In any event, I was able to proceed through the chapters quickly and adopt some of the practices in my work. </p><p>In addition, Beveridge and Wiener do an excellent job of communicating multithreading fundamentals to a diverse audience. For example, they elaborate on several useful tips, including:</p><ul>  <li>Prefer simplicity and safety to complexity and speed.  <li>Do not ever touch data that you cannot guarantee to be in a consistent state.  <li>Remember the thread that creates a window will process all messages sent to that window.  <li>Do not lock a resource for a long time.</ul><p>Another basic tip that all multithreading programmers must know is that you <i>do not</i> make each window of a MDI application its own thread. Beveridge and Wiener give a detailed discussion on why you should not do this. An accompanying CD-ROM includes all the code and sample applications in the book. </p><h3>Object-Oriented Multithreading</h3><p>One of the most striking features of <i>Object-Oriented Multithreading Using C++</i>, by Cameron and Tracy Hughes, is the heavy use of objects -- not only with respect to multithreading, but also by way of diagrams, tables, and figures. The authors should be commended for their ability and diligence in mapping code to diagrams. This lets you take larger steps up the learning curve. Besides their organizational ability, the authors provide a practical guidance on topics such as:</p><ul>  <li>Multithreaded STL algorithms and containers.  <li>Object-oriented mutexes, semaphores, and pipe streams.  <li>Encapsulation.</ul><p>The strength of <i>Object-Oriented Multithreading Using C++</i> is in its examination of the use of multithreading techniques and principles for objects and class libraries. The book assumes little experience with multithreading, but requires familiarity with C++ and object-oriented programming. The focal point on the object-oriented nature of multithreading is based on the chapters "Threading Object-Oriented Architectures," "Class Hierarchies and C++ Components for Threading," and "Class Behavior and Threading."</p><p>The authors provide an excellent treatment of threading object-oriented architectures. For example, they have identified three essential candidates for multithreading: client/server, event-driver programming (GUI), and blackboards. The authors then proceed to give several design examples for each type of architectures, which are extremely useful to novices and seasoned veterans of architectural design. The chapter on class hierarchies and C++ components is excellent and provides helpful examples that take advantage of templates that demonstrate an anatomy of a multithreaded class. Their final chapter on class behavior demonstrates the need to understand how domain, interface, utility, and other support objects will behave in a multithreaded environment.</p><p>Overall, <i>Object-Oriented Multithreading Using C++</i> requires a considerable investment of time but promises a high rate of return. The authors include a disk with all the source code from the book along with a variety of multithreaded components ready to build into your own applications or class library.</p><h3>Other Operating Systems</h3><p>While most of my work has been in the Windows environment, no review on multithreading would be complete without some discussion on other operating systems. A multithreaded programmer must have the ability to move from one platform to another with ease. For an examination of how to implement threads on a variety of different platforms, <i>Multithreading Programming Techniques</i>, by Shashi Prasad, is an excellent resource.</p><p>This book covers five different thread implementations on operating systems such as UNIX, Mach, Windows NT, and OS/2. The thread implementations used are of the POSIX and Win32-OS/2 variety. <i>Multithreading Programming Techniques</i> is organized in such a way that if you are interested only in the POSIX- and UNIX-based threads, you only need to read those chapters.</p><p>Prasad provides a helpful introduction to multithreading and discusses several pitfalls to thread programming, including: </p><ul>  <li>Added complexity.  <li>Difficulties in debugging and testing.  <li>Data synchronization and race conditions.  <li>Potential for deadlocks.  <li>Environment that is not threadsafe.</ul><p>Prasad addresses each one of these pitfalls with respect to each implementation. All code in the book is C, since the operating system Prasad developed has a C-based API for thread programming.</p><p>One of the first lessons I learned in this book is that UNIX supports threads. Operating systems such as AIX, Solaris, Digital UNIX, and SVR4/MP now offer a multithreaded kernel. At a more abstract level, there are small differences between platforms. For effective thread implementation, for example, you must understand thread-synchronization issues such as mutexes and semaphores, along with data handling for threads and overall thread management. While Prasad provides detailed treatment of these topics, he leaves it up to you to compare and contrast the OSs to effectively implement the architectures in real-world examples. The book is accompanied by a disk that provides the source code in C to many of the examples. In addition, Prasad has also included source code for Mthread -- a portable, thread abstraction layer for the different thread implementations developed in the book. </p><h3>Wrapping it Up</h3><p>Multithreading is a difficult subject and you must spend considerable time in designing, coding, and running examples. If you are looking for code to use in your applications, you will not find it in Prasad's book. However, you will find three excellent books that will teach you the fundamentals of thread-based programming. If this is not an option (Steve McConnell says that the average programmer reads less than one book a year), I would start off with Beveridge and Wiener's book for your transition into thread programming. The Prasad book is ideal for those who are not in a development phase and do not have to port a threaded application to another operating system. The Hughes book is excellent for those who are well versed in the use of object-oriented technology and like to be challenged in the construction and implementation of threadsafe objects.</p><p>Although all three books are helpful for developing a grasp of the concepts, it is always helpful to read the code from real-world multithreaded applications. I was able to track down several examples of multithreaded servers that expounded on several of the techniques described in the books examined here. In addition to this intellectual investment, developing multithreaded applications requires a deep understanding of system processes. If you aspire to be ready for this new dawn, you can prepare by tinkering under the hood of Windows and UNIX-based platforms.</p><p><b>DDJ</b></p><HR><I>Copyright &copy; 1998, Dr. Dobb's Journal</I><BR>
</body></html>