<html><head><title>Sep98: Java Q&A</title></head><body bgcolor="FFFFFF"><!--Copyright &#169; Dr. Dobb's Journal--><h1>What Is Swing?</h1><p><i>Dr. Dobb's Journal</i> September 1998</p><h3>By Mukul Sood</h3><I>Mukul is a project manager at DigitalFocus. He can be contacted at mukuls@digitalfocus.com.</I><hr><p>Swing is a collection of lightweight components built on top of the Java Abstract Windowing Toolkit (AWT). Swing components are based on the Lightweight UI Framework that became part of the Java AWT with the JDK 1.1. (With JDK 1.2, Swing becomes part of the Java Foundation Classes.) Lightweight components do not have "peers" (platform-dependent code) associated with them. They are thus unencumbered by problems brought on by peers, such as platform-dependent bugs. Swing, which creates its components using pluggable look-and-feel modules written in pure Java, doesn't make use of native code. Pluggable look-and-feel lets an application running on heterogeneous platforms have the same look-and-feel across dissimilar machines. This feature also has the ability to change the visual representation of the application dynamically at run time. </p><p>As <a name="rf1"><a href="9809mf1.htm">Figure 1</A> illustrates, the architecture of Swing components is based on the model-view-controller (MVC) paradigm. In a Swing component, models provide information that specifies the component's value, views manage the way in which the component and its data are drawn on the screen, and controllers modify the information maintained by the model in response to user input.</p><p>In actuality, Swing uses a modified MVC pattern, in which the view and controller are combined into a single component called the "delegate object." This reduces the number of communication paths between the model, view, and controller, and the number of components to be created and managed. In short, both the appearance and behavior of a component can be managed together, using just one delegate object. The delegate object encapsulates the look-and-feel of each Swing component. </p><h3><i>JTable</i> and Swing </h3><p>In this article, I'll focus on <i>JTable</i>, one of Swing's lightweight components, and explain how the MVC architecture applies to it. <i>JTable</i> is a view controller -- it knows how to draw itself and acts as a controller for the various editors, with which it can be fitted for the Table data model. <i>JTable</i> is a user-interface component that presents data in a two-dimensional table format. Tables (or grids) implemented using <i>JTable</i> can be easily connected to databases through JDBC. <i>JTable</i> provides features such as reassessable and reorderable columns, a flexible and configurable row/column selection mechanism, cells that can be displayed using any components through the use of the <i>Renderer</i> interface (whereby cells can be equipped with Checkbox controls, choice controls, and so on), cells that can be edited using an editor interface, and support for large data sets.</p><p>All delegates extend the <i>ComponentUI</i> interface and all delegates are also part of the com.sun.java.swing.plaf package. <i>ComponentUI</i> defines how a delegate renders a <i>JComponent</i> (the abstract <i>JComponent</i> class is the root class of all Swing components). Under Windows, for example, the default delegate for <i>JButton</i> is <i>BasicButtonUI</i>. This is loaded by default when an application runs on Windows. To change the look-and-feel to, say, a Java look-and-feel, you'd use something like <a name="rl1"><a href="9809m.htm#l1">Listing One</A>. You can also define new looks-and-feels and create custom Swing components.</p><h3>Swing Table Framework</h3><p>The Swing Table framework is an example of MVC architecture. The table data model is represented by the <i>TableModel</i> interface and the view-controller part is handled by the <i>JTable</i> class. The <i>TableModel</i> interface specifies how to describe the data in the table cells. These methods are what <i>JTable</i> uses to interrogate the data model. The <i>TableModel</i> interface also specifies methods required for maintaining a <i>TableModelListener</i> list. <i>TableModelListener</i> defines the interface for an object that listens to changes in a <i>TableModel</i>. The method <i>tableChanged(TableModelEvent)</i>, for instance, tells listeners the exact range of cells, rows, or columns that changed. The <i>JTable</i> component listens to changes in the data model and implements the <i>TableModelListener</i> interface. </p><p>The <i>AbstractTableModel</i> adapter class implements most of the methods in <i>TableModel</i> and maintains the listener list. This simplifies the task of creating a data model. By subclassing from this adapter, only the methods <i>getColumnCount</i>, <i>getRowCount</i>, <i>getValueAt</i>, and <i>setValueAt</i> need to be implemented. Since the <i>setValueAt</i> method is present as a stub in <i>AbstractDataModel</i>, it doesn't have to be implemented. <i>setValueAt</i> sets the value in the data model. The listener must also be notified about this change. This is done by invoking the <i>fireTableCellUpdated</i> method, defined in <i>AbstractDataModel</i>. </p><p>The following methods should be implemented by the data model if you extend from <i>AbstractDataModel</i>:</p><ul>  <li><i>public abstract int getRowCount()</i> returns the number of records managed by the data source object. <i>JTable</i> uses this method to determine how many rows it should create and display. This method should be quick, since it is frequently called by <i>JTable</i>.   <li><i>public abstract int getColumnCount()</i> returns the number of columns managed by the data source object. A <i>JTable</i> uses this to determine how many columns it should create and display upon initialization.   <li>	<i>public abstract Object getValueAt(int rowIndex, int columnIndex)</i> returns an attribute value for the cell at <i>columnIndex</i> and <i>rowIndex</i>. <a name="rl2"><a href="9809m.htm#l2">Listing Two</A>, for example, sets an attribute value for the record in the cell at <i>columnIndex</i> and <i>rowIndex</i>. <i>aValue</i> is the new value. </ul><p><i>JTable</i> can be configured with cell renderers and editors, either default or specialized, for various columns. The values get displayed and edited using the particular renderer and editor for that column. For example, a column could be configured with a combobox editor having a list of colors, and the renderer could display that value in the background color based on the selected value. </p><p>The renderer does not get added as a component; for example, there is no method <i>JTable.add(renderer)</i>. The table has built-in renderer components, and these get set to whatever renderer(s) you supply, through the method <i>JTable.setCellRenderer(MyRenderer)</i>. The renderer's only purpose is to supply the methods needed to draw the values given to it by the <i>JTable</i> object. </p><p>A renderer can either implement the <i>TableCellRenderer</i> interface or use a default implementation by using the <i>DefaultCellRenderer</i> and passing it the <i>JComponent</i> to be used for drawing; for instance, <i>cellRenderer=new DefaultCellRenderer(new JLabel());</i>. <a name="rl3"><a href="9809m.htm#l3">Listing Three</A> is the only method defined by the <i>TableCellRenderer</i> interface. The table invokes this method for each cell, then calls <i>paint()</i> on the returned <i>Component</i> object. If the application needs a renderer (such as a colored button), it could implement it using <a name="rl4"><a href="9809m.htm#l4">Listing Four</A>. </p><p>The table can use editors such as textfield, combobox, and the like, for editing individual cells, and the concept is similar to the concept for renderers: The editor has to implement the <i>TableCellEditor</i> interface; otherwise, a default editor can be used (<i>DefaultCellEditor</i>) and the appropriate <i>JComponent</i> (<i>JTextField</i>, <i>JComboBox</i>, and so on) passed to it.</p><h3>A <i>JTable </i>Example</h3><p>The <i>JTable</i> example I offer here presents automobile information in a tabular format. To run the example, unzip the classes (available electronically; see "Resource Center," page 3) and put them in your classpath. Then type <i>java TableExample.AppMain</i> to start the application. All the classes are in the package TableExample. <i>AppMain</i> creates the application controller class, <i>AppController</i>. <a name="rf2"><a href="9809mf2.htm">Figure 2</A> shows the classes and their relationships. (This example was written using Swing 0.7. The code will not run on previous releases of Swing, as the <i>JTable </i>API has undergone changes in Version 0.7. The most recent Swing release, information, and documentation can be found at http:// www.javasoft.com/.) </p><p><i>AppController</i> instantiates the data model, which is represented by the <i>AutomobileDataModel</i> class. It then instantiates the view (which is the class <i>AppView</i>) passing it the argument <i>TableUI</i> class, which creates the table and its renderers and editor.</p><p>The controller is responsible for all user input event handling, which consists of mouse click events. However, since the <i>JTable</i> is a view-controller component, it automatically handles all these events. The default renderer for <i>String</i> type data is <i>JLabel,</i> and the default editor is <i>JTextField</i>. Consequently, if the data model consists of <i>String</i> type data and allows cell editing (returns True from <i>isCellEditable(int r,int c)</i>), then, by default, the table would allow textfield editing of the cells. No renderers or editors would need to be set on the table. Another default editor type for the table is <i>JCheckBox,</i> which gets set if the data type in a column is <i>Boolean</i>. It is rendered as a checkbox. </p><p>The constructor for the <i>AppController</i> class calls the <i>init</i> method, which instantiates the <i>AutomobileDataModel</i> object. This is the data model for the table. The table queries the data model by invoking its <i>getValueAt(int row,int column)</i> method; this is how the view part of the table gets the value to render. If there is a specific renderer set for that column, then the renderer interprets and draws the value. If the model implements the <i>isCellEditable</i> method (<a name="rl5"><a href="9809m.htm#l5">Listing Five</A>), then the table cells can be edited using whatever editors are set up for table columns. </p><p>The <i>AutomobileDataModel</i> extends the <i>AbstractTableModel</i> class, which provides default implementations for most of the methods in the <i>TableModel</i> interface. It takes care of the management of listeners and provides conveniences for generating <i>TableModelEvents</i> and dispatching them to the listeners. You override the <i>isCellEditable</i> method to enable cell editing. </p><p>The <i>TableUI</i> class instantiates the <i>JTable</i> and creates renderers for the Year, Automobile Make, and Details columns. It also creates a combobox editor for the Year column. The data model instance is passed to <i>TableUI</i>, which creates the table through the call <i>JTable table=new JTable(dataModel)</i>. </p><p><i>JTable</i> has an attribute <i>autoCreateColumnsFromModel</i> that is set to True by default. The <i>JTable table=new JTable(dataModel)</i> call has the effect that the table queries the data model to build the default set of columns. You can check this by uncommenting the <i>System.out.println</i> in <i>setValueAt</i> method. The <i>setModel</i> method (in <i>JTable</i>) could also be used, as in <i>table=new JTable(); table.setModel(dataModel);</i>.</p><p>These two approaches trigger the method <i>fireTableChanged(null),</i> which generates a <i>TableModelEvent</i> that is caught by the <i>JTable</i> (as it implements a <i>TableModelListener</i>). The table then creates the columns and fills in the data from the data model that is passed to it in the <i>TableModelEvent</i>. </p><p>An alternative approach is to call <i>new JTable()</i>, invoking <i>setAutoCreateColumnsFromModel(false)</i>, and then creating the columns using <i>table.addColumn</i> method. </p><p>The <i>TableUI </i>creates a renderer for Automobile Make, which displays the value in a certain font based on that value. It extends from <i>JLabel</i> so you can override label's <i>setText</i> method and plug in your implementation. You have implemented the renderer as an inner class as its part of the table user interface. </p><p>The renderer is associated with the column by invoking <i>TableColumn.setCellRenderer(rendererForColumn)</i>. For the Automobile Make column, I used a <i>DefaultCellRenderer</i> passing it the label object. </p><p>In most cases, you could use a <i>DefaultCellRenderer</i>, but for situations in which you need to override the <i>paint</i> method (such as to toggle display of the component on and off based on value), it would be necessary to provide your implementation of the <i>TableCellRenderer</i> and override whatever methods to get the desired effect. <a name="rf3"><a href="9809mf3.htm">Figure 3</A> shows the table (note the background colors in the Year and Details column as a result of using renderers).</p><p>The <i>TableUI </i>also uses a combobox editor, something that's simple to create. The editor is associated with the column by invoking <i>TableColumn.setCellEditor(editorForColumn)</i>.</p><p>Whenever any cell in the Year column is clicked, a combobox with a selectable list drops down. When a selection is made from this box, the table calls the <i>setValueAt</i> method to set that value in the data model. This is possible since <i>JTable</i> implements the <i>CellEditorListener</i> interface, and it knows the results of editing. </p><p>The Details column uses our implementation of a <i>TableCellRenderer</i>. It basically simulates checkbox behavior. When the cell value is <i>No</i> and the user clicks on the checkbox, the mouse handler calls <i>setValueAt</i>, passing it a value <i>Yes,</i> and <i>setValueAt</i> calls the <i>fireTableCellUpdate</i> method. This method causes the table to invoke <i>getValueAt</i> for that cell and then to pass that value to the renderer. The renderer, which extends <i>JCheckBox</i>, calls <i>setSelected(true)</i> if the value passed is <i>Yes</i>; otherwise, it calls <i>setSelected(false)</i>.</p><p>The mouse handler is implemented in <i>AppController</i> and is set up to listen for mouse click events only (extends from <i>MouseAdapter</i>). It is passed a reference to the table in the constructor, from which it gets the data model. On receiving a mouse click event, it gets the value for the cell that was clicked by invoking the code in <a name="rl6"><a href="9809m.htm#l6">Listing Six</A>. Based on the value (<i>Yes</i> or <i>No</i>), it then calls <i>setValueAt</i> passing it the appropriate value.</p><h3>Conclusion</h3><p>The example I've presented illustrates the concept of a table as a view-controller component and brings to light the various mechanisms that the table uses to achieve its rich functionality. With its wide capabilities and feature set, <i>JTable</i> offers a good solution to developers, IDE builders, and toolset vendors.</p><p><b>DDJ</b></p><H4><a name="l1">Listing One</H4><pre>try {    UIManager.setLookAndFeel (        "com.sun.java.swing.jlf.JLFLookAndFeel");} catch( java.lang.ClassNotFoundException e) {    // look and feel class not found, can't change l&amp;f}</pre><P><a href="#rl1">Back to Article</A></P><H4><a name="l2">Listing Two</H4><pre>public abstract void setValueAt(Object aValue, int rowIndex, int columnIndex)</pre><P><a href="#rl2">Back to Article</A></P><H4><a name="l3">Listing Three</H4><pre>Component getTableCellRendererComponent(JTable table,                    Object valueToBeDisplayed, boolean whetherCellSelected,                 int rowNumber, int columnNumber) </pre><P><a href="#rl3">Back to Article</A></P><H4><a name="l4">Listing Four</H4><pre>class ButtonRenderer extends JButton implements TableCellRenderer {           Component   getTableCellRendererComponent(JTable table,                Object valueToBeDisplayed, boolean whetherCellSelected,               int rowNumber, int columnNumber) {if(valueToBeDisplayed == "red") {    this.setBackground = Color.red;} else {     this.setBackground = Color.white;}                    return this;            }    }</pre><P><a href="#rl4">Back to Article</A></P><H4><a name="l5">Listing Five</H4><pre>  public boolean isCellEditable(int row, int col) {     return true;}</pre><P><a href="#rl5">Back to Article</A></P><H4><a name="l6">Listing Six</H4><pre>        rowIndex = table.rowAtPoint(mouseEvent.getPoint());        colIndex = table.columnAtPoint(mouseEvent.getPoint());        dataModel.getValueAt(rowIndex, colIndex); ALGORITHM ALLEY</pre><P><a href="#rl6">Back to Article</A></P><HR><I>Copyright &copy; 1998, Dr. Dobb's Journal</I><BR>
</body></html>