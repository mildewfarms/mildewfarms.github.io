<html><head><title>Sep98: Asynchronous Communications Using select and <i>poll</title></head><body bgcolor="FFFFFF"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Asynchronous Communications Using <i>select</i> and <i>poll</i></h1><p><i>Dr. Dobb's Journal</i> September 1998</p><h2>Inside powerful UNIX services</h2><h3>By Sean Eric Fagan</h3><I>Sean has been a BSD developer and contributor for many years, starting with 386BSD. Sean can be contacted at sef@freebsd.org.</I><hr><p>One important feature of UNIX-like operating systems is their ability to efficiently handle diverse I/O requirements, including slow serial terminals, high-speed disk drives, multiple network protocols, and pseudodevices that provide a variety of services. For applications to efficiently juggle multiple I/O streams, the operating system provides the <i>select()</i> system call. With this call, you tell the operating system what streams you want to monitor, and it wakes you up when any of those streams have activity.</p><p>In "Tracing BSD System Calls" (<i>DDJ</i>, March 1998), I showed how I added support in the kernel for one process to monitor system calls made by another process. In this article, I'll make that facility easier to use by adding support for <i>select()</i> and <i>poll()</i>.</p><h3>Using <i>Select</i></h3><p>The <i>select()</i> system call was added to 4.2BSD to support a form of asynchronous I/O. Before <i>select()</i>, a program could only determine if a file descriptor was ready for I/O by actually doing the I/O. The two biggest advantages of <i>select()</i> were that it allowed multiple file descriptors to be queried at the same time, and it had a time-out value associated with it.</p><p>For example, <i>select()</i> makes it possible to check for input on 20 different network connections, waiting until input is available, or half a second has passed. This is particularly useful in interactive applications.</p><p>The <i>select()</i> call accepts three bitmaps and a time-out value. The bitmaps are of type <i>fd_set</i>, an opaque type you manipulate using the FD_SET, FD_CLR, FD_ISSET, and FD_ZERO macros. Each bit in one of these bitmaps refers to a particular file descriptor; the default in FreeBSD (http://www.freebsd.org/) allows for up to 256 file descriptors to be monitored, although you can make this limit larger.</p><p><a name="rl1"><a href="9809e.htm#l1">Listing One</A> ses <i>select()</i> to implement a simplistic but complete chat server. This server accepts connections on port 12345, and, once connected, sends whatever it receives to all other connections.</p><p><a href="9809e.htm#l1">Listing One</A> shows some of the power of <i>select()</i>. My simple server is a single process, yet it efficiently interleaves multiple inputs. If there is no input ready from any of the file descriptors (and, as the code shows, a new connection attempt counts as input being ready for the primary socket), the process simply waits, consuming no CPU resources. As <a href="9809e.htm#l1">Listing One</A> also demonstrates, <i>select()</i> sets the appropriate bit on return to indicate which files match the specified criteria.</p><p>This sample program only checks for available input on a stream; the other two bitmasks let you check whether output is possible or there is an exception.</p><p>In <i>select()</i> parlance, exceptions are file-specific states that are not covered by the terms "input ready" or "output ready. A file descriptor is in exception state if the file-specific code decides that it is; there is no other standard. For example, a closed pipe, or out-of-band socket data may result in an exception state. Most file types and device drivers do not have an exception state. </p><h3><i>Select</i> Implementation</h3><p>Since <i>select()</i> is a system call, the bulk of the code resides in the kernel -- /usr/src/sys/kern/sys_generic.c, in this case.</p><p><i>select()</i> is a moderately complex system call; it also requires vnode-specific support. (A vnode is an operating-system data structure that represents a specific communications connection, such as an open file or socket.)</p><p>The top-level <i>select()</i> function works in a loop. On each iteration, <i>select()</i> checks all of the indicated file descriptors (calling the appropriate file-specific code). If any selected file descriptor is in the requested state, the loop ends, <i>select()</i> returns, and the process can service the request. Otherwise, <i>select()</i> relinquishes the processor immediately to let other processes run, and repeats the loop when something changes.</p><p>The two complicated parts are calling the appropriate file-specific code for each indicated descriptor and arranging for the loop to repeat only when some descriptor actually changes state. The first part is handled by the internal <i>selscan()</i> function. The second part involves some standard kernel functions -- <i>tsleep()</i> to put a process to sleep and <i>wakeup()</i> to wake it up again -- combined with a few tricks to make it all more efficient.</p><h3>Checking File Descriptors</h3><p><i>selscan</i> calls the file-specific select routines for each selected file; if any of these functions returns a nonzero value, this indicates that the object in question is immediately ready for the requested I/O. <i>selscan()</i> returns the number of files ready in <i>*retval</i> (or <i>p-&gt;p_retval1</i> in FreeBSD-current).</p><p>Some types of files (such as disk files) are always ready for I/O. In this case, <i>selscan()</i> will return immediately. For file systems that fully support <i>select</i>, the function will check to see if I/O is ready at the time, and, if not, schedule notification to be made when it is.</p><h3>Waiting for a Change</h3><p>The <i>select()</i> call waits for file-status changes in a pretty direct way. At the bottom of its top-level loop, <i>select()</i> calls <i>tsleep()</i> to put this process on the sleep queue and schedule another process. The channel it is waiting on, &amp;<i>selwait</i>, is a global variable; every process sleeping in <i>select()</i> is sleeping on the same channel. In essence, whenever a file descriptor changes state, this channel is notified and all pending <i>select()</i> calls wake up and loop again to check the relevant descriptors. The actual implementation uses a few tricks to make this more efficient.</p><p>If I/O isn't immediately possible, the file-specific code calls <i>selrecord()</i>. Essentially, all <i>selrecord()</i> does is keep track of whether there is a "collision" -- that is, whether there's more than one process waiting on this event.</p><p>When a file's status changes, the file system code calls <i>selwakeup()</i> to wake up any processes that might be waiting for a change in this file. If there is a collision, <i>selwakeup()</i> simply wakes up all of the pending <i>select() </i>calls by notifying the shared channel with <i>wakeup(</i>(caddr_t)&amp;<i>selwait)</i>. This prompts every <i>select()</i> call to recheck all of its file descriptors.</p><p>If there is only one process waiting for this event, <i>selwakeup()</i> cheats a bit and uses its knowledge of process scheduling to wake up only that single process; see <a name="re1"><a href="9809ee1.htm">Example 1</A>.</p><p>The first <i>if</i> statement in <a href="9809ee1.htm">Example 1</A> checks what channel the process is sleeping on. All processes waiting in <i>select()</i> have the same channel -- the address of the global variable <i>selwait</i> (which is used only as an address; it is never read nor modified by anything in the kernel). If the process is indeed waiting on &amp;<i>selwait</i>, then <i>selwakeup()</i> wakes it up directly.</p><p>Once awaken, the <i>select()</i> call loops and calls the file-specific <i>select </i>functions again. This continues until a file matches the requested state, the given time-out runs out, or the process is interrupted by a signal.</p><h3>File-Specific <i>Select</h3><p>The rest of the implementation of </i>select() depends on the particular file, but is usually straightforward. For example, the UFS (UNIX File System) <i>select</i> function immediately indicates that I/O is ready by returning a 1. It does this even if the file is empty. A <i>read()</i> of such a file will return 0 bytes read, but will not hang, which satisfies the purpose of <i>select()</i>.</p><p>Pipes have more complete support for <i>select()</i>. <a name="rl2"><a href="9809e.htm#l2">Listing Two</A>, an excerpt from <i>pipe_select()</i>, is called with three parameters -- the file being examined, a flag indicating whether the file is being examined for input, output, or exception, and the process descriptor structure.</p><p>The first case in <a href="9809e.htm#l2">Listing Two</A>, FREAD (input is being scanned), is typical for a file-specific <i>select</i> routine. If input is available immediately, it returns 1 (which tells <i>selscan()</i> that this file has I/O ready); otherwise, it calls <i>selrecord()</i> to indicate that the pipe is being selected on.</p><p>Whenever the pipe code reads or writes into the pipe buffer, or closes the pipe, it calls <i>pipeselwakeup()</i>. This function merely tests if the pipe is currently being selected; if so, it calls <i>selwakeup()</i>. This causes the monitoring process to wake up and repeat the <i>select()</i> loop, which results in another call to <i>pipeselscan()</i>, which will notice that I/O is ready.</p><p>The main point of the preceding discussion is that, if you can determine when I/O will be ready, it takes little code to fully support <i>select()</i>.</p><h3><i>Poll</i> versus <i>Select</i></h3><p>The <i>poll()</i> system call is a similar routine that originated in System V Release 3.2 UNIX and has recently been added to FreeBSD. The main difference is that <i>poll()</i> takes an array of structures, instead of three bitmasks, to describe which file descriptors and events should be examined.</p><p>Each function has some advantages and disadvantages: <i>select()</i> allows time-outs to be measured in microseconds, while <i>poll</i> only allows tenths of a second. <i>select()</i> can only monitor for "input ready," "output ready," and "something else," while <i>poll()</i> supports many kinds of file-type-specific events.</p><p>Within the kernel, the main difference is that <i>poll()</i> can check for more events, and the file-specific routine specifies which events occurred. Since the functions called by <i>selscan</i> check a single event, and return nonzero if that event happened, the same file-specific function can serve both purposes.</p><h3><i>procfs_select</i></h3><p>Each file object needs to store certain <i>select</i>-related information. For <i>procfs</i>, I could have stored this information either in the <i>proc</i> structure (which is unique to each process) or in the <i>pfsnode</i> structure (which is unique to each open <i>procfs</i> object).</p><p>Placing it in the <i>pfsnode</i> structure makes sense because this information is relevant only to <i>procfs</i>. However, I need to add a <i>selwakeup()</i> call to the generic <i>stopevent()</i> kernel function, which is not part of <i>procfs</i>. For that reason, it makes more sense to store the <i>procfs</i>_<i>select</i> information in the <i>proc</i> structure. Modifying the <i>proc</i> structure is not something you do lightly; a lot of code uses and manipulates <i>proc</i> structures, including loadable kernel modules (LKMs) and programs such as ps. Since these aren't automatically recompiled when you recompile the kernel, there's a potential for version skew problems.</p><p>To alleviate these problems, I moved the <i>procfs</i>-related elements out of the <i>proc</i> structure, and stored only a pointer to them in the <i>proc</i> structure. I then padded the <i>proc</i> structure so that its length is unchanged; this reduces the version-skew problem.</p><p><a name="re2"><a href="9809ee2.htm">Example 2</A> shows the new structure. The <i>p_sel</i> element is the new variable for handling <i>select()</i> and <i>poll()</i>. Now, when an event being monitored by <i>procfs</i> occurs, <i>stopevent() </i>(in /usr/src/kern/sys_process.c) must call <i>selwakeup()</i>; see <a name="re3"><a href="9809ee3.htm">Example 3</A>.</p><p>The remainder of the work is to implement <i>procfs_poll()</i>. This is the function that will be called by <i>selscan()</i> (or the equivalent part of the <i>poll()</i> system call) for a <i>procfs</i> file handle. <a name="rl3"><a href="9809e.htm#l3">Listing Three</A> is the result.</p><p>The bulk of <i>procfs_poll()</i> simply locates the <i>proc</i> structure of the process being monitored and checks (using the CHECKIO() macro) that the monitoring process has the necessary permission.</p><p>The semantics I've chosen for <i>procfs_poll()</i> are essentially identical to the <i>procfs ioctl</i>, PIOCWAIT; that is, it is used to find out when a monitored process stops for some event. This just requires testing <i>procp-&gt;p_ev-&gt;p_step</i>, which is set in <i>stopevent()</i> when a process stops. That is the only time it will be set.</p><p>If <i>p_step</i> is not set, then <i>procfs_poll()</i> calls <i>selrecord()</i>, and returns 0, indicating that none of the requested information is available now.</p><p>The only other kernel code change is to tell <i>procfs</i> about the new function; that is done by adding <i>{</i>&amp;<i>vop_poll_desc, (vop_t *) procfs_poll}</i> to the structure that defines which features <i>procfs</i> supports.</p><h3>Using <i>select()</i> in <i>procfs</i></h3><p>Initially, the UNIX truss utility used an <i>ioctl</i> to wait for a monitored process to stop (see "Tracing BSD System Calls," <i>DDJ</i>, March 1998). However, this can only monitor one process at a time, which is a problem if the program being trussed happens to do a <i>fork()</i> system call. To watch multiple processes, truss would need a way to watch multiple file descriptors -- which, obviously, is where all of this talk and code comes into play.</p><p><a name="re4"><a href="9809ee4.htm">Example 4</A> shows the change to truss that allows it to watch multiple processes. This approach is more complex: In addition to keeping track of "maxfd," truss also has to go through <i>ifds</i> after <i>select()</i> returns to determine which file descriptors have input ready. However, there is no other practical way to monitor multiple processes short of running multiple copies of truss (which would make the output very difficult to follow).</p><h3>Conclusion</h3><p>At this point, the kernel has had a major feature added -- with only a few lines of code. And, with a bit more code being modified, truss is capable of using this feature.</p><p><b>DDJ</b></p><H4><a name="l1">Listing One</H4><pre>/* Simple select()-driven chat server */#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;errno.h&gt;#include &lt;fcntl.h&gt;#include &lt;err.h&gt;#include &lt;netdb.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/time.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;<p></p>main() {  struct protoent *tp = getprotobyname("tcp"); /* TCP protocol */  int serv_sock; /* Master socket for server */  fd_set ifds; /* Bitmap of active sockets */  int maxfd; /* Last active socket */  struct sockaddr_in sin;  char **hostnames;  /* Names of currently connected hosts */<p></p>  /* Create a TCP socket */  if (tp == NULL) err(1, "Cannot get tcp protocol\n");  serv_sock = socket(PF_INET, SOCK_STREAM, tp-&gt;p_proto);  if (serv_sock &lt; 0)    err(2, "Cannot create socket:  %s\n", strerror(errno));  /* Bind the socket to port 12345 */  memset(&amp;sin, 0, sizeof(sin));  sin.sin_len = sizeof(sin);  sin.sin_family = PF_INET;  sin.sin_port = htons(12345);  sin.sin_addr.s_addr = htonl(INADDR_ANY);  if (bind(serv_sock, (struct sockaddr*)&amp;sin, sizeof(sin)) &lt; 0)    err(3, "Cannot bind socket:  %s\n", strerror(errno));  /* Allow incoming connections */  if (listen(serv_sock, 64) &lt; 0)    err(3, "Cannot listen to socket:  %s\n", strerror(errno));  FD_ZERO(&amp;ifds);  FD_SET(serv_sock, &amp;ifds);  maxfd = serv_sock;  for (;;) {    int fd = -1; /* Current file descriptor (socket) with input */    int i;    struct timeval to = { 2, 0 }; /* 2 seconds, 0 microseconds */    /* Wait for input from anywhere */    fd_set tifds = ifds;    int numfds = select(maxfd+1, &amp;tifds, NULL, NULL, &amp;to);    if (numfds == -1) err(4, "Cannot select:  %s\n", strerror(errno));    if (numfds == 0) continue;    /* Find first connection with available input */    fd = -1;    for (i = 0; i &lt;= maxfd; i++)      if (FD_ISSET(i, &amp;tifds)) {        fd = i;        break;      }    if (fd == -1) err(5, "Oops");    if (fd == serv_sock) { /* New connection request */      struct sockaddr_in remote;      int len = sizeof(remote);      int rfd;      /* Accept the connection */      rfd = accept(serv_sock, (struct sockaddr*)&amp;remote, &amp;len);      if (rfd == -1) err(6, "Cannot accept:  %s\n", strerror(errno));      /* Add the new connection to file descriptors I watch */      FD_SET(rfd, &amp;ifds);      if (hostnames &amp;&amp; rfd &lt; maxfd &amp;&amp; hostnames[rfd]) {        free(hostnames[rfd]);        hostnames[rfd] = strdup(inet_ntoa(remote.sin_addr));      } else {        maxfd = rfd;        hostnames = realloc(hostnames, (maxfd+1)*sizeof(char*));        hostnames[rfd] = strdup(inet_ntoa(remote.sin_addr));      }    } else {  /* Input is from a chat participant */      char buf[80];      int count;      char *h = hostnames[fd];      /* Get the input */      count = read(fd, buf, sizeof(buf));      if (count == 0) FD_CLR(fd, &amp;ifds);      else {        /* Relay it to every other participant */    int i;        for (i = 0; i &lt;= maxfd; i++) {          if (FD_ISSET(i, &amp;ifds) &amp;&amp; i != serv_sock &amp;&amp; i != fd) {            write(i, h, strlen(h));            write(i, ": ", 2);            write(i, buf, count);          }        }      }    }  }}</pre><P><a href="#rl1">Back to Article</A></P><H4><a name="l2">Listing Two</H4><pre>/* Excerpt from pipe_select() in /usr/src/sys/kern/sys_pipe.c */switch (which) {case FREAD:  if ( (rpipe-&gt;pipe_state &amp; PIPE_DIRECTW) ||       (rpipe-&gt;pipe_buffer.cnt &gt; 0) ||       (rpipe-&gt;pipe_state &amp; PIPE_EOF)) {         return (1);  }  selrecord(p, &amp;rpipe-&gt;pipe_sel);  rpipe-&gt;pipe_state |= PIPE_SEL;  break;case FWRITE:  if ((wpipe == NULL) ||      (wpipe-&gt;pipe_state &amp; PIPE_EOF) ||      (((wpipe-&gt;pipe_state &amp; PIPE_DIRECTW) == 0) &amp;&amp;       (wpipe-&gt;pipe_buffer.size - wpipe-&gt;pipe_buffer.cnt) &gt;= PIPE_BUF)) {          return (1);  }  selrecord(p, &amp;wpipe-&gt;pipe_sel);  wpipe-&gt;pipe_state |= PIPE_SEL;  break;case 0:  if ((rpipe-&gt;pipe_state &amp; PIPE_EOF) ||      (wpipe == NULL) ||      (wpipe-&gt;pipe_state &amp; PIPE_EOF)) {         return (1);  }  selrecord(p, &amp;rpipe-&gt;pipe_sel);  rpipe-&gt;pipe_state |= PIPE_SEL;  break;}</pre><P><a href="#rl2">Back to Article</A></P><H4><a name="l3">Listing Three</H4><pre>/* Excerpt from file /usr/src/sys/miscfs/procfs/procfs_vnops.c *//* Implement poll for procfs -- not as featureful as it could be, but a start * for now, it only checks for a process stopping via STOPEVENT(). */static intprocfs_poll(ap)  struct vop_poll_args /* {    struct vnode *a_vp;    int a_events;    struct ucred *a_cred;    struct proc *a_p;  } */ *ap;{  struct pfsnode *pfs = VTOPFS(ap-&gt;a_vp);  struct proc *procp, *p;  int error;  p = ap-&gt;a_p;  procp = pfind(pfs-&gt;pfs_pid);  if (procp == NULL) {    return ENOTTY;  }  if (!CHECKIO(p, procp))    return EPERM;  if (!procp-&gt;p_ev) {    get_procfs_event(procp);  } else if (procp-&gt;p_ev-&gt;p_step) {    return (ap-&gt;a_events &amp; (POLLRDNORM | POLLWRNORM));  }  selrecord(p, &amp;procp-&gt;p_ev-&gt;p_sel);  return 0;}</pre><P><a href="#rl3">Back to Article</A></P><HR><I>Copyright &copy; 1998, Dr. Dobb's Journal</I><BR>
</body></html>