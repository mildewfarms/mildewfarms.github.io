<html><head><title>Sep98: Distributing Data Using TLT30G</title></head><body bgcolor="FFFFFF"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Distributing Data Using TLT30G</h1><p><i>Dr. Dobb's Journal</i> September 1998</p><h2>A low-bandwidth "broadcasting" service</h2><h3>By Oleg Kiselyov</h3><I>Oleg is a computer scientist with CSC. He can be contacted at oleg@pobox.com.</I><hr><p>TLT30G is a software system for distributing data from a central location to a number of clients over unidirectional, noisy, and generally slow communication links -- the delivery of up-to-date weather information to a ship, for instance. The information -- gridded data, observations, storm warnings, and so on -- is prepared at a central site, which broadcasts over appropriate channels. Any user equipped with the right satellite receiver and a PC can pick up the broadcast, unpack, and view the data.</p><p>A broadcasting server at a central location may not receive feedback from clients. Besides, when data is being sent to a multitude of recipients, feedback is infeasible; otherwise, the single server would be overwhelmed with retransmission requests. To maximize the probability that any client receives the complete data set, the broadcaster fragments data into segments and repeatedly sends them. A receiver must do its best to reassemble a file as soon as it obtains all segments. That means the receiver should pick up transmission starting from any segment, handle segments received in any order, and listen through as many loops of broadcast as necessary to fully assemble the transmitted file. After the file is successfully received, all further segments belonging to the same broadcast session should be disregarded. The client also should be smart enough to handle interrupted broadcasts (which are purged after a certain time-to-live), outdated broadcasting sessions, as well as several simultaneous transmissions from possibly different servers.</p><p>The broadcasting service should also be as transport-independent as possible, being able to function with any communication link that is capable of sending and receiving an eight-bit byte. The byte transport therefore is handled by plug-ins; currently, TLT30G (available electronically; see "Resource Center," page 3) supports UNIX pipes, UNIX and Win32 asynchronous serial lines, and UDP datagrams, on SunSparc/Solaris, HP-UX, and Windows 95/NT.</p><h3>Communication Protocol</h3><p>TLT30G's communication model is similar to the familiar radio/TV broadcast, with several transmitters showering data that a number of recipients pick up. Thus, TLT30G is made of transmitter (broadcaster) and receiver modules, which are separately compiled executables, running as separate processes on (generally) separate hosts connected via an appropriate communication link. The broadcaster module exists in several flavors: The simplest one sends out a single file, while the advanced versions simultaneously distribute a number of files, taking into account a possibility that each file may be concurrently updated.</p><p>The broadcaster and receiver applications speak (and thus implement) a common TLT30G session protocol, which can run on top of several different transports. The TLT30G protocol's scope is segmenting and reassembling data within a transmission session. The protocol itself does not care how segments are passed from one end to another, only how segments are specified and interpreted. To support such an abstraction, the transport layer is accessed exclusively through a pair of abstract classes <i>LAPIn</i>/<i>LAPOut</i>, which define methods to send/receive bytes and mark packets' boundaries. Currently, TLT30G provides implementations of these interfaces for a stream (file/pipe/serial) and datagram (TCP/IP) communication links.</p><p>A segment is a logical unit of transmission for the TLT30G protocol. A broadcasting module splits the file being distributed into fragments, and builds segments around them with the help of a TLT30G protocol API. A transport layer is called upon to transmit segments, either in packets/frames or in a byte/bit stream depending on a particular transport. A receiving module listens for incoming segments and places their payload data according to a file transmission session they belong to, and their position in the file's assembly. As <a name="rf1"><a href="9809cf1.htm">Figure 1</A> shows, every segment starts with a fixed header, followed by payload data, and is terminated by a CRC field. All segments have the same size (specified in the 0th segment). The 0th segment (the segment with <i>seq_number = 0</i>) defines a transmission session and carries its parameters (<a name="rf2"><a href="9809cf2.htm">Figure 2</A>). Because of its importance, the 0th segment is repeated twice during every loop of a broadcast. Still, the receiver can start assembling a file even if it missed the 0th segment.</p><p>Since only one byte is allocated for the segment data length field, the segment's body cannot exceed 255 bytes. This seems appropriate for slow communication channels. A particular value for the segment size is chosen by a transmitter upon start-up, and remains fixed for all sessions of a given transmitter. A receiver, however, can handle segments of any legal size (within a 4-254 range). Moreover, segment sizes may differ among different reception sessions handled concurrently by a receiver.</p><h3>TLT30G's Communication Links</h3><p>TLT30G currently runs over the following data transports:</p><p></p><ul><li>A file link. A particular type of communication through a UNIX file. This can be either an asynchronous or synchronous channel. If the file link is a regular file, a broadcaster module dumps segments into this file one by one. The resulting dump (trace) can be fed into a receiver module, which reassembles the "transmitted" data sets. This scenario is useful in debugging the system. A "file" used for communication can also be a UNIX/Windows NT pipe, or character device (a serial port, for instance). In this case, the file link is an asynchronous communication channel-linking broadcaster and receiver modules/sites. <a name="re1"><a href="9809ce1.htm">Example 1</A> shows examples of using "file" links.  <li>	  The file transport layer transmits a segment byte-by-byte in a continuous stream. Symbol A is arbitrarily chosen to mark the beginning of a segment in the stream. There is no special symbol/condition denoting a segment end.  <li>	  Reading from a regular file is mostly an error-free operation. To check behavior of the receiver in the presence of channel noise, you may want to deliberately introduce errors into the input stream. You can do this by setting an environment variable LAPFILEERR to a desired error rate before launching the receiver; for example, if LAPFILEERR=10, every 10th byte read from a file (on average) would be deliberately mangled.  <li>A Win32 serial communication link. Under UNIX, opening and reading a serial port is identical to handling a regular file; serial port-specific parameters (baud rate, parity, time-outs) can be set via an <i>stty</i> command prior to running the receiver. The same is true for NT. A COM1 port can be opened with a regular <i>fopen()</i> function; the port's parameters can be specified with a mode command. Unfortunately, the Windows 95 mode command is crippled, making it necessary to use Win32s-specific functions (<i>CreateFile</i>, <i>ReadFile</i>, <i>CloseHandle</i>, <i>SetCommState</i>, and <i>SetCommTimeouts</i>) to access a COM port and set its parameters. A separate Win32 serial transport plug-in was therefore needed. This plug-in (a concrete class implementing the <i>LAPIn</i> interface) supports the same file stream transport protocol as described earlier. In fact, a file sent from a UNIX host through a file link (a serial port, /dev/tty00, for instance) can be received on a Windows 95/NT box; see <a href="9809ce1.htm">Example 1</A>.  <li>A network (UDP) transport. This type of communication link transmits segments as UDP datagrams over an IP network. Of all the Internet protocols, UDP is best suited for a unidirectional packet-oriented broadcast. Unlike the file link, this is a packet-oriented transport. Currently, one UDP packet carries a single segment. Yet, it is not difficult to pack several segments into a datagram to better utilize bandwidth.  <li>	  The network transport lets a central site broadcast several "channels" of information. A channel corresponds to a separate UDP port, which must be specified by an environment variable LAPNETPORT. There may be several broadcasters transmitting different files concurrently over the same channel; any receiver tuned to this channel will pick up each file.  <li>Adding a new link. To run TLT30G over a new transport, you must provide an implementation of abstract classes <i>LAPIn</i> and <i>LAPOut</i>. I suggest using the following naming convention: If the new transport link is to be named <i>Foo</i>, the derived LAP classes should be named as <i>LAPFooIn</i> (derived from <i>LAPIn</i>) and <i>LAPFooOut</i> (derived from <i>LAPOut</i>). The interface code (class definitions) has to be put in a file named LAPFoo.h. The broadcaster and receiver modules have to be recompiled with <i><sub>DDEFLAP=LAPFoo </i></sub>flag. Source-code modifications are not necessary.</ul><h3>TLT30G Walk-Through</h3><p>To see how the system actually works, I'll follow the transmission of a single file across a particular (UDP) communication link.</p><p>On the broadcaster side, the entire transmission occurs within a method <i>FileBeingSent::do_broadcast(LAPOut</i>&amp;<i> out_link)</i> (see <a name="rl1"><a href="9809c.htm#l1">Listing One</A>This is the method that implements the outbound part of the TLT30G session protocol, fragmenting the file and sending the segments out. The method is usually repeatedly called. The <i>FileBeingSent</i> class is derived from a protected class <i>Segment0</i> (see <a name="rl2"><a href="9809c.htm#l2">Listing Two</A>), which represents a single file transmission session. Whenever a <i>Segment0</i> object is constructed (for example, as a part of a <i>FileBeingSent</i> object), a new session is created: A session ID is picked (as a random number), the name of the file is remembered, its size is determined, and the total number of segments in this session is computed. These are all parameters necessary to compose the <i>Segment0</i> of the TLT30G protocol; see <a href="9809cf2.htm">Figure 2</A>. A method <i>Segment0::send(out_link)</i> is used to send out this segment (see <a href="9809c.htm#l1">Listing One</A> and <a name="re2"><a href="9809ce2.htm">Example 2</A>).</p><p>This method, as well as the <i>do_broadcast()</i> method in <a href="9809c.htm#l1">Listing One</A>, rely on a <i>SegmentOutStream</i>, which assembles a segment, packs items of various kinds in it, and interfaces a raw byte transport. This class provides a higher-level abstraction of the communication link <i>LAPOut</i>. Upon construction, a <i>SegmentOutStream</i> object informs the link that a new segment is about to begin. The object offers a family of <i>operator &lt;&lt;</i> methods you can use to send data of particular types: short or long integers, a segment's header, or simply an array of bytes. This is similar to the regular C++ output stream. The <i>SegmentOutStream</i> object takes care of marshaling the data in a platform-independent network byte order, and accumulating a CRC. When the object is destroyed, it writes the CRC down and tells the output link that the segment is finished. For more information on the streaming paradigm, see my article "Speaking in Iostreams-ese" (<i>C/C++ Users Journal</i>, May 1997).</p><p>A byte transport is represented in the code by an instance of a <i>LAPOut</i> class. While <i>SegmentOutStream</i> can handle a variety of data types, the transport class is concerned only with moving raw bytes and marking packets (<a name="re3"><a href="9809ce3.htm">Example 3</A>). <i>LAPOut</i> is a pure abstract class (an interface) that is implemented in a number of derived classes that support specific communication links. The main transmitter module creates an instance of a particular concrete transport class, and passes it -- as a <i>LAPOut</i>&amp; reference -- to all other communication objects. Since all these objects see a transport class only through the <i>LAPOut</i>&amp; interface, the higher-level protocol services they provide are independent of the actual byte transport. For illustration, Listing Three (available electronically) presents a set of concrete classes <i>LAPNetOut</i>/<i>LAPNetIn</i>, which implement the <i>LAPOut</i>/<i>LAPIn</i> interface for a UDP communication link. The full UDP transport code is available electronically; see "Resource Center," page 3.</p><p>A TLT30G receiver can handle several simultaneous broadcasting sessions from different transmitters. Each reception session exists in one of the following states: <i>started</i>, because Segment 0 of the session was just received; <i>opened</i>, when some other segment of the session was first spotted; <i>active</i>, that is, accumulating segments; and <i>zombie</i>. A session becomes a zombie when all needed segments have been received, and the corresponding file successfully reassembled. Therefore, the receiver may ignore subsequent broadcast loops for that session. The receiver manages sessions with the help of a Sessions object. This object is instantiated in the main receiver module. Every time a receiver in its main loop acquires a new segment, it passes the corresponding Segment Input Stream object to the Sessions object (Listing Four, available electronically). The object itself is merely a list of Session objects, each representing a separate reception session (Listing Five, available electronically). The <i>Sessions::digest()</i> method, <a name="re4"><a href="9809ce4.htm">Example 4</A>, takes a newly received segment and decides what to do with it. The method extracts the session ID from the segment's header, and tries to locate the corresponding Session object. If successful, the found Session consumes the segment. Otherwise, a new Session object is created and chained into the list.</p><p>All nontrivial processing of a new segment takes place within a Session object. If the corresponding session's status is active, the segment's data would be put into the appropriate place into the file's assembly, unless the segment is a duplicate. A bitstring <i>Session::fragments_received</i> keeps track of successfully processed segments. This lets a Session handle segments received in any order, and detect duplicates. Once the complete set of segments is received, the corresponding data file is passed to a user-supplied helper, and the Session becomes a <i>zombie</i> (freeing all resources that are no longer necessary).</p><p>Waiting for a new segment, receiving its header and the body, and validating that segment (including a CRC check) are performed by a <i>SegmentInStream</i> object when it is constructed. The object can then be used to take items of various types from the segment's body; the object unmarshals data and converts from the network to the native byte order transparently. Similarly to <i>SegmentOutStream</i>, the <i>SegmentInStream</i> object relies on the byte transport layer (<i>LAPIn</i> interface) for detection of a new packet and receiving bytes making up the segment (see <a href="9809c.htm#l2">Listing Two</A>).</p><p><b>DDJ</b></p><H4><a name="l1">Listing One</H4><pre>                  // Broadcast the file, return FALSE if the broadcast was                   // interrupted (because file was changed in the meantime)bool FileBeingSent::do_broadcast(LAPOut&amp; out_link){  Segment0::log("Starting");  Segment0::send(out_link);  Segment0::send(out_link);  // and do it again, 0th segment is important<p></p>  char buffer[256];  assert( MTU &lt; sizeof(buffer) );  rewind(fp);  for(register unsigned long i=1; i&lt;= max_seq_no; i++)  {    if( was_modified() )      return Logger::log("Session aborted: the file was changed"),      false;    if( fread(buffer,sizeof(char),MTU,fp) &lt;= 0 )      perror("reading input file"),      _error("EOF or error reading an input file");<p></p>    SegmentOutStream(out_link) &lt;&lt; SegmentHeader(i,session_id,MTU)                                             &lt;&lt; byte_array(buffer,MTU);  }  Logger::log("Finished broadcast in session %d",session_id);  return true;}</pre><P><a href="#rl1">Back to Article</A></P><H4><a name="l2">Listing Two</H4><pre>#ifndef __GNUC__#pragma once#else#pragma interface#endif<p></p>#ifndef __Segment_h#define __Segment_h<p></p>#include "LAP.h"#include "myenv.h"<p></p>class SegmentOutStream;class SegmentInStream;<p></p>typedef unsigned short ID;<p></p>            // All segments start with this....struct SegmentHeader{  const unsigned long seq_number;   // Sequence number  const ID session_id;          // ID of the current session  const unsigned char data_length;  // Length of the data only                    // Must be within (1,255)  inline int q_header_size(void) const  // True header size, w/o any padding    { return sizeof(seq_number) + sizeof(session_id) + sizeof(data_length); }  SegmentHeader(const unsigned long _seq_number, const short _session_id,                                                      const int _data_length)    : seq_number(_seq_number), session_id(_session_id),      data_length(_data_length)    { assert( _data_length &gt; 1 &amp;&amp; _data_length &lt; 255 ); }  void write(SegmentOutStream&amp; out_packet) const;  void read(SegmentInStream&amp; in_packet);};class Segment0 : public SegmentHeader{protected:  char file_name[20];           // only the basic portion of name, w/o path  const unsigned long file_size;  unsigned long max_seq_no;     // That is, how many data packets  const unsigned char MTU;      // Max transmission unit: data_length                                // in all the packets to follow  inline int q_data_size(void) const    { return sizeof(file_size) + sizeof(MTU) +             sizeof(max_seq_no) + sizeof(file_name); }         // _Partially_ fill out Segment0 based on what found in some_packet  Segment0(const SegmentHeader&amp; some_packet);    static unsigned char default_MTU;  public:  enum { max_MTU = 255 };  // None of the segments can be bigger than that  Segment0(const char * full_file_name);  void send(LAPOut&amp; out_link) const;  void log(const char * title) const;   // Log the contents of Segment0,                                        // which represents a session.                                        // Complete a partially finished                                        // Segment0 from a packet  void complete(SegmentInStream&amp; packet) throw (rc_bad_packet);  unsigned int q_MTU(void) const        { return MTU; }  unsigned int q_max_seq_no(void) const     { return max_seq_no; }  static void set_default_MTU(const int new_MTU);  static int  get_default_MTU(void);};            // A stream to help compose a packetclass SegmentOutStream{  LAPOut&amp; out_link;  CRC16 crc;  void write_byte(const unsigned char a_byte)  { out_link.write_byte(a_byte); crc &lt;&lt; a_byte; }public:  SegmentOutStream(LAPOut&amp; _out_link);  ~SegmentOutStream(void);      // write the CRC and flush the packet  SegmentOutStream&amp; operator &lt;&lt; (const unsigned char a_byte)        { write_byte(a_byte); return *this; }  SegmentOutStream&amp; operator &lt;&lt; (const unsigned short a_short);  SegmentOutStream&amp; operator &lt;&lt; (const unsigned long a_long);  SegmentOutStream&amp; operator &lt;&lt; (const SegmentHeader&amp; seg_header);        // Write an array of bytes        // Array: a representation for an array. Note, for safety an Array         // object cannot be constructed explicitly, either on stack or on         // heap. An Array object can only be constructed via a friend         // function byte_array, and is always transient.  class Array  {    friend SegmentOutStream;    friend SegmentInStream;    const char * const ptr;    const unsigned long size;    Array(const char * byte_array, const unsigned long _size)                                                  // private constructor    : ptr(byte_array), size(_size) {}    Array&amp; operator = (const Array&amp;); // unimplemented and forbidden    Array(const Array&amp;);              // unimplemented and forbidden  public:    friend inline Array byte_array(const char * ptr, const unsigned long size)        { return Array(ptr,size); }  };  SegmentOutStream&amp; operator &lt;&lt; (const Array&amp; array);};inline SegmentOutStream&amp;SegmentOutStream::operator &lt;&lt; (const SegmentHeader&amp; seg_header){  seg_header.write(*this);  return *this;}      // Stream to help de-compose a packet. When stream is fully constructed,      //  it contains complete packet, with CRC and other checks performedclass SegmentInStream{  unsigned char buffer[Segment0::max_MTU+1];    // The buffer where the packet                 // is received. Two ptrs in buffer for the curent reading                // and writing position  const unsigned char * read_ptr;  unsigned char * write_ptr;  CRC16 curr_crc;       // CRC accumulated while the packet is being received                // The packet header is being read as a part                // of the receiving process  SegmentHeader header;                // Take the current byte from the buffer  unsigned char take_byte(void)    { assert( write_ptr &gt; read_ptr ); return *read_ptr++; }                // Receive a byte from the link and into the buffer  void receive_byte(LAPIn&amp; in_link);public:                // Receive a packet. It throws up if there was an input error  SegmentInStream(LAPIn&amp; in_link);  const SegmentHeader&amp; q_header(void) const { return header; }  SegmentInStream&amp; operator &gt;&gt; (unsigned char&amp; a_byte)        { a_byte = take_byte(); return *this; }  SegmentInStream&amp; operator &gt;&gt; (unsigned short&amp; a_short);  SegmentInStream&amp; operator &gt;&gt; (unsigned long&amp; a_long);  SegmentInStream&amp; operator &gt;&gt; (const SegmentOutStream::Array&amp; array);  void write(FILE * fp);    // Dump the rest of the stream into a file};#endif</pre><P><a href="#rl2">Back to Article</A></P><HR><I>Copyright &copy; 1998, Dr. Dobb's Journal</I><BR>
</body></html>