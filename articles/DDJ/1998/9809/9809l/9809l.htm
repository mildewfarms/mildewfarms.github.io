<html><head><title>Sep98: C Programming</title></head><body bgcolor="FFFFFF"><!--Copyright &#169; Dr. Dobb's Journal--><h1>The Next Great Migration: From C++ to Standard C++ </h1><p><i>Dr. Dobb's Journal</i> September 1998</p><h3>By Al Stevens</h3><I>Al is a DDJ contributing editor. He can be contacted at astevens@ddj.com.</I><hr><p>In the next month or two, if all goes according to schedule, the approved ISO C++ draft standard specification will be approved by ANSI, and the formal standardization process will be complete. At that time you will be able to purchase a copy of the document from ANSI. You can now purchase a copy of the draft specification, which is known as the Final Draft Information Standard (FDIS). See the end of this column for details. </p><p>This is a good time to review what has changed in the C++ language as a result of the standardization process. Many of these changes have been discussed in <i>Dr. Dobb's Journal</i> during the committee's eight-year lifespan. The committee took a different approach than its predecessor C committee did -- it chose to do more than codify existing language usage. It used its charter to add to the language and to change, remove or officially deprecate features that it saw to be harmful or unnecessary. (The C committee did some of that, but mainly to resolve contradictions in traditional C implementations.) The result is a C++ language somewhat changed from the one described in 1990 by Ellis and Stroustrup in <i>The Annotated C++ Reference Manual</i> (Addison-Wesley, ISBN 0-201-51459-1), subtitled the <i>ANSI Base Document</i>, and often called simply the ARM. The time to be critical of the process or the result has passed. Standard C++ is what it is going to be. It is now time for us programmers to understand it and its consequences.</p><p>Time was when we would dwell on a small number of incompatibilities between C and C++, differences imposed by the C++ programming model that prevented some C programs from compiling with a C++ compiler. Commentators stressed that they could enumerate those differences in a one-page list, as if the brevity of the list somehow trivialized the migration from C to C++. The issue today, however, is quite different. The earlier migration is history. Virtually everyone uses C++ and is looking at a new Standard that has yet to be fully implemented. We focus now on how Standard C++ differs from traditional C++, to what extent contemporary compilers support those changes, and the likelihood that future compilers will comply. Of particular interest to programmers is how these changes affect our work, that is, how compatible are legacy code and legacy class libraries with new compilers, and how much new stuff we have to learn in order to stay current.</p><p>In this column I'll touch on several of the changes from the perspective of one who cares how they affect us programmers. This discussion is not comprehensive. The scope of language and library invention and innovation is too large, and the space allowed me here is too limited to permit wall-to-wall coverage. These are the high points. It will take more than one month, however.</p><p>When I call these things "new," I am referring to language and library features and behavior that differ from those described in the ARM. Some of this is already implemented in some compilers. Some is not. Every compiler had its own level of compliance with the proposed standard as it evolved. There probably never was one compiler that implemented C++ exactly as the ARM described it. Probably no compiler anywhere (except, perhaps, inside the laboratories of committee members) implements C++ exactly as the FDIS describes it. Eventually, that will change. Until then, consider this column to be a harbinger of what is yet to be. I'll speak in the present tense as if all these things are available; some are and some are not. If you are curious about a feature, test your compiler to see if and how it is implemented.</p><h3>New Language</h3><p>The committee made several changes to the core language. There are new keywords, new data types, and new behavior for the existing language.</p><p>There are two new data types. The <i>bool</i> type includes the keywords <i>true</i> and <i>false</i> to represent Boolean constants. The <i>wchar_t</i> type is a wide character data representation that can be used to record Unicode and international character sets that cannot be encoded in the standard eight-bit <i>char</i> type that C++ inherits from C.</p><p>Most contemporary compilers implement <i>bool</i>, so <i>bool</i> is not news. But I found one significant consequence. Traditional Windows programs use BOOL, a <i>typedef int</i> in windef.h. TRUE and FALSE are implemented as <i>#define</i> macros with constant values 1 and 0. These declarations are relics of traditional C and C++, which do not implement <i>bool</i> as a type. Many Windows API functions include BOOL variables as argument and return types. If you decide to bring your code up to date and use <i>bool</i> instead of BOOL, you get "performance warnings" when you pass BOOL variable arguments to <i>bool </i>parameters or assign BOOL return values to <i>bool</i> variables. <a name="re1"><a href="9809le1.htm">Example 1</A>(a) demonstrates this behavior. The compiler assumes that the <i>int </i>variable might have a value in it and must convert nonzero values to the manifest constant true. </p><p>In <a href="9809le1.htm">Example 1</A>(b) the second <i>foo</i> function overloads the first, because BOOL <i>(int</i>) and <i>bool</i> are different types and each of the two calls is properly associated with its respective <i>foo</i> function. Delete either <i>foo</i> function, and both calls default to the <i>foo</i> function that you did not delete with no errors and no warnings. In the absence of a function with a parameter that matches the argument, the compiler promotes the true constant argument to an <i>int</i>. </p><p>To avoid all this confusion in a Windows program, you can forgo using the newer idioms and use instead BOOL, TRUE, and FALSE. It would seem that you could change the windef.h header file to equate BOOL, TRUE, and FALSE to <i>bool</i>, <i>true</i>, and <i>false</i>, and maybe you can. I hesitate to try it, however, because I don't know whether the compiler would properly promote and demote return types and arguments between my functions, which would be compiled with the new definitions, and the API functions, which were compiled with the old. Besides, messing with the headers of libraries is an inherently unsafe practice. I wish Microsoft would fix it so we can forget about BOOL.</p><h3><i>for</i>, <i>if</i>, <i>while</i>, and <i>switch</i></h3><p>The ARM specifies that you may declare a variable within the first controlling expression of a <i>for </i>statement and that the scope of that variable "extends to the block enclosing the for-statement." (A <i>for</i> statement is defined as the <i>for</i> statement itself and the statement or brace-surrounded statement block that the <i>for</i> statement controls.) Then the ARM goes on to lament this behavior, saying that the scope of the variable should have been limited to that of the <i>for</i> statement itself, but that, "much code now exists that depends on the general rule."</p><p>Existing code notwithstanding, the committee decided to remedy the situation, and cause the behavior to reflect what Stroustrup's hindsight, as reported in the ARM, dictated. <a name="re2"><a href="9809le2.htm">Example 2</A>(a) shows how things are now.</p><p>The consequence of this change is that a lot of existing code is broken. The committee rationalized that in most cases the compiler would report the problem when the program references the variable outside the <i>for</i> statement as <a href="9809le2.htm">Example 2</A>(b) shows.</p><p>There is one condition that the compiler cannot detect, and if there are going to be bugs caused by this change, this is where they will be. If an outer statement block declares a variable of the same name, the compiler uses that variable as the one referenced outside the <i>for</i> statement but inside a statement block that is lower in the nest than the earlier declaration. <a href="9809le2.htm">Example 2</A>(c) shows that situation.</p><p>Standard C++ also allows you to similarly declare variables within the controlling expressions of <i>if</i>, <i>while</i>, and <i>switch</i> statements. </p><h3><i>enum</i></h3><p>An <i>enum</i> expression used to be like an <i>int</i> expression. To permit function overloading based on <i>enum</i> arguments and to tighten the type safety of the language, Standard C++ specifies that each <i>enum</i> defines a discrete type. This is mostly a good change, although I have found it to be an inconvenience. There are places where I want the <i>int</i> behavior from an <i>enum</i>. With Standard C++ that means I use a cast, a small price to pay for type safety, however. </p><h3>Overloaded <i>new</i> and <i>delete</i> for Arrays</h3><p>It is now possible to overload the <i>new</i> and <i>delete</i> operators that get called for arrays.</p><blockquote><p>void* operator new[](size_t nSize);</p><p>void operator delete[](void* pBuffer);</p></blockquote><p>Two new caveats accompany this feature. Use overloaded operator <i>delete[]</i> only to delete the memory of objects that you allocated with overloaded <i>new[]</i>, and use overloaded operator <i>delete</i> only to delete the memory of objects that you allocated with overloaded <i>new</i>. The newly defined operators introduce more potential for coding errors, I am afraid, so beware.</p><h3>Placement <i>new</i></h3><p>Placement <i>new</i> is a C++ feature not specified in the ARM  but already implemented by most compilers. It permits you to pass an additional argument to an overloaded <i>new </i>operator, typically to tell it where to get the memory. The language provides a placement <i>new </i>operator function in the &lt;new&gt; header that uses whatever memory address you specify as the argument to the <i>new </i>operator. <a name="re3"><a href="9809le3.htm">Example 3</A>(a) demonstrates this behavior. Presumably, you would know better than to call operator <i>delete </i>for an object constructed with such a placement <i>new</i> operator.</p><p>You can provide your own placement <i>new</i> operator function. <a href="9809le3.htm">Example 3</A>(b) suggests one such scenario contrived for this discussion. The program specifies a <i>bool</i> constant to tell the placement <i>new </i>operator function where to get the memory. Once again, you are expected to know which objects need to be deleted and which do not. </p><p>A placement <i>new</i> operator function must have a <i>size_t</i> object as its first parameter. By having at least one additional parameter, the function is automatically a placement <i>new </i>operator function. Those parameters can be anything.</p><h3>Placement <i>delete</i></h3><p>Suppose the constructor for <i>MyClass</i> in <a href="9809le3.htm">Example 3</A> throws an exception. When a constructor called from the default operator <i>new </i>or an overloaded nonplacement operator <i>new </i>throws an exception, the system knows to automatically delete the memory with the <i>delete</i> operator. It assumes that if you overloaded <i>new, </i>you will similarly overload <i>delete. </i>The system cannot use the <i>delete </i>operator when a placement <i>new </i>operator is involved. There can be more than one placement <i>new </i>operator function for a class, and, consequently, the system cannot be sure where the memory came from or what to do to delete it.</p><p>Placement <i>delete</i> was added to make placement <i>new </i>work in this case. If the constructor throws an exception and you have provided a matching placement <i>delete </i>operator, the system calls that operator when the constructor throws an exception. A matching placement <i>delete</i> operator function is one that has the usual <i>void*</i> first parameter and matches the parameter list of the placement <i>new </i>operator function's parameter list starting at the second parameter. <a href="9809le3.htm">Example 3</A>(c) shows a placement <i>delete</i> operator function that matches the placement <i>new </i>operator function of <a href="9809le2.htm">Example 2</A>(b).</p><p>There's one hitch. There's no way for your program to delete the object with a simple delete statement. You have to call the destructor first, then call the matching placement <i>delete </i>operator function as <a href="9809le3.htm">Example 3</A>(d) shows. With the <i>MyClass</i> class in <a href="9809le3.htm">Example 3</A>, these calls are unnecessary because the placement <i>delete </i>function does nothing if the <i>bool</i> parameter is true. Furthermore, you would never need to call the placement <i>delete </i>function with a false argument. Instead, you would simply use the default <i>delete </i>operator. Real-world usages of placement <i>new </i>and <i>delete </i>might not be so simple, however.</p><h3>Namespaces</h3><p>Standard C++ introduces namespaces, a feature that permits you to enclose a body of source code in a namespace such that the identifiers defined in the translation unit do not conflict with other identifiers that have the same name. This feature addresses the problem of name collision encountered when multiple libraries use global declarations. Vendors typically used prefixes on identifiers to try to avoid such collisions, and, by convention, compiler-provided system identifiers started with an underscore. A library vendor can now select a unique namespace identifier and enclose within that namespace those declarations in their header files that were formerly global.</p><p>Any nonstatic external identifier with a declaration not enclosed in a namespace is in the global namespace and visible to all translation units in the program.</p><p>The Standard C++ Library places all its external identifiers in the <i>std</i> namespace, although there is still some controversy about the placement of the Standard C Library functions. More about that later.</p><p>With namespaces, everybody's declarations are available to the using program (and to each other) as long as you qualify the identifiers with the correct namespace.</p><p>Most contemporary compilers implement the namespace feature, although some ports of the GNU compiler do not yet.</p><p>You can provide an unnamed namespace, and the compiler assigns a unique but hidden one for the duration of the translation unit. This feature protects your program's external identifiers from collision without your having to worry about selecting a unique namespace. Standard C++ deprecates the use of the static storage class to restrict global identifiers to file scope in favor of the unnamed namespace. I plan to discuss namespaces in more detail in a future column.</p><h3>New-Style Headers</h3><p>Standard C++ introduces the new style of header files for the Standard C++ Library. Instead of including &lt;iostream.h&gt;, for example, you include &lt;iostream&gt;. Instead of including &lt;stdio.h&gt;, you include &lt;cstdio&gt;. Although Standard C++ does not require it, most compiler vendors provide the old C++ header files (iostream.h, and so on) to support legacy code, but those implementations are vendor specific, meaning they are not bound to any Standard specification. </p><p>There are significant differences between what happens if you include the new versus the old headers. I'm talking about the C++ Library now. I'll get to the C Library headers later. If you include the new headers, all the identifiers are in the <i>std</i> namespace. If you include the old headers, they are probably not, depending on the vendor-specific implementation. There is another significant difference. The classes and functions declared in the new headers, and, consequently, the functions and other external definitions linked to programs that use the new headers are probably (depending on the vendor's legacy library) completely different functions and external variables than those in a program that uses the old headers.</p><p>For example, most Standard C++ Library classes and functions that deal with characters are implemented as templates that are parameterized based on the character type. If you include &lt;string&gt; and instantiate an <i>std::string</i> object, for example, the compiler converts that declaration into a template class object declaration with a char template argument. If you want a string object of wide characters, you instantiate an <i>std::wstring</i> object that invokes a template class object declaration with a <i>wchar_t</i> template argument. By specifying string and stream classes as templates parameterized by the character type, the Standard provides for one body of source code to support all character sets.</p><p>Your code that instantiates strings looks like it always did (with the addition of the namespace qualifier), but there are consequences. First, such objects are not compatible with libraries that were compiled with older compilers. A Standard C++ <i>std::string</i> object is really an object of type <i>std::basic_string&lt;char</i>, <i>char_traits&lt;char&gt;</i>, <i>allocator&lt;char&gt; &gt;</i>. If you use Standard C++ strings, you will include &lt;string&gt;, and things named <i>std::string</i> are really named that longer thing. If your program includes the header file of an older library that itself includes the legacy &lt;string.h&gt; and uses legacy <i>string </i>objects, there is no immediate problem (assuming the library vendor has done a good job of separating the two; Version 5.0 of the Microsoft C++ compiler reveals instances of cross-including old and new headers); the old string identifier is not in the <i>std </i>namespace. But what happens when you call a function in that library and provide your new <i>std::string</i> object as an argument? It doesn't compile, because your <i>std::string</i> is not the same type as the legacy string type identified in the function's prototype.</p><p>The problem gets really confusing if you took the path of least resistance as many programmers do and put a <i>namespace std; </i>statement in your program so you don't have to qualify everything.  When you do that, objects of type <i>string </i>are not the same as objects of type <i>string. </i>Huh?</p><p>The second consequence is that the error message says something about not being able to match an argument of type <i>std::basic_string&lt;char, char_traits&lt;char&gt;</i>, <i>allocator&lt;char&gt; &gt;</i>, which you did not specify (and might never have heard of) to a parameter of type string, which you did specify. If you don't understand the underlying hidden mechanism, you can't decipher the error message, a common requirement of C++ that has always been one of the hardest things to explain to programmers who are new to the language. "Why does it say that? I didn't code that."</p><h3>Standard C Headers</h3><p>A bit of controversy surrounds the issue of the Standard C Library headers. Since Standard C is a part of Standard C++, a complying compiler must provide both versions of the C Library headers so that you can include &lt;stdlib.h&gt; and its ilk as always or &lt;cstdlib&gt; and others to use the new idiom. The convention is to prefix the Standard C Library name with "c" and to drop the ".h."</p><p>The controversy has to do with whether a compiler must put the C names into the <i>std</i> namespace when you include the new headers. I discussed this issue several columns ago. According to some committee members, their intention was to require that C names be in the <i>std</i> namespace when a program includes the new C headers. But ambiguities in the specification permit a compiler vendor to interpret it as allowing them to leave the C names in the global namespace like always, which is how Visual C++ 4.0, for one example, is implemented. Committee members suggest that there could be some clarification at a later date to tighten the requirement and remove the ambiguities. </p><p>Next month I'll continue this discussion. There are changes to how classes work, run-time type information, new-style casts, an almost completely revised Standard C++ Library, and substantial changes to templates.</p><h3>Sources for the FDIS Document</h3><p>The FAQ for the newsgroup comp.std.c++ says that you can order the Final Draft Information Standard, "Programming Language - C++" document from two sources.  In June, I called ANSI (American National Standards Institute, 11 W. 42nd Street, New York, NY 10036, 212-642-4900, http://www.ansi.org/) and they said they would print the Standard on request at a cost of $265. </p><p>Windows CE: A Correction or Two</p><p>A couple of months ago, I wrote about the real-time characteristics of Windows CE and said that "the mechanics of a thread receiving a signal involves the Windows messaging system, which sends a notification message to a window..." I got that information, or, more precisely, that impression, at the Windows CE Developer's Conference and it turns out to be wrong. Several readers wrote to correct me. Tony Barbagallo, the Microsoft Product Manager for Windows CE said, "Signaling a thread from an ISR does not involve any message queues. The thread blocks waiting for an event using <i>WaitForSingleObject, </i>and will be woken up as soon as the interrupt dispatch has completed." Of course, "as soon as" is a vague measure that says nothing about how long it takes for the interrupt to be received and processed, and I still maintain as I did in the July issue that Windows CE is not a real-time operating system according to my understanding of real-time requirements. That contention was not challenged by any readers, but I do need to change my tune about the thread signalling process. Having written plenty of Win32 code that signals threads that use <i>WaitForSingleObject</i>, I should have known better.</p><p>I got another wrong impression at the conference. I did not think I would like palm-size PC devices. I based that conclusion on the hands-on demonstrations at the conference. All conference attendees were to receive a free Cassiopeia device with the Palm PC version of Windows CE installed. I said in July that I'd reserve final judgement until I got mine. I got it. I like it.</p><p><b>DDJ</b></p><HR><I>Copyright &copy; 1998, Dr. Dobb's Journal</I><BR>
</body></html>