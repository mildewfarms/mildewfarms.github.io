<html><head><title>Sep98: The Windows CE 2.0 Remote API</title></head><body bgcolor="FFFFFF"><!--Copyright &#169; Dr. Dobb's Journal--><h1>The Windows CE 2.0 Remote API</h1><p><i>Dr. Dobb's Journal</i> September 1998</p><h2>The CeRapiInvoke API is a versatile tool</h2><h3>By Andrew Tucker</h3><I>Andrew works on development tools for Windows CE at BSQUARE Corporation. He can be reached at ast@halcyon.com.</I><hr><p>Communication between a desktop PC and an external device is one of the fundamental features all Windows CE users expect. To this end, CE provides a wide range of options including dial-up ability with Remote Access Services (RAS), WinSock, and the Remote API (RAPI). Unlike the first two, RAPI is unique to CE and provides a high-level interface to query the device for information (such as the processor type and OS version), as well as manipulate the device's object store and file system. </p><p>With the introduction of CE 2.0, several functions were added to RAPI including <i>CeRapiInitEx</i>, <i>CeGetTempPath</i>, and <i>CeRapiInvoke</i>. The <i>CeRapiInvoke</i> function, in particular, is a confusing but useful method for providing a simplified version of a Remote Procedure Call (RPC) between a desktop machine and a device. In this article, I'll examine <i>CeRapiInvoke</i> and share tips on how to avoid common usage pitfalls.</p><h3>Using <i>CeRapiInvoke</i></h3><p>Assume you are writing a Windows NT application that needs to display the list of all the DLLs loaded on your CE device. How would you go about doing this? One way would be to launch a program on the device that writes to a file or the registry, then read that data via RAPI. This approach is problematic because it is difficult to determine when all of the data has been written. Another possibility is to have a program on the device create a socket connection to pipe the data through. This works -- but for such a small transaction, it requires a lot of overhead. <i>CeRapiInvoke</i> solves this dilemma by providing a way to call a function in a DLL on the device and have it pass back a block of data or a pointer to an <i>IRAPIStream</i> COM object that allows bidirectional communication.</p><p>The prototype for <i>CeRapiInvoke</i> looks like <a name="re1"><a href="9809fe1.htm">Example 1</A>. <i>lpwszDll</i> is the name of a DLL in the Windows directory on the device, and <i>lpwszFunc</i> the name of a function exported from that DLL that you want to call. The <i>dwInputCount</i> and <i>pcbIn</i> parameters specify the data you want to pass to the remote function. These are optional, but if one contains valid data, they both must contain valid data. The <i>pcbOutput</i> and <i>ppbOutput</i> output parameters allow the remote function to return a buffer to the caller. <i>ppStream</i> provides the COM interface for sending and receiving data and determines the mode that this call to <i>CeRapiInvoke</i> is using. The last parameter is reserved for future use and should be set to zero. </p><p><i>CeRapiInvoke</i> can be used in either block or stream mode. In block mode, the <i>ppStream</i> parameter must be NULL, the remote function is called synchronously, and data is passed back through the <i>pcbOutput</i> and <i>ppbOutput</i> parameters. By "synchronously" I mean that the call to <i>CeRapiInvoke</i> will not return until the remote function has completed. When <i>ppStream</i> is not NULL, the remote function is called asynchronously, <i>CeRapiInvoke</i> returns without waiting for <i>lpwszFunc</i> to complete, and <i>ppStream</i> points to an initialized <i>IRAPIStream</i> object that is connected to the corresponding stream on the device. Data can now be sent back and forth until the stream is closed on both ends. Even though <i>pcbOutput</i> and <i>ppbOutput</i> are used only for block mode, they must both not be NULL or <i>CeRapiInvoke</i> will return E_FAIL with a last error value of ERROR_INVALID_PARAMETER.</p><p>Though the name of the remote function can be that of any export, RAPI requires the prototype be like <a name="re2"><a href="9809fe2.htm">Example 2</A>, where the first two parameters are copies of the input parameters from <i>CeRapiInvoke</i>. The next two parameters, <i>pcbOutput</i> and <i>ppbOutput</i>, are filled in by <i>RemoteFunc</i> and passed back to the caller of <i>CeRapiInvoke</i> in block mode. RAPI requires that the memory for <i>ppbOutput</i> be allocated with <i>LocalAlloc</i> to ensure that it is freed correctly. The last parameter is a pointer to an <i>IRAPIStream</i> that RAPI will have allocated if the <i>ppStream</i> parameter in the call to <i>CeRapiInvoke</i> is not NULL.</p><p>That last point about <i>IRAPIStream</i> is an important one -- RAPI allocates and frees the object for you. In other words, to call <i>CeRapiInvoke</i> in stream mode, the <i>ppStream</i> parameter should be the address of a pointer to an <i>IRAPIStream</i> object that is initialized to NULL (<a name="rl4"><a href="9809f.htm#l4">Listing Four</A>, available electronically; see "Resource Center," page 3). RAPI does not allow use of an object that you allocate; attempting to do so will result in a memory leak. When both sides are finished with the stream, they just need to call <i>Release</i> to decrement the reference count and allow the object to be freed. </p><p><i>IRAPIStream</i> is derived from the standard COM <i>IStream</i> interface and provides the two additional functions shown in <a name="re3"><a href="9809fe3.htm">Example 3</A>. Currently only one flag is supported -- STREAM_TIMEOUT_READ. The online documentation for STREAM_TIMEOUT_READ states that it allows setting timeouts for the <i>IStream::Read</i> method, but never indicates what type of units are expected (seconds, milliseconds, whatever). When <i>GetRapiStat</i> is called with a nonNULL <i>pdwValue</i> parameter, it returns the Win32 code ERROR_INVALID_PARAMETER (which is not a valid HRESULT) and calling it with a NULL parameter results in an access violation exception. Conversely, calling <i>SetRapiStat</i> with any nonzero value in <i>dwValue</i> did not cause Read to timeout in any way that I could tell. Additionally, the declaration of <i>IRAPIStream</i> is not included in the Windows CE 2.0 headers and must be retrieved from the NT RAPI.H include file. For these reasons, I suggest you stick with just the <i>IStream</i> level features and don't use any <i>IRAPIStream</i> specifics.</p><p>Similar to <i>GetRapiStat</i> with a non-NULL second parameter, the fact that the return value from <i>CeRapiInvoke</i> is an HRESULT is deceiving. In reality, it can be an HRESULT, the return code from <i>lpwszFunc</i>, or a Win32 error code indicating that the DLL did not exist on the device, the function requested was not exported from the DLL, or the remote function caused an exception. The effect of this is that you must do something similar to <a name="rl1"><a href="9809f.htm#l1">Listing One</A> where I explicitly check for values that are not HRESULT before using the SUCCEEDED macro. There is still a problem, however -- in block mode, the return value from <i>CeRapiInvoke</i> will be the return value from <i>lpwszFunc</i> if no errors occurred. This means that if <i>lpwszFunc</i> innocuously returns the same value as one of the Win32 error codes, there is no way to discern whether an error occurred. I recommend you only return S_OK or S_FALSE from the remote function to avoid this situation. This problem does not occur in stream mode because, due to the asynchronous nature of the call, there is no way to retrieve the return value from the remote function.</p><h3>A Module Name Dialog Example</h3><p>Now that I've covered how to use <i>CeRapiInvoke</i>, let's look at some code that solves the original problem presented (getting a list of all DLLs loaded on the device) and provides a simple dialog-based chat example. The first part will use <i>CeRapiInvoke</i> in block mode while the second will utilize stream mode. The source example code as well as the Visual C++ for Windows CE project that was used to build them is available electronically; see "Resource Center," page 3. The examples are organized into two NT executables, <i>CRIBlock</i>, and <i>CRIStream</i>, and one CE DLL, CRIDLL, that provides the remote functions. </p><p><a name="rl2"><a href="9809f.htm#l2">Listing Two</A> is <i>CRIBlock</i>. The first thing <i>WinMain </i>does is initialize RAPI using the new <i>CeRapiInitEx</i> function. <i>CeRapiInitEx</i>, unlike <i>CeRapiInit</i>, lets you time out after a specified interval and cancel the operation. If the initialization does not succeed after 15 seconds, you cancel the request and display a dialog box stating that you failed to connect. Once RAPI is initialized we then call the <i>GetLoadedModules</i> routine in CRIDLL using <i>CeRapiInvoke</i> and test for success using <a href="9809f.htm#l1">Listing One</A>. If the call succeeds, you then use the Win32 <i>DialogBoxParam</i> API to display the module list passed back through the output parameters of <i>CeRapiInvoke</i>; see <a name="rf1"><a href="9809ff1.htm">Figure 1</A>. When users close the dialog box, <i>DialogBoxParam</i> will return and you free the module list using <i>CeRapiFreeBuffer</i>. </p><p>The dialog box on the host side is pretty boring. In the WM_INITDIALOG handler, you parse the newline-delimited module list using the C run-time routine <i>_tcstok</i>, then add the strings to a listbox. The WM_COMMAND handler takes care of closing the dialog when the user clicks the OK button or Cancel button. All of the real action takes place in CRIDLL routine <i>GetLoadedModules</i> in <a name="rl3"><a href="9809f.htm#l3">Listing Three</A> (also available electronically). </p><p><i>GetLoadedModules</i> uses the Windows CE TOOLHELP routines to retrieve the list of currently loaded DLLs. The call to <i>CreateToolhelp32Snapshot</i> uses the TH32CS_ SNAPMODULE and TH32CS_ GETALLMODS flags to accomplish this. If you've used TOOLHELP before on Windows 95 you'll notice that the TH32CS_GETALLMODS flag is not provided there and is specific to Windows CE. If you didn't include it, you would retrieve the names of the modules loaded for the current process instead of the entire operating system. The code then builds up the module list using the <i>Module32First</i> and <i>Module32Next</i> functions, allocating memory along the way with <i>LocalAlloc</i> and <i>LocalReAlloc</i> as required by RAPI. When <i>Module32Next</i> returns FALSE, you drop out of the loop, close the TOOLHELP handle and set the <i>ppOutput</i> and <i>pcbOutput</i> parameters.</p><p>Using <i>LocalAlloc</i> and <i>LocalReAlloc</i> in this manner exposed a quirk in the Windows CE implementation. In the past, when I used them in a loop like this on NT, I used LPTR as the flag to <i>LocalReAlloc</i>, which allowed me to allocate up to about 512 KB. On Windows CE, this same scenario never allocates more than one KB. This size limitation it too small even for our process list. Changing the <i>LocalReAlloc </i>flag to LMEM_MOVEABLE works on both NT and CE and allows memory up to the size of the biggest free block to be allocated since the location can be moved after the call to <i>LocalAlloc </i>rather than having to be expanded in place. </p><h3>The <i>CRIStream</i> Example</h3><p><a href="9809f.htm#l4">Listing Four</A> (also available electronically) presents my second example, <i>CRIStream</i>. <i>WinMain</i> calls <i>CeRapiInitEx</i> just like <i>CRIBlock</i> and then displays the dialog in <a name="rf2"><a href="9809ff2.htm">Figure 2</A>. When the dialog is first displayed, the edit box and Send button are disabled. After users click on the Connect button a dialog box is created on the CE device, the edit box and Send button are enabled, and the Connect button changes to Disconnect. Clicking on the Send button sends the text in the edit box to the device that is then displayed on the device dialog in a read-only edit box. The dialog box on the device does not accept any user input and is destroyed automatically when users click on the Disconnect button. The connection can be created and destroyed as many times as users like and clicking the close icon in the upper-right corner or hitting ESC on the keyboard will close the dialog box.</p><p>The WM_INITDIALOG handler in <i>DlgProc</i> takes care of initially disabling the edit box and Connect buttons, as well as limiting the edit box to the maximum number of characters that the user is allowed to input. The WM_COMMAND case handles all of the user input. IDCANCEL simply calls <i>EndDialog</i> after calling <i>Disconnect</i> to make sure that you don't close the dialog while still being connected to the device. The case for IDC_CONNECT checks to see if you are currently connected then calls the appropriate <i>Connect</i> or <i>Disconnect</i> routine.</p><p>The <i>Connect</i> routine uses <i>DoCRI</i> to call <i>CeRapiInvoke</i> in stream mode, passing a pointer to the global <i>g_pStream</i> that is initialized to NULL. If the call to <i>CeRapiInvoke</i> succeeds the user interface is updated to the connected state. The <i>Disconnect</i> routine writes a "magic string" to the stream, telling the device that it is disconnecting (this will be explained more in the following paragraph). It then updates the user interface to the disconnected state. The final user input that WM_COMMAND handles is IDC_SEND, which gets the data from the edit box and sends it over <i>g_pStream</i> by first writing the number of bytes being sent, then the bytes themselves. </p><p><i>DlgStreamTest</i> (available electronically) initializes the output variables to NULL and then displays a dialog with <i>DialogBoxParam</i>, passing the pointer to the <i>IRAPIStream</i> in the <i>DlgProc</i>'s LPARAM. After limiting the edit box to the maximum number of characters, the WM_ INITDIALOG handler starts a separate thread to receive the text, passing the dialog's <i>hWnd</i> and the <i>IRAPIStream</i> pointer in a structure through the thread function's formal parameter. If you were successful in starting the thread, you call <i>SetForegroundWindow</i> with the dialog box's <i>hWnd</i> to make sure that it is not hidden behind some other window.</p><p>The thread function <i>ReceiveText</i> takes over next and, after validating its parameters, sits in an endless loop waiting for data from the <i>IRAPIStream</i>. If you are able to read both the size of the data and the data itself, you then check to see if you received the magic string indicating that the user wants to disconnect. If you did not receive the magic string, you just use <i>SetWindowText</i> to display the text in the edit box; otherwise you break out of the loop, post an IDC_FINISHED notification to the dialog box, and call <i>Release</i> on the stream pointer. When <i>DlgProc</i> receives the IDC_FINISHED notification, it waits for the thread to finish executing, and then kills itself with a call to <i>EndDialog</i>.</p><p>The shutdown sequence for this dialog, though it may seem like overkill, is very important. When I first wrote this example, I just had <i>ReceiveThread</i> call <i>SendMessage,</i> and <i>DlgProc</i> did not wait for the secondary thread to exit. This allowed the dialog to close and <i>DlgStreamTest</i> to return before <i>ReceiveThread</i> had completed. The result was that any subsequent connections after the first one would cause intermittent access violation exceptions and crash the CE RAPI component. Changing to the current method solved this problem. This serves as just another example of how important it is to be careful when doing multithreaded programming -- it's easy to go wrong in even as simple a situation as this.</p><p>One final note about writing dialog-based applications for CE. The taskbar only contains buttons for visible, top-level windows that have the WS_OVERLAPPED style. By default, dialog boxes have the WS_POPUP style, and thus, do not get taskbar buttons. If you want your application to have a command bar button, the solution is to change the dialog box to have the WS_OVERLAPPED style instead of WS_POPUP either with the resource editor or by hand editing the RC file. </p><h3>Debugging <i>CeRapiInvoke </i>DLLs</h3><p>Debugging an application that utilizes <i>CeRapiInvoke</i> presents a bit of a unique problem, since it involves a process on the desktop and a DLL on the device. My solution is to debug the desktop application with Visual C++ and the CE DLL with WinDbg. Placing a call to <i>DebugBreak</i> in the routine being called by <i>CeRapiInvoke</i> lets you step through the code and debug as you normally would. See the Windows CE Embedded Toolkit for Visual C++ or the Windows CE Platform SDK for WinDbg and how to set it up to debug CE applications. </p><h3>Conclusion</h3><p><i>CeRapiInvoke</i> is a useful and versatile addition to the RAPI arsenal. The examples I've shown only just begin to scratch the surface of its possible applications.</p><p><b>DDJ</b></p><H4><a name="l1">Listing One</H4><pre>#include &lt;windows.h&gt;/* This handles the overloaded return value from CeRapiInvoke. */<p></p>BOOL CRI_Success(HRESULT hr){    BOOL bOK = TRUE;    if ( hr == ERROR_FILE_NOT_FOUND         ||         hr == ERROR_CALL_NOT_IMPLEMENTED   ||         hr == ERROR_EXCEPTION_IN_SERVICE )    {        bOK = FALSE;    }    else        bOK = (SUCCEEDED(hr));    return bOK;}</pre><P><a href="#rl1">Back to Article</A></P><H4><a name="l2">Listing Two</H4><pre>#include &lt;windows.h&gt;#include &lt;tchar.h&gt;#include &lt;rapi.h&gt;<p></p>#include "..\common.h"<p></p>BOOL CALLBACK ModuleDlgProc(HWND hwndDlg, UINT uMsg,                             WPARAM wParam, LPARAM lParam); int WINAPI WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance,                            LPSTR lpCmdLine, int nCmdShow){    RAPIINIT ri = { sizeof(RAPIINIT) };    if ( SUCCEEDED(CeRapiInitEx(&amp;ri)) )    {        // wait for 15 seconds for the connection...        if ( (WaitForSingleObject(ri.heRapiInit, 15000) == WAIT_OBJECT_0) &amp;&amp;              SUCCEEDED(ri.hrRapiInit) )        {            HRESULT hr;            DWORD   dwBuf;            BYTE    *pbuf;            hr = CeRapiInvoke(_T("cridll.dll"), _T("GetLoadedModules"),                                         0, NULL, &amp;dwBuf, &amp;pbuf, NULL, 0);            if ( CRI_Success(hr) )            {                if ( pbuf == NULL )                {                    MessageBox(NULL, _T("Loaded Module List"), _T("No                                loaded modules found on device"), MB_OK);                }                else                {                    // display dialog and pass pointer to module list                    DialogBoxParam(hInstance,                                    MAKEINTRESOURCE(IDD_BLOCKDLG), NULL,                                     (DLGPROC)ModuleDlgProc, (LPARAM)pbuf);                }                // free the memory allocated by the call to CeRapiInvoke                CeRapiFreeBuffer(pbuf);            }            else            {                MessageBox(NULL, L"CeRapiInvoke failed",                                  L"CeRapiInvoke failed", MB_OK);            }        }        else        {            MessageBox(NULL, _T("CeRapiInitEx failed"),                              _T("CeRapiInitEx failed"), MB_OK);        }        // have to call uninit even if the connection did not succeed        CeRapiUninit();    }    else    {        MessageBox(NULL, _T("CeRapiInitEx failed"),                          _T("CeRapiInitEx failed"), MB_OK);    }    return 0;    if ( CeRapiInit() != E_FAIL )    {    }    else    {        MessageBox(NULL, L"CeRapiInit failed", L"CeRapiInit failed", MB_OK);    }    return 0;}// window function for the dialog boxBOOL CALLBACK ModuleDlgProc(HWND hwndDlg, UINT uMsg,                             WPARAM wParam, LPARAM lParam){    BOOL    bRet = FALSE;    switch( uMsg )    {        case WM_INITDIALOG:        {            LPWSTR lpwszMods = (LPWSTR)lParam;            // parse modules from passed list and display in listbox            LPWSTR lpwsz = _tcstok(lpwszMods, _T("\n"));            while (lpwsz)            {                SendMessage(GetDlgItem(hwndDlg, IDC_MODLIST),                             LB_ADDSTRING, 0, (LPARAM)lpwsz);                lpwsz = _tcstok(NULL, _T("\n"));            }        }        break;        case WM_COMMAND:        {            int     nID = LOWORD(wParam);            int     wNotify = HIWORD(wParam);            // handle click on OK or Cancel            if ( wNotify == BN_CLICKED )            {              switch( nID )              {                case IDCANCEL:                case IDOK:                    EndDialog(hwndDlg, nID);                    bRet = TRUE;                    break;              }            }        }        break;    }    return bRet;}AUCTION</pre><P><a href="#rl2">Back to Article</A></P><HR><I>Copyright &copy; 1998, Dr. Dobb's Journal</I><BR>
</body></html>