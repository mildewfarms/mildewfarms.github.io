<html>
<head>
<title>The C++0x "Remove Concepts" Decision</title>
<link rel="Stylesheet" rev="Stylesheet" href="../../../../forms/Layout.css" type="text/css">
<link rel="Stylesheet" rev="Stylesheet" href="../../../../forms/FontStyles.css" type="text/css">
<link rel="Stylesheet" rev="Stylesheet" href="../../../../forms/newarticle.css" type="text/css">
<script src="../../../../forms/popwindow.js"></script>
</head>

<body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000">
<!--Copyright &#169; Dr. Dobb's Journal-->
<p><i>Dr. Dobb's Digest</i> August 2009</p>

<h1> The C++0x "Remove Concepts" Decision </h1>
<h2>Concepts were to have been the central new feature in C++0x </h2>
<P>
<h3>By Bjarne Stroustrup</h3>


<P>
Bjarne Stroustrup designed and implemented the C++ programming language. He can be contacted <a href="http://www.research.att.com/~bs">here</a>.
<P>
<hr>
<P>

<i>At the July 2009 meeting in Frankfurt, Germany, the C++ Standards Committee voted to remove "concepts" from C++0x. Although this was a big disappointment for those of us who have worked on concepts for years and are aware of their potential, the removal fortunately will not directly affect most C++ programmers. C++0x will still be a significantly more expressive and effective language for real-world software development than C++98. The committee acted with the intent to limit risk and preserve schedule. Maybe a significantly improved version of "concepts" will be available in five years. This note explains the reasons for the removal of "concepts," briefly outlines the controversy and fears that caused the committee to decide the way it did, gives references for people who would like to explore "concepts," and points out that (despite enthusiastic rumors to the contrary) "the sky is not falling" on C++.</i>
<P>
<h3> No "Concepts" in C++0x </h3>
<P>

<P>
At the July 2009 Frankfurt meeting of the <a href="http://www.open-std.org/jtc1/sc22/wg21/">ISO C++ Standards Committee</a> (WG21), the "concepts" mechanism for specifying requirements for template arguments was "decoupled" (my less-diplomatic phrase was "yanked out"). That is, "concepts" will not be in C++0x or its standard library. That -- in my opinion -- is a major setback for C++, but not a disaster; and some alternatives were even worse.
<P>

<P>
I have worked on "concepts" for more than seven years and looked at the problems they aim to solve much longer than that. Many have worked on "concepts" for almost as long. For example, see (listed in chronological order):
<P>
<ul>
<li>Bjarne Stroustrup and Gabriel Dos Reis: <a href="http://www.research.att.com/%7Ebs/N1522-concept-criteria.pdf">Concepts -- Design choices for template argument checking</a>. October 2003. An early discussion of design criteria for "concepts" for C++. 
<li>Bjarne Stroustrup: <a href="http://www.research.att.com/%7Ebs/n1510-concept-checking.pdf">Concept checking -- A more abstract complement to type checking</a>. October 2003. A discussion of models of "concept" checking. 
<li>Bjarne Stroustrup and Gabriel Dos Reis: <a href="http://www.research.att.com/%7Ebs/n1782-concepts-1.pdf">A concept design (Rev. 1)</a>. April 2005. An attempt to synthesize a "concept" design based on (among other sources) N1510, N1522, and N1536.
<li>Jeremy Siek, Douglas Gregor, Ronald Garcia, Jeremiah Willcock, Jaakko Jarvi, and Andrew Lumsdaine: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1758.pdf">Concepts for C++0x</a>. N1758==05-0018. May 2005.
<li>Gabriel Dos Reis and Bjarne Stroustrup: <a href="http://www.research.att.com/%7Ebs/popl06.pdf">Specifying C++ Concepts</a>. POPL06. January 2006.
<li>D. Gregor, B. Stroustrup: <a href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2006/n2042.pdf">Concepts</a>. N2042==06-0012. June 2006. The basis for all further "concepts" work for C++0x.
<li>Douglas Gregor, Jaakko Jarvi, Jeremy Siek, Bjarne Stroustrup, Gabriel Dos Reis, Andrew Lumsdaine: <a href="http://www.research.att.com/%7Ebs/oopsla06.pdf">Concepts: Linguistic Support for Generic Programming in C++</a>. OOPSLA'06, October 2006. An academic paper on the C++0x design and its experimental compiler "ConceptGCC."
<li>Pre-Frankfurt working paper (with "concepts" in the language and standard library): <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2914.pdf">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2914.pdf</a> . N2914=09-0104. June 2009.
<li>B. Stroustrup: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2906.pdf">Simplifying the use of concepts</a>. N2906=09-0096. June 2009.
</ul>
<P>

<P>
It need not be emphasized that I and others are quite disappointed. The fact that some alternatives are worse is cold comfort and I can offer no quick and easy remedies.
<P>

<P>
Please note that the C++0x improvements to the C++ features that most programmers see and directly use are unaffected. C++0x will still be a more expressive language than C++98, with support for concurrent programming, a better standard library, and many improvements that make it significantly easier to write good (i.e., efficient and maintainable) code. In particular, every example I have ever given of C++0x code (e.g., in <a href="http://www.research.att.com/%7Ebs/hopl-almost-final.pdf">Evolving a language in and for the real world: C++ 1991-2006</a> at ACM <a href="http://portal.acm.org/toc.cfm?id=1238844">HOPL-III</a> ) that does not use the keywords "concept" or "requires" is unaffected. See also my <a href="http://www.research.att.com/~bs/C++0xFAQ.html">C++0x FAQ</a>. Some people even rejoice that C++0x will now be a simpler language than they had expected.
<P>

<P>
"Concepts" were to have been the central new feature in C++0x for putting the use of templates on a better theoretical basis, for firming-up the specification of the standard library, and a central part of the drive to make generic programming more accessible for mainstream use. For now, people will have to use "concepts" without direct language support as a design technique. My best scenario for the future is that we get something better than the current "concept" design into C++ in about five years. Getting that will take some serious focused work by several people (but not "design by committee").




    <h3>What Happened?</h3>
<P>

<P>
"Concepts," as developed over the last many years and accepted into the C++0x working paper in 2008, involved some technical compromises (which is natural and necessary). The experimental implementation was sufficient to test the "conceptualized" standard library, but was not production quality. The latter worried some people, but I personally considered it sufficient as a proof of concept.
<P>

<P>
My concern was with the design of "concepts" and in particular with the usability of "concepts" in the hands of "average programmers." That concern was shared by several members. The stated aim of "concepts" was to make generic programming more accessible to most programmers &#91;<a href="http://www.research.att.com/~bs/N1522-concept-criteria.pdf">BS&GDR2003</a>&#93;, but that aim seemed to me to have been seriously compromised: Rather than making generic programming more accessible, "concepts" were becoming yet another tool in the hands of experts (only). Over the last half year or so, I had been examining C++0x from a user's point of view, and I worried that even use of libraries implemented using "concepts" would put new burdens on programmers. I felt that the design of "concepts" and its use in the standard library did not adequately reflect our experience with "concepts" over the last few years.
<P>

<P>
Then, a few months ago, Alisdair Meredith (an insightful committee member from the UK) and Howard Hinnant (the head of the standard library working group) asked some good questions relating to who should directly use which parts of the "concepts" facilities and how. That led to a discussion of usability involving many people with a variety of concerns and points of view; and I eventually -- after much confused discussion -- published my conclusions &#91;<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2906.pdf">BS2009</a>&#93;.
<P>

<P>
To summarize and somewhat oversimplify, I stated that:
<P>
<ul>
<li>"Concepts" as currently defined are too hard to use and will lead to disuse of "concepts," possibly disuse of templates, and possibly to lack of adoption of C++0x.
<li>A small set of simplifications &#91;<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2906.pdf">BS2009</a>&#93; can render "concepts" good-enough-to-ship on the current schedule for C++0x or with only a minor slip.
</ul>
<P>

<P>
That's pretty strong stuff. Please remember that standards committee discussions are typically quite polite, and since we are aiming for consensus, we tend to avoid direct confrontation. Unfortunately, the resulting further (internal) discussion was massive (hundreds of more and less detailed messages) and confused. No agreement emerged on what problems (if any) needed to be addressed or how. This led me to order the alternatives for a presentation in Frankfurt:
<P>
<ul>
<li>"fix and ship"
<P>
<ul>
<li>Remaining work: remove explicit "concepts," add explicit refinement, add "concept"/type matching, handle "concept" map scope problems
<li>Risks: no implementation, complexity of description
<li>Schedule: no change or one meeting
</ul>
<P>
<li>"Yank and ship"
<P>
<ul>
<li>Remaining work: yank (core and standard library)
<li>Risks: old template problems remain, disappointment in "progressive" community ("seven year's work down the drain")
<li>Schedule: five years to "concepts" (complete redesign needed) or never
</ul>
<P>
<li>"Status quo"
<P>
<ul>
<li>Remaining work: details
<li>Risks: unacceptable programming model, complexity of description (alternative view: none)
<li>Schedule: no change
</ul>
</ul>
<P>

<P>
I and others preferred the first alternative ("fix and ship") and considered it feasible. However, a large majority of the committee disagreed and chose the second alternative ("yank and ship," renaming it "decoupling"). In my opinion, both are better than the third alternative ("status quo"). My interpretation of that vote is that given the disagreement among proponents of "concepts," the whole idea seemed controversial to some, some were already worried about the ambitious schedule for C++0x (and, unfairly  IMO, blamed "concepts"), and some were never enthusiastic about "concepts." Given that, "fixing concepts" ceased to be a realistic option. Essentially, all expressed support for "concepts," just "later" and "eventually." I warned that a long delay was inevitable if we removed "concepts" now because in the absence of schedule pressures, essentially all design decisions will be re-evaluated.
<P>

<P>
Surprisingly (maybe), there were no technical presentations and discussions about "concepts" in Frankfurt. The discussion focused on timing and my impression is that the vote was decided primarily on timing concerns.
<P>

<P>
Please don't condemn the committee for being cautious. This was not a "Bjarne vs. the committee fight," but a discussion trying to balance a multitude of serious concerns. I and others are disappointed that we didn't take the opportunity of "fix and ship," but C++ is not an experimental academic language. Unless members are convinced that the risks for doing harm to production code are very low, they must oppose. Collectively, the committee is responsible for billions of lines of code. For example, lack of adoption of C++0x or long-term continued use of unconstrained templates in the presence of "concepts" would lead to a split of the C++ community into separate sub-communities. Thus, a poor "concept" design could be worse than no "concepts." Given the choice between the two, I too voted for removal. I prefer a setback to a likely disaster.



    <h3>Technical Issues</h3>
<P>

<P>
The unresolved issue about "concepts" focused on the distinction between explicit and implicit "concept" maps (see &#91;<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2906.pdf">BS2009</a>&#93;):
<P>
<ol>
<li>Should a type that meets the requirements of a "concept" automatically be accepted where the "concept" is required (e.g. should a type <b>X</b> that provides +, -, *, and / with suitable parameters automatically match a "concept" <b>C</b> that requires the usual arithmetic operations with suitable parameters) or should an additional explicit statement (a "concept" map from <b>X</b> to <b>C</b>) that a match is intentional be required?  (My answer: Use automatic match in almost all cases).
<li>Should there be a choice between <i>automatic</i> and <i>explicit</i> "concepts" and should a designer of a "concept" be able to force every user to follow his choice? (My answer:  All "concepts" should be automatic).
<li>Should a type <b>X</b> that provides a member operation <b>X::begin()</b> be considered a match for a "concept" <b>C&lt;T&gt;</b> that requires a function <b>begin(T)</b> or should a user supply a "concept" map from <b>T</b> to <b>C</b>? An example is <b>std::vector</b> and <b>std::Range</b>. (My answer: It should match).
</ol>
<P>

<P>
The answers "status quo before Frankfurt" all differ from my suggestions. Obviously, I have had to simplify my explanation here and omit most details and most rationale.
<P>

<P>
I cannot reenact the whole technical discussion here, but this is my conclusion: In the "status quo" design, "concept" maps are used for two things:
<P>
<ul>
<li>To map types to "concepts" by adding/mapping attributes and
<li>To assert that a type matches a "concept."
</ul>
<P>

<P>
Somehow, the latter came to be seen an essential function by some people, rather than an unfortunate rare necessity. When two "concepts" differ semantically, what is needed is not an assertion that a type meets one and not the other "concept" (this is, at best, a workaround -- an indirect and elaborate attack on the fundamental problem), but an assertion that a type has the semantics of the one and not the other "concepts" (fulfills the axiom(s) of the one and not the other "concept").
<P>

<P>
For example, the STL <b>input</b> iterator and <b>forward</b> iterator have a key semantic difference: you can traverse a sequence defined by <b>forward</b> iterators twice, but not a sequence defined by <b>input</b> iterators; e.g.,  applying a multi-pass algorithm on an input stream is not a good idea. The solution in "status quo" is to force every user to say what types match a <b>forward</b> iterator and what types match an <b>input</b> iterator. My suggested solution adds up to: If (and only if) you want to use semantics that are not common to two "concepts" and the compiler cannot deduce which "concept" is a better match for your type, you have to say which semantics your type supplies; e.g., "my type supports multi-pass semantics." One might say, "When all you have is a 'concept' map, everything looks like needing a type/'concept' assertion."
<P>

<P>
At the Frankfurt meeting, I summarized:
<P>
<ul>
<li>Why do we want "concepts"?
<P>
<ul>
<li>To make requirement on types used as template arguments explicit
<P>
<ul>
<li>Precise documentation
<li>Better error messages
<li>Overloading
</ul>
</ul>
</ul>
<P>

<P>
Different people have different views and priorities. However, at this high level, there can be confusion -- but little or no controversy. Every half-way reasonable "concept" design offers that.
<P>
<ul>
<li>What concerns do people have?
<P>
<ul>
<li>Programmability
<li>Complexity of formal specification
<li>Compile time
<li>Run time
</ul>
</ul>
<P>

<P>
My personal concerns focus on "programmability" (ease of use, generality, teachability, scalability) and the complexity of the formal specification (40 pages of standards text) is secondary. Others worry about compile time and run time. However, I think the experimental implementation (ConceptGCC &#91;<a href="http://www.research.att.com/~bs/oopsla06.pdf">Gregor2006</a>&#93;) shows that run time for constrained templates (using "concepts") can be made as good as or better than current unconstrained templates. ConceptGCC is indeed very slow, but I don't consider that fundamental. When it comes to validating an idea, we hit the traditional dilemma. With only minor oversimplification, the horns of the dilemma are:
<P>
<ul>
<li>"Don't standardize without commercial implementation"
<li>"Major implementers do not implement without a standard"
</ul>
<P>

<P>
Somehow, a detailed design and an experimental implementation have to become the basis for a compromise.
<P>

<P>
My principles for "concepts" are:
<P>
<ul>
<li>Duck typing
<P>
<ul>
<li>The key to the success of templates for GP (compared to OO with interfaces and more)
</ul>
<P>
<li>Substitutability
<P>
<ul>
<li>Never call a function with a stronger precondition than is "guaranteed"
</ul>
<P>
<li>"Accidental match" is a minor problem
<P>
<ul>
<li>Not in the top 100 problems
</ul>
</ul>
<P>

<P>
My "minimal fixes" to "concepts" as present in the pre-Frankfurt working paper were:
<P>
<ul>
<li>"Concepts" are implicit/auto
<P>
<ul>
<li>To make duck typing the rule
</ul>
<P>
<li>Explicit refinement
<P>
<ul>
<li>To handle substitutability problems
</ul>
<P>
<li>General scoping of "concept" maps
<P>
<ul>
<li>To minimize "implementation leakage"
</ul>
<P>
<li>Simple type/"concept" matching
<P>
<ul>
<li>To make vector a range without redundant "concept" map
</ul>
</ul>
<P>

<P>
For details, see &#91;<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2906.pdf">BS2009</a>&#93;.
<P>
<h3>No C++0x, Long Live C++1x</h3>
<P>

<P>
Even after cutting "concepts," the next C++ standard may be delayed. Sadly, there will be no C++0x (unless you count the minor corrections in C++03). We must wait for C++1x, and hope that 'x' will be a low digit. There is hope because C++1x is now feature complete (excepting the possibility of some national standards bodies effectively insisting on some feature present in the formal proposal for the standard). "All" that is left is the massive work of resolving outstanding technical issues and comments. 
<P>

<P>
A list of features and some discussion can be found on my <a href="http://www.research.att.com/~bs/C++0xFAQ.html">C++0x FAQ</a>. Here is a subset:
<P>
<ul>
<li><a href="http://www.research.att.com/%7Ebs/C++0xFAQ.html#atomics">atomic operations</a> 
<li><a href="http://www.research.att.com/%7Ebs/C++0xFAQ.html#auto">auto (type deduction from initializer) </a> 
<li><a href="http://www.research.att.com/%7Ebs/C++0xFAQ.html#C99">C99 features </a> 
<li><a href="http://www.research.att.com/%7Ebs/C++0xFAQ.html#enum">enum class (scoped and strongly typed enums) </a> 
<li><a href="http://www.research.att.com/%7Ebs/C++0xFAQ.html#constexpr">constant expressions (generalized and guaranteed; <b>constexpr</b>) </a> 
<li><a href="http://www.research.att.com/%7Ebs/C++0xFAQ.html#default">defaulted and deleted functions (control of defaults) </a> 
<li><a href="http://www.research.att.com/%7Ebs/C++0xFAQ.html#delegating-ctor">delegating constructors </a> 
<li><a href="http://www.research.att.com/%7Ebs/C++0xFAQ.html#member-init">in-class member initializers </a> 
<li><a href="http://www.research.att.com/%7Ebs/C++0xFAQ.html#inheriting">inherited constructors </a> 
<li><a href="http://www.research.att.com/%7Ebs/C++0xFAQ.html#init-list">initializer lists (uniform and general initialization) </a> 
<li><a href="http://www.research.att.com/%7Ebs/C++0xFAQ.html#lambda">lambdas </a> 
<li><a href="http://www.research.att.com/%7Ebs/C++0xFAQ.html#XXX">memory model </a> 
<li><a href="http://www.research.att.com/%7Ebs/C++0xFAQ.html#rval">move semantics; see rvalue references </a> 
<li><a href="http://www.research.att.com/%7Ebs/C++0xFAQ.html#nullptr">null pointer (<b>nullptr</b>)</a>  
<li><a href="http://www.research.att.com/%7Ebs/C++0xFAQ.html#for">range for statement </a> 
<li><a href="http://www.research.att.com/%7Ebs/C++0xFAQ.html#raw-strings">raw string literals </a> 
<li><a href="http://www.research.att.com/%7Ebs/C++0xFAQ.html#template-alias">template alias </a> 
<li><a href="http://www.research.att.com/%7Ebs/C++0xFAQ.html#thread-local">thread-local storage </a> (<b>thread_local</b>) </a> 
<li><a href="http://www.research.att.com/%7Ebs/C++0xFAQ.html#unicode">unicode characters </a> 
<li><a href="http://www.research.att.com/%7Ebs/C++0xFAQ.html#uniform-init">Uniform initialization </a> syntax and semantics </a> 
<li><a href="http://www.research.att.com/%7Ebs/C++0xFAQ.html#UD-literals">user-defined literals </a> 
<li><a href="http://www.research.att.com/%7Ebs/C++0xFAQ.html#variadic-templates">variadic templates </a>
</ul>
<P>

<P>
and libraries:
<P>
<li>Improvements to <a href="http://www.research.att.com/%7Ebs/C++0xFAQ.html#XXX">algorithms </a>
<li><a href="http://www.research.att.com/%7Ebs/C++0xFAQ.html#std-array array</a> 
<li> Improvements to <a href="http://www.research.att.com/%7Ebs/C++0xFAQ.html#XXX">containers</a>
<li><a href="http://www.research.att.com/%7Ebs/C++0xFAQ.html#std-duration">duration and time_point</a> 
<li><a href="http://www.research.att.com/%7Ebs/C++0xFAQ.html#std-function">function and bind</a> 
<li><a href="http://www.research.att.com/~bs/C++0xFAQ.html#std-forward_list">forward_list a singly-liked list </a>
<li><a href="http://www.research.att.com/%7Ebs/C++0xFAQ.html#std-future">future and promise</a> 
<li><a href="http://www.research.att.com/%7Ebs/C++0xFAQ.html#gc-abi">garbage collection ABI</a> 
<li><a href="http://www.research.att.com/~bs/C++0xFAQ.html#std-unordered">hash_tables</a>; see <b>unordered_map </b>
<li><a href="http://www.research.att.com/~bs/C++0xFAQ.html#XXX">metaprogramming and type traits</a> 
<li><a href="http://www.research.att.com/%7Ebs/C++0xFAQ.html#std-random">random number generators </a>
<li><a href="http://www.research.att.com/~bs/C++0xFAQ.html#std-regex"> regex a regular expression library </a>
<li><a href="http://www.research.att.com/%7Ebs/C++0xFAQ.html#XXX">scoped allocators </a>
<li><a href="http://www.research.att.com/%7Ebs/C++0xFAQ.html#std-unique_ptr">smart pointers</a>; see <b>shared_ptr</b>, <b>weak_ptr</b>, and <b>unique_ptr</b> </a>
<li><a href="http://www.research.att.com/%7Ebs/C++0xFAQ.html#std-thread">threads</a> 
<li><a href="http://www.research.att.com/%7Ebs/C++0xFAQ.html#std-atomics">atomic operations </a>
<li><a href="http://www.research.att.com/~bs/C++0xFAQ.html#std-tuple">tuple </a>
</ul>
<P>

<P>
Even without "concepts," C++1x will be a massive improvement on C++98, especially when you consider that these features (and more) are designed to interoperate for maximum expressiveness and flexibility. I hope we will see "concepts" in a revision of C++ in maybe five years. Maybe we could call that C++1y or even "C++y!".
<P>

<P>

