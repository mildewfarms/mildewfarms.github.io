<P>
<html>
<head>
<title> A Build System for Complex Projects: Part 3 </title>
<link rel="Stylesheet" rev="Stylesheet" href="../../../../forms/Layout.css" type="text/css">
<link rel="Stylesheet" rev="Stylesheet" href="../../../../forms/FontStyles.css" type="text/css">
<link rel="Stylesheet" rev="Stylesheet" href="../../../../forms/newarticle.css" type="text/css">
<script src="../../../../forms/popwindow.js"></script>
</head>

<body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000">
<!--Copyright &#169; Dr. Dobb's Journal-->
<p><i>Dr. Dobb's Digest</i> October 2009</p>

<h1> A Build System for Complex Projects: Part 3</h1>
<h2>Generating a full-fledged NetBeans system for a non-trivial system involves multiple projects -- and more </h2>
<P>
<h3> By Gigi Sayfan</h3>
<P>


<P>
<i>Gigi Sayfan specializes in cross-platform object-oriented programming in C/C++/ C#/Python/Java with emphasis on large-scale distributed systems. He is currently trying to build intelligent machines inspired by the brain at Numenta (www.numenta.com).</i>
<hr>
<P>

<P>
<a href="0908gs01.html">A Build System for Complex Projects: Part 1</a><br>
<a href="0909gs01.html ">A Build System for Complex Projects: Part 2</a><br>
<a href="0910gs01.html">A Build System for Complex Projects: Part 3</a><br>
<a href="0911gs01.html">A Build System for Complex Projects: Part 4</a><br>
<a href="0912gs01.html">A Build System for Complex Projects: Part 5</a>
<P>

<P>

<hr>
<P>

This is the third article in a series of articles that explore an innovative build system for complicated projects. <a href="http://www.ddj.com/architect/218400678">Part 1</a> and <a href="http://www.ddj.com/architect/219000123">Part 2</a> discussed build systems in general and the internals of the ideal build system that can integrate with existing build systems. This article will explain in detail how the ibs can generate build files for NetBeans 6.x, which is a fantastic free cross-platform IDE that supports multiple programming languages. 
<P>

<P>
To recap: ibs is an invisible build system that doesn't require any build files. It relies on a regular directory and conventions to infer build rules and it detects dependencies automatically. It generates build files for other IDEs or build systems like Makefiles, Visual Studio solutions, or NetBeans projects. It is focused on C/C++ projects, but can be extended to additional languages and other projects types.  
<P>
<h3>Generating a NetBeans Build System</h3>
<P>

<P>
Back in the Hello world project (Enterprise Platinum Edition!!!) trenches Bob and the other developers picked <a href="http://www.netbeans.org">NetBeans</a> as their primary Mac and Linux IDE. NetBeans started as a Java IDE, but grew in leaps and bounds to become a component-based platform for application development in addition to an IDE that supports all the common programming languages in wide use today. The latest version is NetBeans 6.7.1 and it  supports C/C++ development very well and even Python via a special early access.
<P>

<P>
The task facing Bob is to figure out the structure of the NetBeans build files for C/C++ and implement the build system specific parts (the helper and the project templates) to embrace NetBeans into the ibs.
<P>

<P>
Bob did some reading and poking around and discovered that NetBeans itself is a Makefile-based (build system generator. The way it works is that each project's directory has a common Makefile that includes a bunch of auto-generated sub-makefiles. The NetBeans user interface allows you to add files to every project and set dependencies between projects. All this information is stored in several files that NetBeans uses to generate the proper sub-makefiles. Figure 1 shows the NetBeans IDE with the various Hello World projects.
<P>
<div>
<img src="0910gs01f1.gif"> 
<div class="caption">
<b>Figure 1</b>
</div>
</div>
<P>
<h3>The NetBeans Build System Anatomy</h3>
<P>

<P>
Let's take a look and see what all these files are about. As a running example Bob suggests the 'hello' project. This is a static library that contains two files: hello.cpp and hello.hpp. If you are unfamiliar with make-based build systems, you may want to take a small detour and read about it <a href="http://en.wikipedia.org/wiki/Make_(software)">here</a>.
<P>

<P>
<b>The project Makefile</b>
<P>

<P>
In the 'hello' directory there is the common Makefile. This file is the same for every project (on a given platform). It sets some environment variables and contains a bunch of make targets and most importantly includes the project implementation makefile (generated based on the actual content of the project). Every target (a step in the build process) has an empty pre and post targets that allow you to customize the build process by executing actions before and/or after each target. The original file has elaborate comments that explain exactly what targets are available and how you can override them. Here is an edited version without the comments and some of the targets of the Mac OS X Makefile:
<P>
<pre  class="code">
<P>
# Environment 
MKDIR=mkdir
CP=cp
CCADMIN=CCadmin
RANLIB=ranlib
<P>
# clean
clean: .clean-pre .clean-impl .clean-post
<P>
.clean-pre:
# Add your pre 'clean' code here...
<P>
.clean-post:
# Add your post 'clean' code here...
<P>

# all
all: .all-pre .all-impl .all-post
<P>
.all-pre:
# Add your pre 'all' code here...
<P>
.all-post:
# Add your post 'all' code here...
<P>

# include project implementation makefile
include nbproject/Makefile-impl.mk

</pre>
<P>

<P>
<b>nbproject</b>
<P>

<P>
The Makefile resides in the project's directory. All the other build files reside in a sub directory called nbproject. There is nothing special about it. It is just convenient to have all the build files in their own directory and not cluttering the project directory. The Makefile is the exception due to limitations of the make program.  
<P>

<P>
<b>Generated make files</b>
<P>

<P>
NetBeans generates three "sub" make files that are included by the main project Makefile: Makefile-impl.mk, Makefile-Debug.mk and Makefile-Release.mk. Makefile-impl.mk is included directly by the main Makefile and it invokes either Makefile-Debug.mk or Makefile-Release.mk depending on the current active configuration, which is controlled by the <b>$CONF</b> environment variable. In the NetBeans IDE you may select what configuration is active.You may also create your own configurations and they will be available for activation just like the built-in Debug and Release configurations with their own Makefile-<i>your configuration</i>.mk file. Here is the Makefile-impl.mk file of the testPunctuator project:
<P>
<pre  class="code">
<P>
# 
# Generated Makefile - do not edit! 
# 
# Edit the Makefile in the project folder instead (../Makefile). Each target
# has a pre- and a post- target defined where you can add customization code.
#
# This makefile implements macros and targets common to all configurations.
#
# NOCDDL
<P>
# Building and Cleaning subprojects are done by default, but can be controlled with the SUB
# macro. If SUB=no, subprojects will not be built or cleaned. The following macro
# statements set BUILD_SUB-CONF and CLEAN_SUB-CONF to .build-reqprojects-conf
# and .clean-reqprojects-conf unless SUB has the value 'no'
SUB_no=NO
SUBPROJECTS=${SUB_${SUB}}
BUILD_SUBPROJECTS_=.build-subprojects
BUILD_SUBPROJECTS_NO=
BUILD_SUBPROJECTS=${BUILD_SUBPROJECTS_${SUBPROJECTS}}
CLEAN_SUBPROJECTS_=.clean-subprojects
CLEAN_SUBPROJECTS_NO=
CLEAN_SUBPROJECTS=${CLEAN_SUBPROJECTS_${SUBPROJECTS}}
<P>
# Project Name
PROJECTNAME=testPunctuator
<P>
# Active Configuration
DEFAULTCONF=Debug
CONF=${DEFAULTCONF}
<P>
# All Configurations
ALLCONFS=Debug Release 
<P>
# build
.build-impl: .validate-impl 
  @#echo "=&gt; Running $@... Configuration=$(CONF)"
  ${MAKE} -f nbproject/Makefile-${CONF}.mk SUBPROJECTS=${SUBPROJECTS} .build-conf
<P>

# clean
.clean-impl: .validate-impl
  @#echo "=&gt; Running $@... Configuration=$(CONF)"
  ${MAKE} -f nbproject/Makefile-${CONF}.mk SUBPROJECTS=${SUBPROJECTS} .clean-conf
<P>

# clobber 
.clobber-impl:
  @#echo "=&gt; Running $@..."
  for CONF in ${ALLCONFS}; \
  do \
      ${MAKE} -f nbproject/Makefile-$${CONF}.mk SUBPROJECTS=${SUBPROJECTS} .clean-conf; \
  done
<P>
# all 
.all-impl:
  @#echo "=&gt; Running $@..."
  for CONF in ${ALLCONFS}; \
  do \
      ${MAKE} -f nbproject/Makefile-$${CONF}.mk SUBPROJECTS=${SUBPROJECTS} .build-conf; \
  done
<P>

# configuration validation
.validate-impl:
  @if &#91; ! -f nbproject/Makefile-${CONF}.mk &#93;; \
  then \
      echo ""; \
      echo "Error: can not find the makefile for configuration '${CONF}' in project ${PROJECTNAME}"; \
      echo "See 'make help' for details."; \
      echo "Current directory: " `pwd`; \
      echo ""; \
  fi
  @if &#91; ! -f nbproject/Makefile-${CONF}.mk &#93;; \
  then \
      exit 1; \
  fi
<P>
# help
.help-impl:
  @echo "This makefile supports the following configurations:"
  @echo "    ${ALLCONFS}"
  @echo ""
  @echo "and the following targets:"
  @echo "    build  (default target)"
  @echo "    clean"
  @echo "    clobber"
  @echo "    all"
  @echo "    help"
  @echo ""
  @echo "Makefile Usage:"
  @echo "    make &#91;CONF=&lt;CONFIGURATION&gt;&#93; &#91;SUB=no&#93; build"
  @echo "    make &#91;CONF=&gltCONFIGURATION&gt;&#93; &#91;SUB=no&#93; clean"
  @echo "    make &#91;SUB=no&#93; clobber"
  @echo "    make &#91;SUB=no&#93; all"
  @echo "    make help"
  @echo ""
  @echo "Target 'build' will build a specific configuration and, unless 'SUB=no',"
  @echo "    also build subprojects."
  @echo "Target 'clean' will clean a specific configuration and, unless 'SUB=no',"
  @echo "    also clean subprojects."
  @echo "Target 'clobber' will remove all built files from all configurations and,"
  @echo "    unless 'SUB=no', also from subprojects."
  @echo "Target 'all' will will build all configurations and, unless 'SUB=no',"
  @echo "    also build subprojects."
  @echo "Target 'help' prints this message."
  @echo ""

</pre>
<P>

<P>
The structure of this file is very uniform. Every command is implemented in the same way (except .help that just echos the help text to the screen). It always invokes eventually the configuration specific make file. Commands may operate on all configurations and on sub-projects too (on by default). For example the default .build command (if you just type 'make') is:
<P>
<pre  class="code">
<P>
# build
.build-impl: .validate-impl 
  @#echo "=&gt; Running $@... Configuration=$(CONF)"
  ${MAKE} -f nbproject/Makefile-${CONF}.mk SUBPROJECTS=${SUBPROJECTS} .build-conf

</pre>
<P>

<P>
Let me decipher this line-noise that makes sense only to make-savvy people. The name of the command is <b>.build-impl</b>. It will execute the <b>.validate-impl</b> command, skip the commented out <b>echo</b> command (if you remove the # it will print the text between the double quotes) and run 'make' again on the file nbproject/Makefile-${CONF}.mk (CONF is the active configuration, which is Debug in this case, unless you specified CONF=Release when you run 'make'). Finally it will execute the .build-conf command that is defined in the Makefile-${CONF}.mk. This command builds all the subprojects (if necessary) and finally build the project itself by invoking the C++ compiler and linker.
<P>

<P>
It sounds complicated and it is complicated. This is the cleanest make-based system I have seen with good separation of concerns, very uniform structure and great extensibility. Most make-based build systems are simply a mess. The nice thing about NetBeans is that it takes care of all the messy parts and lets you work entirely at the IDE level, but still allows you to extend the build process at the makefile-level if you need to do something special.
<P>

<P>
Let's take a look at the Makefile-Debug.mk file:
<P>
<pre  class="code">
<P>
#
# Generated Makefile - do not edit!
#
# Edit the Makefile in the project folder instead (../Makefile). Each target
# has a -pre and a -post target defined where you can add customized code.
#
# This makefile implements configuration specific macros and targets.
<P>
# Environment
MKDIR=mkdir
CP=cpj
CCADMIN=CCadmin
RANLIB=ranlib
CC=gcc
CCC=g++
CXX=g++
FC=
<P>
# Include project Makefile
include Makefile
<P>
# Object Directory
OBJECTDIR=build/Debug/GNU-MacOSX
<P>
# Object Files
OBJECTFILES= \
  ${OBJECTDIR}/main.o
<P>
# C Compiler Flags
CFLAGS=
<P>
# CC Compiler Flags
CCFLAGS=
CXXFLAGS=
<P>
# Fortran Compiler Flags
FFLAGS=
<P>
# Link Libraries and Options
LDLIBSOPTIONS=../../hw/utils/dist/Debug/GNU-MacOSX/libutils.a
<P>
# Build Targets
.build-conf: ${BUILD_SUBPROJECTS} dist/Debug/GNU-MacOSX/testpunctuator
<P>
dist/Debug/GNU-MacOSX/testpunctuator: ${BUILD_SUBPROJECTS}
<P>
dist/Debug/GNU-MacOSX/testpunctuator: ${OBJECTFILES}
  ${MKDIR} -p dist/Debug/GNU-MacOSX
  ${LINK.cc} -o dist/Debug/GNU-MacOSX/testpunctuator ${OBJECTFILES} ${LDLIBSOPTIONS}
<P>
${OBJECTDIR}/main.o: main.cpp 
  ${MKDIR} -p ${OBJECTDIR}
  $(COMPILE.cc) -g -I../.. -o ${OBJECTDIR}/main.o main.cpp
<P>
# Subprojects
.build-subprojects:
  cd ../../hw/utils && ${MAKE}  -f Makefile CONF=Debug
<P>
# Clean Targets
.clean-conf: ${CLEAN_SUBPROJECTS}
  ${RM} -r build/Debug
  ${RM} dist/Debug/GNU-MacOSX/testpunctuator
<P>
# Subprojects
.clean-subprojects:
  cd ../../hw/utils && ${MAKE}  -f Makefile CONF=Debug clean

</pre>
<P>

<P>
This file includes the project's Makefile (which includes the Makefile-impl.mk), defines a bunch of variables that point to different tools like C and C++ compilers and it also defines the dependencies of the project (in this case just the hw/utils sub-project). Note the <b>.build-conf</b> command that I mentioned earlier when I discussed the <b>.build-impl</b> command from Makefile-impl.mk. So, there is a lot of interplay between the various make files. This is done in the interest of separating fixed logic like command invocation from very dynamic parts like the files that are contained in a project and its dependencies and also providing clear extension points (the.pre and .post commands in the main Makefile). The bottom line is that most developers don't even need to know that there is a make-based build system underneath and can just stay at the IDE level. Build administrators can automate the build process using this clean and standard make interface and people with special needs can customize the build process very elegantly using the extension points provided by .pre and .post targets, as well as add new targets.


    

    <h3>Project Metadata Files</h3>
<P>

<P>
Make files are okay (I wouldn't say great) for running a build, but they are not very easy to parse and modify. NetBeans uses two XML files to maintain the project information and dynamically generates the make files from these files.
<P>

<P>
<b>configurations.xml</b>
<P>

<P>
This is the file. It contains most of the project information used for generating the make files as well as some GUI information such as the logical folders displayed in the IDE for each project and what files reside in them. It is a typical XML file. The root element is called <b>configurationDescriptor</b> and it contains a <b>logicalFolder</b> element called "root that contains nested <b>logicalFolder</b> elements for "HeaderFiles", "ResourceFiles", "SourceFiles" and "ExternalFiles". Each logicalFolder element may contain <b>itemPath</b> elements for the files in this folder. Here is the logical folders of the <b>testPunctuator</b> project:
<P>
<pre  class="code">
<P>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
  &lt;configurationDescriptor version="45"&gt;
    &lt;logicalFolder name="root" displayName="root" projectFiles="true"&gt;
    &lt;logicalFolder name="HeaderFiles"
             displayName="Header Files"
             projectFiles="true"&gt;
    &lt;/logicalFolder&gt;
    &lt;logicalFolder name="ResourceFiles"
             displayName="Resource Files"
             projectFiles="true"&gt;
    &lt;/logicalFolder&gt;
    &lt;logicalFolder name="SourceFiles"
             displayName="Source Files"
             projectFiles="true"&gt;
      &lt;itemPath&gt;main.cpp&lt;/itemPath&gt;
    &lt;/logicalFolder&gt;
    &lt;logicalFolder name="ExternalFiles"
             displayName="Important Files"
             projectFiles="false"&gt;
      &lt;itemPath&gt;Makefile&lt;/itemPath&gt;
    &lt;/logicalFolder&gt;
    &lt;/logicalFolder&gt;

</pre>
<P>

<P>
The configurations.xml file also contains elements for the encoding the make file for the project (in case you want to change its name for some reason):
<P>
<pre  class="code">
<P>
  &lt;sourceEncoding&gt;UTF-8&lt;/sourceEncoding&gt;
  &lt;projectmakefile&gt;Makefile&lt;/projectmakefile&gt;

</pre>
<P>

<P>
Then comes the all important "confs" elements that contains "conf" elements for each configuration. Each "conf" elements contains a "toolset" element and a "compileType" elements that contains various tools. Each tool has its own set of elements and attribute that translate directly to make file tool settings:
<P>
<pre  class="code">
<P>
&lt;confs&gt;
    &lt;conf name="Debug" type="1"&gt;
      &lt;toolsSet&gt;
        &lt;compilerSet&gt;GNU|GNU&lt;/compilerSet&gt;
        &lt;platform&gt;4&lt;/platform&gt;
      &lt;/toolsSet&gt;
      &lt;compileType&gt;
        &lt;ccCompilerTool&gt;
          &lt;includeDirectories&gt;
            &lt;directoryPath&gt;../..&lt;/directoryPath&gt;
          &lt;/includeDirectories&gt;
        &lt;/ccCompilerTool&gt;
        &lt;linkerTool&gt;
          &lt;linkerLibItems&gt;
            &lt;linkerLibProjectItem&gt;
              &lt;makeArtifact PL="../../hw/utils"
                            CT="3"
                            CN="Debug"
                            AC="true"
                            BL="true"
                            WD="../../hw/utils"
                            BC="${MAKE}  -f Makefile CONF=Debug"
                            CC="${MAKE}  -f Makefile CONF=Debug clean"
                            OP="dist/Debug/GNU-MacOSX/libutils.a"&gt;
              &lt;/makeArtifact&gt;
            &lt;/linkerLibProjectItem&gt;
          &lt;/linkerLibItems&gt;
        &lt;/linkerTool&gt;
      &lt;/compileType&gt;
      &lt;item path="main.cpp"&gt;
        &lt;itemTool&gt;1&lt;/itemTool&gt;
      &lt;/item&gt;
    &lt;/conf&gt;
    &lt;conf name="Release" type="1"&gt;
      &lt;toolsSet&gt;
        &lt;compilerSet&gt;GNU|GNU&lt;/compilerSet&gt;
        &lt;platform&gt;4&lt;/platform&gt;
      &lt;/toolsSet&gt;
      &lt;compileType&gt;
        &lt;cCompilerTool&gt;
          &lt;developmentMode&gt;5&lt;/developmentMode&gt;
        &lt;/cCompilerTool&gt;
        &lt;ccCompilerTool&gt;
          &lt;developmentMode&gt;5&lt;/developmentMode&gt;
          &lt;includeDirectories&gt;
            &lt;directoryPath&gt;../..&lt;/directoryPath&gt;
          &lt;/includeDirectories&gt;
        &lt;/ccCompilerTool&gt;
        &lt;fortranCompilerTool&gt;
          &lt;developmentMode&gt;5&lt;/developmentMode&gt;
        &lt;/fortranCompilerTool&gt;
        &lt;linkerTool&gt;
          &lt;linkerLibItems&gt;
            &lt;linkerLibProjectItem&gt;
              &lt;makeArtifact PL="../../hw/utils"
                            CT="3"
                            CN="Release"
                            AC="false"
                            BL="true"
                            WD="../../hw/utils"
                            BC="${MAKE}  -f Makefile CONF=Release"
                            CC="${MAKE}  -f Makefile CONF=Release clean"
                            OP="dist/Release/GNU-MacOSX/libutils.a"&gt;
              &lt;/makeArtifact&gt;
            &lt;/linkerLibProjectItem&gt;
          &lt;/linkerLibItems&gt;
        &lt;/linkerTool&gt;
      &lt;/compileType&gt;
      &lt;item path="main.cpp"&gt;
        &lt;itemTool&gt;1&lt;/itemTool&gt;
      &lt;/item&gt;
    &lt;/conf&gt;
  &lt;/confs&gt;

</pre>
<P>

<P>
There is one "conf" element for each configuration (in this case Debug and Release).
<P>

<P>
<b>project.xml</b>
<P>

<P>
The project.xml file holds additional information like the project type, project dependencies and the file extensions of different file types. I'm not sure why this information should go in a separate file, but that's how it is. Here is the project.xml file of the hello_world application project itself:
<P>
<pre  class="code">
<P>
  &lt;?xml version="1.0" encoding="UTF-8"?&gt;
  &lt;project xmlns="http://www.netbeans.org/ns/project/1"&gt;
    &lt;type&gt;org.netbeans.modules.cnd.makeproject&lt;/type&gt;
    &lt;configuration&gt;
      &lt;data xmlns="http://www.netbeans.org/ns/make-project/1"&gt;
        &lt;name&gt;hello_world&lt;/name&gt;
        &lt;make-project-type&gt;0&lt;/make-project-type&gt;
        &lt;make-dep-projects&gt;
          &lt;make-dep-project&gt;../../hw/hello&lt;/make-dep-project&gt;
          &lt;make-dep-project&gt;../../hw/utils&lt;/make-dep-project&gt;
          &lt;make-dep-project&gt;../../hw/world&lt;/make-dep-project&gt;
        &lt;/make-dep-projects&gt;
        &lt;c-extensions/&gt;
        &lt;cpp-extensions&gt;cpp&lt;/cpp-extensions&gt;
        &lt;header-extensions&gt;hpp&lt;/header-extensions&gt;
      &lt;/data&gt;
    &lt;/configuration&gt;
  &lt;/project&gt;

</pre>
<P>
<h3>Project Group</h3>
<P>

<P>
In addition to the individual project files NetBeans support a higher level of organization called a project group. A project group is simply a collection of projects that can be loaded together into the NetBeans IDE. The hello world system is also a project group that contains many projects. The ibs can generate such a project group on behalf of the user and update it automatically when new projects are added or removed.
<P>

<P>
NetBeans keeps a lot of information in the user's home directory in a hidden directory called ".netbeans". The project groups are stored in the following directory: 
<P>
<pre  class="code">
<P>
~/.netbeans/6.7/config/Preferences/org/netbeans/modules/projectui/groups

</pre>
<P>

<P>
Note the 6.7 version number following the .netbeans directory. You may have multiple versions of NetBeans installed on your machine and their preferences are stored separately. Each project group has a file under the projectui sub-directory called <b>&lt;project group name&gt;.properties</b>. There are three kinds of projects groups: free group, master + dependencies and folder group (all projects under a root directory). The hello_world project group is a folder group. Here is the hello_world.properties file:
<P>
<pre  class="code">
<P>
name=hello_world
kind=directory
path=file\:/Users/gsayfan/Documents/Invisible.Build.System/src

</pre>
<P>

<P>
Pretty simple, really. In addition there is another important file called: 
<P>
<pre  class="code">
<P>
~/.netbeans/6.7/config/Preferences/org/netbeans/modules/projectui/groups.properties. 

</pre>
<P>

<P>
This file determines the active project group if there are multiple project groups. Its format is very simple too and to make a group active you just need to have this line in the file:
<P>
<pre  class="code">
<P>
active=&lt;project group name&gt;

</pre>
<P>

<P>
In case of the hello_world project group it is:
<P>
<pre  class="code">
<P>
active=hello_world

</pre>




    <h3>The NetBeans Helper</h3>
<P>

<P>
The NetBeans Helper class is responsible for implementing all the code that is NetBeans-specific. The generic build_system_generator.py script is using this helper to generate all the NetBeans project files (inside the nbproject directory) for each project and a project group that includes all the generated project. Let's take a closer look at this class. The first thing it does is import some useful system modules and then import the BaseHelper and Template classes from the build_system_generator module (as well as the 'title' function for debugging purposes):
<P>
<pre  class="code">
<P>
#!/usr/bin/env python
import os, sys, string
from pprint import pprint as pp

sys.path.insert(0, os.path.join(os.path.abspath(os.path.dirname(__file__)), '../'))
from build_system_generator import (BaseHelper,
                                    Template,
                                    title)
</pre>
<P>

<P>
Then the <b>Helper</b>class is defined. This is the class that the build system generator module is using to customize the build system generation for each specific target (NetBeans 6.x in this case). The <b>__init__()</b> method accepts the <b>templates_dir</b>, which is the path to the root of the templates directory used to generate all the build files. It also initializes the separator ('/') and line separator ('\n') to Unix values to make the generated files fit well in their intended environment. The <b>skip_dir</b> is used to tell the recursive drill-down code that looks for projects in sub-directories to ignore directories called 'nbproject' (which is the special sub-directory used by NetBeans to store the build files). The other methods this class implements are: <b>get_templates()</b>, <b>prepare_substitution_dict()</b>, and <b>generate_workspace_files()</b>.
<P>
<pre  class="code">
<P>
class Helper(BaseHelper):
  """NetBeans6 helper
  """
  def __init__(self, templates_dir):
    BaseHelper.__init__(self, templates_dir)
    self.sep = '/'
    self.linesep = '\n'
    self.skip_dir = 'nbproject'

  def get_templates(self, template_type):
    ...
    
  def prepare_substitution_dict(self, ...):
    ...
    def generate_workspace_files(self, name, root_path, projects):
    ...
</pre>
<P>

<P>
<b>get_templates()</b>
<P>

<P>
The <b>get_templates()</b>method is pretty simple. For each build file there is a corresponding template file. These template files are just skeleton of real build files, with some place holders. You will see all the template files soon enough. The <b>get_templates()</b> method just iterates over all the template files (located in the nbproject) and adds a template for the Makefile in the project directory itself. For each such  build a file a <b>Template</b> object is generated. Finally the list of <b>Template</b> objects is returned.
<P>
<pre  class="code">
<P>
  def get_templates(self, template_type):
    result = &#91;Template(os.path.join(self.templates_dir,
                                    template_type,
                                    'Makefile'),
                                    'Makefile',
                                    template_type)&#93;
<P>
    nb_project = os.path.join(self.templates_dir, template_type, 'nbproject')
    assert os.path.isdir(nb_project)
    for f in os.listdir(nb_project):
      project_file_template = os.path.join(nb_project, f)
      if not os.path.isfile(project_file_template):
        continue

      filename = os.path.join(nb_project, f)
      relative_path = '/'.join(&#91;'nbproject', f&#93;)
      result.append(Template(filename, relative_path, template_type))
    return result
</pre>
<P>

<P>
<b>prepare_substitution_dict()</b>
<P>

<P>
This method is the heart of <b>NetBeans6_Helper</b> class. It is responsible for creating a substitution dictionary that contains all the values to be substituted into the templates of each build file. This is not so trivial because some place holders are supposed to be replaced by dynamic content that is generated on the fly. In addition, as you saw earlier NetBeans has quite a few build files. The <b>prepare_substitution_dict()</b> method has several nested function to assist in prepare the substitution dictionary for each one of them. The nested functions are: 
<P>
<ul>
<li><b>prepare_makefile()</b> for generating the Makefile-Debug.mk and Makefile-Release.mk files
<li><b>prepare_configurations_xml()</b> for generating configurations.xml 
<li><b>prepare_project_properties()</b> for generating project.properties
<li><b>prepare_project_xml()</b> for generating project.xml
</ul>
<P>

<P>
The substitution dict for the project's main Makefile is empty because it is a generic file that doesn't have any place holder and the substitution dict for the Makefile-impl.mk file contains only the name of the project so no helper function is necessary. Here is the code of the method (without the nested functions). It accepts a long list of arguments that the various nested functions use to generate the proper values. The operating system and the dynamic library extension are also determined here. This method is called multiple times with different template names (each template_name corresponds to a build file) and <b>prepare_substitution_dict()</b> calls the proper nested function or generates the dict directly (for Makefile and MakeFile-Impl.mk).   
<P>
<pre  class="code">
<P>
def prepare_substitution_dict(self,
						project_name,
					project_type,
						project_file_template,
						project_dir,
						libs_dir,
						dependencies,
						source_files,
						header_files,
						platform):
if platform.startswith('darwin'):
  operating_system = 'MacOSX'
  ext = 'dylib'
elif platform.startswith('linux'):
  operating_system = 'Linux'
  ext = 'so'
<P>
temaplate_name = os.path.basename(project_file_template)
if temaplate_name ==  'Makefile':
  return {}
<P>
if temaplate_name ==  'Makefile-Debug.mk':
  return prepare_makefile('Debug', operating_system)
<P>
if temaplate_name ==  'Makefile-Release.mk':
  return prepare_makefile('Release', operating_system)
<P>
if temaplate_name == 'Makefile-impl.mk':
  return dict(Name=os.path.basename(project_dir))
<P>
if temaplate_name == 'configurations.xml':
  return prepare_configurations_xml(operating_system)
<P>
if temaplate_name == 'project.properties':
  return prepare_project_properties()
<P>
if temaplate_name == 'project.xml':
  return prepare_project_xml(dependencies)
<P>
assert False, 'Invalid project file template: ' + temaplate_name
return {}

</pre>
<P>

<P>
Now, let's examine one of nested functions. I chose the <b>prepare_makefile()</b> function because it is not trivial. The keys in its substitution dictionary are: 'ObjectFiles', 'CompileFiles',  'LinkCommand', 'LDLIBSOPTIONS', 'BuildSubprojects', 'CleanSubprojects', 'OperatingSystem' and 'DynamicLibExtension'. Some of these are simple strings like 'OperatingSystem' and 'DynamicLibExtension'. Others are much more complicated like 'CompileFiles', which is a list of compile commands where each command itself requires a template with substitution values such as 'File', 'CompileFlag', 'Platform' and 'FPIC'. The <b>link</b> command depends on the project type and <b>ldliboptions</b> depends on the platform. Here is the code:
<P>
<pre  class="code">
<P>
    def prepare_makefile(conf, operating_system):
      compile_flag = '-g' if conf == 'Debug' else '-O2'
<P>
      d = dict(Name=project_name)
      object_file_template = '	${OBJECTDIR}/%s.o \\\n'
      object_files = ''
      for f in source_files:
        f = os.path.splitext(os.path.basename(f))&#91;0&#93;
        object_files += object_file_template % f
<P>
      # Flag for dynamic libraries
      fpic = '-fPIC  ' if project_type == 'dynamic_lib' else ''
<P>
      # Get rid of last forward slash
      if len(object_files) > 2:
        object_files = object_files&#91;:-3&#93;
      d&#91;'ObjectFiles'&#93; = object_files
<P>
      compile_file_template = \
        '$${OBJECTDIR}/${File}.o: ${File}.cpp \n' + \
        '\t$${MKDIR} -p $${OBJECTDIR}\n' + \
        '\t$$(COMPILE.cc) ${CompileFlag} -I../.. ${FPIC}-o $${OBJECTDIR}/${File}.o ${File}.cpp\n\n'
<P>
      t = string.Template(compile_file_template)
      compile_files = ''
      for f in source_files:
        f = os.path.splitext(os.path.basename(f))&#91;0&#93;
        text = t.substitute(dict(File=f,
                                 CompileFlag=compile_flag,
                                 Platform=platform,
                                 FPIC=fpic))
        compile_files += text
<P>
      # Get rid of the last two \n\n.
      compile_files = compile_files&#91;:-2&#93;
      d&#91;'CompileFiles'&#93; = compile_files
<P>
      link_command = ''
      if project_type == 'dynamic_lib':
        if platform.startswith('darwin'):
          link_command = '${LINK.cc} -dynamiclib -install_name lib%s.dylib' % project_name
        else:
          assert platform.startswith('linux')
          link_command = '${LINK.c} -shared'
        d&#91;'LinkCommand'&#93; = link_command
<P>
      ldlibsoptions = ''
      if dependencies != &#91;&#93;:
        ldliboption_template = '../../hw/%s/dist/%s/GNU-%s/lib%s.a'
<P>
        ldlibsoptions = ' '.join(&#91;ldliboption_template % \
                        (dep.name, conf, operating_system, dep.name)
                        for dep in dependencies&#93;)
        if operating_system == 'Linux':
          ldlibsoptions += ' -ldl'
      d&#91;'LDLIBSOPTIONS'&#93; = ldlibsoptions
<P>
      build_subproject_template = '\tcd ../../hw/%s && ${MAKE}  -f Makefile CONF=%s'
      clean_subproject_template = build_subproject_template + ' clean'
<P>
      build_list = &#91;build_subproject_template % (dep.name, conf) for dep in dependencies&#93;
      clean_list = &#91;clean_subproject_template % (dep.name, conf) for dep in dependencies&#93;
      d&#91;'BuildSubprojects'&#93; = '\n'.join(build_list)
      d&#91;'CleanSubprojects'&#93; = '\n'.join(clean_list)
      d&#91;'OperatingSystem'&#93; = operating_system
      d&#91;'DynamicLibExtension'&#93; = ext

      return d
</pre>
<P>

<P>
Note, that there are better ways to accomplish this task. There are several third-party template languages like Genshi, Mako, Tempita and Jinja. These template engines can handle the nested templates that <b>prepare_makefile()</b> generates manually in a much more natural way. The code could have been much shorter and concise. I made a deliberate decision to use only standard Python libraries in the interest of keeping the scope of this project limited. Choosing a particular template language/engine would have made the code shorter, but required the reader to understand an additional language and might antagonize fans of other template languages.
<P>

<P>
The other <b>prepare_XXX()</b> nested functions are all very similar to <b>make_makefile()</b>  although some of them generate XML files and another one generate a properties file (INI file like).
<P>

<P>
<b>generate_workspace_files()</b>
<P>

<P>
This method is responsible for generating the project groups in the user account. The reason the method is called <b>generate_workspace_files()</b> is that the method is defined in the generic <b>Helper</b> base class and <b>NetBeans6_Helper</b> is just overriding it. So, the NetBeans-specific term "Project Group" is not used here. The code itself is pretty simple. It either creates or updates the proper .properties files that dictate the contents of the project groups as explained earlier:
<P>
<pre  class="code">
<P>
  def generate_workspace_files(self, name, root_path, projects):
    """Generate a NetBeans project group for all the generated projects
<P>
    """
    base_path = \
      '~/.netbeans/6.7/config/Preferences/org/netbeans/modules/projectui'
    base_path = os.path.expanduser(base_path)
<P>
    if not os.path.exists(base_path):
      os.makedirs(base_path)
<P>
    # Create a project group
    groups_path = os.path.join(base_path, 'groups')
    if not os.path.exists(groups_path):
      os.makedirs(groups_path)
<P>
    text = """\
name=%s
kind=directory
path=file\:%s"""
    group_filename = os.path.join(groups_path, name + '.properties')
    open(group_filename, 'w').write(text % (name, root_path))
<P>
    # Make it the active project
    text = 'active=' + name
    open(os.path.join(base_path, 'groups.properties'), 'w').write(text)

</pre>
<P>
<h3>The NetBeans Project Templates</h3>
<P>

<P>
The substitution dictionaries are very important of course, but they can't do much by themselves. Each build file is generated by substituting the values from the proper dictionary into the proper template file.
<P>

<P>
As you recall NetBeans can build three types of projects: static library, dynamic library and a program. for each one of them there are templates of all the build files. A few templates are the same for some or all project types, so an identical copy is kept for each one. The templates are organized in the following file system structure:
<P>
<pre  class="code">
<P>
project_templates
  NetBeans_6
    dynamic_lib
      Makefile
      nbproject
        configurations.xml
        Makefile-Debug.mk
        Makefile-Impl.mk
        Makefile-Release.mk
        project.properties
        project.xml
    program
      Makefile
      nbproject
        ...
    static_lib
      Makefile
      nbproject
        ...

</pre>
<P>

<P>
This regular structure mimics the structure of the build files inside a project directory and allows the generic part of ibs to apply the substitution dicts to the templates blindly and end up with the correct build file in the correct place. Note, the project.properties file that wasn't mentioned earlier. This is an empty file that doesn't seem to have a role in C++ projects, but I keep it there to be consistent with NetBeans.
<P>

<P>
To create the template files I simply took the various NetBeans build files and replaced anything that was project-specific (like the source files or list of dependencies) with a place holder.Let's examine a couple of template files. Here is the main part of the Makefile-Debug.mk of the 'program' project type:
<P>
<pre  class="code">
<P>
# Link Libraries and Options
LDLIBSOPTIONS=${LDLIBSOPTIONS}
<P>
# Build Targets
.build-conf: $${BUILD_SUBPROJECTS} dist/Debug/GNU-${OperatingSystem}/${name}
<P>
dist/Debug/GNU-${OperatingSystem}/${name}: $${BUILD_SUBPROJECTS}
<P>
dist/Debug/GNU-${OperatingSystem}/${name}: $${OBJECTFILES}
	$${MKDIR} -p dist/Debug/GNU-${OperatingSystem}
	$${LINK.cc} -o dist/Debug/GNU-${OperatingSystem}/${name} $${OBJECTFILES} $${LDLIBSOPTIONS}
<P>
${CompileFiles}
<P>
# Subprojects
.build-subprojects:
${BuildSubprojects}
<P>
# Clean Targets
.clean-conf: $${CLEAN_SUBPROJECTS}
	$${RM} -r build/Debug
	$${RM} dist/Debug/GNU-${OperatingSystem}/${name}
<P>
# Subprojects
.clean-subprojects:
${CleanSubprojects}

</pre>
<P>

<P>
The placeholder are expressions of the form <b>${Place holder}</b>. This is the format used by the <b>string.Template</b> class. Unfortunately, this convention is used by make files a lot too for environment variable, defined symbols and make variables. So, when a <b>$</b> sign is part of the make file it is escaped by additional <b>$</b> sign. For example, <b>$${MKDIR}</b> will not be treated as a place holder by the ibs.
<P>

<P>
Here is a simpler template of the project.xml file. It is just a bunch of XML with two placeholders for the name of the project and its dependencies:
<P>
<pre  class="code"
<P>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;project xmlns="http://www.netbeans.org/ns/project/1"&gt;
    &lt;type&gt;org.netbeans.modules.cnd.makeproject&lt;/type&gt;
    &lt;configuration&gt;
        &lt;data xmlns="http://www.netbeans.org/ns/make-project/1"&gt;
            &lt;name&gt;${Name}&lt;/name&gt;
            &lt;make-project-type&gt;0&lt;/make-project-type&gt;
${MakeDepProjects}        &lt;/data&gt;
    &lt;/configuration&gt;
&lt;/project&gt;

</pre>

    <h3>Testing the NetBeans Generated Build System</h3>
<P>

<P>
Bob was pleased with ibs and he decided to put it to the test. His plan to make sure it works on Mac OS X and on Linux (Kubuntu 9.04). For each target OS Bob generated all the build files using ibs and then built all the projects both from the command line using make and from the NetBeans IDE itself. Then he proceeded to run various tests and programs.
<P>

<P>
<b>Generate all the build files</b>
<P>

<P>
Generating the build files is as simple as launching the build system generator. The program displays some simple progress information as it goes through the different stages.
<P>
<pre  class="code">
<P>
{root dir}/ibs &gt;  py build_system_generator.py 
--------------------
generate_build_files 
--------------------
----------------------
_populate_project_list 
----------------------
----
test 
----
----
dlls 
----
----
apps 
----
--
hw 
--
-----------------
generate_projects 
-----------------
----------------------
_generate_project world
----------------------
--------------------------
_generate_project testWorld
--------------------------
----------------------
_generate_project utils
----------------------
----------------------
_generate_project hello
----------------------
---------------------------
_generate_project punctuator
---------------------------
----------------------
_generate_project utils
----------------------
-------------------------------
_generate_project testPunctuator
-------------------------------
----------------------------
_generate_project hello_world
----------------------------
--------------------------
_generate_project testHello
--------------------------
-------------
save_projects 
-------------
------------------------
generate_workspace_files 
------------------------

</pre>
<P>

<P>
Bob did a quick sanity check to verify that the nbproject directory was indeed created for each project under the src directory:
<P>
<pre  class="code">
<P>
{root dir} &gt; find src -name nbproject
src/apps/hello_world/nbproject
src/dlls/punctuator/nbproject
src/hw/hello/nbproject
src/hw/utils/nbproject
src/hw/world/nbproject
src/test/testHello/nbproject
src/test/testPunctuator/nbproject
src/test/testWorld/nbproject

</pre>
<P>

<P>
At that point Isaac (the sage) heard the good news and came into the room. He wanted to personally supervise on the testing of ibs, which will soon be responsible for building the entire "Hello World - Enterprise Edition" system.
<P>

<P>
The next stage was to actually build the system using the ibs-generated build files. For starters Bob fired up NetBeans on Mac OS X, built and ran the hello_world application. This caused all its dependencies to be built and finally the application ran in its little terminal window and indeed printed the vaunted "hello, world!" message (see Figure 2).
<P>
<div>
<img src="0910gs01f2.gif"> 
<div class="caption">
<b>Figure 2</b>
</div>
</div>
<P>

<P>
Isaac was duly impressed, but not fully convinced yet. He asked Bob how ibs can handle automated tests and running outside of the NetBeans IDE. Bob was more than happy to comply and demonstrated how the test_world program can be built using the standard 'make' command from a terminal window and then executed (see Figure 3). 
<P>
<div>
<img src="0910gs01f3.gif"> 
<div class="caption">
<b>Figure  3</b>
</div>
</div>
<P>

<P>
Isaac commended Bob on a job well done, but Bob wasn't done. He knew that Isaac was an old Unix hand and he proceeded to demonstrate the ibs-generated build files on Kubuntu 9.04 (in a VM). First he built the libPunctuator project in the NetBeans IDe and then the testPunctuator project (see Figure 4). 
<P>
<div>
<img src="0910gs01f4.gif"> 
<div class="caption">
<b>Figure 4</b>
</div>
</div>
<P>

<P>
Bob was careful to copy the "libpunctuator.so" shared library to the directory of the testpunctuator program because the test always tries to load the shared library from the current working directory. They both noted with interest that on Kubuntu 9.04 programs run in an external terminal window (see Figure 5) as opposed to the internal NetBeans window on the Mac OS X. 
<P>
<div>
<img src="0910gs01f5.gif"> 
<div class="caption">
<b>Figure 5</b>
</div>
</div>
<P>

<P>
Then, Bob demonstrated building from Kubuntu's terminal (see Figure 6).
<P>
<div>
<img src="0910gs01f6.gif"> 
<div class="caption">
<b>Figure 6</b>
</div>
</div>
<P>

<P>
Isaac felt his concerns melting away. He was now convinced that ibs is the way to go to make "Hello World - Enterprise Edition" the best hello world application on Microsoft Windows too on the way to &#91;Hello&#93; World Domination!
<P>
<h3>Conclusion</h3>
<P>

<P>
In this article you saw ibs in action, generating a full fledged NetBeans build system for a non-trivial system that involves multiple projects, static libraries, shared libraries, applications and test programs. ibs handled well multiple target operating systems (Mac OS X and Kubuntu 9.04) and allowed building and testing from the NetBeans IDE or externally from a terminal window. Bob demonstrated ibs successfully to Isaac his manager and in the next episode, Bob will try to make ibs build the "Hello World - Enterprise Edition" system on the Windows OS.  


