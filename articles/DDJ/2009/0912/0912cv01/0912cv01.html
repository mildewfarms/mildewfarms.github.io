<title>Conversations</title>
<link rel="Stylesheet" rev="Stylesheet" href="../../../../forms/Layout.css" type="text/css">
<link rel="Stylesheet" rev="Stylesheet" href="../../../../forms/FontStyles.css" type="text/css">
<link rel="Stylesheet" rev="Stylesheet" href="../../../../forms/newarticle.css" type="text/css">
<script src="../../../../forms/popwindow.js"></script>
</head>

<body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000">
<!--Copyright &#169; Dr. Dobb's Journal-->
<p><i>Dr. Dobb's Digest</i> December 2009</p>

<h1> Q&A: Software Testing in a Virtualized World</h1>

<h2> Do virtualization and cloud computing pose unique testing challenges?</h2>
<P>
<h3>By Jonathan Erickson</h3>


<P>

<P>
<i>James Whittaker is director of test engineering for Google, and author of "How To Break Software: A Practical Guide To Testing". He recently spoke with Dr. Dobb's editor in chief Jonathan Erickson.</i>
<P>
<hr>
<P>
<img src="0912cv01f1.gif" align="left">

<b>Dr. Dobb's</b>: Do virtualization and cloud computing pose unique testing challenges?
<P>

<P>
<b>Whittaker</b>: Opportunities more than challenges. At Google, if I want to test, say, Chrome, I visit a Web site, tell it how many machines I want and what operating systems, drivers, apps, and the version of Chrome that I want on them, and wham! those machines are provisioned, and I can point my test automation at them. I don't care where they are. I don't care what they are. They exist, and they act just like the test environment that I would otherwise have to painstakingly -- and expensively -- create.
<P>

<P>
<b>Dr. Dobb's</b>: What about multicore platforms and parallel programming?
<P>

<P>
<b>Whittaker</b>: Multicore behaves the same as single core from an external point of view. Same with parallel and serial. The difference is with unit-level and other code-based tests. The devil is in these low-level details, and tools haven't yet caught up.
<P>

<P>
<b>Dr. Dobb's</b>: Functional testing, unit testing, security testing, and more. What's next?
<P>

<P>
<b>Whittaker</b>: Accessibility -- hands down. The idea that we can abstract the input mechanics from the functionality of the app. The idea that anything the application is capable of doing can be invoked programmatically. For users with disabilities, this is crucial as it allows for a great deal of creativity in how the program is manipulated. For testers, this means the ultimate set of test hooks. With accessible code, I can write hooks that can literally drive it through its entire set of capabilities. Nothing needs to be left to chance anymore.
<P>

<P>
<b>Dr. Dobb's</b>: How close are we to "real" automated testing?
<P>

<P>
<b>Whittaker</b>: Whatever buttons users can press, whatever values they can enter, we can see and do with automation. But applying inputs is only the first part of manual testing. Human testers can see subtle variations that lead them to say "that's a bug." This is the primary limiting aspect of automation. Programs aren't good at seeing output and processing behavior. They can see crashes. But they can't notice major bugs like navigating to the wrong page or rendering an image incorrectly.
<P>

