<html>
<head>
<title>Mar02: Programmer's Bookshelf</title>
</head>

<body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000">
<!--Copyright &#169; Dr. Dobb's Journal-->

<h1>Doubling Down on the Good and the Okay</h1>
<p><i>Dr. Dobb's Journal</i> March 2002</p>

<h3>By Gregory V. Wilson</h3>

<I>
Greg is a DDJ contributing editor with a special interest in scientific computing and small-scale software engineering. He presently works for Baltimore Technologies, and can be reached at <a href="mailto:gvwilson@ddj.com">gvwilson@ddj.com</a>.</I>

<hr>

<P><b>Program Generators with XML and Java</b><i><br>
J. Craig Cleaveland</i><br>
Prentice Hall, 2001<br>
448 pp., $49.99<br>
ISBN 0130258784<br>
<b><br>
Programming Python,  Second Edition</b><i><br>
Mark Lutz</i><br>
O'Reilly &amp; Associates, 2001<br>
1292 pp., $54.95<br>
ISBN 0596000855<br>
<b><br>
Developing Bioinformatics  Computer Skills</b><i><br>
Cynthia Gibas and Per Jambeck</i><br>
O'Reilly &amp; Associates, 2001<br>
446 pp., $34.95<br>
ISBN 1565926641<br>
<b><br>
Practical Guide to Testing  Object-Oriented Software</b><i><br>
John D. McGregor  and David A. Sykes</i><br>
Addison-Wesley, 2001<br>
224 pp., $44.95<br>
ISBN 0201325640<br></h4>

<p>The easiest way to explain a general idea is often through specific examples. J. Craig Cleaveland's <i>Program Generators with XML and Java</i> is a good example, and a good book. Despite its title, it isn't really about Java or XML: It's about treating programs as just another kind of data, which is something that programmers ought to do much more often.</p>
<p>By now, most programmers have had some experience with code generators, such as the "wizards" in Microsoft's Visual C++. Cleaveland's book is a systematic exploration of what wizards can do and how they should be built. His examples start simply, but by the end of the book have worked up to customized templating using the XML Document Object Model (DOM), XSLT, XPath, JavaBeans, and other bleeding-edge technologies.</p>
<DDJADVERTISEMENT INLINE>

<p>Chapters 2 and 3 of this book deserve special mention. In Chapter 2, Cleaveland looks at the sort of domain analysis procedures that should be used to scope out a code generator. Chapter 3 is then a diary-style description of those procedures in action. I originally found these chapters out of place, but the further I read, the more I appreciated Cleaveland being explicit about the sort of thinking that ought to go on before any code is written or generated.</p>

<p>I had just finished Cleaveland's book when the second edition of Mark Lutz's <i>Programming Python </i>landed on my desk with a loud "thunk." At almost 1300 pages, this book is far bigger than any single volume ought to be; my back would have been a lot happier if O'Reilly &amp; Associates had published it in two parts. On the positive side, everything in it is very useful. Most of the "Python 101" material from the first edition has been stripped out (or moved to Lutz and Ascher's excellent <i>Learning Python, </i>also from O'Reilly &amp; Associates). What's left, and what's been added, is about as comprehensive as any book can be. If you want to build a full-sized application in Python, and don't want to reinvent any wheels, this book is worth the hernia.</p>

<p>I wish I could say equally good things about Cynthia Gibas and Per Jambeck's <i>Developing Bioinformatics Computer Skills. </i>Unfortunately, the authors try to cover so much of this emerging field that they don't do a satisfactory job of any one part. As the title suggests, the book's aim is to teach people with a background in the life sciences the skills they need to work with the vast volumes of data that are being produced by the Human Genome Project and related efforts. This is a laudable goal, but far too much for any one reader to get out of a single book.</p>

<p>Chapters 3-5, for example, discuss how to set up a Linux workstation, the UNIX filesystem, and the basics of UNIX shell scripting. These are all worthy things, but these chapters fall between two stools: They are too short to be useful to people who don't already know them, but too shallow to teach experienced users anything new. Similarly, I simply don't believe that the quick introduction to Perl in Chapter 12 will be comprehensible to someone who doesn't already speak the language well enough to not need it. That said, there is a lot of useful material in the middle of the book on what standard sequence matching engines do, and how they work. I suspect that much of this material will go stale fairly quickly (just like everything else web-related does), but it's still helpful to have it all pulled together this way.</p>

<p>I was similarly disappointed by John D. McGregor and David A. Sykes's<i> Practical Guide to Testing Object-Oriented Software. </i>The blurb on the back claims that the book "...shows how testing object-oriented software differs from testing procedural software." In fact, I came away feeling that it had actually shown how similar the two are. Take out the UML diagrams, and what you're left with is two key ideas &#151; how to know what you're actually testing, and how to do that testing systematically.</p>

<p>The authors' answer to the first problem is to nail down a tight specification of how the system being tested is supposed to act. There's a lot more formalism here than most working programmers are used to, but one of the strengths of this book is that it shows how rigorous analysis and design pays off in increased testability.</p>

<p>The authors tackle the second problem by describing the whole spectrum of QA working practices, from systematic development of traceable test cases to test drivers and instrumented builds. I think most working programmers would enjoy this part of the book more if it included more "hands on" material; again, it's worth borrowing, but probably not something that most <i>DDJ</i> readers will keep on their desk.</p>



<p><b>DDJ</b></p>
</body>
</html>
