<html>
<head>
<title>Mar02: Programmer's Toolchest</title>
</head>

<body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000">
<!--Copyright &#169; Dr. Dobb's Journal-->

<h1>Examining VB.NET</h1>
<p><i>Dr. Dobb's Journal</i> March 2002</p>
<h2>A popular toolset is reengineered</h2>

<h3>By Lauren Hightower</h3>

<I>
Lauren is a partner in Spin Solutions, LLC. She can be contacted at <a href="mailto:lhightower@spinsolutions.com">lhightower@spinsolutions.com</a>.</I>

<hr>

<p>If you think that the next iteration of Microsoft's Visual Basic is somehow related to its predecessor, Visual Basic 6.0, in any way other than in name, think again. Visual Basic.NET, better known as VB.NET, is a completely reengineered version of the language with dramatic changes in the areas of deployment, data typing, inheritance, and data access. </p>
<p>Why the change? After all, Visual Basic 6.0 is used by millions of programmers because of its accessible syntax and rapid development capabilities. Well, Visual Basic 6.0, along with other Microsoft tools bundled into the first release of Visual Studio, was not engineered with the Web in mind. Because Microsoft was so late in adopting Internet technology and the concept of distributed, stateless applications, it had to retrofit its existing toolset, rather than design new tools for the new development environment. As a result, Visual Studio tools fall painfully short in producing web-based applications that are easy to develop, deploy, and debug. Instead, for three years, developers have used a variety of tricks and techniques to produce distributed applications. The resulting applications are difficult to produce and not optimized for web-based production environments.</p>
<DDJADVERTISEMENT INLINE>

<p>VB.NET changes all this. The toolset has been completely reengineered from the ground up to make it easy to develop web-based and client/server applications in a distributed, disconnected world. The productivity and technical gains you enjoy with VB.NET are more than worth the time and effort you'll spend learning the new tool.</p>

<p>As <A NAME="rt1"><A HREF="0203gt1.htm">Table 1</A> shows, the differences between Visual Basic 6.0 and VB.NET can be categorized into two groups: </p>

<ul>
  <li>Technical changes that improve the performance of applications and drive the syntax and programming-practice changes. 
  <li>Syntax changes or programming-practice differences that require you to change the way you write code.

</ul>

<h3>Technical Changes</h3>


<p>The technical changes included in VB.NET are the driving force behind the syntax and programming-practice changes. The syntax and programming-practice changes in VB.NET are required because of the technical objectives Microsoft is working toward in its new release of VB.</p>


<p>To bring VB in line technically with C++ and C#, Microsoft developed the Common Language Runtime (CLR), which serves as the foundation of all three languages and is at the heart of all applications written in any of the three languages. VB can no longer be considered a pseudocode generator. The CLR makes it a true object-oriented language and puts it on the exact same footing as C++ and C#. An application generated by VB.NET is technically indistinguishable from one generated in C++ or C# because of the CLR.</p>



<h3>Syntax Changes</h3>


<p>While the technical changes to VB.NET are extremely important (and much applauded), they are not as important to the immediate adoption of VB.NET as the syntax and programming-practice changes. I'll examine these changes in more detail because they affect the viability of converting Visual Basic 6.0 applications to VB.NET and help assess the learning curve required to start using VB.NET.</p>


<p>Microsoft included an Upgrade Wizard in the Beta 2 version of the .NET suite of tools to help migrate existing VB 6.0 applications to VB.NET. When appropriate, I indicate the effectiveness of the Upgrade Wizard to assess and fix some of the inconsistencies between VB 6.0 and VB.NET.</p>



<h3>Data Type Changes</h3>


<p>Say goodbye to the <i>Variant, Short</i>, and <i>Long</i> data types as you know them. VB.NET has combined the <i>Object</i> and <i>Variant</i> data types into the single <i>Object</i> data type. <i>Variant</i> was the VB 6.0 default data type assigned to all variables not specifically typed. In addition, Visual Basic assigns variables beyond the first one defined on the same line as variants. Consequently, the line: </p>


<pre><p>
Dim ipCount, ipNumber as Integer</p>

</pre><p>declares the <i>ipCount</i> variable as an integer and the <i>ipNumber</i> variable as a variant. The <i>Integer</i> data type is now <i>Short</i> (16-bit whole number) and the data type that was known as <i>Long</i> is now <i>Integer</i> (32-bit whole number). <i>Long</i> is now a 64-bit whole number. The Upgrade Wizard does a good job of replacing all instances of the <i>Variant, Integer,</i> and <i>Long</i> data types.</p>




<h3>Variable Scope Declaration Issues</h3>


<p>VB 6.0 grants all variables declared in a procedure "full procedure scope." That means that once a variable is declared, it can be accessed anywhere in the procedure. VB.NET reduces the scope of variables defined inside of blocks to the block they are declared in.</p>


<p>In VB.NET, for instance, <A NAME="re1"><A HREF="0203ge1.htm">Example 1</A> produces an error because the variable goes out of scope once the block (defined by a beginning <i>Do, For, </i>or <i>If</i> statement and ending with a <i>Loop, Next,</i> or <i>End If </i>statement) has terminated. Once the <i>For...Next </i>block terminates with the <i>Next</i> statement, the variable <i>j</i> is out of scope because it was declared inside the block. You can avoid this issue by declaring all variables at the beginning of a procedure regardless of where they are used.</p>

<p>The Upgrade Wizard will include any suspicious scope declarations in its final report, but will not fix them automatically.</p>



<h3>Data Access</h3>


<p>Visual Basic 6.0 supported ADO, RDO, and DAO for data-access purposes. VB.NET recommends an enhanced version of ADO, ADO.NET, which has improved namespaces that make working with disconnected data sets more efficient.</p>


<p>VB.NET supports ADO, DAO, and RDO (with some minor modifications) with one major exception &#151; VB.NET does not support DAO and RDO data binding to controls, data controls, or RDO User Connection. </p>

<p>If you've used DAO or RDO in conjunction with data binding controls in VB 6.0 applications, don't upgrade to VB.NET unless you want to spend an inordinate amount of time rewriting the code that binds data to controls. It is virtually impossible for the Upgrade Wizard to interpret your existing data-access code and convert it to ADO.NET- or even VB.NET-acceptable language. The unsupported code has to be changed manually.</p>



<h3>Binding</h3>


<p>Early binding is the practice of declaring a variable and assigning it to an instance of a class before the application is compiled. Doing so instantiates the object and stores it in memory from the time when the application is run until you use it. For instance, <A NAME="re2"><A HREF="0203ge2.htm">Example 2</A>(a) uses early binding to declare the variable<i> rsRecordset </i>as an <i>ADODB.Recordset</i>.</p>


<p>Late binding, on the other hand, is the practice of declaring a variable as an object and then assigning it to an instance of a class at run time. Late binding is good to use when you think a module might not be used frequently and you don't want to load an instance of a class in memory unnecessarily. <A NAME="re2"><A HREF="0203ge2.htm">Example 2</A>(b) uses late binding to declare a variable and bind it to an instance of the <i>ADODB</i> class when it happens upon it in the code.</p>

<p>The Upgrade Wizard can convert early-bound objects much easier than late-bound objects because it can convert properties and methods of strongly typed variables, but not late-bound objects. </p>



<h3><i>ByVal</i> and <i>ByRef</i> Parameters</h3>


<p>By default, variables passed into a VB 6.0 function or subroutine not specifically declared as <i>ByRef</i> or <i>ByVal</i> were assigned automatically based on their type of parameter. All intrinsic data types such as integers, strings, Booleans, and variants were defined <i>ByRef</i>. Object references and user-defined data types were assigned <i>ByVal</i>.</p>


<p>VB.NET defaults all parameters to <i>ByVal</i> unless they are explicitly declared otherwise. This can cause serious problems in applications if you have an intrinsic data type parameter (a string, for instance) that you want the function to alter. If you do not specifically assign the variable <i>ByRef</i>, VB.NET treats the parameter as <i>ByVal</i>.</p>

<p>In VB 6.0, <A NAME="re3"><A HREF="0203ge3.htm">Example 3</A>(a) changes the value of the string passed in because the parameter <i>shString</i> is automatically passed in <i>ByRef</i>. In VB.NET, <A NAME="re3"><A HREF="0203ge3.htm">Example 3</A>(a) leaves the string unchanged because the parameter would be passed in <i>ByVal </i>by default. To change the string inside the procedure, the parameter <i>shString</i> has to be explicitly declared <i>ByRef</i> as in <A NAME="re3"><A HREF="0203ge3.htm">Example 3</A>(b).</p>



<h3>Default Properties</h3>


<p>Visual Basic programmers have enjoyed default properties as a syntax shortcut for years. For instance, the default property for the <i>Textbox</i> component is <i>Text</i>. So, assuming <i>Text1</i> is the name of a text box on a form, <A NAME="re4"><A HREF="0203ge4.htm">Example 4</A>(a) represents the exact same functionality.</p>


<p>VB.NET no longer supports default properties for parameterless objects. However, VB.NET does support default properties for objects that require a parameter. For instance, without using the default properties, <A NAME="re4"><A HREF="0203ge4.htm">Example 4</A>(b) would be written like <A NAME="re4"><A HREF="0203ge4.htm">Example 4</A>(c).</p>

<p><A NAME="re4"><A HREF="0203ge4.htm">Example 4</A>(b) has two default properties, <i>Fields</i> and <i>Value</i>. The <i>Fields</i> property requires the name of the field as a parameter. The <i>Value</i> property does not require a parameter; thus in VB.NET, it must be explicitly stated. <A NAME="re4"><A HREF="0203ge4.htm">Example 4</A>(d) would be interpreted correctly in VB.NET.</p>

<p>The Upgrade Wizard can determine the default property for most, but not all, objects. In addition to the potential incompatibilities with VB.NET, it is good programming practice to abandon the use of default properties altogether and explicitly state the property name for the purposes of code clarity and readability.</p>



<h3>The <i>Double</i> Data Type </h3>


<p>It has also been a common practice for VB 6.0 developers to use the <i>Double</i> data type to store dates. Internally, VB 6.0 converted and stored dates as <i>double</i>s. However, VB.NET does not. Instead, it uses the <i>Date</i> data type to store dates.</p>


<p>The Upgrade Wizard has a difficult time assessing the intent of a <i>double</i>. Consider this code:</p>

<pre><p>
Dim dpDate as Double<br>
DpDate = opRecordset("CancellationDate")</p>

</pre>

<p>As you can imagine, it is impossible for the Upgrade Wizard to determine that the <i>CancellationDate</i> field is truly a <i>Date</i> data type and alter the code appropriately. Instead, the Wizard flags any use of the <i>Double</i> data type and warns you that if you're using it to store a date, you should change the data type to <i>Date.</i></p>



<h3>Arrays</h3>


<p>One of the language-friendly anomalies of Visual Basic 6.0 and its predecessors was the ability to create arrays with lower and upper bounds. That feature has been abolished to ensure interoperability with the other languages in the .NET framework.</p>


<p>VB.NET has a workaround built-in to handle nonzero-based arrays, but it is slow and cumbersome. Consequently, it is highly recommended that you redefine all of your arrays to be zero-based to take advantage of the much faster intrinsic array class. </p>

<p>For instance, the VB 6.0 code in <A NAME="re5"><A HREF="0203ge5.htm">Example 5</A>(a) creates an array that starts at 3. In addition, the array <i>a</i> has 10 integers. To use the integers in the array, you could use <A NAME="re5"><A HREF="0203ge5.htm">Example 5</A>(b) to sum the first, second, and third elements of the array. The new statement in VB.NET requires the array to be zero-based and would only have nine integers; see <A NAME="re5"><A HREF="0203ge5.htm">Example 5</A>(c). The same code to sum the first three elements would look like <A NAME="re5"><A HREF="0203ge5.htm">Example 5</A>(d).<i></p>

<p>ReDim</i> is a popular command in VB 6.0 to reassign a variant as an array later in the code. VB.NET only lets you <i>ReDim</i> a variable that has already been declared as an object. You cannot <i>ReDim</i> a variable that has not yet been defined as you could in VB 6.0.</p>

<p>The Upgrade Wizard will flag the sections of your code that use nonzero-based arrays, but cannot convert them automatically.</p>



<h3>True, False, and Constants</h3>


<p>Much to the dismay of many VB developers, Visual Basic 6.0 broke with other language-coding norms and assigned -1 to the Boolean value of True. VB.NET fixes this anomaly and instead considers a Boolean value of True to be equal to 1. That could introduce some problems in your upgraded code if you test for a particular value instead of testing for True or False in your <i>if</i> statements. For instance, <A NAME="re6"><A HREF="0203ge6.htm">Example 6</A>(a) would work if you were testing the Boolean value <i>bpCheck</i> for True in Visual Basic 6.0. In VB.NET, the same code would be written like <A NAME="re6"><A HREF="0203ge6.htm">Example 6</A>(b). Either way, you could eliminate the discrepancy altogether by using the reserved word <i>True</i> instead of the numerical representation for True; see <A NAME="re6"><A HREF="0203ge6.htm">Example 6</A>(c).</p>


<p>Similarly, use constants instead of a numerical representation of a parameter. For instance, the <i>ADODB</i> object has several methods that require you to pass in parameters that are defined as constants. <A NAME="re6"><A HREF="0203ge6.htm">Examples 6</A>(d) and 6(e) do the exact same thing, but the first uses a constant instead of its numerical representation.</p>

<p>Using a constant instead of the numerical equivalent ensures that your application will be compatible with future releases of the object.</p>

<p>The Upgrade Wizard cannot detect the meaning of code that does not use the reserved words True and False when comparing Boolean values. It will, however, flag the code in its final report to let you know there could be a problem and you should review it.</p>



<h3>Obsolete Syntax</h3>


<p>In the interest of backward compatibility, recent releases of Visual Basic have contained old syntax that represented archaic programming techniques. The reserved words in <A NAME="rt2"><A HREF="0203gt2.htm">Table 2</A> have been removed from VB.NET.</p>




<h3>Conclusion</h3>


<p>VB.NET is a new programming language, and Microsoft is betting the Visual Basic developer community will adopt it because it bears the same name as its enormously popular predecessor. While the syntax and programming-practice changes may take some time to master, the time investment is far outweighed by the advantages of VB.NET. Microsoft made the decision and invested the resources to reengineer VB from the ground up. The result is a technically sound toolset that couples the rapid development capabilities of VB 6.0 with the technical prowess of C++. </p>



<p><b>DDJ</b></p>

</body>
</html>
