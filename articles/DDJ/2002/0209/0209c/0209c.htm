<html>
<head>
<title>Sep02: Java & UDDI Registries</title>
</head>

<body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000">
<!--Copyright &#169; Dr. Dobb's Journal-->

<h1>Java &amp; UDDI Registries</h1>
<p><i>Dr. Dobb's Journal</i> September 2002</p>
<h2>Yes, you can access web services with Java</h2>

<h3>By Paul Tremblett</h3>

<I>
Paul is a software developer with AudioAudit and author of Instant Wireless Java With J2ME (McGraw-Hill, 2002). Paul can be reached at ptremblett@ earthlink.net.</I>

<hr>

<p>Applications that require web services send a request to a service at an advertised URL. The service processes the request and returns the result. Applications obtain information about how to contact a service (along with other useful data) from business registries such as the Universal Description, Discovery, and Integration (UDDI) project (http://www .uddi.org/), a platform-independent, open framework for describing services and businesses and integrating them via the Internet. Currently, more than 200 companies support UDDI. In this article, I'll show how Java applications contact business registries such as UDDI and retrieve information from them. A WAR file containing the components necessary to run the examples presented here is available electronically; see "Resource Center," page 5.</p>


<h3>The Contents of a UDDI Registry</h3>


<p>The UDDI registry, which is publicly accessible to any business or individual, contains the data you need to answer "who, what, where, and how" questions before engaging in business transactions. This includes:</p>
<DDJADVERTISEMENT INLINE>


<p></p>

<ul>
  <li>A verifiable identifier, such as a DUNS number, that answers the question of "who" in identifying a business. 
  <li>An industry standard identifier, such as a North American Industry Classification System (NAICS) code or a Universal Standard Products and Services Classification (UNSPSC) code, that answers the question of "what" a business does. 

  <li>Addresses such as URLs, e-mail addresses, and postal addresses that answer the question of "where." 

  <li>Registered references to information about specifications that describe the usage of a particular software package or interface answer the question "how." According to the UDDI specification, such <i>registered references</i> are called <i>tModel</i>s.

</ul>


<p>Information from a UDDI registry is contained in the four data structure types in <A NAME="rf1"><A HREF="0209cf1.htm">Figure 1</A>. As you can see, at the top of the hierarchy is the <i>businessEntity</i> structure. This structure is identified by a Universally Unique ID (UUID), a 128-bit identifier generated by an algorithm designed to prevent duplication. A typical UUID might be "51A5B3B0-32BD-11D6-83CD-000C0E00ACDD." In addition to holding information such as the name of the business and optional elements like a description of the business and contact information, the <i>businessEntity</i> structure serves as a container for the other three structures. A <i>businessEntity</i> structure can contain zero or more <i>businessServices</i> structures. Each of these structures is identified by a UUID and contains a human-readable name for a family of services, zero or more optional language-qualified text descriptions of the service family, and a <i>bindingTemplate</i> structure. From a <i>bindingTemplate</i>, you can get a technical description of a service, a technical entry point, and technical characteristics of a given implementation. A <i>bindingTemplate</i> also contains a number of <i>tModel</i>s. A <i>tModel</i> can be used to represent a technical specification such as a wireless protocol, an interchange format, or interchange sequencing rules. </p>



<h3>The UDDI API</h3>


<p>A UDDI registry is intended to be accessed programatically via an API based on XML (the complete API is available at http:// www.uddi.org/). The XML messages that comprise the API are transmitted in Simple Object Access Protocol (SOAP) envelopes using HTTP. </p>


<p><A NAME="rf2"><A HREF="0209cf2.htm">Figure 2</A> is a typical message that represents the find_business API and is the message you would send to a UDDI registry to get a list of all business that start with the string "<i>Section VIII</i>." Responses are also SOAP messages. <A NAME="rf3"><A HREF="0209cf3.htm">Figure 3</A> is the list returned by the registry server in response to the find_business request.</p>

<p>As <A NAME="rt1"><A HREF="0209ct1.htm">Table 1</A> shows, the APIs are divided into three categories: general browsing, drill down, and publishing. Here, I focus only on the find_business API.</p>



<h3>Querying a Registry Using JAXM</h3>


<p>To illustrate how to send a query to a registry server, I'll use Java to send a query that originates from a browser.</p>


<p>The JavaServer page QueryRegistryV1.jsp (available electronically) generates HTML code that produces the display in <A NAME="rf4"><A HREF="0209cf4.htm">Figure 4</A>. When users click on one of the two buttons, a request containing values of the parameters <i>queryString</i>, <i>disposition</i>, and depending on which button is clicked, either <i>submitPredefined</i>/<i>predefinedURL</i> or <i>submitUserSpecified</i>/<i>userSpecifiedURL</i> are sent to RegistryServerV1. You can see from web.xml (available electronically) that this URL pattern maps to com.ddj.uddi.RegistryServerV1 (available electronically). After extracting the value of <i>queryString</i> and assigning a value to the local variable <i>url</i>, the servlet invokes the <i>findBusiness()</i> method passing these two variables as arguments. <A NAME="rl1"><A HREF="#l1">Listing One</A> is the code for <i>findBusiness</i>.</p>

<p>This method introduces the Java API for XML Messaging (JAXM). I start by invoking the static method <i>newInstance()</i> of class <i>MessageFactory</i> to create a <i>SOAPFactory</i> object. This is the simplest way to create a <i>MessageFactory</i>, which is usually used by a standalone application and is adequate for the example I present here. A more usual approach is to obtain a connection to a messaging provider and invoke the <i>ProviderConnection</i> object's <i>createMessageFactory()</i> method. Next, I create a <i>SOAPMessage</i> by invoking the <i>MessageFactory</i> object's <i>createMessage()</i> method. The <i>SOAPBody</i> element in which the payload will be stored is contained in the <i>SOAPEnvelope</i>. I get the envelope by invoking the <i>getEnvelope()</i> method of the <i>SOAPPart</i> object returned from the <i>SOAPMessage</i> object's <i>getSOAPPart()</i> method. After saving the envelope for later use, I use the <i>getSOAPBody()</i> method to get the contents of the <i>SOAPBody</i> and construct a query within this body by: </p>


<ul>
  <li>Adding a body element named "<i>find_business</i>" to the body.
  <li>Adding the attributes <i>generic</i> and <i>maxRows</i> to this body element.

  <li>Adding a child element called "<i>name</i>" to the body element.

  <li>Adding a text node containing the query string to the child element.

</ul>


<p>After the message has been constructed, I invoke the <i>saveChanges()</i> method to update the message with all the changes that have been made. Even though this message is called automatically when the message is sent, it's a good idea to call it whenever you make changes to a message. A little redundancy is better than a lot of debugging. The message I just created looks like that in <A NAME="rf2"><A HREF="0209cf2.htm">Figure 2</A>, except for the contents of the query string.</p>

<p>The next step is to send the message. There are two ways to do this. The first uses the <i>ProviderConnection</i> object and the second method uses a <i>SOAPConnection</i>, which is a point-to-point connection a client uses for sending messages directly to a remote party without using a message provider. Since I already said I would not be using a message provider, I'll use the second method. I start by invoking the static method <i>newInstance()</i> of the <i>SOAPConnection</i> class. This method returns a <i>SOAPConnection</i> object. Next, I create the endpoint to which the <i>SOAPConnection</i> object connects by passing the value in the variable <i>url</i> to the constructor of class <i>URLEndpoint</i>. Finally, I transmit the message by passing the <i>SOAPMessage</i> and <i>URLEndpoint</i> to the <i>SOAPConnection</i> object's <i>call()</i> method. Messages sent using the <i>call()</i> method follow the request/response paradigm &#151; the method blocks until it receives a reply. Normally, you'd make sure that a blocking call is in a separate thread, but I wanted to keep this example simple. The <i>findBusiness()</i> method returns the <i>SOAPMessage</i> returned by the <i>call()</i> method. </p>

<p>The way in which the <i>SOAPMessage</i> returned from the <i>findBusiness()</i> method is sent back to the browser depends on the value of the <i>disposition</i> parameter. This value depends on which radio button users click. If users click the radio button labeled "XML," the servlet sets the content type of the response being sent to the client to "text/xml" and calls the <i>SOAPMessage</i> object's <i>writeTo()</i> method to write the contents of the <i>SOAPMessage</i> to the servlet output stream. The results are similar to <A NAME="rf3"><A HREF="0209cf3.htm">Figure 3</A>, but since I searched for businesses starting with "ibm" and specified the IBM Test Registry, the result contains a number of <i>businessEntity</i> structures. </p>

<p>If users click the radio button labeled "HTML," the servlet passes the message returned from <i>findBusiness()</i>, an .xsl file (such as List1.xsl, available electronically), and the servlet response object to the method <i>transformMessage()</i>; see <A NAME="rl2"><A HREF="#l2">Listing Two</A>.</p>

<p>The actual transformation is done by an instance of a <i>Transformer</i> object, which can be found in the package javax.xml.transform. Since I will be using a <i>PipedOutputStream</i> to deliver the XML to the <i>Transformer</i> object, and since having both ends of a pipe in the same thread can result in deadlock, I create a separate thread using an instance of <i>TransformerThread</i>, which implements <i>Runnable</i>. <A NAME="rl3"><A HREF="#l3">Listing Three</A> presents the <i>run()</i> method.</p>

<p>I do the transformation this way:</p>

<ol>
<li>Create a <i>PipedOutputStream</i> to deliver the XML to the thread.
<li>Create a <i>PipedInputStream</i> to receive HTML back from the thread.
<li>Create the thread and start it running.
<li>Write the XML to the <i>PipedOutputStream</i>.
<li>Close the <i>PipedOutputStream</i>.
<li>Read data from the <i>PipedInputStream</i> a byte at a time and write it to the servlet's output stream.
</ol>


<p>The data read from the <i>PipedInputStream</i> is written in the thread, in which I do the following actions:</p>

<ol>
<li>Get a <i>DocumentBuilder</i> using the static method <i>newInstance()</i> of class <i>DocumentBuilderFactory</i>.
<li>Create an instance of <i>org.w3c.dom.Document</i> by parsing the data received via the pipe.
<li>Create a <i>DOMSource</i> from the <i>Document</i> object so that the transformation source can be in the form of a DOM tree.
<li>Create a <i>Transformer</i> object by passing the .xsl file to an instance of <i>TransformerFactory</i>.
<li>Pass the <i>DOMSource</i> and an output stream to the <i>transform()</i> method of the <i>Transformer</i> object (the output stream is a pipe with the other end in the <i>findBusiness()</i> method).
</ol>

<p><A NAME="rf5"><A HREF="0209cf5.htm">Figure 5</A> depicts what the browser looks like when the HTML resulting from the transformation is displayed.</p>



<h3>Making Things Easier Using JAXR</h3>


<p>Even though the first example represented an interesting way to learn about SOAP messages and provided a peek at JAXM and XSLT, it does have problems. For instance, the preparation of the SOAP message for each of the UDDI APIs requires a thorough knowledge of the structure being passed to the API. Second, the program is UDDI specific and UDDI is not the only registry specification. There are others, such as the ebXML Registry and Repository standard, which is being developed by the Organization for the Advancement of Structured Information Standards (OASIS) and the United Nations Centre for the Facilitation of Procedures and Practices in Administration, Commerce, and Transport (U.N./CEFACT). The program presented here could not be used to retrieve data from such registries.</p>


<p>Both of these problems are addressed by the Java API for XML Registries (JAXR), a single, easy-to-use abstraction API that lets you develop portable code that can access a variety of registries. The servlet RegistyServerV2 (available electronically) uses JAXR to query a registry. It is identical to RegistryServerV1 except for the <i>findBusiness()</i> method, which looks like <A NAME="rl4"><A HREF="#l4">Listing Four</A>.</p>

<p>In the <i>findBusiness()</i> method, I create a <i>ConnectionFactory</i> object and use its <i>createConnection()</i> method to create a <i>Connection</i> object. Next, I invoke the <i>Connection</i> object's <i>getRegistryService()</i> method to get the <i>RegistryService</i> interface associated with the <i>Connection</i>. I then call the <i>RegistryService</i> interface's <i>getBusinessQueryManager()</i> method, which returns the <i>BusinessQueryManager</i> interface implemented by the JAXR provider. <i>BusinessQueryManager</i> is the interface exposed by the <i>RegistryService</i> that implements the business-style query interface. <i>BusinessQueryManager</i> is referred to as a focused query interface. The actual query is performed by passing the <i>Collection</i> objects in <A NAME="rt2"><A HREF="0209ct2.htm">Table 2</A> to the <i>findOrganizations()</i> method, which returns a <i>BulkResponse</i> object. </p>

<p>The <i>BulkResponse</i> object returned by <i>findOrganizations()</i> is not XML but rather a <i>Collection</i> of objects, so it can't be simply sent to the browser or transformed. To address this issue, I use the <i>convertToSOAPMessage()</i> method. As its name implies, it converts the <i>BulkResponse</i> to a SOAP message. It does this by obtaining the <i>Collection</i> of objects from the <i>BulkResponse</i>, iterating across the <i>Collection</i>, and using the JAXM API to create a SOAP message whose body contains elements representing the objects in the <i>Collection</i>. The <i>convertToSOAPMessage()</i> method looks like <A NAME="rl5"><A HREF="#l5">Listing Five</A>.</p>

<p>I dispose of the <i>SOAPMessage</i> returned by <i>convertToSOAPMessage</i> in the same manner as in the first example. If I simply send it back to the browser, it looks like <A NAME="rf6"><A HREF="0209cf6.htm">Figure 6</A>. If I transform it using Business2.xsl (available electronically), it looks like <A NAME="rf7"><A HREF="0209cf7.htm">Figure 7</A>. </p>



<h3>Conclusion</h3>


<p>The tools needed to query a UDDI registry are available and easy to use, and the JAXM API is suitable for preparing SOAP messages. Since the SOAP messages are XML, the JAXP API can be used to parse them. JXSLT provides a way to transform XML to HTML, making Java a good choice when you are using web services.</p>


<p></p>

<p><b>DDJ</b></p>
<p>(Listings begin on page 40)</p>

<H4><A NAME="l1">Listing One</H4>


<pre>private SOAPMessage findBusiness(String url, String queryString)
      throws Exception {
    MessageFactory msgFactory = MessageFactory.newInstance();
    SOAPMessage msg = msgFactory.createMessage();
    SOAPEnvelope envelope = msg.getSOAPPart().getEnvelope();
    SOAPBody body = envelope.getBody();
    SOAPElement findBusiness = body.addBodyElement(
        envelope.createName("find_business",
        "", "urn:uddi-org:api"));
    findBusiness.addAttribute(
        envelope.createName("generic"), "1.0");
    findBusiness.addAttribute(
        envelope.createName("maxRows"), "100");
    SOAPElement businessName =
        findBusiness.addChildElement(
        envelope.createName("name"));
    businessName.addTextNode(queryString);
    msg.saveChanges();
            SOAPConnectionFactory scf = 
        SOAPConnectionFactory.newInstance();
    SOAPConnection connection = scf.createConnection();
    URLEndpoint endpoint = new URLEndpoint(url);
    SOAPMessage reply = connection.call(msg, endpoint);
    return reply;
}
</pre>
<P>
<A HREF="#rl1">Back to Article</A>
</P>
<H4><A NAME="l2">Listing Two</H4>


<pre>private void transformMessage(SOAPMessage msg, String xslSource,
            HttpServletResponse response)
        throws Exception {
    response.setContentType("text/html");
    ServletOutputStream out = response.getOutputStream();
    ServletContext context = getServletConfig().
        getServletContext();
    String filePath = context.getRealPath(xslSource);
    PipedOutputStream pipeToThread = new PipedOutputStream();
    PipedInputStream pipeFromThread = new PipedInputStream();
    TransformerThread transformer =
    new TransformerThread(filePath, pipeToThread, pipeFromThread);
    new Thread(transformer).start();
    msg.writeTo(pipeToThread);
    pipeToThread.flush();
    pipeToThread.close();
    int b;
    while ((b = pipeFromThread.read()) &gt;= 0) {
        out.print((char)b);
    }
    pipeFromThread.close();
    out.flush();
    out.close();
}
</pre>
<P>
<A HREF="#rl2">Back to Article</A>
</P>
<H4><A NAME="l3">Listing Three</H4>


<pre>public void run() {
    try {
        factory = DocumentBuilderFactory.newInstance();
        builder = factory.newDocumentBuilder();
        document = builder.parse(pipeFromMain);
        DOMSource source = new DOMSource(document);
        TransformerFactory tFactory = 
            TransformerFactory.newInstance();
        Transformer transformer = 
            tFactory.newTransformer(xslSource);
        StreamResult result = new StreamResult(pipeToMain);
        transformer.transform(source, result);
        pipeToMain.flush();
        pipeToMain.close();
    }
    catch (Exception e) {
        e.printStackTrace();
    }
}
</pre>
<P>
<A HREF="#rl3">Back to Article</A>
</P>
<H4><A NAME="l4">Listing Four</H4>


<pre>private SOAPMessage findBusiness(String url, String queryString)
        throws Exception {
    BulkResponse response = null;
    Connection connection = null;
    SOAPMessage msg = null;
    Properties props = new Properties();
    props.setProperty("javax.xml.registry.queryManagerURL",
        url);
    props.setProperty("javax.xml.registry.factoryClass",
        "com.sun.xml.registry.uddi.ConnectionFactoryImpl");
    try {
        ConnectionFactory factory =
        ConnectionFactory.newInstance();
        factory.setProperties(props);
        connection = factory.createConnection();
        RegistryService rs = connection.getRegistryService();
        BusinessQueryManager bqm =
        rs.getBusinessQueryManager();
        Collection findQualifiers = new ArrayList();
        findQualifiers.add(FindQualifier.SORT_BY_NAME_DESC);
        Collection namePatterns = new ArrayList();
        namePatterns.add(queryString + "%");
        
        response = bqm.findOrganizations(findQualifiers,
        namePatterns, null, null, null, null);
        msg = convertToSOAPMessage(response);
    }
    catch (Exception e) {
        e.printStackTrace();
    } finally  {
        if (connection != null) {
            try {
                connection.close();
            } catch (JAXRException je) {}
        }
        return msg;
    }
}
</pre>
<P>
<A HREF="#rl4">Back to Article</A>
</P>
<H4><A NAME="l5">Listing Five</H4>


<pre>private SOAPMessage convertToSOAPMessage(BulkResponse response) 
    throws Exception {
  MessageFactory factory = MessageFactory.newInstance();
  SOAPMessage msg = factory.createMessage();
  SOAPEnvelope envelope = msg.getSOAPPart().getEnvelope();
  SOAPBody body = envelope.getBody();
  Collection orgs = response.getCollection();
  Iterator orgIter = orgs.iterator();
  while (orgIter.hasNext()) {
      Organization org = (Organization) orgIter.next();
      SOAPBodyElement orgElement = body.addBodyElement(
          envelope.createName("Organization"));
      SOAPElement orgName = orgElement.addChildElement(
          envelope.createName("name"));
      orgName.addTextNode(getName(org));
      SOAPElement orgKey = orgElement.addChildElement(
          envelope.createName("key"));
      orgKey.addTextNode(getKey(org));
      SOAPElement orgDesc = orgElement.addChildElement(
          envelope.createName("description"));
      orgDesc.addTextNode(getDescription(org));
  }
  msg.saveChanges();
  return msg;
}

</pre>
<P>
<A HREF="#rl5">Back to Article</A>
</P>


</body>
</html>
