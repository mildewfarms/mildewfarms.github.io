<html><head><title>Jan02: Reducing Dependencies in .NET Development</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Reducing Dependencies in .NET Development</h1><p><i>Dr. Dobb's Journal</i> January 2002</p><h2>A utility that graphically displays project dependencies</h2><h3>By Scott Allen</h3><I>Scott is a software developer in Hagerstown, Maryland, and can be contacted at <a href="mailto:bitmask@fred.net">bitmask@fred.net</a>.</I><hr><p>Have you ever worked on an application where changing one line of code results in a massive rebuild of the system? To avoid situations such as this, you clearly need to understand the project dependencies before you can begin improvements. However, development environments rarely offer tools to view all of the project relationships at once. Faced with this lack of tools, I wrote (in C#) a utility called "GDEPENDS" that graphically displays project dependencies parsed from Microsoft Visual Studio files. In this article, I show how GDEPENDS leverages .NET Framework features, including COM interoperability, form-based GUI design, extensible metadata, and the .NET class library. </p><p>There are several benefits to understanding project dependencies of large applications. Reducing dependencies can shrink build time and improve reusability. In addition, unit testing and regression testing are easier to manage. (For more information, see <i>Large-Scale C++ Software Design</i>, by John Lakos, Addison-Wesley, 1996.) </p><DDJADVERTISEMENT INLINE><p>Visual Studio lets you group a collection of projects into a workspace (Visual Studio 6) or solution (Visual Studio.NET). Both let you create project dependencies when one project needs the build artifacts of a second project to compile or link. In the not too distant past, these dependencies arose when one project needed a DLL import library from another project. With COM, these dependencies involved MIDL-generated header files and type libraries. In .NET, a project relies on other "assemblies." The rich amount of metadata stored in an assembly replaces header files and other techniques previously used to export information.</p><p>I had a few simple design goals when starting GDEPENDS. While I mainly needed to parse and analyze Visual Studio 6 and Visual Studio.NET files, I also wanted an extensible design to add new file types with a minimum of effort. Furthermore, I wanted to graph the results of a parse, perhaps using third-party tools or libraries, instead of writing layout code myself. </p><h3>The Base Class</h3><p><i>DependencyAnalyzer</i> (from DAnaylzer.cs) is an abstract class with two public methods: <i>Parse</i> and <i>Display</i>. <i>Parse</i> is an abstract method, and in C# the <i>abstract</i> keyword makes a method virtual. It is the responsibility of a derived class to implement <i>Parse</i> and build a directed graph of projects and their dependencies. </p><p>There are two popular techniques to choose from when building a directed graph. Adjacency lists use a collection of linked lists, while adjacency matrices are built on a two-dimensional array. Since most of the parsing algorithms in GDEPENDS need to find a project by name, I chose to use an adjacency list implementation built on a hash table. <i></p><p>DependencyAnalyzer</i> contains a protected member variable of type <i>Hashtable</i> from the <i>System.Collections</i> namespace. Each entry in a <i>Hashtable</i> contains a key-value pair. In this case, the key is a project identifier (a name or a GUID), and the value is an instance of <i>DependencyNode</i>. A <i>DependencyNode</i> maintains some basic properties and display attributes for a dependency and uses an <i>ArrayList</i> to hold references to the other <i>DependencyNode</i>s in the <i>Hashtable</i>. </p><h3>COM Interoperability</h3><p>Originally, I planned to use only .NET technologies for GDEPENDS, perhaps porting some directed graph-drawing algorithms to C#. However, I couldn't stop thinking about all of the shapes and page layout capabilities available for COM automation clients from Microsoft Visio. Since COM is so deeply entrenched in current Microsoft tools, it was no surprise to find robust support for integrating COM components into managed .NET applications. </p><p>Using COM components from .NET begins by generating an <i>interop</i> assembly from a COM type library. The .NET IDE automatically generates an <i>interop</i> assembly for COM libraries when users add a project reference to a COM type library. Alternatively, the type library import utility (tlbimp.exe) offers more control (via command-line parameters) to set filenames, namespaces, and other options. Finally, the <i>TypeLibConverter</i> class from <i>System.Runtime.InteropServices</i> offers a programmatic means to create the <i>interop</i> assembly. </p><p>The metadata inside the <i>interop</i> assembly lets .NET create a run-time callable wrapper class (RCW) for .NET objects to use. The RCW marshals calls from the .NET-managed environment into the COM component, and manages the COM component lifetime via <i>AddRef</i> and <i>Release</i>. COM <i>interop</i> does come with a price, as one TechEd session reported an overhead of 50-70 instructions for each call into a COM component. </p><p>GDEPENDS uses Visio 2002 and the embedded Visio type library in vislib.dll. Although Visio 2002 now supports XML as a native format, I found the automation approach more intuitive. With the <i>interop</i> assembly in place, Visio interfaces appear as native .NET components to C#. </p><h3>Visio Automation</h3><p><A NAME="rl1"><A HREF="#l1">Listing One</A> is source code for the <i>DependencyAnalyzer</i> class. The algorithm for <i>Display</i> is to iterate through the <i>Hashtable</i> of <i>DependencyNode</i>s to place a shape into Visio for each node, then reiterate the <i>Hashtable</i>, drawing a connector from each node's shape to any of the node's dependency shapes. The flexibility of the algorithm is in the protected virtual functions used to do the automation. For instance, a derived class can override the <i>DropShape</i> function to use an entirely different shape. A derived class could also forward the <i>DropShape</i> call to the base class implementation, then use the returned <i>IVShape</i> object to perform additional formatting or add extra text. </p><p><i>LoadVisio</i> is the first virtual method called. <i>LoadVisio</i> starts the Visio application and loads the Auto-size box and Dynamic connector masters. Master objects are instantiated as shapes when users drag them into a drawing. The Auto-size box can adjust its width/height to accommodate the text it contains, while the Dynamic connector can route itself around other shapes on the drawing, as well as provide line jumps when it crosses other connector lines. These characteristics help simplify the drawing code.<i></p><p>DropShape</i> places a box in the drawing and sets the text to the name of the <i>DependencyNode</i>. The second and third parameters to the <i>Drop</i> method of <i>IVPage</i> are the x and y positions. <i>DropShape</i> simply drops all of the shapes into the middle of the page for Visio to rearrange later. <i></p><p>DropConnector</i> works in a similar fashion. However, <i>DropShape</i> has the additional task of formatting the connector with a thick end arrow. Almost every object in Visio has an attached "ShapeSheet" spreadsheet and almost every property adjustment or formatting task requires manipulation of a ShapeSheet. Although intimidating when you first see the large number of cells associated with each object, ShapeSheets are nonetheless powerful. A dynamic connector, for example, has around 130 cells to manipulate. A program can access a cell via a label (Height and Width, for example), and a cell may contain a formula. <i>DropConnector</i> sets the thick end arrow by putting the value 4 into the EndArrow cell. The easiest way for me to find the cells and values to use is to open the ShapeSheet window and experiment directly with the Visio application.<i></p><p>GlueShape</i> uses the <i>GlueTo</i> method of a cell to attach a connector from one shape to the next. <i>GlueShape</i> glues the EndX cell of the connector (x-coordinate of the end point) to the PinX cell of the shape (x-coordinate of the center of rotation). However, the connector does not draw directly into the center of the shape. Instead, using the PinX cell in <i>GlueTo</i> creates "dynamic glue," which lets the connector attach to the shape along the edge, and lets the connector "walk" along the edge as shapes are moved around. </p><p>Finally, <i>LayoutPage</i> lets Visio rearrange shapes and reroute connectors to produce an aesthetic drawing. The resulting layout is generally good (see <A NAME="rf1"><A HREF="0201cf1.htm">Figure 1</A>), although a few tweaks by hand after the automation is finished often improve the diagram. </p><h3>Metadata</h3><p>Recall that one of my design goals was for GDEPENDS to easily support new file types. I envisioned a plug-in type architecture where the program discovers supported file types during execution. Fortunately, I found an easy solution in the extensible metadata of .NET. </p><p>Metadata is the lifeblood of managed execution in .NET. Metadata facilitates garbage collection, security, versioning, serialization, language interoperability, JIT compiling, and many other run-time services and features. COM also used metadata, but the metadata was not easily extensible and often spread throughout the system. For example, a single COM component might store information in a type library, the Windows registry, and the COM+ catalog. In .NET, all of the metadata for a component lives in the component's assembly. </p><p>Custom attributes let you extend the metadata when needed. For GDEPENDS, I needed such a mechanism to describe the file types a class could parse. The <i>PluginAttribute</i> class, derived from <i>System.Attribute</i> (available electronically; see "Resource Center," page 5), is the custom attribute I wrote for this purpose. <i>PluginAttribute</i> lets a class publicize a file extension and a descriptive string without using a configuration file or registry entry.</p><p>You apply an attribute to a target using a pair of square brackets. For example, the <i>PluginAttribute</i> class has an <i>AttributeUsage</i> attribute defined before the class declaration. The <i>AttributeUsage</i> attribute, defined by .NET, describes the allowable usage for a custom attribute. In this case, the <i>AttributeUsage</i> attribute restricts a <i>PluginAttribute</i> to target only a class declaration. If the compiler finds a <i>PluginAttribute</i> attached to another element (a method or parameter, for example), the compiler generates an error. I also allow multiple <i>PluginAttributes</i> on a single class, for classes that support more than one file extension. </p><h3>The SLN Plug-In</h3><p>The <i>SLNAnalyzer</i> class derives from <i>DependencyAnalyzer</i>. <i>SLNAnalyzer</i> contains an implementation to parse Visual Studio.NET solution files. In <A NAME="rl2"><A HREF="#l2">Listing Two</A>, an attribute specification applies a <i>PluginAttribute</i> to the <i>SLNAnalyzer</i> class. There are a couple of interesting items to note about the attribute specification. First, the <i>Attribute</i> suffix is optional in C#. Second, the attribute specification uses a combination of positional and named parameters. Because the <i>PluginAttribute</i> class has a single constructor with a string parameter, the positional parameter (SLN) is required to satisfy the constructor. The attribute specification can optionally initialize other public properties and fields (such as <i>Description</i>) using a named parameter. </p><p>Parsing a solution file is straightforward. The first section of the file lists all of the projects in the following format: <i>Project(SLN_GUID)=PRJ_NAME,PRJ_CONFIG,PRJ_GUID</i>. From this section, <i>ParseProject</i> extracts PRJ_NAME (the project name) and PRJ_GUID (the project's globally unique identifier), and populates the hash table to map GUIDs to <i>DependencyNode</i>s. The parser makes use of the string class's <i>Split</i> and <i>Trim</i> methods. <i>Split</i> turns a single string into an array of strings based on the string delimiter parameter. <i>Trim</i> can remove whitespace, or any characters specified in an array, from the beginning and end of a string.</p><p>Later in the solution file, a <i>ProjectDependencies</i> section contains the dependencies in the format: <i>P_PRJ_GUID .n=C_PRJ_GUID</i>. The <i>ParseDependencies</i> method extracts the <i>P_PRJ_GUID</i> (the parent's project GUID) and the <i>C_PRJ_GUID</i> (the GUID of the project the parent depends on). The method uses the GUIDs to retrieve the corresponding <i>DependencyNode</i>s from the hash table, then adds the child <i>DependencyNode</i> to the parent project's <i>ArrayList</i> of dependencies. When the method finishes, a complete dependency graph is in memory.</p><p>The final piece of plumbing is a class factory to abstract away the details of creating the correct <i>DependencyAnalyzer</i> during run time. The <i>AnalyzerFactory</i> (available electronically) uses classes from <i>System.Reflection</i> to discover the available plug-ins and create the correct object for a given file extension. </p><p>The application needs to forward a plug-in assembly to the <i>RegisterAssembly</i> method. <i>RegisterAssembly</i> retrieves an array of all exported types in the assembly, and queries each <i>Type</i> object for custom attributes. Since a type may contain multiple custom attributes, the method tests the cast to a <i>PluginAttribute</i> using the C# <i>is</i> keyword. When the method finds a <i>PluginAttribute</i>, it stores away the file extension and the <i>Type</i> object into a hash table. It also adds the custom attribute to an <i>ArrayList</i>. An application can maintain this <i>ArrayList</i> to know the file extensions and descriptions available for selection in a GUI. When the application is ready to create an analyzer, it uses the <i>CreateAnalyzer</i> method. <i>CreateAnalyzer</i> looks up the correct <i>Type</i> for a given file extension and uses the <i>Activator</i> class to create an instance of the <i>Type</i>. The <i>Activator</i> class has the ability to create local objects, remote objects, objects with constructor parameters, and more. </p><h3>The User Interface</h3><p>The WinForms Designer in the .NET IDE is similar to many of the current RAD tools. <A NAME="rf2"><A HREF="0201cf2.htm">Figure 2</A> shows GDEPENDS in design mode. Source code for the main form (less designer-generated code) is available electronically. The first few methods are event handlers invoked by the UI elements. These methods simply forward the calls to other member functions for processing.</p><p>When the form loads, the program calls <i>LoadPlugins,</i> which reads the XML file in <A NAME="rl3"><A HREF="#l3">Listing Three</A> using a typed <i>DataSet</i>. I only briefly describe the <i>DataSet</i> class because a full discussion of data access techniques in .NET is beyond the scope of this article. The IDE can create a typed <i>DataSet</i> given an XSD schema file. Instead of using XPath queries or XML DOM navigation techniques, the typed <i>DataSet</i> lets you view an XML file as a collection of tables, each table with a collection of rows. The XML attributes are columns in each table, and hierarchical XML generates parent/child relationships between tables. With a <i>DataSet</i>, you can easily abstract away the source of your data (<i>DataSet</i>s work equally well with any <i>OleDB</i> provider), and a typed <i>DataSet</i> forces compile errors instead of run-time errors when the underlying schema changes. For GDEPENDS, I asked the IDE to generate an XSD schema for my XML file in <A NAME="rl3"><A HREF="#l3">Listing Three</A>, and then generated a typed <i>DataSet</i> with the name <i>Plugins</i>. <i></p><p>LoadPlugins</i> iterates through the assembly names, fetching them into the application with the static <i>LoadFrom</i> method on the <i>Assembly</i> class. The method also registers each assembly with the <i>AnalyzerFactory</i>, and keeps an <i>ArrayList</i> of all the <i>PluginAttributes</i> found. The method uses the <i>ArrayList</i> to build a file filter for the <i>OpenFileDialog</i> to use when prompting users. The code uses a <i>StringBuilder</i> object for efficient string concatenation. </p><p>When users click on the Open button, control arrives at the <i>OpenFile</i> method. If users select a file, the method retrieves the file extension using the <i>FileInfo</i> class, and asks the <i>AnalyzerFactory</i> to create the correct analyzer object.</p><p>My first iteration of the UI was a form with Open, Graph, and Exit buttons. I quickly realized how many applications have all projects dependent on one or two projects of common code or resources, and I wanted a way to remove the clutter of lines generated in Visio. To help, I added a tree view to the form and allow users to select nodes to mark as hidden; see <A NAME="rf3"><A HREF="0201cf3.htm">Figure 3</A>. </p><p>To display the tree view the application calls <i>PopulateTreeView</i>, which simply iterates the hash table and calls <i>AddNode</i>, passing the top-level <i>TreeNodeCollection</i>. <i>AddNode</i> places the node into the <i>TreeNodeCollection</i> and calls itself recursively to add dependencies of the current node. When users select the Hide button, the <i>HideSelectedNode</i> method searches the dependency collection for a project matching the name of the tree node. The node is then marked as hidden and the method refreshes the tree view. Any rendering function should check the Visible property of a <i>DependencyNode</i> before adding the node to a display.</p><h3>Conclusion</h3><p>.NET introduces a number of new features and paradigms. I believe metadata and custom attributes will drive some unique and interesting applications in the future. For GDEPENDS, the garbage collection and RAD environment certainly reduced the development time and lines of code needed to get GDEPENDS to the current stage. I did miss using type-safe collections with the STL, but overall, the expressiveness of C# should make C++ programmers feel comfortable. The complete source code (available electronically) includes a class for parsing Visual Studio 6 workspace files, and I plan to keep adding to the number of plug-in assemblies for the utility. </p><p></p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>/// &lt;summary&gt;/// A DependencyNode keeps state for a dependency: name, /// visibility, visio shape, and child dependencies/// &lt;/summary&gt;public class DependencyNode{    public DependencyNode(string name)    {        if(name == null)        {            throw new ArgumentNullException();        }        this.name = name;        visible = true;        dependencies = new ArrayList();    }    public string Name    {        get { return name;  }        set { name = value; }    }    public bool Visible    {        get { return visible; }        set { visible = value; }    }    public Visio.IVShape Shape    {        get { return shape; }        set { shape = value; }    }    public ArrayList Dependencies    {        get { return dependencies; }    }    protected string name;    protected bool visible;    protected Visio.IVShape shape;    protected ArrayList dependencies;};</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>/// &lt;summary&gt;/// This custom attribute is applied to classes implementing //  DependencyAnalyzer. It allows class to announce supported file extension./// &lt;/summary&gt;[AttributeUsage(AttributeTargets.Class, AllowMultiple = true)]public class PluginAttribute : System.Attribute{    public PluginAttribute(string fileExtension)    {        this.fileExtension = fileExtension;    }    public string FileExtension    {        get { return fileExtension; }    }    public string Description    {        get { return description; }        set { description = value; }    }    private string fileExtension;    private string description;};</pre><P><A HREF="#rl2">Back to Article</A></P><H4><A NAME="l3">Listing Three</H4><pre>&lt;?xml version="1.0" encoding="utf-8" ?&gt;&lt;Plugins xmlns="http://tempuri.org/Plugins.xsd"&gt;	&lt;Assembly Name="DSWAnalyzer.dll" /&gt;	&lt;Assembly Name="SLNAnalyzer.dll" /&gt;&lt;/Plugins&gt;</pre><P><A HREF="#rl3">Back to Article</A></P></body></html>