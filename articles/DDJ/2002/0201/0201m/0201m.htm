<html><head><title>Jan02: Algorithm Alley</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Optimal EOF Handling With Arithmetic Compression</h1><p><i>Dr. Dobb's Journal</i> January 2002</p><h3>By David A. Scott</h3><I>David is a math teacher at El Paso Community College. He can be contacted at <a href="mailto:dscott@elpasonet.net">dscott@elpasonet.net</a>.</I><hr><p>Arithmetic compression and Huffman compression share a problem that does not appear to be fully solved in any literature &#151; how to end the compression bitstream so that it matches the 8-bit binary granularity of modern filesystems.</p><p>While at first glance this might seem difficult to solve, in truth it is straightforward if you separate the task into small, easily accomplished parts. Furthermore, solving the problem results in an additional benefit that proper file endings for compression can make the compression completely "bijective," or one-to-one. (Bijective algorithms with a compressor <i>C</i> and decompressor <i>D</i> have the interesting property that for any file <i>X, C(D(X))=X</i>. This means that not only can any file be compressed using the algorithm, but any file can be decompressed as well. This property is particularly valuable when compressed files are going to be encrypted because it avoids giving a cracker any clues in the form of invalid compressed files.)</p><DDJADVERTISEMENT INLINE><p>Properly handling the end of the bitstream first requires modeling what is really happening. To this end, I'll focus on arithmetic coding. (For more information, see "Arithmetic Coding and Statistical Modeling," by Mark R. Nelson, <i>DDJ</i>, February 1991.)</p><p>The first level of abstraction is to see if the compressor is looking at a series of symbols followed by an EOF signal from the operating system. For example, a typical compressor reads in the symbols <i>S0:S1:....:Sn:EOF</i> one at a time and passes them to a probability-modeling module. In turn, the probability of the character asks the arithmetic encoder to update the output with new high and low ranges. The encoder's output for each symbol is either the null symbol <i>N</i>, or a series of symbols being defined as 0, 1, or <i>C</i> (for carry).  </p><p>The null symbol represents the case where the arithmetic encoder causes less than 1 bit of information to be output. This is what leads to most of the problems with arithmetic compression since it means that more than one symbol can map to a single bit. But the trick is just to use the token <i>N</i>. When you decompress, you won't have a problem because you will be working on the set of <i>N</i>, <i>C</i>, 0, and 1.</p><p>Now assume you want to change the symbols <i>01001CC:CC:N:N:011CC:EOF</i> into 1s and 0s. The <i>N</i>s aren't a problem since they are dropped. The carry bits are output using the conventional rules for arithmetic coding. If a series of <i>C</i>s is followed by a 1, slide the 1 in front of the <i>C</i>s and change the <i>C</i>s to 0s. If a 0 or EOF follows, slide a 0 in front of the <i>C</i>s and change the <i>C</i>s to 1s. (This is because you are really mapping to a structure that has an infinite number of zeros at the end.) For this example, you now have <i>0100101:11:::11101:10000...</i> EOF is replaced by an infinite number of zeroes. (The ":" characters are the original symbol separators.) </p><p>Now comes the tricky part. Notice that the last symbol is <i>:01CC:</i>. If the last symbol contains a 1 or at least two <i>C</i>s, then the compression at this point is fully reversible. The problem occurs when the last symbol is of the form <i>:C:</i>, <i>:000:</i>, or <i>:N:</i> &#151; you've dropped the EOF marker so if this symbol is of this form, the decompressor would not know that the hidden <i>:N:</i> or <i>:000:</i> (where "000" can be any number of zeroes) was last. </p><p>Working around this problem requires another fix. Although there are several ways to tackle this problem, I use the following for my arithmetic compressor: The trick is that when you line up the symbols in order so that the least-likely symbols are closer to the high end of the probability model and the most-likely symbols are closer to the low end, then all the symbols have at least one 1 bit in their expansion, except maybe the most likely symbol. </p><p>There are two special cases where the output of the arithmetic coder may not have any 1 bits. In the first case, the most-probable symbol has a 0.5 or less chance of occurring. The second case, where the most-probable symbol may have no bits in its arithmetic encoding, is when the first symbol occurs with probability of greater than 0.5 so that the <i>:N:</i> field has a high possibility of being the last token in the first mapping. But notice the next most-probable symbol is always 1 or longer and will contain a 1 in the final mapping to the infinite file.</p><p>So here's the next trick. If the file being compressed ends with the most-probable symbol (and thereby might lack a 1 bit), you add the next most-probable symbol to the file. If the symbol ends with a tail of the most-probable symbol followed by a series of second most probable, you add one more second most-probable symbol to the end of string of the second most-probable symbols. This mapping is reversible so far and the last symbol mapped has at least one 1-bit set. Again, in the example <i>0100101:11:::11101:10000...</i> EOF is replaced by an infinite number.</p><p>Since, in this case, the file didn't end in <i>:C:</i>, <i>:N:</i>, or :000:, you don't need an extra string at the end. Notice that the ":" characters designated as symbol separators are not really needed because on decompression, you are only looking at 0s and 1s. The example now becomes <i>0100101:11:::11101:10000...</i> This is still not a byte-aligned stream, but it is a unique string for any arithmetic compression that knows the next trick. </p><p>If you divide the output stream into bytes with the separator character, it then looks like<i>: 01001011:11110110:00000000:00000000:...</i> Because of the concept of the infinite file, you drop all the trailing <i>:00000000:</i> fields; they are implicitly there. This gives a new stream value of <i>:01001011:11110110:</i>. Finally, this is the compressed output. </p><p>Now that the output is properly aligned, my decoder properly restores the input file as long as it assumes the file ends with an infinite string of zeros.</p><p>For just a bit more savings, there is one trick left to apply. Notice that with this algorithm you have compressed the file to binary, where any combination is possible, except having a 1 in the last bit position. Think of the file as containing three types of symbols &#151; the all 0 symbol ("0"), the leading-1 symbol (":10000000:"), and all the rest (type <i>R</i>). If a files ends with the tail of an all-0 symbol (":00000000:") followed by one or more leading-1 symbol (":10000000:"), then you can chop off the last symbol. </p><h3>Conclusion</h3><p>So is getting a standard arithmetic coder to conform to the definition of bijective worth the effort? I think so, for two compelling reasons:</p><p></p><ul>  <li>First, you know from the Counting Theorem that it isn't possible to compress all files. In fact, most files expand under compression due to gaps created when certain files are not used as possible compressions. Bijective compression makes full use of the file space.  <li>Second, programs such as PGP compress and then encrypt. This not only saves space but helps to increase the Unicity distance. Using most conventional compression algorithms, a brute-force attacker can quickly discard most keys by only testing a few bytes of the input file. The nonbijective file quickly shows itself to be invalid. With a bijective algorithm, attackers can always decompress the input stream, valid or not.</ul><p>To illustrate how you can implement the concepts presented here, I'm providing electronically (see "Resource Center," page 5) a pair of command-line programs &#151; a compressor (aribd.cpp) and decompressor (unaribd.cpp). Instructions on their use is included in the source-code comments.</p><p><b>DDJ</b></p></body></html>