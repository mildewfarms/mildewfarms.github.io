<html><head><title>Jan02: Java Mobile Agents & the Aglets SDK</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Java Mobile Agents &amp; the Aglets SDK</h1><p><i>Dr. Dobb's Journal</i> January 2002</p><h2>Migratory software  for distributed systems</h2><h3>By M. Tim Jones</h3><I>Tim is a software engineer with a background in the development of embedded networked systems. He can be contacted at <a href="mailto:mtj@mtjones.com">mtj@mtjones.com</a>.</I><hr><p>Mobile agents, sometimes referred to as "migratory software," aren't new. In fact, both the concept and a number of implementations have existed since the early 1980s, when operating-system researchers implemented architectures whereby processes could migrate between homogeneous systems. This migration embodied not only the process code, but also its data. The primary use of process migration was for load balancing.</p><p>In the early 1990s, General Magic introduced the Telescript mobile agent framework and with it the term "Mobile Agent." Numerous mobile agent frameworks followed Telescript using languages such as Java, TCL/Tk, and Python.</p><DDJADVERTISEMENT INLINE><p>In this article, I discuss the development of Java mobile agents on Linux using the Aglets framework (<a href="http://www.trl.ibm.com/aglets/">http://www.trl.ibm.com/aglets/</a> and <a href="http://www.aglets.org/">http://www.aglets.org/</a>). I then present a mobile agent that migrates to a number of hosts and performs data collection along the way.</p><h3>Why Are Mobile Agents Important?</h3><p>Mobile agents (MA) provide an interesting approach to solving certain classes of problems. For instance, consider data collection problems where the data is remotely located. Mobile agents can migrate to the remote nodes to perform the data collection and then reduce the collected data via filtering or compression. In this way, network bandwidth savings are realized. For remote databases, mobile agents can encapsulate queries and bundle the return of the results. This may sound like a problem easily solved by a simple client/server architecture, but what happens if the nodes are regularly disconnected from the network? In the typical client/server architecture, once the client goes down, the results are retried and then dropped by the server. In the MA model, mobile agents wait at the server until the client is available, then migrate back to provide their results.</p><p>Another promising application domain involves extensible servers, where users migrate mobile agents to a remote server that represents them in terms of personalization. The remote agent then contacts users whenever anything occurs that may be of interest to them.</p><p>A final example is the dynamic deployment of software. Consider an environment made up of laptop and palmtop computers. Ensuring that all have up-to-date software is problematic, and their disconnected nature makes it difficult for administrators to collectively manage them. If applications are bundled within mobile agents, then the agent portion of the application can keep in touch with a remote server to ensure proper version consistency while the bundled application performs its intended function at the remote host.</p><h3>Linux and the Aglets SDK </h3><p>Developed by IBM's Tokyo Research Lab and freely available at <a href="http://www.trl.ibm.com/aglets/download.html">http://www.trl.ibm.com/aglets/download.html</a>, the Aglets SDK is an open-source SDK for Java 1.1. The Aglets SDK contains Java classes to build aglets, documentation (in HTML format), source examples of aglets, and the Tahiti Aglets Server. When you've downloaded the SDK, you can use <A NAME="re1"><A HREF="0201de1.htm">Example 1</A>(a) to install the SDK, creating the subdirectory /usr/local/src/aglets1.1.0. To configure the Aglets SDK, you "cd" into the ./aglets1.1.0/bin subdirectory and edit the agletsd shell script. This script starts the Tahiti Aglets Server that is useful to start and debug aglets. At the beginning of the script, update the JDK_HOME symbol to point to your JDK subdirectory and the AGLET_HOME symbol to point to your aglet distribution. <A NAME="re1"><A HREF="0201de1.htm">Example 1</A>(b) shows how I configured my file.</p><p>This release of the Aglets SDK requires a JDK 1.1.8 that can be downloaded from Sun for Windows (<a href="http://java.sun.com/">http://java.sun.com/</a>), and for Linux, from the Blackdown site (<a href="http://www.blackdown.org/">http://www.blackdown.org/</a>) for your particular architecture. I've used the JDK 1.1.6, but experienced problems when mixing the two versions. Consequently, I advise sticking with JDK 1.1.8.</p><p>Finally, to start an aglet server, execute the agletsd script you previously modified (./agletsd). This first asks you to enter a user name and password for the server. Once this information is reconfirmed, the Tahiti Aglets Server window appears. From this window, you can create aglets, dispatch them to remote nodes, and bring them back and delete them. Log utilities also exist to monitor server activity and memory usage of the server.</p><h3>Mobility</h3><p>What gives aglets the ability to migrate within a network is the Agent Transport Protocol (ATP) &#151; the conduit that communicates an agent and its state to a remote server. For mobile agents to migrate themselves autonomously requires the creation of a "ticket." Tickets are created with a destination, and using the <i>dispatch</i> call with a newly created <i>ticket</i> serializes and then migrates the aglet to the destination. Upon arriving at the remote server, the aglet is restarted with its data intact; see <A NAME="re2"><A HREF="0201de2.htm">Example 2</A>(a). All data within the aglet is also transferred, allowing the aglet to be statefully driven. Migrating all data with the aglet may be unnecessary because some data may only be used for location operations. In these cases, you can declare an object as <i>transient</i>, as in <A NAME="re2"><A HREF="0201de2.htm">Example 2</A>(b). When the aglet is migrated, the instance of this object is left behind and created new at the destination.</p><h3>Sample Problem</h3><p>To illustrate, I now present a simple application where a mobile agent visits a number of nodes and collects data at each one. When the agent returns to the originating host, a Java AWT window is presented with the data collected along the way.</p><p>The <i>collector</i> class in <A NAME="rl1"><A HREF="#l1">Listing One</A> is based on the <i>Aglets</i> class that provides a rich set of functions for both mobility and communication. <A NAME="rl2"><A HREF="#l2">Listing Two</A> is a makefile for building the aglet.</p><p>The first method in the <i>collector</i> class is a callback that lets the Aglets framework notify you when important events occur. In this case, you want to know when your aglet is first created (via the <i>OnCreation</i> callback). In this method, you create objects to be used during the life of this aglet. Also, in this method, you register the desire to receive events when the aglet arrives at a node via the <i>OnArrival</i> callback. You use this method to perform data collection upon arriving at a node.</p><p>The <i>getCurrentNodeInfo</i> and <i>parseItem </i>methods gather data at the node and parse information from the Linux proc filesystem. For data gathering, I use the <i>System</i> class to gather OS/JVM information and the Linux proc filesystem to gather network throughput information.</p><p>The final method, <i>run</i>, is invoked each time the aglet is started on a node. So when it is initially created, the <i>run</i> method is called. When the aglet migrates to another node, the <i>run</i> method is called again. Therefore, you create some state information to let us know what you're doing. This simple state machine is performed sequentially, and is used to migrate to my "Alto" node (192.168.1.5), back to the originating node "Plato" (192.168.1.7), and then finally to emit the data to the user; see <A NAME="rf1"><A HREF="0201df1.htm">Figure 1</A>. Each hop is performed using the <i>ticket/dispatch</i> method. </p><p>The <i>resultsWindow</i> class extends <i>Frame</i> to provide a simple <i>TextArea</i> to display the collected information to users.</p><p>The log window (available through the Tahiti Aglets Server) provides useful information for debugging aglets.</p><p>IBM's Aglets framework also provides a number of other classes that simplify migration to a number of hosts. Aglets may define an itinerary that specifies a number of hosts to visit, and a message to send to the aglet when arriving at a particular host. In this way, the state machine is replaced with a host/message pair and no state data is necessary at the aglet level. As the aglet visits each host, the unique message is sent from the framework to the aglet that in turn drives the aglet to perform whatever activities were necessary at the node.</p><h3>The Future</h3><p>A current interesting area that may benefit from mobile agents is the deployment of dynamic services to remote devices. The Open Service Gateway Initiative (OSGI) provides a Java framework for the distribution of Java services to remote nodes and shares some of the same technologies that have existed within mobile agent frameworks for some time.</p><p>One interesting application is the encapsulation of network services within mobile agents. The mobile agent provides the migration and installs accounting and a service onto a remote node. The mobile agent can determine, prior to install, if the remote environment is satisfactory for the service (all necessary services are available to it). Once installed, the mobile agent deploys the service and then monitors it at the remote location. This is similar to the analogy of a technician coming to your office to install a piece of equipment. But after the equipment is installed, the technician remains to monitor the equipment, communicate with the office for reconfiguration, or recall.</p><h3>Conclusion</h3><p>Mobile agent frameworks aren't a panacea for the growing complexity in our networked systems designs, but they do provide another way to solve certain classes of problems and can be a useful architectural addition to our design solutions toolbox.</p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>// collector.java - Example Aglet.// M. Tim Jones &lt;mtj@mtjones.com&gt;import com.ibm.aglet.*;import com.ibm.aglet.event.*;import java.io.*;import java.awt.*;import java.awt.event.*;import java.net.MalformedURLException;public class collector extends Aglet {  StringBuffer buffer;  int stage = 0;  //--------------------------------------------------------------------  // onCreation()  public void onCreation(Object ini) {    buffer = new StringBuffer();    buffer.append("Collected Information:\r\n\r\n");    addMobilityListener(new MobilityAdapter() {      public void onArrival(MobilityEvent e) {        getCurrentNodeInfo();      }    });  }  //--------------------------------------------------------------------  // getCurrentNodeInfo()  private void getCurrentNodeInfo()  {    BufferedReader inReader;    String line;    String iface;    buffer.append( "  Node " +                     getAgletContext().getHostingURL().toString()+" - \r\n");    buffer.append( "    OS : " +                     System.getProperty("os.name") + " / " +                    System.getProperty("os.version") + " / " +                    System.getProperty("os.arch")+"\r\n" );    buffer.append( "    Java Vers : " +                     System.getProperty("java.version")+"\r\n" );    try {      inReader = new BufferedReader(new FileReader("/proc/net/dev"));      do {        line = inReader.readLine();        if (line != null) {          iface = line.substring(0, 6).trim();          if (iface.compareTo("eth0") == 0) {            buffer.append(  "    " + line.substring(0, 6).trim() + ":" +                             "   Rx Bytes : " + parseItem(line, 1) +                             "   Tx Bytes : " + parseItem(line, 9) + "\r\n");          }        }      } while (line != null);    } catch (Exception excpt) {       excpt.printStackTrace();    }    buffer.append("\r\n");  }  private String parseItem(String line, int number) {    int retValue = 0, startIndex = 7, endIndex = 0;    if ((line != null) &amp;&amp; ( number &gt; 0)) {      while (line.charAt(startIndex) == ' ') startIndex++;      number--;      while (number-- != 0) {        // Find the start of a numeric entry        while (line.charAt(startIndex) == ' ') startIndex++;        // Skip a number        while (line.charAt(startIndex) != ' ') startIndex++;        while (line.charAt(startIndex) == ' ') startIndex++;      }      endIndex = startIndex + 1;      // Find the end of a numeric entry      while (line.charAt(endIndex) != ' ') endIndex++;      return(line.substring(startIndex, endIndex));    }    return(null);  }  //--------------------------------------------------------------------  // run()  public void run() {    // Define a simple Quality of Communication    QoC qoc = new QoC(QoC.NORMALINTEGRITY, QoC.NOCONFIDENTIALITY);    try {      if (stage == 0) {        Ticket ticket = new Ticket("atp://192.168.1.5/", qoc);        if (ticket == null) {          System.out.println("Couldn't get ticket to alto");          System.exit(-1);        }        try {          stage = 1;          dispatch(ticket);        } catch(Exception excpt) {          excpt.printStackTrace();        }      } else if (stage == 1) {        Ticket ticket = new Ticket("atp://192.168.1.7/", qoc);        stage = 2;        if (ticket == null) {          System.out.println("Couldn't get ticket to plato");          System.exit(-1);        }        try {          dispatch(ticket);        } catch(Exception excpt) {          excpt.printStackTrace();        }      } else if (stage == 2) {        resultsWindow window = null;        window = new resultsWindow();        window.appendText(buffer);        window.pack();        window.show();        stage = 3;      }    } catch(MalformedURLException excpt) {      excpt.printStackTrace();      System.exit(-1);    }  }}class resultsWindow extends Frame implements ActionListener {  TextArea text = new TextArea();  public void actionPerformed(ActionEvent e) {    Object source = e.getSource();  }  public resultsWindow() {    super("Results");    setLayout(new BorderLayout(5, 5));    add("Center", text);    text.setEditable(false);    addWindowListener(new WindowAdapter() {      public void windowClosing(WindowEvent e) {        setVisible(false);      }    });  }  public void appendText(StringBuffer str) {    text.append( str.toString() + "\r\n");  }}</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre># MakefileJDK_HOME = /usr/java/jdk118_v1JAVAC = $(JDK_HOME)/bin/javacCLASSPATH = /usr/local/src/aglets1.1.0/src:$(JDK_HOME)/lib/classes.zipAGLETSLIBPATH = /usr/local/src/aglets1.1.0/libAGLETSPUBPATH = /usr/local/src/aglets1.1.0/publicJAVACPUB = $(JAVAC) -deprecation -classpath $(AGLETSLIBPATH):                        $(AGLETSPUBPATH):$(CLASSPATH) -d $(AGLETSPUBPATH)migtest:    $(JAVACPUB) collector.java</pre><P><A HREF="#rl2">Back to Article</A></P></body></html>