<html><head><title>May02: Java Q&A</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>How Do I Correctly  Implement the equals() Method?</h1><p><i>Dr. Dobb's Journal</i> May 2002</p><h3>By Tal Cohen</h3><I>Tal is a researcher in IBM's Haifa Research Labs in Israel. He can be contacted at <a href="mailto:tal@forum2.org">tal@forum2.org</a>.</I><hr><p>The Java <i>equals() </i>method, which is defined in <i>java.lang.Object</i>, is used for instance equality testing (as opposed to reference equality, which is tested using the == operator). Consider, for example, these two assignments:</p><blockquote><p>Date d1 = new Date(2001, 10, 27);</p><DDJADVERTISEMENT INLINE><p>Date d2 = new Date(2001, 10, 27);</p></blockquote><p>In this case, <i>d1 == d2</i> returns False (since == tests for reference equality, and the two variables are references to different objects). However, <i>d1.equals(d2)</i> returns True.</p><p>The default implementation of <i>equals()</i> is based on the == operator: Two objects are equal if and only if they are the same object. Naturally, most classes should define their own alternative implementation of this important method.</p><p>However, implementing <i>equals()</i> correctly is not straightforward. The <i>equals()</i> method has a contract that says the equality relation must meet these demands:</p><ul>  <li>It must be reflexive. For any reference <i>x</i>, <i>x.equals(x)</i> must return True.  <li>It must be symmetric. For any two nonnull references <i>x</i> and <i>y</i>, <i>x.equals(y)</i> should return the exact same value as <i>y.equals(x)</i>.  <li>It must be transitive. For any three references <i>x</i>, <i>y</i>, and <i>z</i>, if <i>x.equals(y)</i> and <i>y.equals(z)</i> are True, then <i>x.equals(z)</i> must also return True.  <li>It should be consistent. For any two references <i>x</i> and <i>y</i>, <i>x.equals(y)</i> should return the same value if called repeatedly (unless, of course, either <i>x</i> or <i>y</i> were changed between the repeated invocations of <i>equals()</i>).  <li>For any nonnull reference <i>x</i>, <i>x.equals(null)</i> should return False.</ul><p>This doesn't sound complicated: The first three items are the natural mathematical properties of equality, and the last two are trivial programmatic requirements. It looks like any implementation based on simple field-by-field comparison would do the trick. For example, in <A NAME="rl1"><A HREF="#l1">Listing One</A> the class <i>Point</i> represents a point in two-dimensional space, with a suggested implementation for the <i>equals()</i> method. At first glance, it looks as though <A NAME="rl1"><A HREF="#l1">Listing One</A> meets all five demands placed by the contract:</p><ul>  <li>It is reflexive, since whenever the parameter <i>o</i> is actually <i>this</i> (which is what happens when one invokes it using <i>x.equals(x)</i>), the fields match and the result is True.  <li>It seems symmetric. If some <i>Point</i> object <i>p1</i> finds its fields are equal to those of some other <i>Point</i> object <i>p2</i>, then <i>p2</i> would also find that its own fields are equal to those of <i>p1</i>. For example, after the two assignments:</ul><blockquote><p>Point p1 = new Point(1, 2);</p><p>Point p2 = new Point(1, 2);</p></blockquote><p>both <i>p1.equals(p2)</i> and <i>p2.equals(p1)</i> return True. If, on the other hand, <i>p2</i> is different than <i>p1</i>, both calls return False.</p><ul>  <li>It seems transitive, for the same reasons.  <li>It is clearly consistent.  <li>Any call of the form <i>x.equals(null)</i> returns False, thanks to the test at the beginning of the code: If the parameter is not an instance of the class <i>Point</i>, the method returns False immediately. Since, in particular, null is not an instance of <i>Point</i> (nor indeed of any other class), the condition is met.</ul><p>However, this is a na&iuml;ve implementation. As Joshua Bloch shows in his book <i>Effective Java Programming Language Guide</i> (Addison-Wesley, 2001), things get much more complex when inheritance is involved. </p><p>Bloch presents the class <i>ColorPoint</i> (<A NAME="rl2"><A HREF="#l2">Listing Two</A>), which extends <i>Point</i> and adds an aspect (namely, a new field). If <i>ColorPoint</i> implements <i>equals()</i> similarly to its superclass <i>Point</i>, symmetry is violated. Again, the implementation seems straightforward and correct. The problem arises when two objects are involved, each of a different class:</p><blockquote><p>ColorPoint p1 = new ColorPoint(1, 2, Color.RED);</p><p>Point p2 = new Point(1, 2);</p></blockquote><p>Now, <i>p2.equals(p1)</i> returns True, since the two fields <i>p2'</i>s <i>equals()</i> method compares, <i>x</i> and <i>y</i>, are indeed equal. Yet <i>p1.equals(p2)</i> returns False because <i>p2</i> is not an instance of the <i>ColorPoint</i> class.</p><p>It is important to understand that an incorrect implementation of <i>equals()</i>, like that just presented, would cause problems in many unexpected places; for example, when the objects are used in various collection classes (that is, in their containment tests). And you have just seen that this simple implementation does not provide symmetry.</p><p><A NAME="rl3"><A HREF="#l3">Listing Three</A>, an alternative implementation of <i>equals()</i>, does meet the symmetry requirement. While at first it might seem a better solution, Bloch shows that it is broken, too. Symmetry is indeed preserved. <i>p1</i> and <i>p2</i> (from the earlier example) would both provide the same answer when asked if one equals the other. However, this implementation violates the demand for "transitivity." To see how, add a third reference, <i>p3</i>:</p><blockquote><p>ColorPoint p3 = new ColorPoint(1, 2, Col or.BLUE);</p></blockquote><p>In this case, <i>p1.equals(p2)</i> returns True, since <i>p1</i> realizes <i>p2</i> is not a <i>ColorPoint</i> and performs a color-blind comparison. <i>p2.equals(p3)</i> also returns True, since <i>p2</i>, being a simple <i>Point</i>, compares only the <i>x</i> and <i>y</i> fields and finds them to be equal. Transitivity demands that if <i>a=b</i> and <i>b=c</i>, then <i>a=c</i> as well. But in this case, even though <i>p1.equals(p2)</i> and <i>p2.equals(p3)</i>, the call <i>p1.equals(p3)</i> returns False.</p><p>One way to avoid the problem is to ignore any fields added in subclasses. This way, <i>ColorPoint</i> inherits the implementation of <i>equals()</i> provided by <i>Point</i>, and doesn't override it. This solution does meet all the contract demands for <i>equals()</i>. However, it is hardly a useful equality test; for example, <i>p1.equals(p3)</i> returns True, even though each point has a different color.</p><p>Bloch claims that "It turns out that this is a fundamental problem of equivalence relations in object-oriented languages. There is simply no way to extend an instantiable class and add an aspect while preserving the equals contract." He suggests that programmers use composition rather than inheritance to work around this problem. Taking this approach, the <i>ColorPoint</i> class would not extend <i>Point</i>, but rather include a field of that type, like <A NAME="rl4"><A HREF="#l4">Listing Four</A>. </p><p>Is this the only solution? Not really. The <i>Point</i> class can be extended, adding an aspect, while preserving the <i>equals()</i> contract. The basic idea is this: For two objects to be equal, both must agree that they are equal. To prevent endless recursion during the mutual verification, you define a protected helper method, <i>blindlyEquals()</i>, which compares fields blindly. The <i>equals()</i> method then verifies that both objects agree that they are blindly equal to each other; see <A NAME="rl5"><A HREF="#l5">Listing Five</A>. Note how the implementation of <i>blindlyEquals()</i> is simply the original implementation of <i>equals()</i>. However, <i>blindlyEquals()</i> is not bound by the <i>equals()</i> contract. By itself, it does not provide a symmetric comparison, but it does provide <i>equals()</i> with the services it needs to fully meet the contract demands.</p><p>In subclasses, you override <i>blindlyEquals()</i> only, leaving <i>equals()</i> unchanged. <A NAME="rl6"><A HREF="#l6">Listing Six</A>, therefore, is a proper implementation of the class <i>ColorPoint</i>. Again, the implementation of <i>blindlyEquals()</i> is the original, nonsymmetric attempt to implement <i>equals()</i>. The <i>equals()</i> method itself is inherited from <i>Point</i>, and not overridden.</p><p>It is easy to see that this new implementation is both symmetric and transitive, as well as meeting all other demands placed by the <i>equals()</i> contract. In particular, when using the three objects defined in the previous examples:</p><ul>  <li><i>p2.blindlyEquals(p1)</i> returns True, but <i>p1.blindlyEquals(p2)</i> returns False. Since <i>equals()</i> checks both ways, both <i>p1.equals(p2)</i> and <i>p2.equals(p1)</i> return False.  <li>Since <i>p1.equals(p2)</i> returns False (and <i>p2.equals(p3)</i> returns False as well), the transitivity demand does not hold in this case (<i>a</i><IMG SRC="noteq.gif"><i>b</i> and <i>b</i><IMG SRC="noteq.gif"><i>c</i> means you do not know in advance if <i>a=c</i> or not).</ul><p>It can be mathematically proven that symmetry and transitivity always hold with this implementation. The symmetry part is easy: For any two references <i>x</i> and <i>y</i>, <i>x.equals(y)</i> and <i>y.equals(x)</i> execute the same code (calling both <i>x.blindlyEquals(y)</i> and <i>y.blindlyEquals(x)</i>, although in a different order). Transitivity can be proven using <i>reductio ad absurdum</i>. And of course, the other three contract demands &#151; reflexivity, consistency, and returning False when tested on null &#151; are also met.</p><p>The technique presented here can be applied to any object hierarchy you define in Java. That <i>equals()</i> itself is never overridden means it would have been best if this implementation was part of the standard <i>java.lang.Object()</i> class, along with a default implementation of <i>blindlyEquals()</i>, which could be easily overridden by each subclass. However, since this change in the Java standard libraries is not likely to occur anytime soon, we will have to be content with manually including it in programs. </p><p>In short, whenever you define a new class, a definition of <i>blindlyEquals()</i> must be included as a nonsymmetric comparison operation, and an implementation of <i>equals()</i> (as presented here) should be added. Then, all subclasses of this newly defined class need only override <i>blindlyEquals()</i> to provide a complete, contract-abiding <i>equals()</i> comparison.</p><p>The method presented here can be used in any object-oriented language, and does not rely on run-time type information (other than the <i>instanceof</i> operator, which is required for any implementation of <i>equals()</i>). It does incur a price on performance, but a relatively minor one: The equality test is repeated twice, but only if the two objects are indeed equal. A few simple modifications can reduce the cost significantly. For an additional discussion, please visit <a href="http://www.forum2.org/tal/equals.html">http://www.forum2.org/tal/equals.html</a>.</p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>class Point {    private int x;    private int y;    // (obvious constructor omitted...)    public boolean equals(Object o) {        if (!(o instanceof Point))            return false;        Point p = (Point)o;        return (p.x == this.x &amp;&amp; p.y == this.y);    }} </pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two </H4><pre>class ColorPoint extends Point {    private Color c;    // (obvious constructor omitted...)    public boolean equals(Object o) {        if (!(o instanceof ColorPoint))            return false;        ColorPoint cp = (ColorPoint)o;        return (super.equals(cp) &amp;&amp; cp.color == this.color);    }} </pre><P><A HREF="#rl2">Back to Article</A></P><H4><A NAME="l3">Listing Three</H4><pre>class ColorPoint extends Point {    private Color c;    // (obvious constructor omitted...)    public boolean equals(Object o) {        if (!(o instanceof Point))            return false;        // if o is a normal Point, do a color-blind comparison:        if (!(o instanceof ColorPoint))            return o.equals(this);        // o is a ColorPoint; do a full comparison:        ColorPoint cp = (ColorPoint)o;        return (super.equals(cp) &amp;&amp; cp.color == this.color);    }} </pre><P><A HREF="#rl3">Back to Article</A></P><H4><A NAME="l4">Listing Four</H4><pre>class ColorPoint {    private Point point;    private Color color;    // ...etc.} </pre><P><A HREF="#rl4">Back to Article</A></P><H4><A NAME="l5">Listing Five</H4><pre>class Point {    private int x;    private int y;    protected boolean blindlyEquals(Object o) {        if (!(o instanceof Point))            return false;        Point p = (Point)o;        return (p.x == this.x &amp;&amp; p.y == this.y);    }    public boolean equals(Object o) {        return (this.blindlyEquals(o) &amp;&amp; o.blindlyEquals(this));    }} </pre><P><A HREF="#rl5">Back to Article</A></P><H4><A NAME="l6">Listing Six</H4><pre>class ColorPoint extends Point {    private Color c;    protected boolean blindlyEquals(Object o) {        if (!(o instanceof ColorPoint))            return false;        ColorPoint cp = (ColorPoint)o;        return (super.blindlyEquals(cp) &amp;&amp;         cp.color == this.color);    }} </pre><P><A HREF="#rl6">Back to Article</A></P></body></html>