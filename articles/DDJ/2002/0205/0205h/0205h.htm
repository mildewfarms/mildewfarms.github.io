<html><head><title>May02: Programmer's Toolchest</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Examining  RubyCocoa</h1><p><i>Dr. Dobb's Journal</i> May 2002</p><h2>Mac OS X programming with Ruby</h2><h3>By Chris Thomas</h3><I>Chris is a system software engineer who has contributed to Apple's Carbon framework for Mac OS X. He can be reached at <a href="mailto:ruby@cjack.com">ruby@cjack.com</a>.</I><hr><p>Apple's Mac OS X melds the best features from several disparate operating systems and environments, including BSD UNIX, the Mach microkernel, and classic Mac OS. However, one of the more interesting technologies in the Mac OS X melting pot is Cocoa, an application framework derived from what was originally the NeXT Application Kit &#151; a powerful object-oriented, user-interface framework (<a a href="http://developer.apple.com/techpubs/macosx/Cocoa/CocoaTopics.html">http://developer.apple.com/techpubs/macosx/Cocoa/CocoaTopics.html</a>). You can use Cocoa to create applications that are at once useful, beautiful, unique, and familiar. Cocoa is solidly grounded in the model-view-controller design pattern, which lets you not only create sophisticated applications, but successfully maintain them over time.</p><p>Every copy of Mac OS X ships with developer tools such as the Project Builder IDE and Interface Builder. Together with Cocoa, these tools give Mac OS X users a powerful platform for rapid application development.</p><DDJADVERTISEMENT INLINE><p>The Cocoa framework is composed of two subframeworks: </p><ul>  <li>Foundation is a useful set of building-block objects for interacting with the underlying operating system, such as string, file, and thread classes.   <li>AppKit is a collection of UI objects that applications use to implement the Mac OS X GUI. </ul><p>Normally, both Cocoa subframeworks are programmed using Objective-C, a Smalltalk influenced, object-oriented variant of C (<a href="http://developer.apple.com/techpubs/macosx/Cocoa/ObjectiveC/index.html">http://developer.apple.com/techpubs/macosx/Cocoa/ObjectiveC/index.html</a>). The Objective-C run-time support library lets classes and methods be added at run time, and provides facilities for introspection through a programming interface that provides access to the internal data structures of Objective-C class definitions. These Objective-C run-time APIs can be used to admit other OO languages with dynamic method dispatch capabilities into the Cocoa programming environment. Apple provides bridge layers for programming Cocoa in Java and in AppleScript.</p><p>Enter RubyCocoa. Ruby, created by Yukihiro Matsumoto, is an interpreted, strongly typed, fully object-oriented language (see "Programming in Ruby," by Dave Thomas and Andy Hunt, <i>DDJ</i>, January 2001 and <a href="http://www.ruby-lang.org/">http://www.ruby-lang.org/</a>). Ruby makes OO programming easy and enjoyable without placing arbitrary constraints on you. RubyCocoa, developed by Hisakuni Fujimoto, is a combination Mac OS X framework and Ruby extension that provides a bridge between the Objective-C implementation of Cocoa and the Ruby language (<a href="http://www.imasy.or.jp/~hisa/mac/rubycocoa/INDEX.en.html">http://www.imasy.or.jp/~hisa/mac/rubycocoa/INDEX.en.html</a>).</p><p>Ruby is a powerful productivity aid and can speed up development manyfold. But since the Ruby interpreter is currently not very fast, performance-critical code should still be written in C. RubyCocoa is well suited to prototypes and simple custom applications. There currently isn't a packaging mechanism that lets you create a standalone RubyCocoa application you can ship to end users; RubyCocoa requires each user to have both Ruby and RubyCocoa installed.</p><h3>So What Can You Do with RubyCocoa?</h3><p>With RubyCocoa, you can do just about anything in Ruby that you can do in Objective-C. Additionally, Ruby provides many benefits to Cocoa programmers, aside from Ruby's many inherently useful features (such as Perl-like regular expressions, infinitely large integer data types, and iterators).</p><p>From a language perspective, Ruby's primary strength in combination with Cocoa is that it removes the need to perform the most tedious tasks of Objective-C programming. For example, Objective-C objects allocated from Ruby are garbage collected. Garbage collection eliminates the need to track down memory leaks and crashes related to dangling object pointers, tasks that are frequent debugging headaches even for experienced Cocoa programmers.</p><p>Ruby also removes the need to write most accessor functions, another tedious, time-consuming task in Cocoa. In Ruby, the <i>attr_writer</i>, <i>attr_reader</i>, and <i>attr_accessor</i> functions do all of the work of creating the accessors, while still letting you change the underlying implementation without impacting clients of your class.</p><p>From a run-time perspective, Ruby lets you write applications quickly. Because there is no need to compile and link the program, you can skip the most time-consuming part of the application build process. The downside is that errors are discovered at run time.</p><h3>Hello, Ruby Baby</h3><p><A NAME="rl1"><A HREF="#l1">Listing One</A>, which illustrates use of Cocoa from Ruby, uses RubyCocoa to create a window with a transparent background displaying a text message. This is a simple Cocoa program that demonstrates some basic features of RubyCocoa. It uses a single custom view class that overrides a single method, with a small amount of code to create the window and start the application's event loop.</p><p>Due to constraints imposed by the Mac OS X UI frameworks, a small amount of bootstrap C code (<A NAME="rl2"><A HREF="#l2">Listing Two</A>) is required to start up the RubyCocoa framework run-time and start the Ruby interpreter running. Although the actual code is in C, this file has the ".m" Objective-C file extension because it might reference headers containing Objective-C class declarations.</p><p>This example is straightforward: Method calls basically map directly between Ruby and Objective-C, one-to-one. </p><h3>Using RubyCocoa</h3><p>All Cocoa objects are reference counted. When first allocated, objects have a reference count of 1. Calling an object's <i>retain</i> method increments the reference count by 1; calling its <i>release</i> method decrements the reference count by 1. When the reference count reaches zero, <i>release</i> calls the <i>dealloc</i> method to deallocate the object. </p><p>Reference counting lets multiple objects safely reference the same object. Without reference counting, one object might deallocate the referenced object without notifying other objects, leaving the other objects with an invalid reference. However, with reference counting, it is easy to get into situations where two objects both reference each other and can thus never be deallocated &#151; a circular reference. This is one reason why garbage collection is useful &#151; objects are kept allocated only as long as they are actually referenced.</p><p>In Objective-C, you instantiate an object by sending the <i>alloc</i> message to the object that represents the class, then by sending an <i>init</i> message to the resulting object; see <A NAME="re1"><A HREF="0205he1.htm">Example 1</A>(a). When using Objective-C objects in RubyCocoa, you do the same thing; see <A NAME="re1"><A HREF="0205he1.htm">Example 1</A>(b). When you're done with the object in Objective-C, you release it, as in <A NAME="re1"><A HREF="0205he1.htm">Example 1</A>(c). In Ruby, all Objective-C objects that are referenced by Ruby code are associated with Ruby wrapper objects, and when the associated Ruby object is released by the Ruby garbage collector, the Objective-C object is released as well. There is no need to release or retain objects in RubyCocoa.</p><h3>Method Names</h3><p>Calling a method in Objective-C requires you to perform some simple translation from Objective-C syntax into Ruby. In Objective-C, each argument in a method call is separated by colons and segments of the name of the method; see <A NAME="re2"><A HREF="0205he2.htm">Example 2</A>(a).</p><p>Ruby methods have no colons and use a C-like comma-separated form for arguments, so RubyCocoa translates Objective-C method names into Ruby using a different form, replacing the colons with underscores, as in <A NAME="re2"><A HREF="0205he2.htm">Example 2</A>(b). For convenience, you can leave off trailing underscores; see <A NAME="re2"><A HREF="0205he2.htm">Example 2</A>(c).</p><p>Finally, RubyCocoa provides a form that lets you preserve some semblance of the Objective-C flavor and break up extremely long method names. You can pass each portion of the Objective-C selector following the initial portion to the function as a Ruby symbol; see <A NAME="re2"><A HREF="0205he2.htm">Example 2</A>(d).</p><h3>Subclassing</h3><p>RubyCocoa exports all of Cocoa through a Ruby module called OSX. You can directly subclass Cocoa classes, override methods, and call superclass method implementations. </p><pre><p>class RubyDocument &lt; OSX::NSDocument</p>end</pre><p>To override an Objective-C method in Ruby, use the <i>ns_overrides</i> declaration to tell RubyCocoa to register the method with the Objective-C run time:</p><pre><p>class RubyDocument &lt; OSX::NSDocument</p>   ns_overrides :documentNibName</p><p>   def documentNibName</p><p>      "MyDocument.nib"</p><p>   end</p>end</pre><p>To call an Objective-C superclass's version of a method, prefix the method name with <i>super</i>_:</p><pre><p>def windowControllerDidLoadNib(sender)</p>super_windowControllerDidLoadNib(sender)</p><p>end</p></pre><h3>Parameter Conversion</h3><p>When you pass a Ruby string to an Objective-C method, RubyCocoa automatically converts the string into an <i>NSString</i>. RubyCocoa uses the type information of the Objective-C method to perform automatic data conversion on all other basic data types. </p><p>RubyCocoa cannot currently handle arbitrary unions or data structures, so certain commonly used data structures (such as <i>NSRect</i>, <i>NSPoint</i>, and <i>NSRange</i>) are handled as special cases. RubyCocoa defines these classes in Ruby, and you allocate them using the standard Ruby <i>new</i> method; see <A NAME="re3"><A HREF="0205he3.htm">Example 3</A>(a).</p><p>RubyCocoa can automatically convert arrays to <i>NSRect</i>s and <i>NSPoint</i>s, which simplifies the task of defining these structures inline; see <A NAME="re3"><A HREF="0205he3.htm">Example 3</A>(b). Also, Ruby ranges are converted automatically to <i>NSRange</i> data structures; see <A NAME="re3"><A HREF="0205he3.htm">Example 3</A>(c).</p><h3>Functions and Data Types</h3><p>Cocoa defines a small number of C functions and data types (in addition to those just mentioned), and RubyCocoa provides these within the OSX module as well. Global variables such as <i>NSFontAttributeName</i> are implemented as functions within the OSX module, so you access them like functions (<i>OSX.NSFontAttributeName</i>). Cocoa C functions can be accessed just like normal module functions (<i>OSX.NSBeep</i>). RubyCocoa implements <i>enum</i> values as Ruby constants (<i>OSX::NSNotFound</i>).</p><h3>Exceptions</h3><p>RubyCocoa translates exceptions raised by Objective-C code into Ruby exceptions. The class <i>OSX::OCException</i> contains information about the original Objective-C exception. It is a simple wrapper for the Cocoa <i>NSException</i> class.</p><h3>Ruby and Interface Builder</h3><p>When you load an Interface Builder file ("nib," a historical abbreviation for "NeXT Interface Builder"), the Cocoa nib loading code asks the Objective-C run time for pointers to the instance variables corresponding to the outlets connected to the views in the nib. It sets the value of each outlet instance variable to the corresponding object instantiated from the nib.</p><p>To support nib files, RubyCocoa provides the <i>ib_outlets</i> declaration, which adds specified instance variables to the Objective-C run time so that the nib loading code can find them.</p><pre><p>class RubyDocument &lt; OSX::NSDocument</p>   ns_overrides :documentNibName</p><p>   ib_outlets   :textView</p><p>   def documentNibName</p><p>     "RubyDocument.nib"</p><p>   end</p><p>end</p></pre><h3>A Simple Test Editor in Ruby</h3><p>MyDocument.rb (available electronically; see "Resource Center," page 5) is a minimal complete text editor written entirely in Ruby (see <A NAME="rf1"><A HREF="0205hf1.htm">Figure 1</A>). This example illustrates some of the features of the Cocoa framework, the use of RubyCocoa in a real application, and some capabilities of pure Ruby that can be used to enhance Cocoa. In addition to basic styled text editing, this application contains a basic incremental search feature, similar to that seen in Emacs and other text editors. When users type into a small text field in one corner of the text document window, the corresponding text is instantly selected (if it is found) in the main text view. Because this editor is implemented in Ruby, you can support text containing regular expressions in this field with little additional effort.</p><p>So where is all of the application code that handles opening files, instantiating the document class, loading the interface, managing the window, and so on? The answer is that, by default, Cocoa provides all of this basic document-handling functionality. All you have to do is specify the name of a subclass of <i>NSDocument</i> in the application's settings, and Cocoa will do the rest &#151; the reading of the file data from disk, creating the document window given an Interface Builder nib file, maintaining the menu items, and other behind-the-scenes chores. You implement only the code specific to your application &#151; Cocoa handles the rest. </p><p>For more complex applications, you can change more of the underlying behaviors and achieve better model-view-controller layering by creating subclasses of <i>NSWindowController</i> in your <i>NSDocument</i> subclass. For this example text editor, a simple <i>NSDocument</i> subclass suffices.</p><p>This example shows a few things that RubyCocoa's automatic data conversion does for you, and also shows a few things that you must do yourself. When you pass a Ruby string to an Objective-C method, RubyCocoa automatically converts the string to an <i>NSString</i>. However, when comparing an <i>NSString</i> object to a Ruby string, you must explicitly convert the <i>NSString</i> to a Ruby string using the <i>to_s</i> method. The same logic applies to <i>NSRange</i> and the Ruby <i>range</i> class.</p><p>To build this application, you'll need to use the document-based template provided with RubyCocoa. You'll also need to perform a small amount of work in Interface Builder and Project Builder to set up the basic window interface and application metadata. First, in Project Builder, create a new project using the RubyCocoaDocApp template provided in the RubyCocoa distribution. In the project, replace the source with the code in MyDocument.rb. Next, open the project file MyDocument.nib in Interface Builder. Add a text view and a text field for incremental search to the window, and use the inspector window to add outlets named <i>text_view</i> and <i>incremental_search_field</i> to the <i>MyDocument</i> class. Connect the outlets to the objects, save, and you're ready to build and run.</p><h3>Conclusion</h3><p>RubyCocoa is still in early development, and will become even more useful and flexible as the inevitable bugs are worked out and more features are added. Some form of compatibility with RIGS, the Objective-C bridge for the GNUstep project (an open-source implementation of the Cocoa libraries for Linux and BSD systems) is a possible project. Another possible project is an application packaging mechanism to let RubyCocoa applications be used on systems that don't have Ruby or RubyCocoa installed. Ruby itself will gain additional valuable features and the speed of the Ruby interpreter will likely improve as performance optimizations are added and bytecode compilation and loading are introduced.</p><p>Apple will continue to enhance Cocoa, adding missing features and fixing inevitable bugs. With a small number of notable exceptions (all for historical reasons), nearly all of the applications that ship with Mac OS X were created with Cocoa, including the development tools. Additionally, Apple may eventually publish specifications allowing third parties to develop plug-in modules for the Project Builder development environment. When and if this happens, we will be able to develop Project Builder plug-ins for easier navigation and interactive debugging of Ruby code.</p><h3>Acknowledgment</h3><p>Many thanks to Hisakuni Fujimoto for both inspiring and reviewing this article.</p><p></p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>require 'osx/cocoa'class HelloView &lt; OSX::NSView    # Tell RubyCocoa to setup Objective-C overrides    # for the NSView method drawRect:.    ns_overrides    :drawRect_        # When the Cocoa view system wants to draw a view, it calls the         # method -(void)drawRect:(NSRect)rect. The rectangle argument is         # relative to the origin of the view's frame, and it may only be         # a small portion of the view. For this reason, simple views with        # only one or two graphical elements tend to ignore this parameter.    def drawRect(rect)        # Set the window background to transparent        OSX::NSColor.clearColor.set        OSX::NSRectFill(bounds)        # Draw the text in a shade of red and in a large system font        attributes = OSX::NSMutableDictionary.alloc.init        attributes.setObject_forKey(  OSX::NSColor.redColor,                                       OSX.NSForegroundColorAttributeName )        attributes.setObject_forKey(                                          OSX::NSFont.boldSystemFontOfSize(48.0),                                      OSX.NSFontAttributeName )        string = OSX::NSString.alloc.initWithString(                                       "Hello, Ruby Baby" )        string.drawAtPoint_withAttributes([0,0], attributes)        # Turn window's shadow off/on. This is a kludge to get the shadow        # to recalculate for the new shape of the opaque window content.        viewWindow = window        window.setHasShadow(0)        window.setHasShadow(1)    endend# If this file is the main file, then perform the following commands. (This# construct is often useful for adding simple unit tests to library code.)if __FILE__ == $0    # First, to establish a connection to the window server,    # we must initialize the application    application = OSX::NSApplication.sharedApplication    # Create the window    window = OSX::NSWindow.alloc.initWithContentRect([0, 0, 450, 200],                :styleMask, OSX::NSBorderlessWindowMask,                :backing,   OSX::NSBackingStoreBuffered,                :defer,     0)    # Allow the window to be partially transparent    window.setOpaque(0)    # Setup the window's root view    view = HelloView.alloc.initWithFrame([0, 0, 450, 200])    window.setContentView(view)    # Place the window near the top of the screen.    # (Screen coordinates in Cocoa are always PostScript coordinates, which     # start from the bottom of the screen and increase as they go up, so we     # have to do some math to place the window at 100 pixels from the top     # of the screen.    screenFrame = OSX::NSScreen.mainScreen.frame    windowOriginPoint =                [40, screenFrame.origin.y + screenFrame.size.height - 100]               window.setFrameOrigin( windowOriginPoint )    # Show the window    window.makeKeyAndOrderFront(nil)    # And start the application event loop    application.runend</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>#import &lt;RubyCocoa/RBRuntime.h&gt;int main( int argc, char* argv[] ){  return RBApplicationMain("helloruby.rb", argc, argv);}</pre><P><A HREF="#rl2">Back to Article</A></P></body></html>