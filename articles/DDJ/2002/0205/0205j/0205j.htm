<html><head><title>May02: Algorithm Alley</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>QuickSort and  Radix Sorts on Lists</h1><p><i>Dr. Dobb's Journal</i> May 2002</p><h3>By Steven Pigeon</h3><I>Steven is a Ph.D. candidate at the University of Montreal. He can be contacted at <a href="http://www.iro.umontreal.ca/~pigeon/">http://www.iro.umontreal.ca/~pigeon/</a>.</I><hr><p>Sorting is one of many tasks that programmers face every day in every program. Sorting is sometimes implicitly dealt with by how the data is read or generated, and sometimes delegated to some other module or GUI component. But often, you have to deal with it explicitly. In the case of an array, you can use QuickSort, which is available in stdlib.h and search.h. While it is good practice to use thoroughly tested and universally available routines, what happens when your code does not apply? For example, what do you do when you have a linked list instead of a flat array?</p><p>QuickSort can be adapted for lists, as long as they are linked both ways. The list nodes are required to point both to the preceding and following nodes because QuickSort scans the list in both directions to build its partitions. The number of manipulations required by QuickSort on <i>n</i> elements is on average <i>O(n lg n)</i> (in worst case, up to <i>O(n</i><sup>2</sup><i>)</i>)<i>, </i>and the complexity of the manipulations depends on how you deal with the data within the nodes.</p><DDJADVERTISEMENT INLINE><p>If the data is included in the nodes themselves, you need to modify the list to exchange nodes. That implies lots of pointer manipulations. On the other hand, if the data is referenced by a pointer in the list node, swapping two nodes reduces to the exchange of the two data pointers, which is faster and simpler than actually modifying the list itself.</p><p>What happens when you have a simply linked list with a pointer to the next element? QuickSort can't be applied as easily. Of course, you can promote the list to a doubly linked list, incurring complications such as reallocating new nodes, moving data, sorting, then demoting it back to a simply linked list. But there is actually a better way &#151; radix sorting.</p><p>Radix sorting sorts an array in linear time. That is, it requires not <i>O(n lg n) </i>operations but<i> O(n),</i> with a hidden constant that doesn't depend on <i>n</i> at all, but on the maximum number of bits of the numbers (or keys) to sort. (For more information on radix sorting, see "QuickSort and Three-Way Radix Sorting," by Jon Bentley and Robert Sedgewick, <i>DDJ</i>, November 1998.) In this article, I present code and methods to QuickSort doubly linked lists, both by exchanging only the data pointer and by modifying the list itself. I also present the radix sort algorithms for arrays and simply linked lists and compare the performance of these algorithms. </p><h3>QuickSorting Lists</h3><p>The basic QuickSort algorithm is surprisingly simple. You start with an array of (unsorted) numbers. At each end of the array, there's a pointer &#151; the left pointer on the left end and right pointer on the other. You first choose the pivot value; that is, a value taken at random within the array. It is important that this value be drawn from the array. You split the array into two parts, one containing only values less or equal to the pivot value, and the other with values above or equal to the pivot value. This is the "invariant" &#151; the condition that must be satisfied at all times. You do this by advancing the left pointer while the value pointed to is less than or equal to the pivot value. The left pointer stops on a value that is greater than the pivot value. Then do the opposite with the right pointer &#151; rewind the right pointer while the value pointed to is greater than or equal to the pivot value. The right pointer stops on a value that is less than the pivot value. Swap the values pointed to by the left and right pointers (or the nodes themselves), thus restoring the invariant. Repeat this until the right and left pointers meet. When the left and right pointers meet somewhere in the array, you are done for this step and the array is divided in two. Reapply, recursively, QuickSort on each newly created subarray. Eventually, you have to sort subarrays of length 2 or 1, which ends the recursion. After all recursive calls return, the array is completely sorted.</p><p>If the pivot value is wisely chosen, you split the array nearly in half. You then reapply QuickSort on each half. But the number of cuts is at most about <i>lg n, </i>which<i> </i>means log base 2, since you cut in half each time. QuickSort performs about <i>O(n lg n)</i> steps to sort an array, as long as the pivot's values are well chosen. </p><p>If the pivot value is poorly chosen, you could split the array in, say, one element on one side and (<i>n-</i>1) on the other. This leads to a catastrophic number of operations of <i>(</i>1/2<i>)n(n+</i>1<i>)=O(n</i><sup>2</sup><i>) </i>steps instead of <i>O(n lg n)</i> &#151; QuickSort's worst case. To avoid this, pick the pivot value as the value that is at the center of the presently examined subarray. This even lets already sorted arrays be QuickSorted in <i>O(n lg n)</i> steps rather than <i>O(n</i><sup>2</sup><i>).</i></p><p>ListQuickSort.cpp (available electronically; see "Resource Center," page 5) is code for QuickSorting a list. A first version, <i>QuickSortList(cList </i>*<i> head, cList </i>* <i>tail, int count)</i>, sorts the list by changing only the node contents and without modifying the list itself. The second version, <i>QuickSortList2(cList</i>* &amp;<i>head, cList</i>*<i> </i>&amp;<i>tail, int count),</i> sorts the list by modifying the list itself: It leaves the node's data untouched, only modifying the way the nodes are linked together. <A NAME="rf1"><A HREF="0205jf1.htm">Figure 1</A> shows how to rethread the list.</p><h3>A Deck of Cards</h3><p>To illustrate radix sorting, say you have a deck of 52 playing cards, distributed into the four usual suits (diamonds, hearts, spades, and clubs) and having the normal markings from ace to king. All cards are numbered 0 to 51 &#151; 0 to 12 are diamonds, 13 to 25 are hearts, and so on for spades and clubs.</p><p>Assume the deck is sufficiently shuffled and you want to sort it. One possibility is to sort it using an insertion sort. You start with the unsorted deck in the right hand and, looking at the cards one by one, insert them in the right place in the sorted part of the deck that you hold in the left hand. This procedure requires essentially (1/2)<i>n</i><sup>2</sup><i> </i>steps to sort a deck of <i>n</i> cards. But there's a way to sort the cards in linear time.</p><p>Rather than using an insertion-based technique, you use a stack-based technique. In <A NAME="rf2"><A HREF="0205jf2.htm">Figure 2</A>, you distribute the unsorted deck into 13 stacks, one for each card rank. You distribute all the aces to the same stack, all the deuces to another stack, and so on, up to the stack for the kings. Eventually, all the cards are dealt to one of the 13 stacks. The next step consists of taking each of these stacks, starting with the lowest ranking stack, the aces, and redistributing all the cards into four new stacks, the stacks of suits. You start with the stack of aces. The four aces are still in some random order, but you can send each of them to the right suit stack. You do the same with deuces, and so on, up to kings. After this, each of the suit stacks contains a complete suite and a complete sorted suit. You are nearly done. All that is left to do is to combine the suit stacks to get a sorted deck. <A NAME="rl1"><A HREF="#l1">Listing One</A> does this. </p><h3>Radix  Sorting Arrays</h3><p>Of course, a card deck example is not especially realistic. To "sort" a deck, it suffices to fill the array with the numbers from 0 to 51. However, it does illustrate how radix sorting works. You can adapt the method to integers instead of card denominations. In the card example, the first "digit" of the card number is its rank and the second "digit" its suit. Radix sorting is all about digits of the numbers to sort. In the card example, the numbers are base-13. However, base-16 (or more) is often more suitable for sorting integers.</p><p>Radix sort on integers works much the same as on cards. Suppose you have an array filled with positive integers in some range, with at most <i>K</i> bits used. You treat those <i>K</i>-bit numbers as base-16 numbers; that is, looking at only 4 bits at a time. You need 16 stacks. Start by distributing all numbers according to their first (least significant) digit. All numbers ending in 0 (mod 16) are stacked onto stack 0, all numbers ending in 1 (mod 16) onto stack 1, and up to numbers ending in 15 (mod 16) onto the last stack, stack 15. Once all numbers have been distributed onto the stacks, unstack them into the original array. Copy the contents of each stack, at the end of each other, in the original array, but without changing the order of the contents of the stacks. Repeat the procedure, but now using the second base-16 digit of each number. Once they are all distributed, unstack them again and proceed to the third pass, using the third digit as the key. Repeat the process as many times as needed to process all the digits of the numbers. When you unstack them for the last time, they are all sorted.</p><p>This works because the unstacking is an order-preserving operation. Indeed, simply copying the contents of the stack to the array doesn't change the order of its contents. <A NAME="rf3"><A HREF="0205jf3.htm">Figure 3</A>, for instance, is a radix sort where the keys are 3 bits long and considered binary numbers. You start with the unsorted array. Scanning the array from left to right, construct two stacks &#151; one with numbers ending in 0, the other ending in 1. When all numbers have been distributed, copy the stacks back into the array (without changing the order of the numbers as you do so). When you repeat the procedure, you still construct two stacks: The first stack contains numbers whose second bit is 0, the second contains numbers whose second bit is 1. As the ordering of the numbers is not affected by unstacking, at the beginning of the third pass, the array is filled by the numbers that end in 00, then by those that end in 01, then in 10, and finally by the numbers that end in 11. Repeat the process as many times as needed to sort all the numbers in the array. In <A NAME="rf3"><A HREF="0205jf3.htm">Figure 3</A>, you need to repeat the process three times, since the numbers are 3 bits long.</p><p>The number of times you repeat the process does not depend on the number of items in the array at all; only on the number of bits in the keys. If you treat the bits one by one and have <i>K</i> bits by key, the sorting process is <i>O(Kn).</i> That is, it needs about <i>Kn</i> steps to sort an array of <i>n</i> items. Since treating bits one by one is somewhat inefficient, treat keys by chunks of <i>c</i> bits. Typically, you set either <i>c</i>=4 or <i>c</i>=8. The number of steps is now <i>(K/c)n</i>, which is still <i>c</i> times better than just <i>Kn.</i></p><p><A NAME="rl2"><A HREF="#l2">Listing Two</A> sorts an array of integers. This code doesn't literally use 2<i><sup>c</i></sup><i> </i>stacks. Instead, it interleaves multiple stacks within the same array. <A NAME="rf4"><A HREF="0205jf4.htm">Figure 4</A> shows how it works. First, you have 2<i><sup>c</i></sup> stack pointers that indicate where the top of each stack is in the shared array. A second array, a predecessor array, indicates the location of the predecessor for each element in the shared array. This way, you can share this array amongst many stacks without having to allocate an array for each stack. Allocating as many arrays as stacks would waste quite a lot of memory. This method only asks for a second array of integers.</p><h3>The Algorithm for Lists</h3><p>Okay, this algorithm is not faster than QuickSort on any reasonably sized flat array but does have a considerable advantage over QuickSort in how it scans the array.</p><p>Often it is not an array you have to sort, but a list. And often, it's a simply linked list that does not allow easy reverse scanning. That is, the only easy way to scan each of the elements is to start from the head of the list and move to the next element, one element at a time, until you reach its tail.</p><p>Should you think of using QuickSort on such a list, you would have to promote it to a doubly linked list, incurring all the complications that this situation is prone to: allocating new memory for the new nodes, copying data or at least linking to it, destroying the original list after sorting, and finally demoting the doubly linked list to a simply linked list again. That's a lot of work, besides actually sorting the list.</p><p>Radix sort naturally uses simply linked lists. ListSort.cpp (available electronically) is a C++ implementation of a radix sort on simply linked lists. Like the previous version of the algorithm, it also uses stacks. Instead of interleaving the stacks together in an array, it uses pointers to the base to the top element of each stack. Moving a list node to a stack doesn't require much of an operation: It suffices to set the "next" pointer of the topmost element of a stack to the current list node, and set the topmost pointer to this newly added element. You don't need to reallocate or move the actual node nor its contents. This is most efficient when the node's contents are large. The other advantage of using such a stack is that the unstacking costs just about nothing: To unstack, it's enough to make the last element of stack 0 point to the first element of stack 1, the last element of stack 1 point to the first element of stack 2, and so on until all of the stacks have been "sewn" together effortlessly. This means that the cost of unstacking is proportional to the number of stacks and not of elements that they contain. <A NAME="rf5"><A HREF="0205jf5.htm">Figure 5</A> shows the process of sewing stacks together. The "sewn together" stacks become the list on which you iterate the algorithm until all bits of the keys are processed.</p><h3>Speed Comparison</h3><p><A NAME="rt1"><A HREF="0205jt1.htm">Table 1</A> compares the timings resulting from the algorithms and their variations. I used a Toshiba 2510 laptop with a 266-MHz Pentium Pro processor as the workbench. The timings are precise within about 10 ms (this is <i>clock()</i>'s usual granularity). The radix sort beats QuickSort on lists of 100,000 elements and more. Here, a 1 million element list takes 3.84 seconds to be sorted, while the QuickSort variation that doesn't modify the list structure takes 5.44 seconds. The QuickSort variation that actually modifies the list is far behind at 14.53 seconds.</p><h3>Conclusion</h3><p>The radix sort algorithm is much slower than QuickSort when applied to unsorted numbers contained within a flat array, but proves itself useful when dealing with lists whose keys are integers. The way it scans the list &#151; forward only &#151; makes it more suitable than QuickSort for simple lists. Furthermore, radix sorting is faster than QuickSort on very large lists. This is additional proof that the algorithm alone isn't everything. QuickSort, powerful on flat arrays, leaves something to be desired on linked lists. Radix sort, on the other hand, is well suited for linked lists.</p><p></p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;template &lt;typename T&gt; void swap(T &amp; a, T &amp; b) { T t=a; a=b; b=t; }///////////////////////////////////////int rank(int i) { return i % 13; }int suit(int i) { return i / 13; }///////////////////////////////////////void SortDeck(int deck[52]) {  int rank_stack_ptr[13];  int suit_stack_ptr[4];  int rank_stack[13][4];  int suit_stack[4][13];  // hash by rank  for (int r=0; r&lt;13; r++) rank_stack_ptr[r]=0;  for (int i=0; i&lt;52; i++)   {    int r = rank( deck[i] );    rank_stack[ r ][ rank_stack_ptr[r]++ ] = deck[i];   }  // hash by suite  for (int s=0; s&lt;4; s++) suit_stack_ptr[s]=0;  for (int i=0; i&lt;13; i++)   for (int j=0; j&lt;4; j++)    {     int s = suit( rank_stack[i][j] );     suit_stack[ s ] [ suit_stack_ptr[s]++] = rank_stack[i][j];    }  // copy cards backs into the deck  for (int d=0, i=0; i&lt;4; i++)   for (int j=0; j&lt;13; j++, d++)    deck[d] = suit_stack[i][j];  // here, deck is sorted }///////////////////////////////////////void main() {  int deck[52];  for (int i=0;i&lt;52;i++) deck[i]=i;  for (int i=0;i&lt;1000;i++)   swap(deck[rand() % 52], deck[rand() % 52]);  SortDeck(deck); }</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>void DistributionSort4(int tas[], int l, int h, int logMax) {  int head[16];  int *stack = new int[h-l];  int *pred  = new int[h-l];  for (int offset=0, i=0; offset &lt; logMax; i++, offset+=4)   {    for (int j=0;j&lt;16;j++) head[j]=-1;    for (int d=0,j=l;j&lt;h;j++,d++)     {      int s = (tas[j] &gt;&gt; offset) &amp; 0xf;      stack[d]=tas[j];      pred[j]=head[s];      head[s]=d;     }    for (int k=h-1, j=15; j&gt;=0; j--)     while (head[j]!=-1)      {       tas[k]=stack[head[j]];       head[j]=pred[head[j]];       k--;      }   }  delete[] stack;  delete[] pred; }</pre><P><A HREF="#rl2">Back to Article</A></P></body></html>