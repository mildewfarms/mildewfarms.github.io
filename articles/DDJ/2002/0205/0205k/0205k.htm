<html><head><title>May02: Programmer's Bookshelf</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Filling In the Gaps</h1><p><i>Dr. Dobb's Journal</i> May 2002</p><h3>By Gregory V. Wilson</h3><I>Greg, a DDJ contributing editor, is the author of</i> Practical Parallel Programming <i>(MIT Press, 1995), and coeditor with Paul Lu of</i> Parallel Programming Using C++ <i>(MIT Press, 1996). Greg can be reached at <a href="mailto:gvwilson@ddj.com">gvwilson@ddj.com</a>.</I><hr><p>If you were to judge by shelfspace, you'd think that computing was awash with useful information about exciting new technologies. In fact, many of the dead trees in your local bookstore just rehash vendors' documentation, or are the dozen'th "me too" presentation of this week's hot topic.</p><p>It is therefore a pleasure to review a couple of books that are both original and useful. The first is Richard Hightower and Nicholas Lesiecki's <i>Java Tools for Extreme Programming</i>, which describes five new Open-Source Java programming tools. One of these, Ant, replaces UNIX's venerable tab-indented makefiles with an XML description of how files depend on each other, and what to do to rebuild them. While Ant doesn't address Make's biggest weaknesses (its poor readability, and lack of a debugger), it is more flexible and makes it easy for programmers to process build descriptions in other ways.</p><DDJADVERTISEMENT INLINE><p>The other four tools support various kinds of testing, from simple unit tests (JUnit) to full-blown integration and performance testing (Cactus, HttpUnit, and JMeter). As well as being useful in their own right, these tools are proof that Open Source is outgrowing its na&iuml;ve "fix what you find" attitude, and taking quality assurance seriously.<i></p><p>Java Tools</i> is readable and well organized, although you'd better know your way around Enterprise JavaBeans and related technologies before you crack the covers. As a bonus, the authors show how to use these tools together; for example, how to automate reexecution of JUnit tests using Ant. They also include lots of pointers to online resources, and comment on such things as which IDEs these tools are integrated with. My only real criticism is with the book's production: Several of the examples are missing a line or two, and some of the diagrams are fuzzy.</p><p>The second of this month's winners is David Bourg's <i>Physics for Game Developers</i>. As the title suggests, the book summarizes those bits of freshman and sophomore physics that are relevant to the design of action games. Want to know what happens when a hovercraft glances off the side of a building? Bourg explains the physics involved, and provides chunks of well-commented code to get your simulation started. Need to figure out the stall speed for a small plane? Bourg analyzes some simple approximations, along with their associated fudge factors. While it is definitely not for the math averse (the first integral sign appears on page 6), <i>PGD</i> is clear, concise, and beautifully produced.</p><p>Last, and unfortunately least, is Matt Telles and Yuan Hsieh's <i>The Science of Debugging</i>. At first glance, I expected to enjoy it at least as much as I enjoyed <i>Java Tools</i>. Like most professional programmers, I spend more time finding and fixing bugs than I do writing new code. And, like most of my peers, I had to teach myself how to do this on my own: There was no "Debugging 101" when I was an undergraduate, and none of the books I've read on compilers, graphics, or network programming talk in any detail about how to diagnose and fix errors. I therefore hoped that <i>The Science of Debugging</i> would be something I could give to junior developers so that they wouldn't have to recapitulate my trials and errors. </p><p>Unfortunately, <i>The Science of Debugging</i> isn't that book. It does contain some useful information, such as famous bugs in history, a taxonomy of debugging techniques, and what you should do after you've fixed the bug. (Answer: Look for more like it.) However, much of the presentation is couched in very general terms, so that if you don't already know what they're talking about, you'll have a hard time relating what they say to your day-to-day work.</p><p>My single biggest complaint about this book is what it doesn't cover. On page 195, the authors say:</p><blockquote><p>Using the debugger is not really an appropriate topic for this book. Individual debuggers include directions for using them, and you will certainly find a plethora of books that discuss how to use various debuggers on various platforms to do your job. </p></blockquote><p>Huh? I can understand the authors not wanting to write a reference manual for GDB, but symbolic debuggers are the most effective bug-bashing tools around. Knowing how to use them properly is one of the things that distinguishes amateur programmers from professionals, and is certainly an appropriate topic for a book on this subject.</p><p><b>DDJ</b></p></body></html>