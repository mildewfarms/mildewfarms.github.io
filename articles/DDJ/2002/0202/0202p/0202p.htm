<html><head><title>Feb02: Programmer's Bookshelf</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Sometimes You  Get What You Want</h1><p><i>Dr. Dobb's Journal</i> February 2002</p><h3>By Gregory V. Wilson</h3><I>Greg is a DDJ contributing editor with a special interest in scientific computing and small-scale software engineering. He presently works for Baltimore Technologies, and can be reached at <a href="mailto:gvwilson@ddj.com">gvwilson@ddj.com</a>.</I><hr><h4><br><b><i>C++ Footprint and Performance  Optimization </b></i><br>Rene Alexander and Graham Bensley<br>Sams Publishing, 2000<br>388 pp., $49.90<br>ISBN 0672319047<br><b><br><i>Python Standard Library</b></i><br>Fredrik Lundh<br>O'Reilly &amp; Associates, 2001<br>281 pp., $29.95<br>ISBN 0596000960<b><br><br><i>Applying Use Case Driven Object Modeling with UML: An Annotated e-Commerce Example</b></i><br>Doug Rosenberg and Kendall Scott<br>Addison-Wesley, 2001<br>176 pp., $34.95<br>ISBN 0201730391<br><b><br><i>Structure and Interpretation of Classical Mechanics</b></i><br>Gerald Jay Sussman and Jack Wisdom<br>MIT Press, 2001<br>526 pp., $60.00<br>ISBN 0262194554<br></h4><p>A couple of years ago, I read and reviewed a book called <i>Applying Use Case Driven Object Modeling with UML,</i> by Doug Rosenberg and Kendall Scott. It was a good book &#151; a very good book &#151; about those bits of the Unified Modeling Language (UML) that are actually useful to most programmers, and how best to use them. My biggest criticism of it was that it was too short: As I said in my review, I really wanted a dozen examples of each point to work through.</p><p>Well, guess what? Not only did Rosenberg and Scott write that book, they also quoted my complaint in its "Introduction." Unlike its title, <i>Applying Use Case Driven Object Modeling with UML: An Annotated e-Commerce Example</i> is short and sweet. The authors use the analysis and design of a simple online bookstore to show which parts of the UML notation should be used when and why. The book's eight sections interleave brief summaries of material from the first book, "Top 10 Mistakes" lists, and "fix the errors" exercises. The writing is crisp, the examples are to the point, and the layout is clear. Together, this book and its predecessor are the best introductory texts on applied object-oriented analysis and design I have seen to date. I can hardly wait for the next one (hint, hint).</p><DDJADVERTISEMENT INLINE><p>Rene Alexander and Graham Bensley's <i>C++ Footprint and Performance Optimization </i>didn't impress me as much, although it does contain a lot of useful information in the book. Chapter 9, for example, is a good (though brief) look at memory fragmentation, the performance problems it can cause, and what programmers can do about it. Similarly, Chapter 12 looks at the speed of various techniques for text and binary I/O, and explains where some of the differences come from.</p><p>So why did I come away feeling a bit disappointed? Partly it was the writing style: Far too many simple points are made using unnecessarily large words, and in the passive voice. Mostly, though, it was that the discussion often stopped just as it got interesting &#151; I would much rather have had a book that covered less ground, in more detail. Now that Jon Bentley's <i>Writing Efficient Programs </i>is out of print (and out of date), there's a real need for a practical, readable book on the subject. With tighter editing and more focus, this book could fill that gap, but as it stands, it's one to borrow, not buy.</p><p>Fredrik Lundh, author of <i>Python Standard Library</i>, has been a frequent contributor to comp.lang.python, and to Python itself. This book combines an overview of the libraries that come in the standard Python distribution with a host of small examples of how those libraries can be used. By the time I was in Chapter 3, I was scribbling "Use this!" in the margin of every second or third page.</p><p>Unfortunately, by the time I was in Chapter 9, I had mostly stopped making notes. Like Beazley's <i>Python Essential Reference </i>(reviewed here in August 2000), and like Python's own documentation, this book's examples grow thinner as the topics themselves grow harder. This may be inevitable &#151; TCP/IP networking is a book in its own right, for example &#151; but once again, I came away feeling that if the book had tried to cover less ground, it might have delivered more value.</p><p>Gerald Jay Sussman and Jack Wisdom's <i>Structure and Interpretation of Classical Mechanics </i>shares both its title and its approach with Abelson and Sussman's classic<i> Structure and Interpretation of Computer Programs,</i> which was for many years the standard introductory computing text at MIT. However, <i>SICM</i> seems aimed at sophomore physics students with a solid programming background.</p><p>The first chapter of <i>SICM</i> starts with the words, "The subject of this book is motion and the mathematical tools used to describe it." Over the next 500 pages, the authors explore the mathematics behind a variety of classical and chaotic systems. Short Scheme programs are mingled in with text and formulas to create a dense, but seamless, whole. The subject matter may not interest most programmers, and the mathematics can get pretty scary, but <i>SICM</i> is an excellent example of how computational science is at last taking its place as an equal beside theory and experimentation.</p><p><b>DDJ</b></p></body></html>