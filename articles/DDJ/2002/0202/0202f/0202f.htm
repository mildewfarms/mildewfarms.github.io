<html><head><title>Feb02: Creating Libraries for Multiple Programming Languages</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Creating Libraries for Multiple Programming Languages</h1><p><i>Dr. Dobb's Journal</i> February 2002</p><h2>Wrapping it up</h2><h3>By Ken Martin, William Hoffman,  and Berk Geveci</h3><I>Ken, William, and Berk develop software for Kitware Inc. (<a href="http://www.kitware.com/">http://www.kitware.com/</a>). They can be contacted at <a href="mailto:kitware@kitware.com">kitware@kitware.com</a>. </I><hr><p>If you ask five software developers what programming language they use, you'll likely get five different answers. C++, Java, Python, Visual Basic, Perl, and Tcl are just a few of the languages commonly used. While it is convenient to have a wide variety of languages to choose from, each with its own set of advantages and disadvantages, it makes reusable library development a challenge. How do you develop a library that a wide range of software developers can use? How do you support rapid prototyping languages such as Python and Tcl while also providing the performance and efficiency required for production applications in C++? In creating the Visualization Toolkit (VTK) (see "3-D Surface Contours," by W.J. Schroeder and W.E. Lorensen, <i>DDJ</i>, July 1996; and <i>The Visualization Toolkit User's Guide</i>, by W.J. Schroeder et al., Kitware Inc. 2001, <a href="http://www.kitware.com/">http://www.kitware.com/</a>), we faced these issues and developed a strategy for addressing them. </p><p>VTK is a library designed to address the visualization needs of academic and commercial communities in fields such as medical and scientific research. As such, it supports a wide variety of developers. There are many researchers using VTK who typically use rapid prototyping languages such as Python or Tcl. They want the flexibility of an interpreted language allowing interaction and modification of a program while it is running. At the same time there are a number of commercial products using VTK where a small memory footprint and fast execution times are critical. These applications are typically done in C or C++, which usually produce faster and more compact code than languages such as Tcl or Visual Basic.</p><DDJADVERTISEMENT INLINE><p>Our approach to writing multilanguage libraries was to write VTK in C++ using object-oriented methodologies, then create tools to automatically wrap the library into other languages. This lets us maintain the core functionality in one language that is fast and efficient, yet makes that functionality available to all languages. We integrate with user interfaces for languages such as Python, Java, Visual Basic (via ActiveX), and Tcl by creating a few support classes that let VTK display its results within a typical widget of the language, such as a JPanel for Java. In this article, we discuss how we did this and the challenges we encountered.</p><h3>Implementation</h3><p>There were a number of challenges to making VTK a library that could be used from many programming languages. With more than 500 C++ classes, VTK is a large library that is actively being developed and extended. Any wrapping technique we used had to be automated to keep up with the changes and additions to VTK. A manual process would quickly fall behind the current state of the software. We also required an approach that would let developers wrap their extensions to the VTK library so that they could access their new VTK classes from their preferred language, just like the core classes. </p><p>The first problem we ran into was parsing our C++ code. To wrap a library into these other languages, we needed a method of parsing the code and breaking it into its lexical components. To do this we decided to use the traditional language tools LEX for the lexical analysis and YACC (Yet Another Compiler Compiler) to parse the grammar. It turns out, writing LEX and YACC code for C++ is not an easy task because C++ has a plethora of features and its syntax is more context sensitive than other languages. Consequently, we had to make several compromises to facilitate the parsing. The first was our philosophy regarding C++. We believed in using only a subset of features from C++ within a relatively rigid development environment. For example, we did not use templated classes, run-time type checking, or exceptions. In addition, our coding standards dictated that all class names start with a common prefix (<i>vtk</i>), a limit of one class per file, and a set of simple macros are used for performing common <i>set/get</i> methods. VTK also uses reference counting, which is key to handling memory management in the various wrapped languages.</p><p>With these restrictions, we were able to develop a LEX- and YACC-based program that could parse VTK header files and extract the pertinent information. <A NAME="rf1"><A HREF="0202ff1.htm">Figure 1</A> is a high-level diagram of the process. The class's name, methods, and method signatures (number of arguments, return type, argument types) are parsed, then stored into a data structure for later use. We made no attempt to handle preprocessor directives, indicating that our wrapping of a class is done based on that class's header file alone, without looking at its superclasses' header files. (We are currently developing a next-generation wrapping approach using GNU C++ to parse the header files. This approach avoids these restrictions.)</p><p>One advantage of using an object-oriented design for the library is that it maps easily to most languages. Java and Python are object oriented by design while other languages, such as Tcl, already have a notion of commands as instance method arguments. Through COM, Visual Basic also maps easily to the notion of an instance with methods that can be invoked on it. <A NAME="re1"><A HREF="0202fe1.htm">Example 1</A> shows the similarities between five languages calling the same method.</p><p>The first step in wrapping a class library is to specify which classes to wrap and if they are concrete or abstract. In object-oriented terminology, abstract classes define an API for their subclasses. They are not meant to be instantiated and, under some circumstances, it can be a compiler error to do so (such as classes with pure virtual methods in C++). As such, we do not want to allow abstract classes to be instantiated in any of the wrapped languages, although we do want to wrap any methods they define because subclasses may rely on them.</p><p>Once we have specified the class's name and if it is concrete or abstract, the next step is to wrap the methods. Most languages provide mechanisms for extensions via C or C++. This extension support is what we use to wrap the methods of a class into a language. For Java we use the JNI (Java Native Interface), for Tcl we use the <i>Tcl_CreateCommand</i> function, for Visual Basic the Component Object Model (COM), and so on. The difficulty arises in three key areas:</p><ul>  <li>Argument type conversions.  <li>Memory management.  <li>Supporting callbacks.</ul><p>Argument type conversions are tricky because each language has its own structures for storing data. Some of the conversions, such as going from Java's <i>jdouble</i> to a C++ <i>double</i>, are easy while others, such as going from a Java <i>jobject</i> to a properly cast C++ pointer are more difficult. To aid in this, we created a set of utility conversion functions for each target language. These functions handle all the conversions between C++ and the target language. The most difficult conversions are object conversions due to the typecasting involved. We need to know if an instance of class <i>A</i> can be passed into a function that takes class <i>B</i>. Most object-oriented languages handle these type conversions and type safety automatically, but in other languages we must trace through the class hierarchy to determine if the type conversion can be safely done. To accomplish this, the automated wrapping typically adds type conversion functions to each wrapped class to convert to its superclasses. This can be chained up the hierarchy providing full, safe type conversion; see <A NAME="rl1"><A HREF="#l1">Listing One</A>.</p><p>The second issue in wrapping methods is memory management. When a C++ method returns an instance of a class, who is responsible for freeing the memory? Recent versions of the JNI have introduced global-weak-references that serve this purpose perfectly. A global-weak-reference provides a reference to the object but doesn't prevent the object from being garbage collected. This lets the language interface code know when Java considers the object to be disposed of. A different strategy is used for Visual Basic through COM. Anytime a C++ object is returned from a method a new COM interface object is instantiated and wrapped around the C++ object. The C++ object has its reference count incremented, which requires that the underlying C++ objects support some form of reference counting. COM then manages the reference counting on the interface object in the standard way. When the COM interface is destroyed, it decrements the reference count on the underlying C++ object. This is important because C++ objects can be referenced in the C++ layer and may or may not have COM interfaces pointing at them.   </p><p>The third issue is providing support for callbacks from C++. Many visualization algorithms are computationally expensive and can take minutes to compute. In these cases, having a progress bar is an advantage. But this requires that the C++ class be capable of invoking a callback to the wrapped language. To accomplish this we used the Subject Observer and Command design patterns (see <i>Design Patterns: Elements of Reusable Object-Oriented Software</i>, by Erich Gamma et al., Addison-Wesley, 1995). A VTK C++ class can have an observer added to its list of observers. When a specified event happens, the observer is notified and a command is invoked. Since the Command design pattern encapsulates a command into a C++ class, we can create subclass commands targeted to each wrapped language. <A NAME="rl2"><A HREF="#l2">Listing Two</A> shows the Tcl command. </p><p>The class stores the Tcl interpreter and a string to execute as instance variables. In a similar manner, the Java command stores a handle to the Java environment (<i>jenv</i>), a Java object (<i>jobject</i>), and a method to invoke. For Visual Basic, we use COM connection points to provide callbacks. <A NAME="rl3"><A HREF="#l3">Listing Three</A> is the command class for COM. <A NAME="rl4"><A HREF="#l4">Listings Four</A> and <A NAME="rl5"><A HREF="#l5">Five</A> illustrate Tcl and Visual Basic code using the observer objects. </p><p>In addition to the methods in the C++ classes that are wrapped, the wrapping process can provide some convenience commands that provide additional features not possible in C++. For example, the Tcl wrapper provides a <i>ListMethods</i> command that will list all of the methods for a particular class. Another command, <i>DeleteAllObjects</i>, lets you delete all objects created in the Tcl interpreter.  </p><h3>Comparison with COM and CORBA</h3><p>Another way to provide this type of multilanguage support from a single library would be to use the Interface Definition Language (IDL) and either COM or CORBA. IDL is a way to define interfaces for objects in a language-neutral way. Both COM and CORBA use variations of IDL for specifying object interfaces. However, IDL only provides the interface for the object, and the implementation must be hand coded in C++, C, or some other language. This adds complexity for library developers who must know both IDL and the implementation language. With our approach, VTK developers need only learn C++ to develop new VTK objects. To use existing objects, users can choose from a variety of wrapped languages. Both COM and CORBA also suffer from portability issues. COM is only available for Windows. CORBA suffers from many different implementations and is often difficult to port from one CORBA implementation to the next.  </p><p>However, if COM or CORBA bindings are desired, this approach can be used to generate the IDL from the C++ classes. In the VTK ActiViz software from Kitware (our company; <a href="http://www.kitware.com/">http://www.kitware.com/</a>), an IDL interface is created for each VTK class. <A NAME="rl6"><A HREF="#l6">Listing Six</A> is an example of the IDL and C++ interfaces for the <i>GetClassName </i>method on <i>vtkObject</i>. The implementation objects for the IDL interfaces are automatically generated as well as thin proxy objects that talk to the C++ implementations. </p><h3>Conclusion</h3><p>The approach we describe here is a good solution for developing toolkits or libraries written in efficient C++, which also allow for rapid prototyping in scripted languages. Providing multiple programming language bindings for a library also gives the code a much wider audience by not forcing users into a particular language choice to use the software. However, the current implementation does have several drawbacks. Since the parser is not a true ISO compliant C++ parser, developers of the toolkit are required to only use a subset of the C++ language. This can be frustrating for experienced C++ developers who want to use advanced features such as templates and exceptions.  </p><p>We are currently working on the next-generation wrapping system, which uses the ISO-compliant C++ parser found in the GNU compiler. The GNU compiler generates XML representations of class interfaces. The resulting XML can be parsed more easily than the original C++. This allows for the wrapping languages to take advantage of more C++ features.</p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>extern "C" JNIEXPORT void* vtkCell_Typecast(void *me,char *dType){  void* res;  if (!strcmp("vtkCell",dType)) { return me; }  if ((res= vtkObject_Typecast(me,dType)) != NULL) { return res; }  return NULL;}</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>class vtkTclCommand : public vtkCommand{public:  vtkTclCommand();  ~vtkTclCommand();   void SetStringCommand(char *arg) { this-&gt;StringCommand = arg; };  void SetInterp(Tcl_Interp *interp) { this-&gt;Interp = interp; };  void Execute(vtkObject *, unsigned long, void *);private:  char *StringCommand;  Tcl_Interp *Interp;};</pre><P><A HREF="#rl2">Back to Article</A></P><H4><A NAME="l3">Listing Three</H4><pre>class vtkComCommand : public vtkCommand{public:  vtkComCommand(T* o, unsigned long id)    {      this-&gt;Object = o;      this-&gt;EventId = id;    }  virtual void Execute(vtkObject *caller, unsigned  long, void *callData)    {      this-&gt;Object-&gt;Fire_VTKEvent(this-&gt;EventId);    }  T* Object;  unsigned long EventId;}</pre><P><A HREF="#rl3">Back to Article</A></P><H4><A NAME="l4">Listing Four</H4><pre>vtkRenderer renderer    renderer SetStartRenderMethod start proc start{}  {   puts "Start Render"}</pre><P><A HREF="#rl4">Back to Article</A></P><H4><A NAME="l5">Listing Five</H4><pre>Dim WithEvents renderer As vtkRendererPrivate Sub renderer_StartEvent()MsgBox "Start Render"End Sub</pre><P><A HREF="#rl5">Back to Article</A></P><H4><A NAME="l6">Listing Six</H4><pre>HRESULT GetClassName ([out, retval] BSTR *arg20); //IDLvirtual const char *GetClassName(); // C++ </pre><P><A HREF="#rl6">Back to Article</A></P></body></html>