<html><head><title>Feb02: Tcl/Tk and SKILL Mix It Up</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Tcl/Tk and SKILL Mix It Up</h1><p><i>Dr. Dobb's Journal</i> February 2002</p><h2>Putting the best of two languages to work</h2><I>Christopher is a senior software engineer at Pinebush Technologies and author of Tcl/Tk Programmer's Reference (<a href="http://www.purl.org/net/TclTkProgRef">http://www.purl.org/net/TclTkProgRef</a>). He can be reached at <a href="mailto:chris@pinebush.com">chris@pinebush.com</a>.</I><hr><p>It is well known that Tcl's roots are in design tools for integrated circuits. But while Tcl is common in that market, it is not pervasive. For example, products from Cadence Design Systems, a leading vendor of electronic design automation (EDA) tools for IC design, are scripted with SKILL, a proprietary dialect of LISP. Imagine my frustration, then, when Pinebush Technologies (where I work) gave me the job of coordinating a GUI written in Tcl/Tk with a Cadence system.</p><p>HyperCDS is Pinebush's add-in for Cadence's Virtuoso, which prints chip designs directly from the Cadence database. While the initial HyperCDS GUI was written entirely in SKILL, the language's UI features are limited and the interfaces it produces appear dated. To make matters worse, HyperCDS had grown to more than 10,000 lines of difficult-to-maintain SKILL code.</p><DDJADVERTISEMENT INLINE><p>As it turns out, Pinebush had also developed a nonHyperCDS Tcl/Tk-based GUI for use in other environments. Because of our experience with Tcl/Tk's strong UI facilities, the Tcl/Tk-based GUI had acquired many more features than HyperCDS over time. Consequently, the decision was made to adapt the Tcl/Tk-based GUI for use with the Cadence tools.</p><p>An overview of the layered architecture of the hybrid HyperCDS system would include the following. At the uppermost level are standard SKILL functions for interacting with the Cadence environment. Below that are a limited number of special-purpose custom SKILL functions for adapting the standard functions to HyperCDS. Finally, there is a small core of general-purpose SKILL functions that manage communication with the Tcl/Tk GUI.</p><p>On the Tcl/Tk side, the uppermost layer is comprised mostly of existing code for the GUI, but with a few HyperCDS-specific functions. Below that, a limited number of special-purpose Tcl <i>proc</i>s expose Cadence functions and data in a form compatible with the GUI's expectations. Finally, a core of general-purpose Tcl <i>proc</i>s manage communication with the Cadence system.</p><h3>The Devil Is in the Details</h3><p>In truth, the aforementioned overview oversimplifies the lowest levels &#151; it takes a leap of faith, for instance, to assume that SKILL and Tcl can exchange data across process boundaries. Fortunately, communication and integration with existing systems are among Tcl's strengths, while SKILL has several functions that can be used for communicating with other processes.</p><p>For instance, included in SKILL's communication options is <i>hiSkillProcess</i> (renamed <i>uiSkillProcess</i> in later CDS releases). <A NAME="rf1"><A HREF="0202df1.htm">Figure 1</A> illustrates dataflows for a child process started with <i>hiSkillProcess</i> communicating with the Cadence system. (A third process, the Cadence <i>serv daemon</i>, is involved as a go-between, but is transparent to SKILL and Tcl programs, and not addressed here.) There are SKILL functions for sending and receiving data through the client's standard channels. In addition to the usual <i>stdin</i>, <i>stdout</i>, and <i>stderr</i>, clients started with <i>hiSkillProcess</i> have two other channels open: The client can send SKILL code to the Cadence system on file descriptor 3 and get back code-evaluation results on fd4.</p><p>With the Cadence side of the interface awaiting SKILL to evaluate, it remains to build a mechanism for Tcl programmers to send SKILL to the Cadence interpreter and get a response back. Ideally, it would be as simple as <A NAME="rl1"><A HREF="#l1">Listing One</A>.</p><p>Depending on how the channel <i>file4</i> is configured, <i>read</i> either blocks waiting for data, or fails because no data is available. If it blocks, the UI locks up because no events can be processed. If it fails, you must poll for a response until one is received. However, even polling is insufficient because different parts of the Tcl application &#151; perhaps the actions associated with different buttons &#151; may require evaluation of different SKILL expressions at the same time. What you need to do is:</p><ol><li>Send the SKILL expression to Cadence for evaluation.<li>Let the Tcl application get on with its business (handling UI events or whatever).<li>Process the response when it comes.</li></ol><p>If you could be assured that the Cadence side would evaluate expressions on a first-in/first-out basis, this might succeed without special bookkeeping code to match responses to requests. However, the Cadence SKILL server operates on expressions asynchronously, giving no assurance about the order of responses.</p><p>Consequently, I turned to Section 7.6 of <i>Effective Tcl/Tk Programming</i> (Addison-Wesley, 1997), where Mark Harrison and Michael McLennan describe a client/server system that uses Tcl as a protocol. The client sends the server a Tcl command to evaluate, and includes a response template to be filled in and returned to the client. When the client receives the filled-in response, it evaluates the response to update its state as needed. In this way, the server can be used by a variety of clients with vastly different needs and the protocol is not hampered by fixed responses.</p><p>For instance, consider a server that accepts requests in the form of two-element lists. The first element of the list is a command to evaluate, the second element a response template. The server evaluates the first element, replaces the value for a token in the second element, and sends the second element back to the client. Neglecting issues about security, error recovery, and the like, the heart of the server might look like <A NAME="rl2"><A HREF="#l2">Listing Two</A>. A test console might exercise the server as in <A NAME="rl3"><A HREF="#l3">Listing Three</A> and a GUI interface might execute code like <A NAME="rl4"><A HREF="#l4">Listing Four</A>. The server's actions are identical in both instances, but the client-side requirements and actions are very different.</p><p>While the HyperCDS server evaluates SKILL (not Tcl), this solution maps well onto the problem and satisfies the requirement for asynchronous evaluation. In other words, instead of a client application saying to the interface, "Give me this data now," it says, "Get this data and here is what I'm going to do with it when it arrives."</p><h3>Refinement</h3><p>Unfortunately, the SKILL evaluation channels provided by <i>hiSkillProcess</i> give little control over the format of responses; you have no opportunity to parse the command and response template from requests or to put values into the response template. However, there is another function for starting client processes: <i>hiBeginProcess</i> (later <i>uiBeginProcess</i>) provides robust client/server I/O while providing more programmer control over transactions.</p><p>Together with functions for evaluating SKILL functions explicitly, <i>hiBeginProcess</i> is the foundation of the communications core of HyperCDS. When a client is started with <i>hiBeginProcess</i>, you set up the event handlers as in <A NAME="rl5"><A HREF="#l5">Listing Five</A> for the client's standard I/O channels. When starting a child process with <i>hiBeginProcess</i>, you specify handlers for the child's <i>stdout</i> and <i>stderr</i> channels. These handlers execute asynchronously from user interactions with the Cadence system and execution of SKILL programs. In our case, we use these handlers to provide a reporting mechanism for client messages and to perform interpretation of SKILL expressions.<i></p><p>tclEcho</i> is a function that echoes its argument to the Cadence command interpreter window (CIW) so that the Tcl application can report errors by writing to <i>stderr</i>; see <A NAME="rl6"><A HREF="#l6">Listing Six</A>. On the other hand, <i>tclInterp</i> is somewhat more complicated. Listing Ten (available electronically; see "Resource Center," page 5) is the function stripped of some error processing and limit handling (the complete function is also available electronically; see Listing Eleven). The client sends an expression to the server via <i>stdout</i> and receives the results of evaluating that expression on <i>stdin</i>, rather like a SKILL RPC mechanism. The server side breaks the received string into one or more requests, breaks each request into a command and response template, evaluates the command, fills in the template, and sends the filled-in response back to the client.</p><h3>Supportability</h3><p>As you'd hope, we did build a little insurance into the system. On the SKILL side, for instance, we allow for tracing transactions. At strategic points throughout the SKILL code, we include clauses like <A NAME="rl7"><A HREF="#l7">Listing Seven</A>.</p><p>When the global variable <i>serverTrace</i> is set, its integer value determines how detailed a level of tracing is recorded in the CIW log. In retrospect, this might be more flexible if we'd done something like <A NAME="rl8"><A HREF="#l8">Listing Eight</A>, which could be used like:</p><blockquote><p>(serverTrace 1 "tclInterp got &lt;&lt;%s&gt;&gt;" 					t_data)</p></blockquote><p>Still, the system is in place and works.</p><p>On the client side, we provide for tracing data exchange. Because we are more comfortable with Tcl, the facility is somewhat more sophisticated. First, when we initialize communication with the SKILL server, we specify a logging command to be invoked when interesting things happen in the interface. The <i>log</i> command can be straightforward:</p><blockquote><p>skill::ilInit -logCmd [list puts stderr]</p></blockquote><p>Listing Twelve (available electronically) is <i>cdsLog</i>, the actual <i>proc</i> used as an interface logging command in HyperCDS. It manages logging to a file and a widget for display. The first part of the <i>proc</i> checks to see if a global variable has been set to specify file logging. If so, it checks to see if the file is already open; if not, it opens it. Finally, it records the interface event to the file. (While it would be possible to set up a <i>proc</i> to close the file on exit, we rely on Tcl's assurance that it will flush and close when the process terminates.)</p><p>The second part of <i>cdsLog</i> handles displaying the log in a Tk text widget. Because logging may begin a relatively long time before the UI is ready to display the log, the log lines are buffered in a global variable until the text widget exists. When the widget exists, the buffer's contents are inserted in the widget and then unset. Thereafter, each time a new line is logged, it is added to the end of the widget's contents.</p><p>Under normal circumstances, the bottom of the log should remain in view and the contents scrolled up as each line is added. However, the log can be quite long and it is not uncommon to scroll back and view contents early in the log. To keep from frustrating users by resetting the view to the end on each update, we check to see what part of the log's contents are visible and only update the view if the bottom of the log was already at the bottom of the window.</p><p>The log is really only a debugging aid and we don't want to bother users with it most of the time. We could add a control or key binding in the HyperCDS GUI to open the log window, but while we are more comfortable in Tcl, HyperCDS users are generally more comfortable in Cadence and SKILL. Ideally, there would be a SKILL command that could be invoked in the Cadence CIW, which would tell the Tcl/Tk-based UI to open the log.</p><p>Recall that there is a Tcl interpreter waiting in the client to evaluate responses to server requests. Because of the asynchronous nature of the interface, that Tcl interpreter doesn't know where the incoming command came from. You can take advantage of this by sending a command from SKILL to Tcl to open the log window. A small wrapper function (see <A NAME="rl9"><A HREF="#l9">Listing Nine</A>) on the SKILL side takes care of hiding the details of the communication from users.</p><h3>Finishing Touches</h3><p>The <i>tclNotify</i> function wraps up to the SKILL-to-Tcl/Tk integration. The Cadence environment provides for a callback mechanism so SKILL-based tools can interact with &#151; and even stop &#151; the process of shutting down the Cadence system. Using <i>tclNotify</i>, you can register a callback that asks the Tcl/Tk GUI if it's okay to shut down. Listing Thirteen (available electronically) presents <i>ptiExitBefore</i>, which implements this technique. It begins by clearing a global variable used in the handshaking, sends the Tcl side of the interface a command to evaluate, and waits for the SKILL global to be set. The trick is that the arguments to the Tcl command are SKILL expressions. If the Tcl/Tk side determines that it is okay to exit, it sends back its first argument. If it's not okay, it sends back the second argument. When one or the other expression arrives, it is evaluated in a separate thread from the loop that's waiting for the global to be set. Evaluating the expression sets the global to true or false (<i>t</i> or <i>nil</i>). This, in turn, controls the return value of the exit callback. Voil&aacute;, the Tcl/Tk GUI controls the exit of the SKILL process. </p><p>By exploiting the common aspects of both languages and the strengths of each, we have a more user friendly, more functional, and more maintainable product.</p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>proc ilEval { expression } {    puts file3 $expression    return [read file4]}</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre># Get a request from the clientset request [read $clientIn]# Parse the command and response templateset command [lindex $request 0]set response [lindex $request 1]# Fill in the response and return it to the clientputs $clientOut [fillTemplate $response [eval $command]]</pre><P><A HREF="#rl2">Back to Article</A></P><H4><A NAME="l3">Listing Three</H4><pre># Set a value in the server, no response neededputs $server [list {set a 1} {}]# Get the value back to confirmset responseAction "The value of a is &lt;&lt;%r&gt;&gt;"puts $server [list {set a} $responseAction]</pre><P><A HREF="#rl3">Back to Article</A></P><H4><A NAME="l4">Listing Four</H4><pre># When the update button is clicked, get the value of the named variable, # and update the value entry with itset responseAction "$valueEntry select 0 end; $valueEntry insert end %r"$updateButton configure -command \        puts $server [list [list set [$variableEntry get]] $responseAction]</pre><P><A HREF="#rl4">Back to Article</A></P><H4><A NAME="l5">Listing Five</H4><pre>(setq tclProcess                  (hiBeginProcess cmdLine     ;; Command                                  ""          ;; Host name                                  'tclInterp  ;; stdout handling                                  'tclEcho    ;; stderr handling                                  'tclDone    ;; post-func                                  ))</pre><P><A HREF="#rl5">Back to Article</A></P><H4><A NAME="l6">Listing Six</H4><pre>;; Echo data received on stderr from child to CIW.;; This allows Tcl clients to put messages in the CIW with;;     [puts stderr ...].(defun tclEcho (x_childID t_data)    (printf "%s\n" t_data)    );;tclEcho</pre><P><A HREF="#rl6">Back to Article</A></P><H4><A NAME="l7">Listing Seven</H4><pre>(if (and (boundp 'serverTrace)              (geqp serverTrace 0))                (printf "\n$$$ tclInterp got &lt;&lt;%s&gt;&gt;\n" t_data))</pre><P><A HREF="#rl7">Back to Article</A></P><H4><A NAME="l8">Listing Eight</H4><pre>(defun serverTrace (level format @rest args)            (setq format (strcat "\n$$$ " format "\n"))            (if (and (boundp 'serverTraceLevel)                         (geqp serverTraceLevel level))                 (if args                     (eval (append (list 'printf format) args))                     (printf format)))           )</pre><P><A HREF="#rl8">Back to Article</A></P><H4><A NAME="l9">Listing Nine</H4><pre>(defun tclNotify (s)    (if (and (boundp 'tclProcess)             tclProcess)             (hiWriteChild tclProcess                          (sprintf nil "skill::IlNotify %s\n" s))            );; if    );; tclNotify</pre><P><A HREF="#rl9">Back to Article</A></P></body></html>