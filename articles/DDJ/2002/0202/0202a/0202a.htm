<html><head><title>Feb02: The MIT Lightweight Languages Workshop</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>The MIT Lightweight Languages Workshop</h1><p><i>Dr. Dobb's Journal</i> February 2002</p><h3>By Eugene Eric Kim</h3><I>Eugene is a freelance programmer and writer, and founder of the Open Hyperdocument System Launch Community (<a href="http://www.eekim.com/ohs/">http://www.eekim.com/ohs/</a>). He can be contacted at <a href="mailto:eekim@eekim.com">eekim@eekim.com</a>.</I><hr><p><i>Organized by the Dynamic Languages Group at the Massachusetts Institute of Technology's Artificial Intelligence Lab and cosponsored by </i>Dr. Dobb's Journal<i>, the primary purpose of the Lightweight Languages Workshop was to bring together programming language implementors from industry and programming language researchers from academia, put them all in the same room, and spark some lively discussion. Just to see how lively those discussions would be, Eugene Eric Kim attended the workshop and filed this report. Additionally, </i>DDJ<i> is webcasting portions of the workshop via our Technetcast service at <a href="http://www.ddj.com/technetcast/">http://www.ddj.com/technetcast/</a>.</p><p> &#151; Editors</p><DDJADVERTISEMENT INLINE></i><hr><p>Several months ago, in the hallowed halls of MIT's legendary Artificial Intelligence Lab, researchers Greg Sullivan and Mike Salib were practicing a time-honored academic tradition &#151; complaining.</p><p>Why, they asked, are mainstream languages so conservative? Why had interesting and useful research in areas such as garbage collection only recently crept into mainstream languages? And why, they sulked, don't language designers listen to academics? For that matter, why do designers struggle to add features such as lexical scoping and closures after the fact, when they should have designed these features into their languages from the start?</p><DDJADVERTISEMENT INLINE><p>To satisfy their curiosity and encourage collaboration between different language communities, Sullivan and Salib organized the Lightweight Languages Workshop (<a href="http://ll1.mit.edu/">http://ll1.mit.edu/</a>), held at MIT's AI Lab. Approximately 80 people attended the workshop, and although several languages &#151; from Scheme and Dylan to Perl and Python &#151; were represented, Lisp T-shirts were the dominant apparel. While the presentations were deeply technical, the discussions were as much about philosophy as about computer science.</p><h3>Is Worse Better?</h3><p>In many ways, Richard Gabriel's notion of "Worse Is Better" versus "The Right Thing" was the dominant theme of the workshop. In 1990, Gabriel wrote an essay (<a href="http://www.dreamsongs.com/WorseIsBetter.html">http://www.dreamsongs.com/WorseIsBetter.html</a>) that described two approaches to software development. His thesis was that software should start small and evolve according to the needs of its users. Although the result might not be necessarily pretty, it has greater odds of surviving and even flourishing.</p><table align="center"><tr><td><IMG SRC="0202af1.gif"></td></tr><tr><td><i>Guy Steele, Dan Weinreb, Jeremy Hylton, Ken Anderson, and Simon Cozens.</i></td></tr></table> <p>The first panel discussion was devoted entirely to Gabriel's thesis. Panelists included legendary language guru Guy Steele, Symbolics cofounder Dan Weinreb, Python developer Jeremy Hylton, language developer Ken Anderson, and Perl developer Simon Cozens.</p><p>All of the panelists seemed to agree on the categories in which their respective languages fell. Both Cozens and Hylton, for example, willingly classified Perl and Python as "Worse Is Better" languages. All of the panelists also agreed that tool availability and timing played as much of a role in a language's success as the language itself. And most of them seemed to agree with Gabriel's overall premise.</p><p>Weinreb was the sole exception. He challenged the dichotomy between "The Right Thing" and "Worse Is Better," noting that designers and users had different value systems, and that what designers consider "right" may not have any relevance to what the user wants or needs.</p><p>Weinreb also posed the question, "What constitutes release 1.0?" In other words, should a language be judged for its incompleteness, when over time, those omissions may go away? He pointed out that Java 1.0 did not include features he felt were important, such as generics, but that they are currently being added to the language. Had Sun postponed release 1.0 until those features were implemented, Java might have missed its opportunity for success. As it stands, features like generics are currently being added back into the language.</p><h3>Programmers as Language Designers</h3><p>A point echoed throughout the day was that all programmers are actually language designers, regardless of whether they are aware of it. Defining new functions, for instance, is equivalent to expanding a language's vocabulary, and as a result, programmers face many of the same issues as language designers. What constitutes a good function name? How long should the name be?</p><p>On a deeper level, one of the defining attributes of lightweight languages is that they are dynamic. Several presenters observed that programmers should take advantage of the compiler that comes built-in for them in most dynamic languages.</p><p>Olin Shivers, a professor of computer science at Georgia Tech and author of scsh (Scheme shell; <a href="http://www.swiss.ai.mit.edu/ftpdir/scsh/">http://www.swiss.ai.mit.edu/ftpdir/scsh/</a>), made a cogent argument for embedding "little languages" &#151; task-specific notations such as awk and yacc &#151; into lightweight languages, namely, Scheme. </p><p>Little language designers usually develop useful syntax for the task at hand, then often find themselves reinventing basic linguistic elements such as control statements. Shivers demonstrated how Scheme macros let designers add new syntax to Scheme while obviating the need to reinvent basic constructs  by embedding an awk library into Scheme. He also contrasted his strategy for little language design with the UNIX approach, noting that embedding multiple little languages into Scheme allowed all of these languages to access data structures directly.</p><table align="left"><tr><td><IMG SRC="0202af3.gif"></td></tr><tr><td><i>Shriram Krishnamurthi.</i></td></tr></table> <p>Shriram Krishnamurthi also evangelized the ability to redefine Scheme's syntax using macros. In one of the most engaging and spirited talks of the day, Krishnamurthi talked about the work his group &#151; PLT, a research effort spanning several universities (<a href="http://www.plt-scheme.org/">http://www.plt-scheme.org/</a>) &#151; was doing with the Scheme language. He first explained how Scheme could be just as practical a language as Perl or Python, mentioning PLT's work on integrated development environments, debuggers, documentation, and libraries.</p><p>Krishnamurthi then explained why he thought Scheme was beautiful. He presented a toy example of recognizing patterns in a stream of characters, showed the finite state machine that solved this problem, and then explained several different ways to implement the state machine. The punchline was that the state machine could be implemented in Scheme almost exactly as written, using a little careful thought and Scheme macros.</p><pre><p><P></pre><h3>Picking on Perl</h3><table align="right"><tr><td><IMG SRC="0202af2.gif"></td></tr><tr><td><i>Dan Sugalski.</i></td></tr></table> <p>Most of the talks were relatively uncontroversial. However, during the Simon Cozens and Dan Sugalski presentation on Perl 6, the clash of cultures quickly became apparent. Cozens and Sugalski gave an excellent summary of Perl 6's run-time engine, but their interaction with the audience was awkward, and the ensuing discussion, although reasoned, was heated.</p><p>Several attendees noted during the talk that the Perl community seemed to be reinventing the wheel in areas such as virtual-machine implementations and garbage collection. At times, the feedback included some not-so-subtle barbs. To their credit, Cozens and Sugalski accepted this feedback gracefully, requesting URLs so that they could examine the appropriate papers themselves.</p><p>Unfortunately, they occasionally inadvertently incited the crowd with their flippant remarks. Sugalski, for example, explained that Perl's run-time engine needed to support a number of high-level programming concepts, and he showed a slide that listed some of them. When coming across "continuations" on his slide, he said, "Let's skip that. I don't really understand them." Gasps were heard throughout the room, as Sugalski's blunt confession seemed to be proof that "Worse Is Better" communities were indeed ignorant of computer science.</p><p>Sugalski also stated that, for academics, "Perl is not very interesting." Although several members of the audience nodded in agreement, it was an unfortunate claim to make, because it was clear that neither Sugalski nor Cozens really knew what academics were interested in.</p><p>Jeremy Hylton and Waldemar Horwat received considerably less heat than their Perl peers, even though their respective languages &#151; Python and JavaScript &#151; were also acknowledged as "Worse Is Better" languages. Perhaps not coincidentally, both are MIT graduates and both related easily to the audience. Hylton talked about his efforts to fix scoping issues in Python, while Horwat described how JavaScript dealt with different class versions using namespaces. Horwat also demonstrated a Common LISP engine for specifying, verifying, and documenting JavaScript semantics.</p><p>Joe Marshall's talk on REBOL, while well received, was a classic case of "The Right Thing." Marshall, the main implementor of the first version of REBOL (see "The REBOL Scripting Language," by Carl Sassenrath, <i>DDJ</i>, July 2000) explained that the language has very little syntax, which makes it difficult to implement tail recursion. He then described how he solved the problem. When asked why he designed REBOL the way he did, Marshall responded, "I like writing languages." Marshall also added that many of the features in the first version of REBOL were omitted in the second, including his tail-recursion implementation.</p><h3>Other Languages</h3><p>The afternoon's talks consisted of Jonathan Bachrach on Proto, Christopher Barber on Curl, and David Simmons on SmallScript (<a href="http://www.smallscript.net/">http://www.smallscript.net/</a>). Bachrach was one of the developers of Dylan (see "The Dylan Programming Language," by Tamme D. Bowen and Kelly M. Hall, <i>DDJ</i> Special Issue on Alternative Programming Languages, 1994), and his goal for Proto is to develop a research and teaching vehicle specifically targeted towards real-time systems. Curl is a Lisp-like language for developing client-side web content (see "The Curl Programming Environment," by Friedger M&uuml;ffke, <i>DDJ</i>, September 2001). Barber focused his discussion on Curl's component model. Simmons described his SmallScript language, a subset of Smalltalk whose run time relies entirely on JITs.</p><table align="left"><tr><td><IMG SRC="0202af4.gif"></td></tr><tr><td><i>Paul Graham.</i></td></tr></table> <p>Paul Graham softened the mood at the end of the day with an entertaining and insightful presentation on Arc (<a href="http://www.paulgraham.com/paulgraham/arc.html">http://www.paulgraham.com/paulgraham/arc.html</a>). Graham founded Viaweb &#151; which was acquired by Yahoo! and became Yahoo! Stores &#151; and he had written much of the software in Lisp. He observed that the advent of server-side applications freed programmers to use whatever languages they wished. He also observed that there hadn't been a new dialect of Lisp since the mid 1980s, and that the present seemed as good a time as any to develop one.</p><p>Graham is developing Arc specifically for web development, and one of his requirements is that the language be fast. One of his colleagues had remarked that with Lisp, it was hard to tell whether the code was expensive. Graham responded that this was really the role of a profiler, not the language itself. However, to be complete, Arc would have to have a profiler, echoing the earlier workshop sentiments about the importance of tools.</p><p>Confessing that he had only been working on the language for about two weeks and that all features were subject to change, Graham proceeded to present what did exist. A number of Arc's features were aesthetic. For example, inspired by Perl's brevity, he chose to shorten some of Lisp's function names, such as "<i>lambda</i>" to "<i>fn</i>."</p><h3>The Future</h3><p>The workshop closed with a panel discussion on the future of lightweight languages. Panelists included Bruce Lewis (creator of the BRL2 reporting language), Sugalski, Graham, Bachrach, and Shivers. Shivers expounded on a number of topics, ranging from the robustness of software to the importance of engineering. He then stated that little languages would play an important role in all of these topics. Although little languages are restricted in power, they make up for that by being easier to analyze. Hence, they can be used to build more robust systems.</p><p>Jonathan Bachrach, one of the key developers of Dylan and of the new language Proto (<a href="http://www.ai.mit.edu/~jrb/proto/">http://www.ai.mit.edu/~jrb/proto/</a>), presented a laundry list of items he wanted to see addressed in the future. Several of his items stood out because they suggested that innovation was possible where many had stopped looking. He told the audience that the Lisp macro system is not the last story, that Prolog is not the end-all-and-be-all of constraint-based languages, and that there needs to be something better for writing code than emacs.</p><p>The workshop was intense and productive. However, examined in light of Sullivan and Salib's hope for cross fertilization of ideas, one thing was glaringly apparent &#151; collaboration requires communication, and communication requires cultural understanding. Unfortunately, the latter is lacking, as was evident during the Perl talk.</p><p>Cozens and Sugalski are well respected in the Perl community, but the quality of interaction would have been much different had someone better versed in functional languages &#151; such as Perl creator Larry Wall &#151; attended. At the same time, the two were unfairly, if indirectly, attacked for not being part of the community predominantly represented at the workshop.</p><p>Members of "Worse Is Better" communities need to do a better job of utilizing and contributing to the academic system for disseminating knowledge. At the same time, members of "The Right Thing" community need to understand that there is in fact much to be learned from other languages, despite the lack of S-expressions and parenthetical syntax.</p><p>Fortunately, the will to collaborate is clearly shared, and the workshop did much to facilitate this by simply bringing these researchers together in one room. Many of the most interesting discussions occurred between presentations, during lunch, and after the workshop over liquid nitrogen ice cream, and they continue even now on the workshop's mailing lists.</p><p><b>DDJ</b></p></body></html>