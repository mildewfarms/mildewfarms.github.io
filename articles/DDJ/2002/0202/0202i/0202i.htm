<html><head><title>Feb02: Programmer's Toolchest</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Borland's CLX Component Framework</h1><p><i>Dr. Dobb's Journal</i> February 2002</p><h2>A RAD tool for Linux</h2><h3>By Ray Lischner</h3><I>Ray is the author of </i>Delphi In a Nutshell <i>(ISBN 1-56592-659-5) and other books. You can contact him at <a href="mailto:lisch@tempest-sw.com">lisch@tempest-sw.com</a>.</I><hr><p>CLX (pronounced "clicks") is a component framework for cross-platform development from Borland Software (<a href="http://www.borland.com/kylix/">http://www.borland.com/kylix/</a>). Although CLX originated in Kylix, Borland's rapid application development tool for Linux, it is also available for Windows in Delphi 6. </p><p>CLX is written in Borland's version of Object Pascal, which has evolved over the years. Its current incarnation in Kylix and Delphi is a modern, object-oriented language with a Java-like object model (single inheritance of classes, and a class can implement multiple interfaces), resizeable arrays, copy-on-write strings, Unicode support, exception handling (see "Exception Handling in Kylix," by Eli Boling and Chuck Jazdzewski, <i>DDJ</i>, November 2001), and other conveniences programmers now expect. (Generic types are an exception, but then you can't have everything.) </p><DDJADVERTISEMENT INLINE><p>CLX has four major parts:</p><ul>  <li>BaseCLX, the core run-time library, which contains utility classes and routines, the standard exception classes, date and time manipulation, I/O and streaming, string manipulation, and so on.  <li>VisualCLX, the widget library, which uses Qt for drawing and user interaction. It is not a mere layer above Qt, though. VisualCLX introduces its own event-handling mechanism and widget set. Some VisualCLX widgets are wrappers around Qt widgets, but there is no attempt to make VisualCLX Qt-like. Instead, VisualCLX closely resembles the Visual Component Library (VCL), the Windows-specific component framework in Borland's Delphi and C++ Builder.  <li>DataCLX, the database interface library, which uses dbExpress, Borland's cross-platform database engine. Currently, dbExpress supports Oracle, DB/2, Interbase, and MySQL.   <li>NetCLX, the Internet and socket library. Part of NetCLX includes the Indy Internet component suite, a freeware project from Nevrona Designs (<a href="http://www.nevrona.com/indy">http://www.nevrona.com/indy</a>). NetCLX also includes web server components that make it easy to write CGI applications and Apache modules.</ul><h3>Kylix Pascal Features</h3><p>Borland designed its Object Pascal implementation specifically for use in Delphi and Kylix. Two of its key features are published declarations and properties:</p><p></p><ul>  <li>In addition to fields (also called "data members" or "instance variables") and methods ("member functions"), Kylix classes can have properties. A property has syntax similar to a field, but with the semantics of a method (or more accurately, several methods). In their simplest form, properties have a name and type and map to a field or method. Reading the property value gets the value from the field or calls a function method. Setting the property value assigns the new value to a field or passes the value to a procedure method. A property can also be read-only by omitting the writer.  <li>A common idiom is for a property's reader to map directly to a field, and the writer maps to a method that checks the validity of the new value before storing it. Properties are the preferred mechanism for accessing an object's state or other attributes.</ul><p><A NAME="rl1"><A HREF="#l1">Listing One</A> is a typical property declaration for a property named <i>Color</i>, of type <i>TColor</i>. (A common Delphi and Kylix convention is to name types with a leading <i>T</i>.) The reader maps to the field <i>FColor </i>(another convention is to name fields with a leading <i>F</i>), and the writer uses the <i>SetColor</i> method.</p><p>Kylix's GUI builder relies on properties for manipulating components at design time. Every component class declares properties for the attributes that can be manipulated at design time, such as caption, color, size, and position. Events (such as a button's <i>OnClick</i>, or an edit box's <i>OnKeyDown</i>) are also properties, where the property type is a method pointer. Thus, event handlers are ordinary methods.</p><p>The GUI builder knows which properties are important because you declare these properties as published. Published declarations have the same visibility and access rules as public declarations; the difference is that the compiler stores run-time type information (RTTI) for all published declarations. The GUI builder reads the RTTI to know which properties to present at design time and how to get and set those properties.</p><p>Fields and methods can also be published. When designing a form (which is the Kylix term for a window or dialog box), the form is represented by a form class. Every component you drop on the form has a corresponding published field declaration. At run time, the field stores an object reference for the component. The field name is the same as the component name. When you change the name in the GUI builder, Kylix automatically updates your source code. Published methods are eligible for use as event handlers. When you assign event handlers in the GUI builder, you can pick an existing method in the form class or create a new method.</p><p>To further enhance Kylix's extensibility, you can install custom property editors by writing a class that implements the <i>IEditor</i> interface. Each property has an associated property editor. The property editor maps property values to strings so the strings can be displayed in the property editor, then maps user-edited strings back to property values, such as integers (<i>Height</i>, for instance), dates and times, and so on. Utility routines in BaseCLX provide additional routines for working with RTTI, such as mapping enumerated literals to/from strings.</p><p>A property editor can also display a drop-down list of choices, open a dialog box, or do almost anything in response to a user's mouse click. </p><h3>Components</h3><p>The root of the component class hierarchy is <i>TComponent</i>, which publishes two properties: <i>Name</i> and <i>Tag</i>. Every component must have a name, and the name must be unique on the form. The tag is an integer that is not used by Kylix. You can freely use it for any use.</p><p><i>TComponent</i> also declares a number of methods to support the component framework. In particular, any component can be the owner of any number of other components. The owner is responsible for managing the lifetime of its components. In other words, when the owner is freed, it must free its children. Every component you drop on a form at design time is owned by the form class. Thus, when the form is freed, it automatically frees all the controls and other components that are on the form.</p><p>Independent of the ownership hierarchy, the component framework supports a parentage hierarchy. Widget controls implement parentage visually. That is, a button can be a child of a panel, in which case the button appears on top of the panel and the button's position is relative to the panel. Move the panel in the form editor, and the button moves with it. Menus implement parentage to reflect the menu item hierarchy: Each menu item is represented by a <i>TMenuItem</i> component, which can have a submenu with child <i>TMenuItem</i> components. Similarly, a data set can have child components to represent the database fields (columns). Different classes implement the notion of parentage differently, but they all use the same mechanism defined by the <i>TComponent</i> class.</p><h3>BaseCLX</h3><p>BaseCLX is the core run-time library. It includes the Pascal run-time library (a suite of utility routines) and classes that form the foundation of CLX. The rest of CLX depends on BaseCLX. For example, BaseCLX declares <i>TComponent</i>, which is the base class for all other components.</p><p>The most important elements of BaseCLX are:</p><ul>  <li>Component foundation (the <i>TComponent</i> and related classes). A form description is stored in a separate file (with the extension .xfm). BaseCLX takes care of saving and loading form descriptions. The Kylix linker includes the form descriptions in the program file, so you never need to worry about deploying or configuring the form descriptions. Everything is handled automatically. (And if you wish, you can customize it by storing any additional information you want.)  <li>String manipulation routines, including support for Unicode strings, UTF-8, and plain ANSI strings. (Most routines work with ANSI and UTF-8 strings. The language supports Unicode strings, but the run-time library is taking longer to catch up.)  <li>Date and time manipulation routines. Dates and times are represented by a double-precision floating-point number, storing the number of days since the start of the day on December 30, 1899, thereby preserving compatibility with Delphi and Windows. The fractional part of the date/time value stores fractional days to your desired precision. Many routines exist to extract parts of a date or time, build a date or time from constituent parts, test for leap year, and perform other date/time manipulation. Borland didn't include routines to convert between local time and UTC, but has included routines to convert to/from UNIX <i>time_t</i> values.  <li>Filename manipulation routines. Build a path from parts, or extract parts of a path. Declarations, such as <i>PathDelim </i>for the directory delimiter in a path name, provide portability between Delphi and Kylix.  <li>Standard exception classes and other error-handling routines. The Kylix Pascal language lets you raise any object in an exception. By convention, exception classes derive from <i>Exception</i> or one of its children. The <i>Exception</i> class holds a string message and various constructors let you create the message as a plain or formatted string, possibly with an associated help topic. Another useful routine is <i>RaiseLastOSError</i>, which raises an exception that incorporates the error code from <i>errno</i>.  <li>Formatting routines. Kylix automatically queries the locale for information on formatting numbers, currency, and dates and times. Various routines give you flexibility in formatting numbers with different precision, padding, and so on. Several routines exist to format dates and times, using names and formatting information from the locale.  <li>Operator overloading with custom <i>Variant</i>s. Pascal is a statically typed language, but Kylix Pascal also supports <i>Variant</i> types, which have dynamic types. A <i>Variant</i>-typed variable can change its type at run time. Kylix comes with predefined <i>Variant</i>s for integers, strings, objects, and more. You can also declare custom <i>Variant</i> types, which confers a form of operator overloading. Commercial editions of Kylix come with a CD-ROM that has an example of a custom <i>Variant</i> that adds support for rational numbers.</ul><h3>VisualCLX</h3><p>VisualCLX, the visual part of the framework, contains the forms and controls you drop on a form. It also contains some nonvisual components that support visual interfaces such as timers, image lists, and action lists.</p><p>Visual controls derive from <i>TControl</i>, which is a child of <i>TComponent</i>. <i>TControl </i>introduces numerous methods for managing visual control such as handling mouse events, drag and drop actions, moving and alignment, and resizing (including constraints on the control's size). <i>TControl</i> publishes some properties that are common to all visual controls such as Left, Top, Width, and Height.</p><p>Control classes do not derive directly from <i>TControl</i>, but from other, more derived classes. There are two kinds of visual controls: graphic controls (which have no keyboard interface) and widget controls (which do). Thus, a control class typically derives from <i>TGraphicControl</i> or <i>TCustomControl</i> (which is a subclass of <i>TWidgetControl</i>).</p><p>Graphic controls cannot get the keyboard focus, so they cannot respond to keyboard events, but they can respond to mouse events. Most important, a graphic control must draw itself on the form, so <i>TGraphicControl</i> provides support for a canvas and derived classes must override the <i>Paint</i> method.</p><p>A <i>TCanvas</i> object is the CLX way of drawing on the screen or off screen. A canvas manages a graphical state (pen, brush, and font), and it has methods for drawing primitives (arcs, lines, text, and so on), clipping, bitblts, and so on. Any control that is visible on a form must paint itself on a canvas.<i></p><p>TWidgetControl</i> declares additional methods for managing the keyboard focus and keyboard events. <i>TCustomControl</i> derives from <i>TWidgetControl</i> and adds support for a canvas, so most widget controls derive from <i>TCustomControl</i>. </p><p>Kylix supports standard widgets: buttons, labels, edit boxes, checkboxes, and so on. Many of the controls are wrappers around Qt widgets. Others are more complicated. An important component is <i>TActionList</i>, which contains a set of actions. An action takes care of common behavior for multiple, related user-interface elements. For example, you can tie a menu item and a toolbar button to the same action. Instead of defining event handlers for the menu item and toolbar button, you use a single event handler for the action. You can also enable/disable the action, and it automatically updates all controls that are tied to it. Actions and action lists simplify the implementation of complex UIs.</p><p>One area where Kylix shows a weakness is in layout control. Positions are specified in terms of pixels. To compensate for different screen resolutions, you set the form's <i>Scaled</i> property, which attempts to scale the form and its contents according to the local screen resolution (relative to the developer's screen resolution). Designing UIs that look good at multiple screen resolutions is feasible, but remains a challenge.</p><h3>DataCLX</h3><p>DataCLX is the database interface. The Desktop Developer edition has support for MySQL and Interbase, while the Server Developer edition adds native interfaces for Oracle and DB/2. In both editions, DataCLX includes data-aware controls and data-management components.</p><p>The data-aware controls mirror the ordinary visual controls; for instance, <i>TEdit </i>is an edit box and <i>TDbEdit</i> a data-aware edit box. Data-aware controls are tied directly to a specific field in a specific data set (a table or a query). The value to display in the edit box is obtained from the data set, and when the user edits the text, the edited text is copied into the database record. A database navigator control lets the end user choose which record to edit, post changes to the database, or abandon changes to the current record. Depending on your UI needs, you might not use the navigator and define other ways to choose records, post changes, and so on. It's simply a matter of calling a few methods of the data-source object.</p><p>dbExpress, the database interface layer, is a cross-platform library that provides a thin, fast interface to native database drivers. One omission is the lack of a PostgreSQL driver. </p><p>The database control and management components use the same component framework. Obviously, a table or query component is not a visual control, so they derive from <i>TComponent</i> instead of <i>TControl</i>. The mechanism of using published properties and events is the same, though. To help write database applications, you can use a data module, which is like a form that's visible only at design time. When developing the application, you can drop nonvisual components on the data module. At run time, those components behave normally, but there is no form. That way you can cleanly separate the visual aspects of your application (using one or more forms) from the database management aspects (using data modules).</p><h3>NetCLX</h3><p>NetCLX is the network and socket interface, and includes Indy (a suite of open-source Internet components) that supports most of the popular Internet protocols. NetCLX also has web server components and wizards for CGI and Apache development.</p><p>Indy components come with the commercial releases of Kylix and are also available separately from Nevrona Designs for use in Delphi, C++ Builder, and Kylix. They support most of the popular Internet protocols, including FTP, NNTP, POP3, and HTTP, for clients and servers. Additional components provide MIME and UU encoding and decoding, MD4 and MD5 hashing, and other miscellaneous utilities. The suite comes with plenty of demo projects. (If you purchased a commercial edition of Kylix, you should download the demos to replace the ones that come on the CD.)</p><p>Web server components only come with the Server Developer edition. The key component is the web module, which is like a data module, but handles the details of CGI or Apache modules. There are several ways to generate HTML pages for web server projects, the simplest being to use a page producer component. You mark up an HTML template with ordinary HTML tags and special tags that are decoded at run time. You supply the code to handle the special tags by writing ordinary Pascal code. This has the advantage of being much faster than interpreted solutions (PHP, ASP, or whatever), but is slightly harder to code because you must keep the HTML template separate from the Pascal code.</p><p>Consider a CGI application that displays all the environment variables it knows about. This is a useful debugging tool, in spite of its simplicity. With NetCLX, start by creating a new CGI project. Choose a CGI or Apache module; the former is simpler because it is a standalone program. An Apache module is built as a dynamic shared object (DSO) and is a little more complicated. Once Kylix sets up the web module, though, they work the same. Drop a page producer component on the web module, and set up the HTML template. <A NAME="rl2"><A HREF="#l2">Listing Two</A> is the HTML template. The <i>&lt;#env&gt;</i> tag is a special tag that is replaced at run time with the actual environment variable list.</p><p>At run time, the web module calls the page producer's <i>OnHTMLTag</i> event. This event handler is just like any other event handler, but the "event" in this case is not a user interaction but the HTML parser encountering a special tag. The event handler (<A NAME="rl3"><A HREF="#l3">Listing Three</A>) examines the environment variables and formats them as simple HTML text. Hook up the page producer as the default action for the web module, compile, and go. NetCLX handles the details, leaving you to program the important guts of the CGI application.</p><h3>FreeCLX</h3><p>Borland licenses the commercial releases of Kylix under a dual license. You can write closed-source proprietary applications, or release the application and source code under the GNU Public License (GPL). In either case, you do not need to pay any additional fees to Borland or TrollTech &#151; Borland has arranged a license so you can use Qt as part of CLX, even in a commercial, closed-source application.</p><p>To facilitate open-source development under the GPL, Borland released Kylix Open Edition (OE) as a free download from <a href="http://www.borland.com/">http://www.borland.com/</a>. All applications developed with Kylix OE must be released under the GPL. Kylix OE comes with a small set of components, but you can download the Indy components (from <a href="http://www.nevrona.com/indy">http://www.nevrona.com/indy</a>), and web sites are springing up to offer a variety of Kylix components.</p><p>Borland has also placed the source code to BaseCLX, VisualCLX, and the data-aware controls of DataCLX on Source Forge under the name FreeCLX (<a href="http://freeclx.sf.net/">http://freeclx.sf.net/</a>). Developers with a commercial Kylix license can use the updated source code. Kylix OE and other users can use the source code under the GPL.</p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>type  TPrettyInPink = class(TComponent)  private    FColor: TColor;    procedure SetColor(NewColor: TColor);    ...  published    property Color: TColor read FColor write SetColor;    ...</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>&lt;html&gt;&lt;head&gt;&lt;title&gt;Environment Variables&lt;/title&gt;&lt;/html&gt;&lt;body&gt;&lt;h1&gt;Kylix Example&lt;/h1&gt;&lt;p&gt;This page was produced by&lt;a href="http://www.borland.com/kylix"&gt;Kylix&lt;/a&gt;,Borland's Rapid Application Development tool for Linux.&lt;/p&gt;&lt;p&gt;&lt;#env&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</pre><P><A HREF="#rl2">Back to Article</A></P><H4><A NAME="l3">Listing Three</H4><pre>procedure TWebModule1.PageProducer1HTMLTag(Sender: TObject;  Tag: TTag; const TagString: string; TagParams: TStrings;  var ReplaceText: String);var  Env: PPChar;begin  if TagString = 'env' then  begin    ReplaceText := '';    Env := envp;    while Assigned(Env^) do    begin      ReplaceText := ReplaceText + Env^ + '&lt;br&gt;'#13#10;      Inc(Env);    end;  endend;</pre><P><A HREF="#rl3">Back to Article</A></P></body></html>