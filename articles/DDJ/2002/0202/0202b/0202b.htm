<html><head><title>Feb02: Mondrian for .NET</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Mondrian for .NET</h1><p><i>Dr. Dobb's Journal</i> February 2002</p><h2>A functional language to work with object-oriented languages </h2><h3>By Jason Smith, Nigel Perry, and Erik Meijer</h3><I>Nigel is a senior fellow and Jason a research assistant at the University of Canterbury, New Zealand. Erik is a program manager with Microsoft's Common Language Runtime team and adjunct professor of Computer Science at the Oregon Graduate Institute. Nigel and Erik can be contacted at <a href="mailto:nigel@cosc.canterbury.ac.nz">nigel@cosc.canterbury.ac.nz</a> and <a href="mailto:emeijer@microsoft.com">emeijer@microsoft.com</a>, respectively.</I><hr><p>Mondrian is a purely functional language specifically designed to leverage the possibilities of the .NET Framework. It brings powerful algorithm expression and scripting techniques to .NET programmers. For web programmers, Mondrian introduces multilanguage ASP.NET, where both C# and Mondrian code can be included on the same page. Mondrian runs under Visual Studio.NET and is freely available at <a href="http://www.mondrian-script.org/">http://www.mondrian-script.org/</a>. (Versions work with .NET Beta 1, Beta 2, and RC1 as released at PDC 2001.) </p><p>Mondrian is designed to interwork with object-oriented languages; as such, it is a blend of the two paradigms. From its functional heritage (in particular, that of Haskell), it offers:</p><DDJADVERTISEMENT INLINE><ul>  <li>Higher order functions. Functions are first-class values and may be passed as function arguments and returned as results; new functions may be created dynamically.  <li>Just-In-Time (JIT) evaluation. Work is not done until needed and is cached once it has been done the first time (usually termed "lazy" or "nonstrict" evaluation in the functional world).  <li>Monadic I/O. Allows complex side-effecting computations to be constructed from simpler ones.</ul><p>From the .NET Common Language Runtime (CLR) and C#, influenced by Massey Hope<sup>+</sup>C and Haskell, Mondrian offers:</p><ul>  <li>Object-oriented friendly types. The ways of defining and using types are rather different in the functional and object-oriented paradigms. The Mondrian type system provides the flexibility of functional language type systems, while providing maximum compatibility with object-oriented languages. The syntax of type declarations leans toward the object-oriented style.  <li>Multiple threads and thread synchronization primitives. Programs may consist of threads written in different languages.   <li>Full support for exceptions, including cross-language throwing and catching.</ul><p>The language syntax resembles a meld of C# and traditional functional languages to simplify use.</p><p>Mondrian code can call routines written in other .NET-hosted languages, and one of its design goals was to be useful as a scripting language. Mondrian also supports standalone programming and being called from other .NET-hosted languages. The latter lets you exploit the particular strengths of functional languages in projects primarily written in other languages.</p><h3>Why Use Functional Languages?</h3><p>Functional languages are so named because they are based entirely on functions, the term being used here in the mathematical sense. Functional languages contain no conventional assignment or flow-of-control statements; algorithms are expressed as mappings from input values to output values. This means that, in functional languages, you can concern yourself with the higher level details of what you want accomplished, and not with the lower level details of how it is accomplished. In turn, this reduces both development and maintenance costs.</p><p>Expressing an algorithm is often clearer and more concise than in traditional imperative languages. Furthermore JIT evaluation, where work is not done unless it is needed, opens up new ways of solving problems. </p><p><b>Composing Financial Contracts. </b>Recent work in evaluating financial contracts has been reported by Simon Peyton Jones of Microsoft Research, Jean-Marc Ebar of LexiFi Technologies, and Julian Seward of the University of Glasgow, in the paper "Composing Contracts: An Adventure in Financial Engineering" (<a href="http://research.microsoft.com/Users/simonpj/Papers/contracts-icfp.htm">http://research.microsoft.com/Users/simonpj/Papers/contracts-icfp.htm</a>).</p><p>Financial contracts can become quite complex, but are usually composed from a set of basic operations. Higher order programming, which allows larger functions to be composed from smaller ones, let Peyton Jones et al. flexibly construct more complex contracts from basic operations, paralleling the real-world process.</p><p>To evaluate a contract over a period of time, "value trees" are used, which represent a discrete approximation of the continuous process; for example, the interest-rate evolution. Computing a value tree can be intensive because its size is quadratic in the number of time steps it covers. Furthermore, complex contracts result in combining many value trees, so evaluating financial contracts is traditionally computationally intensive. However, Peyton Jones et al. significantly reduced the computation required by using a functional language. This occurs because only a path through the value tree is needed, and JIT evaluation performs just enough work to compute that path. In a traditional imperative or object-oriented language, the whole value tree is produced, doing much unneeded computation in the process.</p><p><b>Designing Chips. </b>Traditional implementations of the Fast Fourier Transform (FFT) algorithm involve repeated iterations over arrays. In recent years, researchers have been working on new formulations of traditional algorithms. This work has produced purely functional implementations of a number of algorithms, including FFT. By "purely functional," we mean that the algorithm is defined as the composition of a number of functions. In a simple linear composition, data is fed into the first function: Its result becomes the input to the second function, and so on. Composition doesn't need to be linear &#151; networks of functions can be created and the data flows around it. Function composition is a basic feature of functional programming languages and can be expressed clearly and concisely. </p><p>Digital circuits are made up of a number of functional units (gates and the like) connected by wires (connections on the chip). Functional composition is a direct model of this. This connection between functional programs and digital circuitry has caught the interest of fabricators, and functional languages are now being used to design and model real chips. (Work in this area, for example, is underway at Sweden's Chalmers University in association with various commercial companies, including Xilinx.)</p><p><b>Enter .NET. </b>Real-world applications of functional programming range from programming telephone exchanges to graphical animation packages (for more information, see <a href="http://www.haskell.org/practice.html">http://www.haskell.org/practice.html</a>). However, it would be wrong to suggest that functional languages are the best tools for all programming tasks. Indeed, it would be wrong to claim that for any language or paradigm. As the history of PL/1 shows, no single programming language can be completely general purpose.</p><p>This is where .NET enters the picture. It lets you choose the most appropriate language for different parts of your applications. Mondrian for .NET lets you program your whole solution in a functional language if you wish. However, just as important, it lets you mix-and-match languages to exploit their particular powers  and improve solutions whenever the use of the functional programming paradigm is most appropriate.</p><h3>Algorithm Specification:  Keep It Readable</h3><p>To demonstrate the clarity of functional programming, we will compare QuickSort coded in C# and Mondrian.</p><p>The QuickSort algorithm can be described as follows (where "collection" means any collection type &#151; list, array, and so on):</p><ol><li>If the collection has only one element, it is sorted.<li>Select an element from the collection, call this the <i>pivot</i>. Any element will do; the first or last is often chosen.<li>Partition the remaining elements in the collection into two. The first partition should contain all those elements less than the <i>pivot</i>, the second all those greater or equal to the <i>pivot</i>.<li>Recursively perform the algorithm on the two partitions.<li>Join the (now sorted) first partition, the <i>pivot</i>, and the second partition together to form the final sorted collection.</li></ol><p><A NAME="rl1"><A HREF="#l1">Listing One</A> is the core of QuickSort written in C#. (A complete program demonstrating its use is available electronically; see "Resource Center," page 5.) This algorithm is not particularly complex, yet the correctness of it, in particular the <i>partition</i> function, is hard to determine. How much time has been lost over the years correcting invalid array index computations in algorithms such as this?</p><p>In contrast, <A NAME="rl2"><A HREF="#l2">Listing Two</A> is the core of QuickSort written in Mondrian (again, a complete implementation is available electronically). This implementation is more concise and clearer than the C# version. Its correctness is simple to determine, no danger of catching "indexitis" here.</p><p>Our implementation uses Mondrian's standard <i>filter</i> function to split the data into the two partitions required by the algorithm. The <i>filter</i> function takes a predicate function and a list, and returns all items in the list for which the predicate is True (a complete definition for <i>filter</i> is available electronically). The code <i>x -&gt; compare x pivot </i>denotes an inline anonymous function that uses the supplied comparison argument, <i>compare</i>, to define a predicate that selects all items less than the <i>pivot</i> value. The second application of <i>filter</i> selects all items greater than or equal to the <i>pivot</i> by negating (<i>not</i>) the result of the comparison function. The operator "++" is list concatenation.</p><p>In case you think we are cheating in this comparison by using the defined function <i>filter</i>, <A NAME="rl3"><A HREF="#l3">Listing Three</A> is <i>partition</i> in Mondrian. The type <i>Pair</i> is standard in Mondrian and enables functions to easily return two values. Its definition is trivial and it is equivalent to a two-field structure in C#. (An implementation of QuickSort using <i>partition</i> is available electronically.)</p><h3>JIT Evaluation: Don't Do Unnecessary Work!</h3><p>JIT evaluation is a key concept in functional programming. JIT evaluation simply means that a computation is not actually performed until its result is needed; and once the computation has been performed, its value is cached. In particular, this means that unlike most programming languages, arguments to functions are not evaluated unless the function actually needs the value. JIT evaluation also allows the definition of potentially "infinite" data structures, but only the part traversed by the application is actually built in memory, and already traversed portions are garbage collected. For example, this Mondrian code defines the infinite list of all integers <IMG SRC="gteq.gif" WIDTH="9" HEIGHT="11"> <i>n</i> (where "::" is Mondrian's list construction operator):</p><blockquote><p>// from : Integer -&gt; List&lt;Integer&gt;;</p><p>from = n -&gt; n :: from(n + 1);</p></blockquote><p>A call such as<i> from 2 </i>returns immediately, as the recursive call is not actually performed until the tail of the list is required. In contrast, if <i>from</i> would be defined in a strict language such as C#, then the call <i>from(2) </i>would either produce a stack overflow or, if you have a huge amount of memory, an overflow exception would result as C# tried to create a list of all integers <IMG SRC="gteq.gif"> 2.<i></p><p></i><b>The Sieve of Eratosthenes. </b>Primes are useful in many algorithms; for example, in cryptography algorithms and random-number generators. The Sieve of Eratosthenes is a well-known and simple algorithm for generating primes:</p><ol><li>Initialize some collection (array, list, set, and the like) to contain integers starting from 2 and going up to some limit.<li>Remove the least number from this collection; it is a prime.<li>If another prime is required, then remove from the collection all multiples of the prime found in step 2.<li>Go to step 2.</li></ol><p>To code the Sieve in a procedural language, an array of some fixed size, <i>n,</i> is used, which is then sieved to produce all the primes <IMG SRC="lteq12.gif"><i>n</i>. <A NAME="rl4"><A HREF="#l4">Listing Four</A> is a C# version of the Sieve, where <i>ArrayList</i> (from the .NET Framework) provides an extensible array. The algorithm cannot use an extensible array for the collection from which primes are generated; this must be a fixed-sized array, or the sieve would not work.</p><p>The Sieve algorithm in Mondrian (<A NAME="rl5"><A HREF="#l5">Listing Five</A>) uses the built-in <i>from</i> function to generate a list of all the natural numbers, then sieves this list to calculate a list of all the primes on demand. In contrast to the procedural version, this implementation can determine the first <i>n</i> primes for all <i>n</i>. </p><p>As with QuickSort, we use the standard <i>filter</i> function. In this case, the predicate is the inline function<i> x -&gt; x % y != </i>0<i> </i>that returns True if <i>x</i> is not a multiple of <i>y</i>.</p><p><b>The Best of Both Worlds.</b> The Mondrian realization of the Sieve of Eratosthenes is both simpler and more flexible than the C# version being able to provide all the primes <IMG SRC="lteq12.gif"> <i>n</i> or the first <i>n</i> primes. However, calculating primes is probably only a small part of a particular solution and other parts of that solution might be better written, for various reasons, in another language such as C#. Can you combine the benefits of using Mondrian for algorithms such as these with the benefits provided by other languages in other areas; for example, in producing GUIs? With .NET, the answer is "yes." One of .NET's strengths is its support for multilanguage programming. Whether you wish to use a whole library written in another language or just a single routine, .NET (through its CLR) provides a simple way to achieve this. Well, for some languages anyway.</p><p>Mondrian, with its JIT evaluation, is not compiled in quite the same way as typical object-oriented and procedural languages. This doesn't mean JIT evaluation cannot be compiled well onto .NET &#151; it just means that calling a Mondrian function from, say, C# is a little different than calling, say, a Visual Basic function.</p><p><A NAME="rl6"><A HREF="#l6">Listing Six</A> is a C# class that provides an object-oriented iterator-style interface to the Mondrian prime generator in <A NAME="rl5"><A HREF="#l5">Listing Five</A>. A Mondrian function, such as <i>primes, </i>is accessible from other .NET languages as a class with a method <i>Apply</i>. The <i>Apply</i> method handles the interface between Mondrian's JIT evaluation model and the strict model of .NET, similar to the way the standard class <i>System.Delegate</i> provides an <i>invoke</i> method. The functions/classes <i>mondrian.prelude.hd</i> and <i>mondrian.prelude.tl</i> are the standard Mondrian functions for returning the head and tail of a list, respectively.</p><p>The class <i>PrimeIterator</i> provides a more flexible prime generator than C# in <A NAME="rl4"><A HREF="#l4">Listing Four</A>. This demonstrates some of the power of .NET &#151; users of the <i>PrimeIterator</i> class never need to know what language it was written in, they never need to even have heard of JIT evaluation. All they see is a clever class, which they've no idea how to write themselves in C#, C++, or Visual Basic.</p><h3>Scripting: Control Using Mondrian</h3><p>Mondrian's function-plus-data model is rather different than .NET's object-plus-method model. This causes a slight impedance match when calling Mondrian from typical object-oriented languages. However, the object-plus-method model fits well into Mondrian's command expressions (known as "monads" by functional programmers). Command expressions enable Mondrian to be used very effectively to script code written in other .NET-hosted languages. As with functions, individual command expressions can be combined to produce more complex operations. Normal functions and JIT evaluation may also be exploited to produce scripts not easily written in other languages.</p><p><A NAME="rl7"><A HREF="#l7">Listing Seven</A> demonstrates the use of Mondrian to call and connect functions written in another CLR-hosted language. In this case, the functions are from the .NET Framework, whatever language(s) that is written in; as this is .NET, it does not matter. The classes <i>HttpWebRequest</i> and <i>WebResponse</i> are from the .NET Framework, the first three lines of the <i>readLinesFromURL</i> function open a URL and return a stream from which the contents of the item referred to by the URL may be read. The command function <i>readLines</i>, provided by Mondrian, takes a stream and returns a list of all the lines read from the URL. This function relies on JIT evaluation. The complete stream is not read in at one go &#151; it could be gigabytes in length, so it is read in only as needed. JIT evaluation lets the URL stream be processed as though it was all in memory at once, avoiding the need to coordinate processing the current line, reading the next line, and so on.</p><p>The <i>try/catch</i> command construct mirrors that of .NET and languages such as C#. Mondrian can handle general exceptions (including those thrown by other .NET hosted languages it calls) and throw its own, which is unusual for a functional language.</p><h3>ASP.NET:  Multilanguage Web Scripting</h3><p>Any language hosted on .NET can be used for coding ASP.NET pages if the language provider chooses to implement CodeDom support. The ease of supporting CodeDom ranges from trivial (for languages such as C# and Visual Basic) to very involved (for languages that are far removed from C# or Visual Basic). Mondrian falls into the latter category. However, by devising a new approach to CodeDom support, not only does Mondrian support ASP.NET, but in the true spirit of .NET, it also provides multilanguage ASP.NET pages. Currently, a mixture of Mondrian and C# is allowed; other languages may be added in the future.</p><p>Why would you want to use multiple languages on ASP.NET pages? To exploit the best tools for solving the problem. On the form in <A NAME="rf1"><A HREF="0202bf1.htm">Figure 1</A>, for instance, text can be typed into the left field, or one of the two Sample buttons used to enter sample text. Pressing the Sort button sorts the lines in the left field and places the result into the right field. </p><p>To produce this, you first need to define an ASP.NET form (see <A NAME="rl8"><A HREF="#l8">Listing Eight</A>). In this form, every button has a handler method defined for the <i>OnClick</i> event. Defining the two initialization methods in C# is trivial, as in <A NAME="rl9"><A HREF="#l9">Listing Nine</A>. The handler for the Sort button, however, is a little more involved. The contents of an <i>asp:TextBox</i> control is a single string. To sort the lines, this string must be broken up into the individual lines, these lines sorted, and then the reordered lines joined back together into a single string. Such data manipulation is one of Mondrian's strong points; <A NAME="rl10"><A HREF="#l10">Listing Ten</A> is a function that does this.</p><p>Lists are the natural data type in Mondrian, so the input string is first converted to a list using <i>stringToList</i>, and the final result is converted to a string using <i>listToString</i>. The <i>qsort</i> function is defined in <A NAME="rl2"><A HREF="#l2">Listing Two</A>, while <i>lines</i> and <i>unlines</i> are standard Mondrian functions. To attach <i>SortLines</i> to the ASP.NET button, another small C# routine is used, as in <A NAME="rl11"><A HREF="#l11">Listing Eleven</A>. Finally, the code and HTML fragments need to be combined into a single ASP.NET page. To do this requires Mondrian's multilanguage support, the page outline is shown in <A NAME="rl12"><A HREF="#l12">Listing Twelve</A> (the complete page is available electronically).</p><p>In a Mondrian ASP.NET page, the default language of a script is Mondrian. To include C# code, a language marker <i>[C#] </i>is added after the opening &lt;<i>script</i>&gt; tag. Mondrian and C# routines can call each other and both can access elements on the page.</p><h3>Visual Studio Integration</h3><p>Of course, your experience wouldn't be complete unless you could program in your favorite functional language (Mondrian, in this case) in your equally favorite RAD environment (say, Visual Studio .NET). To that end, we have integrated Mondrian into the Visual Studio .NET environment. </p><h3>Acknowledgment</h3><p>Mondrian started life at the Universiteit Utrecht in the Netherlands in a project led by Erik Meijer. Nigel Perry was a visiting researcher, from New Zealand, on the project and Arjan van IJzendoorn wrote much of the first system. The Mondrian project is now based in New Zealand. Questions regarding Mondrian can be directed to Nigel at <a href="mailto:nigel@cosc.canterbury.ac.nz">nigel@cosc.canterbury.ac.nz</a>.</p><p></p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>delegate bool SortComp(Object lxpr, Object rxpr);static void QSort(Object[] Data, SortComp Cmp){  QSortPart(Data, 0, Data.Length-1, Cmp);}static void QSortPart(Object[] Data, int Left, int Right, SortComp Cmp){  if(Right &lt;= Left) return;   int NewPivot = Partition(Data, Left, Right, Cmp);   QSortPart(Data,       Left,   --NewPivot, Cmp);   QSortPart(Data, ++NewPivot,        Right, Cmp);}static int Partition(Object[] Data, int Left, int Right, SortComp Cmp){  int iLeft  = Left - 1;   int iRight = Right;   int iPivot = Right; // Pick right element as the pivot   Object PivotValue = Data[iPivot];    while(true)   {  while(Cmp(Data[++iLeft], PivotValue));       while(Cmp(PivotValue, Data[--iRight]))         if(iRight == iLeft) break;      if(iLeft &gt;= iRight) break;      Swap(Data, iLeft, iRight);   }   Swap(Data, iLeft, iPivot);   return iLeft;}static void Swap(Object[] Data, int i, int j) {  Object x = Data [i];   Data[i] = Data[j];   Data[j] = x;}</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>// qsort : forall a. (a -&gt; a -&gt; Boolean) -&gt; List&lt;a&gt; -&gt; List&lt;a&gt;qsort = compare -&gt; l -&gt;   switch(l)   {  case []: [];      case (pivot::t):         let            before = filter (x -&gt; compare x pivot)       t;            after  = filter (x -&gt; not (compare x pivot)) t;         in            (qsort compare before)            ++ (pivot :: (qsort compare after));   };</pre><P><A HREF="#rl2">Back to Article</A></P><H4><A NAME="l3">Listing Three</H4><pre>partition = pred -&gt; data -&gt; before -&gt; after -&gt;   switch(data)   {  case []:         Pair{ a = before;               b = after;             };      case (first::tail):         if(pred first)            partition pred tail (first::before) after         else            partition pred tail before (first::after);   };</pre><P><A HREF="#rl3">Back to Article</A></P><H4><A NAME="l4">Listing Four </H4><pre>static ArrayList primes(int limit){  int [] sieve = new int[limit];   ArrayList found = new ArrayList();   // initialise array   for (int i = 2; i &lt; limit; i++) sieve[i] = i;   // find primes   for (int cursor = 2; cursor &lt; limit; cursor++)   {  if (sieve[cursor] != 0)      {  // found a prime         found.Add(cursor);         // Sieve the array         for (int j = cursor + 1; j &lt; limit; j++)            if (sieve[j]%cursor == 0)               sieve[j] = 0;      }   }   return found;}</pre><P><A HREF="#rl4">Back to Article</A></P><H4><A NAME="l5">Listing Five</H4><pre>// sieve : List&lt;Integer&gt; -&gt; List&lt;Integer&gt;;sieve = xs -&gt;    switch (xs)   {  case (y::ys):         // keep head, remove all multiples of head from tail,         // then recursively sieve tail         y :: sieve (filter (x -&gt; x % y != 0) ys);   };primes = sieve (from 2);</pre><P><A HREF="#rl5">Back to Article</A></P><H4><A NAME="l6">Listing Six</H4><pre>class PrimeIterator{  private Object list = primeGenerator.primes.Apply();   public int Current()   {  return (int)mondrian.prelude.hd.Apply(list);   }   public void Next()   {  list = mondrian.prelude.tl.Apply(list);   }}</pre><P><A HREF="#rl6">Back to Article</A></P><H4><A NAME="l7">Listing Seven</H4><pre>// readLinesFromURL :: String -&gt; IO&lt;List&lt;String&gt;&gt;;readLinesFromURL = url -&gt;{  try   {  req &lt;- HttpWebRequest.Create(url);      rsp &lt;- req # HttpWebRequest.GetResponse();      str &lt;- rsp # WebResponse.GetResponseStream();      readLines str;   }   catch (e : Exception)   {   result Nil;   };};</pre><P><A HREF="#rl7">Back to Article</A></P><H4><A NAME="l8">Listing Eight</H4><pre>&lt;form method="POST" action="SortMondrian.aspx" runat=server&gt;&lt;table border=0 cellspace=4&gt;  &lt;tr&gt;    &lt;td valign=center&gt;      &lt;asp:Button id="I1" text="Sample 1" OnClick="Init1"       runat="server" /&gt;      &lt;br&gt;&amp;nbsp;&lt;br&gt;      &lt;asp:Button id="I2" text="Sample 2" OnClick="Init2"       runat="server" /&gt;&lt;br&gt;    &lt;/td&gt;    &lt;td valign=center&gt;      &lt;asp:TextBox id="T" rows="6" textmode="multiline" text=""       runat="server" /&gt;    &lt;/td&gt;    &lt;td valign=center align=center&gt;      &lt;asp:Button id="B" text="-&gt; Sort -&gt;" OnClick="DoSort"       runat="server" /&gt;    &lt;/td&gt;    &lt;td valign=center&gt;      &lt;asp:TextBox id="T2" rows="6" textmode="multiline" text=""       runat="server" /&gt;    &lt;/td&gt;  &lt;/tr&gt;&lt;/table&gt;&lt;/form&gt;</pre><P><A HREF="#rl8">Back to Article</A></P><H4><A NAME="l9">Listing Nine</H4><pre>void Init1(object sender, EventArgs e){ T.Text = "turtle\nkakapo\naardwolf\neagle\ntuatara\nvole\nbadger";}void Init2(object sender, EventArgs e){ T.Text = "reversed\ninput\ndata";}</pre><P><A HREF="#rl9">Back to Article</A></P><H4><A NAME="l10">Listing Ten</H4><pre>SortLines = cs -&gt;   let      l = lines (stringToList cs);      r = qsort stringLT l;   in      listToString (unlines r);</pre><P><A HREF="#rl10">Back to Article</A></P><H4><A NAME="l11">Listing Eleven</H4><pre>void Clicked(object sender, EventArgs e){  T2.Text = (string)SortLines.Apply(T.Text);}</pre><P><A HREF="#rl11">Back to Article</A></P><H4><A NAME="l12">Listing Twelve</H4><pre>&lt;%@ Page Language="Mondrian" %&gt;&lt;script runat="server"&gt;// qsort - Listing Two// SortLines - Listing Ten&lt;/script&gt;&lt;script runat="server"&gt;[C#]// C# handlers - Listings Nine and Eleven&lt;/script&gt;&lt;html&gt;&lt;body&gt;// the form - Listing Eight&lt;/body&gt;&lt;/html&gt;</pre><P><A HREF="#rl12">Back to Article</A></P></body></html>