<html><head><title>Nov02: Voice Biometrics & Application Security</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Voice Biometrics &amp; Application Security</h1><p><i>Dr. Dobb's Journal</i> November 2002</p><h2>Identification, verification, and classification</h2><h3>By Moshe Yudkowsky</h3><I>Moshe is a speech-technology consultant and can be contacted at speech@pobox.com and http://www.Disaggregate.com/.</I><hr><p>Security experts recommend a three-tier approach to proving identity&#151;"something you have, something you know, something you are." At O'Hare Airport in Chicago, for instance, employees use badges ("something you have") and access codes ("something you know") to open security doors. But as I wait for flights, I've found it fairly easy to see the codes employees enter on the keypads&#151;and employee badges can be stolen, found, and even forged.</p><p>Some airports have added the third tier of security: biometrics, which measure "something you are." For example, employees might place their hands on hand-geometry scanners. If the shape of the hand matches previous measurements, the system grants access. Other biometrics for security include retinal and iris scans, facial recognition, and fingerprint readers. But these biometric technologies have a drawback: They require specialized, expensive, and easily vandalized equipment.</p><DDJADVERTISEMENT INLINE><p>Voice biometrics, however, are an excellent option for application security. Voice biometrics, which measure the user's voice, require only a microphone&#151;a robust piece of equipment as close as the nearest telephone. In this article, I prototype an application that uses a telephone call to verify identity using freely available voice biometric resources that have simple APIs. Furthermore, the prototype can be easily integrated with Internet-capable applications.</p><h3>Identify, Verify, Classify</h3><p>Voice biometrics provide three different services: identification, verification, and classification. Speaker verification authenticates a claim of identity, similar to matching a person's face to the photo on their badge. Speaker identification selects the identity of a speaker out of a group of possible candidates, similar to finding a person's face in a group photograph. Speaker classification determines age, gender, and other characteristics. Here, I'll focus on speaker verification resources ("verifiers").</p><p>Older verifiers used simple voiceprints, which are essentially verbal passwords. During verification, the resource matches a user's current utterance against a stored voiceprint.</p><p>Modern verifiers create a model of a user's voice and can match against any phrase the user utters. This is a terrific advantage. First, ordinary dialogue can be used for verification, so an explicit verification dialogue may be unnecessary. Second, applications can challenge users to speak random phrases, which make attacks with stolen speech extremely difficult.</p><h3>Architecture, Resources</h3><p>The prototype I present uses a telephony server to connect to the telephone network, a speech-technology server, and an application server to execute my code and control the other two servers; see <A NAME="rf1"><A HREF="0211af1.htm">Figure 1</A>.</p><p>For the telephony server, speech-technology resource server, and application server, I use BeVocal's free developer hosting (http://cafe.bevocal.com/). BeVocal hosts VoiceXML-based applications. VoiceXML is an open specification from the W3C's "voice browser" working group (http://www.w3.org/Voice/). XML-based VoiceXML lets you write scripts with dialogues that use spoken or DTMF input, and text-to-speech or prerecorded audio for output. My scripts reside on the Internet and are fetched by the VoiceXML server via HTTP. Since the VoiceXML specification does not define a voice biometrics API, I used BeVocal's extensions to VoiceXML. </p><p>Another company that offers voice biometrics hosting is Voxeo (http://techpreview.voxeo.com/); Voxeo uses a different API. Voxeo lets you send tokens through HTTP to initiate calls from the VoiceXML server to users, which is convenient for web-based applications&#151;not to mention more secure, as the application can easily restrict the calls to predefined telephone numbers. Both BeVocal and Voxeo offer free technical support&#151;and they need to because documentation is often sparse or incorrect. Loggers track script execution and report errors, but you'll need your sleuthing skills to uncover the actual errors.</p><h3>Enrollment</h3><p>Before users can use the verifier, the verifier must obtain a model of the user's voice&#151;users must enroll. During enrollment, users speak several phrases, usually similar to those used during verification. <A NAME="rl1"><A HREF="#l1">Listing One</A> highlights the enrollment application (the complete source code and related files are available electronically; see "Resource Center," page 5).</p><p>Users' voice models are stored in a database at the VoiceXML server. Each developer has a separate database, and the developer assigns keys to each user. Generally, users speak or enter ID numbers, which act as the keys. </p><p>VoiceXML is based around forms, each with several fields to be filled. After collecting user ID numbers in a previous form, <A NAME="rl1"><A HREF="#l1">Listing One</A>'s &lt;<i>form</i>&gt; tag starts collecting speech for enrollment. The &lt;<i>var</i>&gt; tags create JavaScript variables, which are initialized via JavaScript functions (not shown) with numeric and text versions of a four-digit random number. BeVocal's &lt;<i>register</i>&gt; tag activates both a verifier and speech-recognition resource. The <i>keyExpr</i> attribute of &lt;<i>register</i>&gt; gives the verifier the key under which to store the voice model; in our case, the ID number. The <i>name</i> attribute defines a field that accepts the results of recognition, and <i>type</i> specifies the input to expect: a four-digit number. A &lt;<i>prompt</i>&gt; tag sends text to the text-to-speech resource, which plays it to the user. The &lt;<i>break</i>&gt; tag introduces a pause between the introductory prompt and challenge phrase. The &lt;<i>say-as</i>&gt; tag is a directive to the text-to-speech system: The string "1234" should be pronounced "one two three four" and not "one thousand two hundred thirty four."</p><p>If users do not speak, the &lt;<i>noinput</i>&gt; tag is activated; if the user's utterance does not match the grammar (is not a four-digit number), the &lt;<i>nomatch</i>&gt; tag is activated. In either case, a counter decrements; when the counter drops to zero, I emulate transfer to a human agent. This counter defends the application against malicious users who tie up the server, and helps users who are having trouble.</p><p>When user utterances match the grammar, the &lt;<i>filled</i>&gt; tag is activated, and &lt;<i>if</i>&gt; compares the utterance with the challenge. This ensures that the verifier hasn't inadvertently collected noise and mistaken it for a valid utterance&#151;and that someone is not trying to spoof the system with prerecorded utterances. If the utterance matches the challenge, the application goes to the next step via the &lt;<i>goto</i>&gt; tag; if they do not match, the recognition result is reset via the &lt;<i>clear</i>&gt; tag, which causes the &lt;<i>register</i>&gt; to execute again. In the remainder of the enrollment application, users repeat a different four-digit number and current date.</p><h3>Verification</h3><p>To verify a user's identity, a user first claims an identity; in our case, by providing an ID number. <A NAME="rl2"><A HREF="#l2">Listing Two</A> is the application after a user has made a claim.</p><p>The BeVocal API does not let you check whether the database of voice models actually contains the needed model. Instead, if the database key is incorrect, the server interrupts itself in midprompt when the mistake is discovered&#151;which annoys me and users. Fortunately, a little judicious hacking solves the problem. <A NAME="rl2"><A HREF="#l2">Listing Two</A>(a) starts with the &lt;<i>verify</i>&gt; tag, which activates the verifier and speech-recognition resource, and defines both a field to receive the results and the type of input expected. The identity claim is passed to the verifier via the <i>keyExpr</i> attribute. The &lt;<i>property</i>&gt; tag sets the total time to perform recognition to 1 ms, and the prompt is only 1-ms long. The first &lt;<i>catch</i>&gt; is processed if the key is in the database. The second &lt;<i>catch</i>&gt; is activated if the key is invalid; the user is sent back to the form that collects the ID number. As in enrollment, too many errors will send a user to an operator.</p><p>With a valid key, the system moves on to <A NAME="rl2"><A HREF="#l2">Listing Two</A>(b). Variables are initialized with a random challenge phrase, and an announcement plays to users. The &lt;<i>verify</i>&gt; tag starts a verifier and speech-recognition resource, and users are asked to speak the four-digit challenge number. If users are silent (&lt;<i>noinput</i>&gt;) or say something other than a number (&lt;<i>nomatch</i>&gt;), &lt;<i>reprompt</i>&gt; reprompts them. </p><p>If users speak a number, the &lt;<i>filled</i>&gt; tag is activated, and &lt;<i>if</i>&gt; checks the number of attempts. If the user is still under the limit, the first &lt;<i>elseif</i>&gt; compares the utterance to the challenge number. If they are not the same, &lt;<i>clear</i>&gt; resets the results and users try again. Otherwise, &lt;<i>elseif</i>&gt; tags examine the decision of the verifier, which returns one of three confidence levels. If users are accepted, the transaction is approved; if users are decisively rejected, they are sent to operators for further assistance. If neither is true&#151;if the result is "unsure"&#151;users are sent to further &lt;<i>verify</i>&gt; tags (not shown) with a second or third round of challenge phrases. Users who cannot be verified are sent to operators.</p><h3>Threats, Hints, Pitfalls</h3><p>Having worked in speech technology for many years, I regard the current level of achievement as almost magical. Speech recognizers have vocabularies of thousands of words, text-to-speech is very intelligible, and verification highly reliable.</p><p>But I did say "almost." Like all biometric technologies, verifiers by their very nature are prone to error. I occasionally make mistakes guessing at who's speaking during a conference call; speech technology may well be better at guesses than I am, but I don't expect it to be perfect.</p><p>Verifiers have two main errors: false negative, denying valid users; and false positive, accepting impostors. Verifiers have a decision threshold that can be adjusted. The verifier can reject almost all impostors but at the cost of rejecting many valid users, or can accept all valid users at the cost of accepting more impostors. The false accept/false reject curves (<A NAME="rf2"><A HREF="0211af2.htm">Figure 2</A>) intersect at the "equal error rate," and a goal of speech technologists is to make the equal error rate as low as possible. Tests with actual users will reveal the error rates for your application.</p><p>Unlike passwords, which are either valid or not, verifiers produce results with varying levels of confidence&#151;and sometimes verifiers are wrong. In this prototype, I authorize the transaction if users pass just one check. Depending on what's at stake  in an actual application, I might demand more checks or longer challenge phrases, which are more secure because they use more acoustic data.</p><p>Verifiers are not immune to identify theft caused by careless procedures or poorly designed applications. For instance, Alice receives a letter in the mail from her credit-card company. She's given a phone number to call, and her ID number is her home phone number. Bob knows that Alice's company is doing this and knows her phone number, so Bob calls up and enrolls, pretending to be Alice. Bob can now make purchases and, pretending to be Alice, verify them.</p><p>In another scenario, Bob may be able to steal Alice's identity even after she enrolls. In <A NAME="rl1"><A HREF="#l1">Listing One</A>, the &lt;<i>register</i>&gt; tag has its <i>mode</i> attribute set to "adapt," which means that each time Alice calls, the voice model further adapts to her voice. (Some companies give users an opportunity to improve their voice models.) But what happens if it's Bob who calls to "improve" Alice's model? Unless the verifier notices the radical shift in voices&#151;and some do detect this kind of attack&#151;Bob can retrain Alice's voice models. Setting the <i>mode</i> attribute to "delete" in the application would simply cause the old models to be discarded immediately and train solely on Bob's voice. If the <i>mode</i> is set to "skip," Bob can't modify Alice's voice models, but neither can Alice.</p><p>The lesson from these scenarios is straightforward: A voice model is a credential, and credentials require a chain of authenticity. </p><p>If Bob prerecords Alice's utterance, could Bob impersonate Alice? In theory, he could, but most (not all) voice biometric resources detect these attacks. To deter this type of attack, avoid using static challenge phrases such as phone numbers, or even phrases that change only gradually, such as the current date.</p><p>The application itself may be threatened, rather than individual users. Speech-technology resources are expensive, and most servers provide only a handful. I use counters or timers to prevent a single user from tying up a server indefinitely.</p><p>The human factors of speech applications are a separate subject. Make certain prompts clearly state what users must utter. Test your application using real users from your target population. When the verifier or recognizer cannot decipher the utterance, I avoid arguing with or scolding users ("your response was not understood"). Instead, the application is brisk and goal oriented, and simply asks users to repeat the utterance. I like to use male voices. While telephone applications traditionally use female voices, male voices&#151;with their lower frequencies&#151;are actually more intelligible over the telephone network.</p><h3>VoiceXML and Your Application</h3><p>If your application is voice-only and over the phone, adding speaker verification is straightforward. But any Internet-capable application can add VoiceXML.</p><p><A NAME="rf3"><A HREF="0211af3.htm">Figure 3</A> shows one method. After users fill out a web page and start the transaction, the application generates both a web page and VoiceXML script. The web page, sent to users, directs users to call the telephony server. The VoiceXML script contains a script for the verifier with user-specific data, and the result of verification is sent to the application.</p><p>VoiceXML lacks any defined method to send/receive pure data over the Internet. As a simple workaround, <A NAME="rl3"><A HREF="#l3">Listing Three</A> shows how the VoiceXML server can notify the application of the verifier's result. When the VoiceXML &lt;<i>audio</i>&gt; tag calls a CGI script to fetch an announcement, it also sends the user's ID number. The CGI script relays this ID to the application. This method is obviously vulnerable to attack; production systems would use better security (tokens, for instance).</p><h3>Conclusion</h3><p>Biometrics in general, and speech technologies in particular, are imperfect and have a unique capacity for abuse: Voices, faces, and other characteristics can be scanned without knowledge or consent. Still, knowing "something you are" is a powerful security tool when coupled with "something you have" and "something you know."</p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>&lt;form id="samples"&gt;    &lt;block&gt;        &lt;prompt&gt;          We need several samples of your voice. We'll ask you to repeat some          numbers. Just repeat what we say, and speak naturally.        &lt;/prompt&gt;    &lt;/block&gt;    &lt;var name="thisSample" expr="fourDigitRandom()"/&gt;    &lt;var name="thisSampleString" expr="fourDigitString(thisSample)"/&gt;    &lt;register name="fourDigits_1" keyExpr="key"                                  type="digits?length=4" mode="adapt"&gt;        &lt;prompt&gt;            Repeat after me: &lt;break size="small" /&gt;             &lt;say-as type="number:digits"&gt;              &lt;value expr="thisSampleString"/&gt; &lt;/say-as&gt;        &lt;/prompt&gt;        &lt;noinput&gt;            &lt;assign name="totalAttempts" expr="totalAttempts - 1" /&gt;            &lt;if cond="totalAttempts &amp;lt;= 0"&gt;                &lt;goto next="#bounce"/&gt;            &lt;/if&gt;            &lt;reprompt/&gt;        &lt;/noinput&gt;        &lt;nomatch&gt;            &lt;assign name="totalAttempts" expr="totalAttempts - 1" /&gt;            &lt;if cond="totalAttempts &amp;lt;= 0"&gt;                &lt;goto next="#bounce"/&gt;            &lt;/if&gt;            &lt;reprompt/&gt;        &lt;/nomatch&gt;        &lt;filled&gt;            &lt;var name="ok" expr="fourDigits_1 == thisSampleString" /&gt;            &lt;!-- check to see that we match --&gt;            &lt;if cond="!ok"&gt;                &lt;clear namelist="fourDigits_1"/&gt;                &lt;prompt&gt;                    We didn't get that, please try again. &lt;break/&gt;                &lt;/prompt&gt;            &lt;else/&gt;              &lt;!-- reset for use by next "register" --&gt;              &lt;assign name="thisSample" expr="fourDigitRandom()"/&gt;              &lt;assign name="thisSampleString"                               expr="fourDigitString(thisSample)"/&gt;              &lt;assign name="totalAttempts" expr="3" /&gt;            &lt;/if&gt;        &lt;/filled&gt;</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><b>(a)</b><pre>&lt;form id="verification"&gt;    &lt;!-- Verify that the user is in the database --&gt;    &lt;verify name="checkKey" keyExpr="key" type="digits?length=20" &gt;        &lt;!-- make this a quick timeout --&gt;        &lt;property name="timeout" value="1ms" /&gt;        &lt;!-- inaudible prompt --&gt;        &lt;prompt&gt;            &lt;break time="1ms" /&gt;        &lt;/prompt&gt;        &lt;!-- if there is a key we should timeout immediately and go here --&gt;        &lt;catch event="noinput nomatch filled"&gt;            &lt;!-- assign value to field so Field Interpreter Algorithm                                            doesn't bring us here again --&gt;            &lt;assign name="checkKey" expr="'123'" /&gt;            &lt;goto nextitem="fourDigits_1" /&gt;        &lt;/catch&gt;        &lt;!-- if the key is not present, we end up here --&gt;        &lt;catch event="error.verify.keynotfound error.badfetch"&gt;            &lt;!-- likely a bad key - send back to beginning of form --&gt;            &lt;prompt&gt;                Sorry, we can't find account number                &lt;say-as type="number:digits"&gt; &lt;value expr="key" /&gt; &lt;/say-as&gt;.                Let's try again.            &lt;/prompt&gt;            &lt;goto next="#getid" /&gt;        &lt;/catch&gt;    &lt;/verify&gt;    </pre><b>(b)</b><pre>    &lt;var name="thisSample" expr="fourDigitRandom()"/&gt;    &lt;var name="thisSampleString" expr="fourDigitString(thisSample)"/&gt;    &lt;var name="totalAttempts" expr="3" /&gt;    &lt;block&gt;        &lt;prompt&gt;            We will ask you to repeat some numbers. Please speak naturally.        &lt;/prompt&gt;    &lt;/block&gt;    &lt;verify name="fourDigits_1" keyExpr="key" type="digits?length=4"&gt;        &lt;prompt&gt;            Repeat after me. &lt;break size="small" /&gt;             &lt;say-as type="number:digits"&gt;                                  &lt;value expr="thisSampleString"/&gt; &lt;/say-as&gt;        &lt;/prompt&gt;        &lt;noinput&gt;            &lt;assign name="totalAttempts" expr="totalAttempts - 1" /&gt;            &lt;if cond="totalAttempts &amp;lt;= 0"&gt;                &lt;goto next="#denied" /&gt;            &lt;else/&gt;                &lt;reprompt/&gt;            &lt;/if&gt;        &lt;/noinput&gt;        &lt;nomatch&gt;            &lt;!-- utterance did not match grammar. Spoof? --&gt;            &lt;assign name="totalAttempts" expr="totalAttempts - 1" /&gt;            &lt;if cond="totalAttempts &amp;lt;= 0"&gt;                &lt;goto next="#denied" /&gt;            &lt;else/&gt;                &lt;reprompt/&gt;            &lt;/if&gt;        &lt;/nomatch&gt;        &lt;filled&gt;            &lt;assign name="totalAttempts" expr="totalAttempts - 1" /&gt;            &lt;!-- Too many attempts? Did we verify? --&gt;            &lt;var name="check1" expr="totalAttempts &amp;lt;= 0" /&gt;            &lt;var name="check2" expr="fourDigits_1 != thisSampleString" /&gt;            &lt;!-- check to see that we match --&gt;            &lt;if cond="check1"&gt;                &lt;!-- too many attempts --&gt;                &lt;goto next="#denied"/&gt;            &lt;elseif cond="check2" /&gt;                &lt;!-- person spoke incorrect number. Spoof in progress? --&gt;                &lt;clear namelist="fourDigits_1"/&gt;                &lt;reprompt/&gt;            &lt;elseif cond="fourDigits_1$.decision=='accepted'" /&gt;                &lt;goto next="#accepted" /&gt;            &lt;elseif cond="fourDigits_1$.decision=='rejected'"/&gt;                &lt;goto next="#denied" /&gt;            &lt;else/&gt;                &lt;!-- decision was "unsure." Proceed to next field --&gt;                &lt;!-- reset attempts counter for use by next verify --&gt;                &lt;assign name="totalAttempts" expr="3" /&gt;            &lt;/if&gt;        &lt;/filled&gt;</pre><P><A HREF="#rl2">Back to Article</A></P><H4><A NAME="l3">Listing Three</H4><pre>&lt;form id="accepted"&gt;    &lt;block&gt;        &lt;prompt&gt;            Your transaction has been accepted. Thank you. Goodbye.        &lt;/prompt&gt;        &lt;!-- Inform app of results --&gt;        &lt;var name="resultString"                      expr="'http://www.example.com/cgi-bin/success.cgi'" /&gt;        &lt;assign name="resultString"                      expr="resultString+='?accountID='+key"/&gt;        &lt;assign name="resultString"                      expr="resultString+='&amp;amp;outcome=success'"/&gt;        &lt;prompt&gt;            &lt;audio expr="resultString"/&gt;        &lt;/prompt&gt;    &lt;/block&gt;&lt;/form&gt;</pre><P><A HREF="#rl3">Back to Article</A></P></body></html>