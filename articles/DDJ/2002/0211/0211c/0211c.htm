<html><head><title>Nov02: Java</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Building Secure Java RMI Servers</h1><p><i>Dr. Dobb's Journal</i> November 2002</p><h3>By Paulo Marques</h3><I>Paulo is a researcher in distributed systems at the University of Coimbra, Portugal. He can be reached at pmarques@dei.uc.pt.</I><hr><p>When building server applications using Java Remote Method Invocation (RMI), it is not possible to directly control which users are calling what methods on the server. Consider the following: In Java, you define an interface with several methods that your server objects implement. You then create the objects and bind them to the registry running on the local machine. At that time, any client can connect to the registry, retrieve a reference to an object, and call methods on it. There is no direct way to prevent certain users from calling certain methods. When you publish an object, that's it&#151;all the functionality is available to whomever wants to use it. If your server is exposing certain functionality that shouldn't be available to everyone, you have a problem.</p><p>In this article, I explain how to use the proxy pattern in conjunction with the Java Authentication and Authorization Service (JAAS) API for building secure RMI servers. Such servers allow only properly authenticated users access to a system. The complete source code for the server is available electronically; see "Resource Center," page 5.</p><DDJADVERTISEMENT INLINE><h3>Architecture</h3><p>Imagine that you have a server interface like that in <A NAME="rl1"><A HREF="#l1">Listing One</A>. The server has two methods, <i>doOperationA()</i> and <i>doOperationB()</i>, that print out on the server the name of the operation being performed. What you would like to have is a policy file, such as <A NAME="rl2"><A HREF="#l2">Listing Two</A>, where you can configure which operations are available to each user. For instance, in this file you can see that <i>"root"</i> can call all the methods on the server (denoted by "*"), <i>"alice"</i> can only call <i>doOperationA()</i>, and <i>"guest"</i> cannot call anything at all. To implement this functionality, you must make extensive use of proxies; see <A NAME="rf1"><A HREF="0211cf1.htm">Figure 1</A>. The server application does not publish its server object directly. Instead, it publishes a login object, which is bound to the local registry on the server. Whenever a client wants to use the server, it first locates the login object from the registry, then authenticates with it by sending its username and password. If the user is unknown to the server, the client gets a security exception. If the authentication process succeeds, the login object returns a reference to a proxy object that lives on the server. All the calls from the client go through that proxy object. Whenever there is a call, that call is forwarded to the "real" server object if the user has the necessary permissions for invoking the method; if not, an exception is thrown.</p><p>One key aspect of this approach is that the login object creates a new proxy for each existing client. The proxy contains information about the particular client using it. The server knows exactly who is making the call because the only way a client can get a reference to a server proxy is by using the login object whenever there is a method evocation. </p><p>In the Java 2 security architecture, security checks are based on who signed the code and where it came from. But when developing server applications, it is often also necessary to make security verifications based on who is running the code. The Java Authentication and Authorization Service (JAAS) API lets you do that. Here, I use JAAS for associating permissions to users when they access the login object. This way, it's straightforward to check whether users have the necessary privileges when a call is about to be made on the server object. With JAAS, you can create a fine-grained security policy according to who is making the calls. </p><h3>Authentication</h3><p>The <i>LoginInterface</i> and the <i>LoginImpl</i> definitions (<A NAME="rl3"><A HREF="#l3">Listings Three</A> and Four, respectively) provide what is needed for authentication. <i>LoginImpl</i> is the login object that is bound to the local server registry. It implements a method called <i>login()</i>, which takes a username and password as parameters. If a user is correctly authenticated, it returns a reference to a proxy object that implements the interface of the server (<i>ServerInterface</i>); if not, a security exception is thrown. </p><p>The <i>login()</i> method starts by creating a <i>Subject</i> object, named <i>user</i>, which represents the user on the server. <i>Subject</i> is a basic class from JAAS that represents any entity that can be authenticated. </p><p>After <i>user</i> is created, an <i>RMILoginPrincipal</i> containing the user's username is added to the object. <i>RMILoginPrincipal</i> is a simple class derived from <i>java.security.Principal</i> (see <A NAME="rl5"><A HREF="#l5">Listing Five</A>), which lets the username be stored and used in the JAAS policy file. Referring to the policy file in <A NAME="rl2"><A HREF="#l2">Listing Two</A>, you see the name of the class being used to refer to <i>"root"</i>, <i>"alice"</i>, and <i>"guest"</i> (that is, <i>authrmi.RMIPrincipal</i>). The method then checks whether the username/password supplied by the client matches anyone in the password file. If so, a new proxy object that represents that user is created, and a reference is returned to the client; if not, an <i>InvalidUserException</i> is raised. In this example, the password file is in plain text. In a real application, this would not be acceptable, and passwords should at least be saved as a hash value. </p><h3>Authorization</h3><p>At this point, the client has a reference to a server proxy that knows the client's identity. This proxy is an instance of <i>ServerProxy</i> (see ServerProxy.java, available electronically). The proxy object implements all the methods that the real server object does (it implements <i>ServerInterface</i>). Whenever a call is made to <i>doOperationA()</i> or <i>doOpeationB()</i>, the <i>checkPermission()</i> method is called. When this happens, two outcomes are possible: The call returns silently and the method on the real server object is invoked, or <i>checkPermission()</i> throws a security exception that is propagated to the client. This means that the user doesn't have the necessary permissions for making the call.</p><p>The <i>checkPermission()</i> method contains a single call:</p><blockquote><pre>try{	Subject.doAs(user, new ValidateMethodCall(methodName));}catch (java.security.PrivilegedActionException e){	throw (SecurityException) e.getException();}</pre></blockquote><p>The static method <i>Subject.doAs()</i>, in the core of the JAAS API, lets a specific piece of code be called using the permissions of a <i>Subject</i>, instead of the permissions of the calling code. Thus, you use the permissions specified for the user in the JAAS policy file to execute the code in <i>ValidateMethodCall</i>. <i>ValidateMethodCall </i>checks if the user actually has the permissions to make the <i>doOperationXXX() </i>on the server. This is the tricky part. </p><p>Whenever you make a call to <i>Subject.doAs()</i>, an object that either implements the <i>java.security.PrivilegedAction </i>or <i>java.security.PrivilegedExceptionAction </i>must be passed. <i>ValidateMethodCall</i> implements the second one. Both interfaces require a single method to be implemented&#151;<i>run()</i>. It is in this method that the code to be executed in the name of the <i>Subject</i> lives. The difference between the two interfaces is that the second one lets you retrieve an exception that was thrown during the execution of <i>run()</i>. Looking at ServerProxy.java, you see that any exception thrown by the call <i>Subject.doAs()</i> is propagated back to the client application. So, what is being done inside the <i>run()</i> method of <i>ValidateMethodCall</i>? Inside this method, there is a single call in which a number of things happen:</p><blockquote><p>AccessController.checkPermission(new 		ServerPermission(methodName));</p></blockquote><p>For one thing, a new <i>ServerPermission </i>object is created containing the name of the method being called. This object is passed to the <i>AccessController</i>, which checks whether the current context has a permission that implies the specified permission. What this means is that if the calling code has a permission that is equal to or supersedes the specified permission, the call returns silent; if not, a security exception is thrown. <i>AccessController</i> is a class in the Java 2 platform that lets security checks be made according to the current context. When you install a security manager in Java, the calls are typically forwarded to the <i>AccessController</i> class. </p><p>Granted, this can be confusing; see <A NAME="rf2"><A HREF="0211cf2.htm">Figure 2</A>. The call to <i>AccessController</i> is being made inside of a call to <i>Subject.doAs()</i>. Thus, the current context only has the permissions that were specified for the user in the policy file. But how does the <i>AccessController</i> know which permissions users have? The <i>java.security.auth.policy </i>property specifies which policy file is used by JAAS. When the API is loaded, that file is parsed and the permissions associated to each user is read. When a call to <i>Subject.doAs()</i> is made, JAAS makes sure that the called context will only contain the permissions of the <i>Subject</i> specified in the call (the <i>user</i> object). <i>ServerPermission</i> is a class that represents the permissions that users have on the server. As you can see in ServerPermission.java (available electronically), it extends <i>java.security.BasicPermission</i>. This type of permission represents a named Boolean permission that a principal either has or doesn't have. It also supports wildcards. Looking at the policy file (<A NAME="rl2"><A HREF="#l2">Listing Two</A>), you see the full name of this class being used for associating permissions with users. When JAAS is parsing the file, it automatically instantiates objects of this class for representing the permissions each user has. In fact, the <i>AccessController</i> traverses all the permissions a user has to see if any implies the permission passed as a parameter. </p><p>That's basically it. Through this scheme, you get a server that has a fine-grained security policy for the methods being called on the server objects. One other thing you should consider is that JAAS is only used to verify whether a user has the necessary permissions for calling methods. The methods themselves are still called with the full permissions given to the server. Nevertheless, if you wish to specify exactly what permissions each user has on the code being executed on the server, it's just a question of moving the proxy calls inside the <i>Subject.doAs()</i> evocation. For instance, if you have a method on the server that lets a client read a file from disk, you could use a <i>java.io.FilePermission</i> to say that <i>"alice"</i> can only access files in "/home/alice."</p><h3>Technical Hurdles</h3><p>Up until now, I have assumed that if a client doesn't go through the login object, it can't access any of the proxy objects. That isn't strictly true. When you first export a remote object such as <i>ServerProxy</i>, the RMI run time opens a new port on the machine where calls can be made to the object. (Only one port is open per class.) So imagine you are exporting several <i>ServerProxy</i> objects that correspond to several clients. Clever programmers can read the Java RMI specification and browse the RMI source code to find out how to call these objects.</p><p>Fortunately, that isn't so simple. If you check the RMI wire protocol and read the source code, you discover that when an object is published, it is identified by a 176-bit object ID. The format of this identifier is something like:</p><blockquote><p>&lt;UID[112 bit], obj_number[64 bit]&gt;</p></blockquote><p>where UID is <i>&lt;unique_number[32 bit]</i>, <i>timestamp[64 bit]</i>, <i>count[16 bit]&gt;</i>. The identifier <i>unique_number</i> represents a unique number generated in the context of the running JVM, <i>timestamp</i> represents the time the first object of the class was exported, and <i>count</i> is a simple incremental counter. <i>obj_number</i> represents a number uniquely associated to the object being exported. If you use RMI normally, the exported objects have no UID, and <i>obj_number</i> keeps counting whenever a new object is exported. Thus, it would be trivial for a malicious person to use a proxy object of someone else.</p><p>An interesting thing happens when you set the <i>java.rmi.server.randomIDs</i> property to True. In this case, a new UID is generated for each new object. Nevertheless, <i>unique_number</i> and <i>timestamp</i> are equal for all exported objects. Only <i>count</i> is changed for each new object. Thus, the UID by itself wouldn't make the system much safer. But when you set this property, <i>obj_number</i> stops being a counter and becomes a securely generated 64-bit random number. So if someone wants to access an object by using the wire protocol, it must find the correct UID of the object and get the 64-bit number right. This constitutes a sparse space large enough for preventing most attacks. Even so, in some cases it might be advisable to set the <i>java.rmi.server.logCalls</i> property to True, so that all RMI calls are logged.</p><p>If you want to check which object identifiers your program is using, just add the following line to the constructor of <i>ServerProxy</i>:</p><blockquote><p>System.out.println("Object ID:" + get				Ref().remoteToString());</p></blockquote><p>Also notice that the real server object&#151;<i>ServerImpl</i> from <A NAME="rl1"><A HREF="#l1">Listing One</A>&#151;does not extend <i>java.rmi.server.UnicastRemoteObject</i>. That would be a serious mistake since it would make the server object available on the network, and that object should never be exported. One final point is that it is quite easy for anyone to eavesdrop on the connections and find out the usernames and passwords of the users. If you are deploying this kind of security, you should consider using RMI over SSL. For that you will need the Java Secure Socket Extension (JSSE; http://java.sun.com/ products/jsse/index.html). It's straightforward to setup RMI to use SSL. (If you are using JDK 1.4, JSSE is already integrated into the JDK.)</p><h3>Final Details</h3><p>The file MyServer.java (available electronically) presents the main class of the server and of the client. On the server, a security manager is installed so that JAAS will work. Before that, two properties are configured&#151;one that represents the policy file to use for the whole program (java.security.policy), and another that represents the policy file of permissions associated to each user (java.security.auth.policy). Also notice that the server creates a local registry, rather than relying on the rmiregistry program. This is more practical than running rmiregistry all the time. The client simply connects to a server and tries to call both methods. Since the client doesn't install any security manager, no dynamic class downloading takes place. For running applications that use JAAS, be careful with the deployment of the classes. Any classes that will be used on <i>Subject.doAs()</i> calls must be placed in a separate classpath from the main classes. This happens because if you give certain permissions to classes in the global policy file, they cannot be revoked on the JAAS' policy file. If you look at the policy file of <A NAME="rl6"><A HREF="#l6">Listing Six</A>, you notice that full permissions (java.security.AllPermission) are given to the main classes of the server. If you included the <i>ValidateMethodCall</i> class on the same code source, it would also have those permissions, independent of which permissions were granted to the users, and no security exception would be thrown. So for deploying this server, you just create two jar files&#151;one with all the classes of the server, and one with the <i>ValidateMethodCall</i>. The first one has complete permissions, the second one has none. It will have the permissions associated to each user when the <i>Subject.doAs() </i>call is made.</p><p>To run the server I present here, you must also download JAAS (http://java.sun .com/products/jaas/) and install it locally on your machine. You can either put it on the classpath of the server or install it as a Java standard extension. If you are using JDK 1.4, you don't have to do anything because JAAS is already integrated in the new JDK.</p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>package authrmi;/** The interface of the server. */public interface ServerInterface   extends java.rmi.Remote{   /** The first operation. @throws SecurityException If the client doesn't    * have permissions for executing this method. */public void doOperationA()      throws java.rmi.RemoteException, SecurityException;   /** The second operation. @throws SecurityException If the client doesn't    * have permissions for executing this method. */   public void doOperationB()      throws java.rmi.RemoteException, SecurityException;}package authrmi;/** The actual implementation of the server. */public class ServerImpl   implements ServerInterface{   /** The first operation. */   public void doOperationA()   {      System.out.println("Operation A!");   }   /** The second operation. */   public void doOperationB()   {      System.out.println("Operation B!");   }}</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>grant Principal authrmi.RMILoginPrincipal "root"{   permission authrmi.permissions.ServerPermission "*";};grant Principal authrmi.RMILoginPrincipal "alice"{   permission authrmi.permissions.ServerPermission "doOperationA";};grant Principal authrmi.RMILoginPrincipal "guest"{};</pre><P><A HREF="#rl2">Back to Article</A></P><H4><A NAME="l3">Listing Three</H4><pre>package authrmi;/** Interface for client users to login. */public interface LoginInterface extends java.rmi.Remote{   /** Method that lets clients login, returning an interface to the server.   * @param username The name of the user.   * @param password The password of the user.   * @return A reference to a proxy of the server object.   * @throws SecurityException If the client is not allowed to login. */   public ServerInterface login(String username, String password)      throws java.rmi.RemoteException, SecurityException;}</pre><P><A HREF="#rl3">Back to Article</A></P><H4><A NAME="l4">Listing Four</H4><pre>package authrmi;import authrmi.exceptions.*;import javax.security.auth.*;import java.util.*;/** Implements the server object that allows clients to login. */public class LoginImpl   extends java.rmi.server.UnicastRemoteObject   implements LoginInterface{   /** The real server object */   private ServerInterface myServer;   ////////////////////////   /** Class constructor. @param theServer The real server object. */   public LoginImpl(ServerInterface theServer)      throws java.rmi.RemoteException   {      myServer = theServer;   }   /** Allows a client to login and get an interface to the server. */   public ServerInterface login(String username, String password)      throws java.rmi.RemoteException, SecurityException   {      // Creates a subject that represents the user      Subject user = new Subject();      user.getPrincipals().add(new RMILoginPrincipal(username));      // Check if this user can login. If not, an exception is thrown      // Checks if the user is known and the password matches      String realPassword = null;      try      {         Properties passwords = new Properties();         passwords.load(new java.io.FileInputStream(Constants.PASS_FILENAME));         realPassword = passwords.getProperty(username);      }      catch (java.io.IOException e)      {         throw new InvalidUserException(username);      }      if ((realPassword==null) || !realPassword.equals(password))      {         throw new InvalidUserException(username);      }      // Return a reference to a proxy object that encapsulates the access      // to the server, for this client      return new ServerProxy(user, myServer);   }}</pre><P><A HREF="#rl4">Back to Article</A></P><H4><A NAME="l5">Listing Five</H4><pre>package authrmi;/** Class used for representing an authenticated user in the system. */public class RMILoginPrincipal   implements java.security.Principal{   /** The username */   private String username;   ////////////////////////   /** Class constructor.  @param username The username of the user. */   public RMILoginPrincipal(String username)   {      this.username = username;   }   /** Returns the username of the user. @return The username. */   public String getName()   {      return username;   }}</pre><P><A HREF="#rl5">Back to Article</A></P><H4><A NAME="l6">Listing Six</H4><pre>grant codebase "file:authrmi_main.jar"{   permission java.security.AllPermission;};grant codebase "file:authrmi_actions.jar"{};</pre><P><A HREF="#rl6">Back to Article</A></P></body></html>