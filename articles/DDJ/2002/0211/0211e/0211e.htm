<html><head><title>Nov02: Programmer's Toolchest</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Integrating the GoAhead WebServer  &amp; eCos</h1><p><i>Dr. Dobb's Journal</i> November 2002</p><h2>Web-based remote management for  small systems</h2><h3>By Anthony J. Massa</h3><I>Anthony is a senior software engineer and author of Embedded Software Development with eCos (Prentice Hall PTR, 2002) due out later this year. He can be contacted at amassa@san.rr.com.</I><hr><p>Even though the Simple Network Management Protocol (SNMP) is a de facto standard, it nonetheless comes up short for many remote management applications. To transmit data packets, for instance, SNMP uses the User Datagram Protocol (UDP)&#151;a connectionless, unreliable protocol that does not offer mechanisms for the retransmission of data in the event that the data is lost. This can have disastrous consequences for embedded systems. Web-based management, on the other hand, uses the Transmission Control Protocol (TCP) for transactions, providing a reliable method for transferring data using an acknowledgment/retransmission scheme. </p><p>SNMP also requires complex and costly client-side network management software. While this may not be an issue for large organizations, smaller ones often cannot afford this investment. However, web-based management relies on standard (and often free) web browsers for the client side. In effect, this makes the familiar web browser an embedded device's GUI. Tasks such as programming VCRs, for example, are less daunting when the interface is familiar to users. Furthermore, the web browser handles the task of rendering the GUI, something that's important in embedded systems where every processor cycle counts. </p><DDJADVERTISEMENT INLINE><p>Security is always a concern, especially since SNMP does not offer much security with all transactions being in plain text. Web servers used for web-based management offer security such as encrypted password authentication for users trying to access the server.</p><p>Devices using web-based management can also leverage existing RTOS features that are standard in most operating systems, such as networking stacks and filesystems. This eliminates the need to incorporate additional functionality to support embedded web servers, taking up valuable system resources.</p><p>On the downside, a disadvantage to web-based management is the handling of dynamic data&#151;once a page is served from the embedded web server to the browser, the content is static and does not change, unless the user requests the data again. However, any number of solutions eliminate this problem without requiring user intervention. One solution is to use the HTTP REFRESH tag, which forces the browser to rerequest the data at a specified interval. Another is to use Java and JavaScript to run applets in the browser for a continuous data stream.</p><h3>GoAhead WebServer</h3><p>The GoAhead WebServer from GoAhead Software (http://www.goahead.com/) is a portable, open-source, small-footprint web server specifically designed for use in embedded systems. Unlike most web servers, The GoAhead WebServer is designed to meet embedded constraints&#151;small memory footprint, configurable security model, dynamic web-page content support, support for devices that do not have a filesystem, and integration of the source code into custom devices. </p><p>The GoAhead WebServer supports a range of Internet technologies and protocols, including Active Server Pages (ASP), in-process Common Gateway Interface (CGI), embedded JavaScript, HTTP 1.0 with persistent connections found in HTTP 1.1, 65 connections per second, Secure Sockets Layer (SSL) 3.0, Digest Access Authentication (DAA), user management via login access, and storage of web pages in ROM.</p><p>The GoAhead WebServer is written in C and has been ported to operating systems such as Windows 95/98/NT/CE, Linux, eCos, Embedded Linux, ChorusOS, pSOS, MicroC/OS, VxWorks, QNX, Lynx, IRIX, HP-UX, RTEMS, and Novell Netware. GoAhead WebServer requires a TCP/IP stack, event timer, and approximately 60 KB of RAM. </p><p>The GoAhead WebServer source code can be downloaded free of charge in exchange for any enhancements to the source-code base. The license for using the GoAhead WebServer is based on three basic requirements: </p><ul>  <li>GoAhead must be notified prior to shipping the product using the WebServer.  <li>The GoAhead mark must be displayed on the initial page.  <li>GoAhead can identify companies using the WebServer for marketing efforts.</ul><p>The entire GoAhead WebServer license can be found on the GoAhead web site. </p><h3>The eCos RTOS</h3><p>In this article, I integrate the GoAhead WebServer into the eCos RTOS. Although this discussion uses eCos, the techniques can be applied to any of the RTOSs supported by the GoAhead WebServer.</p><p>eCos, short for "Embedded Configurable Operating System," is an open- source, royalty-free RTOS. (For more information on eCos, see "eCos: An Operating System for Embedded Systems," by Gary Thomas, <i>DDJ</i>, January 2000.) eCos is ideal for embedded applications and is supported by the GNU open-source development tools, which include the GNU compiler (GCC) and the GNU debugger (gdb). Because eCos is open source, you can download and test eCos for free (see http://sources.redhat.com/ecos/). </p><p>eCos is designed for use in real-time applications and provides features such as preemptable tasks with multiple priority levels, low-latency interrupt handling, multiple scheduling policies, and multiple synchronization methods. Its core functionality also includes exception handling, timers, counters, device drivers, memory management, and ISO C and math libraries. A complete development and debug environment is provided&#151;GNU-based compilers, assemblers, linkers, debuggers, and simulators. Configuration and build tools are available to run on either Linux or Windows host environments.</p><p>eCos supports a number of 16-, 32-, and 64-bit processor architectures including ARM, Intel x86, Matsushita AM3x, MIPS, NEC V8xx, PowerPC, SPARC, and SuperH. Here, I use Windows NT as the host development platform, eCos as the target RTOS, and the GNU development tools built for the PowerPC. Again, the steps can be applied using any host development platform and any supported OS.</p><h3>Integrating the GoAhead WebServer </h3><p>The first step in installing the GoAhead WebServer on the eCos platform is to download the GoAhead WebServer source code. The source code is contained in either a Windows zip file (816 KB), tar format (1.96 MB), or compressed tar format (640 KB).</p><p>The source files are extracted under the root directory ws211-011120. <A NAME="rt1"><A HREF="0211et1.htm">Table 1</A> lists the other directories extracted under the root directory. After extracting the Windows zip file, the source code uses approximately 1.8 MB of disk space.</p><p>The eCos directory includes the files main.c and makefile. main.c contains the code that gets implemented along with your application. makefile includes the build information for generating an archive or library file from the GoAhead WebServer source code.</p><p>GoAhead provides source code for webcomp, a program that lets web pages be built into the WebServer image. The webcomp.c program (located in the root directory) takes the files under the web subdirectory and compiles them into a format for storage in webrom.c, also located in the root directory.</p><p>For eCos, the webcomp program must be built using Windows or Linux native tools. The complete development project space for the Windows host platform is provided in the win subdirectory.</p><p>After building webcomp, webcomp.exe is generated. You want to copy this file into the eCos subdirectory. The webcomp program is called from the makefile to generate the webrom.c file with the appropriate web pages.</p><p>The DOS <i>find</i> command is used in <A NAME="rl1"><A HREF="#l1">Listing One</A> to generate a list of files under the web subdirectory. This list is stored in the file web_files. Then, webcomp is called to generate the file webrom.c, which contains the compiled web pages. You can then compile webrom.c into the GoAhead WebServer archive image.</p><p>The makefiles for the supported operating systems compile the GoAhead WebServer code into a library or archive file. The next step is to verify that the makefile is configured properly.</p><p>The makefile in the eCos subdirectory contains definitions for building the WebServer for two specific development boards&#151;the Cirrus Logic EDB72xxx and the Motorola PowerPC MBX860 (see <A NAME="rl2"><A HREF="#l2">Listing Two</A>). For other development boards, you need to make the appropriate changes for the COMMAND_PREFIX and CFLAG definitions. You also need to ensure the PKG_INSTALL_DIR points to the location of the working directory for the built eCos image. (A good source to understand the changes that need to be made to the makefile is included with the eCos examples.) You also want to comment out the line to build webcomp in the makefile since you have built webcomp independently; see <A NAME="rl3"><A HREF="#l3">Listing Three</A>.</p><p>Next, set the compiler definitions for the build. Since you are storing the web pages in ROM, you want to ensure the compiler definitions are set appropriately. In the makefile, include the option DWEBS_PAGE_ROM in the CFLAGS definition. The default configuration of the GoAhead WebServer uses a filesystem for web pages. <A NAME="rt2"><A HREF="0211et2.htm">Table 2</A> lists other possible compiler definitions.</p><p>At this point, you are ready to build the GoAhead WebServer using the GNU development tools and make utility, which is run from the ecos subdirectory. After the build completes, the GoAhead WebServer archive file libwebs.a, which is located in the ecos subdirectory, needs to be linked into the eCos image file.</p><p>To start building the eCos operating system and including the GoAhead WebServer archive image, you first need to increase the memory pool size for the <i>malloc</i> function. This is done by increasing the CYGNUM_MEMALLOC_FALLBACK_MALLOC_POOL_SIZE configuration option to 1638400. You can then build the eCos operating-system image. The eCos operating system is built into an archive library file that is included in the link with the user application.</p><p>You must then edit the eCos linker file to include the GoAhead WebServer image in the link process. The linker script file, target.ld, is located under the install/lib subdirectory within the eCos build working directory structure work/mbx. To include the GoAhead WebServer archive file, add libwebs.a to the GROUP command. <A NAME="rl4"><A HREF="#l4">Listing Four</A> is a portion of the target.ld linker script file detailing this modification. Also copy the WebServer archive file to the install/lib subdirectory. Detailed information about building the eCos operating system can be found on the eCos web site.</p><p>Next, modify the application source code to run GoAhead WebServer. Each operating system supported by the GoAhead WebServer includes the file main.c, which gives example code on how to initialize and run the WebServer. <A NAME="rl5"><A HREF="#l5">Listing Five</A> shows the task setup to initialize and run GoAhead WebServer. The first function, <i>bopen</i>, initializes the memory allocator with 60 KB. Approximately 8 KB is allocated for each page request. This value should be set based on the number of concurrent page requests expected for the system. If more memory is needed to handle additional page requests, this value can easily be increased based on the target resources available.</p><p>Next, <i>initWebs</i> is called to initialize the GoAhead WebServer. This function initializes the target's network by calling the eCos function init_all_network_interfaces. Calling socketOpen initializes the socket subsystem. The default web page and password are also set in initWebs. The WebServer is opened on port 80 (the default) using websOpenServer.</p><p>Finally, you enter into an endless loop to process the client requests. <i>socketReady</i> returns True when there is a socket with an event ready to process. Passing in -1 causes the function to go through all available sockets. The function <i>socketSelect</i> blocks until an event occurs on a socket, the parameter -1 causes the function to go through all sockets, and 2000 is the timeout in milliseconds. <i>socketProcess</i> services the events on each socket. The function <i>emfSchedProcess</i> manages the processing of the tasks queued by the WebServer. The last three function calls&#151;<i>websCloseServer, socketClose,</i> and <i>bclose</i>&#151;clean up the WebServer resources if an error occurs and you exit the endless loop. In normal operation, this should not occur.</p><p>There are two functions to remove&#151;<i>send</i> and <i>recv</i>, both located at the end of the file main.c. These functions are placeholders for the actual routines, which are provided by the network stack code included with the eCos operating system.</p><h3>Accessing the GoAhead WebServer</h3><p>Finally, you can run the application. After downloading and starting the application, launch a browser to access the GoAhead WebServer. This assumes that there is some network connection between the target hardware and the host system, which runs the browser.</p><p>To access the GoAhead WebServer homepage, enter "http://&lt;Target_IP_Address&gt;" in the browser address field. This launches home.asp, the default homepage. It may be helpful to use either the Linux or Windows (depending on your host development platform) source code to build the GoAhead WebServer for your host platform. This lets you test the GoAhead WebServer on your host before integrating it into your RTOS. Host development platforms typically have a wider range of debugging tools available that let you step through and understand the GoAhead WebServer code before moving to your embedded platform.</p><h3>Additional Modifications</h3><p>There are a few modifications you can make to customize the GoAhead WebServer for your specific application:</p><p></p><ul>  <li>Port number. The default port number for the WebServer is set to 80. To change the default port number, modify the line <i>port = 80;</i> located in the file main.c. If this default is changed, when accessing the home page as just described, you will need to use "http://xxx.xxx.xxx .xxx:yy", where <i>yy</i> is the port number.  <li>Retries. By default, the GoAhead WebServer retries five times to find an alternative port to use if the default port is not available. This default can be modified in main.c by changing the line <i>retries = 5;</i>.  <li>Password. To password-protect server accesses, the default password needs to be entered in main.c. The line to modify is <i>*password = T("");</i>, where the new password is entered between the quotes "". The default password is blank, which allows access to the server without a password.  <li>Default homepage. Eventually, you will need to modify the web pages under the web subdirectory. The current web pages offer a great starting point for new web- page designs. If the name of the default homepage is changed, the code must also be changed to reflect the new homepage. This is located in main.c on the line <i>websRedirect(wp, T("home.asp"));</i>, where the new homepage is entered in place of home.asp.</ul><h3>Other Concerns</h3><p>Other issues you may need to address involve dynamic page refreshing and storage of cookie files. There have been some recent posts to the GoAhead WebServer newsgroup (news://news.goahead .com/goahead.public.webserver) that offer suggestions and code samples that detail different methods for handling these issues.</p><p>It may also be necessary to dynamically change the content of the web pages stored on the target hardware. If this is the case, a filesystem needs to be implemented as well as a method for updating the contents of the web pages.</p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre># Build a set of ROMable pageswebrom.c:     find ../web -name "*.*" &gt;web_files    ./webcomp ../web web_files &gt;webrom.c</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre># For Cirrus Logic EDB72xx board#PKG_INSTALL_DIR := /work/net_test/install#COMMAND_PREFIX := arm-elf-#CFLAGS := -mcpu=arm7tdmi -D__EDB7209 -D__EDB7212 -g -Wall -O2# For Motorola PowerPC MBX/860PKG_INSTALL_DIR := /work/mbx/installCOMMAND_PREFIX := powerpc-eabi-CFLAGS := -mcpu=860 -msoft-float -g -Wall -O2</pre><P><A HREF="#rl2">Back to Article</A></P><H4><A NAME="l3">Listing Three</H4><pre>#webcomp:# cc -o webcomp -O2 -DWEBS -DUEMF -DOS="Linux" -DLINUX -I.. ../webcomp.c</pre><P><A HREF="#rl3">Back to Article</A></P><H4><A NAME="l4">Listing Four</H4><pre>STARTUP(vectors.o)ENTRY(__exception_reset)INPUT(extras.o)GROUP(libtarget.a libwebs.a libgcc.a)</pre><P><A HREF="#rl4">Back to Article</A></P><H4><A NAME="l5">Listing Five</H4><pre>void WebserverTask( cyg_addrword_t data ){   /* Initialize the memory allocator. */   bopen(NULL, (60 * 1024), B_USE_MALLOC);   /* Initialize the web server */   if (initWebs() &lt; 0)   {      diag_printf( "Error: webserverInitialize Failed!!!\n" );      return;   }   /* Basic event loop. */   while (!finished)   {      if (socketReady(-1) || socketSelect(-1, 2000))      {         socketProcess(-1);      }      emfSchedProcess();   }   /* Close the socket module, report memory leaks, and close the memory        allocator. */   websCloseServer();   socketClose();   bclose();   return;}</pre><P><A HREF="#rl5">Back to Article</A></P></body></html>