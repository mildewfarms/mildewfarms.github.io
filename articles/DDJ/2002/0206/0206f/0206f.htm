<html><head><title>Jun02: ASP.NET Server Components</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>ASP.NET Server Components</h1><p><i>Dr. Dobb's Journal</i> June 2002</p><h2>Mixing client  and server code</h2><h3>By Douglas Reilly</h3><I>Doug is the author of Designing Microsoft ASP.NET Applications and owner of Access Microsystems. Doug can be reached at <a href="mailto:doug@accessmicrosystems.com">doug@accessmicrosystems.com</a>.</I><hr><p>Active Server Pages (ASP) have been a powerful tool for building Microsoft-centric scalable, dynamic web applications. Of course, there are things ASP does not do well (or at all), forcing you move to tools such as Visual Basic. You can create COM components with Visual Basic that do some of the things ASP can't do, including low-level access to the Win32 API and e-mail. Alas, these COM components present a deployment challenge and do little to enhance client-side interactions of application users.</p><p>With the ASP.NET, on the other hand, you can create components in the same languages as the web form logic, notably VB.NET and C#. Since these components are not COM components, many COM overhead and deployment issues disappear. One significant improvement that ASP.NET has over ASP is support within the ASP.NET framework for components, which lets you split the task of the component between the client and the server.</p><DDJADVERTISEMENT INLINE><h3>The ASP.NET Component Model</h3><p>Of course, ASP applications could use client-side scripting &#151; a time-consuming, detailed process. To use client-side code, you need to write the application so that it emits JavaScript code. Controlling what code is emitted and ensuring that only a single copy of it is written out is not difficult, but error prone. Consequently, most ASP developers ignore the client side's computing power, opting for server-side code.</p><p>ASP.NET provides an alternative model for server-side controls. Server-side controls are commonly (though not exclusively) wrappers that provide added functionality to existing HTML widgets. For instance, the <i>TextBox</i> control lets you forget about all the details of the Text Input HTML control, and instead set properties of the control. Rather than setting a <i>Value</i> attribute within the &lt;INPUT&gt; tag, you can either use the designer or (in code) say <i>TextBox1.Text="Hi There!"</i>. Through ASP.NET, you can even retrieve the value of the <i>TextBox</i> using, for example, <i>strRet=TextBox.Text</i>.</p><p>In addition to normal server-side components, ASP.NET lets you create components that automatically sense whether the client can support client-side scripting, then emit code that loads the client-side code (generally JavaScript). While the net effect is the same as what could be achieved using ASP, creating a component one time to generate client-side script is much easier than remembering to use it on individual pages.</p><p>Of course, most of the reasons for using client-side scripting on web pages are to do client-side validation. There are still some sorts of specialized client-side validation that might be best suited for custom JavaScript, but before using it you should consider validation in ASP.NET. </p><h3>Validation in ASP.NET</h3><p>In addition to controls that wrap HTML controls, ASP.NET provides a group of controls called "validators." Instead of being manipulated directly by users, validators are hooked to another control and the information entered into the control is then validated. By default, validation is done on the client and server. Client-side-only validation is a bad idea, since it is possible that a client machine may not have a functional JavaScript interpreter, even though it seems that it does.</p><p><A NAME="rt1"><A HREF="0206ft1.htm">Table 1</A> lists the validator types supported by ASP.NET. (For details on all possible validators, see the MSDN documentation, especially about the <i>ValidationSummary</i> control.) The <i>ValidationSummary</i> control is completely different from the <i>CompareValidator</i> in <A NAME="rl1"><A HREF="#l1">Listing One</A>. This code generates a simple page, performing a common task. The first field is for the current password, and the last two fields are for entering and confirming a new password. If you have ASP.NET on your machine and place this code into a virtual directory that supports ASP.NET, you will get a screen that looks like <A NAME="rf1"><A HREF="0206ff1.htm">Figure 1</A>. It shows the correct current password followed by two passwords in the <i>new password </i>and <i>confirm new password</i> fields that do not agree. </p><p>In standard web pages, you might assume that the message about entering and reentering the new password appears only after the Submit button is pressed &#151; but you'd be incorrect. How does this work? <A NAME="rl1"><A HREF="#l1">Listing One</A> creates this page. While this ASP.NET page might look like ASP, there are significant differences.</p><p>Start with the section of the page's source code that creates the second password field to reenter the new password in <A NAME="re1"><A HREF="0206fe1.htm">Example 1</A>. Most of the HTML tags are from the ASP namespace <i>&lt;asp:TextBox&gt;</i>. Some of these controls are similar to their HTML counterparts. For instance, the <i>asp:TextBox</i> control is similar to the HTML <i>Input</i> control where <i>type="text"</i>. However, in the second of the two table cells, I use controls that have no equivalence in pure HTML. These controls are validator controls that are set up to display a message when specified conditions are met. In the case of the <i>RequiredFieldValidator</i>, the control referred to by <i>ControlToValidate</i> must have a value entered. In the case of the <i>CompareValidator</i> (which I am using to compare two controls on the form), by default the text in the control specified by the <i>ControlToValidate</i> must be the same as the text in the control specified by the <i>ControlToCompare</i>.</p><p>Validator controls are a nice feature of ASP.NET, but they are even better than you might think. For instance, the validator in <A NAME="rf1"><A HREF="0206ff1.htm">Figure 1</A> is displayed when you tab out of the control. How does it do that? The answer to this question can be found in the emitted source code.</p><p>In <A NAME="re1"><A HREF="0206fe1.htm">Example 1</A>, you find several <i>&lt;script&gt;</i> blocks. Of course, <A NAME="rl1"><A HREF="#l1">Listing One</A> has no script blocks. The code in the scripts will be JavaScript, and one of the script blocks contains an include file of some other JavaScript code in a file on the server that contains the web page.  </p><p>One of the validator types in <A NAME="rt1"><A HREF="0206ft1.htm">Table 1</A> is a <i>CustomValidator</i>, which lets you do validation on the client and server, using custom code on each side. This is often enough, but sometimes you may need something a little more powerful. For those situations, you can create a custom server control that uses both client- and server-side scripting to perform the required function.</p><h3>Custom Server Controls </h3><p>One thing many web developers miss is the ability to immediately react to an entry by users in a control. Such was the situation recently when I needed to create a web version of an application that a set of users had long used and become accustomed to. Several of the controls behaved in ways that, until now, would have been difficult to duplicate on the Web. For instance, U.S. Social Security numbers were entered without the dashes, then redisplayed upon exiting the field with the appropriate dashes, enabling data entry people to see that the SSN entered was correct if the number was redisplayed with dashes. If the incorrect number of digits were entered, an error message was displayed. I created a <i>FormatSSN</i> class to encapsulate this functionality.</p><p><A NAME="rl2"><A HREF="#l2">Listing Two</A>, an ASP.NET page that uses <i>FormatSSN</i>, has no code other than HTML markup and the declaration of the single <i>FormatSSN</i> control. When the web page is loaded and you enter a nine-digit number and tab out of the field, the number is reformatted.</p><p>Listing Three (available electronically; see "Resource Center," page 5) contains a C# namespace called <i>DDJ</i>, which contains a class <i>FormatSSN</i>. To create an ASP.NET custom control, you must inherit from a class that descends from the <i>System.Web.UI.Control</i> class. The likely candidate to inherit from this control is the <i>TextBox</i> control. Most of what the control needs to do is what the <i>TextBox</i> control does. However, there is a problem with using the <i>TextBox</i> as a base class: Since I wanted to be able to let the control participate in the normal ASP.NET validation process, I used <i>BaseValidator</i> as the base class. This may not be the best solution, but it does suit the purposes of this example.</p><p><A NAME="re2"><A HREF="0206fe2.htm">Example 2</A> is the class declaration. In addition to inheriting from the <i>BaseValidator </i>control, the class also implements <i>IPostBackDataHandler</i> and <i>IPostBackEventHandler</i>. C#, like VB.NET, does not allow multiple inheritance. However, both languages do let you inherit from a single class and implement as many interfaces as you like.  </p><p>Implementing <i>IPostBackDataHandler</i> and <i>IPostBackEventHandler</i> let the control have data posted back to the HTML form whenever the form is posted. Thus, you do not need special logic on your form to repopulate the control after a post. Virtually all ASP.NET server controls are built to properly have the information entered into a control to survive postbacks. While VB or C++ developers may consider this a given, ASP developers spend time making persistent values in controls between calls.  </p><p>To implement <i>IPostBackDataHandler</i>, I needed to provide an override for the <i>LoadPostData</i> method. This method checks for changes in the data being posted, and returns True if the data has changed or False if it has not. The <i>LoadPostData</i> method accepts two parameters: the <i>postDataKey</i> (a string) and <i>Values</i> (a <i>NameValueCollection</i>). Using the <i>postDataKey</i> as an index into the <i>Values</i> parameter, I can get the posted value for the control.</p><p>Any control that inherits from the <i>BaseValidator</i> control must implement a single method, called <i>EvaluateIsValid</i>. This method returns a Boolean value that is used to indicate if the control contains valid information. The framework checks the value of the <i>BaseValidator</i> controls on a page to determine if a page is valid. <i>FormatSSN</i> calls the method of the class called <i>ServerFormatSSN</i>. This method is shown in <A NAME="rl2"><A HREF="#l2">Listing Two</A>. <i>ServerFormatSSN</i> uses regular expressions to identify either of the properly formatted input strings (nine digits or three digits, dash, two digits, dash, four digits).</p><p>One method of any server control that can be used to perform required tasks is the <i>OnLoad</i> method; see <A NAME="re3"><A HREF="0206fe3.htm">Example 3</A>. <i>OnLoad</i> first calls the base <i>OnLoad</i>. This seems to be required to ensure that the base properly performs the required tasks. Next, if this is a postback, I test the format of the entered field, and set the <i>IsValid</i> property to the <i>bIsValid</i> member value, set within <i>ServerFormatSSN</i>. Next, I check to see if the client target of the page is downlevel. If it is not, I emit a JavaScript script block. (I presume that a client target of downlevel will not support JavaScript, so I do not emit it.) I use a special method of the <i>Page</i> class, called <i>RegisterClientScriptBlock,</i> to write the script within the page. While it might seem easier to simply emit the script block, it's essential you use this call to ensure that the script block is written to the page only once, no matter how many <i>FormatSSN</i> controls are on the page. This script simply writes out an include file.</p><p>When creating a custom control in ASP.NET, you have two ways to create the control &#151; composition or rendering. With composition, you create child controls that make up the server control. For instance, you could have a text box and validator control created as part of a single control. To use composition, you must override the <i>CreateChildControls</i> method, and use the <i>Add</i> method of the <i>Controls</i> object to add controls to the server control.<i></p><p>FormatSSN</i> uses the second method &#151; rendering. With rendering, you are given total flexibility in what HTML is rendered in the resulting control. Within the overridden <i>Render</i> method, I use the <i>HtmlTextWriter</i> instance (called <i>output</i> in the <i>FormatSSN</i> example) to actually render the HTML. When rendering the control, I do not use a hardcoded value for the <i>Name</i> and <i>ID</i> attributes of the control. Instead, I use <i>this.UniqueID</i>, which is guaranteed to be unique, even if there are multiple instances of the same custom control on the page. It is also critical to render both the <i>ID</i> and <i>Name</i> attributes of the control. If you do not add a <i>Name</i> attribute/value pair in the rendered control, postbacks will not work correctly. In the <i>Render</i> method of <i>FormatSSN</i>, I once again check to see if the browser is downlevel, and if it is not, write out an input box with an <i>OnChange</i> event. This <i>OnChange</i> event will be run on the client, not the server. I set the <i>OnChange</i> event to <i>FormatSSN</i>, a method included in FormatSSN.js (available electronically) inserted as the <i>FormatSSNClientScript</i> script block.  </p><p>FormatSSN.js tests the string entered into the text box to see if it is in one of the two allowed formats, and if it is, makes sure the string is formatted for display with the dashes. If it is not valid, <i>FormatSSN</i> will display a message box indicating there is a problem. Of course, this behavior can be modified. The client-side code is in an include file. The importance of implementing the control in this way was reinforced when there was a problem with the Microsoft-supplied validation code in the Beta 2 release. Because the code was in an include file and not embedded into the server-side controls, anyone who was bothered by the bug could fix it. </p><h3>Why Client and Server Validation?</h3><p>Why provide client and server validation? Doesn't the client validation ensure the value is entered correctly? The answer is "no" &#151; you have no control over the state of the JavaScript engine on the browser. Even for browsers that support JavaScript, it is possible that someone trying to force invalid data into the application can do so by sending back a properly formed URL. Server-side validation ensures that the data is really valid before it is accepted.</p><h3>Conclusion</h3><p>One of the things I discovered after creating this control is that there are several possible similar controls. For instance, the system that I needed to emulate formatted dates entered in <i>mmddyy</i> format into <i>m/d/yyyy</i> format. Creating a <i>BaseFormat </i>control that contains support for rendering the control and including a JavaScript script block might be useful. Letting descendants control the JavaScript file included and the properties of the text box would allow descendants to offer almost any type of reformatting. I have not done this yet, but it certainly is something I have considered.</p><p></p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>&lt;%@ Page Language="vb" AutoEventWireup="false" %&gt;&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"&gt;&lt;HTML&gt;    &lt;HEAD&gt;        &lt;title&gt;WebForm1&lt;/title&gt;        &lt;meta content="Microsoft Visual Studio.NET 7.0" name="GENERATOR"&gt;        &lt;meta content="Visual Basic 7.0" name="CODE_LANGUAGE"&gt;        &lt;meta content="JavaScript" name="vs_defaultClientScript"&gt;        &lt;meta content=http://schemas.microsoft.com/intellisense/ie5 name="vs_targetSchema"&gt;    &lt;/HEAD&gt;    &lt;body&gt;    &lt;form id="Form1" method="post" runat="server"&gt;        &lt;table width="500"&gt;            &lt;tr&gt;                &lt;td align="right" width="33%"&gt;Old Password:                &lt;/td&gt;                &lt;td&gt;&lt;asp:textbox id="OldPassword" runat="server" Width="100" TextMode="Password"&gt;&lt;/asp:textbox&gt;&lt;/td&gt;                &lt;td&gt;&lt;asp:requiredfieldvalidator id="RequiredFieldValidator1" runat="server" display="Dynamic" ControlToValidate="OldPassword" ErrorMessage="*"&gt;&lt;/asp:requiredfieldvalidator&gt;&lt;/td&gt;            &lt;/tr&gt;            &lt;tr&gt;                &lt;td align="right" width="33%"&gt;New Password:                &lt;/td&gt;                &lt;td&gt;&lt;asp:textbox id="NewPassword" runat="server" Width="100" TextMode="Password"&gt;&lt;/asp:textbox&gt;&lt;/td&gt;                &lt;td&gt;&lt;asp:requiredfieldvalidator id="RequiredFieldValidator2" runat="server" display="Dynamic" ControlToValidate="NewPassword" ErrorMessage="*"&gt;&lt;/asp:requiredfieldvalidator&gt;&lt;/td&gt;            &lt;/tr&gt;            &lt;tr&gt;                &lt;td align="right" width="33%"&gt;Re-Enter:                &lt;/td&gt;                &lt;td&gt;&lt;asp:textbox id="NewPassword2"     runat="server" Width="100" TextMode="Password"&gt;&lt;/asp:textbox&gt;&lt;/td&gt;                &lt;td&gt;&lt;asp:requiredfieldvalidator id="RequiredFieldValidator3" runat="server" display="Dynamic" ControlToValidate="NewPassword2" ErrorMessage="*"&gt;&lt;/asp:requiredfieldvalidator&gt;&lt;asp:comparevalidatorid="CompareValidator1" runat="server" ControlToValidate="NewPassword2" ErrorMessage="Please enter and re-enter the same new password" ControlToCompare="NewPassword" Display="Dynamic"&gt;&lt;/asp:comparevalidator&gt;&lt;/td&gt;            &lt;/tr&gt;            &lt;tr&gt;                &lt;td align="middle" colSpan="3"&gt;&lt;asp:button id="Button1" Runat="server" Text="Submit"&gt;&lt;/asp:button&gt;&lt;/td&gt;            &lt;/tr&gt;        &lt;/table&gt;        &lt;/form&gt;    &lt;/body&gt;&lt;/HTML&gt;</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>&lt;%@ Register TagPrefix="DDJ" Namespace="DDJ" Assembly="FormatDateControl" %&gt;&lt;%@ Page Language="vb" AutoEventWireup="false" %&gt;&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"&gt;&lt;HTML&gt;    &lt;HEAD&gt;        &lt;title&gt;WebForm2&lt;/title&gt;        &lt;meta name="GENERATOR" content="Microsoft Visual Studio.NET 7.0"&gt;        &lt;meta name="CODE_LANGUAGE" content="Visual Basic 7.0"&gt;        &lt;meta name="vs_defaultClientScript" content="JavaScript"&gt;        &lt;meta name="vs_targetSchema"                    content="http://schemas.microsoft.com/intellisense/ie5"&gt;    &lt;/HEAD&gt;    &lt;body&gt;        &lt;form id="Form1" method="post" runat="server"&gt;            &amp;nbsp;            &lt;table width="500"&gt;                &lt;tr&gt;                    &lt;td width="50%" align="right"&gt;                        SSN:                    &lt;/td&gt;                    &lt;td&gt;                        &lt;DDJ:ReformatSSN id="ReformatSSN1" runat="server"&gt;&lt;/DDJ:ReformatSSN&gt;&lt;br&gt;                    &lt;/td&gt;                &lt;/tr&gt;                &lt;tr&gt;                    &lt;td colspan="2" align="center"&gt;                        &lt;asp:Button id="Button1" runat="server" Text="Button"&gt;&lt;/asp:Button&gt;                    &lt;/td&gt;                &lt;/tr&gt;            &lt;/table&gt;        &lt;/form&gt;    &lt;/body&gt;&lt;/HTML&gt;</pre><P><A HREF="#rl2">Back to Article</A></P></body></html>