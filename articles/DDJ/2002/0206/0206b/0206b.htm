<html><head><title>Jun02: Using Tiny Perl Server Pages and mySQL</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Using Tiny Perl Server Pages and mySQL</h1><p><i>Dr. Dobb's Journal</i> June 2002</p><h2>Implementing web site personalization</h2><h3>By Andy Yuen and Hung-Wai Yuen</h3><I>Andy is a solution architect and Hung-Wai an MCSE. They can be reached at <a href="mailto:andyyuen@kardinia.com">andyyuen@kardinia.com</a> and <a href="mailto:wai@scmp.com">wai@scmp.com</a>, respectively.</I><hr><p>There are three basic reasons why organizations invest in web-based information technology: to increase revenue, reduce cost, and improve customer relationships. But when visiting web sites, customers increasingly want more than just static HTML documents &#151; they now expect personalized content and interaction with the site. In this article, we'll explore personalization techniques that involve technologies ranging from cookies and URL rewriting to tracking user sessions and state management. The tools we use are mySQL and Tiny Perl Server Pages (TPSP) custom tag library facility (for more information on TPSP, see "A Tiny Perl Server Pages Engine," by Andy Yuen, <i>DDJ</i>, August 2001). In the process, we'll present ConsoleApp, a tool that facilitates building web applications using the Model-View-Controller paradigm. While the code presented here is written in TPSP, the techniques can easily be applied to other programming and scripting languages.</p><h3>TPSP and Custom Tags </h3><p>TPSP unites client-side HTML, server-side scripting, and component-based development to produce dynamic pages. TPSP has many JSP-like features including custom tag support. The latter lets you develop custom tag modules to encapsulate complex server-side behaviors and business rules into simple XML-like elements that content developers can use. The only requirements for running TPSP are that your web server supports CGI and that you have Perl 5.005 or later installed on your system. In other words, TPSP is platform- and web-server independent.</p><DDJADVERTISEMENT INLINE><p>Like JSP, TPSP lets you create custom tags. But, unlike JSP, you are not required to provide an XML-based Tag Library Descriptor (TLD) with each tag library you develop. <A NAME="rl1"><A HREF="#l1">Listing One</A> is a TPSP page that demonstrates the use of nested tags. It uses the custom tags <i>&lt;test:loop&gt;, &lt;test:if&gt;, &lt;test:condition&gt;, &lt;test:then&gt;,</i> and <i>&lt;test:else&gt; </i>to generate 10 random numbers and displays either "head" or "tail" in an unnumbered list, depending on whether the random number is greater than 0.5. </p><h3>Cookies and Hidden Fields</h3><p>Unlike JSP, previous versions of TPSP did not provide a built-in <i>session</i> object for session tracking. Since HTTP is a stateless protocol, this is a limitation if you want to implement personalization because personalization relies on the availability of a session-tracking mechanism. </p><p>A session is a set of interactions between the client's web browser and a web server. A session starts when users first invoke a site's URL and ends when they terminate their browser, or when the web server closes the session after a certain period of inactivity (timeout). Since HTTP is a stateless protocol, it requires an external mechanism to save the state information between client/web server interactions. The most common mechanisms used to maintain state are cookies and hidden fields. </p><p>Cookies are name-value pairs similar to CGI query strings. Cookies are sent back and forth between the browser and web server in the HTTP header and maintained by the browser. They can be created to have an indefinite lifespan or expire when the browser terminates. Cookies are easy to use. To create a cookie, you can use the TPSP built-in <i>$response</i> object: <i>$mycookie = $request-&gt;cookie(-name=&gt; $COOKIENAME, -value=&gt;$sid, -expires=&gt;'+30m');</i>, where <i>$COOKIENAME</i> is defined elsewhere and contains the name of the cookie and <i>$sid</i> contains the session identifier (SID).</p><p>A cookie is then sent to the browser in the HTTP header: <i>Out-&gt;print($request-&gt; header(-cookie=&gt;$mycookie));</i>. To read a cookie, use: <i>$sid = $request-&gt;cookie ($COOKIENAME);</i>. </p><p>One limitation of <i>cookie</i> is its size constraint. The cookie header can store a maximum of 4 KB of text. Unpredictable behavior may result if your cookie is assigned a value exceeding 4 KB. This makes it impractical to store a huge amount of information in cookies. Another drawback is that they cannot be passed among different domains. Also, there is a limitation to the number of cookies you can create for a particular domain. However, the most severe drawback is that users can disable cookies from the browser (usually for privacy reasons). Hence, a site must have a fallback mechanism to store state information.</p><p>Hidden fields are one of the many HTML INPUT types. They are set by servers and do not correspond to any displayable user-interface element. To use hidden fields to store state information, use: <i>&lt;INPUT TYPE="hidden" NAME="STATE" VALUE="state info"&gt;</i>. </p><p>The drawback to hidden fields is that stored information has to be sent across the network multiple times during a session. For example, if you save state information in the first page accessed by users, you have to send the information back in one or more hidden fields. If users add some more information in a subsequent page, you have to add that information in the next page you send, and so forth. This can quickly become messy. If your site relies on numerous existing legacy pages, it may be difficult to change all the legacy code to accommodate the use of hidden fields and preserve state information.</p><p>Security is another problem for both cookies and hidden fields. Hence, storing sensitive information directly in cookies and hidden fields is not recommended. </p><h3>URL Rewriting</h3><p>Instead of saving user information in cookies or hidden fields directly, the alternative is to only store an SID in them and save the state information on the server side. In case cookies are disabled on the client's browser, you can use URL rewriting to achieve a similar result. This involves the inclusion of the SID in the HTTP query string of the URL:</p><blockquote><p>HTTP://domainName/cgi-bin/something.pl?SID=xxxxxxxxx</p></blockquote><p>Once you use URL rewriting, you have to make sure that all URLs referencing your TPSP pages include this SID in the query string, otherwise the session will be lost. <A NAME="rl2"><A HREF="#l2">Listing Two</A> uses <i>cookie</i> in the first attempt to save the SID and when it fails, reverts to URL rewriting. The simple approach works as follows:</p><ol><li>Read the SID stored in the named cookie.</p><li>If the cookie is present, record that you are using the cookie and go to Step 5.</p><li>If SID is present in the query string, record that you are using URL rewriting and go to Step 5.</p><li>If you get here, either cookies have been disabled or this is the beginning of a new session. Generate a new and unique SID, redirect to the same URL but include the SID in the query string, and a cookie with the SID as its value in the HTTP header. The redirection will bring you back to Step 1.</p><li>The SID is now retrieved from the client. Check if the session is still valid before proceeding to service the request. If the session has expired, go back to Step 4.</p></li></ol><h3>State Management Strategies</h3><p>Once you have a mechanism to identify a session by its SID, you must determine how to save the state information on the server. If you are using ASP and JSP, you can use the built-in <i>session</i> object to store the information in memory. PHP has a similar mechanism called "session variables." Some of these technologies also implement the URL rewriting mechanism.</p><p>There are several ways to save the session data. Hewlett-Packard's Bluestone J2EE application server offers at least three options for state management:</p><ul>  <li>State Server-External process: Communication between application and State Server is via a TCP connection. This is hidden in a simple State Server API.  <li>In-Process State Server-Internal process. This is different from the first approach in that the State Server runs in the same Java Virtual Machine (JVM) of the application server instead of in its own JVM.  <li>Persistent State. Persistence of state to a JDBC data source.</ul><p>By far, the most common approach is to make the data persistent in a relational database. For example, IBM's J2EE WebSphere application server uses a shared <i>HTTPSession</i> (a Java Servlet class) implementation. Each interaction with the shared <i>HTTPSession</i> is a transaction with a relational database. The SID is used to identify a row in the database. Serialized Java objects are saved in the database as binary large objects (BLOBs). </p><p>TPSP also uses the relational-database approach based on the mySQL relational database.</p><p>The session table is simple, having only four columns: </p><ul>  <li><i>sid</i>, to store the session identifier.   <li><i>state</i>, to store serialized Perl objects.   <li><i>mtime</i>, to store the timestamp when the row is modified.   <li><i>ctime</i>, to store the timestamp when the row is created. </ul><p>A <i>page</i> object, <i>session</i> object, and several TPSP custom tags have been developed to facilitate state management in TPSP. </p><h3>A Framework Based On the MVC Design Pattern</h3><p>Model-View-Controller (MVC) is an abstraction that helps you divide functionality among objects to minimize the degree of coupling among them. The "model" deals with the business rules and data, "view" with presentation aspects of the application, and "controller" accepts and interprets user requests and controls the model and possibly multiple views to fulfill these requests.</p><p>Several approaches are possible in using MVC. One example is Struts, an open-source initiative from the Jakarta Project sponsored by the Apache Software Foundation. It uses J2EE servlets and JSP technologies. (For more information on Struts, see <a href="http://jakarta.apache.org/struts/">http://jakarta.apache.org/struts/</a>). In TPSP's approach, each web application is made up of one controlling TPSP and one or more model and view TPSPs. The controlling TPSP receives all HTTP requests from clients and directs those requests to the appropriate model and view TPSPs. The model TPSPs are responsible for invoking the <i>business</i> objects (in our case Perl modules). In a nontrivial application, the model TPSP extracts parameters from the HTTP requests query string and translates them to a form suitable for use in invoking <i>business</i> objects. These objects should be designed to maximize reusability and hence should not normally be made to handle HTTP requests directly. Model TPSPs do not produce any direct output. After processing, they send the request back to the controlling TPSP so that it can direct the proper view TPSPs to create the content and send it to the client. The model stores the data in the TPSP <i>page</i> object for view TPSPs to pick up.</p><p>The controlling TPSP authenticates users for each request that it receives. That is, it makes sure that users have already logged in to the application before certain pages can be accessed. </p><p>Each application has an entry in the <i>appl_global_mapping</i> and multiple entries in the <i>appl_page_mapping</i> tables. These table entries map client HTTP requests to the appropriate model and view TPSPs. <A NAME="rl3"><A HREF="#l3">Listing Three</A> is the schema for these tables. </p><p>The fields (columns) in the <i>appl_global_mapping</i> table are:</p><ul>  <li><i>appname</i>, the web application name.  <li><i>path</i>, the absolute directory path on the server where all the TPSPs are located.  <li><i>login_page</i>, the login page to display if authentication is required for a page and the user has not already logged in.  <li><i>error_page</i>, the error page to display when problems occur. The error page retrieves the error message from the <i>page</i> object for display.  <li><i>home_page</i>, the page to display when <i>cmd</i> (see next section) is not specified.  <li><i>mdate</i>, the date on which this entry was modified.  <li><i>comment</i>, the web application description.</ul><p>The fields in the <i>appl_page_mapping</i> table are:</p><ul>  <li><i>appname</i>, the web application name. <i>appname</i> and <i>cmd</i> together form the primary key for this table.  <li><i>cmd</i>, the controlling TPSP uses this field and <i>appname</i> to locate the model and view TPSPs for handling an HTTP request.  <li><i>model</i>, the name of the TPSP that invokes the <i>business</i> objects for the command specified in <i>cmd</i>. A model TPSP may invoke other model TPSPs.  <li><i>success_view</i>, the name of the TPSP for display on successful execution of the model TPSP. The return code from the model TPSP is retrieved from the <i>page</i> object.  <li><i>failure_view</i>, the name of the TPSP for display on failure in execution of the model TPSP. The return code from the model TPSP is retrieved from the <i>page</i> object.  <li><i>authen_level</i>, specifies if authentication is needed before the request specified in <i>cmd</i> is carried out. It has a value ranging from 0 to 5.  <li><i>comment</i>, a description on this page.</ul><p><A NAME="rl4"><A HREF="#l4">Listing Four</A> is the controlling TPSP. Its complex logic has been hidden by TPSP custom tags. The custom tags use the <i>page</i> and <i>session</i> objects introduced in earlier sections. This controlling TPSP can be reused by other web applications with only minor changes: the <i>cookieName</i> attribute in the <i>PECS:UseSession</i> and the <i>name</i> attribute in the <i>PECS:Application</i> tag. The rest is handled by the configuration information in the database. (PECS is short for "TPSP E-Commerce System.")</p><p>The <i>page</i> object is not persisted between user and server interaction. Its purpose is to provide a simple in-memory area for TPSPs to exchange information, for example, between model and view TPSPs. The only method it provides (other than the constructor) is <i>attribute</i>. To set an <i>attribute</i>, use: <i>$page-&gt;attribute('errMsg', "error message");</i>. To retrieve an attribute, use: <i>$msg = $page-&gt;attribute('errMsg');</i>. </p><p>The <i>session</i> object is derived from the <i>page</i> object. Other than the constructor and the <i>attribute</i> method inherited from the <i>page</i> object, it provides the following methods:</p><ul>  <li><i>getSid</i>, retrieves the unique session identifier.  <li><i>include</i>, includes a TPSP page.  <li><i>encodeURL</i>, appends the SID in the specified URL if URL rewriting is in use.  <li><i>_runScript</i>, is a private method that translates and executes a TPSP page.</ul><p>The TPSP custom tags used include:</p><p></p><ul>  <li><i>&lt;PECS:UseSession timeout="N" cookie Name="appname" dsn="dsn" user="user" password="password"&gt; &lt;/PECS:UseSession&gt;</i>, which creates a <i>session</i> object, saves it in the <i>$request</i> object, and handles the persistence of session data to the mySQL relational database. <A NAME="rl1"><A HREF="#l1">Listing One</A> is extracted from this custom tag. It uses the Data::Dumper Perl module for object serialization and deserialization. The serialized <i>session</i> object is saved in the <i>state</i> column in the <i>session</i> table: <i>timeout</i> specifies the number of minutes of inactivity before the session times out (terminates). <i>cookieName</i> specifies the name to be used for the cookie. It should be unique for each web application. Although you specify the cookie name here, the custom tag may use URL rewriting for session tracking if cookies have been disabled on the user's browser. <i>dsn</i>, <i>user</i>, and <i>password</i> are the data source name, user name, and password, respectively. These are parameters for accessing the mySQL relational database using Perl DBI. TPSP does not support connection pooling. However, it keeps only one database connection for processing a page. This custom tag saves the database parameters and the database connection handle in the <i>page</i> object so the TPSPs that make up the page can access it. The database parameters are saved in the <i>page</i> attributes: <i>db_dsn</i>, <i>db_user</i>, <i>db_password</i>, and <i>db_handle</i>, respectively.  <li><i>&lt;PECS:Application name="appname" /&gt;</i> specifies the web application name so that the proper configuration and processing information for the application can be retrieved from the database for the controlling TPSP. It uses the <i>appl_global_mapping</i> and <i>appl_page_mapping</i> table entries to determine how to process requests and error conditions. This custom tag must be nested inside the <i>PECS:UseSession</i> tag.</ul><p>The TPSP template (tpsp.tpl is available electronically together with the complete TPSP package and example applications; see "Resource Center," page 5) has been modified to support these new features. However, the new template is compatible with TPSP pages built using previous versions of TPSP.</p><p>To support the <i>session</i> and <i>page</i> object, the built-in <i>$request</i> and <i>$response</i> objects are now instantiated using class <i>Request</i>, a subclass of CGI, instead of using CGI directly as in previous versions of TPSP. The <i>Request</i> class provides one new method, <i>attribute</i>, which functions in the same way as the <i>page</i> object's <i>attribute</i> method. Its main use is for custom tags to retrieve the <i>session</i> and <i>page</i> objects, and other information items that are necessary to perform a task.</p><h3>The ConsoleApp Example Application</h3><p>To illustrate the concepts discussed here, we now present a web-based management console for the creation and administration of web applications using the MVC architecture. You can actually use it to change and enhance its own behavior or create new web applications. The application is bootstrapped using a SQL script to create a database and insert data into the <i>appl_global_mapping</i>, <i>appl_page_mapping</i>, <i>user</i>, and <i>security</i> tables. You have to change the absolute path for the application to point to the directory where you are putting all the TPSPs. The web server must be configured to allow executing CGI scripts in this directory. Write access is also needed because TPSPs are translated dynamically at least once. <A NAME="rf1"><A HREF="0206bf1.htm">Figure 1</A> is a typical ConsoleApp screen. This application only helps you to define which TPSPs are needed to handle what requests and where they are located on the server. You are responsible to develop these TPSPs yourself.</p><p>There are a few things to be aware of when examining the source code:</p><ul>  <li>The controller TPSP has been manually translated using tpspt.pl. This is done to avoid using different URL syntax to invoke the TPSP translator CGItpspt.pl on different web servers (see my previous article on TPSP). The controller has the same name as <i>appname</i>; for example, ConsoleApp.pl. All model and view TPSPs called by the controller will be translated automatically.  <li>The SID is a 32-bit number generated using MD5 based on the current time, a random number, and the process number.  <li>All URLs in TPSPs are encoded using the <i>session</i> object's <i>encodeURL</i> method, which appends the SID to the URL query string if URL rewriting is used by the session. Please note that static HTML pages cannot be used with URL rewriting.  <li>Some model TPSPs such as savePage.tpsp, delPage.tpsp, and so on, invoke other model TPSPs at the end of their processing using the <i>session</i> object's <i>include</i> method.  <li>The forwardToCMD.tpsp takes the URL of the page to forward from the <i>page</i> object's <i>cmd</i> attribute (placed there by a model TPSP). ForwardToCMD uses the refresh HTTP header (CONTENT attribute) of the &lt;META&gt; tag to do redirection. For example, <i>&lt;META HTTP-EQUIV="refresh" CONTENT="1; URL=URL"&gt;</i>.  <li>Access to each page is controlled by the page's <i>authen_level</i> and the user's <i>sec_level</i>. User security can be assigned by site. It is controlled by two tables: <i>user</i> and <i>security</i>.  <li>If users have not logged in or their access level is insufficient to access a page, a login page prompts users to log in.  <li>All business logic is encapsulated in the ConsoleApp::DataAccess.pm Perl module specifically developed for the ConsoleApp application. The model TPSPs translate parameters from the HTTP query string to a form suitable for calling the <i>business</i> object. For more complex applications, there can be more than one <i>business</i> object.  <li>The model TPSP passes information to be displayed by a view TPSP using the <i>page</i> object. The information is usually returned in one or more sets of description and result lists (<i>descList</i> and <i>resultList</i>). The <i>descList</i> is a simple array that returns a description of each data item in <i>resultList</i>, which is returned by the DBI <i>fetchall_arrayref([])</i> method call. In short, it returns a reference to an array containing a reference to an array for each row of data fetched.  <li>Each view TPSP uses the TPSP's directive <i>&lt;%@ include file="url" %&gt;</i> to include header and footer files (header.tpsp and footer.tpsp) to give a consistent look and feel to the application.</ul><h3>Conclusion</h3><p>In a future article, we'll delve into personalization, explain what it is, how it works, and enhance the web-based ConsoleApp to support the building and administering of web applications that provide rule-based personalized product recommendation. Updates, if any, will be posted on the TPSP home site at <a href="http://www.playsport.com/psp_home/">http://www.playsport.com/psp_home/</a>.</p><p></p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"&gt;&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;Nested Custom Tag Demo&lt;/TITLE&gt;&lt;/HEAD&gt;&lt;BODY&gt;&lt;H3&gt;PSP Nested Custom Tag Demo&lt;/H3&gt;&lt;P&gt;&lt;UL&gt;&lt;test:loop repts=10&gt;&lt;LI&gt;&lt;test:if&gt;  &lt;test:condition&gt;&lt;%= (rand &gt; .5) %&gt;&lt;/test:condition&gt;  &lt;test:then&gt;Head&lt;/test:then&gt;  &lt;test:else&gt;Tail&lt;/test:else&gt;&lt;/test:if&gt;&lt;/test:loop&gt;&lt;/UL&gt;&lt;/BODY&gt;&lt;/HTML&gt;</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre> ...# extract SID from cookiemy $sid = $request-&gt;cookie($self-&gt;{'cookiename'});if ($sid) {    # cookie present: record the fact that we are using cookie    $url_flag = 2;}else {    # cookie not present    if (($sid = $request-&gt;param("SID"))) {        # sid found in query string: record that we are using URL rewriting        $url_flag = 1;    }    else {        # no sid found, redirect url using both cookie and url rewriting        $self-&gt;_sendSid();        exit(0);    }} ...# check if session has timed out ...</pre><P><A HREF="#rl2">Back to Article</A></P><H4><A NAME="l3">Listing Three</H4><pre>DROP DATABASE IF EXISTS pecs;CREATE DATABASE pecs;USE pecs;DROP TABLE IF EXISTS appl_global_mapping;CREATE TABLE  appl_global_mapping(  appname   varchar(32) NOT NULL PRIMARY KEY,  path     varchar(128) NOT NULL,  login_page    varchar(32) NOT NULL,  error_page    varchar(32) NOT NULL,  home_page varchar(32) NOT NULL,  mdate     date NOT NULL,  comment   text);DROP TABLE IF EXISTS appl_page_mapping;CREATE TABLE  appl_page_mapping(  appname   varchar(32) NOT NULL,  cmd       varchar(32) NOT NULL,  model     varchar(32) NOT NULL,  success_view  varchar(32) NOT NULL,  failure_view  varchar(32) NOT NULL,  authen_level  int unsigned NOT NULL,  comment   text,  PRIMARY KEY (appname, cmd));DROP TABLE IF EXISTS user;CREATE TABLE user  (  username  varchar(16) NOT NULL PRIMARY KEY,  passwd    varchar(16) NOT NULL,  email     varchar(64) NOT NULL);DROP TABLE IF EXISTS security;CREATE TABLE security  (  username  varchar(16) NOT NULL,  appname   varchar(32) NOT NULL,  sec_level int unsigned NOT NULL,  PRIMARY KEY (username, appname)  );DROP TABLE IF EXISTS session;CREATE TABLE session  (  sid       varchar(36) NOT NULL PRIMARY KEY,  mtime     timestamp NOT NULL,  ctime     timestamp NOT NULL,  state     text);GRANT select, insert, update, deleteON pecs.*TO pecs@localhost identified by 'xfiles';</pre><P><A HREF="#rl3">Back to Article</A></P><H4><A NAME="l4">Listing Four</H4><pre>&lt;%!use PECS::Request;use PECS::Session;use PECS::Page;my $page = new PECS::Page;$request-&gt;attribute('page', $page);%&gt;&lt;PECS:UseSession timeout="15" cookieName="ConsoleApp"          dsn="DBI:mysql:pecs" user="pecs" password="xfiles"&gt;    &lt;PECS:Application name="ConsoleApp" /&gt; &lt;/PECS:UseSession&gt; </pre><P><A HREF="#rl4">Back to Article</A></P></body></html>