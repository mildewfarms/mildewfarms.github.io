<html><head><title>Jun02: Programmer's Toolchest</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Testing C++ Compilers for  ISO Language Conformance</h1><p><i>Dr. Dobb's Journal</i> June 2002</p><h2>Conforming to standards really is a big deal</h2><h3>By Brian A. Malloy, Scott A. Linde, Edward B. Duffy, and James F. Power </h3><I>Brian Malloy is an associate professor in the computer science department at Clemson University and can be contacted at <a href="http://www.brianmalloy.com/">http://www.brianmalloy.com/</a>. Scott Linde received his M.S. in Computer Science from Clemson University in February, 2002. This  paper is part of his M.S. thesis. Edward Duffy is a masters student in the computer science department at Clemson University. James Power is a researcher in the computer science department at the National University of Ireland at Maynooth. </I><hr><p>Conformance to a standard is one of the most important assurances compiler vendors can make. Conformance can affect acceptance of the compiler and, in many cases, impact the language itself. Conformance enables code portability and wider use of the language and corresponding libraries. And even if code portability isn't important, conformance facilitates documentation so that text books and language-reference manuals have a common frame of reference. </p><p>However, conformance is especially important and difficult for C++ because the language standard was slow to develop and acceptance of the standard occurred  years after its introduction. By 1998, when the ISO Standard was accepted, there were many established and accepted C++ compilers in use. </p><DDJADVERTISEMENT INLINE><p>In this article, we describe a test harness we built to measure conformance of C++ compilers. In applying the same standard to all vendors under consideration, we use the same test cases and testing framework for all executions &#151; even though some of the compilers are platform dependent and there is no common platform for all compilers. We found that with its scripting facility, platform independence, and object orientation (facilitating code reuse), Python provided the functionality we needed. Moreover, unlike other languages, Python includes a testing framework with the language. This testing framework is a Python module called "<i>unittest</i>" (<a href="http://pyunit.sourceforge.net/">http://pyunit.sourceforge.net/</a>), written by S. Purcell, and patterned after the JUnit framework developed by Kent Beck and Erich Gamma (<a href="http://members.pingnet.ch/gamma/junit.htm">http://members.pingnet.ch/gamma/junit.htm</a>), and included with Python 2.1 and later (<a href="http://www.python.org/">http://www.python.org/</a>). We have extended the framework to facilitate measurement of ISO conformance. </p><p>We use our extended framework in all test case executions. To avoid bias for or against any vendor, our test case selection is based on test cases found directly in the ISO C++ Standard (<i>International Standard: Programming Languages &#151; C++</i>. Number 14882:1 998(E) in ASC X3. American National Standards Institute, First Edition, September 1998. ISO/IEC JTC 1). All of our test cases are actual examples listed specifically in the Standard with outcomes specified. </p><p>The Python code, together with Clause 3 test cases from the ISO Standard, are available electronically from <i>DDJ</i> (see "Resource Center," page 5) and <a href="http://www.cs.clemson.edu/~malloy/projects/ddj.html">http://www.cs.clemson.edu/~malloy/projects/ddj.html</a>.</p><h3>The <i>unittest</i> Testing Framework </h3><p>In Python, each class begins with the keyword <i>class</i> and each function begins with the keyword <i>def</i>. There are classes defined on lines 1-3 of <A NAME="rl1"><A HREF="#l1">Listing One</A> and functions defined on lines 4, 10, 12, 14, 16, 18, and 26. The classes in lines 1-2 do not contain data or methods, as indicated by the keyword <i>pass</i>: They are used to handle exceptions. Class <i>Binary</i> (lines 3-25) represents an abstraction for binary numbers. Users of the class instantiate <i>Binary</i> numbers using positive decimal numbers, then, using the overloaded operators, manipulate each binary number in the same manner as an integer, applying addition, multiplication, comparison, and output. <i>Binary</i> has six member functions. Function <i>__init__</i> (lines 4-9) is the constructor for <i>Binary</i>. Functions <i>__add__</i>, <i>__mul__</i>, <i>__eq__</i>, and <i>__ne__</i> overload the +, *, ==, and ! = operators for two binary numbers. Function <i>__str__</i> (lines 18-25) enables output of binary numbers, similar to operator &lt;&lt; for C++, and <i>toString</i> for Java. Function <i>test()</i> (lines 26-34) represents one approach to testing class <i>Binary</i>. Binary numbers <i>bin</i>1 and <i>bin</i>2 are instantiated in lines 27-28, then used in addition, multiplication, and comparison in lines 29-34. Function <i>test()</i> is invoked (line 36) when the module is executed in standalone fashion. </p><p>These tests aren't intended to be exhaustive, but rather illustrate one approach to testing modules. There are drawbacks, of course, in using this approach. First, the code to test the module is included in the module itself, which can distract readers interested in understanding the class and requires that the code to test the module be shipped with the module. Second, the person performing the test must inspect the output and verify it is correct. If this verification were performed automatically with a summary report at the end of the test, the testing process would be less prone to error. </p><p><A NAME="rl2"><A HREF="#l2">Listing Two</A> is an alternative, using the <i>unittest</i> module, to the testing approach in <A NAME="rl1"><A HREF="#l1">Listing One</A>. (For detailed information on <i>unittest</i>, see the PyUnit homepage, the <i>Python Library Reference</i>, and Mark Pilgrim's public-domain book, <i>Dive Into Python</i> at http://diveintopython.org/.) </p><p><A NAME="rl2"><A HREF="#l2">Listing Two</A> imports the modules <i>unittest</i>, <i>Binary</i>, and <i>InvalidBinaryError </i>in lines 1, 2, and 3, respectively. The <i>import</i> format on line 1 requires all uses of the imported module be prefixed with the module name; the format used in lines 2-3 do not require the module name prefix. The classes <i>BinaryTest</i> (line 4) and <i>BadInputTest</i> (line 18) encapsulate the test cases we use to test class <i>Binary</i>. Both classes are derived from <i>TestCase</i>, a class in module <i>unittest</i>; this inheritance is indicated by putting the class names in parentheses at the point of declaration (lines 4-18). By inheriting from <i>TestClass</i>, we acquire useful methods to facilitate testing.<i></p><p>BinaryTest</i> and <i>BadInputTest</i> encapsulate the testing process of <i>Binary</i>, with <i>BinaryTest</i> testing for success, and <i>BadInputTest</i> testing for failure. <i>BinaryTest </i>contains five methods that either initialize the test process, <i>test</i>, or recover from the test process. The first method in <i>BinaryTest</i>, <i>setUp </i>(lines 5-6), instantiates a <i>Binary</i> zero as a data member. Method <i>tearDown</i> (line 7) does nothing, but might be used to clean up after the test process. There are three test cases in <i>BinaryTest</i>: methods <i>testZero</i>, <i>testAddition</i>, and <i>testMultiplication</i>, each containing <i>assertEqual</i> statements to determine if the values returned by the <i>Binary</i> API are correct. The statement in line 9 of <i>testZero</i> compares the value of the data member <i>self.n</i> to the newly instantiated number <i>Binary(0)</i>: If they are equal, the test passes; if not, <i>assertEqual</i> raises an exception and the test fails. <i>testAddition</i> is one test case but actually tests two addition operations. The <i>testMultiplication </i>method is also a single test case, but tests 100 multiplication operations. <i></p><p>BadInputTest</i> uses the <i>assertRaises</i> statement to ensure the <i>Binary</i> API handles bad input. The <i>testNegative</i> test case (line 21, <A NAME="rl2"><A HREF="#l2">Listing Two</A>) ensures that <i>Binary</i> raises the exception <i>InvalidBinaryError</i> (line 23) if users of the API attempt to instantiate a negative binary number; this test case passes. However, <i>testDecimal</i>, the method to test for decimal input (line 25), does not pass since the <i>Binary</i> API does not raise an exception when users attempt to instantiate a decimal <i>Binary</i>. This is the only test case in <A NAME="rl2"><A HREF="#l2">Listing Two</A> that fails. <i></p><p>unittest</i> automatically calls <i>setUp</i> and <i>tearDown</i> before/after each test case execution, and the three test methods in <i>BinaryTest</i> are invoked automatically by <i>unittest</i>. Similarly, the <i>setUp</i> routine for <i>BadInputTest</i> and both its negative test cases are automatically called. In fact, a lot automatically happens when using <A NAME="rl2"><A HREF="#l2">Listing Two</A> in standalone fashion. For instance, when <i>main</i> is invoked in line 29, all methods that begin with "test" in classes <i>BinaryTest</i> and <i>BadInputTest</i> are recognized as test cases and a test suite is constructed consisting of each of these methods. These test cases then run automatically; the order of execution is determined by a function that sorts the test cases lexicographically by the name of the function using the built-in Python <i>cmp </i>function. The testing framework provides an environment in which the test cases can execute and a report is generated. Alternatively, users can construct the test suite and pass the name of the test method as a parameter to the newly constructed test suite. Executing the tests in <A NAME="rl2"><A HREF="#l2">Listing Two</A> produces the output in <A NAME="rf1"><A HREF="0206gf1.htm">Figure 1</A>, with five test cases executed and one test case failure (<i>testDecimal</i>). </p><h3>Building the Test Harness </h3><p><A NAME="rl3"><A HREF="#l3">Listing Three</A>, the test case generation module called "<i>runtests.py</i>," consists of two functions, <i>doTests</i> (lines 3-13) and <i>cleanUp</i> (lines 14-21). Each Python module contains a global namespace with an identifier called <i>name</i> that stores the module's name. When a Python interpreter session begins executing a module, the value of <i>name</i> is <i>main</i>. Thus, we begin our test case generation by running the Python interpreter on runtests.py and the <i>if</i> statement (line 22) evaluates to True. </p><p>When the session begins, the <i>if</i> statement (lines 23-34) verifies user input and calls functions to run the tests and clean up. Our test suite is partitioned into directories and we have a directory for each clause in the standard that we test. The <i>if </i>statement in line 23 verifies that two parameters were entered, and line 28 verifies that the second parameter is a valid directory within the current directory. Then, <i>doTests</i> and <i>cleanUp</i> do the testing of the clause and clean up afterward. </p><p>Function <i>doTests</i> (line 3) accepts two arguments: the full path to the directory containing the clause under test, <i>full-path</i>, and the directory name, <i>directory</i>. The function gathers a list of the files contained in the directory, and instantiates a test runner (using <i>TextTestRunner</i>) and a test suite (using <i>TestSuite</i>). <i>TextTestRunner</i> and <i>TestSuite</i> are part of the <i>unittest</i> framework, which we import. The <i>for</i> loop in <i>doTests</i> examines each name in the list to determine if it's a file, and verifies the proper extension. If the name represents a file with a C++ extension, a test case is generated (line 10) with two parameters passed to the constructor: the function that executes the test, <i>testExecute</i>, and the prefix of the name of the C++ test case. After the test case is generated, it is added to the test suite. The final action of <i>doTests</i> tells the <i>TextTestRunner</i> object, <i>runner</i>, to run the tests (line 13). </p><p>Function <i>cleanUp</i> (<A NAME="rl3"><A HREF="#l3">Listing Three</A>, lines 14-21) cleans up after the test suite is executed. We could have used the <i>tearDown</i> method in <i>CppTestCase</i>, derived from <i>unittest</i> to clean up after individual test cases, but we found it more efficient to clean up after all test cases when the test suite has been executed. Line 15 gets a listing of the files in the directory of the clause under test and the <i>for</i> loop examines each file to see if it should be removed. In running each test case, we may have constructed an object file or executable and these are also removed as part of the cleanup process. </p><h3>The C++ Test Case Wrapper </h3><p><A NAME="rl4"><A HREF="#l4">Listings Four</A> and Five present class <i>CppTestCase</i>, a wrapper for our C++ test cases extracted from the ISO C++ Standard. The class contains four methods. Method <i>init</i> (lines 3-18) is the class constructor, and <i>setUp</i> (lines 19-28) performs initialization for each test case. Method <i>tearDown</i> does nothing because we recover from test case execution in the test case generator after the entire suite is executed, as previously described. Function <i>testExecute</i> is the longest method in the class and we show only its signature in <A NAME="rl4"><A HREF="#l4">Listing Four</A>; the code for <i>testExecute</i> is in <A NAME="rl5"><A HREF="#l5">Listing Five</A>. </p><p>The constructor for <i>CppTestCase</i> (<i>init </i>in <A NAME="rl4"><A HREF="#l4">Listing Four</A>) initializes the data used in the test case. The method begins by calling the constructor of the superclass, <i>TestCase</i> (line 4), passing the name of the function that executes the test case; in our framework this is <i>testExecute</i>, introduced in <A NAME="rl3"><A HREF="#l3">Listing Three</A>. It is important that the <i>CppTestCase</i> constructor explicitly calls the constructor of the superclass because, in Python, constructors for superclasses are not automatically invoked. Lines 5-14 initialize a list that contains the calls for each of the compilers we use to execute C++ test cases; the actual compiler is chosen in <i>testExecute</i> by indexing into this list. Included with the compiler call is a flag, passed using the <i>-D</i> option, that may be used in the test cases to determine the name of the files to include. We also set the name of the file for this C++ test case, the <i>toPass</i> flag that indicates if this test case is supposed to pass or fail, and <i>hasMain</i>, a flag that indicates if this test case has a main function. Finally, the directory is initialized to the current working directory, line 18. </p><p>Method <i>setUp</i> (lines 19-28, <A NAME="rl4"><A HREF="#l4">Listing Four</A>) parses the test case to determine if it contains a function <i>main</i>. If it does, the <i>hasMain</i> flag is set to True (line 20) and the test case is compiled, linked, and executed. <A NAME="rl4"><A HREF="#l4">Listing Four</A> is <i>testExecute</i>, the code for the final method of <i>CppTestCase</i>. The first part of <i>testExecute</i> chooses the compiler, link, and execute call, and then compiles the program. If the test case has a <i>main</i> and it successfully compiled, the program is linked and executed. </p><p>The system calls to compile, link, and execute the program are on lines 4, 7, and 10 of <A NAME="rl4"><A HREF="#l4">Listing Four</A>, respectively, where the results are assigned to variables <i>compiled</i>, <i>linked</i>, and <i>executed</i>. All of the systems we used follow the convention that upon successful compile, link, or execute, a zero value is returned; otherwise, a nonzero value is returned. However, Windows 95/98 do not follow this convention, but return a zero value for both success and failure. Thus, our framework will not provide correct results on these systems. </p><p>Some examples in the ISO Standard are intended to compile, others to link, execute, and give a specified output, and still others are intended to fail. We translated the examples into test cases that are either positive or negative, depending on whether they are expected to successfully compile, link, or execute. Negative test cases are intended to expose compilers that accept a superset of the Standard. Thus, a negative test case does not pass if it compiles successfully, or compiles and executes successfully. Forty-one percent of the test cases we extracted from the Standard are negative test cases and form an important part of our measurement of ISO conformance. </p><p>The most important function of <i>testExecute</i> is to determine whether the test case passes or fails, based on the values of the flags <i>toPass</i> and <i>hasMain</i> and the outcome of the compile, link/execute phase of the test process. If the <i>toPass</i> flag is True, then this is a positive test case; if the <i>hasMain </i>flag is True, then this test case is supposed to link, execute, and possibly give a specified output. We make a judgment about whether the test case passes based on the values in these two flags and the outcome of the compile and link/execute phases of the test. Thus, there are four variables that must be modeled, producing 16 possible paths, six of which are infeasible. We model the 10 possible outcomes on lines 12-48 of <A NAME="rl5"><A HREF="#l5">Listing Five</A>. </p><h3>Test Case Extraction </h3><p>A single example in the Standard can produce many test cases. Some examples expand into multiple positive test cases, while others may expand into a single positive test case and multiple negative test cases. Consider <A NAME="rl6"><A HREF="#l6">Listing Six</A>, taken from Clause 3 of the ISO Standard, which specifies rules for name lookup in namespaces. <A NAME="rl6"><A HREF="#l6">Listing Six</A> represents a single example in the Standard, but clearly this must be more than one test case. For example, there are errors on lines 12 and 17; if this example is used as a single test case and the program fails, the tester will not be able to determine if the error occurred on line 12, line 17, or both. </p><p>In our approach, we generate three test cases for <A NAME="rl6"><A HREF="#l6">Listing Six</A>: One test case with no errors that should pass, another test case with the first error that should fail, and a third test case with the second error that should also fail. Thus, we get one positive and two negative test cases. However, a different testing approach might generate many more test cases than three using the example in <A NAME="rl6"><A HREF="#l6">Listing Six</A>. </p><p>Many of the positive examples will not compile as described in the Standard. Some examples require variable or type declarations, or header file inclusion. We have found a wide variation in nomenclature of include files across vendors. In some cases, we were able to avoid the problem of this variation in the include file names if the class or function in the included file is not part of the test. For example, a variable declaration such as <i>strings</i>; might be modified to <i>int</i>s; if the purpose of the test does not involve the <i>string</i> class. </p><p>However, in some cases a function or class in the included file is part of the test. <A NAME="rl7"><A HREF="#l7">Listing Seven</A>, taken from Clause 3 of the ISO Standard, illustrates a test case where the function <i>memcpy</i> is part of the test. In <A NAME="rl7"><A HREF="#l7">Listing Seven</A>, <i>memcpy</i> is used to copy a value from a <i>struct</i> to a buffer, then back again to the <i>struct</i>; the test case succeeds if the value is successfully transferred in both directions. However, the Borland compiler places <i>memcpy</i> in <i>mem.h</i> while the other compilers place <i>memcpy</i> in <i>memory.h</i>. The conditionally compiled code, lines 1-5 of <A NAME="rl7"><A HREF="#l7">Listing Seven</A>, chooses the file to include based on the compiler under test. </p><h3>C++ Conformance Roundup </h3><p>The article "C++ Conformance Roundup," by Herb Sutter (<i>C/C++ User's Journal</i>, April 2001), presents the results of a roundup of a dozen C++ compiler and library vendors in an attempt to establish their conformance to the ISO Standard. In the roundup, three suppliers of C++ conformance test suites &#151; Dinkumware (<a href="http://www.dinkumware.com/">http://www.dinkumware.com/</a>), Perennial (<a href="http://www.peren.com/">http://www.peren.com/</a>), and Plum Hall (<a href="http://www.plumhall.com/">http://www.plumhall.com/</a>) &#151; were asked to evaluate compilers from IBM, Sun Microsystems, Kuck and Associates, Metrowerks, Intel, Hewlett-Packard, Microsoft, GNU, Borland (BC++ and BCC), and Comeau Computing. </p><p>The Plum Hall test suite is based on providing a test case for each sentence in the ISO Standard. For Clauses 1 through 16, describing the language definition, this line-by-line approach produced some 4356 test cases. Perennial has used a similar approach but produced nearly 10 times as many &#151; a total of 35,993 test cases for the same clauses. </p><p>We found the Conformance Roundup to be inconclusive, so we decided to design our own conformance tests. In an attempt to factor out bias, we decided to use the same testing framework for all test executions. Moreover, rather than engage in a line-by-line interpretation of the ISO Standard, which might bias us toward the compiler with which we were most familiar, we have chosen to only extract explicit examples in the Standard with outcomes specified. Using this approach, we extracted 760 test cases. </p><h3>Case Study </h3><p>We applied our testing framework to several C++ compilers running on several different platforms. The compilers in our study include Borland 5.5.1 (<a href="http://www.borland.com/">http://www.borland.com/</a>), Visual C++ 6.0 (<a href="http://www.microsoft.com/">http://www.microsoft.com/</a>), gcc 2.95.2, gcc 2.96, and gcc 3.0.4 (<a href="http://gcc.gnu.org/">http://gcc.gnu.org/</a>), and MIPSpro7.3.1.2m (<a href="http://www.sgi.com/">http://www.sgi.com/</a>). We executed the test cases for Borland 5.5.1 and Visual C++ 6.0 on Windows NT/2000; the rest of the test cases were executed on Linux or Solaris systems running Red Hat 7.1 or Solaris SunOS 5.8. We have tested the framework on Python 1.5 through 2.2; for versions of Python prior to 2.1, the <i>unittest</i> module must be downloaded separately. To provide some insight into the efficiency of the Python framework, we were able to run the 217 test cases for Clause 14, containing the largest number of test cases, in 5.125 seconds on a Dell Precision 530 workstation, with a Xeon 1.7-GHz processor and 512 MB of Rambus memory. </p><p><A NAME="rf2"><A HREF="0206gf2.htm">Figure 2</A> summarizes our results, where the first column lists the names of the compilers and the columns labeled 3-15 list the results for Clauses 3-15 for the respective compilers. The column labeled "Failures" lists the total number of test cases failed by the respective compiler and the final column, "% Passed," represents the percentage of test cases that passed. The bottom row in <A NAME="rf2"><A HREF="0206gf2.htm">Figure 2</A> lists the number of test cases in each of the respective clauses, with the total number of test cases at 760. For example, column 1 shows that the gcc 3.0.4 compiler failed 8 out of 88 test cases for Clause 3 of the ISO Standard. </p><p>The final column of <A NAME="rf2"><A HREF="0206gf2.htm">Figure 2</A> shows that the first three compilers passed at least 90 percent of the test cases, with the gcc 2.95.2 and Borland compilers very close to 90 percent. Moreover, the Visual C++ 6.0 compiler also performed well in the tests. Our goal here is to show that our testing framework is extensible to multiple platforms and provide some measure of how the compilers stack up against the examples in the ISO Standard. We are not considering compile speed, efficiency of optimized code, or friendliness of the environments. Moreover, the performance of a given compiler on these tests may not directly predict the performance of the compiler on a real-world program or test suite. To underscore the intricacy of the test cases, consider <A NAME="rl8"><A HREF="#l8">Listing Eight</A>, a test case that all compilers failed. The purpose of the test case is to illustrate that the expression in line 6 is not a function call and that argument-dependent name lookup does not apply; rather, the expression is a cast equivalent to int(a). However, the compilers we tested find the expression in line 6 to be a redeclaration of the <i>friend</i> function in line 3 and became confused with the <i>typedef</i> in line 1. None of the compilers were able to compile this example correctly. </p><p><A NAME="rf2"><A HREF="0206gf2.htm">Figure 2</A> provides an overview of compliance on a clause-by-clause basis. For example, the four bars at the top of the graph illustrate the percentage of Clause 15 test cases passed by gcc 3.0.4, MIPSpro7.3.1.2m, Borland 5.5.1, and Visual C++ 6.0. The bar in the graph for Clause 4 (Conversions) shows that gcc 3.0.4 and Borland 5.5.1 passed both tests, while MIPSpro7.3.1.2m and Visual C++ 6.0 failed one of the two test cases. The bars for Clause 4 might indicate that the latter two compilers did poorly on this clause but, in fact, they failed only a single test case. </p><p>One of our goals was to measure the progress of the GNU C++ compiler toward ISO conformance. <A NAME="rf3"><A HREF="0206gf3.htm">Figure 3</A> reveals that gcc is making steady progress toward conformance. The graph contains three bars for each of the clauses, where the top bar for a clause represents the most recent version of gcc in our tests (gcc 3.0.4), the second bar represents gcc 2.96, and the third bar represents the oldest version (gcc 2.95.2). For all clauses we tested, gcc 3.0.4 performed as well or better than gcc 2.95.2. Also, for Clause 14, which tests templates, gcc has shown steady improvement toward ISO conformance. </p><h3>Conclusion </h3><p>We have described the construction of a Python test framework that lets us use the same test harness for compilers on different platforms. We have used the examples from the ISO Standard together with the described outcomes to construct test cases to measure the conformance of popular compilers. Since nomenclature for include files varies across vendors, we conditionally compile the correct header file for the respective compiler. Our results indicate that all of the compilers in our test suite performed very well and that the GNU C++ compiler is moving steadily toward conformance to the ISO Standard. We believe that our approach is adaptable to other forms of testing where cross-platform compatibility is important. We are currently extending our framework to perform unit testing on C++ classes. </p><p></p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One </H4><pre>1 class BinaryError( Exception): pass 2 class InvalidBinar yError(BinaryE rror): pass 3 class Binary: 4    def _init_ ( self, n = '0' ): 5       """number s are stored as integers""" 6       if int(n) &lt; 0: 7           raise InvalidBinary Error, n 8           "Negative numbers are invalid" 9       self.number = int( n ) 10   def _add_ ( self, rhs ): 11      return Binary(self.number+rhs.number) 12   def _mul_ ( self, rhs ): 13      return Binary(self.number*rhs.number) 14   def _eq_ ( self, rhs ): 15      return (self.num ber==rhs.numbe r) 16   def _ne_ ( self, rhs ): 17      return (self.num ber!=rhs.numbe r) 18   def _str_ ( self ): 19      """Prints the number in binary format""" 20      number = self.number 21      result = [] 22      while number: 23          result.inser t(0, str(number%2)) 24          number = number / 2 25      return "".join(result) 26 def test(): 27   bin1 = Binary( 17 ) 28   bin2 = Binary( 127 ) 29   print bin1, " + ", bin2, " is ", bin1+bin2 30   print bin1, " * ", bin2, " is ", bin1*bin2 31   if bin1 != bin2: print "Not Equal" 32   else : print "Equal" 33   if bin2 != Binary(127): print "Not Equal" 34   else : print "Equal" 35 if name == " _main_": 36   test() </pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>1 import unittest 2 from binary import Binary 3 from binary import InvalidBinaryError 4 class BinaryTest(unittest.TestCase): 5    def setUp(s elf): 6        self.n = Binary(0) 7    def tearDow n(self): pass 8    def testZero(self): 9        self.asse rtEqual(self.n, Binary(0)) 10    def testAdd ition(self): 11       rhs = Binary(7) 12       self.assertEqual((self.n+rhs), Binary(7)) 13       self.assertEqual((Binary(7)+rhs), Binary(14)) 14   def testMultiplication(self): 15       for n in range(100): 16           self.assertEqual(Binary(n)*Binary(n), \17           Binary(n*n)) 18 class BadInputTest(unittest.TestCase): 19   def setUp(self): 20       self.n = Binary(0) 21   def testNegative(self): 22       """Binary should fail with negative input""" 23       self.assertRaises(InvalidBinaryError, \24       Binary, -1) 25   def testDecimal(self): 26       self.assertRaises(InvalidBinaryError,\27       Binary, 0.5) 28 if name == " _main_ ": 29   unittest.main () </pre><P><A HREF="#rl2">Back to Article</A></P><H4><A NAME="l3">Listing Three </H4><pre>1 #!/usr/bin/env python2.2 2 import unittest, fnmatch, os, sys, cpptests 3 def doTests(fu llpath, directory): 4     dirlist = os.listdir(fullpath) 5     runner = unittest.TextTestRunner () 6     suite = unittest.TestSuite() 7     for fname in dirlist : 8        if os.path.isfile(fullpath+' /'+fname) \ 9            and fnmatch.fnma tch(fname, "*.cpp"): 10           gen = cpptests.CppTestCase("test Execute", \ 11               fname[:-4 ]) 12           suite.addTest( gen ) 13    runner.run(suite) 14 def cleanUp(fu llpath): 15     dirlist = os.listdir(fullpath) 16     for fname in dirlist : 17        if os.path.isfile(fullpath+' /'+fname) and \ 18           (fnmatch.fnmatch(fname, "*.o") 19           or fnmatch.fnmatch(fname, "*.obj") 20           or fnmatch.fnmatch(fname, "*.exe")): 21           os.remove(fname) 22 if __name__ == "__main__": 23     if len(sys.argv) != 2: 24         print "usage: ", sys.argv[0], " &lt;clause dir&gt;" 25     else : 26         directory = sys.argv[1] 27         fullpath = os.getcwd() +'/'+directory 28         if os.path.isdir(fullpath): 29             os.chdir(fullpath) 30             doTests(fullpath, directory) 31             cleanUp(fullpath) 32         else : 33             print directory, " is not in this directory" 34             print "Current directory is: ", os.getcwd() </pre><P><A HREF="#rl3">Back to Article</A></P><H4><A NAME="l4">Listing Four</H4><pre>1 import unittest, os, re 2 class CppTestCase(unittest.TestCase): 3     def __init__ (self, testfun, fname): 4        unittest.TestCase.init (self, testfun) 5        self.compile = [ "g++ -c -DGCC29x %s.cpp", \6           "g++ -Wno- -c -DGCC30x %s.cpp", \7           "cl /w /nologo /c -DMSVC6x %s.cpp", \ 8           "bcc32 -w- -q -c -DBORLAND 55 %s.cpp", \9           "CC -c -DMIPS %s.cpp ] 10       self.link = [ "g++ -o %s.exe %s.o", \11          "g++ -o %s.exe %s.o", \ 12          "cl /nologo /w /Fe%s.exe %s.obj", \13          "bcc32 -q -e%s.exe %s.obj" , \14          "CC -o %s.exe %s.o" \15          ]16       self.fileName = fname 17       self.toPass = not (fname[:4] == "fail") 18       self.hasMain = 0 19       self.directory = os.getcwd() 20    def setUp(self): 21       print "Executing: %s.cpp" % self.fileName 22       oldFile = open(self.file Name+".cpp", "r") 23       currentline = oldFile.readline() 24       while currentline : 25          if re.search("main", currentline): 26             self.hasMain = 1 27             break; 28           current line = oldFile.readline() 29       oldFile.close() 30    def tearDown(self): pass 31    def testExecute(self): 32    #Code for this method in Listing Five</pre><P><A HREF="#rl4">Back to Article</A></P><H4><A NAME="l5">Listing Five</H4><pre>1 def testExecute(self): 2    def testExecute(self): 3       executed = 0 4       compiled = (os.system(self.compile[0] % \5          self.fileName) == 0) 6       if compiled and self.hasMain: 7          linked = (os.system(self.link[0] % \8            (self.fileName, self.fileName)) == 0) 9          if linked: 10           executed = (os.system ("%s.exe" % \11               self.fileName) == 0) 12      if self.toPass and self.hasMain \13         and compiled and executed: 14         print "PASS: Semantics properly supported" 15      elif self.toPass and self.hasMain \16         and compiled and not executed: 17         print "FAIL: Semantics not supported" 18         failures.add(self.fileName) 19      elif self.toPass and self.hasMain and \20         not compiled and not executed: 21         print "FAIL: Should have compiled" 22         failures.add(self.fileName) 23      elif self.toPass and not self.hasMain and \24         compiled and not executed: 25         print "PASS: Compiled as expected" 26      elif self.toPass and not self.hasMain and \27         not compiled and not executed: 28         print "FAIL: Should have compiled" 29         failures.add(self.fileName) 30      elif not self.toPass and self.hasMain \31         and compiled and executed: 32         print "FAIL: Executed but shouldn't have" 33         failures.add(self.fileName) 34      elif not self.toPass and self.hasMain \35         and compiled and not executed: 36         print "PASS: Semantics properly supported" 37      elif not self.toPass and self.hasMain \ 38         and not compiled and not executed: 39         print "PASS: Did not compile, as expected" 40      elif not self.toPass and not self.hasMain \41         and compiled and not executed: 42         print "FAIL: Should not have compiled " 43         failures.add(self.fileName) 44      elif not self.toPass and not self.hasMain \45         and not compiled and not executed: 46         print "PASS: Did not compile, as expected" 47      else: 48         print "logic errors" </pre><P><A HREF="#rl5">Back to Article</A></P><H4><A NAME="l6">Listing Six</H4><pre>1 namespace N { 2   int i; 3   int g( int a) {return a;}4   int j(); 5   void q(); 6 } 7 namespace { int l = 1; } 8 namespace N { 9   int g( char a) { // overloads N::g( int ) 10     return l+a;   // l is from unnames namespace 11  } 12  int i;           // error: duplicate definition 13  int j()          // OK: duplicate function declaration 14  int j()  {       // OK: definition of N::j() 15     return g(i);  // calls N::g( int ) 16  } 17  int q();          // error: different return type 18 } </pre><P><A HREF="#rl6">Back to Article</A></P><H4><A NAME="l7">Listing Seven</H4><pre>1 #if defined( BORLAND55) 2 #include &lt;mem.h&gt; 3 #else 4 #include &lt; memory.h &gt; 5 #endif 6 struct T { int a; }; 7 #define N sizeof(T) 8 int main () {9    char buf[N]; 10   T obj; 11   obj.a = 1138; 12   memcpy(buf, &amp;obj, N); 13   memcpy(&amp;obj, buf, N); 14   if (1138 != obj.a) return 1; 15   return 0; 16 } </pre><P><A HREF="#rl7">Back to Article</A></P><H4><A NAME="l8">Listing Eight</H4><pre>1 typedef int f; 2 struct A { 3   friend void f(A &amp;); 4   operator int (); 5   void g(A a) { 6     f(a); 7   } 8 } ; </pre><P><A HREF="#rl8">Back to Article</A></P></body></html>