<html><head><title>Jun02: The Mail4ME Project</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>The Mail4ME Project</h1><p><i>Dr. Dobb's Journal</i> June 2002</p><h3>By J&ouml;rg Pleumann</h3><I>J&ouml;rg is a research assistant and Ph.D. candidate in the computer science department at the University of Dortmund, Germany. He can be contacted at <a href="mailto:joerg@pleumann.de">joerg@pleumann.de</a>.</I><hr><p>Apart from the World Wide Web, e-mail is the most popular Internet service. According to a recent study, the number of e-mails sent on an average day in 2001 will have passed the 10 billion mark. With communication-centric, wireless devices such as two-way pagers, cell phones, and PDAs becoming more prevalent, it would be nice if they supported real e-mail too, rather than the 150 characters possible with SMS.</p><p>The Java 2 Micro Edition (J2ME) platform and Mobile Information Device Profile (MIDP; <a href="http://java.sun.com/products/midp">http://java.sun.com/products/midp</a>) used in the emerging generation of cell phones and PDAs should be able to meet this need, allowing the development of portable, Java-based e-mail applications for these devices. Yet, neither the core J2ME nor MIDP provide libraries suitable for Java-based e-mail access.  The JavaMail API (<a href="http://java.sun.com/products/javamail/">http://java.sun.com/products/javamail/</a>) uses features not available in J2ME. While there are some devices that have built-in native e-mail applications, there's no standardized interface allowing Java applications to utilize this functionality; for example, by sending e-mail from inside a MIDlet.</p><DDJADVERTISEMENT INLINE><p>The Mail4ME project (<a href="http://mail4me.enhydra.org/">http://mail4me.enhydra.org/</a>) provides a solution to this problem. Mail4ME is a lightweight implementation of the popular POP3 and SMTP protocols &#151; including MIME support and with IMAP support to come &#151; allowing wireless J2ME/MIDP devices to access e-mail services at any time and from any place (as long as a suitable antenna is in reach and the device's battery is not empty, of course). Mail4ME belongs to the EnhydraME family of projects (<a href="http://me.enhydra.org/">http://me.enhydra.org/</a>). The goal of EnhydraME is to provide application server-like functionality for J2ME-enabled devices. Most EnhydraME projects &#151; including Mail4ME &#151; are available as open source under the Enhydra Public License, which is similar to the BSD license. </p><p>Since the project targets the J2ME environment, the implementation must respect the limited resources inherent in that platform. In particular, this implies that it's not possible to represent every piece of information an e-mail contains (or may contain) by a specialized Java class. So the level of abstraction is somewhat lower than that used by JavaMail. In terms of memory constraints, it should be possible to deploy only those parts of the library to target devices that are actually needed by an application. The latter means that the different classes must not be mutually dependent.</p><p>As <A NAME="rf1"><A HREF="0206cf1.htm">Figure 1</A> shows, the basic classes of the Mail4ME package and their most important relationships include:</p><ul>  <li>Messages, represented by a line-oriented data structure following the rules specified by the Internet Message Standard (RFC822; <a href="http://www.nic.mil/ftp/rfc/rfc822.txt">http://www.nic.mil/ftp/rfc/rfc822.txt</a>). This representation is easy to implement, easy to use, and requires little memory. Since it's also close to the data format used during actual transmission, not much transformation is needed, making it reasonably fast even on low-horsepower J2ME devices.  <li>Headers and body lines can be accessed and manipulated by their index, with a number of additional methods allowing for comfortable access to the various field names and values of a message's header.  <li>Protocols are encapsulated by one class each, so there's a <i>Pop3Client</i> class (RFC1939; <a href="http://www.nic.mil/ftp/rfc/rfc1939.txt">http://www.nic.mil/ftp/rfc/rfc1939.txt</a>), <i>SmtpClient</i> class (RFC821; <a href="http://www.nic.mil/ftp/rfc/rfc821.txt">http://www.nic.mil/ftp/rfc/rfc821.txt</a>), and two specialized exception classes that report errors during POP3 and SMTP sessions. Messages are retrieved and sent by calling a method on one of the protocol clients. For the special case that a message has to be resent or forwarded without changing the original message's header, an additional <i>Envelope</i> class is provided, giving some control over the addressing stage of an SMTP session.  <li>A special <i>MimeDecoder</i> class allows access to the tree-like hierarchy of body parts in a MIME-encoded message (RFC2057: <a href="http://www.nic.mil/ftp/rfc/rfc2057.txt">http://www.nic.mil/ftp/rfc/rfc2057.txt</a>). It can extract plaintext and binary data that uses "base64" encoding.  <li>Since the implementation uses a helper class that provides abstraction from J2ME's Generic Connection Framework as well as from J2SE's <i>Socket </i>class, the package can be used in both environments, thus providing a lightweight and easy-to-use alternative to JavaMail, even for the desktop. The mechanism used here is akin to that used in the Generic Connection Framework itself: The actual connection class is chosen at run time depending on the value of the "microedition.configuration" property.</ul><p><A NAME="rf2"><A HREF="0206cf2.htm">Figure 2</A> shows the dependencies between the Mail4ME classes. The <i>Message </i>class is at the heart of the package and is the only class that is mandatory. All other classes build upon <i>Message</i> but are optional, meaning that only those parts of Mail4ME actually needed by an application have to be deployed to a J2ME MIDP device. If, for example, an application deals with nothing but receiving plaintext messages from a POP3 mailbox and is not involved in sending messages or MIME decoding at all, the SMTP and MIME classes could be left out of the final JAR file to save memory on the device.</p><h3>A Sample Application</h3><p>For the purpose of illustration, assume an imaginary customer is in need of mailing-list processor software to run on J2ME-enabled hardware. For simplicity, the list of requirements consists of only three items:</p><ol><li>The list processor reads mail from a POP3 account and forwards it to a fixed list of users using the SMTP service.</p><li>Only subscribed users are allowed to use the list. Postings by users not subscribed to the list are rejected.</p><li>In favor of saving bandwidth, the list allows posting of plaintext messages only. As a result, messages containing binary or other nontextual attachments are also rejected.</p></ol><p>How can these requirements be addressed? First of all, a class skeleton (<A NAME="rl1"><A HREF="#l1">Listing One</A>) containing some constant definitions for the POP3 and SMTP server settings is needed. This skeleton also declares a string array containing mailing-list subscribers.</p><p>Additionally, a <i>main() </i>method that contains the basic control flow is declared. This method provides an entry point for a plain J2ME implementation, such as those available for Windows and Linux. For an MIDP implementation, <i>main()</i> could be replaced by the <i>startApp()</i> lifecycle method used for MIDlets. Whatever its name, the method opens a POP3 session, processes all waiting messages, and closes the session. In <A NAME="rl2"><A HREF="#l2">Listing Two</A>, downloading the messages from the server is done by calling the <i>getMessageCount() </i>and <i>getMessage()</i> methods of the <i>Pop3Client</i> class. For each of the messages, the code first checks whether it is valid in terms of requirement #2. If valid, the message is forwarded to the list; otherwise, an error message is sent to the originator. Also, the messages are removed from the server after being processed.</p><p>The next step is to implement the methods <i>isValidUser()</i>, <i>goodMessage()</i>, and <i>badMessage()</i>, which are used by <i>main()</i>.</p><p>The <i>isValidUser()</i> method (<A NAME="rl3"><A HREF="#l3">Listing Three</A>) checks whether the originator of a given message actually subscribes to the list. This is easily implemented by first getting the value of the message's "From" header field using the <i>getHeaderValue()</i> method. This method could also query other interesting fields contained in the header; for example, "To," "Subject," or "Date." For now I'm only interested in knowing the sender. The <i>getMachineAddress()</i> method then extracts the machine-readable part of the address (the user@domain part), since you don't want to deal with real-life names or other commentary stuff that may be part of the address. The result is converted to lowercase and compared to each of the entries of the <i>users[]</i> array. If it is found, <i>true</i> is returned; otherwise, the invalidity of the message is denoted by returning <i>false</i>.</p><p>The second method to implement is <i>badMessage(),</i> which takes two parameters &#151; the "bad" message and an additional string that is to be included in the response sent to users. The method queries the originator of the message. It then uses this value in conjunction with the list owner's address and the string "Error" to create a new message. The creation process makes use of a "convenience constructor" that automatically sets the "From," "To," and "Subject" fields to the given values, as well as "Date" and "Message-ID" to reasonable ones (the current date/time and a unique ID). It is also possible, of course, to use the default constructor and set the different fields manually. Afterwards, several body lines are added to the message. The last four lines of the method are interesting because they show how easy it is to send a message using Mail4ME: An <i>SmtpClient</i> instance is created (<A NAME="rl4"><A HREF="#l4">Listing Four</A>) and a new SMTP session is opened. The message can then be sent by calling the <i>sendMessage() </i>method before the session is closed to free the underlying socket resources. It is possible, of course, to send more than one message inside the same SMTP session.</p><p>The third method is <i>goodMessage()</i> (<A NAME="rl5"><A HREF="#l5">Listing Five</A>), which forwards a given message to all subscribers of the list. The method does its duty by creating an instance of the <i>Envelope</i> class, in which the original message in enclosed. The envelope's sender is then set to the list owner, and all the subscribers are added to the envelope's list of recipients. This method also opens an SMTP session, but does not send the message directly; instead it sends the envelope in which the message is contained. As a result, the original message is forwarded to the subscribers without changing any header fields. This behavior, which is considered good style in the world of mail-processing software, is known as the "principal of minimal mangling."</p><p>In its current form, the list fulfills requirements #1 and #2, but not the third one: The list should only allow plaintext postings and reject all attempts to post binary content. To address this requirement, you need to make use of the MIME capabilities of the Mail4ME package, namely the <i>MimeDecoder</i> class. Remember that a MIME message is constructed of a tree-like hierarchy of MIME parts, the leaves of which bear the actual content of the message. An instance of <i>MimeDecoder</i> represents exactly one of these parts, giving access to the part's type, and either its content or its list of subordinate parts.</p><p>The <i>isTextOnly()</i> method (<A NAME="rl6"><A HREF="#l6">Listing Six</A>) is able to check whether a MIME part and all of its subordinate parts are text only. The method first checks the result of the <i>getPartCount()</i> method to find out whether it deals with an inner node in the hierarchy of parts or with a leaf. In the former case, it calls itself recursively to check all the subordinate parts; in the latter case, it checks the type of the given part using the <i>getType()</i> method. If this type is not "text/plain," the message is considered bad.</p><p>As usual with recursive methods, the solution is short and elegant. The question left is how and when the first invocation of the method takes place. The answer is simple: The <i>MimeDecoder</i> constructor expects to be passed an existing <i>Message</i> instance, resulting in a top-level MIME view of the message. With that in mind, the <i>isTextOnly()</i> method is integrated with the existing code of the <i>main()</i> method; see <A NAME="rl7"><A HREF="#l7">Listing Seven</A>.</p><p>This mailing-list processor is by no means perfect, or even capable of running a real mailing list. There are a lot of missing features &#151; the ability to change list subscriptions by mail, for instance. Also, user data should be saved to disk, and a list archive could be created for good messages. Some error handling needs to be added to the program; otherwise, subscribers whose e-mail accounts don't exist any more (or simply an invalid subscriber address) result in delivery-failed messages bouncing merrily between the list processor and the nonexistent address. In short, work needs to be done before the list is applicable in real life. Still, building on the basic concepts presented here should be a manageable task.</p><h3>MIDP-Specific Problems</h3><p>The Mail4ME project has a problem that many MIDP applications deal with: The MIDP specification demands only an implementation of the HTTP protocol, meaning that an MIDP-enabled wireless device is not required to provide plain sockets. Unfortunately, these plain sockets are needed for POP3 and SMTP connections. Luckily, the manufacturers of many MIDP-enabled devices implemented the plain socket protocol in addition to the MIDP-specified requirements. Consequently, everything already works fine on these devices.</p><p>But for devices that do not provide plain socket access, a specialized proxy service on a desktop or server machine is needed to allow tunneling POP3 and SMTP through HTTP. This proxy, which is currently under development, might be based on Locumi (<a href="http://locumi.enhydra.org/">http://locumi.enhydra.org/</a>), another EnhydraME project. The tunneling approach would also work for other Internet protocols; for example, if you want to implement Telnet or FTP clients for MIDP. An alternative approach might be to use XML/SOAP-based mail services where possible. Again, an EnhydraME project might provide the foundation, namely KSOAP (<a href="http://ksoap.enhydra.org/">http://ksoap.enhydra.org/</a>).</p><p>J2ME implementations other than MIDP (for example, the upcoming PDA profile) are not expected to exhibit these problems because they're targeted at bigger devices and likely to encompass plain sockets. The same is hopefully true for updated versions of MIDP, now under development by the Sun Community Process.</p><h3>Present and Future</h3><p>There is currently one demo application that shows the potential of Mail4ME on top of MIDP &#151; an e-mail client MIDlet (included in the project's source code) that lets you browse through your POP3 inbox, read individual messages, and compose/send new ones. Since it uses the package's MIME capability, it can display messages composed of plaintext and PNG images.</p><p>We've tested the application and underlying Mail4ME library in the following environments:</p><ul>  <li>The MIDP emulator provided by Sun's Wireless Toolkit 1.0.3 (<a href="http://java.sun.com/products/midp/">http://java.sun.com/products/midp/</a>).  <li>The emulator/SDK for the Siemens SL45i cell phone (<a href="http://www.siemens-mobile.com/mobile/">http://www.siemens-mobile.com/mobile/</a>).  <li>Esmertec's JBed/MIDP for PalmOS (<a href="http://www.esmertec.com/p_jbed_profile_for_MID.html">http://www.esmertec.com/p_jbed_profile_for_MID.html</a>).  <li>The ME4SE project (<a href="http://www.me4se.org/">http://www.me4se.org/</a>), which provides a J2ME emulation layer for the J2SE environment. ME4SE allows the use of traditional J2SE development tools to implement and test MIDP applications before compiling them for MIDP and doing the final test on the actual device.</ul><p>While the Mail4ME package already works well, there is room for enhancements. The top two items on the list are support for the IMAP protocol and a proxy service for MIDP devices that don't support plain sockets. Also, the demo MIDlet is merely a proof of concept and also more-or-less of a client-side feature. Another application that shows Mail4ME's potential inside application server environments is currently under development: A full-featured mailing list processor &#151; somewhat akin to the one shown in the example section &#151; that can be run on any J2ME-enabled device.</p><h3>Acknowledgment</h3><p>Thanks to the people at Lutris, especially the Enhydra folks, for providing a platform for this project.</p><p></p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>public class MailingList {  static String pop3Host = "pop3.yourisp.com";  static String pop3User = "user0815";  static String pop3Pass = "secret";  static String smtpHost = "smtp.yourisp.com";  static String listMachine = "localhost";  static String listOwner = "owner@yourlist.com";  static String[] users = {"duke@sun.com", "clippy@microsoft.com"};}</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>  public static void main(String[] args) throws Exception {    Pop3Client pop3 = new Pop3Client();    pop3.open(pop3Host, pop3User, pop3Pass);    for (int i = 0; i &lt; pop3.getMessageCount(); i++) {      Message message = pop3.getMessage(i);      if (!isValidUser(message)) {        badMessage(message, "you are not subscribed to the list.");      }      else {        goodMessage(message);      }      pop3.removeMessage(i);    }    pop3.close();  }</pre><P><A HREF="#rl2">Back to Article</A></P><H4><A NAME="l3">Listing Three</H4><pre>static boolean isValidUser(Message message) throws Exception {  String sender = message.getHeaderValue("From");  sender = Message.getMachineAddress(sender).toLowerCase();  for (int i = 0; i &lt; users.length; i++) {    if (users[i].equals(sender)) return true;  }  return false;}</pre><P><A HREF="#rl3">Back to Article</A></P><H4><A NAME="l4">Listing Four</H4><pre>static void badMessage(Message message, String reason) throws Exception {  String sender = message.getHeaderValue("From");  Message reply = new Message(listOwner, sender, "Error");  reply.addBodyLine("Sorry, " + Message.getDisplayAddress(sender));  reply.addBodyLine("");  reply.addBodyLine("your message could not be delivered because");  reply.addBodyLine(reason);  reply.addBodyLine("");  reply.addBodyLine("Regards, " + owner);  SmtpClient smtp = new SmtpClient(listMachine);  smtp.open(smtpHost);  smtp.sendMessage(reply);  smtp.close();}</pre><P><A HREF="#rl4">Back to Article</A></P><H4><A NAME="l5">Listing Five</H4><pre>static void goodMessage(Message message) throws Exception {  Envelope envelope = new Envelope(message, false);  envelope.setSender(listOwner);  for (int i = 0; i &lt; users.length; i++) {    envelope.addRecipient(users[i]);  }  SmtpClient smtp = new SmtpClient(listMachine);  smtp.open(smtpHost);  smtp.sendMessage(envelope);  smtp.close();}</pre><P><A HREF="#rl5">Back to Article</A></P><H4><A NAME="l6">Listing Six</H4><pre>static boolean isTextOnly(MimeDecoder mime) {  int count = mime.getPartCount();  if (int i == 0) {    for (int i = 0; i &lt; count; i++) {      if (!isTextOnly(mime.getPart(i))) return false;    }  }  else {    if (!mime.getType().toLowerCase().equals("text/plain")) return false;  }  return true;}</pre><P><A HREF="#rl6">Back to Article</A></P><H4><A NAME="l7">Listing Seven</H4><pre>if (!isValidUser(message)) {  badMessage(message, "you are not subscribed to the list.");}else if (!isTextOnly(new MimeDecoder(message))) {  badMessage(message, "the list allows plain text messages only.");}else {  goodMessage(message);}</pre><P><A HREF="#rl7">Back to Article</A></P></body></html>