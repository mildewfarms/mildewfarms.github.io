<html><head><title>Jun02: Examining  QNX RTOS 6.1</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Examining  QNX RTOS 6.1</h1><p><i>Dr. Dobb's Journal</i> June 2002</p><h2>A message-based, microkernel architecture</h2><h3>By Bart Van Beneden</h3><I>Bart is a project manager at Dedicated Systems Experts. He can be reached at <a href="mailto:b.van.beneden@dedicated-systems.com">b.van.beneden@dedicated-systems.com</a>.</I><hr><p>The QNX real-time operating system has been around for over 20 years and been a part of mission-critical systems ranging from nuclear reactors and medical equipment, to large telecom networks. Over the last couple of years, QNX Software Systems (<a href="http://www.qnx.com/">http://www.qnx.com/</a>) has dramatically redesigned and improved the RTOS. Consequently, we figured it was time to evaluate the real-time capabilities and robustness of the system. To accomplish this, Dedicated Systems Experts (the company I work for) designed a specialized test suite that it has applied to several commercial RTOSs. The fact that we use the same hardware platform for every evaluation makes it possible for us to make product comparisons that make sense. In fact, we used the same platform as the basis for my previous article "Examining Windows CE 3.0 Real-Time Capabilities" (<i>DDJ</i>, December 2001). In this article, I again summarize some key findings of our evaluation. The complete evaluation is freely available at <a href="http://www.dedicated-systems.com/encyc/buyersguide/rtos/rtosmenu.htm">http://www.dedicated-systems.com/encyc/buyersguide/rtos/rtosmenu.htm</a>.</p><h3>The History of the QNX RTOS</h3><p>QNX Software Systems was established in 1980 when it developed its first release of the QNX RTOS, which was designed to run on Intel-based PCs only. QNX featured multiprocessing, transparent distributed processing, fault-tolerant networking, and virtual memory protection (for more information, see "Message-Passing Operating Systems," by Dan Hildebrand, <i>DDJ</i>, June 1988). Over the years, the RTOS built a good reputation in terms of reliability and stability, and was therefore often used in mission-critical applications.</p><DDJADVERTISEMENT INLINE><p>QNX's major downside was that it was available for the Intel x86 platform only, while other processors were more prevalent, especially in the embedded systems market. That's why QNX Software Systems decided to completely redesign the kernel. The new kernel, named "Neutrino," was designed to support multiple platforms &#151; MIPS, PowerPC, StrongARM, and the like &#151; and released in 1996. Today, all releases of the QNX RTOS, including Version 6.1, use this kernel. </p><h3>Architecture of a Modern RTOS</h3><p>The QNX RTOS 6.1 is a message-based operating system with a true microkernel architecture. Message passing is the primary means of interprocess communication. Most of the API calls use this message-passing mechanism. For example, when an application wants to open a file, the system call is translated into a message that is sent to the filesystem manager. The file manager (after accessing the storage device via its device drivers) replies with a file handle. Since this message-passing mechanism is network transparent, the system in its entirety can be seamlessly distributed over several nodes, without requiring any modifications in the application code. </p><p>The microkernel architecture fosters robustness and stability. Every system manager, device driver, and user process runs in its own private virtual memory space, protected from all other processes. The QNX RTOS is also what's called "High Availability (HA) capable," a term that describes an RTOS's ability to stay up and running without interruption for extended periods of time. The QNX RTOS has inherent HA features, such as virtual memory protection and the capability to dynamically load/unload system components. More recently, QNX has added HA-specific modules that support hot swapping and recovery whenever system services, processes, and server connections fail.</p><h3>Testing the System</h3><p>We submitted the QNX RTOS 6.1 to our real-time performance and robustness test suite, which addresses thread and process handling, advanced interrupt handling, synchronization mechanisms, filesystem, and network stack performance. Additionally, the test suite performs various stress tests that monitor the system for memory leaks and performance degradation under loaded conditions. All the tests were executed on the exact same platform we always use &#151; an ordinary PC with an Intel x86 200-MHz MMX processor. </p><p>In one of our more sophisticated tests, we generate two simultaneous interrupts (see <A NAME="rl1"><A HREF="#l1">Listing One</A>) and observe how the system handles them. Both interrupts &#151; one with a higher priority than the other &#151; are generated with less than 100 ns  delay between them. This qualifies as simultaneous interrupts. The system services the highest priority interrupt first, followed by its low-priority counterpart. <A NAME="rf1"><A HREF="0206ef1.htm">Figure 1</A> shows the results for the interrupt latency; the time the RTOS needs to service both interrupts. Clearly, the QNX RTOS doesn't experience the slightest difficulty in handling simultaneous interrupts, as it did not even take 6 ms (microseconds) to start servicing the low-priority interrupt in the worst-case scenario we encountered. The high-priority interrupt was always serviced within 3 <IMG SRC="mu.gif" ALIGN="top">s.</p><p>Again, the QNX RTOS uses virtual memory protection. While this mechanism increases robustness, it is often thought of as detrimental to the system's performance. To assess the performance impact of this memory protection mechanism, we executed our thread switch latency test two different ways. The first test measures the latency to switch between threads belonging to the same process. All threads within a process share the same address space. On the other hand, every process (application, device driver, or whatever) has its own private virtual memory space. That's why we repeated the same test with each thread residing in a different process, measuring the process switch latency. <A NAME="rf2"><A HREF="0206ef2.htm">Figure 2</A> presents the results. As you might expect, switching between processes is slower, but not by much. If you're going to use an RTOS in a mission-critical system, virtual memory protection is a must-have. The performance penalty does not weigh up against the increase in stability and robustness. Only in the smallest and most resource-constrained embedded systems, memory-protection mechanisms and processes may be inappropriate because of the overhead they cause.</p><p>Priority inversion can occur when at least three threads are sharing a common resource that is, for example, protected by a mutex. If the RTOS doesn't have the capability to detect and recover from this situation, it's high-priority tasks may be delayed indefinitely. We executed a test that created a priority-inversion situation and verified how long it would take the QNX RTOS to recover (for a detailed explanation of this test, see "Report Definition and Test Plan" available at <a href="http://www.dedicated-systems.com/encyc/buyersguide/rtos/eval_roadmap.htm#reportdef">http://www.dedicated-systems.com/encyc/buyersguide/rtos/eval_roadmap.htm#reportdef</a>). <A NAME="rf3"><A HREF="0206ef3.htm">Figure 3</A> shows the test results.</p><p>Again, our test suite includes stress tests. During one test, we expose the system to a constant stream of periodic interrupts, and check if the system is able to service all of them. The purpose of this is to ascertain the maximum interrupt frequency that can be sustained during long periods of time, without losing interrupts. We do this in two steps. During the first phase of the test, the system is exposed to only 1000 interrupts (set to occur at a particular frequency), while we count how many of those interrupts were serviced. <A NAME="rt1"><A HREF="0206et1.htm">Table 1</A> shows the frequency threshold at which the system inevitably starts losing interrupts. The results gave us a rough estimate of the maximum interrupt frequency the system could handle during short periods of time.</p><p>During the second phase, we repeat the same tests, but this time around, we generate 1 billion (10<sup>9</sup>) interrupts, keeping the system busy for several hours. Naturally, the longer the system is exposed to these interrupts, the more likely it is that some of them will not get serviced. This is reflected by the results in <A NAME="rt2"><A HREF="0206et2.htm">Table 2</A>: The system lost one single interrupt at 8 <IMG SRC="mu.gif">s, and lost more than we were able to detect with our test setup at 7 <IMG SRC="mu.gif">s. Needless to say, the QNX RTOS performed well in this stress test.</p><p>Be aware that we used a minimal ISR; it simply incremented a counter so we could keep track of the number of interrupts that were serviced. You should also keep in mind that this test not only stresses the RTOS, but also the PC hardware. So no hard conclusions can be drawn as to which part of the system is to blame for losing interrupts.</p><h3>Conclusion</h3><p>At the outset, I mentioned that the QNX RTOS is regarded as a robust and reliable system. Looking at the results of this evaluation, it is fair to say that this reputation is justified and well deserved. The system never exhibited any signs of instability during our stress tests and always responded in a fast and predictable manner. Finally, the QNX RTOS is downloadable free for noncommercial use at <a href="http://get.qnx.com/">http://get.qnx.com/</a>.</p><p></p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>/****************************************************************************//*** This test program installs two interrupt handlers; one hooking into ***//*** into IRQ9, the other one into IRQ10.                                ***//*** Both interrupts simultaneously generated by two PCI bus exersizers. ***//*** This test program measures the time the system needs to react to    ***//*** both interrupts. By adding a small delay between the interrupts,    ***//*** this program can also be used to verify that the interrupt handling ***//*** is prioritized, and that the handlers can be nested.                ***/ /****************************************************************************//* Include files */#include &lt;stdio.h&gt;#include &lt;signal.h&gt;#include &lt;pthread.h&gt;#include &lt;sys/neutrino.h&gt;#include &lt;sched.h&gt;#include &lt;sys/mman.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;#include &lt;time.h&gt;#include &lt;semaphore.h&gt;#include &lt;stdlib.h&gt;#include "trace.h"/* Defintion of some constants */#define PCI_MEMORY   0xE1000000#define P_DRIVE_1    0xE1100000#define P_DRIVE_2    0xE1200000#define PCI_IRQ_1    0x09#define PCI_IRQ_2    0x0a/* Global variables */unsigned long*    pulp_trace;               // PCI_MEMORYunsigned long*    pulp_pdrive_1;            // P_DRIVE_1unsigned long*    pulp_pdrive_2;            // P_DRIVE_2int               iFlag1, iFlag2;/* Function prototypes */const struct sigevent*  isr_handler_1(void* pvp_arg,int id);const struct sigevent*  isr_handler_2(void* pvp_arg,int id);/***************************************************************************//*** The main program entry. This function sets up the interrupt handlers **//*** and initializes the hardware.                                        **//***************************************************************************/void main(){   int nb_trace,  i_status, i, l, b;   /* Set this thread to highest priority */   setprio( 0, 63 );   /* Map the PCI memory into this thread's virtual address space */   pulp_trace = (unsigned long*) mmap(0, 4, PROT_READ |                  PROT_WRITE,MAP_PHYS | MAP_SHARED, NOFD, PCI_MEMORY);   /* Map the P_drive_1 into this thread's virtual address space */   pulp_pdrive_1 = (unsigned long*) mmap( 0, 4, PROT_READ |                  PROT_WRITE,MAP_PHYS | MAP_SHARED, NOFD, P_DRIVE_1);   /* Map the P_drive_2 into this thread's virtual address space */   pulp_pdrive_2 = (unsigned long*) mmap( 0, 4, PROT_READ |                  PROT_WRITE,MAP_PHYS | MAP_SHARED, NOFD, P_DRIVE_2);   /* Initialise P-Drive-1 */   *(pulp_pdrive_1 + 0x68/4) = INIT_CODE_PDRIVE;   *(pulp_pdrive_1 + 0x60/4) = 0x01;   /* Initialise P-Drive-2 */   *(pulp_pdrive_2 + 0x68/4) = INIT_CODE_PDRIVE;   *(pulp_pdrive_2 + 0x60/4) = 0x01;   /* Enable I/O privilege. You need to have root privileges */   /* to execute this */   ThreadCtl(_NTO_TCTL_IO, 0);   /* Attach the high-priority ISR */   i_status= InterruptAttach(PCI_IRQ_1, isr_handler_1 , NULL, 0, 0);   if(i_status==-1) printf(" error attaching ISR-1");   /* Attach the low-priority ISR */   i_status= InterruptAttach(PCI_IRQ_2, isr_handler_2 , NULL, 0, 0);   if(i_status==-1) printf(" error attaching ISR-2");   /* Enable interrupts */   InterruptEnable();   sleep(1);   /* Generate interrupts */   for(;;)   {      /* Write 1 to PDRive mailbox register 0 to generate interrupt */      *( pulp_pdrive_1 + ( 0x40/4 ) )= 0x01;          *( pulp_pdrive_2 + ( 0x40/4 ) )= 0x01;      /* Write traces to PCI bus to calculate interrupt latencies   */      /* Write the only until the interrupts have been serviced.    */       /* This prevents the trace buffer from filling up immediately */      for(i=0; i&lt;250; i++)      {         *pulp_trace = MAIN_LOOP_TRACE;         if((iFlag1==1)&amp;&amp;(iFlag2==1)) break;      }      /* Dummy loop to create a busy delay */      for(l=0; l&lt;2000; l++)      {         i = i &lt;&lt; (b+5*3); b++;      }      iFlag1=0;      iFlag2=0;   }   exit(0);}/***************************************************************************//*** The interrupt handler that is hooked to IRQ9                        ***//***************************************************************************/const struct sigevent* isr_handler_1(void* pvp_arg, int id){   /* Write the trace to get interrupt latency and re-init the PDrive */   *pulp_trace    = ISR1_TRACE;   *(pulp_pdrive_1 + (0x64/4)) = 0x1;   iFlag1 = 1;   return 0; }/***************************************************************************//*** The interrupt handler that is hooked to IRQ10                       ***//***************************************************************************/const struct sigevent* isr_handler_2(void* pvp_arg, int id){   /* Write the trace to get interrupt latency and re-init the PDrive */   *pulp_trace    = ISR2_TRACE;   *(pulp_pdrive_2 + (0x64/4)) = 0x1;   iFlag2 = 1;   return 0; }</pre><P><A HREF="#rl1">Back to Article</A></P></body></html>