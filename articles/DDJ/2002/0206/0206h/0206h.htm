<html><head><title>Jun02: Java Q&A</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Does Java  Guarantee Thread Safety?</h1><p><i>Dr. Dobb's Journal</i> June 2002</p><h3>By Peter Haggar</h3><I>Peter is a senior software engineer for IBM and author of Practical Java Programming Language Guide (Addison-Wesley, 2000, ISBN 0-201-61646-7). He can be contacted at <a href="mailto:haggar@us.ibm.com">haggar@us.ibm.com</a>.</I><hr><p>The Java Language Specification (JLS) guarantees that operations on 32 bits or less are atomic and therefore cannot be interrupted. To eliminate costly synchronization, some programmers try to achieve thread safety by relying on atomic operations. On 32-bit hardware, all primitive types except <i>double</i> and <i>long</i> are typically represented by 32 bits, with <i>double</i> and <i>long</i> typically represented by 64 bits. In addition, object references, implemented as native pointers, are typically 32 bits, too. I say "typically" because the "range of values" of primitive types is guaranteed by the language, not their storage size in the Java Virtual Machine (JVM). Therefore, an <i>int</i> always represents the same range of values on any compliant JVM implementation. Still, one JVM implementation might use 32 bits to represent an <i>int</i>, while another uses 64 bits. According to the JLS, this leads to two guarantees: </p><ul>  <li>The range of values represented by each primitive type is the same across all compliant JVM implementations.  <li>Operations on 32-bit, or smaller, values are atomic.</ul><p>Given this, how can atomic operations not be threadsafe? The main point is that atomic operations can be threadsafe, but there is no guarantee that they are. The reason is that the JLS lets threads keep private working copies of variables separate from main memory. Therefore, main memory is not updated on each access to the variable, resulting in a performance optimization. For example, on a 32-bit machine, the class in <A NAME="rl1"><A HREF="#l1">Listing One</A> contains two methods that set/return the <i>clkID</i> variable. The writing of the <i>clkID</i> variable in the <i>setClockID</i> method and the reading of it in the <i>clockID</i> method are both atomic operations. The <i>clkID</i> variable is an <i>int</i>, thus represented with 32 bits. Assuming <A NAME="rl1"><A HREF="#l1">Listing One</A> is to be accessed by multiple threads concurrently and because of the atomic behavior of a 32-bit variable, you might leave out synchronization for performance benefits. However, consider <A NAME="rf1"><A HREF="0206hf1.htm">Figure 1</A>, which depicts one instance of the <i>RealTimeClock</i> class and two threads of execution (Thread 1 and Thread 2):</p><DDJADVERTISEMENT INLINE><ol><li>Thread 1 calls the <i>setClockID</i> method passing 5.</p><li>5 is placed in the private working memory for Thread 1.</p><li>Thread 1 is preempted by Thread 2.</p><li>Thread 2 calls the <i>setClockID</i> method passing 10.</p><li>10 is placed in the private working memory for Thread 2.</p><li>Thread 2 is preempted by Thread 1<i>.</i></p><li>Thread 1 calls the <i>clockID</i> method and returns 5 from its private working memory.</p></ol><p>The call to <i>clockID</i> in Step 7 should return 10 since that is the last value set. However, 5 is returned because the read/writes were done to the private working memory of the thread. At no point was the variable in working memory reconciled with main memory. The read/writes of <i>clkID</i> are definitely atomic, but because of the allowance for this type of behavior in a JVM, not necessarily threadsafe. There is no guarantee that this problem will occur, but there is no guarantee it won't either. </p><p>Working copies of variables in threads are reconciled with main memory under two conditions:</p><ul>  <li>The variable is declared <i>volatile</i>.  <li>The variable is accessed within a <i>synchronized</i> method or block.</ul><p>If a variable is declared <i>volatile</i>, it is reconciled with main memory on each access. In addition, if a variable is accessed within a <i>synchronized</i> method or block, it is reconciled when the lock is obtained at method or block entry, and when the lock is released at method or block exit. Therefore, either approach ensures this problem does not occur and guarantees that the call to <i>clockID</i> returns 10, the correct value.</p><p>The approach you choose can have performance implications depending on how often the variable is accessed. If concurrency is important and you are not updating many variables, consider using <i>volatile</i>. However, if you are updating many variables, <i>volatile</i> might be slower than synchronization. Remember that when variables are declared <i>volatile</i>, they are reconciled with main memory on every access. Conversely, when <i>synchronized</i> is used, the variables are reconciled with main memory only when the lock is obtained and released. However, synchronization makes the code less concurrent. </p><p>Consider using <i>synchronized</i> if you are updating many variables and don't want the cost of reconciling each of them with main memory on every access, or you want to eliminate concurrency for another reason.</p><p>The JLS states that the operations on 64-bit variables are guaranteed to be atomic if they are declared <i>volatile</i>. However, there is a bug in many JVM implementations with the <i>volatile</i> keyword and 64-bit variables.</p><h3>Atomic Behavior, <i>volatile</i>,  And 64-bit Variables </h3><p>JVMs treat operations on non<i>volatile</i> 64-bit variables as two distinct 32-bit operations. This means that operations on <i>double</i> and <i>long</i> variables are not inherently atomic, as they are with 32-bit variables. However, the JLS proclaims that operations on 64-bit variables are atomic if they are declared <i>volatile</i>. Not only does this ensure atomicity, but it also ensures that private working copies of the variables are atomically reconciled with main memory on every access, and therefore do not need explicit synchronization. Unfortunately, many JVMs do not implement the semantics of the <i>volatile</i> keyword correctly. Therefore, relying on the proper behavior of 64-bit <i>volatile</i> variables is dangerous. <A NAME="rl2"><A HREF="#l2">Listing Two</A> is a modified version of a program found on Bill Pugh's web site (<a href="http://www.cs.umd.edu/~pugh/java/memoryModel/">http://www.cs.umd.edu/~pugh/java/memoryModel/</a>) that demonstrates this problem. </p><p>The comments in <A NAME="rl2"><A HREF="#l2">Listing Two</A> show the values for the variables for Thread 1 for all iterations of the loop except the first. On the first iteration of the loop, <i>val</i> is equal to 0, its initial value, and is set to the value of variable <i>key</i> at the bottom. To demonstrate the problem with <i>volatile</i>, <A NAME="rl2"><A HREF="#l2">Listing Two</A> creates nine <i>AtomicLong</i> objects on nine different threads. Each object initializes its 64-bit <i>key</i> variable to a unique value. 00000001 00000001 is the value for Thread 1, 00000002 00000002 for Thread 2, and so on. When each thread enters its <i>run</i> method, it begins a loop that is set to execute 10 million times. The only variable shared between all nine threads is the <i>static volatile</i> variable <i>val.</i> This is a 64-bit value that should, after the first loop iteration, always equal its initial <i>key</i> value. </p><p>The code in the loop takes the 64-bit variable, <i>val</i>, and converts it into two 64-bit variables, <i>temp1</i> and <i>temp2</i>. The variable <i>temp1</i> only holds the high 32 bits of <i>val</i>, and <i>temp2</i> only holds the low 32 bits of <i>val</i>. The code breaks apart the 64-bit variable into its two 32-bit halves. Each half should be identical, ensuring the consistency of the value. The code does this by taking <i>val</i> and assigning it to a temporary 64-bit <i>long</i> variable <i>temp</i>. It then shifts the bits in <i>temp</i> 32 places to the right, filling with zeros, and stores the result in <i>temp1</i>. Then it shifts the bits held in <i>temp</i> 32 places to the left, filling with zeros, and stores the result in <i>temp2</i>. Finally, it takes the bits held in <i>temp2</i> and shifts them 32 places to the right, filling with zeros, and stores the result in <i>temp2</i>. Now, <i>temp1</i> and <i>temp2</i> should be equal. If they aren't, one of the two assignments involving the 64-bit variable <i>val</i> &#151; <i>temp =val;</i> at the top of the loop and<i> val=key; </i>at the bottom &#151; was not performed atomically as guaranteed by the language. </p><p>Since nine threads are executing this code concurrently and variable <i>val</i> is shared among all nine threads (because it is static), these assignments must be atomic to avoid the problem. Remember that 64-bit variables are normally treated as two separate 32-bit operations. However, because <i>val</i> is declared <i>volatile</i>, these assignments are supposed to be atomic. If <i>temp1</i> and <i>temp2</i> are not equal, their values are printed and the program stops. If <i>volatile</i> is implemented correctly, the program never displays any output. Running this code on a variety of JVMs shows that <i>volatile</i> does not guarantee atomic operations on 64-bit variables. Typical output of this code is something like this: </p><pre><p>Saw: 100000003 <br> temp1 is:1<br> temp2 is:3<br></pre><p>This output means that when <i>val</i> was assigned to <i>temp</i> at the top of the loop, or <i>key</i> was assigned to <i>val</i> at the bottom, the lower 32 bits were written by Thread 3 and the upper 32 bits by Thread 1. When <i>temp1</i> and <i>temp2</i> are calculated, it proves that the reading/writing of the 64-bit variable <i>val</i> is not done atomically. This could happen because: For Thread 1, variable <i>key</i> equals 00000001 00000001 and for Thread 3, <i>key</i> equals 00000003 00000003. Then, consider the following sequence for the assignment <i>val=key;</i>:</p><ol><li>Thread 3 assigns 00000003 to the high 32 bits of variable <i>val</i>.</p><li>Thread 1 preempts Thread 3 before it can write the low 32 bits.</p><li>Thread 1 performs two 32-bit writes and assigns 00000001 00000001 to variable <i>val.</i></p><li>Thread 1 is preempted by Thread 3.</p><li>Thread 3 completes its write by writing 00000003 to the low 32 bits of variable <i>val</i>.</p><li>Variable <i>val</i> now equals 00000001 00000003 and the program stops.</p></ol><p>Even if <i>val=key;</i> occurs atomically, there is still a problem at the top of the loop with <i>temp=val;</i>. Assume that for Thread 3 <i>val</i> is set to 00000003 00000003 with the assignment <i>val=key;</i> at the bottom. Then assume this sequence:</p><ol><li>Thread 3 begins to execute <i>temp=val; </i>at the top of the loop and reads the low 32 bits from <i>val</i>, 00000003, and writes it in the low 32 bits of <i>temp</i>. </p><li>Thread 3 is then preempted by Thread 1.</p><li>Thread 1 writes 64 bits, assigning 00000001 00000001 to <i>val</i> at the bottom of the loop.</p><li>Thread 1 is preempted by Thread 3.</p><li>Thread 3 completes its operation by reading the high 32 bits from <i>val</i>, 00000001, and writing them to the high 32 bits of variable <i>temp</i>.</p><li>Variable <i>temp</i> now equals 00000001 00000003 and the program stops.</p></ol><p>If <i>volatile</i> was implemented correctly, this scenario would not be possible. The 64-bit write operations would happen atomically and <i>val</i> would always be consistent. I tested the AtomicLong program on different JVMs with different run-time optimizers, each failing to implement the <i>volatile</i> semantics correctly. The JVMs I tested include the IBM JDK 1.3 for Windows, Sun JDK 1.2.1 for Windows, and Sun JDK 1.3 for Windows (classic, server, and hotspot VMs).</p><p>According to Bill Pugh's web site, there are other JVMs that do not implement the semantics of <i>volatile</i> correctly (this problem has been reported to JavaSoft as bug number 4023233). In fact, his testing reveals only one that does (the Sun Solaris JDK 1.2.2). Neither of us has tested every JVM, so this is not to say there are not other JVMs that implement the semantics of <i>volatile</i> correctly. Therefore, you should not rely on the stated semantics of <i>volatile</i> to access 64-bit variables in a threadsafe manner, unless you have tested your JVM. </p><h3>64-Bit Variables &amp; <i>synchronized</i></h3><p>Given that your JVM most likely does not implement <i>volatile</i> correctly, the only solution is to synchronize access to the shared 64-bit variables. This fixes the problem but is unfortunate because the use of synchronization reduces the concurrency of your code. Again, depending on your code, the use of synchronization to guarantee atomicity of 64-bit variables can be less desirable to the use of <i>volatile</i>. To work around the problem of <i>volatile</i> and guarantee atomicity with 64-bit variables, you need to add a <i>synchronized</i> block around both lines that access the 64-bit variable. The code at the top of the loop then looks like this:</p><pre><p>// Place the assignment in a <br>// synchronized block <br>synchronized(AtomicLong.class)<br>  temp =val;   <br>     //temp =00000001 00000001<br>}</p></pre><p>while the code at the bottom of the loop then looks like this:</p><pre><p>//Place the assignment in a <br>// synchronized block <br>synchronized(AtomicLong.class){<br>  val =key;   //val should always = <br>	     // 00000001 00000001 <br>	     // for thread 1<br>}</p></pre><p>This code synchronizes on the class literal, <i>AtomicLong.class</i>. The code does not synchronize on <i>this</i>, since that would let the different threads execute the assignment concurrently. Because there are nine threads, there are nine different objects represented by <i>this</i>. Synchronizing on the class literal, of which there is only one, ensures that only one thread executes the assignments in the <i>synchronized</i> block at a time. Running this code with the same JVMs as before results in each of them working properly.</p><h3>Conclusion</h3><p>Java supports atomic operations, but because of the way many JVMs are implemented, atomic operations are not necessarily threadsafe. You need <i>synchronized</i> or <i>volatile</i> to guarantee the correctness of atomic operations on 32 bits or less. According to the JLS, the use of <i>volatile</i> and <i>synchronized</i> should guarantee correctness of atomic operations of 64-bit variables as well. However, many JVMs do not implement the <i>volatile</i> keyword correctly, requiring <i>syncronized</i> to be used instead.</p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>class RealTimeClock {   private int clkID;   public int clockID()   {      return clkID;   }   public void setClockID(int id)   {      clkID =id;   }   //...}</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>public class AtomicLong extends Thread {   static volatile long val;   static int count =10000000;   long key;   AtomicLong(int k)   {      long temp =k;      key =(temp&lt;&lt;32)|temp;   //key =00000001 00000001 for thread 1   }                          //key =00000002 00000002 for thread 2 etc   public void run()   {      for(int i =0;i &lt;count;i++)      {         //This 64 bit assignment is supposed to be atomic since val is declared            //atomic         long temp =val;//temp =00000001 00000001         long temp1 =temp&gt;&gt;&gt;32;//temp1 =00000000 00000001         long temp2 =temp&lt;&lt;32;//temp2 =00000001 00000000         temp2 =temp2&gt;&gt;&gt;32;//temp2 =00000000 00000001         if (temp1 !=temp2)         {            System.out.println("Saw:"+Long.toHexString(temp));            System.out.println("temp1 is:"+Long.toHexString(temp1));            System.out.println("temp2 is:"+Long.toHexString(temp2));            System.exit(1);         }         //This 64-bit assignment is supposed to be atomic since val is         //declared volatile.temp1 should always equal temp2.         val =key;//val should always =00000001 00000001 for thread 1     }  }  public static void main(String args [] )  {     for(int t =1;t &lt;10;t++)     new AtomicLong(t).start();   }}</pre><P><A HREF="#rl2">Back to Article</A></P></body></html>