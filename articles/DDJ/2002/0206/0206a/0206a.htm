<html><head><title>Jun02: A C++ Socket Library for Linux</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>A C++ Socket Library for Linux</h1><p><i>Dr. Dobb's Journal</i> June 2002</p><h2>An IPv4/IPv6 class-based sockets C++ library</h2><h3>By Jason But</h3><I>Jason is a senior research fellow at the Centre for Telecommunications and Information Engineering, Monash University. He can be contacted at <a href="mailto:jason.but@eng.monash.edu.au">jason.but@eng.monash.edu.au</a>.</I><hr><p>I was recently working on a network traffic generator that needed to produce both TCP and UDP traffic over both IPv4 and IPv6. No problem. Linux supported IPv6, the standard socket library calls provided the functionality, and W. Richard Stevens's <i>UNIX Network Programming: Volume 1</i> (Prentice Hall, 1997) covered what I needed to write the software. </p><p>But as it turned out, there was a problem. Since I was implementing the program in C++, the design was class based and I wanted the overall program design to utilize a C++ socket class library, rather than use the provided socket function calls. Consequently, I began looking for suitable (free) libraries to use. And although I found a number of libraries, each one had something that made it unsuitable &#151; it wasn't free, it had only TCP or only IPv4 support, it was too complex, and the like.</p><DDJADVERTISEMENT INLINE><p>In the end, I wrote SocketCC, the C++ class library I present here, which supports both IPv4 and IPv6 network communications using both TCP- and UDP-style sockets. SocketCC is not a comprehensive sockets library, nor is it necessarily suitable for all types of applications. However, it is both class based and open source, so you should be able to work around any deficiencies by inheriting classes or rewriting the base class. </p><h3>The Classes</h3><p>SocketCC's header file, socketcc.h (available electronically; see "Resource Center," page 5), includes the C++ class definitions for all of the classes defined by the SocketCC library. Some standard socket and pthread library headers are included because they are required by some definitions within the header file; otherwise, this .h file includes the C++ definitions and a series of comments to describe the intended class usage. Since this header file is to be made accessible in the /usr/include directory, it is important for it to be well documented. <A NAME="rf1"><A HREF="0206af1.htm">Figure 1</A> illustrates the class hierarchy defined in socketcc.h. You can see that there are two standalone classes as well as a family of classes inherited from the <i>SocketBase</i> base class. The family of inherited classes provides the actual socket functionality. The base class provides common socket functions and the inherited socket classes provide the specific functionality of a particular type of socket.</p><p>SocketCC uses the <i>SocketException</i> class to pass error messages. If an error occurs at any time within SocketCC, an exception of type <i>SocketException</i> is thrown. The class stores an error code and string representation of the error code. The exception can be queried to determine the error type and be cast to a string value for printing purposes. The class is implemented within socketexception.cpp (available electronically).</p><p>The <i>IPAddress</i> class provides encapsulation of both IPv4 and IPv6 addresses within a single type. Within the standard sockets library, IPv4/IPv6 addresses are stored as continuous binary arrays of different lengths and require different function calls to convert both to and from a string representation. Similarly, when using these addresses within a socket call, different structures need to be used depending on which address type is in use. The idea behind the <i>IPAddress</i> class is to allow both address types to be represented within a single type and simplify socket calls, where a variable of type <i>IPAddress</i> is all the user application needs to pass and refer to. A goal in designing this class was to encapsulate DNS functionality &#151; to allow the address to be set either by its binary value or string representation, as well as to retrieve a string representation of the address having set it using the binary representation.</p><p>The <i>SocketBase</i> class encapsulates existing socket function calls. My first idea was to store the socket descriptor as a private member variable within the class and provide method calls that identically wrap the socket function calls. I modified this approach to allow use of <i>IPAddress</i> instances and integer port number parameters instead of <i>sockaddr</i> structures. As <i>sockaddr</i> structures are different for both IPv4 and IPv6, they are constructed within the <i>SocketBase</i> methods so that a single method implementation supports both IPv4 and IPv6. The more useful socket function calls are wrapped by <i>SocketBase</i> methods; it is straightforward to include more methods in the definition if more functionality is required. Together with the <i>IPAddress</i> class, the <i>SocketBase</i> class forms the key part of the SocketCC library. </p><p>The <i>TCPSocket</i>, <i>TCPClientSocket</i>, and <i>TCPServerSocket</i> classes extend <i>SocketBase</i> to provide TCP functionality. <i>TCPSocket</i> forms a base class for <i>TCPClientSocket</i> and <i>TCPServerSocket</i>; it provides functionality that is common to both client and server TCP sockets. The class is protectively inherited from <i>SocketBase</i>; therefore, none of the <i>SocketBase</i> methods are available to <i>TCPSocket</i> users to ensure that only valid TCP operations are available. <i>TCPClientSocket</i> inherits publicly from <i>TCPSocket</i> with all public member methods of <i>TCPSocket</i> becoming public member methods of <i>TCPClientSocket</i>. This class provides for the client side of a TCP connection by letting the socket execute a connection to a remote TCP server type socket. <i>TCPServerSocket</i> also inherits publicly from <i>TCPSocket</i> with the same inheritance of the <i>TCPSocket</i> public member methods. This class provides functionality specific to the server side of a TCP connection by creating a listening TCP socket and allowing connections on that socket to be accepted. When a connection is accepted, a class instance of type <i>TCPSocket</i> is created and returned; this instance refers to the newly created socket and enables communication with the remote TCP client socket. The methods within the TCP socket classes are implemented by calling the methods of the base class <i>SocketBase</i> with the appropriate parameters. Given <i>SocketBase</i>, the implementation of these three classes is straightforward &#151; the classes are implemented within tcpsockets.cpp (available electronically).</p><p><i>UDPSocket</i>, <i>UDPServerSocket</i>, and <i>UDPConnectedSocket</i> extend <i>SocketBase</i> to provide UDP functionality. Unlike <i>TCPSocket</i> (which forms a base class to two other classes), <i>UDPSocket</i> forms a base class only to <i>UDPServerSocket</i>. This is because UDP sockets do not have to be connected as TCP sockets do. <i>UDPSocket</i> provides the base functionality of a UDP unconnected socket, allowing the sending/receiving of datagrams to/from a variety of other UDP sockets. Like <i>TCPSocket</i>, <i>UDPSocket</i> is protectively inherited from <i>SocketBase</i> and, therefore, none of the <i>SocketBase</i> methods are available to <i>UDPSocket</i> users. <i>UDPServerSocket</i> inherits publicly from <i>UDPSocket</i> with the full public inheritance of the <i>UDPSocket</i> public member methods. This class provides functionality specific to the server side of a UDP connection where the UDP socket is bound to an IP address and port number. <i>UDPConnectedSocket</i> inherits from <i>SocketBase</i>. While UDP sockets are connectionless, a UDP socket can be connected to a remote UDP socket using the <i>connect()</i> function call. Once this occurs, datagrams can only be sent to the remotely connected socket and are only received if they are sent by the remote socket. Datagrams arriving from a different socket are ignored and not passed to the application. In this case, there is no need to specify the destination socket address nor to obtain the source address information. <i>UDPConnectedSocket</i> encapsulates this functionality by providing a similar interface to <i>TCPClientSocket,</i> which can find a use in a UDP client application where the socket will only be used to talk with a single UDP server. This simplifies the code as the source/destination address information need not be specified multiple times. Like the TCP socket classes, the implementation of the UDP classes is straightforward and the classes are implemented within udpsockets.cpp (available electronically).</p><h3>Implementing <i>IPAddress</i></h3><p>The <i>IPAddress</i> class is implemented in ipaddress.cpp (available electronically). <i>IPAddress</i>'s key feature is that it can be assigned by either a binary IPv4 address, binary IPv6 address, hostname, or another instance of an <i>IPAddress</i> class. Also, there are methods provided to retrieve the stored hostname, address string, a pointer to the binary address, and the length of the binary address. These values are stored internally within private member variables.</p><p>One of the key issues involved with the implementation of <i>IPAddress</i> is that the <i>gethostbyname2()</i>/<i>gethostbyaddr()</i> functions (called from within the class) are nonreentrant. This means that if the function is called a second time, it overwrites the result written during the function's prior call. This becomes a problem in multithreaded applications where multiple threads can be executing <i>IPAddress</i> methods simultaneously. You can solve this by using a static mutual exclusion that is common to all instances of <i>IPAddress</i>. <i>MutEx</i> ensures that only one thread has access to the protected functions until all the returned values are safely copied into the internal member variables.</p><p>There are four assignment operator overloads, whereby an <i>IPAddress</i> class can be set equal to the following: an existing <i>IPAddress</i> class, IPv4 resolved, IPv4 resolved hostname string, binary IPv4 address, and binary IPv6 address. When copying from an existing <i>IPAddress</i> class, all fields within the class are copied from the original. When copying from a hostname string, the <i>SetHostName()</i> member method is called, setting the class to the IPv4 resolved IP address of the provided hostname. Copying from a binary IP address results in the <i>SetAddress()</i> member method being called to set the class instance to either the provided IPv4 or IPv6 address.</p><p>There are also four comparison operator overloads, allowing the <i>IPAddress</i> instance to be compared against another <i>IPAddress</i> class, a hostname string value, and a binary IPv4 or IPv6 address. When comparing to another <i>IPAddress</i> class, you only compare the <i>iAddressType</i>, <i>iAddressLength</i>, and <i>pcAddress</i> fields. This is because if the <i>pcAddress</i> fields match, then the <i>pcStrAddress</i> fields must also match since it is the string representation of <i>pcAddress</i>. <i>pcHostName</i> fields are not compared because the same IP address can have more than one possible hostname. You are comparing the IP address, not the related hostname. The other three comparison overload methods create an instance of <i>IPAddress</i> based on the provided information and then compare this newly created address with itself.</p><p>The advantages of using <i>IPAddress</i> are twofold: An <i>IPAddress</i> is set and calculated via a single operation, and an <i>IPAddress</i> class is passed to <i>SocketBase</i> methods, which takes the appropriate action based on whether it is an IPv4 or IPv6 address, respectively. This hides the details of IPv4 or IPv6 from programmers who can then use a single code base that functions with both IPv4 and IPv6 addresses.</p><h3>Implementing <i>SocketBase</i></h3><p>When I first devised the interface for SocketCC, my intention was to hide the details of the multiple <i>sockaddr</i> structures from user applications, letting it communicate using <i>IPAddress</i> classes and integer values for port numbers. I intended to construct the <i>sockaddr</i> structures as required within methods of the <i>SocketBase</i> class. As it turned out, more socket functions used <i>sockaddr</i> structures than I thought. I first thought about moving this functionality to a private method, but decided that the range of <i>sockaddr</i> structures needed to be encapsulated into a single class, just as I had encapsulated IPv4 and IPv6 binary addresses into a single class. However, I still did not want this to be part of the library. </p><p>My solution was to create a private class called <i>SocketAddress</i>, defined and implemented entirely within socketbase.cpp (also available electronically). As such, I could use this class freely within my <i>SocketBase</i> implementation, but since it is not exported outside this source file, it is unavailable to other classes within the SocketCC library as well as to users of the library.</p><h3>The <i>SocketAddress</i> Class</h3><p>The <i>SocketAddress</i> class encapsulates the structures <i>sockaddr</i>, <i>sockaddr_in</i>, and <i>sockaddr_in6</i> into a single class. While all these structures can be passed as parameters to socket function calls, they are not defined as a family tree and cannot be simply interchanged for one another. The <i>SocketAddress</i> class overcomes this by creating a memory space for a <i>sockaddr_in6</i> structure (the largest of the three structures), and defining three pointers of each structure type to point to the single allocated structure. This saves memory allocation and lets you access fields retrieved via a socket function call by casting to the correct structure type. The class has been defined to simplify code in the <i>SocketBase</i> class, where a <i>SocketAddress</i> class is created, used in a socket function call, and then destroyed.</p><p>The public interface of the <i>SocketAddress</i> class consists of a constructor that clears and sets the internal variables (a series of methods that allow setting the IP address) and port number fields of the <i>SocketAddress</i> class as well as a series of methods to retrieve these values from the class. Finally, there is a method to return the size of the <i>sockaddr</i> structure currently being represented, as well as being able to cast the class to a <i>(sockaddr </i>*<i>)</i>. This cast lets you use the class directly in calls to socket functions.</p><p><i>SocketAddress</i> is straightforward. Each method branches to one of two instructions to either set or retrieve information from the encapsulated <i>sockaddr</i> structure. The instructions differ, depending on whether the structure represents an IPv4 or IPv6 address/port pair.</p><h3>The <i>SocketBase</i> Class</h3><p>If any of the socket function calls return an error within <i>SocketBase</i>, the error code in the global variable <i>errno</i> is examined and the matching <i>SocketException</i> is thrown, causing the method to terminate. Each method in <i>SocketBase</i> corresponds to a matching socket function call, with the class constructor implementing the <i>socket()</i> function call and the class destructor implementing <i>close()</i>. The class constructor creates the socket via <i>socket()</i>, the result of which is the socket descriptor that is then assigned to the internal member variable <i>iSockDesc</i> for future reference.</p><p>Where a socket function requires a <i>sockaddr</i> structure to be filled and passed as a parameter, the corresponding method requires an <i>IPAddress</i> and port number as parameters. A <i>SocketAddress</i> instance is created and its values are set to the provided values. This instance is then cast to a <i>(sockaddr </i>*<i>)</i> pointer when calling the socket function. Where a socket function call returns data by filling in a <i>sockaddr</i> structure, a <i>SocketAddress</i> instance is created and cast to a <i>(sockaddr </i>*<i>)</i> pointer for the socket function call. The <i>IPAddress</i> and port number stored within the <i>SocketAddress</i> instance is then extracted and returned to the caller.</p><p>Some minor differences are evident in the <i>Bind()</i>, <i>Recv()</i>, and <i>RecvFrom()</i> methods. <i>Bind()</i> has two implementations, one that accepts both an <i>IPAddress</i> and port number to bind the socket to. The second implementation accepts just a port number. In this case, the socket is bound to all local IP addresses; this is reflected in the <i>SetIPAddressWildcard()</i> method of <i>SocketAddress</i>. As for the standard socket function calls, a port number of 0 indicates that the server selects any available port number to bind the socket to. Like the socket <i>recvfrom()</i> function call, the two data retrieval methods return the actual number of bytes read from the socket. However, a function result of 0 indicates the socket has been closed at the remote end. In keeping with the basic design of the SocketCC library, these methods throw a <i>NotConnected SocketException</i> when this occurs, saving the calling code from checking the return value of these methods.</p><p>The <i>Accept()</i> method accepts a new connection on a listening socket. The underlying function call returns a new socket descriptor that refers to the newly connected client socket, while the original descriptor refers to the still listening socket. Since the aim of <i>SocketBase</i> is to hide the socket descriptor from the user as an abstraction, the <i>Accept()</i> method should instead return a new <i>SocketBase</i> instance that refers to the newly created socket. The problem is that <i>SocketBase</i> is intended as a base class and you may want to return an inherited class instance for the new connection. My approach is to require a pointer to a <i>SocketBase</i> (or inherited class) instance to be provided to the <i>Accept()</i> method; once the new connection is accepted, the <i>SocketBase</i> instance is modified to represent the newly created socket. This procedure involves closing the socket that is already represented and then setting the value of its internal variables. In the <i>Accept()</i> method, this is achieved by calling the protected <i>NewSocketDetails()</i> method on the second <i>SocketBase</i> instance. To understand the code structure involved in accepting a connection, see <A NAME="rl1"><A HREF="#l1">Listing One</A>.</p><h3>Using SocketCC</h3><p>Once the SocketCC library has been compiled and installed to the system (installation tips are available electronically), it is available for use in all applications. Myecho.cpp (also available electronically) is a sample app that can be compiled with the command <i>gcc -lsocketcc -o myecho myecho.cpp</i>.</p><p>The most interesting parts of this application are the functions <i>TCPEchoClient()</i>, <i>TCPEchoServer()</i>, <i>UDPEchoClient()</i>, and <i>UDPEchoServer()</i>. The rest of the source code is concerned with parsing the command-line parameters and calling one of these four functions with the appropriate parameters. If you ignore the code that prints information to the screen, you can see that the function implementations are simple. For example, <i>TCPEchoClient()</i> creates an instance of <i>TCPClientSocket</i>, connects to the specified server, sends a character string, and waits for a response before disconnecting the socket. In contrast, the server creates an instance of <i>TCPServerSocket</i> that is bound to the provided port number. The <i>AcceptClient()</i> method returns a pointer to a newly created instance of <i>TCPSocket</i>. You wait for data to arrive on the <i>TCPSocket</i> instance and echo it back to the sender. This socket is then closed and destroyed. The cycle repeats, waiting for the next connection. While this server cannot support multiple concurrent clients (which requires the use of multiple threads), it does provide a simple example of the usage of the SocketCC library.</p><p>The UDP client and server implementations are similar and you can use the sample application to experiment with TCP and UDP data transfer over both IPv4 and IPv6 networks based on the command-line parameters of the myecho program.</p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>try{    IPAddress       cClientIP;    int             iClientPort;    SocketBase      cListenSock(), cCommsSock;    // Bind listening socket to port 80 and start listening for a connection    cListenSock.Bind(80);    cListenSock.Listen(5);4    // Block until a client connects, cCommsSock now refers to     //    the newly connected socket    cListenSock.Accept(&amp;cCommsSock, cClientIP, iClientPort);printf("Client (%s) connected from port %d\n",                          (const char *) cClientIP, iClientPort);    // Data transfer using cCommsSock    cCommsSock.Recv(..);    cCommsSock.Send(..);    // cListenSock and cCommsSock are closed when they go out of scope}catch (SocketException &amp;excep);{    printf("Error in Socket Call : %s\n", (const char *) excep);}</pre><P><A HREF="#rl1">Back to Article</A></P></body></html>