<html><head><title>Jul02: Inside Intel's  JPEG Library</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Inside Intel's  JPEG Library</h1><p><i>Dr. Dobb's Journal</i> July 2002</p><h2>A handy addition to your image-processing toolkit</h2><h3>By Mark R. Nelson</h3><I>Mark is a DDJ contributing editor. You can reach Mark at <a href="mailto:markn@ieee.org">markn@ieee.org</a> or via his web site at <a href="http://www.dogma.net/markn/">http://www.dogma.net/markn/</a>.</I><hr><p>To encourage software development for its microprocessors, Intel provides a number of freely available libraries and SDKs. </p><p>These libraries include those for multimedia processing, linear algebra and FFT, speech and character recognition, image manipulation, and encoding/decoding JPEG images. It is no surprise that all of these libraries have processor-specific routines for various families of Intel CPUs and generic code that will run on any standard Intel architecture CPU.</p><DDJADVERTISEMENT INLINE><p>Although these libraries are freely available (<a href="http://developer.intel.com/software/products/perflib/ijl/index.htm">http://developer.intel.com/software/products/perflib/ijl/index.htm</a>), you do have to go through a licensing procedure to redistribute the libraries with your software. However, as far as I can tell, there aren't any circumstances under which Intel will require payments or royalties. Support is another matter. While Intel's web site has FAQ material, known issues, and the like, talking to a person requires a subscription to a premium support service.  </p><p>In this article, I examine one of these libraries &#151; Intel's Win32 JPEG Library--and present a slideshow application I built to test it. I also provide a short comparison of Intel's library against Microsoft's standard <i>IPicture</i> component.</p><p>I originally stumbled upon Intel's library while searching for a solution to a critical problem. A friend and I were intent on supplying entertainment to a company shindig where we work. We wanted to be roving digital photographers, snapping candid shots of coworkers as they engaged in atypical mirth and merriment. </p><p>Our goal was to use a notebook PC and projector to randomly display candid shots of partygoers during the event. What we needed was a slideshow program that randomly displayed JPEG photos from a directory tree. We were hoping for a program that ran in unattended mode, but still was able to periodically scan the photo archive looking for new images. This would lets us add photos across the network without having to break into the show.</p><p>Although affordable slideshow software is easy to come by, we suffered from the Goldilocks syndrome &#151; nothing we tried out was just right. Following the age-old programmer tradition, I decided to reinvent the wheel. Once I found Intel's JPEG Library, I knew I could make a quick job of it.</p><h3>Using Intel's Library</h3><p>The Win32 JPEG Library ships from Intel with a decent manual in PDF format, and a nicely fleshed out sample program called "JPGView." The manual includes code fragments that do a good job of illustrating the various library features. After reading the manual and examining the sample code, the process of displaying a JPEG image on the screen looked straightforward: </p><ol><li>Initialize the library.</p><li>Read the JPEG file header to get the basic image information, including size and color space.</p><li>Set up the various members of the data structure that will hold a Win32 Device Independent Bitmap (DIB).</p><li>Read the JPEG image data into the DIB.</p><li>Display the DIB.</p></ol><p>The first four steps are accomplished in a single routine I wrote called <i>CreateImage</i>. This function takes an input filename as a parameter and returns a pointer to a JPEG_CORE_PROPERTIES structure, which is where the Intel library stores all its information. </p><p>The final step is done in the WM_PAINT handler for the program <i>WndProc</i>. Since the first four steps create a fully functional DIB, all the WM_PAINT handler has to do is set up some parameters and draw the DIB to the output device context. </p><h3>Slideshow</h3><p>Although the code for Slideshow is built using Visual C++, the program doesn't use MFC so you should have good luck using the program with any brand X C++ compiler. The complete source code, including executables and related files, is available electronically; see "Resource Center," page 5.</p><p>Slideshow starts off as a console program that takes a directory name as a command-line argument. That directory name should be the root directory of your album of JPEG files. Slideshow then creates a full-screen main window, starts a five-second timer, and proceeds to process the message loop.</p><p>Other than a bit of glue code, the message handling routine for this program really only cares about two messages: WM_PAINT and WM_TIMER.</p><h3>WM_TIMER</h3><p>Slideshow's main window gets a timer tick once every five seconds. It has three main jobs to do when this timer tick occurs:</p><p></p><ul>  <li>Reload the list of pictures to display, if necessary.  <li>Destroy the current picture object.  <li>Create a new picture object.</ul><p>Slideshow keeps a list of all the pictures it finds in the JPEG directory in a vector named <i>WindowData::picture_names</i>. It also keeps an index of the next picture to decode in <i>WindowData::current_picture</i>. As soon as the timer handler is entered, it checks to see if the <i>current_picture</i> value is at or past the end of the <i>picture_names</i> vector. If it is, the current contents of the vector are erased and the picture directories are scanned for a new list of picture names. (This happens naturally the first time the WM_TIMER tick is processed.) The picture names are randomized so the sequences aren't repeated each time the program is executed.</p><p>After potential maintenance of the image name list, it's a simple matter to delete the current image and create a new one. <i>CreateImage</i> does all the processing needed to load the JPEG image into a DIB. This new image is ready to be painted on the screen. I force that to happen by calling the Windows API function, <i>InvalidateRect(),</i> which forces a WM_PAINT message to be sent to the main window.</p><h3>WM_PAINT</h3><p>The WM_PAINT message means it is time to paint the JPEG image onto the screen. I've characterized this as being an easy task, since the image is now in a DIB. Examination of the WM_PAINT handler in Slideshow.cpp (available electronically) bears this out.</p><p>The actual painting is done via a call to Windows API <i>StretchDIBits()</i> function, which not only copies the image to the screen, but scales it as well. There are a dozen or so lines of code that set up the call to this function. I scale the image so that it fills as much of the screen as possible without clipping any bits, filling any unused space with the desktop background color.</p><p><A NAME="rf1"><A HREF="0207cf1.htm">Figure 1</A> shows what this looks like on the screen of a PC. The program quietly paints a new random image on the screen every five seconds. The machine shown here is a modified I-Opener Internet terminal running Windows 98 and has full network access. (With no cooling fan to create ambient noise, the I-Opener is an ideal desktop photo album.)</p><h3>Making Windows into Objects</h3><p>If you are used to using MFC for all of your C++ projects under Windows, you might find this to-the-API program a bit different. I did try to make it a little more structured by encapsulating the Window data in a C <i>struct</i>, which could just as easily be a class.</p><p>When the program first starts, I create a <i>WindowData</i> object, which contains all the information regarding the currently selected picture, the list of filenames, and so on. When the window is created, I stuff a pointer to this object into the GWL_USERDATA DWORD owned by the window. From that point on, every time I enter the <i>WndProc</i> I can get a pointer to the structure, eliminating the need for global variables.</p><h3>Integrating with Visual Studio</h3><p>The complete Slideshow package (available electronically) includes a project file, but you may need to do a bit of modification after you install Intel's JPEG Library.</p><p>First of all, the SlideShow.cpp file includes Intel's header file, ijl.h:</p><blockquote><p>#include &lt;windows.h&gt;<br>#include "ijl.h"<br>#include &lt;iostream&gt;<br>#include &lt;string&gt;<br>#include &lt;vector&gt;<br>#include &lt;ctime&gt;<br>#include &lt;algorithm&gt;<br>using namespace std; </p></blockquote><p>Naturally, this file won't be in your normal include path. I take care of this by going to the Project|Settings dialog in Visual C++, selecting the C/C++ pane, then the Preprocessor category. You should then enter Intel's header directory in the Additional include directories edit box. </p><p>The project file I built for Slideshow includes the static library, ijl5l.lib. If you took the default path for Intel's install, you don't need to make any changes whatsoever. </p><p>If you use Intel's DLL instead of the static library, or if you chose a different install path, you'll need to delete the current library from the project. After deleting, use menu option Project|Add to Project|Files to add the correct library. </p><h3>Intel versus Microsoft</h3><p>There are any number of reasons you might choose to use Intel's library to display JPEG images. But what about Microsoft's solution? Does the standard distribution of Windows come with components that can perform just as well?</p><p>As it happens, Microsoft provides a standard COM object called <i>IPicture</i> that shares much of the functionality with Intel's library. It not only handles JPEG files, but works with GIF, BMP, and other formats as well.</p><p>To get a handle on its ease of use, I reworked my Slideshow.cpp to use an all-Microsoft solution. The resulting program, SlideShowMS.cpp (available electronically), shares the same structure, and is probably nearly identical in terms of structure and complexity. The major changes are:</p><ul>  <li>Microsoft's image data is stored in the <i>IPicture</i> component, Intel's is in a JPEG_CORE_PROPERTIES structure.  <li>Reading the file data requires two steps and a bit of coding for Intel. Microsoft makes reading easier with the simple <i>OleLoadPicture()</i> function, but loses points for not reading from standard files. By requiring the awkward creation of an <i>IStream</i> object, Microsoft throws away any advantage they have in this area.  <li>I used a standard Windows GDI function to draw the Intel object to the screen. <i>IPicture</i> has a <i>Render()</i> method that is somewhat easier to use and requires less setup.</ul><p>After examining these points, I think you'll agree that there's no clear winner here. If all that matters to you is how much work you have to perform to solve your imaging problems, you can stick with your personal preference and not worry about making a big mistake.</p><p>When it comes to decoding JPEG files and rendering them to the screen, Intel's library stole the show. I ran Slideshow through a batch of 20 JPEG files that were mostly 1600x1200 pixels in size. <A NAME="rt1"><A HREF="0207ct1.htm">Table 1</A> lists the results of my nonscientific test.</p><p>Intel's library seems to take Microsoft's time and cut it in half! It appears that Intel's attention to performance paid off. (Interestingly, I would have expected to see a bigger delta between Intel and Microsoft on the Celeron CPU, but was disappointed.)</p><p>I'm sure there are ways to tweak my SlideShowMS program to get better performance from Microsoft's implementation. But the point of this article is to look at an off-the-shelf solution you can use if you're not a graphics expert. And for a straightforward implementation, Intel appears to really deliver when it comes to CPU cycles.</p><h3>What About IJG?</h3><p>The JPEG file format enjoys great acceptance in the software world. This is due in no small part to the availability of the Independent JPEG Group's (IJG) source code. The IJG (<a href="http://www.ijg.org/">http://www.ijg.org/</a>) created a noncommercial source-code package that has been used as a reference and/or library by literally hundreds of packages out there. It enjoys a great deal of respect for its flexibility and feature depth.</p><p>Intel knows that many developers have already integrated the IJG code into their products, so they have created a 26-page whitepaper that discusses what you need to perform open-heart library replacement. There are major structural differences between the two sets of code, so this isn't an exercise for the faint of heart. But it can be done.</p><h3>Conclusion</h3><p>Intel's library was easy to work with, which is probably evident given the length of my sample application. While I didn't do any objective performance testing, I was happy with the speed I achieved when decoding and displaying multi-megapixel JPEG files on various PCs. </p><p>My satisfaction with the library is certainly only enhanced by the absence of a price tag. Intel's JPEG Library is definitely part of my image processing toolbox, you might want to add it to yours as well.</p><p><b>DDJ</b></p></body></html>