<html><head><title>Jul02:  Monitoring Web Application  Performance & ISAPI</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1> Monitoring Web Application  Performance &amp; ISAPI</h1><p><i>Dr. Dobb's Journal</i> July 2002</p><h2>Solving the  performance  monitoring problem</h2><h3>By Kevin T. Manley</h3><I>Kevin is an independent software developer and consultant and can be reached at <a href="mailto:kmanley@cs.washington.edu">kmanley@cs.washington.edu</a>.</I><hr><p>Accurately measuring the performance characteristics of web applications under realistic loads is a difficult task. Many web applications are designed for hundreds or thousands of concurrent users, but it's not always possible to simulate this level of use before a system goes into production. Subsequently, performance measurement is often ignored until the site is deployed and users complain that it's "too slow."</p><p>Making the task harder, the architecture of modern web applications is complex and can involve multiple underlying technologies. A typical site might use Microsoft's IIS web server, dozens or hundreds of ASP pages coded in VBScript or JScript, a middle tier of COM+ objects implemented in C++ or Visual Basic (perhaps using some third-party libraries), and a database tier accessed via ADO or ODBC. Where do you begin to look for performance problems? What you need is a way to profile the running system so you can gather quantitative data.</p><DDJADVERTISEMENT INLINE><p>The structure of a web application provides an opportunity to centralize performance monitoring since every client request must pass through the web server. Therefore, if you can extend the web server to monitor performance, you can identify the worst-performing resource requests. Luckily, many commercial web servers do offer hooks for extending functionality. In this article, I present an Internet Server API (ISAPI) filter for Microsoft IIS that does just this. The complete source code and related files for this filter are available electronically; see "Resource Center," page 5.</p><h3>Introducing MonitorIsapiFilter </h3><p>MonitorIsapiFilter is an ISAPI filter that watches all requests sent to IIS, then maintains statistics for each unique resource. Over time, these statistics reveal the true run-time characteristics of the web application. Statistics the filter tracks include:</p><ul>  <li>Number of requests for each resource.  <li>Min/max/average time to serve each resource.  <li>Min/max/average bytes returned from each resource.  <li>Average bytes/sec throughput for each resource.</ul><p>You can view the current performance data by requesting a special URI. The filter dumps data out in a tab-delimited format, and if you have Microsoft Excel installed, it opens in the browser window displaying the data, as in <A NAME="rf1"><A HREF="0207ff1.htm">Figure 1</A> (collected while using the IIS Administration site on my machine). The filter persists its data across server restarts so you can collect data over long periods of time. </p><p>The advantages of monitoring performance with MonitorIsapiFilter include:</p><ul>  <li>Changes to your existing web application are not required. In contrast, instrumenting individual server components (ASP pages, COM objects) can be time consuming, error prone, and difficult to maintain.   <li>It works with any resource request served by IIS. It doesn't matter if your site uses a combination of ColdFusion, ASP, Java servlets, and CGIs.   <li>Virtually no effect on site performance is introduced. There is less than 1-ms overhead per request, so it can be used in a production setting, where performance data reflects real-world use.   <li>Performance data is always up to date and accessible from any browser on the local network. </ul><h3>ISAPI Overview</h3><p>ISAPI extensions, functionally equivalent to in-process CGIs, are plug-ins requested like other server resources &#151; via specific URIs. IIS responds to the request by making a function call into your ISAPI extension DLL, which does some work and writes data back to the client. </p><p>However, MonitorIsapiFilter is implemented using a lower level plug-in type called an "ISAPI filter," which is not requested directly, but is registered with IIS to receive specific event notifications on every HTTP request and response. This ability to see and respond to every HTTP request that crosses the server lets you implement a global performance monitor for all requested resources. </p><h3>ISAPI Filter Basics</h3><p>Like every ISAPI filter, MonitorIsapiFilter is a standard Win32 DLL that exports three functions. IIS calls the first function, <i>GetFilterVersion()</i>, once when the service starts up. The filter sets the <i>dwFlags</i> field in <i>pVer</i> to indicate the events for which it would like to receive callback notifications. </p><pre><p>BOOL WINAPI GetFilterVersion(<br>  PHTTP_FILTER_VERSION pVer  <br>);</p></pre><p><i>HttpFilterProc()</i> is the function IIS calls whenever one of the registered events occurs. The <i>pfc</i> structure is essentially a wrapper around the socket connection between the client and server. The filter uses this to query HTTP request headers, read IIS server variables, and write data back to the client. <i>pvNotification</i> contains extra information specific to the callback. Depending on the value of <i>notificationType</i>, the filter implementation must cast <i>pvNotification</i> to a pointer to one of several structure types. IIS may call <i>HttpFilterProc()</i> several times during the lifetime of a single HTTP request, depending on the notifications the filter registered to receive.</p><pre><p>DWORD WINAPI HttpFilterProc(<br>  PHTTP_FILTER_CONTEXT pfc,  <br>  DWORD notificationType,  <br>  LPVOID pvNotification  <br>);</p></pre><p>The last filter function, <i>TerminateFilter()</i>, is called once by IIS when it is shutdown in an orderly fashion. This gives the filter a chance to free resources before being unloaded from memory. </p><pre><p>BOOL WINAPI TerminateFilter(<br>  DWORD dwFlags  <br>);</p></pre><h3>MonitorIsapiFilter Notifications</h3><p>To implement performance monitoring, MonitorIsapiFilter needs to know when a resource request begins, how many bytes the server sends to the client for the requested resource, and when the resource request ends. This requires the following notifications, defined in the ISAPI header file httpfilt.h:</p><p></p><ul>  <li>SF_NOTIFY_URL_MAP. Occurs after IIS has translated the requested URI into a physical path on the server. It's the earliest notification that can be used to determine the name of the requested resource. Once the resource name is known, the filter starts a timer associated with the request.   <li>SF_NOTIFY_SEND_RAW_DATA. Occurs as IIS sends data to the client and can occur multiple times for a single request. The sum of bytes returned for each of these notifications is the total bytes returned for the resource.   <li>SF_NOTIFY_SEND_RESPONSE. Occurs after the request has been processed but before any data has been sent to the client. Trapping this event helps avoid a potential denial of service attack, described later.  <li>SF_NOTIFY_END_OF_REQUEST. Occurs at the end of the request, after data has been written to the client. The filter stops the timer, which started when it received the SF_NOTIFY_URL_MAP event for the request here. The elapsed time is the time to serve the resource. </ul><h3>Responding to Notifications</h3><p>In MonitorIsapiFilter, <i>HttpFilterProc()</i> delegates work to several helper functions based on notification type, casting the <i>pvNotification</i> pointer to the appropriate type for that notification. <i>OnNotifyUrlMap()</i> (<A NAME="rl1"><A HREF="#l1">Listing One</A>) handles the SF_NOTIFY_URL_MAP callback, and is the first notification of a new HTTP request. If the request is not for an internal command (a command that dumps the dataset or resets counters), I find an available <i>ContextInfo</i> structure and set its start time to the current time. <i>ContextInfo</i> structures are stored in a structure called <i>ContextMap</i>, which is actually a fixed-length array of size MAX_CONCURRENT_REQUESTS. I wanted to avoid allocating memory for a <i>ContextInfo</i> structure on each request because access to the global heap is serialized and dynamic memory allocation is relatively slow. This can cause a severe performance bottleneck in a busy server processing hundreds of concurrent requests. Since I want to ensure the performance monitoring code doesn't introduce additional performance problems, I quickly scan the small <i>ContextMap</i> array to find an available <i>ContextInfo</i> structure (<A NAME="rl2"><A HREF="#l2">Listing Two</A>). If none are available, I skip logging performance info for the request. To identify subsequent event notifications for the same request, I cast the HTTP_FILTER_CONTEXT pointer to a DWORD and store this key in the <i>ContextInfo</i> structure. </p><p><i>OnSendRawData()</i> handles the SF_NOTIFY_SEND_RAW_DATA notification. All that is required is to look up the <i>ContextInfo</i> structure for the request and increment the number of bytes sent so far. This event notification can occur many times for requests that generate a lot of data.<i></p><p>OnEndOfRequest()</i> (<A NAME="rl3"><A HREF="#l3">Listing Three</A>) is where most of the work happens. At this point, the request has been serviced and IIS is ready to accept another request or drop the connection. Again, I look up the <i>ContextInfo</i> structure, then calculate the elapsed duration for the request by subtracting the current time from the start time stored in <i>OnNotifyUrlMap()</i>. The filter uses Windows's high-resolution timer API function <i>QueryPerformanceCounter()</i> to achieve submicrosecond resolution (the standard timer API, <i>GetTickCount()</i>, only has 10-ms resolution on NT 3.5+, 55 ms on Windows 95/98). </p><p>The next step involves <i>PageMap</i>, a standard STL map that associates string URIs with <i>PageInfo</i> pointers. For this data structure, I used dynamic memory allocation for two reasons: </p><ul>  <li>I wanted to be able to handle large sites with an arbitrary number of unique URIs.   <li>I only have to allocate memory when a URI that hasn't been requested before is seen, which is infrequent. </ul><p>The <i>PageInfo</i> structures store cumulative stats for each resource request, including the total number of requests, min/max/avg bytes, and min/max/avg duration. At the end of <i>OnEndOfRequest()</i>, the filter dumps statistics for the request to any attached debugger via the Win32 call <i>OutputDebugString()</i>. Rather than run IIS under a debugger, I usually use the excellent DebugView utility (<a href="http://www.sysinternals.com/ntw2k/freeware/debugview.shtml">http://www.sysinternals.com/ntw2k/freeware/debugview.shtml</a>); see <A NAME="rf2"><A HREF="0207ff2.htm">Figure 2</A>.</p><h3>Other Implementation Issues</h3><p>Again, the filter allocates memory when it encounters a unique URI. This should raise a red flag because it opens a potential denial of service attack. If attackers knew a web site was using MonitorIsapiFilter, they could continually request random URIs, causing the filter to allocate memory without bound. To avoid this, I trap the SF_NOTIFY_SEND_RESPONSE event in <i>OnNotifySendResponse()</i> (<A NAME="rl4"><A HREF="#l4">Listing Four</A>). If the URI request results in a "404 Not Found" error, I skip performance monitoring for the request. URIs are also stripped of any <i>querystring</i> parameters before being added to the <i>PageMap</i>. This avoids a proliferation of URIs being stored for the same resource.</p><p>Internal commands are handled by <i>OnInternalRequest</i>. Here I check the client's IP to make sure it's in one of the nonroutable address ranges (for example, 172.16.0.0-172.31.255.255; see RFC 1597). This prevents random clients on the Internet from issuing commands to reset the performance monitor or dump its current dataset. This minimal authentication scheme could be enhanced to require user names and passwords to access performance data. </p><p>When authorized clients request a dump of the dataset, <i>DumpProfileData</i> (<A NAME="rl5"><A HREF="#l5">Listing Five</A>) renders the dataset into a tab-delimited text stream and writes the data back to the client. The trick here is setting the HTTP Content-Type header to application/vnd.ms-excel. If Excel is installed and you are using Internet Explorer, Excel loads the data directly and displays it in the browser window. </p><h3>Installing the Filter</h3><p>MonitorIsapiFilter can be installed either at the server or web-site level. If you install it at the server level, it sees all requests for all active web sites on the server. To install the filter, open the Internet Services Manager and edit the properties for the server or site. Click on the IIS Filters tab and add MonitorIsapiFilter.dll to the list. </p><p>If you use a cluster of load-balanced web servers, it's a good idea to initially install MonitorIsapiFilter on all the web servers. The first time I tried this in production at my current place of employment, I immediately saw a load-balancing problem that was resulting in three times as much traffic sent to one server than the others. If all your web servers are running identical hardware/software and load balancing is working properly, you can choose to run MonitorIsapiFilter on a single web server, since data collected there is representative of any machine in the cluster. </p><h3>Controlling the Filter</h3><p>You can control MonitorIsapiFilter with special URI commands starting with the characters "monitor-isapi-filter." Type an address like <a href="http://www.myserver.com/monitor-isapi-filter">http://www.myserver.com/monitor-isapi-filter</a> in your browser to invoke the command. <A NAME="rt1"><A HREF="0207ft1.htm">Table 1</A> lists the supported commands.</p><p>You can turn the filter on/off without having to shutdown IIS and uninstall the filter. When the filter is off, overhead is on the order to 10 microseconds per request. When the filter is on, performance monitoring is active and the overhead is on the order of 0.5 milliseconds per request. </p><p>When you issue the <i>reset</i> command, the filter saves its current dataset to a file of format c:\mif-data-YYYYMMDD-HHMMSS.txt, using the current date and time for the last part of the filename. If you cycle IIS, the filter saves its current dataset in a file called c:\mif-data.txt. <i>reset</i> must be issued via HTTP POST instead of GET. This makes it harder to accidentally reset the counters. </p><h3>Interpreting Performance Data</h3><p>Before trying to interpret the performance data MonitorIsapiFilter gathers, let it run long enough to track hundreds or thousands of requests. That way, the data will better reflect average behavior and won't be thrown off by a few requests that had very high latency (or returned an unusually large amount of data). Once you have a statistically significant sample, you can start to draw some conclusions about how your web application performs: </p><p></p><ul>  <li>Resources with high values for <i>NumCalls</i> are the most-requested resources. Following the design principle of "making the common case fast," focus on the performance of these resources. Conversely, it may not be worthwhile to spend time on resources that are rarely requested, no matter how poor their performance.  <li>Resources with <i>MinDuration</i> close to <i>MaxDuration</i>, and a high value (two seconds or more) for both, consistently take a long time to process. This could be due to expensive database queries, multiple cross-process COM+ calls, contention for access to a shared resource, or other factors. If commonly requested, these resources warrant a closer examination.   <li>Resources with low <i>AvgBytesPerSec</i> take a long time to process relative to the amount of data they produce. This indicates inefficient algorithms that may respond well to simple optimizations.   <li>Resources with high <i>AvgBytes</i> consistently return a lot of data, which can be a problem for users connecting over slow links. Consider implementing page navigation for the data returned by these resources, sending a smaller amount of data back per page.   <li>Static resources (GIF, JPEG, HTML files, and so on) with <i>AvgBytes</i> close to <i>MaxBytes</i> may indicate caching problems. Normally a resource cached on the client should result in a small response from the server (HTTP 304 Not Modified). One possible cause is accidentally appending query string parameters to the end of static resource URIs; for example, <a href="http://www.myserver.com/static.jpg?sessionid=123">http://www.myserver.com/static.jpg?sessionid=123</a>.</ul><p>These are just a few of the issues to consider when viewing statistics collected by MonitorIsapiFilter. Time and experience will show other ways to gain insight from the information. After identifying problem resources, you can use finer grained instrumentation to discover the underlying causes. This instrumentation will necessarily be specific to your site.</p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>// Handler for SF_NOTIFY_URL_MAP notificationDWORD OnNotifyUrlMap(    PHTTP_FILTER_CONTEXT pfc,      HTTP_FILTER_URL_MAP* pUrlMap){    // If this is an internal request, handle it now    if( strstr( pUrlMap-&gt;pszURL, "monitor-isapi-filter" ) ) {        return OnInternalRequest( pfc, pUrlMap );     } else if( !bOn ) {         // Otherwise, if turned off, disable notifications &amp; exit        DisableNotifications(pfc);         return SF_STATUS_REQ_NEXT_NOTIFICATION;    } // if      // Get context data structure for this request   ContextInfo* pContextInfo=contextMap.GetOrCreateContextInfo( (DWORD) pfc );   if( pContextInfo ) {        // No need to lock pContextInfo; it can only be active in         // one invocation of HttpFilterProc at a time        pContextInfo-&gt;start = StartTiming();         pContextInfo-&gt;bytes = 0;     } else {      TRACE0("[MIF] INFO: failed to create context info in OnNotifyUrlMap\n");    } // else    return SF_STATUS_REQ_NEXT_NOTIFICATION;}</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>// Fetches ContextInfo pointer from list, assigns a new // slot for it if it doesn't already existinline ContextInfo* ContextMap::GetOrCreateContextInfo(     DWORD dwKey ) {    int slot=0;     CritSectLock lock(&amp;cs); // lock list    ContextInfo* pInfo = internalGetContextInfo( dwKey, &amp;slot );    if( (pInfo == NULL) &amp;&amp; slot&gt;0 ) {        // We didn't find it, but there is a slot available        pInfo = &amp;(info[slot]);        pInfo-&gt;Clear();        pInfo-&gt;key = dwKey;    } // if    return pInfo;}// Fetches ContextInfo pointer from map if available. While scanning list, // keep track if you've found any empty slots. If return value is NULL,// then pnAvailSlot may point to a nonzero available slot number if a slot was// available. NOTE: caller must synchronize access to the info data structureinline ContextInfo* ContextMap::internalGetContextInfo(     DWORD dwKey,     int* pnAvailSlot ) {    for( int i=0; i&lt;MAX_CONCURRENT_REQUESTS; i++ ) {        ContextInfo* pInfo = &amp;(info[i]);         if( pInfo-&gt;key == dwKey ) {            return pInfo;         } else if( pInfo-&gt;key == 0 ) {            *pnAvailSlot = i;         } // else    } // for    return NULL;}</pre><P><A HREF="#rl2">Back to Article</A></P><H4><A NAME="l3">Listing Three</H4><pre>// Handler for SF_NOTIFY_END_OF_REQUEST notificationDWORD OnEndOfRequest(    PHTTP_FILTER_CONTEXT pfc  ){    // Get context data structure for this request    ContextInfo* pContextInfo = contextMap.GetContextInfo( (DWORD) pfc );    if( pContextInfo ) {        // NOTE: no need to lock pContextInfo since it can only         // be active in one invocation of HttpFilterProc at a time        // Get URL of request        char szPageName[MAX_URL_LEN];        GetRequestUrl( pfc, szPageName, MAX_URL_LEN );          // Get or create data structure for this page        PageInfo* pPageInfo = pageMap.GetOrCreatePageInfo( szPageName );        if( pPageInfo ) {            CritSectLock lock(&amp;(pPageInfo-&gt;cs)); // lock PageInfo structure            DWORD dwDuration = (DWORD) EndTiming( pContextInfo-&gt;start );             // If duration is truncated to 0, bump it to min resolution of 1ms            if( dwDuration == 0 ) {                dwDuration = 1;            } // if            DWORD dwBytes = pContextInfo-&gt;bytes;            pPageInfo-&gt;numcalls++;            pPageInfo-&gt;duration.Update(dwDuration);            pPageInfo-&gt;bytes.Update(dwBytes);            // Make copies of pPageInfo data so we can exit critsect before            // expensive sprintf/trace calls            long numcalls = pPageInfo-&gt;numcalls;            Counter duration = pPageInfo-&gt;duration;            Counter bytes = pPageInfo-&gt;bytes;            // Release page and context info, unblocking waiting threads             lock.Unlock();            contextMap.FreeContextInfo(pContextInfo);            TRACE10( "[MIF] %s: calls=%lu, time=%lu (min=%lu, max=%lu,                avg=%lu), bytes=%lu (min=%lu, max=%lu, avg=%lu)\n", szPageName,               numcalls, dwDuration, duration.dMin, duration.dMax,                duration.Average(numcalls), dwBytes, bytes.dMin, bytes.dMax,                bytes.Average(numcalls));        } else {            TRACE0( "[MIF] INFO: failed to get or create                                         page info in OnEndOfRequest\n" );        } // else    } else {        TRACE0("[MIF] INFO: failed to get context info in OnEndOfRequest\n");    } // else    return SF_STATUS_REQ_NEXT_NOTIFICATION;}</pre><P><A HREF="#rl3">Back to Article</A></P><H4><A NAME="l4">Listing Four</H4><pre>// Handler for SF_NOTIFY_SEND_RESPONSEDWORD OnSendResponse(     PHTTP_FILTER_CONTEXT pfc,      HTTP_FILTER_SEND_RESPONSE* pfsr){    // The monitor SF_NOTIFY_SEND_RESPONSE to avoid a possible DoS attack    // Since we allocate memory on each unique URI served, malicious attackers    // could hit server with random URIs, filling our memory. Therefore if we    // see that this request resulted in a 404 Not Found error, we skip     // logging for this request    if( pfsr-&gt;HttpStatus == 404 ) {        ContextInfo* pContextInfo = contextMap.GetContextInfo( (DWORD) pfc );        if( pContextInfo ) {            contextMap.FreeContextInfo( pContextInfo );         } // if        DisableNotifications( pfc );     } // if    return SF_STATUS_REQ_NEXT_NOTIFICATION;}</pre><P><A HREF="#rl4">Back to Article</A></P><H4><A NAME="l5">Listing Five</H4><pre>// Dumps profile data in tab-delimited format to the browser.DWORD DumpProfileData(    PHTTP_FILTER_CONTEXT pfc  ){  LPCSTR FIRSTLINE =   "PageName\tNumCalls\tMinDuration\tMaxDuration\tAccumDuration\tAvgDuration\t"  "MinBytes\tMaxBytes\tAccumBytes\tAvgBytes\tAvgBytesPerSec\n";  LPCSTR HEADERS =    "HTTP/1.0 200 OK\r\n"                      "Content-Type: application/vnd.ms-excel\r\n"                      "Cache-Control: no-cache\r\n"                      "Expires: Mon, 09 Oct 2000 16:00:00 GMT\r\n"                       "Pragma: no-cache\r\n"                      "\r\n";    DWORD dwLen = strlen(HEADERS);    pfc-&gt;WriteClient( pfc, (LPVOID)HEADERS, &amp;dwLen, 0);     dwLen = strlen(FIRSTLINE);    pfc-&gt;WriteClient( pfc, (LPVOID)FIRSTLINE, &amp;dwLen, 0);    strstream stream;    pageMap.Dump(stream);     dwLen = stream.pcount();    pfc-&gt;WriteClient( pfc, stream.str(), &amp;dwLen, 0);    return SF_STATUS_REQ_FINISHED;}</pre><P><A HREF="#rl5">Back to Article</A></P></body></html>