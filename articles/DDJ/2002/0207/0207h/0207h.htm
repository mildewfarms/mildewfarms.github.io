<html><head><title>Jul02: Java Q&A</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>What Is a  Java Event Agent?</h1><p><i>Dr. Dobb's Journal</i> July 2002</p><h3>By Eric J. Bruno</h3><I>Eric is a development analyst with Reuters. He can be contacted at <a href="mailto:eric.bruno@reuters.com">eric.bruno@reuters.com</a>.</I><hr><p>The JavaBean event model is powerful in its simplicity. A source bean sends an event to anonymous listener beans via a method call on an interface. The source does not need to know who's listening to the events &#151; or what happens when the events are received &#151; and the listeners don't need to know the implementation behind these events.</p><p>Events are a big part of the JavaBean component architecture. Despite the simplicity of the event model, it does bring along complexities related to component dependencies. </p><DDJADVERTISEMENT INLINE><h3>The JavaBean Event Model</h3><p>The event model is made up of an event source, event interface, event object, and event listener that implements the event interface. The event source component fires an event by invoking a method on the event interface of the event listener. </p><p>An event interface extends <i>java.util.EventListener</i> and defines additional methods that make up a related set of events. Each method defined represents a unique event notification. The parameter for each method on the event interface is typically a subclass of <i>java.util.EventObject</i>. This object should be used to encapsulate the details of the event. However, it is not mandatory that you use it &#151; an arbitrary list of parameters is acceptable.</p><p>An event source is identified by its implementation of a registration method that accepts instances of a particular event interface. A component can be a source to multiple event interfaces by implementing a registration method for each one it supports. Conversely, a component can listen to more than one event set by implementing each event interface. </p><p>To illustrate, I've created a set of JavaBeans to handle changes to a company's stock price (quote). In this quote system (available electronically; see "Resource Center," page 5), I have <i>QuoteSource</i>, <i>QuoteListener</i>, and <i>QuoteObject</i> classes. I have also defined a <i>QuoteChangedListener</i> interface (<A NAME="re1"><A HREF="0207he1.htm">Example 1</A>) that defines an event for when a quote changes. <i>QuoteListener</i> implements this interface and provides an implementation of the <i>quoteChanged</i> event method. The method's parameter is an event object, <i>QuoteEvent</i> (<A NAME="re2"><A HREF="0207he2.htm">Example 2</A>). The <i>QuoteEvent</i> class constructor takes the event source as a parameter, which is stored by calling the superclass constructor. The <i>java.util.EventObject</i> interface defines a <i>getSource</i> method that returns a reference to the source object. A listener can call this method to identify the source component when an event is fired. <A NAME="rl1"><A HREF="#l1">Listing One</A> presents the <i>QuoteSource</i> and <i>QuoteListener</i> code.</p><h3>Component  Dependencies</h3><p>The complexity begins as multiple components implement multiple event interfaces. This situation gets more complex when a source component is also a listener of another source component. In <A NAME="rf1"><A HREF="0207hf1.htm">Figure 1</A>, which illustrates this complex web of components, the quotes system contains a component that manages system state. The <i>StateChangeSource</i> component fires system state change events. The <i>QuoteDisplay</i> component listens to these events and grays out the display if the state changes to "unavailable." The <i>QuoteChangedSource</i> component has a requirement to maintain a history of quote changes, thus needs to retrieve quote history data when the state changes back to "available." The <i>PortfolioValueChangedSource</i> tracks all changes to quotes in the user's portfolio, and all changes to this value are reflected by the <i>QuoteDisplay</i> component.</p><p>On the surface, this seems like a reasonable quote system design. However, instead of designing components that simply receive events, I've really designed components that are clients of many other components. The component dependency matrix this creates becomes a huge maintenance problem.</p><p>You should not need to know which component is the source to a particular set of events. Another developer deciding to combine two source components into one component that now sources the combined events will affect the listener component's code. Of course the opposite could occur, where one source component is broken out into multiple source components. These are implementation details that, as an event listener, you shouldn't need to know about. At the least, you should not need to modify your code as a result of such changes.</p><h3>Circular Dependencies</h3><p>A more complex component relationship arises when two source components are also listeners to one another's events, as in <A NAME="rf2"><A HREF="0207hf2.htm">Figure 2</A>. This is a problem because it creates a tight coupling between the two components. It can also lead to a memory leak, as the objects may never release their references to one another.</p><h3>Event Source Abstraction</h3><p>One solution is to abstract all source and listener components one more level by placing a Singleton component between them. This component &#151; or agent &#151; exists on behalf of all source components. Each source component can register itself with the agent as the source for an event interface. Other components can register themselves as listeners with this agent, thereby removing the need to know which specific components source each event interface. The agent notifies the source components when listeners arrive.</p><h3>The Event Agent</h3><p>The event agent I describe here is a component that provides this level of abstraction. It is only involved in matching up listener components with source components, and does not act as a router of the events themselves. This would otherwise make the event agent a bottleneck. Once a source and a listener component are matched together, the event agent is out of the picture. </p><p>In this implementation, the event agent uses the Singleton design pattern to ensure that there is only one instance of it in existence. To achieve this, the constructor is made private and the class contains a private, static, final instance of itself, accessible via a static method named <i>getInstance</i>. <A NAME="re3"><A HREF="0207he3.htm">Example 3</A> implements this design pattern, and can be used to make any Java class a Singleton.</p><p>The UML class diagram in <A NAME="rf3"><A HREF="0207hf3.htm">Figure 3</A> shows all of the member variables and methods within the <i>EventAgent</i> class. The only publicly accessible methods of this class are <i>getInstance</i> (just described), <i>regSource</i>, <i>regListener</i>, <i>deRegSource</i>, and <i>deRegListener</i>. The event agent lets source and listener components register independent of one another, meaning a source can register before any listener components do, and vice versa. </p><h3>Registering a Source Component</h3><p>This implementation of the event agent allows only one source component for each event interface. If multiple source components were allowed per event interface, the choice as to which source component to notify when a listener registers would be ambiguous. Additionally, giving the listener the ability to choose its event source defeats the purpose of the event agent. If there is reason to listen to events from one source compared to the same events from a different source, then the events are truly unique and should be implemented as unique event interfaces.</p><p>A source component registers with the event agent by calling the <i>regSource</i> method (see <A NAME="rl2"><A HREF="#l2">Listing Two</A>), providing a reference to itself and the name of the event interface as a <i>String</i>. The following steps occur when <i>regSource</i> is called (see <A NAME="rf4"><A HREF="0207hf4.htm">Figure 4</A>).</p><p>1.	A check is made to ensure that the source component implements <i>SourceInterface</i> by using the Java <i>instanceof</i> keyword.</p><p>2.	A reference to the source component is stored in a <i>HashMap</i> with the key being the event interface name. A check is made to ensure that no other source has registered for the given event interface.</p><p>3.	A check is made to see if any listener components have already registered for this event set. If so, the source component is notified by calling <i>addListener</i> for each listener component. A <i>Vector </i>of objects is used to encapsulate each listener component and the event interface it has registered for. The event interface name for each listener is compared to that of the source component. For each matching listener: The source is notified by calling its <i>addListener</i> method and passing a reference to the listener; the listener is removed from the <i>Vector</i>. All other listener components remain in this <i>Vector</i> until a matching source component registers with the event agent, whereby this process is repeated.</p><h3>Registering a Listener Component</h3><p>It is completely acceptable, and likely, that your software will require multiple listener components interested in the same event interface. The event agent entirely supports this.</p><p>A listener component registers with the event agent by calling the <i>regListener</i> method (<A NAME="rl3"><A HREF="#l3">Listing Three</A>), providing a reference to itself and the name of the event interface as a <i>String</i>. The following steps occur when <i>regListener</i> is called (<A NAME="rf5"><A HREF="0207hf5.htm">Figure 5</A>):</p><p>1.	The <i>HashMap</i> of source components is checked for a source that implements the given event interface. If a matching source component is found, the source component is notified by calling its <i>addListener</i> method.</p><p>2.	If a matching source component is not found, this listener component is added to a <i>Vector</i> of listeners in anticipation that a source component will register at some future time. </p><h3>Source and Listener Deregistration</h3><p>Under some conditions, a source component may need to stop accepting listeners. Similarly, a listener component may no longer be able to wait for a matching source component. For these reasons, the event agent supports deregistration for both source and listener components.</p><p>A source or listener component can deregister itself by calling <i>deRegSource</i> or <i>deRegListener</i>, respectively. Both methods take the component's object reference and the name of the event interface as parameters. If the component is indeed on the source or listener list with the given event interface name, it will be removed from that list.</p><h3>Listener and Source  Component Collections</h3><p>The <i>HashMap</i> of source components and the <i>Vector</i> of listener components actually store references to objects of the class <i>EventComponent</i>. This class, embedded within the <i>EventAgent</i> class, simply wraps the source or listener component as an <i>Object</i>, and the <i>String</i> representing the event interface in question. <A NAME="rl4"><A HREF="#l4">Listing Four</A> implements this class.</p><h3>The Modified Stock Quote Example</h3><p>Using the stock quote example, the modifications needed to use the <i>EventAgent</i> are minor and actually quite helpful.</p><p>The event agent requires that all source components implement the interface named <i>SourceInterface</i>. This interface contains one method named <i>addListener()</i>. Since all source components need a similar method to allow clients to register, the requirement that this interface be implemented is not unreasonable. As a result, the event agent can call this method when a listener registers for any source component's event interface. </p><p>In regard to event listener components and event objects, there are no additional interface requirements. The final modification needed is for the source/listener components to register themselves with the event agent.</p><p>I suggest you add the interface name to the listener interface as a static <i>String</i>. Use this variable as the second parameter when calling <i>regSource()</i> or <i>regListener()</i>. This eliminates the potential for a typo that could otherwise result in a hard to find bug.</p><p><A NAME="rl5"><A HREF="#l5">Listing Five</A> shows the changes made to the <i>QuoteSource</i> component to use the event agent. Three minor changes have been made. The first is the addition of the <i>implements SourceInterface</i> clause to the class declaration. The second change is to get the <i>EventAgent</i> instance reference. The third change is the call to <i>EventAgent</i>'s <i>regSource</i> method.</p><p><A NAME="rl6"><A HREF="#l6">Listing Six</A> shows the changes made to the <i>QuoteListener</i> component to use the event agent. The obsolete code has been commented out. Again, a line is added to get the <i>EventAgent</i> instance reference. The final change is a call to the <i>EventAgent</i>'s <i>regListener</i>.</p><h3>Conclusion</h3><p>Reducing component coupling and dependencies within your code go a long way toward reducing bugs. In my experience, the event agent helps to accomplish this goal, with little additional code to make it work. In fact, programming events becomes more consistent through the use of the common <i>SourceInterface</i> and the unified method of event registration for both source and listener components.</p><p>The complete event agent source code (available electronically) contains logging to help track components and the events they are listening to. In larger software systems, this can be helpful in simplifying component relationships, as well as acting as a learning tool for new developers. </p><p>Overall, the event agent should help to simplify your event-handling code as well as further insulate components from implementation changes.</p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>public class QuoteSource {    protected Vector listeners;    public QuoteSource()     {    }    public void addListener(Object listenerObj)    {        listeners.add( listenerObj );    }    public void synchronized fire_quoteChange(double newQuote)    {        QuoteEvent qe = new QuoteEvent( this, newQuote );        // give each listener in the Vector         // this QuoteEvent object        Vector listenersCopy;        synchronized ( this )        {            listenersCopy = (Vector)listeners.clone();        }                int cnt = listenersCopy.size();        for (int i = 0; i &lt; cnt; i++)        {            QuoteChangedListener client =                 (QuoteChangedListener)listenersCopy.elementAt(i);            client.quoteChanged( qe );        }    }}public class QuoteListener implements QuoteChangedListener{    protected QuoteSource quoteSource;    public QuoteListener()     {        quoteSource = new QuoteSource();        quoteSource.addListener( this );    }    public void quoteChanged(QuoteEvent qe)        {        // do something with the new quote        ...    }}</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>public synchronized boolean regSource(Object sourceObj, String eventName){   // sourceObj must implement SourceInterface   if ( ! ( sourceObj instanceof SourceInterface ) )      return false;   // Add this source object to our HashMap once only    if ( sourceObjects.containsKey( eventName ) == true )      return false;   sourceObjects.put( eventName, sourceObj );   // Since listener and source objects can register at any time   // check if there are matching listener objects in the Vector   int i = 0;   int count = listenerObjects.size();   while ( i &lt; count )   {      EventComponent listener = (EventComponent)listenerObjects.elementAt(i);      // Check the listener's event interface name      if ( eventName.equals( listener.getEventName() ) )      {         notifySource( sourceObj, listener.getObject() );         // Remove the listener. All remaining elements will          // shift left so don't increment vector index i         listenerObjects.remove( i );         count--; // one less item in the list now      }      else      {         i++; // Check the next listener      }   }  return true;}</pre><P><A HREF="#rl2">Back to Article</A></P><H4><A NAME="l3">Listing Three</H4><pre>public synchronized boolean regListener(Object listenerObj, String eventName){   // Search for the Matching Source in the HashMap   EventComponent source = (EventComponent)sourceObjects.get( eventName );   if ( source != null )   {      notifySource( source.getObject(), listenerObj );   }   else   {      // Didn't find the matching Source. Add the listener to the      // list in anticipation that the source will register later      EventComponent listener = new EventComponent( listenerObj, eventName );      listenerObjects.addElement( listener );   }    return true;} </pre><P><A HREF="#rl3">Back to Article</A></P><H4><A NAME="l4">Listing Four</H4><pre>class EventComponent{    protected Object theObject = null;    protected String eventType = null;    public EventComponent(Object obj, String s)    {        theObject = obj;        eventType = s;    }    public Object getObject()    {        return theObject;    }    public String getEventType()    {        return eventType;    }}</pre><P><A HREF="#rl4">Back to Article</A></P><H4><A NAME="l5">Listing Five</H4><pre>public interface QuoteChangedListener extends java.util.EventListener {    public static final String eventName = "QuoteChangedListener";    // called when the stock quote changes    public void quoteChanged(QuoteEvent qe);}public class QuoteSource implements SourceInterface{    protected Vector listeners;    protected EventAgent eventAgent = EventAgent.getInstance();    public QuoteSource()     {        eventAgent.regSource( this, QuoteChangedListener.eventName);    }    public void addListener(Object listenerObj)    {        listeners.add( listenerObj );    }    public void fire_quoteChange(double newQuote)    {        ...    }}</pre><P><A HREF="#rl5">Back to Article</A></P><H4><A NAME="l6">Listing Six</H4><pre>public class QuoteListener implements QuoteChangedListener{    // NOTE: no longer need to know the source component    // OBSOLETE: protected QuoteSource quoteSource;    protected EventAgent eventAgent = EventAgent.getInstance();    public QuoteListener()     {        eventAgent.regListener( this, QuoteChangedListener.eventName );                // OBSOLETE: quoteSource = new QuoteSource();        // OBSOLETE: quoteSource.addListener( this );    }    public void quoteChanged(QuoteEvent qe)        {        ...    }}</pre><P><A HREF="#rl6">Back to Article</A></P></body></html>