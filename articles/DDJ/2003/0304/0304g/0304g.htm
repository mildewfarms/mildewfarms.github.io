<html><head><title>Apr03: Managing Devices with XML-RPC</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Managing Devices with XML-RPC</h1><p><i>Dr. Dobb's Journal</i> April 2003</p><h2>Treating devices  as web services</h2><h3>By Brett Porter</h3><I>Brett is chief architect, device management framework, for Art &amp; Logic Inc. He can be contacted at bgporter@acm.org.</I><hr><p>Developers routinely encounter a variety of interfaces and protocols when designing and building devices. For instance, manufacturers of embedded devices have historically provided simple command-line interfaces to monitor and control their products, while in the networking world, vendors often resort to SNMP interfaces. In other industries, you run into devices with protocols ranging from Sun's ONC-RPC or CORBA to Java RMI or custom homebrewed binary protocols.</p><p>More recently, designers of these systems have started integrating web-based management interfaces. In addition to being ideal for occasional users or consumer products, these systems employ a protocol that provides a remote API to devices, allowing the development of applications that are not bound by web browser limitations. The DMF Embedded Web Application Server (developed by Art &amp; Logic, the company I work for; http://www.artlogic.com/dmf/) is one such tool that lets you build traditional web-based device management interfaces and open up devices as web services.</p><DDJADVERTISEMENT INLINE><p>Some applications of web service-enabled devices are:</p><ul>  <li>Custom standalone applications to manage devices (like the monitor application I present in this article).   <li>Building one-to-many network management systems. A single application can manage a large number of devices, presenting the state of the network either via a standard desktop UI or creating a web interface to manage the attached devices.  <li>Device-to-device communications. Adding support for the client end of one of the web service protocols lets you develop networks of devices that monitor each other.  <li>Adapter interfaces. Legacy device management applications can be connected to new devices via adapter applications that support the legacy protocol on one side and XML-RPC on the other. Alternatively, legacy devices can be coupled with applications that translate between their protocol and XML-RPC.  <li>Building richer web interfaces (using Macromedia Flash) that run in browsers, both on the desktop and on handheld devices, scaling automatically to the available screen size.</ul><p>In this article, I present a monitor application (written in Python) that uses XML-RPC to monitor the state of a simulated device. The DMF Embedded Web Application Server implements the server-side functionality required for the client-side Python application and assumes that a device exists that implements the XML-RPC API discussed here. (The complete source code to the application is available electronically; see "Resource Center," page 5.) Some of the advantages for using XML-RPC or SOAP instead of CORBA, SNMP, RMI, or other legacy protocols are:</p><ul>  <li>Being HTTP-based, XML-RPC or SOAP move easily through firewalls.  <li>Being text-based and also using self-describing XML messages, the protocols ease the creation of systems that are more flexible than those built with messages defined at compile time.  <li>The web service protocols are language-agnostic; http://www.xmlrpc.com/ lists almost 70 client library implementations in languages ranging from C/C++, Python, Perl, Java, to Pike, REBOL, and Squeak. SOAP is currently supported by Microsoft's .NET languages, but many other languages have (or are adding) SOAP support.  <li>The relative simplicity of the protocols lowers the bar to building an application that uses them.  <li>Tools like my company's Device Management Framework (DMF) lets a single server support a traditional web interface as well as XML-RPC and SOAP via a single piece of back-end code that integrates with the actual device.</ul><p>While this article focuses on using XML-RPC to monitor and control devices, you could just as easily use SOAP (XML-RPC's sibling protocol). In fact, SOAP may be a preferable protocol in some cases, depending on tool support (for instance, if you plan on writing clients with one of the .NET languages or another tool that speaks SOAP natively). </p><h3>Parameter Space</h3><p>Central to the design of the monitor application I present here is the decision to view the state of the device as a tree of named parameters. Each of these parameters has a value and separate read/write access controls. While it's not required as part of the design, I usually model the parameter space as a hierarchical tree. One advantage of a hierarchical parameter space is that the DMF's XML-RPC implementation answers a request for a node in the tree by returning the values of all the parameters beneath that node, letting you condense several (or many) HTTP transactions with a single call/response cycle.</p><p>For example, you might design a device that has a node at the root of its parameter tree named "sys." Under that you could build a tree like the following: </p><blockquote><p>sys</p><p>    info</p><p>       sysName</p><p>       uptime</p><p>       description</p><p>       buildDate</p><p>    network</p><p>       interfaceCount</p><p>       ipAddress</p><p>       ipMask</p><p> ...and so on. </p></blockquote><p>Requesting the value of <i>sys.info</i> returns the values of the parameters <i>sys.info.sysName, sys.info.uptime, sys.info.description, </i>and <i>sys.info.buildDate</i> as a single XML-RPC structure. Parameters at the leaves of the tree may be indexable. For instance, there might be valid values for the parameters <i>sys.network.ipAddress[0] </i>through <i>sys.network.ipAddress[sys.network.interfaceCount-1].</i></p><h3>The XML-RPC API</h3><p>Since the entire state of the device is represented by a tree of named parameters, an API with get/set semantics is all that's needed to monitor and control the device. <A NAME="re1"><A HREF="0304ge1.htm">Example 1</A> is pseudocode for the two main functions in the XML-RPC interface.</p><p>When an error occurs in XML-RPC, the server notifies the client by sending a special Fault message to notify the client code of the problem. The Fault message contains a structure with two members: an application-defined fault code and a text description of the error.</p><p>The Python xmlrpclib module converts fault messages arriving from the server into an exception object that you can catch, keeping the main flow of the client app logic clean; see <A NAME="re2"><A HREF="0304ge2.htm">Example 2</A>.</p><h3>The Python <i>Device</i> Class</h3><p>I use two Python classes to abstract the remote device in the client. The main class, <i>Device</i>, provides three major API functions:</p><ul>  <li><i>value = Query(parameterName [, index]) </i>performs an XML-RPC call to the device and caches the returned value(s) in a <i>ValueTree</i> object. This cache gives you a mechanism to request a snapshot of some subsection of the parameter tree from the device, then you can pull out the individual parameters one at a time later.  <li><i>value = GetValue(parameterName [, index])</i> retrieves the requested parameter from the <i>ValueTree</i> cache; if the parameter is not found, it raises an exception. No XML-RPC calls are made to the device.  <li><i>SetValue(parameterName, value, [index]) </i>sends a new parameter value to the device using an XML-RPC call. If the<i> set() </i>operation succeeds, the new value is cached in the device's <i>ValueTree</i>, and calling <i>GetValue()</i> returns this new value (without performing another XML-RPC call).</ul><p>The <i>ValueTree</i> class stores data from the device in the same nested dictionary data structure used by the xmlrpclib. Doing this lets you swap in new subtrees in a single step. The main API functions exposed by the <i>ValueTree</i> class are <i>value = GetValue(parameterName [,index]) </i>and <i>SetValue(parameterName, value [, index])</i>, which retrieve or set the requested value in the <i>ValueTree</i>'s set of nested dictionaries. The <i>Device</i> class's <i>GetValue() </i>function just delegates to the implementation of <i>ValueTree'</i>s<i> GetValue() </i>function.</p><h3>The Pseudodevice</h3><p>For this client-side monitor demonstration, I've built a simulated device with a small (but interesting) parameter tree. The pseudodevice contains two subtrees that branch from the top level: <i>system.info</i> and <i>system.values</i>. The <i>system.info</i> branch contains parameters that provide information about the device itself:</p><p></p><ul>  <li><i>system.info.name</i>. A string of up to 80 characters giving the name of this device.   <li><i>system.info.description</i>. A string of up to 80 characters giving a description of the device.  <li><i>system.info.uptime</i>. The number of seconds since the device was started.</ul><p>The <i>system.values</i> branch of the parameter tree contains the actual data values reported by the device, as well as additional information about the data values. I've modeled this application after several real-world projects I've worked on&#151;monitoring satellite telemetry data, broadcasting equipment at FM radio stations, and the like. Each of the data value parameters also has an associated text label and separate <i>highAlarm</i> and <i>lowAlarm</i> alarm values. When the data value is either lower than its <i>lowAlarm</i> value or higher than its <i>highAlarm</i> alarm value, it is considered to be in an alarm state. Each of these parameters is indexable; calling <i>server.get("system.values.value")</i> returns the entire array in a single XML-RPC array, or you may also call <i>server.get("system.values.value", 0) </i>to retrieve just the first data value. The full list of parameters contained in the <i>system.values</i> subtree is:</p><ul>  <li><i>system.values.value</i>. An array of 16 integers representing current data values.  <li><i>system.values.highAlarm</i>. An array of 16 integers representing the high alarm point for each data value.  <li><i>system.values.lowAlarm</i>. An array of 16 integers representing the low alarm point for each data value.  <li><i>system.values.label</i>. An array of 16 text strings (each up to 32 characters long) with a descriptive label for each of the data values</ul><h3>The Monitor Application</h3><p>The monitor application uses the <i>Device</i> class to monitor the simulated pseudodevice. The simulator is written to initialize each of the 16 data values randomly between 1 and 100, then perform a simple random walk around each of those data values every time an update is requested. </p><p>The application interface was written using the Tkinter toolkit, standard with Python. The application should build and run cleanly on any platform supported by Python.</p><p>As <A NAME="rf1"><A HREF="0304gf1.htm">Figure 1</A> shows, each data value on the device is represented in the UI as a single row within a grid. Each row displays that value's associated label, lower/upper alarms, and current value. The label and alarm values are editable; moving the cursor out of a modified cell causes the app to transmit the new label or alarm value to the device. The current value is displayed as read-only. When the current value is lower than the lower alarm setting for that channel, it is displayed as yellow text on a blue background; if it is higher than the upper alarm, it is displayed as white text on a red background. Every second, the monitor application queries the device for the pertinent section of its parameter tree and updates the display accordingly.</p><h3>Potential Drawbacks of XML-RPC</h3><p>While I've shown here the relative ease with which you can build a standalone application to manage a device using XML-RPC, there are aspects of the protocol that you must consider before adopting it for real projects. </p><p></p><ul>  <li>No built-in security model or authentication. Other XML-RPC applications typically handle this problem by sending username/password in the clear on every call made to the server. The next major release of the DMF framework features a better authentication model, implemented by adding a few new functions to the API that perform a cryptographic hash on the authentication credentials as part of a login procedure. The output of that procedure is a unique ID that is then passed to the server with every call.  <li>Network administrators may not like its ability to pass through firewalls. Many applications for managing devices over XML-RPC will require that only users inside the firewall be allowed to access the device. Selecting an appropriate port number eliminates the problem.  <li>Call/response design makes asynchronous alerts difficult. Being built on top of HTTP, XML-RPC servers don't do anything until a client makes a request. We get around that limitation by polling, which has proven to be adequate in every situation that we've encountered to date. Common objections to polling include concerns about increasing network loads, increasing the load on the server, and alert latencies that may approach the polling frequency. While there are some situations where one or more of these concerns may prove valid enough to avoid using XML-RPC for device control (it's probably not an appropriate technology to use to monitor audio streams, for example), we have found that in the real-world applications that our customers have built, the load is light enough and the latency small enough to make this kind of monitor and control application more than sufficient.</ul><p><b>DDJ</b></p></body></html>