<html><head><title>Apr03: Letters</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Letters</h1><p><i>Dr. Dobb's Journal</i> April 2003</p><p><b>C++'s typename Keyword</b></p><p>Dear <i>DDJ</i>,</p><DDJADVERTISEMENT INLINE><p>I just read Al Stevens's comments about the keyword <i>typename </i>in his February 2003 <i>DDJ</i> column. It's a nice article, but I thought I could add a few comments of my own.</p><p>First, Al's statement, "It's the best I can do given the available literature" may be a bit misleading. In any case, it looks like Al's bookshelf is missing both C++ books I wrote. The first, <i>C++ Solutions</i> (Addison-Wesley, 1997), contains an exhaustive description of when and when not to use <i>typename</i> in C++ source. It does not explain <i>why</i> the keyword is needed, but it does point out cases where you might expect that <i>typename</i> would be okay, and yet it is not. </p><p>The second book is<i> C++ Templates: The Complete Guide </i>(Addison-Wesley, 2002), which I wrote with Nico Josuttis. The main discussion on the details of <i>typename</i> is found on page 130 and following. In that chapter, you'll also find a number of other related topics (for example, the use of <i>::template, .template, and -&gt;template</i>). A shorter discussion is also found on page 44 (part of the tutorial introduction to templates with which the book starts). Aside from this, I'll also mention that it's the best darn C++ book published in the past year ;-)</p><p>I do have a few other nits about your article.</p><p>You mention the use of <i>typename</i> to refer to member <i>typedefs</i>, but it also applies to member classes and member <i>enums,</i> of course. In the two latter cases, you can use an elaborated name instead. For example, to refer to an <i>enum</i> member <i>E</i> of <i>X&lt;T&gt;, </i>you can write <i>typename X&lt;T&gt;::E</i> or <i>enum X&lt;T&gt;::E. </i>You explain that <i>typename</i> isn't necessary if a compiler doesn't parse a template until instantiation time. That's true, but it might tempt readers into thinking that that is a valid way of implementing Standard C++. In fact, the Standard pretty much requires (implicitly) that templates be parsed in their generic form (see section 10.3 in<i> C++ Templates: The Complete Guide</i>; an explanation would, unfortunately, make this e-mail a bit too long). Currently, only the Edison Design Group's implementation gets this completely right (http://www.edg.com/; I work there ;-). However, historically, Hewlett-Packard's a C++ compiler was the first to parse templates in their generic form and as a result, it was (and still is, I believe) often unforgiving about missing <i>typename</i> keywords (I used to work on the a C++ compiler, too...). Again, our book says a little more about this history.</p><p>David ("Daveed") Vandevoorde</p><p>daveed@vandevoorde.com</p><p><b>More VB Versus the World</b></p><p>Dear <i>DDJ</i>,</p><p>In his January 2003 "Letter," Wayne Bloss tries to make out that Visual Basic is the only RAD tool on the market. It is a shame he has never tried Borland's C++ Builder, which can meet his dataset challenge without any code! Delphi provides identical capabilities, backed by Object Pascal; still a far better language than Basic. Tcl, Python, Java, Wx, Qt, and Gtk all have multiple RAD GUI builders with various levels of capability. To the huge markets built from VB, I offer a lemming.</p><p>Trevor Davel</p><p>twylite@crypt.co.za</p><p><b></p><p>RF Band Letter Designations</b></p><p>Dear <i>DDJ</i>,</p><p>To the best of my knowledge, the radio frequency "new band" designations listed in Ed Nisley's February 2003 "Embedded Space" column (page 72) have been abandoned, and not all that recently, either. It seems that the "old" designations just refused to go away, so whoever was trying to reinvent the wheel quietly gave up! <i>Reference Data for Engineers,</i> Eighth Edition (Sams Publishing, 1993) provides the following information, quoted from "IEEE Standard Letter Designations for Radar Frequency Bands," IEEE Std 521-1984, reaffirmed 1989.</p><blockquote><p>L 	1000-2000 MHz</p><p>S 	2000-4000 MHz</p><p>C 	4000-8000 MHz</p><p>X 	8000-1200 MHz</p><p>Ku	12-18 GHz</p><p>K 	18-27 GHz</p><p>Ka 	27-40 GHz</p><p>V 	40-75 GHz</p><p>W 	75-110 GHz</p></blockquote><p></p><blockquote><p>(1 GHz = 1000 MHz)</p></blockquote><p>Doug McGarrett</p><p>Doug_McGarrett@pittway.com</p><p><i>Ed responds:</i> Thanks for your note Doug. Although the "new" band letters must have seemed like a good idea at the time, they should serve as a cautionary tale for anyone who thinks changing human behavior is either simple or easy. Joeseph Carr's 1996<i> Secrets of RF Circuit Design,</i> Second Edition (McGraw-Hill/TAB Electronics, 1997; ISBN 0070116725), presents three tables: pre-1970 military (the "old" letters), post-1970 military (the "new" sequence), and the IEEE Standard, which, predictably, differs from both. Evidently there's a Standard for every occasion!</p><p></p><p><b>Happy with XSLT </b></p><p>Dear <i>DDJ</i>,</p><p>Thanks to Giuseppe Naccarato for his article "XSLT Querying and XML Documents" because it inspired me to jump into the world of XSLT and start working with a technology I'd heard about but never studied. Using XSLT for dynamic content generation as an alternative to SAX or DOM is tempting. </p><p>I also want to suggest an alternative approach to the dynamic assignment of a query in the XSL style sheet. Giuseppe's method requires a lot of I/O and on-the-fly file creation. However, you can use the <i>&lt;xsl:param&gt;</i> element to pass in a query parameter at execution time. For instance:</p><blockquote><p>&lt;xsl:param name="displaySet"/&gt;</p><p>&lt;xsl:template match="/"&gt;</p><p>  ...</p><p>   &lt;xsl:for-each select="//employee</p><p>           [contains(surname, $displaySet)]"&gt;</p><p>  ...</p><p>&lt;/xsl:template&gt;</p></blockquote><p>Then the calling code is:</p><blockquote><p>TransformerFactory factory = </p><p>           TransformerFactory.newInstance();</p><p>Transformer trans = </p><p>         factory.newTransformer(xslSource);</p><p>trans.setParameter("displaySet",</p><p>                            employeeSurname);</p><p>trans.transform(_xmlSource,result);</p></blockquote><p>With this approach, all file I/O is avoided. If the query parameter is set to null (or not set at all), then all <i>employees</i> are displayed. The query parameter can easily be applied at the command-line interface, too. The XSLT processor can even support external objects as parameters. I've been able to pass Java objects from one Java resource to another via the XSLT style sheet (at least with a little help from an extension class). Again, thanks for the inspiration.</p><p>Jim Hunter</p><p>hunterj@addr.com</p><p><b>DDJ</b></p><hr></body></html>