<html><head><title>Apr03: Algorithm Alley</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Cross-Correlation and Matched Filters</h1><p><i>Dr. Dobb's Journal</i> April 2003</p><h2>Solving the time-delay estimation problem</h2><h3>By Shehrzad Qureshi</h3><I>Shehrzad is a member of the Technical Staff for Picoliter Inc. He can be contacted at shehrzad_q@hotmail.com.</I><hr><p>Time-delay estimation of waveforms is of fundamental importance in a variety of signal-processing applications. The problem boils down to computing the location of a digitized "signature" waveform residing within a larger time-slice. In <A NAME="rf1"><A HREF="0304ef1.htm">Figure 1</A>, for instance, I'm searching for the location of the triangular pulse waveform within the larger signal. In a typical signal-processing application such as radar or sonar, an "echo pulse" is emitted from a transmitter, and a receiver device records the (digitized) response. The transmitted ping bounces off objects, resulting in something like <A NAME="rf1"><A HREF="0304ef1.htm">Figure 1</A>(b). After the time-delay estimation (TDE) is calculated, the distance of the object can be derived by a simple formula, assuming the velocity of the wave field is known <i>a priori</i>. </p><p>In the absence of noise, or in a relatively high signal-to-noise ratio (SNR) environment, this problem can easily be solved. Consider two simplistic approaches, one where the estimator searches for the maximum signal value in the digitized response, and another where the estimator thresholds the response, and uses the first location where the response rises above the threshold as the time-delay. While easy to implement, both methods suffer from significant amounts of "jitter" in the presence of noise. In this article, I describe a commonly employed signal-processing tool&#151;the matched filter&#151;which solves the TDE problem, even in the presence of significant amounts of line noise. The matched filter is implemented using a mathematical formulation known as "cross-correlation." </p><DDJADVERTISEMENT INLINE><p>As it turns out, Intel's Integrated Performance Primitives (IPP) includes just such a cross-correlation routine. IPP (http://www.developer.intel.com/software/ products/perflib/spl/index.htm) is a software API that provides a multitude of functions for multimedia, audio and video codecs, image processing, signal processing, speech compression, plus math support for lower-level routines like cross-correlation. In addition, IPP exposes a set of data types, data structures, and associated naming conventions so that these routines can be tailored for different types of input data (bytes, single-precision floating-point numbers, double-precision floating-point numbers, and so on). IPP runs on Intel processors such as the Pentium 4, Itanium architecture, Xeon, SA-1110, and PCA, and supports both Linux (32- and 64-bit) and Windows (32- and 64-bit). In this article, I use IPP and The Mathworks' Matlab programming environment (http://www.mathworks.com/) to illustrate how a matched filter, implemented using cross-correlation, can extract a signature waveform from a given signal&#151;even when the signature waveform is buried within background noise. The line noise described in this simulation may not always be of the ambient variety; you can imagine a military setting where an enemy combatant is intentionally jamming a radar or sonar system, and the matched filter's job is to search the signal space, throw away (or ignore) the jamming noise, and extract whatever the system is interested in.</p><p>In addition, if you effectively model the noise, then the matched filter can be augmented with some form of adaptive filtering, further enhancing its effectiveness. In certain situations, matched filters can also be used in image processing (for example, to perform image registration) or to implement certain machine-vision primitives.</p><h3>Noise and Estimation Jitter</h3><p>The 64-sample waveform in <A NAME="rf1"><A HREF="0304ef1.htm">Figure 1</A>(b) is an example echo response. <A NAME="rf2"><A HREF="0304ef2.htm">Figure 2</A> is a plot of three noisy echo responses, where I have added gaussian white noise (GWN) to the original, pristine echo response. The magnitude of the additive noise can be quantified by the standard deviation of the normal distribution added to the original signal; in this case I used standard deviations of 0.1, 0.2, and 0.3, respectively. I then computed time-delay estimations for 10 noisy input signals, for each example noise scenario, using both the max and threshold methods. <A NAME="rt1"><A HREF="0304et1.htm">Table 1</A> lists the simulation results.</p><p>As the level of noise increases, the uncertainty in the time-delay estimate increases. In particular, the thresholder performs terribly in the noisiest scenario. However, even the "max method" jitters around quite a bit in this scenario. Fortunately, there is another tool in our arsenal&#151;the matched filter.</p><h3>Cross-Correlation and Matched Filters</h3><p>In its simplest incarnation, matched filters are built directly on top of the cross-correlation. The cross-correlation of two signals is a measure of similarity between the two sequences. The cross-correlation function (<i>ccf</i>) is maximized when the two signals have similar frequency content and are in phase with one another. In the continuous domain, the cross-correlation of two input signals <i>x(t)</i> and <i>y(t)</i> is defined as in <A NAME="re1"><A HREF="0304ee1.htm">Example 1</A>(a).</p><p>Computers operate in the discrete domain, with finite sequences; hence, the cross-correlation of two digitized input sequences <i>x[n]</i> and <i>y[n]</i> is defined as in <A NAME="re1"><A HREF="0304ee1.htm">Example 1</A>(b). These equations may look ominous, but are actually simple to visualize. The <i>ccf</i> is essentially the same operation as convolution, sans the time reversal of <i>y(t)</i> (or <i>y[n]</i>). <A NAME="rf3"><A HREF="0304ef3.htm">Figure 3</A> is a graphical interpretation of cross-correlation. Performing the cross-correlation involves computing a series of shifted vector dot products, where the parameter <i>l</i> in <A NAME="re1"><A HREF="0304ee1.htm">Example 1</A>(b) is typically referred to as the "lag" parameter.</p><p>If the input sequences <i>y[n]</i> and <i>x[n]</i> correspond to a cross-correlation "kernel" such as that given in <A NAME="rf1"><A HREF="0304ef1.htm">Figure 1</A>(a), and an input sequence (any of the three in <A NAME="rf2"><A HREF="0304ef2.htm">Figure 2</A>, for example), then a matched filter is nothing more than maximizing the <i>ccf r</i><i><sub>x,y</i></sub><i>(l)</i>. That is, compute the <i>ccf</i> as given in <A NAME="re1"><A HREF="0304ee1.htm">Example 1</A>(b), find the maximum correlation value, and then the output of the matched filter is the lag that this maximum corresponds to. This lag is the time shift where the two signals are the most similar, thus providing a robust method for solving the TDE problem.</p><p>The increase in performance when using a matched filter to solve the TDE problem is profound. To illustrate its robustness in the presence of significant amounts of noise, I reran the TDE experiment, this time adding GWN with standard deviations of 0.1, 0.2, 0.3, and 0.4. <A NAME="rt2"><A HREF="0304et2.htm">Table 2</A> shows the results. The column marked "xcorr" is the TDE as computed using the matched filter; note the stability of its results. The constant delta between the max/threshold estimates (24 versus approximately 40) and the matched filter estimate is to be expected, and has to do with the fact that the matched filter approach utilizes the entire "signature" waveform for its calculations, rather than a single point or threshold. This delta is always present and is dependent on the support (length) of the cross-correlation kernel. The salient point is that the matched filter is able to determine the location of the signature waveform every single time, even in relatively noisy cases. <A NAME="rf4"><A HREF="0304ef4.htm">Figure 4</A> is a sample noisy waveform with GWN of standard deviation 0.4.</p><h3>Implementation Issues</h3><p>Not surprisingly, there are highly efficient algorithms for computing cross-correlations, in particular for input sequences of large length. Recall that cross-correlation is similar to convolution. <A NAME="re2"><A HREF="0304ee2.htm">Example 2</A> shows the relationship between cross-correlation and convolution, where the "*" symbol is the standard symbol denoting convolution.</p><p>Implementing convolution in software by extending the smaller input to be the same length as the larger input (by zero-padding), shifting <i>y(l)</i> for each lag, and then performing the vector dot product for each lag <i>l</i> is a brute-force and computationally prohibitive algorithm. Rather, DSP libraries and DSP hardware take advantage of one of the fundamental tenets of signal-processing theory&#151;the time-convolution theorem. This theorem states that convolution in the time domain is equivalent to multiplication in the frequency domain. If the inputs to the cross-correlation are lengths that are powers of two (for example, the length of the sequence <i>x[n]</i> is 2<i><sup>k</i></sup><sup>1</sup> samples and the length of the sequence <i>y[n]</i> is 2<i><sup>k</i></sup><sup>2</sup> samples), then the fast fourier transform (FFT) algorithm can be used to transform the sequences from the time domain to the frequency domain. After applying the FFT to <i>x[n]</i> and <i>y[n],</i> thereby yielding <i>X[f]</i> and <i>Y[f]</i>, you can multiply <i>X[f]</i> and <i>Y[f]</i> together, perform an inverse FFT, and the result is the cross-correlation. <A NAME="re3"><A HREF="0304ee3.htm">Example 3</A> is pseudocode for the fast cross-correlation algorithm.</p><p>The IPP Library includes cross-correlation routines for both signal-processing and image-processing. <A NAME="rl1"><A HREF="#l1">Listing One</A> is a function that utilizes the signal-processing API function to compute the cross-correlation of two sequences. <A NAME="rl2"><A HREF="#l2">Listing Two</A> is an example matched filter implementation, using the function in <A NAME="rl1"><A HREF="#l1">Listing One</A> and a couple of other functions contained in the signal-processing API. <A NAME="rl3"><A HREF="#l3">Listing Three</A> is a Matlab function that performs a cross-correlation of two sequences using Matlab's built-in convolution functionality. All of the Matlab source used to implement the simulation described here is available electronically; see "Resource Center," page 5. The Matlab Signal-Processing Toolkit (http://www.mathworks.com/) includes the function <i>xcorr(),</i> which can be used to perform cross-correlations.</p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>#include "ipp.h"bool xcorr(Ipp32f *x, int nx,   // x[n]           Ipp32f *y, int ny,   // y[n]           Ipp32f **r, int *nr, // rxy           int *startLag)      // 1st lag we compute {    // this function assumes that x &amp; y are of power-of-2 lengths!    // the lags we care about    int lagLo = -(nx-1),        lagHi = ny-1;    // # of elements in the output array    *nr = lagHi-lagLo+1;    // allocate output array (use Intel SP function for mem allocation)    *r = ippsMalloc_32f(*nr);    IppStatus st = ippsCrossCorr_32f(x, nx, y, ny, *r, *nr, lagLo);    *startLag = lagLo;    return (st==ippStsNoErr);}</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>int matched_filter(Ipp32f *x, int nx, // x[n]                   Ipp32f *y, int ny) // y[n]{    // matched filter, return value is the lag where    // the maximum cross-correlation by sequences x and y occurs.    // both of the following to be initialized by the function xcorr()    Ipp32f *crossCorrelation = 0;    int nxcorr = 0,        startLag = 0;    // perform the cross-correlation of x[n] &amp; y[n]    xcorr(x, nx, y, ny, &amp;crossCorrelation, &amp;nxcorr, &amp;startLag);   // | crossCorrelation |    ippsAbs_32f_I(crossCorrelation, nxcorr);    // max value of | crossCorrelation |    int maxLag = 0;    Ipp32f maxCrossCorr = 0.0;    ippsMaxIndx_32f(crossCorrelation, nxcorr, &amp;maxCrossCorr, &amp;maxLag);    return (maxLag+startLag);}</pre><P><A HREF="#rl2">Back to Article</A></P><H4><A NAME="l3">Listing Three</H4><pre>function [l, rxy] = cross_corr(x, y)%% CROSS_CORR   compute the cross-correlation of two sequences%    [lags, rxy] = CROSS_CORR(x,y) returns the cross-correlation%    of x[n] and y[n] in rxy.  The output l contains the%    lag indices.%% time-reverse x[n]x = fliplr(x);% construct lag indicesl = 1-length(x):length(y)-1;% use built-in Matlab function conv to perform cross-correlationrxy = conv(y, x);</pre><P><A HREF="#rl3">Back to Article</A></P></body></html>