<html><head><title>Apr03: C Programming</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Underdocumented C++</h1><p><i>Dr. Dobb's Journal</i> April 2003</p><h3>By Al Stevens</h3><I>Al is DDJ<i>'s</i> senior contributing editor. He can be contacted at astevens@ddj.com.</I><hr><p>In my February 2003 column, I wrote about the <i>typename</i> keyword, its behavior, and why it was added to Standard C++. The Standard C++ document contains a lot of information about how the language behaves, presumably to provide compiler implementers with sufficient detail to write a compliant compiler. The document does not often explain the rationale behind a feature, and the reasons for some of the new features are not immediately obvious to programmers. Standard C++ includes many language features that did not exist in compilers when the standardization process was begun. The committee used the process as an opportunity to fix legacy C++ so that it had all the features that the committee as a whole wanted. One of those features was the <i>typename</i> keyword. I had to learn more about it than I knew because I had to explain it in the next edition of my C++ tutorial book,<i> Teach Yourself C++</i>, Seventh Edition. Introductory and tutorial programming language books should not simply explain how a feature works&#151;they should explain why the feature exists and give examples that illustrate the behavior and the purpose.</p><p>I reported last time that the <i>typename</i> feature has not been explained in most of the current C++ books in my library and in the local bookstores. It has been mentioned by some, ignored by others, and explained by only a few, none of which are C++ tutorials. I was delighted to report that situation because I could get one up on the competition and plug my book all in one fell swoop. Shameless self-aggrandizing behavior, I know. I held my head low for about a microsecond. I did identify the few books available to me that mention <i>typename</i>. Some readers told me about a couple of other books that do a good job covering it, but rather than plug those books, I'd prefer to identify another Standard C++ feature that I haven't found explained in any book whatsoever. I am delighted to do so, because my book, now in the final stages of production and due in a bookstore near you soon, does indeed explain the feature. </p><DDJADVERTISEMENT INLINE><p>I call such features "underdocumented C++" with apologies to Andrew Schulman, whose "Undocumented..." and "Unauthorized..." series of books were popular several years ago. A feature with well-understood behavior but ill-defined motivation is, in my opinion, underdocumented. When you are trying to explain programming language behavior to a student, it really helps to know why the language behaves as it does. It helps the student, too.</p><p>(By the way, if you think a computer journalist should not use valuable column space to plug his own self-interests and those of his friends and family, you should refer to our heritage and legacy from the early days of computer journalism. Precedent and tradition exists. It is called the "Pournellian imperative.")</p><h3>Argument-Dependent Name Lookup</h3><p>The underdocumented feature of the month is called "argument-dependent name lookup," nicknamed "Koenig lookup" after Andrew Koenig, the committee member who invented it. I am saddened to report that neither of the recent excellent C++ books coauthored by Andrew even mentions the feature. Saddened? Yeah, right. Did I mention the name of my book? Oh, yeah, I did.</p><p>I searched the Web for a thorough explanation of the feature and found a link (http://www.gotw.ca/publications/ mill02.htm) to Herb Sutter's article in the March 1998 issue of the now-defunct<i> C++ Report,</i> which, to support the subject of Herb's article, explained Koenig lookup sufficiently that I could understand why it is necessary. From that and several other articles, I put together my own description of the feature to include in my book. The treatment here draws on that text and expands considerably upon it. The level of detail here is a bit deep for my book's targeted readership, entry-level C++ programmers.</p><h3>Ordinary Name Lookup</h3><p>Understanding Koenig lookup requires an understanding of ordinary name lookup. When the compiler encounters an unqualified identifier in your source code&#151;that is, an identifier with no prefix to specify where the identifier is declared&#151;the compiler launches a lookup for the name starting in the innermost scope. With function names, this lookup includes matching argument types to parameter types to accommodate overloaded function possibilities. The search continues through each successive outer scope until the compiler either finds a name match or hits the wall, which, in this case, is the global scope, at which time the compiler reports the undeclared identifier as a compile-time error.</p><p>The nested levels of scope include brace-surrounded statement blocks, function parameter lists, namespaces, class declarations, and the global scope. Some of these things can be within others of these things according to how the program is structured.</p><p>Given ordinary name lookup, a function declared in a namespace can be called without the namespace prefix only if the function call itself is within the namespace, perhaps nested several scope levels deep. Programmers don't usually think about compiler behavior when they write code. They think about how the code ought to work, and ordinary name lookup is intuitive. Koenig lookup, or rather its effects, are not. Consequently, it surprises programmers the first time they encounter it.</p><h3>Koenig Lookup</h3><p>You might discover Koenig lookup the first time you call a Standard Library function and find that, although you forgot to provide the <i>std:: </i>prefix, the compiler finds the correct function as shown here:</p><blockquote><p>std::vector&lt;int&gt; vint;</p><p>// ...    </p><p>sort(vint.begin(), vint.end());</p></blockquote><p>Even though the <i>sort</i> function is declared within the <i>std:: </i>namespace, you do not need to provide the namespace qualifier when you call it. The behavior is as if the function was in the global namespace. A search of the library headers finds no <i>sort</i> function in the global namespace. This is not the intuitive ordinary name lookup you have come to expect. Your first reaction is to report a bug to the compiler vendor.</p><p>The compiler vendor responds patiently, and if tech support is on the ball, you learn that a special circumstance exists wherein the namespace prefix is not required for a function identifier declared in a namespace. To whit: When a function is declared in a namespace and at least one of its parameters is also declared in the namespace, a call to the function does not need to qualify the function name with the namespace as long as it properly qualifies the argument that matches the parameter. Let's step away from the Standard Library functions and examine a generic example that illustrates Koenig lookup. Consider the program in <A NAME="rl1"><A HREF="#l1">Listing One</A>.</p><p>Even though the paycheck function in <A NAME="rl1"><A HREF="#l1">Listing One</A> is declared inside the <i>personnel</i> namespace, the <i>main</i> function, which is, of course, outside the <i>personnel</i> namespace can call the <i>paycheck</i> function without specifying the namespace&#151;as long as the argument to the function includes namespace information. The <i>empl</i> object is declared as being an object of type <i>personnel::employee</i>, which gives the compiler sufficient namespace information under the rules of Koenig lookup. However, suppose the <i>main</i> function looked like <A NAME="rl2"><A HREF="#l2">Listing Two</A>.</p><p>In <A NAME="rl2"><A HREF="#l2">Listing Two</A> the call to <i>paycheck</i> is invalid, because the argument, a null address, does not provide the compiler with any namespace information to use in selecting the function to call.</p><p>What is the purpose of Koenig lookup? Why is it necessary? What problem does it solve? Consider the following code:</p><blockquote><p>std::cout &lt;&lt; "hello";</p></blockquote><p>The line of code just shown is actually C++ shorthand for calling an overloaded operator function. In this case, the overloaded operator function is:</p><blockquote><p>std::operator&lt;&lt;(std::ostream&amp;, const char*). </p></blockquote><p>Without Koenig lookup, the compiler would not know which overloaded <i>operator&lt;&lt; </i>function to call, and there are many such overloaded functions. The Standard Library has its own and you might have them in your own classes, too. Consider the code in <A NAME="rl3"><A HREF="#l3">Listing Three</A>, which overloads the <i>operator&lt;&lt;</i> function for displaying objects of type <i>employee</i> on <i>std::ostream objects.</i></p><p>In <A NAME="rl3"><A HREF="#l3">Listing Three</A>, the <i>employee</i> class's overloaded operator function is in the <i>personnel </i>namespace. The two calls to overloaded <i>operator&lt;&lt;</i> functions in the <i>main</i> function call different functions in different namespaces, yet neither call explicitly tells the compiler which function to call. But both calls have arguments that reference objects of classes declared within those namespaces. Remember that the two statements are C++ shorthand for calling the overloaded operator functions. They could be coded like this as well:</p><blockquote><p>operator&lt;&lt;(std::cout, "Employee: ");</p><p>operator&lt;&lt;(std::cout, empl);</p></blockquote><p>When the compiler looks for a function to match the first call, it looks in the <i>std</i> namespace because the first argument is in the <i>std</i> namespace. The compiler finds a function there with a parameter list that matches the two argument types, <i>std::ostream</i> and <i>const char</i>*<i>.</i> When the compiler looks for a function to match the second call, it does not find one in the <i>std</i> namespace because the Standard Library does not define an overloaded <i>operator&lt;&lt;</i> function with those two types; the Standard Library does not know about the user-defined <i>employee</i> class, which is the type of the second argument to the function call. So the compiler uses the <i>personnel</i> namespace from that second argument and looks for a matching overloaded <i>operator&lt;&lt;</i> function there, which, of course it finds. The two statements shown above would be compiled this way after the compiler applies Koenig lookup:</p><blockquote><p>std::operator&lt;&lt;(std::cout, "Employee: ");</p><p>employee::operator&lt;&lt;(std::cout, empl);</p></blockquote><p>It would be reasonable to expect a programmer to provide the namespace qualification in all cases except for the shorthand notation that supports overloaded operators. Take another look at the two uses of overloaded <i>operator&lt;&lt; </i>in <A NAME="rl3"><A HREF="#l3">Listing Three</A>. Where would you put the namespace qualification? It would be unreasonable to expect programmers to write code like this:</p><blockquote><p>std::cout std::&lt;&lt; "Employee: ";</p><p>std::cout employee::&lt;&lt; empl;</p></blockquote><p>I did not participate in the standardization process, so I can only guess about what happened when the framers of the namespace feature bumped into the problem of overloaded operator functions declared within namespaces. No doubt there was some head-scratching, nail-biting, and hair-pulling among the committee members, after which Mr. Koenig came up with a rather clever solution, and Standard C++ now has Koenig lookup as one of its quiet features. Without Koenig lookup, everything you know about using <i>std::cout, </i> and overloading<i> operator&lt;&lt; </i>would not work. </p><p>A side effect is that sometimes functions declared in namespaces behave as if they are in the global namespace because you can call them without specifying their namespaces. This can confuse programmers who subconsciously expect ordinary name lookup and don't include Koenig lookup in their day-to-day thought processes. Which begs the question: Why didn't the committee opt to apply Koenig lookup only to calls to overloaded operator functions? I don't know the answer to that. Perhaps there is a good reason. There must be. Surely, I'm not the first programmer to wonder about that. This is one of those things that happen when programming languages mutate and evolve and are designed in a committee. New constructions build upon old ones, and sometimes things get in the way.</p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>namespace personnel {  class employee { };  void paycheck(employee* emp)  {    // ...  }}int main(){   personnel::employee empl;   paycheck(&amp;empl);   // ...   return 0;}</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>int main(){   paycheck(0);   // ...   return 0;}</pre><P><A HREF="#rl2">Back to Article</A></P><H4><A NAME="l3">Listing Three</H4><pre>namespace personnel {  class employee {    // ...  };  std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const employee&amp; em);}int main(){   personnel::employee empl;   // ...   std::cout &lt;&lt; "Employee: ";   std::cout &lt;&lt; empl;   return 0;}</pre><P><A HREF="#rl3">Back to Article</A></P></body></html>