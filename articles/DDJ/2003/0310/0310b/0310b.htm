<html><head><title>Oct03: C++ String Performance</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>C++ String Performance</h1><p><i>Dr. Dobb's Journal</i> October 2003</p><h2>Multithreaded apps make special demands</h2><h3>By Lev Kochubeevsky</h3><I>Lev is a principal engineer at Netscape/AOL and can be contacted at levk@netscape.com or lev@smartneighborhood.net.</I><hr><p>It's easy to imagine the reaction of seasoned C++ programmers upon seeing yet another string class implementation: "So why do we need another string class? We had too many in the pre-standard C++ Library world, and now that we finally have <i>std::string</i>, why not just use it?"</p><p>I agree, but only if the standard implementation doesn't introduce significant performance problems. In this article, I show how the standard string implementation isn't always good enough, particularly for multithreaded applications that create lots of temporary strings. That said, it is worth noting that there's no such thing as a standard string implementation&#151;they all differ. (For examples of the different implementations, see item 15 in Scott Meyers's <i>Effective STL: 50 Specific Ways to Improve Your Use of the Standard Template Library</i>, Addison-Wesley, 2001.) Here, I analyze one of the more popular string implementations&#151;the one that comes with g++ 2.96 on Red Hat Linux 7.x. To this end, I create a number of multithreaded tests showing the Standard C++ string implementation (which comes with g++ 2.96 on Red Hat Linux 7.3) can have real performance problems for multithreaded applications that need to create lots of unrelated temporary string objects. To address these performance problems, I present a string class that gives you the speed and efficiency of automatic C strings, plus the convenience of C++ string objects that are STL friendly.</p><DDJADVERTISEMENT INLINE><h3><i>std::string</i> Class Design</h3><p>All string implementations&#151;including g++ 2.96&#151;usually share the same design principles: </p><p></p><ul>  <li>Memory for the string value is always allocated on the heap. (Okay, Scott Meyers describes one implementation that doesn't allocate memory for the very short strings.) Think about it. You have a string object on the stack, but there is always a heap allocation for the value of the string unless it is initialized through a copy constructor and it's reference counted (which generates other problems).  <li>String values are reference counted; so if you assign string <i>s1</i> to <i>s2, </i>their internal pointers point to the same location in memory. It's apparently done to make copy constructors and assignment operators very fast. They don't need to allocate memory and copy the value, just set the pointer and increment a reference counter. The same logic makes a destructor very fast. In most cases, it just decrements the reference counter.  <li>Closely related to reference counting is copy-on-write (COW) optimization that allocates/copies when one of the string objects pointing to the same value changes.</ul><p>The first item is usually a bad idea when you have lots of temporary strings as automatic variables in a multithreaded application. The heap is shared between threads, so some locking is inevitable; otherwise, the heap's internal data is corrupted. This approach defeats the idea of the fast non-blocking creation/access of the stack variables in multithreaded applications (every thread has its own nonshared stack). It looks deceptive to programmers, too. For instance, in <A NAME="re1"><A HREF="0310be1.htm">Example 1</A>, <i>mystring</i> is an automatic (stack) variable with no indication that memory for "Some C value" is allocated on the heap (unfortunately, that is exactly what happens).</p><p>Likewise, the second and third items may sound good until you realize they're a bad fit for multithreaded applications. Value and reference counters are shared between multiple string variables and potentially between multiple threads that absolutely require access serialization (locking) to the reference counter. Atomic increment/decrement/check can be used if these operations are supported by the CPU's command set; see "Optimizations that Aren't (In a Multithreaded World)," by Herb Sutter, <i>C/C++ Users Journal</i>, June 1999.</p><p><A NAME="rl1"><A HREF="#l1">Listing One</A> (teststring1.cpp) creates 100,000 temporary <i>std::string</i> objects on the stack (most of the memory is allocated on the heap). It has only one thread running, but was built as a multithreaded application, so it does all the required locking (refer to the Makefile, available electronically; see "Resource Center," page 5). I ran this and subsequent tests on a 2-GHz Dell desktop with 1 GB of RAM under Red Hat Linux 7.3. <A NAME="re2"><A HREF="0310be2.htm">Example 2</A>(a) shows the results.</p><p><A NAME="rl2"><A HREF="#l2">Listing Two</A> (teststring2.cpp) is the same test, but with 10 threads running&#151;each creating/destroying 100,000 automatic string objects. (Again, every one of them allocates memory on the heap and employs some locking and copying.) <A NAME="re2"><A HREF="0310be2.htm">Example 2</A>(b) presents the less-than-encouraging results of the teststring2.cpp test. With just 10 threads, average automatic string object handling (creation/destruction) increased approximately 100 times (10000/108). Since these results seem unacceptable for high-load multithreaded applications, I decided to find out where time is being spent, then create a new string class that doesn't have those deficiencies. Possible performance culprits include locking introduced by the reference counting optimization, heap allocations (and it's locking) and copying of the value.</p><h3>A New String Class</h3><p>In creating a new string class, I wanted to be able to:</p><p></p><ul>  <li>Avoid heap allocation and copying completely; just to set an internal pointer to some C string.  <li>Avoid heap allocation for the nonheap variables; just copy the value to the buffer inside the object.  <li>Force heap allocation and copying for any string object (as with a <i>std::string </i>implementation, minus reference counting/COW).</ul><p>Since it supported the last two of these three requirements, I used <i>SString</i> (see <i>Thinking In C++</i>, by Bruce Eckel; Prentice-Hall, 1995, ISBN 0-13-917709-4) as the basis for my new string class. I then implemented the fastest and most important mode, which doesn't do any allocation or copying. It also occurred to me that the string class features should be selectable by programmers who instantiate the string objects, not the string implementation. Consequently, it's up to users of this class (see <A NAME="rl3"><A HREF="#l3">Listing Three</A>) to instantiate particular string objects in particular modes. The complete implementation of this new <i>CGenStringT&lt;&gt;</i> class (again, Eckel's <i>SString</i> was used as a basis) is in util.h (also available electronically). </p><p>The mode of the string being created in <A NAME="rl3"><A HREF="#l3">Listing Three</A> is set by the combination of two parameters: template parameter <i>bufsize,</i> and constructor parameter <i>bAlloc. CGenStringT</i> is a template with one template parameter, <i>bufsize</i>, that governs the size of the internal buffer. In addition to specifying the size of the internal buffer, this parameter defines the mode of the string in conjunction with a <i>bAlloc</i> constructor's parameter. The possible combinations are:</p><ul>  <li>Mode 1: <i>bufsize == </i>0 &amp;&amp;<i> bAlloc </i>== 0. No heap allocation, no copying, just setting the pointer (fastest).  <li>Mode 2: <i>bufsize &gt; </i>0. No heap allocation, copying into the internal buffer (slower).  <li>Mode 3: <i>bufsize == </i>0 &amp;&amp;<i> bAlloc == </i>1. Heap allocation and copying (slowest).</ul><p>Once you understand the idea, the implementation is straightforward: Constructor, copy constructor, assignment operator, and destructor are doing the right thing for the three different modes (like allocation, copying, deleting), or none of them. For example, the copy constructor in <A NAME="rl4"><A HREF="#l4">Listing Four</A> is a good example of handling all three modes (only ASCII null-terminated strings are currently supported). Right after the <i>CGenStringT</i> class definition there's a bunch of useful <i>typedef</i>s and a <i>define</i>:</p><blockquote><p>typedef CGenStringT&lt;0&gt; CGenString;</p><p>typedef CGenStringT&lt;100&gt; CStackString100;</p><p>#define FAST_STRING(id,str) CGenString 				         id(str,0);</p></blockquote><p><i>CGenString</i> is a Mode 3 string (allocation and copying), <i>CStackString100</i> is a Mode 2 string (copying) with an internal buffer of 100 bytes, and FAST_STRING defines a Mode 1 string variable ID (no <i>alloc</i>, no copying) and sets its value to <i>str</i>.</p><p>The "stack" word is being used in comments throughout the <i>CGenStringT</i> implementation and in <i>CStackString100</i> to denounce Mode 2 strings (with an internal buffer). In general, this term is incorrect, because the internal buffer is on the stack only when the string variable itself is a stack variable. If this variable is created on the heap (using <i>new()</i>), then the buffer is on the heap as well. So, in general, the buffer as a part of the string object is always allocated in the same class of memory as the string object that owns it.</p><h3>Performance Testing</h3><p>To gauge performance, I start by testing the slowest mode (forced heap allocation and copying) to see if the removal of reference counting helps. Teststring3.cpp (available electronically) tests one thread, while teststring4.cpp (also available electronically) tests 10 threads. They are the same, respectively, as teststring1.cpp and teststring2.cpp, except that <i>std::string</i> is replaced with <i>CGenString</i>.</p><p><A NAME="re3"><A HREF="0310be3.htm">Example 3</A>(a) shows the result of running teststring3, and <A NAME="re3"><A HREF="0310be3.htm">Example 3</A>(b) the results for teststring4. Compared to <i>std::string</i>, this isn't bad at all for the slowest version&#151;it's 45 percent faster with one thread (59 versus 108) and it's more or less 100(!) times faster with 10 threads running (~100 versus ~10000). And since the heap is still being hit, it looks like <i>std::string</i> reference counting hurts big time!</p><p>Moving to the faster Mode 2 strings (using automatic string variables so a buffer for every string is on the stack: no heap allocations, just copying), teststring5.cpp and teststring6.cpp (both available electronically) are the same tests as before&#151;but using <i>CStackString100</i>.</p><p><A NAME="re4"><A HREF="0310be4.htm">Example 4</A>(a) shows the results of running teststring5, while <A NAME="re4"><A HREF="0310be4.htm">Example 4</A>(b) shows the results of running teststring6. By eliminating the need to allocate on the heap, you get significantly faster performance: for one thread, 23 versus 59 (Mode 3) versus 108 (<i>std::string</i>), and for 10 threads, ~40 versus 100 (Mode 3) versus 10,000 (<i>std::string</i>). </p><p>Teststring7.cpp and teststring8.cpp, both available electronically, test the fastest mode (Mode 1: no heap allocation or copying, just setting a pointer). <A NAME="re5"><A HREF="0310be5.htm">Example 5</A>(a) is the result for teststring7, and 5(b) for teststring8. As expected, it's blazingly fast. <A NAME="rt1"><A HREF="0310bt1.htm">Table 1</A> summarizes the performance test results.</p><p>Mode 1 (fastest) is 35 times faster than <i>std::string</i> in a one-thread application and 2500(!) times faster for the application with just 10 threads. A no-frills Mode 3 string with heap allocation and copying is still 100 times faster than <i>std::string</i> for a 10-thread application thanks to the absence of the reference counting/COW optimization.</p><h3>Real-World Example</h3><p>In the real world, many C++ applications get their input from C network protocols or database drivers. In the case of strings, one popular use is as keys in the STL map. <A NAME="rl5"><A HREF="#l5">Listing Five</A> does exactly that&#151;it accepts parameters as C strings, converts them to C++ strings, and uses them as keys for the STL map. Now take a closer look at the function calls <i>ci=m_mymap.find(str);</i> and <i>m_mymap.erase (str);</i>.</p><p><A NAME="rl5"><A HREF="#l5">Listing Five</A> looks benign until you realize that every time you do a lookup or erase, you create a temporary string object (with heap allocation and value copying). This temporary string object is created through the <i>std::string(char</i>*<i>)</i> constructor. This object's lifespan is just the duration of the <i>map::find/erase call:</i> It's destroyed right before return (with another heap hit, of course). It sounds expensive&#151;and it is. So what can you do? The first solution may be to use pointers to the strings instead of the strings themselves. It would solve a creation-of-objects problem, but burdens you with memory management and comparison issues (remember a map is a balanced tree that always keeps its contents sorted).</p><p>The preferred solution would be to have all the beauty of using C++ string objects as keys, but with the C speed of conversion between C strings and C++ strings for the temporary strings. That's where my new Mode 1 (FAST_STRING) shines. To achieve the speed of temporary C strings and still be able to use C++ strings for the lookup, take a look at <A NAME="rl6"><A HREF="#l6">Listing Six</A> and testmap.cpp (available electronically). Mode 3 (value allocated on the heap) is used only when the new element is added. For the lookup and erase, the fastest Mode 1 strings are used (just setting the pointer). </p><p>There is no allocation and no copying, which means that you have a real automatic (stack) string variable with all the performance of C strings and all power/convenience of the STL map. The constructor and destructor are extremely simple for the fastest (Mode 1) strings&#151;jsut setting a pointer in the constructor, and no-op in the destructor.</p><h3>Possible Improvements</h3><p>One area of improvement would be adding support for multibyte characters. A good way to do this would be to follow STL string design (where string is <i>typedef</i>ed to <i>basic_string &lt;char&gt;</i>) and add another template parameter for the actual character type.</p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>#include &lt;pthread.h&gt;#include "util.h"unsigned int createStrings ( int n ){ static char *samples[]={"something1","something2","something3","something4"}; printf ("Thread &lt;%d&gt;: Creating/destroying %d strings...\n",pthread_self(),n); unsigned int start = utilGetTickCount (); for ( int i=0; i&lt;n; i++ ) {    string s ( samples[i%4] ); } unsigned int end = utilGetTickCount (); printf ( "Thread &lt;%d&gt;: total time=%d millisecs, average=%f\n",           pthread_self(), end-start, (float)(end-start)/n ); return ( end - start );}int main ( int argc, char **argv ){  if ( argc &gt; 2 )  {    printf ( "teststring1 &lt;n_of_strings_to_create&gt; \n" );    return 0;  }  int n = 100000;  if ( argc &gt; 1 )    n = atoi ( argv[1] );  createStrings ( n );  exit(0);}</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>#include &lt;pthread.h&gt;#include "util.h"void *createStrings ( void *n_void ){ int n = (int) n_void; static char *samples[]={"something1","something2","something3","something4"}; printf ("Thread &lt;%d&gt;: Creating/destroying %d strings...\n",pthread_self(),n); unsigned int start = utilGetTickCount (); for ( int i=0; i&lt;n; i++ ) {    string s ( samples[i%4] ); } unsigned int end = utilGetTickCount (); printf ( "Thread &lt;%d&gt;: total time=%d millisecs, average=%f\n",            pthread_self(), end-start, (float)(end-start)/n ); return NULL;}int main ( int argc, char **argv ){  if ( argc &gt; 3 )  {    printf (        "teststring1 [&lt;n_of_strings_to_create&gt;] [&lt;n_threads&gt;]\n" );    return 0;  }  int n = 100000;  int n_thr = 10;  if ( argc &gt; 1 )    n = atoi ( argv[1] );  if ( argc &gt; 2 )    n_thr = atoi ( argv[2] );  pthread_attr_t attr;  pthread_attr_init ( &amp;attr );  pthread_t *tid = new pthread_t[n_thr];  int i;  // create threads  for  ( i=0; i&lt;n_thr; i++ )  {    if ( pthread_create ( &amp;tid[i], NULL, createStrings, (void *) n ) )    {      printf ( "ERROR: ptread_create for thread &lt;%d&gt;\n", i );      exit(-1);    }  }  // wait for all threads to terminate  for  ( i=0; i&lt;n_thr; i++ )    pthread_join ( tid[i], 0 );  exit(0);}</pre><P><A HREF="#rl2">Back to Article</A></P><H4><A NAME="l3">Listing Three</H4><pre>template&lt;int bufsize&gt;class CGenStringT{public:  CGenStringT ( const char *S = "", int bAlloc = 1 ) : m_s(m_buf)  {    if ( !bufsize ) ...private:  char *m_s;   int   m_bAlloc;  char  m_buf[bufsize+1];};</pre><P><A HREF="#rl3">Back to Article</A></P><H4><A NAME="l4">Listing Four</H4><pre> ...  CGenStringT ( const CGenStringT&amp; rv ): m_s(m_buf)  {    if ( !bufsize )    {      if ( m_bAlloc = rv.m_bAlloc )      {        // make on heap        m_s = new char [ strlen(rv.m_s)+1 ];        strcpy ( m_s, rv.m_s );      }      else        // just set a pointer        m_s = rv.m_s;    }    else    {      // make on stack      m_buf[bufsize] = 0;      strncpy ( m_s, rv.m_s, bufsize );    }#ifdef MEM_ALLOC_DEBUG    printf ("CGenString copy constructor called: this=%x allocation=%s"            " ptr=%x\n", this, (!bufsize &amp;&amp; m_bAlloc ) ? "yes":"no", m_s );#endif  } ...</pre><P><A HREF="#rl4">Back to Article</A></P><H4><A NAME="l5">Listing Five</H4><pre>class CMyMap{private:  map &lt; string, int &gt; m_mymap;public:  void add ( const char *str, int i )  {    m_mymap[str] = i;  }  void remove ( const char *str )  {    m_mymap.erase ( str );  }  bool find ( const char *str, int *res )  {    map &lt; string, int &gt;::const_iterator ci;    ci = m_mymap.find(str);    bool found = ( ci != m_mymap.end() );    if ( found )       *res = ci-&gt;second;    return found;  }};</pre><P><A HREF="#rl5">Back to Article</A></P><H4><A NAME="l6">Listing Six</H4><pre>class CMyMap{private:  map &lt; CGenString, int &gt; m_mymap;  typedef map &lt; CGenString, int &gt; GenStringIntMap;public:  void add ( const char *str, int i )  {    m_mymap[str] = i;  }  void remove ( const char *str )  {    FAST_STRING(s,str);    m_mymap.erase ( s );  }  bool find ( const char *str, int *res )  {    map &lt; CGenString, int &gt;::const_iterator ci;    FAST_STRING(s,str);    ci = m_mymap.find(s);    bool found = ( ci != m_mymap.end() );    if ( found )      *res = ci-&gt;second;    return found;  }};</pre><P><A HREF="#rl6">Back to Article</A></P></body></html>