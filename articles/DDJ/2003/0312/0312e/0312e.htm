<html><head><title>Dec03: Programmer's Toolchest</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Web Services  &amp;  C++</h1><p><i>Dr. Dobb's Journal</i> December 2003</p><h2>Developing  SOAP services  and clients in C++ </h2><h3>By Peter Lacey</h3><I>Peter is an engineer at Systinet. He can be contacted at lacey@systinet.com.</I><hr><p>While there's no shortage of information on how to implement web services using Java, C#, or even Perl, there's little information on how to bring web services to the C++ world&#151;despite the millions of lines of C/C++ code currently in production. In this article, I close this gap by showing how to develop SOAP services and clients in C++ using the WASP Server for C++ from Systinet (the company I work for). </p><p>Although a license is required for deployment on multiCPU hardware, WASP is available for a variety of operating systems and compilers as a free download from Systinet (http://www.systinet.com/). All you need is an operating system and C++ compiler for which WASP binaries are available, and a 1.3 or higher JVM.</p><DDJADVERTISEMENT INLINE><h3>Defining Web Services</h3><p>In SOAP, a "service" loosely corresponds to a C++ "class," and an "operation" to a "method." For instance, a sample service called "Planet" contains a simple operation, <i>getPlanet().</i> The service's endpoint (that is, URL) is /<i>PlanetService</i>/. The <i>getPlanet()</i> operation takes a single argument&#151;an integer between 1 and 9&#151;and returns the name of the planet that corresponds to that position in order from the Sun. It returns a SOAP fault if the input parameter is out of bounds.</p><p>There are two principal components to a web service&#151;the service itself and the Web Services Description Language (WSDL) document that describes it. It is helpful to have the WSDL document in hand when developing services, since you can use the WASP wsdlc utility to autogenerate the client stub code and service skeleton code. However, since WSDL documents can be complicated, it would be nice not to have to create the WSDL manually. </p><p>To autogenerate WSDL documents, you have to have a source file that contains enough information to represent a service, and in a format that is simpler than WSDL itself. While WASP for C++ does not have a means of generating a WSDL from a C++ source or object file, you can generate a WSDL from a Java class file. The utility for doing so is Java2WSDL, included in the WASP for C++ Companion Toolkit.</p><p>The first thing to do is create a simple Java interface for the service; see <A NAME="rl1"><A HREF="#l1">Listing One</A>. Save this source as Planet.java and compile it. The compilation directive <i>$ javac Planet.java</i> generates a Java class file from which the WSDL document can be created. To create the WSDL, run Java2WSDL; see <A NAME="re1"><A HREF="0312ee1.htm">Example 1</A>. (<A NAME="rt1"><A HREF="0312et1.htm">Table 1</A> describes what each flag does.) By default, Java2WSDL creates the file Definitions.wsdl. For consistency, you should rename this file to Planet.wsdl (<i>$ Definitions.wsdl Planet.wsdl</i>).</p><h3>Generating Source Code</h3><p>The WSDL document can now be used to generate the bulk of the client and service source code. wsdlc is the WASP utility used to compile a WSDL document into C++ source. </p><p>In <i>wsdlc Planet.wsdl Planet</i>, the second argument to <i>wsdlc</i> is a project name, and the wsdlc utility uses this string when naming the source files it creates. The output of this command is a series of C++ source files that help in developing both the client and service. Altogether, the wsdlc utility generates six files: a source and header file for the client stubs, another pair for the service skeletons, and a third pair that represents shared data structures. In this case, the resulting files are the client stubs Planet.cpp and Planet.h, the service skeletons PlanetImpl.cpp and PlanetImpl.h, and the shared structures PlanetStructs.cpp and PlanetStructs.h.</p><h3>Creating the Service</h3><p>To create the service, you first declare the service in a distinct header file (<A NAME="rl2"><A HREF="#l2">Listing Two</A>). This class declaration should be derived from the <i>PlanetImpl</i> skeleton class created by wsdlc and defined in PlanetImpl.h. The <i>WASP_VString</i> type is a WASP class for representing a string in C++. Save this prototype as "PlanetService.h." </p><p><A NAME="rl3"><A HREF="#l3">Listing Three</A> is the service itself. The code checks the input parameter, which WASP has already serialized from XML to a C++ <i>int</i> type. If the parameter is less than 1 or greater than 9, the code throws an ordinary C++ exception. WASP catches this exception, serializes it into a SOAP fault, and returns it to the client for handling. </p><p>The <i>WASP_VString</i> class is a wrapper around a simple <i>char </i>*, primarily offered to allow translation from ASCII to the Unicode encoding used in SOAP, and to speed up serialization. It should be used for all string data types passed between SOAP clients and servers.</p><h3>Implementing the Server</h3><p>It only remains to take this service and integrate it with the WASP runtime libraries. Unlike SOAP servers available for more dynamic languages (such as Java), C++ does not allow dynamic deployment of object files to a distinct server process. Therefore, it is necessary to link the service with the WASP server code to create SOAP-enabled executables. It stands to reason that the server code needs to be made aware of the service. Thus, the last bit of server-side source code registers the service with WASP, starts up the WASP environment, and waits forever.</p><p><A NAME="rl4"><A HREF="#l4">Listing Four</A> is the server code. After including the requisite headers, the code first registers the service with WASP. When expanded, the WASP_FACTORY_DEFINE macro declares a factory function that returns a new instance of the <i>PlanetService</i> class. In the <i>main()</i> body, it creates an array of these function pointers with the help of a few more macros. Under the covers each array element holds a struct containing the name of the service and a pointer to the factory function that instantiates it. In this case, there is just one service, but as more services are created in the future, they can be simply added to this list.</p><p>With this infrastructure in place, the code initializes WASP, registers the service factories with the WASP super factory, and starts accepting requests. When implementing this code, remember to wrap the SOAP engine up with some exception handling. Also remember to terminate the WASP server politely with the <i>serverTerminate() </i>call. Save the server code as SOAPServer.cpp and compile and link everything together: <i>$ g++ -o SOAPServer SOAPServer.cpp PlanetService.cpp PlanetImpl.cpp PlanetStructs.cpp -I/usr/local/ waspc/include/usr/local/waspc/lib/libwasp.so</i>.</p><h3>Configuring the Server</h3><p>While it is tempting to start the new server at this point, there are a couple of loose threads to resolve. For instance, the server does not know that the Planet.wsdl document is related to the PlanetService service; nor does it know what URL should cause the PlanetService service to be instantiated. Fortunately, the answers to these questions do not require any further coding, but can be set up in a simple XML configuration file like <A NAME="rl5"><A HREF="#l5">Listing Five</A>.</p><p>The configuration file first contains some initial (boilerplate) namespace declarations and server configuration elements. These are followed by the elements that control the service endpoint. Of the components in the <i>&lt;serviceEndpoint&gt;</i> attribute list, the interesting ones are the <i>wsdl</i> and <i>url</i> attributes. The <i>wsdl</i> attribute describes the path to the service's WSDL document relative to the start-up directory of the server, and <i>url</i> specifies the URL of the service relative to the root of the HTTP server.</p><p>The use of the <i>&lt;cppa:instance&gt; </i>tag names this endpoint so that it can later be associated with a service instance as known to the server&#151;that is, the object code. This is done with the <i>&lt;serviceInstance&gt;</i> element. The name attribute of the <i>&lt;serviceInstance&gt;</i> element refers back to the <i>ref</i> attribute of the <i>serviceEndpoint/instance</i> element, and the class attribute to the name of the class as specified in the WASP_FACTORY_DEFINE macro of the server. Save this file as config.xml (as dictated by the<i> WASP_Runtime::serverStart() </i>function).</p><p>With all the components in place, the server can be started:<i> $ ./SOAPServer </i>&amp;.</p><h3>Creating the Client</h3><p><A NAME="rl6"><A HREF="#l6">Listing Six</A>, the client code (in which some error handling has been omitted for clarity), begins with a number of boilerplate <i>#include</i>s, the last of which is one of the client header files output by the wsdlc utility. The call to <i>clientInitialize()</i> is a mandatory call that, obviously, initializes and configures the client environment, and should be called before any SOAP-oriented code is executed. It differs from the <i>clientStart() </i>function a few lines further down in that the former performs core functions like initializing threads and factories, while the latter initializes the transport layer, serialization mechanism, and such&#151;all of which you can manipulate. <i>clientStart()</i> requires the name of a configuration file; the default of conf/client.xml, found in the $WASPC_HOME/share/waspc directory, is sufficient.</p><p>With the setup out of the way, the code initializes the parameter to be sent to the <i>getPlanet()</i> service and its return value. The input parameter is taken from the command line. The actual call to the service consists of:</p><blockquote><p>Planet PlanetService;</p><p>RetPlanet = PlanetService.getPlanet(pos);</p></blockquote><p>The WSDL compiler has created a stub class for every <i>&lt;port&gt; </i>mentioned in the <i>&lt;service&gt;</i> element of the WSDL document. And this class contains methods for every <i>&lt;operation&gt;</i> mentioned in the<i> &lt;binding&gt;</i> element of the WSDL<i>.</i> The code instantiates an instance of this class, which is effectively a local proxy of the remote service, then calls the operation (method). And here is the beauty of web services&#151; the ability to call a service written in an unknown language, hosted on a foreign computer, as if it were local to your own machine.</p><p>The returned string is copied to a new variable by the <i>transcode()</i> method before being used. The <i>transcode()</i> method converts UTF encoding to ASCII. Other transcoders are also available, for instance to convert UTF into wide (<i>wchar_t </i>*) characters. It is important to note that <i>transcode() </i>allocates a new buffer for the copy, so it is incumbent on you to release it.</p><p>Finally, there is the exception handling code. A <i>WASP_StubFaultException</i> signals that the service is communicating back a SOAP fault, showing nicely how SOAP faults get serialized into C++ exceptions. The second catch of the <i>WASP_Exception</i> catches all other errors, such as not being able to find the server. </p><p>Save the client code as client.cpp, and compile/link it (<i>g++ -o client client.cpp Planet.cpp PlanetStructs.cpp -I/usr/local/waspc/include /usr/local/waspc/lib/libwasp.so</i>). Running the client produces the output in <A NAME="rf1"><A HREF="0312ef1.htm">Figure 1</A>.</p><h3>Conclusion</h3><p>The ability to SOAP-enable new or existing C++ applications has important implications both inside and outside the enterprise. It lets you extend existing services to internal users and partners without having to generate and distribute a number of difficult and incompatible APIs. The ease with which this can be done, and the shallow learning curve of doing so, makes adopting web services much smoother than learning and implementing a complete C# or Java environment. </p><p></p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>interface Planet {  String getPlanet(int pos);}</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>#include "PlanetImpl.h"class PlanetService : public PlanetImpl {  public:    virtual WASP_VString getPlanet(int pos);};</pre><P><A HREF="#rl2">Back to Article</A></P><H4><A NAME="l3">Listing Three</H4><pre>#include "PlanetService.h"WASP_VString PlanetService::getPlanet(int pos) {  if ( (pos &lt; 1) || (pos &gt; 9) ) {    throw new WASP_Exception("Index out of range. Must be 1 through 9.");  }  char * planets[] = {"Mercury", "Venus", "Earth", "Mars", "Jupiter",                      "Saturn", "Uranus", "Neptune", "Pluto"};  WASP_VString planet = planets[pos-1];  return planet;}</pre><P><A HREF="#rl3">Back to Article</A></P><H4><A NAME="l4">Listing Four</H4><pre>#include &lt;iostream&gt;#include &lt;waspc/common.h&gt;#include &lt;waspc/runtime/Runtime.h&gt;#include &lt;waspc/runtime/SuperFactory.h&gt;#include "PlanetService.h"using std::cout;using std::cerr;using std::endl;WASP_FACTORY_DEFINE (PlanetService);int main (int, char **) {    WASP_FactoryDefinition serviceFactory[]={        WASP_FACTORY_ENTRY (PlanetService),        WASP_FACTORY_END ()    };    WASP_Runtime::serverInitialize ();    WASP_SuperFactory::registerFactory (serviceFactory);    try {        cout &lt;&lt; "Starting WASP SOAP Server." &lt;&lt; endl;        WASP_Runtime::serverStart ("config.xml",NULL);    } catch (WASP_Exception *exc) {        char *trace=GET_TRACE (exc);        cerr &lt;&lt; "Exception during startup: " &lt;&lt; exc-&gt;getCharMessage() &lt;&lt; endl;        cerr &lt;&lt; "Stack trace follows: " &lt;&lt; endl &lt;&lt; trace &lt;&lt; endl;        delete[] trace;        delete exc;    };    WASP_Runtime::serverTerminate ();    cout &lt;&lt; "WASP Server shutdown" &lt;&lt; endl;    return 0;}</pre><P><A HREF="#rl4">Back to Article</A></P><H4><A NAME="l5">Listing Five</H4><pre>&lt;?xml version="1.0"?&gt;&lt;waspc-config    xmlns:wasp="urn:WaspServer"    xmlns:cppa="urn:CppAdaptor"    xmlns:sep="urn:ServiceEndpoint"    xmlns:svci="urn:ServiceInstanceRepository"&gt;    &lt;wasp:import ref="conf/server.xml"/&gt;    &lt;!-- Service binding --&gt;    &lt;sep:serviceEndpoint        sep:dispatcherRef="DefaultDispatcher"        sep:adaptorRef="DefaultCppAdaptor"        sep:wsdl="Planet.wsdl"        sep:url="/PlanetService/"&gt;        &lt;cppa:instance cppa:ref="planetsref"/&gt;    &lt;/sep:serviceEndpoint&gt;    &lt;!-- Service instances - implementation classes --&gt;    &lt;svci:serviceInstance         svci:class="PlanetService"         svci:name="planetsref"/&gt;&lt;/waspc-config&gt;</pre><P><A HREF="#rl5">Back to Article</A></P><H4><A NAME="l6">Listing Six</H4><pre>#include &lt;iostream&gt;#include &lt;waspc/common.h&gt;#include &lt;waspc/runtime/Runtime.h&gt;#include &lt;waspc/client/StubFaultException.h&gt;#include "Planet.h"using std::cout;using std::endl;int main (int argc,char *argv[]) {  WASP_Runtime::clientInitialize ();  try {    WASP_Runtime::clientStart("conf/client.xml", NULL);    int pos = atoi(argv[1]);    WASP_VString RetPlanet = "";    char *PlanetStr;    Planet PlanetService;    RetPlanet = PlanetService.getPlanet(pos);    PlanetStr = RetPlanet.transcode();    cout &lt;&lt; "Planet number " &lt;&lt; pos &lt;&lt; " is " &lt;&lt; PlanetStr &lt;&lt; endl;    delete PlanetStr;  }  catch (WASP_StubFaultException *exc) {    WASP_XMLProtocolFault *fault = exc-&gt;getFault();    if (fault) {       WASP_VString msg;       msg &lt;&lt; "Fault Received\n";       msg &lt;&lt; "  Fault String: " &lt;&lt; fault-&gt;getFaultString() &lt;&lt; "\n";       char *transcodedMsg = msg.transcode();       cout &lt;&lt; transcodedMsg;       delete transcodedMsg;    }    delete exc;  } catch (WASP_Exception *exc) {    char *trace=GET_TRACE (exc);    cout &lt;&lt; "Exception during call: " &lt;&lt; exc-&gt;getCharMessage() &lt;&lt; endl;    cout &lt;&lt; "Stack trace follows: " &lt;&lt; endl &lt;&lt; trace &lt;&lt; endl;    delete[] trace;    delete exc;  }  WASP_Runtime::clientTerminate();  return 0;}</pre><P><A HREF="#rl6">Back to Article</A></P></body></html>