<html><head><title>Dec03: Full-Text Searching & the Burrows-Wheeler Transform</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Full-Text Searching &amp; the Burrows-Wheeler Transform</h1><p><i>Dr. Dobb's Journal</i> December 2003</p><h2>Finding any character sequence in source text&#151;and fast!</h2><h3>By Kendall Willets</h3><I>Kendall is a software engineer living in San Francisco and can be contacted at kendall@willets.org.</I><hr><p>When it comes to full-text indexing, we usually think of methods such as inverted indices that break text on word boundaries, consequently requiring search terms to be whole words only. Yet all of us probably have had the experience of searching for not-quite-words&#151;C++, VM/CMS, SQL*Plus, 127.0.0.1, &lt;blink&gt;, and the like&#151;that were skipped by an inverted index, or broken into less-distinctive pieces. The same goes when you are working with data such as DNA sequences, where you need to quickly find any sequence of symbols.</p><p>In this article, I examine an indexing method that lets you find any character sequence in the source text&#151;in time only proportional to the sequence length&#151;using a structure that can compress the entire source text and index into less space than the text alone. This technique is exceptionally fast at detecting and counting occurrences of any string in the source text. The fact that you can build a string match incrementally&#151;adding one character at a time and seeing the result at each step&#151;gives you the flexibility to explore variable patterns such as regular expressions with maximum effectiveness.</p><DDJADVERTISEMENT INLINE><p>In "Fast String Searching with Suffix Trees" (<i>DDJ</i>, August 1996), Mark Nelson addressed full-text indexing using suffix trees; while in "Data Compression with the Burrows-Wheeler Transform" (<i>DDJ</i>, September 1996), he focused on the use of the Burrows-Wheeler Transform (BWT) for compression. While the BWT is commonly known as a data-compression technique, researchers have found that block-sorted data has a structure that lends itself naturally to search, while using space close to its minimal compressed size. This was first demonstrated in the FM index (see "Opportunistic Data Structures with Applications," by Paolo Ferragina and Giovanni Manzini, <i>Proceedings of the 41st IEEE Symposium on Foundations of Computer Science,</i> 2000; http://www.mfn.unipmn.it/~manzini/fmindex/). In short, the same transformation that yields high-compression ratios, by grouping similar substrings together, also lets you find arbitrary substrings with little overhead.</p><h3>Block Sorting Reviewed</h3><p>When block sorting, you construct a list of <i>n</i> blocks consisting of the source text <i>S</i> (usually followed by a special End-of-String character <i>$</i>) of length <i>n,</i> cyclically shifted from zero to <i>n</i>-1 positions. When you sort the blocks, you get a matrix <i>M</i>; see <A NAME="rf1"><A HREF="0312df1.htm">Figure 1</A>(a). The first column of <i>M</i> is called <i>F,</i> and the last,<i> L. F</i> has a simple structure, containing all the characters of <i>S</i> in sorted order, with duplicates. Column <i>L</i> has a more complex structure that contains enough information to reconstruct the original string, and usually forms the basis for BWT compression.</p><p>In its naive form, <i>M</i> contains <i>n</i><sup>2</sup> characters, but a simple trick represents each block by its first character and a link to the block starting one character to the right; <A NAME="rf2"><A HREF="0312df2.htm">Figures 1</A>(b) and <A NAME="rf3"><A HREF="0312df3.htm">1(c)</A>. To decode a block, you read its first character, follow its link to the next block, read its character and link, and repeat the process until the desired number of characters have been read. This character-and-link representation slashes spatial complexity from <i>O</i>(<i>n</i><sup>2</sup>) to <i>O</i>(<i>n</i>). </p><p>The links act as a permutation on <i>M,</i> which I call <i>FL</i> because it permutes the orderly <i>F</i> column to the higher entropy <i>L</i> column. <i>FL</i> is the permutation caused by shifting <i>M</i> one column to the left and resorting it; each row <i>i</i> moves to a new position <i>FL[i]</i>.</p><p>Since the <i>F</i> column is a sorted list of characters, the next space saver is to change from explicitly storing the <i>F</i> column, to simply recording the starting position for each character's range in <i>F</i>, using an array that I call "<i>C</i>"; <A NAME="rf3"><A HREF="0312df3.htm">Figure 1</A>(c). At a given position<i> i </i>in <i>M</i>, you look through <i>C</i> to find the section <i>c</i> of <i>F</i> that contains <i>i</i>. The <i>F() </i>method in bwtindex.cc (available electronically; see "Resource Center," page 5) applies this idea. Also see <A NAME="rf4"><A HREF="0312df4.htm">Figure 1(d)</A>.</p><p>By storing only <i>FL</i> and <i>C,</i> you have a reasonable&#151;but not minimal&#151;representation of <i>M</i>, and you can decode successive characters of the source from left to right. The <i>decode</i> method in bwtindex.cc shows how to carry out this iteration. See <A NAME="rf5"><A HREF="0312df5.htm">Figure 1(e)</A>.</p><h3>Useful Properties of the Permutation</h3><p><A NAME="rf6"><A HREF="0312df6.htm">Figure 2</A> shows how <i>FL</i> is order preserving on blocks that start with the same character. That is, given two blocks <i>i</i> and <i>j</i> that both start with <i>c</i>, lexical comparison implies that if <i>i&lt;j, </i>then <i>FL[i]&lt;FL[j].</i> This is one of the core elements of the BWT.</p><p>This order-preserving property means that <i>FL</i> consists of sections of integers in ascending order, one section for each character. You can search one of these sections for a target value quickly, using binary search. </p><h3>Pattern Matching</h3><p>If you pick an arbitrary pattern string <i>P,</i> say "<i>abr,</i>" one way to find all occurrences of it is to search the sorted blocks in <i>M</i>, finding the range of blocks that start with <i>a</i>, then narrowing it to blocks prefixed by "<i>ab,</i>" and so on, extending the pattern from left to right. This method is workable, but a more efficient algorithm (first developed by Ferragina and Manzini) works in the opposite direction, extending and matching the pattern one character to the left at each turn.</p><p>To understand this method inductively, first consider how to match one character <i>c,</i> then how to extend a single character beyond a pattern that has already been matched. The answer to the first problem is easy, since you know blocks in the range <i>C[c]...C[c+</i>1<i>]-</i>1<i> </i>start with <i>c.</i> I call this range "<i>R</i><i><sub>c</i></sub>."</p><p>To left-extend a pattern match, consider the string <i>cP</i> formed by prepending a character <i>c</i> onto the already matched string <i>P</i>. Use <i>FL</i>, starting from the range of locations prefixed by <i>P</i>, mapping <i>FL</i> inversely to find the interval of blocks prefixed by <i>cP,</i> as follows.</p><p>Given the next character <i>c</i> and the range <i>R</i><i><sub>P</i></sub> of blocks prefixed by <i>P</i>, you need to find the range <i>R</i><i><sub>cP</i></sub> of blocks prefixed by <i>cP</i>. You know two things about <i>R</i><i><sub>cP</i></sub>:</p><ul>  <li>It must fall within the range <i>R</i><i><sub>c</i></sub> of blocks starting with <i>c</i>, that is, <i>R</i><i><sub>cP</i></sub> is a subrange of <i>R</i><i><sub>c</i></sub>.   <li><i>FL</i> must map all blocks in <i>R</i><i><sub>cP</i></sub> into blocks in <i>R</i><i><sub>P</i></sub>, because every block starting with <i>cP</i> must left-shift to a block that starts with <i>P.</i></ul><p>My approach is to start with the widest possible range <i>R</i><i><sub>c</i></sub>, and narrow it down to those entries that <i>FL</i> maps into <i>R</i><i><sub>P</i></sub>. Because of the sorting, you know that entries prefixed by <i>cP</i> form a contiguous range. Since <i>FL</i> is order-preserving on <i>R</i><i><sub>c</i></sub>, you can find <i>R</i><i><sub>cP</i></sub> as follows:</p><ul>  <li>Scan <i>R</i><i><sub>c</i></sub> from the start until you find the lowest position <i>i</i> that <i>FL</i> maps into <i>R</i><i><sub>P</i></sub>.  <li>Scan backwards from the end to find the highest position <i>j</i> that <i>FL</i> maps into <i>R</i><i><sub>P</i></sub> (in practice, you use binary search, but the idea is the same).</ul><p>The resulting [<i>i,j</i>] range is <i>R</i><i><sub>cP</i></sub>, the range of blocks prefixed by <i>cP</i>. <A NAME="rf7"><A HREF="0312df7.htm">Figures 3(a)</A>, <A NAME="rf8"><A HREF="0312df8.htm">3(b)</A>, <A NAME="rf9"><A HREF="0312df9.htm">3(c)</A> and <A NAME="rf10"><A HREF="0312df10.htm">3(d)</A> show this narrowing-down process; the <i>refine</i> method implements this algorithm in bwtindex.cc.</p><p>The result at each step in this process is a start/end position for a range of blocks prefixed by the pattern matched so far. The difference between these positions is the number of matches in the text, and starting from any position in this range, you can decode characters in and following each match.</p><h3>The Location Problem</h3><p>There is one valuable piece of information you haven't found: The exact offset of each match within the original text. I can call this the "location problem," because there is virtually no information in a sorted block to tell you how far you are from the start or end of the text, unless you decode and count all the characters in between.</p><p>There are a number of solutions to the location problem that I won't address here except to say that all of them require extra information beyond <i>FL</i> and <i>C,</i> or any BWT representation. The simple but bulky solution is just to save the offset of each block in an array of <i>n</i> integers, reducing the problem to a simple lookup, but adding immensely to the space requirement. The problem is how to get the equivalent information into less space.</p><p>Some approaches rely on marking an explicit offset milepost at only a few chosen blocks, so you quickly encounter a milepost while decoding forward from any block. Others use the text itself as a key, to index locations by unique substrings. Another possibility lets you jump ahead many characters at a time from certain blocks, so as to reach the end of the text more quickly while counting forward. The variety of possible solutions makes it impossible to cover them here.</p><h3>A Word About Compression</h3><p>Recall that I promised a full-text index that consumes only a few bits per character, but so far you've only seen a structure taking at least one <i>int</i> per character&#151;hardly an improvement. However, the integers in <i>FL</i> have a distribution that makes them highly compressible. You already know <i>FL</i> contains long sections of integers in ascending order. Another useful fact is that consecutive entries often differ by only one; in normal text, as many as 70 percent of these differences are one, with the distribution falling off rapidly with magnitude. My own experiments using simple differential and gamma coding have</p><p>shrunk <i>FL</i> to fewer than 4 bits per character, and more sophisticated methods  (see "Second Step Algorithms in the Burrows-Wheeler Compression Algorithm," by Sebastian Deorowicz; <i>Software: Practice and Experience,</i> Volume 32, Issue 2, 2002), have shrunk <i>FL</i> to even more competitive levels.</p><p>The practical problem with compression is that elements of <i>FL</i> then vary in size, so finding an element <i>FL</i>[<i>i</i>] requires scanning from the beginning of the packed array. To eliminate most of the scanning, you need to use a separate bucket structure, which records the value and position of the first element of each bucket. To find <i>FL</i>[<i>i</i>], you scan forward from the beginning of the closest bucket preceding <i>i,</i> adding the encoded differences from that point until position <i>i</i> is reached. The process is laborious, but does not affect the higher level search and decoding algorithms.</p><p><b>DDJ</b></p></body></html>