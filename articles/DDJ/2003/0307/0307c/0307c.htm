<html><head><title>Jul03: Using  Thread-Local Variables in Java</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Using  Thread-Local Variables in Java</h1><p><i>Dr. Dobb's Journal</i> July 2003</p><h2>Boosting  performance with thread-local variables</h2><h3>By Tom White</h3><I>Tom is lead Java developer at Kizoom, which provides travel information to mobile devices. He can be contacted at tomwhite@zoo.co.uk.</I><hr><p>Version 1.2 of the Java 2 SDK, Standard Edition introduced a class called "<i>ThreadLocal</i>" for concurrent programming. In this article, I examine how you can use thread-local variables to improve the performance of frequently used utility classes with instances that must be shared between multiple threads. Scenarios such as these are common on application servers that have many long-running execution threads.</p><p>There are two common approaches to making nonthreadsafe code safe for concurrent use&#151;synchronization and segregated instances. Using synchronization means a single instance of the unsafe class may be used, but sacrifices "liveness" because only one thread can use the object at any one time. Segregated instances work by creating a new object for each client, which wastes more resources but does not sacrifice liveness. You choose which approach is better depending on the requirements of your application&#151;do you want to sacrifice resources or liveness for thread safety? The thread-local approach offers a third way by creating an object per thread, so different threads cannot interfere with each other's objects. This approach maintains liveness, but not at the expense of resources because only so many instances of threads are created.</p><DDJADVERTISEMENT INLINE><h3>A Threadsafe Date Parser</h3><p>To illustrate, consider a <i>DateParser</i> interface that parses a <i>String</i> representation of a date into a <i>java.util.Date</i> object, as in <A NAME="rl1"><A HREF="#l1">Listing One</A>. The contract of this interface requires that multiple threads can safely share a single instance of the <i>DateParser</i>. Granted, a real date parser would support many formats but, for simplicity, our example understands only one. </p><p>A naive implementation of the <i>DateParser</i> interface uses a single instance of <i>java.text.SimpleDateFormat</i> to do its parsing; see <i>UnsynchronizedDateParser</i> in <A NAME="rl2"><A HREF="#l2">Listing Two</A>. Although it is not mentioned in the Javadoc for <i>SimpleDateFormat</i>, multiple threads may not safely call <i>SimpleDateFormat</i>'s <i>parse</i> method. Therefore, <i>UnsynchronizedDateParser </i>does not satisfy the <i>DateParser</i> interface contract because, under some circumstances, <i>SimpleDateFormat </i>(and therefore, <i>UnsynchronizedDateParser)</i> will throw an <i>ParseException</i> or an unchecked <i>numberFormatException </i>when two threads call the <i>parse</i> method at the same time.</p><p>The most common way to fix the broken <i>UnsynchronizedDateParser </i>is via synchronization. If you make the <i>parse</i> method synchronized (see <i>SynchronizedDateParser</i> in <A NAME="rl3"><A HREF="#l3">Listing Three</A>), then the implementation satisfies the contract because only one thread at a time calls the unsafe <i>parse</i> method on the underlying <i>SimpleDateFormat.</i> Another simple fix is to create a fresh instance of <i>SimpleDateFormat</i> each time the <i>parse</i> method of <i>DateParser</i> is called (as in <i>NewInstanceDateParser</i> in <A NAME="rl4"><A HREF="#l4">Listing Four</A>). </p><p><A NAME="rf1"><A HREF="0307cf1.htm">Figure 1</A>, a performance comparison of the two simple approaches to thread safety generated by an application called "PerformanceTester" (available electronically; see "Resource Center," page 5), reveals that using synchronization is considerably better. PerformanceTester exercises each <i>DateParser</i> implementation with several runs, each differing in the number of threads that access the <i>DateParser</i> instance simultaneously. For each run, the number of dates parsed was the same, so you can compare the effect of contention between threads. <i>ControlDateParser</i> is a no-op implementation of <i>DateParser</i> with a <i>parse</i> method that returns null. It is included to gauge the precision of the other results.</p><p><A NAME="rf1"><A HREF="0307cf1.htm">Figure 1</A> also includes a <i>DateParser</i> implementation that uses <i>ThreadLocal.</i> It performs better than the two simple approaches, particularly as the number of threads increases.</p><h3>Implementing a  Date Parser with <i>ThreadLocal</i></h3><p>The <i>ThreadLocal</i> class was designed to make it simple for you to use thread-local variables in your programs. The work of creating a new variable for each new thread is taken care of, as are other issues that are surprisingly tricky to get right, such as the task of ensuring that thread-local variables are eligible for garbage collection when the thread terminates. All you have to do is initialize (and possibly update) the values of your thread-local variables. To do this, you subclass <i>ThreadLocal</i> and provide an implementation of the <i>initialValue</i> method, which is used to set the initial value of the thread-local variable for each thread. The value is accessed and updated using the <i>get</i> and <i>set</i> methods of <i>ThreadLocal.</i> Multiple threads access a single instance of the specialized <i>ThreadLocal</i> class, which manages the values for each thread and ensures that different threads see different values.</p><p>For the date-parser example, each thread should hold a separate instance of <i>SimpleDateFormat.</i> This is the approach taken by <i>ThreadLocalDateParser</i> in <A NAME="rl5"><A HREF="#l5">Listing Five</A>. When the <i>parse</i> method of <i>ThreadLocalDateParser</i> is called, it calls the <i>get</i> method of the specialized <i>ThreadLocal</i> class (DATE_PARSER_THREAD_LOCAL). If the current thread has not called <i>parse</i> before, then calling <i>get</i> on the <i>ThreadLocal</i> object causes it to initialize itself by calling the overridden <i>initialValue</i> method. In this case, a new <i>SimpleDateFormat</i> is created&#151;and immediately returned by the <i>get</i> method. Subsequent calls to <i>parse</i> in the same thread will see the same <i>SimpleDateFormat</i> instance. However, a different thread will see a different <i>SimpleDateFormat</i> instance. The <i>ThreadLocal</i> mechanism ensures each thread has its own independent copy of a <i>SimpleDateFormat</i> variable; therefore, the implementation of <i>ThreadLocalDateParser</i> is safe and satisfies the interface contract.</p><p>One way to understand <i>ThreadLocal</i> is to imagine that it contains a hash table mapping threads to values. When <i>ThreadLocal'</i>s <i>get</i> method is called, it uses the current thread (retrieved using <i>Thread.currentThread()</i>) as the key to look up the value to return. If there is no such key in the hash table, then <i>initialValue</i> is called to populate the value. Not all implementations necessarily use this strategy for the <i>ThreadLocal</i> class; however, it is a useful model for conceptualizing <i>ThreadLocal.</i> <A NAME="rf2"><A HREF="0307cf2.htm">Figure 2</A> is the class diagram of this conceptual model.</p><p>Although there are as many thread-local variables as there are threads in an application, there should typically only be a single instance of the <i>ThreadLocal</i> subclass. This is because the <i>ThreadLocal</i> instance is a container for thread-local variables. In <i>ThreadLocalDateParser</i> (<A NAME="rl5"><A HREF="#l5">Listing Five</A>), the anonymous <i>ThreadLocal</i> subclass is a private static field, which ensures there is only a single instance for the lifetime of the application.</p><p>On the other hand, if multiple instances of <i>ThreadLocal</i> are created for the same thread-local variables, then the benefits of using <i>ThreadLocal</i> are diluted as more variables are created than are needed. Worse, there is a memory leak in older implementations of <i>ThreadLocal</i> whereby the <i>ThreadLocal</i> instance does not become eligible for garbage collection until all threads using it terminate&#151;even if the program has no references to the <i>ThreadLocal</i> instance. Fortunately, there is no chance of experiencing memory leaks if you stick to creating a single <i>ThreadLocal</i> instance for each collection of thread-local variables. Put another way, <i>ThreadLocal</i> objects should be private static fields in the class that uses them.</p><h3><i>ThreadLocal</i> Performance </h3><p>Even though the general contract of the class did not change, Sun's implementations of <i>java.lang.ThreadLocal</i> changed radically between the release of 1.2 and 1.3, and provided a substantial increase in performance. There were further efficiency gains in the 1.4 release. To measure these improvements, I benchmarked the performance of <i>SynchronizedDateParser, NewInstanceDateParser,</i> and <i>ThreadLocalDateParser</i> for Versions 1.4.1_02, 1.3.1_07, and 1.2.2_014 (<A NAME="rf1"><A HREF="0307cf1.htm">Figures 1</A>, <A NAME="rf3"><A HREF="0307cf3.htm">3</A>, and <A NAME="rf4"><A HREF="0307cf4.htm">4</A>, respectively) of Sun's JVMs. The timings shown are mean values averaged over five test runs.</p><p>The first conclusion to draw from all the results is that creating a new object each time the <i>parse</i> method is called, as <i>NewInstanceDateParser</i> does, is very expensive. While the cost of creating new object instances has come down substantially for each major JVM release (for the example being discussed, 1.4 is almost twice as fast as 1.2), it is still significantly less efficient than using synchronization or <i>ThreadLocal</i>. There is also an extra cost, not measured here, in terms of memory usage and garbage collection for the many objects created.<i></p><p>ThreadLocalDateParser</i> and <i>SynchronizedDateParser</i> show similar levels of performance across all JVMs and numbers of threads. However, two features stand out.</p><ul>  <li>Synchronization is marginally more efficient than the <i>ThreadLocal</i> implementation on the 1.2 JVM.   <li><i>ThreadLocalDateParser</i> scales to larger numbers of threads more effectively than <i>SynchronizedDateParser</i> for 1.3 and 1.4 JVMs&#151;the curve is much flatter. </ul><p>In fact, over the range of the test (from 1 to 64 threads), the performance of both <i>NewInstanceDateParser</i> and <i>SynchronizedDateParser</i> for 1.3 and 1.4 JVMs falls by a factor of about two; whereas for <i>ThreadLocalDateParser,</i> the factor is about 1.25. So, while synchronization is good, the <i>ThreadLocal</i> approach is even better, especially for large numbers of threads.</p><h3>Conclusion</h3><p>It can be difficult to write efficient code that is safe for multithreaded access. Java's <i>ThreadLocal</i> class provides a powerful, easy-to-use solution, while avoiding the drawbacks of other approaches. Plus, <i>ThreadLocal</i> implementations are more efficient, particularly in later JVMs. If you are trying to improve the performance of frequently used classes that use nonthreadsafe resources that are expensive to create (such as XML parsers or connections to a database), try a <i>ThreadLocal</i> implementation. </p><p></p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>import java.text.ParseException;import java.util.Date;public interface DateParser {    public Date parse(String text) throws ParseException;}</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>import java.text.DateFormat;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;public class UnsynchronizedDateParser implements DateParser {  private final DateFormat dateFormat = new SimpleDateFormat("dd/MM/yyyy");  public Date parse(String text) throws ParseException {    return dateFormat.parse(text);  }}</pre><P><A HREF="#rl2">Back to Article</A></P><H4><A NAME="l3">Listing Three</H4><pre>import java.text.DateFormat;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;public class SynchronizedDateParser implements DateParser {  private final DateFormat dateFormat = new SimpleDateFormat("dd/MM/yyyy");  public synchronized Date parse(String text) throws ParseException {    return dateFormat.parse(text);  }}</pre><P><A HREF="#rl3">Back to Article</A></P><H4><A NAME="l4">Listing Four</H4><pre>import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;public class NewInstanceDateParser implements DateParser {    public Date parse(String text) throws ParseException {        return new SimpleDateFormat("dd/MM/yyyy").parse(text);    }}</pre><P><A HREF="#rl4">Back to Article</A></P><H4><A NAME="l5">Listing Five</H4><pre>import java.text.DateFormat;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;public class ThreadLocalDateParser implements DateParser {    private static final ThreadLocal DATE_PARSER_THREAD_LOCAL =                                                      new ThreadLocal() {        protected Object initialValue() {            return new SimpleDateFormat("dd/MM/yyyy");        }    };    public Date parse(String text) throws ParseException {        return ((DateFormat) DATE_PARSER_THREAD_LOCAL.get()).parse(text);    }}</pre><P><A HREF="#rl5">Back to Article</A></P></body></html>