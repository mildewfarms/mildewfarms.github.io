<html><head><title>Jul03: Calling  C Library Routines From Java</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Calling  C Library Routines From Java</h1><p><i>Dr. Dobb's Journal</i> July 2003</p><h2>Using the Java  Native Interface</h2><h3>By Mick Pont</h3><I>Mick works in the development division of the Numerical Algorithms Group and can be contacted at mick@nag.co.uk.</I><hr><a name="rs1"><a href="0307bs1.htm">Run-Time Error Messages</a><hr><p>The NAG C Library from the Numerical Algorithms Group (http://www.nag.com/) is a mathematical and statistical library containing routines for linear algebra, optimization, quadrature, differential equations, regression analysis, and time-series analysis. Although written in C, the library's functionality can be accessed from other languages. On PCs, DLL versions of the library can be exploited in many ways, including calling from Microsoft Excel, Visual Basic, or Borland Delphi. Consequently, NAG C Library users often ask if they can call it from Java.</p><p>One way to perform numerical computations is by creating Java classes that implement the required functionality. However, this is often difficult and time consuming. In this article, I present a technique for calling C Library routines directly from Java. </p><DDJADVERTISEMENT INLINE><p>Apart from avoiding rewriting numerical code in Java, using existing C code has another advantage. Java is portable&#151;compiled programs run on any machine with a Java Virtual Machine (VM). To accomplish this, the Java compiler does not compile to a machine-dependent assembler, but to machine-independent bytecode that is interpreted at run time by the VM. Although the interpreter is efficient, no interpreted program runs as fast as programs compiled to assembler code. For applications that perform CPU-intensive operations on large amounts of data, this can be significant, and moving those operations from Java into compiled libraries can cut execution time.</p><h3>The Java Native Interface</h3><p>To access a library routine from a Java program, I use the Java SDK's Java Native Interface (JNI), which gives compile- and run-time support for calling native code from a Java program. By native code, I mean code that is not Java, typically C or C++; here, I assume C.</p><p>At compile time, JNI defines how Java data types correspond to C data types. C programs get this information from JNI header files that come with the Java SDK. Javah, a tool that comes with the SDK, creates application-specific header files that help eliminate programming errors in communication between Java and C routines. At run time, JNI lets Java objects be passed to C code, and lets C code access Java properties and methods. Thus, C code can set properties of Java classes, making it possible to call Java methods from C.</p><p>For this article, I used the Java 2 SDK 1.4.1 on: a Linux machine running Red Hat Linux 8.0 with the GNU C compiler, gcc 3.2; a Sun machine running Solaris 8.0 with the Sun Workshop 6 C compiler, cc 5.2; and a PC running Windows 2000 with Visual C++ 5.0. Working on UNIX platforms other than Sun or Linux is similar, the main differences being in the location of Java include files and the method of creating a shared object (dynamic library).</p><h3>Using Native Code Libraries</h3><p>When Java programs call native methods (C functions, for instance), extra arguments are prepended to the argument list of the called C function. These arguments give the C code a handle onto Java methods and properties. This may not be a problem if you control and may modify the C code of the function to call&#151;you can add the extra arguments to your native function. However, to call a function that's in object code, you must use an intermediate shared library (UNIX) or DLL (Windows). This library is the interface between the Java code and library code. Your interface library must make its own calls to the underlying library, and send the results back to Java; see <A NAME="rf1"><A HREF="0307bf1.htm">Figure 1</A>.</p><p>Implementing calls from Java to native functions is a three-step process:</p><p>1.	Write a declaration in Java for the native method. This declaration includes the keyword <i>native</i> to signify to the Java compiler that it is implemented externally.</p><p>2.	Create a header file for use by the native (C) code. This header file contains the declaration of the native method as viewed by the C compiler. It includes the extra arguments required for the C function to access Java methods and properties, and has argument types defined in terms of standard C types.</p><p>3.	Implement the native method in C. This function uses the header file in Step 2, makes calls to library functions it needs (possibly back to Java methods), and returns results to Java. This C code is compiled to build a shareable library.</p><p></p><p>After the native shareable library is built, Java code that uses it is still machine-independent even though the native library is not. Thus, you must build the library on all platforms the Java program runs on, although you don't need to edit or rebuild the Java code.</p><h3>A Simple Function of One Argument</h3><p>In the simplest example of creating an interface library, I call a function with only one argument and one return value&#151;the <i>Y</i><i><sub>0</i></sub><i>(x) </i>Bessel function routine from the Standard C Math Library. (The various Bessel functions, of which this is one, are named for 18th-century German astronomer Friedrich Wilhelm Bessel.)</p><p>The function prototype from the C &lt;math.h&gt; header file is <i>double y0(double x);. </i>The Java program declares the method <i>private native double bessely0(double x);</i>, which has a <i>double</i> argument, returning <i>double</i>. The <i>native</i> keyword tells the Java compiler that the method is implemented outside Java.</p><p>You must build a shared library to contain the native method that interfaces between Java and the math library function <i>Y</i><i><sub>0</i></sub><i>(x). </i>The Java program loads that interface library, CJavaInterface, by passing its name to a Java <i>System.LoadLibrary()</i> call. Even though the interface library may have a different name (depending on the OS), <i>LoadLibrary</i> sorts it out. For example, under Linux or Solaris, the Java <i>System.loadLibrary("CJavaInterface");</i> searches for a library named "libCJavaInterface.so." But under Windows, it searches for "CJavaInterface.dll."</p><p><A NAME="rl1"><A HREF="#l1">Listing One</A> is the Java program Bessel.java, including the native method declaration and <i>loadLibrary</i> call. The <i>System.loadLibrary</i> call is placed inside a static initializer so that it is executed when the class gets loaded by Java. The main program gets a value of <i>x</i> from the command line, and calls the native method using that argument and nine other arguments derived from it. Compile the Java program with the command <i>javac Bessel.java. </i>If all goes well, the compiler produces a file named "Bessel.class." Note: all source code mentioned in this article is available electronically; see "Resource Center," page 5. With the source code are scripts that you can use to compile and run all the examples under Windows (.bat files) or Linux (.sh files).</p><p>Once Bessel.java is compiled, use the Java SDK's javah tool to create a header file that the C compiler can use. The command<i> javah -jni Bessel </i>produces the file Bessel.h; see <A NAME="rl2"><A HREF="#l2">Listing Two</A>. The header file includes &lt;jni.h&gt; (which comes with the Java SDK); javah extracted this declaration of the native function for use by the C program:</p><blockquote><p>JNIEXPORT jdouble JNICALL </p><p>	Java_Bessel_bessely0</p><p>	     (JNIEnv *, jobject, jdouble);</p></blockquote><p>The name<i> Java_Bessel_bessely0 </i>shows the Java class in which it is declared, as well as the name <i>bessely0 </i>chosen for the native function. The macros <i>JNIEXPORT</i> and <i>JNICALL</i> are defined via &lt;jni.h&gt; and affect the Windows calling convention (on UNIX, the macros disappear). The types <i>JNIEnv</i>, <i>jobject</i>, and <i>jdouble</i> are also defined via &lt;jni.h&gt;, in terms of machine-dependent C types. For example, the type <i>jdouble</i> is the Java <i>double</i> type, which equates to the C <i>double</i> type.</p><p>From the C point of view, the first two arguments, of types <i>JNIEnv</i>*<i> </i>and <i>jobject</i>, give C code access to the Java environment. In this case, the third argument&#151;the argument <i>x</i> of the <i>Y</i><i><sub>0</i></sub><i>(x) </i>Bessel function&#151;passes to the C Math Library.</p><p>Once Bessel.h is created, you can write a C implementation of <i>Java_Bessel_bessely0</i>; see <A NAME="rl3"><A HREF="#l3">Listing Three</A>. You can write any C code you like here but, in this case, all I do is to call the <i>Y</i><i><sub>0</i></sub> function from the Standard Math Library.</p><h3>Building the Shareable Library or DLL</h3><p>Building the shareable library or DLL is operating-system dependent.</p><p>To compile under Linux, assuming Java is installed in /usr/java/j2sdk1.4.0_02 (if yours is elsewhere, modify accordingly), you first use the GNU C compiler to compile BesselImp.c:</p><blockquote><p>gcc -c -I/usr/java/j2sdk1.4.0_02/include </p><p>   -I/usr/java/j2sdk1.4.0_02/include/linux 				BesselImp.c</p></blockquote><p>The <i>-I </i>switches tell the C preprocessor where to look for header files. The first directory,<i> /usr/java/j2sdk1.4.0_02/include</i>, locates the jni.h header file. The second directory,<i> /usr/java/j2sdk1.4.0_02/include/linux</i>, is machine dependent and used by jni.h to find type definitions. The <i>linux</i> element of this name changes if you use another operating system. </p><p>When BesselImp.c compiles, turn it into a shareable object using<i> ld -G BesselImp.o -o libCJavaInterface.so -lm -lc -lpthread.</i> The <i>-G</i> flag means "create a shareable object." The <i>-o </i>flag names the shareable library as libCJavaInterface.so, the name needed by the <i>loadLibrary() </i>call in the Java code. Finally, the <i>-lm</i>, <i>-lc</i>, and <i>-lpthread</i> flags ensure that you link with required system math and run-time libraries.</p><p>Under Windows, assuming Java is installed in c:\j2sdk1.4.0_01 (modify accordingly if not), compile and build the DLL in one step:</p><blockquote><p>cl /Ic:\j2sdk1.4.1_01\include </p><p>   /Ic:\j2sdk1.4.1_01\include\win32</p><p> /Gz /LD BesselImp.c /FeCJavaInterface.dll</p></blockquote><p>As with UNIX, the two<i> /I </i>switches tell the C compiler where to look for header files.</p><p>Without the<i> /Gz </i>compiler option (meaning "use the __<i>stdcall</i> calling convention"), the code may compile and link&#151;and even start running&#151;but eventually may cause an access violation. The <i>/LD</i> flag means "build a DLL." The<i> /Fe </i>flag names the output file as CJavaInterface.dll. You can run the program using <i>java Bessel 1.0. </i><A NAME="rl4"><A HREF="#l4">Listing Four</A> is the expected output.</p><h3>Calling a C Function  With Array Arguments</h3><p>Most native functions return more than a single value. To illustrate, I use a vector addition function to show how to pass array arguments between Java and C. I don't call any auxiliary library functions, but code the entire routine from scratch.</p><p>The file VectorAdd.java (available electronically) is the Java program in which the declaration of the native function<i> private native int vectoradd(int n, double[] a,double[] b, double[] c);</i> includes argument <i>n</i>, the length of the vectors to be added, along with input vectors <i>a</i> and <i>b,</i> and output vector <i>c</i>.</p><p>Compile the Java program with the command <i>javac VectorAdd.java</i>, then use <i>javah -jni VectorAdd</i> to create a C header file. The generated header file, VectorAdd.h, contains the function prototype:</p><blockquote><p>JNIEXPORT jint JNICALL </p><p>   Java_VectorAdd_vectoradd</p><p>       (JNIEnv *, jobject, jint, jdoubleArray,</p><p>        jdoubleArray, jdoubleArray);</p></blockquote><p>From the C point of view, the function has extra arguments of type<i> JNIEnv </i>*<i> </i>and <i>jobject</i>. This time, they are needed; see VectorAddImp.c (available electronically).</p><p>You cannot access the elements of array arguments <i>a, b,</i> and <i>c</i> directly because they are Java-style (not C-style) arrays of type <i>jdoubleArray.</i> Trying to access the array elements directly leads to catastrophe. Instead, convert them to C-style double arrays, using the JNI function <i>GetDoubleArrayElements</i>. Header file jni.h declares this function:</p><blockquote><p>jdouble * (JNICALL *GetDoubleArrayElements)</p><p>(JNIEnv *env, jdoubleArray array, jboolean 				    *isCopy);</p></blockquote><p><i>GetDoubleArrayElements</i> is accessed through the <i>JNIEnv</i> pointer, *<i>env</i>. Given the array of type <i>jdoubleArray</i>, it returns a pointer to an array of elements of type <i>jdouble,</i> which can be safely manipulated by C. The output argument <i>isCopy</i> tells you whether Java made a copy of the array, or passed a pointer to the elements in situ.</p><p>The C program, therefore, makes three calls of <i>GetDoubleArrayElements</i>, one for each array argument. It adds each element of array <i>a</i> to array <i>b,</i> putting the results in array <i>c</i>. Then it tells Java that it is finished with the array pointers using three calls of <i>ReleaseDoubleArrayElements</i>, declared in jni.h as:</p><blockquote><p>void (JNICALL *ReleaseDoubleArrayElements)</p><p>(JNIEnv *env, jdoubleArray array, jdouble 			      *elems, jint mode);</p></blockquote><p>This ensures that results get copied back to the appropriate Java arrays, and that Java garbage collection can work properly.</p><p>Compile this code into an interface library in a similar way to the first example. Under Windows:</p><blockquote><p>cl /Ic:\j2sdk1.4.1_01\include </p><p>  /Ic:\j2sdk1.4.1_01\include\win32</p><p>     /Gz /LD VectorAddImp.c </p><p>       /FeCJavaInterface.dll</p></blockquote><p>Run the program with <i>java VectorAdd</i>.</p><h3>Calling a C Function  With a Function Argument</h3><p>Assume that you have a C library containing a root-finding function </i><i>rootfinder</i>, with prototype <i>double rootfinder(double (</i>*<i> f)(double x), double a, double b, int </i>*<i>nits, int </i>*<i>fail);.</i> The function is designed to find a simple root of an algebraic equation&#151;a point <i>x</i> where the function<i> f(x)</i> evaluates to zero. For example, <i>x=3</i> is a root of the function <i>f(x)=x</i>*<i>x-5</i>*<i>x+6</i>. The first argument of <i>rootfinder</i> is a pointer to the function of which a root is sought. The arguments <i>a</i> and <i>b</i> are user-supplied points that the caller asserts are bounds on the root, such that<i> f(a) </i>has the opposite sign to <i>f(b).</i></p><p>If the search for a root is successful, <i>rootfinder</i> returns the root, along with the number of iterations of the algorithm that were required to find the root (via argument <i>nits</i>). The output argument <i>fail</i> returns as zero if a root was found, and nonzero otherwise.</p><p>Because you probably don't have a library containing the <i>rootfinder</i> function, rootlib.c (which is also available electronically) contains a simple bisection method implementation of <i>rootfinder</i>. Under Windows, compile it into rootlib.dll (cl /I. /Gz /LD rootlib.c /Ferootlib.dll). The file RootFinder.java (available electronically) calls the <i>rootfinder</i> function. In the Java program, I declare the <i>rootfinder</i> function as a method: <i>private native int rootfinder(String funName, double a, double b);</i>. I use the <i>int</i> return value to send back any error code from the native function.</p><p>Since it isn't possible to pass a function argument directly from Java to C, I pass the name of a function via the <i>String</i> argument <i>funName</i>. Also, the Java declaration does not contain any of the output arguments of the C function <i>rootfinder</i>. Instead, I use a different way to pass the information that the output arguments contain back to Java.</p><p>Compile the Java program and generate a C header file with the commands<i> javac RootFinder.java </i>and<i> javah -jni RootFinder. </i></p><p>RootFinderImp.c (available electronically) is the C interface library.</p><p>The function <i>Java_RootFinder_rootfinder</i> is the C implementation of the Java-declared method <i>rootfinder</i>. Since you cannot pass the Java method that evaluates <i>f(x) </i>directly to the rootlib C Library function <i>rootfinder</i>, you need to wrap it in a C function such as <i>rootFun</i>. Its prototype is <i>double rootFun(double x);</i> and it has the argument type and return type required by the <i>rootlib</i> library function. Inside <i>rootFun,</i> I only call the Java method to evaluate the function. The trick is in knowing how to make this call to Java.</p><p>You do this using the JNI function <i>CallDoubleMethod</i>, which is declared in jni.h (there are similar functions&#151;<i>CallVoidMethod, CallIntMethod</i>, and others&#151;for methods with different return types). <i>CallDoubleMethod</i> needs several arguments, including the <i>JNIEnv</i> pointer argument <i>env</i> and the Java object argument, both of which were passed to <i>Java_RootFinder_rootfinder</i>. It also needs the argument <i>methodID</i>, which is the ID of the Java method to be called. These arguments are known (or can be obtained) by <i>Java_RootFinder_rootfinder</i>, but are not directly known by the function <i>rootFun</i>. Instead, I give these arguments to <i>rootFun</i> via global variables, which I declare like this in C:</p><blockquote><p>JNIEnv *globalJavaEnv;</p><p>jobject globalJavaObject;</p><p>jmethodID globalMid;</p></blockquote><p>Because these variables are global, they can be accessed by both <i>Java_RootFinder_rootfinder</i> and <i>rootFun</i>.</p><p>Besides these arguments, <i>rootFun</i> also passes to <i>CallDoubleMethod</i> the actual arguments that the Java method needs to evaluate the function <i>f(x).</i> <i>CallDoubleMethod</i> can accept any number of these arguments, but in this case, there is only argument <i>x</i>.</p><p>I could have written the evaluation code in C (and would not have needed to use <i>CallDoubleMethod</i> and the routines associated with it) instead of calling the Java method from <i>rootFun</i> to evaluate the function <i>f(x).</i> However, an advantage to the method I use is that once the interface library is built, you need never rebuild it even if the evaluation function changes&#151;just supply a different Java evaluation function.<i></p><p>Java_RootFinder_rootfinder</i> first copies its arguments <i>env</i> and <i>obj</i> to global variables <i>globalJavaEnv</i> and <i>globalJavaObject</i>. Next, take the name of the Java method passed as the <i>jstring</i> argument <i>funName</i> and convert it into a method ID. Use the JNI function <i>GetStringUTFChars</i> to convert the <i>jstring</i> into a C <i>char</i> pointer named "<i>functionName"</i> because the <i>jstring</i> cannot be safely accessed directly. Then the JNI functions <i>GetObjectClass</i> and <i>GetMethodID</i> are used to get hold of the method ID of the Java evaluation function:</p><blockquote><p>functionName = (*env)-&gt;GetStringUTFChars</p><p>                              (env, funName, 0);</p><p> ...</p><p>cls = (*env)-&gt;GetObjectClass(env, obj);</p><p>globalMid = (*env)-&gt;GetMethodID(env, cls, 		functionName, "(D)D");</p></blockquote><p>(Note that in the example program, the evaluation function is either the method <i>myFunction</i> or <i>myFunction2.</i>) <i>GetMethodID'</i>s second argument, of type <i>jclass</i>, is the class containing the method; the third argument is the name of the method; and the fourth argument is the signature of the method. In this case, the signature (<i>D)D</i> means a method with one <i>double</i> argument that returns a value of type <i>double</i>.</p><p>Once you have the method ID to be used by <i>rootFun</i>, you no longer need the C string <i>functionName</i>, so free it via a call to JNI function <i>ReleaseStringUTFChars</i> to avoid memory leaks. At this point, you have everything you need to call the C rootlib library function <i>rootfinder</i>. <A NAME="rf2"><A HREF="0307bf2.htm">Figure 2</A> illustrates what happens at run time.</p><h3>Returning Results To Java</h3><p>After returning from the C rootlib library, results must be returned to Java using JNI functions. Notice that the Java class contains the properties (variables) <i>result</i> and <i>niterations</i>.</p><p>Given the name and signature of one of these variables, the JNI function <i>GetFieldID</i> returns its "field ID," which you can pass to another JNI function to set its value. For example, the function <i>SetDoubleField</i> sets the value of a <i>double</i> property given its field ID. The lines</p><blockquote><p>fid = (*env)-&gt;GetFieldID(env, cls, "result", "D");</p><p>/* Set the result value via the ID */</p><p>(*env)-&gt;SetDoubleField(env, obj, fid, result);</p></blockquote><p>get the field ID of property <i>result</i>, and set its value to that of the variable contained in the C code <i>result</i>. Similarly, the lines:</p><blockquote><p>fid = (*env)-&gt;GetFieldID(env, cls, "niterations", 			           "I");</p><p>(*env)-&gt;SetIntField(env, obj, fid, nits);</p></blockquote><p>get the field ID of int property <i>niterations</i>, with signature <i>I</i>, and set its value to <i>nits</i>, the number of iterations taken by <i>rootfinder</i> in searching for the root.</p><h3>Conclusion</h3><p>With the techniques presented here, you can pass information between C and Java. Furthermore, you should be able to re-use some of the source code presented here to create interfaces to your own routines, written in C or in a precompiled library.</p><p></p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>// The Bessel.java filepublic class Bessel{  // Declaration of the Native (C) function  private native double bessely0(double x);  static    {      // The runtime system executes a class's static initializer       // when it loads the class.      System.loadLibrary("CJavaInterface");    }  // The main program  public static void main(String[] args)    {      double x, y;      int i;      /* Check that we've been given an argument */      if (args.length != 1)        {          System.out.println("Usage: java Bessel x");          System.out.println("  Computes Y0 Bessel function of argument x");          System.exit(1);        }      // Create an object of class Bessel      Bessel bess = new Bessel();      /* Convert the command line argument to a double */      x = new Double(args[0]).doubleValue();      System.out.println();      System.out.println("Calls of Y0 Bessel function routine bessely0");      for (i = 0; i &lt; 10; i++)        {          /* Call method bessely0 of object bess */          y = bess.bessely0(x);          System.out.println("Y0(" + x + ") is " + y);          /* Increase x and repeat */          x = x + 0.25;        }    }}</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>/* The Bessel.h file generated from the Bessel class by the javah tool. *//* DO NOT EDIT THIS FILE - it is machine generated */#include &lt;jni.h&gt;/* Header for class Bessel */#ifndef _Included_Bessel#define _Included_Bessel#ifdef __cplusplusextern "C" {#endif/* Class:     Bessel * Method:    bessely0 * Signature: (D)D */JNIEXPORT jdouble JNICALL Java_Bessel_bessely0  (JNIEnv *, jobject, jdouble);#ifdef __cplusplus}#endif#endif</pre><P><A HREF="#rl2">Back to Article</A></P><H4><A NAME="l3">Listing Three</H4><pre>/* The BesselImp.c file, which implements the native function */#include &lt;jni.h&gt;      /* Java Native Interface headers */#include "Bessel.h"   /* Auto-generated header created by javah -jni */#include &lt;math.h&gt;     /* Include math.h for the prototype of function y0 *//* Our C definition of the function bessely0 declared in Bessel.java */JNIEXPORT jdouble JNICALLJava_Bessel_bessely0(JNIEnv *env, jobject obj, jdouble x){  double y;  /* Call Y0(x) Bessel function from standard C mathematical library */  y = y0(x);  return y;}</pre><P><A HREF="#rl3">Back to Article</A></P><H4><A NAME="l4">Listing Four</H4><pre>// Output when running the Java Bessel programCalls of Y0 Bessel function routine bessely0Y0(1.0) is 0.08825696421567694Y0(1.25) is 0.2582168515945407Y0(1.5) is 0.38244892379775886Y0(1.75) is 0.465492628646906Y0(2.0) is 0.5103756726497451Y0(2.25) is 0.5200647624572782Y0(2.5) is 0.4980703596152316Y0(2.75) is 0.4486587215691318Y0(3.0) is 0.3768500100127903Y0(3.25) is 0.2882869026730869</pre><P><A HREF="#rl4">Back to Article</A></P></body></html>