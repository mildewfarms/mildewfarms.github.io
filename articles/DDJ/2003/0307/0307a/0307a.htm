<html><head><title>Jul03: Dynamic Proxies in Java and .NET</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Dynamic Proxies in Java and .NET</h1><p><i>Dr. Dobb's Journal</i> July 2003</p><h2>Separating cross-cutting concerns</h2><h3>By Tom Barrett</h3><I>Tom is a senior developer for Hubbard One. He can be contacted at barrett_tom@yahoo.com.</I><hr><a name="rs1"><a href="0307as1.htm">Proxies versus Decorators</a><hr><p>Discrete modules such as components and classes are designed to maximize functional cohesion while minimizing the interaction between modules. In typical object-oriented systems, these components are defined by the functional boundaries of the domain, even though many concerns are not aligned along these functional boundaries. Concerns such as logging, security, persistence, threading, and caching usually touch most areas of an application. While it is common to pull these concerns into separate subsystems, thereby limiting the degree to which they are spread throughout the code, explicit calls to these subsystems decrease cohesion and increase coupling of resulting modules. Consequently, one of the primary goals of software design is separation of concerns. </p><p>Attempts at separating cross-cutting concerns are not new. Microsoft's MTS/COM+ and Java EJB services have separated cross-cutting concerns for years. For instance, you write COM+ and EJB components without worrying about security or threading, since the underlying COM+ server and EJB container frameworks address these issues. In this article, I examine how proxies separate cross-cutting concerns, then explore a new twist on the traditional Proxy pattern that promotes reuse and decreases complexity. The complete source code (in C# and Java) that implements the techniques presented is available electronically (see "Resource Center," page 5). </p><DDJADVERTISEMENT INLINE><p>Interestingly, aspect-oriented programming (AOP) deals with this exact issue. AOP defines a framework for implementing concerns that cross cut many different modules ("aspects") in a loosely coupled manner. But aspects represent a framework that is unlike traditional languages, which lack formal support for AOP. More recently, there are add-ons for Java such as AspectJ (see "Aspect-Oriented Programming with AspectJ," by William Grosso, <i>DDJ</i>, August 2002). Still, AOP is not currently an option for many projects. </p><h3>Proxy Pattern</h3><p>AOP aside, the cleanest way of developing cross-cutting concerns is via interception. Instead of creating actual business objects, you can create proxies to these objects that implement the same interface as the real business objects, but with added functionality (also see the accompanying text box entitled "Proxies versus Decorators"). To illustrate how to apply proxies to separate cross-cutting concerns, consider an <i>Employee</i> component in either .NET or Java. <A NAME="rf1"><A HREF="0307af1.htm">Figure 1</A> shows the <i>Employee</i> interface, an Abstract Factory (see <i>Design Patterns: Elements of Reusable Object-Oriented Software,</i> by Erich Gamma et al., Addison-Wesley, 1995) for returning instances of an <i>Employee</i> and simple implementations of both the interface and the factory.</p><p>Suppose you want to add logging to the <i>Employee</i> class to trace application flow through an <i>Employee</i> object. The obvious way would be to modify the <i>Employee</i> implementation class and add a call to a logging component in all of the method calls. While this works, it decreases the cohesion of the <i>Employee</i> implementation class, while increasing coupling. The class now needs to know about the logging framework, making it impossible to use the <i>Employee</i> implementation class in projects that don't have the same logging framework without modifying the source code. Additionally, the process can be error prone in practice since it is easy to forget to modify a method.</p><p>Alternatively, consider the additions in <A NAME="rf2"><A HREF="0307af2.htm">Figure 2</A> that employ the Proxy pattern to separate logging concerns. The original <i>Employee</i> implementation class remains untouched, but I've added the <i>LoggingEmployee</i> and <i>LoggingEmployeeFactory </i>classes. The only change to start using this new logging functionality is to instantiate <i>LoggingEmployeeFactory</i> in place of the original <i>SimpleEmployeeFactory</i>. <i>LoggingEmployeeFactory</i> returns instances of <i>LoggingEmployee</i> that look like a typical <i>Employee</i> object (as they implement the <i>Employee</i> interface), but are just wrappers around a real <i>Employee</i> object. <i>LoggingEmployee</i> logs method requests, then forwards the request to the actual <i>Employee</i> object. You now have a logging <i>Employee</i> component without reducing cohesion or increasing coupling of the underlying classes.</p><p>This solution is cleaner than the original, but not without problems. These problems become more apparent by recognizing that applications typically consist of many components with cross-cutting concerns. For each new concern, a new concrete class for each domain class needs to be developed, and factory methods for these classes must be created or modified. In systems with many domain classes and cross-cutting concerns, the number of classes makes this scheme too complex to be viable. Code generation reduces some complexity (by automatically generating classes for each concern) but ideally, there is one class for each cross-cutting concern that could be applied to all classes in the domain, instead of a class for each concern/domain class combination.</p><h3>Dynamic Proxies</h3><p>Fortunately, both Java and .NET support dynamic proxies. According to the Java documentation (http://java.sun.com/j2se/1.3/docs/index.html):</p><blockquote><p>A dynamic proxy class is a class that implements a list of interfaces specified at run time such that a method invocation through one of the interfaces on an instance of the class will be encoded and dispatched to another object through a uniform interface.</p></blockquote><p>In other words, a dynamic proxy is an instance of a class created at run time that can serve as a proxy for an interface or set of interfaces. Classes generated at run time may not be exciting to Smalltalk aficionados, but this behavior has traditionally been unavailable in C-based, object-oriented languages. </p><h3>Java Dynamic Proxies</h3><p>In Java, dynamic proxies are created using the classes<i> java.lang.reflect.Proxy </i>and <i>java.lang.reflect.InvocationHandler</i>. The <i>Proxy</i> class has a factory method<i> newProxyInstance()</i>, which returns dynamic proxy objects given a class loader, an array of interfaces to implement, and an instance of <i>java.lang.reflect.InvocationHandler. </i>The interface <i>InvocationHandler, </i> which you must implement for dynamic proxies, consists of a single method,<i> invoke()</i>, which is called whenever a call to the proxy occurs. The <i>invoke() </i>method is passed a reference to the dynamic proxy, the method that was called, and an array of the arguments that were passed to the method.</p><p>To see this in action, I refactor the logging <i>Employee</i> component to use dynamic proxies. Instead of creating an <i>Employee-</i>specific logging proxy, I create the class <i>LoggingProxy</i> as a generic logging proxy that wraps any object. As expected, <i>LoggingProxy</i> implements <i>InvocationHandler</i> with an implementation of <i>invoke() </i>that logs the method call, then uses reflection to invoke the method on the actual wrapped object. <i>LoggingProxy</i> also has the factory method <i>getProxy(), </i>which returns a dynamic proxy instance given an object to proxy. Because the syntax for creating dynamic proxies is often messy, it is common to hide the details for obtaining them in factory methods.</p><h3>.NET Dynamic Proxies</h3><p>There are several ways in .NET to intercept calls to objects at run time, thereby creating dynamic proxies. However, the easiest way is to enlist the use of the <i>System.Runtime.Remoting.Proxies.RealProxy </i>class. (The other common method is to have domain objects implement <i>System.ContextBoundObject</i> and have custom <i>ContextAttributes</i> perform the interception.) As evident by its namespace, <i>RealProxy</i> is used in the .NET Framework for remote operations, but actually performs a role similar to <i>InvocationHandlers</i> in Java. The <i>RealProxy</i> class has one abstract method,<i> Invoke(),</i> which takes an <i>IMessage</i> object as a parameter and returns an <i>IMessage</i> object as a result. The <i>IMessage</i> parameter object wraps the call information into one object, which can be unpacked to get the method being called and its arguments. The <i>RealProxy</i> method <i>GetTransparentProxy() </i>is a factory method that returns the actual proxy object, much like the <i>newProxyInstance()</i> factory in Java. One difference between .NET and Java remote proxies is that a <i>RealProxy</i> can only proxy one interface (or alternatively a <i>MarshalByRef</i> object), whereas a Java <i>Proxy</i> can proxy any number of interfaces.</p><p>Refactoring the C# version of the logging proxy, I again create a generic logging proxy that wraps any object. <i>LoggingProxy</i> extends <i>RealProxy</i>, implementing the abstract method <i>Invoke().</i> The <i>Invoke()</i> method is slightly messier than the Java version, as the <i>IMessage</i> parameter needs to be cast into an <i>IMethodCallMessage</i>, which I then pick apart to get the method and parameters. The return value of the method also needs to be wrapped in an <i>IMessage</i> object, in this case a <i>ReturnMessage</i>, and returned from the proxy. Although .NET provides a way to return output parameters from a dynamic proxy, this example assumes that there are no output parameters. Also, the factory method for the .NET version takes in an object to proxy and the <i>Type</i> of the interface for which to proxy (alternatively, the <i>Type</i> of a <i>MarshalByRef</i> object). </p><h3>Problems with Dynamic Proxies</h3><p>Aside from some minor frustration with less than obvious syntax for creating dynamic proxies, the drawback of using dynamic proxies is speed of execution. In both Java and .NET, calls through dynamic proxies require the use of reflection, resulting in method calls being 5 to 200 times slower (at least in my informal testing). Of course, this relative decrease is in comparison to blazingly fast local method calls; in the case of method calls that perform significant business logic, both relative and absolute performance degradation may be imperceptible. As with all performance testing, your results may be different. In most cases, the slight performance degradation is an acceptable tradeoff for producing maintainable, reusable code.</p><h3>Persistence Example</h3><p>One place where performance of dynamic proxies likely will not affect overall system performance is with database calls. For example, consider a modified <i>Employee</i> component; this time, only in C#. I've added a manager/manages bidirectional relationship to the <i>Employee</i> class, and my new goal is to map <i>Employee</i>s to a relational database (<A NAME="rf3"><A HREF="0307af3.htm">Figure 3</A>).</p><p>For ease of illustration, I limit the mapping to the relatively simple case of loading instances from the database by object identifier (OID). But even with this simplification, an interesting problem remains: When an employee is retrieved from the database, ideally, I would like to load employees who are related to it; otherwise consumers of my <i>Employee</i> component will have to explicitly load them. If I load the related employees, however, I also want to load employees related to these related employees (for the same reason) and the employees related to these employees, and so forth. If there's no mechanism in place to stop this loading chain, the entire object graph of employees can be loaded into memory just to get one employee back from the database.</p><p>To avoid this, most object-relational mapping schemes employ some type of "lazy loading" pattern. As objects are loaded from the database, related objects are not all materialized at the same time. Instead, proxies that contain only partially loaded objects take their place. Only if the client navigates to one of these proxies does an "object fault" occur and result in the proxy loading the entire object. This can be an effective pattern when objects have many relationships that are not often traversed, as related objects never end up being loaded if they are not used.</p><p>Often, the proxies for related objects are the actual domain objects themselves, except that the objects just contain an OID. The getters and setters for all of the properties of the domain object first check if the object is just a "ghost" and, if so, load the actual object before returning a value. For example, you could modify the <i>Employee</i> class to have properties that look something like:</p><blockquote><p>public string FirstName {</p><p>   get {</p><p>     if (!this.IsLoaded)</p><p>       Load();</p><p>     return name;</p><p>   }</p><p>}</p></blockquote><p>This approach works, but also is an example of a cross-cutting concern (the need for lazy loading) interfering with the domain logic. The <i>Employee</i> class shouldn't need to know anything about ghosts or lazy loading&#151;it should stick to implementing the business logic of being an <i>Employee</i>.</p><p>I could, of course, hardcode an <i>Employee</i> ghost proxy, but as more domain components are added, I would need to go through the tedious task of creating a hardcoded proxy for each component. Fortunately, I can enlist the support of dynamic proxies to take care of this problem.</p><p>To keep the <i>Employee</i> class free of any database logic, I created a simple <i>EmployeeMapper</i> class, which makes <i>Employee</i> objects materialize by OID. <i>EmployeeMapper</i> has two public methods, <i>Find() </i>and <i>FindByManager()</i>, which return an <i>Employee</i> by OID and a list of <i>Employees</i> by manager OID, respectively. <i>EmployeeMapper</i> also keeps a <i>Hashtable</i> of loaded objects to avoid loading the same object twice.</p><p>The interesting logic lives in the<i> Load() </i>method. After checking to make sure the OID is not already loaded, the <i>FirstName</i> and <i>LastName</i> properties are set as expected. At this point, the <i>Manager</i> object and <i>Manages</i> list could be loaded as well by calling <i>Find() </i>on the manager foreign key and <i>FindByManager()</i> on the OID, but if I did this now, I would run into the exact problem described earlier.</p><p>To avoid this situation, dynamic proxies are created with <i>Delegates</i> to these functions and the corresponding OIDs (a <i>Delegate</i> in .NET is similar to a function pointer). The <i>RealProxy</i> implementation classes <i>LazyLoadObjectProxy</i> and <i>LazyLoadListProxy</i> have factory methods that take in a <i>Delegate</i> and an OID and return dynamic proxies. <i>LazyLoadObjectProxy</i> serves as the factory for dynamic proxies to domain objects, and <i>LazyLoadListProxy</i> serves as the factory for dynamic proxies to lists of domain objects. The<i> Invoke() </i>method of these classes checks if the wrapped object (<i>IList</i> in the case of <i>LazyLoadListProxy</i>) is null; if so, it calls the <i>Delegate</i> function with the OID before invoking the method.</p><p>The nice thing about this technique is its flexibility. Many object-relational mapping problems boil down to looking up objects by their primary key or by a foreign key, and the two <i>Delegate/Proxy</i> combinations handle these two cases perfectly. Dynamic proxies have afforded us a flexible, reusable solution for a common problem.</p><h3>Conclusion</h3><p>Applications that employ dynamic proxies to separate concerns are cleaner, more reusable, and contain less code than their traditional counterparts. While aspect-oriented programming may be the future solution for separating cross-cutting concerns, dynamic proxies offer a unique solution that you can implement today. In cases where performance drawbacks are not critical, the simplicity and reusability of dynamic proxies is a powerful solution to the classic problem of cross-cutting concerns.</p><p><b>DDJ</b></p></body></html>