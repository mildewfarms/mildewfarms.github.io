<html><head><title>Jul03: Programmer's Toolchest</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Distributed Loadbuilds</h1><p><i>Dr. Dobb's Journal</i> July 2003</p><h2>Building loads  three times faster</h2><h3>By Kevin W. Smith</h3><I>Kevin is a software architect for Nortel Networks and can be reached at kwsmith@ nortelnetworks.com.</I><hr><a name="rs1"><a href="0307es1.htm">ClearMake Advantages</a><hr><p>The idea of dividing a computationally intensive task between multiple physical machines has been around for as long as computer networks have existed. For many programmers, SETI@home (http://setiathome.ssl.berkeley.edu/) provided an introduction to the power of network computing. In addition to SETI, there are a variety of toolkits available for distributing and load-balancing units of work over a network. For example, Sun provides its Grid Engine (http://www.sun.com/software/gridware/get.html), and there's a Gnu toolkit called "Gnu Queue" (http://www.gnuqueue.org/home.html). Large software projects are often faced with loadbuild times that approach 24 hours. Is it possible to reduce the time required to build loads by applying concepts from distributed computing?</p><p>Many implementations of make, such as Gnu make and Rational's ClearMake (which is part of its ClearCase toolset; http://www.rational.com/products/clearcase/), automatically distribute a single loadbuild onto different workstations. In typical software development shops, each software developer has a powerful workstation on his or her desk. Typically, most of these desktop workstations are relatively idle&#151;developers are writing code, reading e-mail, or performing other tasks that consume little CPU or I/O resources. There are also many times during the day (and night) when people are not using their computers. Why not use this spare horsepower to build loads faster? In this article, I describe my experiences in converting a large software system to use Rational's distributed build technology on a cluster of networked Sun Solaris 2.6 workstations; however, these concepts are applicable to any distributed build implementation on any platform. (ClearMake also supports Windows.)</p><DDJADVERTISEMENT INLINE><p>Correctly written makefiles perform build avoidance, which means that most build times are not excessive since files that are not impacted by a code change are not recompiled. Unfortunately, there are situations where build avoidance is not enough. For example, changing low-level header files might force recompiles of all source files in the system. Also, there are times when you want to build cleanly to ensure you have a stable configuration. These situations are ideal candidates for distributed builds.</p><h3>Makefile Architectures</h3><p>Large software projects often have several hundred makefiles that are all invoked from one master makefile. There are two common ways to connect these makefiles: </p><ul>  <li>Recursive make. With this architecture, your project is divided into a series of directories containing subdirectories. Each directory has a makefile that builds the contents of the directory, and calls the makefile contained in each subdirectory. The traditional disadvantage of this approach is that you cannot represent dependencies between targets in different directories since the build dependencies are described in physically separate makefiles.  <li>Inclusive make. With this approach, your project is still divided into a series of directories containing subdirectories, however, most directories have an incomplete makefile that describes only the rules needed to build the software contained in that directory. If a directory has subdirectories, the makefiles in those directories are included into the parent directory's makefile via make's built-in <i>include</i> command. Since all the rules are present in one (very large) composite makefile, it is possible to represent dependencies between different directories.</ul><p>The recursive make architecture creates a unique problem for distributed builds. Each recursive call to make starts up a new round of parallel make processes with no knowledge that there are other parallel make processes running on the same machine. This causes an explosion in the number of build processes running on a given node, which greatly reduces build performance and can cause system crashes. I solved this problem by forcing every recursive makefile to always build serially via ClearMake's special .NOTPARALLEL target. This reduces performance somewhat, but most recursive makefiles do not actually perform any compiles (they just invoke other makefiles), so the performance penalty is not significant.</p><h3>Distributed Build Technology</h3><p>Before starting a distributed build, you must supply ClearMake with a list of workstations in the build pool and the maximum number of concurrent processes to launch across all machines. ClearMake uses the dependency information in your makefile to select targets that can be built on remote machines; for example, targets that do not depend on one another can be built in parallel. Next, ClearMake selects an idle machine from the pool and starts a remote build process using UNIX's <i>rsh</i> command. By checking the CPU load prior to building, ClearMake automatically performs load balancing across the pool of available workstations. So, when your coworker returns from lunch and fires up a CPU-intensive task on his workstation, ClearMake won't launch additional build processes on his machine until his CPU is idle again. Once all the nodes in the build pool are busy or the maximum number of concurrent processes has been reached, ClearMake waits for a build process to finish or for a machine to become free.</p><p>The build pool is relatively easy to configure. Each user must be able to run remote processes on each node; on UNIX systems, this is accomplished through a user's .rhosts file or through the system's hosts.equiv file. I used .rhosts in my testing. Obviously, each node in the pool must be able to access the source code and the build directories. After implementing distributed builds on UNIX systems, you must pay careful attention to the interactive and noninteractive portions of your login shell. Obviously, the remote builds will be running noninteractively (under <i>rsh</i>), so all environment variables and paths needed to compile must be setup in the noninteractive portion of your login shell. Equally true, the noninteractive portion of your login shell must not try to perform interactive operations. For example, one of my coworkers defined an alias for the UNIX <i>rm</i> command that forced <i>rm</i> to always request confirmation before deleting a file. Unfortunately, this alias was defined in the noninteractive section of the shell initialization file, so when a makefile running on a remote workstation attempted to delete (via <i>rm</i>) a temporary file, it waited indefinitely for someone to acknowledge the removal!</p><p>The list of machines in the pool is listed in the .bldhosts file, which is stored in your home directory. A series of command flags can also be given in the .bldhosts file. For example, you can set the CPU-free threshold for each machine using the <i>-idle</i> command. By default, ClearMake starts using the machines listed at the top of the .bldhosts file; however, you can instruct ClearMake to choose randomly instead by using the <i>-random</i> command. The <i>#include</i> command lets you include a file into the .bldhosts file. <A NAME="re1"><A HREF="0307ee1.htm">Example 1</A> is a typical .bldhost file.</p><p>In general, ClearMake build times are greatly influenced by a Rational network caching technology called "winking" (see the accompanying text box entitled, "ClearMake Advantages"). <A NAME="rt1"><A HREF="0307et1.htm">Table 1</A> identifies the observed performance improvements after distributed build technology was introduced into our environment with winking disabled and with winking enabled. Each test used a different number of CPUs and processes, and recorded the number of times that ClearMake waited (because all available CPUs were busy) and the total time required for the build. In other tests, I found that using more build processes than CPUs was not productive due to thrashing caused by task switching. Generally, as more CPUs are added to the pool, each CPU contributes less. These diminishing returns are caused by the dependencies in the makefiles&#151;you can't build the entire system in parallel because makefiles contain rules that say one part of the system should be built before another part.</p><h3>Distributed Build Disadvantages</h3><p>Although introducing distributed build technology into your organization improves build performance, distributed builds create some unique problems.</p><ul>  <li>If your network suffers from performance issues, then your builds also suffer. For example, a slow network causes slow builds, and unreliable networks can cause builds to fail. Because the network adds several new points of failure into your build environment, building in a distributed environment will always be less reliable than building on a single workstation.  <li>You will invest time to convert your existing makefiles. In particular, any errors in your makefiles will become more apparent after distributed builds are introduced. For example, if your makefiles are missing any important dependencies, your distributed builds will fail.  <li>On UNIX systems it is possible to create files with a "#" character in the filename. Because "#" starts a comment line in many UNIX shell scripting languages, many scripts cannot successfully read files containing a "#" character in the file name. In particular, Rational's distributed build scripts cannot build files whose names contain "#" characters. I solved this problem by renaming all of our files with "#" characters in their names.   <li>Software licensing should be considered. If you have purchased a fixed number of compiler licenses, distributed builds will cause your license consumption to increase. Before starting this type of project, you should ensure that software licensing is not a concern in your environment and purchase additional licenses if needed.</ul><h3>Conclusion</h3><p>Idle computers in your organization can be used to improve software developer productivity by reducing overall build times. In my environment, I was able to reduce build times by a factor of three. Distributed build technology is only useful when a build performs a large number of compile operations. If a build only performs a few compiles and a few links, then adding more processors will not improve performance.</p><p></p><p><b>DDJ</b></p></body></html>