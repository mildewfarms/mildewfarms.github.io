<html><head><title>Jul03: JELLY: An XML-Based Scripting Language</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>JELLY: An XML-Based Scripting Language</h1><p><i>Dr. Dobb's Journal</i> July 2003</p><h2>A glue language  written in Java</h2><h3>By Siegfried G&ouml;schl</h3><I>Siegfried is a software quality-assurance consultant and can be contacted at siegfried.goeschl@it20one.at.</I><hr><p>Jelly is a scripting language from the Jakarta community. Although implemented in Java, Jelly (http://jakarta.apache.org/commons/sandbox/jelly/) is designed to let you turn XML into executable code. Once you've imported the Jelly tag library, every JavaBean implementing Jelly's Tag interface can be turned into a Jelly Tag and used in Jelly scripts. Jelly can be used as a standalone scripting language or embedded in tools such as Maven (http://maven.apache.org/), the Jakarta Project's project management and build tool; or eQ!, a commercially available Java development platform from Browsersoft (http://www.browsersoft.com/).</p><p><A NAME="rl1"><A HREF="#l1">Listing One</A> is a "Hello World" program written in Jelly, while <A NAME="rl2"><A HREF="#l2">Listing Two</A> embeds the same functionality into a Java application that creates a Jelly instance, then loads and compiles the script. <i>JellyContext</i> is used to exchange variables between the application and the Jelly interpreter. After running the Jelly script, you get the result from <i>JellyContext</i>. <A NAME="rl3"><A HREF="#l3">Listing Three</A> is the executed Jelly script that creates the result variable with the value<i> Hello Dr. Dobb's Journal!!.</i></p><DDJADVERTISEMENT INLINE><p>Custom tag libraries let you extend Jelly functionality. In <A NAME="rl4"><A HREF="#l4">Listing Four</A>, for example, I use the <i>doTag</i> method in Jelly's Tag interface to implement a tag library containing two Jelly tags for Base64 encoding/decoding. <i>doTag()</i> retrieves the input value from either evaluating an expression or the XML body text. The resulting Base64-encoded string is written into <i>XMLOutput</i> or stored as the value of a variable. Since the Jelly interpreter needs to know about the new tags, a tag library associates a name with a class (<A NAME="rl5"><A HREF="#l5">Listing Five</A>). The corresponding Jelly script creates a variable <i>plainString</i> with the value "Foo Is Not Bar." The content of this variable is used to create the base64-encoded variable <i>base64String</i>. The Jelly interpreter finds two attributes&#151;<i>setValue() </i>and <i>setVar()</i>, both of which use reflection to resolve to the corresponding setters. To prove correctness, you can decode <i>base64String</i> by evaluating the XML body tag of <i>&lt;base64:decode&gt;</i> (<A NAME="rl6"><A HREF="#l6">Listing Six</A>), and <A NAME="rl7"><A HREF="#l7">Listing Seven</A> shows that Jelly has successfully been extended. In short, there's no need to roll your own tag library, since Jelly already comes with more than 30 tag libraries as part of the standard distribution.  </p><p>Of course, "Hello World" programs are one thing, and real-world applications quite another. To that end, Maven was selected by Together Teamloesungen (http://www.together.at/) as the project management and build environment for the company's insurance brokerage platform. Maven's core functionality involves automated project building, regression testing, deployment, and web-site creation. The Maven-generated web sites contain project description, documentation, and HTML reports, including software metrics, coding style checks, and JUnit regression test reports.</p><p>Since the company also needed automated web testing, it selected Canoo WebTest (http://webtest.canoo.com/), a functional web-testing tool based on HTTPUnit (http://httpunit.sourceforge .net/). Canoo WebTest provides ANT support because the tests scripts are actually executed by ANT (http://ant.apache.org/), but with no Maven integration. Since Maven's core functionality is implemented as plug-ins written in Jelly, Together Teamloesungen developers were able to write a plug-in that provided seamless integration of Canoo WebTest into Maven. (The Maven Canoo WebTest plug-in for Maven is available at http://maven-plugins/ sourceforge.net/.)</p><p>The requirements for a Canoo WebTest plug-in include being able to:</p><ul>  <li>Determine that all test scripts executed are based on regular expressions.  <li>Execute the test scripts using an ANT process.  <li>Transform the resulting test reports into HTML using XSLT.  <li>Create an XML test summary report to be transformed into HTML</ul><p><A NAME="rl8"><A HREF="#l8">Listing Eight</A> finds all the Canoo WebTest scripts to be executed. In line 1, a local variable <i>currSourceDir</i> is created; it contains the directory where the test scripts are located. Line 3 instantiates a file scanner that looks in the test script directory for all files matching the pattern defined in the Jelly variable <i>maven.webtest.file</i>. Test script files are executed using the ANT process in <A NAME="rl9"><A HREF="#l9">Listing Nine</A>. In line 1, the <i>forEach</i> statement iterates over the list of test scripts to be executed. In line 2, a Java process is created, where the classpath consists of predefined JAR files and all JAR files found in the plug-in directory. Passing system properties configures the newly created ANT process, and the variable <i>testScriptFile</i> contains the name of the test script to be executed. Executing a Canoo WebTest script generates an XML report, which is transformed to HTML using an XSLT processor. <A NAME="rl10"><A HREF="#l10">Listing Ten</A> highlights Jelly's power&#151;the file iterator returns a <i>java.io.File</i> object, not a string. Jelly invokes arbitrary methods on Java objects within the script. In line 13, the <i>File.getName()</i> method retrieves the name of the currently processed file.</p><p>An important feature is the creation of an XML test summary report reflecting the result of the individual tests. This is done with Jelly and its XML libraries, giving you the power of XML processing within a Jelly script. In line 1 of <A NAME="rl11"><A HREF="#l11">Listing Eleven</A>, the XML file "webtest-raw-report.xml" is created. The content of this file includes the previously generated Canoo WebTest XML reports. In line 6, you create an XML root element named "summary." Using an iterator, you load and parse the individual XML test reports (line 8) and extract the information using XPath expression applied to the parsed XML document.</p><p>Jelly is an exciting solution for enabling scripting in Java applications. It provides direct access to Java objects using reflection and is easily extended with custom tag libraries. Moreover, the resource consumption of an embedded Jelly interpreter is reasonable, adding only 4 MB to your memory usage and executing a compiled script in less than a millisecond. If you find yourself thinking of embedding a scripting language rather than hardwiring application logic, then Jelly might be the answer. </p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>&lt;?xml version="1.0"?&gt;&lt;j:jelly xmlns:j="jelly:core"&gt;   Hello World!&lt;/j:jelly&gt;</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>public class JellySample1{   public static void main(String[] args)   {      try      {         Jelly jelly = new Jelly();         jelly.setUrl( new File("scripts/hello_world.jelly").toURL() );         Script script = jelly.compileScript();         JellyContext context = new JellyContext();         context.setVariable("name", "Dr. Dobb's Journal");         script.run( context, xmlOutput );         System.out.println(context.getVariable("result"));     }     catch (Exception e)     {        e.printStackTrace();     }   }}</pre><P><A HREF="#rl2">Back to Article</A></P><H4><A NAME="l3">Listing Three</H4><pre>&lt;?xml version="1.0"?&gt;&lt;j:jelly xmlns:j="jelly:core"&gt;   &lt;j:set var="result" value="Hello ${name}!!"/&gt;&lt;/j:jelly&gt;</pre><P><A HREF="#rl3">Back to Article</A></P><H4><A NAME="l4">Listing Four</H4><pre>public class Base64EncodeTag extends TagSupport{   private String var;   private Expression value;   public void doTag(XMLOutput output) throws Exception   {      String input = null;      if ( value != null ) {         input = value.evaluateAsString(context);      } else {         input = getBodyText(false);      }      String result = new String(         Base64.encode(input.getBytes())         );      if ( var != null ) {         context.setVariable( var, result);      } else {         output.write(result);      }   }   public void setValue(Expression value) {      this.value = value;   }   public void setVar(String var) {      this.var = var;   }}</pre><P><A HREF="#rl4">Back to Article</A></P><H4><A NAME="l5">Listing Five</H4><pre>public class Base64TagLibrary extends TagLibrary{   public Base64TagLibrary()   {      this.registerTag( "encode", Base64EncodeTag.class );      this.registerTag( "decode", Base64DecodeTag.class );   }}</pre><P><A HREF="#rl5">Back to Article</A></P><H4><A NAME="l6">Listing Six</H4><pre>&lt;?xml version="1.0"?&gt;&lt;j:jelly   xmlns:j="jelly:core"   xmlns:base64="jelly:Base64TagLibrary"&gt;   &lt;j:set var="plainString"&gt;Foo Is Not Bar&lt;/j:set&gt;   &lt;base64:encode var="base64String" value="${plainString}"/&gt;   Plain string : ${plainString}   Base64 encoded : ${base64String}   Base64 decoded : &lt;base64:decode&gt;${base64String}&lt;/base64:decode&gt;&lt;/j:jelly&gt;</pre><P><A HREF="#rl6">Back to Article</A></P><H4><A NAME="l7">Listing Seven</H4><pre>Plain string : Foo Is Not BarBase64 encoded : Rm9vIElzIE5vdCBCYXI=Base64 decoded : Foo Is Not Bar</pre><P><A HREF="#rl7">Back to Article</A></P><H4><A NAME="l8">Listing Eight</H4><pre>1 &lt;j:set var="currSourceDir" value="${maven.webtest.src}"/&gt;23 &lt;fileScanner var="testScripts"&gt;4    &lt;fileset dir="${currSourceDir}"&gt;5       &lt;patternset&gt;6          &lt;include name="${maven.webtest.file}"/&gt;7       &lt;/patternset&gt;8    &lt;/fileset&gt;9 &lt;/fileScanner&gt;</pre><P><A HREF="#rl8">Back to Article</A></P><H4><A NAME="l9">Listing Nine</H4><pre>1 &lt;j:forEach var="testScriptFile" items="${testScripts.iterator()}"&gt;2    &lt;java classname="org.apache.tools.ant.Main"3          fork="yes"4          dir="${basedir}"5          failonerror="false"&gt;6       &lt;classpath&gt;7       &lt;fileset dir="${plugin.dir}/jars"&gt;8       &lt;include name="*.jar"/&gt;9       &lt;/fileset&gt;10      &lt;pathelement path="${plugin.getDependencyPath('ant')}"/&gt;11      &lt;pathelement ... /&gt;12      &lt;pathelement path="${plugin.getDependencyPath('xercesImpl')}"/&gt;13      &lt;/classpath&gt;14      &lt;sysproperty key="basepath" value="${maven.webtest.config.basepath}"/&gt;15      &lt;sysproperty ... /&gt;16      &lt;sysproperty key="verbose" value="${maven.webtest.config.verbose}"/&gt;17      &lt;arg value="-f"/&gt;18      &lt;arg value="${testScriptFile}"/&gt;19   &lt;/java&gt;20 &lt;/j:forEach&gt;</pre><P><A HREF="#rl9">Back to Article</A></P><H4><A NAME="l10">Listing Ten</H4><pre>1 &lt;j:forEach var="testSummaryFile"2    items="${testSummaries.iterator()}"&gt;3    &lt;echo&gt;Transforming ${testSummaryFile.getName()} into HTML&lt;/echo&gt;4    &lt;java classname="org.apache.xalan.xslt.Process" fork="yes"&gt;5       &lt;classpath&gt;6          &lt;pathelement path="${plugin.getDependencyPath('xercesImpl')}"/&gt;7          &lt;pathelement path="${plugin.getDependencyPath('xalan')}"/&gt;8          &lt;pathelement path="${plugin.getDependencyPath('xml-apis')}"/&gt;9       &lt;/classpath&gt;10      &lt;arg value="-in"/&gt;11      &lt;arg value="${testSummaryFile.toString()}"/&gt;12      &lt;arg value="-out"/&gt;13      &lt;arg value="${maven.docs.dest}/webtest/${testSummaryFile.getName()}.html"/&gt;14      &lt;arg value="-xsl"/&gt;15      &lt;arg value="${plugin.dir}/xslt/reportFromSummary.xsl"/&gt;16    &lt;/java&gt;17 &lt;/j:forEach&gt;</pre><P><A HREF="#rl10">Back to Article</A></P><H4><A NAME="l11">Listing Eleven</H4><pre>1 &lt;j:file2  name="${maven.build.dir}/webtest-raw-report.xml"3  outputMode="XML"4  encoding="ISO-8859-1"5  prettyPrint="true"&gt;6  &lt;x:element name="summary"&gt;7   &lt;j:forEach var="testSummaryFile" items="${testSummaries.iterator()}"&gt;8   &lt;x:parse var="xmlTestReport" xml="${testSummaryFile.toString()}"/&gt;9   &lt;x:set var="success" select="string($xmlTestReport/summary/testresult/@successful"/&gt;10  &lt;x:set var="starttime" select="string($xmlTestReport/summary/testresult/@starttime"/&gt;11  &lt;x:set var="endtime" select="string($xmlTestReport/summary/testresult/@endtime"/&gt;12  &lt;x:element name="test"&gt;13          &lt;x:element name="file"&gt;${testSummaryFile.getName()}&lt;/x:element&gt;14          &lt;x:element name="success"&gt;${success}&lt;/x:element&gt;15          &lt;x:element name="starttime"&gt;${starttime}&lt;/x:element&gt;16          &lt;x:element name="endtime"&gt;${endtime}&lt;/x:element&gt;17  &lt;/x:element&gt;18  &lt;/j:forEach&gt;19  &lt;/x:element&gt;20 &lt;/j:file&gt;</pre><P><A HREF="#rl11">Back to Article</A></P></body></html>