<html><head><title>May03: Dynamic Programming</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Dynamic Programming</h1><p><i>Dr. Dobb's Journal</i> May 2003</p><h2>Looking for "simply the best"</h2><h3>By Mark A. Pumar</h3><I>Mark is a principal software engineer at Raytheon ITSS in Pasadena, California. He can be contacted at Mark_Pumar@raytheon.com.</I><hr><p>Dynamic programming lends itself best to problems that can be decomposed into discrete steps or stages. By choosing the best course at each stage, it eliminates otherwise suboptimal or unprofitable avenues to arrive, after a finite number of steps, at the optimal solution. The ability to discard suboptimal solutions at each stage is known as the "principle of optimality." Richard Bellman stated this principle in <i>Dynamic Programming</i> (Princeton University Press, 1957) as follows:</p><p>An optimal policy has the property that whatever the initial state and the initial decisions are, the remaining decisions must constitute an optimal policy with regard to the state resulting from the first decision.</p><DDJADVERTISEMENT INLINE><p>For example, consider the problem of selecting the best route from, say, New York to San Diego; see <A NAME="rf1"><A HREF="0305af1.htm">Figure 1</A>. Suppose the best routes from Chicago, Denver, and Austin to San Diego are known. Each of these routes has an associated cost that reflects the notion of what is meant by best&#151;shortest, quickest, least expensive. Now consider a possible route that goes from New York to Washington D.C., then either to Chicago, Denver, or Austin. The principal of optimality states that no matter what route is taken to Washington D.C., the best route from there to San Diego is the one with the minimum cost.  </p><p>This route is easily found from examining the cost from Washington D.C. to Chicago, Denver, and Austin, and adding it to the cost of traveling to San Diego from each of these cities. The route with the overall lowest cost is best. Suppose, for the sake of concreteness, this is the route through Denver. Then the routes through Chicago and Austin can be eliminated from further consideration with respect to a route through Washington D.C. Thus, when examining routes from, say, New York to Philadelphia and Raleigh that pass through Washington D.C., it is no longer necessary to consider the routes from Washington D.C. to Chicago and Austin&#151;only the route to Denver is relevant since it has the lowest cost. This eliminates the need to keep recalculating the cost of the routes through Chicago and Austin, therefore reducing the amount of computation required to find the best route.</p><p>Algorithmically, dynamic programming works by decomposing the problem into a finite number of stages. Each stage contains the same set of discrete objects under consideration (a list of cities in the route-finding example). The cost of combining each item in the set, with the set of best combinations computed from the previous stage, is calculated. Using the principle of optimality, only the best combinations are saved, and the process repeats until the last stage is reached. The final set of best combinations, or strategies, is then examined and the one with the lowest cost is the optimal solution to the problem.</p><p>Mathematically, let <i>L={o<sub>1</sub>,...o<sub>N</sub>}</i> be a set of <i>N</i> objects and <i>Sm(n)</i> a set containing <i>n</i> of the objects from <i>L</i> where<i> n</i>£<i>N</i>. The set <i>S(n)={S<sub>m</sub>(n)}</i>0£<i>m</i>£<i>M</i> denotes the strategies at the <i>n</i><sup>th</sup> stage of the process with <i>M</i>£<i>N</i>. If the <i>o<sub>i</sub>ÅSm(n)</i> denotes the cost of combining the <i>i</i><sup>th</sup> object from <i>L</i> with the <i>m</i><sup>th</sup> strategy from <i>S(n)</i>, then <A NAME="re1"><A HREF="0305ae1.htm">Examples 1</A>(a) and 1(b) are True. </p><p><A NAME="re1"><A HREF="0305ae1.htm">Example 1</A>(a) is the mathematical statement of the principle of optimality and shows how each stage is computed from the previous stage in the process. <A NAME="re1"><A HREF="0305ae1.htm">Example 1</A>(b) gives the initialization of the first stage of the process. Thus, the first set of strategies each contains a single object from the set <i>L</i>. In essence, they are just to the objects in <i>L</i> and <i>S(</i>0<i>)=L</i>. The optimal solution, <i>s</i>, is found by selecting the strategy with the minimum cost from the final set in <A NAME="re1"><A HREF="0305ae1.htm">Example 1</A>(c).</p><p>Implementing a dynamic program requires the following steps:</p><p>1. Initializing the initial set of strategies with the set of input objects; see <A NAME="re1"><A HREF="0305ae1.htm">Example 1</A>(b).</p><p>2. Computing and saving the strategies at each stage according to <A NAME="re1"><A HREF="0305ae1.htm">Example 1</A>(a).</p><p>3. Finding the strategy with the minimum cost; see <A NAME="re1"><A HREF="0305ae1.htm">Example 1</A>(c).</p><p>4. Extracting the set of objects from the strategies with the minimum cost.</p><p></p><p>The last step is required because the strategies usually don't maintain a list of objects, but rather contain a single object and pointer to the best pairing strategy from the previous stage. It is, therefore, necessary to trace back through the strategies from each stage to extract the objects in the optimal solution set.  </p><h3>Implementation</h3><p><A NAME="re1"><A HREF="0305ae1.htm">Example 1</A> suggests that a general implementation of a dynamic programming (DP) algorithm is possible if the details of computing the cost between objects and strategies can be abstracted away from the generation and management of the strategies at each stage of the process. Fortunately, C++ is ideally suited for this kind of abstraction with its built-in support of polymorphism and inheritance. (I've compiled and tested all source code presented here under Windows 2000 using Microsoft Visual C++, and under Linux and HP UNIX using the gcc compiler. The complete source code is available electronically; see "Resource Center," page 5.) Both are used to achieve an implementation that works for a large number of practical problems for which DP is the solution method of choice.</p><p><A NAME="rl1"><A HREF="#l1">Listing One</A> is the header for the <i>DpSolution</i> class that implements <A NAME="re1"><A HREF="0305ae1.htm">Example 1</A>. This is not an abstract class, but rather makes use of the helper class <i>DpObject</i> (<A NAME="rl2"><A HREF="#l2">Listing Two</A>), which is abstract. The abstract class <i>DpObject</i> encapsulates the calculation of cost between objects, removing this detail from the DP solution class. The <i>DpSolution</i> class interface is small, consisting of a single constructor, destructor, and the <i>solve</i> function as its main components. </p><p>The class constructor (<A NAME="rl3"><A HREF="#l3">Listing Three</A>) handles the initialization of the class and the DP solution in <A NAME="re1"><A HREF="0305ae1.htm">Example 1</A>(b). A list of input objects is copied to a vector and an optional sort is performed. The sort is controlled by the last argument of the constructor.  </p><p>In some cases, the DP solution is facilitated by ordering the initial objects before beginning the calculation. After the sort, a matrix of strategies is initialized with the sorted input objects. <i>Typedefs</i> are used to define the matrix as a vector of vectors. This shifts most of the memory management from the class to the Standard Template Library. Unfortunately, some memory management is still required. In particular, the <i>DpObject</i> class (and its children) are required to provide a clone function used by the <i>DpSolution</i> class for making copies of the input objects. These copies are stored in the <i>m_stage</i> class data member, which holds the solution strategies.  </p><p>The class destructor deletes these objects when the class goes out of scope. In addition, the class constructor deletes the temporary copy of the input list used for the optional sort. After initialization, the <i>solve</i> function is called to compute and return the solution (as a list of <i>DpObjects</i>). <A NAME="rl4"><A HREF="#l4">Listing Four</A> is the <i>solve</i> member function. This function begins by checking that the number of stages is less than the number of objects; if not, a list containing the input objects is returned.</p><p>Next, the cost associated with the first-stage strategies is computed using the <i>evalInitialCost</i> member function from the <i>DpObject</i> class. This function allows initialization of the starting strategies with nonzero values, if necessary. Next, the cost associated with each strategy is computed for every stage in the process. The code:</p><blockquote><p>double c = m_stage[i][j]-&gt;</p><p>    evalCost(m_stage[i-1][k]) + </p><p>    m_stage[i-1][k]-&gt;cost();</p><p>if(c&lt;cmin) {cmin=c; partner=k;}</p></blockquote><p>in the innermost <i>For</i> loop is the implementation of <A NAME="re1"><A HREF="0305ae1.htm">Example 1</A>(a). The index to the strategy of the previous stage that yields the minimum overall cost is kept in the temporary variable <i>partner</i> and later stored as part of the strategy.</p><p>Once all the strategies have been computed, a final cost is added to the last-stage strategies using the <i>DpObject</i> class member function <i>evalFinalCost</i>. This accounts for any end-point or boundary conditions associated with the objects. If no such conditions exist, this function returns zero for the final cost. This computation is leveraged to find the lowest cost strategy that contains the optimal solution to the problem.</p><p>Finally, the trace-back calculation is performed to extract the objects from the strategies that comprise the optimal solution. Again, strategy contains a pointer (index) to a partner strategy from the previous stage. By starting with the lowest cost strategy at the final stage, these indices are traced back to the first stage and their associated objects are extracted. These extracted objects constitute the optimal solution and are stored in the list <i>ans</i>, which is returned at the end of the <i>solve</i> function.</p><p>The <i>DpSolution</i> class contains a few additional member functions for returning the number of stages and strategies (<i>stages</i>), and the individual strategies at each stage (<i>stage</i>), and for printing. Although these functions are not necessary, they are useful for examining and extracting substrategies and their solutions, if desired.</p><p><A NAME="rl3"><A HREF="#l3">Listings Three</A> and Four contain the general implementation of the DP algorithm. This code is devoid of the particulars of computing cost or the nature of the objects that constitute the problem. These details are encapsulated in the abstract class <i>DpObject</i>. The <i>DpObject</i> class defines the interface between the problem and method of solution, and contains three data members: <i>m_id</i>, a string for identifying the object; <i>m_cost</i>, the cost associated with the object and its partners; and <i>m_partner</i>, an index to a partnering object. The member functions: <i>string id(void), int partner(void), double cost(void), void setCost(double cost), </i>and<i> void setPartner(int index, int stage) </i>provide read/write access to these data members and are used by <i>DpSolution</i> to store/retrieve this information during the calculation.</p><p>The member functions <i>double evalCost(const DpObject </i>*<i>dp), double evalInitialCost(void), </i>and <i>double evalFinalCost(void) </i>return the costs associated with the objects during the calculation. These are all pure virtual functions and must be defined in the inheriting class. The <i>setPartner</i> function is overloaded to provide access to the chosen partner object during the storage of its index in case additional information about the partner is required during this phase of the process.</p><p>The operator functions <i>operator&gt;</i> and <i>operator&lt;</i> are also defined for use in sorting the initial list of objects. These functions are also pure virtual functions that must be defined in the inheriting class. Finally,<i> operator&lt;&lt;</i> is defined for printing the class. Also contained in the <i>DpObject</i> header is the inline function <i>DpObjectPtrLessThan,</i> which is used in the <i>sort</i> function in the <i>DpSolution</i> class constructor. <i></p><p>DpSolution</i> and <i>DpObject</i> are the basis for implementing the DP algorithm as a solution to a discrete optimization problem. The solution to an actual problem is computed by implementing a concrete class that inherits from <i>DpObject</i>, contains the details of the particular problem, and provides the required cost evaluation functions. This class is then used to construct an instance of the <i>DpSolution</i> class, and its <i>solve</i> member function is called to compute the desired solution. The work is therefore reduced to defining and implementing a class that contains the particulars of the problem of interest.</p><h3>Application</h3><p>To demonstrate <i>DpSolution</i> and <i>DpObject</i>, I present an example of tracking an astronomical object&#151;that is, a planet. The inputs to the problem are viewing intervals when the planet is physically observable from one or more fixed locations on the Earth. The objective is to provide a fixed number of viewing intervals (called "tracking passes"), which are uniformly distributed over a desired observation period. The uniformity of the intervals is found by minimizing <A NAME="re2"><A HREF="0305ae2.htm">Example 2</A>, where <i>T</i><i><sup>b </i></sup>and <i>T</i><i><sup>e </i></sup>are the beginning/ending of the desired observation period, respectively, and <i>t<sub>bi</sub></i> and<i> t<sub>ei</sub></i> are the beginning/ending of the <i>i</i><sup>th</sup> tracking pass. <A NAME="rf2"><A HREF="0305af2.htm">Figure 2</A> shows viewing intervals for Mars when it is within 60 million kilometers of Earth. Observers are located at three different sites that span the globe. </p><p>Assume that during the approximately 41 days when Mars is within 60 million kilometers of the Earth, you want to make 14 uniformly spaced observations. Determining the desired viewing intervals is done by creating a <i>TrackingPass</i> class (available electronically) that inherits from <i>DpObject</i>. The <i>TrackingPass</i> class implements all the virtual functions of the <i>DpObject</i> parent class. In particular, the member functions <i>evalInitialCost</i>, <i>evalCost</i>, and <i>evalFinalCost</i> implement <A NAME="re2"><A HREF="0305ae2.htm">Example 2</A> for computing the cost associated with each interval.  </p><p>The <i>TrackingPass</i> class contains four data members particular to this problem&#151;the beginning/ending times of the view interval (<i>m_begin</i> and <i>m_end</i>), and the beginning/ending times of the observation period (<i>m_refBeg</i> and <i>m_refEnd</i>, respectively). These intervals define the <i>t<sub>bi</sub></i>, <i>t<sub>ei</sub></i>, <i>T<sub>b</sub></i>, and <i>T<sub>e</sub></i> in <A NAME="re2"><A HREF="0305ae2.htm">Example 2</A>. The file ppp.cpp (also available electronically) is the calling program that combines all the classes, computes, and prints the solution. The data is contained in the header file TrackData.hpp for compactness; a more general implementation would probably read the viewing intervals from an external file.</p><p>The program begins by opening an output file for printing the results and declaring two lists of <i>DpObject</i> pointers, one to hold the input data and the other to hold the answers. Next, the input data is placed into <i>TrackingPass</i> objects and stored in the list declared earlier. The data in the input list is used to instantiate a <i>DpSolution</i> object along with the desired number of observations or passes. The data is then printed and deleted from memory. The <i>DpSolution</i> object's <i>solve</i> member function is called to compute the solution, and the contents are printed. This <i>solve</i> function returns a list of <i>DpObject</i> pointers in the previously declared list, prints it, and then deletes it. <A NAME="rf3"><A HREF="0305af3.htm">Figure 3</A> shows the results for the viewing intervals of <A NAME="rf2"><A HREF="0305af2.htm">Figure 2</A> and the cost function in <A NAME="re2"><A HREF="0305ae2.htm">Example 2</A>. </p><p>The intervals selected as part of the solution are in green and red, and intervals excluded are in white. Since the spacing between intervals for Observer #2 was the smallest of the three observers, the optimal solution (not surprisingly) consists almost exclusively of intervals from this site. Also, the chosen intervals are uniformly spaced with every third interval selected as part of the solution. The DP algorithm achieved the desired goals implicitly through the cost function (<A NAME="re2"><A HREF="0305ae2.htm">Example 2</A>). The algorithm itself has no explicit connection to the desired optimization goals. Changing the cost function is therefore equivalent to changing the desired goals. This is illustrated by the results in <A NAME="rf4"><A HREF="0305af4.htm">Figure 4</A>, where the cost has been modified to reflect a higher cost for using Observer #2, relative to the other two sites. </p><p>In this case, a fixed cost is added to <A NAME="re2"><A HREF="0305ae2.htm">Example 2</A> every time Observer #2 is selected. This cost reflects the additional expense of using this site. Again, intervals not selected as part of the optimal solution are in white, while selected intervals are red, blue, and green. In this case, Observer #1 is chosen to replace Observer #2 over approximately half of the observation period. This is not surprising since the time between viewing intervals for Observer #1 is less than for Observer #3. The choice of Observer #3 at the end is due to its close proximity to the end of the observation period. Different results can be achieved by modifying <A NAME="re2"><A HREF="0305ae2.htm">Example 2</A> to reflect whatever goals are desired with respect to viewing Mars during its period of close approach to the Earth. <A NAME="rf3"><A HREF="0305af3.htm">Figures 3</A> and <A NAME="rf4"><A HREF="0305af4.htm">4</A> illustrate some of the possibilities.</p><h3>Conclusion</h3><p>Dynamic programming has been widely applied to solve a variety of problems in science, engineering, and finance (see, for example,<i> Dynamic Programming and Modern Control,</i> by Richard Bellman and R. Kalaba, Academic Press, 1966). Like all optimization techniques, DP suffers from the so-called curse of dimensionality&#151;the number of computations increases geometrically with the size of the problem. The traveling salesman problem is perhaps the most famous example of this problem. As the number of cities visited increases, the size of the possible solution space increases astronomically, and the problem quickly becomes practically unsolvable even on the fastest computers. Although DP significantly reduces the size of the solution space, it is not immune to this effect, and large problems can easily consume exorbitant amounts of memory, CPU cycles, and time.</p><p>However, unlike other optimization techniques, DP does guarantee that the resulting solution is optimal. This should be contrasted with techniques such as branch and bound, which merely guarantee good, but not necessarily optimal, solutions. As such, DP is the algorithm of choice for many large optimization problems.</p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>// DpSolution.hpp. This class encapsulates the dynamic programming solution. // It uses the abstract class DpObject which contains the interface to the // problem and uses the functions in this interface to calculate the solution // to the problem. The class contains the following public functions:#ifndef _DP_SOLUTION#define _DP_SOLUTION #include &lt;list&gt;#include &lt;vector&gt;#include &lt;iostream&gt; #include "DpObject.hpp"class DpSolution{   public:      DpSolution(const list&lt;DpObject *&gt; &amp;dp, int N, bool sortList = true);     ~DpSolution(void);      list&lt;DpObject *&gt; solve(void);      int stages(void) const;      int stages(int stageNum) const;      DpObject * stage(int stageNum,int objectNum) const;      friend ostream&amp; operator&lt;&lt;( ostream&amp; os, const DpSolution&amp; dps );   private:      typedef vector&lt;DpObject *&gt; Strategy;      typedef vector&lt;Strategy&gt; Stage;      Stage m_stage;  // solution strategies};#endif</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>// DpObject.hpp. Abstract class definition for dynamic solution object. This // class defines the interface between the problem and the DpSolution class // which is used to determine the solution. Inheriting class are required to // define the following member functions:#ifndef _DPOBJECT_#define _DPOBJECT_#include &lt;string&gt;using namespace std;class DpObject{   public:     // constructors/destructor     DpObject(void);     DpObject(const DpObject &amp;tp);     virtual ~DpObject(void);     // member functions     string id(void) const;     int partner(void) const;     double cost(void) const;     DpObject *clone(void) const;     // cirtual functions     virtual void setCost(double cost);     virtual void setPartner(int index, int stage);     // Pure virtual functions     virtual bool operator&gt;(const DpObject &amp; dp) const = 0;     virtual bool operator&lt;(const DpObject &amp; dp) const = 0;     virtual void setPartner(int index, int stage, const DpObject *dp) = 0;     virtual double evalCost(const DpObject *dp) const = 0;     virtual double evalInitialCost(void) const = 0;     virtual double evalFinalCost(void) const = 0;     // friend functions     friend ostream&amp; operator&lt;&lt;( ostream&amp; os, const DpObject&amp; dp );   protected:      string m_id;          // object identifier      int    m_partner;     // object partner      double m_cost;        // object cost   private:      virtual DpObject *cloneDpObject(void) const = 0;      virtual void print(ostream&amp; os) const = 0;};// comparison function used for sortinginline bool DpObjectPtrLessThan(DpObject *dp1, DpObject *dp2) {   return(*dp1 &lt; *dp2);}#endif</pre><P><A HREF="#rl2">Back to Article</A></P><H4><A NAME="l3">Listing Three</H4><pre>// Constructor// Inputs:// const list&lt;DpObject *&gt; &amp;dp - object containing the problem definition// int                    N   - number of objects desired in solution// ABSTRACT: Initialize solution class for finding the problem solution. DpSolution::DpSolution(const list&lt;DpObject *&gt; &amp;dp, int N, bool sortList) {   // copy and sort input objects   Strategy p;   for(list&lt;DpObject *&gt;::const_iterator iter = dp.begin();                                                iter != dp.end(); ++iter)   {      p.push_back((*iter)-&gt;clone());   }   if(sortList) sort(p.begin(),p.end(),DpObjectPtrLessThan);   // create solution stages   m_stage.resize(N);   for(int i = 0; i &lt; m_stage.size(); ++i)   {     m_stage[i].resize(dp.size());     // store tracking passes     int j = 0;     for(Strategy::iterator iter = p.begin();                            (iter != p.end()) &amp;&amp; (j &lt; dp.size()); ++iter)     {        m_stage[i][j] = (*iter)-&gt;clone();        ++j;     }   }   // delete sorted list   for(Strategy::iterator piter = p.begin(); piter != p.end(); ++piter)   {      delete *piter;   }}</pre><P><A HREF="#rl3">Back to Article</A></P><H4><A NAME="l4">Listing Four</H4><pre>// Function: solve// Inputs: None// Returns: list&lt;DpObject *&gt; - list of objects in solution// ABSTRACT: Calculate and return list of object that from optimal solution list&lt;DpObject *&gt; DpSolution::solve(void) {  // check that solution is feasable   if(m_stage[0].size() &lt;= m_stage.size())   {  // no solution, return inputs      list&lt;DpObject *&gt; ans;      for(int j = 0; j &lt; m_stage[0].size(); ++j)      { ans.push_front(m_stage[0][j]-&gt;clone());}      return(ans);   }   // compute stage 1 (initial) strategy/cost   for(int j = 0; j &lt; m_stage[0].size(); ++j)   {      m_stage[0][j]-&gt;setCost(m_stage[0][j]-&gt;evalInitialCost());   }   // compute stage 2 to N-1 strategies/costs   for(int i = 1; i &lt; m_stage.size(); ++i)   {     for(int j = 1; j &lt; m_stage[i].size(); ++j)     {        double cmin = m_stage[i][j]-&gt;evalCost(m_stage[i-1][0]) +                                              m_stage[i-1][0]-&gt;cost();        int partner = 0;        for(int k = 1; k &lt; j; ++k)        {           double c = m_stage[i][j]-&gt;evalCost(m_stage[i-1][k])  +                                               m_stage[i-1][k]-&gt;cost();           if(c &lt; cmin) { cmin = c; partner = k; }        }        m_stage[i][j]-&gt;setCost(cmin);        m_stage[i][j]-&gt;setPartner(partner, i-1, m_stage[i-1][partner]);     }   }   // compute final stage N strategy/cost   double cmin = m_stage[m_stage.size()-1][0]-&gt;cost() +                         m_stage[m_stage.size()-1][0]-&gt;evalFinalCost();   int    imin = 0;   for(int k = 1; k &lt; m_stage[m_stage.size()-1].size(); ++k)   {     m_stage[m_stage.size()-1][k]-&gt;                       setCost(m_stage[m_stage.size()-1][k]-&gt;cost() +                       m_stage[m_stage.size()-1][k]-&gt;evalFinalCost());     if(m_stage[m_stage.size()-1][k]-&gt;cost() &lt; cmin)     {        imin = k;        cmin = m_stage[m_stage.size()-1][k]-&gt;cost();     }   }   // extract solution   list&lt;DpObject *&gt; ans;   int is = m_stage.size()-1;   while((imin &gt;= 0) &amp;&amp; (is &gt;= 0))   {      DpObject *tp = m_stage[0][imin]-&gt;clone();      tp-&gt;setCost(m_stage[is][imin]-&gt;cost());      tp-&gt;setPartner(m_stage[is][imin]-&gt;partner(),imin);      ans.push_front(tp);      imin = m_stage[is][imin]-&gt;partner();      --is;   }   return(ans);}</pre><P><A HREF="#rl4">Back to Article</A></P></body></html>