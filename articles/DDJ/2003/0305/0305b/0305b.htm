<html><head><title>May03: The SquareList  Data Structure</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>The SquareList  Data Structure</h1><p><i>Dr. Dobb's Journal</i> May 2003</p><h2>A self-adjusting  data structure</h2><h3>By Mark Sams</h3><I>Mark is a contract programmer for Adecco Technical. He can be contacted at msams@cableone.net.</I><hr><p>The SquareList is a self-adjusting data structure that performs basic tasks such as <i>insert</i>, <i>delete</i>, and <i>findmin</i>. The structure is particularly useful in applications that frequently require the minimum and maximum values, as they both can be found in constant time. The SquareList maintains a doubly linked list of doubly linked lists of bounded size. The arrangement of the lists is similar to a square 2D array. The SquareList is required to abide by specific rules that let it perform <i>insert/delete/find</i> operations, within a worst-case running time of <i>O(<IMG SRC="sqrt.gif" ALT="" WIDTH="13" HEIGHT="15">n)</i>.</p><p>The horizontal-linked list is comprised of one node from each of the vertical-linked lists. Those nodes are referred to as "top nodes." The design of the SquareList is such that the length of the list of top nodes will never be greater than<i> </i>[<i><IMG SRC="sqrt.gif" ALT="" WIDTH="13" HEIGHT="15">n</i>]. The list that is specific to each top node, the "vertical list," will also be restricted to the same depth limit of<i> </i>[<i><IMG SRC="sqrt.gif" ALT="" WIDTH="13" HEIGHT="15">n</i>] plus some constant <i>c.</i> </p><DDJADVERTISEMENT INLINE><p>As <A NAME="rf1"><A HREF="0305bf1.htm">Figure 1</A> illustrates, the handle on SquareList is the "head," which is the minimum node. The SquareList is always sorted, so the maximum node can be found by following two pointers from the head. Every value in the circular linked list of top nodes is less than the value of the node to the right, with the exception of the last top node in the list. Each vertical list is also sorted in ascending order. The child nodes in the vertical list are not connected to nodes in other vertical lists.</p><p>One of the interesting characteristics of the SquareList is the pointer that connects the top node to the bottom node in the vertical list. The purpose of this pointer is so the nodes can be shifted from one vertical list to another in constant time. The bottom node pointer serves an additional benefit as well: The maximum node can be located in constant time.</p><p>It is necessary to keep track of the number of elements in the SquareList so that the length of the top list and the depth of the vertical lists can be controlled. Each top node contains a variable that holds the depth of the vertical list, which is incremented when a node is added, and decremented when a node is deleted. The use of a member variable eliminates the necessity of traversing the list to determine the depth. </p><h3>Background</h3><p><A NAME="rt1"><A HREF="0305bt1.htm">Table 1</A> lists several commonly used data structures. The priority queue is a binary tree that has the property that the root is smaller than its children and the subtrees have the same property. When extracting the root (<i>min</i> value), two trees are created and must be combined. Finding the maximum node is less efficient because all the leaf nodes need to be visited. The main advantage skiplists have over binary trees is that there is no need to balance the list. Skiplists have fast and consistent operations. The binomial heap is a set of binomial heaps that have the heap property&#151;the key node is greater than the key of its parent. Binomial heaps also suffer from the disadvantage of having to search all of the leaf nodes to find the <i>max</i> value. Fibonacci heaps have an advantage in that they are able to perform operations that do not involve a <i>delete</i> in <i>O</i>(1) time. They are based on amortizing the amount of work to be performed. But from a practical perspective, Fibonacci heaps are less desirable because of the constant factors and because of their programming complexity.</p><h3>Inserting</h3><p>As <A NAME="rl1"><A HREF="#l1">Listing One</A> shows, inserting nodes into the SquareList is straightforward. When a new node is inserted into the SquareList, <i>findVertList</i> traverses the list of top nodes to find the vertical list in which the new node will be inserted. <i>putInVertList</i> places the node in the correct location in the vertical list. The depth of the top node of the current vertical list is then checked. If the depth is too great, the bottom node from that list is shifted to the top node of the list to the right. This progression continues recursively until a list is found with available space. This process is encapsulated in the <i>shiftRight</i> routine. If <i>shiftRight</i> is called and no space is found by the end of the SquareList, then either a new node is created or an analogous routine, <i>shiftLeft</i>, is called. The <i>shiftLeft</i> routine (<A NAME="rl2"><A HREF="#l2">Listing Two</A>) pushes the nodes back until space is found in the SquareList. <i>shiftLeft</i> moves the top node of the vertical list to the bottom node of the vertical list to the left. The depth of that list is compared to the <i>maxSize</i>, and if the depth is too deep, <i>shiftLeft</i> is called recursively.</p><p>The routines <i>shiftLeft</i> and <i>shiftRight</i> are required to run in <i>O(<IMG SRC="sqrt.gif" ALT="" WIDTH="13" HEIGHT="15">n)</i> time for <i>insert/delete</i> to run in <i>O(<IMG SRC="sqrt.gif" ALT="" WIDTH="13" HEIGHT="15">n)</i> time. The necessary adjustment of pointers is performed in constant time, but the number of times that <i>shiftLeft</i> or <i>shiftRight</i> could be called is [<i><IMG SRC="sqrt.gif" ALT="" WIDTH="13" HEIGHT="15">n</i>] if the entire list of top nodes needs to be traversed.</p><p>The variable <i>whichOp</i> is set to a constant, which determines the allowable variation in the depth. The value of <i>whichOp</i> depends on whether the calling routine is <i>delete</i> or <i>insert</i>. <i>shiftRight</i> is analogous to <i>shiftLeft</i>.</p><p>For example, assume that you want to insert "75" in <A NAME="rf2"><A HREF="0305bf2.htm">Figure 2</A>. The top nodes are traversed until the proper vertical list is found. The vertical list is then traversed until the node is placed in the appropriate location. After the node is inserted, the depth of the top node ("50") is checked. If the depth exceeds <i>maxSize</i> (in this case, four), then a call to <i>shiftRight</i> is made to decrease the depth of the list. <i>shiftRight</i> is called recursively until the depths of all lists are no longer than <i>maxSize</i>; see <A NAME="rf3"><A HREF="0305bf3.htm">Figure 3</A>.</p><p>The values in the vertical list are not each shifted down one position. Rather, the bottom node of one list becomes the top node of the next, and the bottom pointer is reset. This allows the time bound to be met.</p><p>The <i>shiftRight</i> routine is called again; see <A NAME="rf4"><A HREF="0305bf4.htm">Figure 4</A>. If it is called when the top node equals <i>head.getLeft</i>, a check is made to determine if the list is square. If the number of nodes is <i>square</i>+1, then a new node is added to the list of top nodes and <i>maxSize</i> is incremented by 1. If the list is not square, then <i>shiftLeft</i> is called until a list is found that has a depth less than <i>maxSize</i>; see <A NAME="rf5"><A HREF="0305bf5.htm">Figure 5</A>.<i></p><p>findVertList</i> examines the list of top nodes a maximum of [<i><IMG SRC="sqrt.gif" ALT="" WIDTH="13" HEIGHT="15">n</i>] times to find the correct vertical list. <i>putInVertList</i> examines, at most, [<i><IMG SRC="sqrt.gif" ALT="" WIDTH="13" HEIGHT="15">n</i>] nodes to find the appropriate location. To ensure the depths of the vertical lists are correct, <i>shiftRight</i> is called, at most, [<i><IMG SRC="sqrt.gif" ALT="" WIDTH="13" HEIGHT="15">n</i>] times, and <i>shiftLeft</i> could be called, at most, [<i><IMG SRC="sqrt.gif" ALT="" WIDTH="13" HEIGHT="15">n</i>] times, each of which run in constant time. While this may appear to be a cumulative running time of 4*[<i><IMG SRC="sqrt.gif" ALT="" WIDTH="13" HEIGHT="15">n</i>], the actual running time can be limited to 3*[<i><IMG SRC="sqrt.gif" ALT="" WIDTH="13" HEIGHT="15">n</i>] for a single <i>insert</i>. The running time for <i>insert</i> is <i>O(</i>[<i><IMG SRC="sqrt.gif" ALT="" WIDTH="13" HEIGHT="15">n</i>]<i>).</i></p><h3>Deleting</h3><p>Deleting is similar to inserting, although differences do exist. When a node is deleted, the depth of the vertical list is checked. If the depth of the list equals <i>maxSize</i>-1, then no modifications need to be made to the list. If the depth of the list equals <i>maxSize</i>-2 (or some constant <i>c</i>), then a node is shifted into the list to increase its depth; see <A NAME="rl3"><A HREF="#l3">Listing Three</A>. </p><p><i>Delete</i> must find the value of the node to be deleted. It begins by examining [<i><IMG SRC="sqrt.gif" ALT="" WIDTH="13" HEIGHT="15">n</i>] top nodes to find the appropriate vertical list. Then, [<i><IMG SRC="sqrt.gif" ALT="" WIDTH="13" HEIGHT="15">n</i>] nodes in the vertical list are searched to find the node. The removal of the node is simply a matter of manipulating pointers, so it is performed in constant time. The use of <i>delFixUp</i> yields a running time of <i>O(</i>[<i><IMG SRC="sqrt.gif" ALT="" WIDTH="13" HEIGHT="15">n</i>]<i>)</i>.</p><p>After the completion of a <i>delete</i> operation, <i>delFixUp</i> is called. If a deleted node had a depth equal to <i>maxDepth</i>, then <i>delFixUp</i> would not need to be executed. <i>delFixUp</i> does one of three things when called. If a list has a depth of <i>maxDepth</i>-2, then a search is performed for a list that has a depth of <i>maxSize</i>. When that list is found, then either <i>shiftLeft</i> or <i>shiftRight</i> is called to balance the depth of the list. If no lists are found to have a depth equal to <i>maxSize</i>, then a node is shifted from the last list into the list that is too short via <i>shiftLeft</i>; see <A NAME="rl4"><A HREF="#l4">Listing Four</A>.</p><p>The reason for requiring all vertical lists (except the last list) to be no shorter than <i>maxSize</i>-1 is so that when the list goes from <i>square</i>+1 to <i>square</i>, the deletion of one node results in a list that is perfectly square. <i>getFullList</i> returns the top node of the list with depth [<i><IMG SRC="sqrt.gif" ALT="" WIDTH="13" HEIGHT="15">n</i>]. A comparison is made between that top node and the deleted node. If the top node is smaller than the deleted node, then <i>shiftRight</i> is called to move nodes from the left to the right. If the top node is greater than the deleted node, then the nodes are shifted from right to left with the <i>shiftLeft</i> routine.</p><p>If the depth of a vertical list needs to be corrected, <i>getFullList</i> examines [<i><IMG SRC="sqrt.gif" ALT="" WIDTH="13" HEIGHT="15">n</i>] nodes in the list of top nodes. Then either <i>shiftRight</i> or <i>shiftLeft</i> is used to move the nodes, which have a stated running time of <i>O(</i>[<i><IMG SRC="sqrt.gif" ALT="" WIDTH="13" HEIGHT="15">n</i>]<i>)</i>.</p><h3>Testing</h3><p>To empirically test the data structure, I created a SquareList of size <i>n</i> before adding or deleting any nodes. I then performed three tests that involved inserting 100 nodes into the list. After the completion of those trials, I then executed three trials of deleting 100 nodes from the list. My strategy was as follows: Within the code, counters were placed inside loops. The counter was incremented with each iteration of the loop, and the value was returned upon completion. After creating the list, the counter was reset to 0. Then, 100 nodes were either inserted in or deleted from the list. For example, in trial number 1 with 1000 nodes, the first node was inserted into a list of 1000 nodes, and the 100th insertion was into a list with 1099 nodes. <A NAME="rt2"><A HREF="0305bt2.htm">Table 2</A> shows the data, while <A NAME="rf6"><A HREF="0305bf6.htm">Figure 6</A> graphs it. The average value of the counter for insertion and deletion is highlighted as well as the value of <i><IMG SRC="sqrt.gif" ALT="" WIDTH="13" HEIGHT="15">n.</i> The last two columns show the ratio of <i>insert</i> or <i>delete</i> as a ratio of <i><IMG SRC="sqrt.gif" ALT="" WIDTH="13" HEIGHT="15">n</i>.</p><h3>Conclusion</h3><p>Clearly, there are changes you could make to improve the efficiency of the SquareList. For instance, <i>findVertList</i> could search left or right to find the appropriate vertical list. If users know in advance that data will be somewhat ordered, this could be a significant advantage. Alternatively, <i>putInVertList</i> could search from the bottom up as well as from the top down to find the correct location of a node. The SquareList may also be more efficient if calls to <i>shiftLeft</i> and <i>shiftRight</i> are delayed until a time that requires that the list be "squared." Programmers could also implement dummy nodes to make the implementation more convenient.</p><h3>Acknowledgement</h3><p>Thanks to Dr. John C. Lusth for his guidance on this project.</p><p></p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>void insert(int value){    slNode toAdd = new slNode(value);    size++;    if(size == 1)        head = toAdd;    else    {        slNode temp = findVertList(toAdd);        putInVertList(temp, toAdd);    }    updateMaxDepth();}</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>private void shiftLeft(slNode top, int whichOp){    slNode temp = new slNode(top.getValue());    top.setValue(top.getChild().getValue());    if(top.getDepth() == 2)        top.setChild(top);    else    {        top.setChild(top.getChild().getChild());        top.getChild().setParent(top);    }    top.changeDepth(-1);    slNode left = top.getLeft();    temp.setParent(left.getBottom());    left.getBottom().setChild(temp);    temp.setParent(left.getBottom());    left.setBottom(temp);    left.changeDepth(1);    if(tooDeep(left, whichOp))        shiftLeft(left, whichOp); }   </pre><P><A HREF="#rl2">Back to Article</A></P><H4><A NAME="l3">Listing Three</H4><pre>public int delete(int value){    slNode top = new slNode(findVertList(value));    slNode toDelete = findInVertList(top, value);    if(toDelete == null)        return -1;    size--;    // Top node     if(toDelete.getParent() == null)        deleteParentNode(toDelete);    // Bottom node in sublist    else if(toDelete.getChild() == toDelete)        deleteBottomNode(top);    // Found node in sublist    else         deleteMiddleNode(top, toDelete);    updatemaxDepth();    delFixUp ();    return value;}</pre><P><A HREF="#rl3">Back to Article</A></P><H4><A NAME="l4">Listing Four</H4><pre>private void delFixUp (slNode theTop){    // Nothing needs to be done.    if(theTop.getDepth() == maxDepth -1)        return;    slNode temp = getFullList();    if(temp.getValue() &gt; theTop.getValue())        // This situation should only occur if the list goes from        // square + 1 to square        if((temp == head.getLeft()) &amp;&amp; (temp.getDepth() == 1))        {            // Move the last node left one list            putInVertList(temp.getLeft(), temp);            // Only want to shiftLeft if node is not placed in the short list            if(theTop != temp.getLeft())                shiftLeft(temp.getLeft(), ONE);            // Set the respective pointers            head.setLeft(temp.getLeft());            temp.getLeft().setRight(head);    }        else shiftLeft(temp, ONE);    else if(temp.getValue() &lt; theTop.getValue())        shiftRight(temp, ONE);          else ;  // Do nothing.  Depths of lists are appropriate}</pre><P><A HREF="#rl4">Back to Article</A></P></body></html>