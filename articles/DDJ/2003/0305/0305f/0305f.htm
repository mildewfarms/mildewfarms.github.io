<html><head><title>May03: Graph Canonicalization</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Graph Canonicalization</h1><p><i>Dr. Dobb's Journal</i> May 2003</p><h2>Generating unique  representations of graphs</h2><h3>By Brian Kelley</h3><I>Brian is a software engineer at the Whitehead Institute for Biomedical Research. He can be contacted at bkelley@wi.mit.edu.</I><hr><p>Graph structures are used in applications ranging from representations of molecules in chemistry to analysis of computer network topology. Graph canonicalization is the process of forming a unique text representation for a graph, thereby enabling quick text-based searching without resorting to time-consuming isomorphism algorithms. In this article, I introduce a generic method for graph canonicalization that you can adapt to different graph representations. </p><p>The SMILES chemistry language was created to solve problems in chemoinformatics, including representation of molecules for database storage (see "SMILES: A Chemical Language and Information-System," by D. Weininger, <i>Journal of Chemical Information and Computer Sciences,</i> 1988). One of the main problems with database searches for duplicate compounds is that the same molecular graph can be input in many different ways ("six chemists, seven representations"). One of the properties of SMILES is the so-called "canonical smiles output," which is a unique representation for a molecular graph. This technique was used to produce unique database keys for quick discovery of duplicated compounds. This canonical graph representation is also used to produce consistent depictions of molecules. Daylight Chemical Information Systems (http://www.daylight.com/smiles/) created and maintains the SMILES language. </p><DDJADVERTISEMENT INLINE><p>The SMILES algorithm is adapted to solve the canonicalization problem for graphs where the vertices and edges are labeled with any label that can be sorted, such as arbitrary text strings. Graphs that have attributes for vertices and edges are referred to as "labeled" or "colored" graphs. <A NAME="rf1"><A HREF="0305ff1.htm">Figure 1</A> shows two such labeled graphs, both equivalent but represented differently. Here, I present a Python implementation that forms a unique ordering of nodes and edges for arbitrarily labeled graphs.</p><h3>Algorithm</h3><p>The graph representation used is straightforward. A graph contains vertices and edges, and a vertex can be traversed through an edge to its adjacent neighbors; see <A NAME="rl1"><A HREF="#l1">Listing One</A>. Both the vertex and the edge are objects that have attributes and methods. For computation purposes, all attributes are stored in arrays such that the first vertex's equivalence class is stored in the equivalence class array position 0, and so on. Once properties have been computed, they are assigned back as attributes of the vertex and edge objects.  </p><p>If all the vertices in a given graph have unique properties, the solution to the graph canonicalization is trivial&#151;you simply sort the vertices, then use the sorted vertices to uniquely sort the edges of the graph. A problem arises, however, when two different vertices have the same label or properties. This happens in chemistry where two different atoms may have the same atomic properties, or could be as simple as a molecular graph of DNA that is composed of repeating copies of the same subunits. In these cases, the only difference between two atoms in a molecular graph may be the surrounding topology. In other words, the only difference between two vertices may be the vertices to which they are connected, and a different technique is required to create a unique representation for such graphs. <A NAME="rl2"><A HREF="#l2">Listing Two</A> is a relatively complete graph implementation using extensions of basic Python types.</p><p>The canonicalization algorithm computes three new attributes&#151;an equivalence class, symmetry class, and symmetry order&#151;for each vertex in the graph. The equivalence class is a unique integer value for each vertex or edge label; however, if two vertices or edges have the same label, then they belong to the same equivalence class. Given the equivalence classes, a symmetry class is calculated using the topology or structure of the graph. If two vertices have the same symmetry class, then they are topologically indistinguishable from each other. In other words, two members of the same symmetry class have the same surrounding symmetry in the graph; see <A NAME="rf1"><A HREF="0305ff1.htm">Figure 1</A>(b). A symmetry order is then computed that generates a unique order for every vertex in the graph. This unique order breaks ties between two vertices with the same symmetry class and ensures that no matter how the vertices in a graph are input, the canonical ordering for vertices with the same surrounding topology will be the same. In other words, a symmetry order ensures a unique representation for the graph. Again in <A NAME="rf1"><A HREF="0305ff1.htm">Figure 1</A>(b), the algorithm needs to determine whether the edges <i>A-b-C</i> should be output before the edge<i> A-d-C,</i> even though their respective end vertices have the same equivalence class and the same symmetry class. Finally, outputting nodes and edges in order of their symmetry orders generates a unique graph representation. <A NAME="re1"><A HREF="0305fe1.htm">Example 1</A> shows the basic steps of the algorithm.</p><h3>Computing the Equivalence Class</h3><p>With this background, the algorithm is deceptively simple. The first step is assigning an equivalence class to each vertex. This is done by sorting the set of unique vertex labels, then assigning the equivalence class for a vertex as the sorted position of the vertices label plus one. The same process is used to generate an equivalence class for each edge; see <A NAME="rl3"><A HREF="#l3">Listing Three</A>. (I use the term "node" for coding, and "vertex" for discussion of the algorithm.)</p><h3>Computing the Symmetry Class</h3><p>Computing symmetry classes is an iterative procedure. At every step, a new symmetry class is generated for each vertex and the process continues until the symmetry classes stabilize for all vertices. At each iteration, the goal is to take identical symmetry classes and determine if the surrounding topology of the corresponding vertices are different. If the algorithm determines a difference in topology, these ties are broken and a new symmetry class is added to the graph. Each iteration propagates these changes in symmetry classes to their surrounding vertices. An oversimplification is that the algorithm asks the question, "Are the neighboring vertices at a distance of one different?" and, "Are the vertices neighboring vertices at a distance of two different?"&#151;continuing until these differences cannot be found. The source code for the canonicalization class is available electronically; see "Resource Center," page 5.</p><p>To determine if neighboring topologies are different between two vertices, the current symmetry orders are sorted and replaced with their corresponding primes. Because prime numbers cannot be factored, the products of the corresponding primes of the vertices' neighbors are guaranteed to be unique for different sets of neighbors. The same is done for generating the corresponding primes from an edge's equivalence class, although this is done only once since the edge values are static.</p><p>In brief, the algorithm is: Initialize the symmetry class by setting it to the vertices equivalence class. The iterative procedure is then: First, the current symmetry classes are ranked and each node is marked with the symmetry class's corresponding prime number. For example, the lowest current symmetry class is assigned 2, the third lowest is assigned 5, and so forth. I don't use 0 or 1 as primes. The symmetry class ranking is detailed in the rank method of <i>GenerateSymmetryClasses</i>. Second, a neighbor value for each vertex is computed by multiplying the products of the corresponding prime of its neighbors and the corresponding prime of the edge traversed to reach the respective neighbor. The neighbor value is used to break ties in the symmetry classes. If two nodes have the same symmetry class but different neighbor values, then they are not topologically the same. The vertex with the largest neighbor value has its symmetry class incremented by one and all vertices with larger symmetry classes are also incremented by one. This is done for all symmetry class ties. This procedure is repeated until the new symmetry classes are equivalent to the previous iteration's symmetry classes, i.e., no new symmetry classes are added to the graph. The final set of symmetry classes is called an invariant in that no matter how the graph is input, each vertex with the same surrounding topology will have the same invariant symmetry class. This is detailed in the <i>findInvariant</i> method <i>GenerateSymmetryClasses</i>.</p><p><A NAME="rf2"><A HREF="0305ff2.htm">Figure 2</A> is a contrived example of determining the symmetry class using this algorithm using a simple graph that stabilizes in one iteration. I start off with the labeled graph in <A NAME="rf2"><A HREF="0305ff2.htm">Figure 2</A>(a) and, by sorting the node labels and edges labels, create the initial symmetry classes in <A NAME="rf2"><A HREF="0305ff2.htm">Figure 2</A>(b). Now there are two nodes with a symmetry class of 1, so I use their neighbors to see if these nodes are topologically distinct. The symmetry classes are converted to their corresponding primes, <A NAME="rf2"><A HREF="0305ff2.htm">Figure 2</A>(c). Then by analyzing their neighboring symmetry classes, I can determine if these two nodes are topologically equivalent. Since in <A NAME="rf2"><A HREF="0305ff2.htm">Figure 2</A>(d) they aren't equivalent, I generate a new symmetry class and increment all higher classes by one resulting in <A NAME="rf2"><A HREF="0305ff2.htm">Figure 2</A>(e). This process iterates back to generating the new corresponding primes until the symmetry classes converge. In this case, there are no symmetry class ties, so ordering in <A NAME="rf2"><A HREF="0305ff2.htm">Figure 2</A>(e) is the stable ordering, and no more iterations are required.</p><h3>Computing the Symmetry Order</h3><p>As an initial pass, the symmetry class of a vertex yields symmetry orders. Since the definition of symmetry order is a unique number for each vertex, symmetry class ties must be broken. Because the symmetry class is invariant with respect to topology, ties can be broken arbitrarily. Invariance with respect to topology means that if two nodes have the same symmetry class, then it makes no difference which node comes first in the output. The symmetry orders are broken by finding the lowest repeated symmetry class and arbitrarily adding 1 to one of the ties and all symmetry classes of higher value. This is repeated until no ties remain. The result is called "invariant partitioning," in which the order of the symmetry orders defines a canonical ordering of the graph's nodes. The details are shown in the <i>findInvaritantPartitioning</i> method of <i>GenerateSymmetryClasses</i> (see the canonicalization class, available electronically).</p><p>If edges are not labeled, then the initial pass in creating the symmetry orders is all that is necessary. The vertices in the graph can be output in the order of their symmetry orders, and the output order for edges can be determined by the symmetry orders of their endpoints. For example, an edge with symmetry class endpoints of (0, 3) is output before one with endpoints (1, 3).</p><p>Determining the order when edges are labeled is slightly trickier. In <A NAME="rf3"><A HREF="0305ff3.htm">Figure 3</A>, the two vertices labeled "<i>A</i>" have exactly the same symmetry class and the vertices labeled "<i>C</i>" also have exactly the same symmetry class.  However, because the edges are labeled, we need to choose which edge comes first. In <A NAME="rf3"><A HREF="0305ff3.htm">Figure 3</A>, I need to distinguish edge "<i>b</i>" from edge "<i>d</i>." A simple traversal algorithm solves this problem by traversing the graph starting from the lowest symmetry order, proceeding to the next lowest symmetry order through the edge with the lowest equivalence class and continuing until all vertices and edges have been visited. The order in which an edge and vertex then visited determines the final symmetry order. <A NAME="rl4"><A HREF="#l4">Listing Four</A> shows the recursive procedure.</p><p>Using this traversal algorithm yields an extended benefit; the traversal itself can be used to form the output representation. Daylight uses this technique for generating the canonical SMILES output. For example, the representation of benzene in the SMILES language is "<i>c1ccccc1</i>". The lowercase "<i>c</i>" represents a carbon in the aromatic state and the number 1 represents a closure, which indicates that the two atoms are connected. To see an implementation of the SMILES language, or if you are interested in chemoinformatics, go http://frowns.sourceforge.net/ or http://www.daylight.com/. </p><h3>Conclusion</h3><p>Given a large enough graph, the product of a vertex's neighboring corresponding primes can overflow a 32-bit integer. One of Python's features is that it automatically converts overflowing integers to arbitrarily long integers. Implementations in statically typed languages will have to take this potential into account. Isospectral graphs will not form a canonical ordering. I cannot say how frequent these graphs are but I have not encountered them during the analysis of several millions graphs averaging about 500 vertices each.</p><p>The examples included in the code (available electronically) have a couple of utilities to read/write simple types of graphs, including a bare-bones GraphML (http://graphml.graphdrawing.org/) parser and formatter that you can adapt as needed. The current implementation of the algorithm has only been tested with undirected graphs but should be easily modified to support directed graphs.</p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>for node in graph:    # for every node in g traverse to their    # adjacentNeighbors and edges    for adjacentNode, traversalEdge in node.neighbors():        print adjacentNode, traversalEdge</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>"""One of the best ways to store graphs in python is with a dictionary object.g = {}Nodes in a graph are the keys in a dictionary and the edges are the values.To traverse through the nodes in a graphfor n in g:   # do something with the nodeto traverse through key and edge valuesfor n,e in g.items()to traverse through edge valuesfor n in g.values()"""from types import DictTypeclass Graph(DictType):    def nodes(self):        return self.keys()    def edges(self):        _edges = {}        for neighbor in self.values():            for edge in neighbor.values():                _edges[edge] = 1        return _edges.keys()    def iternodes(self):        """iterate through the nodes"""        return self.iterkeys()    def neighbors(self, node):        """(node) -&gt; return the (node, edge) pairs for a given        node"""        return self[node].items()    def iterneighbors(self):        """iterate through the neighbors of a node"""        return self.iteritems()    def addNode(self, node):        self[node] = self.get(node, {})        node.setParent(self)    def addEdge(self, n1, n2, edge):        # assumes n1 and n2 are already in a node        try:            assert not self[n1].has_key(n2)            assert not self[n2].has_key(n1)            self[n1][n2] = edge            self[n2][n1] = edge        except KeyError:            raise GraphError("One of the edge nodes is not in the graph")from weakref import proxyclass Base:    def __init__(self, label):        self.label = label        self.equiv_class = -1        self.symorder = -1        self.symclass = -1        self.parent = None    def setParent(self, parent):        self.parent = proxy(parent)    def __hash__(self):        return id(self)    def __cmp__(self, other):        return cmp(self.label, other.label)    def __str__(self):        return self.label    def __repr__(self):        return "%s(%s)"%(self.__class__.__name__, `self.label`)class Node(Base):    def neighbors(self):        return self.parent.neighbors(self)class Edge(Base):    pass</pre><P><A HREF="#rl2">Back to Article</A></P><H4><A NAME="l3">Listing Three</H4><pre>"""computes equivalence classes for atomsGenerateEquivClasses(graph)"""def GenerateEquivClasses(graph):    """(graph) -&gt; given a graph, generate the equivalence classes for the     nodes and edges of the graph by assigning a unique number to uniquely     labeled nodes and edges.  The nodes and edges must be sortable"""        # sort and rank the Nodes and Edges    for labeledObject in [graph.nodes(), graph.edges()]:        # sort the objects based on their label attribute        labeledObject.sort(lambda x,y: cmp(x.label, y.label))        last = None        rank = -1        for ob in labeledObject:            if ob.label != last:                # increment the rank                rank = rank + 1            ob.equiv_class = rank            last = ob.label</pre><P><A HREF="#rl3">Back to Article</A></P><H4><A NAME="l4">Listing Four</H4><pre>"""Recursively traverse a graph building up a canonical representation.Each vertex of a Molecule or Graph must have a attribute 'symorder' whichis a unique number. This number guarantees only one traversal forthe graph. Additionally each edge must have an attribute equiv_class which isa unique value for each different type of bond. This guaranteesproper canonicalization of edges as well as vertices.usagegenerateSymmetryOrders(graph)"""def _traverse(node, prevNode, visitedNodes, visitedEdges, nodes, edges):    visitedNodes[node] = 1    nodes.append(node)    edgeIndex = 0    edgesToTraverse = []    for onode, edge in node.neighbors():                if prevNode is not None and onode is prevNode:            # we are traversing back the way we came! so don't...            pass        elif visitedNodes.has_key(onode):            # a closure!            # traverse.addClosure(node, onode, edge)            edges.append(edge)            visitedEdges[edge] = 1        else:            edgesToTraverse.append((onode.symorder, edge.equiv_class,                                              edgeIndex, onode, edge))        edgeIndex += 1    if not edgesToTraverse:        # dead end, return        return    edgesToTraverse.sort()    for symorder, edgeEclass, index, onode, oedge in edgesToTraverse:        if visitedNodes.has_key(onode):            # somehow, we've seen this node so skip it            continue        edges.append(oedge)        visitedEdges[oedge] = 1        _traverse(onode, node, visitedNodes, visitedEdges, nodes, edges)def _get_lowest_symorder(nodes):    best = nodes[0]    for node in nodes[1:]:        if node.symorder &lt; best.symorder:            best = node    return bestdef generateSymmetryOrders(graph):    """(graph) -&gt; traverse the symmetry classes in order of the    smallest edge equiv_classes to generate symmetry orders"""    node = _get_lowest_symorder(graph.nodes())    visitedNodes = {}    visitedEdges = {}    nodesUsed = []    edgesUsed = []    _traverse(node, None, visitedNodes, visitedEdges, nodesUsed, edgesUsed)    i = 0    # set the symmetry orders of the nodes and edges    for n in nodesUsed:        n.symorder = i        i += 1    i = 0    for edge in edgesUsed:        edge.symorder = i        i += 1        </pre><P><A HREF="#rl4">Back to Article</A></P></body></html>