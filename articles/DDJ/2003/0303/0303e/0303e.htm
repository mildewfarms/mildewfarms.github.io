<html><head><title>Mar03: Programmer's Toolchest</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>The SmlMC  Model Checker</h1><p><i>Dr. Dobb's Journal</i> March 2003</p><h2>Verifying that implementation meets the design specs</h2><h3>By Wouter Boeke</h3><I>Wouter formerly worked in the R&amp;D department of Lucent Technologies. He can be contacted at w.m.boeke@chello.nl.</I><hr><p>Model checking is a method for verifying whether an implementation satisfies a design specification. To model check a system, you must first create a model from which you can derive the system states and the transitions between those states. Furthermore, you must also be able to describe some properties of the system. If the verification tool can show that the state/transition structure satisfies the properties, it is referred to as a "model checker." </p><p>Models and properties are usually expressed in special-purpose languages. The model checker parses the model description code, examines the semantics, and enumerates all states and transitions; likewise with the properties. However, SmlMC, the model checker I present here, takes a different approach&#151;its model and properties are specified in the Standard ML (SML) programming language (http://www.diku.dk/users/tofte/publ/tips.ps). The advantage of this approach is that users have greater freedom in writing the model by using all kinds of data types, as well as access to structuring and debugging options provided by a real programming language. (On the downside, it's not always possible to implement state reduction techniques, which are often necessary because of the enormous number of states that can be reached with model checkers. If, for instance, three independent processes can each be in 100 states, then together they form a transition system with 1 million states!) </p><DDJADVERTISEMENT INLINE><p>Features that functional languages such as SML provide&#151;which procedural languages like C++ don't&#151;include:</p><ul>  <li>Variables that keep their value as long as they are reachable.  <li>Undeceivable type checking at compile time, yet you do not have to specify types. They are inferred by the compiler.  <li>Functional values that can be specified and used like any other value.  <li>Polymorphism through pattern matching.  <li>No crashes at run time.</ul><p>SML implementations differ with respect to libraries and compilation strategy. For this project, I chose Moscow ML (http:// www.dina.kvl.dk/~sestoft/mosml.html) because, apart from being well designed, some components in its library are coded in C, facilitating the access of internal data structures. This yields a hash table that works for arbitrary data types. Without the polymorphic hash function, SmlMC users would have to write dedicated hash functions for each new data type that they use.</p><h3>Event-Driven Process Synchronization</h3><p>Suppose, as in <A NAME="rf1"><A HREF="0303ef1.htm">Figure 1</A>, there are three communicating processes. Further, suppose that several events by which the global state may be modified are pending. If an event fires, the global system state is evaluated and stored in a hash table if it is a new state. However, it is also possible that the events are known to occur at (or about) the same moment, although their relative order is unknown. In this case, all pending events are fired in some order, and at the end the new global state is evaluated. Next, a backtrack to the old state is performed, after which all pending events are fired again, but in a different order. This goes on until all permutations in the order of events have been exercised.</p><p>What happens when many events are pending, as the number of permutations will grow with a factorial rate? You could say that the state explosion in other model checkers is replaced by a computation explosion. SmlMC addresses this by making a limited number of random choices between all possible permutations. The threshold where this occurs is user specified. </p><p>What happens between the events? In all likelihood, some calculations are done. With most model checkers, after each atomic calculation the global state is recalculated because, for example, interaction via global variables can occur. Hence, impressive numbers of states may be reported. With SmlMC, I assume that calculations are always atomic and performed in zero time between events.</p><p>To illustrate the reduction of the number of states that can occur, consider the Leader Election Protocol, a well-known benchmark for model checkers. In the case of five interconnected nodes, the (reduced) state space, as reported by the model checker Spin (see "The Spin Model Checker" by Gerald J. Holzmann, <i>DDJ</i>, October 1997), is 3008 states (without property checking). With SmlMC, the number of states is 1445 if all states are stored individually, and 8 if events are supposed to be concurrent and applied with all permutations as previously described. The choice between the two modes of operation is controlled by the Boolean value <i>with_timing</i> (<A NAME="rl1"><A HREF="#l1">Listing One</A>).</p><h3>The Algorithm</h3><p>What makes one model checker different from another is the way processes communicate. Communication is usually accomplished via FIFO queues with zero, bounded, or infinite length. However, this approach has the disadvantage that mutual exclusion constructs and buffer overflow must often be modeled&#151;both of which are considered too low level for a decent model checker. The way processes communicate in SmlMC is borrowed from Lotos (an ISO standard language), where two or more processes synchronize via common "gates" and possibly instantaneously interchange data in any direction. Consequently, users need to organize their model as follows: </p><p></p><ul>  <li>A number of components that contain data, but cannot manipulate these data themselves.  <li>A number of events that can fire if they are activated. An event is stateless and has access to the data of all components. It can replace this data with new content. It can reactivate itself or other events, if needed, with a delay.</ul><p>Conceptually, the components are the blocks in <A NAME="rf1"><A HREF="0303ef1.htm">Figure 1</A>, whereas the events are the connections between them.</p><p><A NAME="rl1"><A HREF="#l1">Listing One</A> is an SmlMC file that models a buffer that is filled and emptied. (The complete SML source code for SmlMC is available electronically; see "Resource Center," page 5.) The line starting with <i>val</i> <i>buffer</i>, where a value of type <i>Component</i> is declared, is a reference that can be reassigned. Two events (<i>e1</i> and <i>e2</i>) are declared. These are also references, initialized to a <i>no-operation</i> functional value. Later, the events are reassigned by function <i>init_ev</i> and placed in vector <i>events</i>.</p><p>In the body of the functional value assigned to <i>e1,</i> there is the line <i>if n &lt; 3 then buffer := Buffer{cnt=n+1}</i>. In SML, a record always has to be fully specified&#151;a partial assignment is impossible. The line <i>act</i> <i>e1</i> reactivates event <i>e1</i> after it has been fired. Running the program only starts if at least one event has been activated; this is done in <i>val _ = (act e1;act e2)</i>. The last line in <A NAME="rl1"><A HREF="#l1">Listing One</A> specifies how the generated states have to be displayed on the screen.</p><p><A NAME="rl1"><A HREF="#l1">Listing One</A> is the user-defined part. Also required are two common files: SmlMC_head.sml, which contains definitions, and SmlMC_gen.sml, where states, transitions, and other output are generated. The three files are compiled with <i>make,</i> controlled by a standard makefile. An executable is generated that, when run, writes the output as in <A NAME="rl2"><A HREF="#l2">Listing Two</A>.</p><p>As you can see, all states (<i>sta:</i>) and transitions (<i>tra:</i>) are listed in a single output. This is also true for other generated information. The idea is to perform postprocessing on the output by piping it through grep, sed, or awk in case simple inspection isn't enough. </p><p>Nondeterministic choice is a standard feature of model checkers. In this case, it is performed by specifying an event differently: Normally, for instance, you write <i>ev ev1 fv1</i> where <i>ev1</i> is an event and <i>fv1</i> a functional value. The code: </p><blockquote><p>ev ev1 fv1,</p><p>ev_choice ev2 [fv20,fv21,fv22],</p><p>ev ev3 fv3</p></blockquote><p>is expanded internally into three sequences (each that will be permuted):</p><blockquote><p>fv1 - fv20 - fv3</p><p>fv1 - fv21 - fv3</p><p>fv1 - fv22 - fv3</p></blockquote><p>Different functionalities can be specified in <i>fv20</i>, <i>fv21</i>, and <i>fv22</i>. </p><p>Normally, an event is activated by something like <i>act e1</i>. It can also be activated after a delay (for instance, <i>act_timed e1 3</i>), then the event is placed in a timing queue. At run time, the head of this timing queue is used as the new list of activated events. Of course, no real delays are involved; they're only symbolic.</p><p>Backtracing is another standard model-checking feature. Backtracing makes it possible to list the traversed states from the current state back to the start state, and is activated by calling function <i>backtrace</i>. This is usually done if some test yields an interesting result. In SmlMC, states are searched breadth first, so the shortest path will always be reported.</p><p>The global state consists of:</p><ul>  <li>The values of the passive components.  <li>A list of the activated events.  <li>A list of future events in the timing queue. </ul><p>These parts are taken together and stored as a key in a hash table. A hash table from the SML library doesn't make copies of keys, which implies that keys must be of an immutable data type. So your components may contain vectors and lists, but no references or arrays.</p><p>Value <i>perm_max</i> controls the maximum number of permutations between concurrent events. For example, if <i>perm_max</i> is set to 4, then at most 4<i>!=</i>24 random choices between all possible permutations will be performed. </p><h3>Model Checking</h3><p>Two dominant logics exist to express properties to be checked: LTL and CTL, both of which specify paths through the states. Formulas in these logics are transformed to state/transition structures and their intersections with the state/transition structure of the model is calculated. In this project, it is done differently: Properties are described using components and events just like for the model.</p><p>To check the property of a path through the state space, one special event (<i>path_test</i>) is activated at the end of each event firing cycle. By default, <i>path_test</i> does nothing and should be reassigned. Arbitrary path properties can be checked, like "Value <i>X</i> first will be 2, then 4, then keep that value forever." </p><p>Final states can also be checked. In <A NAME="rf2"><A HREF="0303ef2.htm">Figure 2</A>, which depicts a hypothetical state/transition structure, different cases can be distinguished:</p><ul>  <li>State 0 is the start state.  <li>State 2 has no successor, it will be reported as a deadlock.  <li>States 4, 5, and 6 can always be reached from each other. In graph theory these are called strongly connected components.  <li>States 7, 8, 9, and 10 are also strongly connected, and at that they cannot be left. This is an example of a live lock; I call these states final.  <li>State 3 is a single final state.</ul><p>Eventually, a system always cycles through one of the groups of final states. So if users are interested in the "steady state" of their model, then they should have the ability to traverse the groups of final states. This is provided by the <i>reach_test</i> function that, by default, does nothing and should be reassigned. Then properties can be checked like, "The system will always halt after an alarm" or "Value Y will stay constant after the initialization phase."</p><p>This functionality is only provided if variable <i>model_check</i> has been set to true. This is because users often want to see only a listing of the states and transitions.</p><h3>An Example: Checking the SSM Protocol</h3><p>The SSM telecom protocol ensures that interconnected network elements are clocked by one single clock source&#151;the highest quality clock available within the network. Since cable breaks are anticipated, the elements are connected into rings. The widely used SSM protocol is interesting here because it is flawed: It is possible that a network element thinks it receives a high-quality clock&#151;thus synchronizes its internal clock to this external one&#151;whereas it actually is originating from its own clock. Consequently, the clock frequency will start to slowly drift away.</p><p><A NAME="rf3"><A HREF="0303ef3.htm">Figure 3</A> shows a ring of four network elements. <A NAME="rl3"><A HREF="#l3">Listing Three</A> is the complete model together with the properties to be checked. The quality of the SSM signal ranges from <i>PRC</i> to <i>undef</i>. To enforce a default synchronization direction, the ports of a network element are provisioned with a priority, ranging from <i>pr_1</i> to <i>dis</i>. Activation of events is arranged like this: If event <i>w1</i> has fired, then component <i>ne1</i> probably will have been modified. So event <i>w1</i> should activate <i>w2</i> and <i>w11</i> because these are dependent on <i>ne1</i>'s data.</p><p>In this example, two disturbances are modeled. As a first case, the connection between network elements <i>ne1</i> and <i>ne2</i> can break, after which the system should stabilize toward a different configuration. In the second one, the clock source connected to <i>ne0</i> might fail. In this case, the internal clock of one of the network elements should take control (quality-level <i>SEC</i>). Now model checking reveals "Clocking loop found!" if the cable breaks and the clock fails in a certain sequence. This is a simplified model for a simple network. It is also possible that several rings of network elements are interconnected. </p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>open SmlMC_headval with_timing = falseval model_check = falsedatatype Component =  Buffer of { cnt:int }val buffer = ref(Buffer{cnt=0})val components = #[ buffer ]val (e1,e2) = (nop(),nop())val get_b = fn ref(Buffer d) =&gt; dval events = init_ev[ ev e1  ( fn() =&gt;    ( let val n = #cnt (get_b buffer)      in        if n &lt; 3 then buffer := Buffer{cnt=n+1} else ()      end;      act e1    )  ),  ev e2  ( fn() =&gt;    ( let val n = #cnt (get_b buffer)      in        if n &gt; 0 then buffer := Buffer{cnt=n-1} else ()      end;      act e2    )  )]val _ = ( act e1; act e2 )val print_comp = fn  Buffer{cnt=n} =&gt; pr.printq `buffer(^(pr.d n))`</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>start: buffer(0)  sta: 0 - buffer(0) ev:2  sta: 1 - buffer(0) ev:1  tra: 0 1  sta: 2 - buffer(1) ev:1  tra: 0 2  sta: 3 - buffer(2) ev:1  tra: 2 3  tra: 1 1  sta: 4 - buffer(3) ev:1  tra: 3 4  tra: 4 45 states</pre><P><A HREF="#rl2">Back to Article</A></P><H4><A NAME="l3">Listing Three</H4><pre>structure dut = structlocal  open SmlMC_headinval with_timing = trueval model_check = trueval _ = perm_max := 3val (PRC,SEC,DNU,undef) = (4,3,2,1)val (pr_1,pr_2,pr_3,dis) = (4,3,2,1)type Ssm = { ql:int }datatype Component =  Clock of Ssm| Ne of string * int * Ssm * Ssm * Ssm * Ssm        (* id,q,in1,in2,out1,out2 *)| Con of boolstructure ne = struct  val get = fn ref(Ne t) =&gt; t | _ =&gt; err "Ne"  fun set this f = this := Ne(f(get this))  fun id   t = #1 (get t)  fun q    t = #2 (get t)  fun in1  t = #3 (get t)  fun in2  t = #4 (get t)  fun out1 t = #5 (get t)  fun out2 t = #6 (get t)enddatatype Var_Fix =  Ne_vf of { var:Component ref, fix:{ prov:int Vector.vector,                                                     i3:Component ref } }val get_con = fn ref(Con on) =&gt; on | _ =&gt; err "get_con"val get_ck = fn ref(Clock d) =&gt; d | _ =&gt; err "get_ck"val [ck,w1,w2,w3,w4,w11,w12,w13,w14,con] = List.tabulate(10,fn _ =&gt; nop())val dummy = { ql=undef }val clock = { ql=PRC }val no_clock = ref(Clock dummy)val okay = ref(Con true)val ck1=ref(Clock clock)val con1=ref(Con true)fun init id = (id,0,dummy,dummy,dummy,dummy)val (ne0,ne1,ne2,ne3) =( Ne_vf{ var=ref(Ne(init "ne0")),                             fix={ prov= #[0,dis,pr_2,pr_1], i3=ck1 } },  Ne_vf{ var=ref(Ne(init "ne1")),                             fix={ prov= #[0,pr_1,pr_2,dis], i3=no_clock } },  Ne_vf{ var=ref(Ne(init "ne2")),                             fix={ prov= #[0,pr_1,pr_2,dis], i3=no_clock } },  Ne_vf{ var=ref(Ne(init "ne3")),                             fix={ prov= #[0,pr_1,pr_2,dis], i3=no_clock } })val components =  let fun get (Ne_vf{ var=v, ...}) = v  in #[ ck1,get ne0,get ne1,get ne2,get ne3,con1 ]  endval \ = fn(a,c) =&gt; Vector.sub(a,c)infix 9 \fun for(a,b,f) = if a&gt;b then () else (f(a); for(a+1,b,f))datatype Sig_flow = o1_i1 | o2_i2fun ne_update (Ne_vf snd) (Ne_vf rcv) sig_flow con =  let  fun sel_alg({ql=ql1},{ql=ql2},{ql=ql3},q) =    let      val ql = #[undef,ql1,ql2,ql3]      val q = ref q      val prov = #prov(#fix rcv)    in      if prov\(!q) = dis orelse ql\(!q) &lt;= DNU then q := 0 else ();      for (1,3,fn p =&gt;        if prov\p &lt;&gt; dis andalso ql\p &gt; DNU andalso           ( ql\p &gt; ql\(!q)             orelse             ql\p = ql\(!q) andalso prov\p &gt; prov\(!q)           )        then q := p        else ()      );      (ql\(!q),!q)    end  val (i1,i2) = if sig_flow = o1_i1    then (if (get_con con) then ne.out1(#var snd) else dummy,ne.in2(#var rcv))    else (ne.in1(#var rcv),if (get_con con) then ne.out2(#var snd) else dummy)  val (ql_in,q) = sel_alg(i1,i2,get_ck(#i3(#fix rcv)),ne.q(#var rcv))  val (ql_out,q) = (if ql_in &lt; SEC then (SEC,0) else (ql_in,q))  val (out1,out2) =    case q of        3 =&gt; ({ ql=ql_out }, { ql=ql_out })      | 2 =&gt; ({ ql=DNU },    { ql=ql_out })      | 1 =&gt; ({ ql=ql_out }, { ql=DNU })      | 0 =&gt; ({ ql=ql_out }, { ql=ql_out })      | _ =&gt; err "q"  in    ne.set (#var rcv) (fn(id,_,_,_,_,_)=&gt;(id,q,i1,i2,out1,out2))  endfun evn(snd,rcv,sflow,act1,act2,on) =  fn() =&gt;  ( ne_update snd rcv sflow on;    act act1; act act2  )val events = init_ev[ ev_choice ck [ fn() =&gt; (ck1 := Clock dummy; act ck),                 fn() =&gt; (ck1 := Clock clock; act ck)               ],  ev w1  (evn(ne0,ne1,o1_i1,w2,w11,okay)),  ev w11 (evn(ne1,ne0,o2_i2,w1,w14,okay)),  ev w2  (evn(ne1,ne2,o1_i1,w3,w12,con1)),  ev w12 (evn(ne2,ne1,o2_i2,w2,w11,con1)),  ev w3  (evn(ne2,ne3,o1_i1,w4,w13,okay)),  ev w13 (evn(ne3,ne2,o2_i2,w3,w12,okay)),  ev w4  (evn(ne3,ne0,o1_i1,w1,w14,okay)),  ev w14 (evn(ne0,ne3,o2_i2,w4,w13,okay)),  ev_choice con [ fn() =&gt; (con1 := Con false; act con),                  fn() =&gt; (con1 := Con true; act con)                ]]val _ = (  act w1; act con; act ck;  reach_test :=  ( fn init =&gt;    let      val getq = fn Ne_vf ne =&gt; ne.q(#var ne)      val q0 = getq ne0      val rec all_eq = fn        [] =&gt; false | [x] =&gt; x = q0 | x::xs =&gt; x = q0 andalso all_eq xs    in      if all_eq [getq ne1,getq ne2,getq ne3]      then      ( print "Clock loop detected!\n";        backtrace();        BasicIO.exit 0      ) else ()    end  ))val print_comp = fn  Clock{ql=n} =&gt; pr.printq `ck1(ql=^(pr.d n)) `| Ne d =&gt;  let val r=ref(Ne d) in    pr.printq `^(ne.id r)(q=^(pr.d(ne.q r)) `;    pr.printq `o1=^(pr.d(#ql(ne.out1 r))) o2=^(pr.d(#ql(ne.out2 r)))) `  end| Con on =&gt; pr.printq `con1(^(if on then "on" else "off")) `end end</pre><P><A HREF="#rl3">Back to Article</A></P></body></html>