<html><head><title>Mar03: Generalized Callbacks:  C++ and C#</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Generalized Callbacks:  C++ and C#</h1><p><i>Dr. Dobb's Journal</i> March 2003</p><h2>Comparing C++'s libsigc++ class library to C#'s delegate feature </h2><h3>By William F. Humphrey</h3><I>Bill holds a Ph.D. in Physics from the University of Illinois and is currently a developer for Proximation LLC. He can be contacted at bill @kiboko.com.</I><hr><p>Callbacks are techniques for implementing dynamic selection and invocation of functions at run time. In C, the address of a callback function can be stored in a variable for invocation at some later time; see <A NAME="rl1"><A HREF="#l1">Listing One</A>. A number of packages build on this concept to implement generalized callback mechanisms. These systems let multiple callback targets be bound to abstracted callback containers (acting as events or signals), and generalize the type of callback targets that can be bound to include functions, static methods, nonstatic methods, and more. The techniques used to implement these features vary from package to package and language to language, giving you a choice between systems with different feature sets, performance characteristics, and interfaces.</p><p>In this article, I examine two technologies that implement generalized, extensible callback mechanisms in C++ and C#. In doing so, I compare the libsigc++ class library in C++ to the <i>delegate</i> feature in C#, focusing on the different features and interfaces they provide. The libsigc++ library is available under the LGPL license from http://libsigc.sourceforge.net/, while implementations of C# are available from Microsoft (http://msdn.microsoft.com/) or the Mono project (http://www.go-mono.com/). I've tested the sample libsigc++ Version 1.2 code presented here with the Gnu C++ compiler 2.95.2, and the C# <i>delegate</i> code with Microsoft Visual Studio .NET using the Microsoft C# 1.0 compiler.</p><DDJADVERTISEMENT INLINE><p>While I focus on libsigc++ and C# delegates, there are several C++ packages that support generalized callbacks using techniques or features similar to those described here, including the Boost Signals library (http://www.boost.org/). </p><h3>Basic Libsigc++ and C# Callbacks</h3><p>With callback techniques, you register references to a callable target entity with some callback container at run time, so that the target can be invoked at later times and with varying arguments. In languages with object-oriented support (C++, C#, and Java, for instance), this pattern can be implemented using polymorphic entities, like that for C++ in <A NAME="rl2"><A HREF="#l2">Listing Two</A>. Polymorphic designs use abstract interfaces that define virtual functions implemented by derived classes. The virtual functions and polymorphic class instances represent the callback targets while the abstract interfaces represent the items to which callback containers store references and use to invoke the callback. This strategy limits the types of targets that can be registered as callbacks to virtual functions within classes that implement the proper interface. To register other functions or methods that would be useful as callback targets, you must write adapters that implement the abstract interface and call the alternative target, or modify the desired target to expose the required interface.</p><p>In most cases, requiring a specific interface to be implemented for all callback targets is exactly what is desired. For some systems, however, such as generalized frameworks or libraries designed to work with a wide variety of external software packages, it is useful to be able to register many different types of executable callback targets with a callback container, such as global functions, nonstatic and static methods of a class. This is the purpose of the libsigc++ library in C++, and the delegate mechanism in C#.</p><p>The libsigc++ library lets you define C++ <i>Signal</i> objects templated on a return type and on the types of arguments for a callback. A <i>Signal</i> is a callback container that can store any number of references to different callback targets. The name "Signal" points to one of the intended purposes for this class&#151;to act as a generator of signals that interact with the connected callbacks at certain times. You can include <i>Signals</i> in a class, and connect callbacks to the <i>Signal</i> objects within instances of that class to obtain notification when the instance emits those <i>Signals</i>. <A NAME="rl3"><A HREF="#l3">Listing Three</A> is an example of adding a <i>Signal</i> to a class simply as public member data. <i>Signal</i> is templated on the return type of the callback and the types of each callback argument, and there is actually a family of templated <i>Signal</i> classes&#151;<i>Signal0</i>, <i>Signal1</i>, and so on&#151;that work with different numbers of arguments.</p><p>Libsigc++ <i>Signals</i> can be connected to any number of <i>Slot</i> objects that act as generic wrappers around callback targets, using the <i>Signal::connect</i> method. <i>Slots</i> provide an abstraction for many different types of callback targets&#151;global functions, static methods, nonstatic methods, even other <i>Slots</i>. </p><p><A NAME="rl4"><A HREF="#l4">Listing Four</A> provides examples of connecting callbacks to the <i>Signal</i> object created in <A NAME="rl3"><A HREF="#l3">Listing Three</A>. Just like <i>Signals</i>, <i>Slots</i> are templated on the return type and argument types of the callback, and there is a family of <i>Slot</i> classes <i>Slot0, Slot1, </i>and so on. The main restrictions on the use of <i>Slots</i> are that the <i>Slot</i> template parameters must match those of the <i>Signal</i> to which it connects, and a class must inherit from <i>SigC::Object</i> for its nonstatic methods to be used in a <i>Slot</i> connected to a <i>Signal</i>.</p><p>Callbacks in a <i>Signal</i> can be invoked at any time by emitting the signal </p><blockquote><p>sample.signalobj.emit(1, 2.0); </p></blockquote><p>or by simply treating the <i>Signal </i>as a functor<i> </p><blockquote><p>sample.signalobj(1, 2.0);</p></blockquote><p></i><i>Slot</i> objects also implement <i>operator()</i> and can be used as functors that invoke the underlying callback target that they wrap. Emitting a <i>Signal</i> simply invokes all connected <i>Slots</i> in the order they were added.</p><p>When a connection is made between a <i>Slot</i> and a <i>Signal</i>, a <i>Connection</i> object that manages this connection is returned. You can sever the association by calling the<i> disconnect() </i>method on the relevant <i>Connection</i> object (<A NAME="rl4"><A HREF="#l4">Listing Four</A>).</p><p>By comparison, C# provides a feature known as "delegates" to accomplish a similar task. Delegates can store a list of callback targets and invoke them when requested. They are declared using the <i>delegate</i> keyword; see <A NAME="rl5"><A HREF="#l5">Listing Five</A>. You create and use <i>delegate</i> objects in C# classes in much the same way that libsigc++ <i>Signal</i> objects are used in C++; in fact, C# defines an <i>event</i> keyword that reads suspiciously like a signal and is used to create delegates with certain restrictions on their use outside the owning class.</p><p>The declaration of <i>SampleDelegate</i> in <A NAME="rl5"><A HREF="#l5">Listing Five</A> defines a new <i>delegate</i> type, much like the <i>typedef</i> declaration of <i>SampleSignal_t</i> in <A NAME="rl3"><A HREF="#l3">Listing Three</A>. <i>SampleDelegate</i> can now be used to define <i>delegate</i> instances that work with callbacks that have the <i>SampleDelegate</i> type signature. The <i>delegate</i> keyword is simply shorthand for declaring a new subclass of the <i>System.MulticastDelegate</i> class. C# <i>delegate</i> objects and libsigc++ <i>Signal</i> objects are both callback containers, storing references to callbacks of the specified type and capable of invoking them at later times. </p><p>To store references to callback targets, C# reuses the same <i>delegate</i> object instead of using a separate class, as is done in libsigc++ with the <i>Slot</i> objects. To connect a new callback to an empty <i>delegate</i>, you simply assign it a new instance of that <i>delegate</i> type initialized with the callback function, or use the += operator to connect an additional callback to the same delegate. You can connect static or nonstatic methods, as in <A NAME="rl6"><A HREF="#l6">Listing Six</A>. A callback can be disconnected by using the -= operator, which requires a reference to the originally added callback delegate or a new instance that refers to the same callback target. This differs from the libsigc++ strategy, which returns <i>Connection</i> objects when a <i>Slot</i> is connected to a <i>Signal</i>, and uses <i>Connection::disconnect</i> to break the connection. The libsigc++ solution is more flexible in some situations&#151;it lets users connect the same callback target to a <i>Signal</i> multiple times, while C# <i>delegates</i> can only store one reference to a target. C# <i>delegates</i>, just like libsigc++ <i>Signals</i>, act like functors, so that you can invoke all the registered callbacks by treating the delegate like a function: </p><blockquote><p>sample.delegateobj(1, 2.0);.</p></blockquote><h3>Additional  Callback Techniques</h3><p>The libsigc++ library includes an API for defining <i>Signal</i> and <i>Slot</i> objects of different numbers of arguments, and for easily generating adapter <i>Slots</i> that can do things such as bind additional arguments to a callback expecting more arguments than the signal emits, or connect one <i>Signal</i> to another. Similarly, C# <i>delegates</i> have an API that may be used to perform more advanced callback operations. </p><ul>  <li>Automatic callback cleanup. What happens when a callback target is no longer valid, for example a callback that refers to a method in an object that has been deleted? For libsigc++, a class that makes its nonstatic methods available for connection to a <i>Signal</i> must inherit from <i>SigC::Object</i>, allowing the library to keep track of all the <i>Signals</i> to which a <i>SigC::Object</i> entity is connected. When that object is deleted, libsigc++ automatically disconnects all <i>Slots</i> that refer to its methods. Similarly, <i>Signals</i> disconnect from all <i>Slots</i> that they contain when it is deleted.<p>		In contrast, C# does not perform automatic <i>delegate</i> disconnection. When a nonstatic method for a class is registered with a <i>delegate</i>, the container creates a new reference to that instance, so the object will not be deleted by the garbage collector until it is removed from the delegate. To avoid potential unwanted dangling references, you may want to take extra care to always explicitly disconnect all callbacks that you add to a delegate.</p>  <li>Chaining callback containers. You can chain one libsigc++ <i>Signal</i> object to another by creating a <i>Slot</i> object that wraps around the target <i>Signal</i>, like the following code:<blockquote><p>Signal1&lt;void, int&gt; s1, s2;</p><p>s1.connect(s2.slot());</p></blockquote> <p> Here, emitting <i>Signal s1 </i>also invokes <i>Signal s2</i> and all callbacks connected to it. The generic nature of <i>Slots</i> and the template facilities of C++ makes this fairly easy to implement.</p><p> 	C# <i>delegates</i> can also be easily chained together. Since a <i>delegate</i> is both a container of other <i>delegates</i> and a wrapper around a callback target, you can simply add one <i>delegate</i> to another:</p><blockquote><p>SimpleDelegate d1 = </p><p>       new SimpleDelegate(Class1.method);</p><p> SimpleDelegate d2 = </p><p>       new SimpleDelegate(Class2.method);</p><p>  d2 += new SimpleDelegate(Class3.method);</p><p>d1 += d2;</p></blockquote><p> When <i>d1</i> is invoked, it calls <i>Class1.method,</i> then invokes <i>d2 </i>that in turn calls <i>Class2.method</i> and <i>Class3.method</i>.</p>  <li>Mismatched argument types or counts. Consider the problem that may arise if you are using an external library that uses one of these callback packages to provide <i>Signal</i> or <i>delegate</i> containers, and you need to connect callback targets that are part of another external package. The targets may not exactly conform in the types of arguments, return values, or the number of arguments. One solution is to write adapters that map from the type of <i>Signal/delegate</i> to the type of the callback. Can you avoid this extra work?<p>  		Libsigc++ provides a number of templated adapters that do just this. Adapter functions such as the following generate new <i>Slot</i> objects that wrap around an existing <i>Slot</i> to adapt it to a different use:<i></p><p> 		Slot1&lt;RT,T1&gt; bind&lt;T2&gt;(Slot2&lt;RT,T1, T2&gt; </i>&amp;,<i> T2 </i>&amp;<i>extra) </i>lets you connect a callback <i>Slot</i> that takes two arguments to a <i>Signal</i> that emits just one argument. The extra argument is specified in the <i>bind</i> call; the returned <i>Slot1</i> stores the original <i>Slot2</i> and the extra argument. Invoking the new <i>Slot1</i> with the smaller number of arguments results in the wrapped <i>Slot2</i> being called with the extra argument included at the end. Similar bind calls work with <i>Slots</i> of different argument counts.</p><p> 		<i>Slot2&lt;RT,T1,T2&gt; hide&lt;T1&gt;(Slot1&lt;RT, T1&gt; </i>&amp;<i>)</i> does the oppose of <i>bind</i>&#151;it drops one of the arguments emitted from a <i>Signal</i>.</p><p> 		<i>Slot1&lt;RT,NewT1&gt; retype&lt;NewT1&gt; (Slot1&lt;RT,T1&gt; </i>&amp;<i>) </i>lets you convert the type of the argument to a <i>Slot1</i> to another type, as long as there is a simple conversion between the types.</p><p>  		Similar functions handle adapting the return type or value. In this area, C# has no functional equivalent. You must write your own adapters to convert from one type of delegate to another, or write your own subclass of <i>System.MulticastDelegate</i>.</p>  <li>Handling return values. What is the return value of a <i>Signal</i> or <i>delegate</i>, used as a functor, that in turn calls many different callbacks that each return different values? Libsigc++ refers to this issue as how do you marshal the return values. The answer is that you may want to do a number of different things&#151;if the callbacks return Boolean values, for example, you may want the results ANDed together, or ORed together, or perhaps summed to determine how many callbacks returned True. Each <i>Signal</i> class takes a final template parameter that specifies a type of <i>Marshal</i> object (with a default <i>Marshal</i> type that simply uses the return value from the last invoked callback), and you can write your own marshalers to do specific operations. Thus, each <i>Signal</i> instance can customize how to combine the callback return values. <A NAME="rl7"><A HREF="#l7">Listing Seven</A> is a custom marshaler that returns the count of the number of callback return values that equal zero. <p> 	In C#, when you invoke a delegate for callbacks that return a value, the result is simply the value from the last callback that was called. To perform more complex marshaling, you must iterate over the target delegates stored within a delegate container and invoke each one by hand to see the results of each call. Libsigc++ also lets you iterate over the <i>Slots</i> in a <i>Signal</i>, but this capability is often not needed in an application.</p></ul><h3>Conclusion</h3></blockquote><p>Conceptually, both callback mechanisms I describe here are similar. Both define type-safe callback containers that can be used as signal or event objects, and let you dynamically connect or disconnect a variety of different callback targets for later invocation. The key implementation distinction between libsigc++ and C# delegates, beyond the clear difference in language, is that libsigc++ achieves a high degree of generality by using C++ templates, while C# delegates are provided as a core language feature understood by the compiler.</p><p>Syntactically, both packages require similar amounts of code to perform the basic tasks of a generalized callback system: declare <i>Signals</i> or delegates, connect or disconnect callback targets, and invoke callbacks through their containers (compare <A NAME="rl4"><A HREF="#l4">Listing Four</A> and <A NAME="rl6"><A HREF="#l6">Listing Six</A>). A type-safe callback package could quite possibly be written in C# with the help of the C# reflection and attribute APIs, but it would have some difficulty in matching the ease of use and minimal syntax afforded by the delegate keyword. Libsigc++, in this comparison, demonstrates the utility of the template features of C++ and uses them well to provide a more extensive and extensible set of callback management features such as callback adapters and return value marshalers.</p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>/* Define the callback function */float callback(int, double) { /* function body */ }int main(int argc, char *argv[]) {  /* Create a variable to store a reference to the callback */typedef float (*CallbackRef)(int, double);  CallbackRef cb;  /* Register the callback function for later invocation */  cb = &amp;callback;  /* Invoke the callback function with arguments */  cb(1, 2.0);}</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>// The abstract callback interfaceclass CallbackInterface {public:  // The target callback function  virtual void callback(int, double) = 0;};// An implementation of the interfaceclass CallbackImpl : public CallbackInterface {public:  virtual void callback(int, double) {    std::cout &lt;&lt; "Callback invoked" &lt;&lt; std::endl;  }};// A class that stores a target callback reference and invokes it // later using operator()class CallbackContainer {public:  CallbackContainer(CallbackInterface *c) : cb_m(c) { }  void operator()(int a, double b) { cb_m-&gt;callback(a, b); }private:  CallbackInterface *cb_m;};int main(int argc, char *argv[]) {  // Declare a callback container and add a reference  CallbackContainer cb(new CallbackImpl());  // Invoke the callback after doing some work  cb(1, 2.0);}</pre><P><A HREF="#rl2">Back to Article</A></P><H4><A NAME="l3">Listing Three</H4><pre>typedef SigC::Signal2&lt;float, int, double&gt; SampleSignal_t;class SampleClass {public:  SampleSignal_t signalobj;};</pre><P><A HREF="#rl3">Back to Article</A></P><H4><A NAME="l4">Listing Four</H4><pre>// A global function callbackfloat callback(int, double) { /* function body */ }// A class with nonstatic method callbacksclass SampleCB : public SigC::Object {public:  float method(int, double) { /* body */ }};// Connect callbacks to the signal from Listing Threeint main(int argc, char *argv[]) {  SampleClass sample;  SampleCB target;  // Connect a global function  sample.signalobj.connect(SigC::Slot2&lt;float,int,double&gt;(callback));  // Connect a method using 'slot' utility function, noting connection  SigC::Connection connection =    sample.signalobj.connect(slot(target, &amp;SampleCB::method));  // Emit the signal, calling 'callback' and 'method'  sample.signalobj.emit(1, 2.0);  // Disconnect the second callback then emit the same signal;  // this will only invoke 'callback'  connection.disconnect();  sample.signalobj.emit(2, 2.0);}</pre><P><A HREF="#rl4">Back to Article</A></P><H4><A NAME="l5">Listing Five</H4><pre>public delegate float SampleDelegate(int a, double b);public class SampleClass {  public SampleDelegate delegateobj = null;}</pre><P><A HREF="#rl5">Back to Article</A></P><H4><A NAME="l6">Listing Six</H4><pre>// A class with static and nonstatic method callbackspublic class SampleCB {  public static float callback(int a, double b) { return 1.0F; }  public float method(int a, double b) { return 2.0F; }};// Connect callbacks to the delegate from Listing Fivepublic class MainClass {  public static void Main(string[] args) {    SampleClass sample = new SampleClass();    // Connect a static method to the delegate in sample    sample.delegateobj += new SampleDelegate(SampleCB.callback);    // Connect an instance method to the delegate    SampleCB target = new SampleCB();    sample.delegateobj += new SampleDelegate(target.method);    // Invoke the delegate, calling 'callback' and 'method'    sample.delegateobj(1, 2.0);    // Disconnect the second callback then invoke the delegate again;    // this will only invoke 'SampleCB.callback'    sample.delegateobj -= new SampleDelegate(target.method);    sample.delegateobj(2, 2.0);  }}</pre><P><A HREF="#rl6">Back to Article</A></P><H4><A NAME="l7">Listing Seven</H4><pre>// A new Marshal classtemplate&lt;class T&gt;class EqualZeroMarshal {public:  typedef T InType;  typedef int OutType;  OutType value()  {    return result_m;  }  static OutType default_value()  {    return 0;  }  // If this returns true, no more callbacks will be called.  bool marshal(const InType &amp;in)  {    if (in == 0)      result_m++;    return false;  }  EqualZeroMarshal() : result_m(0) { }private:  OutType result_m;};// Create a Signal using this marshaller.SigC::Signal1&lt;bool,float,EqualZeroMarshal&lt;bool&gt; &gt; signalobj;</pre><P><A HREF="#rl7">Back to Article</A></P></body></html>