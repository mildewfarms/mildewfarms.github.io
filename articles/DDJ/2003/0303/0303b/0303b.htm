<html><head><title>Mar03: XML  Data Binding</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>XML  Data Binding</h1><p><i>Dr. Dobb's Journal</i> March 2003</p><h2>Simplifying XML processing</h2><h3>By Eldon Metz and Allen Brookes</h3><I>Eldon is a senior software engineer and Allen a software engineer for Rogue Wave Software. They can be contacted at eldonm@geofolio.com and abrookes@roguewave.com, respectively.</I><hr><p>An XML data binding is programming language code that handles data that can be represented in XML documents. XML data binding utilities dramatically simplify the task of writing XML-enabled applications by automatically creating a data binding for you. A successful data binding provides accurate, high-performing parsing and serialization code in a fraction of the time it takes to write and maintain the same code by hand.</p><p>To use an XML data binding, a document's constraints must be understood and captured in the form of an XML schema. XML documents, without expressed constraints, are much more difficult to share and understand. For XML data to be truly portable, there needs to be a shared understanding of the acceptable structure and format so that it can be exchanged. To communicate the allowable set of constraints, you typically use a schema. </p><DDJADVERTISEMENT INLINE><p>There are a variety of schema languages available, including the Document Type Definition (DTD) and XML Schema. XML Schema (http://www.w3.org/TR/ xmlschema-0/) is an attempt to overcome the limitations of DTDs and lets document constraints be expressed using techniques found in many object-oriented (OO) languages; grammar for specifying these constraints is expressed using XML. XML Schema also provides a rich type system of more than 44 different built-in types and the ability to create user-defined types. We will focus on XML Schema because of the benefits that it provides. Most of the principles apply (with slight modifications) to other schema languages. </p><p>Data bindings can theoretically translate XML schemas into the constructs of any programming language. Given an XML Schema that incorporates principles from OO languages such as C++ and Java, the most obvious and intuitive mappings are to these languages. </p><p>Data bindings can provide the higher level of abstraction using code-generation techniques. Typically, the data binding automatically creates an object model with parsing and serialization code. Most data binding utilities also allow the mapping of XML Schema type definitions to language constructs to be configured in some way.</p><p>An XML data binding utility compiles XML Schema type definitions into classes for OO languages. <A NAME="rf1"><A HREF="0303bf1.htm">Figure 1</A> shows how an instance of a compiled class can be compared to an instance document that conforms to the schema. An instance document can be unmarshaled, or parsed, into the equivalent object-oriented instance. Likewise, the OO instance can then be marshaled, or serialized, to the XML document instance equivalent.</p><h3>Parsing</h3><p>There are a variety of ways to parse XML and a data binding is free to choose any of them. The DOM and SAX APIs can be extended, with the obvious choice of SAX resulting in a more efficient implementation, although requiring a more complex implementation. A SAX parser is a push parser, with every element in the document&#151;attribute, character data, processing instruction, and the like&#151;passed to a callback that the parsing implementation chooses to utilize or ignore. An XML pull parser, on the other hand, lets the parsing implementation walk the document tree, extracting the elements, attributes, character data, and anything else it cares about. This is a simpler approach that generally results in better performance. </p><p>XML data bindings do not require generic parsers. Since an XML data binding utility analyzes the schema, it generates code that optimally parses in instance documents that conform to it. This gives a data binding that uses a specific parser a distinct performance advantage over a generic parser-based implementation.</p><p>DOM-based parsing solutions can be inefficient for large XML documents. Not only is a generic in-memory model created, but typically the data stored in this model must then be converted to different data types, which can create overhead. In contrast, SAX-based parsers result in faster implementations, but unless you already have an existing data model to populate, you'll need to create one from scratch.</p><h3>Mapping Details</h3><p>A data binding is a mapping to the constructs of the programming language that users desire to work with. A binding for XML schema can be complex, as the XML Schema specification is extensive. </p><p>The first issue is naming. The XML Schema type definition mechanism provides the capability to define attributes, elements, and complex types with names that must then be mapped to the programming language conventions. Most data bindings let you customize the names of the type definitions being mapped. However, if the schema follows good design practices, the data binding utility should be designed such that the generated mapping for names is appropriate and acceptable. Otherwise, the generated API may not be desirable to program against.</p><p>The data binding is also responsible for creating the mapping of the XML document instance to an OO type-safe object model. Elements and complex types can be mapped to classes in languages such as Java and C++. Complex types are directly analogous to user-defined language types. Element definitions define a specific name for a complex type definition and are not quite analogous. However, top-level elements require a representation and in OO languages, the only tool available is the class. Attributes and element definitions that are simple types can be represented as language primitives such as <i>long</i>, <i>double</i>, <i>float</i>, <i>int</i>, and so on. Attributes can only be simple types, but element declarations can refer to complex type definitions. The data binding creates a signature that lets attributes and child elements of a complex type be accessed. Consider the Purchase Order schema and example document in <A NAME="rl1"><A HREF="#l1">Listings One</A> and Two, taken from the XML Schema Primer documentation (http://www.w3.org/TR/xmlschema-0/#po.xml, and http://www.w3.org/TR/xmlschema-0/#po.xsd). The schema describes the documents exchanged for a simple ordering and billing application. When compiled to a Java class, the <i>PurchaseOrderType</i> might have an interface similar to <A NAME="rl3"><A HREF="#l3">Listing Three</A>. The data binding includes a default constructor, equals method, and methods for accessing and setting member data as well as marshaling the object to/from XML data. Elements and attributes that are optional have an associated <i>is&lt;identifier&gt;Set</i> method for querying whether the element or attribute value is present after parsing. Also note that an optional validation interface might be generated, letting users choose if/when validation should occur. The XML details exposed in this interface are minimal. XML parsing, serialization, or validation errors may occur, but in terms of working with the data, the familiar and high-level constructs available to the language are all that is necessary. </p><p>XML schemas also provide support for defining collections by declaring an element to have an occurrence constraint that is greater than 1. Such schema collections can be mapped directly to simple vector or list collection types. Support for more advanced collection types (hash tables and dictionaries) is a more difficult task, and you can only configure them with additional input via a configuration file or other form of input. The example Java interface in <A NAME="rl4"><A HREF="#l4">Listing Four</A> shows how a basic collection mapping can be established. This interface is a result of a binding to the Java language from the <i>Items</i> complex type definition found in the purchase order schema in <A NAME="rl2"><A HREF="#l2">Listing Two</A>.</p><p>An important part of the data binding is the inclusion of an error model that reports useful errors. If an instance document's structure does not conform to the schema, the generated parsing implementation needs to report this to users via raising of an exception. The exception should contain the line and column number where the error occurred, as well as an error message. <A NAME="rl5"><A HREF="#l5">Listing Five</A> is an exception class for Java.</p><h3>Using the Generated Classes</h3><p>Business logic can be added to the generated API by subclassing and adding behavior. The generated classes may provide methods that can be overridden by the subclass. Typically, it is best not to change the generated code directly since these changes are lost when the generator is run again.</p><p>Depending on the language, different techniques to build the generated classes may be involved. In Java, an <i>ant</i> script may be generated, letting users easily build the generated code. In C++, makefiles for building the classes into shared libraries on a particular operating system/compiler for linkage into your application may be desired. In either case, it is best that the code generator only generates the files that have changed. There are large schemas such as Financial products Markup Language (FpML; http://www.fpml.org/), which contain over 300 type definitions. If each of these classes must be rebuilt each time a minor change to the schema is made, the build times will be greater than necessary.</p><p>For creating new applications, a data binding can bring significant savings. The generated code saves on development, testing, porting, and maintenance.</p><h3>Converting to XML</h3><p>In many cases, you need to take existing business processes that exchange data that is not XML and convert them to XML. For such tasks, XML data-binding tools can be valuable. Given a schema that describes the data, the tool generates a set of language constructs that lets users produce and consume XML documents that conform to the schema.</p><p>Converting applications to exchange data in XML becomes one of creating and populating instances of the generated classes for sending, and accessing data from instances of the generated classes for receiving. Given an existing process with an existing data model, the problem becomes one of extracting data from one data model into another. When the data model is a set of programming language constructs, it may be much easier than trying to directly generate XML. This typically consists of simply assigning fields from one class to another.</p><p>In other cases, a database is the data model. In this instance, you would need to write code that extracts data from the database into the generated classes. While this is not a difficult task, it is a common enough model that several data-binding tools provide support for simplifying this task (see http://www.rpbourret.com/xml/XMLDataBinding.htm). </p><p>Generating code for converting the data model to XML presumes the existence of an XML Schema. Other tools might be desirable for creating schemas, but discussion of them is beyond the scope of this article.</p><h3>Coping with  Existing Code</h3><p>An XML data-binding tool can get XML data into programming language constructs, but it still creates its own data structures. In many cases, there will already be language constructs for representing and storing the data and the data needs to be transferred between the generated data structures and existing data structures. This may not be daunting in some cases, although it may require copying a number of fields from one class to another, or perhaps require augmentation of the generated classes to read/write the data using database tables. </p><p>In other cases (complex structures with deep nesting, for example), this may constitute more work or introduce a performance hit you can't afford. Having parallel data models uses more space and takes more time than having a single model, not to mention work needed to create the conversion tools. In short, there comes a point when the data-binding tool does not make sense.</p><p>When existing code causes an XML data binding to be undesirable, it might make more sense to augment existing classes with the ability to marshal/unmarshal XML&#151;and generate the code to do so. This is the approach used in tools such as Rogue Wave's XML Streams library (http://www.roguewave.com/products/sourcepro/core/fb.cfm), which lets you adapt C++ classes by adding a few macros so that XML data may be streamed into and out of instances of the class. Castor (http://castor.exolab.org/), an open-source data binding for Java, provides similar functionality using Java's introspection capabilities. Microsoft's .NET lets classes be marked up with metadata (http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cpguide/html/cpconintroducingxmlserialization.asp), allowing them to be serialized as XML. Since these approaches do not use a schema, it might be desirable to extend an XML data-binding tool to perform a similar task of inserting and extracting XML from an existing data model, but base it on XML Schemas rather than on a generic XML model.</p><h3>Extending the Model</h3><p>Can the XML data binding model be extended to cope with existing code? The general problem is to generate code that lets existing classes marshal XML and XML to be unmarshaled into instances of existing classes. This can take two forms: </p><p></p><ul>  <li>Create a schema that represents the data in an existing class and then generate methods that marshal and unmarshal XML that corresponds to the schema.  <li>Adapt an existing schema to an existing class and generate marshal and unmarshal methods for this schema that work with the existing class. </ul><h3>Generating  Schemas from Code</h3><p>Creating schemas from programming language constructs involves parsing the language construct&#151;a process that finds all possible data within the construct. Not all data is significant, however. Some data may be there only as a cache. To be an accurate representation of the data, the schema creation requires some input identifying which data members are significant.</p><p>One approach is to start with a tool (such as Rational Rose) that takes programming language code and produces UML. From UML, you can produce XMI, which can then be edited to indicate the significant data and then transformed to XML Schema.</p><h3>Reconciling Object Models with Schema</h3><p>Another possible scenario consists of an existing object model and schema that may not be a perfect match. This can occur when attempts are made to standardize a proprietary process. The schema created is a compromise of the various ways of handling the process, but doesn't conform exactly to any of the existing object models for the process.</p><p>In this case, you want to generate code that extracts data from the XML and places it in instances of objects in the object model. You don't want to generate new classes since you would have a redundant model and still need to get data out of the generated classes and into the existing classes. This approach also requires input identifying how data in the programming language code maps to data in the schema.</p><h3>Adding Marshaling and  Unmarshaling to Existing Code</h3><p>Once you have a schema that represents how the data is represented in XML, the schema can be used to generate code to extract data from an instance and insert data into an instance. This can be done either intrusively or nonintrusively.</p><p>The intrusive approach is to actually modify the language construct, adding functions that provide the marshaling/unmarshaling. There are two advantages to this approach: Adding marshaling/unmarshaling directly to the class alleviates access problems. They don't all go away since there may be private data in a super class, but there is access to all local private and protected data. In addition, this approach is easier to understand. The marshal/unmarshal methods become part of the class.</p><p>The nonintrusive approach creates a parallel construct that provides the marshal/unmarshal methods. The advantage of this approach is that it doesn't require a change to existing code. However, if a class has private data with no accessors, this method will not allow this data to be marshaled/unmarshaled.</p><p>You also need a way to map data to the schema. In the case where the schema is generated from the code, you only need to be able to identify which items are significant. If the schema was not generated from the code, then you need to create a mapping that connects each item in the schema to a data member in a class.</p><h3>Conclusion</h3><p>An XML binding is programming language code that represents XML data, thereby ensuring that the documents conform to their schema. The generated code enables the transfer of XML data to/from instances of the generated classes. While XML data-binding tools may not always be useful when writing code to process XML, they usually do save time in coding, testing, and maintenance. For more information, see Ronald Bourret's XML data-binding resources at http://www.rpbourret.com/xml/XMLDataBinding.htm.</p><p></p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>&lt;?xml version="1.0"?&gt;&lt;purchaseOrder orderDate="1999-10-20"&gt;  &lt;shipTo country="US"&gt;    &lt;name&gt;Alice Smith&lt;/name&gt;    &lt;street&gt;123 Maple Street&lt;/street&gt;    &lt;city&gt;Mill Valley&lt;/city&gt;    &lt;state&gt;CA&lt;/state&gt;    &lt;zip&gt;90952&lt;/zip&gt;  &lt;/shipTo&gt;  &lt;billTo country="US"&gt;    &lt;name&gt;Robert Smith&lt;/name&gt;    &lt;street&gt;8 Oak Avenue&lt;/street&gt;    &lt;city&gt;Old Town&lt;/city&gt;    &lt;state&gt;PA&lt;/state&gt;    &lt;zip&gt;95819&lt;/zip&gt;  &lt;/billTo&gt;  &lt;comment&gt;Hurry, my lawn is going wild!&lt;/comment&gt;  &lt;items&gt;    &lt;item partNum="872-AA"&gt;      &lt;productName&gt;Lawnmower&lt;/productName&gt;      &lt;quantity&gt;1&lt;/quantity&gt;      &lt;USPrice&gt;148.95&lt;/USPrice&gt;      &lt;comment&gt;Confirm this is electric&lt;/comment&gt;    &lt;/item&gt;    &lt;item partNum="926-AA"&gt;      &lt;productName&gt;Baby Monitor&lt;/productName&gt;      &lt;quantity&gt;1&lt;/quantity&gt;      &lt;USPrice&gt;39.98&lt;/USPrice&gt;      &lt;shipDate&gt;1999-05-21&lt;/shipDate&gt;    &lt;/item&gt;  &lt;/items&gt;&lt;/purchaseOrder&gt;</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>&lt;xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema"&gt; &lt;xsd:annotation&gt;  &lt;xsd:documentation xml:lang="en"&gt;   Purchase order schema for Example.com.   Copyright 2000 Example.com. All rights reserved.  &lt;/xsd:documentation&gt; &lt;/xsd:annotation&gt; &lt;xsd:element name="purchaseOrder" type="PurchaseOrderType"/&gt; &lt;xsd:element name="comment" type="xsd:string"/&gt; &lt;xsd:complexType name="PurchaseOrderType"&gt;  &lt;xsd:sequence&gt;   &lt;xsd:element name="shipTo" type="USAddress"/&gt;   &lt;xsd:element name="billTo" type="USAddress"/&gt;   &lt;xsd:element ref="comment" minOccurs="0"/&gt;   &lt;xsd:element name="items"  type="Items"/&gt;  &lt;/xsd:sequence&gt;  &lt;xsd:attribute name="orderDate" type="xsd:date"/&gt; &lt;/xsd:complexType&gt; &lt;xsd:complexType name="USAddress"&gt;  &lt;xsd:sequence&gt;   &lt;xsd:element name="name"   type="xsd:string"/&gt;   &lt;xsd:element name="street" type="xsd:string"/&gt;   &lt;xsd:element name="city"   type="xsd:string"/&gt;   &lt;xsd:element name="state"  type="xsd:string"/&gt;   &lt;xsd:element name="zip"    type="xsd:decimal"/&gt;  &lt;/xsd:sequence&gt;  &lt;xsd:attribute name="country" type="xsd:NMTOKEN"     fixed="US"/&gt; &lt;/xsd:complexType&gt; &lt;xsd:complexType name="Items"&gt;  &lt;xsd:sequence&gt;   &lt;xsd:element name="item" minOccurs="0" maxOccurs="unbounded"&gt;    &lt;xsd:complexType&gt;     &lt;xsd:sequence&gt;      &lt;xsd:element name="productName" type="xsd:string"/&gt;      &lt;xsd:element name="quantity"&gt;       &lt;xsd:simpleType&gt;        &lt;xsd:restriction base="xsd:positiveInteger"&gt;         &lt;xsd:maxExclusive value="100"/&gt;        &lt;/xsd:restriction&gt;       &lt;/xsd:simpleType&gt;      &lt;/xsd:element&gt;      &lt;xsd:element name="USPrice"  type="xsd:decimal"/&gt;      &lt;xsd:element ref="comment"   minOccurs="0"/&gt;      &lt;xsd:element name="shipDate" type="xsd:date" minOccurs="0"/&gt;     &lt;/xsd:sequence&gt;     &lt;xsd:attribute name="partNum" type="SKU" use="required"/&gt;    &lt;/xsd:complexType&gt;   &lt;/xsd:element&gt;  &lt;/xsd:sequence&gt; &lt;/xsd:complexType&gt; &lt;!-- Stock Keeping Unit, a code for identifying products --&gt; &lt;xsd:simpleType name="SKU"&gt;  &lt;xsd:restriction base="xsd:string"&gt;   &lt;xsd:pattern value="\d{3}-[A-Z]{2}"/&gt;  &lt;/xsd:restriction&gt; &lt;/xsd:simpleType&gt;&lt;/xsd:schema&gt;</pre><P><A HREF="#rl2">Back to Article</A></P><H4><A NAME="l3">Listing Three</H4><pre>public class PurchaseOrderType {   ...  public PurchaseOrderType() {    ...  }  public boolean equals(Object rhs) {    ...  }  public void unmarshal(InputStream in) throws XmlParseException {    ...  }  public void marshal(OutputStream out) throws XmlSerializeException {    ...  }  public boolean isValid() throws XmlValidationException {    ...  }  public USAddress getShipTo() {    ...  }  public void setShipTo(USAddress ShipTo) {    ...  }  public USAddress getBillTo() {    ...  }  public void setBillTo(USAddress BillTo) {    ...  }  public String getComment() {    ...  }  public void setComment(String Comment) {    ...  }  public boolean isCommentSet() {    ...  }  public Items getItems() {    ...  }  public void setItems(Items Items) {    ...  }  public java.util.Date getOrderDate() {    ...  }  public void setOrderDate(java.util.Date OrderDate) {    ...  }  public boolean isOrderDateSet() {    ...  }}</pre><P><A HREF="#rl3">Back to Article</A></P><H4><A NAME="l4">Listing Four</H4><pre>public class Items {  ...  public Items() {    ...  }  ...  public Vector getItemVector() {    ...  }  public void setItemVector(Vector Item) {    ...  }  ...}</pre><P><A HREF="#rl4">Back to Article</A></P><H4><A NAME="l5">Listing Five</H4><pre>public class XmlParseException extends Exception {  ...  public XmlParseException(String msg, String src,                                      int lineNumber, int columnNumber) {    ...  }  public String toString() {    ...  }  public int getLineNumber() {    ...  }  public int getColumnNumber() {    ...  }</pre><P><A HREF="#rl5">Back to Article</A></P></body></html>