<html><head><title>Sep03: Creating Java  Grid Services </title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Creating Java  Grid Services </h1><p><i>Dr. Dobb's Journal</i> September 2003</p><h2>Building computational grids using the Globus Toolkit </h2><h3>By Aaron E. Walsh</h3><I>Aaron is the founder of Mantis Development Corps and director of the Media Grid and Web3D Web (http://Web3DWeb.com/). He teaches computer graphics and Internet/web-application development at Boston College, and is also author of J2EE 1.4 Essentials (http://www.wiley.com/compbooks/walsh/). Aaron can be contacted at aaron@mantiscorp.com.</I><hr><a name="rs1"><a href="0309as1.htm">Global Grid Forum,  OGSA, and OGSI</a><hr><p>Over the past decade, the technology behind computational grids has evolved from raw concept into tangible reality. Grids are generally distinguished from the field of traditional distributed computing by their ability to share resources such as processing power and databases on a large scale and with high performance. To date, grid technology has been used primarily by researchers for building specialized scientific and engineering applications. More recently, however, grids have migrated into the corporate world. Utility computing, on-demand computing, and autonomous computing are just a few of the buzzwords describing technology that is based, to some degree, on large-scale resource sharing across organizational boundaries. </p><p>Of the many grid technologies available to Java developers, the Globus Project's Globus Toolkit is perhaps the most well known and widely adopted. In this article, I briefly discuss the Globus Project, then examine the latest version of the Globus Toolkit, with which you can create Java-based grid services and grid clients. </p><DDJADVERTISEMENT INLINE><h3>The Globus Project</h3><p>The Globus Project (http://globus.org/) was started in 1996 as a collaborative research and development project for building foundation technologies that enable computational grids. The project is based at the Argonne National Laboratory's Mathematics and Computer Science Division, the University of Southern California's Information Sciences Institute, and the University of Chicago's Distributed Systems Laboratory. In addition to universities and government agencies, the Globus Project is also sponsored by IBM, Microsoft, and Cisco.</p><p>The open-source Globus Toolkit is the project's key deliverable. As a unified collection of grid software services and libraries, the Globus Toolkit Version 2.4 provides a standard development framework you can use to develop special-purpose grids. The toolkit supports discovery, management, and monitoring of grid resources, as well as file management and security features. The Globus Toolkit is used by grid projects around the world and is the foundation on which many commercial grid projects are currently being built. </p><p>Version 3 of the Globus Toolkit has been released and shipped earlier this year. Globus Toolkit 3 gives Java developers a standard solution for developing and deploying grid services and clients. The Media Grid that powers the Web3D Web (http:// Web3DWeb.com/), for example, uses GT3 to enable digital media delivery and processing services on a massive scale.</p><h3>Globus Toolkit 3 </h3><p>Globus Toolkit 3 (GT3) was officially released as open source by the Globus Project recently. As a high-performance grid framework, GT3 relies on native code that is exposed to Java developers through standard APIs. In other words, you can harness the power of GT3 using pure Java.</p><p>GT3 is an open-source implementation of the Open Grid Services Infrastructure (OGSI); see the accompanying text box entitled "Global Grid Forum, OGSA, and OGSI." By providing a number of premade OGSI services and the ability to create custom OGSI-compliant services as needed, the toolkit gives you a powerful framework for building grids based on standard web services. The OGSI specification builds on grid- and web-service technologies to define how "grid services" are created and managed, and how information can be exchanged among grid services. According to the specification, a grid service is merely a web service that conforms to specific interface and behavior conventions that define how clients interact with that service. </p><p>Simply put, a grid service is a special-purpose web service designed to operate in a grid environment. To this end, OGSI uses the Web Services Description Language (WSDL) to define compliant grid services that are accessible over the Internet using SOAP/HTTP. The current OGSI 1.0 specification implemented by GT3 extends WSDL 1.1 to define grid services and will eventually support WSDL 1.2. OGSI 1.0 defines a component model by extending WSDL 1.1 and XML Schema Definition (XSD) to support a number of useful and innovative enhancements, including: stateful web services; support for inheritance of web-service interfaces; asynchronous state change notifications; references to service instances; service collections; and service state data.</p><p>Although the full GT3 run time is a Linux product, the Java-based OGSI reference implementation portion of Globus Toolkit 3 can run in any of the following four Java environments on any platform (provided Java 1.3.1 or higher is available):</p><ul>  <li>Embedded in any existing Java 2 Standard Edition (J2SE) application.  <li>Standalone in a lightweight J2SE server (used primarily for testing and development work).  <li>Java 2 Enterprise Edition (J2EE) web container by deploying to a servlet container such as Apache Jakarta Tomcat.  <li>J2EE Enterprise JavaBean (EJB) container by using a Globus code generator that enables stateful Entity and Session beans to be exposed as OGSI-compliant grid services.</ul><p>GT3 features a core architecture built on OGSI primitives and protocols. <A NAME="rf1"><A HREF="0309af1.htm">Figure 1</A> illustrates the GT3 core architecture, which is designed to make OGSI-based grids easy to create and use. The GT3 core provides an open-source implementation of all interfaces defined by OGSI 1.0. In addition, it provides various hosting environments layered on top of an abstract container. Conceptually, the GT3 core is a suite of building blocks that provide the main functionality necessary for a variety of grid applications. GT3 also provides a security framework, various system services (logging, management and administration, and so forth), and a development environment that includes code-generation tools to make life easier on grid application developers.</p><p>The white boxes in <A NAME="rf1"><A HREF="0309af1.htm">Figure 1</A> indicate components provided by the GT3 core, while gray boxes are considered outside of the core. User-defined services provided by application developers, for instance, are not considered part of the GT3 core. Similarly, the web-services engine and base services are not officially part of the core, although they are provided with the full GT3 run time (base services enable execution, data management, and information services; user-defined services are any services built using GT3 components). </p><p>The OGSI Reference Implementation in <A NAME="rf1"><A HREF="0309af1.htm">Figure 1</A> supports all of the interfaces defined by OGSI 1.0, in addition to related APIs and tools used to create compliant grid services. The Security Infrastructure implementation, meanwhile, provides a variety of security features such as SOAP and transport-level message protection; end-to-end mutual authentication; and single sign-on authorization. The OGSI Reference Implementation and Security Infrastructure don't provide run-time services directly&#151;they are infrastructure building blocks used by other parts of the GT3 architecture.</p><p>The services and primitives that make up the GT3 core interact with an abstract OGSI run-time environment, known as the "Grid Services Container." This container hides low-level implementation details (such as the underlying database used for data persistence) from you so that you can focus on developing grid services and clients at a higher level.</p><h3>Creating Grid Services</h3><p>Creating a grid service with Version 3 of the Globus Toolkit is a four-stage process:</p><p></p><p>1.	Create the service interface. </p><p>2.	Generate stub and support code.</p><p>3.	Implement the service.</p><p>4.	Deploy the service. </p><p>You define grid services interfaces by writing Java code, from which the toolkit generates the appropriate WSDL interfaces, or you can create the WSDL interfaces manually. <A NAME="rl1"><A HREF="#l1">Listing One</A>, for example, is the Java interface code for the Counter example program provided with the toolkit, while <A NAME="rl2"><A HREF="#l2">Listing Two</A> shows key portions of a corresponding WSDL interface. Only the abstract definition of the service (including the types, message, and <i>portType</i> parts of WSDL) are necessary when creating a WSDL interface directly, since the binding and service portions are generated by the toolkit.</p><p>After defining the interface for your grid service, you must then generate the stub and support code for your service. At this stage, you use the Ant tasks and XML batch file tools provided with GT3 to generate the code needed to host your grid service. <A NAME="rl3"><A HREF="#l3">Listing Three</A>, for instance, is the Ant command used to generate a WSDL interface from the Counter Java interface in <A NAME="rl1"><A HREF="#l1">Listing One</A>. After the WSDL interface is available, you can then generate the Java stubs that let your service data be accessed via SOAP over HTTP. <A NAME="rl4"><A HREF="#l4">Listing Four</A> is the Ant command that generates these stubs for the Counter example (<A NAME="rl3"><A HREF="#l3">Listings Three</A> and Four are excerpts of the build.xml file that comes with this example).</p><p>Upon generating stubs and support code, you actually implement the service. <A NAME="rl5"><A HREF="#l5">Listing Five</A> shows the Java implementation of the Counter grid service, for which the class <i>CounterImp.java</i> is defined. This class extends the base grid services implementation, <i>GridServiceImpl</i>, and implements the <i>CounterPortType</i> interface created in the previous step. In cases where you don't want your grid service to be dependent on implementation classes provided with GT3 (such as <i>GridServiceImpl</i>), you can provide an implementation using an operation-provider (delegation) approach instead. (For details, see the Java Programmer's Guide Core Framework, available through the GT3 download area.)</p><p>After providing an implementation for your service, it's ready to be deployed. To do so, you must write a deployment descriptor that describes and configures your service, then bundle the descriptor and the various files that comprise the service into a Grid Archive (GAR) package. GAR packages can be deployed to any suitable grid service hosting environment. <A NAME="rl6"><A HREF="#l6">Listing Six</A> is a key excerpt of the deployment descriptor for the Counter grid service example that comes with GT3, while <A NAME="rl7"><A HREF="#l7">Listing Seven</A> is the Ant command that builds the GAR package for this service.</p><h3>Creating Grid Services Clients</h3><p>Creating grid services is only half the battle: To be of any real value, a grid service is accessed and used by a grid client. Although you can create grid services clients using the standard JAX-RPC API, you'll find it much easier to use the JAX-RPC extensions provided with GT3. Standard JAX-RPC doesn't directly support grid services, and you'll save a lot of time by simply using the helper JAX-RPC classes provided with GT3 as illustrated by <A NAME="rl8"><A HREF="#l8">Listing Eight</A>.</p><h3>Getting Started with Globus Toolkit 3</h3><p>GT3 is freely available at http://www.globus.org/. To get started, simply download and install the toolkit, then turn to the example programs that come with it (the Counter example presented here is just one of many GT3 grid-service examples). You will find the related User's Guide Core Framework and Java Programmer's Guide Core Framework documents essential, and can find links to both through the GT3 download area. Whereas the User's Guide Core Framework tells you how to install/configure the toolkit and run the various example programs that come with it, the Java Programmer's Guide Core Framework provides details on how you can create grid services using Java. You'll also find the Grid Service Development Tools Guide useful in learning the various Ant commands that you can use to create and manage your services (it's also available through the GT3 download area).</p><p></p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>/* "Counter" interface example provided with Globus Toolkit 3. Refer to  * guide/src/org/globus/ogsa/guide/impl/Counter.java for complete example. */package org.globus.ogsa.guide.impl.guide;public interface Counter {    public int add(int value);    public int subtract(int value);    public int getValue();} </pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>&lt;types&gt; ...&lt;xsd:element name="add"&gt;  &lt;xsd:complexType&gt;    &lt;xsd:sequence&gt;      &lt;xsd:element name="value" type="xsd:int"/&gt;    &lt;/xsd:sequence&gt;   &lt;/xsd:complexType&gt;  &lt;/xsd:element&gt; ...&lt;/types&gt; ...&lt;message name="AddInputMessage"&gt;  &lt;part name="parameters" element="tns:add"/&gt;&lt;/message&gt; ...&lt;gwsdl:portType name="CounterPortType" extends="ogsi:GridService"&gt;  &lt;operation name="add"&gt;    &lt;input message="tns:AddInputMessage"/&gt;    &lt;output message="tns:AddOutputMessage"/&gt;    &lt;fault name="Fault" message="ogsi:FaultMessage"/&gt;  &lt;/operation&gt;&lt;/gwsdl:portType&gt;</pre><P><A HREF="#rl2">Back to Article</A></P><H4><A NAME="l3">Listing Three</H4><pre>&lt;ant antfile="${build.services}" target="generateWSDL"&gt;  &lt;property name="interface.package" value="org.globus.ogsa.guide.impl"/&gt;  &lt;property name="interface.name" value="Counter"/&gt;  &lt;property name="generated.dir" value="guide"/&gt;&lt;/ant&gt;</pre><P><A HREF="#rl3">Back to Article</A></P><H4><A NAME="l4">Listing Four</H4><pre>&lt;ant antfile="${build.services}" target="generateStubs"&gt;  &lt;property name="schema.file.dir" value="guide/Counter"/&gt;  &lt;property name="schema.file" value="counter_service.wsdl"/&gt;&lt;/ant&gt; </pre><P><A HREF="#rl4">Back to Article</A></P><H4><A NAME="l5">Listing Five</H4><pre>/* "Counter" implementation example provided with Globus Toolkit 3. Refer to  * uide/src/org/globus/ogsa/guide/impl/CounterImpl.java for complete example. */public class CounterImpl extends GridServiceImpl implements CounterPortType {    private int val = 0;    public CounterImpl() {        super("Guide Counter");    }    public int add(int val) throws RemoteException {        this.val = this.val + val;        return this.val;    }    public int subtract(int val) throws RemoteException {        this.val = this.val - val;        return this.val;    }    public int getValue() throws RemoteException {        return this.val;    }}</pre><P><A HREF="#rl5">Back to Article</A></P><H4><A NAME="l6">Listing Six</H4><pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;deployment name="defaultServerConfig"        xmlns="http://xml.apache.org/axis/wsdd/"       xmlns:java="http://xml.apache.org/axis/wsdd/providers/java"&gt;   &lt;service name="guide/counter/CounterProviderFactoryService"                  provider="Handler" style="wrapped"&gt;  &lt;parameter name="name" value="Guide Counter Provider Factory"/&gt;  &lt;parameter name="instance-name" value="Guide Counter Proivider Counter"/&gt;  &lt;parameter name="instance-schemaPath"                  value="schema/guide/Counter/counter_service.wsdl"/&gt;  &lt;parameter name="instance-className"                  value="org.globus.ogsa.guide.Counter.wsdl.CounterPortType"/&gt;  &lt;parameter name="instance-baseClassName"                  value="org.globus.ogsa.impl.ogsi.GridServiceImpl"/&gt;  &lt;parameter name="instance-operationProviders"                  value="org.globus.ogsa.guide.impl.CounterProvider"/&gt;  &lt;parameter name="persistent" value="true"/&gt;  &lt;parameter name="schemaPath"                  value="schema/ogsi/ogsi_notification_factory_service.wsdl"/&gt;  &lt;parameter name="baseClassName"                  value="org.globus.ogsa.impl.ogsi.PersistentGridServiceImpl"/&gt;  &lt;parameter name="handlerClass"                  value="org.globus.ogsa.handlers.RPCURIProvider"/&gt;  &lt;parameter name="className"                  value="org.gridforum.ogsi.NotificationFactory"/&gt;  &lt;parameter name="allowedMethods" value="*"/&gt;  &lt;parameter name="factoryCallback"                 value="org.globus.ogsa.impl.ogsi.DynamicFactoryCallbackImpl"/&gt;  &lt;parameter name="operationProviders"                 value="org.globus.ogsa.impl.ogsi.FactoryProvider org.                globus.ogsa.impl.ogsi.NotificationSourceProvider"/&gt; &lt;/service&lt;/deployment&gt;</pre><P><A HREF="#rl6">Back to Article</A></P><H4><A NAME="l7">Listing Seven</H4><pre>&lt;ant antfile="${build.packages}" target="makeGar"&gt;  &lt;property name="gar.name" value="${build.lib}/guide.gar"/&gt;  &lt;property name="garlib.dir" value="${build.lib}"/&gt;  &lt;property name="garserverdeployment.file" value="guide-config.wsdd"/&gt;  &lt;property name="garschema.origin" value="${build.schema}/guide"/&gt;  &lt;property name="garschema.path" value="guide"/&gt;&lt;/ant&gt;</pre><P><A HREF="#rl7">Back to Article</A></P><H4><A NAME="l8">Listing Eight</H4><pre>/* "Counter" grid service client JAX-RPC example provided with Globus  * Toolkit 3. Refer to GT3 Java Programmers Guide Core Framework for details. */OGSIServiceGridLocator gridLocator = new OGSIServiceGridLocator();Factory factory = gridLocator.getFactoryPort(handle);GridServiceFactory gridFactory = new GridServiceFactory(factory);LocatorType locator = gridFactory.createService();CounterServiceGridLocator counterLocator = new CounterServiceGridLocator();CounterPortType counter = counterLocator.getCounterPort(locator);int val = counter.add(2);  </pre><P><A HREF="#rl8">Back to Article</A></P></body></html>