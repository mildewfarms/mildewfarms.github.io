<html><head><title>Sep03: Programmer's Toolchest</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Ant, Cpptasks,  &amp; Multiplatform  C/C++ Projects</h1><p><i>Dr. Dobb's Journal</i> September 2003</p><h2>Migrating from  Make to Ant</h2><h3>By Mirko Raner </h3><I>Mirko is a software engineer for PTSC and can be contacted at mraner@ptsc.com.</I><hr><p>Ant is a platform-independent build utility that uses XML as its script language. Besides controlling the actual build process, Ant (http://ant.apache.org/) supplies platform-independent command implementations (tasks) that handle classic shell operations such as copying, deleting, zipping, or directory creation. For its part, cpptasks is an Ant extension for building C and C++ projects, and is maintained by the ANT Contrib project (http://sf.net/projects/ant-contrib/). In this article, I use Ant and cpptasks to build a multiplatform C/C++ application, and share tips for migrating existing projects from Make to Ant. </p><h3>The Ant Philosophy</h3><p>Being a pure Java solution, Ant is a fully platform-independent build tool. A top-level project of the Apache Software Foundation, Ant was primarily designed to drive the Java compiler and other platform-independent Java tools. Essentially, Ant assumes there is only one toolset that is invoked the same way on all development platforms. Ant is unaware of different target platforms; it targets only the abstract platform of the Java Virtual Machine.</p><DDJADVERTISEMENT INLINE><p>This single-platform notion of platform independence does not necessarily support multiplatform development. For C/C++ projects, for instance, a different idea of platform independence is required. The actual target platforms can no longer be treated as identical. Different files have to be produced for Windows, Linux, or Solaris, and different compilers with different sets of command-line options have to be used to produce them.</p><p>Cpptasks addresses this problem by extending Ant's XML-based build description language with a C/C++ compilation task and providing compiler adapters for a variety of compilers (including GCC). You specify compiler options using abstract XML attributes. The compiler adapter chooses the appropriate command-line options for the selected compiler.</p><p>Ant does not provide built-in support for multiplatform builds. You must provide the Ant code that properly configures the compiler and linker for the current build platform. Consequently, Ant build scripts for C/C++ are structurally different from scripts for Java.</p><p><A NAME="rl1"><A HREF="#l1">Listing One</A> is an Ant script that builds an executable from a single source file, hello.c. The default name for Ant build scripts is always "build.xml." To build the project, just type <i>ant</i>. The script file in <A NAME="rl1"><A HREF="#l1">Listing One</A> is surprisingly large, considering that a one-liner for Make is equivalent to:</p><blockquote><p>hello: hello.c; $(CC) -o $@ hello.c</p></blockquote><p>Due to the structure of XML files, Ant build scripts are always larger and more verbose than makefiles. In makefiles, it is sufficient to write <i>hello: hello.c</i> to specify a target and its dependency. The proper XML statement to specify the same target in Ant is<i> &lt;target name="hello"&gt;</i>, which also requires a matching <i>&lt;/target&gt;</i> statement and does not even express the dependency on the file hello.c. In fact, Ant does not require source files to be listed as dependencies. Only Ant targets can act as dependencies for other targets.</p><p>Every Ant build script in <A NAME="rl1"><A HREF="#l1">Listing One</A> begins with a <i>&lt;project...&gt; </i>element and ends with <i>&lt;/project&gt;.</i> Inside the project, you define properties and targets. A property is roughly comparable to a Make variable. However, Ant properties are immutable: Once defined, they cannot be changed. Ant targets are also similar to Make targets. Each target contains zero or more so-called "tasks." Compiling or copying files are common Ant tasks.</p><p>The <i>taskdef</i> and <i>typedef</i> elements at the beginning of the build script initialize the new tasks that are provided by the cpptasks package. These two elements are required in every Ant build script that uses cpptasks.</p><h3>Initialization Target</h3><p>The <i>init</i> target initializes all platform-dependent properties to their specific values. This target is only a suggestion and you can name it anything you like. However, such an initialization target is indispensable for most multiplatform projects. Generally, Ant properties are defined at project level (that is, outside any particular target). However, conditional expressions depend on the use of the <i>condition</i> task, and the Ant syntax allows tasks only inside a target definition. In my example, the <i>init</i> task sets the property <i>cc</i> to <i>gcc</i> on a UNIX platform, and <i>msvc</i> under Windows, thus selecting GCC or Visual C/C++. All C/C++ targets in the build must directly or indirectly depend on this <i>init</i> target.</p><h3>The <i>cc</i> Task</h3><p>Finally, the target <i>hello</i> contains the actual instructions for producing an executable file from the source file hello.c. In Ant, the name of the target is not identical to the name of the produced file, which is an advantage in this case, since the output file name might differ between platforms.</p><p>The <i>name</i> attribute of the <i>cc</i> task selects the compiler adapter specified by the property <i>cc</i>, initialized by the <i>init</i> task. The output file name specified by the <i>outfile</i> attribute serves only as a base name; the <i>cc</i> task adds extensions (like <i>.exe</i>) or prefixes (like <i>lib</i>) as necessary.</p><p>Unfortunately, standard Ant tasks are not aware of platform-specific naming differences for C/C++-related files; the build script in <A NAME="rl2"><A HREF="#l2">Listing Two</A> contains a more advanced initialization task that defines additional properties for filename prefixes and extensions.</p><p>A significant advantage of the <i>cc</i> task over Make is its built-in dependency analysis. Makefiles have to specify the complete dependency graph of all source and header files. Usually, <i>makedepend</i> generates these dependency lists for larger projects, but this approach has problems. Manual invocation of <i>makedepend</i> can easily be forgotten (possibly leading to some files not being properly rebuilt). Automatic invocation in every build can be time consuming. The <i>cc</i> task always performs an automatic dependency analysis for all files in a fileset and caches the results in a dependencies.xml file.</p><p>The compiler adapters provided by cpptasks allow platform-independent selection of most important compiler features. The adapter automatically maps the following attributes to the proper compiler switches:</p><ul>  <li><i>outtype</i>. The type of output that shall be produced; possible values are <i>executable</i> (the default), <i>static</i> (for archives or static libraries; .lib/.a), and <i>shared</i> for DLLs or lib.so files.  <li><i>runtime</i>. The method used to link with run-time libraries; possible values are <i>static</i> and <i>dynamic</i>.   <li><i>multithreaded</i>. The multithreading requirements of the output file; can be <i>true</i> or <i>false</i>.  <li><i>warnings</i>. The warning level during compilation: <i>none, severe, default, production, diagnostic, </i>and<i> failtask.</i>  <li><i>debug</i>. The generation of debugging information; can be <i>true</i> or <i>false</i>.</ul><p>While most common situations can be addressed with these attributes, the need for advanced control of the compiler or linker will eventually arise. Examples for such situations are nonstandard <i>include</i> or library paths, special symbols that need to be defined on the command line, or compiler options that take advantage of processor-specific features.</p><h3>Advanced Compiler and Linker Control</h3><p>Cpptasks provides a <i>compiler</i> and a <i>linker</i> element for additional control of the compilation and linking step. These elements can appear at project level or as nested elements of the <i>cc</i> task. Both types of elements can have a unique reference ID tag, which allows you to refer to them in various places without the necessity of repeating the whole element all the time. It is also possible to extend an existing element, similar to extending a C++ or Java class. This is a particularly nice feature because it reduces redundancies in the build script.</p><p>Unfortunately, at least with the current version of cpptasks, the <i>compiler</i> and <i>linker</i> elements must be nested in the <i>cc</i> task element to have an effect. Though these elements may be defined at project level, they always have to be referenced from within the <i>cc</i> task. If you have specified global features by <i>compiler/linker</i> elements, each <i>cc</i> element must at least repeat a definition like:</p><blockquote><p>&lt;compiler refid="${cc}-compiler"/&gt;</p><p>&lt;linker refid="${cc}-linker"/&gt;</p></blockquote><p>The expression <i>${cc}-compiler </i>evaluates to "gcc-compiler" or "msvc-compiler" depending on the value of the <i>cc</i> property. <i>Compiler</i> and <i>linker</i> elements on the global project level cannot make references to platform-dependent properties that are dynamically defined by the <i>init</i> target. Ant parses and processes project-level elements before the <i>init</i> target gets executed.</p><h3>Configuration Levels</h3><p>Compiler and linker configuration plays a crucial role in a multiplatform build procedure. The main goal here is to avoid redundancies and keep the configuration as simple as possible. Typically, you have to consider multiple levels of configuration items such as:</p><ul>  <li>Global configuration items, which apply to all targets on all platforms; for example, you might want to generally disable nonANSI language extensions and enable all warnings.  <li>Platform-specific configuration items, which apply only to a specific platform; optimization features are a good example here.  <li>Target-specific configuration. Certain individual targets might require a special configuration (on all platforms or only on some particular platforms); for example, certain symbols might have to be predefined for some targets</ul><p><A NAME="rl2"><A HREF="#l2">Listing Two</A> is an advanced Ant build script that uses these configuration levels. The example project consists of a few (imaginary) C sources for a Java Native Interface (JNI) library.</p><p>The global compiler configuration has the reference ID <i>cc</i>. The configuration specifies that every compiler run (for every target and every platform) defines the symbol _POSIX_SOURCE to enforce POSIX compatibility. cpptasks adds -D_POSIX_SOURCE (under UNIX) or /D_POSIX_SOURCE (for Visual C/C++) to the compiler command line.</p><p>The platform-specific configurations <i>gcc-</i>compiler and <i>msvc-</i>compiler are both derived from the basic <i>cc</i> configuration (note that the reference ID "<i>cc</i>," the property "<i>cc,</i>" and the <i>cc</i> task reside in different namespaces and thus do not conflict). The <i>name</i> attribute in the compiler element specifies the compiler adapter for which the configuration applies. Both configurations add a compiler-specific switch for disabling nonANSI extensions. This makes the ANSI strictness a global configuration feature, though it is activated differently for each compiler (<i>-ansi</i> versus <i>/Za</i>).</p><p>For the Visual C/C++ compiler, the configuration selects an additional platform-specific option to optimize for Pentium processors (/G5).</p><p>The target <i>jnidemo</i> demonstrates a target-specific configuration. Its nested <i>compiler</i> element extends the selected compiler configuration, adds additional <i>include</i> paths for JNI header files, and also disables optimizations. The correct compiler-specific option flag is selected using the optional <i>if</i> attribute of the <i>compilerarg</i> element.</p><p>The linker configuration follows the same principles as the compiler configuration.</p><h3>More Properties and Targets</h3><p><A NAME="rl2"><A HREF="#l2">Listing Two</A> also defines additional platform-specific properties in its <i>init</i> target. The properties<i> lib, static, shared, obj,</i> and <i>exe</i> define platform-specific filename extensions and prefixes. These properties are essential for standard Ant tasks that are unaware of platform-specific naming conventions. The clean-up tasks <i>jnilib-clean </i>and <i>jnidemo-clean</i> use these properties to make sure that the right files are deleted on each platform.</p><p>Similar to the <i>clean</i> target in a makefile, every Ant build script should have one or more targets to remove all produced files. Clean-up target names that end in "-<i>clean</i>" are only a naming suggestion; you can name the clean-up targets anything you like.</p><p>In addition to properties like <i>cc</i>, which have a platform-specific value ("<i>gcc</i>" or "<i>msvc</i>"), it is also often helpful, or even obligatory, to have Boolean properties that allow you to distinguish between different platforms. The <i>init</i> task in <A NAME="rl2"><A HREF="#l2">Listing Two</A> alternatively defines the Boolean property <i>msvc</i> or <i>gcc</i> based on the value of the <i>cc</i> property (see the statements <i>&lt;condition property="msvc"&gt;</i> and<i> &lt;condition property="gcc"&gt;</i>). Among other things, such Boolean properties are required as arguments for the <i>if</i> attribute, which is supported by a large number of Ant tasks and elements. Examples for the use of a Boolean property are the <i>&lt;compilerarg value="-O0" if="gcc"/&gt; </i>statement in the compiler configuration of the <i>jnidemo </i>target<i>,</i> or the definition of the property <i>additionalfiles </i>in the <i>jnidemo-clean</i> target.</p><h3>Common Pitfalls</h3><p>Frequent testing on all targeted platforms during the initial development of a multiplatform Ant build script will keep you out of trouble. Usually, Ant scripts for Java projects are not suitable as template scripts for C/C++ projects. Some common pitfalls are:</p><p></p><ul>  <li>Use of * and ** wildcards, commonly used in Java projects, increases the chance of unwanted source files getting pulled into a build. Instead, use Ant filesets that individually list the source files that are part of the build.  <li>Wrong property type for directory paths. Ant properties that are defined with the <i>value=...</i> attribute will not undergo automatic conversion of path naming schemes (such as "/" versus "\"). Use the <i>location=...</i> attribute for properties that represent directory paths.  <li>Wrong relative paths in the <i>cc</i> task. If the <i>objdir</i> attribute is specified in the <i>cc</i> task, the compiler adapter changes into the specified directory before invoking the compiler. Relative paths that are supplied by nested elements inside the <i>cc</i> task must be relative to that specified object directory (not the current directory).  <li>Redundant use of string constants. If in doubt,you should use a property rather than a string constant. For example, instead of adding the attribute <i>runtime="dynamic" </i>to all <i>cc</i> tasks in a script, it is better to define a property <i>rt</i> (for example) and use <i>runtime="${rt}"</i> instead. In case of a change, you only have to modify one property definition.  <li>Outdated cpptasks package. There are only very infrequent releases of cpptasks. Check out the current CVS repository for the latest bug fixes. </ul><h3>Ant Pros and Cons </h3><p>Ant is not a silver bullet. Generally, Ant build scripts are much larger than makefiles, usually by a factor of 2 or 3. If your goal is to save keystrokes, and your makefiles work fine for all your target platforms, Ant is probably not for you. Also, Ant build scripts usually have a much higher level of redundancy than makefiles. After all, Make's classic shorthands (or "automatic variables") $&lt;, $^, and $@ do not only reduce the size of makefiles, but also their redundancy: In Make, you usually have to change the name of a target or a file only in one place, because repeated occurrences usually refer to the same file or target with an automatic variable. Such luxury is not available in Ant&#151;at least not for the time being. Especially for small projects, Ant also has a noticeable overhead for JVM start-up and initial XML processing. An Ant build will, therefore, take a little longer than a build with Make. Fortunately, in larger projects, this overhead usually does not carry too much weight.</p><p>On the other hand, Ant has a number of advantages to offer. Thanks to cpptasks, these advantages are now also available for the C/C++ world. A carefully written Ant build script can run without any modifications on a number of different platforms. The standard Ant tasks provide a platform-independent replacement for shell commands or built-in command interpreter commands, which have caused trouble in the past even if the same variation of Make was used on all platforms. The XML-based build scripts can be easily processed in an automatic fashion with a large number of freely available XML transformation tools. The dependency-analysis features provided by cpptasks can save a lot of hassle with <i>makedepend</i>. And Java projects that also contain JNI libraries written in C or C++ can now be built from a single Ant script; no separate makefile for building the C/C++ part is required. </p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>&lt;?xml version="1.0"?&gt;&lt;project name="Hello" default="hello" basedir="."&gt; &lt;taskdef resource="cpptasks.tasks"/&gt; &lt;typedef resource="cpptasks.types"/&gt; &lt;target name="init"&gt;  &lt;condition property="cc" value="msvc"&gt;   &lt;os family="windows"/&gt;  &lt;/condition&gt;  &lt;condition property="cc" value="gcc"&gt;   &lt;os family="unix"/&gt;  &lt;/condition&gt; &lt;/target&gt; &lt;target name="hello" depends="init"&gt;  &lt;cc name="${cc}" outfile="hello"&gt;   &lt;fileset dir="." includes="hello.c"/&gt;  &lt;/cc&gt; &lt;/target&gt;&lt;/project&gt;</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>&lt;?xml version="1.0"?&gt;&lt;project name="JNI Demo" default="jnidemo" basedir="."&gt; &lt;taskdef resource="cpptasks.tasks"/&gt; &lt;typedef resource="cpptasks.types"/&gt; &lt;property environment="getenv"/&gt; &lt;compiler id="cc"&gt;  &lt;defineset define="_POSIX_SOURCE"/&gt; &lt;/compiler&gt; &lt;compiler name="gcc" id="gcc-compiler" extends="cc"&gt;  &lt;compilerarg value="-ansi"/&gt; &lt;/compiler&gt; &lt;compiler name="msvc" id="msvc-compiler" extends="cc"&gt;  &lt;compilerarg value="/Za"/&gt;  &lt;compilerarg value="/G5"/&gt; &lt;/compiler&gt; &lt;linker name="gcc" id="gcc-linker"/&gt; &lt;linker name="msvc" id="msvc-linker"&gt;  &lt;linkerarg value="/libpath:${getenv.MSDEVDIR}\lib"/&gt; &lt;/linker&gt; &lt;target name="init"&gt;  &lt;condition property="cc" value="msvc"&gt;   &lt;os family="windows"/&gt;  &lt;/condition&gt;  &lt;condition property="cc" value="gcc"&gt;   &lt;os family="unix"/&gt;  &lt;/condition&gt;  &lt;condition property="msvc"&gt;   &lt;equals arg1="${cc}" arg2="msvc"/&gt;  &lt;/condition&gt;  &lt;condition property="gcc"&gt;   &lt;equals arg1="${cc}" arg2="gcc"/&gt;  &lt;/condition&gt;  &lt;condition property="lib" value=""&gt;   &lt;isset property="msvc"/&gt;  &lt;/condition&gt;  &lt;condition property="lib" value="lib"&gt;   &lt;isset property="gcc"/&gt;  &lt;/condition&gt;  &lt;condition property="static" value=".lib"&gt;   &lt;isset property="msvc"/&gt;  &lt;/condition&gt;  &lt;condition property="static" value=".a"&gt;   &lt;isset property="gcc"/&gt;  &lt;/condition&gt;  &lt;condition property="shared" value=".dll"&gt;   &lt;isset property="msvc"/&gt;  &lt;/condition&gt;  &lt;condition property="shared" value=".so"&gt;   &lt;isset property="gcc"/&gt;  &lt;/condition&gt;  &lt;condition property="obj" value=".obj"&gt;   &lt;isset property="msvc"/&gt;  &lt;/condition&gt;  &lt;condition property="obj" value=".o"&gt;   &lt;isset property="gcc"/&gt;  &lt;/condition&gt;  &lt;condition property="exe" value=".exe"&gt;   &lt;isset property="msvc"/&gt;  &lt;/condition&gt;  &lt;condition property="exe" value=""&gt;   &lt;isset property="gcc"/&gt;  &lt;/condition&gt;  &lt;condition property="platform" value="linux"&gt;   &lt;os name="Linux"/&gt;  &lt;/condition&gt;  &lt;condition property="platform" value="win32"&gt;   &lt;os family="windows"/&gt;  &lt;/condition&gt;  &lt;condition property="platform" value="solaris"&gt;   &lt;os name="SunOS"/&gt;  &lt;/condition&gt; &lt;/target&gt; &lt;target name="jnilib" depends="init"&gt;  &lt;cc name="${cc}" outfile="jnilib" outtype="static"&gt;   &lt;compiler refid="${cc}-compiler"/&gt;   &lt;linker refid="${cc}-linker"/&gt;   &lt;fileset dir="." includes="jnilib1.c jnilib2.c"/&gt;  &lt;/cc&gt; &lt;/target&gt; &lt;target name="jnidemo" depends="jnilib"&gt;  &lt;cc name="${cc}" outfile="jnidemo" outtype="shared"&gt;   &lt;compiler extends="${cc}-compiler"&gt;    &lt;includepath location="${java.home}/../include"/&gt;    &lt;includepath location="${java.home}/../include/${platform}"/&gt;    &lt;compilerarg value="-O0" if="gcc"/&gt;    &lt;compilerarg value="/Od" if="msvc"/&gt;   &lt;/compiler&gt;   &lt;linker refid="${cc}-linker"/&gt;   &lt;fileset dir="." includes="jnidemo.c"/&gt;   &lt;libset dir="." libs="jnilib"/&gt;  &lt;/cc&gt; &lt;/target&gt; &lt;target name="jnilib-clean" depends="init"&gt;  &lt;delete&gt;   &lt;fileset dir="." includes="*${obj}"/&gt;   &lt;fileset dir="." includes="${lib}jnilib${static}"/&gt;  &lt;/delete&gt; &lt;/target&gt; &lt;target name="jnidemo-clean" depends="init"&gt;  &lt;condition property="additionalfiles" value=""&gt;   &lt;isset property="gcc"/&gt;  &lt;/condition&gt;  &lt;condition property="additionalfiles"   value="jnidemo.lib jnidemo.exp"&gt;   &lt;isset property="msvc"/&gt;  &lt;/condition&gt;  &lt;delete&gt;   &lt;fileset dir="."    includes="jnidemo${obj} ${lib}jnidemo${shared} ${additionalfiles}" /&gt;  &lt;/delete&gt; &lt;/target&gt; &lt;target name="clean" depends="jnidemo-clean, jnilib-clean"/&gt;&lt;/project&gt;</pre><P><A HREF="#rl2">Back to Article</A></P></body></html>