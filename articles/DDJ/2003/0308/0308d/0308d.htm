<html><head><title>Aug03: Creating .INI Classes in Java</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Creating .INI Classes in Java</h1><p><i>Dr. Dobb's Journal</i> August 2003</p><h2>An alternative to Properties</h2><h3>By Mark Meyer</h3><I>Mark is a software developer on Team RateView with TravelClick (http://www.TravelClick.net/). Mark can be reached at geeky2@gte.net.</I><hr><p>I recently worked on a project that required reading standard Microsoft-style .ini files in Java. Although the JDK 1.4 does not specifically provide an .<i>ini</i> class, I thought that either the JDK 1.4 java.util.Properties or the Preferences API would do the job. I quickly discovered, however, that neither cleanly translates to the standard .ini file format. By "standard" .ini file format, I mean a format similar to Microsoft's .ini file format, where text entries are organized by sections, each section with corresponding key/value pairs separated by an equals sign (=), and comments that use semicolons (;) and pound signs (#); see <A NAME="re1"><A HREF="0308de1.htm">Example 1</A>.</p><p>With this in mind, I created <i>IniFile</i>, a lightweight Java class that reads standard .ini text files into memory, lets you manipulate their contents, and store the various sections with their corresponding key/value pairs in memory.<i></p><DDJADVERTISEMENT INLINE><p>IniFile</i> (available electronically; see "Resource Center," page 5) has one public constructor, which takes two parameters. The first parameter is a <i>String</i> object pointing to a disk file; and the second parameter is a Boolean indicating whether the <i>IniFile</i> class should be case sensitive. If this parameter is False, then <i>IniFile</i> turns case sensitivity off (see <A NAME="rl1"><A HREF="#l1">Listing One</A>). After calling the <i>IniFile</i> constructor, you call the <i>loadFromFile()</i> method (<A NAME="rl2"><A HREF="#l2">Listing Two</A>) to load the contents of an .ini file in to memory. Calling the <i>IniFile</i> constructor and the <i>loadFromFile()</i> method on a file that does not exist causes no problems. In fact, this is what you need to do to create new files right from the start.</p><h3>Working with <i>IniSections</i></h3><p>After loading <i>IniFile</i> (be it empty or not), you can create a new section or read from an existing section in the <i>IniFile</i> object. The <i>IniFile</i> class relies upon another class&#151;<i>IniSection</i> (available electronically). Just as a typical .ini file has one or more sections designated by square brackets <i>[MySection]</i>, the <i>IniFile </i>class creates one <i>IniSection</i> object for each section it finds in the file. If you want to add a section to your in-memory <i>IniFile</i> object, invoke the <i>addSection()</i> method, passing in the name of the section identifier you want to create:</p><blockquote><p>inf.loadFromFile();</p><p>iniSection sect = inf.addSection("fruit");</p></blockquote><p>As <A NAME="rf1"><A HREF="0308df1.htm">Figure 1</A> illustrates, <i>IniFile</i> also provides public methods to delete a section (<i>public void deleteSection(String value)</i>), get a pointer to an existing section (<i>public IniSection getSection(String name)</i>), get a collection of all sections (<i>public Set getSections()</i>), and query as to whether a given section exists (<i>public boolean hasSection(String value)</i>).</p><p>The <i>IniSection</i> class encapsulates a specific section in a given .ini file. A typical section has one or more key/value pairs that are separated by an equals sign:</p><blockquote><p>[fruit]</p><p>banana = yellow</p></blockquote><p>The <i>IniSection</i> class (<A NAME="rf2"><A HREF="0308df2.htm">Figure 2</A>) provides accessor methods to delete a key (<i>public void deleteKey(String key)</i>), get a collection of the keys in a section (<i>public Set getKeys()</i>), get a value given a key (<i>public String getValue(String key)</i>), get a collection of values (<i>public Set getValues()</i>), determine whether a key exists (<i>public boolean hasKey(String key)</i>), determine whether a value exists (<i>public boolean hasValue(String value)</i>), set the value of key/value pairs (<i>public void setValue (String key, String value)</i>), and return the section represented as a property of java.util.Properties (<i>public Properties getProperties()</i>).</p><h3>Writing to Disk with <i>IniFile</i></h3><p><i>IniFile</i> works with the contents of an .ini file in memory after calling the <i>loadFromFile()</i> method. When you're ready to write changes to disk, simply invoke the <i>flushToFile()</i> method (<A NAME="rl3"><A HREF="#l3">Listing Three</A>), and <i>IniFile</i> does the rest. This scratch-pad ability also lets you load the contents of one file, make changes in memory, then write the contents out to another file.</p><p>The <i>IniFile</i> class relies on a <i>LinkedHashMap</i> class to maintain an ordered list of its sections. I chose <i>LinkedHashMap</i> because, according to JDK 1.4, iteration, ordering is defined and is normally the order in which keys are inserted into the <i>LinkedHashMap</i> object. Just as with <i>IniFile</i>, the <i>IniSection</i> object utilizes a <i>LinkedHashMap</i> class to maintain its list of key/value pairs.</p><p>When <i>IniFile</i> parses a file into memory, it creates an <i>IniSection</i> object for each section it finds in the file. It then populates the <i>IniSection</i> object by calling the <i>setValue()</i> method, passing in the key and value. The <i>setValue()</i> method (<A NAME="rl4"><A HREF="#l4">Listing Four</A>) is simply a wrapper method that first checks to see whether case sensitivity is on, then checks whether the key already exists in the internal <i>LinkedHashMap _map</i>. If the key does not exist, it calls the <i>put() </i>method of the <i>LinkedHashMap</i> class (available electronically).</p><p>When an <i>IniSection</i> has been filled in, the <i>IniFile</i> class calls the put method of its <i>LinkedHashMap (_sectionMap)</i>, passing in the name of the section and the now-filled-in <i>IniSection</i> object:</p><blockquote><p>_sectionMap.put(name, currentSection);</p></blockquote><h3>Maintaining Anonymity</h3><p>While first storing all the elements of an <i>IniSection</i> object in a <i>LinkedHashMap</i>, then storing the <i>IniSection</i> objects in another <i>LinkedHashMap,</i> makes things easy for the <i>IniFile</i> class, I still needed a mechanism to flag lines that contained white space and comments. I also needed a means of storing these special lines in the order they appeared in the file and writing them back out to a file&#151;while not having to worry about them during retrieval processes. The trick is to treat comment and whitespace lines as if they're keys and sections, but still make them anonymous so they cannot be retrieved. </p><p>For instance, if <i>IniFile</i> found:</p><blockquote><p>1 # comment 1</p><p>2 # comment 2</p><p>3 # comment 3</p><p>4 [MyFirstSection]</p></blockquote><p>at the top of a file, it would interpret and store lines 1-3 as anonymous sections. It doesn't matter to <i>IniFile</i> that the anonymous sections do not have associated key/value pairs. Line 4 would be stored as a legitimate section line.</p><p>In <A NAME="rl5"><A HREF="#l5">Listing Five</A>, <i>IniFile</i> treats lines 1-4 as anonymous sections, even though two of the lines are whitespace lines (just like the comment lines). Again, line 5 is accepted as a legitimate section line, and lines 6-7 are stored as anonymous keys under a legitimate section tag <i>[MyFirstSection]</i>. Finally, lines 8-9 are stored as legitimate keys, and line 10 as another legitimate section.</p><h3>The Not So Obvious</h3><p>During testing, I searched my hard drive for files with a mask of "*.ini," in hopes of finding some large and complicated examples that would produce good test cases. Out of the gate, I found OPCTRNM.INI located in the C:\ORANT\DBS directory. When I opened it with TextPad, I found C++-style comment lines similar to <A NAME="rf3"><A HREF="0308df3.htm">Figure 3</A>&#151;even though you only use semicolons or pound signs to indicate a comment in .ini files. The last thing I wanted to do was to change code every time a new comment string indicator came along. As luck would have it, I was working with javaCC (http://www.webgain.com/products/java_cc/), which lets you build parser logic. As it turns out, the syntax for defining acceptable token values for the parser (<A NAME="re2"><A HREF="0308de2.htm">Example 2</A>) is exactly what I needed. By applying this concept to my <i>IniFile</i> class, users can dynamically define any comment indicator they want. To provide this functionality, I use a java.util.HashMap class <i>named _commentTable </i>to store the comment indicators. Access to <i>_commentTable</i> is provided via the public method <i>addComment</i>. Comments are defined in the <i>HashMap</i> table as name/value pairs (see <A NAME="rl6"><A HREF="#l6">Listing Six</A>). Now, with one method invocation, you can define any comment indicator string (<A NAME="rl7"><A HREF="#l7">Listing Seven</A>).</p><p>Finally, I set up a Boolean flag in the constructor (<A NAME="rl8"><A HREF="#l8">Listing Eight</A>) to provide case sensitivity. This flag allows decision making to be done when calling internal methods such as <i>hasKey()</i> and <i>setValue()</i>.</p><h3>Conclusion</h3><p>There are any number of things you can do to make <i>IniFile</i> more useful. For instance, try using a switch to the <i>IniFile</i> constructor, letting it automatically load "default" comments into the comment table. This would prevent users of the class from having to use the <i>loadComment() </i>method each time.</p><p></p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>// constructorpublic IniFile( String filePathName, boolean caseOn ) throwsIOException {  this.setCaseOn(caseOn);  this.setLineNumberRead(filePathName);}// turn case sensitivity offIniFile inf = new IniFile(args[0],false);</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>// load the contents of the file passed in to the contructorinf.loadFromFile();</pre><P><A HREF="#rl2">Back to Article</A></P><H4><A NAME="l3">Listing Three</H4><pre> // create IniFile object from mark.iniIniFile inf = new IniFile("c:\\mark.ini",false);inf.loadFromFile();// add a section in memoryIniSection sect = inf.addSection("fruit");// add a key+value pair under the "fruit" sectionsect.setValue("banana","yellow");// write contents of memory out to mega.iniinf.setFileName("c:\\mega.ini");inf.flushToFile();</pre><P><A HREF="#rl3">Back to Article</A></P><H4><A NAME="l4">Listing Four</H4><pre>currentSection = new IniSection( name, this.getCaseOn() );public void setValue (String key, String value){  String s;  if (getCaseOn()){    s = key.toUpperCase();  }  else{    s = key;  }  if (!this.hasKey(key)){    _map.put( s, value );  }}</pre><P><A HREF="#rl4">Back to Article</A></P><H4><A NAME="l5">Listing Five</H4><pre>1 # comment 12 &lt;white space here3 # comment 24 &lt;white space here5 [MyFirstSection]6 &lt;white space here7 ; comment = 3 very bogus8 banana = yellow9 apple = red10 [MyNextSection]</pre><P><A HREF="#rl5">Back to Article</A></P><H4><A NAME="l6">Listing Six</H4><pre>private HashMap _commentTable = new HashMap();public void addComment(String name, String value){   _commentTable.put(name,value);}</pre><P><A HREF="#rl6">Back to Article</A></P><H4><A NAME="l7">Listing Seven</H4><pre>IniFile inf = new IniFile("c:\mark.ini",false);inf.addComment("POUND","#");inf.addComment("SEMICOLON",";");inf.addComment("DOUBLESLASH","//");</pre><P><A HREF="#rl7">Back to Article</A></P><H4><A NAME="l8">Listing Eight</H4><pre>public void setValue (String key, Stringue){  String s;  if (getCaseOn()){     s = key.toUpperCase();  }  else{    s = key;  }  if (!this.hasKey(key)){    _map.put( s, value );  }}</pre><P><A HREF="#rl8">Back to Article</A></P></body></html>