<html><head><title>Aug03: Overriding the  C++ Operator==</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Overriding the  C++ Operator==</h1><p><i>Dr. Dobb's Journal</i> August 2003</p><h2>An approach that  uses the Template Method design pattern</h2><h3>By Daniel E. Stevenson and  Andrew T. Phillips</h3><I>Daniel is an assistant professor and Andrew chair of the Computer Science Department at the University of Wisconsin-Eau Claire. They can be contacted at stevende@uwec.edu and phillipa@uwec.edu, respectively. </I><hr><p>In his article "How Do I Correctly Implement the <i>equals()</i> Method?" (<i>DDJ</i>, May 2002), Tal Cohen presented a software design for overriding the Java <i>equals</i> method, a technique that is both elegant in design and (more importantly) semantically correct. In this article, we extend Tal's ideas in two ways. First, we present a design that handles complex inheritance situations, including cases where you want to have groups of different objects (from different classes) that remain members of the same equivalence class. Second, we present our design in C++, as well as in Java, to show that the basic design isn't a good Java design as much as it is a good object-oriented design.</p><p>Before jumping into the C++ version, we briefly review Tal's original design, but with two variations: <A NAME="rl1"><A HREF="#l1">Listing One</A> is our version of this Java design (see our paper "Implementing Object Equivalence in Java Using the Template Method Design Pattern," <i>Proceedings of the 34th SIGCSE Technical Symposium on Computer Science Education</i>, 2002). In our design, we have made explicit use of the Template Method design pattern (see <i>Design Patterns: Elements of Reusable Object-Oriented Software</i>, by Erich Gamma et al., Addison-Wesley, 1995) to factor out each class-specific definition of Tal's <i>blindlyEquals</i> so that our implementation of <i>equals</i> is now completely independent of any specific class. Thus, we have moved <i>equals</i> into the abstract super class <i>T,</i> the template class, which now supplies the invariant steps required to correctly implement equality. The variant code is still supplied by each subclass, such as our class <i>A</i> with its single private data member <i>x,</i> in <i>blindlyEquals</i>.</p><DDJADVERTISEMENT INLINE><p>Our second variation from the original design is in our inclusion of the method <i>getTypeEquiv</i>, which simply reports the name of the class (type) to which that instance wishes to belong. Following this design, instances from two different classes will now be able to report that they are really to be treated as the same type. This is important because the only way for two instances to be equal is if their corresponding types are the same and they both inherit from the super class <i>T.</i> Hence, each subclass will necessarily be required to supply a unique (and protected) version of <i>blindlyEquals</i> and of <i>getTypeEquiv</i> to make the proper private data-member comparisons and to report the appropriate class type, respectively.</p><p>If we now extend the class <i>A</i> with a subclass <i>B</i> containing a single private data member <i>y,</i> <A NAME="rl2"><A HREF="#l2">Listing Two</A> provides the versions of <i>blindlyEquals</i> and <i>getTypeEquiv</i> for class <i>B,</i> assuming that we do not want <i>A</i> and <i>B</i> to be of the same type.</p><p>In our Template Method design, each class-specific implementation of <i>blindlyEquals</i> requires a specific downcast of the argument into the appropriate type; and this cast is typesafe because the actual types of both <i>this</i> and <i>that</i> are checked and guaranteed to be the same by the use of <i>Class.forName</i> in the code for <i>getTypeEquiv</i>. Obviously, if <i>this</i> and <i>that</i> are members of the same class, then they are of identical types; and herein lies a key to why our design correctly adheres to the general contract for <i>equals</i>&#151;namely, that it satisfy the requirements of an equivalence relation.</p><p>What if you wanted to define a set of two or more different classes, all of which should be treated as the same type? For example, you might want to extend class <i>A</i> with class <i>B</i> in such a way as to permit overriding of some of the methods of <i>A,</i> but still maintain identical private data members. Or more generally, it might be desirable to simply define two different classes <i>A</i> and <i>B</i> both of which inherit from a common ancestor <i>C,</i> neither of which inherits from the other, and yet consider <i>A</i> and <i>B</i> to be equivalent types for the purposes of comparison. We call this concept "type equivalence." In either case, our design permits these generalizations as long as you adhere to the following rules:</p><ul>  <li>All of the classes that are in the same type-equivalent set <i>E</i> must have a common ancestor <i>RE</i> in the inheritance hierarchy, and <i>RE</i> also must be in the set <i>E</i>. Hence, <i>RE</i> is the canonical member for all of the type-equivalent classes in <i>E.</i>  <li>The template class <i>T</i> must be a proper ancestor of <i>RE</i> in the inheritance hierarchy.  <li><i>RE</i> must be the only member of the type-equivalent set <i>E</i> to define <i>getTypeEquiv</i> and <i>blindlyEquals</i>. All other members of <i>E</i> will therefore inherit these methods from <i>RE</i>.  <li>If <i>A</i> and <i>B</i> are both members of the type-equivalent set <i>E,</i> then all classes between <i>A</i> and <i>B</i> in the inheritance hierarchy must also be in <i>E</i>.</ul><p>To illustrate how these rules permit a variety of designs of type equivalence while maintaining semantic correctness, encapsulation, and code reuse, consider the example inheritance hierarchy in <A NAME="rf1"><A HREF="0308ef1.htm">Figure 1</A>.</p><p><A NAME="rf1"><A HREF="0308ef1.htm">Figure 1</A> shows three distinct type-equivalent sets: <i>A=A</i><sub>1</sub><i>,A</i><sub>2</sub><i>}, B={B</i><sub>1</sub><i>,B</i><sub>2</sub><i>,B</i><sub>3</sub><i>,B</i><sub>4</sub><i>},</i> and <i>C={C</i><sub>1</sub><i>}.</i> Each type-equivalent set has a top-most member (the canonical member <i>RE</i>) of the inheritance hierarchy: These are <i>A</i><sub>1 </sub>for <i>A, B</i><sub>1</sub> for <i>B</i>, and <i>C</i><sub>1</sub> for <i>C</i> in this example. Each of these canonical members is therefore required to define a version of <i>blindlyEquals</i> and of <i>getTypeEquiv</i>, but none of the other members of the inheritance hierarchy in this example would contain such methods. In particular, the subclasses <i>B</i><sub>2</sub>, <i>B</i><sub>3</sub>, and <i>B</i><sub>4</sub><sub> </sub>all would inherit <i>blindlyEquals</i> and <i>getTypeEquiv</i> from <i>B</i><sub>1</sub> because they are all in the same type-equivalent set as <i>B</i><sub>1</sub>.</p><p>Using this design allows two instances of the type-equivalent set <i>B</i> to be tested for equality based solely on the private data members of <i>B</i><sub>1</sub>. The fact that the two distinct instances may not be of the same actual Java type is of no consequence here because the downcast from an <i>Object</i> to a <i>B</i><sub>1</sub> performed in <i>blindlyEquals</i> is still typesafe (as guaranteed by <i>getTypeEquiv</i>). And, of course, the semantic correctness of <i>equals</i> is still maintained by our Template Method design.</p><p>Now for our C++ design, since one test of the value and generality of a good design is whether the same design is cleanly transferable to a different object-oriented language. In the case of our <i>equals</i> design and C++, we are interested in the overloading of the <i>operator==</i>.</p><p>Many of the same design and implementation issues relevant in Java are also issues in C++&#151;namely, providing the proper signatures, testing the argument for Null, ensuring <i>this</i> and <i>that</i> are type equivalent and then performing the corresponding downcast, and most importantly, ensuring that the operation actually implements an equivalence relation. In each case, there is a simple, if not particularly elegant, C++ solution. As an example, <A NAME="rl3"><A HREF="#l3">Listing Three</A> shows the C++ versions of the template base class <i>T</i> and subclass <i>A,</i> now implemented in C++.</p><p>The design similarities between the C++ version and our Java version are intentional and apparent. The only significant change in the design of the code (ignoring the obvious syntax and implementation-specific details of typecasting) is that the C++ version of <i>operator==</i> requires the template type <i>T</i> to be the argument in the signature because C++ has no overarching <i>Object</i>. This also permits us to drop the explicit <i>that instanceof T </i>inheritance check because this type compatibility test is required for compilation anyway. Also, the method <i>blindlyEquals</i> must explicitly be declared virtual (which is automatic in Java) so that all subclasses can override it and have their <i>blindlyEquals</i> methods selected dynamically (but the<i> operator== </i>method should not be virtual so as to discourage that dynamic behavior). Aside from this, the generality of our design makes it easily transferable to C++.</p><p>Regarding the importance of providing the proper method signatures for the <i>operator==</i>, consider the following common and yet flawed design, illustrated using UML in <A NAME="rf2"><A HREF="0308ef2.htm">Figure 2</A>, for overloading the <i>operator== </i>in a simple two-class inheritance hierarchy.</p><p>If you construct a signature tailored to the specific class (as is commonly done), such an approach will surely lead to a serious flaw. Consider <A NAME="rl4"><A HREF="#l4">Listing Four</A>. In <A NAME="rf2"><A HREF="0308ef2.htm">Figure 2</A>, the <i>operator==</i> is overloaded in class <i>B, </i>and the argument for that method can accept an object of type <i>B</i> but not <i>A</i>. What happens in <A NAME="rl4"><A HREF="#l4">Listing Four</A>? Java developers would answer that because class <i>A </i>has a version of <i>equals</i> with a signature that can accept an<i> A,</i> the result would be a call to the<i> operator==</i><i><b> </i></b>method available in class<i> A.</i> But in C++, the result is actually quite surprising&#151;the code doesn't compile. Why? Because the C++ mechanism for resolving dynamic method invocation uses a two-step process that:</p><p>1.	Finds the first enclosing scope in which the method name is defined (in this case, class <i>B</i>).</p><p>2.	Tries to match the signature with a method in that scope only. </p><p>In our example, there is no method in class <i>B </i>with a signature for <i>operator== </i>that can accept an argument of type<i> A</i>, even using a legal cast. Hence, the code won't compile. Of course, if the order of <i>instanceB</i> and <i>instanceA</i> were reversed in the conditional test of the example in <A NAME="rl4"><A HREF="#l4">Listing Four</A> (that is, *<i>instanceA == </i>*<i>instanceB</i>), the example would not only compile, but the code in class <i>A</i> would be executed. Thus, the <i>operator==</i> must be overloaded using only the most general base class (which is <i>T</i>).</p><p>If you take the position that each distinct class should define its own distinct type-equivalent set (and we certainly do), then the design is greatly simplified. In this case, <i>getTypeEquiv</i> would be moved into the template class <i>T</i> and made protected and final (or nonvirtual in C++) as in <A NAME="rl5"><A HREF="#l5">Listing Five</A>. In this way, each class identifies itself (using <i>getClass</i> in Java or <i>typeid</i> in C++) as distinct from all other classes, and there is no need or way for any class to ever override <i>getTypeEquiv</i>.</p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>abstract class T {    public final boolean equals(Object that) {        boolean isEqual = false;        if ((that != null) &amp;&amp; (that instanceof T)) {            T castedThat = (T) that;            if (this.getTypeEquiv().equals(castedThat.getTypeEquiv())) {                isEqual = blindlyEquals(that);            }        }        return isEqual;    }    protected boolean blindlyEquals(Object that) {        return true; // to stop the chaining    }    abstract protected Class getTypeEquiv();}class A extends T {    protected boolean blindlyEquals(Object that) {        A castedThat = (A) that;        // perform comparisons on private data        boolean isEqual = (this.x == castedThat.x);        return (isEqual &amp;&amp; super.blindlyEquals(that));    }   protected Class getTypeEquiv() {        Class result = null;        try { // will never fail, but must try/catch            result = Class.forName("A");        } catch (ClassNotFoundExeception e) { }        return result;    }    private int x;}</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>class B extends A {    protected boolean blindlyEquals(Object that) {        B castedThat = (B) that;        // perform comparisons on private data        boolean isEqual = (this.y == castedThat.y);        return (isEqual &amp;&amp; super.blindlyEquals(that));    }    protected Class getTypeEquiv() {        Class result = null;        try { // will never fail, but must try/catch            result = Class.forName("B");        } catch (ClassNotFoundExeception e) { }        return result;    }    private int y;}</pre><P><A HREF="#rl2">Back to Article</A></P><H4><A NAME="l3">Listing Three</H4><pre>class T {public:    bool operator==(const T &amp;that) const {        bool isEqual = false;        if ((&amp;that != NULL) &amp;&amp; (*(this-&gt;getTypeEquiv()) == *(that.getTypeEquiv()))) {            isEqual = (this-&gt;blindlyEquals(&amp;that));        }        return isEqual;    }protected:    virtual bool blindlyEquals(const T *that) const {        return true; // default to stop the chaining    }    virtual const type_info* getTypeEquiv() const = 0;};class A : public T {protected:    virtual bool blindlyEquals(const T *that) const {        const A *castedThat = dynamic_cast&lt;const A*&gt;(that);        // perform comparisons on private data        bool isEqual = (this-&gt;x == castedThat-&gt;x);        return (isEqual &amp;&amp; T::blindlyEquals(that));    }    virtual const type_info* getTypeEquiv() const {        return &amp;typeid(*(new A()));    }private:    int x;};</pre><P><A HREF="#rl3">Back to Article</A></P><H4><A NAME="l4">Listing Four</H4><pre>A *instanceA = new A;B *instanceB = new B;if (*instanceB == *instanceA) {    // which version of == will run??}</pre><P><A HREF="#rl4">Back to Article</A></P><H4><A NAME="l5">Listing Five</H4><pre>abstract class T { // Java version ... // same as before    protected final Class getTypeEquiv() {        return this.getClass();    }}class T { // C++ versionprotected:    const type_info* getTypeEquiv() const {        return &amp;typeid(*this);    }}</pre><P><A HREF="#rl5">Back to Article</A></P></body></html>