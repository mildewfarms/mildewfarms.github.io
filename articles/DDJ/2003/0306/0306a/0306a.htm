<html><head><title>Jun03: Route Control & Streaming Video</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Route Control &amp; Streaming Video</h1><p><i>Dr. Dobb's Journal</i> June 2003</p><h2>Monitoring and optimizing the delivery of streaming video</h2><h3>By Michael Larson</h3><I>Michael is a principal engineer working at Proficient Networks. He can be reached at mike@lrlart.com.</I><hr><a name="rs1"><a href="0306as1.htm">Routing/BGP/CIDR</a><hr><p>Video streams can be sensitive to unpredictable delays during transport of video packets across the Internet. And while the video codec, streaming server, hardware, number of concurrent connections, and network bandwidth are under your control, the path on which the streaming video travels is not. As it turns out, many streaming server sites have multiple delivery paths that video packets could potentially use. However, streaming video in particular is sensitive to what is called "jitter"&#151;that is, variability in the delivery times of the streamed packets.</p><p>In this article, I examine how an emerging technology called "route control" can improve streaming video quality, and I also present guidelines for building it into your server installation.</p><DDJADVERTISEMENT INLINE><h3>Route Control</h3><p>Route control is the ability to select the path of data packets as they leave your video server. Route control is possible when your server resides in a "multihomed" network&#151;one in which your server's network possesses more than one distinct external connection to the Internet. In multihomed networks, you control which network path video packets travel to their specific IP destinations. Differences in the quality of these paths can vary enormously. For instance, <A NAME="rf1"><A HREF="0306af1.htm">Figure 1</A> shows a typical network with network egress points for the streaming video server. Of the three paths, video streams on path 1 travel on a more stable path with lower jitter than those on path 2 or 3. Because of jitter in this example, the ratio of worst-path to best-path exhibits 70 times more instability than the preferred path. </p><p>In general, maintaining multihomed sites is complex and paths are assigned using the metrics of the routing protocol through which the paths were acquired. The assignment of these paths doesn't take into account application-specific metrics (jitter for streaming video, for instance) that have more meaning to the quality of the delivery of the data.</p><p>As data packets travel across the Internet, routers forward them to neighboring routers by determining which network prefix is associated with a destination address, then sending the packet to the next hop-gateway router associated with that prefix. Typically, there are 10 to 20 routers that forward data packets (up to a limit of 255) before a packet is dropped. Each path possesses different data transmission characteristics.</p><p>From a client's point of view, video stream playback is sensitive to variability in arrival times of the data packets at the client. Video streams are usually divided into temporal (time windowed) chunks of data, delivered with the expectation that they will arrive at the client within a certain time window. The inability for a client to predict this arrival time window for streaming packets could cause faults in the video playback. These changes in the elapsed travel time of packets are referred to as "jitter." Jitter that exceeds a threshold can play havoc with the buffer that the client has set up to receive the data. If the buffer has been exhausted before the next video packet arrives, the playback displays artifacts (halted playback or broken images), depending on the codec/player used. To deliver the highest quality video experience, jitter needs to be as low as possible.</p><p>Route control lets the source network minimize jitter by choosing the best available streaming path. By selecting the best route, you can experience an average improvement of 50 percent over the default path. Even better, this is a low-level optimization that affects all stream types, transports, video-on-demand, or live-streaming for the delivery of video.</p><h3>Controlling Video Routes</h3><p>Some multihomed networks have two network connections, others may have dozens of external connections. Each external connection represents a potential path to a specific destination. Finding out which path has better characteristics, then selecting that path, can be difficult&#151;but this is the essence of route control. </p><p>Among the capabilities that a video server's network route-controlling system should possess are the ability to:</p><ul>  <li>Communicate with client routers by using, for example, the BGP-4 protocol (see the accompanying text box entitled "Routing/BGP/CIDR").  <li>Probe or collect data on network path characteristics.  <li>Store and correlate results for decision making.</ul><p>The best way to support these capabilities is by using individual functional components. <A NAME="rf2"><A HREF="0306af2.htm">Figure 2</A> illustrates the functional relationships between these components and responsibilities (arrows denote communication paths between components). This route-control design is based on individual components: Manager, Measurement, Decision, Router Communication Interface, and Listener. Each component runs on a separate schedule and contains a collection of objects. The Router Communication Interface communicates with client routers, the Measurement module probes/collects path characteristics, and the Decision module stores/correlates decision-making data. The Manager is a support module for controlling the communication between BGP modules, and the Listener is a module for communicating with external (nonBGP) modules.</p><p>Jitter-based route control follows this sequence:</p><p>1. On a video stream request, dispatch the requestor's IP address to the route-control process.</p><p>2. Route control identifies the prefix and potential egress points.</p><p>3. Route control collects specific path jitter measurements.</p><p>4. The path with the lowest jitter is inserted as the new default path.</p><p>5. Repeat upon regular intervals until the connection is dropped. </p><p>These steps can be executed in a straightforward process. I've avoided details about the interface with BGP and communication with router peers; you can find information on this from BGP implementations such as GateD (http://www.nexthop.com/), MRT (http://www.mrtd.net/), GNU Zebra (http://www.zebra.org/), and ZebOS (http://www.ipinfusion.com/).</p><h3>Collecting Data</h3><p>There are several techniques you can use to collect data on potential routes to specific destinations. The route-control design I present here supports a generic interface that allows implementation of these techniques. </p><ul>  <li><b>Passive metrics.</b> This requires a complex integration with the web service and router systems. Web-site designers need to include two 1-pixel images per egress path that (through the network routing configuration) directs HTTP traffic over each multihomed path. Data retrieved from the images quantifies the jitter. Therefore, once a request is made, jitter data can be collected though the original request. This only measures data quality over the HTTP protocol and may not be representative of all traffic types.  <li><b>Active collection.</b> This is closer to a representative metric of jitter for streaming video. The route-controller system "pings" near the client destination at regular intervals and records the response through each protocol path. This approach requires coordination of test routes with ping measurements to collect data.   <li><b>Externally processed. </b>There can be ways to characterize the quality of the path remotely and dispatch the computed measurement directly to the route controller for processing and control of the best path.</ul><p>The route-controller design lets you derive from the <i>MeasurementBase</i> parent class to implement specific measurement methodologies for collecting and storing jitter data. As you can see in <A NAME="rl1"><A HREF="#l1">Listing One</A>, the base class requirements are simple. You need only the capacity to handle an incoming request through <i>processRequest()</i>. When the measurement process has completed, submit the data to storage via <i>submit(). MeasurementBase</i> provides additional support for communication between external requests for measurements through the <i>listen()</i> method that binds to a specific port during the construction of the object. Any number of derived measurement objects can coexist within this design, but coordination of measurements between these modules is required and is the responsibility of the Measurement manager object.</p><p>In the active data-collection approach, the video request is received in the form of an IP address from the video server (or appropriate surrogate). The IP address is matched up to a routing prefix. Because this request was received at the server, you know that this IP address (and corresponding prefix) is an actively used prefix and can be tested and optimized to reduce jitter. The <i>MeasurementBase</i> class receives the request, and the derived active measurement module is responsible for inserting test routes and pinging the target through each test path. Once a measurement has been completed, the jitter measurement is computed and stored.</p><p><A NAME="rl2"><A HREF="#l2">Listing Two</A> presents an active measurement implementation of the <i>MeasurementBase</i> pure virtual method <i>processRequest()</i>. <i>ProcessRequest()</i> receives a <i>MsmtRequest</i> object that contains a target prefix for active measuring. The <i>processRequest()</i> method inserts a route for testing and pings the destination. Once the response has either been received or timed-out over <i>iNumProbes</i> measurements, the active route is removed from the client router. The jitter is computed in <i>computeScore</i>, then stored via the <i>submit()</i> method. A different approach is required for a passive measurement, where the <i>MsmtRequest</i> object wraps the raw measurements that have been captured through a web page request. The measurements are then used for computing jitter.</p><p>The approach used to collect the jitter data can result in different characteristics of the paths being measured. In addition, this design lets you support a mixture of data-collection methods. Again, since the active measurements and the external measurement process can potentially affect test paths, these measurement techniques are coordinated within the Measurement component by the manager.</p><p>With either measurement approach, the data is collected in the form of latency values (round-trip travel times) and is converted into jitter measurements. Jitter can be computed from received latency values using the formula:</p><blockquote><p>Jitter=(p2received-p2sent)-(p1received-p1sent)</p></blockquote><p>Jitter is computed in milliseconds and represents a single measurement. This measurement represents a round-trip computation of jitter. Because data usually returns on the same path for a given prefix, the return trip will be constant based on the computed round-trip value. This measurement can be assigned a sample time midway between the times <i>probe1</i> and <i>probe2 </i>are sent. A weighted temporal window can be applied to multiple samples so as to provide a more accurate representation of the current jitter value. A single measurement is useful, but might indicate a singularity in that particular measurement, therefore, multiple measurements are performed over time.</p><h3>Selecting the Best Route</h3><p><A NAME="rl3"><A HREF="#l3">Listing Three</A> shows the route-decision process within the <i>RouteSelection</i> object. With the collected and processed path scores, the <i>RouteSelection</i> object iterates through the vector of prefixes and inserts paths that possess the lowest jitter score. The <i>RouteSelection::engineer()</i> method accepts a prefix object that contains the rating or score of the prefix along with routing information. This path is then inserted as the new route to the router. If an error occurs during insertion of this route, the path is removed from the prefix and a recursive call is made to <i>RouteSelection::engineer()</i> until a path is inserted without error or no paths are available. Upon a successful insertion, this information is recorded and this method is exited. <i>RouteSelection::engineer()</i> is called on a regular basis to update routes based on the current statistics collected for these paths.</p><p>Because path characteristics change over time, it is important to use current path metrics. The design I present here allows that a destination be measured upon video-stream request. Therefore, paths that are not frequently engineered are reduced in priority compared to data from frequently requested prefix sources. Routes and paths can also become available/unavailable at various times; therefore, it is important to reevaluate newly collected metric data and reinsert the best path on a regular basis (for example, engineering every 15 minutes would be reasonable). However, recently received requests from prefixes should be engineered after they have been tested.</p><h3>Optimized Delivery</h3><p>You can achieve significant improvement in the delivery of streaming video when your server is able to make intelligent decisions regarding which paths to select. <A NAME="rf3"><A HREF="0306af3.htm">Figure 3</A> is an example of jitter data for multiple paths and the resulting route selection decision of the lowest jitter path for a destination using a commercial route-control device over a 24-hour period. The gain in performance of the stream is not through improving the delivery path itself (for example, modifying the nature of the path on which the packet would travel), but intelligently selecting the best delivery path at that time from all the paths that are available in a multihomed environment.</p><p>Further optimizations in the design can be applied to the areas of concurrent measurements, additional path characteristic measurements, advanced target identification and testing to provide further accuracy in the data collected, and sampling theory to create a picture of the path characteristics over time and to be somewhat predictive in the behavior of the path characteristics. Finally, commercially available appliances from Proficient Networks (the company I work for), NetVMG, and RouteScience support route control in different forms.</p><p>If your server is operating in a multihomed environment and it is important to squeeze every bit of performance from the quality of your video streams, then this is one optimization that you can't ignore.</p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>class MeasurementBase{public:     bool processRequest(MsmtRequest &amp;req) = 0; //implemented by derived class     bool shutdown(); //shutdown this componentprotected:     MeasurementBase(RouteComm *pRouteComm, int iPort) : m_pRouteComm(pRouteComm), m_iPort(iPort) {;}     virtual MeasurementBase() {;}     //commit collected data to data store     bool submit(Target &amp;target, double dSample);private:     bool listen(); //initiates a listen to port, base class will take care of initial contact private: //variables     RouteComm *m_pRouteComm;     int m_iPort;};</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>bool JitterActive::processRequest(MsmtRequest &amp;msmtReq){	Prefix prefix;	PrefixPaths paths;	PrefixPaths::iterator iter;	bool fErr;	int i;	double dValue, dResult;	vector&lt;double&gt; respColl;	Target target;	prefix = msmtReq.getPrefix();	paths = prefix.getPaths();	iter = paths.begin();	if (iter == paths.end())		return Konstants::bFail;	while (iter != paths.end())	{		target = iter-&gt;getTarget();		try		{			fErr = m_pRouteComm-&gt;insertTargetRoute(target);		}		catch (Exception e)		{			cerr &lt;&lt; "Error in insertion of route" &lt;&lt; endl;			return Konstants::bFailure;		}				if (fErr == Konstants::bSuccess)		{			for (i = 0; i &lt; Konstants::iNumProbes; ++i)			{				fErr = sendProbe(target);				if (fErr == Konstants::bFail)				{					cerr &lt;&lt; "Error in sending probe" &lt;&lt; endl;				}				else				{					dValue = waitForResponse(target);					if (dValue &lt; 0)					{						dValue = Konstants::dJitterMax;						cerr &lt;&lt; "Error in receiving data" &lt;&lt; endl;					}					respColl.push_back(dValue);				}			}						//compute score for this path			fErr = computeScore(target, respColl, dResult);			if (fErr == Konstants::bFail)			{				cerr &lt;&lt; "Error computing rank for this path" &lt;&lt; endl;			}			else			{				fErr = submit(target, dResult);				if (fErr == Konstants::bFail)				{					cerr &lt;&lt; "Error in writing response" &lt;&lt; endl;				}				}		}		//empty result vect		respColl.erase(respColl.begin(), respColl.end());		//move to next path		++iter;	}	try	{		//remove last target route		fErr = m_pRouteComm-&gt;removeTargetRoute(target);	}		catch (Exception e)	{			cerr &lt;&lt; "Error in removal of route" &lt;&lt; endl;		return Konstants::bFailure;	}	if (fErr == Konstants::bFail)	{		cerr &lt;&lt; "Error in removal of route" &lt;&lt; endl;		return Konstants::bFailure;	}		//finished performing measurements for this target	return Konstants::bSuccess;}</pre><P><A HREF="#rl2">Back to Article</A></P><H4><A NAME="l3">Listing Three</H4><pre>bool RouteSelection::engineer(Prefix&amp; prefix){	PrefixPaths paths;	PrefixPaths::iterator iter;		int iVal;	bool fErr;	paths = prefix.getPaths();	if (paths.empty() == true)		return Konstants::bFail;	//collection is already sorted by path score	iter = paths.begin(); //best path	try	{		fErr = m_pRouteComm-&gt;insertRoute(*iter);		if (fErr == Konstants::bFail)			return fErr;	}	catch(Exception e)	{		cerr &lt;&lt; "Exception thrown by routerInterface " &lt;&lt; e &lt;&lt; endl;		return Konstants::bFail;	}		if (fErr == Konstants::bFail)	{		//recursive call until we get this right		prefix.removePath(*iter);			fErr = engineer(prefix);		if (fErr == Konstants::bFail);			return fErr;	}	else	{		try		{			fErr = m_pState-&gt;recordEngineered(*iter);			if (fErr == Konstants::bFail)				return fErr;		}		catch(Exception e)		{			cout &lt;&lt; "Exception thrown by State " &lt;&lt; e &lt;&lt; endl;			return Konstants::bFail;		}	}	return Konstants::bSuccess;}</pre><P><A HREF="#rl3">Back to Article</A></P></body></html>