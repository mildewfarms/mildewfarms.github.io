<html><head><title>Jun03: The Heap Data Structure</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h2>The Heap Data Structure</h2><p>Heap is a simple but useful data structure that lets you enter a sequence of elements in an arbitrary order, then retrieve them one by one in a sorted order. There are naturally other data structures that can perform the same task, but heap is arguably the simplest, most efficient, and easiest to implement.</p><p>Basically, heap is a binary tree with two special properties:</p><DDJADVERTISEMENT INLINE><ul>  <li>Heap property. The value of each node is smaller than those of its sons. This effectively implies that the root element is the smallest one, so it can be readily accessed in <i>O</i>(1). On the other hand, finding the largest element is inefficient. It must reside in one of the leaves of the tree (because if it had a child, it would not be the largest one), but to find it, you must painstakingly scan all the leaves.  <li>Tree property. Heap is an almost complete binary tree; that is, all the elements up to a certain depth are present in the tree, except maybe for some elements at the lower-most level (see <A NAME="rf1"><A HREF="0306ef1.htm">Figure 1</A>). The maximum depth of the heap tree is log<sub>2</sub><i>n</i>, where <i>n</i> is the total number of nodes. Consequently, you don't need to use a tree to actually implement a heap; an array (or a vector) will do. This way, for a node residing at index <i>i</i>, its two sons reside at indices 2*<i>i</i>+1 and 2*<i>i</i>+2, while its parent resides at (<i>i</i>-1)/2.</ul><p>When a heap is embedded in an array, you can define its last element as the very last element of the host array. This element can be safely removed from the heap without disturbing any of its properties. This tactic is what lets you efficiently extract the smallest element from the heap&#151;you simply remove the last element from the heap, inject it in place of the smallest element (at the root), and bubble it down, restoring the heap property for every node it encounters en route; see <A NAME="rf2"><A HREF="0306ef2.htm">Figure 2</A>. The time complexity of this operation is bounded by the tree depth and equals <i>O(</i>log<i>n)</i>.</p><p>To insert a new element into the heap, you just insert it after the last array element and bubble it up similarly to restore the heap property. The complexity of this operation is also <i>O(</i>log<i>n)</i>.</p><p>Finally, an unsorted array can be converted into a heap ("heapified") by performing the bubble operations in a particular sequence. Interestingly, while the worst-case complexity of any given bubble operation is <i>O(</i>log<i>n)</i>, all the operations required for heapification together sum up to only <i>O(n)</i>!</p><p>And the best news is that you don't even need to implement any of the heap manipulation functions, as they constitute an integral part of the C++ Standard Library. The three heap operations described here are realized by the STL functions <i>std::pop_heap</i>, <i>std::push_heap</i>, and <i>std::make_heap</i>, defined in the header file &lt;algorithm&gt;.</p><p>&#151;E.G. and A.G.</p><a href="0306e.htm#rs1">Back to Article</a></body></html>