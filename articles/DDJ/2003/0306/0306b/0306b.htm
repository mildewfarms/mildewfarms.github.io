<html><head><title>Jun03: JXTA &  Peer-to-Peer Networks</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>JXTA &amp;  Peer-to-Peer Networks</h1><p><i>Dr. Dobb's Journal</i> June 2003</p><h2>A TINI presence in a P2P world</h2><h3>By Sing Li</h3><I>Sing is an author and consultant, and his most recent book is Early Adopter JXTA: P2P Java (Wrox Press, 2001). He can be reached at westmakaha@yahoo.com.</I><hr><p>Peer-to-peer networks have unique qualities that distinguish them from conventional, loosely distributed client/server networks, including the potential for network composition to dynamically and continuously change, as peers join and leave. Consequently, it is often necessary for many peer-to-peer (P2P) applications to determine the "presence" of a particular peer. In this article, I examine the difficulty in creating a generic presence solution, then present a workable solution for a P2P chat application on a JXTA P2P network. The presence solution I present is built on TINI, a Java-based embedded controller from Maxim/Dallas Semiconductors. For more information on TINI, see "A Tiny Board with Big Possibilities," by Al Williams (<i>DDJ</i>, October 2000).</p><h3>P2P Network Fundamentals </h3><p>P2P networks are usually introduced by contrasting their topological architectures against the more familiar multitiered client/server. Often, the network is described as a network with only clients and no servers. </p><DDJADVERTISEMENT INLINE><p>An alternate approach to understanding P2P networks begins by examining features that P2P networks must deliver to users, then works backwards to achieve it. In other words, you examine the problems to solve, then come up with solutions. Not only is this approach more intuitive for the engineering-minded, but it is also more fun.</p><p>So, a P2P network is a spontaneous, continuous union of connected machines, each sharing and exploiting resources&#151;content, bandwidth, and so on&#151;brought collectively to the network. It is spontaneous because its constituency is constantly changing. Machines and users log on/off the network at any time, and failure on a single machine may occur at any time. The features/services delivered by the P2P network must be relatively unaffected by this constantly changing constituency and network topology. This means there's no dependency on one or more dedicated server machines.</p><p>For a typical P2P network to be useful, a critical mass of constituents needs to be continuously connected. Why? Because the network itself is delivering the desired features and/or functionality to end users, not a particular site, server, or service. Desirable features and/or functionality usually center around the sharing of collective resources, contributed by all (or a subset) of the connected constituents. Shared resources may include content, bandwidth, CPU cycles, storage, connectivity, or other specialized capabilities. For example, distributed chat systems on P2P networks share bandwidth, connectivity, and storage within the network by caching and propagating user messages between the constituency.</p><p>There are a number of engineering problems to be solved when designing P2P networks and/or applications, including heterogeneous connectivity, discovery, and presence.  </p><p>Although constituents in a P2P network are connected, they may not be connected in the same physical way. They can be based on completely different hardware pieces (supercomputers, PCs, PDAs, notebook computers, soda machines, heart pacemakers, and the like) running completely different software, and connected, using completely different networking/communication technologies. A generic P2P network technology must cope with and work in a diverse world of potential constituents. In addition, it must be able to route communication messages intelligently across this heterogeneously connected network, and heal itself should the heterogeneous connections break up.</p><p><A NAME="rf1"><A HREF="0306bf1.htm">Figure 1</A> illustrates a P2P network consisting of a PDA, soda machine, three PCs, two notebooks, supercomputer, and pacemaker&#151;all connected using dissimilar hardware and communicating with different networking/communications technology. While the peers are not directly connected physically, the P2P network should make them logically so. This means that a doctor with a PDA and P2P application can have real-time access to pacemaker statistics from patients who are also connected to the network. Should the user on notebook 1 turn off her notebook, the P2P networking software on the PDA reestablishes a physical connection to another peer (say PC 1 via Wi-Fi), transparent to users and applications.</p><p>When users/machines join the P2P network, they need to find out what other peers are there, who to send communication messages to, and what features/functionalities are available. Since the network topology is constantly changing, network discovery must be performed dynamically&#151;and the process must be continuous while the peer is connected to the network. </p><p>Because we currently live in a client/server world, familiar conventions such as presence are hard to give up. Presence is the ability to determine if specific peers in P2P networks are present at any moment. To determine presence, you must first be able to uniquely identify the possible entities. Presence becomes controversial if the entities are human users, and the P2P network spans the Internet. Other than being controversial, the idea of knowing absolutely (at some point in time) if users or systems are connected to the P2P network goes against the grain of spontaneity and dynamism, which are cornerstones of a true P2P network. </p><p>Fortunately, if you are working within a specific application domain (such as instant messaging systems) and aren't concerned about generic presence systems, you can use JXTA to create highly usable solutions to the presence problem.</p><h3>JXTA: A Workable P2P Substrate</h3><p>JXTA (http://www.jxta.org/) is an open-source development project for creating a P2P substrate&#151;applicable to any hardware or software platform&#151;that simplifies the creation of P2P-based applications and enhances interoperability of different P2P applications. While retaining a Java heritage, JXTA is actually the specification of a standard set of "minimal denominator" protocols. These protocols are specified independent of programming language, hardware, and even networking and communications technology. This protocol relies on the minimal ability to pass structured data messages between participating peers. Consequently, devices or machines can become JXTA peers as long as they can source or sink communication messages (either textual XML or binary). </p><p>A protocol-based solution partially solves the heterogeneous connectivity problem&#151;JXTA protocol messages can flow through systems that differ in hardware, software, and communications technology as long as they are connected and can manipulate and/or parse messages. The other half of the heterogeneous connectivity problem is the required ability to heal the network when peers connect/disconnect. Solving this problem is more involved. <A NAME="rf2"><A HREF="0306bf2.htm">Figure 2</A> illustrates the stack of components that addresses this problem.</p><p>First, each peer has a decentralized address (ID) in the network. This address is generated without any centralized authority (unlike IP addresses). The virtual routing and resolving layer binds this address to an actual physical network endpoint when messages are routed between peers. This binding is done as late as possible to accommodate last minute changes in the network topology. But even binding as late as possible may fail due to instantaneous topological changes. In these situations, the JXTA resolver (that is, code for binding address to endpoint) performs a distributed query to determine the latest route. The endpoint routing protocol in the JXTA protocol suite is responsible for this. (For details on how the JXTA components stack operates, see my book <i>Early Adopter JXTA</i>, Wrox Press, 2001; ISBN 1861006357.) </p><h3>Solving Discovery Problems</h3><p>Bootstrap discovery is handled in JXTA via the peer discovery protocol. When peers bootstrap in a JXTA network, they advertise themselves by sending protocol messages (advertisements) to the network of rendezvous, whose members cache and propagate these advertisements amongst themselves, following a monitor-cache-propagate pattern. Therefore, for one peer to locate another, it only has to query its nearest rendezvous. While this method of discovery works on top of the heterogeneous connectivity often found in the P2P network, other more optimized methods of discovery are available for specialized situations (on Java implementation over TCP/IP networks, for example, UDP broadcast or multicast can be used to discover peers within a LAN or multicast group).</p><p>True to their P2P heritage, JXTA peers follow a monitor-cache-propagate pattern with regard to interesting information. During their lifetimes (that is, while connected and functional on the network), JXTA peers monitor and observe information on the network. This information may contain ID and location of other peers, the announcements of other services that are (or became) available on the network, plus other information of application interest (file location, segments of files being shared, and so on).  </p><p>As they monitor for information flowing through the network, JXTA peers may selectively store (cache) some local knowledge for later use. Of course, most information cached quickly becomes stale as peers come and go in the network. However, as long as these peers stay connected to the network, the information is relatively up to date. However, if peers disconnect/reconnect, they have at least a startup view that is usable to bootstrap again. To quickly familiarize themselves with the network after a period of absence (or the first time a network is joined), peers depend on the propagation of knowledge with other connected peers.</p><p>Propagation of knowledge relies on cached information and dynamic queries. New peers starting up and/or rejoining the P2P network must query a subset of known peers, acting as rendezvous (either by human configuration or located from a previously cached list of peers), for the most current network information. Therefore, it is vital that other peers on the P2P network share in this information. By sharing the most information, P2P networks let new peers quickly come up to speed with network information. </p><h3>A Presence Solution for JXTA </h3><p>In itself, JXTA does not provide a solution to the presence problem. Here, however, I present a "good enough" implementation, but for a very specific case&#151;a chat application.</p><p>MyJXTA (also known as "Instant P2P"), the showcase application in the JXTA network, combines a group chat, one-on-one chat, and filesharing application into one application. For this example, I create a workable presence solution in the context of the chat application. This presence solution enables peers in the chat room to perform a query similar to <i>davids?</i>, meaning, "Did anyone see davids recently?" Since it isn't possible in the pure JXTA context to guarantee that a peer is connected and reachable at any moment, most chat-room users will be satisfied with answers such as: "Yes, we last heard from davids just five minutes ago" or "No, davids has not joined the chat room at all."</p><p>This JXTA service is called <i>SimplePresence</i>. To activate it during the chat, you only need to format the chat message into one of the commands in <A NAME="rt1"><A HREF="0306bt1.htm">Table 1</A>. <A NAME="rf3"><A HREF="0306bf3.htm">Figure 3</A> is the <i>SimplePresence</i> service in action. In this case, the service is set to monitor posts from a user named "davids," by the user "Kauaian." <i>SimplePresence</i> runs independently from any peers that may be using it. Ideally, the peers hosting <i>SimplePresence</i> should be up most of the time&#151;or even be redundantly implemented. By using an embedded, low-cost platform such as TINI to implement such a service, you can provide a reliable service (perhaps even redundant) without tying up expensive standalone PC servers.</p><p>The JXTA-For-TINI project (http://tini.jxta.org/) is a community project owned by Sean Kelly (seankelly@jxta.org). The project currently provides a TINI-compatible library to use the relay service provided by the JXME project (http://jxme.jxta.org/). (JXME is JXTA on J2ME platforms.) The JXME relay service enables PDA and other limited-resource Java devices to run JXTA by delegating most of the storage, memory, and computation intensive tasks to the proxy service running on a more powerful peer. At the time of writing, JXTA 2.0 has just become available. JXTA 1.0 and JXTA 2.0 are not compatible on the protocol level. Both JXME and TINI for JXTA work only with JXTA 1.0 proxy service at this time.</p><p>The source code for the <i>SimplePresence</i> service is in the DDJFinder.java file (available electronically; see "Resource Center," page 5). Take a look at the <i>main() </i>method (<A NAME="rl1"><A HREF="#l1">Listing One</A>) to see how the pieces fit together. The only argument required by the <i>DDJFinder</i> constructor is the URL of the proxy service. The <i>main</i> method first initializes the service, then calls the <i>processMessages()</i> method. <A NAME="rl2"><A HREF="#l2">Listing Two</A> is the <i>init()</i> method that first creates a <i>PeerNetwork </i>instance using the static <i>PeerNetwork.createInstance() </i>call. This is followed by a connection to the JXME proxy via a <i>connect()</i> method call, which starts the bootstrapping process on the proxy for this new peer.</p><p><A NAME="rl3"><A HREF="#l3">Listing Three</A> is the <i>processMessages() </i>method, which stays in a tight loop polling for messages on a JXTA pipe using a call to the <i>listen()</i> method of <i>PeerNetwork</i>. Every incoming message is parsed to see if it is a command; see the <i>isCommand()</i> helper method (<A NAME="rl4"><A HREF="#l4">Listing Four</A>; available electronically). Additionally, it also examines the sender to see if it is someone that the service is currently tracking. If the sender is being tracked, the date and current date/time is logged in the private Hashtable called <i>presenceDB</i>. See the <i>logSender()</i> helper method in <A NAME="rl4"><A HREF="#l4">Listing Four</A>, which encapsulates the command processing logic in the <i>processMessages()</i> helper method.</p><p>You don't need to have a TINI to test the <i>DDJFinder</i> service. The TINI-For-JXTA development environment lets you compile using any JDK 1.1 (or later) environment and test the code on a local PC. However, it does take some work to set up the TINI-For-JXTA development environment; for details, see the file README.TXT (available electronically).</p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>public static void main(String[] argv) {    if (argv.length != 1) {        System.err.println("Usage: DDJFinder proxyServerURL");        System.exit(1);    }       DDJFinder myFinder = new DDJFinder(argv[0]);       myFinder.init();       myFinder.processMessages();}</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>public void init() {try {        System.err.println("Creating peer network...");        peerNetwork = PeerNetwork.createInstance(serviceName);        System.err.println("Connecting to " + proxyURL);        peerNetwork.connect(proxyURL, null);        }   catch (Exception ex) {            System.err.println("Problem connecting to JXTA network...");                            ex.printStackTrace();        }    }    </pre><P><A HREF="#rl2">Back to Article</A></P><H4><A NAME="l3">Listing Three</H4><pre>public void processMessages()  {     try {               System.err.println("Listening to pipe " + IP2P_PIPE_ID);         peerNetwork.listen(serviceName, IP2P_PIPE_ID, "JxtaPropagate");         System.err.println("Ready.");         while(true) {             Message msg = pollForMsg();                     if (! isCommand(msg))                            logSender(msg);                     else                         {                             if (!isTerminate(msg))                        sendMessage(peerNetwork,processCmd(msg),serviceName);                              else                                  break;                          }                    }// of while     } catch (Exception ex) {         System.err.println("Error during message processing");         ex.printStackTrace();         System.exit(1);     }    }</pre><P><A HREF="#rl3">Back to Article</A></P></body></html>