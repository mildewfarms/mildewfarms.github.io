<html>
<head>
<title>Feb03: C Programming</title>
</head>

<body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000">
<!--Copyright &#169; Dr. Dobb's Journal-->

<h1>Epicenter Johnny &amp; <i>typename</i> Exposed</h1>
<p><i>Dr. Dobb's Journal</i> February 2003</p>

<h3>By Al Stevens</h3>

<I>
Al is DDJ'<i>s</i> senior contributing editor. He can be contacted at astevens@ddj.com.</I>

<hr>

<p>Many years ago, the son of a friend came to me for some advice. John Fitz wanted to be a writer. He wanted to write stories like Stephen King writes and have them published. I was the closest thing to a professional writer he knew, and he thought I might have some advice that he could use to help him get started.</p>
<p>John was motivated, but he did not have the tools he needed to write. Or, at least, he did not have the tools that were available at that time. All John had was a typewriter and some paper. Sure, that was good enough for Hemingway, but this was 1987, and we'd come a long way.</p>
<DDJADVERTISEMENT INLINE>

<p>There is almost always a computer in my shop looking to be given away or, in these days of such rapidly advancing technology, ready for the land fill. When John came to me for advice, I had upgraded to some kind of PC clone and had retired a very nice little CP/M machine with a video terminal and a couple of 5.25-inch diskette drives. I told John he needed a word processor if he wanted to be a writer in the 1980s. I gave him that little machine along with diskettes of CP/M and the Wordstar word processor. John took his new hardware and went off somewhere to begin writing the Great American Scary Novel. When John finally had enough narrative written to print, he got a printer and I helped him install it, no easy task back then. As I recall, I had to write a printer driver in 8080 assembly language and install it into the operating system. Easier than writing about the occult, I suppose, but every bit as scary.</p>

<p>Over the years, I heard from John occasionally. He told me he was still writing, still sending manuscripts to publishers, and still papering his walls with rejection notices. He maintained a day job, which allowed him to gradually upgrade to better hardware and software to use in his writing endeavors. John's resolve never waned. He never lost confidence in his own ability. He knew he had the right stuff. He kept plugging away.</p>

<p>A few weeks ago, John's dad brought me a present. It is the first published book authored by John Fitz, who autographed this copy just for me. The book is called <i>Epicenter Johnny.</i> Stephen King's breakthrough book was <i>Carrie</i>, about a girl who could use her mind to make fires break out. John's book is about a guy who can bring on earthquakes. If occult literature interests you, you can find<i> Epicenter Johnny </i>at Amazon.com. For me, it's a source of pride that someone I helped in a small way so many years ago stuck with it and found his way through the discouraging and frustrating maze one must navigate to get a book into print.</p>

<p>You might remember the MidiFitz project I published in this column several years ago. That project was named after John's dad, Johnny Fitz, my good friend and musical collaborator for over two decades. And so the circle remains unbroken.</p>



<h3>What's in a <i>typename</i></h3>


<p>Speaking of books and publishers, I am writing yet another edition of my tutorial C++ book titled <i>Teach Yourself C++</i> to be published under the MIS:Press imprint, owned (this year, at least) by Wiley. As usual, when shamelessly plugging my book, I remind readers not to mistake my work for those with similar titles. Other publishers, short on originality and eager to capitalize on my wildly successful series of books, appropriated my title and turned their authors loose. MIS:Press, being a kindly and benevolent publisher, declined to press the matter, wishing as King did (Rodney, not Stephen) that we can all just get along. Yeah, right. Consequently, there are at least three lines of computer books titled "Teach Yourself" something or other from three different publishers. Don't be fooled by imitations. Mine is the original. Those other guys are mere pretenders to the throne.</p>


<p>While doing research for this new edition, I went in search of lucid explanations of some of the more arcane language additions introduced by Standard C++. The C++ Standard document explains each such improvement with respect to how a compiler writer should implement them in a compliant compiler. But the Standard rarely explains why a particular feature exists, and it never provides more than a mere fragment of code to demonstrate a feature's operation, much less a code example that illustrates why the feature is needed in the first place. Not that it should. A programming language standard specification document only explains the language for compiler builders. It is up to others to explain its uses and rationales from a programmer's perspective, said others being distinguished computer book authors such as yours truly, whose mission it is to clear up the mysteries of the Standard.</p>

<p>One such mysterious feature is the <i>typename</i> keyword. Standard C++ added <i>typename</i> to the language to solve some semantic ambiguities introduced by the class template mechanism and to make template declarations more intuitive to the human reader. Typically, the Standard explains the grammar, syntax, and behavior of <i>typename</i> without explaining its purpose, which is not exactly intuitive.</p>

<p>I have a lot of C++ books. I pored through the more recent ones, those published since 1998 when Standard C++ became official, only to find a dearth of information about <i>typename</i>. Only three books in my library even attempt to explain it and none of them are C++ tutorials. Perhaps my library is already out of date. Since I'm only now getting around to updating my book, maybe all those other authors, including the ones who ripped off my title, are ahead of me. A trip to Books 'A' Million turned up a lot of very recent C++ titles and almost no information about <i>typename</i>. I spent the better part of an hour poring through every book, even the ones that promise to be complete, comprehensive treatments of C++. Very few books even mention <i>typename</i>, and those that do have almost no useful information about it. I won't mention any authors' names whose books are derelict in their coverage. I won't embarrass them that way. They know who they are.</p>

<p>The three books in my library that do try to explain <i>typename</i> are <i>The C++ Programming Language,</i> Third Edition (Addison-Wesley, 1997), by Bjarne Stroustrup; <i>Effective STL </i>(Addison-Wesley, 2001), by Scott Meyers; and <i>Standard C++ IOStreams and Locales </i>(Addison-Wesley, 2000), by Angelika Langer and Klaus Kreft. None of these books are C++ tutorials and, of the three, only the last one adequately explains why the C++ language needs <i>typename</i>. Stroustrup makes a good stab at it, but, typical of Stroustrup, he writes concisely for the expert rather than the novice. A C++ programmer would understand his explanation. A C++ student might not.</p>

<p>That third book, <i>Standard C++ IOStreams and Locales,</i> is an essential part of any C++ library. It is the only work I've seen that explains <i>IOStreams</i> at a detailed enough level that you can begin to see how you might use the library to its fullest potential. It is also the only work I've seen that addresses C++ locales in sufficient detail to get you started making a software system portable to many cultures. It explains <i>typename</i> only as an aside in a section that identifies new C++ language features.</p>

<p>So, if you are looking for a tutorial C++ book with comprehensive coverage, you know where to go. Sometime in early 2003, look for <i>Teach Yourself C++,</i> Seventh Edition. If you are unsure whether you are looking at my book or one of those feeble imitations, look in the index. If you find <i>typename</i> listed there, chances are you've got the right book. Assuming my name is on the cover that is. Those other guys wouldn't stoop to putting my name on their cover next to my title. Would they?</p>



<h3>Template Ambiguities</h3>


<p>To understand the ambiguities that <i>typename</i> addresses, you must understand <i>typedef</i> and public class members. Here's some background.</p>


<p>First, a program can define a new type name by using the <i>typedef</i> statement; see <A NAME="re1"><A HREF="0302he1.htm">Example 1</A>. The compiler treats the <i>pint</i> identifier in <A NAME="re1"><A HREF="0302he1.htm">Example 1</A> as a type defined to be the same as a pointer to <i>int</i>. The program can now declare and use variables of type <i>pint</i>.</p>

<p>You can declare a <i>typedef</i> within a class definition as <A NAME="re2"><A HREF="0302he2.htm">Example 2</A> shows. The <i>iter typedef</i> declaration in <A NAME="re2"><A HREF="0302he2.htm">Example 2</A>, which is a pointer to type <i>Placecard</i> in this case, is not in global or file scope. It is declared as a public member of the <i>Placecard</i> class. The program declares objects of type <i>iter</i> by qualifying the type reference with the name of the class that declares it and the scope resolution operator like this: </p>

<blockquote><p>
Placecard::iter pi;</p>

</blockquote><p>The program now uses the <i>pi</i> variable just as it would a pointer to type <i>Placecard</i>. The compiler knows how to translate the <i>typedef</i> name <i>Placecard::iter</i> into a type that is, in this case, a pointer to <i>Placecard</i>. </p>


<p>Suppose you are building a class template that expects its parameterized class to declare a type named <i>iter</i> as <i>Placecard</i> does. That class template might look something like <A NAME="re3"><A HREF="0302he3.htm">Example 3</A>: The ambiguity in <A NAME="re3"><A HREF="0302he3.htm">Example 3</A> might not be immediately obvious, but the compiler does not know what to do with this statement:<i> </p>

<blockquote><p>
T::iter</i> * y;</p>

</blockquote><p>First, the compiler does not know what <i>T</i> is at this time because it has to parse the class template code without having seen an instantiation of the class template with a parameterized type. That is a normal circumstance with which the compiler routinely deals. Not knowing what <i>T</i> is, the compiler does not know what <i>T::iter</i> is, either. Because the compiler does not know that, it cannot tell whether the statement declares a pointer to type <i>T::iter</i> named <i>y</i> or is an expression that multiplies whatever <i>T::iter</i> is times whatever <i>y</i> turns out to be. If <i>y</i> is not defined in the current scope, the compiler reports an unidentified <i>y</i>. In either case, the compiler, does not know what to do with the statement, which it assumes is an expression.</p>


<p>To eliminate the ambiguity, the committee added the <i>typename</i> keyword. The class template and its member functions qualify all references to types defined in the parameterized type with the <i>typename</i> keyword as in:<i> </p>

<blockquote><p>
typename T::iter </i>* y;</p>

</blockquote>

<p>When the compiler sees the <i>typename</i> keyword, it knows that what follows is a type and parses the code assuming a type name will be filled in by the instantiation. </p>

<p>Standard C++ requires the <i>typename</i> qualifier for all types referenced in a template that are defined in the templatized class even when no ambiguity would result from omitting it. <A NAME="rl1"><A HREF="#l1">Listing One</A> (available electronically; see "Resource Center, page 5), demonstrates the use of <i>typename</i> in this manner. You can see the effect of not using <i>typename</i> in this manner by removing it from the code in <A NAME="rl1"><A HREF="#l1">Listing One</A> and compiling the program with any of today's Standard C++ compliant compilers.</p>

<p>There are other kinds of expressions in class template member functions that would result in ambiguities that the <i>typename</i> keyword disambiguates. C++ syntax permits parentheses where you rarely see them:</p>

<blockquote><p>
int (num);</p>

</blockquote><p>This statement declares an <i>int</i> variable named <i>num</i>. The parentheses are superfluous, but they are permitted. Suppose, however, that a class template member function contains this statement: </p>


<blockquote><p>
T::iter(num);</p>

</blockquote><p>The compiler does not know whether this statement declares a variable named <i>num</i> of type <i>T::iter,</i> or calls a function named <i>T::iter </i>passing an argument named <i>num</i>, quite possible if there is a nonlocal variable of that name in the current scope when the class template is instantiated. The <i>typename</i> keyword corrects this ambiguity the same way it does the earlier example: </p>


<blockquote><p>
typename T::iter(num);</p>

</blockquote><p><i> </i>By requiring the <i>typename</i> qualifier for all references to types declared in the parameterized class, the Standard ensures that such ambiguities cannot occur.</p>


<p>At least, these are the arguments given to justify <i>typename</i>. Compilers that do nothing with template code until something in the program instantiates a parameterized object of the template class should not have this problem, and older compilers do, in fact, properly compile templates that refer to types declared in parameterized types without the <i>typename</i> keyword. Most contemporary C++ compilers instantiate templates when the program instantiates parameterized types. But Standard C++ anticipates better compiler implementations that will someday compile template code without knowing the parameterized type. The Standard also expects that template member functions do not have to be visible to the compiler whenever a parameterized type is declared. The Standard anticipates a time when template member functions can be compiled outside the scope of the code that uses them, even in independent translation units. Thus, the potential if not actual ambiguity and, thus, the requirement for <i>typename</i>.</p>

<p>I hope I got that explanation right. It's the best I can do given the available literature.</p>



<h3><i>typename</i> versus <i>class</i></h3>


<p>Given the introduction of <i>typename</i> into Standard C++, the committee decided to use it in templates where <i>class</i> was used to declare the parameterized types. Previous implementations of templates prior to the publication of the Standard C++ specification use the <i>class</i> keyword in their template declarations like this:</p>


<blockquote><p>
template&lt;class T1, class T2&gt;. </p>

</blockquote><p>This syntax might be misleading because the actual parameterized types in an instantiation of a template can be classes, intrinsic types, pointers and references to things, and <i>typedefs</i>, many of which are not classes at all. Thus, Standard C++ allows the <i>typename</i> keyword instead of <i>class</i> in template declaration statements like this: </p>


<blockquote><p>
template&lt;typename T1, typename T2&gt;</p>

</blockquote>

<p><A NAME="rl2"><A HREF="#l2">Listing Two</A> (available electronically) demonstrates <i>typename</i> instead of <i>class</i> in the template declaration statements for function templates and class templates.</p>

<p>Standard C++ could not simply replace class with <i>typename</i> in this context because too much existing code would have been broken. The template mechanism was in place in many implementations long before <i>typename</i> became part of the Standard specification. Whether you use <i>class</i> or <i>typename</i> in this context is a matter of preference. The experts are divided on whether you should use <i>typename</i> or <i>class</i> in template declarations.</p>

<p>In <i>Effective STL</i>, Scott Meyers says, "When I declare a formal type parameter for a template, I use <i>typename</i> instead of <i>class...class</i> and <i>typename</i> mean exactly the same thing, but I find that <i>typename</i> more clearly expresses what I usually want to say: that any type will do; <i>T</i> need not be a class."</p>

<p>In the other camp, in<i> The C++ Programming Language, </i>Third Edition, Bjarne Stroustrup says, "Being an indifferent typist and always short of screen space, I prefer the shorter:<i> template &lt;class T&gt;...</i>"</p>


<p><b>DDJ</b></p>




<H4><A NAME="l1">Listing One</H4>

<pre>
#include &lt;iostream&gt;

static int y;

template &lt;class T&gt;
class Table {
	typename T::iter t;
public:
	explicit Table(const typename T::iter&amp; ti) : t(ti)
	{  }
	void position()
	{
		typename T::iter * y;
		y = &amp;t;
		std::cout &lt;&lt; (*y)-&gt;p;
	}
};
class Placecard {
public:
	typedef Placecard* iter;
	int p;
	Placecard(int pos) : p(pos)
	{ }
}
;
int main()
{
	Placecard pc(3);
	Table&lt;Placecard&gt; settable(&amp;pc);
	settable.position();
	return 0;
}
</pre>
<P>
<A HREF="#rl1">Back to Article</A>
</P>
<H4><A NAME="l2">Listing Two</H4>

<pre>
#include &lt;iostream&gt;

template&lt;typename T&gt;
T DoubleValue(T value)
{
	return value * 2;
}

template&lt;typename T1, typename T2&gt;
class TwoThings {
	T1 thing1;
	T2 thing2;

	T1 thing3;
public:
	TwoThings(T1 tt1, T2 tt2)
	{
		thing1 = tt1;
		thing2 = tt2;
		thing3 = DoubleValue&lt;T1&gt;(tt1);
	}
	void display()
	{
		std::cout &lt;&lt; thing1 &lt;&lt; ' ' &lt;&lt; thing2 &lt;&lt; ' '
		&lt;&lt; thing3 &lt;&lt; std::endl;
	}
};
int main()
{
	int a = 123;
	double b = 456.789;
	TwoThings&lt;int, double&gt; my2things(a, b);
	my2things.display();
	return 0;
}
</pre>
<P>
<A HREF="#rl2">Back to Article</A>
</P>


</body>
</html>
