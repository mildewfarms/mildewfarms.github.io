<html>
<head>
<title>Jan03: Algorithm Alley</title>
</head>

<body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000">
<!--Copyright &#169; Dr. Dobb's Journal-->

<h1>The "All-Pairs Closest Points" Problem</h1>
<p><i>Dr. Dobb's Journal</i> January 2003</p>
<h2>A divide-and-conquer algorithm solves it</h2>

<h3>By William R. Mahoney</h3>

<I>
William is the senior vice president of Technical Support Inc. and a part-time computer science faculty member at the University of Nebraska at Omaha. He can be contacted at bill@techsi.com.</I>

<hr>

<p>Each year, my wife and I dedicate one day near the end of the year to holiday shopping. I take the day off, the kids go to their grandparents, and we hit the road with plenty of cash. Last year, we dropped off the kids, hopped into the car, and I was asked the inevitable "Where to?" question. I immediately went with the safe answer: "I don't know, where do you want to go?"</p>
<p>"Well, are there any toy stores close together so that we don't have to drive as much?" she asked.</p>
<DDJADVERTISEMENT INLINE>

<p>Which, of course, requires an efficient algorithm for finding the pair {<i>A,B</i>} of map coordinates from a set of map coordinates <i>S</i>, such that the pair {<i>A,B</i>} has the minimal Euclidean distance between all pairs in <i>S</i>. The Euclidean distance, remember, is discovered through the Pythagorean Theorem shown in <A NAME="re1"><A HREF="0301ee1.htm">Example 1</A>.</p>

<p>Each map coordinate can be thought of as the <i>x,y</i>-coordinates of the point on the map (in this case, the front door of the toy store). I use the upper-right quadrant for the coordinates so that <i>x</i> increases left to right and <i>y</i> increases bottom to top. Although we have hills, I assume that all toy stores are at the same altitude. The challenge is to find the pair {<i>A,B</i>} such that this distance is minimal among all possible pairs. The cardinality of the set <i>S</i> is |<i>S</i>|, the number of elements in it. Obviously, there are |<i>S</i>|<sup>2</sup> pairs of points, and the naive among us would resort to an algorithm that is <i>O</i>(|<i>S</i>|<sup>2</sup>) to locate the closest pair of toy stores&#151;just check all possible points against all of the other ones. This method is demonstrated in the source code (available electronically; see "Resource Center," page 5) as a check of the alternate technique. But, of course, we need to be fuel efficient, so I really want to use a better algorithm.</p>

<p>Consequently, I describe here a divide-and-conquer algorithm for solving this "all-pairs closest points" problem. The algorithm works by recursively partitioning the set of points into two halves, then solving for the halves plus a "strip" in the middle. I show that the overall algorithm is <i>O</i>(|<i>S</i>|log|<i>S</i>|), which is better than the naive approach. </p>

<p>To find the closest pair, the coordinate set must first be sorted by the value of <i>x</i> for each coordinate. This takes <i>O</i>(|<i>S</i>|log|<i>S</i>|) to sort, so as far as the overall algorithm complexity is concerned, this doesn't cost anything. At various times, the coordinate set also needs to be sorted by <i>y</i> value. The same argument applies here&#151;from the standpoint of the algorithm complexity, this is free. Because of these requirements, the algorithm simply sets aside two arrays&#151;one containing indices into the coordinates so that scanning the array gives coordinates in <i>x</i> order, and the other gives them in <i>y</i> order. This is a preprocessing step. Sorting once is sufficient for the whole algorithm.</p>

<p>Once the sorted arrays are ready, the algorithm recursively subdivides the map into halves, finding the closest pair of points in each half. The smaller of these two is almost the correct answer. First, imagine a vertical line through the map called the "slicing line." This line can be positioned so that it puts half of the points in <i>S</i> on the left of the line, and half of the points in <i>S</i> on the right of the line (<A NAME="rf1"><A HREF="0301ef1.htm">Figure 1</A>). If the set of map coordinates happened to be sorted by the <i>x</i> map coordinate, this takes essentially no time to position the line because I know that I have |<i>S</i>| points. Thus, if the points are sorted, |<i>S</i>|/2 is the halfway point on the map as far as <i>x</i>-coordinates are concerned. Anything before this point in the sorted array is in the left, and anything after is in the right. (There is a subtlety here, but for now, this makes things simple.)</p>

<p>Now imagine that I make two recursive calls, which return the closest pair to the left of the slicing line and the closest pair to the right of the slicing line. While I've yet to describe the algorithm in detail, if you can assume it is possible to find the closest pair for the entire map&#151;certainly it is possible to find the closest pair for half of it. Make these left and right recursive calls based on the slicing line; then save their return values. Call these pairs <i>P</i><i><sub>L</i></sub> and <i>P</i><i><sub>R</i></sub><sub> </sub>with distances <img src="delta12.gif"><i><sub>L</i></sub><sub> </sub>and <img src="delta12.gif"><i><sub>R</i></sub>, respectively. One or the other is smaller; call this <i>P</i><i><sub>LR</i></sub> at a distance <img src="delta12.gif"><i><sub>LR</sub></i>. You'd think that this shorter distance is the pair of points that is the closest in the set <i>S</i>. </p>

<p>However, when it comes to shopping, things are never as easy as they sound. That's the case here, for I could have a point just barely on the left of my slicing line that is close to a point just slightly to the right of my slicing line. The distance between them <i>could</i> be less than <img src="delta12.gif"><i><sub>LR</i></sub>. This pair is not in the left half, so it was not found in the recursive call for the left side of the map. Neither is it in the right half for the same reason.</p>

<p>It is necessary to check for this condition on the set of coordinates so that I don't inadvertently miss the actual closest pair. The area where this could be a problem lies within a vertical strip centered on the vertical slicing line, and extends <img src="delta12.gif"><i><sub>LR</i></sub> on the left and <img src="delta12.gif"><i><sub>LR</i></sub> on the right; see <A NAME="rf2"><A HREF="0301ef2.htm">Figure 2</A>.</p>

<p>You can likely now see the problem: A point may be slightly to the left of the slicing line, but within <img src="delta12.gif"><i><sub>LR</i></sub> of it, and another point could be slightly on the right of the slicing line yet within <img src="delta12.gif"><i><sub>LR</i></sub> of it. Also, it is possible to have a point that is on the slicing line but considered "in the other half" during recursion, resulting in the need to check +/-<img src="delta12.gif"><i><sub>LR</i></sub>. You need to check any and all points within this strip to make sure you have not missed the real closest pair of points. </p>

<p>Unfortunately, in some strange arrangements of points, the number of coordinates to check within this strip could be very close to |<i>S</i>|. So deciding upon a method to efficiently check this strip is crucial to the efficiency of the algorithm&#151;you don't want to have to resort to checking all |<i>S</i>|<sup>2</sup> points once again. If you are clever, this can be done in time proportional to the number of points in the strip; that is, <i>O</i>(|<i>M</i>|) for <i>M</i> strip points. Remember that I said that sorting by <i>y</i>-coordinate was a setup step for the algorithm. Here's why.</p>

<p>Suppose that only the toy stores within the vertical strip were sorted by their <i>y</i>-coordinates. This will let you order the coordinates going up from the bottom, or south to north, on the map. You could then check the lowest point, call it <i>P</i><sub>1</sub>, against the next lowest, <i>P</i><sub>2</sub> , the second to next lowest, <i>P</i><sub>3</sub>, the third to next lowest, <i>P</i><sub>4</sub>, and so on. At first blush, this appears to force you once again to |<i>S</i>|<sup>2</sup> or at least |<i>M</i>|<sup>2</sup>, checking <i>P</i><sub>1</sub> against <i>P</i><sub>2</sub>, <i>P</i><sub>3</sub>, <i>P</i><sub>1</sub>,...|<i>M</i>|. But I am checking them in order of their <i>y</i>-coordinates. Once the distance between <i>P</i><sub>1</sub> and some other point, <i>P</i><i><sub>n</i></sub>,<i><sub> </i></sub>above it differs by a distance greater than <img src="delta12.gif"><i><sub>LR</i></sub>, there is no further need to check any points above <i>P</i><i><sub>n</i></sub>. All other points are even farther above <i>P</i><i><sub>n</i></sub>, and so no other point in <i>M</i> could be less than <img src="delta12.gif"><i><sub>LR</i></sub> away from <i>P</i><sub>1</sub>. </p>

<p>This severely limits the number of actual tests that must be made in the strip. Since nothing that is greater than <img src="delta12.gif"><i><sub>LR</i></sub> above a point needs to be considered, you can think of a bounding box that is <img src="delta12.gif"><i><sub>LR</i></sub> left of the slicing line, <img src="delta12.gif"><i><sub>LR</i></sub> right of the slicing line, and <img src="delta12.gif"><i><sub>LR</i></sub><sub> </sub>above the point you need to check. This is the close-up view shown in <A NAME="rf3"><A HREF="0301ef3.htm">Figure 3</A>.</p>

<p><A NAME="rf3"><A HREF="0301ef3.htm">Figure 3</A> is one of a small set of worst-case scenarios where the point in question is on a corner of the area you are concerned with. (You can quickly convince yourself that the worst-case test points will always be at the corners.) Remember that any point with a <i>y</i>-coordinate above the top of this rectangular area terminates the search&#151;if you are looking in increasing order of <i>y</i>, there can be no more points beyond this and you can stop testing other points relative to the test coordinate. </p>

<p>Now consider what points could lie within the rectangular areas in <A NAME="rf3"><A HREF="0301ef3.htm">Figure 3</A>. Suppose that there was another point inside of Area <i>B</i>. This could be close to the test point, and also on the right of the slicing line; therefore, the distance from this point to the test point might be less than <img src="delta12.gif"><i><sub>R</i></sub>. But if that were the case, the rectangular area would be smaller, since you would have returned this (closer) pair on the recursive call handling the right of the slicing line. If the other point inside of Area <i>B</i> is farther away than <img src="delta12.gif"><i><sub>R</i></sub>, it is not better than <img src="delta12.gif"><i><sub>R</i></sub>. You can picture an arc inside of Area <i>B</i>, beyond which the points are not closer and inside of which there could not be a point (<A NAME="rf4"><A HREF="0301ef4.htm">Figure 4</A>).</p>

<p>For this reason, the only possible improvement would be if the test point is closer to the slicing line and the other point is in Area <i>A.</i> Additional points could be located on the arc, but they would only tie for the closest distance and not improve upon it.</p>

<p>Obviously, if the test point is in the lower left corner of the region, the same argument applies to Area <i>A</i>, just in reverse. </p>

<p>A bit of work with scratch paper shows that the worst-case example in the rectangle only requires one to test four points before giving up and moving to the next point in the region. Think about the test point being on the slicing line, for instance. </p>

<p>If there are at most four points to test in Area <i>A</i> plus Area <i>B,</i> this is <i>O</i>(1); that is, constant time to test for a given point in the slice area. Because there are |<i>M</i>|&lt;=|<i>S</i>| points in this region, the region can be completely tested in <i>O</i>(|<i>S</i>|) time, and often considerably less than this bound. The worst case happens only when all points are on the slicing line&#151;certainly not realistic as far as the location of toy stores is concerned. </p>

<p>By the way, this approach is because |<i>M</i>| could be close to |<i>S</i>|. If this is not the case, and the points in <i>S</i> are distributed at random (as is the case in the sample code), then |<i>M</i>| is about <img src="check.gif">|<i>S</i>|and you could argue that the brute-force <i>O</i>(|<i>M</i>|<sup>2</sup>) approach within the strip is not unreasonable in these cases. </p>

<p>Now that all of this is noted, the expense of actually sorting the coordinates within the strip needs to be eliminated. You definitely want to avoid the expense of sorting every time you check the strip, because this would cost <i>O</i>(|<i>M</i>|log|<i>M</i>|) every time the recursive calls return. That would tend to force the algorithm towards <i>O</i>(|<i>S</i>|log<sup>2</sup>|<i>S</i>|)&#151;not as good. Instead, if you have a complete list of coordinates sorted by <i>y</i> (remember, I created this at the start), scanning this array retrieves the values in <i>y</i> order at a cost of <i>O</i>(|<i>M</i>|). </p>

<p>It now remains to see that overall you can find the closest pair in <i>O</i>(|<i>S</i>|log|<i>S</i>|) worst-case complexity. <A NAME="rt1"><A HREF="0301et1.htm">Table 1</A> lists the overall time requirements for the algorithm. As a result <i>T</i>(|<i>S</i>|)=2<i>T</i>(|<i>S</i>|/2)+|<i>S</i>|= <i>O</i>(|<i>S</i>|log|<i>S</i>|). </p>

<p>The C++ source code (also available electronically) has a few constants that can be changed at the top of the program. I selected a set of 2500 random points in an area that was 5000 units on a side. The function <i>fill_coordinates()</i> is charged with initializing the set of coordinates with random data. Duplicate points are allowed. The seed for the random number can be passed on the command line; while debugging, I used a shell script to check 10,000 runs of the program at a time, and to stop with the random seed printed if the program failed. </p>

<p>There are two functions in the program to calculate the closest pair&#151;the first is <i>O</i>(|<i>S</i>|<sup>2</sup>), which checks the results of the more complex recursive version and is in the function <i>closest_via_n_squared()</i>. </p>

<p>The actual algorithm starts in <i>closest_via_n_log_n()</i>, which does the preliminary work, assigning the coordinate indices to the arrays <i>x_sort</i> (coordinate indices sorted by <i>x</i>) and <i>y_sort</i> (coordinate indices sorted by <i>y</i>). It is important later for a coordinate to know where the corresponding <i>x_sort</i> entry is, so a final setup step is to set this pointer back to the address in the <i>x_sort</i> array where the entry resides. The array <i>x_sort</i> is never altered once it is sorted.</p>

<p>Once the sorts are ready, I call a function<i> find_closest()</i>,<i> </i>which is the actual recursive function to locate the closest pair. The initial call passes the sort arrays and the number of points in the region, denoted as <i>N.</i></p>

<p>The recursive call checks the size of the arrays (that is, the number of points in the area). In small cases of one, two, or three points, the calculations are done directly on the points. A case where one point is passed returns an infinite distance. Assuming that <i>N</i>&gt;3, you do the recursive calls. First decide on a split line, which can be easily determined by the middle point in the <i>x_sort</i> array. Once the split is located, the <i>y_sort</i> array is partitioned into halves, one for the left side and one for the right. This is trickier than it first appears, and many references to this algorithm explain it incorrectly.</p>

<p>The difficulty is semantics. Strictly speaking, you are not locating an <i>x</i> value (horizontal coordinate value) and partitioning around it. Rather, it is necessary to put those <i>y_sort</i> values that correspond to <i>x_sort[0] </i>through <i>x_sort[N/2] </i>in the left, and the remainder in the right. What's the difference? There could be coordinates with duplicate <i>x</i> distance values right at the split line. In other words, the true split must be by array index, not by Euclidean <i>x</i> distance. Splitting purely by <i>x</i> distance can result in the left recursive call receiving indices in <i>x_sort</i> that do not have a corresponding value in <i>y_sort</i>. The solution is that you compare by pointers, thus the need to have a coordinate know the address of its <i>x_sort</i> counterpart. The variable <i>mid_ptr</i> is used for this. </p>

<p>After the <i>y_sort</i> is split (at a cost of <i>O</i>(|<i>S</i>|)), recursive calls return values for pairs <i>P</i><i><sub>L</i></sub> and <i>P</i><i><sub>R</i></sub>, and distances <img src="delta12.gif"><i><sub>L</i></sub> and <img src="delta12.gif"><i><sub>R</i></sub>. The actual function returns an item of type <i>pair</i>, which contains the coordinates and their distance. </p>

<p>The next step is to examine the points in the strip. Using the original <i>y_sort</i>, any coordinates in the strip are placed into a temporary array <i>y_strip</i>. This is then scanned with the two for loops. The <i>break</i> statement (labeled "important") lets the loop with the index <i>j</i> terminate early. In fact, it always terminates with <i>j</i>&lt;=4, just as it should. Without this statement, the two loops execute in quadratic time compared to the number of points in <i>y_sort</i>.</p>

<p>Finally, compare the best in the strip to the distances <img src="delta12.gif"><i><sub>L</i></sub> and <img src="delta12.gif"><i><sub>R</i></sub>, and return the smallest pair of all of them. The recursion goes all the way back to the calling function, where you have the answer.</p>

<p>Meanwhile, my wife and I had made a few successful stops right away. I was raring to go, having recently consumed a grand&eacute; caf&eacute; mocha with whipped cream. I was basking in the fact that I knew a good solution to the "all-pairs closest points" problem, when my wife continued: "What other toy store is the closest to this one?". Of course, since we were sitting in the parking lot at a particular store right at that moment, we could decide on that question in <i>O</i>(|<i>S</i>|) for that store. But I anticipated she would be asking that again and again as the day wore on, so I started thinking about how to solve the "all nearest neighbors problem"&#151;for all toy stores, what is the closest <i>other</i> toy store? This can be done in <i>O</i>(|<i>S</i>|log|<i>S</i>|) as well. But that's next year's shopping puzzle.</p>


<p><b>DDJ</b></p>

</body>
</html>
