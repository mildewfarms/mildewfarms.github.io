<html>
<head>
<title>Beyond Functional Requirements On Agile Projects</title>
<link rel="Stylesheet" rev="Stylesheet" href="../../../../forms/Layout.css" type="text/css">
<link rel="Stylesheet" rev="Stylesheet" href="../../../../forms/FontStyles.css" type="text/css">
<link rel="Stylesheet" rev="Stylesheet" href="../../../../forms/newarticle.css" type="text/css">
<script src="../../../../forms/popwindow.js"></script>
</head>

<body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000">
<!--Copyright &#169; Dr. Dobb's Journal-->
<p><i>Dr. Dobb's Journal</i> October 2008</p>

<h1>Beyond Functional Requirements On Agile Projects</h1>
<h2>Strategies for addressing nonfunctional requirements </h2>


<h3>By Scott W. Ambler</h3>


<I>
Scott is Practice Leader Agile Development for IBM Rational.</I>

<hr>




<p>Study after study has shown poor requirements management is the leading cause of failure for traditional software development teams. When it comes to requirements, agile software developers typically focus on functional ones that describe something of value to end users&#151;a screen, report, feature, or business rule. Most often these functional requirements are captured in the form of user stories, although use cases or usage scenarios are also common, and more advanced teams will iteratively capture the details as customer acceptance tests. Over the years, agilists have developed many strategies for dealing with functional requirements effectively, likely one of the factors leading to the higher success rates enjoyed by agile teams. Disciplined agile teams go even further, realizing that there is far more to requirements than just this, that we also need to consider nonfunctional requirements and constraints. </p>

<p>Nonfunctional requirements (NFRs), also known as "technical requirements" or "quality of service" (QoS) requirements, focus on aspects that typically cross-cut functional requirements. Common NFRs include accuracy, availability, concurrency, consumability (a superset of usability), environmental/green concerns, internationalization, operations issues, performance, regulatory concerns, reliability, security, serviceability, support, and timeliness. </p>

<p>A constraint defines a restriction on your solution, such as being required to store all corporate data in DB2 per your enterprise architecture, or only being allowed to use open source software (OSS), which conforms to a certain level of OSS license. Constraints can often impact your technical choices by restricting specific aspects of your architecture, defining suggested opportunities for reuse, and even architectural customization points. Although many developers will bridle at this, the reality is that constraints often make things much easier for your team because some technical decisions have already been made for you. I like to think of it like this&#151;agilists will have the courage to make tomorrow's decisions tomorrow, disciplined agilists have the humility to respect yesterday's decisions as well.</p>

<p>Although agile teams have pretty much figured out how to effectively address functional requirements, most are still struggling with NFRs and constraints. Some teams create technical stories to capture NFRs and constraints in a simple manner as they capture functional requirements via user stories. This is great for documentation purposes but quickly falls apart from a management and implementation point of view. Agile requirements management strategies (see <a href="http://www.agilemodeling.com/essays/changeManagement.htm">www.agilemodeling.com/essays/changeManagement.htm</a>) assume that requirements are self-contained and can be addressed in a finite period of time, an assumption that doesn't always hold true for NFRs and constraints.</p>


<div>
    
<div class="smallcap">&#91;Click image to view at full size&#93;</div>
<!--  -->    
<img class="illowide" src="080901sa01_f1.jpg" onclick = "popimage(this,'www.ddj.com - Beyond Functional Requirements On Agile Projects - Figure 1')">

<div class="caption">
Figure 1: The full system lifecycle.
</div>
</div>


<p>Figure 1 depicts a high-level timeline for an agile system lifecycle. It shows how the full system lifecycle addresses the preproject activities of Iteration -1 (see "The Iteration Negative One," <a href="http://www.ddj.com/architect/209902719">www.ddj.com/architect/209902719</a>), the full software development lifecycle (SDLC), the Production phase where the system is operated and supported, and an optional Retirement phase where the system is completely removed from your environment. The system development lifecycle includes Iteration 0, the construction lifecycle, and the release iteration(s) and is gone through once for each successful release of your system. During Iteration 0, also called the Inception phase, you do the work required to get the project started, including initial modeling and planning. During the construction lifecycle, the portion of the lifecycle that most agile methods focus on, you build the system. Disciplined agile construction includes an independent investigative testing effort (see "Agile Testing Strategies," <a href="http://www.ddj.com/architect/196603549">www.ddj.com/architect/196603549</a>) that runs in parallel to development activities. During the release iteration(s), also called the Transition phase (see "The Agile End Game," <a href="http://www.ddj.com/architect/198800565">www.ddj.com/architect/198800565</a>), you do the work required to deploy the system into production. This lifecycle is important because it reveals three of the four strategies for addressing NFRs and constraints on agile projects:</p>

<ul>
    <li>Initial requirements and architecture envisioning during Iteration 0 to identify NFRs and constraints.</li>
  <li>Just in time (JIT) model storming through the construction lifecycle to explore the details.</li>
  <li>Independent investigative testing throughout the lifecycle to ensure that the system addresses the NFRs and constraints appropriately.</li>
  <li>Developer education so that they understand the fundamentals of the full range of architectural concerns described in the requirements.</li>
</ul>









<h3>Agile Modeling Strategies</h3>

<p>An important part of Iteration 0 is requirements and architectural envisioning because it enables you to gain critical information required to start the project successfully. For example, few organizations will fund a project unless the team can indicate what problem they intend to address, how they intend to do so, roughly how much it will cost, and roughly how long it will take. The team needs at least a high-level understanding of the requirements and a reasonable technical strategy; hence, the need for initial envisioning. I recently ran a survey within the agile community to explore this issue (the results are posted at <a href="http://www.ambysoft.com/surveys/practicesPrinciples2008.html">www.ambysoft.com/surveys/practicesPrinciples2008.html</a>) and found that 83 percent of respondents indicated that they very often, often, or sometimes performed requirements envisioning and 81 percent performed architectural envisioning at similar levels. Contrary to popular belief, agilists do in fact do up-front modeling.</p>

<p>It is during your initial requirements envisioning that you will identify high-level functional requirements, NFRs, and constraints. All forms of requirements will drive your architectural efforts, which occur iteratively in parallel with requirements envisioning. Initial envisioning is done at a high-level, the goal is to do just enough modeling to provide sufficient information to drive the initial decision making on your project. The goal is not to create detailed specifications because that would actually increase the risk, and the costs, of your project.  </p>

<p>Although the initial envisioning efforts make you aware of the NFRs and constraints, you will discover that you very likely don't have the details that you require to fully address them. These details are captured on a JIT basis throughout construction via short model storming sessions with stakeholders. For example, you'll pull a functional requirement off the top of the stack that describes a change to an existing screen and supporting functionality behind that screen. As you explore the details of the functional requirement on a JIT basis with your stakeholder(s), you will also explore the cross-cutting NFRs and constraints that apply to it. The implication is that not only do the developers need to be aware of the NFRs and constraints, which the initial envisioning should have accomplished, they need to be sufficiently skilled to do so. More on this shortly.</p>










<h3>Independent Testing</h3>

<p>Models, particularly those created early in the lifecycle, are little better than speculative promises regarding what you intend to build or how you intend to build it. Promises are nice, but validation that you're fulfilling those promises is even nicer. Although many agilists have adopted a test-first or test-driven approach to development, an incredibly good practice, as I described in "Scaling Test-Driven Development" (<a href="http://www.ddj.com/architect/205207998">www.ddj.com/architect/205207998</a>) this is at best a confirmatory approach to testing. The goal of confirmatory testing is to validate that you've built the system to your understanding of the requirements. Test-driven development (TDD) is effectively the agile equivalent of testing against the specification, but that assumes that the requirements are identified and understood. If you're not doing TDD you've got an even bigger challenge. </p>

<p>The point is that TDD is a great start but that you need more. As Figure 1 shows, disciplined agile teams include an independent testing effort that runs in parallel to development. The basic strategy is that the agile team should deploy a working build of their system to an independent test team on a regular basis, at least once an iteration, so that they can perform investigative testing and other higher forms of testing. This independent testing effort addresses concerns that are typically addressed by traditional teams during the testing phase at the end of the lifecycle. By doing this testing in parallel with development, and by reporting issues back to the development team quickly, you can reduce the average cost of addressing any defects and often shorten the overall time of your project. The development team treats the identified defects as potential requirements to be put onto their prioritized work item list and eventually addressed through TDD.</p>

<p>The independent test team is small, perhaps one independent tester for every 10  people on the development team, because the development team should be addressing confirmatory testing (which is the majority of the testing work). The independent testers are highly skilled testing specialists, perhaps the top 5 to 10 percent of the testing community, who have access to sophisticated testing tools. They will use these tools to try to break the system, and this is often around the types of issues addressed by NFRs and constraints. </p>










<h3>Developer Education</h3>

<p>The fourth strategy for addressing NFRs and constraints on agile teams, and on traditional teams for that matter, is to educate developers in these issues. It's easy to say that you're going to identify and then validate NFRs pertaining to consumability, security, and green IT, but if developers don't have even a basic understanding of these issues then how could they possibly do so effectively? I'm not saying that everyone needs to become a security expert, but they should understand the fundamentals. </p>

<p>Many organizations balk at the concept of training their developers to this extent, a decision that is incredibly short sighted. Yes, giving everyone a two-day training course in each of 20 to 30 topics adds up. But, when you spread these costs over a 30-year career, they're very small. When you look at the total value provided by improved knowledge and skills, it often proves to be a very good investment. When you enhance your training and education efforts by nonsolo development practices such as pair programming and modeling with others, you quickly see benefits from the training courses.</p>

<p>The four strategies for addressing nonfunctional requirements and constraints on agile projects go hand-in-hand. You need to first identify these issues through requirements envisioning and formulate a viable technical strategy through architectural envisioning during Iteration 0. The details are then explored on a just-in-time (JIT) manner throughout construction and validated via parallel independent investigative testing. Finally, to ensure that everyone involved understands these issues, your organization must invest in educating IT professionals, giving them knowledge beyond the intricacies of the technology <i>de jure</i> that will improve their overall productivity throughout their careers. Disciplined agilists go beyond the prioritized stack approach to requirements management and adopt a more holistic approach that addresses not only functional requirements but nonfunctional requirements and constraints as well.</i></p>

















</body>
</html>