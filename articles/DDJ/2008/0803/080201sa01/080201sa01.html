<html>
<head>
<title>Agile is Relative</title>
<link rel="Stylesheet" rev="Stylesheet" href="../../../../forms/Layout.css" type="text/css">
<link rel="Stylesheet" rev="Stylesheet" href="../../../../forms/FontStyles.css" type="text/css">
<link rel="Stylesheet" rev="Stylesheet" href="../../../../forms/newarticle.css" type="text/css">
<script src="../../../../forms/popwindow.js"></script>
</head>

<body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000">
<!--Copyright &#169; Dr. Dobb's Journal-->
<p><i>Dr. Dobb's Journal</i> March 2008</p>

<h1>Agile is Relative</h1>
<h2>When it comes to agile development, myths abound</h2>


<h3>By Scott W. Ambler</h3>


<I>Scott is a DDJ Senior Contributing Editor and author of numerous IT books. He can be contacted at <a href="http://www.ambysoft.com/scottAmbler.html">www.ambysoft.com/scottAmbler.html</a>.</I>

<hr>




<p>Agile software development practices have been adopted by many IT organizations, and it's fair to conclude that agile is very clearly mainstream and is on track to become the dominant approach to software development. Having said that, many people are still struggling to understand what agile is really all about, particularly when it comes to scaling agile approaches. People struggle because they've been misled by some of the popular myths surrounding agile, they're suffering from "versusitis," and they've been misled about the benefits of traditional approaches. This month, I hope to motivate you to pause and reconsider your approach to agile, even if you have years of successful experience with agile but particularly if you think that it won't work in your situation.  </p>

<p>When you talk with people who are unfamiliar with agile, you quickly discover that there are a lot of myths and misunderstandings surrounding it. For example, I've lost track of the number of times I've been told that Agilists don't model or write documentation, which is particularly galling because I'm the person behind the Agile Modeling (AM) methodology. Learn how to use Google, people! Table 1 lists the common myths that I've run into over the years and provides some advice for overcoming them.</p>


<h3>Do You Have Versusitis?</h3>

<p>Gaining a clear understanding of agile software development is not only hobbled by agile myths, but also by versusitis&#151;a debilitating disease that afflicts a large number of IT professionals. The symptoms of versusitis include the desire to think of things in absolute terms (for example, either you're doing Scrum fully or you're not doing it at all), or worse yet, in terms of absolute trade-offs (for example, you want to know the differences between agile versus CMMI). Versusitis reduces your effectiveness as an IT professional because it inhibits you from seeing the shades of gray that exist between the extremes of black and white.</p>

<p>The cure for versusitis is to become flexible&#151;to recognize that although as technologists we work in a binary world of zeros and ones, that the real world is in fact analog. In particular, recognize that when it comes to soft issues such as process, there are no absolutes, and you must find the sweet spot between the extremes. For example, many organizations have adopted Scrum's daily stand-up meetings and its philosophy about prioritizing requirements, but have given up on Scrum's concept of Product Owner due to scalability concerns (see my January 2008 column, <a href="http://www.ddj.com/architect/204801134">www.ddj.com/architect/204801134</a>). Other people recognize that they can leverage agile techniques within a CMMI environment; see Hillel Glazer's blog at www.agilecmmi.com for some insights, because they prove compatible in practice. The point is that the religious fervor that we often see around process-related subjects rarely helps people to understand and identify how they can successfully benefit from new ideas. By working together, we can stamp out versusitis forever!</p>



<div>
<table cellpadding=3 cellspacing=3>
  <tr valign="top">
    <td><b>Agile Myth</b></td>
    <td><b>Reality</b></td>
  </tr>
  <tr valign="top">
    <td>Agile teams don't write documentation</td>
    <td>Agilists treat documentation like a requirement&#151;it gets estimated, prioritized, and "implemented" in the appropriate order. By putting price tags on things, we find that our stakeholders are a bit more selective as to how they choose to invest their hard-earned money. We also prefer executable specifications in the form of tests over static documents (see my February 2008 column for details: <a href="http://www.ddj.com/architect/205207998">www.ddj.com/architect/205207998</a>), reducing the amount if interim documentation created. And of course, we'll still need to create user documentation, support documentation, operations documentation, and even system overview documentation for the maintenance team.</td>
  </tr>
  <tr valign="top" bgcolor="CCCC99">
    <td>Agile teams don't model</td>
    <td>DDJ's 2007 Agile Adoption Survey found that 93% of Agile teams do whiteboard modeling, 77% of teams do some up-front requirements and architecture envisioning, 66% of Agile teams do paper-based modeling, and 47% of Agile teams use some sort of electronic drawing or CASE tool. Visit www.agilemodeling.com for more information as to how Agilists model in practice, and <a href="http://www.ambysoft.com/surveys/">www.ambysoft.com/surveys/</a> for details about the survey itself.</td>
  </tr>
  <tr valign="top">
    <td>Agile is undisciplined</td>
    <td>Agile requires greater discipline than traditional approaches, as I describe in my October 2007 column at www.ddj.com/architect/201804241.</td>
  </tr>
  <tr valign="top" bgcolor="CCCC99">
    <td>Agile teams don't plan</td>
    <td>Agile teams do as much planning, and often more, than traditional teams, but they do it in a different way. The 2007 Agile Adoption Survey explored the value of various work products on Agile teams and found that the 5th most valuable one was an iteration task list, the agile version of a detailed project plan. The 19th most valuable work product, out of 19, was a detailed Gantt chart (but as VersionOne's Robert Holler points out, at least it's in the top 20). Agilists plan, they're just not creating dubious management artifacts.</td>
  </tr>
  <tr valign="top">
    <td>Agile only works for small, colocated teams</td>
    <td>Agile works best in these situations, as do traditional approaches, but the survey also found that many organizations are now successfully running agile teams of 50, 100, and even over 200. Furthermore, the survey showed that organizations are even succeeding at agile offshoring (albeit at a lower success rate).</td>
  </tr>
  <tr valign="top" bgcolor="CCCC99">
    <td>Agile is difficult to govern</td>
    <td>As I showed in my November 2007 column (<a href="http://www.ddj.com/architect/202401107">www.ddj.com/architect/202401107</a>), agile projects are easier to govern due to the higher stakeholder involvement and greater visibility provided by the regular delivery of working software.</td>
  </tr>
  <tr valign="top">
    <td>Agile requires talented people</td>
    <td>Yes, but so does traditional. Agile does in fact motivate people to be generalizing specialists who have a wider range of skills than people who are just specialists. This is a good thing for the individuals because it makes them more employable and it's good for organizations because their people are more effective.</td>
  </tr>
</table>

<div class="caption">
Table 1: The myths surrounding agile software development.
</div>
</div>


<h3>The Myths of Bureaucracy</h3>

<p>The traditional community places far more faith in bureaucracy than is justified. Several myths are based around the value of comprehensive specifications, namely that you need to document requirements in detail, that you need to document the design in detail, and that you need to create detailed test plans. The reality is that you need to understand and then implement the requirements; you should strive to think through the design before implementing it, and then  you need to test your work. The relationship between these goals and detailed documentation is tenuous in the best of circumstances, let alone the less-than-ideal situations IT professionals regularly find themselves in. These myths assume that the static specifications are sufficiently correct and kept up to date, that they'll be read and understood by the intended audience, and that the specifications will be trusted and then followed. Agilists have found that capturing specifications in the form of tests, which you can execute as part of your regression test suite, is far more effective than capturing specifications as static documentation.  </p>

<p>For decades, traditionalists have assumed that software development is similar to civil engineering, despite all evidence to the contrary, and have thus justified significant up-front work as a result. This leads to several myths surrounding the value of detailed, up-front planning and modeling. Significant effort is often expended early in the project to "set a solid foundation" from which to proceed. But people aren't good at defining requirements in detail and changes in the business environment will necessitate requirements changes no matter how good your documentation efforts. In practice, software development proves to be a dynamic endeavor that is better suited to the just-in-time (JIT) planning and modeling approach prevalent in the agile community. There is definitely value in planning and modeling, but that value is gained throughout the project, not just in the beginning.</p>










<h3>Flexibility Scales</h3>

<p>Once you get beyond all of the myths and recognize that it's not a black-and-white world, it soon becomes obvious that there is no one single agile strategy that is right for all situations. This is true even in the most simple of situations, let alone in the complex situations that we usually find ourselves in&#151;teams are made up of individuals, people who have their own unique experiences, skills and preferences. The implication is that we need to be flexible in the way that we approach software process&#151;that a single "repeatable" approach isn't going to work in all situations.</p>

<p>This is particularly true when you scale agile software development approaches, and that to do so effectively you need to recognize that there are many factors to consider. Each team finds itself in different situations, and depending on where it finds itself with respect to these various factors will determine which agile strategies to apply and how to do so. The critical complexity factors are:</p>

<p><b>1. Geographical distribution.</b> Is your team colocated (working in the same room), near located (working in the same building or city), or dispersed to various locations around the world? Your communication strategy will vary; in particular, the more dispersed your team, the greater the need for coordination and interim documentation.</p>

<p><b>2. Regulatory compliance.</b> Regulations such as the Sarbanes-Oxley Act and the Food and Drug Administration (FDA) statutes will increase the documentation and process burden on your projects. </p>

<p><b>3. Entrenched policies, people, and processes. </b>The organization in which your agile team works may be very agile, it may be very traditional, or somewhere in between. Development teams will need to be flexible in the way that they work with enterprise support teams, and similarly these support teams will need to vary their strategy depending on the working styles of the various teams that they support.  </p>

<p><b>4. Legacy assets.</b> Does your system have to integrate with existing assets such as legacy databases, shared services, or legacy systems? Not only will your technical strategy change to reuse these assets, you may discover that you need to refactor them to bring their quality in line with what your team is creating.  </p>

<p><b>5. Organizational distribution.</b> Do you have people on your team from different work groups, divisions, countries, or even companies? This will impact the way that you organize your team, how you organize the work, and how you share information.  </p>

<p><b>6. Degree of governance.</b> If you have one or more IT projects underway, then you have a development governance program in place. How formal is it? Does it enable or hinder agile work practices? Does it add additional overhead or does it help to streamline your work?  </p>

<p><b>7. Team size. </b>The way that you organize, manage, and support a team of 5 people is very different than the way you do so for a team of 50 or 500.  </p>

<p><b>8. System complexity. </b>The more complex the system, the greater the need for a viable architectural strategy, although that doesn't necessarily imply the need for onerous documentation. Many agile teams adopt the Rational Unified Process (RUP)'s strategy of envisioning the architecture early in the lifecycle and then immediately proving that it works via the creation of an end-to-end, working skeleton of the system. </p>



<p>The values contained in the Agile Alliance's Agile Manifesto (<a href="http://www.agilemanifesto.org">www.agilemanifesto.org</a>) implicitly promote the concept that agile is relative, yet it seems to me that we often forget this in practice. More and more we're applying agile approaches at scale and we're finding that we need to be flexible in our approach. We're also finding that at scale, we need to move towards the right-hand side of the agile values more than some agile zealots would prefer. The agile strategies that worked for small, colocated teams developing straightforward systems won't work very well for large, dispersed teams working in regulatory environments on very complex software. Different situations require different strategies, and the best advice that I can give is to embrace change.</p>
















</body>
</html>