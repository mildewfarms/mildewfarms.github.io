<html>
<head>
<title>Conversations: Pairwise and Combinatorial Testing</title>
<link rel="Stylesheet" rev="Stylesheet" href="../../../../forms/Layout.css" type="text/css">
<link rel="Stylesheet" rev="Stylesheet" href="../../../../forms/FontStyles.css" type="text/css">
<link rel="Stylesheet" rev="Stylesheet" href="../../../../forms/newarticle.css" type="text/css">
<script src="../../../../forms/popwindow.js"></script>
</head>

<body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000">
<!--Copyright &#169; Dr. Dobb's Journal-->
<p><i>Dr. Dobb's Journal</i> March 2008</p>

<h1>Conversations: Pairwise and Combinatorial Testing</h1>
<h2></h2>


<h3>By Jonathan Erickson</h3>


<I></I>

<hr>


<img src="080201cv01_f1.jpg" width="100" height="150" border="0" align="left">
<p>
<b>Jeff Lei</b>
</p>

<p><i>Jeff Lei is an assistant professor of Computer Science at the University of Texas, Arlington. He can be contacted at <a href="mailto:ylei@cse.uta.edu">ylei@cse.uta.edu</a>.</i></p>

<p><b>DDJ:</b>Pairwise testing is considered the traditional approach to testing. Can you tell us what pairwise testing is?</p>

<p><b>JL:</b> Assume that a software object has <i>n</i> input parameters, each parameter having <i>d</i> possible values. One straightforward approach to testing this object is to test every possible <i>n</i>-way combination of values; for instance, every combination of values of the <i>n</i> parameters. This approach covers the entire input space, but is nearly always impractical for real-world software due to the well-known combinatorial explosion problem. </p>

<p>Pairwise testing is an alternative approach that only tries to test every possible two-way combination of values; that is, every combination of values of any two parameters. Testing all two-way combinations, instead of all <i>n</i>-way combinations, does not cover the entire input space. However, empirical studies show that many software faults are caused by interactions between only two parameters. Testing all two-way combinations can effectively detect these faults, while substantially reducing the number of tests. </p>

<p><b>DDJ: </b>Where does pairwise testing come up short or in what ways does it reach its limits?</p>

<p><b>JL:</b> Pairwise testing primarily targets faults caused by interactions between two parameters. However, some faults can be caused by interactions involving more than two parameters. Those faults cannot effectively be detected by pairwise testing.  </p>

<p><b>DDJ: </b>Combinatorial testing, which is the focus of much of your current research, seems to address these shortcomings. Can you tell us what combinatorial testing is?</p>

<p><b>JL:</b> Combinatorial testing is a more general type of testing than pairwise testing. Instead of focusing on two-way combinations, combinatorial testing tests all <i>t</i>-way combinations, where <i>t</i> is referred to as the strength of testing and can be chosen by the user.</p>

<p><b>DDJ: </b>Are there situations where combinatorial testing doesn't make sense?</p>

<p><b>JL:</b> Combinatorial testing does not make sense when only a few of the input parameters interact with each other. A group of parameters interact if their values jointly affect the runtime behavior of the object under test. Note that for combinatorial testing to be effective, the input parameters and the values those parameters can take need to be identified. Approaches such as category partitioning can be used to identify the parameters and their possible values. </p>

<p><b>DDJ: </b>Can you share a real-world scenario/example of how combinatorial testing solved a problem?</p>

<p><b>JL:</b> A recent study of actual faults by D. R. Kuhn et al. at NIST examined several open-source software applications and reported that all of the known faults are caused by interactions involving no more than six parameters. This study is, however, in retrospect. We are currently collaborating with several groups to apply combinatorial testing to real-world applications. </p>

<p><b>DDJ: </b>Can you tell us about the unique algorithms that form the foundations for combinatorial testing?</p>

<p><b>JL:</b> The main challenge for combinatorial testing is to generate a test set that guarantees the test coverage chosen by the user and that is as small as possible. Existing algorithms for pairwise testing can be extended for general combinatorial testing. However, because of the higher strength of testing, general combinatorial testing has higher space and time requirements than pairwise testing. Therefore, general combinatorial testing algorithms must strike a balance between the size of the test sets that they generate and the amount of time and space that they require. </p>

<p><b>DDJ: </b>What about source code implementations of the concept? Have you or anyone else implemented combinatorial testing in working programs?</p>

<p><b>JL:</b> A combinatorial testing tool called "FireEye" has been developed by NIST and the University of Texas at Arlington (UTA). FireEye implements several combinatorial testing algorithms developed by the Automated Combinatorial Testing for Software group (csrc.nist.gov/groups/SNS/acts/index.html), which involves NIST, UTA, and several other universities. FireEye can quickly generate <i>t</i>-way test sets up to six-way testing.</p>

<p><b>DDJ: </b>What about scalability? Does combinatorial testing scale well?</p>

<p><b>JL:</b> As a black-box testing technique, combinatorial testing does not examine the source code. The main factor to be considered for scalability is the size of the input space, which is determined by the number of parameters and number of possible values each parameter can take. With appropriate abstractions, the newly developed algorithms for combinatorial testing can quickly generate test sets for up to six-way testing, which we believe will be effective for real-world applications.</p>







</body>
</html>