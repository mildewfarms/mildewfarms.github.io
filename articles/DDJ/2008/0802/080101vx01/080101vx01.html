<html>
<head>
<title>Software Builds and the Virtual Time Machine</title>
<link rel="Stylesheet" rev="Stylesheet" href="../../../../forms/Layout.css" type="text/css">
<link rel="Stylesheet" rev="Stylesheet" href="../../../../forms/FontStyles.css" type="text/css">
<link rel="Stylesheet" rev="Stylesheet" href="../../../../forms/newarticle.css" type="text/css">
<script src="../../../../forms/popwindow.js"></script>
</head>

<body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000">
<!--Copyright &#169; Dr. Dobb's Journal-->
<p><i>Dr. Dobb's Journal</i> February 2008</p>

<h1>Software Builds and the Virtual Time Machine</h1>
<h2>Making efficient use of available hardware</h2>


<h3>By John Graham-Cumming</h3>


<I>John is founder of Electric Cloud, which focuses on improving software production processes. He can be contacted at jgc@electric-cloud.com</I>

<hr>




<p>If you are not yet using virtualization in your build environment, then it's time to get moving. Applying virtual machine technology to a build system, just as many have done in the test environment, means being able to give instant answers to questions like "Can you give me the log files for build XYZ?", "Which system headers were used for project ABC?" and it means always being able to say "Yes" when someone asks for a rebuild of an ancient software version.</p>

<p>Fundamentally, software build management is about the process of getting all the right software components&#151;a particular version of the source, the specific tools (such as compilers and linkers) and the right third-party code (such as system libraries)&#151;on to a machine with the right operating system and running the build script.</p>

<p>Once the build script has run, the object code generated has to be extracted, source code tagged, and precious log files and other output saved for later use. Frequently, a complete record of the configuration of the build machine is needed (including tool, library, and OS versions) as well as a bill-of-materials listing all the source code that went into the build.</p>

<p>Complete, detailed records are necessary because the build machine's configuration will inevitably change as time goes by and other builds are performed on it.</p>

<p>But what if that were not the case? What if every time the build finished, the entire machine was placed in a vault in case the build had to be reproduced? Each time the build manager performed a build, they'd have to go out and buy a new machine.</p>

<p>Sounds ridiculous? Yes. But wouldn't it be great?</p>

<p>There would be no problem reproducing an old build when an important customer demands a bug fix, or a security headache means rereleasing old code. No problem grepping an old log file. No problem asking questions about what exactly went into a build. No need to guess what the configuration was, or sweat trying to reproduce an old build.</p>

<p>Happily, virtual machines turn physical hardware into files. And like any other file they can be backed up, versioned, and reloaded when needed.</p>

<p>If builds are performed on a virtual machine, that machine can be saved and tagged with each build. Or a virtual machine "snapshot" can be taken and tagged with the build number. You could even check the snapshot into version control when the build is tagged.</p>

<p>Now the configuration of an old build is on hand at any time. Just fire up the right VM to go back in time. You'll be taken right back to the moment the build finished, with the complete machine state available, and a cursor flashing at a shell prompt ready for the next command.</p>

<p>But keeping the complete state is not the only advantage of virtualization. Old operating systems can be made to run on new hardware by virtualizing the interfaces that the OS sees. It's no longer necessary to keep ancient hardware around&#151;and working&#151;if that Windows 98 VM can run on the latest virtualized Intel box.</p>

<p>Virtual machines also mean that pristine configurations are always available. The ultimate "make clean" is booting from a newly initialized virtual machine. A repository of configurations can be built and run on any machine available to the build team. The problem of maintaining specific machines for specific builds goes from being a hardware issue to a software one.</p>

<p>And the same hardware can be used to support different OS configurations, making more efficient use of build infrastructure.</p>

<p>All these changes mean that software production management products need to understand virtualization and help the build team manage virtual assets. If the management system is virtualization-aware, then it can control the entire process of starting the right virtual machines, getting sources, running builds, archiving output, and saving virtual machine snapshots.</p>

<p>The latest software production management products (including my company's ElectricCommander) integrate with the classic suite of build tools (such as SCM, scripting languages, make or ant tools, and test systems) and have been enhanced to be virtualization-aware.</p>

<p>In short, virtualization makes more efficient use of existing build hardware, simplifies the management of different build configurations, and gives the build manager a virtual time machine capable of taking them back to the moment when any given build was completed.</p>

















</body>
</html>