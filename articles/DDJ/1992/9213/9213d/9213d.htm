<HTML>
<META NAME="year" CONTENT="1992">
<HEAD>
<TITLE>SP92: TEMPLATES IN C++</TITLE></HEAD>
<BODY BGCOLOR="#ffffff">
<h1>TEMPLATES IN C++<a name="02f5_0003"></h1><P>
<h2><a name="02f5_0001"><a name="02f5_0000">Function and class templates are powerful features</h2><P>
<h3>Nicholas Wilt</h3><P>
<p><i><a name="02f5_0002"><a name="02f5_0000">Nicholas is a software engineer working in the Boston area.  His interests include computer graphics, C++, and assembler programming.  He can be reached through the DDJ offices.</i></p><hr><P>
Templates are one of C++'s most powerful features in that they allow you to define the &quot;shape&quot; of a function or class and leave the implementation specifics to the compiler.<P>
Function templates can be used to describe algorithms defined on a wide variety of types. By using a function template to define a sorting algorithm, for example, the type to sort is left as a parameter.  Then, whenever the template is invoked, a sort function for that type is generated by the compiler.<P>
Class templates can be used to define a class's structure in terms of the template arguments.  For every different set of template arguments given to a class template, the compiler creates a new class.  This is an especially useful feature for container classes; when you define a class template for BinaryTree, for example, it becomes easy to declare BinaryTree of int, float, or a user-defined type.<P>
Compared to the way C++ handles inheritance and polymorphism, templates are relatively simple, especially once you come to grips with their syntax.  The examples in this article were developed with Borland C++ 3.0, but with a minimum of effort they should work with other C++ implementations that support templates.<P>
<h3><a name="02f5_0004">Function Templates<a name="02f5_0004"></h3><P>
Selection, like sorting, is defined on all ordered types.  Selection takes an array of N elements and an index i, and returns the ith element in the sorted order of the array.  To compute the median of an N-element input array, for example, you select the element represented by N/2.  The minimum is selection of the 0th element; the maximum is selection of the element represented by (N - 1).  (Note that arrays are numbered from 0.)<P>
Given the definition of the selection problem and its relation to the sorted order of the array, programmers often make the mistake of performing selection by sorting the array, then returning the ith element.  This technique works, but it does more work than needed.  It is more efficient to repeatedly partition the array and consider only the partition that contains the ith element.  A good discussion of a randomized, expected linear time-selection algorithm is presented in Introduction to Algorithms by Thomas Cormen, Charles Leiserson, and Ronald Rivest (MIT Press, 1990).  This algorithm is usually more efficient than one that sorts the input array.<P>
In pretemplate C++, there were two (unattractive) alternatives for implementing selection:<P>
<UL>
<li>A generic implementation, in which a variety of types can be selected with a single routine.  The qsort() library routine in ANSI C takes this approach.</li>
<li>A variety of selection routines, one for each type you wish to select.</li>
</UL>
The generic approach is not type-safe; if you confuse integers with floating-point numbers, the compiler is unable to warn you.  It is also inefficient, since a generic pointer to a function is typically called every time two elements need to be compared.<P>
The variety approach is equally unattractive because it involves code duplication.  Errors are likely to be introduced during code duplication, and errors in the routine itself get propagated across all the routines.<P>
Templates offer a solution that resolves both concerns.  By allowing you to write the function once in a general form, they enforce type safety and avoid source-code duplication.<P>
<h3><a name="02f5_0005">Syntax<a name="02f5_0005"></h3><P>
To declare a function template, you write something like <a href="#02f5_0006">Example 1</A>. <a href="#02f5_000b">Listing One</A> (page 32) shows an implementation of selection that uses templates.  Our template-based Select function is defined in <a href="#02f5_0007">Example 2(a)</A>.  The resulting code looks remarkably similar to the pseudocode found in textbooks on algorithms.  Select is a function that returns the ith element of an array of Ts.  What are Ts?  Ts are anything that can be sorted!  They are a parameter of the function template.<P>
<h4><a name="02f5_0006">Example 1: Declaring a function template.</h4><P>
<pre>
  template&lt;template parameters&gt;
  return value                   // From here on we define
  name (function parameters) {   // the function in terms of
    function body                // the template parameters.
  }</pre><P>
<P>
<h4><a name="02f5_0007">Example 2: (a) Defining a template-based Select function; (b) calling the Select function; (c) defining a template like this means it will not be invoked for integers.</h4><P>
<pre>
  (a)

  template&lt;class T&gt; T
  Select(T *base, int n, int i)
  {
      // Implementation
  }

  (b)

  int *arr, n;
  // ... allocate array and set n
  // Set penultimate to the second-largest element in arr.
  int penultimate = Select(arr, n, n - 2);

  (c)

  int
  Select(int *x, int n, int i)
  {
    // Own function definition of Select&lt;int&gt;
  }</pre><P>
<P>
To use Select, just call it with a pointer to an ordered type.  To select the second-largest element in an array of integers, for example, call Select, as shown in <a href="#02f5_0007"> Example 2(b)</A>.  Since Select uses the &lt; operator to determine how to order the array, operator &lt; must be defined for the class passed to Select.  Operator &lt; is built in for primitive types such as ints and floats, so we did not need to do anything special to select from an array of integers.<P>
Calling the template-based Select function is like invoking a macro.  Earlier, we called Select with a pointer to int.  This tells the compiler we need an instance of Select with T set to int.  As with a macro invocation, the compiler replaces each mention of T (the name of the template parameter) with int.  The resulting instance of Select takes an int* parameter, declares local instances of int, uses the integer &lt; operator to compare elements in the input array, and returns int.<P>
If the user were to call Select with a float* parameter, the compiler would create an instance of Select taking parameters (float*, const int, int) and replace T with float everywhere in the function declaration.  This function instance is distinct from the one for integers; the entry point, parameters, and code generated are completely separate.  In the executable, the only thing the two functions int Select(int*, const int, int) and float Select(float*, const int, int) have in common is that they both perform selection.<P>
What happens if you define your own Select function with the same parameters as an instance of the Select template?  If you were to define, say, <a href="#02f5_0007">Example 2(c)</A>, then the Select template would no longer be invoked for integers.  Instead, the user-defined Select function will be used.<P>
Select can be used on arrays of user-defined classes (let's call them MyClass), as well as on built-in types.  Just pass a pointer to the array of MyClass you want to select from, making sure operator &lt; is defined for MyClass.<P>
<a href="#02f5_000d">Listing Two</A> (page 32) illustrates the use of Select.  It has an example of selecting on arrays of a user-defined class, as well as the built-in int type.<P>
<h3><a name="02f5_0008">Class Templates<a name="02f5_0008"></h3><P>
You can specify templates for classes as well as functions.  The most common use for a class template is a container class such as a linked list or binary heap.  Let's take binary trees as an example.  A binary tree can contain any ordered type, so you can have binary trees of integers, floating-point numbers, or other objects.  In C++ without templates, you have two choices for implementing a binary-tree class: Implement a generalized BinaryTree class that takes a generic representation of the objects to manipulate, or implement a specific BinaryTree class for each type of object you wish to put in a binary tree.<P>
These are the same problems faced by the selection example given earlier.  A method that combines the best of both worlds (without templates) is to implement a generalized class, then derive &quot;Binary tree of integer,&quot; &quot;Binary tree of float,&quot; and so on from the base binary-tree class and make sure the member functions of the derived classes are type-safe.<P>
Templates provide a better approach.  By specifying the template for a BinaryTree class, you can define the class in terms of the template parameters.  Thus, a parameterized binary tree-node class can be defined, as in <a href="#02f5_0009">Example 3(a)</A>.  Note that the above definition is not of a class.  There is no class called BinaryNode; BinaryNode is merely a template describing a family of classes.  This family of classes has names like BinaryNode&lt;int&gt;, BinaryNode&lt;float&gt;, BinaryNode&lt;UserDefinedType&gt;, and so on, and every one of them is distinct.  That is why the left and right pointers in the class definition in <a href="#02f5_0009">Example 3(a)</A> are pointers to BinaryNode&lt;T&gt;, rather than pointers to BinaryNode.<P>
<h4><a name="02f5_0009">Example 3: (a) Defining a parameterized binary node class; (b) using classes generated from templates as base classes; (c) a vector class might take two parameters: the type to be a vector of and the number of elements in the vector.</h4><P>
<pre>
  (a)

  template&lt;class T&gt;
  class BinaryNode {
    T x;              // Contents of node
    BinaryNode&lt;T&gt; *left, *right;  // Left and right children
  //etc.
  };

  (b)

  // Class template for a binary tree node including a
  // pointer to the parent.
  template&lt;class T&gt;
  class BinaryNodeWithParent : public BinaryNode&lt;T&gt; {
    BinaryNodeWithParent&lt;T&gt; *parent;
  // etc.
  };

  (c)

  template&lt;class T, int Size&gt;
  class Vector {
    T x[Size];       // Vector contains Size T's.
  // etc.
  };</pre><P>
<P>
Classes generated from templates can be used as base classes; in fact, class templates can inherit from other class templates.  By extending the BinaryNode example, we might have <a href="#02f5_0009">Example 3(b)</A>.  <a href="#02f5_000f">Listing Three</A> (page 32) gives a minimal template-based BinaryTree class.  The binary-tree data structure is described in any good algorithms text; it supports a variety of operations on ordered types in logarithmic time on average.  Our BinaryTree class supports insertion, traversal, and query.  Although many other operations are defined on binary trees, they are omitted for lack of space.  It may be instructive to extend our BinaryTree class to support other operations such as minimum, maximum, and deletion.<P>
<a href="#02f5_0011">Listing Four</A> (page 33) is a typical C++ program that uses the BinaryTree class.  It simply insert ten random numbers in the range [0,99] into a BinaryTree &lt;int&gt;, then displays the pre-, in-, and post-order traversal orders of the tree.<P>
Unfortunately, we have concentrated on the most common type of template, which takes a single class parameter.  There can be multiple template parameters, and they need not be general classes.  A vector class might take two parameters: the type to be a vector of and the number of elements in the vector; see <a href="#02f5_0009">Example 3(c)</A>.<P>
The class template described here could reuse code for two-element vectors of integer (perhaps for screen coordinates in a graphics program) and three-element vectors of float (perhaps for world coordinates in a three-dimensional sketching program).<P>
<h3><a name="02f5_000a">Conclusion<a name="02f5_000a"></h3><P>
Templates open up a whole new world for C++ programmers.  They allow for compact and efficient implementation of container classes and other parameterized types.  They also allow general, efficient implementation of algorithms with a minimum of code duplication.  Look for C++ class libraries to change dramatically as templates become widely supported.  Many of the current approaches to flexibility are based on inheritance and have become outmoded with the advent of templates.<P>

<PRE>


_TEMPLATES IN C++_
by Nicholas Wilt
<a name="02f5_000b">
<a name="02f5_000c"></pre><B>[LISTING ONE]</B><pre><a name="02f5_000c">
// select.h -- Template-based C++ implementation of the randomized
//   selection algorithm from _Introduction to Algorithms_ by Cormen,
//   Leiserson and Rivest (pg. 187). Copyright (C) 1992 by Nicholas Wilt.
//   All rights reserved.

template&lt;class T&gt; T
Select(T *base, const int n, int inx)
{
  int left = 0;
  int right = n;

  // This while loop terminates when base[left..right]
  // defines a 1-element array.
  while (right != left + 1) {
    // Partition about the q'th element of the array
    int q = left + rand() % (right - left);

    T t = base[q];
    base[q] = base[left];
    base[left] = t;

    // Partition about base[left]; all elements less than
    // base[left] get swapped into the left-hand side of
    // the array.
    int i = left - 1;
    int j = right;
    while (j &gt;= i) {
      while (j &gt; 0 &amp;&amp; t &lt; base[--j]);
      while (i &lt; (right-1) &amp;&amp; base[++i] &lt; t);
      if (i &lt; j) {
    T t = base[i];
    base[i] = base[j];
    base[j] = t;
      }
    }
    // Now focus attention on the partition containing
    // the order statistic we're interested in.
    if (inx &lt;= j - left)
      // Throw away the right-hand partition; we know it
      // doesn't contain the i'th order statistic.
      right = j + 1;
    else {
      // Throw away the left-hand partition; we know it
      // doesn't contain the i'th order statistic.
      // Now we're looking for the inx - j - left + 1'th
      // order statistic of the right-hand partition.
      inx -= j - left + 1;
      left = j + 1;
    }
  }
  // base[left] is the element we want, return it.
  return base[left];
}

<a name="02f5_000d">
<a name="02f5_000e"></pre><B>[LISTING TWO]</B><pre><a name="02f5_000e">

// select.cpp -- Demonstrates the use of the Select function template on
//   arrays of integers and Point2D's. It generates a random of array of
//   integers, then enumerates the order statistics from 0..n-1. This will
//   print out the members of the array in sorted order. This isn't a
//   suggestion for how to use Select (obviously it's more efficient to sort
//   the array if you want to print out the members in sorted order!) but it's
//   good to enumerate them all to verify that algorithm is working properly.
//   The other class the program deals with is a used-defined Point2D class.
//   This is a two-dimensional point defined by two floating-point numbers.
//   The ordering chosen, defined by the operator&lt; for the class, is a
//   standard topological ordering from computational geometry.
//   Copyright (C) 1992 by Nicholas Wilt.  All rights reserved.

#include &lt;fstream.h&gt;
#include &lt;iomanip.h&gt;
#include &lt;stdlib.h&gt;
#include &quot;select.h&quot;

// Just for fun, here's a signum template function. Returns -1 if a &lt; b; 1 if
// b &lt; a; 0 if they're equal. I've ensured only operator&lt; is used for
// comparisons, so operator&gt; isn't defined for a user-defined class.
template&lt;class T&gt; int
Signum(T a, T b)
{
  if (a &lt; b)         return -1;
  else if (b &lt; a)    return 1;
  else           return 0;
}
class Point2D {
  double x, y;
public:
  Point2D() { }
  Point2D(double X, double Y): x(X), y(Y) { }

  // operator&lt; makes our points sorted in topological order: increasing order
  // in x, and increasing order in y if there is a tie in x.
  friend int operator&lt;(const Point2D&amp; x, const Point2D&amp; y) {
    int ret = Signum(x.x, y.x);
    return (ret) ? ret &lt; 0 : Signum(x.y, y.y) &lt; 0;
  }
  friend ostream&amp; operator&lt;&lt; (ostream&amp; a, Point2D&amp; b) {
    a &lt;&lt; &quot;(&quot; &lt;&lt; b.x &lt;&lt; &quot;, &quot; &lt;&lt; b.y &lt;&lt; &quot;)&quot;;
    return a;
  }
};
// Number of elements to allocate in the test arrays
const int NumInts = 10;
const int NumPts = 5;
int
main()
{
  int *x = new int[NumInts];
  int i;
  for (i = 0; i &lt; NumInts; i++) {
    x[i] = rand() % 100;
    cout &lt;&lt; x[i] &lt;&lt; ' ';
  }
  cout &lt;&lt; '\n';
  for (i = 0; i &lt; NumInts; i++) {
    cout &lt;&lt; Select(x, NumInts, i) &lt;&lt; ' ';
  }
  cout &lt;&lt; '\n';
  delete x;
  Point2D *y = new Point2D[NumPts];
  cout &lt;&lt; setprecision(2);
  for (i = 0; i &lt; NumPts; i++) {
    y[i] = Point2D( (double) rand() * 10.0 / RAND_MAX,
            (double) rand() * 10.0 / RAND_MAX);
    cout &lt;&lt; y[i] &lt;&lt; ' ';
  }
  cout &lt;&lt; '\n';
  for (i = 0; i &lt; NumPts; i++) {
    cout &lt;&lt; Select(y, NumPts, i) &lt;&lt; ' ';
  }
  cout &lt;&lt; '\n';
  return 0;
}

<a name="02f5_000f">
<a name="02f5_0010"></pre><B>[LISTING THREE]</B><pre><a name="02f5_0010">

// bintree.h -- Header file for simple binary tree class template.
//   Copyright (C) 1992 by Nicholas Wilt.  All rights reserved.
//  BinaryNode is a helper class template for the BinaryTree class template. It
//  should be needed only rarely by the end user of the BinaryTree class, if
//  ever. BinaryTree&lt;T&gt; is BinaryNode&lt;T&gt;'s friend. The only other classes that
//  can access BinaryNode's data are classes for which it is a base class.
template&lt;class T&gt;
class BinaryNode {
protected:
  T x;
  BinaryNode&lt;T&gt; *left, *right;
public:
  BinaryNode(const T&amp; X): x(X) {
    left = right = 0;
  }
  BinaryNode(const T&amp; X, BinaryNode&lt;T&gt; *l, BinaryNode&lt;T&gt; *r): x(X) {
    left = l;
    right = r;
  }
  friend class BinaryTree&lt;T&gt;;
}
// BinaryTree manipulates binary trees described by pointers to BinaryNode.
template&lt;class T&gt;
class BinaryTree {
protected:
// Pointer to the root node of the binary tree.
  BinaryNode&lt;T&gt; *root;
// Various functions to manipulate collections of binary
// tree nodes.  These are the functions that do the real work.
  static BinaryNode&lt;T&gt; *InsertNode(BinaryNode&lt;T&gt; *r, T x);
  static BinaryNode&lt;T&gt; *DupNode(BinaryNode&lt;T&gt; *r);
  static void PostOrderDeletion(BinaryNode&lt;T&gt; *r);
  static T *QueryNode(BinaryNode&lt;T&gt; *r, const T&amp; x);
  static void PreOrderNode(BinaryNode&lt;T&gt; *r, void (*f)(T *));
  static void InOrderNode(BinaryNode&lt;T&gt; *r, void (*f)(T *));
  static void PostOrderNode(BinaryNode&lt;T&gt; *r, void (*f)(T *));
public:
  // Constructors and assignment operator
  BinaryTree() { root = 0; }
  // Copy constructor duplicates all the nodes in the tree.
  BinaryTree(BinaryTree&lt;T&gt;&amp; x) { root = DupNode(x.root); }
  // Assignment operator deletes nodes already there, then
  // copies the ones in the tree to be copied.
  BinaryTree&lt;T&gt;&amp; operator=(const BinaryTree&lt;T&gt;&amp; x) {
    PostOrderDeletion(root);
    root = DupNode(x.root);
    return *this;
  }
  // Destructor frees all the nodes in the binary tree.
  ~BinaryTree() { PostOrderDeletion(root);  }
  // Inserts a node containing x into the binary tree.
  void Insert(const T&amp; x) { root = InsertNode(root, x); }
  // Returns a pointer to node equal to x, if in tree.
  // If none found Query returns 0.
  T *Query(const T&amp; x) { return QueryNode(root, x); }

  // Various traversal functions perform the traversal
  // in the order given and call f with a pointer to the
  // node contents when visiting.
  void PreOrder(void (*f)(T *)) { PreOrderNode(root, f); }
  void InOrder(void (*f)(T *)) { InOrderNode(root, f); }
  void PostOrder(void (*f)(T *)) { PostOrderNode(root, f); }
};
// The following function declarations give examples of how to
// write function templates for member functions.
// Deletes the tree pointed to by r.
template&lt;class T&gt; void
BinaryTree&lt;T&gt;::PostOrderDeletion(BinaryNode&lt;T&gt; *r)
{
  if (r) {
    PostOrderDeletion(r-&gt;left);
    PostOrderDeletion(r-&gt;right);
    delete r;
  }
}
// Inserts a node with key x into the binary tree with the
// root given, and returns the new root.
template&lt;class T&gt; BinaryNode&lt;T&gt; *
BinaryTree&lt;T&gt;::InsertNode(BinaryNode&lt;T&gt; *r, T x)
{
  if (r) {
    if (x &lt; r-&gt;x)
      r-&gt;left = InsertNode(r-&gt;left, x);
    else
      r-&gt;right = InsertNode(r-&gt;right, x);
  }
  else
    r = new BinaryNode&lt;T&gt;(x);
  return r;
}
// Duplicates the binary tree given and returns pointer to the new root.
template&lt;class T&gt; BinaryNode&lt;T&gt; *
BinaryTree&lt;T&gt;::DupNode(BinaryNode&lt;T&gt; *r)
{
  if (r)
    return new BinaryNode&lt;T&gt;(r-&gt;x,
                 DupNode(r-&gt;left),
                 DupNode(r-&gt;right));
  else
    return 0;
}
// Returns pointer to key given, if found in binary tree. Otherwise returns 0.
template&lt;class T&gt; T *
BinaryTree&lt;T&gt;::QueryNode(BinaryNode&lt;T&gt; *r, const T&amp; x)
{
  if (r) {
    if (x == r-&gt;x)
      return &amp;r-&gt;x;
    if (x &lt; r-&gt;x) return QueryNode(r-&gt;left, x);
    else      return QueryNode(r-&gt;right, x);
  }
  else
    return 0;
}
// Traversal functions. These three functions traverse the tree and call the
// pointer to function on the node contents when it's time to visit the node.
template&lt;class T&gt; void
BinaryTree&lt;T&gt;::PreOrderNode(BinaryNode&lt;T&gt; *r, void (*f)(T *))
{
  if (r) {
    (*f)(&amp;r-&gt;x);
    PreOrderNode(r-&gt;left, f);
    PreOrderNode(r-&gt;right, f);
  }
}
template&lt;class T&gt; void
BinaryTree&lt;T&gt;::InOrderNode(BinaryNode&lt;T&gt; *r, void (*f)(T *))
{
  if (r) {
    InOrderNode(r-&gt;left, f);
    (*f)(&amp;r-&gt;x);
    InOrderNode(r-&gt;right, f);
  }
}
template&lt;class T&gt; void
BinaryTree&lt;T&gt;::PostOrderNode(BinaryNode&lt;T&gt; *r, void (*f)(T *))
{
  if (r) {
    PostOrderNode(r-&gt;left, f);
    PostOrderNode(r-&gt;right, f);
    (*f)(&amp;r-&gt;x);
  }
}



<a name="02f5_0011">
<a name="02f5_0012"></pre><B>[LISTING FOUR]</B><pre><a name="02f5_0012">

// bintree.cpp -- Demonstration program for BinaryTree class template. Inserts
//  10 random numbers into a BinaryTree&lt;int&gt;, prints them out and then prints
//  out the pre-, in- and post-order traversals of the resulting binary tree.
//  Copyright (C) 1992 by Nicholas Wilt.  All rights reserved.

#include &lt;iostream.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;alloc.h&gt;

#include &quot;bintree.h&quot;

// Passed to BinaryTree&lt;int&gt; traversal functions. This gets called with a
// pointer to the node contents (int in this case, since it's a
// BinaryTree&lt;int&gt;) whenever it's time to visit a node in the tree.
void
PrintInt(int *x)
{
  cout &lt;&lt; *x &lt;&lt; ' ';
}
int
main()
{
  int i;
  BinaryTree&lt;int&gt; tree;
  cout &lt;&lt; &quot;Insertion:\t&quot;;
  for (i = 0; i &lt; 10; i++) {
    int insertme = rand() % 100;
    tree.Insert(insertme);
    cout &lt;&lt; insertme &lt;&lt; ' ';
  }
  cout &lt;&lt; '\n';
  cout &lt;&lt; &quot;Pre-order:\t&quot;;  tree.PreOrder(PrintInt);  cout &lt;&lt; '\n';
  cout &lt;&lt; &quot;In-order:\t&quot;;   tree.InOrder(PrintInt);   cout &lt;&lt; '\n';
  cout &lt;&lt; &quot;Post-order:\t&quot;; tree.PostOrder(PrintInt); cout &lt;&lt; '\n';
  return 0;
}


Example 1: Declaring a function template

template&lt;template parameters&gt;
return value               // From here on we define
name(function parameters) {    // the function in terms of
  function body            // the template parameters.
}




Example 2: (a) defining a template-based Select function; (b)
calling the Select function

(a)

template&lt;class T&gt; T
Select(T *base, const int n, int i)
{
    // Implementation
}


(b)

    int *arr, n;
    // ... allocate array and set n
    // Set penultimate to the second-largest element in arr.
    int penultimate = Select(arr, n, n - 2);

(c)

int
Select(int *x, const int n, int i)
{
  // Own function definition of Select&lt;int&gt;
}



Example 3

(a)

template&lt;class T&gt;
class BinaryNode {
  T x;              // Contents of node
  BinaryNode&lt;T&gt; *left, *right;  // Left and right children
//etc.
};


(b)

// Class template for a binary tree node including a
// pointer to the parent.
template&lt;class T&gt;
class BinaryNodeWithParent : public BinaryNode&lt;T&gt; {
  BinaryNodeWithParent&lt;T&gt; *parent;
// etc.
};


(c)

template&lt;class T, int Size&gt;
class Vector {
  T x[Size];       // Vector contains Size T's.
// etc.
};


<P>
<P>
</pre><HR><P>Copyright &copy; 1992, <I>Dr. Dobb's Journal</I></P></BODY></HTML>
