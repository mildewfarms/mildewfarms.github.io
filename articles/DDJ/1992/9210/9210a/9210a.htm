f<HTML>
<META NAME="year" CONTENT="1992">
<HEAD>
<TITLE>OCT92:  SIZING UP APPLICATION FRAMEWORKS AND CLASS LIBRARIES</TITLE></HEAD>
<BODY BGCOLOR="#ffffff">
<h1> SIZING UP APPLICATION FRAMEWORKS AND CLASS LIBRARIES<a name="021e_0003"></h1><P>
<h2><a name="021e_0001"><a name="021e_0000">Tools for reducing coding effort and leveraging prefab functionality</h2><P>
 This article contains the following executables: DDJAFX.TXT  (program spec) BOROWL.ARC  (Borland OWL) OWLYAO.ARC  (OWL version by Paul Yao)   INZAPP.ARC  (Inmark zApp) OBJMNU.ARC (Island Systems object-Menu) CPPVUS.ARC  (Liant  C++/Views) MSMFC.ARC  (Microsoft MFC)  .<P>
<h3>Ray Valdes</h3><P>
<p><i><a name="021e_0002"><a name="021e_0000">Ray is senior technical editor at DDJ.  He can be reached through the DDJ offices, at 76704,51 on CompuServe, or at rayval@well.sf.ca.us.</i></p><hr><P>
As today's applications increase in complexity, so do the tools for building them. Application frameworks, class libraries, and GUI toolkits are three such categories of tools, yet they represent very different technological approaches.  Still, the tool categories, though different, all address the same basic software-development issues: reducing coding effort, speeding time to market, increasing maintainability, adding robustness, and leveraging prefab functionality.<P>
Although comparing these tools is like comparing apples, oranges, and bananas, when you start a development project, you might end up saying, &quot;All these products look like fruit to me.&quot;  In this article we'll provide you with a basis for deciding which of these approaches is right for you, focusing on five object-oriented application frameworks and class libraries. In future articles, we'll cover GUI toolkits not based on object-oriented languages, as well as additional class libraries.<P>
<h3><a name="021e_0004">The View from Square One<a name="021e_0004"></h3><P>
When your project is at square one, there's a simple question: Do you stay with the raw API (basic DOS or Windows services), or do you choose something at a higher level?  If you choose the latter (the &quot;fruit scenario&quot;), then you're at square two: choosing between an application framework, a class library, or a GUI toolkit.<P>
Once you decide on one of these three categories, the next question is, which particular toolkit?  Your decision can be as critical to your success as your choice of algorithm or programming language.  These categories are new enough that no clear standards have emerged, and many plausible contenders exist.  Even properly defining these categories is sticky.  (See the textbox, &quot;What is an Application Framework?&quot;)<P>
The trade-offs are numerous.  With an application framework, you can cruise above the API at a high altitude, but you'll have the steepest learning curve.  Their productivity-increasing power implies great complexity.  Also, because the framework constrains your design decisions, you run the risk of crashing into a brick wall.  If you use a GUI toolkit, you stay much closer to the ground-level API and enjoy a gentle learning gradient as well as free choice in architectural-design approach.  The downside, of course, is that you must do much more of the work yourself.  Smack-dab in the middle between GUI toolkit and application framework is the class-library category.<P>
This is where we found ourselves when we needed a program to display digitized samples for our &quot;Handprinting Recognition Contest.&quot;  We chose the safe but slow ground-level route of writing the program using the native Windows API.  (Actually, we first wrote a DOS version which used the compiler's library of rudimentary graphics primitives.)  Like programmers everywhere, we had a deadline and were leery of diving into a large, complex product we had no experience with.  In retrospect, we wondered which tool was the right one for the job; hence this article.<P>
<h3><a name="021e_0005">The Problem with &quot;Saturday Night&quot; Reviews<a name="021e_0005"></h3><P>
Because much of an application framework's machinery lies under the surface, evaluating application frameworks is a uniquely difficult task.  A few hours spent with the manual or looking over example programs won't cut it for complex and subtle tools.<P>
So how do you make an informed choice?  Not by reading most product reviews we've seen.  The limited hours allotted for a standard product review--typically, an evening with the manual, plus a weekend working with sample code--do not give the reviewer sufficient exposure to realworld use of the framework.  (A recent review of several application frameworks in another programming magazine presents, with a straight face, the source code to &quot;Hello World&quot; using four different products, averaging about a dozen lines of code each.  Although &quot;Hello World&quot; is a convenient way to meet a framework, it's not something on which you want to build a long-term relationship.  It's like buying a house based on the look of the front door.)  As with a programming language, the best way to evaluate a tool is to live with it for a while on a nontrivial development project.<P>
But the live-in approach has problems too.  First, the steep learning curve precludes conducting more than one or two such evaluations.  Although the products are meant to make life simpler, they are complex pieces of software machinery, as <a href="#021e_0006">Table 1</A> and <a href="#021e_0007">2</A> show.  Second, weeks or even months can elapse before you run into product limitations that stymie further development or require contrived workarounds.  When you finally discover that your framework is in fact a straight-jacket, it may be too late.  A third problem is that, even if a framework is well designed and bug free, it may offer multiple ways of accomplishing a given task, and it is not always clear to the novice which is the best approach.  By contrast, the experienced user of a framework knows which methods offer best performance and are easiest to code, but such knowledge is often hard-won.<P>
<h4><a name="021e_0006">Table 1: A simple OOP metric for varius frameworks and class libraries.</h4><P>
<pre>
                         Number of
                          classes
  --------------------------------

  Apple MacApp 3.0           70
  Borland OWL                75
  Digitalk Smalltalk/V      110
  Go PenPoint               250
  Inmark zApp               121
  Island object-Menu         81
  Liant C++/Views           102
  Microsoft MFC              87
  Think C Class Library      61
  Xerox Smalltalk-80        120</pre><P>
<P>
<h4><a name="021e_0007">Table 2: Source-code size for the five packages described in this article.</h4><P>
<pre>
                          Lines of  Source in
                            Code    Kilobytes
  -------------------------------------------

  Borland OWL + ClassLib
            CPP files      11,300     332K
            HPP files      13,678     411K
            Total          24,978     743K

  Inmark zApp
            CPP files      19,299     612K
            HPP files       3,802     100K
            Total          24,101     712K

  Liant C++/Views
            CPP files      27,000     600K
            HPP files      10,139     275K
            Total          37,000     875K

  Microsoft MFC
            CPP files      17,202     403K
            HPP files       8,211     285K
            Total          25,413     688K

  Island object-Menu
            CPP files      35,268    1150K
            H files         6,484     250K
            Total          41,752    1400K</pre><P>
<P>
The tack we settled on was to ask expert programmers at various tool vendors to code up the same small, but non-trivial example program.  We wrote a program specification (see the textbox, &quot;The Spec for the Sample Application&quot;) that exercised many of the most interesting features of these different packages, yet can be implemented by an expert user of a framework in three or fewer working days.  Someone new to the framework, by contrast, could spend a couple of weeks accomplishing the same task.<P>
By examining different implementations of the same functional requirements, you can obtain concrete information to help you decide which available tools are appropriate.  You can then weigh the resulting programs in light of your own particular trade-offs.  The program specification, programmer's notes, complete source code, and executables are available electronically; see &quot;Availability&quot; on page 5.<P>
This isn't a confrontational &quot;shoot-out.&quot;  Arguing about the &quot;best&quot; framework is like arguing about the best cuisine, text editor, or programming language.  Our position is that different tools satisfy different needs and tastes: Some support portability between platforms, others focus on high-level object orientation, others emphasize closeness to the Windows API, and still others swear by performance optimization.  Every programmer has a unique set of opinions about which characteristics are important and which can be sacrificed in real-world trade-offs.  Not only that, but strongly held opinions often change in the course of development, in response to changing market conditions.<P>
We find it more interesting to get a real-world useful application that works, rather than a contrived example that displays 20 different dialog boxes that we'll never use.  With this in mind, our specification offers plenty of leeway to the implementor to solve the problem in a way best suited to the application and tool.  This wide latitude in design choices reflects the implementations described here: We had no dogmatic preferences about UI widgets; we just cared about getting the job done.  Our philosophy is that any program is better than no program, and the world's fanciest empty dialog box is useless compared to a complete rudimentary program that accomplishes the given task.  In the case of our own implementations (the raw Windows API and the DOS versions), the results are indeed homely but usable nevertheless.<P>
Our focus is on the single-user, graphics-oriented application.  The example does not do anything related to text-editing, multiform data entry, database access, or multiuser processing.  Nor does our spec address cut, copy, paste, selection by pointing, raster-image data, and the all-important Undo command.  In homage to real-world randomness, we'll leave these for another time.<P>
<h3><a name="021e_0008">The Participants<a name="021e_0008"></h3><P>
We've not tried to be comprehensive in our selection of vendors.  (There are way too many to cover in one or two issues of the magazine.)  Rather, our focus remains on technology issues rather than specific products.  We've tried to make our list representative rather than comprehensive.  Comparing apples, oranges, and bananas is a stated goal; comparing all such instances is not.<P>
Although the boundaries are not always clear-cut, we look this month at object-oriented application frameworks and class libraries.  Future articles will focus on GUI toolkits and bare-bones class libraries.<P>
This article sizes up the following tools:<P>
<UL>
<li>Borland's ObjectWindows Library (OWL).</li>
<li>Inmark's zApp Application Framework.</li>
<li>Island Systems' object-Menu for C++.</li>
<li>Liant's C++/Views Class Library.</li>
<li>Microsoft's Foundation Classes (MFC).</li>
</UL>
In the coming months, we'll present implementations using packages such as Autumn Hill's Menuet, MetaGraphics' MetaWindow, XVT Software's XVT, and others.<P>
<h3><a name="021e_0009">The Results<a name="021e_0009"></h3><P>
The results are indeed striking in both diversity and homogeneity -- a fascinating case study in user-interface design as well as engineering trade-offs.  <a href="19920220.htm">Figure 1</A> through <a href="19920221.htm">Figure 5</A> show screen displays from the various implementations.  <a href="#021e_000a">Table 3</A> summarizes which features were actually implemented.  <a href="#021e_000b">Tables 4</A>, <a href="#021e_000c">5</A>, and <a href="#021e_000d">6</A> provide some rudimentary metrics (lines of code, executable size, and runtime memory profile, respectively) on the various implementations.  These metrics, like EPA mileage estimates, are for rough comparisons only; relative standings may vary depending upon your application.<P>
<h4><a name="021e_000a">Table 3: Feature sets in the different implementations of the DDJ HWX Browser (missing features do not imply lack of support by product).</h4><P>
<pre>
                         Borland  Inmark     Island      Liant    Microsoft
                           OWL     zApp   object-Menu  C++/Views     MFC
  -------------------------------------------------------------------------

  File-open dialog         x        x          x         x          x
  Data window is
   resizable               --       x          x         --         --
  Data window is
   scrollable              --       --         x         --         --
  Access commands
   via menu                x        x          x         x          x
  Access commands via
   toolbar or button       x        x          x         x          x

  Show menu help
   in status pane          --       x          x         --         --
  Show general help
   in Help window          --       x          --        x          --
  Select instance by
   pointing                x        x          x         x          x
  Select letter
   by pointing             x        x          x         x          x
  Select instance by
   keyboard                x        x          --        --         --
  Select letter
   by keyboard             x        x          --        --         --
  Select instance by
   scrollbars              x        x          x         x          x
  Select letter
   by scrollbars           x        x          x         --         x
  Show all letters
   and instances           --       --         x         --         --
  Multiple kinds of
   views of instance       x        x          x         --         x
  Display custom
   sequence of letters     --       --         x         --         --
  Letters in drop-down
   graphic list            --       --         --        --         x
  Change line
   color of letter         x        x          x         x          x
  Change background
   color of letter         x        x          x         --         x
  Change line
   width of letter         x        x          x         x          x
  Change scaling
   of letter               x        x          --        --         --
  Print letter             x        x          x         x          x
  MDI-style
   child windows           --       --         x         --         --
  Tear-off menus           --       --         x         --         --</pre><P>
<P>
<h4><a name="021e_000b">Table 4: Source-code size (in lines of code) of different implementations of the DDJ HWX Browser.</h4><P>
<pre>
  Line   Borland  Inmark    Island       Liant    Microsoft
  Type     OWL     zApp   object-Menu  C++/Views    MFC
  ---------------------------------------------------------

  CPP      2470    1116      1592        1512       412
  HPP       269      --        --          --        --
  C          --      --        --          --       251
  H         816      29       197         334       175
  RC        106      74        --           5        85
  DEF         6       9        --           8        11
           ____________________________________________
  Total    3398    1497      1789        1859       934</pre><P>
<P>
<h4><a name="021e_000c">Table 5: Size of executable files (in bytes) of different implementations of the DDJ HWX Browser.</h4><P>
<pre>
  Borland OWL          56,848
  Inmark zApp         334,848
  Island object-Menu  470,048
  Liant C++/Views     269,312
  Microsoft MFC        46,536</pre><P>
<P>
<h4><a name="021e_000d">Table 6: Profile of memory consumption after initial program load.</h4><P>
<pre>
                   Segment Type        Number of   Number
                                        Segments  of Bytes
  -----------------------------------------------------------

  Borland OWL      Code                     11      24,928
                   DGroup                    1      22,304
                   Resource                  2       1,536
                   Private data              3       4,896
                    Total Application       17      54,784{*}

  Inmark zApp      Code                     17     208,352
                   DGroup                    1      39,328
                   Resource                  2       1,024
                   Private data              2      69,632
                   Other                    10       2,176
                    Total Application       32     320,512{*}

  Liant C++/Views  Code                     14     197,792
                   DGroup                    1      51,104
                   Resource                  9       5,248
                   Private data              5      69,952
                   Other                     2       1,024
                    Total Application       31     325,120{*}

  Microsoft MFC    Code                      1      29,984
                   DGroup                    1      15,520
                   Resource                  8         992
                   Other                     3       1,280
                    Total Application       12      47,776{*}
</pre><P>
{*} The OWL implementation has an additional runtime requirement of 312,640 bytes for the OWL runtime DLLs.  In addition, the OWL, zApp, C++/Views, and MFC implementations are all Windows-based programs, and therefore require memory consumption of 915,584 bytes of Windows runtime environment.  Because Island Systems' implementation is DOS-based there are no comparable figures; after program load, the memory manager reports 346 Kbytes available for use by the application.<P>
<P>
The following sections discuss, in alphabetical order, each of the five toolkits and their corresponding implementations.  While there's not enough room in this article to fully describe any one of the five products covered here, we'll introduce them briefly and touch upon interesting highlights.  Keep in mind that our goal is not detailed coverage, but rather to direct your attention to areas for further investigation.<P>
The tools in this article all run on the PC platform.  Four of the five packages--Borland's OWL, Microsoft's MFC, Inmark's zApp, Liant's C++/ Views--are Windows-based, while Island's object-Menu is DOS-based.  Others, such as Glockenspiel's CommonView and Autumn Hill's Menuet/CPP, are certainly worth considering.  Fortunately or unfortunately, the area of application frameworks and class libraries is one in which there will be many available choices and little consensus of opinion about which is best, for some time to come.<P>
<h3><a name="021e_000e">Borland's ObjectWindow Library<a name="021e_000e"></h3><P>
OWL from Borland, while not the first framework on the PC market, is certainly the most visible and likely the one with the most number of installations, given the popularity of Borland's C++ language products.<P>
<a href="#021e_0014">More Details.</A><P>
The technology in OWL evolved from an earlier effort by the Whitewater Group (authors of the Actor language/environment for Windows), which has been in use for some years and is generally well regarded.  OWL relies on a nonportable extension to C++ known as dynamic-dispatch virtual tables (DDVT), which simplifies the handling of Windows messages.  While Borland has shown a version running on NT and has announced plans to support OS/2, OWL currently runs only on Windows.  Note that OWL does not support DOS apps; for that, you must use Borland's companion framework, TurboVision.<P>
<a href="#021e_0016">More Details.</A><P>
OWL classes (of which there are 25, plus 405 methods) cover the middle layer of user-interface components, such as dialogs, controls, and text-edit windows, as well as some higher-level components (application classes, MDI frame windows).  Graphics classes (those that correspond to the Windows GDI) can be found in the Whitewater Group's ObjectGraphics library, designed to complement OWL.  OWL does not provide low-level components such as data-structure classes (collections, sets, arrays, lists) and date and time classes.  These low-level classes are part of Borland's Class Library, which runs on both DOS and Windows and supports both OWL and TurboVision.  Borland's Class Library comes with the OWL package, and for this reason we count OWL and the Class Library together in our discussion and in the table summaries.  (Windows expert and noted author Paul Yao has ported our DOS implementation to Windows using OWL, resulting in an implementation of 1050 lines.  This implementation is also available electronically, if you want to see another approach to OWL programming.)<P>
<a href="19920222.htm">Figure 1</A> shows the interface Borland programmers designed.  <a href="#021e_0018">Listing One</A> (page 106) shows some of the code implementing the main application window.  Borland's implementation of our sample application required the most lines of code; see <a href="#021e_000b">Table 4</A>.  Despite the number of lines, the resulting executable is still small; see <a href="#021e_000c">Table 5</A>.  Unlike those implementations with large executables, programs written with OWL do require about 312K of runtime DLLs.  The runtime support, however, is shared by all OWL applications running at the time, much as Windows itself is shared by Windows apps.<P>
<h3><a name="021e_000f">Inmark's zApp<a name="021e_000f"></h3><P>
Of the Windows-hosted products discussed here, zApp and C++/Views are the two which strive to take the high road above the Windows API. zApp and C++/Views each define higher-level abstractions that offer a modern, event-driven GUI application model, which is portable to platforms other than Windows (OS/2, DOS, and Motif).  The advantage of the &quot;high-road&quot; approach is that the design is not burdened or warped by the historical vagaries of the Windows API.  The disadvantage for the programmer is that there is a brandnew set of concepts to learn, with the potential danger that some of these abstractions may be poorly conceived and not stand the test of time.<P>
Unlike C++/Views, which is strongly influenced by the classic Smalltalk MVC paradigm, zApp has its own unique design.  The design, however, results from years of experience in building GUI apps.  (The architects of zApp started out as a consulting firm doing GUI software development in C++.)<P>
There's a saying that good design is invisible.  As Ward Cunningham puts it, &quot;Good class libraries whisper the design in your ear.&quot;  This is the case with zApp, which straight-forwardly provides all the usual classes you'd expect in building event-driven GUI programs: a main application class, a small hierarchy of event-handling classes, classes for graphic display, window-containing classes, and the usual GUI widgets (push button, check box, list box, combo box, and so on).  There are no radical concepts or unpleasant surprises, greatly easing any learning curve associated with a brand-new API.<P>
Inmark's implementation is shown in <a href="19920223.htm">Figure 2</A>.  <a href="#021e_001a">Listing Two</A> (page 108) shows some of the principal member functions in Inmark's implementation of our sample application.<P>
<h3><a name="021e_0010">Island Systems' object-Menu<a name="021e_0010"></h3><P>
object-Menu is the only DOS-based product we cover in this article.  Like the other packages here, it's written in C++ and provides a set of classes that serve as a configurable framework for a GUI application.  Island Systems plans to release a Windows version later this year.<P>
The programmers at Island Systems came up with the most complete implementation of our sample application (see <a href="#021e_000a">Table 3</A>), showcasing many of the features in their product.  The application's visual components (see <a href="19920224.htm">Figure 3</A>) have a sculpted, three-dimensional look reminiscent of Motif.  One slightly disconcerting element for people used to Windows (and the Mac) is that the mouse pointer arrow angles to the right rather than to the left.<P>
Among the features of the sample implementation, multiple scrollable browser windows can be opened to view part or all of the handwriting-data samples.  <a href="#021e_001c">Listing Three</A> (page 110) shows excerpts from Island's implementation.  Each window can be iconized, and has its own menu.  An object-Menu window includes functionality for maximize, minimize, close, resize, drag, and autoplacement of internal items.  object-Menu can use automatic placement directives to define positioning of visual components, similar to the facility in zApp and C++/Views.  Unlike other implementations that use scrollbars to select next and previous characters in the alphabet, the scroll bars here truly scroll the items in a given window's display.<P>
One nice feature in Island Systems' implementation is a window that allows you to type in a string and see the corresponding letters from the handwriting sample data.  Another unique feature is the use of tear-off menus, similar to those on the Mac and in OpenLook; the Edit/Copy menu is the only tear-off menu in this implementation.  Island's implementation apparently does not directly support printing, but accomplishes the task via the use of Graf-Drive Plus (from Fleming Software).  Note also that object-Menu does not contain graphics primitives, but can work with a number of low-level graphics libraries (Borland's BGI, MetaWindow, Genus FX, and Flash Graphics).<P>
The executable size of Island Systems' implementation was larger than the others.  However, considering that the other packages are relying on Windows for extensive support (approximately one megabyte of runtime support, up to five megabytes on disk), the size of the Island Systems implementation does not seem so large.<P>
With regard to performance, all of the Windows-based implementations felt about the same on our test hardware (a 386/33 with 8 Mbytes of RAM).  Island's DOS-based implementation was the only one that seemed sluggish.  One reason for this is that the other implementations were running in Windows Enhanced mode, which uses both extended and virtual memory.  In DOS, of course, any memory above 640K generally lies unused.  Because the code we supplied reads the entire data file (250K worth) into memory, there's not much room left, and the overlay manager must kick into action.  Using a disk cache helped, but the sluggishness remained.  object-Menu can get around this overlay swapping by using Phar Lap's DOS extender and Metaware's 32-bit C++ compiler, but we did not try this version.<P>
Another way to speed up performance might be to use an optimized graphics library, such as MetaWindow, or Flash-Graphics instead of BGI.<P>
<h3><a name="021e_0011">Liant's C++/Views<a name="021e_0011"></h3><P>
Of the five tools covered here, Liant's C++/Views may have the longest heritage.  C++/Views evolved from a C-based package that attempted to bring to C some of the benefits of the Smalltalk language and class libraries.  The package was called &quot;c_talk&quot; (from CNS, later acquired by Liant) and came out in 1988.  It was noteworthy because it included a class-browser utility similar to that found in Smalltalk-80 and Digitalk's Smalltalk/V.  A class browser is a program that allows you to view and edit the source code for classes by using a multipane window display.  In one window pane is a scrolling hierarchical list of classes, on a second pane is a scrolling list of methods (termed &quot;member functions&quot; in C++), and in a third pane is the code for the method itself, which can be edited and changed.<P>
The design of the class browser stems from the object-oriented nature of the Smalltalk environment, in which there is no real concept of source files, header files, or module linking as there is in C and C++.  By contrast, the integrated development environments (IDE) from Borland and Microsoft are designed with the individual source-code file as the main focus of a programmer's attention.  As time passes, these IDEs have evolved to better support object-oriented programming by supplying graphical views of class hierarchy and so on.  In the DOS or UNIX C/C++ environment, you can always drop down out of the IDE to work at the command-line level, editing source files with your favorite text editor and running the compiler directly (or via make).  In the Smalltalk environment, the class browser provides the sole access to the source code.  Liant's version allows you to work in both ways.  Source code is maintained in source files, rather than in a persistent object database of classes and methods.<P>
C++/Views is strongly influenced by Smalltalk's Model/ View/Controller (MVC) paradigm.  This approach to structuring applications consists of three parts: a control component that manages events, a view component that manages the presentation of data to the user, and a model component that encapsulates application-specific data and processes.  (See Adele Goldberg's &quot;Information Models, Views, and Controllers,&quot; DDJ, July 1990.)  According to this protocol, any changes made to the application's data model (say it's a collection of numbers) can be automatically reflected in multiple views (such a bar chart, pie chart, or spreadsheet view) without the model knowing which views are presenting the data.  In my opinion, this design strategy has not been surpassed in the 15 years since it was first conceived.<P>
Despite this heritage, C++/Views is more than a clone of Smalltalk-80; it has its own design.  The VNotifier class is the controller that handles events.  The VView class (a subclass of VWindow) is an abstract class from which view classes are derived.  Graphics output is accomplished through the VPort class.  The application's data model can be constructed using user-defined classes in conjunction with C++/Views data-structure classes (sets, dictionaries, lists, and the like).<P>
Liant's implementation of our sample application is not the most feature-filled, but has, as <a href="19920225.htm">Figure 4</A> shows, a clean, intuitive feel.  The implementation strategy decomposes the main window into a nested set of panes, or views, corresponding to the various visual elements on the application.  <a href="#021e_001e">Listing Four</A> (page 111) shows a sample of the browser code.  One nice feature in Liant's class library is the VRatio class, which is used in conjunction with the VFrame class (a window frame) to flexibly specify the screen size of display objects.  This is similar to the automatic sizing facility in zApp.<P>
<h3><a name="021e_0012">Microsoft's Foundation Class Library<a name="021e_0012"></h3><P>
Most articles on Microsoft's MFC say it's a &quot;thin veneer&quot; or &quot;wrapper&quot; around the Windows native API. This myth is not substantiated by the facts.  Metrics such as line count, number of classes, and number of methods indicate otherwise.<P>
The reason behind the myth is likely that MFC is designed to sit at a close conceptual distance from the Windows API.  Classes in MFC map on a one-to-one basis with entities in the Windows API, such as display context, bitmap, brush, button, MDI child window, and so on.<P>
In terms of lines of code, the source for MFC library is larger than the source for OWL or zApp (although all are in the same general ballpark).  Those lines of MFC source code are not just idly sitting there: Microsoft was able to implement our sample application using the fewest lines of code.  In addition, Microsoft's implementation had the smallest executable and required the least amount of runtime support from DLLs.  <a href="#021e_0020">Listing Five</A>  (page 113) shows sample code that makes up the browser UI.<P>
Microsoft's implementation was not as comprehensive as some of the others (such as Inmark's or Island Systems'), although it did fully satisfy the specs we provided.  Microsoft's implementation (<a href="19920226.htm">Figure 5</A> shows the UI implemented by Microsoft) provided one nice feature that the others did not: a drop-down list box that shows the graphical shapes of the handwriting data.  Using this UI component as a means for selecting letters, rather than having to handcode the tabular display of shapes, may have contributed to the compact implementation.<P>
One possible reason for the small executable size is the use of a dialog box as the main application window, rather than using a &quot;heavy-weight,&quot; user-defined window.  In Windows, dialog boxes are built-in components, in that they don't require user code for registration or full-fledged window procs, thus saving space in the executable and/or the runtime.  Using dialogs means the main window is not scrollable or resizable (not required by the spec).  Note that other implementors also used the dialog-box technique (in Borland's implementation, for example, TMainWindow is a subclass of TDialog), but without equivalent savings in space.<P>
Microsoft has demonstrated MFC on DOS text mode (via Mewel, like Inmark's zApp), on Windows/NT, and apparently has plans to create a portability layer for the Macintosh platform (according to leaks published in the trade press).  Inelegant yes, but portable nonetheless.<P>
The design of MFC requires a form of exception handling and template classes, which are implemented in a nonstandard way due to deficiencies in Microsoft's C7 compiler (unlike Borland's compiler, C7 does not support templates).  But these mechanisms are implemented using macros and other standard constructs, and are therefore theoretically portable to other compilers.  It would be an interesting exercise to port MFC to Borland's compiler.  For those who don't mind sitting within spitting distance of the native Windows API, such a combination may well be the best of both worlds.<P>
<h3><a name="021e_0013">Conclusion<a name="021e_0013"></h3><P>
All the tools discussed here were able to deliver on our program spec.  Each has different strengths and weaknesses; you'll have to decide which one fits your requirements profile.  Try out the sample implementations.  Ask the vendors for additional information and demo diskettes.<P>
Although these products are full-featured and mature, it seems that none of the PC-based products yet contain the rich functionality present in non-PC-based frameworks like MacApp or PenPoint.  This situation will likely change.  In the meantime, you can still get a leg up on program development by using one of these products.<P>
<h3><a name="021e_0014"><a name="021e_0015">What is an Application Framework?<a name="021e_0015"></h3><P>
Although application frameworks are not a new concept, they have only recently arrived as a mainstream development tool on the PC platform.  Object-oriented languages are ideal vehicles in which to embody an application framework, and the advent of C++ to the PC platform has allowed mainstream PC programmers to finally enjoy the benefits of application frameworks.<P>
From the early '80s to the start of this decade, C++ was found mostly on UNIX systems and researcher's workstations, rather than on PCs and in commercial settings.  C++, along with other object-oriented languages, enabled a number of university and research projects to produce the precursors to today's commercial frameworks and class libraries.  The most visible of these early efforts were Mark Linton's InterViews, Keith Gorlen's NIH class library, the Andrew toolkit from CMU, and Erich Gamma's ET++ framework.<P>
These tools had their roots in the Smalltalk-80 system, the granddaddy of frameworks and class libraries.  In Smalltalk-80, there's no concept of an application distinct from the enclosing framework or environment.  The act of programming in Smalltalk consists of navigating the class hierarchy in search of appropriate classes to reuse or subclass.  And, it turns out, there are quite a few.  The typical Smalltalk-80 environment has over 120 classes, 4000 methods, 6000 instantiated objects, and 1.3 Mbytes of source code.<P>
In 1985, Apple Computer's MacApp system rigorously systematized the key ideas of a commecial application framework: a generic app on steroids that provides a large amount of general-purpose functionality within a well-planned, well-tested, cohesive structure.  More specifically, Apple defines an application framework as &quot;an extended collection of classes that cooperate to support a complete application architecture or application model, providing more complete application development support than a simple set of class libraries.&quot;  This support means not just visual components such as list boxes and dialogs, but all the other facilities needed by an application, such as support for undoing commands, printing, and debugging.<P>
For our purposes, we define an application framework as an integrated object-oriented software system that offers all the application-level classes (documents, views, and commands) needed by a generic application.  An application framework is meant to be used in its entirety, and fosters both design reuse and code reuse.  An application framework embodies a particular philosophy for structuring an application, and in return for a large mass of prebuilt functionality, the programmer gives up control over many architectural-design decisions.  The architectural approach used by many application frameworks is an evolutionary descendant of Smalltalk's Model/View/Controller triad.<P>
Class libraries and GUI toolkits are generally smaller and simpler systems than application frameworks.  We define a class library as an object-oriented set of workhorse classes that can be incorporated piecemeal into an application, rather than the other way around.  (Apple's definition of a class library is &quot;a collection of classes designed to work together to make a given set of programming tasks easier, i.e., numerics, graphics memory management, etc.&quot;)  By allowing the programmer to pick and choose, a class library does not enforce any particular architectural approach.  Class libraries are object-oriented implementations, unlike GUI toolkits.  The services offered by class libraries include both user-interface functions (menus, dialog boxes, and graphics primitives), as well as general-utility functions (date and time conversion, data-structure manipulations, and so on).<P>
Finally, GUI toolkits offer services similar to those of a class library, but using a procedure-oriented rather than an object-oriented interface.  GUI toolkits predate object-oriented languages, and some of the most successful products in this category are written in assembler.  Most DOS-based GUI libraries are at the same basic level of abstraction as Windows (or at least the early versions of Windows).  Unlike class libraries, GUI toolkits generally do not offer nongraphical utility routines (queue management routines, for example).<P>
Both class libraries and GUI toolkits often come bundled with design tools that allow you to interactively specify application components, such as dialog boxes and menus.<P>
In practice, the distinctions between one product and another are not as clear-cut as these definitions.  For example, one class-library vendor directly compares their product against a popular application framework.  Another class-library vendor avoids comparisons with application frameworks, yet the sample programs bear an uncanny philosophical resemblance to those of the application framework.<P>
Although the ancestral lines are often blurred, a collective unconscious (community memory) is at work here.  For example, one particular vendor (not part of this issue's roundup) was unaware of the basic concepts of MacApp, Smalltalk, and the MVC triad, even though his product competes directly against frameworks that embody the architectural heritage of these OOP pioneers.<P>
--R.V.<P>
<P>
<h3><a name="021e_0016"><a name="021e_0017">The Spec for the Sample Application<a name="021e_0017"></h3><P>
We've all been there.  Your boss comes to you on a Friday afternoon with a request for a &quot;simple program&quot; that's needed ASAP.  In this particular case, it happens to be a graphics-oriented program to display some digitized vectors.<P>
&quot;It's real easy,&quot; your boss tells you.  &quot;All you have to do is let the user pick from a list of files, then read in the data, which is just a bunch of points, and then display those points using MoveTo and LineTo.  Do you think you can have it ready by Monday morning?&quot;<P>
This, in essence, is what we asked the tool vendors to do.  The application is called HWX Browser, and it allows users to read in different sets of handwriting data from files on disk and display the alphabets in an application window.<P>
The program is not a contrived example meant to exercise items on vendor's feature lists. Rather, the specs come from an entirely different project and predate the current effort.  The program is in many ways representative of graphics-oriented programs, as well as offering its own unique challenges to the implementor.<P>
The DDJ HWX Browser allows the user to view handwriting samples which have been gathered from a number of people.  Each file represents samples collected from a single person, in the form of a series of alphabets.  The file has a particular structure, consisting of a short header, followed by the data for individual letters of the alphabet, each letter being represented by multiple instances or versions.  The data for a single instance is basically a sequence of coordinates as gathered by the digitizer; a set of points for each stroke in a character.<P>
Each vendor received the same specs and had the same amount of time.  The basic areas of functionality are: file operations, character selection, display of the image in a window, printing, and debugging.  For each area, we specified minimum requirements and identified optional features.  Our spec provided plenty of leeway to the implementor to highlight features unique to their product.  The complete spec is available electronically.<P>
We supplied the data files and the specification for the file format; we also implemented DOS-based functions to read the data from the disk into an in-memory data structure, and other functions to display a letter on the screen using MoveTo() and LineTo() callback functions. Implementors were free to change the code to their liking, as long as functionality was preserved.<P>
This was not a programming exam in the sense of trick questions or hidden problems to solve.  We're only interested in looking at the final result, in understanding what it took to get there, and in discussing the technological issues surrounding frameworks, class libraries, and GUI toolkits.  Also, we hoped to provide some good fun.  In retrospect, it looks like we succeeded in that goal: More than one implementor told us that he welcomed the chance to do some uninterrupted programming.<P>
--R.V.<P>
<P>

<PRE>


_SIZING UP APPLICATION FRAMEWORKS AND CLASS LIBRARIES_
by Ray Valdes

<a name="021e_0018">
<a name="021e_0019"></pre><B>[LISTING ONE]</B><pre><a name="021e_0019">

/******* BORLAND  ******/

....standard #includes...

_CLASSDEF( TMainWindow )
_CLASSDEF( TMainApp )

//----------------------------  Constructor of Application's MainWindow.
TMainWindow::TMainWindow( PTWindowsObject AParent,LPSTR AName,PTModule AModule)
            : TDialog(  AParent, AName, AModule )
{
    fDataLoaded= FALSE;
    DrawData.cur_char = 'A';
    DrawData.cur_inst =  0;
    DrawData.rgbBackGroundColor = GetSysColor( COLOR_WINDOW );
    DrawData.rgbLineColor       = GetSysColor( COLOR_WINDOWTEXT );
    DrawData.nLineThickness     = 1;
    DrawData.nScaleFactor       = NORM_SCALE;
    GridWindow     = new TGridWindow( this, ID_GRIDWINDOW , &amp;DrawData );
    ViewWindow     = new TViewWindow( this, ID_VIEWWINDOW , &amp;DrawData );
    Printer        = new TPrinter;
    ScaleScrollBar = new TScrollBar( this, ID_SCROLLSCALE );
    ScaleText      = new TStatic   ( this, ID_SCALETEXT,-1);
}
//--------------------------------------  Destructor of App's MainWindow
TMainWindow::~TMainWindow()
{
    if ( Printer )  delete Printer;
}
//-------------------------------------  return Main Window's Class Name
LPSTR TMainWindow::GetClassName()
{
    return &quot;bordlg_MainDialog&quot;;
}
//---- Use the Borland Custom Dialog Class and indicate the Application's Icon
void TMainWindow::GetWindowClass( WNDCLASS&amp; AWndClass )
{
   TDialog::GetWindowClass( AWndClass );
   AWndClass.lpfnWndProc = BWCCDefDlgProc;
   AWndClass.hIcon = LoadIcon( GetApplication()-&gt;hInstance,&quot;ApplicationIcon&quot; );
}
//----- Function called as a result of WM_INITDIALOG. Center Dialog on Screen.
void TMainWindow::SetupWindow()
{
    RECT  rc;
    TDialog::SetupWindow();
    GetWindowRect( HWindow, &amp;rc );
    OffsetRect( &amp;rc, -rc.left, -rc.top );
    MoveWindow( HWindow, (( GetSystemMetrics( SM_CXSCREEN ) -
                   rc.right ) / 2 + 4 ) &amp; ~7,
                 ( GetSystemMetrics( SM_CYSCREEN ) - rc.bottom ) / 2,
                   rc.right, rc.bottom, 0 );
    ScaleScrollBar-&gt;SetRange( 1, 10 );
    ScaleScrollBar-&gt;SetPosition( 5 );
    EnableScaleScrollBar( FALSE );
    ScaleText-&gt;SetText( &quot;&amp;Scale:  50%&quot; );
    SetFocus( GridWindow-&gt;HWindow );
}
void TMainWindow::EnableScaleScrollBar( BOOL fFlag )
{
    EnableWindow( ScaleScrollBar-&gt;HWindow, fFlag );
    EnableWindow( ScaleText-&gt;HWindow, fFlag );
}
//---- Function responds to FILE|READ Menu Option...
//  Prompts user for FileName and Read Data...
void TMainWindow::CMFileRead ( RTMessage )
{
    strcpy( lpszFileName , &quot;*.dat&quot; );
    GetApplication()-&gt;ExecDialog( new TFileDialog( this ,
                                       SD_FILEOPEN , lpszFileName ));
    SetWait();
    if ( file_LoadHWXData( lpszFileName ))
    {
        fDataLoaded = TRUE;
        GridWindow-&gt;UpdateView();
        ViewWindow-&gt;UpdateView();
    }
    ReleaseWait();
}
//--------  Responds to the Print Request...
void TMainWindow::CMPrint(RTMessage)
{
    PTPrintCharInst Printout = 0;

    if ( Printer )
    {
        Printout = new TPrintCharInst( &quot;Char Instance&quot;, DrawData.cur_char,
                                    DrawData.cur_inst, DrawData.nLineThickness,
                                    DrawData.nScaleFactor );
        if ( Printout )
        {
            Printout-&gt;SetBanding( TRUE );
            Printer-&gt;Print(this, Printout);
            delete Printout;
        }
    }
}
//------- Allows user to Select/Configure Printer
void TMainWindow::CMPrinterSetup(RTMessage)
{
    if ( Printer )   Printer-&gt;Setup(this);
}
//--------- Request to Exit Menu Choice - Terminates App...
void TMainWindow::CMExit( RTMessage )
{
    PostMessage( HWindow, WM_SYSCOMMAND, SC_CLOSE, 0 );
}
//--------------------------------------Bring up AboutBox
void TMainWindow::CMAbout( RTMessage )
{
   GetApplication()-&gt;ExecDialog( new TDialog( this , &quot;ABOUTBOX&quot; ));
}
void TMainWindow::UpdateSubViews( void )
{
    GridWindow-&gt;UpdateView();
    ViewWindow-&gt;UpdateView();
}
//----- Allows user to select Foreground/Line Color.
void TMainWindow::IDForColor( RTMessage )
{
  PTColorDialog ColorDialog = new TColorDialog( this , DrawData.rgbLineColor );
    if ( ColorDialog )
    {
        delete ColorDialog;
        UpdateSubViews();
    }
}
//--------------------------------------user selects Background Color
void TMainWindow::IDBackColor( RTMessage )
{
    PTColorDialog ColorDialog = new TColorDialog( this ,
                                          DrawData.rgbBackGroundColor , TRUE );
    if ( ColorDialog )
    {
        delete ColorDialog;
        UpdateSubViews();
    }
}
//-------------------------------------- Responds to Line Thickness Selection
void TMainWindow::IDLineRad1( RTMessage )
{
    DrawData.nLineThickness = 1;
    UpdateSubViews();
}
//---------------------------------- user can specify scale for GridDisplay
void TMainWindow::IDScrollScale( RTMessage )
{
    int nPos = ScaleScrollBar-&gt;GetPosition();
    if ( nPos != DrawData.nScaleFactor )
    {
        char buff[80];
        wsprintf( buff, &quot;&amp;Scale: %d%%&quot;, nPos*10 );
        DrawData.nScaleFactor = MAX_SCALE + MIN_SCALE - nPos;
        ScaleText-&gt;SetText( buff );
        GridWindow-&gt;UpdateView();
    }
}
//---- Sent by GridWindow to MainWindow which then informs ViewWindow of change
void TMainWindow::SetCurChar( int ch, int inst )
{
    if ( DrawData.cur_char != ch  ||  DrawData.cur_inst != inst )
    {
        DrawData.cur_char = ch;
        DrawData.cur_inst = inst;
        ViewWindow-&gt;UpdateView();   // Allows View to Refresh
    }
}
//----------------------------------  Constructor of Main Application Class

TMainApp::TMainApp( LPSTR AName, HINSTANCE hInstance,
                    HINSTANCE hPrevInstance, LPSTR lpCmd, int nCmdShow )
         : TApplication( AName, hInstance, hPrevInstance, lpCmd, nCmdShow )
{
}
//--------------------------------- Specifying the Application's Main Window
void TMainApp::InitMainWindow()
{
    BWCCGetVersion();          // Force Implicit Loading of BWCC.DLL !
    MainWindow = new TMainWindow( NULL,  &quot;MainDialog&quot; );
}
//----------------------------------  Create Application Class and run !
int PASCAL WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance,
                                                  LPSTR lpCmd, int nCmdShow )
{
   TMainApp  MyApp( &quot;HWX Browser&quot;, hInstance, hPrevInstance, lpCmd, nCmdShow );
   MyApp.Run();
   return( MyApp.Status );
}





<a name="021e_001a">
<a name="021e_001b"></pre><B>[LISTING TWO]</B><pre><a name="021e_001b">

/******** INMARK *******/

#include &quot;zapp.hpp&quot;
#include &quot;ddj.hpp&quot;

typedef int (zEvH::*KeyProc)(zKeyEvt*);
Alphabet *alpha=0;
char *types[]={
    &quot;HWX Files (*.dat)&quot;,&quot;*.dat&quot;,
    &quot;All Files (*.*)&quot;,&quot;*.*&quot;,
    0,0
};
void Browser::removeViews() {
    if (grid!=0) {
        grid-&gt;sizer()-&gt;remove();
        has()-&gt;remove(grid);
        delete grid;
        grid=0;
    }
    if (curVis!=0) {
        curVis-&gt;sizer()-&gt;remove();
        has()-&gt;remove(curVis);
    }
    if (ilet!=0) {
        ilet-&gt;sizer()-&gt;parent()-&gt;remove();
        delete ilet-&gt;sizer()-&gt;parent();
        has()-&gt;remove(ilet);
        delete ilet;
        ilet=0;
    }
}
void Browser::changeLetInInstView() {
    removeViews();
    curInst = 0;
    ilet=new VisLetter(this,center,new zPercentSizer(left,100,50,sizer()),curLet,1);
    has()-&gt;append(ilet);
    grid=new GridCompound(this,sizer());
    select(grid-&gt;addLetter(alpha,curVis-&gt;letter()-&gt;ch()));
    sizer()-&gt;update();
    canvas()-&gt;setDirty();
    updateStats(selVis);
}
void Browser::changeInstanceInAlphaView(int spos) {
    removeViews();
    curInst = spos;
    grid=new GridCompound(this,sizer());
    select(grid-&gt;addAlphabet(alpha,curInst));
    updateStats(selVis);
    sizer()-&gt;update();
    canvas()-&gt;setDirty();
}
void Browser::changeLetterFromScrollPos(int spos) {
    int cnt=0,let=0;
    while (let &lt;HICHAR &amp;&amp; cnt &lt;=spos)
        if (alpha-&gt;instance(let++,curInst)!=0) cnt++;
    changeChar(let-1,curInst);
}
void Browser::changeLetFromInstScr(int spos) {
    int cnt=0,let=0;
    while (let &lt;HICHAR &amp;&amp; cnt &lt;=spos)
        if (alpha-&gt;instance(let++,curInst)!=0) cnt++;
    curLet = alpha-&gt;instance(let-1,curInst);
    curVis-&gt;letter(curLet);
}
InfoPane::InfoPane(zWindow *w, zSizer *siz):VisualPane(w,siz) {
    VisPanel *pan;
    pan=new VisPanel(this,new zPercentSizer(left,100.0,33.3,siz));
    add(pan);
    zSizer *x2;
    x2=new TextFrameSizer(middle,zDimension(0,0),sizer(),pan);

    totalc=new InfoText(this,x2,&quot;Total Chars&quot;,pan);
    fsize=new InfoText(this,x2,&quot;Size&quot;,pan);
    totalseg=new InfoText(this,x2,&quot;Total Segments&quot;,pan);

    pan=new VisPanel(this,new zPercentSizer(left,100.0,33.3,siz));
    add(pan);
    x2=new TextFrameSizer(middle,zDimension(0,0),sizer(),pan);
    wchar=new InfoText(this,x2,&quot;Char&quot;,pan);
    cinst=new InfoText(this,x2,&quot;Instance&quot;,pan);
    scalef=new InfoText(this,x2,&quot;Scaling Factor&quot;,pan);

    pan=new VisPanel(this,new zPercentSizer(left,100,33.3,siz));
    add(pan);
    x2=new TextFrameSizer(middle,zDimension(0,0),sizer(),pan);
    nstrok=new InfoText(this,x2,&quot;Strokes&quot;,pan);
    npoints=new InfoText(this,x2,&quot;Points&quot;,pan);
    csize=new InfoText(this,x2,&quot;Size&quot;,pan);
    backgroundColor(zColor(192,192,192));
}
Browser::Browser(zWindow *w,zSizer *siz, InfoPane *inp):VisualPane(w,siz,zSCROLLV|zSCROLLH) {
    ilet=selVis=0;
    curLet=0;
    curInst=curWidth=0;
    curView=IDM_SVIEW;
    ip=inp;
    curVis=new VisLetter(this,center,sizer(),0,1);
    add(curVis);
    has()-&gt;alwaysHit();
}
BOOL Browser::getPreferredSize(zDimension&amp; d) {
    d.width() = 500;
    d.height() = alpha-&gt;maxSize().height()*grid-&gt;vertKids();
    return 1;
}
void Browser::updateStats(VisLetter *vl) {
    char buf[50];
    wsprintf(buf,&quot; %d - %c   &quot;,(int)vl-&gt;letter()-&gt;ch(),
            (char)vl-&gt;letter()-&gt;ch());
    ip-&gt;wchar-&gt;setVal(buf);
    wsprintf(buf,&quot; %d of %d   &quot;,vl-&gt;letter()-&gt;instance()+1,
            alpha-&gt;letterInstances(vl-&gt;letter()-&gt;ch()));
    ip-&gt;cinst-&gt;setVal(buf);
    wsprintf(buf,&quot; %d x %d    &quot;,
            vl-&gt;maxSize().width(),vl-&gt;maxSize().height());
    ip-&gt;csize-&gt;setVal(buf);
    ip-&gt;nstrok-&gt;setVal(vl-&gt;letter()-&gt;strokes());
    int tot=vl-&gt;letter()-&gt;strokes();
    for (int i=0;i&lt;vl-&gt;letter()-&gt;strokes();i++)
        tot+=vl-&gt;letter()-&gt;path(i).length();
    ip-&gt;npoints-&gt;setVal(tot);
    ip-&gt;scalef-&gt;setVal(vl-&gt;scaling());
}
int Browser::ch(zKeyEvt* e) {
    if (curView == IDM_SVIEW || curView == IDM_IVIEW) {
        Letter *test=0;
        if (alpha!=0) test=alpha-&gt;instance(e-&gt;ch(),0);
        if (test!=0 &amp;&amp; test!=curLet) {
            if (curView == IDM_SVIEW) changeChar(e-&gt;ch(),0);
            else {
                curLet = test;
                curVis-&gt;letter(curLet);
                int mnum = 0;
                for (int cnt = 0; cnt &lt; curVis-&gt;letter()-&gt;ch();cnt++)
                    if (alpha-&gt;instance(cnt,curInst)!=0) mnum++;
                scrollBarVert()-&gt;pos(mnum);
                scrollBarVert()-&gt;oldpos(mnum);
                changeLetInInstView();
            }
        }
    }
    return 0;
}
int Browser::printView(zCommandEvt* e) {
    if (alpha==0) {
        zMessage(app-&gt;rootWindow(),&quot;No data file loaded&quot;,&quot;Error&quot;);
        return 1;
    }
    zPrinterDisplay *pr=new zPrinterDisplay;
    if (!pr-&gt;isValid()) {
        zMessage mess(this,&quot;No Printer drivers installed&quot;,&quot;Unable to print&quot;);
        return 1;
    }
    if (pr-&gt;printerSetup()) {
        zDefPrJobDlg *prDlg=new zDefPrJobDlg(parent(), zResId(PRINT));
        zPrintJob *pj = new zPrintJob(this, pr, prDlg);
        pj-&gt;setJobName(&quot;HWX Print Job&quot;);
        pj-&gt;go();
    }
    return 1;
}
int Browser::print(zPrinterDisplay *pd, zRect *re) {
    zRect r;
    pushDisplay(pd);
    canvas()-&gt;lock();
    // Re-Lay out the display based on the printers display;
    canvas()-&gt;getVisible(r);
    zRect save(*sizer());
    sizer()-&gt;update(&amp;r);
    draw(0);
    // Restore the old display layout.
    canvas()-&gt;unlock();
    sizer()-&gt;update(&amp;save);
    popDisplay();
    return 0;
}
int Browser::changeView(zCommandEvt* e) {
    int which,cnt=0;
    if (e==0) {
        curView=0;
        which=IDM_SVIEW;
    } else which=e-&gt;cmd();

    if (which==curView || alpha==0) return 1;
    selVis=0;
    curInst = 0;
    app-&gt;rootWindow()-&gt;menu()-&gt;checkItem(curView,FALSE);
    app-&gt;rootWindow()-&gt;menu()-&gt;checkItem(which,TRUE);
    if (scroller()) delete scroller();
    removeViews();
    switch (which) {
    case IDM_SVIEW:
        sizer()-&gt;append(curVis-&gt;sizer());
        has()-&gt;append(curVis);
        scroller(new BroScroller(this));
        scrollBarVert()-&gt;limits(zRange(0,alpha-&gt;totalChars()-1));
        for (cnt = 0; alpha-&gt;instance(cnt,curInst)==0;cnt++);
        changeChar(cnt,curInst,0);
        scrollBarVert()-&gt;oldpos(scrollBarVert()-&gt;pos());
        scrollBarHoriz()-&gt;pos(curInst);
        scrollBarHoriz()-&gt;oldpos(curInst);
        ip-&gt;totalc-&gt;setVal(alpha-&gt;totalChars());
        ip-&gt;fsize-&gt;setVal(alpha-&gt;fileSize());
        ip-&gt;totalseg-&gt;setVal(alpha-&gt;totalSegments());
        break;
    case IDM_IVIEW:{
        ilet=new VisLetter(this,center,new zPercentSizer(left,100,50,sizer()),curLet,1);
        has()-&gt;append(ilet);
        grid=new GridCompound(this,sizer());
        select(grid-&gt;addLetter(alpha,curLet-&gt;ch()));
        updateStats(selVis);
        scroller(new InstanceScroller(this));
        scrollBarVert()-&gt;limits(zRange(0,alpha-&gt;totalChars()-1));
        int mnum=0;
        for (cnt = 0; cnt &lt; curVis-&gt;letter()-&gt;ch();cnt++)
            if (alpha-&gt;instance(cnt,curInst)!=0) mnum++;
        scrollBarVert()-&gt;pos(mnum);
        scrollBarVert()-&gt;oldpos(mnum);
        break;}
    case IDM_AVIEW:
        grid=new GridCompound(this,sizer());
        select(grid-&gt;addAlphabet(alpha,curInst));
        updateStats(selVis);
        scroller(new AlphabetScroller(this));
        scroller()-&gt;respondToSize();
    }
    sizer()-&gt;update();
    canvas()-&gt;setDirty();
    curView=which;
    return 1;
}
void Browser::changeChar(int wh,int ins,int updateNow) {
    curInst=ins;
    curLet=alpha-&gt;instance(wh,ins);
    curVis-&gt;letter(curLet);
    updateStats(curVis);
    scrollBarHoriz()-&gt;limits(zRange(0,
        (alpha-&gt;letterInstances(curVis-&gt;letter()-&gt;ch())-1)));
    int mnum=0;
    for (int cnt=0; cnt &lt; curVis-&gt;letter()-&gt;ch();cnt++)
        if (alpha-&gt;instance(cnt,curInst)!=0) mnum++;
    scrollBarVert()-&gt;pos(mnum);
    if (updateNow) {
        canvas()-&gt;setDirty();
        UpdateWindow(*this);
    }
}
void Browser::select(VisLetter *vl) {
    if (selVis!=vl) {
        if (selVis!=0) selVis-&gt;select(FALSE);
        selVis=vl;
        selVis-&gt;select(TRUE);
        if (ilet!=0) {
            ilet-&gt;letter(selVis-&gt;letter());
            updateStats(ilet);
        } else
            updateStats(selVis);
    }
}
int Browser::changeLineWidth(zCommandEvt* e) {
    AskNumForm *ask;
    ask=new AskNumForm(new zFormDlg(((HwxApp *)parent()),
        zResId(&quot;ASKNUMFORM&quot;)),curWidth);
    if (ask-&gt;completed() &amp;&amp; ask-&gt;width()!=curWidth) {
        VisLetter::setPen(new zPen(def[IDM_LINEC-IDM_BACK],Solid,
            curWidth=ask-&gt;width()));
        canvas()-&gt;setDirty();
    }
    delete ask;
    return 1;
}
int Browser::changeColor(zCommandEvt* e) {
    zColorSelForm *tmp=new zColorSelForm(this,def[e-&gt;cmd()-IDM_BACK]);
    if (tmp-&gt;completed()) {
        def[e-&gt;cmd()-IDM_BACK]=tmp-&gt;color();
        switch (e-&gt;cmd()) {
        case IDM_BACK:
            backgroundColor(tmp-&gt;color());
            break;
        case IDM_LINEC:
            VisLetter::setPen(new zPen(tmp-&gt;color(),Solid,curWidth));
            break;
        case IDM_HILIGHTC:
            VisLetter::setHighlightColor(tmp-&gt;color());
            break;
        case IDM_LINEB:
            VisLetter::setBrush(new zBrush(tmp-&gt;color()));
        }
        canvas()-&gt;setDirty();
    }
    return 1;
}
HwxToolBar::HwxToolBar(zWindow *w,zSizer *s,DWORD d):ToolBar(w,s,d) {
    backgroundColor(zColor(LTGRAY));
    frame-&gt;append(new VisBmpButton(this,top,sizer(),IDM_OPEN,LINEI,LINEI+1));
    frame-&gt;append(new VisBmpButton(this,top,sizer(),IDM_PRINT,PRI,PRI+1));
    frame-&gt;append(new VisBmpButton(this,top,sizer(),IDM_SVIEW,SVI,SVI+1));
    frame-&gt;append(new VisBmpButton(this,top,sizer(),IDM_IVIEW,IVI,IVI+1));
    frame-&gt;append(new VisBmpButton(this,top,sizer(),IDM_AVIEW,AVI,AVI+1));
}
HwxApp::HwxApp(zWindow *w,zSizer *siz,DWORD d,const char *title)
: zAppFrame(w,siz,d,title) {
    menu(new zMenu(this,zResId(&quot;TOPMENU&quot;)));
    menu()-&gt;setCommand(this,(CommandProc)&amp;HwxApp::fOpen,IDM_OPEN);
    setIcon(new zIcon(zResId(&quot;DRAWICON&quot;)));
    sline=new StatusLine(this,new zGravSizer(bottom,0));
    sline-&gt;show();
    sline-&gt;setupHilite();
    toolbar=new HwxToolBar(this,new zGravSizer(left,32),WS_BORDER);
    toolbar-&gt;show();
    ip = new InfoPane(this, new zGravSizer(top,zPrPoint(0,590)));
    ip-&gt;show();
    image=new Browser(this,new zGravSizer(middle),ip);
    menu()-&gt;setCommand(image,
            (CommandProc)&amp;Browser::changeColor,IDM_BACK,IDM_LINEB);
    menu()-&gt;setCommand(image,
            (CommandProc)&amp;Browser::changeLineWidth,IDM_LINEW);
    menu()-&gt;setCommand(image,
            (CommandProc)&amp;Browser::changeView,IDM_SVIEW,IDM_AVIEW);
    menu()-&gt;setCommand(image,(CommandProc)&amp;Browser::printView,IDM_PRINT);
    image-&gt;show();
}
HwxApp::~HwxApp() {
    delete sline;
    delete toolbar;
    delete image;
}
int HwxApp::fOpen(zCommandEvt*e) {
    zFileOpenForm *tmp=new zFileOpenForm(this,&quot;Select File&quot;,0,types);
    if (tmp-&gt;completed()) {
        sline-&gt;message()-&gt;printf(&quot;Loading File...&quot;);
        setCursor(zCursor(Hourglass));
        char buf[300];
        wsprintf(buf,&quot;zApp HWX Browser - %s&quot;,tmp-&gt;name());
        caption(buf);
        alpha=new Alphabet();
        alpha-&gt;readFile(tmp-&gt;name());
        if (alpha-&gt;isValid()) {
            image-&gt;addVertScrollBar();
            image-&gt;addHorzScrollBar();
            image-&gt;changeView();
            sline-&gt;message()-&gt;printf(&quot;File Loaded&quot;);
        } else alpha=0;
        setCursor(zCursor(Arrow));
    }
    return 1;
}
int HwxApp::focus(zFocusEvt* e) {
    if (e-&gt;gainFocus() &amp;&amp; image!=0) image-&gt;setFocus();
    return 1;
}
int HwxApp::command(zCommandEvt*e) {
    switch (e-&gt;cmd()) {
    case IDM_EXIT:
        app-&gt;quit();
        break;
    case IDM_HELP:
        WinHelp(*this,&quot;ddj.hlp&quot;,HELP_INDEX,0);
        break;
    case IDM_ABOUT:{
        AboutBox *ab = new AboutBox(this,new zSizer,&quot;About Box&quot;);
        delete ab;}
    }
    return 1;
}
void zApp::main() {
    HwxApp* p=new HwxApp(0,new zSizer,zSTDFRAME,&quot;zApp HWX Browser&quot;);
    p-&gt;show();
    go();
    delete p;
}





<a name="021e_001c">
<a name="021e_001d"></pre><B>[LISTING THREE]</B><pre><a name="021e_001d">

/***** ISLAND SYSTEMS IMPLEMENTATION USING OBJECT-MENU*****/

#include &quot;omExt.h&quot;

#include &quot;h_config.h&quot;
#include &quot;h_stddef.h&quot;
#include &quot;h_list.h&quot;
#include &quot;h_grafic.h&quot;

#include &quot;h_om.h&quot;


#include &quot;omExt.h&quot;

#include &quot;h_config.h&quot;
#include &quot;h_stddef.h&quot;
#include &quot;h_list.h&quot;
#include &quot;h_grafic.h&quot;

#include &quot;h_om.h&quot;

extern void   LoadHWXData(LPSTR name);
extern void   omDisplayInstance(lpRect R, int char_code, int instance_num,
                                int shift, int boxcolor, int drawcolor);

extern void RegisterCallback(
       HDISPLAY display_entity,
       void (*pf_move_to)(HDISPLAY,INT16,INT16),
       void (*pf_line_to)(HDISPLAY,INT16,INT16));

extern void    myMoveTo(HDISPLAY display_entity,INT16 h,INT16 v);
extern void    myLineTo(HDISPLAY display_entity,INT16 h,INT16 v);

//----- globals
const char titlePredicate[] = &quot;Sample File: &quot;;
omDispHelpBlock *dispHelp;

...subordinate routines deleted...

//-----------------MAIN FUNCTION------------------

int omRunIt()
{
  //------ initialize help and icon libraries: hw.dlb, hw.ilb

  omLibMgr = new omLibMgrType(&quot;hw&quot;);
  if (omLibMgr==NULL) {omBeep(); return 1;}             // enough memory?
  if (!omLibMgr) {omBeep(); return omLibMgr-&gt;lastErr;}  // init ok?

  RegisterCallback(0, myMoveTo, myLineTo);              // DDJ callbacks

  dispHelp = new omDispHelpBlock( 100, 4*omFontHeight, 0,0);
  dispHelp-&gt;usedNew     = TRUE;
  dispHelp-&gt;pageBkColor = LIGHTGRAY;
  dispHelp-&gt;theDress    = RIDGE;

  //------- FILE MENU: allocate and assign items to the &quot;File&quot; pulldown menu

  hwFileMenu *fileMenu = new hwFileMenu(4);
  if (fileMenu==NULL) return 1;
  fileMenu-&gt;usedNew = omTRUE;
  *fileMenu + &quot;~Open&quot;  + &quot;~About&quot; + &quot;_&quot;  + &quot;E~xit&quot;;
  fileMenu-&gt;assignId( ID_FILEMENU );
  omIDTABLE.add(ID_FILEMENU, fileMenu);
  fileMenu-&gt;setEventHelp( &quot;file&quot; );      // set help prefix
  fileMenu-&gt;setDisplayHelp( dispHelp );  // attach help

  //------- EDIT MENU: allocate and assign items to the &quot;Edit&quot; pulldown menu

  omVertMenu *editMenu = new omVertMenu( 5 );
  if (editMenu==NULL) return 1;
  editMenu-&gt;usedNew = omTRUE;
  *editMenu + &quot;~Cut&quot;   + DISABLE + &quot;~Copy&quot; + &quot;?copy&quot; //+ DISABLE
            + &quot;~Paste&quot; + DISABLE + &quot;_&quot;     + &quot;Undo&quot; + DISABLE + IS_TEAROFF;
  editMenu-&gt;setEventHelp( &quot;edit&quot; );                   // set help prefix
  editMenu-&gt;setDisplayHelp( dispHelp );               // attach help

  //------- OPTION MENU: allocate and assign items to the &quot;Edit&quot; pulldown menu

  hwOptMenu *optMenu = new hwOptMenu( 2 );
  if (optMenu==NULL) return 1;
  optMenu-&gt;usedNew = omTRUE;
  *optMenu + &quot;~Open new browser !!&quot;
           + &quot;?open&quot; + &quot;~Single letter !!&quot; + &quot;?single&quot;;
  optMenu-&gt;setEventHelp( &quot;optmenu&quot; );                 // set help prefix
  optMenu-&gt;setDisplayHelp( dispHelp );                // attach help

  //------- TOP MENU: allocate and assign items to Horizontal menu bar

  omHorizMenu *topMenu = new omHorizMenu( 6 );
  if (topMenu==NULL) return 1;
  topMenu-&gt;usedNew = omTRUE;
  *topMenu + &quot;~File&quot;   + &quot;?file&quot;   + *fileMenu
           + &quot;~Edit&quot;   + &quot;?edit&quot;   + *editMenu
           + &quot;~Browse&quot; + &quot;?browse&quot; + *optMenu
           + &quot;~Printer| setup&quot; + &quot;?printcfg&quot; + psetup
           + &quot;dela~yed|help&quot; + omIconFcnRadioDiam + changeHelpTimeOut
                                                  + &quot;?delayedhelp&quot; + IS_RADIO
           + &quot;~immediate|help&quot;     + omIconFcnRadioDiam + changeHelpTimeOut
                                                  + &quot;?immedhelp&quot;;

  if ( omPrefs.helpTimeout&gt;0 ) topMenu-&gt;autoRadioToggle(4);  // delayed help
  else                         topMenu-&gt;autoRadioToggle(5);  // immed   help

  topMenu-&gt;setEventHelp( &quot;topmenu&quot; );                     // set help prefix
  topMenu-&gt;setDisplayHelp( dispHelp );                    // attach help
  topMenu-&gt;assignId(ID_TOPMENU);

  //------------ WINDOW: define the window

  omBkWindow *w = new omBkWindow(); w-&gt;bkColor = CYAN;
  if (w==NULL) return 1;
  w-&gt;usedNew = omTRUE;

  w-&gt;setTitle(&quot;Island Systems Handwriting Utility&quot;
               &quot; Rev 1.1|Dr. Dobb's Journal, October 1992&quot;);
  w-&gt;assignId(ID_BKWINDOW);
  w-&gt;setDrawModeBk( omCOLOR );

  *w + *topMenu + omTL + *dispHelp + omBL;
  w-&gt;makeTask();

  //------------- RUN: put the window on the event Queue and run.
  *omMEQ + *w;
  omMEQ-&gt;run();

  return 0;
}





<a name="021e_001e"></pre><B>[LISTING FOUR]</B><pre>

/****** LIANT ******/

#include &quot;about.h&quot;
#include &quot;brush.h&quot;
#include &quot;bttnrbbn.h&quot;
#include &quot;button.h&quot;
#include &quot;charview.h&quot;
#include &quot;file.h&quot;
#include &quot;fileslct.h&quot;
#include &quot;font.h&quot;
#include &quot;hwxappvw.h&quot;
#include &quot;notifier.h&quot;
#include &quot;objarray.h&quot;
#include &quot;pen.h&quot;
#include &quot;pointrry.h&quot;
#include &quot;popupmen.h&quot;
#include &quot;port.h&quot;
#include &quot;printer.h&quot;
#include &quot;printdlg.h&quot;
#include &quot;printab.h&quot;
#include &quot;statusbr.h&quot;

#include &lt;stdio.h&gt;   // for sprintf()

#define BR_HT   40   // height of the Button Bar window
#define STAT_HT   24   // height of the Status Bar window

defineClass(HwxAppView, VAppView)

/* menu definition (could also come from a resource) */
char *file[]   = { &quot;&amp;Open...&quot;,                 &quot;&quot;,
                    &quot;&amp;Print...&quot;,                &quot;&quot;,
                    &quot;&amp;About...&quot;,                &quot;&quot;,
                    &quot;E&amp;xit&quot;,                    0
};
method fmthds[] = { methodOf(HwxAppView, openFile),NIL_METHOD,
                    methodOf(HwxAppView, print),NIL_METHOD,
                    methodOf(HwxAppView, about),NIL_METHOD,
                    methodOf(HwxAppView, closeApp),NIL_METHOD
};
char *display[]    = { &quot;&amp;Style...&quot;,                    &quot;&quot;,
                    &quot;&amp;Instance&quot;,
                    &quot;&amp;Alphabet&quot;,
                    0
};
method dmthds[] = { methodOf(HwxAppView, setDisplayStyle),NIL_METHOD,
                    methodOf(HwxAppView, showByInstance),
                    methodOf(HwxAppView, showByAlphabet),NIL_METHOD
};
/* icon bar definition */
char *bttns[] = { &quot;FILEBOX&quot;,&quot;PRINTER&quot;,&quot;PALETTE&quot;,&quot;ALPHA&quot;,0};
method bMthds[] = {
        methodOf(HwxAppView, btnOpen),
        methodOf(HwxAppView, btnPrint),
        methodOf(HwxAppView, btnStyle),
        methodOf(HwxAppView, btnAlpha),
        NIL_METHOD
};
HwxAppView::HwxAppView()
{
    /* set title and background brush for main window */
    setTitle(&quot;Liant HWX: (no file loaded)&quot;);
    setBackground(new VBrush(BLUE));
    /* create the icon bar */
    bttnRbbn = new ButtonRibbon(VFrame(0, 0, 1.0F, BR_HT),
                                                this, this, bttns, bMthds);
    /* create a status bar */
    int x, y, w, h;
    getArea(&amp;x, &amp;y, &amp;w, &amp;h);
    statBar = new StatusBar(VFrame(0, h - STAT_HT, 1.0F, STAT_HT), this);
    statBar-&gt;putText(&quot;HWX Browser&quot;);
    statBar-&gt;setFont(new VFont(&quot;TMS RMN&quot;, 10));
    /* create the pull down menu (using arrays defined above) */
    VPopupMenu *pm = new VPopupMenu(&quot;&amp;File&quot;);
    addPopup(pm);
    pm-&gt;addItems(file, fmthds, this);
    displayMenu = new VPopupMenu(&quot;&amp;Display&quot;);
    addPopup(displayMenu);
    displayMenu-&gt;addItems(display, dmthds, this);
    displayMenu-&gt;enableAll(FALSE);
    displayMenu-&gt;checkAt(TRUE, 2);
    /* create the single character view sub-window */
    charView = new CharacterView(VFrame(10, 50, 100, 100), this);
    /* create the multi-instance view sub-window */
    multiView = new MultiCellView(VFrame(130, 50, 7 * 60, 200), this);
    multiView-&gt;setDims(6, 13, 30, 30);
    multiView-&gt;uponClick(this, methodOf(HwxAppView, multiSelect));
    /* create the character selection sub-window */
    selectView = new AlphaCellView(VFrame(10, 300,
                                          17 * 32 + 6, 17 * 3 + 6), this);
    selectView-&gt;setDims(3, 32, 17, 17);
    selectView-&gt;uponClick(this, methodOf(HwxAppView, charSelect));
    /* create pen for drawing single character instance */
    charPen = new VPen();
    charData = 0;
    byInstance = TRUE;
    setCharacter(48, 0);
}
HwxAppView::~HwxAppView()
{
    /* destroy status bar font */
    VFont *f = statBar-&gt;getFont();
    if (f) {
        f-&gt;free();
    }
    /* destroy background brush */
    if (getBackground()) {
        delete getBackground();
    }
    /* destroy character pen */
    if (charPen) {
        delete charPen;
    }
    /* destroy associated character data */
    if (charData) {
        delete charData;
    }
}
boolean HwxAppView::free()
{
    delete this;
    return(TRUE);
}
boolean HwxAppView::paint()
{
    VPort    port(this);
    int        x, y, w, h;
    getArea(&amp;x, &amp;y, &amp;w, &amp;h);
    port.open();
    /* draw a separator above the staus bar */
    port.moveTo(0, h - STAT_HT - 1);
    port.lineTo(w, h - STAT_HT - 1);
    port.close();
    return(TRUE);
}
boolean HwxAppView::resized(int w,int h)  // called when window changes size.
{
    // resize the ButtonRibbon
    bttnRbbn-&gt;resize(w, BR_HT);
    // move the StatusBar up to bottom of MDI client
    statBar-&gt;move(0, h - STAT_HT, w, STAT_HT);
    return(TRUE);
}
boolean HwxAppView::openFile(VMenuItem *m) //    Load a new data file
{
    VString *temp;
    VString filter(&quot;*.dat&quot;);
    char     str[100];
    temp = VFileSelect::dialog(this, &quot;Select Data File&quot;, NIL, &amp;filter);
    if (temp) {
        notifier-&gt;beginWait();
        statBar-&gt;putText(&quot;Loading File...&quot;);
        VFile f(temp-&gt;gets());
        if (f.open(ReadOnly)) {
            if (charData != 0) {
                delete charData;
                charData = 0;
            }
            charData = new CharacterData(f);
            f.close();
            /* update window title */
            sprintf(str, &quot;Liant HWX: (%s)&quot;, temp-&gt;gets());
            setTitle(str);
            /* enable display menu */
            displayMenu-&gt;enableAll(TRUE);
        }
        notifier-&gt;endWait();
        setCharacter(48, 0);
    }
    return(TRUE);
}
boolean HwxAppView::closeApp(VMenuItem *m) //    Close the application
{
    return(VAppView::close());
}
boolean HwxAppView::print(VMenuItem *m) //    Print the current character.
{
    VPrinter *printer = 0;
    /* get a printer object via the printer dialog */
    boolean ret = VPrintDialog::print(NIL, &amp;printer, this);
    if (!ret) {
        statBar-&gt;putText(&quot;Printer not ready.&quot;);
    }
    else {
        /* display the print abort dialog */
        VPrintAbort *pab = new VPrintAbort(&quot;HWX&quot;,
                                &quot;Printing character.&quot;, printer, this);
        /* open a port on the printer */
        VPort    port(printer);
        VRectangle rect(CornerDim, 50, 50, 300, 300);
        port.open();
        /* draw the character on the printer */
        charView-&gt;drawCharacter(&amp;port, &amp;rect, 5.0);
        // printer-&gt;newPage();
        port.close();
        pab-&gt;free();
        printer-&gt;free();
    }
    return(TRUE);
}
boolean HwxAppView::about(VMenuItem *m) //    Display the About box
{
    VAbout::dialog(&quot;Liant HWX Browser\n\n) 1992 by Liant Software Corp.&quot;
                    &quot;\nWritten by Joe DeSantis\n&quot;
                    &quot;\nDeveloped with C++/Views 2.0&quot;, this);
    return(TRUE);
}
boolean HwxAppView::setDisplayStyle(VMenuItem *m)
/* Put up a dialog, and set the width and color of the character display. */
{
    int            width;
    rgbColor    color;
    width = charPen-&gt;width();
    color = charPen-&gt;color();
    DisplayDialog::dialog(this, &amp;width, &amp;color);
    charPen-&gt;width(width);
    charPen-&gt;color(color);
    charView-&gt;update();
    return(TRUE);
}
boolean HwxAppView::showByAlphabet(VMenuItem *m)
{
    displayMenu-&gt;checkAt(FALSE, 2);
    displayMenu-&gt;checkAt(TRUE, 3);
    setByInstance(FALSE);
    return(TRUE);
}
boolean HwxAppView::showByInstance(VMenuItem *m)
{
    displayMenu-&gt;checkAt(TRUE, 2);
    displayMenu-&gt;checkAt(FALSE, 3);
    setByInstance(TRUE);
    return(TRUE);
}
void HwxAppView::setCharacter(int cno, int ino)
{   //    Set the current character/instance displayed.
    char str[100];
    currChar = cno;
    currInst = ino;
    int icount = (charData) ? charData-&gt;getInstanceCount(currChar) : 0;
    /* update status bar */
    sprintf(str, &quot;Character %d, Instance %d out of %d&quot;,
                                currChar, currInst, icount);
    statBar-&gt;putText(str);
    /* update views */
    charView-&gt;setCharData(charData, currChar, currInst);
    multiView-&gt;setCharData(charData, currChar, currInst);
    selectView-&gt;setCharData(currChar, currInst);
}
void HwxAppView::charSelect(long row, long col)
{   //    AlphaCellView box clicked in cell row, col
    if (byInstance) {        /* view a new character */
        setCharacter((int) ((row + 1) * 32 + col), currInst);
    }
    else {   /* view a new instance */
        setCharacter(currChar, (int) (row * 16 + col));
    }
}
void HwxAppView::multiSelect(long row, long col)
{    //  MultiCellView box clicked in cell row, col
    if (byInstance) {
        /* view a new instance */
        setCharacter(currChar, (int) (row * 13 + col));
    }
    else {
        /* view a new character */
        setCharacter((int) (row * 13 + col + 48), currInst);
    }
}
void HwxAppView::setByInstance(boolean tf)
/* Specifies whether to display all instances of a single character,
    or an alphabet of a specific instance. */
{
    if (byInstance != tf) {
        byInstance = tf;
        if (tf) {
            selectView-&gt;setDims(3, 32, 17, 17);
        }
        else {
            selectView-&gt;setDims(3, 16, 34, 17);
        }
        multiView-&gt;setByInstance(tf);
        selectView-&gt;setByInstance(tf);
        setCharacter(48, 0);
        selectView-&gt;update();
    }
}
boolean HwxAppView::btnOpen(VButton *b) //    Callback for file icon
{
    openFile(NIL);
    return(TRUE);
}
boolean HwxAppView::btnPrint(VButton *b) //    Callback for print icon
{
    print(NIL);
    return(TRUE);
}
boolean HwxAppView::btnStyle(VButton *b)  //    Callback for style icon
{
    setDisplayStyle(NIL);
    return(TRUE);
}
boolean HwxAppView::btnAlpha(VButton *b)//    Callback for alpha/instance icon
{
    if (byInstance) {
        showByAlphabet(NIL);
    }
    else {
        showByInstance(NIL);
    }
    return(TRUE);
}





<a name="021e_0020">
<a name="021e_0021"></pre><B>[LISTING FIVE]</B><pre><a name="021e_0021">

/****** MICROSOFT ******/

//------ CHwbDlg:  The main user interface to this application is a dialog
class CHwbDlg : public CModalDialog
{
// Constructors
public:
    CHwbDlg();
    ~CHwbDlg();
// Attributes
    // global state of browser
    COLORREF   m_colorCur;
    int        m_nLineWidth;
    // current state (based on selection in .DAT file)
    BOOL       m_bLoaded;          // .DAT file loaded
    char       m_chCur;            // current character
    int        m_nInstanceCount;   // number of instance of this character
    int        m_iInstanceCur;     // current instance of that character
// Operations
    void RenderInstance(CDC* pDC, char ch, int iInstance,
                             CRect rect, int inflate, BOOL bAttrib);
// Implementation
    CImageBox   m_charBox;    // all possible characters
protected:
  // brushes for drawing
    CBrush     m_brBack, m_brGray;
    CFont      m_statusFont;
  // special controls
    CBitmapButton    m_buttons[NUM_BITMAPBUTTONS];
    CImageBox        m_imageBox;          // image selection
    CStatic          m_display;           // display output control
    CScrollBar       m_scrollBar;
    CRect GetOutputRect();
  // message handlers
    virtual BOOL OnInitDialog();
    virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
    afx_msg void OnPaint();
    afx_msg void OnHScroll(UINT nSBCode, UINT nPos, CScrollBar*);
    afx_msg void OnMenuSelect(UINT nItemID, UINT nFlags, HMENU hSysMenu);
  // command handlers
    afx_msg void OnOpen();
    afx_msg void OnCopy();
    afx_msg void OnPrint();
    afx_msg void OnAbout();
    afx_msg void OnPrevChar();
    afx_msg void OnNextChar();
    afx_msg void OnLineColor();
  // control notification handlers
    afx_msg    void OnInstanceSelect();
    afx_msg    void OnCharSelect();
#ifdef _DEBUG
    afx_msg void OnShowStrokes();
#endif
    DECLARE_MESSAGE_MAP()
};
// Message map defines messages handled by our main window
BEGIN_MESSAGE_MAP(CHwbDlg, CModalDialog)
    ON_WM_PAINT()
    ON_WM_HSCROLL()
    ON_WM_MENUSELECT()
    ON_COMMAND(IDM_OPEN, OnOpen)
    ON_COMMAND(IDM_COPY, OnCopy)
    ON_COMMAND(IDM_PRINT, OnPrint)
    ON_COMMAND(IDM_ABOUT, OnAbout)
    ON_COMMAND(IDC_PREV, OnPrevChar)
    ON_COMMAND(IDC_NEXT, OnNextChar)
    ON_COMMAND(IDM_LINE_COLOR, OnLineColor)
#ifdef _DEBUG    // debug commands
    ON_COMMAND(IDM_DEBUG_SHOW_STROKES, OnShowStrokes)
#endif //_DEBUG
    ON_CBN_SELCHANGE(IDC_INSTANCE_BOX, OnInstanceSelect)
    ON_CBN_SELCHANGE(IDC_ALLCHARS_BOX, OnCharSelect)
END_MESSAGE_MAP()
//-----------------------------------------------------------------
CHwbDlg::CHwbDlg()
     : CModalDialog(&quot;MAINDIALOG&quot;),
       m_brBack(::GetSysColor(COLOR_WINDOW)),
       m_brGray(RGB(128, 128, 128))
{
    m_bLoaded = FALSE;
    m_colorCur = RGB(0, 0, 0);    // black to start with
    m_nLineWidth = 1;
}
//-----------------------------------------------------------------
CHwbDlg::~CHwbDlg()
{
    if (m_bLoaded)
        ::UnloadHWXData();        // free old data file
}
//-----------------------------------------------------------------
BOOL CHwbDlg::OnInitDialog()
{
    // initialize bitmap buttons
    for (int i = 0; i &lt; NUM_BITMAPBUTTONS; i++)
        VERIFY(m_buttons[i].AutoLoad(IDC_BITMAPBUTTON_MIN + i, this));
    // wire in the dialog controls
    VERIFY(m_imageBox.SubclassDlgItem(IDC_INSTANCE_BOX, this));
    m_imageBox.m_pParent = this;
    VERIFY(m_charBox.SubclassDlgItem(IDC_ALLCHARS_BOX, this));
    m_charBox.m_pParent = this;
    VERIFY(m_scrollBar.SubclassDlgItem(IDC_SCROLLBAR, this));
    // select a lighter font for the status bar
    LOGFONT logfont;
    GetFont()-&gt;GetObject(sizeof(logfont), &amp;logfont);
    logfont.lfWeight = FW_NORMAL;
    VERIFY(m_statusFont.CreateFontIndirect(&amp;logfont));
    GetDlgItem(IDC_STATUS)-&gt;SetFont(&amp;m_statusFont);
    OnOpen();        // require an open data file
    if (!m_bLoaded)
        EndDialog(IDCANCEL);        // abort
    return TRUE;
}
//-----------------------------------------------------------------
void CHwbDlg::OnOpen()
{
    CFileDialog    dlg(TRUE, &quot;dat&quot;, NULL, OFN_FILEMUSTEXIST | OFN_HIDEREADONLY,
                       &quot;Data Files (*.dat)|*.dat|All Files (*.*)|*.*||&quot;);
        // constructor for standard file open dialog
    if (dlg.DoModal() != IDOK)
        return;                    // stay with old data file
    HCURSOR hCurs = ::SetCursor(::LoadCursor(NULL, IDC_WAIT));
                                // set the wait cursor
    if (m_bLoaded)
        ::UnloadHWXData();        // free old data file
    // open new data file
    ::LoadHWXData(dlg.GetPathName());
    m_bLoaded = TRUE;
    // fill listbox with all valid characters using exported Dr. Dobbs APIs
    m_charBox.ResetContent();
    for (char ch = 0; ch &lt;= 126; ch++)        // simple ASCII range
    {
        if (::GetInstanceCount(ch) == 0)
            continue;        // skip characters with no instances
        int nIndex = m_charBox.AddString(MAKEINTRESOURCE(ch));
        if (ch == 'A')
            m_charBox.SetCurSel(nIndex);        // initial selection
    }
    OnCharSelect();        // update instances
    ::SetCursor(hCurs); // change cursor back to standard
}
//-----------------------------------------------------------------
void CHwbDlg::OnCopy()
{
    // copy current image to clipboard
    if (!OpenClipboard())
        return;
    CMetaFileDC dc;
    if (dc.Create())
    {
        RenderInstance(&amp;dc, m_chCur, m_iInstanceCur, CRect(0,0,0,0), 0, TRUE);
        HGLOBAL hData = ::GlobalAlloc(GPTR, sizeof(METAFILEPICT));
        if (hData != NULL)
        {
            LPMETAFILEPICT lpMFP = (LPMETAFILEPICT)::GlobalLock(hData);
            lpMFP-&gt;mm = MM_ANISOTROPIC;
            lpMFP-&gt;hMF = dc.Close();
            VERIFY(EmptyClipboard());
            ::GlobalUnlock(hData);
            SetClipboardData(CF_METAFILEPICT, hData);
        }
        VERIFY(CloseClipboard());
    }
}
//-----------------------------------------------------------------
void CHwbDlg::OnPrint()
{
    // print the current image
    CPrintDialog dlg(FALSE, PD_NOPAGENUMS | PD_NOSELECTION);
    if (dlg.DoModal() != IDOK)
        return;
    HCURSOR hCurs = ::SetCursor(::LoadCursor(NULL, IDC_WAIT));
                                // set the wait cursor
    CDC dc;
    dc.Attach(dlg.GetPrinterDC());
    CRect rect;
    dc.GetClipBox(rect);
    dc.StartDoc(&quot;HandWriting&quot;);
    dc.StartPage();
    RenderInstance(&amp;dc, m_chCur, m_iInstanceCur, rect, 0, FALSE);
    dc.EndPage();
    dc.EndDoc();
    ::SetCursor(hCurs); // return to standard cursor
}
void CHwbDlg::OnAbout()
{
    CModalDialog dlg(&quot;ABOUTDIALOG&quot;);
    dlg.DoModal();
}
void CHwbDlg::OnNextChar()
{
    m_charBox.SetCurSel(m_charBox.GetCurSel() + 1);
    OnCharSelect();
}
void CHwbDlg::OnPrevChar()
{
    m_charBox.SetCurSel(m_charBox.GetCurSel() - 1);
    OnCharSelect();
}
void CHwbDlg::OnCharSelect()
{
    ASSERT(m_bLoaded);
    if (m_charBox.GetCurSel() == -1)
        m_charBox.SetCurSel(0);        // select first one
    m_chCur = (char)m_charBox.GetItemData(m_charBox.GetCurSel());
    // update the character indicator and box
    SetDlgItemText(IDC_CHARACTER, CString(m_chCur));
    m_nInstanceCount = ::GetInstanceCount(m_chCur);
    m_scrollBar.SetScrollRange(0, m_nInstanceCount-1);
    // update the list of possible instances
    m_imageBox.ResetContent();
    for (int i = 0; i &lt; m_nInstanceCount; i++)
        m_imageBox.InsertString(i, NULL);        // data not used
    m_imageBox.SetCurSel(m_iInstanceCur = 0);    // start at first one
    OnInstanceSelect();        // initial update
}
void CHwbDlg::OnInstanceSelect()
{
    int iSel = m_imageBox.GetCurSel();
    if (iSel != -1)
    {
        ASSERT(iSel &gt;= 0 &amp;&amp; iSel &lt; m_nInstanceCount);
        m_iInstanceCur = iSel;
    }
    // update output
    ASSERT(m_bLoaded);
    ASSERT(m_iInstanceCur &gt;= 0 &amp;&amp; m_iInstanceCur &lt; m_nInstanceCount);
    m_scrollBar.SetScrollPos(m_iInstanceCur);
    InvalidateRect(GetOutputRect(), FALSE);    // will redraw at paint time
}
//-------- Encapsulated drawing code
CRect CHwbDlg::GetOutputRect()
{
    CRect rect;
    GetDlgItem(IDC_OUTPUT)-&gt;GetWindowRect(rect);
    ScreenToClient(rect);
    rect.InflateRect(-2, -2);    // leave border alone
    return rect;
}
//----- functions to map Dr Dobbs API calls to CDC member functions
static void _MoveTo(CDC* pDC, int x, int y)
    { pDC-&gt;MoveTo(x, y); }
static void _LineTo(CDC* pDC, int x, int y)
    { pDC-&gt;LineTo(x, y); }
//------- Render a character in the DC passed in. All drawing takes place here
void CHwbDlg::RenderInstance(CDC* pDC, char ch, int iInstance,
        CRect rect, int inflate, BOOL bAttrib)
{
    // fill in background
    if (inflate)
        pDC-&gt;FillRect(rect, &amp;m_brBack);
    if (iInstance &lt; 0)
        return;    // nothing more to do
    rect.InflateRect(inflate, inflate);
    if (inflate != 0 &amp;&amp; bAttrib)
        pDC-&gt;FrameRect(rect, &amp;m_brGray);
    pDC-&gt;SaveDC();
    // draw scaled to fit with optional attributes
    CPen pen(PS_INSIDEFRAME, m_nLineWidth*2+1, m_colorCur);
    if (bAttrib)
        pDC-&gt;SelectObject(&amp;pen);
    pDC-&gt;SetMapMode(MM_ANISOTROPIC);
    if (!rect.IsRectEmpty())
    {
        pDC-&gt;SetViewportExt(rect.Size());
        pDC-&gt;SetViewportOrg(rect.TopLeft());
    }
    CRect rect2 = ::CalcInstanceBoundingBox(ch, iInstance);
    pDC-&gt;SetWindowExt(rect2.Size());
    pDC-&gt;SetWindowOrg(rect2.TopLeft());
    ::RegisterCallback(pDC, _MoveTo, _LineTo);
    ::DisplayInstance(ch, iInstance);
    pDC-&gt;RestoreDC(-1);
}
void CHwbDlg::OnPaint()
{
    CPaintDC dc(this);
    RenderInstance(&amp;dc, m_chCur, m_iInstanceCur, GetOutputRect(), -10, TRUE);
}
void CHwbDlg::OnHScroll(UINT nSBCode, UINT nPos, CScrollBar*)
{
    static int deltas[] = { -1, 1, -1, 1, 0, 0, -1000, 1000, 0 };
    int iSel = nPos;
    if (nSBCode != SB_THUMBTRACK &amp;&amp; nSBCode != SB_THUMBPOSITION)
        iSel = m_iInstanceCur + deltas[nSBCode];
    if (iSel &lt; 0)
        iSel = 0;
    else if (iSel &gt;= m_nInstanceCount)
        iSel = m_nInstanceCount-1;
    m_imageBox.SetCurSel(iSel);
    OnInstanceSelect();
}
// menu prompt string tracking
void CHwbDlg::OnMenuSelect(UINT nItemID, UINT nFlags, HMENU)
{
    CString strPrompt;
    if (nItemID != 0 &amp;&amp;
      !(nFlags &amp; (MF_SEPARATOR|MF_POPUP|MF_MENUBREAK|MF_MENUBARBREAK)))
        strPrompt.LoadString(nItemID);
    SetDlgItemText(IDC_STATUS, strPrompt);
}
// Line width: handle with one function for efficiency for a range of commands
BOOL CHwbDlg::OnCommand(WPARAM wParam, LPARAM lParam)
{
    int nWidth = LOWORD(wParam) - IDM_LINE_WIDTH_BASE;
    if (nWidth &lt; 0 || nWidth &gt;= MAX_LINE_WIDTH)
        return CModalDialog::OnCommand(wParam, lParam);    // not line width
    m_nLineWidth = nWidth;
    // update the menu
    for (int i = 0; i &lt; MAX_LINE_WIDTH; i++)
        GetMenu()-&gt;CheckMenuItem(IDM_LINE_WIDTH_BASE + i,
            (i == m_nLineWidth) ? MF_CHECKED : MF_UNCHECKED);
    InvalidateRect(GetOutputRect(), FALSE);        // redraw
    return TRUE;
}
void CHwbDlg::OnLineColor()
{
    CColorDialog dlg(m_colorCur);
    if (dlg.DoModal() != IDOK)
        return;
    m_colorCur = dlg.GetColor();
    InvalidateRect(GetOutputRect(), FALSE);
}







<P>
<P>
</pre><HR><P>Copyright &copy; 1992, <I>Dr. Dobb's Journal</I></P></BODY></HTML>
