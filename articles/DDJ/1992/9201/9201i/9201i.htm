<HTML>
<META NAME="year" CONTENT="1992">
<HEAD>
<TITLE>JAN92: PROGRAMMING PARADIGMS</TITLE></HEAD>
<BODY BGCOLOR="#ffffff">
<h1>PROGRAMMING PARADIGMS<a name="0044_0003"></h1><P>
<h2><a name="0044_0001"><a name="0044_0000">Still Running Light</h2><P>
<h3>Michael Swaine</h3><P>
<a name="0044_0002"><a name="0044_0000">Not many people got in on the microcomputer revolution as early as Tom Pittman.  His first computer, on which he ran a business, used an Intel 4004 processor, back before Intel discovered the numeral 8.  Tom picked up this magazine in 1976 when its subtitle was Running Light Without Overbyte and its sole mission was to show programmers how to implement something called &quot;Tiny Basic&quot; on the microcomputers just arriving on the scene.  Tom wrote one of the first implementations of Tiny Basic.  He's also a sought-after embedded system developer. Recent vice-chair of the US delegation to the ISO working group on Modula-2.  Ex-university lecturer in computer science.  President, janitor, and sole proprietor of Itty Bitty Computers.  And the author of a product that he expects us to believe can turn HyperCard into a serious software development environment and HyperTalk into a serious competitor for C as a Macintosh programming language.  He's serious.<P>
<B>DDJ</B>: Tom, for someone with a personal stake in HyperCard's survival, you've been saying some unnerving things on-line about the future of HyperCard--unnerving to HyperCard fanatics, anyway.<P>
<B>TP</B>: Well, yeah.  Apple doesn't know what HyperCard is, so they're trying to make it something that it isn't.<P>
<B>DDJ</B>: You've actually laid out a timetable for HyperCard's demise.<P>
<B>TP</B>: Oh, you saw that?  Well, it's kind of a guess, but I figured last year when Apple was transferring it to Claris, that's going to kill HyperCard.  At that time I wasn't real sure about the timetable, but it's a little more clear in my head now.  The first step is that Claris gets control, and then that Claris gets ownership control, which means that they can cut off the bundled HyperCard.  I expected that to happen already, but I think it's going to happen in the next year.  Claris is going to say, we can't make money selling a product that Apple is giving away free.  So sometime in the next year you can expect Apple to stop bundling the same HyperCard that Claris sells.<P>
<B>DDJ</B>: They tried to do that already.<P>
<B>TP</B>: They tried to do that, but with the hue and cry, they let people know how to get around it.  I don't know exactly where the decision was made.  But Apple--or Claris--didn't expect, I think, the negative reaction.<P>
<B>DDJ</B>: What happens next?<P>
<B>TP</B>: Sales will fall off, and Claris will discover that it's not making money like they thought.  So they'll raise the price.<P>
<B>DDJ</B>: And when will HyperCard finally give up the ghost?<P>
<B>TP</B>: I would guess that two to three years after it stops being free in the box and a year or two after they raise the price, Claris is going to discontinue it because it won't be a profitable product.<P>
<B>DDJ</B>: What does profitable mean?<P>
<B>TP</B>: It won't make money like MacWrite, like a spreadsheet, like MacDraw.  And they'll decide it's not worth the effort to support it.<P>
<B>DDJ</B>: The first steps have already taken place, of course.  Is there an empirical basis for the rest of your conclusions?<P>
<B>TP</B>: Well, you can hear the gears grinding in there, trying to get Apple to stop bundling it. Things like hiding the scripting buttons.  I think that part is almost surely going to get more rigid.  I think they're going to do their very darndest to make sure that the HyperCard that Apple is bundling does not have scripting capability.  At all.  Whether they do a runtime version or stop bundling it entirely.  I don't think they'll stop bundling it entirely.<P>
<B>DDJ</B>: Doesn't your talking about this sort of undermine your own business?<P>
<B>TP</B>: Yeah.  I guess it was a year ago, I went out on a limb and said that I was out to make HyperTalk the programming language of choice for Macintosh programming.  I'm kind of on the way to trying to do that, but it doesn't have the rosy, profitable future that I once thought.<P>
<B>DDJ</B>: I'm a CompileIt fan.  When I saw the first version I thought it was a neat idea, a compiler for HyperTalk.  Very slow, though.<P>
<B>TP</B>: It was awful.<P>
<B>DDJ</B>: But the second version, which I recently reviewed for another magazine, seems to have the depth and power of a real programming language, and yet anyone who knows a little bit about HyperTalk can get into it.  It seems to me you've taken some of the jaggies out of that learning curve.  I'm using it regularly now to develop External Commands (XCMDs).<P>
<B>TP</B>: My goal in life, ever since 1975, was empowerment.  I like Albrecht's phrase, &quot;computer power to the people.&quot;  I guess I'm a bit of a populist, and I've never really lost that.  I would like to give computer power to the common person.  I always saw myself as that even when I was in high school ten years earlier.<P>
<B>DDJ</B>: You weren't a computer kid?<P>
<B>TP</B>: When I was in high school, I was going to build my own computer.  I couldn't afford to buy one, so I was going to build one.  I accumulated 200 dual triodes and dozens of filament transformers.  I had no idea how to build a computer.  But when the microprocessor came out in 1972, I jumped on it.  I had, in 1972, a microprocessor on my desk.  A computer.  By 1975 I had a disk operating system and not exactly a WYSIWYG screen editor, but certainly not TECO, which was the competition.<P>
<B>DDJ</B>: Your own editor?<P>
<B>TP</B>: My own editor.  It was kind of WYSIWYG in the sense that I could see the fragment of the file that it was looking at.  That was the editor that I used when I maintained the Homebrew Computer Club mailing list.<P>
<B>DDJ</B>: On your 1972-vintage microcomputer.<P>
<B>TP</B>: Lee Felsenstein would get up at the Homebrew meetings and ask, how many of you have this type of computer, and how many have this type.  And then just for laughs he would ask, and how many run 4004.  Because that's what I was running.  Most people there were using paper tape on 8080s and I had a disk operating system on a 4004.  But I could do the Homebrew mailing list because I could sort it on my computer.<P>
<B>DDJ</B>: So far as I know, there was no commercial 4004 computer.  Where did you get this thing?<P>
<B>TP</B>: When the microcomputer first came out, I signed up for a free seminar on programming it. That was in April of '72.<P>
<B>DDJ</B>: At Intel?<P>
<B>TP</B>: At Intel, yeah.  I asked, do you have anything that runs resident, and they said no.  I said, if somebody wrote one, would you buy it?  They said, come up and talk with us afterward.  So after the seminar I went up there and they said, how about if we trade you a computer for it?  And I thought, you're in!  So I wrote a resident assembler.  Unfortunately I only had 1K; four 256-byte erasable ROMs.  But I succeeded, and they continued to use it for several years.<P>
<B>DDJ</B>: Tell me how you came to write your Tiny Basic.<P>
<B>TP</B>: Bob Albrecht gave a talk on Basic at a computer conference.  I went up afterward, and he pointed me to the Homebrew Computer Club.  I was at that first meeting in Gordon French's garage.  Then when the &quot;Build Your Own Basic&quot; article came out, I think it was written by Dennis Allison, I really grooved on that.  Because I understood writing interpreters, I had done that, but for the first time I understood how a parser worked.  So I wrote an underlying interpreter in assembly language for that metalanguage.  I think I was the only one who took that approach, but I wasn't the first one [to write a Tiny Basic].<P>
<B>DDJ</B>: Arnold and Whipple, down in Texas, may have that honor.  Of course there was that Harvard dropout down in Albuquerque who was heavily into Basic interpreters then, too.<P>
<B>TP</B>: The Microsoft Basic paper tape.<P>
<B>DDJ</B>: The Homebrew Club sort of unilaterally lowered the price of Microsoft Basic.<P>
<B>TP</B>: Everybody was whining about the $150 price.  So I got up and said, if it was $5, would you buy it?<P>
<B>DDJ</B>: Copies were made.  Bill got mad.<P>
<B>TP</B>: Actually, those copies were legal.  Bill Gates had forgotten to include a copyright notice, and under the copyright law at that time, they were not copyrighted.  Bill Gates never made that mistake again.  But those copies were perfectly legal.  Immoral perhaps, but perfectly legal.  They also made Microsoft a software giant.<P>
<B>DDJ</B>: Tiny Basic didn't do quite as well for you.<P>
<B>TP</B>: I announced that I had it, and got no response.  I was very disappointed.  But BYTE magazine ran a little notice about it in the back of the magazine, and the first weekend after the issue came out, I got 50 calls.  And for several years, while it never supported me, it made a substantial contribution to my income.<P>
<B>DDJ</B>: At $5 a copy?<P>
<B>TP</B>: At $5 a copy.<P>
<B>DDJ</B>: I know you went back to school to study computer science and taught it for a while at Kansas State.  Where was it that the Mac came into the picture?<P>
<B>TP</B>: I needed all these symbols in my dissertation and just about then the Macintosh came out, and the fonts were all software.  I said, that's the tool I need.  My thesis advisor lent me his.  He never got it back.<P>
<B>DDJ</B>: Did it have any effect on your programming?<P>
<B>TP</B>: I had always written programs on paper.  The Mac was the first time I actually wrote software online.<P>
<B>DDJ</B>: What was your first Macintosh program?<P>
<B>TP</B>: AutoBlank.  The screen blanker.  I needed a screen blanker and I don't wear a watch, so I said, why not bounce an analog clock around on the screen?<P>
<B>DDJ</B>: You wrote it in assembly language?<P>
<B>TP</B>: I had a Tiny Pascal compiler that I wrote on a project before the Mac came out, for a 68000 machine.  The project never went anywhere but I had this Tiny Pascal compiler, so I adapted it to produce Macintosh code.  I had the first resident Pascal compiler in the world for the Macintosh.  I never sold it, but that's what I wrote AutoBlank with.<P>
<B>DDJ</B>: Why did you decide to write CompileIt?<P>
<B>TP</B>: Mac World ran this SuperStacks contest.  I thought, HyperCard, that's a programming environment.  Bill Atkinson understood what it was, but Apple was not willing to admit that was what it was.  So I said, let's do a stack that proves that this is a programming language.  Let's do Tiny Basic in HyperTalk.  Then I said, wait a minute, that's silly.  Why don't we compile HyperTalk?  So that's where the idea came from.  I worked furiously on it from the time the contest was announced to the submission deadline, and I submitted it.  It was working imperfectly, but it was working.  And the philistines in San Francisco didn't understand it at all.  I didn't win.  I was really disappointed.  I'd put so much work into it.  So I called up Heizer Software, and I've worked with Brian Molyneaux since summer '88 to turn this thing into a product.<P>
<B>DDJ</B>: I had intended to ask you about programming languages and environments.  It sounds like you use assembly language and HyperCard.  Anything else?<P>
<B>TP</B>: I got started in Pascal when I got the UCSD P-system for a Z80 computer I got in exchange for some work I did for Zilog.  I was always doing assembly language for the target code to make money, because that was what I was good at, writing high-performance assembly language code.<P>
<B>DDJ</B>: What are you using now?<P>
<B>TP</B>: Professionally now I'm using exclusively Modula-2, which is a pretty good language.  The standards people are turning it into Ada.  What they're doing is a travesty of Modula-2.  I've gotten into that.  So when I program for the Mac it's HyperCard, and otherwise it's Modula-2.<P>
<B>DDJ</B>: Never C?<P>
<B>TP</B>: C is interesting.  It's kind of a high-level assembler for the PDP-11.  You can see that in the operators; they're all PDP-11 operators.  When you get to machines that are different from the PDP- 11, it gets harder and harder to write a good C compiler.  But because it's such a low-level language, programmers think they can write better code with it.  So compiler writers are doing hand-stands and jumping through hoops to try and get C code efficiency up. It's interesting, because in every benchmark I've ever seen comparing C and Pascal Pascal wins.<P>
<B>DDJ</B>: Always?<P>
<B>TP</B>: Always.  And every time, C programmers express disbelief or surprise at the fact.  The problem is that C is such a low-level language that programmer are doing these hacks to give them superefficient code, and the compiler has to undo all those optimizations to do what it really should do in that processor.  Whereas in a high-level language like Pascal or Modula-2, the compiler can start with the more abstract representation and get to the efficient code much more quickly.  So I ask, why should I use a brain-dead language like C?<P>
<B>DDJ</B>: C isn't an altogether stationary target; it is evolving.  Is C++ a move in a direction you like?<P>
<B>TP</B>: Yeah.  Well, eventually C programmers are going to recognize the failings of C. C++ has more type management in it, and ANSI C has gone that way.  And these variant implementations of C like Neuron C and the Echelon system are much more strongly typed than vanilla C. Pascal is awful.  It's rigid and you have to think about your problem a lot harder in order to get it to compile right.  And people don't want to do it; they'd rather just hack the brush, produce code, and then find the errors at debugging time.  That ad for Symantec C said, &quot;Make errors faster.&quot;  That's how they think!  I'd rather not make errors.  And if it takes me longer to think about my program so that I can compile it with fewer errors, I will actually get done faster.  It's not a programming preference issue, it's actually a productivity and quality issue.<P>
<B>DDJ</B>: Spoken like someone who spent years writing programs with a pencil.<P>
<B>TP</B>: Having the ability to look at how your code is running is extremely productive and important.  But it should never substitute for thinking about your problem.  I think one of the biggest advantages of object-oriented programming is that it's so much harder to do the same thing that you have to think a lot harder about the whole program before you do it.  Now if object-oriented programming could produce efficient code as well, I'd be for it.<P>
<B>DDJ</B>: Maybe you should tell me what kind of environment you have created in CompileIt.<P>
<B>TP</B>: In 1988 when I designed it, it was a toy.  But I have turned it into the programming environment I would want as a programmer.  I've been writing programs for 25 years, so I know what I like.  I like the Lightspeed Pascal environment, and I've imported as many of its ideas as I can into CompileIt.<P>
<B>DDJ</B>: But no editor?<P>
<B>TP</B>: An integrated editor is nice, but it's hard to get one that meets everybody's preferences.  I use HyperCard for formatting.  You set the script of button X to field 1, put the script of button X into field 1, and that formats it.  Now, debugging is one of the most powerful things to come out of microcomputer software design, and I [wanted] a source - level debugger.  It took me a year to write and debug that, along with compiling the compiler, which I did at the same time.  I was having a terrible time getting it to work, and then I realized, this isn't Pascal or Modula-2 in programming style, it's C. I hope I never have to do anything that large again in that language.  It's great for doing little things.  I saw an interview with one of the designers of C that said C was not intended for large projects.  Absolutely right.<P>
<B>DDJ</B>: But you do use HyperTalk for your Mac programming?<P>
<B>TP</B>: When I have little throwaway programs, I write them in HyperCard.  When something is too slow, I compile it, but HyperCard by itself is a great tool for little personal programming projects, when you need to do a quick hack job, reformat this text file, rearrange the data, or do a quick graph.  I did a project with reports and frequency graphs and data simulations and error analysis, all in HyperCard.  When a client wants a new interface, I mock it up in HyperCard.<P>
<B>DDJ</B>: In CompileIt, you've really opened up the ROM Toolbox.<P>
<B>TP</B>: It was free.  It was easy to put in.  CompileIt may be the first compiler to produce inline code for all of them, not just the Pascal-glued ones.<P>
<B>DDJ</B>: What's next?<P>
<B>TP</B>: About a year ago, as I said, I was working to make HyperTalk a language of choice for programmers, an alternative to C. It's already there in terms of XCMDs; C offers nothing over HyperTalk in doing XCMDs, in my opinion.  I've worked hard to make that true.  But what about other kinds of things?  I got to thinking that it should be possible to do entire stand-alone double-clickable applications in HyperTalk.<P>
<B>DDJ</B>: I'll be interested in seeing that.<P>
<P>
<P>
<HR><P>Copyright &copy; 1992, <I>Dr. Dobb's Journal</I></P></BODY></HTML>
