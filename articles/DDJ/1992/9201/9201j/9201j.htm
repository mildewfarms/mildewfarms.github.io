<HTML>
<META NAME="year" CONTENT="1992">
<HEAD>
<TITLE>JAN92: C PROGRAMMING</TITLE></HEAD>
<BODY BGCOLOR="#ffffff">
<h1>C PROGRAMMING<a name="0046_0003"></h1><P>
<h2><a name="0046_0001"><a name="0046_0000">D-Flat Edit Boxes</h2><P>
 This article contains the following executables: DFLAT9.ARC DF9TXT.ARC<P>
<h3>Al Stevens</h3><P>
<a name="0046_0002"><a name="0046_0000">Last month I described the D-Flat TEXTBOX window class, the base class for derived window classes that display text.  The TEXTBOX class does not concern itself with manipulation or meaning of the text that it stores.  Rather, it just provides the means to store the text, display it, and scroll and page through it.  Other window classes add functionality to the text, and they use the base TEXTBOX class to support the low-level text management processes. This month we discuss one such window class, the EDITBOX class.<P>
<h3><a name="0046_0004">The D-Flat EDITBOX Class<a name="0046_0004"></h3><P>
The EDITBOX class adds text editor functions to the TEXTBOX class.  An EDITBOX supports the user's entry and modification of text by processing keystrokes and commands for text editing. <a href="#0046_000a">Listing One</A>, page 132, is editbox.c, the source file that implements the EDITBOX window class.  The program consists of a window-processing module, named EditBoxProc, and several other functions that process the D-Flat messages that EditBoxProc intercepts.<P>
The CreateWindowMsg function processes the CREATE_WINDOW message, and it is the first function you see in the source file.  Most of the functions are named similarly and have comments that identify the message that they process.  Some functions process subsets of the COMMAND message, and they have names and comments that associate the function with the COMMAND.  I'll address each message and command and trust that you will be able to find the correct function that processes it.<P>
The CREATE_WINDOW message sets initial values into the window's edit box fields.  It establishes the default maximum text length, and sets up an initial empty buffer.  The SETTEXT message allows the application program to specify a buffer of text for the edit box.  The message makes sure that the length of the text does not exceed the maximum length specified for the edit box.  Then it passes the message to the window-processing module for the TEXTBOX class via the BaseWndProc function.<P>
The ADDTEXT message adds a line of text to a TEXTBOX window.  When the window is an EDITBOX class as well, the message first checks to make sure that the length of the buffer with the new text added will not exceed the maximum text length for the window.  Then the program passes the message to the TEXTBOX class's window-processing module.<P>
After that, if the EDITBOX is a single-line editbox--typical of many data entry fields on dialog boxes--the program sets the current column pointer to the end of the text and marks a block that spans all of the text in the edit box.  This block supports the CUA convention where single line edit boxes are marked when the user first tabs to the field.  Then, if the user begins typing, the block is deleted.  If the user moves the cursor first, the text remains, and the block mark is removed.<P>
The GETTEXT message copies the text from the edit box's text buffer into the space pointed to by the message sender's first parameter.<P>
The SETTEXTLENGTH message sets the maximum text length for an edit box.<P>
Applications send the KEYBOARD_CURSOR message to move the cursor to a new position.  So do parts of D-Flat.  The EDITBOX class itself moves the cursor around by using the KEYBOARD_CURSOR message.  Ultimately, the message gets into the code in message.c, which I discussed last July, to physically move the cursor.  First, however, the EDITBOX class needs to update its pointers that specify where the cursor is with respect to the text buffer and the window.  Then the program must make sure that the cursor will be in view--that the window has the focus, is visible, and that the part of it where the cursor is being moved is on screen, within the borders of any ancestor windows, and not overlapped by another window.  If all of these conditions are true, the program sends the SHOW_CURSOR message to the system. Otherwise, it sends the HIDE_CURSOR message.<P>
The SETFOCUS, PAINT, and MOVE messages pass themselves to the base window class and then send the window a KEYBOARD_CURSOR message.  This process assures that the cursor is set properly when an EDITBOX window gets painted or moved and that it gets turned on when the window comes into focus and turned off when the window leaves the focus.<P>
The SIZE message passes itself to the base class and then makes sure that the size operation did not cause the cursor position to go beyond the new window borders.  If it did, the program adjusts the cursor position to stay within the window.<P>
The SCROLL, HORIZSCROLL, SCROLLPAGE, and HORIZSCROLLPAGE messages first pass themselves to the base class to perform the scrolling or paging operation.  The TEXTBOX class maintains variables that indicate the line of text in the buffer at the top of the window and the column of text in the left margin.  These variables change as the text scrolls and pages horizontally and vertically.  Scrolling is moving the text within the window one line or character position at a time.  Paging is moving it one window height or width at a time.  The EDITBOX class has to intercept the scrolling and paging messages to keep the keyboard cursor within the boundaries of the window.  If the window scrolls the keyboard cursor position off the window, these intercepts will reposition the cursor so that it stays in view.<P>
The LEFT_BUTTON message moves the keyboard cursor to where the mouse cursor is positioned. If the user positions the mouse where there is no text--beyond the end of a line or below the last line in the buffer, for example--the program puts the keyboard cursor as close as possible on a valid character position.<P>
If the program is in the process of marking text, the LEFT_BUTTON message has no effect unless the mouse cursor is in the border.  If so, the program scrolls the window in one of four directions depending on which border the mouse is in.  Then it extends the marked block by one line or column to reflect the movement.  This process allows the user to mark text blocks with the mouse where the block size exceeds the size of the window.  By dragging the mouse into a border and holding the button down, the user scrolls the window and continues to mark the block.<P>
The EDITBOX class receives the MOUSE_MOVED message whenever the user moves the mouse and its cursor is inside the edit box window.  If the mouse button is down, the user is marking text in the edit box.  The program establishes the position of the mouse when the user pressed the button as the anchor point of the block.  Now, as long as the user holds the button and moves the mouse, the block will be defined in the range from the anchor point to the present mouse position.  This message sends the MOUSE_TRAVEL message to restrict the mouse's movements to inside the edit box window.  The window will keep the mouse restricted that way until the user releases the button.<P>
The BUTTON_RELEASED message arrives when the user releases the mouse button.  If the user was marking text with the mouse, then the program resets the text-marking mode, releases the restriction on the mouse travel, and adjusts the block markers so that the lower line and column define the beginning of the block.<P>
The KEYBOARD message starts in the KeyboardMsg function and breaks down into several more function calls.  The message itself begins by ignoring all keys if the user is moving or sizing the window or holding down the Alt key.  Those keys and certain Ctrl-key combinations will be processed by window classes higher in the base class hierarchy.<P>
The DoMultiLines function takes care of initiating the marking of a block.  If the edit box has the MULTILINE attribute, and the user is holding down a shift key while typing a key that moves the cursor, and keyboard marking has not begun, the program puts the window into text marking mode and sets the current keyboard cursor position as the anchor point for the marked block.<P>
The DoScrolling function processes all keys that will scroll or page through the text.  Some of these keys can be processed by the base TEXTBOX class.  Others are processed as the result of a combination of the base class and functions unique to the EDITBOX class.  The Home, End, NextWord, PrevWord, Upward, Downward, Forward, and Backward functions move the keyboard cursor and the text pointers.  If there is a marked block, and the window is not in the text marking mode--which means the user released the shift key or the mouse button--this function unmarks the block.<P>
If the KeyboardMsg function sees that the user is marking a block with the keyboard and the DoScrolling function reported that it did indeed process a scrolling or paging key, the KeyboardMsg function calls ExtendBlock to extend the marked block to the new keyboard cursor location.<P>
If DoScrolling reports that the key is not a scrolling or paging key, then KeyboardMsg calls DoKeyStroke to process the typed key.  DoKeyStroke processes the Rubout, Del, Tab, Shift+Tab, and Enter keys.  It moves the cursor to the left one position for the Rubout key and then drops into the code to process the Del key, which calls the DelKey function.  The DelKey function deletes the key from the text buffer at the position pointed to by the keyboard cursor.  DoKeyStroke calls the TabKey function to process the Tab and Shift+Tab keys.  For the tab key, the function sends KEYBOARD messages with either a space character or the FWD character depending on the insert mode of the window.  If the edit box is single-line, the function passes the Tab or Shift+Tab character to the window's parent.  A dialog box parent will use this character to move the focus out of the edit box control.<P>
DoKeyStroke passes all other keys, which will be displayable values, to the KeyTyped function.  First, however, if the user types a key while a block is marked, the program deletes the block to be replaced by the typed key.  The KeyTyped function inserts the key into the text buffer and performs the word wrap operation when the keyboard cursor reaches the window's right margin.<P>
The SHIFT_CHANGED message watches for the user to release the shift key while marking a block of text with the keyboard.  When that happens, the program calls StopMarking to take the window out of text marking mode.<P>
The COMMAND message processes commands to a window from other places.  A window typically receives a COMMAND message when the user executes a menu choice, although nothing prevents any part of a program from sending a COMMAND message.  In fact, the EDITBOX class uses its own ID_DELETETEXT command to delete blocks of text when the user does something outside the menu that would cause text deletion.<P>
The EDITBOX class processes five commands.  All five are on the Edit menu in the example Memopad application.  The menu commands correspond to standard menu items specified in the SAA/CUA specification.  Whether or not your application implements the menu in the same way, most edit boxes will need some or all of these functions.<P>
The ID_DELETETEXT command deletes a marked block of text.  D-Flat maintains a buffer of deleted text so that the user can undo the most recent deletion.  The ID_DELETETEXT command calls SaveDeletedText first to copy the marked block into the undo buffer.  Then it moves the text buffer from one past the end of the block to the beginning of the block and updates the window's text pointers.<P>
The ID_CLEAR command is similar to ID_DELETETEXT command except that it deletes the text, leaving an open space.  The program must delete the lines in the marked block, leaving the newline characters in place.<P>
The ID_UNDO command inserts the contents of the deleted text buffer into the active text buffer at the current cursor position.<P>
The ID_PARAGRAPH command forms a new paragraph from the marked block if one exists.  If not, the command forms the paragraph from the current cursor location to the end of the paragraph. Text in an edit box consists of lines with terminating newline characters.  A paragraph is a group of lines up to the next blank line.<P>
The CLOSE_WINDOW message hides the cursor and frees the deleted text undo buffer if one exists.<P>
<h3><a name="0046_0005">How to Get D-Flat Now<a name="0046_0005"></h3><P>
The D-Flat source code is on CompuServe in Library O of the DDJ Forum and on M&amp;T's OnLine. The source code is in a file named DFLATn.ARC.  The n is a version number.  A second file, DFnTXT.ARC, includes the following:<P>
<UL>
<li>A README.DOC file that describes the changes and how to build the software</li>
<li>A calendar of the issues and the D-Flat subjects that my column addresses</li>
<li>The D-Flat Help system database</li>
<li>Documentation for the D-Flat API</li>
</UL>
D-Flat compiles with Turbo C 2.0, Borland C++ 2.0, Microsoft C 6.0, and Watcom C 8.0.  There are makefiles for the TC, MSC, and Watcom compilers.  There is an example program, the MEMOPAD program, a multiple document notepad.<P>
If you cannot use either online service, send me a formatted diskette -- 360K or 720K -- and an addressed, stamped diskette mailer.  Send it to me in care of DDJ, 501 Galveston Drive, Redwood City, CA 94063.  I'll send you the latest copy of the library.  The software is free, but if you care to, stick a dollar bill in the mailer for the Brevard County Food Bank.  They take care of homeless and hungry families.  We've collected about $500 so far from generous D-Flat &quot;careware&quot; users.  I took a pile of money over there today.  They are very grateful.<P>
If you want to discuss D-Flat with me, use CompuServe.  My CompuServe ID is 71101,1262, and I monitor DDJ Forum daily.<P>
<h3><a name="0046_0006">Cheap Editor<a name="0046_0006"></h3><P>
Fast, good, cheap.  Pick any two.  Remember that?  Well, there's a word processor that delivers all three.  When I find a bargain, I want to share it.  The VDE word processor/text editor is a bargain.  For companies it's cheap.  For individuals it's free.  You can download it from Library 1 of the IBMAPP forum on CompuServe.  Its file name is VDE161.ZIP.  I'm using VDE to write this column.  I have always wanted a word processor that devotes the entire screen to the text, is configurable, programmable, fast, small, and inexpensive.  VDE is all of that.  There is nothing that I want to do with text that VDE will not do.  It is small and fast because it does not include all the dings and toots of those so-called full-featured behemoth word processors.  VDE is not a WYSIWYG desktop publisher.  It does not do graphics. There is no integrated spell checker or thesaurus.  It is not a Windows app.  So, just what is it?  It is simply the best DOS text-based word processor I have ever seen, and I've tried most of them.<P>
You can make VDE emulate the commands of several word processors.  Its default mode uses the old WordStar command keys.  Many PC users, particularly the old-timers, have those commands burned into their brains.  WordStar was a staple in the Wonder years.  Even though I haven't used it for a long time, my fingers leapt immediately to Ctrl-KD, Ctrl-QF, and all the other commands.  You forget that you liked them, that you ever knew them.  They're comfortable, like an old pair of slippers, a 1957 Tri-Pacer, or Uncle Jim's tobacco-reeking leather Morris chair.<P>
You don't pays any money but you still gets your choice--about what goes on the screen, for example.  I prefer a screen with nothing but text, but if you like a ruler line and a status bar that tells you the file name, cursor position, and other stuff, you can have them.  You can have a screen border, too.  When the old peepers get tired, you can switch into a VGA 20-line mode.  For high-density text, you can have 28, 33, 40, 50, or 57 lines and 132 columns--your choice of colors, of course.<P>
VDE will work with the file formats of WordStar, Word Perfect, MS Word, XWrite, as well as with ASCII text.  It supports a two-window split screen, and you can have several files in memory at once.  Everything it does, it does fast.  It has returned validity to my old 4.77-MHz, 640K, one-diskette, T1000 laptop.<P>
VDE's author is Eric Meyer.  He wrote VDE in assembly language and maintains it as freely distributed shareware that individuals may use without charge.  You can register for $30 if you want, and get support and the latest version.  Companies can get site licenses that range from $2.10 down to $1 per user, depending on how many users there are.  You can't beat those prices.  If I was in charge at Microsoft or Word Perfect, I'd pay Meyer a million bucks just to get this thing off the market and out of the competition.  In case they want to take my advice, or in case you want to send for a registered copy, here's the address: Eric Meyer, 3541 Smuggler Way, Boulder, CO 80303 USA, CompuServe: [74415,1305].<P>
What's all that got to do with C?  Well, VDE includes a C-language configuration package that does C indenting, so VDE is more than acceptable as a C programmer's editor.<P>
<h3><a name="0046_0007">The Standard C Library<a name="0046_0007"></h3><P>
The Standard C Library (1992, Prentice Hall) by P. J. Plauger is a new book from a member of the ANSI X3J11 committee.  From its title you might expect it to be a complete reference to the standard C functions as defined by ANSI, but it is not.  I am not sure who the audience is for this book, so I will let you decide if it is for you.<P>
The Standard C Library describes and publishes the source code for the header files, macros, and functions defined in standard C. In effect, it is a C-library implementation published in book form.  You could use the library if you were building a new C compiler, but there are hardly enough new C compiler builders to justify the cost of publishing a book.  Most readers already have a C compiler, and their compiler already has a library, so the book does not bring to the typical programmer some useful and heretofore unavailable piece of code.<P>
So what is this book all about?  For starters, it is a good study in how to implement a library.  Also, the implementation has good examples of some of the more arcane features of C. I found the book useful for understanding some of the functions that the ANSI standard does not clearly describe.  There are notes of historical interest throughout the book which describe the rationale behind some of the decisions made by the committee.  You can often read between the lines and guess where the squeaky wheels prevailed over common sense.  Even though he is an active member of the ANSI committee and contributes significantly to its work, Dr. Plauger pulls no punches when he addresses the deficiencies and failures of the standard.<P>
The book is organized into chapters dedicated to the ANSI header files and the macros and functions defined and declared in each.  The chapter on locale.h addresses the subject of writing C programs that you must port among international operating environments.  This chapter is the best treatment of that subject that I have ever seen and is worth the price of the book by itself.  So is the chapter on stdarg.h, which addresses functions that can accept a variable number of arguments.  If you ever wondered how printf does its thing, this book is for you.  If you ever wondered why scanf is not the answer to all your input prayers, you'll find out why here.  There are places where more explanations would help.  For example, the book does not explain why the implementation includes functions as well as masking macros in the header files for many of the standard C functions.  Some readers will not know that older C programs often failed to include the header files, and because standard C compilers must compile old programs, they must provide the functions even when the macros are more efficient.  The chapter on setjmp and longjmp is the weakest with respect to its code, and the author admits as much, telling you not to use the &quot;grubby&quot; code, which serves only to describe what a more platform-dependent implementation should do.<P>
My most serious criticism of the book is that there are too many typographical errors.  I can only guess that the book is a symptom of the rush-to-publish syndrome from which most managing editors and all publishers suffer.  It is an author's responsibility to resist and counterbalance that pressure, and Plauger failed in that effort.  Most of the errors that I found would be caught during a casual proof reading of the book, never mind the intense copy editing that most works receive.<P>
There are some errors in the code examples that accompany the text, further indication of poor or no proof reading.  I did not test the library code, so I cannot comment on its quality except to say that the brace indenting and placement style is not my favorite.  You can get a diskette for $49.95 by using an order form in the back of the book.  That's twice the usual cost of a companion diskette.  The author claims to have validated the code with a validation suite and compiled and executed it with a number of compilers from UNIX, DOS, and other platforms.  I believe that claim, but because of the surplus of publishing errors in the text, I would not trust the printed code enough to key it in.  Get the diskette if you want the code.  You should know, however, that if you compile a program that uses the code, the silly terms of the copyright require you to insert a string in your executable module that gives credit to Plauger and Prentice-Hall.<P>
<h3><a name="0046_0008">Why I'm Glad My Name Isn't Pee Wee<a name="0046_0008"></h3><P>
If you've been watching the news, you've seen a recent item from my home state, Florida.  Some irate parents video-taped a couple making love in view of the neighborhood and its children. The couple was arrested and have since been on Donahue, in all the papers, and on the 6 o'clock national news.  The gentleman being prosecuted is a fellow Floridian named Al Stevens.  I don't know what he does when he isn't performing for the neighbors, but please be advised that he DOES NOT WRITE THIS COLUMN!<P>
<h3><a name="0046_0009">The Ascent of Language<a name="0046_0009"></h3><P>
On the whole, I like DOS 5.0--now that I've got it properly installed.  I think, however, that once you've gone through the process, the experience can add to the programming languages listed on your resume.  The two new ones are CONFIG.SYS and AUTOEXEC.BAT, which have now become slightly more difficult to master than APL. Here are some of the keywords that DOS 5.0 adds to our lexicon: high, loadhigh, himem, devicehigh, umb, hma, setver, fastopen, wina2O.386, temp, smartdrv, doskey, and emm386.<P>
Judy makes kitchen samplers with poems and quotes reminiscent of her Pennsylvania Dutch origins.  I think I'll ask her to cross-stitch this one:<P>
My patience is all,   The features are yet,   The opener the architecture,   The behinder I get.<P>

<PRE>


_C PROGRAMMING COLUMN_
by Al Stevens

<a name="0046_000a">
<a name="0046_000b"></pre><B>[LISTING ONE]</B><pre><a name="0046_000b">

/* ------------- editbox.c ------------ */
#include &quot;dflat.h&quot;

#define EditBufLen(wnd) (isMultiLine(wnd) ? EDITLEN : ENTRYLEN)
#define SetLinePointer(wnd, ln) (wnd-&gt;CurrLine = ln)
#define isWhite(c)     ((c)==' '||(c)=='\n')
/* ---------- local prototypes ----------- */
static void SaveDeletedText(WINDOW, char *, int);
static void Forward(WINDOW);
static void Backward(WINDOW);
static void End(WINDOW);
static void Home(WINDOW);
static void Downward(WINDOW);
static void Upward(WINDOW);
static void StickEnd(WINDOW);
static void NextWord(WINDOW);
static void PrevWord(WINDOW);
static void ResetEditBox(WINDOW);
static void ModTextPointers(WINDOW, int, int);
/* -------- local variables -------- */
static int KeyBoardMarking, ButtonDown;
static int TextMarking;
static int ButtonX, ButtonY;
static int PrevY = -1;
/* ----------- CREATE_WINDOW Message ---------- */
static int CreateWindowMsg(WINDOW wnd)
{
    int rtn = BaseWndProc(EDITBOX, wnd, CREATE_WINDOW, 0, 0);
    wnd-&gt;MaxTextLength = MAXTEXTLEN+1;
    wnd-&gt;textlen = EditBufLen(wnd);
    wnd-&gt;InsertMode = TRUE;
    ResetEditBox(wnd);
    return rtn;
}
/* ----------- SETTEXT Message ---------- */
static int SetTextMsg(WINDOW wnd, PARAM p1)
{
    int rtn = FALSE;
    if (strlen((char *)p1) &lt;= wnd-&gt;MaxTextLength)    {
        rtn = BaseWndProc(EDITBOX, wnd, SETTEXT, p1, 0);
        wnd-&gt;CurrLine = 0;
    }
    return rtn;
}
/* ----------- ADDTEXT Message ---------- */
static int AddTextMsg(WINDOW wnd, PARAM p1, PARAM p2)
{
    int rtn = FALSE;
    if (strlen((char *)p1)+wnd-&gt;textlen &lt;= wnd-&gt;MaxTextLength) {
        rtn = BaseWndProc(EDITBOX, wnd, ADDTEXT, p1, p2);
        if (rtn != FALSE)    {
            if (!isMultiLine(wnd))    {
                wnd-&gt;CurrLine = 0;
                wnd-&gt;CurrCol = strlen((char *)p1);
                if (wnd-&gt;CurrCol &gt;= ClientWidth(wnd))    {
                    wnd-&gt;wleft = wnd-&gt;CurrCol-ClientWidth(wnd);
                    wnd-&gt;CurrCol -= wnd-&gt;wleft;
                }
                wnd-&gt;BlkEndCol = wnd-&gt;CurrCol;
                SendMessage(wnd, KEYBOARD_CURSOR,
                                     WndCol, wnd-&gt;WndRow);
            }
        }
    }
    return rtn;
}
/* ----------- GETTEXT Message ---------- */
static int GetTextMsg(WINDOW wnd, PARAM p1, PARAM p2)
{
    char *cp1 = (char *)p1;
    char *cp2 = wnd-&gt;text;
    if (cp2 != NULL)    {
        while (p2-- &amp;&amp; *cp2 &amp;&amp; *cp2 != '\n')
            *cp1++ = *cp2++;
        *cp1 = '\0';
        return TRUE;
    }
    return FALSE;
}
/* ----------- SETTEXTLENGTH Message ---------- */
static int SetTextLengthMsg(WINDOW wnd, unsigned int len)
{
    if (++len &lt; MAXTEXTLEN)    {
        wnd-&gt;MaxTextLength = len;
        if (len &lt; wnd-&gt;textlen)    {
            if ((wnd-&gt;text=realloc(wnd-&gt;text, len+2)) != NULL) {
                wnd-&gt;textlen = len;
                *((wnd-&gt;text)+len) = '\0';
                *((wnd-&gt;text)+len+1) = '\0';
                BuildTextPointers(wnd);
            }
        }
        return TRUE;
    }
    return FALSE;
}
/* ----------- KEYBOARD_CURSOR Message ---------- */
static int KeyboardCursorMsg(WINDOW wnd, PARAM p1, PARAM p2)
{
    int rtn;
    wnd-&gt;CurrCol = (int)p1 + wnd-&gt;wleft;
    wnd-&gt;WndRow = (int)p2;
    wnd-&gt;CurrLine = (int)p2 + wnd-&gt;wtop;
    rtn = BaseWndProc(EDITBOX, wnd, KEYBOARD_CURSOR, p1, p2);
    if (wnd == inFocus &amp;&amp; CharInView(wnd, (int)p1, (int)p2))
        SendMessage(NULL, SHOW_CURSOR, wnd-&gt;InsertMode, 0);
    else SendMessage(NULL, HIDE_CURSOR, 0, 0);
    return rtn;
}
/* ----------- SIZE Message ---------- */
int SizeMsg(WINDOW wnd, PARAM p1, PARAM p2)
{
    int rtn = BaseWndProc(EDITBOX, wnd, SIZE, p1, p2);
    if (WndCol &gt; ClientWidth(wnd)-1)
        wnd-&gt;CurrCol = ClientWidth(wnd)-1 + wnd-&gt;wleft;
    if (wnd-&gt;WndRow &gt; ClientHeight(wnd)-1)    {
        wnd-&gt;WndRow = ClientHeight(wnd)-1;
        SetLinePointer(wnd, wnd-&gt;WndRow+wnd-&gt;wtop);
    }
    SendMessage(wnd, KEYBOARD_CURSOR, WndCol, wnd-&gt;WndRow);
    return rtn;
}
/* ----------- SCROLL Message ---------- */
static int ScrollMsg(WINDOW wnd, PARAM p1)
{
    int rtn = FALSE;
    if (isMultiLine(wnd))    {
        rtn = BaseWndProc(EDITBOX,wnd,SCROLL,p1,0);
        if (rtn != FALSE)    {
            if (p1)    {
                /* -------- scrolling up --------- */
                if (wnd-&gt;WndRow == 0)    {
                    wnd-&gt;CurrLine++;
                    StickEnd(wnd);
                }
                else
                    --wnd-&gt;WndRow;
            }
            else    {
                /* -------- scrolling down --------- */
                if (wnd-&gt;WndRow == ClientHeight(wnd)-1)    {
                    if (wnd-&gt;CurrLine &gt; 0)
                        --wnd-&gt;CurrLine;
                    StickEnd(wnd);
                }
                else
                    wnd-&gt;WndRow++;
            }
            SendMessage(wnd,KEYBOARD_CURSOR,WndCol,wnd-&gt;WndRow);
        }
    }
    return rtn;
}
/* ----------- HORIZSCROLL Message ---------- */
static int HorizScrollMsg(WINDOW wnd, PARAM p1)
{
    int rtn = FALSE;
    char *currchar = CurrChar;
    if (!(p1 &amp;&amp;
            wnd-&gt;CurrCol == wnd-&gt;wleft &amp;&amp; *currchar == '\n'))  {
        rtn = BaseWndProc(EDITBOX, wnd, HORIZSCROLL, p1, 0);
        if (rtn != FALSE)    {
            if (wnd-&gt;CurrCol &lt; wnd-&gt;wleft)
                wnd-&gt;CurrCol++;
            else if (WndCol == ClientWidth(wnd))
                --wnd-&gt;CurrCol;
            SendMessage(wnd,KEYBOARD_CURSOR,WndCol,wnd-&gt;WndRow);
        }
    }
    return rtn;
}
/* ----------- SCROLLPAGE Message ---------- */
static int ScrollPageMsg(WINDOW wnd, PARAM p1)
{
    int rtn = FALSE;
    if (isMultiLine(wnd))    {
        rtn = BaseWndProc(EDITBOX, wnd, SCROLLPAGE, p1, 0);
        SetLinePointer(wnd, wnd-&gt;wtop+wnd-&gt;WndRow);
        StickEnd(wnd);
        SendMessage(wnd, KEYBOARD_CURSOR,WndCol, wnd-&gt;WndRow);
    }
    return rtn;
}
/* ----------- HORIZSCROLLPAGE Message ---------- */
static int HorizPageMsg(WINDOW wnd, PARAM p1)
{
    int rtn = BaseWndProc(EDITBOX, wnd, HORIZPAGE, p1, 0);
    if ((int) p1 == FALSE)    {
        if (wnd-&gt;CurrCol &gt; wnd-&gt;wleft+ClientWidth(wnd)-1)
            wnd-&gt;CurrCol = wnd-&gt;wleft+ClientWidth(wnd)-1;
    }
    else if (wnd-&gt;CurrCol &lt; wnd-&gt;wleft)
        wnd-&gt;CurrCol = wnd-&gt;wleft;
    SendMessage(wnd, KEYBOARD_CURSOR, WndCol, wnd-&gt;WndRow);
    return rtn;
}
/* ----- Extend the marked block to the new x,y position ---- */
static void ExtendBlock(WINDOW wnd, int x, int y)
{
    int bbl, bel;
    int ptop = min(wnd-&gt;BlkBegLine, wnd-&gt;BlkEndLine);
    int pbot = max(wnd-&gt;BlkBegLine, wnd-&gt;BlkEndLine);
    char *lp = TextLine(wnd, wnd-&gt;wtop+y);
    int len = (int) (strchr(lp, '\n') - lp);
    x = min(x, len-wnd-&gt;wleft);
    wnd-&gt;BlkEndCol = x+wnd-&gt;wleft;
    wnd-&gt;BlkEndLine = y+wnd-&gt;wtop;
    bbl = min(wnd-&gt;BlkBegLine, wnd-&gt;BlkEndLine);
    bel = max(wnd-&gt;BlkBegLine, wnd-&gt;BlkEndLine);
    while (ptop &lt; bbl)    {
        WriteTextLine(wnd, NULL, ptop, FALSE);
        ptop++;
    }
    for (y = bbl; y &lt;= bel; y++)
        WriteTextLine(wnd, NULL, y, FALSE);
    while (pbot &gt; bel)    {
        WriteTextLine(wnd, NULL, pbot, FALSE);
        --pbot;
    }
}
/* ----------- LEFT_BUTTON Message ---------- */
static int LeftButtonMsg(WINDOW wnd, PARAM p1, PARAM p2)
{
    int MouseX = (int) p1 - GetClientLeft(wnd);
    int MouseY = (int) p2 - GetClientTop(wnd);
    RECT rc = ClientRect(wnd);
    char *lp;
    int len;
    if (KeyBoardMarking)
        return TRUE;
    if (WindowMoving || WindowSizing)
        return FALSE;
    if (isMultiLine(wnd))    {
        if (TextMarking)    {
            if (!InsideRect(p1, p2, rc))    {
                if ((int)p1 == GetLeft(wnd))
                    if (SendMessage(wnd, HORIZSCROLL, 0, 0))
                        ExtendBlock(wnd, MouseX-1, MouseY);
                if ((int)p1 == GetRight(wnd))
                    if (SendMessage(wnd, HORIZSCROLL, TRUE, 0))
                        ExtendBlock(wnd, MouseX+1, MouseY);
                if ((int)p2 == GetTop(wnd))
                    if (SendMessage(wnd, SCROLL, FALSE, 0))
                        ExtendBlock(wnd, MouseX, MouseY+1);
                if ((int)p2 == GetBottom(wnd))
                    if (SendMessage(wnd, SCROLL, TRUE, 0))
                        ExtendBlock(wnd, MouseX, MouseY-1);
                SendMessage(wnd, PAINT, 0, 0);
            }
            return TRUE;
        }
        if (!InsideRect(p1, p2, rc))
            return FALSE;
        if (TextBlockMarked(wnd))    {
            ClearTextBlock(wnd);
            SendMessage(wnd, PAINT, 0, 0);
        }
        if (wnd-&gt;wlines)    {
            if (MouseY &gt; wnd-&gt;wlines-1)
                return TRUE;
            lp = TextLine(wnd, MouseY+wnd-&gt;wtop);
            len = (int) (strchr(lp, '\n') - lp);
            MouseX = min(MouseX, len);
            if (MouseX &lt; wnd-&gt;wleft)    {
                MouseX = 0;
                SendMessage(wnd, KEYBOARD, HOME, 0);
            }
            ButtonDown = TRUE;
            ButtonX = MouseX;
            ButtonY = MouseY;
        }
        else
            MouseX = MouseY = 0;
        wnd-&gt;WndRow = MouseY;
        SetLinePointer(wnd, MouseY+wnd-&gt;wtop);
    }
    if (isMultiLine(wnd) ||
        (!TextBlockMarked(wnd)
            &amp;&amp; MouseX+wnd-&gt;wleft &lt; strlen(wnd-&gt;text)))
        wnd-&gt;CurrCol = MouseX+wnd-&gt;wleft;
    SendMessage(wnd, KEYBOARD_CURSOR, WndCol, wnd-&gt;WndRow);
    return TRUE;
}
/* ----------- MOUSE_MOVED Message ---------- */
static int MouseMovedMsg(WINDOW wnd, PARAM p1, PARAM p2)
{
    int MouseX = (int) p1 - GetClientLeft(wnd);
    int MouseY = (int) p2 - GetClientTop(wnd);
    RECT rc = ClientRect(wnd);
    if (!InsideRect(p1, p2, rc))
        return FALSE;
    if (MouseY &gt; wnd-&gt;wlines-1)
        return FALSE;
    if (ButtonDown)    {
        SetAnchor(wnd, ButtonX+wnd-&gt;wleft, ButtonY+wnd-&gt;wtop);
        TextMarking = TRUE;
        SendMessage(NULL,MOUSE_TRAVEL,
                (PARAM)&amp;WindowRect(wnd),0);
        ButtonDown = FALSE;
    }
    if (TextMarking &amp;&amp; !(WindowMoving || WindowSizing))    {
        ExtendBlock(wnd, MouseX, MouseY);
        return TRUE;
    }
    return FALSE;
}
static void StopMarking(WINDOW wnd)
{
    TextMarking = FALSE;
    if (wnd-&gt;BlkBegLine &gt; wnd-&gt;BlkEndLine)    {
        swap(wnd-&gt;BlkBegLine, wnd-&gt;BlkEndLine);
        swap(wnd-&gt;BlkBegCol, wnd-&gt;BlkEndCol);
    }
    if (wnd-&gt;BlkBegLine == wnd-&gt;BlkEndLine &amp;&amp;
            wnd-&gt;BlkBegCol &gt; wnd-&gt;BlkEndCol)
        swap(wnd-&gt;BlkBegCol, wnd-&gt;BlkEndCol);
}
/* ----------- BUTTON_RELEASED Message ---------- */
static int ButtonReleasedMsg(WINDOW wnd)
{
    if (isMultiLine(wnd))    {
        ButtonDown = FALSE;
        if (TextMarking &amp;&amp; !(WindowMoving || WindowSizing))  {
            /* release the mouse ouside the edit box */
            SendMessage(NULL, MOUSE_TRAVEL, 0, 0);
            StopMarking(wnd);
            return TRUE;
        }
        else
            PrevY = -1;
    }
    return FALSE;
}
/* ---- Process text block keys for multiline text box ---- */
static void DoMultiLines(WINDOW wnd, int c, PARAM p2)
{
    if (isMultiLine(wnd))    {
        if ((int)p2 &amp; (LEFTSHIFT | RIGHTSHIFT))    {
            int kx, ky;
            SendMessage(NULL, CURRENT_KEYBOARD_CURSOR,
                (PARAM) &amp;kx, (PARAM) &amp;ky);
            kx -= GetClientLeft(wnd);
            ky -= GetClientTop(wnd);
            switch (c)    {
                case HOME:
                case END:
                case CTRL_HOME:
                case CTRL_END:
                case PGUP:
                case PGDN:
                case CTRL_PGUP:
                case CTRL_PGDN:
                case UP:
                case DN:
                case FWD:
                case BS:
                case CTRL_FWD:
                case CTRL_BS:
                    if (!KeyBoardMarking)    {
                        if (TextBlockMarked(wnd))    {
                            ClearTextBlock(wnd);
                            SendMessage(wnd, PAINT, 0, 0);
                        }
                        KeyBoardMarking = TextMarking = TRUE;
                        SetAnchor(wnd, kx+wnd-&gt;wleft,
                                                ky+wnd-&gt;wtop);
                    }
                    break;
                default:
                    break;
            }
        }
    }
}
/* ---------- page/scroll keys ----------- */
static int DoScrolling(WINDOW wnd, int c, PARAM p2)
{
    switch (c)    {
        case PGUP:
        case PGDN:
            if (isMultiLine(wnd))
                BaseWndProc(EDITBOX, wnd, KEYBOARD, c, p2);
            break;
        case CTRL_PGUP:
        case CTRL_PGDN:
            BaseWndProc(EDITBOX, wnd, KEYBOARD, c, p2);
            break;
        case HOME:
            Home(wnd);
            break;
        case END:
            End(wnd);
            break;
        case CTRL_FWD:
            NextWord(wnd);
            break;
        case CTRL_BS:
            PrevWord(wnd);
            break;
        case CTRL_HOME:
            if (isMultiLine(wnd))    {
                SendMessage(wnd, SCROLLDOC, TRUE, 0);
                wnd-&gt;CurrLine = 0;
                wnd-&gt;WndRow = 0;
            }
            Home(wnd);
            break;
        case CTRL_END:
            if (isMultiLine(wnd) &amp;&amp; wnd-&gt;wlines &gt; 0)    {
                SendMessage(wnd, SCROLLDOC, FALSE, 0);
                SetLinePointer(wnd, wnd-&gt;wlines-1);
                wnd-&gt;WndRow =
                    min(ClientHeight(wnd)-1, wnd-&gt;wlines-1);
                Home(wnd);
            }
            End(wnd);
            break;
        case UP:
            if (isMultiLine(wnd))
                Upward(wnd);
            break;
        case DN:
            if (isMultiLine(wnd))
                Downward(wnd);
            break;
        case FWD:
            Forward(wnd);
            break;
        case BS:
            Backward(wnd);
            break;
        default:
            return FALSE;
    }
    if (!KeyBoardMarking &amp;&amp; TextBlockMarked(wnd))    {
        ClearTextBlock(wnd);
        SendMessage(wnd, PAINT, 0, 0);
    }
    SendMessage(wnd, KEYBOARD_CURSOR, WndCol, wnd-&gt;WndRow);
    return TRUE;
}
/* -------------- Del key ---------------- */
static int DelKey(WINDOW wnd)
{
    char *currchar = CurrChar;
    int repaint = *currchar == '\n';
    if (TextBlockMarked(wnd))    {
        SendMessage(wnd, COMMAND, ID_DELETETEXT, 0);
        SendMessage(wnd, PAINT, 0, 0);
        return TRUE;
    }
    if (*(currchar+1) == '\0')
        return TRUE;
    strcpy(currchar, currchar+1);
    if (repaint)    {
        BuildTextPointers(wnd);
        SendMessage(wnd, PAINT, 0, 0);
    }
    else    {
        ModTextPointers(wnd, wnd-&gt;CurrLine+1, -1);
        WriteTextLine(wnd, NULL, wnd-&gt;WndRow+wnd-&gt;wtop, FALSE);
    }
    wnd-&gt;TextChanged = TRUE;
    return FALSE;
}
/* ------------ Tab key ------------ */
static int TabKey(WINDOW wnd, PARAM p2)
{
    if (isMultiLine(wnd))    {
        int insmd = wnd-&gt;InsertMode;
        do  {
            char *cc = CurrChar+1;
            if (!insmd &amp;&amp; *cc == '\0')
                break;
            if (wnd-&gt;textlen == wnd-&gt;MaxTextLength)
                break;
            SendMessage(wnd,KEYBOARD,insmd ? ' ' : FWD,0);
        } while (wnd-&gt;CurrCol % cfg.Tabs);
        return TRUE;
    }
    PostMessage(GetParent(wnd), KEYBOARD, '\t', p2);
    return FALSE;
}
/* --------- All displayable typed keys ------------- */
static void KeyTyped(WINDOW wnd, int c)
{
    char *currchar = CurrChar;
    if ((c != '\n' &amp;&amp; c &lt; ' ') || (c &amp; 0x1000))
        /* ---- not recognized by editor --- */
        return;
    if (!isMultiLine(wnd) &amp;&amp; TextBlockMarked(wnd))    {
        ResetEditBox(wnd);
        currchar = CurrChar;
    }
    if (*currchar == '\0')    {
        /* ---- typing at end of text ---- */
        if (currchar == wnd-&gt;text+wnd-&gt;MaxTextLength)    {
            /* ---- typing at the end of maximum buffer ---- */
            beep();
            return;
        }
        /* --- insert a newline at end of text --- */
        *currchar = '\n';
        *(currchar+1) = '\0';
        BuildTextPointers(wnd);
    }
    /* --- displayable char or newline --- */
    if (c == '\n' || wnd-&gt;InsertMode ||    *currchar == '\n') {
        /* ------ inserting the keyed character ------ */
        if (wnd-&gt;text[wnd-&gt;textlen-1] != '\0')    {
            /* --- the current text buffer is full --- */
            if (wnd-&gt;textlen == wnd-&gt;MaxTextLength)    {
                /* --- text buffer is at maximum size --- */
                beep();
                return;
            }
            /* ---- increase the text buffer size ---- */
            wnd-&gt;textlen += GROWLENGTH;
            /* --- but not above maximum size --- */
            if (wnd-&gt;textlen &gt; wnd-&gt;MaxTextLength)
                wnd-&gt;textlen = wnd-&gt;MaxTextLength;
            wnd-&gt;text = realloc(wnd-&gt;text, wnd-&gt;textlen+2);
            wnd-&gt;text[wnd-&gt;textlen-1] = '\0';
            currchar = CurrChar;
        }
        memmove(currchar+1, currchar, strlen(currchar)+1);
        ModTextPointers(wnd, wnd-&gt;CurrLine+1, 1);
        if (isMultiLine(wnd) &amp;&amp; wnd-&gt;wlines &gt; 1)
            wnd-&gt;textwidth = max(wnd-&gt;textwidth,
                (int) (TextLine(wnd, wnd-&gt;CurrLine+1)-
                TextLine(wnd, wnd-&gt;CurrLine)));
        else
            wnd-&gt;textwidth = max(wnd-&gt;textwidth,
                strlen(wnd-&gt;text));
        WriteTextLine(wnd, NULL,
            wnd-&gt;wtop+wnd-&gt;WndRow, FALSE);
    }
    /* ----- put the char in the buffer ----- */
    *currchar = c;
    wnd-&gt;TextChanged = TRUE;
    if (c == '\n')    {
        wnd-&gt;wleft = 0;
        BuildTextPointers(wnd);
        End(wnd);
        Forward(wnd);
        SendMessage(wnd, PAINT, 0, 0);
        return;
    }
    /* ---------- test end of window --------- */
    if (WndCol == ClientWidth(wnd)-1)    {
        int dif;
        char *cp = currchar;
        while (*cp != ' ' &amp;&amp; cp != TextLine(wnd, wnd-&gt;CurrLine))
            --cp;
        if (!isMultiLine(wnd) ||
            cp == TextLine(wnd, wnd-&gt;CurrLine) ||
                !wnd-&gt;WordWrapMode)
            SendMessage(wnd, HORIZSCROLL, TRUE, 0);
        else    {
            dif = 0;
            if (c != ' ')    {
                dif = (int) (currchar - cp);
                wnd-&gt;CurrCol -= dif;
                SendMessage(wnd, KEYBOARD, DEL, 0);
                --dif;
            }
            SendMessage(wnd, KEYBOARD, '\r', 0);
            currchar = CurrChar;
            wnd-&gt;CurrCol = dif;
            if (c == ' ')
                return;
        }
    }
    /* ------ display the character ------ */
    SetStandardColor(wnd);
    PutWindowChar(wnd, c, WndCol, wnd-&gt;WndRow);
    /* ----- advance the pointers ------ */
    wnd-&gt;CurrCol++;
}
/* ------------ screen changing key strokes ------------- */
static int DoKeyStroke(WINDOW wnd, int c, PARAM p2)
{
    switch (c)    {
        case RUBOUT:
            Backward(wnd);
        case DEL:
            if (DelKey(wnd))
                return TRUE;
            break;
        case CTRL_FIVE:    /* same as Shift+Tab */
            if (!((int)p2 &amp; (LEFTSHIFT | RIGHTSHIFT)))
                break;
        case '\t':
            if (TabKey(wnd, p2))
                return TRUE;
            break;
        case '\r':
            if (!isMultiLine(wnd))    {
                PostMessage(GetParent(wnd), KEYBOARD, c, p2);
                break;
            }
            c = '\n';
        default:
            if (TextBlockMarked(wnd))    {
                SendMessage(wnd, COMMAND, ID_DELETETEXT, 0);
                SendMessage(wnd, PAINT, 0, 0);
            }
            KeyTyped(wnd, c);
            break;
    }
    return FALSE;
}
/* ----------- KEYBOARD Message ---------- */
static int KeyboardMsg(WINDOW wnd, PARAM p1, PARAM p2)
{
    int c = (int) p1;
    if (WindowMoving || WindowSizing || ((int)p2 &amp; ALTKEY))
        return FALSE;
    switch (c)    {
        /* --- these keys get processed by lower classes --- */
        case ESC:
        case F1:
        case F2:
        case F3:
        case F4:
        case F5:
        case F6:
        case F7:
        case F8:
        case F9:
        case F10:
        case INS:
        case SHIFT_INS:
        case SHIFT_DEL:
            return FALSE;
        /* --- these keys get processed here --- */
        case CTRL_FWD:
        case CTRL_BS:
        case CTRL_HOME:
        case CTRL_END:
        case CTRL_PGUP:
        case CTRL_PGDN:
            break;
        default:
            /* other ctrl keys get processed by lower classes */
            if ((int)p2 &amp; CTRLKEY)
                return FALSE;
            /* --- all other keys get processed here --- */
            break;
    }
    DoMultiLines(wnd, c, p2);
    if (DoScrolling(wnd, c, p2))    {
        if (KeyBoardMarking)
            ExtendBlock(wnd, WndCol, wnd-&gt;WndRow);
    }
    else if (!TestAttribute(wnd, READONLY))    {
        DoKeyStroke(wnd, c, p2);
        SendMessage(wnd, KEYBOARD_CURSOR, WndCol, wnd-&gt;WndRow);
    }
    return TRUE;
}
/* ----------- SHIFT_CHANGED Message ---------- */
static void ShiftChangedMsg(WINDOW wnd, PARAM p1)
{
    if (!((int)p1 &amp; (LEFTSHIFT | RIGHTSHIFT)) &amp;&amp;
                                   KeyBoardMarking)    {
        StopMarking(wnd);
        KeyBoardMarking = FALSE;
    }
}
/* ----------- ID_DELETETEXT Command ---------- */
static void DeleteTextCmd(WINDOW wnd)
{
    if (TextBlockMarked(wnd))    {
        char *bbl=TextLine(wnd,wnd-&gt;BlkBegLine)+wnd-&gt;BlkBegCol;
        char *bel=TextLine(wnd,wnd-&gt;BlkEndLine)+wnd-&gt;BlkEndCol;
        int len = (int) (bel - bbl);
        SaveDeletedText(wnd, bbl, len);
        wnd-&gt;TextChanged = TRUE;
        strcpy(bbl, bel);
        wnd-&gt;CurrLine = TextLineNumber(wnd, bbl-wnd-&gt;BlkBegCol);
        wnd-&gt;CurrCol = wnd-&gt;BlkBegCol;
        wnd-&gt;WndRow = wnd-&gt;BlkBegLine - wnd-&gt;wtop;
        if (wnd-&gt;WndRow &lt; 0)    {
            wnd-&gt;wtop = wnd-&gt;BlkBegLine;
            wnd-&gt;WndRow = 0;
        }
        SendMessage(wnd, KEYBOARD_CURSOR, WndCol, wnd-&gt;WndRow);
        ClearTextBlock(wnd);
        BuildTextPointers(wnd);
    }
}
/* ----------- ID_CLEAR Command ---------- */
static void ClearCmd(WINDOW wnd)
{
    if (TextBlockMarked(wnd))    {
        char *bbl=TextLine(wnd,wnd-&gt;BlkBegLine)+wnd-&gt;BlkBegCol;
        char *bel=TextLine(wnd,wnd-&gt;BlkEndLine)+wnd-&gt;BlkEndCol;
        int len = (int) (bel - bbl);
        SaveDeletedText(wnd, bbl, len);
        wnd-&gt;CurrLine = TextLineNumber(wnd, bbl);
        wnd-&gt;CurrCol = wnd-&gt;BlkBegCol;
        wnd-&gt;WndRow = wnd-&gt;BlkBegLine - wnd-&gt;wtop;
        if (wnd-&gt;WndRow &lt; 0)    {
            wnd-&gt;WndRow = 0;
            wnd-&gt;wtop = wnd-&gt;BlkBegLine;
        }
        /* ------ change all text lines in block to \n ----- */
        while (bbl &lt; bel)    {
            char *cp = strchr(bbl, '\n');
            if (cp &gt; bel)
                cp = bel;
            strcpy(bbl, cp);
            bel -= (int) (cp - bbl);
            bbl++;
        }
        ClearTextBlock(wnd);
        BuildTextPointers(wnd);
        SendMessage(wnd, KEYBOARD_CURSOR, WndCol, wnd-&gt;WndRow);
        SendMessage(wnd, PAINT, 0, 0);
        wnd-&gt;TextChanged = TRUE;
    }
}
/* ----------- ID_UNDO Command ---------- */
static void UndoCmd(WINDOW wnd)
{
    if (wnd-&gt;DeletedText != NULL)    {
        PasteText(wnd, wnd-&gt;DeletedText, wnd-&gt;DeletedLength);
        free(wnd-&gt;DeletedText);
        wnd-&gt;DeletedText = NULL;
        wnd-&gt;DeletedLength = 0;
        SendMessage(wnd, PAINT, 0, 0);
    }
}
/* ----------- ID_PARAGRAPH Command ---------- */
static void ParagraphCmd(WINDOW wnd)
{
    int bc, ec, fl, el, Blocked;
    char *bl, *bbl, *bel, *bb;

    el = wnd-&gt;BlkEndLine;
    ec = wnd-&gt;BlkEndCol;
    if (!TextBlockMarked(wnd))    {
        Blocked = FALSE;
        /* ---- forming paragraph from cursor position --- */
        fl = wnd-&gt;wtop + wnd-&gt;WndRow;
        bbl = bel = bl = TextLine(wnd, wnd-&gt;CurrLine);
        if ((bc = wnd-&gt;CurrCol) &gt;= ClientWidth(wnd))
            bc = 0;
        Home(wnd);
        /* ---- locate the end of the paragraph ---- */
        while (*bel)    {
            int blank = TRUE;
            char *bll = bel;
            /* --- blank line marks end of paragraph --- */
            while (*bel &amp;&amp; *bel != '\n')    {
                if (*bel != ' ')
                    blank = FALSE;
                bel++;
            }
            if (blank)    {
                bel = bll;
                break;
            }
            if (*bel)
                bel++;
        }
        if (bel == bbl)    {
            SendMessage(wnd, KEYBOARD, DN, 0);
            return;
        }
        if (*bel == '\0')
            --bel;
        if (*bel == '\n')
            --bel;
    }
    else    {
        /* ---- forming paragraph from marked block --- */
        Blocked = TRUE;
        bbl = TextLine(wnd, wnd-&gt;BlkBegLine) + wnd-&gt;BlkBegCol;
        bel = TextLine(wnd, wnd-&gt;BlkEndLine) + wnd-&gt;BlkEndCol;
        fl = wnd-&gt;BlkBegLine;
        bc = wnd-&gt;CurrCol = wnd-&gt;BlkBegCol;
        wnd-&gt;CurrLine = fl;
        if (fl &lt; wnd-&gt;wtop)
            wnd-&gt;wtop = fl;
        wnd-&gt;WndRow = fl - wnd-&gt;wtop;
        SendMessage(wnd, KEYBOARD, '\r', 0);
        el++, fl++;
        if (bc != 0)    {
            SendMessage(wnd, KEYBOARD, '\r', 0);
            el++, fl ++;
        }
        bc = 0;
        bl = TextLine(wnd, fl);
        wnd-&gt;CurrLine = fl;
        bbl = bl + bc;
        bel = TextLine(wnd, el) + ec;
    }
    /* --- change all newlines in block to spaces --- */
    while (CurrChar &lt; bel)    {
        if (*CurrChar == '\n')    {
            *CurrChar = ' ';
            wnd-&gt;CurrLine++;
            wnd-&gt;CurrCol = 0;
        }
        else
            wnd-&gt;CurrCol++;
    }
    /* ---- insert newlines at new margin boundaries ---- */
    bb = bbl;
    while (bbl &lt; bel)    {
        bbl++;
        if ((int)(bbl - bb) == ClientWidth(wnd)-1)    {
            while (*bbl != ' ' &amp;&amp; bbl &gt; bb)
                --bbl;
            if (*bbl != ' ')    {
                bbl = strchr(bbl, ' ');
                if (bbl == NULL || bbl &gt;= bel)
                    break;
            }
            *bbl = '\n';
            bb = bbl+1;
        }
    }
    ec = (int)(bel - bb);
    BuildTextPointers(wnd);
    if (Blocked)    {
        /* ---- position cursor at end of new paragraph ---- */
        if (el &lt; wnd-&gt;wtop ||
                wnd-&gt;wtop + ClientHeight(wnd) &lt; el)
            wnd-&gt;wtop = el-ClientHeight(wnd);
        if (wnd-&gt;wtop &lt; 0)
            wnd-&gt;wtop = 0;
        wnd-&gt;WndRow = el - wnd-&gt;wtop;
        wnd-&gt;CurrLine = el;
        wnd-&gt;CurrCol = ec;
        SendMessage(wnd, KEYBOARD, '\r', 0);
        SendMessage(wnd, KEYBOARD, '\r', 0);
    }
    else    {
        /* --- put cursor back at beginning --- */
        wnd-&gt;CurrLine = TextLineNumber(wnd, bl);
        wnd-&gt;CurrCol = bc;
        if (fl &lt; wnd-&gt;wtop)
            wnd-&gt;wtop = fl;
        wnd-&gt;WndRow = fl - wnd-&gt;wtop;
    }
    SendMessage(wnd, PAINT, 0, 0);
    SendMessage(wnd, KEYBOARD_CURSOR, WndCol, wnd-&gt;WndRow);
    wnd-&gt;TextChanged = TRUE;
    BuildTextPointers(wnd);
}
/* ----------- COMMAND Message ---------- */
static int CommandMsg(WINDOW wnd, PARAM p1)
{
    switch ((int)p1)    {
        case ID_DELETETEXT:
            DeleteTextCmd(wnd);
            return TRUE;
        case ID_CLEAR:
            ClearCmd(wnd);
            return TRUE;
        case ID_UNDO:
            UndoCmd(wnd);
            return TRUE;
        case ID_PARAGRAPH:
            ParagraphCmd(wnd);
            return TRUE;
        default:
            break;
    }
    return FALSE;
}
/* ---------- CLOSE_WINDOW Message ----------- */
static void CloseWindowMsg(WINDOW wnd)
{
    SendMessage(NULL, HIDE_CURSOR, 0, 0);
    if (wnd-&gt;DeletedText != NULL)
        free(wnd-&gt;DeletedText);
}
/* ------- Window processing module for EDITBOX class ------ */
int EditBoxProc(WINDOW wnd, MESSAGE msg, PARAM p1, PARAM p2)
{
    int rtn;
    switch (msg)    {
        case CREATE_WINDOW:
            return CreateWindowMsg(wnd);
        case ADDTEXT:
            return AddTextMsg(wnd, p1, p2);
        case SETTEXT:
            return SetTextMsg(wnd, p1);
        case CLEARTEXT:
            ResetEditBox(wnd);
            break;
        case GETTEXT:
            return GetTextMsg(wnd, p1, p2);
        case SETTEXTLENGTH:
            return SetTextLengthMsg(wnd, (unsigned) p1);
        case KEYBOARD_CURSOR:
            return KeyboardCursorMsg(wnd, p1, p2);
        case SETFOCUS:
        case PAINT:
        case MOVE:
            rtn = BaseWndProc(EDITBOX, wnd, msg, p1, p2);
            SendMessage(wnd,KEYBOARD_CURSOR,WndCol,wnd-&gt;WndRow);
            return rtn;
        case SIZE:
            return SizeMsg(wnd, p1, p2);
        case SCROLL:
            return ScrollMsg(wnd, p1);
        case HORIZSCROLL:
            return HorizScrollMsg(wnd, p1);
        case SCROLLPAGE:
            return ScrollPageMsg(wnd, p1);
        case HORIZPAGE:
            return HorizPageMsg(wnd, p1);
        case LEFT_BUTTON:
            if (LeftButtonMsg(wnd, p1, p2))
                return TRUE;
            break;
        case MOUSE_MOVED:
            if (MouseMovedMsg(wnd, p1, p2))
                return TRUE;
            break;
        case BUTTON_RELEASED:
            if (ButtonReleasedMsg(wnd))
                return TRUE;
            break;
        case KEYBOARD:
            if (KeyboardMsg(wnd, p1, p2))
                return TRUE;
            break;
        case SHIFT_CHANGED:
            ShiftChangedMsg(wnd, p1);
            break;
        case COMMAND:
            if (CommandMsg(wnd, p1))
                return TRUE;
            break;
        case CLOSE_WINDOW:
            CloseWindowMsg(wnd);
            break;
        default:
            break;
    }
    return BaseWndProc(EDITBOX, wnd, msg, p1, p2);
}
/* ------ save deleted text for the Undo command ------ */
static void SaveDeletedText(WINDOW wnd, char *bbl, int len)
{
    wnd-&gt;DeletedLength = len;
    if ((wnd-&gt;DeletedText=realloc(wnd-&gt;DeletedText,len))!=NULL)
        memmove(wnd-&gt;DeletedText, bbl, len);
}
/* ---- cursor right key: right one character position ---- */
static void Forward(WINDOW wnd)
{
    char *cc = CurrChar+1;
    if (*cc == '\0')
        return;
    if (*CurrChar == '\n')    {
        Home(wnd);
        Downward(wnd);
    }
    else    {
        wnd-&gt;CurrCol++;
        if (WndCol == ClientWidth(wnd))
            SendMessage(wnd, HORIZSCROLL, TRUE, 0);
    }
}
/* ----- stick the moving cursor to the end of the line ---- */
static void StickEnd(WINDOW wnd)
{
    char *cp = TextLine(wnd, wnd-&gt;CurrLine);
    char *cp1 = strchr(cp, '\n');
    int len = cp1 ? (int) (cp1 - cp) : 0;
    wnd-&gt;CurrCol = min(len, wnd-&gt;CurrCol);
    if (wnd-&gt;wleft &gt; wnd-&gt;CurrCol)    {
        wnd-&gt;wleft = max(0, wnd-&gt;CurrCol - 4);
        SendMessage(wnd, PAINT, 0, 0);
    }
    else if (wnd-&gt;CurrCol-wnd-&gt;wleft &gt;= ClientWidth(wnd))    {
        wnd-&gt;wleft = wnd-&gt;CurrCol - (ClientWidth(wnd)-1);
        SendMessage(wnd, PAINT, 0, 0);
    }
}
/* --------- cursor down key: down one line --------- */
static void Downward(WINDOW wnd)
{
    if (isMultiLine(wnd) &amp;&amp;
            wnd-&gt;WndRow+wnd-&gt;wtop+1 &lt; wnd-&gt;wlines)  {
        wnd-&gt;CurrLine++;
        if (wnd-&gt;WndRow == ClientHeight(wnd)-1)
            SendMessage(wnd, SCROLL, TRUE, 0);
        wnd-&gt;WndRow++;
        StickEnd(wnd);
    }
}
/* -------- cursor up key: up one line ------------ */
static void Upward(WINDOW wnd)
{
    if (isMultiLine(wnd) &amp;&amp; wnd-&gt;CurrLine != 0)    {
        if (wnd-&gt;CurrLine &gt; 0)
            --wnd-&gt;CurrLine;
        if (wnd-&gt;WndRow == 0)
            SendMessage(wnd, SCROLL, FALSE, 0);
        --wnd-&gt;WndRow;
        StickEnd(wnd);
    }
}
/* ---- cursor left key: left one character position ---- */
static void Backward(WINDOW wnd)
{
    if (wnd-&gt;CurrCol)    {
        if (wnd-&gt;CurrCol-- &lt;= wnd-&gt;wleft)
            if (wnd-&gt;wleft != 0)
                SendMessage(wnd, HORIZSCROLL, FALSE, 0);
    }
    else if (isMultiLine(wnd) &amp;&amp; wnd-&gt;CurrLine != 0)    {
        Upward(wnd);
        End(wnd);
    }
}
/* -------- End key: to end of line ------- */
static void End(WINDOW wnd)
{
    while (*CurrChar &amp;&amp; *CurrChar != '\n')
        ++wnd-&gt;CurrCol;
    if (WndCol &gt;= ClientWidth(wnd))    {
        wnd-&gt;wleft = wnd-&gt;CurrCol - (ClientWidth(wnd)-1);
        SendMessage(wnd, PAINT, 0, 0);
    }
}
/* -------- Home key: to beginning of line ------- */
static void Home(WINDOW wnd)
{
    wnd-&gt;CurrCol = 0;
    if (wnd-&gt;wleft != 0)    {
        wnd-&gt;wleft = 0;
        SendMessage(wnd, PAINT, 0, 0);
    }
}
/* -- Ctrl+cursor right key: to beginning of next word -- */
static void NextWord(WINDOW wnd)
{
    int savetop = wnd-&gt;wtop;
    int saveleft = wnd-&gt;wleft;
    ClearVisible(wnd);
    while (!isWhite(*CurrChar))    {
        char *cc = CurrChar+1;
        if (*cc == '\0')
            break;
        Forward(wnd);
    }
    while (isWhite(*CurrChar))    {
        char *cc = CurrChar+1;
        if (*cc == '\0')
            break;
        Forward(wnd);
    }
    SetVisible(wnd);
    SendMessage(wnd, KEYBOARD_CURSOR, WndCol, wnd-&gt;WndRow);
    if (wnd-&gt;wtop != savetop || wnd-&gt;wleft != saveleft)
        SendMessage(wnd, PAINT, 0, 0);
}
/* -- Ctrl+cursor left key: to beginning of previous word -- */
static void PrevWord(WINDOW wnd)
{
    int savetop = wnd-&gt;wtop;
    int saveleft = wnd-&gt;wleft;
    ClearVisible(wnd);
    Backward(wnd);
    while (isWhite(*CurrChar))    {
        if (wnd-&gt;CurrLine == 0 &amp;&amp; wnd-&gt;CurrCol == 0)
            break;
        Backward(wnd);
    }
    while (!isWhite(*CurrChar))    {
        if (wnd-&gt;CurrLine == 0 &amp;&amp; wnd-&gt;CurrCol == 0)
            break;
        Backward(wnd);
    }
    if (isWhite(*CurrChar))
        Forward(wnd);
    SetVisible(wnd);
    if (wnd-&gt;wleft != saveleft)
        if (wnd-&gt;CurrCol &gt;= saveleft)
            if (wnd-&gt;CurrCol - saveleft &lt; ClientWidth(wnd))
                wnd-&gt;wleft = saveleft;
    SendMessage(wnd, KEYBOARD_CURSOR, WndCol, wnd-&gt;WndRow);
    if (wnd-&gt;wtop != savetop || wnd-&gt;wleft != saveleft)
        SendMessage(wnd, PAINT, 0, 0);
}
/* ----- reset the text attributes of an EDITBOX ------- */
static void ResetEditBox(WINDOW wnd)
{
    unsigned blen = EditBufLen(wnd)+2;
    wnd-&gt;text = realloc(wnd-&gt;text, blen);
    memset(wnd-&gt;text, 0, blen);
    wnd-&gt;wlines = 0;
    wnd-&gt;CurrLine = 0;
    wnd-&gt;CurrCol = 0;
    wnd-&gt;WndRow = 0;
    wnd-&gt;wleft = 0;
    wnd-&gt;wtop = 0;
    wnd-&gt;textwidth = 0;
    wnd-&gt;TextChanged = FALSE;
    ClearTextPointers(wnd);
    ClearTextBlock(wnd);
}
/* ----- modify text pointers from a specified position
                by a specified plus or minus amount ----- */
static void ModTextPointers(WINDOW wnd, int lineno, int var)
{
    while (lineno &lt; wnd-&gt;wlines)
        *((wnd-&gt;TextPointers) + lineno++) += var;
}
</pre>

<HR><P>Copyright &copy; 1992, <I>Dr. Dobb's Journal</I></P></BODY></HTML>
