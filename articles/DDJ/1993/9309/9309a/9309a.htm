<HTML>
<META NAME="year" CONTENT="1993">
<HEAD>
<TITLE>SEP93: Recursive Worlds</TITLE></HEAD>
<BODY BGCOLOR="#ffffff">
<h1>Recursive Worlds<a name="025a_0003"></h1><P>
<h2><a name="025a_0001"><a name="025a_0000">Repeatedly replacing replicas</h2><P>
<h3>Clifford A. Pickover</h3><P>
<p><i><a name="025a_0002"><a name="025a_0000">Cliff is the author of numerous books including <I>Computers, Pattern, Chaos, and Beauty</I> (1990), <I>Computers and the Imagination</I> (1991), and <I>Mazes for the Mind</I> (1992), all published by St. Martin's Press. He is also a researcher at IBM's Thomas J. Watson Research Center. Cliff can be contacted at cliff@watson.ibm.com.</i></p><hr><P>
<I>He watched her for a long time and she knew that he was watching her and he knew that she knew he was watching her, and he knew that she knew that he knew; in a kind of regression of images that you get when two mirrors face each other and the images go on and on and on in some kind of infinity.</I><P>
--Robert Pirsig, <I>Lila</I><P>
Whatever can be done once can always be repeated,&quot; begins Louise B. Young in <I>The Mystery of Matter</I> when describing the shapes and structures of nature. From the branching of rivers and blood vessels, to the highly convoluted surface of brains and bark, the physical world contains intricate patterns formed from simple shapes through the recursive application of dynamic procedures. Questions about the fundamental rules underlying the variety of nature have led to the search to identify, measure, and define these patterns in precise scientific terms.<P>
Recursion is a fundamental concept in computer science, mathematics, biology, art, and even linguistics. Imagine, for instance, you're paging through a dictionary to find the definition of &quot;recursion,&quot; finding it just below &quot;recuperate:&quot;<P>
<I>recumbent</I> - lying down<P>
<I>recuperate</I> - to recover health<P>
<I>recursion</I> - look up the definition of recursion<P>
Here, &quot;recursion&quot; is defined in terms of itself--a <I>recursive definition</I>, in other words. (&quot;Recursion&quot; is distinct from &quot;iteration,&quot; which is exemplified by turning the pages of the dictionary to find a particular word, expressed in a program as: <I>NextPage=CurrentPage+1.</I>)<P>
Other linguistic recursive definitions include &quot;a wolf pack is two wolves or a wolf pack together with a wolf,&quot; or more simple constructs such as &quot;art is art,&quot; &quot;a dog is a dog,&quot; or even &quot;a dog is not a dog.&quot; Sometimes the term &quot;self-referential&quot; is used when referring to these constructs.<P>
The related concept of &quot;quining,&quot; discussed in Douglas Hofstadter's <I>Godel, Escher, Bach</I> (Vintage, 1980), is a process of taking a group of words, and forming a self-referential sentence by preceding the original group with the same group enclosed in quotes. For example: &quot;is a sentence fragment of seven words&quot; is a sentence fragment of seven words.<P>
<h4>Perhaps the most striking application of recursion occurs in the biological world where growth starts with a bud, which grows into a pipe, which then branches into two buds, each of these two buds branching in a recursive growth process. Iteration, or repeated application of these simple rules, results in a self-similar oak tree, arterial blood system, the bronchial system of lungs, or the like. The branching patterns are thought to be the result of the simplest of growth algorithms: The steps repeat the previous ones on smaller and smaller scales.  <a href="1993025c.htm">Example 2</A></h4><P>
<a href="1993025d.htm">Figure 1</A> shows a coral-like form I computed using simple recursive branching rules at smaller and smaller size scales. In geometry, one of the most interesting consequences of recursive processes is &quot;self-similarity.&quot; A self-similar object appears roughly the same after increasing or shrinking in size. Like a nested collection of Russian dolls within dolls, self-similar objects contain within themselves miniature copies of themselves. Look inside a turbulent stream of water: The largest eddies contain smaller ones, and these contain smaller ones still. The beautiful consequences of self-similarity are intricate, fine-grained patterns, now generally called &quot;fractals.&quot; The term fractals was coined in <I>The Fractal Geometry of Nature</I> by Benoit Mandelbrot (Freeman, 1982) to encompass many of the detailed and convoluted shapes found in nature and produced by recursion in both the mathematical and natural worlds.<P>
One of my earliest (and still most interesting) introductions to recursion and self-similarity was a Don Martin cartoon in <I>Mad</I> magazine. In the first frame, a man lies anesthetized on a hospital operating table. In the second, a surgeon uses a small circular saw to cut along the circumference of the man's head. Then, he removes the patient's skull cap.<P>
Inside the head, the surgeon doesn't find a brain, but rather, another fully formed head, identical to the original, but slightly smaller. The surgeon removes this smaller head and opens its skull cap, finding yet another head. He continues to open smaller and smaller heads until the last head sits in the palm of his hand. He opens this one and finds a slip of paper that reads, &quot;Inspected by number 47.&quot;<P>
In computer programming, recursion often refers to the structure and functioning of programs. The common definition of a recursive program is one that calls itself, and a recursive function is one that is defined in terms of itself. (Interestingly, recursion can be removed from any recursive program using iteration.)<P>
Perhaps the most common example of recursion in programming and in mathematics (where recursion is called a &quot;recurrence relation&quot;) is the factorial function: <I>X! =X</I>x<I>(X-1)!</I> for <I>X<img src="gteq.gif" alt="&gt;=">1, 0! =1</I> where <I>X</I> is an integer. This can be accomplished with a simple recursive program; in <a href="#025a_0005">Example 1(a)</A>, the program calls itself in line 3. Another common example of a recurrence relation is one that defines the Fibonacci numbers. This sequence of numbers, called the <I>Fibonacci sequence</I>, plays important roles in mathematics and nature. These numbers are such that, after the first two, every number in the sequence equals the sum of the two previous numbers: F<SUB>N</SUB>= F<SUB>N-1</SUB>+F<SUB>N-2</SUB> for N<img src="gteq.gif" alt="&gt;=">2,F<SUB>0</SUB>=F<SUB>1</SUB>=1. This defines the sequence: 1,1,2,3,5,8,13,21,34,55_.<P>
Like the factorial function, a simple recursive program can be written to generate the Fibonacci sequence such as in <a href="#025a_0005">Example 1(b)</A>.<P>
In actuality, as with many recurrence relations, it's easy to compute F<SUB>N</SUB> using arrays in a non-recursive program like <a href="#025a_0005">Example 1(c)</A>. This program computes the first 30 Fibonacci numbers using an array size of 30. This method of using arrays to store previous results is usually the preferred method for evaluating recurrence relations, because it allows even complex expressions to be processed in a uniform and efficient manner. Of course, in this example, you can avoid the array by retaining the last two values in two variables.<P>
<h3><a name="025a_0004">Recursive Lattices<a name="025a_0004"></h3><P>
I'll now turn to a particular class of self-similar objects I call <I>recursive lattices</I> because they can easily be constructed using checkerboards of different sizes. The concept of repeatedly replacing copies of a pattern at different-size scales to produce interesting patterns dates back many decades, including the work of mathematicians Koch, Hilbert, and Peano. More recent work has been done by Mandelbrot and Lindenmeyer. Artists such as Escher, Vasarely, Shepard, and Kim have also experimented with recursive patterns. I'll provide computational recipes for some intriguing, yet simple to compute, designs.<P>
To create the intricate forms, start with a collection of squares called the <I>initiator lattice</I> or array. You can see what these look like in the upper-left corners in Figures 2 and 3, for instance. The initial collection of squares represents one size scale. At each filled (black) square in the initial array I place a small copy of the filled array. This is the second-size scale. At each point in this new array, I place another copy of the initial pattern. This is the third-size scale. In practice, I only use three size scales for computational speed, and because an additional-size scale does not add much to the beauty of the final pattern.<P>
In mathematical terms, begin with an SxS square array, (A), containing all 0s to which 1s, representing filled squares or sites, are added at random locations. For example:<P>
<pre>0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 1 1 1 0 0
0 0 0 1 0 0 0 0
0 0 0 1 0 0 0 0
0 1 1 1 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0</pre><P>
Just how many patterns can you create by randomly selecting array locations and filling them with 1s? Think of the process of filling array locations in terms of cherries and wineglasses. Consider an SxS grid of beautiful crystal wineglasses. Throw M cherries at the grid. A glass is considered occupied if it contains one or more cherries. With every throw each cherry goes into one of the glasses. How many different patterns of occupied glasses can you make? (A glass with more than one cherry is considered the same as a glass with one cherry in the pattern.)<P>
It turns out that for an SxS array and M cherries, the number of different patterns is shown in <a href="1993025e.htm">Figure 4</A>(a). As an example of how large the number of potential patterns is, consider that 32 cherries thrown at a 9x9 grid creates  more than 10<SUP>22</SUP> different patterns. This is far greater than the number of stars in the Milky Way galaxy (10<SUP>12</SUP>) and greater than the number of atoms in a person's breath (10x10<SUP>21</SUP>). In fact, it is about equal to the estimated number of stars in the universe (10<SUP>22</SUP>).<P>
For patterns like Figures 2 and 3, I use S=7. Smaller arrays would lead to fewer potential patterns (particularly with the added induced symmetry, discussed later), and greater values of S lead to diffuse patterns with the scaling used. In C, the process of filling the initial array can be coded as in <a href="#025a_0006">Example 2(a)</A>. Notice that lines 6--9 introduce a fourfold--symmetrical pattern which leads to an overall symmetry in the design at several size scales. Since each of the &quot;cherries&quot; is symmetrically placed in each of the four quadrants of the initial array, each pattern is really defined by the smaller quadrant subpattern. Although this symmetrization decreases the number of possible patterns to that in <a href="1993025f.htm">Figure 4</A>(b).<P>
For even values of S, use Floor((S+1)/2), where &quot;Floor(x)&quot; returns the largest integer value not greater than the x parameter. I find that inducing the symmetry of the original pattern produces more aesthetically appealing designs than those produced by a random initial array.<P>
For convenience, a program may store the values of the A array in two 1-D arrays, x and y, whose values are centered at the origin. The final value of N is the number of filled points in the symmetrized array in <a href="#025a_0006">Example 2(b)</A>. The major computational step begins with the generation of the three size scales from these x and y arrays, the values of which store the positions of the filled (one) sites in the original structural motif. To determine the final positions of all the black squares in the final design, a scale factor <img src="alpha12.gif" alt="alpha"> is applied to each position and the resulting terms summed; see <a href="19930260.htm">Figure 4</A>(c). For the patterns in Figures 2 and 3, <img src="alpha12.gif" alt="alpha"><SUB>1</SUB>=1,<img src="alpha12.gif" alt="alpha"><SUB>2</SUB>=S,<img src="alpha12.gif" alt="alpha"><SUB>3</SUB>=<I>S</I><SUP>2</SUP>. To do this in a program, see <a href="#025a_0006">Example 2(c)</A>.<P>
Several numerical measures of the patterns can be computed and displayed in an effort to quantify the structure of the patterns (note the graphs in the upper-right of Figures 2 and 3). If these parameters are found to correlate with the &quot;beauty&quot; of certain patterns, computer programs can then examine these parameters and automatically generate classes of patterns of aesthetic value.<P>
Perhaps the most obvious parameter to compute is the fractal dimension <I>D,</I> which characterizes the size-scaling behavior of the pattern. This value gives an indication of the degree to which the pattern fills the plane--how the pattern &quot;behaves&quot; through different magnifications. Luckily, the <I>D</I>-value for these recursive lattice patterns is easy to compute; in general, <I>N=S</I><SUP>D</SUP> (where <I>N</I> is the number of filled sites in the original symmetrical array of squares, and <I>S</I> is the magnification factor used, in this case the same as the size of an edge of the original array, 7). Notice as the number of filled (black) sites (<I>N</I>) in the initial array increases, the dimension (<I>D</I>) increases. In one sense, <I>D</I> quantifies the degree to which the porous patterns fill the plane in which they reside. If all the sites in the initial array are filled, <I>N</I> is 49 and therefore <I>D</I>=2. This makes sense: If the entire plane is filled, the dimension of the object should be 2. In a program, <I>D</I> is calculated from <I>D=log(N)/log(7)</I>. In recursive words, dimensions are tangled up like a ball of twine, and all the patterns are neither one nor two dimensions, but somewhere in between.<P>
Another quantitative measure of the patterns' spatial characteristics is <I>p(r)</I>, the length-distribution function. The function indicates the distribution of all the interpoint distances, <I>r<SUB>ij</SUB></I>, in the pattern. Mathematically speaking, this new function <I>p(r)</I> is defined by <a href="19930261.htm">Figure 4</A>(d) where <I>N</I> is the number of points in the pattern. The sums are over <I>i</I> and <I>j</I>, and what's being summed is <img src="delta12.gif" alt="delta">(<I>r<SUB>ij</SUB>, r</I>)=1 if <I>r<SUB>ij</SUB>=r</I> and 0 if <I>r<SUB>ij</SUB><img src="noteq.gif">r</I>. In simple English, to compute <I>p(r)</I>, select a point in the pattern and compute the distances from that point to every other point in the pattern. Do this for each point in the pattern, and create a graph showing the number of different lengths as a function of each length. To interpret these graphs, the right-most point in the <I>p(r)</I> graph is the maximum distance found in the structure, and the left-most point is the minimum. The most common distance is the highest point of the curve.<P>
In a program, I use a Monte Carlo approach to compute <I>p(r)</I>, because actually computing all the interpoint distances is computationally expensive. Instead, you can randomly select pairs of points in the structure and produce the final <I>p(r)</I> curve after 500,000 pairs are cataloged. In C, the Monte Carlo process looks like <a href="#025a_0007">Example 3(a)</A>. <I>R</I><SUB>max</SUB>, the longest vector in the structure, or maximum linear dimension, can also be estimated by examining the last non-zero value of <I>p(r)</I>. The variable <I>Npts</I> is the number of points in the final recursive lattice pattern. Obviously there is some noise in the Monte Carlo process, and I use a simple nearest-neighbor smoother to reduce the noise so the eye can concentrate on the global structures of the curve; see <a href="#025a_0007">Example 3(b)</A>. If you run the Monte Carlo process twice using different random numbers, the graphics look almost identical.<P>
Another parameter, the radius of gyration, <I>R<SUB>g</SUB></I>, can be computed from the unsmoothed length-distribution function <I>p(r)</I> in <a href="19930262.htm">Figure 5</A>. The radius of gyration quantifies the spatial extent of the structure in the plane. Small, compact patterns have small values of <I>R<SUB>g</SUB></I>. LaR<SUB>g</SUB>e, extended patterns have laR<SUB>g</SUB>e values of <I>R<SUB>g</SUB></I>. To get an intuitive feeling for this parameter, if all of the squares in the final pattern were to lie on the edge of a circle of radius <I>R</I>, then <I>R<SUB>g</SUB>=R</I>. If the circle were stretched in one direction to form an ellipse, the <I>R<SUB>g</SUB></I> value would increase because the &quot;mass&quot; of the pattern is further from the center of mass of the entire pattern. In C, the <I>R<SUB>g</SUB></I> computation looks like <a href="#025a_0008">Example 4(a)</A>.<P>
After examining hundreds of recursive lattice patterns, I find that many people prefer high values of the fractal dimension of around 1.8. The <I>p(r)</I> curves for the preferred structures usually do not exhibit global features (bumps and valleys). To date, I haven't been able to determine a correlation between perceived beauty and the <I>R<SUB>g</SUB></I> parameter. You may wish to compute the lattice patterns and also look for correlations between perceived beauty and the fractal dimension.<P>
As indicated earlier, most people seem to prefer patterns with a symmetrical structure over those with purely random structures. I prefer patterns with fourfold symmetry; however, I've also experimented with patterns with inversion symmetry, bilateral symmetry, and random-walk symmetry. <a href="19930263.htm">Figure 3</A>, for example, is a bilaterally symmetric pattern produced by making the left and right sides contain the same patterns: A<SUB>ij</SUB>=1, A<SUB>S-1-i,j</SUB>=1. <a href="#025a_0008">Example 4(b)</A> shows this in C. Inversion symmetry can be computed by: A<SUB>ij</SUB>=1, A<SUB>S-1-i, S-1-j</SUB>=1. <a href="#025a_0008">Example 4(c)</A> shows this in C.<P>
Random walks can be used to force greater correlation between points in the initial array. Rather than selecting each site randomly with random-walk symmetry, the position of each new site is related to the previous. For example, select a point and continually subtract 1 from, or add 1 to, the initial site's x and y coordinates. Other symmetries, such as the sixfold symmetry of a snowflake, can also be used.<P>
<h4><a name="025a_0005">Example 1:<a name="025a_0005"></h4><P>
<pre>(a)
1 Factorial(X);
2     IF X=0 then Factorial=1
3     ELSE Factorial=X*Factorial(X-1)
4 END
(b)
1 Fibonacci(X)
2      IF N &lt;= 1 then Fibonacci=1
3      ELSE Fibonacci=Fibonacci(N-1)+Fibonacci(N-2)
4 END
(c)
Fibonacci
    F[0]=1;F[1]=1;
    For i = 2 to 30
           F[i]=F[i-1]+F[i-2]
    END
END</pre><P>



<h4><a name="025a_0006">Example 2:<a name="025a_0006"></h4><P>
<pre>1 S = 7; Sz = S-1; M = 20;
2 for (h=1; h&lt;=M; h++) {
3      /* rand returns a value between 0 and 32767 */
4      v = ((float) rand()/32767.)*S;
5      w = ((float) rand()/32767.)*S;
6      a[v][w]=1;
7      a[Sz-v][w]=1;
8      a[Sz-v][Sz-w]=1;
9      a[v][Sz-w]=1;
10 }
(b)
 N=0; Sz = S - 1;
 for (i=0; i&lt;=S; i++)
   for (j=0;j&lt;=S; j++)
          if (a[i][j]==1)
          {N++; x[h]=i-Sz/2; y[h]=j-Sz/2;}
(c)
  for (i=1; i&lt;=N; i++) {
     for (j=1; j&lt;=N; j++) {
         for (k=1; k&lt;=N; k++) {
               X = alpha[1]*x[h]+alpha[2]*x[h]+alpha[3]*x[h]
               Y = alpha[1]*y[h]+alpha[2]*y[h]+alpha[3]*y[h]
               PlotSquareAt(X,Y)
         }
     }
 }</pre><P>



<h4><a name="025a_0007">Example 3:<a name="025a_0007"></h4><P>
<pre>(a)
 /* initialize p array to zero */
 for(i=0; i&lt;900; i++) p&amp;lbrk.i&amp;rbrk.=0;
 total=500000;
 /* catalog 500000 vector lengths */
 for(i=0; i&lt;total; i++) {
      rnd1 = ((float) rand()/32767.)*Npts;
      rnd2 = ((float) rand()/32767.)*Npts;
      xterm = corx[rnd1]-corx[rnd2];
      yterm = cory[rnd1]-cory[rnd2];
      dist = sqrt (xterm*xterm+yterm*yterm);
      dist = dist+.5;
      p[(int)dist]++;
 }
(b)
 for(i=1; i&lt;900;i++) {
   ps[i]=.25*(float)p[i-1]+.5*(float)p[i]+.25*(float)p[i+1];
 }</pre><P>
<h4><a name="025a_0008">Example 4:<a name="025a_0008"></h4><P>
<pre>(a)
   sum=0; summ=0;
   for(i=0; i&lt;900;i++) {
        summ=summ+p[i];
        sum=sum+p[i]*i*i;
   }
   Rg=sqrt(sum/((float) summ*2)) ;
(b)
 Sz = S - 1;
 for (h=1; h&lt;=40; h++) {
      v = ((float) rand()/32767.)*S;
      w = ((float) rand()/32767.)*S;
      a[v][w]=1;
      a[Sz-v][w]=1;
 }
(c)
 Sz = S - 1;
 for (h=1;i h&lt;=30; h++) {
     v = ((float) rand()/32767.)*S;
     w = ((float) rand()/32767.)*S;
     a[v][w]=1;
     a[Sz-v][Sz-w]=1;
 }
</pre><P>
<h4> <a href="19930264.htm">Figure 1</A>: Coral-like form generated from a recursive program</h4><P>
<h4> <a href="19930265.htm">Figure 2</A>: Recursive lattice design using a fourfold-symmetrical pattern</h4><P>
<h4> <a href="19930266.htm">Figure 3</A>: Recursive lattice design using a bilaterally symmetric pattern</h4><P>
<h4> <a href="19930267.htm">Figure 4</A>: (a) The number of different patterns for an SXS array; (b) symmetrization decreases the number of possible patterns; (c) determining the final positions of all the black squares in the final design; (d) p(r), the length-distribution function, is a quantitative measure of the patterns' spatial characteristics</h4><P>
<h4> <a href="19930268.htm">Figure 5</A>: The radius of gyration R sub g, can be computed from the unsmoothed length-distribution function p(r).</h4><P>

<HR><P>Copyright &copy; 1993, <I>Dr. Dobb's Journal</I></P></BODY></HTML>
