<HTML>
<META NAME="year" CONTENT="1993">
<HEAD>
<TITLE>JUN93: EXAMINING MFC 2.0</TITLE></HEAD>
<BODY BGCOLOR="#ffffff">
<h1>EXAMINING MFC 2.0<a name="019b_0003"></h1><P>
<h2><a name="019b_0001"><a name="019b_0000">This class library has all the elements you need to build a graphical periodic table</h2><P>
<h3>Michael Yam</h3><P>
<p><i><a name="019b_0002"><a name="019b_0000">Michael is an independent consultant and has served New York's financial district since 1984.  He can be reached on CompuServe at 76367,3040.</i></p><hr><P>
The Microsoft Foundation Class library (MFC) provides a wrapper for most, but not all, Windows API functions.  The result is a condensed, object-oriented API that's at least familiar to seasoned SDK programmers.  You're in for a surprise, however, when you start looking for the SDK's WinMain, WndProc, or a message loop because MFC doesn't need the skeletal code required by the Windows API.  This could be disconcerting for experienced SDK programmers because it suggests a loss of control.  That's not the case, however.<P>
MFC 1.0, originally introduced with Microsoft C/C++ 7.0, took a minimalist approach to supporting the implementation of user-interface elements within Windows.  MFC 2.0, released with Visual C++, is more robust.  While MFC 1.0 contained about 60 C++ classes, MFC 2.0 provides over 100.  According to Microsoft, any application written under earlier versions of MFC will run virtually unmodified under 2.0--well, almost.  I've found that the functionality of some classes has been either merged or completely replaced.  Although the changes are minor, they can be &quot;gotchas&quot; when moving your code to MFC 2.0.  Furthermore, a redesign of your application may be required to take full advantage of the more recent version of MFC.<P>
<h3><a name="019b_0004">A Look at PT<a name="019b_0004"></h3><P>
As a &quot;Petzoldian&quot; and a chemistry major of long ago (in my time, only 105 elements existed), writing a periodic table was a good way to examine MFC.  PT, a periodic table like that in most chemistry textbooks, is a Windows application I originally wrote using MFC 1.0.  See <a href="#019b_0005">Table 1(a)</A> for a list of the files that make up PT.  PT uses a modeless dialog box as its main window.  Doing so takes advantage of the built-in functionality offered by dialog boxes, such as allowing the user to move among controls with the Tab key.  It's also easier to get and set text in edit controls.  And in terms of program size and memory requirements, a dialog box as a main window is thriftier than a standard frame window.<P>
<h4><a name="019b_0005">Table 1: (a) Files that make up PT; (b) data members in the CWinApp class; (c) MFC global functions to access WinMain() variables.</h4><P>
<pre>
  (a)

     PT.H
     PT.CPP
     PT.RC
     PT.DEF
     MAKEFILE
     DIALOGS.DLG
     RESOURCE.H
     PT.ICO

  (b)

     Data Members          Description
     ---------------------------------------------------------------------

     m_pszAppName          Specifies the name of the application.
     m_hInstance           Corresponds to the hInstance parameter passed
                            by Windows to WinMain().
     m_hPrevInstance       Corresponds to the hPrevInstance parameter
                            passed by Windows to WinMain().
     m_IpCmdLine           Corresponds to the IpCmdLine parameter passed
                            by Windows to WinMain().
     m_nCmdShow            Corresponds to the nCmdShow parameter passed
                            by Windows to WinMain().
     m_pMainWnd            Holds a pointer to the application's main
                            window.

  (c)

     Functions             Description

     AfxGetApp             Obtain a pointer to the CWinApp object.
     AfxGetInstanceHandle  Obtain a handle to the current application
                            instance.
     AfxGetResourceHandle  Obtain a handle to the application's resources.
     AfxGetAppName         Obtain a pointer to a string containing the
                            application's name.</pre><P>
<P>
I arranged the display of the periodic table to resemble the map in your chemistry class; see <a href="1993019d.htm">Figure 1</A>.  The idea is to point to the element of choice, click the mouse, and have the program display edit fields containing the name, symbol, atomic number, and atomic weight of the specified element.  You can also retrieve information by typing data into the appropriate edit field and pressing Enter.  As a convenience for those who can't remember the spelling of, say, &quot;Molybdenum&quot; or recall its symbol, the name and symbol edit fields are implemented as combo boxes so that data may be chosen from the list-box portion.<P>
<h3><a name="019b_0006">Browsing MFC<a name="019b_0006"></h3><P>
Microsoft developed MFC to simplify the Windows API, enable object-oriented (C++) techniques, and provide a degree of portability from 16- to 32-bit versions of Windows.  The more than 100 MFC classes can be divided into two groups: general purpose and Windows specific.  The former manages file services, persistent objects, exception handling, strings, and collections.  The latter should appeal to SDK programmers because it supports GDI, MDI, OLE, menus, dialogs, controls, and the like.  <a href="1993019e.htm">Figure 2</A> shows the complete hierarchy.<P>
The class CWinApp wraps all the functionality of WinMain() in class members; see <a href="#019b_0005">Table 1(b)</A>.  An MFC program only needs to declare an instance of CWinApp and the constructor takes care of the usual WinMain() responsibilities (class registration and main message-loop processing).  And just as an SDK program can have only one WinMain(), an MFC program can only have one instance of CWinApp.<P>
With 2.0 message maps, you write individual functions to handle each event instead of using switch/case statements to process messages in Windows procedures.  A good comparison is MS Basic's ON KEY(n) GOSUB line statement; if a function key or cursor key is pressed, then GOSUB line is executed.  With MFC, your individual function is executed if an event (like a function key, button press, or paint message) is detected.  A side benefit of the message map is that it provides portability to Win32 by eliminating the need to decode wParam and lParam.<P>
MFC 2.0 also supports OLE 1.0 (unlike MFC 1.0).  Nine classes provide for client and server applications, and integrate OLE into MFC's document architecture and view classes.  The client and server classes should not be thought of as two different categories of OLE items, but as two different interfaces to the same OLE item.  Since these interfaces communicate through OLE system DLLs, a client application should never directly call member functions of a server class.  Likewise, a server application should never directly call member functions of a client class.  Maintaining the integrity of the OLE interprocess communication allows client applications to accept items from any server; you won't need to write code to handle the specific contents of an incoming item.  This separation of client and server, now artificially imposed by the framework, will be extended and integrated into the upcoming OLE 2.0.<P>
The server classes allow for the creation of full and mini-servers.  A full server can be a stand-alone application or an application that has been launched by a client.  A full server handles both embedded and linked objects, can own documents and write them to disk, and typically has a multiple document interface.  A mini-server, on the other hand, is launched by a client and handles only embedded objects.  A mini-server does not own documents, but rather accesses those of the client.  Additionally, a mini-server typically has a single-document interface.  The MS-Draw and Graph components of Microsoft Word for Windows are mini-servers.<P>
Also new to MFC 2.0 is support for Visual Basic 1.0 custom controls or VBX controls.  VBX controls are stored in Windows DLLs and the class CVBControl allows you to load the controls, and get and set their properties.  Compatibility is good, although some VBX features, such as drag-and-drop and control arrays, are not supported.  Naturally, any VBX control that relies on the internal or undocumented features of Visual Basic isn't guaranteed to work.<P>
<h3><a name="019b_0007">Dialog Box as the Main Window<a name="019b_0007"></h3><P>
As previously mentioned, PT uses a modeless dialog box as its main window.  From Microsoft's CDialog class, PT derives its own class, CPTDialog (as shown in <a href="#019b_000f">Listing One</A>, page 132).  To conserve space here, many of the functions for the 109 elements are available electronically; see page 7.  Using an object of this class as a main window requires a further look at two components of CWinApp: an overrideable member function, InitInstance(), and a public data member, m_pMainWnd.  InitInstance() creates a window object and m_pMainWnd holds the pointer to that window object.  Therefore, you need to assign the main window pointer to the CPTDialog constructor to make a dialog object a main window.  From CWinApp, PT derives an application class, CTheApp, and inside CTheApp::InitInstance(), places the statement m_pMainWnd=new CPTDialog().<P>
<h3><a name="019b_0008">Custom Icons<a name="019b_0008"></h3><P>
The code inside the constructor should reassure SDK programmers that MFC can be overridden; besides creating the dialog object, CPTDialog() replaces the default icon, a white box, with its own icon.  MFC provides two mechanisms for loading a custom icon; unfortunately, neither work for a dialog box.  Still, the techniques are worth knowing, so I'll mention them briefly.  The first mechanism is through a function, AfxRegisterWndClass(), which accepts the icon as one of its arguments.  Other arguments include the class style, the mouse cursor, and the background.  AfxRegisterWndClass() generates a class name to be passed into a Create() member function, typically of the CWnd class.  The problem is that the Create() member function of the CDialog class doesn't accept a class name.<P>
The second mechanism involves overriding reserved MFC icon IDs defined as AFX_IDI_STD_FRAME and AFX_IDI_STD_MDIFRAME (see <a href="#019b_0009">Figure 3</A>).  But as the names of the identifiers suggest, this works only for standard frame windows and MDI frame windows, not for dialogs.  Loading a custom icon for a dialog box wasn't obvious from the documentation, possibly because a user doesn't usually need to minimize a dialog box.  The solution was to register my own PT dialog class, and load my icon there.<P>
<h4><a name="019b_0009">Figure 3: Overriding icon IDs reserved by MFC.</h4><P>
<pre>
  AFX_IDI_STD_FRAME     ICON  custom.ico
  AFX_IDI_STD_MDIFRAME  ICON  custom.ico</pre><P>
<P>
Inside CPTDialog, you'll find a private function member: RegisterPTClass() (shown in <a href="#019b_0011">Listing Two</A>, page 132).  It fills in the WNDCLASS structure and resembles some of the initialization code found in WinMain().  I set the icon, as well as the cursor, background, and menu, and designated the class name as PTDLGCLASS.  This class name is referenced by the dialog-box template described in the resource file DIALOGS.DLG (available electronically; see page 7).  Notice that RegisterPTClass() uses &quot;unwrapped&quot; Windows functions such as ::LoadIcon(), ::LoadCursor(), and ::RegisterClass().  The C++ scope resolution operator, ::, indicates that the name refers to the Windows function and not to a class-member function.  RegisterPTClass() also needs the application's instance handle and calls an MFC global function AfxGetInstanceHandle() to retrieve it.  MFC global functions access the WinMain() variables, of which there are four; see <a href="#019b_0005">Table 1(c)</A>.<P>
<h3><a name="019b_000a">Mapping Messages<a name="019b_000a"></h3><P>
For simplicity, I've assigned each element its own button control.  This totals 109 element buttons.  (Don't forget that 255 controls per dialog is the limit set by the Windows API.) Each button is entered into the message map and associated with a function to display the element's data.  To establish a message map, I first included DECLARE_MESSAGE_MAP inside the CPTDialog class.  Only one declaration is allowed per class.  The code fragment in <a href="#019b_000b">Figure 4</A> belongs outside the class declaration and outside the scope of any function.<P>
<h4><a name="019b_000b">Figure 4: Declaring a message map.</h4><P>
<pre>
  BEGIN_MESSAGE_MAP (CPTDialog, CDialog)
     WM_CLOSE ()
     ON_COMMAND (IDM_ABOUT, OnAbout)
     ON_CBN_SETFOCUS (IDD_ELEMENTNAME,
                         OnNameSetFocus)
     ON_COMMAND (H. OnH)
     // other messages
  END_MESSAGE_MAP()</pre><P>
<P>
<a href="#019b_0011">Listing Two</A> contains the map.  Four categories of messages can be trapped: WM_COMMAND messages generated by menu selections, WM_COMMAND messages generated by keys, notification messages from child windows, and general WM_messages such as WM_PAINT or WM_CLOSE.  Messages to be trapped are placed between the macros BEGIN_MESSAGE_MAP and END_MESSAGE_MAP().  To help direct the flow of messages, BEGIN_MESSAGE_MAP requires two arguments: the derived class and the base class.  When a message is sent to a CPTDialog object, it is compared against the CPTDialog message map.  If an entry is found, the associated function is executed.  Otherwise, the search continues with the message map in the parent class.  As long as the message isn't matched, it continues to flow up the class hierarchy until it reaches the CWnd class--the mother of all Windows classes in MFC.  One of its member functions includes DefWindowProc().  Just as in the SDK Windows procedure, this is where unmatched messages go for default processing.<P>
The first message in <a href="#019b_000b">Figure 4</A> traps WM_CLOSE, overriding CWnd::OnClose().  This is generally not necessary for a standard window frame, but is required when using a dialog box.  Recall that a modeless dialog box can only be closed with DestroyWindow().  Yet when using MFC, DestroyWindow() by itself is not enough.  The function only destroys, or closes, the dialog window you see on the screen; it does not destroy the dialog object.  Any associated data structures and resources remain in memory.  MFC 1.0 provided an elegant solution to this problem: code CPTDialog::OnClose() with the C++ statement delete this.  This not only destroys the CPTDialog object (freeing resources), but also transparently calls DestroyWindow() to close the dialog window.  Had I not trapped WM_CLOSE, the message would have flowed up to CWnd and triggered the destructor, ~CWnd.  Since ~CWnd just calls DestroyWindow(), it would have left the dialog object as orphaned memory.  However, using this technique with MFC 2.0 is no longer recommended by Microsoft.  Instead, you should code DestroyWindow() and move delete this to an overrided PostNcDestroy member function (see <a href="#019b_000f">Listing One</A>).<P>
The second message in the map corresponds to a menu message; CPTDialog::OnAbout() is executed whenever IDM_ABOUT is detected.  OnAbout() in turn opens a modal dialog box to display information about the periodic table.  A modal dialog box, About, is then constructed and accepts two parameters: the dialog template name (see <a href="#019b_0013">Listing Three</A>, page 134) and a pointer that identifies the current object, CPTDialog.  DoModal() is the member function that runs the dialog box.<P>
The third message in the map is just one of four combo-box/edit-field notification messages trapped by PT.  By keeping track of which field has the input focus, PT can determine what kind of information the user wants to search on: the element name, symbol, atomic number, or atomic weight.  The search is performed by CPTDialog::GetPTData() in <a href="#019b_0011"> Listing Two</A>.<P>
The fourth message starts a long list of element IDs and their associated display functions.  I've identified the dialog button ID as H, instead of IDD_H (per Microsoft naming convention).  In the context of PT the IDD_ prefix seemed redundant and would not enhance code readability.  Also, it would have been natural to assign each element's button ID to their respective atomic numbers, starting with one for Hydrogen and ending with 109 for Une, but I couldn't.  Microsoft reserves ID numbers below 100 (for example, IDOK and IDCANCEL are one and two, respectively), so I defined the element-button IDs as &quot;atomic number+ 100.&quot;<P>
PT data is stored in memory as an array of structures, as shown in <a href="#019b_000c">Figure 5</A>.  The &quot;+1&quot; in the fields indicates they are null terminated.  Setting the 0th element to Null, I filled the array by atomic number, starting with information for Hydrogen as _atom[1] and ending with Une as _atom[109].  CPTDialog::Display() accepts the element button ID as its argument and displays the information corresponding to _atom[elementid- 100].<P>
<h4><a name="019b_000c">Figure 5: Structure used to store PT data.</h4><P>
<pre>
  struct
  {
     unsigned char number;
     char symbol [3+1];
     char element [12+1];
     char weight [9+1];
  }_atom [110];</pre><P>
<P>
<h3><a name="019b_000d">Conclusion<a name="019b_000d"></h3><P>
I've covered only a small, but fundamental, part of MFC.  If you've had the patience and curiosity to pursue the SDK, you won't have a problem coping with MFC.  The most difficult aspects were accepting that WinMain() and Windows procedures were gone, and trusting that significant control hadn't been lost.  Also, locating MFC member functions which paralleled the SDK functions was difficult because, while the SDK Programmer's Reference laid out functions in alphabetical order (flat), the MFC Class Libraries Reference stored member functions in class descriptions (hierarchical); MFC is, after all, object oriented.<P>
Conventional wisdom states that to learn Windows programming and C++, you should study one, then the other, but not both at the same time.  The combined concepts, from the Windows' API to the syntax of C++ to object-oriented programming, would overwhelm most people.  But because MFC and C++ go hand in hand, it now makes good sense to learn and take advantage of both.<P>
<h3><a name="019b_000e">References<a name="019b_000e"></h3><P>
Chiverton, Bob.  &quot;C/C++ Questions &amp; Answers.&quot;  Microsoft Systems Journal (October, 1992).<P>
Microsoft C/C++ Class Libraries Reference.  Microsoft Corp., 1991.<P>
&quot;Reference Tables for Chemistry.&quot;  New York State Department of Education.<P>


<PRE>


_EXAMINING MFC 2.0_
by Michael Yam

<a name="019b_000f">
<a name="019b_0010"></pre><B>[LISTING ONE]</B><pre><a name="019b_0010">

//----- PT.H - Declares class interfaces for Periodic Table -----
#ifndef __PT_H__
#define __PT_H__

#define PT_MAXELEMENTS  107

class CPTDialog : public CDialog
{
private:
    static BOOL bRegistered;
    static BOOL RegisterPTClass();
    void Display (int iAtomicNumber);
    void GetPTData (int nID);
    char CB_Focus[4];
public:
    CPTDialog();
    void OnClose()
    {
        delete this;
    }
    void OnAbout();
    void OnHelp();
    void OnOK();
    void OnCancel();

    void OnNameSetFocus();
    void OnSymbolSetFocus();
    void OnNumberSetFocus();
    void OnWeightSetFocus();

    void OnH()
    {
        Display (H);
    }
    void OnHe()
    {
        Display (He);
    }
    void OnLi()
    {
        Display (Li);
    }
    void OnBe()
    {
        Display (Be);
    }
    void OnB()
    {
        Display (B);
    }
    void OnC()
    {
        Display (C);
    }
    void OnN()
    {
        Display (N);
    }
    void OnO()
    {
        Display (O);
    }
    void OnF()
    {
        Display (F);
    }
    void OnNe()
    {
        Display (Ne);
    }
    void OnNa()
    {
        Display (Na);
    }
    void OnMg()
    {
        Display (Mg);
    }
    void OnAl()
    {
        Display (Al);
    }
    void OnSi()
    {
        Display (Si);
    }
    void OnP()
    {
        Display (P);
    }
    void OnS()
    {
        Display (S);
    }
    void OnCl()
    {
        Display (Cl);
    }
    void OnAr()
    {
        Display (Ar);
    }
    void OnK()
    {
        Display (K);
    }
    void OnCa()
    {
        Display (Ca);
    }
    void OnSc()
    {
        Display (Sc);
    }
    void OnTi()
    {
        Display (Ti);
    }
    void OnV()
    {
        Display (V);
    }
    void OnCr()
    {
        Display (Cr);
    }
    void OnMn()
    {
        Display (Mn);
    }
    void OnFe()
    {
        Display (Fe);
    }
    void OnCo()
    {
        Display (Co);
    }
    void OnNi()
    {
        Display (Ni);
    }
    void OnCu()
    {
        Display (Cu);
    }
    void OnZn()
    {
        Display (Zn);
    }
    void OnGa()
    {
        Display (Ga);
    }
    void OnGe()
    {
        Display (Ge);
    }
    void OnAs()
    {
        Display (As);
    }
    void OnSe()
    {
        Display (Se);
    }
    void OnBr()
    {
        Display (Br);
    }
    void OnKr()
    {
        Display (Kr);
    }
    void OnRb()
    {
        Display (Rb);
    }
    void OnSr()
    {
        Display (Sr);
    }
    void OnY()
    {
        Display (Y);
    }
    void OnZr()
    {
        Display (Zr);
    }
    void OnNb()
    {
        Display (Nb);
    }
    void OnMo()
    {
        Display (Mo);
    }
    void OnTc()
    {
        Display (Tc);
    }
    void OnRu()
    {
        Display (Ru);
    }
    void OnRh()
    {
        Display (Rh);
    }
    void OnPd()
    {
        Display (Pd);
    }
    void OnAg()
    {
        Display (Ag);
    }
    void OnCd()
    {
        Display (Cd);
    }
    void OnIn()
    {
        Display (In);
    }
    void OnSn()
    {
        Display (Sn);
    }
    void OnSb()
    {
        Display (Sb);
    }
    void OnTe()
    {
        Display (Te);
    }
    void OnI()
    {
        Display (I);
    }
    void OnXe()
    {
        Display (Xe);
    }
    void OnCs()
    {
        Display (Cs);
    }
    void OnBa()
    {
        Display (Ba);
    }
    void OnLa()
    {
        Display (La);
    }
    void OnCe()
    {
        Display (Ce);
    }
    void OnPr()
    {
        Display (Pr);
    }
    void OnNd()
    {
        Display (Nd);
    }
    void OnPm()
    {
        Display (Pm);
    }
    void OnSm()
    {
        Display (Sm);
    }
    void OnEu()
    {
        Display (Eu);
    }
    void OnGd()
    {
        Display (Gd);
    }
    void OnTb()
    {
        Display (Tb);
    }
    void OnDy()
    {
        Display (Dy);
    }
    void OnHo()
    {
        Display (Ho);
    }
    void OnEr()
    {
        Display (Er);
    }
    void OnTm()
    {
        Display (Tm);
    }
    void OnYb()
    {
        Display (Yb);
    }
    void OnLu()
    {
        Display (Lu);
    }
    void OnHf()
    {
        Display (Hf);
    }
    void OnTa()
    {
        Display (Ta);
    }
    void OnW()
    {
        Display (W);
    }
    void OnRe()
    {
        Display (Re);
    }
    void OnOs()
    {
        Display (Os);
    }
    void OnIr()
    {
        Display (Ir);
    }
    void OnPt()
    {
        Display (Pt);
    }
    void OnAu()
    {
        Display (Au);
    }
    void OnHg()
    {
        Display (Hg);
    }
    void OnTl()
    {
        Display (Tl);
    }
    void OnPb()
    {
        Display (Pb);
    }
    void OnBi()
    {
        Display (Bi);
    }
    void OnPo()
    {
        Display (Po);
    }
    void OnAt()
    {
        Display (At);
    }
    void OnRn()
    {
        Display (Rn);
    }
    void OnFr()
    {
        Display (Fr);
    }
    void OnRa()
    {
        Display (Ra);
    }
    void OnAc()
    {
        Display (Ac);
    }
    void OnTh()
    {
        Display (Th);
    }
    void OnPa()
    {
        Display (Pa);
    };
    void OnU()
    {
        Display (U);
    }
    void OnNp()
    {
        Display (Np);
    }
    void OnPu()
    {
        Display (Pu);
    }
    void OnAm()
    {
        Display (Am);
    }
    void OnCm()
    {
        Display (Cm);
    }
    void OnBk()
    {
        Display (Bk);
    }
    void OnCf()
    {
        Display (Cf);
    }
    void OnEs()
    {
        Display (Es);
    }
    void OnFm()
    {
        Display (Fm);
    }
    void OnMd()
    {
        Display (Md);
    }
    void OnNo()
    {
        Display (No);
    }
    void OnLr()
    {
        Display (Lr);
    }
    void OnUnq()
    {
        Display (Unq);
    }
    void OnUnp()
    {
        Display (Unp);
    }
    void OnUnh()
    {
        Display (Unh);
    }
    void OnUns()
    {
        Display (Uns);
    }
    void OnUno()
    {
        Display (Uno);
    }
    void OnUne()
    {
        Display (Une);
    }
    DECLARE_MESSAGE_MAP()
};
class CTheApp : public CWinApp
{
public:
    BOOL InitInstance();
};
// Data stored in memory as an array of structures: _atom[]. Weights in
// parens correspond to atoms of most stable isotope. Data retrieved from
// &quot;Reference Tables for Chemistry,&quot; SUNY, State Education Dept., Albany, NY  12234.
struct
{
    unsigned char number;           // atomic number
    char symbol[3+1];               // three char symbol plus null
    char element[12+1];             // full name plus null
    char weight[9+1];               // atomic weight
}_atom[] = {
     0, &quot;&quot;,   &quot;&quot;,                &quot;&quot;,
     1, &quot;H&quot; , &quot;Hydrogen&quot;,        &quot;1.0079&quot;,
     2, &quot;He&quot;, &quot;Helium&quot;,          &quot;4.00260&quot;,
     3, &quot;Li&quot;, &quot;Lithium&quot;,         &quot;6.941&quot;,
     4, &quot;Be&quot;, &quot;Beryllium&quot;,       &quot;9.01218&quot;,
     5, &quot;B&quot; , &quot;Boron&quot;,           &quot;10.81&quot;,
     6, &quot;C&quot; , &quot;Carbon&quot;,          &quot;12.011&quot;,
     7, &quot;N&quot; , &quot;Nitrogen&quot;,        &quot;14.0067&quot;,
     8, &quot;O&quot; , &quot;Oxygen&quot;,          &quot;15.9994&quot;,
     9, &quot;F&quot; , &quot;Fluorine&quot;,        &quot;18.998403&quot;,
    10, &quot;Ne&quot;, &quot;Neon&quot;,            &quot;20.179&quot;,
    11, &quot;Na&quot;, &quot;Sodium&quot;,          &quot;22.98977&quot;,
    12, &quot;Mg&quot;, &quot;Magnesium&quot;,       &quot;24.305&quot;,
    13, &quot;Al&quot;, &quot;Aluminum&quot;,        &quot;26.98154&quot;,
    14, &quot;Si&quot;, &quot;Silicon&quot;,         &quot;28.0855&quot;,
    15, &quot;P&quot; , &quot;Phosphorus&quot;,      &quot;30.97376&quot;,
    16, &quot;S&quot; , &quot;Sulfur&quot;,          &quot;32.06&quot;,
    17, &quot;Cl&quot;, &quot;Chlorine&quot;,        &quot;35.453&quot;,
    18, &quot;Ar&quot;, &quot;Argon&quot;,           &quot;39.948&quot;,
    19, &quot;K&quot; , &quot;Potassium&quot;,       &quot;39.0983&quot;,
    20, &quot;Ca&quot;, &quot;Calcium&quot;,         &quot;40.08&quot;,
    21, &quot;Sc&quot;, &quot;Scandium&quot;,        &quot;44.9559&quot;,
    22, &quot;Ti&quot;, &quot;Titanium&quot;,        &quot;47.90&quot;,
    23, &quot;V&quot; , &quot;Vanadium&quot;,        &quot;50.9414&quot;,
    24, &quot;Cr&quot;, &quot;Chromium&quot;,        &quot;51.996&quot;,
    25, &quot;Mn&quot;, &quot;Manganese&quot;,       &quot;54.9830&quot;,
    26, &quot;Fe&quot;, &quot;Iron&quot;,            &quot;55.847&quot;,
    27, &quot;Co&quot;, &quot;Cobalt&quot;,          &quot;58.9332&quot;,
    28, &quot;Ni&quot;, &quot;Nickel&quot;,          &quot;58.70&quot;,
    29, &quot;Cu&quot;, &quot;Copper&quot;,          &quot;63.546&quot;,
    30, &quot;Zn&quot;, &quot;Zinc&quot;,            &quot;65.38&quot;,
    31, &quot;Ga&quot;, &quot;Gallium&quot;,         &quot;69.72&quot;,
    32, &quot;Ge&quot;, &quot;Germanium&quot;,       &quot;72.59&quot;,
    33, &quot;As&quot;, &quot;Arsenic&quot;,         &quot;74.9216&quot;,
    34, &quot;Se&quot;, &quot;Selenium&quot;,        &quot;78.96&quot;,
    35, &quot;Br&quot;, &quot;Bromine&quot;,         &quot;79.904&quot;,
    36, &quot;Kr&quot;, &quot;Krypton&quot;,         &quot;83.80&quot;,
    37, &quot;Rb&quot;, &quot;Rubidium&quot;,        &quot;85.4678&quot;,
    38, &quot;Sr&quot;, &quot;Strontium&quot;,       &quot;87.62&quot;,
    39, &quot;Y&quot; , &quot;Yttrium&quot;,         &quot;88.9059&quot;,
    40, &quot;Zr&quot;, &quot;Zirconium&quot;,       &quot;91.22&quot;,
    41, &quot;Nb&quot;, &quot;Niobium&quot;,         &quot;92.9064&quot;,
    42, &quot;Mo&quot;, &quot;Molybdenum&quot;,      &quot;95.94&quot;,
    43, &quot;Tc&quot;, &quot;Technetium&quot;,      &quot;(97)&quot;,
    44, &quot;Ru&quot;, &quot;Ruthenium&quot;,       &quot;101.07&quot;,
    45, &quot;Rh&quot;, &quot;Rhodium&quot;,         &quot;102.9055&quot;,
    46, &quot;Pd&quot;, &quot;Palladium&quot;,       &quot;106.4&quot;,
    47, &quot;Ag&quot;, &quot;Silver&quot;,          &quot;107.868&quot;,
    48, &quot;Cd&quot;, &quot;Cadmium&quot;,         &quot;112.41&quot;,
    49, &quot;In&quot;, &quot;Indium&quot;,          &quot;114.82&quot;,
    50, &quot;Sn&quot;, &quot;Tin&quot;,             &quot;118.69&quot;,
    51, &quot;Sb&quot;, &quot;Antimony&quot;,        &quot;121.75&quot;,
    52, &quot;Te&quot;, &quot;Tellurium&quot;,       &quot;127.60&quot;,
    53, &quot;I&quot; , &quot;Iodine&quot;,          &quot;126.9045&quot;,
    54, &quot;Xe&quot;, &quot;Xenon&quot;,           &quot;131.30&quot;,
    55, &quot;Cs&quot;, &quot;Cesium&quot;,          &quot;132.9054&quot;,
    56, &quot;Ba&quot;, &quot;Barium&quot;,          &quot;137.33&quot;,
    57, &quot;La&quot;, &quot;Lanthium&quot;,        &quot;138.9055&quot;,
    58, &quot;Ce&quot;, &quot;Cerium&quot;,          &quot;140.12&quot;,
    59, &quot;Pr&quot;, &quot;Praseodymium&quot;,    &quot;140.9077&quot;,
    60, &quot;Nd&quot;, &quot;Neodymium&quot;,       &quot;144.24&quot;,
    61, &quot;Pm&quot;, &quot;Promethium&quot;,      &quot;(145)&quot;,
    62, &quot;Sm&quot;, &quot;Samarium&quot;,        &quot;150.4&quot;,
    63, &quot;Eu&quot;, &quot;Europium&quot;,        &quot;151.96&quot;,
    64, &quot;Gd&quot;, &quot;Gadolinium&quot;,      &quot;157.25&quot;,
    65, &quot;Tb&quot;, &quot;Terbium&quot;,         &quot;158.9254&quot;,
    66, &quot;Dy&quot;, &quot;Dysprosium&quot;,      &quot;162.50&quot;,
    67, &quot;Ho&quot;, &quot;Holmium&quot;,         &quot;164.9304&quot;,
    68, &quot;Er&quot;, &quot;Erbium&quot;,          &quot;167.26&quot;,
    69, &quot;Tm&quot;, &quot;Thulium&quot;,         &quot;168.9342&quot;,
    70, &quot;Yb&quot;, &quot;Ytterbium&quot;,       &quot;173.04&quot;,
    71, &quot;Lu&quot;, &quot;Lutetium&quot;,        &quot;174.97&quot;,
    72, &quot;Hf&quot;, &quot;Hafnium&quot;,         &quot;178.49&quot;,
    73, &quot;Ta&quot;, &quot;Tantalum&quot;,        &quot;180.9479&quot;,
    74, &quot;W&quot; , &quot;Tungsten&quot;,        &quot;183.85&quot;,
    75, &quot;Re&quot;, &quot;Rhenium&quot;,         &quot;186.207&quot;,
    76, &quot;Os&quot;, &quot;Osmium&quot;,          &quot;190.2&quot;,
    77, &quot;Ir&quot;, &quot;Iridium&quot;,         &quot;192.22&quot;,
    78, &quot;Pt&quot;, &quot;Platinum&quot;,        &quot;195.09&quot;,
    79, &quot;Au&quot;, &quot;Gold&quot;,            &quot;196.9665&quot;,
    80, &quot;Hg&quot;, &quot;Mercury&quot;,         &quot;200.59&quot;,
    81, &quot;Tl&quot;, &quot;Thallium&quot;,        &quot;204.37&quot;,
    82, &quot;Pb&quot;, &quot;Lead&quot;,            &quot;207.2&quot;,
    83, &quot;Bi&quot;, &quot;Bismuth&quot;,         &quot;208.9804&quot;,
    84, &quot;Po&quot;, &quot;Polonium&quot;,        &quot;(209)&quot;,
    85, &quot;At&quot;, &quot;Astatine&quot;,        &quot;(210)&quot;,
    86, &quot;Rn&quot;, &quot;Radon&quot;,           &quot;(222)&quot;,
    87, &quot;Fr&quot;, &quot;Francium&quot;,        &quot;(223)&quot;,
    88, &quot;Ra&quot;, &quot;Radium&quot;,          &quot;226.0254&quot;,
    89, &quot;Ac&quot;, &quot;Actinium&quot;,        &quot;(227)&quot;,
    90, &quot;Th&quot;, &quot;Thorium&quot;,         &quot;232.0381&quot;,
    91, &quot;Pa&quot;, &quot;Protactinium&quot;,    &quot;231.0359&quot;,
    92, &quot;U&quot; , &quot;Uranium&quot;,         &quot;238.029&quot;,
    93, &quot;Np&quot;, &quot;Neptunium&quot;,       &quot;237.0482&quot;,
    94, &quot;Pu&quot;, &quot;Plutonium&quot;,       &quot;(244)&quot;,
    95, &quot;Am&quot;, &quot;Americium&quot;,       &quot;(243)&quot;,
    96, &quot;Cm&quot;, &quot;Curium&quot;,          &quot;(247)&quot;,
    97, &quot;Bk&quot;, &quot;Berkelium&quot;,       &quot;(247)&quot;,
    98, &quot;Cf&quot;, &quot;Californium&quot;,     &quot;(251)&quot;,
    99, &quot;Es&quot;, &quot;Einsteinium&quot;,     &quot;(254)&quot;,
   100, &quot;Fm&quot;, &quot;Fermium&quot;,         &quot;(257)&quot;,
   101, &quot;Md&quot;, &quot;Mendelevium&quot;,     &quot;(258)&quot;,
   102, &quot;No&quot;, &quot;Nobelium&quot;,        &quot;(255)&quot;,
   103, &quot;Lr&quot;, &quot;Lawrencium&quot;,      &quot;(260)&quot;,
   104, &quot;Unq&quot;,&quot;Unq&quot;,             &quot;(261)&quot;,
   105, &quot;Unp&quot;,&quot;Unp&quot;,             &quot;(262)&quot;,
   106, &quot;Unh&quot;,&quot;Unh&quot;,             &quot;(263)&quot;,
   107, &quot;Uns&quot;,&quot;Uns&quot;,             &quot;(262)&quot;,
   108, &quot;Uno&quot;,&quot;Uno&quot;,             &quot;?.?&quot;,
   109, &quot;Une&quot;,&quot;Une&quot;,             &quot;?.?&quot;,
};
#endif  // __PT_H__





<a name="019b_0011">
<a name="019b_0012"></pre><B>[LISTING TWO]</B><pre><a name="019b_0012">

//----- PT.CPP - Periodic Table for Windows -------
#include &lt;afxwin.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;math.h&gt;
#include &lt;string.h&gt;

#include &quot;resource.h&quot;
#include &quot;pt.h&quot;

BOOL CPTDialog::bRegistered = FALSE;

//------ CPTDialog -- Registers our class if necessary, constructs the
//                    dialog object, and populates the combo boxes.
CPTDialog::CPTDialog()
{
    int i;
    if (!bRegistered)
        bRegistered = RegisterPTClass();
    Create (&quot;pt&quot;);
    for (i=1; i&lt;=PT_MAXELEMENTS; ++i)
    {
        CWnd::SendDlgItemMessage (IDD_ELEMENTNAME, CB_ADDSTRING,
                            0, (LONG)(LPSTR)_atom[i].element);
        CWnd::SendDlgItemMessage (IDD_ELEMENTSYMBOL, CB_ADDSTRING,
                            0, (LONG)(LPSTR)_atom[i].symbol);
    }
    // No combo-box has focus.
    memset (CB_Focus, 0, sizeof (CB_Focus));
}
//----- RegisterPTClass -- Register PT dialog class and replace the default
//      white box icon with our own.
//      Returns: nonzero if class is registered. 0 if class is not registered.
BOOL CPTDialog::RegisterPTClass()
{
    WNDCLASS wndclass;
    wndclass.style = 0;
    wndclass.lpfnWndProc = DefDlgProc;  /* use default dialog proc */
    wndclass.cbClsExtra = 0;
    // This field MUST be set to DLGWINDOWEXTRA, or this class we're
    // registering won't work properly with our dialog boxes.
    // MUST be set to DLGWINDOWEXTRA or class won't work properly
    wndclass.cbWndExtra = DLGWINDOWEXTRA ;
    // Use MFC global function to retrieve app's instance.
    wndclass.hInstance = AfxGetInstanceHandle();
    // Load custom icon, cursor, set background, load menu
    wndclass.hIcon = ::LoadIcon (AfxGetInstanceHandle(), &quot;PTICON&quot;);
    wndclass.hCursor = ::LoadCursor (NULL, IDC_ARROW) ;
    wndclass.hbrBackground  = COLOR_WINDOW + 1 ;
    wndclass.lpszMenuName   = &quot;PTMenu&quot;;
    // Need unique name here.  Name must be used in dialog box
    // template in DIALOGS.DLG to force dialog box to use this class.
    wndclass.lpszClassName  = &quot;PTDLGCLASS&quot;;
    return ::RegisterClass(&amp;wndclass);
}
//--- GetPTData -- Retrieve and display data based on location of input focus:
//  name, symbol, atomic number, or atomic weight. Accepts control ID as input.
void CPTDialog::GetPTData (int nID)
{
    char buffer[20];
    char *pWeight;
    double fBuffer;
    int i, bytes;
    bytes = CWnd::GetDlgItemText (nID, (LPSTR)buffer, sizeof(buffer));
    if (bytes &gt; 0)
    {
        switch (nID)
        {
        case IDD_ELEMENTNAME:
            for (i=1; i&lt;=PT_MAXELEMENTS; ++i)
            {
                if (_stricmp (buffer, _atom[i].element) == 0)
                    break;
            }
            break;
        case IDD_ELEMENTSYMBOL:
            for (i=1; i&lt;=PT_MAXELEMENTS; ++i)
            {
                if (_stricmp (buffer, _atom[i].symbol) == 0)
                    break;
            }
            break;
        case IDD_ATOMICNUMBER:
            i = atoi (buffer);
            break;
        case IDD_ATOMICWEIGHT:
            //  Atomic weights stored as strings.  Convert
            //  to floating point to do comparisons.
            fBuffer = atof (buffer);
            for (i=1; i&lt;=PT_MAXELEMENTS; ++i)
            {
                //  Some weights are in parens.
                //  Skip over them if detected.
                if (_atom[i].weight[0] != '(')
                    pWeight = _atom[i].weight;
                else
                    pWeight = &amp;_atom[i].weight[1];

                if (atof (pWeight) &gt;= fBuffer)
                    break;
            }
            break;
        default:
            i = 0;
            break;
        }
        //  i contains the index into the array of structures: _atom[i].xxxx
        if (i &lt;= PT_MAXELEMENTS &amp;&amp; i &gt; 0)
            Display (i+100);
        else
            MessageBox (&quot;Selected element not found in periodic table.&quot;,
                        &quot;Error&quot;,
                        MB_OK | MB_ICONEXCLAMATION);
    }
}
//  OnNameSetFocus -- OnSymbolSetFocus -- OnNumberSetFocus -- OnWeightSetFocus
//    These functions keep track of which field has input focus. Fields are
//    mapped to array CB_Focus[]. If user clicks on any edit fields or type
//    in any data, blank out any existing data with Display (100).
void CPTDialog::OnNameSetFocus()
{
    Display (100);
    memset (CB_Focus, 0, sizeof(CB_Focus));
    CB_Focus[0] = 1;
}
void CPTDialog::OnSymbolSetFocus()
{
    Display (100);
    memset (CB_Focus, 0, sizeof(CB_Focus));
    CB_Focus[1] = 1;
}
void CPTDialog::OnNumberSetFocus()
{
    Display (100);
    memset (CB_Focus, 0, sizeof(CB_Focus));
    CB_Focus[2] = 1;
}
void CPTDialog::OnWeightSetFocus()
{
    Display (100);
    memset (CB_Focus, 0, sizeof(CB_Focus));
    CB_Focus[3] = 1;
}
//  OnCancel -- User pressed the &quot;Cancel&quot; button.  Terminate program.
void CPTDialog::OnCancel()
{
    delete this;
}
//  OnOK -- User pressed the &quot;OK&quot; button.  Retrieve element info
//          based on the edit box which has the input focus.
void CPTDialog::OnOK()
{
    //  CB_Focus tracks which edit box user entered data.  GetPTData
    //  searches for that data.
    if (CB_Focus[0])
        GetPTData (IDD_ELEMENTNAME);
    else if (CB_Focus[1])
        GetPTData (IDD_ELEMENTSYMBOL);
    else if (CB_Focus[2])
        GetPTData (IDD_ATOMICNUMBER);
    else
        GetPTData (IDD_ATOMICWEIGHT);
}
//  OnAbout -- User selected &quot;About&quot; from menu.  Open a modal dialog
//      box and tell user about this program.
void CPTDialog::OnAbout()
{
   CModalDialog about( &quot;AboutBox&quot;, this );
   about.DoModal();
}
//  OnHelp -- User selected help from the menu.  Open a modal dialog
//      box and display help info.
void CPTDialog::OnHelp()
{
    CModalDialog version (&quot;HelpBox&quot;, this);
    version.DoModal();
}
//  Display -- Display element info in the edit boxes using &quot;SetDlgItemText&quot;
void CPTDialog::Display(int iAtomicNumber)
{
    char szNumber[4];
   // Atomic numbers range from 1-108; to avoid conflict with IDOK and IDCANCEL
   // (1 &amp; 2), 100 is added to atomic numbers. Adjust before indexing array.
    iAtomicNumber -= 100;
    //  Convert atomic number from numeric to string.
    if (iAtomicNumber &lt;= 0)                        /* too small */
        memset (szNumber, 0, sizeof (szNumber));
    else if (iAtomicNumber &gt; PT_MAXELEMENTS)       /* too big */
        sprintf (szNumber, &quot;%3d&quot;, PT_MAXELEMENTS);
    else                                           /* juuust right */
        sprintf (szNumber, &quot;%3d&quot;, _atom [iAtomicNumber].number);
    CWnd::SetDlgItemText (IDD_ELEMENTNAME, _atom [iAtomicNumber].element);
    CWnd::SetDlgItemText (IDD_ELEMENTSYMBOL, _atom [iAtomicNumber].symbol);
    CWnd::SetDlgItemText (IDD_ATOMICNUMBER, szNumber);
    CWnd::SetDlgItemText (IDD_ATOMICWEIGHT, _atom [iAtomicNumber].weight);
}
//    MESSAGE MAP
BEGIN_MESSAGE_MAP (CPTDialog, CDialog)
    ON_WM_CLOSE ()
    ON_COMMAND (IDM_ABOUT, OnAbout)
    ON_COMMAND (IDM_HELP, OnHelp)
    ON_COMMAND (IDCANCEL, OnCancel)
    ON_COMMAND (IDOK, OnOK)
    ON_CBN_SETFOCUS  (IDD_ELEMENTNAME, OnNameSetFocus)
    ON_CBN_SETFOCUS  (IDD_ELEMENTSYMBOL, OnSymbolSetFocus)
    ON_EN_SETFOCUS  (IDD_ATOMICNUMBER, OnNumberSetFocus)
    ON_EN_SETFOCUS  (IDD_ATOMICWEIGHT, OnWeightSetFocus)
    ON_COMMAND (H, OnH)
    ON_COMMAND (He, OnHe)
    ON_COMMAND (Li, OnLi)
    ON_COMMAND (Be, OnBe)
    ON_COMMAND (B, OnB)
    ON_COMMAND (C, OnC)
    ON_COMMAND (N, OnN)
    ON_COMMAND (O, OnO)
    ON_COMMAND (F, OnF)
    ON_COMMAND (Ne,OnNe)
    ON_COMMAND (Na, OnNa)
    ON_COMMAND (Mg, OnMg)
    ON_COMMAND (Al, OnAl)
    ON_COMMAND (Si, OnSi)
    ON_COMMAND (P, OnP)
    ON_COMMAND (S, OnS)
    ON_COMMAND (Cl, OnCl)
    ON_COMMAND (Ar, OnAr)
    ON_COMMAND (K, OnK)
    ON_COMMAND (Ca, OnCa)
    ON_COMMAND (Sc, OnSc)
    ON_COMMAND (Ti, OnTi)
    ON_COMMAND (V, OnV)
    ON_COMMAND (Cr, OnCr)
    ON_COMMAND (Mn, OnMn)
    ON_COMMAND (Fe, OnFe)
    ON_COMMAND (Co, OnCo)
    ON_COMMAND (Ni, OnNi)
    ON_COMMAND (Cu, OnCu)
    ON_COMMAND (Zn, OnZn)
    ON_COMMAND (Ga, OnGa)
    ON_COMMAND (Ge, OnGe)
    ON_COMMAND (As, OnAs)
    ON_COMMAND (Se, OnSe)
    ON_COMMAND (Br, OnBr)
    ON_COMMAND (Kr, OnKr)
    ON_COMMAND (Rb, OnRb)
    ON_COMMAND (Sr, OnSr)
    ON_COMMAND (Y, OnY)
    ON_COMMAND (Zr, OnZr)
    ON_COMMAND (Nb, OnNb)
    ON_COMMAND (Mo, OnMo)
    ON_COMMAND (Tc, OnTc)
    ON_COMMAND (Ru, OnRu)
    ON_COMMAND (Rh, OnRh)
    ON_COMMAND (Pd, OnPd)
    ON_COMMAND (Ag, OnAg)
    ON_COMMAND (Cd, OnCd)
    ON_COMMAND (In, OnIn)
    ON_COMMAND (Sn, OnSn)
    ON_COMMAND (Sb, OnSb)
    ON_COMMAND (Te, OnTe)
    ON_COMMAND (I, OnI)
    ON_COMMAND (Xe, OnXe)
    ON_COMMAND (Cs, OnCs)
    ON_COMMAND (Ba, OnBa)
    ON_COMMAND (La, OnLa)
    ON_COMMAND (Ce, OnCe)
    ON_COMMAND (Pr, OnPr)
    ON_COMMAND (Nd, OnNd)
    ON_COMMAND (Pm, OnPm)
    ON_COMMAND (Sm, OnSm)
    ON_COMMAND (Eu, OnEu)
    ON_COMMAND (Gd, OnGd)
    ON_COMMAND (Tb, OnTb)
    ON_COMMAND (Dy, OnDy)
    ON_COMMAND (Ho, OnHo)
    ON_COMMAND (Er, OnEr)
    ON_COMMAND (Tm, OnTm)
    ON_COMMAND (Yb, OnYb)
    ON_COMMAND (Lu, OnLu)
    ON_COMMAND (Hf, OnHf)
    ON_COMMAND (Ta, OnTa)
    ON_COMMAND (W, OnW)
    ON_COMMAND (Re, OnRe)
    ON_COMMAND (Os, OnOs)
    ON_COMMAND (Ir, OnIr)
    ON_COMMAND (Pt, OnPt)
    ON_COMMAND (Au, OnAu)
    ON_COMMAND (Hg, OnHg)
    ON_COMMAND (Tl, OnTl)
    ON_COMMAND (Pb, OnPb)
    ON_COMMAND (Bi, OnBi)
    ON_COMMAND (Po, OnPo)
    ON_COMMAND (At, OnAt)
    ON_COMMAND (Rn, OnRn)
    ON_COMMAND (Fr, OnFr)
    ON_COMMAND (Ra, OnRa)
    ON_COMMAND (Ac, OnAc)
    ON_COMMAND (Th, OnTh)
    ON_COMMAND (Pa, OnPa)
    ON_COMMAND (U, OnU)
    ON_COMMAND (Np, OnNp)
    ON_COMMAND (Pu, OnPu)
    ON_COMMAND (Am, OnAm)
    ON_COMMAND (Cm, OnCm)
    ON_COMMAND (Bk, OnBk)
    ON_COMMAND (Cf, OnCf)
    ON_COMMAND (Es, OnEs)
    ON_COMMAND (Fm, OnFm)
    ON_COMMAND (Md, OnMd)
    ON_COMMAND (No, OnNo)
    ON_COMMAND (Lr, OnLr)
    ON_COMMAND (Unq, OnUnq)
    ON_COMMAND (Unp, OnUnp)
    ON_COMMAND (Unh, OnUnh)
    ON_COMMAND (Uns, OnUns)
    ON_COMMAND (Uno, OnUno)
    ON_COMMAND (Une, OnUne)
END_MESSAGE_MAP()

//  Create the application object
CTheApp theApp;
//  InitInstance -- Make CPTDialog object the main window by assigning
//      m_pMainWnd to constructor.  Returns:    TRUE
BOOL CTheApp::InitInstance()
{
   m_pMainWnd = new CPTDialog();
   m_pMainWnd-&gt;ShowWindow( m_nCmdShow );
   m_pMainWnd-&gt;UpdateWindow();

   return TRUE;
}




<a name="019b_0013">
<a name="019b_0014"></pre><B>[LISTING THREE]</B><pre><a name="019b_0014">

//----- PT.RC - Resources for Periodic Table -----
#include &lt;windows.h&gt;
#include &lt;afxres.h&gt;
#include &quot;resource.h&quot;

PTICON      ICON    pt.ico
PTMenu MENU
{
    POPUP       &quot;&amp;Help&quot;
    {
        MENUITEM &quot;&amp;General Information&quot;, IDM_HELP
        MENUITEM &quot;&amp;About Periodic Table&quot;, IDM_ABOUT
    }
}
rcinclude dialogs.dlg        // file generated by MS Dialog Editor
//------- End of PT.RC -------


</PRE>


<HR><P>Copyright &copy; 1993, <I>Dr. Dobb's Journal</I></P></BODY></HTML>

