<HTML>
<META NAME="year" CONTENT="1993">
<HEAD>
<TITLE>OCT93: Comparing Object-oriented Languages</TITLE></HEAD>
<BODY BGCOLOR="#ffffff">
<h1>Comparing Object-oriented Languages<a name="02df_0003"></h1><P>
<h2><a name="02df_0001"><a name="02df_0000">The familiar linked-list is a good yardstick for comparison</h2><P>
<h3>Michael Floyd</h3><P>
<p><i><a name="02df_0002"><a name="02df_0000">Mike is executive editor for <I>DDJ</I> and can be contacted through the <I>DDJ</I> offices or on CompuServe at 76703,4057.</i></p><hr><P>
While many programmers proclaim C++ to be <I>the</I> object-oriented language of the '90s, others find the quest for the perfect language to be elusive. In fact, deciding on the right language can be downright confusing. &quot;Pure&quot; OO languages like Smalltalk include a rich set of reusable classes, while hybrids such as C++ force you to roll your own. Languages such as Eiffel promote (or impose) their notion of software correctness, which is supported by the syntax of the language. Some languages are compiled, others interpreted, and a couple even provide both. Additionally, many languages are adding support for concurrency and multithreading. And while most languages are general purpose, others like Drool are context-specific. In short, there's an endless choice of options and the right language largely depends upon your specific needs.<P>
To aid in your search, <I>DDJ </I>invited a number of programmers to implement a simple linked-list class in their favorite language. The linked-list was chosen because it's widely used and understood, making it easier to compare how different languages, approach a given problem. This, in effect, allows the code to speak for itself. To this end, you can examine and compare approaches in C++. Smalltalk, Eiffel, Sather, Objective-C, Parasol, Beta, Turbo Pascal, C+@, Liana, Ada, and, yes, even Drool.<P>
<h3><a name="02df_0004">Specifications and Requirements<a name="02df_0004"></h3><P>
Because most traditional compiled languages bind data elements at compile time, linked-lists are usually homogenous; that is, a given list can only store elements of a single data type. Consequently, programmers are constantly rewriting linked-list code to support new and different data types, and applications must duplicate code that manages these lists. Object-oriented languages provide run-time binding (often called &quot;late&quot; or &quot;dynamic binding&quot;) which allows the binding of data elements to be deferred. This feature, which allows the creation of a heterogeneous list, lets you store different object types.<P>
We asked our participants to create a double-ended linked-list class that's capable of handling multiple object types. The class needed to include methods for creating a new list, adding a list element to the end of the list, and printing individual list elements. Of course, a full-featured linked-list class would require methods to get the next and previous elements, get the head and tail of the list, append, delete, count elements in the list, check for an empty list, and iterators to iterate over the elements in the list. <I>DDJ</I> contributing editor David Betz supplied the C++ version (see <a href="#02df_0009">Listing One</A>, page 118), which served as an admittedly less-than-scientific specification. We asked our various programmers to duplicate the functionality of <a href="#02df_0009">Listing One</A>, although not necessarily the program structure or even variable names. This allowed them to approach the linked-list problem in the manner natural to each language.<P>
Since linked-lists are well-known and widely used dynamic data structures, I won't belabor Listing One's code; however, I will point out, that <a href="#02df_0009">Listing One</A> declares two object types, <I>MyNumber </I>and <I>MyPoint.</I> <I>main()</I> constructs instances of both objects and stores them in their respective lists--numbers are stored in <I>list1</I> and points are placed in <I>list2</I>. To demonstrate that the lists are heterogeneous, <I>main()</I> also places points in <I>list1</I> numbers in <I>list2</I>, and finishes off by storing <I>list1</I> in <I>list2</I>. Finally, the lists are printed and the program terminates.<P>
<h3><a name="02df_0005">What to Look For<a name="02df_0005"></h3><P>
It was up to the individual programmer to implement the list-manager code which, of course, depends on the facilities available in a particular language. For example, Smalltalk includes an <I>OrderedCollection</I> class that provides most of the functionality required for this project. Therefore, the Smalltalk version in <a href="#02df_0015">Listing Seven</A>, page 122, merely subclasses from class <I>OrderedCollection</I>, and later creates a list instance, instantiates the objects, and adds them to the list. In most languages, however, containers are not a standard part of the language. This is reflected in the number of lines of code for each language.<P>
<a href="#02df_0008">Table 1</A> illustrates this point by summarizing the number of lines of code each language used in the linked-list project. It's important to keep in mind that the line count is a deceiving number since it doesn't reflect the underlying mechanisms being executed. (Not to mention that in most cases blank lines have been deleted simply to conserve space.) Facilities such as a garbage collector, exception handlers, built-in support for collections and containers (as noted above), and inheritance mechanisms all affect the line count. In the case of automatic garbage collection, for example, the compiler allocates and manages memory, which frees the programmer from worries such as orphaned pointers, memory leaks, and the like. It also results in slightly less source code since constructors (if any) are reduced to initializers and destructors go away.<P>
Exception handlers beef up the source code a little, but the gain is worth the pain. Exceptions provide a way of dealing with a failed execution of an instruction or routine. Without an exception handler, the failure may cause the system to terminate unpredictably. In <a href="#02df_0008">Table 1</A>, note that, while exceptions are provided for in Stroustrup's <I>The annotated C++ Reference Manual</I> (often referred to as the ARM), they're still listed as &quot;experimental&quot; and many C++ vendors have yet to implement them.<P>
The most dramatic affect on line count, however, is the syntax of the language. For example, the C++ version makes use of initializers in class declarations: <I>MyListElement()</I> includes {<I>data = initialData;</I>} all on a single line within the declaration. However, the Turbo Pascal version I wrote (<a href="#02df_000d">Listing Three</A>, page 119) initializes data within its <I>MyListElement Init</I> constructor. The constructor requires a minimum of four lines of code. (Note that source code compactness does not translate into fewer instructions.) I could site other example, but you get the idea.<P>
<h3><a name="02df_0006">Programming Notes<a name="02df_0006"></h3><P>
Implementing the linked-list code in Smalltalk can be done in either of two ways. The first approach is to conduct a straightforward translation of the C++ version of Smalltalk. However, an experienced Smalltalk programmer might choose an alternative approach, which is to do the minimum necessary to sat can be done in four lines of code. The test program can be satisfied by a protocol consisting of three methods: Create a list, add an element to a list, and (recursively) print the elements of a list. Most of this behavior is already available in class <I>Ordered-Collection</I>, one of the standard classes in Smalltalk/V. <a href="#02df_0015">Listing Seven</A>, page 122, which was provided by <I>DDJ</I> senior technical editor Ray Valdes, shows how to subclass <I>OrderedCollection</I> and implement the modicum of additional behavior (the <I>printOn:</I> method). Of course, in a real-world setting, a link-list class would require a richer protocol. This would require additional code, as would be the case in the other languages, and would probably require building on top of the from-scratch version shown in <a href="#02df_0017">Listing Eight</A>, page 122, rather than subclassing <I>OrderedCollection</I>.<P>
Also, notice in <a href="#02df_0008">Table 1</A>, that we've included Ada in the linked-list project. While not object oriented, Ada is still considered to be object based. Because Ada currently doesn't support run-time binding, <I>List_Example</I> in <a href="#02df_0021">Listing Thirteen</A> (page 124) can only handle homogenous lists. According to Mike Ruf at Rational Systems, there are ways to simulate run-time polymorphism in Ada83 (see comments in <a href="#02df_0021">Listing Thirteen</A>). It's also worth noting that the next Ada standard is expected to support single inheritance and run-time polymorphism.<P>
<h3><a name="02df_0007">Conclusion<a name="02df_0007"></h3><P>
As you browse the listings you'll find Robert Jervis's Parasol implementation (<a href="#02df_000f">Listing Four</A>, page 120), Jim Fleming's C+@ implementation (<a href="#02df_0011">Listing Five</A>, page 120), a Liana implementation by Jack Krupansky of Base Technology (<a href="#02df_0013">Listing Six</A>, page 121), an Eiffel implementation by Robert Howard of Tower Technology (<a href="#02df_0019">Listing Nine</A>, page 122), a Sather implementation by Stephen Omohundro of ICSI (<a href="#02df_001b">Listing Ten</A>, page 124), a Beta implementation from Steve Mann of MADA (<a href="#02df_001d">Listing Eleven</A>, page 124), and David Betz's Drool (<a href="#02df_001f">Listing Twelve</A>, page 124). You'll also find more coverage on each of the these languages elsewhere in this issue. In addition to the C++, Turbo Pascal, Smalltalk, and Ada listings previously mentioned in this article, Stephen Asbury of Next Computer presents an Objective-C Implementation (<a href="#02df_000b">Listing Two</A>, page 118).<P>
Finally, the linked-list project is not a contest to find the best object-oriented language; rather, it's a window into the soul of each language. And while the number of lines of code may not provide a realistic comparison between languages, it <I>is</I> how many managers gauge programmer productivity. This, in fact, may be the poorest of measures, especially when you factor in code reuse.<P>
<h4><a name="02df_0008">Table 1:<a name="02df_0008"></h4><P>
<pre>

             Garbage                  Late               Exception   Lines of
             Collection  Inheritance  Binding  Compiled  Handling    Code (approx.)
C++          No          Multiple     Yes      C         Yes          85
Objective-C  No          Single       Yes      C         No          120
Turbo Pascal No          Single       Yes      C         No          140
Parasol      No          Single       Yes      C         No           75
C+@          Yes         Multiple     Yes      C         No          110
Liana        Yes         Single       Yes      I         No           33
Smalltalk    Yes         Single       Yes      I/C       No          *44
Eiffel       Yes         Multiple     Yes      **I/C     Yes         155
Sather       Yes         Multiple     Yes      I/C       Yes          80
Beta         Yes         Single       Yes      C         Yes          55
Drool        Yes         Multiple     Yes      Byte Code No           45
Ada          No          ***None      ***No    C         Yes         125

Key object-oriented features. 1=interpreted. C=compiled.
*Line count given is for the minimal implementation; full implementation is 145 lines of code. 
**Eiffel uses its &quot;melting ICE&quot; technology to interpret small chunks of code for testing purposes. 
***The next Ada standard is expected to support both single inheritance and run-time binding.</pre><P>

<PRE>


_COMPARING OBJECT-ORIENTED LANGUAGES_
by Michael Floyd


<a name="02df_0009"><a name="02df_000a"><B>[LISTING ONE]</B>


C++ Implementation by David Betz (Dr. Dobb's Journal)


#include &lt;iostream.h&gt;

/* any object that will appear in a list must inherit from this class */
class MyListData {
public:
    virtual void Print(void);
};
void MyListData::Print(void)
{
    cout &lt;&lt; &quot;No print method!\n&quot;;
}
class MyListElement {
     MyListData *data;
     MyListElement *next;
public:
     MyListElement(MyListData *initialData) { data = initialData; next = nil; }
     friend class MyList;
};
class MyList : public MyListData {
    MyListElement *head;
    MyListElement *tail;
public:
    MyList(void) { head = tail = nil; }
    void AddToList(MyListData *data);
    void Print(void);
};
void MyList::AddToList(MyListData *data)
{
    MyListElement *newElement = new MyListElement(data);
    if (head == nil)
        head = tail = newElement;
    else {
        tail-&gt;next = newElement;
        tail = newElement;
    }
}
void MyList::Print(void)
{
    MyListElement *element;
    for (element = head; element != nil; element = element-&gt;next)
    element-&gt;data-&gt;Print();
}
class MyNumber : public MyListData {
    int value;
public:
    MyNumber(int initialValue) { value = initialValue; }
    virtual void Print(void);
};
void MyNumber::Print(void)
{
    cout &lt;&lt; &quot;Number: &quot; &lt;&lt; value &lt;&lt; &quot;\n&quot;;
}
class MyPoint : public MyListData {
    int x;
    int y;
public:
    MyPoint(int initialX,int initialY) { x = initialX; y = initialY; }
    virtual void Print(void);
};
void MyPoint::Print(void)
{
    cout &lt;&lt; &quot;Point: &quot; &lt;&lt; x &lt;&lt; &quot;,&quot; &lt;&lt; y &lt;&lt; &quot;\n&quot;;
}
void main(void)
{
    MyList *list1 = new MyList;
    MyList *list2 = new MyList;
    MyNumber *n1 = new MyNumber(10);
    MyNumber *n2 = new MyNumber(20);
    MyPoint *p1 = new MyPoint(2,3);
    MyPoint *p2 = new MyPoint(4,5);
    /* build the lists */
    list1-&gt;AddToList(n1);
    list1-&gt;AddToList(n2);
    list1-&gt;AddToList(p1);
    list2-&gt;AddToList(n2);    /* an object can be in more than one list    */
    list2-&gt;AddToList(p1);    /*    at the same time                       */
    list2-&gt;AddToList(p2);
    list2-&gt;AddToList(list1); /* we can even put a list into another list */
    /* print the lists */
    cout &lt;&lt; &quot;list1:\n&quot;;
    list1-&gt;Print();
    cout &lt;&lt; &quot;list2:\n&quot;;
    list2-&gt;Print();
}


<a name="02df_000b"><a name="02df_000c"></pre><B>[LISTING TWO]</B><pre><a name="02df_000c">

Objective-C Implementation by Stephen Asbury (Next Computer)

#import &lt;stdio.h&gt;
#import &lt;objc/Object.h&gt;/* Include the header for the Root class */

@interface LinkedListNode:Object /* declare a node class */
{
    id value;/* a node can store an object of any class as it's
value */
    id next;
}
- setValue:newValue;
- value;
- setNext:newNext;
- next;
- print;
@end
@implementation LinkedListNode /* implement the node class */
- setValue:newValue {value = newValue; return self;}
- value {return value;}
- setNext:newNext {next = newNext; return self;}
- next {return next;}
- print
{   /* In order to allow any object to be added to the list, we first check
    * to see if the value can print, if so have it print */
    if([value respondsTo:@selector(print)] == YES) [value print];
    return self;
}
@end
@interface LinkedList:Object /* declare a linked list class */
{id tail,head;}
- addObjectToList:theObject;
- print;
@end
@implementation LinkedList /* implement the linked list class */
- init /* refine the init method of the super class */
{
    self = [super init];
    tail = head = nil;
    return self;
}
- addNodeToList:newNode /* private method used only by the object */
{
    if(head == nil)
        head = tail = newNode;
    else{
        [tail setNext:newNode];
        tail = newNode;
    }
    return self;
}
- addObjectToList:theObject
{
    id newNode = [[[LinkedListNode alloc] init]
setValue:theObject];
    [self addNodeToList:newNode];
    return self;
}
- print
{
    id element;
    for(element = head;element != nil;element = [element next])
        [element print];
    return self;
}
@end
@interface MyNumber:Object /* declare a number class */
{float value;}
- initValue:(float)aValue;
- print;
@end
@implementation MyNumber /* implement the number class */
- initValue:(float)aValue
{
    self = [super init];
    value = aValue;
    return self;
}
- print {printf(&quot;Number %f\n&quot;,value); return self;}
@end

@interface Point:Object /* declare a point class */
{float X,Y;}
- initX:(float)anX y:(float)anY;
- print;
@end
@implementation Point /* implement the point class */
- initX:(float)anX y:(float)anY
{
    self = [super init];
    X = anX;
    Y = anY;
    return self;
}
- print { printf(&quot;Point %f , %f\n&quot;,X,Y); return self; }
@end
void main(void)
{
    id list1 = [[LinkedList alloc] init];
    id list2 = [[LinkedList alloc] init];
    id number1 = [[MyNumber alloc] initValue:10];
    id number2 = [[MyNumber alloc] initValue:20];
    id point1 = [[Point alloc] initX:2 y:3];
    id point2 = [[Point alloc] initX:4 y:5];
    /* Build the Lists */
    [list1 addObjectToList:number1];
    [list1 addObjectToList:number2];
    [list1 addObjectToList:point1];
    [list2 addObjectToList:number2];/* an object can be in
multiple list */
    [list2 addObjectToList:point1];
    [list2 addObjectToList:point2];
    [list2 addObjectToList:list1];/* lists can contatin lists */
    printf(&quot;List 1\n&quot;);
    [list1 print];
    printf(&quot;List 2\n&quot;);
    [list2 print];
    exit(0);
}

<a name="02df_000d"><a name="02df_000e"></pre><B>[LISTING THREE]</B><pre><a name="02df_000e">

Turbo Pascal Implementation by Michael Floyd (Dr. Dobb's Journal)

Program LListObj;

Type
  PMyListData = ^MyListData;
  MyListData = object
     procedure Print; virtual;
  end;
  PMyListElement = ^MyListElement;
  MyListElement = object
    Data : PMyListData;
    Next : PMyListElement;
    constructor Init(initialData: PMyListData);
  end;
  PMyList = ^MyList;
  MyList = object(MyListData)
    Head, Tail: PMyListElement;
    constructor Init;
    procedure AddToList(var Data: PMyListData);
    procedure Print; virtual;
  end;
   PMyNumber = ^MyNumber;
   MyNumber = object(MyListData)
      Value : Integer;
      constructor Init(initialValue: Integer);
      procedure Print; virtual;
   end;
   PMyPoint = ^MyPoint;
   MyPoint = object(MyListData)
      X, Y: Integer;
      constructor Init(initialX, initialY: Integer);
      procedure Print; virtual;
   end;
{ MyListElement Methods }
constructor MyListElement.Init(initialData: PMyListData);
begin
   data := initialData;
   next := nil;
end;
{ MyListData Methods }
procedure MyListData.Print;
begin
   writeln('No Print Method!');
end;
{ MyList Methods }
constructor MyList.Init;
begin
   Head:= nil;
   Tail:= nil;
end;
procedure MyList.AddToList(var Data: PMyListData);
var
  Added : PMyListElement;
begin
  Added := New(PMyListElement,Init(Data));
  If Head = nil then
  begin
    Head := Added;
    Tail := Added;
  end
  Else begin
    Tail^.Next := Added;
    Tail := Added;
  end;
  Added^.Next := nil;
end;
procedure MyList.Print;
var
   Current : PMyListElement;
begin
  Current := Head;
  while Current &lt;&gt; nil do
  begin
      Current^.Data^.Print;
      Current := Current^.Next;
  end;
end;
{ MyNumber Methods }
constructor MyNumber.Init(initialValue: Integer);
begin
   Value := initialValue;
end;
procedure MyNumber.Print;
begin
   writeln('Number: ', Value);
end;
{ MyPoint Methods }
constructor MyPoint.Init(initialX, initialY: Integer);
begin
   X := initialX;
   Y := initialY;
end;
procedure MyPoint.Print;
begin
   writeln('Point: ', X, ',',Y);
end;
{ Main }
Var
   NumList, PointList : MyList;
   Number, Coordinates: PMyListData;
   I, J               : Integer;
Begin
   with NumList do begin      { create list of numbers }
      Init;
      For I := 1 to 5 do
      begin
        Number := New(PMyNumber, Init(I));
        AddToList(Number);
      end;
      Print;
   end;
   with PointList do begin    { create list of points }
      Init;
      For I := 1 to 5 do
      begin
        J := I + 1;
        Coordinates := New(PMyPoint, Init(I,J));
        AddToList(Coordinates);
      end;
      Print;
   end;
   NumList.AddToList(Coordinates);    { Coords can be added to Number list }
   NumList.Print;
   readln;
end.

<a name="02df_000f"><a name="02df_0010"></pre><B>[LISTING FOUR]</B><pre><a name="02df_0010">

Parasol Implementation by Robert Jervis


include file;
/* any object that will appear in a list must inherit from this class */
MyListData: type    { public:
Print:  dynamic () = {
    printf(&quot;No print method!\n&quot;);
    }
};
MyList: public  type inherit MyListData {
    head:   ref MyListElement;
    tail:   ref MyListElement;
    MyListElement:  type {
    public:
        data:   ref MyListData;
        next:   ref MyListElement;
    constructor:    (initialData: ref MyListData) =
                { data = initialData; next = 0; }
    };
public:
constructor:    () = { head = tail = 0; }

AddToList:  (data: ref MyListData) = {
    newElement: ref MyListElement = new MyListElement[data];
        if  (head == 0)
                head = tail = newElement;
        else    {
                tail-&gt;next = newElement;
                tail = newElement;
        }
    }
Print:  dynamic () = {
    element:    ref MyListElement;
    for (element = head; element != 0; element = element-&gt;next)
        element-&gt;data Print();
    }
};
MyNumber:   type    inherit MyListData {
    value:  int;
public:
constructor:    (initialValue: int)  = { value = initialValue; }
Print:  dynamic () = {
    printf(&quot;Number: %d\n&quot;, value);
    }
};
MyPoint:    type    inherit MyListData {
    x:  int;
    y:  int;
public:
constructor:   (initialX: int, initialY: int) = { x = initialX; y = initialY; }
Print:  dynamic () = {
    printf(&quot;Point: %d,%d\n&quot;, x, y);
    }
};
main:   entry   () =
{
    list1:  ref MyList = new MyList[];
    list2:  ref MyList = new MyList[];
    n1: ref MyNumber = new MyNumber[10];
    n2: ref MyNumber = new MyNumber[20];
    p1: ref MyPoint = new MyPoint[2,3];
    p2: ref MyPoint = new MyPoint[4,5];
        /* build the lists */
    list1 AddToList(n1);
    list1 AddToList(n2);
    list1 AddToList(p1);
    list2 AddToList(n2);    /* an object can be in more than one list */
    list2 AddToList(p1);    /*    at the same time                    */
    list2 AddToList(p2);
    list2 AddToList(list1); /* we can even put a list into another list */
        /* print the lists */
    printf(&quot;list1:\n&quot;);
    list1 Print();
    printf(&quot;list2:\n&quot;);
    list2 Print();
}

<a name="02df_0011"><a name="02df_0012"></pre><B>[LISTING FIVE]</B><pre><a name="02df_0012">

C+@ Implementation by Jim Fleming (Unir Corp.)


class MyListData {
   method print
   {
       &quot;No print method&quot;.print;
   }
}
class MyListElement {
   inherit MyListData;
   MyListData    data;
   MyListElement next;

   class method (_) new (initialData) {
           _ = create
           _.init(initialData);
   }
   method init (idata)  {
       data = idata;
       next = nil;
   }
   method (_) data {
       _ = data;
   }
   method(_) next {
       _ = next;
   }
   method linkTo (listElement) {
       next = listElement;
   }
}
class MyList {
   MyListElement head;
   MyListElement tail;

   class method (_) new {
      _ = create;
      _.init;
   }
   method init {
      head = nil;
      tail = nil;
   }
   method addToList (data) {
      var newElement;
           newElement = MyListElement.new(data);
           if(head == nil) {
              head = newElement;
              tail = head;
           }
           else{
              tail.linkTo(newElement);
              tail = newELement;
           }
     }
     method print {
        var element;
        for (element = head; element != nil; element = element.next) {
           element.data.print;
        }
     }
}
class MyNumber {
   Integer value;
   class method (_) new (initialValue) {
      _= create;
       .init (initialValue)
    }
    method init (initialValue) {
        value = initialValue;
    }
    method print  {
       (&quot;Number: &quot; // value // &quot;\n&quot;).print;
    }
}
class MyPoint  {
   Integer x;
   Integer y;
   class method (_) new (initialX,initialY) {
      _= create;
      .init(initialX,initialY);
   }
   method init (initialX,initialY) {
      x = initialX;
      y = initialY;
    }
    method print {
      (&quot;Point: &quot;// x // &quot;,&quot; // y // &quot;\n&quot;).print
    }
}
/* The following can be typed directly into command shell */
list1 = Mylist.new;
list2 = Mylist.new;
n1 = Mynumber.new(10);
n2 = Mynumber.new(20);
p1 = MyPoint.new(2,3);
p2 = MyPoint.new(4,5);

list1.addToList(n1);
list1.addToList(n2);
list1.addToList(p1);
list2.addToList(n2); /* an object can be in more than one list */
list2.addToList(p1);
list2.addToList(p2);
list2.addToList(list1); /* we can even put a list into another list */
/* print the lists */
&quot;list1;\n&quot;.print;
list1.print;
&quot;list2;\n&quot;.print;
list2.print;


<a name="02df_0013"><a name="02df_0014"></pre><B>[LISTING SIX]</B><pre><a name="02df_0014">

Liana Implementation by Jack Krupansky (Base Technology)

class  MyList : array
{
           Print
           {
                  for (int i = 0, int n = size; i &lt; n; i++)
                       if ((any e = this [i]).isa (&quot;MyList&quot;))
                                e.Print();
                       else
                                cout &lt;&lt; e.class_name+&quot;: &quot;+e.text+&quot;\n&quot;;
           }
};
//-------------------------------------------
void main (void)
{
        MyList  list1 =   new   MyList;
        MyList  list2 =   new   MyList;
        int     n1 =      10;
        int     n2 =      20;
        point   p1 =      new   point (2,3);
        point   p2 =      new   point (4,5);

        /* build the lists */
        list1 &lt;&lt; n1 &lt;&lt; n2 &lt;&lt; p1;

        /* an obj can be in more than one lst at same time */
        list2 &lt;&lt; n2 &lt;&lt; p1 &lt;&lt; p2;

        list2 &lt;&lt; list1; /* we can even put a list into another list  */

        /* print the lists */
        cout &lt;&lt; &quot;\nLIST1:\n&quot;;    list1.Print;
        cout &lt;&lt; &quot;\nLIST2:\n&quot;;    list2.Print;
}

<a name="02df_0015"><a name="02df_0016"></pre><B>[LISTING SEVEN]</B><pre><a name="02df_0016">

Minimal Smalltalk implementation by Ray Valdes (Dr. Dobb's Journal)

OrderedCollection subclass: #MyListClass
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''   !
!MyListClass class methods ! !
!MyListClass methods !
printOn: aStream
    &quot; Method to display list elements, recursing if necessary &quot;
    aStream cr; nextPutAll:  ' ',(self class name),' '; cr.
    self do: [:c | c printOn: aStream. aStream cr ].
    ^self.
!
test
    &quot; Program to test the linked-list class &quot;
    |
       aList1 aList2 aNumber1 aNumber2 aPoint1 aPoint2 aMsg
    |
    aList1 := MyListClass new.
    aList2 := MyListClass new.
    aNumber1 := 10.
    aNumber2 := 20.
    aPoint1 := (2 @ 3).
    aPoint2 := (4 @ 5).
    &quot; build the lists &quot;
    aList1 add: aNumber1; add: aNumber2; add: aPoint1.
    &quot; an object can be in more than one list at same time &quot;
    aList2 add: aNumber2; add: aPoint1;      add: aPoint2.
    &quot; we can even put a list into another list &quot;
    aList2 add: aList1.
    &quot; print the lists &quot;
    aList1 printOn: Transcript.
    aList2 printOn: Transcript.
! !


<a name="02df_0017"><a name="02df_0018"></pre><B>[LISTING EIGHT]</B><pre><a name="02df_0018">

Complete Smalltalk/V implementation by Ray Valdes (Dr. Dobb's Journal)

&quot;-------------------------------------------------------------&quot;
Object subclass: #MyListClasses
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''    !
!MyListClasses class methods ! !
!MyListClasses methods ! !
&quot;-------------------------------------------------------------&quot;
MyListClasses subclass: #TestList
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''    !
!TestList class methods ! !
!TestList methods !
test
    &quot; Program to test the linked-list class &quot;
    |
       aList1 aList2 aNumber1 aNumber2 aPoint1 aPoint2
    |
    aList1   := MyList new.
    aList2   := MyList new.
    aNumber1 := MyNumber new: 10.
    aNumber2 := MyNumber new: 20.
    aPoint1  := MyPoint  new: (2 @ 3).
    aPoint2  := MyPoint  new: (4 @ 5).
    &quot; build the lists &quot;
    aList1 add: aNumber1; add: aNumber2; add: aPoint1.
    &quot; an object can be in more than one list at same time &quot;
    aList2 add: aNumber2; add: aPoint1;      add: aPoint2.
    &quot; we can even put a list into another list &quot;
    aList2 add: aList1.
    &quot; print the lists &quot;
    aList1 print.
    aList2 print! !
&quot;------------------------------------------------------------------&quot;
MyListClasses subclass: #MyListElement
  instanceVariableNames: 'data next'
  classVariableNames: ''
  poolDictionaries: ''    !
!MyListElement class methods !
new: someData
   ^super new initialize: someData! !
!MyListElement methods !
initialize: someData
     data := someData.
     ^self!
next
    ^next!
next: anElement
      next := anElement.
      ^self!
print
      data print.
      ^self! !
&quot;-------------------------------------------------------------&quot;
MyListClasses subclass: #MyListData
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''    !
!MyListData class methods ! !
!MyListData methods !
print
   Transcript cr; nextPutAll: 'Must override this method'; cr.
   ^self! !
&quot;-------------------------------------------------------------&quot;
MyListData subclass: #MyList
  instanceVariableNames: 'head tail'
  classVariableNames: ''
  poolDictionaries: ''  !
!MyList class methods ! !
!MyList methods !
add: someData
    | anElement |
    anElement := MyListElement new: someData.
    head isNil
      ifTrue:  [ head := anElement. tail := anElement ]
      ifFalse: [ tail next: anElement.  tail := anElement].
     ^self!
print
    | anElement |
    anElement := head.
    [anElement isNil]
    whileFalse: [
        anElement print.
        anElement := anElement next .
        Transcript cr.
        ].
     ^self! !
&quot;-------------------------------------------------------------&quot;
MyListData subclass: #MyNumber
  instanceVariableNames: 'value'
  classVariableNames: ''
  poolDictionaries: ''    !
!MyNumber class methods !
new: aValue
    ^super new initialize: aValue! !
!MyNumber methods !
initialize: aValue
     value := aValue.
     ^self!
print
    value printOn: Transcript.
    ^self! !
&quot;-------------------------------------------------------------&quot;
MyListData subclass: #MyPoint
  instanceVariableNames: 'point'
  classVariableNames: ''
  poolDictionaries: '' !
!MyPoint class methods !
new: aPoint
    ^super new initialize: aPoint! !
!MyPoint methods !
initialize: aPoint
    point := aPoint.
    ^self!
print
    point printOn: Transcript.
    ^self! !


<a name="02df_0019"><a name="02df_001a"></pre><B>[LISTING NINE]</B><pre><a name="02df_001a">

Eiffel Implementation by Robert Howard (Tower Technology)


class DRIVER
   -- In Eiffel, the top level driver is an object, too.
inherit
   BASIC_IO
creation
   make
feature {ANY}
   make is
     -- run this test driver
      local
     list1, list2 : MY_LIST[PRINTABLE] ;
     n1, n2 : MY_NUMBER ; -- a kind of PRINTABLE
     p1, p2 : MY_POINT ;  -- also a kinf of PRINTABLE
      do
         -- create the various objects
     !!list1 ;
     !!list2 ;
     !!n1.set( 10 ) ;
     !!n2.set( 20 ) ;
     !!p1.set( 2, 3 ) ;
     !!p2.set( 4, 5 ) ;

     list1.add_to_list( n1 ) ;
     list1.add_to_list( n2 ) ;
     list1.add_to_list( p1 ) ;
     list2.add_to_list( n2 ) ; -- objects can be in more than one list
     list2.add_to_list( p1 ) ;
     list2.add_to_list( p2 ) ;
     list2.add_to_list( list1 ) ; -- list 1 is an element of list 2

     put_string( &quot;list1:%N&quot; ) ;
     list1.print_self ;
     put_string( &quot;list2:%N&quot; ) ;
     list2.print_self ;
      end -- make
end -- DRIVER
deferred class PRINTABLE
   -- insures that 'print_self' is implemented
inherit
   BASIC_IO
feature {ANY}
   print_self is
     -- print yourself
      deferred
      end -- print_self
end -- PRINTABLE
class MY_NUMBER
   -- holds and can print an integer
inherit
   PRINTABLE
creation
   set
feature {ANY}

   value : INTEGER ;
   set( new_value : INTEGER ) is
     -- set this number
      do
     value := new_value ;
      end ; -- make
   print_self is
     -- print the value
      do
     put_string( &quot;Number: &quot; ) ;
     put_int( value ) ;
     put_newline ;
      end ; -- print_self
end -- MY_NUMBER
class MY_POINT
   -- holds and can print an x,y pair
inherit
   PRINTABLE
creation
   set
feature {ANY}
   x, y : INTEGER ;
   set( new_x : INTEGER; new_y : INTEGER ) is
     -- set this point
      do
     x := new_x ;
     y := new_y
      end ; -- set
   print_self is
     -- print the value
      do
     put_string( &quot;Point: &quot; ) ;
     put_int( x ) ;
     put_char( ',' ) ;
     put_int( y ) ;
     put_newline ;
      end ; -- print_self
end -- MY_POINT
class ELEMENT[T]
   -- holds an object reference and a
   -- single link to another ELEMENT[T]
creation
   set_data
feature {LIST}
   data : T ;
   next : ELEMENT[T] ;
   set_data( new_data : T ) is
     -- set data to the new_data
      do
     data := new_data
      end ; -- set_data
   set_next( new_next : ELEMENT[T] ) is
     -- set next to the element
      do
     next := new_next

      end ; -- set_next
end -- class ELEMENT
class LIST[T]
   -- a generic linked list class
feature {ANY}
   add_to_list( data : T ) is
     -- add to the end of the list
      local
     new_element : ELEMENT[T] ;
      do
     !!new_element.set_data( data ) ;
     if head = void
      then
        head := new_element ;
     else
        tail.set_next( new_element ) ;
     end
     tail := new_element ;
      end ; -- add_to_list
feature {NONE}
   head, tail : ELEMENT[T] ;
invariant
   tail_next_is_void: tail.next = void ;
   tail_void_when_head_void: head = void implies tail = void
end -- LIST
class MY_LIST[T-&gt;PRINTABLE]
   -- A printable list which holds printable data
inherit
   LIST[T]
   PRINTABLE
feature {ANY}
   print_self is
     -- print the list elements
      local
     el : ELEMENT[T] ;
      do
     from
        el := head
     until
        el = void
     loop
        el.data.print_self
        el := el.next ;
     end ;
      end ; -- print_self
end -- MY_LIST


<a name="02df_001b"><a name="02df_001c"></pre><B>[LISTING TEN]</B><pre><a name="02df_001c">

Sather Implementation by Stephen Omhundro (ICSI)

-------------------------------------------------------------------
abstract class $MY_LIST_DATA is
   -- Data that will appear in a list must inherit this class.

   print is
      -- Print the data on OUT. Should be redefined in descendants.
      #OUT + &quot;No print routine defined!\n&quot; end;
end;
-------------------------------------------------------------------
class MY_LIST_ELEMENT is
   -- An element of a MY_LIST.

   attr data:$MY_LIST_DATA;
   attr next:MY_LIST_ELEMENT;
end;
-------------------------------------------------------------------
class MY_LIST is
   -- A double ended linked list.
   inherit $MY_LIST_DATA;

   private head, tail:MY_LIST_ELEMENT;

   add_to_list($MY_LIST_DATA) is
      -- Append arg to the end of self.
      new_elt::=#MY_LIST_ELEMENT(data:=arg);
      if head=void then head:=new_elt
      else tail.next:=new_elt end;
      tail:=new_elt end;

   print is
      -- Print the data held in the list on OUT.
      elt::=head;
      loop while!(elt/=void); elt.data.print;
     elt:=elt.next end end;
end;
-------------------------------------------------------------------
class MY_NUMBER is
   -- An integer value that can be held in a MY_LIST.
   inherit $MY_LIST_DATA;

   attr value:INT;

   print is
      -- Print the integer value on OUT.
      #OUT + &quot;Number: &quot; + value + &quot;\n&quot; end;
end;
-------------------------------------------------------------------
class MY_POINT is
   -- A two-dimensional point that can be held in a MY_LIST.
   inherit $MY_LIST_DATA;

   attr x,y:INT;

   print is
      -- Print the point coordinates on OUT.
      #OUT + &quot;Point: &quot; + x + &quot;,&quot; + y + &quot;\n&quot; end;
end;
-------------------------------------------------------------------
class MY_LIST_TEST is
   -- Test of MY_LIST.

   main is
      -- Add some numbers and points to lists and print them out.
      list1::=#MY_LIST; list2::=#MY_LIST;
      n1::=#MY_NUMBER(10); n2::=#MY_NUMBER(20);
      p1::=#MY_POINT(2,3); p2::=#MY_POINT(4,5);
      -- Build the lists:
      list1.add_to_list(n1); list1.add_to_list(n2);
      list1.add_to_list(p1);
      list2.add_to_list(n2);    -- An object can be in more than one list.
      list2.add_to_list(p1); list2.add_to_list(p2);
      list2.add_to_list(list1); -- Put a list in another list.
       -- Print the lists
      #OUT + &quot;list1:\n&quot;;
      list1.print;
      #OUT + &quot;list2:\n&quot;;
      list2.print end;
end;


<a name="02df_001d"><a name="02df_001e"></pre><B>[LISTING ELEVEN]</B><pre><a name="02df_001e">

Beta Implementation by Steve Mann (MADA)

--- program:descriptor---
(#
   MyListData: (#  Print:&lt; (# do INNER #)  #);
   MyListElement: (#   data: ^MyListData;  next: ^MyListElement;   #);
   MyList: MyListData (#
       head, tail: ^MyListElement;
   AddToList: (#
       newItem: ^MyListData
       enter newItem[]
       do  (if head[] = NONE // TRUE then
           &amp;MyListElement[] -&gt; head[] -&gt; tail[];
           newItem[] -&gt; head.data[];
          else
           &amp;MyListElement[]-&gt; tail.next[] -&gt; tail[];
           newItem[] -&gt; tail.data[];
          if);
   #);
   Print::&lt; (#
       element: ^MyListElement
       do head[] -&gt; element[];
           loop    (# while::&lt; (# do element[] &lt;&gt; NONE -&gt; value #);
       do  element.data.print; element.next[] -&gt; element[];
   #); #); #);
   MyNumber: MyListData (#
   value: @integer;
        Print::&lt; (# do 'Number: ' -&gt; PutText; value -&gt; PutInt; NewLine; #);
        enter value
    #);
   MyPoint: MyListData (#
   x, y: @integer;
        Print::&lt; (# do  'Point: ' -&gt; PutText;   x -&gt; PutInt;
        ', ' -&gt; PutText;    y -&gt; PutInt;NewLine;
     #);
     enter (x, y)
     #);
(********************** MAIN **************************)
   list1, list2: @MyList;
   n1, n2: @MyNumber;  p1, p2: @MyPoint;
do
   10 -&gt; n1;   20 -&gt; n2;
   (2, 3) -&gt; p1;   (4, 5) -&gt; p2;

   n1[] -&gt; list1.AddToList;n2[] -&gt; list1.AddToList;
   p1[] -&gt; list1.AddToList;

   n2[] -&gt; list2.AddToList;p1[] -&gt; list2.AddToList;
   p2[] -&gt; list2.AddToList;list1[] -&gt; list2.AddToList;

   'list1: ' -&gt; PutLine;   list1.Print;
   'list2: ' -&gt; PutLine;   list2.Print;
#)


<a name="02df_001f"><a name="02df_0020"></pre><B>[LISTING TWELVE]</B><pre><a name="02df_0020">

Drool Implementation by David Betz (Dr. Dobb's Journal)


(defobject MyListElement ()
  (property next nil
            data nil))
(defobject MyList ()
  (property head nil
            tail nil))
(defmethod (MyList 'AddToList data)
  (let ((newElement (clone MyListElement 'data data))
        (tail (getp self 'tail)))
    (if tail
      (setp! tail 'next newElement)
      (setp! self 'head newElement))
    (setp! self 'tail newElement)))
(defmethod (MyList 'Print)
  (let ((element (getp self 'head)))
    (while element
      ((getp element 'data) 'Print)
      (set! element (getp element 'next)))))
(defobject MyNumber ()
  (property value 0))
(defmethod (MyNumber 'Print)
  (print &quot;Number: &quot; (getp self 'value) &quot;\n&quot;))
(defobject MyPoint ()
  (property x 0
            y 0))
(defmethod (MyPoint 'Print)
  (print &quot;Point: &quot; (getp self 'x) &quot;,&quot; (getp self 'y) &quot;\n&quot;))
(define (main)
  (let ((list1 (clone MyList))
        (list2 (clone MyList))
        (n1 (clone MyNumber 'value 10))
        (n2 (clone MyNumber 'value 20))
        (p1 (clone MyPoint 'x 2 'y 3))
        (p2 (clone MyPoint 'x 4 'y 5)))
    (list1 'AddToList n1)
    (list1 'AddToList n2)
    (list1 'AddToList p1)
    (list2 'AddToList n2)
    (list2 'AddToList p1)
    (list2 'AddToList p2)
    (list2 'AddToList list1)
    (print &quot;list1\n&quot;)
    (list1 'Print)
    (print &quot;list2\n&quot;)
    (list2 'Print)))


<a name="02df_0021"><a name="02df_0022"></pre><B>[LISTING THIRTEEN]</B><pre><a name="02df_0022">

Ada Implementation by Mike Ruf (Rational)

-- Ada83 does not support run-time polymorphism, so only supports homogeneous
-- lists. Ada9X will run-time polymorphism. There are ways to simulate run-time
-- polymorphism in Ada83, which is discussed in: Seidewitz, Ed,
-- &quot;Object-Oriented Programming Through Type Extension in Ada 9X,&quot; Ada
-- Letters, Volume 11, Number 2, Mar/Apr 1991, pages 86-97. Hirasuna, Michael,
-- &quot;Using Inheritance and Polymorphism with Ada in Government Sponsored
-- Contracts&quot;, Ada Letters, Volume 12, Number 2, Mar/Apr, 1992, pp. 43-56.
-- Mike Ruf, Rational Systems
-- This package implements a singly-linked list abstraction.
--
generic
    type Element is private;
    with procedure Print (This : Element);
package Printable_List_Generic is
    type List is private;
    function New_List return List;
    -- Returns an empty list.
    procedure Append (To_List : in out List;
                      This_Element : in Element);
    -- Propagates the Storage_Error exception if it occurs.
    procedure Print (This : in List);
    -- For each element in the list, calls the Print procedure,
    -- which is supplied as a generic formal parameter.
private
    type Node;
    type Pointer is access Node;
    type Node is
        record
            Contents : Element;
            Next : Pointer := null;
        end record;
    type List is
        record
            First : Pointer := null;
            Last : Pointer := null;
        end record;
end Printable_List_Generic;
package body Printable_List_Generic is
    function New_List return List is
    begin
        return (List'(First =&gt; null, Last =&gt; null));
    end New_List;
    procedure Append (To_List : in out List;
                      This_Element : in Element) is
       New_Node : Pointer := new Node'(Contents =&gt; This_Element, Next =&gt; null);
       -- The &quot;next&quot; component of the last node is always &quot;null&quot;
    begin
        if To_List.First = null then
            To_List.First := New_Node;
            To_List.Last := New_Node;
        else
            To_List.Last.Next := New_Node;
            To_List.Last := New_Node;
        end if;
    end Append;
    procedure Print (This : in List) is
        Current : Pointer := This.First;
    begin
        while (not (Current = null)) loop
            Print (Current.Contents);
            Current := Current.Next;
        end loop;
    end Print;
end Printable_List_Generic;

package Geometry is
    type Number is new Integer;
    procedure Print (This : Number);
    type Point is
        record
            X : Number := 0;
            Y : Number := 0;
        end record;
    procedure Print (This : Point);
end Geometry;

package body Geometry is
    procedure Print (This : Number) is
    begin
        Text_Io.Put_Line (&quot;Number:&quot; &amp; Number'Image (This));
    end Print;
    procedure Print (This : Point) is
    begin
        Text_Io.Put_Line (&quot;Point: &quot; &amp; Number'Image (This.X) &amp;
                          &quot;,&quot; &amp; Number'Image (This.Y));
    end Print;
end Geometry;

procedure List_Example;

with Geometry;
with Printable_List_Generic;

procedure List_Example is
    package Numbers is new Printable_List_Generic (Element =&gt; Geometry.Number,
                                                   Print =&gt; Geometry.Print);
    package Points is new Printable_List_Generic (Element =&gt; Geometry.Point,
                                                  Print =&gt; Geometry.Print);
    Number_List : Numbers.List := Numbers.New_List;
    Point_List : Points.List := Points.New_List;
    N1 : Geometry.Number := 10;
    N2 : Geometry.Number := 20;
    P1 : Geometry.Point := (2, 3);
    P2 : Geometry.Point := (4, 5);
begin
    -- Build the lists
    Numbers.Append (To_List =&gt; Number_List, This_Element =&gt; N1);
    Numbers.Append (To_List =&gt; Number_List, This_Element =&gt; N2);
    --
    Points.Append (To_List =&gt; Point_List, This_Element =&gt; P1);
    Points.Append (To_List =&gt; Point_List, This_Element =&gt; P2);
    -- Print the lists
    Numbers.Print (Number_List);
    Points.Print (Point_List);
end List_Example;

------------------------------- OUTPUT  -------------------------------
Number: 10
Number: 20
Point:  2, 3
Point:  4, 5


</pre><HR><P>Copyright &copy; 1993, <I>Dr. Dobb's Journal</I></P></BODY></HTML>
