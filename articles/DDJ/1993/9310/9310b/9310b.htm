<HTML>
<META NAME="year" CONTENT="1993">
<HEAD>
<TITLE>OCT93: The C+@ Programming Language</TITLE></HEAD>
<BODY BGCOLOR="#ffffff">
<h1>The C+@ Programming Language<a name="02ac_0003"></h1><P>
<h2><a name="02ac_0001"><a name="02ac_0000">Its mature foundation class library makes a difference</h2><P>
<h3>Jim Fleming</h3><P>
<p><i><a name="02ac_0002"><a name="02ac_0000">Jim is one of the founders of Unir Technology Inc., and can be contacted there at 184 Shuman Blvd., Naperville, IL 60563; or at 708-305-0600 or 1-800-222-8647.</i></p><hr><P>
The C+@ programming language, an object-oriented language derived from AT&amp;T Bell Lab's Calico programming language, was developed to provide programmers with a true object-based language and development environment. C+@ (pronounced &quot;cat&quot;) has the syntax of C and the power of Smalltalk. Unlike C++, C+@ includes a mature class library with more than 350 classes used throughout the system. The C+@ compiler itself is written in C+@, and all of the source for the class libraries is included with development systems.<P>
The Calico project was started at AT&amp;T Bell Labs in the early '80s, after the introduction of Smalltalk and at the same time as C++. Calico was originally used for rapid prototyping of telecommunication services; hence, its heavy emphasis on keeping the language syntax simple and showcasing the power of the graphical development environment.<P>
The name &quot;C+@&quot; is derived from C++ and Smalltalk. The @ method is used in Smalltalk (and C+@) to create objects of class <I>Point</I> from an <I>x</I> and <I>y</I> component. For example, the expression 12 @ 34 indicates that the @ method should be applied to the receiver 12 with the argument 34. Both 12 and 34 are objects of class <I>Integer</I> and are used to initialize the new <I>Point</I> object; see <a href="199302ae.htm">Figure 1</A>. Points are used in graphics and other 2-D applications.<P>
<h3><a name="02ac_0004">C+@ Overview<a name="02ac_0004"></h3><P>
In C+@, all data items are objects and behave uniformly. The programming environment is dynamic, responsive, and supports multideveloper collaboration using an open source storage facility with hierarchical views.<P>
C+@ was designed to be a comfortable companion language to C and C++ rather than an extension to C. It retains C's expression syntax and control statements. C functions and data objects can be accessed directly from C+@. C+@ supports most of the features of Smalltalk as well as multiple inheritance. The complete C+@ graphical development environment is written in C+@ and provides a powerful edit/compile/debug cycle. A GUI builder is included for quickly building applications visually by drawing them on the screen. C+@ can also be used in a command-line mode as an interactive object-oriented shell programming language.<P>
C, C++, and C+@ each have a place in the development environment. C+@ offers significant advantages for rapid prototyping and for providing the object-oriented &quot;backbone&quot; of an application. C still offers an excellent solution where performance takes precedence over productivity. For most large applications, supplementing C with C+@ provides an effective trade-off between application speed and rapid delivery.<P>
The binaries produced by the C+@ compiler are independent of the underlying machine architecture. Without recompiling, applications can be moved from SPARC to 68000 to Intel x86, and so on. C+@ is not interpretive--the binaries are encoded using a sophisticated &quot;beading&quot; technique developed at Bell Labs. Because of the streamlined language design, the C+@ compiler produces these portable binaries with extraordinary speed, without the need for preprocessing or front ends.<P>
C+@ can be used in applications involving pen-based computing, real-time systems, GUIs, object-oriented database servers, and the like. For the past eight years, C+@ has been evolving and has reached a state where AT&amp;T has decided to release it to the commercial world. C+@ is not intended to replace C (or C++), but certainly provides a streamlined companion. (Unir Corporation has released versions of C+@ for SPARC-compatible workstations.)<P>
<h3><a name="02ac_0005">C+@ and Smalltalk<a name="02ac_0005"></h3><P>
Comparisons between C+@ and C++ aren't really fair because C++ is syntactically very complex and designed to support a range of programming styles. C++ was conceived as an extension to C and, over the past ten years, has enabled programmers to experiment with object-oriented programming. Just because a program is written in C++ doesn't mean it's object-oriented. In many cases, C++ programmers don't use any of the object-oriented extensions of the language--they use C++ as a better C.<P>
The best language to compare C+@ to is Smalltalk. Like Smalltalk, C+@ was designed for object-oriented programming from the outset. C+@ supports garbage collection and can be used as a typeless language. In C+@, the notion of a pointer is not visible to programmers because all variables can contain pointers. With C+@, new programmers can bypass all of the cryptic syntactic puzzles that continue to fill C++ programming books and have nothing to do with developing an application or maintaining high-quality software. C+@ is much easier to learn than C or C++.<P>
Just as the Smalltalk environment is written in Smalltalk, the C+@ development environment is completely written in C+@.<P>
The primary difference between C+@ and Smalltalk is in constructs for handling control flow of methods are written. In Smalltalk, conditional statements are implemented by sending messages and code. Evaluation is based on the value of the Boolean object. This is similar to the C construct <I>&lt;expression&gt;?&lt;statement&gt;:&lt;statement&gt;;.</I> This form sometimes makes Smalltalk programs difficult to read and maintain. C+@ supports all of the C control-flow constructs and can be easily read by C programmers.<P>
Like Smalltalk, C+@ documentation refers to objects, classes, instances, methods, and messages. All C+@ data items are objects and are classified into classes which are themselves objects. Each object is said to be an instance of a particular class and the data fields of an object are called &quot;instance variables.&quot; The class itself is called the &quot;distinguished instance&quot; and can contain global class variables. An object can be manipulated by invoking its methods via messages; only instance methods can access the encapsulated instance variables. Class methods are used to access global class variables.<P>
Programming in C+@ is done by writing class descriptions that define class variables, instance variables, class methods and instance methods. These classes and methods are loaded as required, based on the interaction of the various objects in a workspace. Objects are instantiated by the distinguished instance which responds to class methods.<P>
The class descriptions also describe the inheritance relationships of classes and methods. C+@ supports direct and delegate inheritance. Direct inheritance is commonly used with abstract classes which don't contain instance variables but provide common behavior to other classes; delegate inheritance is used when a class wants to take advantage of the capabilities of another class. Methods not recognized by a receiver will be passed to a delegate without the sender's knowledge.<P>
For example, the Smalltalk <I>Rectangle</I> class can be created as in <a href="199302af.htm">Figure 2</A>. As the C+@ code shows, a class can be created with two instance variables, similar to a C <I>struct</I> with two fields (<I>origin</I> and <I>corner</I>). Unlike C, the keyword <I>var</I> indicates that these variables can contain values of any type. In <a href="199302b0.htm">Figure 2</A>, the method <I>origin_corner_</I> can be used to create an instance of a <I>Rectangle</I> object which references two <I>Points</I> created using the @ method. The class method <I>origin_corner_</I> is applied to the distinguished instance of <I>Rectangle</I>. The <I>origin_corner_</I> class method causes a new <I>Rectangle</I> object to be created (or instantiated). A reference (the address of the instance) is returned from <I>origin_corner_</I> and stored in the variable <I>p</I>.<P>
Methods for the class <I>Rectangle</I> can be written as small sequences of statements that look similar to C functions. These methods are grouped in the surrounding braces of the class <I>Rectangle {...}</I> construct, ensuring that variables and methods for a class are grouped in one syntactic construct that can be stored in a separate ASCII file. This provides a form of source-code encapsulation, allowing you to use standard UNIX tools (editors, make, and the like).<P>
As with Smalltalk, C+@ supports binary and unary/keyword methods. The binary methods of C+@ and Smalltalk are very similar; see <a href="#02ac_0008">Figure 3</A>. Smalltalk differentiates the unary methods with arguments, and the keyword methods via colons (:). C+@ only supports the dot-method form used in C++ and in many respects is more consistent than Smalltalk. The lack of a keyword construct has not been a limitation. Smalltalk keyword methods can easily be converted to C+@ using a simple convention.<P>
Although C+@ and Smalltalk are similar at the high-level of class and method design, the actual control-flow statements are very different. In Smalltalk, messages to objects are used to control the flow of execution in a method. In C+@, the control-flow statements look like C statements, making it easier for experienced C programmers to pick up the language. In some cases algorithms have been converted from C to C+@ with little change in the control-flow source.<P>
In <a href="#02ac_0009">Figure 4</A>, the receiver (<I>queue</I>) is sent the message <I>isEmpty</I> which returns a Boolean, (True or False). In the C+@ example, this result is tested and the variable index is set to 0, or the result of applying the next method to the receiver (<I>queue</I>). In the Smalltalk example, the <I>ifTrue:ifFalse:</I> message is sent to the Boolean that results from applying the <I>isEmpty</I> method to the receiver (<I>queue</I>). When <I>ifTrue:ifFalse:</I> is sent, two arguments are passed and evaluated depending on the value of the receiver. If the value is True, then the block <I>[index&lt;=0]</I> will be sent a message to be evaluated. If the value is False, then the block <I>[index&lt;=queue next]</I> is evaluated, again by sending the block a message.<P>
C+@ supports most of the features of Smalltalk with a C syntax. Since all of the C operators are handled as method selectors, operators like &lt;&lt; and &gt;&gt; can be invented to shift integer values left or right. These same operators could be defined in another class to indicate some sort of special shifting, sorting, or movement operation. For example, the &lt;&lt; operator applied to a <I>Window</I> class object may mean &quot;move it left.&quot;<P>
C+@ array constructs are handled just like any other method. The C+@ compiler is capable of rearranging the source code to allow array methods to be handled in this manner.<P>
When the C+@ compiler encounters a statement such as <I>a[i]=j;,</I> the receiver <I>a</I> is sent the <I>[]=</I> method with the arguments <I>(i,j)</I>. This is equivalent to writing <I>a.[]=(i,j)</I> which most C programmers would not recognize. Therefore, the compiler handles the conversion. Array access is handled in a similar manner. For example, the C+@ statement <I>i=a[j];</I> results in the <I>[]</I> method being sent to the receiver a with the argument <I>j</I>. This is equivalent to <I>i=a.[](j);</I> which, once again, would be foreign to a C programmer. The C+@ compiler handles the shift and allows you to think in terms of standard C.<P>
Multidimensional arrays are also available in C+@, although the syntax of the indexes is slightly different from C. For example, if <I>a</I> is a two-dimensional array, then it's legal to write <I>a[2,5]=j;.</I> The C+@ compiler converts this to <I>a.[]=(2,5,j)</I> and the correct<I> []= </I>method is selected based on the number of arguments.<P>
Because the standard C array operator is implemented as a normal method in C+@, you can have statements such as <I>array[&quot;manager&quot;]=&quot;mary wilson&quot;;</I> that's equivalent to <I>array.[]=(&quot;manager&quot;,&quot;mary wilson&quot;).</I> The C+@ foundation class library contains classes for Arrays, Trees, Lists, and Tables. Many of these classes support the <I>[]=</I> array assignment method and the <I>[]</I> array access method for indexes other than integers.<P>
The Smalltalk <I>block</I> construct allows small fragments of C+@ programs to be grouped together into objects of class <I>Block</I>, and passed around. These objects can be sent messages to execute the fragment of code encapsulated in the <I>Block</I> object. This is useful when an algorithm needs to be applied to all of the members of an array. An instance method of objects of class <I>Array</I> can be used to iterate over each array element. The block of code can be executed for each element without knowledge of the contents of the block.<P>
<h3><a name="02ac_0006">C+@ Class and Method Definition<a name="02ac_0006"></h3><P>
C+@ programming consists of declaring a series of classes that contain not only a description of the fields used to store data in an object but also the routines (or methods) used to manipulate these data fields. In <a href="199302b1.htm">Figure 5</A>, these field definitions for instance, variables and the methods are nested inside of a class <I>Name {...}</I> construct. Inheritance relationships and class variables can also be defined (although they don't apply in <a href="199302b2.htm">Figure 5</A>).<P>
In <a href="199302b3.htm">Figure 5</A>, there are two instance variables (<I>x</I> and <I>y</I>). Everytime an object of class <I>Point</I> is created, for example, the object's data area will have two fields that can be accessed in the methods for the object by referring to the variables <I>x</I> and <I>y</I>. In general, these variables will likely contain integer values, but since they were declared using the keyword <I>var</I>, any class of objects can be stored in a <I>Point</I> object's instance variables.<P>
For class <I>Point</I>, there are class methods and instance methods. This is similar to Smalltalk. The class method <I>x_y_</I> can be used to construct (or create) an object of class <I>Point</I>. The <I>create</I> keyword in the first line of the method manufactures an object of class <I>Point</I> with two instance variables, <I>x</I> and <I>y</I>.<P>
The instance methods can be used to operate on the newly-created object. The <I>setXY</I> instance method is used to initialize the instance variables of the object and the <I>x</I> and <I>y</I> methods are used to access the values stored in the instance variables of the object. Methods look like functions in C, and class methods are denoted with the keyword <I>class</I>.<P>
In all methods, the return value is passed back in a variable that was arbitrarily called <I>r</I>. Unlike Smalltalk, C+@ supports multiple return values which are useful in debugging when extra information needs to be returned with the primary result. The extra information can be ignored when the message is returned.<P>
Once class <I>Point</I> is defined (see <a href="199302b4.htm">Figure 5</A>), it can be used as in <a href="199302b5.htm">Figure 6</A>. A <I>Point</I> object can be created by invoking the <I>x_y_</I> class method. This method is applied to the distinguished instance object. Once <I>Point</I> is created (via the method <I>x_y_</I>) a pointer is returned and stored in the variable <I>a_point</I>. The instance methods (<I>x</I> or <I>y</I>) can be sent to the object referenced by the variable, <I>a_point</I>. The <I>print</I> message can then be sent to the object returned from the respective instance method. As shown, the <I>print</I> method causes a value to be printed.<P>
A class can have more than one method defined with the same name but the number of arguments must be different. In <a href="#02ac_000a">Figure 7</A>, <I>Point</I> can be extended to include methods that can be used to set the instance variables <I>x</I> or <I>y</I>. These methods will each have an argument and therefore can be distinguished from the original methods that were used to access the instance variables.<P>
The keyword <I>private</I> (<a href="#02ac_000a">Figure 7</A>) can be used instead of <I>method</I> to prevent external access to the method. The <I>setXY</I> instance method is used in the <I>x_y_</I> class method to initialize the instance after creation.<P>
<h3><a name="02ac_0007">The C+@ Foundation Classes<a name="02ac_0007"></h3><P>
The <I>Clock</I> class (<a href="#02ac_000b">Listing One</A>, page 106) is one of over 350 classes included in the foundation class library. This class illustrates many of C+@'s features, including inheritance.<P>
Besides providing a flavor for the syntax of C+@, the <I>Clock</I> class illustrates how lightweight processes or threads are supported. The variable process is initialized to contain a <I>Process</I> object that acts as a scheduler for updating the clock. The method <I>clockLoop</I> is sent to the <I>Process</I> object and a <I>Timer</I> object is eventually created to block the process.<P>
The instance variables in the <I>Clock</I> class are tagged with the <I>Class</I> of the object that the variable will likely reference. In C+@, this can be used to provide you with additional information, but isn't essential. All of the instance variables could have been defined in the typeless manner.<P>
One of main advantages--and real tests--of true object-oriented systems is the ability to reuse other people's classes. To this end, numerous people have contributed to the more than 350 reusable C+@ classes. The foundation class library is organized into a hierarchy using a standard file system. The library includes demos, basic library classes, graphics classes, the C+@ compiler, and various tests and system classes. There are also a variety of serial and visual tools that can be used for examples. <a href="199302b6.htm">Figure 8</A> illustrates a small subset of the directories used to organize the source for the foundation classes.<P>
The binaries for all of the classes are also included with nondeveloper versions of the system. The binaries for the classes are also contained in standard files and are dynamically loaded when used. Usually the binaries are organized into a few directories, and are accessed via a view-path philosophy so that new classes can be tested by one user without impacting another user.<P>
The binaries are portable across various machine architectures. This allows you to develop a class library on a SPARC workstation and move it to an Intel x86-based system without recompiling the source code. This makes it especially attractive for developers who must ship their application for several target architectures.<P>
Besides the foundation classes, hundreds of other, more specialized classes have been developed for projects at AT&amp;T Bell Labs. The largest such project was a prototype switching system used for demonstrations of customer-programmable telecommunication services. This system consists of 175 classes above and beyond the foundation class library and over 75,000 lines of code.<P>
<h4> <a href="199302b7.htm">Figure 1</A>: Creating an object of class Point in C+@.  x and y are instance-variable names, 12 and 34 are instance-variable values.</h4><P>
<h4> <a href="199302b8.htm">Figure 2</A>: Creating an object of class rectangle in C+@.</h4><P>
<h4><a name="02ac_0008">Figure 3: Method selector syntax; (a) C+@; (b) Smalltalk<a name="02ac_0008"></h4><P>
<pre>(a)
   C+@ Binary Methods
      a=b + c;
      p=12 @ 34
   C+@ Unary/keyword Methods
      p=Rectangle.origin_corner_(12@34,100@200);
      x=p.origin;
(b)
   Smalltalk Binary Methods
      a&lt;=b+c
      p&lt;=12@34
   Smalltalk Keyword Method
      p&lt;=Rectangle origin: 12@34 corner: 100@200
   Smalltalk Unary Method
      x&lt;= p origin</pre><P>
<h4><a name="02ac_0009">Figure 4: Conditionals: (a) C+@; (b) SmallTalk<a name="02ac_0009"></h4><P>
<pre>(a)
if(queue.isEmpty) {
   index=0;
}
else{
   index=queue.next;
}
(b)
queue isEmpty
    ifTrue: [ index &lt;= 0]
    ifFalse: [ index &lt;= queue next]</pre><P>
<h4> <a href="199302b9.htm">Figure 5</A>: C+@ source-code structure for a class called Point</h4><P>
<h4> <a href="199302ba.htm">Figure 6</A>: Class methods and instance methods for class Point.</h4><P>
<h4><a name="02ac_000a">Figure 7: C+@ method selection based on argument count.<a name="02ac_000a"></h4><P>
<pre>class Point
{
/* instance variables */
var x; /* x coordinate */
var y; /* y coordinate */
/* class methods */
class method (r) x_y_ (a_x, a_y)
{
/*  create an object of class Point and set x=a_x and y=a_y */
    r = create;
    r.setXY(a_x,a_y);
}
/* instance methods */
private setXY (x_coordinate, y_coordinate)
{
    x = x_coordinate;
    y = y_coordinate;
}
method (r) x
{
    r = x;
}
method (r) x (value)
{
    x = value;
    r = self;
}
method (r) y
{
    r = y;
}
method (r) y (value)
{
    y = value;
    r = self;
}</pre><P>



<h4> <a href="199302bb.htm">Figure 8</A>: Overview of C+@ Foundation Class Library</h4><P>

<PRE>

_THE C+@ PROGRAMMING LANGUAGE_
by Jim Fleming

<a name="02ac_000b"><a name="02ac_000c"><B>[LISTING ONE]</B>

class Clock {
/* An instance of Clock is a window system application
* displaying an analog clock face with Roman Numerals. */
inherit View view;
/* constants */
const minExtent = (96@112);
const font = Font.new(Rroman.8S);
const iconFont = Font.new(Rbold.12S);
/* instance variables */
BlankView analog;
Bitmap icon;
Integer minuteHand;
Integer hourHand;
Point center;
Point minutePoint;
Point hourPoint;
Rectangle dayRectangle;
Process process;
/* CATEGORY: Creation  -- Create an instance of a Clock application. */
class method (_) new
{
    _ = create;
    Layer.new(_);
}
/* RESTRICTED CATEGORY: Initialization -- Initialize an instance of Clock. This
*  method is required by View paradigm. It links into view hierarchy by using
*  TaViewU as a delegate (of class View). */
method initialize (aView)
{
    Point p;
    Integer ox, oy, cx, cy;
    Integer y;
    Rectangle r;
    view = aView;
    p = view.extent;
    if (p.x &lt; minExtent.x || p.y &lt; minExtent.y) {
        view.topView.initializeFailed(true);
        return;
    }
    /* Create a BlankView */
    ox = 0;
    oy = 0;
    cx = p.x;
    cy = p.y;
    r = Rectangle.origin_corner_(ox@oy, cx@cy);
    analog = BlankView.basicNew;
    thisSelf.newSubView(r, 1, analog);
    thisSelf.init;
}
/* RESTRICTED CATEGORY: Window System Event Handling */
/* Receive a window event. If it is a resize event then adjust our subViews. */
method (_) windowEvent(minor, p)
{
    Integer ox, oy, cx, cy;
    Integer y;
    Rectangle r;
    if (minor @! Event.WINDOW_RESIZE_EVENT) return;
    p = view.extent;
    if (p.x &lt; minExtent.x || p.y &lt; minExtent.y) return;
    _ = thisSelf;
    process.terminate;
    ox = 0;
    oy = 0;
    cx = p.x;

   cy = p.y;
    r = Rectangle.origin_corner_(ox@oy, cx@cy);
    analog.adjustSubView(r);
    hourPoint = nil;
    minutePoint = nil;
    thisSelf.init;
}
method deleteLayerExit
{
    process.terminate;
}
/* RESTRICTED CATEGORY: Private -- Initialize an instance of Clock. Draw analog
* clock face and start a surrogate process to update clock time periodically.*/
private init
{
    Point p, q;
    Integer radius, xor, i, j;
    Float sin30, sin60;
    Integer n30, n60;
    Integer charHeight, charWidth;
    /* set up bitmap for clock icon */
    icon = Icon_OL.icon(RClockS, R     R);
    /* set up clock face */
    charHeight = font.charHeight(TAU);
    charWidth = font.charWidth(TAU);
    p = analog.rectangle.extent;
    p.y(p.y - 16);
    dayRectangle = Rectangle.origin_corner_(0@p.y,analog.rectangle.corner);
    if (p.x &gt; p.y)
        radius = (p.y / 2) - 2;
    else
        radius = (p.x / 2) - 2;
    center = (p.x / 2)@(p.y / 2);
    for (i=0; i &lt; 3; i = i + 1)
        analog.circle(center, radius-i, Bitmap.F_STORE);
    sin30 = (Float.fromInteger(30) * Float.radiansPerDegree)
        .sin;
    sin60 = (Float.fromInteger(60) * Float.radiansPerDegree)
        .sin;
    radius = radius - charHeight*2;
    n30 = (sin30 * Float.fromInteger(radius)).asInteger;
    n60 = (sin60 * Float.fromInteger(radius)).asInteger;
    q = (n30@n60) + center;
    thisSelf.centerString(analog, RVS, font, q);
    q = (n60@n30) + center;
    thisSelf.centerString(analog, RIVS, font, q);
    q = (radius@0) + center;
    thisSelf.centerString(analog, RIIIS, font, q);
    q = (n60@(-n30)) + center;
    thisSelf.centerString(analog, RIIS, font, q);
    q = (n30@(-n60)) + center;
    thisSelf.centerString(analog, RIS, font, q);
    q = (0@(-radius)) + center;
    thisSelf.centerString(analog, RXIIS, font, q);
    q = ((-n30)@(-n60)) + center;
    thisSelf.centerString(analog, RXIS, font, q);
    q = ((-n60)@(-n30)) + center;
    thisSelf.centerString(analog, RXS, font, q);
    q = ((-radius)@0) + center;
    thisSelf.centerString(analog, RIXS, font, q);
    q = ((-n60)@n30) + center;
    thisSelf.centerString(analog, RVIIIS, font, q);
    q = ((-n30)@n60) + center;
    thisSelf.centerString(analog, RVIIS, font, q);
    q = (0@radius) + center;
    thisSelf.centerString(analog, RVIS, font, q);

    j = radius / 20;
    for (i=1;i&lt;j;i=i+1)
        analog.circle(center, i, Bitmap.F_STORE);
    hourHand = radius / 2;
    minuteHand = radius * 3 / 4;
    /* create clock process */
    process = Process.new(thisSelf);
    process.clockLoop;
}
method centerString (aView, aString, aFont, aPoint)
{
    Integer x,y;
    Point p;
    x = aFont.xOfString(aString);
    y = aFont.yOfString(aString);
    p = aPoint - ((x/2)@(y/2));
    aView.string(aFont, aString, p, Bitmap.F_STORE);
}
method time (hours, minutes)
{
    Integer hq, mq;
    Integer length, x, y;
    Float hrads, mrads;
    String digital;

   hours = hours % 12;
    if (hours @= 0)
        digital = R12S;
    else if (hours &lt; 10)
        digital = R %S.sprintf(hours);
    else
        digital = R%S.sprintf(hours);
    if (minutes &lt; 10)
        digital = digital // R:0%S.sprintf(minutes);
    else
        digital = digital // R:%S.sprintf(minutes);
    Icon_OL.newString(digital, icon);
    thisSelf.layer.newIcon(icon);
    if (hours &lt; 3)
        hq = 1;
    else if (hours &lt; 6)
        hq = 2;
    else if (hours &lt; 9)
        hq = 3;
    else
        hq = 4;
    if (minutes &lt; 15)
        mq = 1;
    else if (minutes &lt; 30)
        mq = 2;
    else if (minutes &lt; 45)
        mq = 3;
    else
        mq = 4;
    hours = (hours % 3) * 60 + minutes;
    if (hq @= 2 || hq @= 4) hours = 179 - hours;
    minutes = minutes % 15;
    if (mq @= 2 || mq @= 4) minutes = 14 - minutes;
    hrads = Float.fromInteger(hours/2) * Float.radiansPerDegree;
    mrads = Float.fromInteger(minutes*6) * Float.radiansPerDegree;
    length = Float.fromInteger(hourHand);
    x = (hrads.sin * length).asInteger;
    y = (hrads.cos * length).asInteger;
    if (hq @= 1)
        y = -y;
    else if (hq @= 3)
        x = -x;
    else if (hq @= 4) {
        x = -x;
        y = -y;
    }
    analog.batchOn;
    if (hourPoint @! nil)
        analog.vector(center, hourPoint, Bitmap.F_XOR);
    hourPoint = center+(x@y);
    analog.vector(center, hourPoint, Bitmap.F_XOR);
    length = Float.fromInteger(minuteHand);
    x = (mrads.sin * length).asInteger;
    y = (mrads.cos * length).asInteger;
    if (mq @= 1)
        y = -y;
    else if (mq @= 3)
        x = -x;
    else if (mq @= 4) {
        x = -x;
        y = -y;
    }
    if (minutePoint @! nil)
        analog.vector(center, minutePoint, Bitmap.F_XOR);
    minutePoint = center+(x@y);
    analog.vector(center, minutePoint, Bitmap.F_XOR);
    analog.batchOff;
}
method clockLoop
{
    Date time, lastTime;
    lastTime = Date.now - 3601*24;
    for (;;) {
        if (!view.layer.isAlive) {
            /* Our layer has been deleted */
            Process.running.terminate;
        }
        time = Date.now;
        if (time.minute @! lastTime.minute) {
            thisSelf.time(time.hour, time.minute);
            if (time.dayOfMonth @! lastTime.dayOfMonth) {
                analog.rectf(dayRectangle, Bitmap.F_CLR);
                thisSelf.centerString(analog,
                    time.dayOfWeekString[0,3] &lt;&lt; R, R &lt;&lt;
                        time.monthString &lt;&lt;
                          R R &lt;&lt; time.dayOfMonth.asString,
                    iconFont, dayRectangle.center);
            }
        }
        lastTime = time;
        Timer.sleep(60 - Date.now.second);
    }
}
/* end of class Clock */
}



</pre><HR><P>Copyright &copy; 1993, <I>Dr. Dobb's Journal</I></P></BODY></HTML>
