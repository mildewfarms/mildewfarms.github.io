<HTML>
<META NAME="year" CONTENT="1993">
<HEAD>
<TITLE>SP93: Getting to Know TrueType</TITLE></HEAD>
<BODY BGCOLOR="#ffffff">
<h1>Getting to Know TrueType<a name="03e4_0003"></h1><P>
<h2><a name="03e4_0001"><a name="03e4_0000">Meeting some interesting characters</h2><P>
<h3>Steven Reichenthal</h3><P>
<p><i><a name="03e4_0002"><a name="03e4_0000">Steve develops Windows CAD  applications and teaches object-oriented programming. He received an MS in computer science from Cal State Fullerton with an emphasis in graphics. Steve can be reached at xsreiche@aunix. fullerton.edu.</i></p><hr><P>
Although Windows 3.1 has been out for some time, a few of its features are only now moving into many programmers' field of view. One such feature is the built-in support for outline fonts, which uses the TrueType format defined by Microsoft and Apple.<P>
In this article, I'll describe the TrueType format and how fonts are rendered, then show how a new function in the Windows API, <I>GetGlyphOutline()</I>, can be used to create a simple font-viewing program. But first, some background on digital fonts.<P>
<h3><a name="03e4_0004">Flavors of Fonts<a name="03e4_0004"></h3><P>
The early versions of Windows only supported two font formats: bitmap and vector. As you know, bitmap fonts represent a character shape simply by selectively coloring a grid of pixels. Bitmap fonts can be displayed quickly, and, if properly designed, they look very good at the size at which they were created. But when scaled to larger sizes, the resulting &quot;jaggies&quot; look terrible and have given bitmap fonts a bad name. Nevertheless, for high-quality results at low screen resolutions, nothing beats a hand-tuned bitmap font in readability.<P>
Vector fonts are more scalable than bitmaps, but don't look as good--either at the original size or enlarged. Vector fonts represent character shapes via straight-line segments. They have a &quot;CAD look&quot; to them, because the space between the lines doesn't get filled in. When scaled large enough, the characters look very thin. Also, since curved features are rendered via straight lines, at a certain size these straight edges and corners are glaringly visible.<P>
Outline-based fonts such as TrueType combine the best features of both vector and raster fonts without the disadvantages of either, by representing characters with mathematical outlines instead of simple strokes or a raster grid of pixels. Outline fonts are not new with TrueType; they have been used in electronic publishing systems for over 20 years, initially in imaging or typesetting systems, and more recently in interactive desktop systems. The approach used by TrueType has much in common with these older systems, but has also pushed the technology further in the areas of font rendering and hinting (discussed later).<P>
In TrueType, a character's outline is defined by combinations of lines and curves. An outline can be scaled to fit a wide range of sizes, and then filled in to result in a high-quality bitmap font at the desired size. The scaling and rendering process happens at run time. Once in bitmap form, TrueType fonts can be displayed as quickly as raster fonts. Conversion of an entire font at a given size usually takes only a second or two, depending on the sizes of the bitmaps and the speed of the computer. Once converted, Windows stores the bitmaps in a font cache where they are used over and over.<P>
TrueType brings with it the specialized terminology of typography and digital fonts, as well as introducing its own terms. Character figures are called &quot;glyphs.&quot; The outlines that describe glyphs are collections of closed curves called &quot;contours.&quot; For example, the glyph outline for the lowercase &quot;i&quot; consists of two contours: one for the dot and one for the stem. The lowercase &quot;b&quot; also has two contours: an outer one and an inner one. Contours are defined by ordered sequences of points, sometimes called &quot;control points.&quot; Each point is specified to be either on or off of the contour. If two consecutive points are on the contour, a straight line connects them, otherwise a smooth curve is tangent to them. The points may range from --16,384 to 16,383 in units known as &quot;font units&quot; or &quot;FUnits.&quot; Points specify locations relative to a grid called the &quot;EM square.&quot; The fonts supplied with Windows happen to use 2048 FUnits per EM.<P>
TrueType font files have the TTF extension and are stored in the Windows System directory. For example, the file ARIAL.TTF contains the normal (i.e. not bold or italic) font for the Arial typeface. These files consist of a series of tables. One table (glyf) contains the points and &quot;hints&quot; that describe the outlines of the character figures. Another table (<I>cmap</I>) indexes the characters in the glyf table. TTF files also contain a table called <I>head </I>that provides scaling information. There are 16 other defined tables that may appear--but these three tell us the most about the inner workings of the rendering process.<P>
<h3><a name="03e4_0005">The Three Rendering Stages<a name="03e4_0005"></h3><P>
As shown in <a href="199303e6.htm">Figure 1</A>, each glyph outline goes through three transformations before emerging as a bitmap. The transformations are accomplished by three TrueType modules known as the Scaler, Interpreter, and Rasterizer. First, the Scaler shrinks (or stretches) the outline to the requested size. Then the Interpreter grid fits the scaled outline by executing instructions (&quot;hints&quot;) attached to the glyph. The resulting outline goes to the Rasterizer to generate a bitmap.<P>
As an example, consider the rendering process applied to the letter &quot;b&quot; of the Arial font, displayed at 14 points in EGA resolution. The Scaler converts coordinates from font units into device units (pixels). Most EGA monitors display 96 pixels per inch horizontally and 72 pixels per inch vertically. In the TTF file, the glyph for the letter &quot;b&quot; is 921 FUnits wide and 1490 FUnits high on a scale of 2048 FUnits per EM. The resulting scaled dimensions are 8.39 pixels wide and 10.19 pixels high on the EGA screen. <a href="199303e7.htm">Figure 2</A>(a) shows the scaled outline mapped to a pixel grid.<P>
In scaling glyphs down to small sizes, it often becomes unclear whether a given pixel belongs to the glyph or not. This decision is critical if a glyph is scaled so small that a typographic feature occupies only a single pixel; because if even one pixel is missing or out of place, the glyph may become illegible. In a process called &quot;grid fitting,&quot; the Interpreter uses the &quot;hints&quot; associated with the glyph to distort the scaled outline so that it improves the appearance of the bitmap.<P>
One advance of TrueType over older outline-font technology is the sophistication of its hinting mechanism. Hints are not passive data structures, as their name implies, but active software programs that literally take control of the Interpreter. The TrueType instruction set resembles assembly language, complete with opcodes and mnemonics for If/Then constructs, loops, subroutines, and a full complement of arithmetic and logical operations. For example, the MD instruction measures the distance between two outline points and pushes the result on the Interpreter's stack--to possibly serve as part of a further calculation.<P>
A similar instruction, MPS, makes it possible to measure the current point size, perhaps as a basis for choosing an alternate path through the instruction stream. Grid-fitting is also aided by the RTG instruction that aligns points to the nearest grid line. There are over 120 different instructions. Fortunately, they are generated automatically by font editors. <a href="199303e8.htm">Figure 2</A>(b) shows the outlines after hints are applied.<P>
After the Interpreter makes the necessary adjustments, it sends the grid-<P>fitted outline to the Rasterizer to produce a bitmap. The Rasterizer fills in the outline by following a simple rule: It turns on only those pixels whose center lies either inside or exactly on the outline of the glyph. The grids in Figures 2(a) and 2(b) indicate the center of a pixel with a dot. By analyzing the direction traveled between any two points, the Rasterizer can always determine where the inside of the glyph is. The points are ordered such that as it follows along the outline in the direction from one point to another, the inside is always to the right.<P>
<h3><a name="03e4_0006">Using <I>GetGlyphOutline</I><a name="03e4_0006"></h3><P>
If you want to experiment with TrueType glyph outlines, the Windows 3.1 API provides the <I>GetGlyphOutline</I> function and a few specialized data structures. This function retrieves the same fully scaled and hinted outline that the Rasterizer gets. The function takes a device context, a character in the current font, and the address of a buffer where it will store the glyph data. We usually need to call this function with a NULL buffer the first time so that it can return the required buffer size. <I>GetGlyphOutline</I> returns information about the dimensions of the glyph in a GLYPHMETRICS structure.<P>
The points that describe a glyph outline use fixed-point numbers, which can carry 16 bits of fractional precision. Fractional precision is not only necessary for accurately scaling and rotating the points, but should be maintained when computing the curves. Both popular techniques for rendering polynomial curves--forward differencing and subdivision--require some degree of fractional precision, although subdivision usually requires less. The Windows header file defines FIXED as a structure with two 16-bit components: an integer part and a fractional part. It also defines fixed-point coordinates using a POINTFX structure that contains two FIXED structures.<P>
It's easy to carry out any necessary math if we treat FIXED structures as signed longs, noting that the <I>n</I>th bit starting at 0 has a value of 2<I>n</I>--16. For example, the long number 65,536 corresponds to the real number 1; the long number 32,768 corresponds to the real number 0.5, and so on. When dealing with POINTFX structures, it's convenient to define a structure called LONGPOINT and use a type cast. The structure is:<P>
<pre>struct LONGPOINT
        {
        long x, y;
        };
</pre><P>
The glyph data from <I>GetGlyphOutline</I> is returned in a buffer containing each contour of the outline. Parts of a contour can be a mixture of straight lines or curves. Each contour begins with a 16-byte TTPOLYGONHEADER structure. The first data member, <I>cb</I>, specifies the number of bytes in the contour--in other words, the next contour, if any, starts exactly <I>cb</I> bytes from the beginning of the current one. This structure also contains the <I>pfxStart</I> member which denotes the first (and last) point on the contour.<P>
One or more TTPOLYCURVE records immediately follow the header. Each contains a variably sized array called <I>apfx,</I> which holds the actual points (POINTFX structures) that define a curve or polyline on the contour. The <I>wType</I> member indicates whether the points represent polylines (with the value TT_PRIM_LINE) or quadratic B-splines (with the value TT_PRIM_QSPLINE). Naturally, since the array can contain any number of points, this record has a member <I>cpfx</I> that specifies how many.<P>
Here's the rule for connecting sequences of curves: Every curve automatically begins where the last point on the previous curve ends--unless it's the first curve, which begins at <I>pfxStart</I>. This way each point is specified only once. When the last point on the last curve is different from <I>pfxStart</I>, a straight line should be drawn between the two points, closing the contour.<P>
<I>GetGlyphOutline</I> also requires, as a parameter, a two-dimensional transformation matrix of type MAT2. Since this structure contains four FIXED numbers, we can play the same kind of trick that we used with POINTFX: typecast the MAT2 variable and manipulate it as an array of longs. Be careful, however, with the values you put in this matrix because <I>GetGlyphOutline</I> can overflow--causing an unrecoverable application error (UAE). Although the identity matrix works well, there may be times when you want a glyph rotated. If you plan to rotate a glyph, be prepared to do a suitable translation because all rotations are about the origin of the glyph's coordinate system. Naturally, we can forego transformations within the required matrix and provide our own transformations. The demonstration program for this article shows how to add some special effects to font renderings.<P>
To render a filled character from the outline data, we can either write our own rasterizer (a lot of work) or use the <I>PolyPolygon</I> function in the Windows API. Although <I>PolyPolygon</I> uses a different algorithm from the TrueType Rasterizer to determine the interior of a figure, the results are usually excellent for characters greater than 25 points or so. Smaller characters, however, suffer in quality due to the rounding that occurs when converting from FIXED points to POINT points. One advantage to using this function is that we can get textured renderings by using a pattern brush. Since <I>PolyPolygon</I> requires a complete array of points, we must make sure to allocate enough memory to store all of the points.<P>
<h3><a name="03e4_0007">A Glyph-viewing Program<a name="03e4_0007"></h3><P>
My TrueType Font Demo program decodes and displays the outline data from <I>GetGlyphOutline</I> for any character entered at the keyboard. As indicated in the title bar of the main window, the current font may be changed from the File menu by choosing New. An Options menu also lets the user change the fill style, display control points, and apply special effects.<P>
The code is in <a href="#03e4_000a">Listing One</A> (page 60). At startup, the program does the usual Windows initialization: registering a window class, creating a main window, and cycling through the message loop. At this point, it selects the default font, Arial, and the character &quot;a.&quot; The corresponding screen display is shown in <a href="199303e9.htm">Figure 3</A>. To select a different font, the program calls <I>ChooseFont,</I> which brings up the Font dialog box. The selection of fonts here is restricted to TrueType fonts only. If the user chooses OK, the function returns True and stores the information about the font in a global LOGFONT structure.<P>
When the user changes the font, chooses an option, or types a character, the program stores that information and then forces a repaint of the window. Repainting involves creating a font and a brush with the current settings, and then calling <I>draw_glyph_outline</I> to render the current character.<P>
The <I>draw_glyph_outline</I> function takes, as arguments, the device context, the location of the upper corner of the character, and the desired character to be displayed. It first calls <I>GetGlyphOutline</I> to fill a buffer with the outline data for the character. It then calls <I>compute_memory_requirement</I> and allocates enough memory to hold the array of contour points that eventually get passed to <I>PolyPolygon</I>. Next, it walks through the data in a doubly nested loop. The outer loop finds each closed outline and sends it to the inner loop, which in turn steps through the individual pieces of the outline. The inner loop passes the groups of control points to <I>draw_polyline</I> and <I>draw_quadratic_bspline</I> as directed by the <I>wType</I> member of the TTPOLYCURVE structure. Before drawing an individual curve, it first modifies the point array (<I>apfx</I>) by inserting the last point of the previous curve at the beginning so that each group of control points is independent from its predecessor. Then it calls the <I>transform</I> function.<P>
The <I>compute_memory_requirement</I> function steps through the outline data in the same manner as <I>draw_glyph_outline</I>. When it encounters a polyline, it advances the count variable by the number of vertices. When it encounters a B-spline, it advances the count by the number of B&eacute;zier curve segments multiplied by the maximum number of points in each segment. At the end, it returns the maximum number of bytes required to hold the array of contour points.<P>
The <I>transform</I> function produces special effects by moving the control points of the outline. If the user has chosen Pinch from the options menu, then this function will pull control points nearing the center of the character even closer. This results in a cartoon-like effect. If you choose Punch from the menu, then the points near the center are pushed farther away--resulting in a bloating effect.<P>
When <I>draw_polyline</I> receives the address and size of an array of POINTFX structures representing vertices, it stores each point at the end of the array of contour points. Likewise, <I>draw_quadratic_bspline</I> takes the address and size of an array of POINTFX structures. If a curve has three control points, these are sent unmodified to <I>draw_Bezier_curve</I>. Otherwise, the B&eacute;zier conversion method is applied to each consecutive three-point grouping and the results sent individually to <I>draw_Bezier_curve</I>.<P>
Producing a smooth curve depends on <I>draw_Bezier_curve</I>. Since it uses recursive subdivision, the quality of the shape depends on the depth of the recursion. There is a trade-off here since the more points it stores, the slower the curve will draw. The depth is set at 8 for this program, which means only three bits of fractional precision are required for accuracy. POINTFX structures keep 16 bits of fractional precision so there are no round-off problems when computing the curve. With a depth of 8, a maximum of 257 points along a curve can be stored. But this storage requirement grows exponentially as the depth increases.<P>
Conversion of a POINTFX value to a window coordinate takes place in <I>fixed_to_int,</I> which selects the closest pixel by rounding the FIXED values to the nearest whole number. Rounding points to the nearest pixel produces good results when the glyphs are large, but achieving higher quality at small sizes requires an algorithm based on the method used by the Rasterizer.<P>
<h3><a name="03e4_0008">References<a name="03e4_0008"></h3><P>
Foley, James, Andries van Dam, Steven K. Feiner, and John F. Hughes. <I>Computer Graphics: Principles and Practice, </I>second edition. Reading, MA: Addison-Wesley, 1990.<P>
Rubinstein, Richard. <I>Digital Typography</I>. Reading, MA: Addison-Wesley, 1988.<P>
<I>TrueType Font Files</I>. Microsoft Corporation, 1991.<P>
<h4><B> <a href="199303ea.htm">Figure 1</A>:</B> The TrueType rendering pipeline.</h4><P>
<h4><B> <a href="199303eb.htm">Figure 2</A>:</B> (a) A scaled outline before grid fitting; (b) the result of grid fitting.</h4><P>
<h4><B> <a href="199303ec.htm">Figure 3</A>:</B> A glyph-viewing program.</h4><P>
<a name="03e4_0009">The Mathematics of Quadratic B-splines<a name="03e4_0009"><P>
The implementors of TrueType chose splines as the means for representing curves. You can think of splines as a series of simple polynomial curves smoothly spliced together. For a quadratic spline, each piece (or segment) is described by a quadratic polynomial function of the form <I>y(x)=ax<SUP>2</SUP>+bx+c</I>, where <I>a</I>, <I>b</I>, and <I>c</I> are constant coefficients. Remember from algebra that this function produces a parabola. It has only one point of inflection and depending on the coefficient <I>a</I>, opens either upward or downward. But, for free-form quadratic splines like the ones in TrueType, we need parabolas that can open not only up and down, but in any direction. That's why curves are typically represented parametrically. In two dimensions we plot the functions <I>x(t)=axt<SUP>2</SUP>+bxt+cx</I> and <I>y(t)=ayt<SUP>2</SUP>+<P>byt+cy</I>.<P>
By restricting the variable <I>t</I> to the closed interval between 0 and 1, a curve segment has definite starting and ending coordinate, and can open in any direction. Each function requires three coefficients.<P>
In the early '70s Pierre B&eacute;zier, a mathematician working for the French automaker Renault, devised a clever way of blending three points, called &quot;control points,&quot; to obtain the coefficients such that a curve segment connects to the two endpoints and pulls toward the other point. The function for a quadratic B&eacute;zier curve is: <I>Q(t)=t<SUP>2</SUP>(B<SUB>0</SUB>-2B<SUB>1</SUB>+B<SUB>2</SUB>)+t(-2B<SUB>0</SUB>+2B<SUB>1</SUB>)+B</I> where each <I>B<SUB>i</SUB></I> is a control point. <a href="199303ed.htm">Figure 4</A> shows what a quadratic B&eacute;zier curve looks like. It's easy to verify mathematically that it connects to the endpoints by evaluating the function for <I>t</I> equal to 0, and then 1. For simplicity, we can also describe the curve as function of its control points. For instance, <I>Bezier (B<SUB>0</SUB>, B<SUB>1</SUB>, B<SUB>2</SUB>) </I>equals the drawing in <a href="199303ee.htm">Figure 4</A>.<P>
What makes B&eacute;zier curves attractive is that your program can render them without fully evaluating the polynomials, using a fast algorithm known as the deCasteljau algorithm. Given the three control points for a B&eacute;zier curve, the algorithm uses a series of recursive subdivision operations to render the curve. Each subdivision splits a B&eacute;zier curve into two smaller B&eacute;zier curves and generates a point on the original curve. <a href="199303ef.htm">Figure 4</A> shows one subdivision. If the points are integer coordinates, then only a few shifts and adds are required at each subdivision step. Once the curve has been divided enough times, you can connect the resulting points on the curve with straight lines.<P>
Quadratic B-splines, which can have three or more control points, can be converted into quadratic B&eacute;zier curves by choosing each consecutive point and the two points that follow. For example, a spline with seven points converts to five B&eacute;zier curve segments by choosing:<P>
{(P<SUB>0</SUB>,P<SUB>1</SUB>,P<SUB>2</SUB>),
(P<SUB>1</SUB>,P<SUB>2</SUB>,P<SUB>3</SUB>),
(P<SUB>2</SUB>,P<SUB>3</SUB>,P<SUB>4</SUB>),
(P<SUB>3</SUB>,P<SUB>4</SUB>,P<SUB>5</SUB>),
(P<SUB>4</SUB>,P<SUB>5</SUB>,P<SUB>6</SUB>)}<P>
You can then use the following rules to find the B&eacute;zier curve segments:<P>
<OL>
<LI><I>Bezier (P<SUB>0</SUB>,P<SUB>1</SUB>,P<SUB>2</SUB>)</I>, when the spline has exactly one curve segment (3 points).</LI>
<LI><I>Bezier (P<SUB>0</SUB>,P<SUB>1</SUB>,(P<SUB>1</SUB>+P<SUB>2</SUB>)/2)</I>, for the first segment.</LI>
<LI><I>Bezier ((P<SUB>i</SUB>+P<SUB>i</SUB>+1)/2, P<SUB>i</SUB>+1,(P<SUB>i</SUB>+1+<P>P<SUB>i</SUB>+2)/2)</I>, for the interior segments.</LI>
<LI><I>Bezier ((P<SUB>n-3</SUB>+P<SUB>n-2</SUB>)/2, P<SUB>n-2</SUB>, P<SUB>n-1</SUB>)</I>, for the last segment.</LI>
</OL>
Rule #3 is the uniform conversion applied to the inner curve segments. Rules #1, #2, and #4, are called &quot;end conditions,&quot; because uniform B-splines don't ordinarily connect to their endpoints--as we need them to.<P>
--S.R.<P>
<h4><B> <a href="199303f0.htm">Figure 4</A>:</B> Quadratic B&eacute;zier curve showing one level of subdivision.</h4><P>

<HR>

<h4><a name="03e4_000a"><a name="03e4_000b"><B>[LISTING ONE]</B></H4>

<PRE>

/***************************************************************************
 * Glyph viewing program by Steven Reichenthal, 1993. Although this code
 * is basically C, it uses certain C++ constructs such as in-place
 * declaration of variables that require use of a C++ compiler.
 **************************************************************************/

#include &lt;windows.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;commdlg.h&gt;
#include &lt;math.h&gt;

#define IDM_NEW                 101     // File Menu ID's
#define IDM_EXIT                108

#define MARKERSIZE              4

#define IDM_SHOWCONTROLPOINTS   402
#define IDM_FILL                403
#define IDM_OUTLINE             404
#define IDM_NORMAL              405
#define IDM_PINCH               406
#define IDM_PUNCH               407

long FAR PASCAL WndProc (HWND hwnd, unsigned iMessage, WORD wParam,
LONG lParam);

HANDLE          hInst;
HWND            hwnd;
HDC             hdc;
PAINTSTRUCT     ps;
HWND            hwndFrame;
WORD            maxClient;
WORD            cxClient,cyClient;
LOGFONT         lf;
CHOOSEFONT      cf;
int             character;
int             nEffect;
BOOL            bShowControlPoints = TRUE;
BOOL            bFill;
BOOL            bOutline = TRUE;
float           pi;

static char  szAppName [] = &quot;TrueType Font Demo&quot;;

/*----------------------------------------------------------------------*/
// set the caption for the frame window
void set_frame_caption ()
{
    char sz [80];
    wsprintf (sz, &quot;%s - %s&quot;, (LPSTR) szAppName, (LPSTR) lf.lfFaceName);
    SetWindowText (hwndFrame, sz);
}
/*----------------------------------------------------------------------*/
#pragma argsused
int PASCAL WinMain (HANDLE hInstance, HANDLE hPrevInstance,
    LPSTR lpszCmdLine, int nCmdShow)
{
    HWND hwnd;
    MSG msg;
    hInst = hInstance;

    if (!hPrevInstance)
    {   WNDCLASS wc;
        wc.style = CS_HREDRAW | CS_VREDRAW | CS_BYTEALIGNWINDOW;
        wc.lpfnWndProc = (WNDPROC) WndProc;
        wc.cbClsExtra = 0;
        wc.cbWndExtra = 0;
        wc.hInstance = hInstance;
        wc.hIcon = 0;
        wc.hCursor = LoadCursor (NULL, IDC_ARROW);
        wc.hbrBackground = GetStockObject (WHITE_BRUSH);
        wc.lpszMenuName = &quot;MENU_1&quot;;
        wc.lpszClassName = szAppName;

        if (!RegisterClass (&amp;wc))   return FALSE;
    }
    pi = atan2 (0, -1);
    lf.lfHeight = -200;
    lf.lfWeight = 400;
    strcpy (lf.lfFaceName, &quot;Arial&quot;);
    character = 'a';

    hwnd = CreateWindow (szAppName, szAppName,
        WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN | WS_CLIPSIBLINGS,
        CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
        NULL, NULL, hInstance, NULL);

    if(!hwnd) return FALSE;

    hwndFrame = hwnd;

    set_frame_caption ();
    ShowWindow (hwnd, nCmdShow);
    UpdateWindow (hwnd);

    while (GetMessage (&amp;msg, NULL, NULL, NULL))
    {
        TranslateMessage (&amp;msg);
        DispatchMessage (&amp;msg);
    }
    return msg.wParam;
}
/*----------------------------------------------------------------------*/
int xOffset,yOffset;
struct LONGPOINT
{
    long x, y;
};
/*----------------------------------------------------------------------*/
inline int fixed_to_int (long value) // convert a fixed value to an integer
{
    return (value + 32767) &gt;&gt; 16;
}

// draw the array of control points
void draw_control_points (POINTFX pt [], int nPoints)
{   int i;
    LONGPOINT *p = (LONGPOINT *) pt;

    if (!bShowControlPoints)
        return;
    for (i = 0; i &lt; nPoints; i++)
    {
        POINT pt;
        pt.x = xOffset + fixed_to_int (p [i].x);
        pt.y = yOffset - fixed_to_int (p [i].y);
        PatBlt (hdc,
            pt.x - MARKERSIZE / 2, pt.y - MARKERSIZE / 2,
            MARKERSIZE, MARKERSIZE, BLACKNESS);
    }
}
/*----------------------------------------------------------------------*/
#define DEPTH                   8       // Bezier recursion depth
#define MAX_BEZIER_POINTS       ((1 &lt;&lt; DEPTH) + 1)

static POINT huge *     Pts;            // array of contour points
static POINT huge *     pPts;           // current point
static POINT huge *     pPtsStart;      // first contour point
static int *            polyCounts;     // array of coutour point counts
static int              nContours;      // number of contours
static GLYPHMETRICS     gm;

/*----------------------------------------------------------------------*/
// transform the array of control points
void transform (POINTFX pt [], int nPoints)
{
    LONGPOINT *p = (LONGPOINT *) pt;

    switch (nEffect)
    {
    case IDM_NORMAL:   return;

    case IDM_PINCH:
        while (nPoints--)
        {
            float xx = 2.0 * pi * float ((p-&gt;x &gt;&gt; 16) - gm.gmptGlyphOrigin.x)
                / float (gm.gmBlackBoxX);
            float yy = 2.0 * pi * float ((p-&gt;y &gt;&gt; 16) - gm.gmptGlyphOrigin.y)
                / float (gm.gmBlackBoxY);
            p-&gt;x = p-&gt;x + float (gm.gmBlackBoxX) / 10.0 * 65536.0 * sin (xx);
            p-&gt;y = p-&gt;y + float (gm.gmBlackBoxY) / 10.0 * 65536.0 * sin (yy);
            p++;
        }
        break;
    case IDM_PUNCH:
        while (nPoints--)
        {
            float xx = 2 * pi * float ((p-&gt;x &gt;&gt; 16) - gm.gmptGlyphOrigin.x)
                / float (gm.gmBlackBoxX);
            float yy = 2 * pi * float ((p-&gt;y &gt;&gt; 16) - gm.gmptGlyphOrigin.y)
                / float (gm.gmBlackBoxY);
            p-&gt;x = p-&gt;x + float (gm.gmBlackBoxX) / 5.0 * 32768.0
            * (1 + cos (yy) * sin (xx));
            p-&gt;y = p-&gt;y + float (gm.gmBlackBoxY) / 5.0 * 32768.0
            * (1 + cos (xx) * sin (yy));
            p++;
        }
        break;
    }
}
/*----------------------------------------------------------------------*/
// store a point in the array of contour points
void store (LONGPOINT pt)
{
    pPts-&gt;x = xOffset + fixed_to_int (pt.x);
    pPts-&gt;y = yOffset - fixed_to_int (pt.y);
    pPts++;
}

// sub-divide the quadratic Bezier curve
void near pascal sub_divide (LONGPOINT p [])
{
    static int depth = DEPTH;
    LONGPOINT q [8];

    int x = xOffset + fixed_to_int (p [2].x);
    int y = yOffset - fixed_to_int (p [2].y);

    if (x == pPts [-1].x &amp;&amp; y == pPts [-1].y)    return;

    if (!depth)
    {
        store (p [2]);
        return;
    }
    q [0] = p [0];
    q [4] = p [2];

    q [1].x = (p [0].x + p [1].x) &gt;&gt; 1;
    q [3].x = (p [1].x + p [2].x) &gt;&gt; 1;
    q [2].x = (q [1].x + q [3].x) &gt;&gt; 1;

    q [1].y = (p [0].y + p [1].y) &gt;&gt; 1;
    q [3].y = (p [1].y + p [2].y) &gt;&gt; 1;
    q [2].y = (q [1].y + q [3].y) &gt;&gt; 1;

    depth--;
    sub_divide (q);
    sub_divide (q + 2);
    depth++;
}
/*----------------------------------------------------------------------*/
// draw the quadratic Bezier curve
void draw_bezier_curve (LONGPOINT p [])
{
    store (p [0]);
    sub_divide (p);
}
/*----------------------------------------------------------------------*/
// draw the quadratic B-spline from the array of points
void draw_quadratic_bspline (POINTFX pt [], int nPoints)
{
    LONGPOINT b [3];
    LONGPOINT *p = (LONGPOINT *) pt;

    if (nPoints == 3)
    {
        draw_bezier_curve (p);
        return;
    }
    b [0] = p [0];
    b [1] = p [1];
    b [2].x = (p [1].x + p [2].x) &gt;&gt; 1;
    b [2].y = (p [1].y + p [2].y) &gt;&gt; 1;

    draw_bezier_curve (b);

    for (int i = 1; i &lt; nPoints - 3; i++)
    {
        b [0].x = (p [i].x + p [i + 1].x) &gt;&gt; 1;
        b [0].y = (p [i].y + p [i + 1].y) &gt;&gt; 1;
        b [1] = p [i + 1];
        b [2].x = (p [i + 1].x + p [i + 2].x) &gt;&gt; 1;
        b [2].y = (p [i + 1].y + p [i + 2].y) &gt;&gt; 1;

        draw_bezier_curve (b);
    }
    b [0].x = (p [i].x + p [i + 1].x) &gt;&gt; 1;
    b [0].y = (p [i].y + p [i + 1].y) &gt;&gt; 1;
    b [1] = p [i + 1];
    b [2] = p [i + 2];

    draw_bezier_curve (b);
}
/*----------------------------------------------------------------------*/
// draw the polyline from the array of points
void draw_polyline (POINTFX points [], int nPoints)
{
    LONGPOINT *p = (LONGPOINT *) points;

    for (int i = 0; i &lt; nPoints; i++)
        store (p [i]);
}
/*----------------------------------------------------------------------*/
// calculate the number of bytes needed for the array of contour points
DWORD compute_memory_requirement (TTPOLYGONHEADER *header, DWORD cbBuffer)
{
    DWORD count = 1;
    do
    {
        TTPOLYGONHEADER *nextHeader =
        (TTPOLYGONHEADER *) (header-&gt;cb + (char *) header);
        TTPOLYCURVE *curve = (TTPOLYCURVE *) (header + 1);
        POINTFX pfxStart = header-&gt;pfxStart;

        while (1)
        {
            UINT cpfx = curve-&gt;cpfx + 1;
            POINTFX *ppfx = curve-&gt;apfx - 1;
            POINTFX pfxEnd = ppfx [cpfx - 1];

            if (curve-&gt;wType == TT_PRIM_LINE)
                count += cpfx;
            else
                count += (cpfx - 2) * MAX_BEZIER_POINTS;

            curve = (TTPOLYCURVE *) (ppfx + cpfx);
            if (nextHeader &lt;= (TTPOLYGONHEADER *) curve)
            {
                if (memcmp (&amp;pfxEnd, &amp;pfxStart, sizeof (pfxEnd)))
                    count += 2;
                break;
            }
        }
        count++;
        cbBuffer -= header-&gt;cb;
        header = nextHeader;
    }
    while (cbBuffer);

    return count * (DWORD) sizeof (POINT);
}
/*----------------------------------------------------------------------*/
// draw the glyph outline of the selected character in the current font
int draw_glyph_outline (HDC hdc, int x, int y, int ch)
{
    TEXTMETRIC tm;
    MAT2 mat2;

    GetTextMetrics (hdc, &amp;tm);
    xOffset = x;
    yOffset = (y + tm.tmAscent);

    memset (&amp;mat2, 0, sizeof (mat2));
    mat2.eM11.value = 1;
    mat2.eM22.value = 1;

    DWORD cbBuffer = GetGlyphOutline (hdc,
          ch, GGO_NATIVE, &amp;gm, 0, NULL, &amp;mat2);
    if (long (cbBuffer) &lt;= 0 || cbBuffer &gt; 32767)
        return 0;

    void *buffer = malloc (int (cbBuffer));
    if (!buffer)
        return 0;

    GetGlyphOutline (hdc, ch, GGO_NATIVE, &amp;gm, cbBuffer, buffer, &amp;mat2);
    TTPOLYGONHEADER *header = (TTPOLYGONHEADER *) buffer;

    DWORD cbPolygons = compute_memory_requirement (header, cbBuffer);
    HANDLE hPolygons = GlobalAlloc (GMEM_FIXED, cbPolygons);
    if (!hPolygons)
    {
        free (buffer);
        return 0;
    }
    Pts = (POINT huge *) GlobalLock (hPolygons);
    pPts = Pts;
    nContours = 0;
    polyCounts = ((int *) header)+2;  //use the area beyond cb for the counts
    do
    {
        TTPOLYGONHEADER *nextHeader =
        (TTPOLYGONHEADER *) (header-&gt;cb + (char *) header);
        TTPOLYCURVE *curve = (TTPOLYCURVE *) (header + 1);
        POINTFX pfxEnd = header-&gt;pfxStart;
        POINTFX pfxStart = pfxEnd;
        pPtsStart = pPts;

        while (1)
        {
            UINT wType = curve-&gt;wType;
            UINT cpfx = curve-&gt;cpfx + 1;
            POINTFX *ppfx = curve-&gt;apfx - 1;
            ppfx [0] = pfxEnd;        // this overwrites 8 bytes before apfx,
            // but we are done with them at this point.
            pfxEnd = ppfx [cpfx - 1];

            transform (ppfx, cpfx);
            draw_control_points (ppfx, cpfx);

            if (wType == TT_PRIM_LINE)
                draw_polyline (ppfx, cpfx);
            else
                draw_quadratic_bspline (ppfx, cpfx);

            curve = (TTPOLYCURVE *) (ppfx + cpfx);
            if (nextHeader &lt;= (TTPOLYGONHEADER *) curve)
            {
                if (memcmp (&amp;pfxEnd, &amp;pfxStart, sizeof (pfxEnd)))
                {
                    ppfx [0] = pfxEnd;
                    ppfx [1] = pfxStart;
                    transform (ppfx, 2);
                    draw_polyline (ppfx, 2);
                }
                break;
            }
        }
        *pPts++ = *pPtsStart;
        polyCounts [nContours++] = pPts - pPtsStart;
        cbBuffer -= header-&gt;cb;
        header = nextHeader;
    }
    while (cbBuffer);

    PolyPolygon (hdc, (LPPOINT) Pts, polyCounts, nContours);

    GlobalUnlock (hPolygons);
    GlobalFree (hPolygons);
    free (buffer);
    return 1;
}
/*----------------------------------------------------------------------*/
long FAR PASCAL WndProc (HWND hwnd, unsigned iMessage, WORD wParam,
LONG lParam)
{
    const MF [2] = { MF_UNCHECKED, MF_CHECKED };

    switch (iMessage)
    {
    case WM_COMMAND:
        switch (wParam)
        {
        case IDM_NEW:
            cf.lStructSize = sizeof (cf);
            cf.hwndOwner = hwnd;
            cf.lpLogFont = &amp;lf;
            cf.Flags = CF_SCREENFONTS | CF_TTONLY
            | CF_FORCEFONTEXIST | CF_INITTOLOGFONTSTRUCT;
            cf.nFontType = SCREEN_FONTTYPE;
            if (ChooseFont (&amp;cf))
            {
                set_frame_caption ();
                InvalidateRect (hwnd, NULL, TRUE);
            }
            break;
        case IDM_EXIT:
            SendMessage (hwnd, WM_CLOSE, 0, 0L);
            break;
        case IDM_SHOWCONTROLPOINTS:
            bShowControlPoints ^= TRUE;
            CheckMenuItem (GetMenu (hwnd), IDM_SHOWCONTROLPOINTS,
                MF [bShowControlPoints]);
            InvalidateRect (hwnd, NULL, TRUE);
            break;
        case IDM_FILL:
            bFill ^= TRUE;
            CheckMenuItem (GetMenu (hwnd), IDM_FILL, MF [bFill]);
            InvalidateRect (hwnd, NULL, TRUE);
            break;

        case IDM_OUTLINE:
            bOutline ^= TRUE;
            CheckMenuItem (GetMenu (hwnd), IDM_OUTLINE, MF [bOutline]);
            InvalidateRect (hwnd, NULL, TRUE);
            break;
        case IDM_NORMAL:
        case IDM_PINCH:
        case IDM_PUNCH:
            nEffect = wParam;
            CheckMenuItem (GetMenu (hwnd),
                IDM_NORMAL, MF [wParam == IDM_NORMAL]);
            CheckMenuItem (GetMenu (hwnd),
                IDM_PINCH, MF [wParam == IDM_PINCH]);
            CheckMenuItem (GetMenu (hwnd),
                IDM_PUNCH, MF [wParam == IDM_PUNCH]);
            InvalidateRect (hwnd, NULL, TRUE);
            break;
        }
        break;
    case WM_SIZE:
        cxClient = LOWORD (lParam);
        cyClient = HIWORD (lParam);
        break;
    case WM_CHAR:
        character = wParam;
        InvalidateRect (hwnd, NULL, TRUE);
        break;
    case WM_PAINT:
        hdc = BeginPaint (hwnd, &amp;ps);
        HFONT hFont = SelectObject (hdc, CreateFontIndirect (&amp;lf));
        int PolyFillMode = SetPolyFillMode (hdc, ALTERNATE);

        static WORD brushBits [] =
        { 0xf8, 0x74, 0x22, 0x47, 0x8f, 0x17, 0x22, 0x71
        };
        HANDLE hBitmap = CreateBitmap (8, 8, 1, 1, brushBits);
        HBRUSH hBrush = SelectObject (hdc,
                  bFill ? CreatePatternBrush (hBitmap)
                        : GetStockObject (NULL_BRUSH));
        HPEN hPen = SelectObject (hdc, bOutline ? GetStockObject (BLACK_PEN)
            : GetStockObject (NULL_PEN));

        draw_glyph_outline (hdc, 100, 0, character);

        SelectObject (hdc, hPen);
        hBrush = SelectObject (hdc, hBrush);
        if (bFill)
        {
            DeleteObject (hBrush);
            DeleteObject (hBitmap);
        }
        SetPolyFillMode (hdc, PolyFillMode);
        DeleteObject (SelectObject (hdc, hFont));
        EndPaint (hwnd, &amp;ps);
        break;
    case WM_QUERYENDSESSION:
    case WM_CLOSE:
    case WM_DESTROY:
        PostQuitMessage (0);
        return 1;
    default:
        return DefWindowProc (hwnd, iMessage, wParam, lParam);
    }
    return 0;
}
/*----------------------------------------------------------------------*/
End Listing
</pre>

<HR><P>Copyright &copy; 1993, <I>Dr. Dobb's Journal</I></P></BODY></HTML>
