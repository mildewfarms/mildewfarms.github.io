<HTML>
<META NAME="year" CONTENT="1993">
<HEAD>
<TITLE>AUG93: Indexing Image Databases</TITLE></HEAD>
<BODY BGCOLOR="#ffffff">
<h1>Indexing Image Databases<a name="022e_0003"></h1><P>
<h2><a name="022e_0001"><a name="022e_0000">A search algorithm implemented in C++</h2><P>
<h3>Art Sulger</h3><P>
<p><i><a name="022e_0002"><a name="022e_0000">Art works in the Technical Services Group for the New York State Office of Mental Health. He can be reached on CompuServe at 75730,3076.</i></p><hr><P>
Imaging systems require a way to store and retrieve large amounts of unstructured data. At the New York Office of Mental Health, for instance, we estimate that at each of our 30 facilities there might be as many as 100,000,000 documents to be archived. However, the stability of vendors offering archiving tools is often suspect. (Indeed, some of the software we're using was provided by a leading vendor who has since filed for Chapter 11.) Consequently, we needed an indexing system that would allow many different image- file formats, be simple enough to test and implement within the project time allowed, but not lock us into any vendor-specific solution.<P>
Typically, a document image system uses at least two files to store and retrieve documents. The first is a traditional file that has a text description of the image along with a key to a second file. The second file contains the document location. The user selects a record from the first file using a search algorithm. This front end can be complex, as when the system supports keyword searches, or even icons of the documents. Once the user selects a record, the application keys into the location index, finds the document, and displays it. The name of the image to be displayed is not important to the user and is often generated by the system. The second file can be any traditional indexing structure. In this article, I'll discuss the search algorithm used in this second file to locate images.<P>
Our first attempts used published B-tree code. Because the image filenames did not have to be readable or intelligent in any way, we generated a meaningless sequential name, similar to <I>tmpnam</I> in stdio.h. We wrote some batch-testing programs that generated thousands of filename keys and stored them in our B-tree. The filenames were 14 characters long, a length that caused some concern. Large data items in <P>B-trees cause the tree to be deeper and larger. Disk thrashing ensued, and all we proved was that B-trees don't handle ordered data very well. Obviously, we needed to build random names. Before heading down the path of hash tables and random generators, however, we found a better way.<P>
<h3><a name="022e_0004">The Mapper<a name="022e_0004"></h3><P>
One of the fastest ways to locate data in a file is by going to a direct offset into a file. In C, you can do this with the <I>lseek</I> or <I>fseek</I> functions. We could store any location directions we wished at the chosen offset. This would yield very fast search times, and there would be less worry about the size of the location entry. Even the size of the location entry is reduced by using the image filename itself to derive an offset into a &quot;mapper&quot; file which contains directions to locate the image.<P>
For example, to store the location of a file named C:\AA\12345678.TIF, we create an entry in the mapper file that's at a 12,345,678-byte offset. At this location, we store the device, subdirectory, and file extension. Encoding and decoding the image filename to and from a meaningful offset is simple. Fortuitously, the 4-byte long value needed by  or lseek can be represented by the eight hex characters which form the filename. They're decoded as offsets into the mapper file. We've encapsulated the functions to manipulate these index entries in the mapper class written in C++.<P>
The <I>Mapper</I> class header (see <a href="#022e_000a">Listing One</A>, page 104) contains a member struct that describes the layout of a mapper record. You should tailor this to your needs. The struct we're using is shown in <a href="#022e_0008">Example 1</A>. The device member is the drive letter. The path is a 2-byte directory entry. A DOS path label may be any alphabetic character or digit, as well as one of the following: ! _ - @ # $ % ^ &amp; ( ) ~ ` { }. In other words, there are 50 possible single-character paths available: 50x50+50=2550 directories on each device. We can tell which image viewer to use based on the <I>FileExtension</I> member. A .TIF extension will call the TIFF viewer, a WP5 extension will call the WordPerfect viewer, and so on. If your application uses a more intelligent viewer, you could drop this member.<P>
The larger this <I>struct</I> is, the fewer mapper entries you'll be able to write. But don't get too ambitious in keeping the struct slim. Few systems have the need or the space to store as many files as the 6-byte <I>struct</I> given in this example (232/<I>sizeof(struct)</I>=715 million); see the text box entitled, &quot;How Much Can We Store?&quot;.<P>
At minimum, the <I>struct</I> should indicate whether the document is stored on a magnetic drive or on a removable, probably optical, drive. If you're using a removable optical drive, also known as an &quot;autochanger&quot; or a &quot;jukebox,&quot; you'll need to store the directory information. Jukeboxes are treated as a single device, and each platter looks to the programmer like a subdirectory. Note that by storing the device in a file separate from the user interface you can easily update storage-location changes. If you write an archiving application, for example, you will only need to update one byte in the mapper file.<P>
<h3><a name="022e_0005">Multipage Documents<a name="022e_0005"></h3><P>
It would be nice if our imaging system could handle documents that have more than one page. Treating multipage documents is a little more complex. We still store the location information for each document page in the mapper file. A second file contains a doubly linked list. Each linked-list entry also points at a single mapper-file entry. This allows us to scan forward and backward through the document's pages. A separate <I>LinkedList</I> class handles file I/O to a linked-list file. The header is in <a href="#022e_000a">Listing One</A> (page 104), and the methods of this class and the <I>Mapper</I> class are in <a href="#022e_000c">Listing Two</A> (page 104). The layout of the linked-list file is shown in <a href="#022e_0009">Example 2</A>. Notice that the linked-list structure is larger than that of the mapper. You'll have to estimate the ratio of multipage to single-page documents. If every document is multipage you may consider using a singly linked list, which will eliminate one-third of the space required for the linked-list entries. The drawback, of course, is that the application will have to write its own routine for scanning the pages of a document in reverse.<P>
<a href="#022e_000e">Listing Three</A> (page 105) contains the code for a program that exercises the <I>Mapper</I> and <I>LinkedList</I> classes. It writes out 1000 single-page document entries and 1000 four-page document entries, then reads them back.<P>
The <I>Mapper</I> and <I>LinkedList</I> objects are contained in and contain other objects. I've omitted a class that provides extensive error messages. If there are run-time errors in this example, the objects will return a NULL if a character value was expected and a --1 if an integer value was expected; a 0 returned usually signals success.<P>
The locking calls are compiler specific (Zortech), but I left them in to indicate likely places you should lock out other users. Scanners take several seconds, during which time you won't want your initialized index space updated by another scanner user. Turn off locking by defining NOLOCK=0.<P>
You use the <I>Mapper</I> class to create the name of the image file. The <I>Lock- Spot</I> method does this and also locks the new record space in the mapper file. This might be necessary if more than one scanner is in operation. The filename returned does not include the extension.<P>
You retrieve the location of the image file with the <I>Read</I> method which will construct a fully qualified filename. Essentially, this method returns the location instructions. You could expand these instructions beyond a simple file specification.<P>
You should call <I>Write</I> after <I>LockSpot</I>. First your application will get the filename via <I>LockSpot</I>. Then you will scan the document using that filename. Finally, you'll write this information in the already locked and initialized MAPPER.DAT file.<P>
At some time during the creation and storage of the image, you should get the long value that is the offset into the mapper file. This is done with the lMAPSSLOT number. If you're combining single- and multiple-page images, you'll indicate that the offset is to the <I>Mapper</I> by keeping it a positive value; offsets to the <I>LinkedList</I> are converted to a negative number.<P>
Your application must know before creating the index whether the document is to have a single or multiple pages. Multipage documents can be stored and then retrieved in the same order. If the scanner operator picks multiple pages, your application will create an instance of the <I>LinkedList</I> class and call the <I>LockSpot</I> method. After getting a LinkedList slot, <I>LockSpot</I> gets the next available mapper slot and saves the value in the <I>MapperAddress</I> member of the <I>LinkedListBuffer</I>. The mapper value in hex is the filename you will use when scanning. This function returns a pointer to the <I>Mapper</I> value.<P>
For the second and all subsequent pages, after you have called <I>LockSpot</I> and stored the next page of the image file, use <I>Linkin</I> to link the previous page with a call to this member.<P>
You'll want several members to make it easy to traverse the linked list. <I>LastImage</I> is one that retrieves the fully qualified filename of the last image in a multipage document. To save space, I've not listed the others here.<P>
The application will store the offset in a database somewhere. If the offset is a negative value, pass it to the <I>Read</I> member of the <I>LinkedList</I> class, which returns a pointer to a fully qualified filename. <I>Read</I> assumes you know that the value is in the <I>LinkedList</I>. Whether you pass a positive or negative number, <I>LinkedList </I>will save it as a positive value.<P>
<I>Open</I> and <I>Close</I> could be put into the constructor and destructor. Having separate members will allow you to limit the number of open files. <I>Close</I> allows you to free the two file handles while maintaining the internal variable values. <I>Open</I> will automatically create a new file if one doesn't already exist. <I>Open</I> is called by almost every member function just to check if the file handle is valid. You can avoid this extra function call by checking for the existence of a valid file pointer.<P>
<h3><a name="022e_0006">What We'd Do Differently Next Time<a name="022e_0006"></h3><P>
The current design never cleans up space released by deleted images. We felt that going to optical storage would obviate the need to have a delete function. However, there were more scanning errors than we anticipated. The linked list and mapper should incorporate a single linked-list of deleted records. I first saw this in the B-tree code in Al Stevens's <I>C Database Development</I> (MIS Press, 1987). Both files would have a header that would indicate the first available slot. That slot would have a pointer to the next deleted slot, and so on.<P>
<h3><a name="022e_0007">Summary<a name="022e_0007"></h3><P>
A custom-tailored mapper file can open up new avenues for storage. For instance, if you have access to a mainframe, you could store location information for 9-track tape or high-density pack storage. You can use any location information that you can encode in your customized mapper <I>struct</I>. You can store images on a LAN, WAN, tape, optical disk, mainframe, or jukebox, and this system will locate and retrieve each image.<P>
<h4><a name="022e_0008"><B>Example 1: </B>The member struct that describes the layout of a mapper record.<a name="022e_0008"></h4><P>
<pre>struct Mapper
  {
  char Device ;
  char Path [2] ;
  char FileExtension [3] ;
  };
</pre><P>
<h4><a name="022e_0009"><B>Example 2:</B> Layout of the linked-list file.<a name="022e_0009"></h4><P>
<pre>
struct LinkedList
  {
  unsigned long Prev ;
  unsigned long MapperOffset ;
  unsigned long Next ;
  } ;
</pre><P>
<a name="022e_0033">How Much Can We Store?<P>
The purpose of the mapper structure is to hold location information. Each mapper entry points to a single file. You want to make your structure flexible enough to describe many different types of storage, because when you get into image processing, disk sizes suddenly seem quite small. Imaging people buy storage big and often. If you plan to store your million or so images on magnetic disk, you may be in for a surprise. DOS uses a file-allocation table (FAT) to locate disk clusters. Each file will occupy at least one cluster. The FAT entry on DOS fixed disks larger than 17 megabytes is 16 bits long. So even the largest drives available, 2 gigabytes, will limit you to about 64K files (assuming that each file is &lt;=32K). You will require 16 2-gigabyte drives to store a million images.<P>
Even if the FAT entry were increased, a 2-gigabyte disk would not have the data space to store many more images. This is one of the reasons that removable storage becomes important in imaging systems.<P>
On the other hand, removable optical storage, even jukeboxes, can be very slow when more than one user at a time requests data. So you must find a balance between fixed and removable storage. In an ordinary system, volatility is the most important part of the equation. Our image storage and retrieval applications do not ordinarily update images, so read demand becomes the more important ingredient.<P>
--A.S.<P>

<PRE>

<a name="022e_000a"><I><a name="022e_000b"><B>[LISTING ONE]</B><a name="022e_000b"></I>

// Mapper.hpp
#define NOLOCK 1
// these constants would be in a default file
// or WIN.INI (for a Windows app):
char cMap[]    = &quot;C:\\MAPTEST&quot; ; // Mapper.Dat location
char cLinkL[]  = &quot;C:\\MAPTEST&quot; ; // Linkedl.Dat location
#ifndef MAPPER
#define MAPPER
#include &lt;stdio.h&gt;
#include &lt;sys\locking.h&gt;
#include &lt;share.h&gt;
#include &lt;io.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;string.h&gt;

class Mapper
  {
  private :
    int fp ; // file pointer
    long lBytePosition ;
    char cBytePosition [9] ; // hex representation of long value
    char * cMapperFileSpec ; // Mapper.dat full file name
    struct MapperBuffer      // layout of the Index entry
      {
      char cDevice [1] ;     // device where image is
      char cPath [2] ;       // directory or Jukebox platter
      char cFileExtension [3] ; // type of image
      } Map ;
    void WipeMapper(){strnset((char *)&amp;Map,'\0',sizeof(Map));}
    char cMwholefilename[19];
  public :
    Mapper() ;

    ~Mapper() ;
    int     Close() ;
    char *  Hexbytes(){return cBytePosition ;}
    long    lMapSlot() { return lBytePosition  ; }
    char *  LockSpot() ;
    int     Open() ;
    char *  Read(long lOffset) ;
    int     Write() ; // commit to disk
    int     Write(char * Extension, // Image type
                  char * Path, // subdirectory or jukebox platter
                  char * Device) ;
  } ;
#endif // MAPPER

#ifndef LINKEDLIST
#define LINKEDLIST
class LinkedList
  {
  private :
    int fp ; // file pointer
    long lBytePosition ;
    char * cLinkedListFileSpec ;
    struct LinkedListBuffer
      {
      long Previous ;
      long Next ;
      long MapperAddress ; // points at Mapper Index entry
      } ll ;
    Mapper * M;
  public :
     LinkedList() ;
    ~LinkedList() ;
     int    Close() ;
     int    Linkin(long OldEntry) ;
     long   lLinkSlot() { return lBytePosition  ; }
     char * LastImage(long lOffset) ;
     char * LockSpot() ;
     long   MapAddress() {return ll.MapperAddress ;}
     long   Next(){return ll.Next ;}
     int    Open() ;
     char * Read(long) ;
     int    Write(char * Extension, // Image type
                  char * Path, // subdir or jukebox platter
                  char * Device) ;
  } ;
#endif // LINKEDLIST
</PRE>

<h4><a name="022e_000c"><a name="022e_000d"><B>[LISTING TWO]</B></h4>

<pre>

#include &quot;Mapper.hpp&quot;
//                    M A P P E R    M E T H O D S
//-----------------constructor-----------------------------
Mapper::Mapper()
  {
  fp = lBytePosition = 0 ;
  Open() ;
  }
//------------------------oblivion-------------------------
Mapper::~Mapper()
  {
  if (fp)
    {
    delete cMapperFileSpec ;
    close(fp) ;
    }
  fp = 0 ;
  }
//-------------------open and close members-----------------
Mapper::Open()
  {
  if (!fp)
    { // get file location defaults:
    cMapperFileSpec = new char [strlen(cMap) + 13] ;
    sprintf(cMapperFileSpec, &quot;%s\\MAPPER.DAT&quot;, cMap) ;
    // append if exists, otherwise create :
    if (access(cMapperFileSpec, F_OK == -1))
      {
      FILE * fd = fopen(cMapperFileSpec, &quot;w+&quot;) ;
      fclose(fd) ;
      }
    if ((fp = sopen (cMapperFileSpec,
                     O_RDWR,

                     SH_DENYNO)) == -1)
      return -1 ;
    }
  return 0 ;
  }
//------------------Close-----------------------------------
Mapper::Close()
  {
  if (fp)
    {
    close(fp) ;
    fp = 0 ;
    }
  return 0 ;
  }
//-------------------LockSpot-------------------------------
char * Mapper::LockSpot()
  {
  if (!fp) Open() ;
  lBytePosition = lseek(fp, 0L, SEEK_END) ;
  WipeMapper() ;
  if (write(fp, &amp;Map, sizeof(Map) ) == -1)
    return NULL ;
  lseek(fp, lBytePosition, SEEK_SET) ;
  #ifndef NOLOCK
  // don't let anyone else append
  if (locking(fp, LK_LOCK, (long)sizeof(Map)) == -1)
    return NULL ;
  #endif
  sprintf(cBytePosition,&quot;%8.8lx&quot;, lBytePosition) ;
  return cBytePosition ;
  }
//---------------------------Read---------------------------
char * Mapper::Read(long lOffset)
  {
  if (!fp) Open() ;
  if (lseek(fp, lOffset, SEEK_SET) == -1)
    return NULL ;
  if (read(fp, &amp;Map, 6 ) == -1) // device,dir, &amp; extension
    return NULL ;
  sprintf(cBytePosition, &quot;%8.8lx&quot;, lOffset);    // filename
  sprintf(cMwholefilename, &quot;%1.1s:\\%1.2s\\%8.8s.%3.3s&quot;,
          Map.cDevice,     // Image device
          Map.cPath,       // Image path (or Jukebox disk)
          cBytePosition,   // filename/offset in hex
          Map.cFileExtension ) ; // type (TIF,WP4,WP5...)
  return cMwholefilename;
  }
//--------------------------Write--------------------------
Mapper::Write(char * Extension,// Image type
              char * Path,  // Image subdir or juke platter
              char * Device)// Image device (single letter)
  {
  if (!fp) Open() ;
  memcpy((char *)&amp;Map.cDevice, Device, 1) ;

  memcpy((char *)&amp;Map.cPath, Path, sizeof(Map.cPath)) ;
  memcpy((char *)&amp;Map.cFileExtension, Extension,
        sizeof(Map.cFileExtension)) ;
  return Write() ;
  }
//----------------------------------------------------------
Mapper::Write()
  {
  lseek(fp, lBytePosition, SEEK_SET) ;
  if (write(fp, &amp;Map, sizeof(Map) ) == -1)
    return -1 ;  // should return error code here
  #ifndef NOLOCK
  if (locking(fp, LK_UNLCK, (long)sizeof(Map)) == -1)
    return - 1 ;  // should return error code here
  #endif
  return 0 ;
  }
//             L I N K E D   L I S T    M E T H O D S
//-------------------------constructor----------------------
LinkedList::LinkedList()
  {
  fp = 0 ;
  Open() ;
  M = new Mapper();
  }
//------------------------oblivion--------------------------
LinkedList::~LinkedList()
  {
  if (fp)
    close(fp) ;
  delete M ;
  }
//-------------------open and close members-----------------
LinkedList::Open()
  {
  int ok ;
  if (!fp)
    {
    cLinkedListFileSpec = new char [strlen(cLinkL) + 13] ;
    sprintf(cLinkedListFileSpec,&quot;%s\\LINKEDL.DAT&quot;, cLinkL) ;
    // append if exists, otherwise create :
    if (access(cLinkedListFileSpec, F_OK == -1))
      {
      FILE * fd = fopen(cLinkedListFileSpec, &quot;w+&quot;) ;
      fclose(fd) ;
      if ((fp = sopen (cLinkedListFileSpec,
                       O_RDWR,
                       SH_DENYNO)) == -1)
        return -1 ;
      lBytePosition = lseek(fp, 0L, SEEK_END) ;
      // Write a -1 header because a '0' file name * -1 = 0
      ll.Previous = ll.Next = 0 ;
      ll.MapperAddress = -1 ;
      lBytePosition = 0 ;
      lseek(fp, lBytePosition, SEEK_SET) ;

      if (write(fp, &amp;ll, sizeof(ll) ) == -1)
        return -1 ;
      return 0 ;
      }
    else  // file already exists
    if ((fp = sopen (cLinkedListFileSpec,
                     O_RDWR,
                     SH_DENYNO)) == -1)
      return -1 ;
    }
  return 0 ;
  }

LinkedList::Close()
  {
  if (fp)
    {
    delete cLinkedListFileSpec ;
    close(fp) ;
    fp = 0 ;
    }
  return 0 ;
  }
//---------------------LastImage----------------------------
char * LinkedList::LastImage(long lOffset)
  {
  Read(lOffset) ;
  while (ll.Next)
    Read(ll.Next);
  return (M-&gt;Read(ll.MapperAddress)) ;
  }
//--------------------------Read---------------------------
char * LinkedList::Read(long lOffset)
  {
  char lbuf[9];
  char buffer[7];
  if (lOffset &lt; 0)
    lOffset *= -1 ;
  lBytePosition = lOffset ;
  if (!fp) Open() ;
  if (lseek(fp, lOffset, SEEK_SET) == -1)
    return NULL ;
  if (read(fp, &amp;ll, sizeof(ll) ) == -1)
    return NULL ;
  return (M-&gt;Read(ll.MapperAddress));
  }
//---------------------LockSpot-----------------------------
char * LinkedList::LockSpot()
  {
  if (!fp) Open() ;
  lBytePosition = lseek(fp, 0L, SEEK_END) ;
  ll.Next = ll.Previous = 0 ;
  if (write(fp, &amp;ll, sizeof(ll) ) == -1)
    return NULL ;
  lseek(fp, lBytePosition, SEEK_SET) ;

  #ifndef NOLOCK
  if (locking(fp, LK_LOCK, (long)sizeof(ll)) == -1)
    return NULL ;
  #endif
  M-&gt;LockSpot() ;
  ll.MapperAddress = M-&gt;lMapSlot() ;
  return M-&gt;Hexbytes() ;
  }
//---------------------------Write--------------------------
LinkedList::Write(char * Extension, // Image type
                  char * Path,      // subdir or platter
                  char * Device)
  {
  if (!fp) Open() ;
  lseek(fp, lBytePosition, SEEK_SET) ;
  if (write(fp, &amp;ll, sizeof(ll) ) == -1)
    return -1 ;
  #ifndef NOLOCK
  if (locking(fp, LK_UNLCK, sizeof(ll)) == -1)
    return -1 ;
  #endif
  M-&gt;Write(Extension, Path, Device) ;
  return 0 ;
  }
//---------------------------Write--------------------------
LinkedList::Linkin(long LLPr)
  {
  if (!fp) Open() ;
  lseek(fp, LLPr, SEEK_SET) ;
  if (read(fp, (char *)&amp;ll, sizeof(ll) ) == -1)
    return -1 ;
  lseek(fp, LLPr, SEEK_SET) ;
  ll.Next = lBytePosition ;
  if (write(fp, (char *)&amp;ll, sizeof(ll) ) == -1)
    return -1 ;
  lseek(fp, lBytePosition, SEEK_SET) ;
  if (read(fp, (char *)&amp;ll, sizeof(ll) ) == -1)
    return -1 ;
  lseek(fp, lBytePosition, SEEK_SET) ;
  ll.Previous = LLPr ;
  if (write(fp, &amp;ll, sizeof(ll) ) == -1)
    return -1 ;
  #ifndef NOLOCK
  if (locking(fp, LK_UNLCK, sizeof(ll)) == -1)
    return -1 ;
  #endif

  return 0 ;
  }

</PRE>

<h4><a name="022e_000e"><a name="022e_000f"><B>[LISTING THREE]</B></H4>

<PRE>

/* this program creates a Mapper.dat and LinkedL.dat and
writes 1,000 single image entries and 1,000 entries of 4 page
documents, then reads them back.  The entries are stored in
a sequential file as 4 byte character strings. */
char cKey[]  = &quot;C:\\MAPTEST\\KEYS.X&quot; ;
char cDev[]  = &quot;X&quot;; // where 'images' are stored
const long TestCount = 1000 ;
const int  MultiPage = 4 ; // # Images in multipage docs.
union value  // converts 4 byte chars to long and visa-versa
 {
 long lValue ;
 char cValue[sizeof(long)] ;
 } uValue ;
Mapper     * Map ;
LinkedList * LL ;
char * AvailableMapper ;
#include &quot;stdlib.h&quot;
int main(int argc, char * argv[])
  {
  char cmd [32] ;
  FILE * fd ;
  int fp ;
  long i ;
  long lLong ;
  char szDir[3] ;
  sprintf(cmd, &quot;DEL %s\\MAPPER.DAT&quot;, cMap) ;
  system(cmd) ;
  sprintf(cmd, &quot;DEL %s\\LINKEDL.DAT&quot;, cLinkL) ;
  system(cmd) ;
  fd = fopen(cKey, &quot;w&quot;) ;
  fclose(fd) ;

  fp = open(cKey, O_WRONLY) ;
  Map = new Mapper ;
  itoa(1, szDir, 10) ; // make up directory names
  for (i = 0; i &lt; TestCount; i++)
    {
    Map-&gt;LockSpot() ;
    Map-&gt;Write(&quot;TIF&quot;, szDir, cDev) ;
    uValue.lValue = Map-&gt;lMapSlot() ;
    lseek(fp, 0, SEEK_END) ;
    write(fp, (char *)&amp;uValue.cValue, sizeof(long)) ;
    if ((i / 100) * 100 == i)
      {
      itoa(i, szDir, 10) ; // change directory name
      printf(&quot;\t%ld&quot;, i) ;
      }
    }
  delete Map ;
  close(fp) ;
  // Build some Multi-page:
  fp = open(cKey, O_RDWR) ;
  printf(&quot;\nMulti-page Documents\n&quot;) ;
  LL = new LinkedList ;
  itoa(1, szDir, 10) ; // make up directory names
  for (i = 0; i &lt; TestCount; i++)
    {
    LL-&gt;LockSpot() ;
    LL-&gt;Write(&quot;TIF&quot;, szDir, cDev) ;
    uValue.lValue = LL-&gt;lLinkSlot() ;
    uValue.lValue *= -1 ; // say we are a linked list entry
    lseek(fp, 0, SEEK_END) ;
    write(fp, (char *)&amp;uValue.cValue, sizeof(long)) ;
    lLong = LL-&gt;lLinkSlot() ;
    for (int j = 1; j &lt; MultiPage; j++)
      { // next pages:
      LL-&gt;LockSpot() ;
      LL-&gt;Write(&quot;TIF&quot;, szDir, cDev) ;
      LL-&gt;Linkin(lLong) ;
      lLong = LL-&gt;lLinkSlot() ;
      }
    if ((i / 100) * 100 == i)
      {
      itoa(i, szDir, 10) ; // change directory name
      printf(&quot;\t%ld&quot;, i) ;
      }
    }
  close(fp) ;
  delete LL ;
  // we can read them all back now:
  Map = new Mapper ;
  LL = new LinkedList ;
  fp = open(cKey, O_RDONLY) ; // open the keys
  lseek(fp, 0, SEEK_SET) ;
  printf(&quot;\n'Long'\tFilename\n&quot;) ;
  while (read(fp, (char *)&amp;uValue.cValue, sizeof(long)))
    {

    if (uValue.lValue &gt;= 0)
      printf(&quot;\n%ld\t%s&quot;,
             uValue.lValue, Map-&gt;Read(uValue.lValue)) ;
    else
      {
      printf(&quot;\n%ld\t%s&quot;,
             uValue.lValue, LL-&gt;Read(uValue.lValue)) ;
      while (LL-&gt;Next())
        printf(&quot;\n%ld\t%s&quot;,
               uValue.lValue, LL-&gt;Read(LL-&gt;Next())) ;
      }
    }
  close(fp) ;
  delete Map ;
  delete LL ;
  return 0 ;
  }
End Listings
</pre>

<HR><P>Copyright &copy; 1993, <I>Dr. Dobb's Journal</I></P></BODY></HTML>
