<HTML>
<META NAME="year" CONTENT="1993">
<HEAD>
<TITLE>NOV93: LETTERS</TITLE></HEAD>
<BODY BGCOLOR="#ffffff">
<h1>LETTERS<a name="02f7_0001"></h1><P>
<h3><a name="02f7_0002">Going in Circles<a name="02f7_0002"></h3><P>
Dear <I>DDJ</I>,<P>
Cliff Pickover's article &quot;Recursive Worlds&quot; (<I>DDJ</I>, September 1993) reminded me of two bits of doggerel:<P>
<I>Great fleas have little fleas</I><P>
<I>  On their backs to bite 'em</I><P>
<I>And little fleas have lesser fleas</I><P>
<I>  So on ad infinitum.</I><P>
<I>Big whirls have little whirls</I><P>
<I>  Which feed on their velocity</I><P>
<I>And little whirls have lesser whirls</I><P>
<I>  And so on to viscosity</I><P>
William Drissel<P>
Grand Prairie, Texas<P>
<h3><a name="02f7_0003">Extending C<a name="02f7_0003"></h3><P>
Dear <I>DDJ</I>,<P>
The textbox &quot;Extending C&quot; in the article &quot;C/C++ Standardization: An Update&quot; by Rex Jaeschke (<I>DDJ</I>, August 1993) touched one of my &quot;hot buttons&quot; about C--that all functions in the C math libraries do everything in double. I am a casual user of C, but a power user of Fortran. In about 15 years of scientific programming in Fortran, I have learned there are very few occasions when double precision (64 bit) is needed to produce sufficiently accurate manipulation. The suggestion in the textbox that float-math libraries be an extension to C has my enthusiastic support.<P>
Roger H. James<P>
East Hartford, Connecticut<P>
<h3><a name="02f7_0004">Computer Science and Programmers' Future<a name="02f7_0004"></h3><P>
<h3><a name="02f7_0005">Dear <I>DDJ</I>,<a name="02f7_0005"></h3><P>
I have some observations sparked by Nick Tredennick's article &quot;Computer Science and the Microprocessor.&quot; (<I>DDJ</I>, June 1993).<P>
First he points out the obvious fact that Intel's processors will continue to dominate the market for quite sometime to come. This comes as no surprise to the average <I>DDJ</I> reader. Next, he highlights the not-so-obvious fact that the backward compatibility Intel has committed to (or is trapped by, depending on your point of view) will keep the existing applications developed under MS-DOS or Windows (which is really only a DOS process) popular for some time to come. Then he reminds us that all of the major applications for the Intel (cum MS-DOS) platforms have been written, and keeping them current requires a lot fewer programmers than writing it in the first place. Finally, and most distressing, he implies that this means a reduced need, with a consequently smaller job market, for the professional programmer.<P>
I'm no longer a professional. I now program only for my own amusement, so the above doesn't cause me much economic worry. I doubt, however, that too many programmers will have it as easy to change careers as I did. So here's a suggestion. There are other places where the programmer can sell his services. There are other types of hardware and other operating systems: the Amiga, the Atari, and, my personal favorite, the OS9 opsys, which is used on dozens of different platforms including a new version for the 386 and above. All of these platforms are waiting for many of the applications already developed from the compatible and Macintosh markets.<P>
It's true that the market won't be nearly as large: A word processor that sells for, say, $80.00 in the compatible market would have to sell for considerably more in the OS9 market. Of course considering that OS9 is fully multiuser, higher costs are justified. Once you've gotten over the learning curve of a new system's quirks, porting an application to another platform is easier than starting from scratch. If you can't legally port your code, then rewriting is still easier than writing it the first time.<P>
Given the above, perhaps it's time for <I>DDJ</I> to begin helping the professional decide where to move to, when it becomes necessary, by offering articles with applicability to a broader range of hardware and operating systems. Your &quot;Algorithm Alley&quot; column is an excellent start since everything offered is presented in a pseudocode that can be readily adapted to any programming language.<P>
I'll admit a bit of missionary zeal in the above. The personal computer is not just the one hardware/opsys combination that dominates the current market, but an idea that has been implemented on dozens of different hardware architectures. I believe it is important to the long term health of personal computing that a diversity of operating systems and hardware survive and evolve.<P>
Because there's no clear historical parallel to the personal computer phenomena, I'll indulge my penchant for simile; think of multiple hardware/opsys platforms as similar to the biodiversity that gives an ecosystem the resiliency to survive change. Remember that mammals once occupied a narrow ecological niche just below the smallest of the dominant saurians (mammals that had insulating hair) but things were upset quite a bit when that piece of junk came barreling out of the sky 65 million years ago. I hope that no parallel disaster awaits the personal computer but Nick Tredennick, intentional or not, has pointed out some of the realities of a rapidly changing market before the &quot;crisis.&quot;<P>
J. Stephen Carville<P>
Glendora, California<P>
<h3><a name="02f7_0006">Listen Up, Curmudgeons!<a name="02f7_0006"></h3><P>
Dear <I>DDJ</I>,<P>
Apparently, object-oriented ignorance has not been overcome. The logic of the curmudgeon argument (see May 1993 &quot;Letters'') that we don't need to move to OO languages because there is nothing we cannot accomplish in procedural languages is flawed at best. From the tone of the subject letter, we can only conclude that all curmudgeons are either incompetent at or intimidated by OOP (they just like to drop <I>DDJ</I> a line every now and then to let us all know!).<P>
Listen up, curmudgeons: The reason for using OO languages instead of procedural languages is that we don't have to perform <I>programming calisthenics</I> to gain some additional abstraction, enhance our design capabilities, and to facilitate reuse. OOP allows us to express useful programming (and for the first time, &quot;elegant design'') concepts in a succinct and productive manner. If we want to, we could simulate C++ function templates in C by passing void pointers to a lookup table inside each instantiation, but why not let the language and the compiler do the work for us? Procedural languages incorporate certain functionality in the form of libraries or reserved words because these tools are used so often that it would be counterproductive to exclude them. OO languages such as C++ and Ada 9X do the same thing; they just include different types of functionality. I don't know, nor have I heard of a procedural programmer using an OOP successfully and then preferring to return to procedural languages. I also highly doubt that any curmudgeon has been using &quot;...object techniques since 1978...'' that even closely resemble the object techniques of today. Like it or not, new languages are emerging for larger software systems where &quot;the problem is (NOT) so well understood.'' Most curmudgeons have never confronted systems like these; systems so large that no one person can possibly understand them completely. This is the area where object-based languages are helpful and I'm glad they're here to stay. Curmudgeons, begone!<P>
Spencer Roberts<P>
Redondo Beach, California<P>
<h3><a name="02f7_0007">Putting HVC in Order<a name="02f7_0007"></h3><P>
Dear <I>DDJ</I>,<P>
In the sidebar &quot;Putting Colors in Order&quot; by Harry Smith that accompanied the article &quot;Color Models&quot; (<I>DDJ,</I> July 1993), the conversion between the HVC and RGB color space variables permits RGB values larger than unity, or negative. The geometrical picture given by Smith didn't include the required variation of the maximum chroma radius with intensity (V). This variation in chroma radius is introduced because the mapping between RGB and HVC transforms in 3-D space from the color cube to a color cone. The radius variable C in the transformation equations is therefore a scaled function of the chroma value, C'. For chroma varying in the range C(0.0,0.50) let <I>C=4C<SUB>max</SUB>'</I>, <I>C<SUB>max</SUB> =min (V,1-V)</I>.<P>
The definition of <I>C<SUB>max</SUB></I> accounts for the variation of the radius of the circle in Smith's diagram with V. For V=0.50, C<SUB>max</SUB>=0.50, and the circle diameter is unity. As the total intensity V increases to 1.0 or decreases to 0.0, the conversion-circle diameter decreases proportionally.<P>
The value of chroma C is thereby scaled by the maximum circle radius. For V=0 or V=1.0, chroma is undefined because the conversion circle contracts to a point. However, for finite intensity near 0 or for V near unity, chroma is defined even though it contributes little to the image appearance. Using the definition above for C in the equations ensures that the RGB values calculated from HVC values with Smith's equation set (a) are positive in the range (0,1).<P>
Maxwell T. Sanford II<P>
Los Alamos, New Mexico<P>
<h3><a name="02f7_0008">Mo' Better Linked Lists<a name="02f7_0008"></h3><P>
Dear <I>DDJ</I>,<P>
Regarding, &quot;Strategies for Better Linked Lists&quot; by Garyl Hester (<I>DDJ</I>, August 1993), a simple improvement would be to maintain the free list in sorted physical address order. It would not involve an actual sort, but instead, just a series of comparisons during free list insertion.<P>
On average, it would reduce the number of partially filled blocks by reallocating in a prescribed, rather than arbitrary order. It would also simplify the block deallocation logic. Because the freed atoms would be in order, <I>pPrev</I> of the first atom in the block along with <I>pNext</I> of the last atom in the block would suffice to purge the entire block from the free list. Cache performance might also benefit from inherent clustering.<P>
Berry Ratcliff<P>
Ann Arbor, Michigan<P>
<h3><a name="02f7_0009">Swaine vs. Aristotle: Mano a Mano<a name="02f7_0009"></h3><P>
Dear <I>DDJ</I>,<P>
In his column &quot;Fuzzy Logic and Prejudice&quot; (<I>DDJ</I>, July 1993), Michael Swaine wrongly asserts that Aristotelian logic is defined by an inability to deal with matters of degree. He supposes that classical logic rounds everything to fit the nearest &quot;binary-valued&quot; pigeon hole. Swaine's misrepresentation is tantamount to equating the law of identity with the Kronecker delta function. His obvious purpose is to diminish classical logic to make room for some new subjective logics, of which he believes &quot;fuzzy logic&quot; is one. Fuzzy logic may be robust but it is nothing more (and nothing less) than a clever classical mechanistic method of processing complex and time-varying inputs to produce outputs that satisfy a set of complex criteria. According to Swaine, though, it operates by some sort of superior, non-Aristotelian, supernatural logic.<P>
The term &quot;fuzzy logic&quot; is only controversial to fanciful folks who insist on giving the most generously wide interpretation to the word &quot;logic&quot; in its name. I'm sure the name was actually conceived in the spirit of &quot;fuzzy logic gates.&quot;<P>
Aristotle's law of identity has not been bested. Since its context encompasses all perceptual phenomena, it cannot and it need not be bested. Indeed, it was such a towering accomplishment that even today, very few philosophers have grasped its implications. They do not understand what Aristotle gave us: Logic, the art of noncontradictory identification. This intellectual sloppiness, coupled with a charlatan mentality which is eager to promote each new incremental advance to the status of fundamental scientific revolution, is why we have a proliferation of new &quot;logics.&quot; Quantum logic. Classical logic. Your logic. My logic. Fuzzy logic. And now Swaine's logic.<P>
Paul Ierymenko<P>
Ajax, Ontario<P>
<h3><a name="02f7_000a">More Keyboard Controllers<a name="02f7_000a"></h3><P>
<h3><a name="02f7_000b">Dear <I>DDJ</I>,<a name="02f7_000b"></h3><P>
After reading Al Stevens' column on keyboard controllers for the handicapped (&quot;C Programming,'' June 1993) I'd like to mention an excellent keyboard controller for Windows that you might like. It's called &quot;WiViK,'' and has been developed by the Microcomputer Applications Programme at the Hugh MacMillan Rehabilitation Centre, Toronto.<P>
One of its most useful features is word prediction which displays a row of words that you might be trying to type as you enter each letter. If your word appears, you can select it rather than typing the rest of it. The word prediction is updated based on how often you select a word. We at BioControl Systems (Palo Alto, California) have adapted our BioMuse product into applications for the handicapped. The BioMuse can be used for eye tracking and muscle control input into a computer. We have used the BioMuse with WiViK for hands-free Windows control.<P>
The following is from the Overview section of WiViK 2.0 Help:<P>
WiViK is a special software program that allows a computer user to enter text into any application within Microsoft 3.1 (including DOS windows) with any pointing device that can emulate the standard mouse. It is fully compatible with the standard IBM keyboards and includes several features that make its use easier with pointing devices.<P>
Possible pointing devices include: headpointing devices, joysticks, mice, pens, touchscreens, and trackballs. No modifications to the applications are necessary, and the standard keyboard remains fully functional. Human factors issues relating to the use of an on-screen keyboard have been carefully considered in the design of WiViK to ensure its operation is natural and easy.<P>
WiViK operates similar to other Windows applications. A keyboard is displayed within a moveable, resizeable window to meet your needs. The keyboard window is always available, moving above an active application when necessary. It may be customized for: number and arrangement of keys; key widths; key labels; key label font; and key spacing. Keys are automatically resized when the keyboard is resized.<P>
Besides the standard keyboard layout, you can define and use different layouts. Keys may contain complex macros that allow you to send words, phrases, and commands with a single key selection. You can display and use multiple keyboards, each with specific functionality.<P>
WiViK 2.0 is the second version of the program. It has been enhanced based upon customer feedback and the results of current research. The key enhancement is a modular design that enables it to be extended with optional modules called additions. Two additions, abbreviation-expansion and word prediction, are the first modules to be available in an optional Rate Enhancement Package. These additions are described here. Future optional additions will include scanning access and more support for access through imprecise pointing.<P>
Rick Rees<P>
San Francisco, California<P>

<HR><P>Copyright &copy; 1993, <I>Dr. Dobb's Journal</I></P></BODY></HTML>
