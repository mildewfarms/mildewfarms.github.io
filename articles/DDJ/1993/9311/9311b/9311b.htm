<HTML>
<META NAME="year" CONTENT="1993">
<HEAD>
<TITLE>NOV93: Heap Checking</TITLE></HEAD>
<BODY BGCOLOR="#ffffff">
<h1>Heap Checking<a name="0303_0003"></h1><P>
<h2><a name="0303_0001"><a name="0303_0000">A pair of libraries for handling heap-related bugs</h2><P>
<h3>Steve Oualline</h3><P>
<p><i><a name="0303_0002"><a name="0303_0000">Steve is author of <I>C Elements of Style</I> (M&amp;T Books, 1992) and can be contacted at sdo@crash.cts.com.</i></p><hr><P>
Because they don't cause immediate problems that are easy to spot, heap errors are among the most difficult and frustrating programming bugs to root out. Heap errors are sneaky. They quietly modify random data, causing other portions of your program to fail and you usually don't have any idea what causes the problem.<P>
In comparison, logic errors are easy to find. Suppose, for example, you make a logic error in a check-balancing program--you subtract, instead of add, deposits. The resulting negative balance is obvious and easy to correct.<P>
With heap errors, however, the balance might end up being something 86,#*2,*(#.%%. Unquestionably garbage is being written into memory--but how? In this case, memory used for data was changed by bad code. The code could just as easily have changed code memory or DOS's memory. Since DOS doesn't like having it's memory monkeyed with, your system will likely crash even to the point that Ctrl-Alt-Del doesn't do the job, forcing a hard reset.<P>
This article presents two libraries which address problems such as these. The SafeHeap library intercepts all the heap-related calls (<I>malloc</I>, <I>free</I>, and the like) and performs extensive error checking before actually executing the operation. The LogHeap library prints out a log message every time the heap changes. These log messages can then be used help locate heap problems, such as memory leaks.<P>
<h3><a name="0303_0004">Borland's Heap-checking Routines<a name="0303_0004"></h3><P>
Borland recognizes the difficulties of heap debugging and provides you with a number of library routines designed to ensure the integrity of the heap. These functions, see <a href="#0303_000c">Table 1</A>, give you a tremendous set of tools for finding program errors. For example, if you try to free the same block twice, heap corruption will occur. You can check for this problem by simply using <I>heapchecknode</I> to make sure that the pointer you're freeing is really allocated; see <a href="19930305.htm">Example 1</A>.<P>
By putting calls to the Borland checking routines in strategic places in your code, you can detect heap problems early. There are some problems with this approach, however. First, you must modify your source code. You must also decide where to put the checks, and you may make the wrong choice. Additionally, the C library makes your job harder by burying heap allocation inside library routines such as <I>strdup</I>. Finally, this method requires work that you want to avoid whenever possible.<P>
<h3><a name="0303_0005">The SafeHeap and LogHeap Libraries<a name="0303_0005"></h3><P>
To address the problem of heap errors and fill in some of the gaps with Borland C, I wrote the SafeHeap and LogHeap libraries. This set of debugging tools includes code that checks memory leaks, data integrity on each call, and the like. I've also written a group of sample programs that illustrate how to use the library. The source code and executables for the library and sample programs are available electronically; see &quot;Availability,&quot; page 3.)<P>
To use the library, you need to divide your program into two parts--one part for the heap routines, the rest for the program. See <a href="19930306.htm">Figure 1</A>(a). You can also add another layer between the heap and program for debugging. This layer, which I call the &quot;paranoid&quot; layer, checks all heap requests for sanity and report errors the moment they happen. See <a href="19930307.htm">Figure 1</A>(b). Borland has helped in the construction of this layer by supplying the source code to their run-time library. First, edit the module farheap.asm, renaming the functions as in <a href="19930308.htm">Figure 2</A>. The prefix <I>r_</I> indicates that these are the &quot;real&quot; routines. (You don't have to worry about <I>calloc</I> since it actually calls <I>malloc</I> to allocate the memory.)<P>
Now you can write the paranoid layer. Your version of <I>malloc</I> looks <a href="19930309.htm">Figure 3</A>, although in practice it's not this simple. All this version tells you is that you have an error. It doesn't give you vital information--who or what caused the problem, for instance.<P>
<h3><a name="0303_0006">Getting the Return Address<a name="0303_0006"></h3><P>
To get the return address, you first need the address of the calling procedure. One way of getting this is to run the program under the debugger, put a breakpoint at the error message, and display the call stack. (Unfortunately, some programs are so large and complex that they resist debugging. Run a program normally and you get a pointer error. Run it under the debugger and you crash the debugger and everything else.)<P>
Here's another way of getting calling procedure's address. Looking at the assembly code for a <I>far</I> call, you see it starts with a CALL FAR instruction, see <a href="1993030a.htm">Figure 4</A>(a), which pushes the return address segment and offset onto the stack. The initialization code of a C procedure looks like <a href="1993030b.htm">Figure 4</A>(b). The first instruction saves the <I>bp</I> register on the stack. Next the current stack pointer is saved in the register <I>bp</I>. This sets up the <I>bp</I> register so that it points to space for the local variables. Finally the stack pointer is adjusted to allocate stack space for these variables.<P>
The result of all this is that the <I>bp</I> register points to a block of memory that contains the information in <a href="1993030c.htm">Figure 5</A>. You can get a pointer to the return address with <I>char **ret_ptr = MK_FP(_SS, _BP+2);.</I> This gives you the absolute return address. You need to transform this address into one that's relative to the beginning of the program. The variable <I>_psp</I> contains the segment of the Program Segment Prefix (PSP). This is a 0x100 byte data area at the beginning of each program. You can use this variable to help transform our return address into something useful.<P>
Start by breaking the address apart into a segment and offset; see <a href="1993030d.htm">Figure 6</A>(a). You then adjust the segment by the value of the PSP segment. One final adjustment is needed for the PSP, 0x100 bytes, or 0x10 paragraphs; see <a href="1993030e.htm">Figure 6</A>(b).<P>
<h3><a name="0303_0007">Turning an Address into a Line Number<a name="0303_0007"></h3><P>
Once now you've got the caller address, you need its location in the code. The link map comes to the rescue. The <I>tlink /v</I> option or the <I>bcc -lv</I> option generates a link map containing line numbers. Just scan the listing for an address close to the one in the log file to determine the source line containing the error.<P>
For example, when you run the program BAD_FREE (one of the sample programs available electronically), you get the message <I>heap error(free)</I> <I>023E:0058 20E0:0004 (2,4).</I> The first number in this message is the address call the caused the problem. Looking through the map file for BAD_FREE, you come across <a href="1993030f.htm">Figure 7</A>. You return address (023E:0058) is between line 023E:004D (line 16) and 023E:005A (line 18). Thus, you've narrowed down the problem to line 16 where there's an illegal call to free.<P>
<h3><a name="0303_0008">Memory Leaks<a name="0303_0008"></h3><P>
A memory leak occurs when you allocate, but never free, a block of memory. This can cause you to run out of memory. To find memory leaks, you need to use a different version of the intercept library. Instead of merely reporting errors, this version reports <I>all</I> heap allocation and deallocation calls.<P>
The result is a complete (and somewhat large) log file you can use for locating memory leaks. All you have to do is pair up the <I>malloc</I> calls with the corresponding <I>free</I>s. Anything else is a memory leak.<P>
Rather than do this manually, I've included the utility H_CHECK. First run your program with the LogHeap library, then run H_CHECK, and you'll get a list of allocated memory that was never freed.<P>
<h3><a name="0303_0009">Technical Details<a name="0303_0009"></h3><P>
The compiler provided a number of surprises when creating this set of debugging tools. First, the function <I>fopen</I> calls <I>malloc</I>. This normally isn't a problem, unless you're trying to call <I>fopen</I> from your own &quot;intercept&quot; <I>malloc</I>. The problem is that you've introduced an infinite recursion. The function <I>malloc</I> detects an error, calls <I>fopen</I> to open the log file, which calls <I>malloc</I> which detects an error which calls . . . and on, and on.<P>
The solution is to use the log routine to turn off logging while inside the library. If the <I>in_log</I> flag is set, you can ignore any recursive calls.<P>
The other problem concerns NULL pointer checking. The first time I ran BAD_NULL, I found location 0000:0000 was being changed in two places. This was surprising since I'd only changed it once. Who was the mystery player?<P>
As it turns out, the startup code installs a new divide-by-zero handler, although when the program exits, it restores the old value. This was the restoration I was logging. Consequently, I changed NULL pointer checking to not complain if interrupt vector 0 is restored to it's original value (contained in <I>_Int0Vect</I>).<P>
<h3><a name="0303_000a">C++ Heap Checking<a name="0303_000a"></h3><P>
C++ uses <I>new</I> and <I>delete</I> to allocate memory. In Borland C++, these routines are front ends for <I>malloc</I> and <I>free</I>. Borland C++ defines the symbol __BCPLUSPLUS__ when compiling C++ code. The SafeHeap and LogHeap libraries use this symbol to automatically compile their own version of <I>new</I> and <I>delete</I>. To create a C++ version of the libraries, edit the makefile to include the Borland C++ option -P (force C++ compile).<P>
<h3><a name="0303_000b">Conclusion<a name="0303_000b"></h3><P>
SafeHeap and LogHeap provide a set of tools for finding many different heap problems. They can't find everything, but they will catch most errors. Better yet, they catch errors early, before they have time to corrupt memory and cause other parts of the program to fail.<P>
<h4><a name="0303_000c">Table 1: Borland library routines that deal with the heap.<a name="0303_000c"></h4><P>
<pre>
Routine      Description
<I>heapcheck</I>     Walks through the heap and checks each block's critical
                 attributes such as link pointer and size.
<I>heapcheckfree</I> Checks the free space in the heap to make sure that each
                 word contains the same value. This value can be set by the
                 function <I>heapfillfree</I>.
<I>heapchecknode</I> Checks a given pointer to make sure it points to an
                 allocated block in the heap.
<I>heapfillfree</I>  Fills the free blocks in the heap with a constant.</pre><P>
<h4> <a href="19930310.htm">Example 1</A>: Using the heapchecknode function</h4><P>
<h4> <a href="19930311.htm">Figure 1</A>: (a) Heap routine and main program layers; (b) &quot;paranoid&quot; layer of program added for debugging purposes</h4><P>
<h4> <a href="19930312.htm">Figure 2</A>: Renaming functions in farheap.asm.</h4><P>
<h4> <a href="19930313.htm">Figure 3</A>: The &quot;paranoid&quot; layer version of malloc.</h4><P>
<h4> <a href="19930314.htm">Figure 4</A>: (a) Getting the calling procedure's address using a CALL FAR; (b) initialization code of a C procedure.</h4><P>
<h4> <a href="19930315.htm">Figure 5</A>: The bp register points to a block of memory that contains this information.</h4><P>
<h4> <a href="19930316.htm">Figure 6</A>: (a) Breaking the address apart into a segment and offset; (b) adjusting the segment by the value of the PSP segment.</h4><P>
<h4> <a href="19930317.htm">Figure 7</A>: Line numbers for bad_free.obj (bad_free.c) segment BAD_FREE_TEXT</h4><P>

<HR><P>Copyright &copy; 1993, <I>Dr. Dobb's Journal</I></P></BODY></HTML>
