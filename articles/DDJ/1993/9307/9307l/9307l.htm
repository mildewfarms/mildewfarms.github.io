<HTML>
<META NAME="year" CONTENT="1993">
<HEAD>
<TITLE>JUL93: UNDOCUMENTED CORNER</TITLE></HEAD>
<BODY BGCOLOR="#ffffff">
<h1>UNDOCUMENTED CORNER<a name="0210_0003"></h1><P>
<h2><a name="0210_0001"><a name="0210_0000">The PIF File Format, or, Topview (sort of) Lives!</h2><P>
<h3>Michael P. Maurice</h3><P>
<p><i><a name="0210_0002"><a name="0210_0000">Mike is the developer of EDOS and other enhancements to DOS sessions under Windows. He can be reached on CompuServe at 71171,47, or by telephone at 503-694-2221. Additional PIF-related resources are available on the EDOS BBS, 503-643-8396.</i></p><hr><P>
<h3>Edited by Andrew Schulman</h3><P>
The next time you're in Silicon Valley, visit the Weird Stuff Warehouse in Sunnyvale, just across the street from Fry's Electronics. In addition to piles of dead disk drives and boxes full of doohickies, Weird Stuff (&quot;We Buy Excess Inventories&quot;) also has several aisles of defunct software.<P>
Walking these aisles is a sobering experience for any software developer. Here, for example, you will find the mammoth OS/2 Extended Edition for $14.95 (the disks alone are probably worth more), IBM's Topview software development kit for $7.95, and Topview itself for only $4.95. This is the software boulevard of broken dreams.<P>
The fact is, most new technology never goes anywhere. Very often, something to which many man-years have been devoted ends up as little more than excess inventory. Equally often, these products were greeted with great fanfare when they first appeared. How many of today's hot products are going to wind upon the shelves of Weird Stuff with their price knocked down to $9.95?<P>
So products, technologies, and companies come and go. At the same time, another aspect of our industry is the way that outmoded technology persists longer than anyone would expect. The presence of many CP/M-isms in MS-DOS, even when running on the hottest Pentium processor, is a good example of this kind of uneven development.<P>
Even unsuccessful products can leave their mark. A case in point is this month's topic, the Program Information File (PIF) format. Most Windows programmers and users are probably familiar with PIF files as the mechanism that Windows uses to exercise some control over how &quot;old&quot; DOS programs are run. An end user might use the PIF editor to instruct Windows to run his or her copy of dBase III Plus in a window, with background execution enabled. Windows NT (which may or may not be destined to wind up at Weird Stuff, next to the piles of OS/2 Extended Edition) also uses PIF files.<P>
Most Windows programmers probably don't remember that Windows PIF files come directly from that $4.95 operating environment, Topview. Quarterdeck's Desqview operating environment, which at one point in its career was a Topview clone, uses the same PIF file format, under the name DVP. As Stephen Manes and Paul Andrews note in their biography of Bill Gates, &quot;Microsoft's adaptation of PIFs would remain long after Topview had withered and died.&quot;<P>
So we have a more or less unbroken chain from Topview to NT; the more things change, the more they stay the same. As Mike Maurice shows this month, a large portion of this file format really has remained unchanged since the days of Topview. This portion of the format was documented by Quarterdeck for the Desqview SDK; you can read more about it in the chapter on Desqview in <I>Extending DOS</I>, second edition, edited by Ray Duncan (Addison-Wesley, 1992).<P>
Unfortunately, most items of interest to Windows programmers, such as the flags controlling windowed vs. full-screen display, background vs. foreground execution, the idle-detection flag, and so on, are in portions of the file added later by Microsoft, and thus are not described in the Desqview documentation. Microsoft has documented many other less-important file formats (such as those used by the Calendar applet), but it has not documented PIF.<P>
Mike (author of EDOS, a popular Windows DOS-box enhancer) has done a nice job of cracking this format, and even of explaining how the PIF editor in Windows 3.1 can manage NT PIFs. In essence, after the initial Topview/<P>Desqview portion of the PIF file, there's a linked list of records; each record starts with a string. The first of these records starts at offset 171h in the PIF file and has the string &quot;MICROSOFT PIFEX&quot;; this can be used as a signature to determine that you have a valid Windows PIF file. Most of the interesting PIF flags are kept in the record that begins with the string &quot;WINDOWS 386 3.0&quot;; the PIFSTRUC.H header file (described later) refers to the corresponding structure as DATA386.<P>
As an illustration of what you can do once you know the PIF file format, I've written a small set of functions (PIFEXEC.C, <a href="#0210_0008">Listing One</A>, page 144) that allow a few PIF flags to be set programmatically. The <I>PifExec()</I> function is similar to <I>WinExec()</I>, except that you can specify a window title and set or clear the background-execution and windowed-display flags. <I>PifExec()</I> is written using the functions <I>ReadPif()</I>, <I>WritePif()</I>, <I>GetPif386()</I>, and <I>IsPif()</I>, also in PIFEXEC.C. <I>PifExec()</I> reads in the stock _DEFAULT.PIF file, modifies a few fields, and writes out a new __TMP.PIF file, which it then passes to <I>WinExec()</I>. PIFEXEC.C uses Mike's PIFSTRUC.H (<a href="#0210_000b">Listing Two</A>, page 144).<P>
As always, I welcome your comments and suggestions for this column; send e-mail via CompuServe (76320,302) or Internet (andrew@pharlap.com).<P>
--Andrew Schulman<P>
By now you are probably thinking, &quot;Who cares about PIFs, anyway?&quot; Program Information Files: What could be more boring? Well, maybe PIF files are slightly boring. But knowing how they are constructed can also be very <I>useful</I>!<P>
In case you have forgotten (or never knew), PIF files contain information--flags, integer, byte quantities, and alphabetic strings--to guide the operating environment (notice I did not call it an &quot;operating system&quot;), in starting and running a DOS application.<P>
The DOS executable file format does not contain enough information for a multitasking environment. When writing new applications, you use a new executable file format. In fact, Windows applications use something called, appropriately enough, the &quot;new&quot; executable file format, with an NE signature. But what about running old applications under new environments? The old executable can't be changed. So a secondary file tags along, with information needed by the operating environment, called a Program Information File (PIF).<P>
If you have ever used the PIF Editor in Windows, you know that PIF files contain flags that determine whether the target application can run in the background, what its timeslice priorities are, whether it starts up windowed or full-screen, how much XMS and EMS memory it uses, and so on.<P>
When Moses came down from the mountain, he said there would be PIFs. Well, maybe it was someone else. But the effect was the same. The first record of PIFs seems to have been with IBM's Topview. Remember Topview? It came before QuarterDeck's Desqview. Both of these systems were designed to run more than one task. Would you believe that even Windows NT uses PIFs? This just proves that we are stuck with PIFs, as far as the eye can see.<P>
<h3><a name="0210_0004">The PIF Record Structure<a name="0210_0004"></h3><P>
Topview used a PIF of about 171h bytes. This basic early PIF contained a filename and stored some BIOS data variables that needed duplicating, such as memory and screen information.<P>
When Desqview came out, PIFs were renamed .DVP files, and their size increased, from 172h up to 18Dh in later versions. This extra room was needed for more exotic flags to indicate serial-port use and virtualization of other shared hardware resources (memory, screen, keyboard, and so on). Ralf Brown's &quot;MS-DOS Interrupt List&quot; (available on CompuServe in the IBMPRO forum and at Simtel20 on the Internet) and the book <I>PC Interrupts</I> (Addison-Wesley, 1991) by Ralf Brown and Jim Kyle, contains a fair description of the basic Topview/Desqview PIF format. This information can be used as the beginning basis for decoding the layout of the Windows PIF format.<P>
Today, Windows uses the basic 171h data structure with few modifications, but increases the file, potentially to 3FFh (1023) bytes. These extra bytes are of course not covered in Topview/Desqview descriptions. The new portion of the file is used for storing the flags and switches used by standard and 386 Enhanced Mode Windows when running a DOS session. Only about a third or a half of the original 171h byte space is used by Windows. The PIF Editor reads in 3FFh bytes and will save the number of bytes read, which may be less than 3FFh, as most Windows PIF files are only 221h (545) or 23Ch (572) bytes long.<P>
PIFs created under NT use the same format, but store different information. NT PIFs can be edited and run using Windows 3.1 and vice-versa. How's that? Obviously, the only way that a newer file layout can be recognized by an older editor is if all the formats follow the same guidelines.<P>
The area from 171h to 3FFh in the Windows PIF file is a simple linked-list record system. A sample hex dump of this area (using _DEFAULT.PIF) is shown in <a href="#0210_0007">Figure 1</A>. A block consists of:<P>
<UL>
<li>A 16-byte string, such as &quot;WINDOWS 386 3.0&quot;.</li>
<li>A three-word structure that contains the offsets to the next and current record and the data-record size.</li>
<li>The data record itself.</li>
</UL>
The four known record types are: &quot;MICROSOFT PIFEX&quot;, &quot;WINDOWS 286 3.0&quot;, &quot;WINDOWS 386 3.0&quot;, and &quot;WINDOWS NT  3.1&quot;. (Note that there are two spaces between &quot;NT&quot; and &quot;3.1&quot;.)<P>
The MICROSOFT PIFEX record must come directly at offset 171h. (<I>WinOldAp</I>, the Windows module responsible for running DOS programs, relies on the &quot;MICROSOFT PIFEX&quot; string at offset 171h as a &quot;sanity check&quot; that it has a valid PIF file.) However, the number and order of the WINDOWS ?86 3.0 record groups does not appear to be important. In some files the first W in the 286 record will be zeroed. This seems to indicate that it is not being used, in which case there is normally another 286 record that does not have the W zeroed.<P>
A COMMENT record can be created, using the appropriate string, and plugging in the correct offsets and size. This has been tested and worked on the March 1993 NT beta. The resulting records can be read and written by both the Windows 3.1 and NT PIF editors.<P>
The layout of the Windows PIF format is presented in PIFSTRUC.H (<a href="#0210_000b">Listing Two</A>). Byte offsets in hex are noted in the comments. These offsets are correct up to 171h. After that, they are based on the offsets typical of Windows 3.1 PIFs. These are <I>not</I> correct for all PIFs, but since most readers will only have access to Windows 3.1, I've also provided them in this manner. It is more portable to use the structures and fields in PIFSTRUC.H rather than the hard-coded file offsets.<P>
PIFSTRUC.H uses C bit fields. Oddly enough, in some cases the PIF bit fields are organized on half-byte boundaries; very strange! For example, the reserved hotkeys start in the middle of one byte and continue into the next.<P>
NT PIF files add a new record type; a typical NT PIF file is 745 bytes long. The record consists of the ID string (&quot;WINDOWS NT 3.1&quot;), then 12 unknown bytes followed by two 64-byte fields to hold the pathnames for two files: session-specific AUTOEXEC.BAT and CONFIG.SYS files. NT totally ignores several kinds of information used in Windows 3.1 Enhanced Mode. NT automatically sets the size of conventional memory, priorities, monitor ports, idle detection, and use of the HMA. Under NT, PIF information is much less environment sensitive than in Windows 3.1: Options are simplified, and the NT PIF is left with identifying strings, files, paths, and keyboard issues.<P>
READPIF.C is a demonstration program that prints the contents of a PIF file (available electronically; see &quot;Availability,&quot; page 5). The program is a DOS application that will compile under Borland or Microsoft C; it basically reads the PIF file into a buffer, checks to see if it is a legal MS PIF and then prints out the defined strings. Using <I>printf</I> statements, it formats and prints the values of the various flags, bytes, and word variables. The first 171h bytes are in a fixed format and can be decoded on the spot. The record blocks that follow require following the linked list; a pointer initialized to the first record leads to the next record, and so on. At each record block, a compare is made to find the record type. The record can then be dumped using an appropriately <I>typedef</I>ed pointer. The last record has a next pointer of --1, at which point the For loop is exited and a success message is printed to indicate that the record system was successfully decoded.<P>
<h3><a name="0210_0005">How Windows Uses PIF Settings<a name="0210_0005"></h3><P>
It's interesting to look for a few moments at how Windows actually uses PIF files. This requires an understanding of how Windows starts a DOS session. The following discussion assumes that Standard mode is a dead issue, and that the emphasis should be on Enhanced mode.<P>
DOS sessions are started by a call to WinExec. When it sees that it has a DOS rather than a Windows program, WinExec starts <I>WinOldAp </I>(WINOA386.MOD in Enhanced mode), giving it the PIF or DOS application name to run. If a DOS application name is given, <I>WinOldAp </I>will use _DEFAULT.PIF. If an explicit PIF name is used, it will contain the name of the DOS application or batch file to be executed (see the <I>prog_path</I> field in <a href="#0210_000b">Listing Two</A>).<P>
When the first instance of <I>WinOldAp</I> is started, the 386 grabber is loaded. <I>WinOldAp</I> creates a Virtual Machine (VM), and then WSHELL, a virtual device driver (VxD) built into WIN386.EXE, forces the DOS application to start in the new VM. <I>WinOldAp</I> opens the PIF file to be used and at various times reads out the data it needs to start the session. In general, <I>WinOldAp</I> does not store the PIF information internally.<P>
The DOS session system consists of the grabber, virtual display driver (VDD), virtual keyboard driver (VKD), and <I>WinOldAp</I>. There are other virtual drivers but these are the basic components. The grabber is a Windows DLL that renders a windowed DOS session into a Windows window. When a DOS session is windowed, the DOS application is not actually printing to the real display, but only to a virtual hidden (&quot;shadow&quot;) screen. The grabber reads this hidden screen and displays the results in the window. The VDD maps the physical display memory in and out of the various DOS sessions (VMs), traps the I/O ports, and attempts to bring order in controlled chaos. Many times, when you get a GP fault while running a DOS application, the VDD is at fault. VKD does similar work for the keyboard.<P>
PIF options are supported by several function calls documented in the Windows Device Driver Kit (DDK) <I>Virtual Device Adaptation Guide</I> (VDAG). The following VxD calls are related in one way or another to PIF settings: <I>VDD_PIF_State</I>, <I>VKD_Define_Paste_Mode</I>, <I>VMPoll_Enable_Disable</I>, <I>_DOSMGR_Set_Exec_VM_Data</I>, the G<I>et/Set_Time_Slice_Priority</I>/<I>Granularity</I> functions, <I>SHELL_GetVMInfo</I>, and the <I>V86MMGR_Get/Set_EMS_XMS_Limits</I> functions. There are also undocumented calls, and generally the data structures in <I>WinOldAp</I> and the VxDs are all undocumented.<P>
PIF settings fall into several categories. Those set at VM start-up can't be changed; this includes settings such as the file to be started. Some PIF settings are easy to change in mid-session: priority, exclusive, background, application hotkey, and window title. Some are quite difficult to change in midstream, including memory locking and reserving hot keys. Most video options seem impossible to change on-the-fly. Finally, some options are simply not practical to change once a session starts, such as EMS/XMS memory size.<P>
The Monitor Ports settings in the PIF editor Advanced screen turn on and off VDD's trapping of I/O for the various display modes. Enabling VDD trapping causes a performance slowdown and is normally avoided. The Emulating Text Mode option causes the VDD to replace some video BIOS calls with its own routines. The performance improvement is substantial.<P>
<h3><a name="0210_0006">Changing PIF Settings On-the-Fly<a name="0210_0006"></h3><P>
Knowledge of PIF layout is necessary to change PIF settings which, as shown in the PIFEXEC example, allows much more dynamic DOS-session creation. However, the weakness in this approach is that the PIF has to be changed before the DOS application is started.<P>
A more elegant solution would allow changes on-the-fly, while the DOS application is running. Changing PIF settings on-the-fly requires building a Virtual Device Driver (VxD). A VxD can watch PIF setting changes and make its own changes, in concert or at any time it chooses.<P>
For the past year I've been building just such a system. It's called &quot;EDOS,&quot; or Enhanced DOS for Windows, and is built from a VxD and a DLL. It supports changing most PIF settings (for instance, priorities, time slice, exclusive, background, fast paste, and task switching) either from the command line (using the undocumented COMMAND.COM interface, INT 2Fh functions AE00h and AE01h) or by way of a virtual-8086 (V86) entry point. A V86 entry point allows a DOS application to call into a VxD and execute code running at ring zero. There is also a protected-mode (PM) entry-point system for use by Windows applications. The entry-point mechanism is a feature of the VxD system, but the code that is executed and that provides the useful functionality is the responsibility of the VxD developer. VxD development is not trivial, but it can be fun.<P>
If a Windows PIF had additional flag bits defined, then a utility such as EDOS could be enhanced to examine this information. The VxD could be modified to enable/disable disk swapping, or perhaps to assign the serial port automatically. Alternatively, it could be modified to support a V86-mode DOS call that would assign the serial port in an open/<P>close environment.<P>
A shareware version of EDOS, which demonstrates changing many PIF settings from the command line, is available on CompuServe (GO WINADV) and is also included in Brian Livingston's book <I>Windows 3.1 Secrets</I> (IDG Books, 1992).<P>
In closing, we might speculate on why Microsoft does not document the PIF file format, especially when so many other formats, such as font files, Program Manager files, and even the file format used by the Calendar applet have been documented. One developer at Microsoft told us that, &quot;We can't document that; it's going away in the next release.&quot; However, as we've seen, the ages-old PIF format persists in NT, and, for better or worse, definitely is <I>not</I> going away any time soon.<P>
<pre></pre><P>
<h4><a name="0210_0007">Figure 1: Hex dump of _DEFAULT.PIF: Boxes indicate next and current pointers.<a name="0210_0007"></h4><P>
<pre>
0000: 00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00 ................
0010: 00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00 ................
0020: 80 02 80 00 5F 44 45 46  41 55 4C 54 2E 42 41 54 ...._DEFAULT.BAT
0030: 00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00 ................
....
0170: 00 4D 49 43 52 4F 53 4F  46 54 20 50 49 46 45 58 .MICROSOFT PIFEX
0180: 00 87 01 00 00 71 01 57  49 4E 44 4F 57 53 20 32 .....q.WINDOWS 2
0190: 38 36 20 33 2E 30 00 A3  01 9D 01 06 00 00 00 00 86 3.0..........
01A0: 00 00 00 57 49 4E 44 4F  57 53 20 33 38 36 20 33 ...WINDOWS 386 3
01B0: 2E 30 00 FF FF B9 01 68  00 80 02 80 00 64 00 32 .0.....h.....d.2
01C0: 00 00 04 00 00 00 04 00  00 08 10 02 00 1F 00 00 ................
01D0: 00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00 ................
</pre><P>

<PRE>


_UNDOCUMENTED CORNER COLUMN_<a name="0210_0008">
edited by Andrew Schulman
_THE PIF FILE FORMAT_
by Michael P. Maurice

<a name="0210_0009"></pre><B>[LISTING ONE]</B><pre>: PIFEXEC.C<a name="0210_0009">

/* PIFEXEC.C -- Dr. Dobb's Journal &quot;Undocumented Corner&quot;
Andrew Schulman, April 1993 -- bcc -WS -DTESTING pifexec.c */

#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &quot;windows.h&quot;
#include &quot;pifstruc.h&quot;

/* is this a valid Windows PIF file? */
BOOL IsPif(PIF far *fppif)
{
    BYTE far *fp = (BYTE far *) fppif;
    return (lstrcmp(&amp;fp[PIFEX_OFFSET], &quot;MICROSOFT PIFEX&quot;) == 0);
}
/* read PIF file into memory */
BOOL ReadPif(char far *name, PIF far *fppif)
{
    HFILE f;
    UINT cb;
    if ((f = _lopen(name, READ)) == HFILE_ERROR)
        return FALSE;
    if ((cb = _lread(f, fppif, MAX_PIFFILE_SIZE)) == HFILE_ERROR)
        return FALSE;
    if (cb &lt; PIFEX_OFFSET)
        return FALSE;
    _lclose(f);
    return IsPif(fppif);
}
/* write PIF structure to file on disk */
BOOL WritePif(char far *name, PIF far *fppif)
{
    HFILE f;
    UINT cb;
    if ((f = _lcreat(name, 0)) == HFILE_ERROR)
        return FALSE;
    if ((cb = _lwrite(f, fppif, MAX_PIFFILE_SIZE)) == HFILE_ERROR)
        return FALSE;
    if (cb &lt; MAX_PIFFILE_SIZE)
        return FALSE;
    _lclose(f);
    return TRUE;
}
/* return pointer to the Windows 386 section */
DATA386 far *GetPif386(PIF far *fppif)
{
    BYTE far *fp = ((BYTE far *) fppif) + PIFEX_OFFSET;
    SECTIONHDR far *fpsection =
        (SECTIONHDR far *) (fp + sizeof(SECTIONNAME));
    if (! IsPif(fppif))
        return (DATA386 far *) 0;
    for (;;)
    {
        if (lstrcmp(fp+1, &quot;INDOWS 386 3.0&quot;) == 0)
            return (DATA386 far *) ((BYTE far *) fppif +
                fpsection-&gt;current_section);
        if (fpsection-&gt;next_section == 0xFFFF)
            break;
        fp = (BYTE far *) fppif + fpsection-&gt;next_section;
        fpsection = (SECTIONHDR far *) (fp + sizeof(SECTIONNAME));
    }
    /* still here */
    return (DATA386 far *) 0;
}
int _dos_delete_file(char far *filename)
{
    _asm push ds
    _asm lds dx, dword ptr filename
    _asm mov ah, 41h
    _asm int 21h
    _asm pop ds
    _asm jc error
    return 0;   // success
error:;
    // return error in AX
}
/* WinExec a DOS app, specifying a few PIF settings. This is intended only as
  an example; other PIF settings can similarly be manipulated programmatically.
  For example, the program's command line
   (ppif-&gt;prog_param), default directory (ppif-&gt;def_dir), and
   idle-detect flag (data386-&gt;flags386.Detect_Idle). */
UINT PifExec(char far *name, char far *title, BOOL background, BOOL windowed)
{
    static char *tmp_pif = &quot;__tmp.pif&quot;;
    PIF *ppif;
    UINT retval = 0;
    DATA386 far *data386;
    char *pathname;

    if (! (pathname = (char *) malloc(256)))
        return FALSE;
    if (! (ppif = (PIF *) malloc(MAX_PIFFILE_SIZE)))
    {
        free(pathname);
        return FALSE;
    }
    /* read in the standard _DEFAULT.PIF file */
    GetWindowsDirectory(pathname, 256);
    strcat(pathname, &quot;\\_default.pif&quot;);
    if (! ReadPif(pathname, ppif))
        goto done;
    /* modify some fields in the PIF structure */
    if ((lstrlen(name) &gt; 63) || (lstrlen(title) &gt; 30))
        goto done;
    lstrcpy(ppif-&gt;prog_path, name);
    lstrcpy(ppif-&gt;title, title);
    if (! (data386 = GetPif386(ppif)))
        goto done;
    data386-&gt;flags_386.BackgroundON = background;
    data386-&gt;flags_386.FullScreenYes = (! windowed);
    /* write out a new __TMP.PIF file, WinExec it, and delete it */
    if (WritePif(tmp_pif, ppif))
    {
        retval = WinExec(tmp_pif, SW_NORMAL);
        _dos_delete_file(tmp_pif);
    }
done:
    free(pathname);
    free(ppif);
    return retval;
}
#ifdef TESTING
/* Standalone test:  run with a DOS program name on the command
   line.  For example:  PIFEXEC \DOS\COMMAND.COM */
int PASCAL WinMain(HANDLE hInstance, HANDLE hPrevInstance,
    LPSTR lpszCmdLine, int nCmdShow)
{
    if (lpszCmdLine &amp;&amp; *lpszCmdLine)
        PifExec(lpszCmdLine, &quot;A Test of PifExec&quot;, 1, 1);
    else
        MessageBox(0, &quot;usage: pifexec [program name]&quot;, &quot;PIFEXEC&quot;, MB_OK);
    return 0;
}
#endif


<a name="0210_000a"></pre><B>[LISTING TWO]</B><pre> : PIFSTRUC.H<a name="0210_000b">

/* PIFSTRUC.H -- Structure of Windows PIF files --
Dr. Dobb's Journal &quot;Undocumented Corner&quot; -- Mike Maurice, July 1993 */

#define MAX_PIFFILE_SIZE        0x3FF
#define PIFEX_OFFSET            0x171

typedef struct {
    char name_string[16];
} SECTIONNAME, *npSECTIONNAME, FAR *fpSECTIONNAME;
typedef struct {
    WORD next_section; /* offset of section after this      */
    /* last section if contents = FFFF   */
    /* contents = 205, NT = 1A3          */
    WORD current_section; /* offset of data */
    /* contents = 19d                    */
    WORD size_section; /* sizeof section */
    /* contents = 68, NT = 06            */
} SECTIONHDR, *npSECTIONHDR, FAR *fpSECTIONHDR;
typedef struct {
    int Unused0 :1;
    int Graph286 :1;
    int PreventSwitch :1;
    int NoScreenExch :1;
    int Close_OnExit :1; /* only bit used in 386 mode */    // 0x10
    int Unused001 :1;
    int Com2 :1;
    int Com1 :1;
} CLOSEONEXIT;
typedef struct {
    int AllowCloseAct :1;       // 0x01
    int BackgroundON :1;        // 0x02
    int ExclusiveON :1;         // 0x04
    int FullScreenYes :1;       // 0x08
    int Unused1 :1;
    int RSV_ALTTAB :1;          // 0x20
    int RSV_ALTESC :1;          // 0x40
    int RSV_ALTSPACE :1;        // 0x80
    int RSV_ALTENTER :1;        // 0x01 &lt;&lt; 8
    int RSV_ALTPRTSCR :1;       // 0x02 &lt;&lt; 8
    int RSV_PRTSCR :1;          // 0x04 &lt;&lt; 8
    int RSV_CTRLESC :1;         // 0x08 &lt;&lt; 8
    int Detect_Idle :1;         // 0x10 &lt;&lt; 8
    int UseHMA :1;              // 0x20 &lt;&lt; 8
    int Unused2 :1;
    int EMS_Locked :1;          // 0x80 &lt;&lt; 8
} FLAGS386;
typedef struct {
    int XMS_Locked :1;          // 0x01
    int Allow_FastPst :1;       // 0x02
    int Lock_App :1;            // 0x04
    int Unused3 :5+8;
} FLAGSXMS;
typedef struct {
    int VidEmulateTxt :1;       // 0x01
    int MonitorText :1;         // 0x02
    int MonitorMGr :1;          // 0x04
    int MonitorHiGr :1;         // 0x08
    int InitModeText :1;        // 0x10
    int InitModeMGr :1;         // 0x20
    int InitModeHiGr :1;        // 0x40
    int VidRetainVid :1;        // 0x80
    int VideoUnused :8;
} VIDEO;
typedef struct {
    int HOT_KEYSHIFT :1;    // 0x01
    int Unused4 :1;
    int HOT_KEYCTRL :1;     // 0x04
    int HOT_KEYALT :1;      // 0x08
    int Unused5 :4+8;
} HOTKEY;
typedef struct {
    int AltTab286 :1;
    int AltEsc286 :1;
    int AltPrtScr286 :1;
    int PrtScr :1;
    int CtrlEsc286 :1;
    int SaveScreen :1;
    int Unused10 :2;
} FLAGS286;
typedef struct {
    int Unused11 :4+2;
    int Com3 :1;
    int Com4 :1;
} COMPORT;
typedef struct {
    /* The offsets are accurate only for Windows -- *NOT* NT! */
    short mem_limit; /* 19d */
    short mem_req; /* 19f */
    WORD for_pri; /* 1a1  */
    WORD back_pri; /* 1a3  */
    short ems_max; /* 1a5  */
    WORD ems_min; /* 1a7  */
    short xms_max; /* 1a9  */
    WORD xms_min; /* 1ab  */
    FLAGS386 flags_386; /* 1ad  */
    FLAGSXMS flags_XMS; /* 1af  */
    VIDEO video; /* 1b1  */
    WORD zero1; /* 1b3  */
    WORD hot_key_scan; /* 1b5 */
    /* any other legal ky on board, a scan code number. */
    HOTKEY hot_key_state; /* 1b7,  alt, ctrl, shift.              */
    WORD hot_key_flag; /* 1b9, 0=no hot key, ? f= hot key defined */
    WORD zero2[5]; /* 1ba  */
    char opt_params[64]; /* 1c5, 386 mode for opt params         */
} DATA386, FAR *fpDATA386;
typedef struct {
    WORD xmsLimit286; /* 237  */
    WORD xmsReq286; /* 239  */
    FLAGS286 flags_286; /* 23b  */
    COMPORT com_ports; /* 23c  */
} DATA286, FAR *fpDATA286;
typedef struct {
    /* from 0 -170 hex, not used by Windows, unless so indicated. */
    /* Note that in some cases the PIF editor fills in a value,     */
    /* even though it does not SEEM to be used        */
    BYTE resv1;
    BYTE checksum; /* used by Windows                     */
    char title[30]; /* 02 used by 286,386 mode for title   */
    short max_mem; /* 20h used byt 286, 386 mem size      */
    short min_mem; /* 22h, these 2 are duplicates see 19c */
    char prog_path[63]; /* 24h used by 286,386 mode for program &amp; path*/
    CLOSEONEXIT close_onexit; /* 63h, 286 and 386 modes     */
    BYTE def_drv; /* 64h  */
    char def_dir[64]; /* 65h used by 286,386 mode for start dir */
    char prog_param[64]; /* a5, used by 286 */
    BYTE initial_screenMode; /* usually zero, sometimes 7F hex         */
    BYTE text_pages; /* always one                             */
    BYTE first_interrupt; /* always zero                            */
    BYTE last_interrupt; /* always FF hex                          */
    BYTE rows; /* always 25                              */
    BYTE cols; /* always 80                              */
    BYTE window_pos_row;
    BYTE window_pos_col;
    WORD sys_memory; /* always 7  */
    char shared_prog_name[64];
    char shared_prog_data_file[64];
    BYTE flags1; /* 16f, usually zero  */
    BYTE flags2; /* 170, usually zero  */
    /* Microsoft PIF editor reads up to 3FF hex bytes in. When writing back */
    /* out it writes same number of byte read. This means a PIF file can    */
    /* be up to 3FF hex bytes with the assumption that any 3rd party        */
    /* utilities take this into account. NOTE 400 hex WILL NOT WORK !!      */
    /* Tested under Win 3.1 and NT (Oct 92 beta).                           */
} PIF, FAR *fpPIF; /* PIF structure    */
#ifdef DOCUMENTATION
/* ---   171h  Begin of Microsoft Windows Stuff */
SECTIONNAME pifex; /* 171,hard coded &quot; MICROSOFT PIFEX&quot;   */
SECTIONHDR section_zero; /* 181   */
SECTIONNAME first_name; /* 187, hard coded &quot;WINDOWS 386 3.0&quot;, 286 if NT  */
SECTIONHDR section_one; /* 197, points to str_286A, or section_nameNT   */
#ifdef NT
DATA286 data_286; /* 19D   */
SECTIONNAME section_nameNT; /* 1A3, hard coded &quot;WINDOWS 386 3.0&quot;  */
SECTIONHDR section_hdrNT; /* 1B3   */
DATA386 data_386; /* 1B9   */
/* paded with zeros, from 220-22f hex.   */
#else
DATA386 data_386; /* 19D   */
/* ---205 hex, end of 386 material   */
/* start of 286 specific stuff       */
SECTIONNAME str286A; /* 205, hard coded &quot; INDOWS 286 3.0&quot; */
SECTIONHDR section_286A; /* 215,  */
DATA286 data_286A; /* 21B   */
SECTIONNAME str286B;/* 221, hard coded &quot;WINDOWS 286 3.0&quot;  */
SECTIONHDR section_286B; /* 231   */
DATA286 data_286B; /* 237   */
/* ends at 23c   */
#endif   /* NT */
/* 23d   */
#endif   /* DOCUMENTATION   */
typedef struct {
    SECTIONNAME SName;
    SECTIONHDR Hdr;
    DATA386 D386;
} BLOCK386, *npBLOCK386, FAR *fpBLOCK386;
typedef struct {
    SECTIONNAME SName;
    SECTIONHDR Hdr;
    //DATA386 D386;
} BLOCKNT, *npBLOCKNT, FAR *fpBLOCKNT;
typedef struct {
    SECTIONNAME SName;
    SECTIONHDR Hdr;
    DATA286 D286;
} BLOCK286, *npBLOCK286, FAR *fpBLOCK286;
typedef char FAR *fpBLOCKCMNT;
typedef char *npBLOCKCMNT;
typedef struct {
    SECTIONNAME SName;
    SECTIONHDR SHdr;
} BLOCKVOID, *npBLOCKVOID, FAR *fpBLOCKVOID;
typedef struct {
    char AuxName[8+1+3];
} SECTIONAUX, *npSECTIONAUX, FAR *fpSECTIONAUX;
typedef struct {
    BYTE Hdr1[3];
    BYTE HChkSum;
} SECTIONHDR1, *npSECTIONHDR1, FAR *fpSECTIONHDR1;
typedef struct {
    SECTIONHDR1 CHdr1;
    SECTIONAUX CAux;
} COMMENTS, *npCOMMENTS, FAR *fpCOMMENTS;



<a name="0210_000c"></pre><B>[LISTING THREE:  READPIF.C]</B><pre><a name="0210_000c">

/*
READPIF.C
Copyright 1992,1993 Michael P. Maurice
This is very accurate and moderately tested.
This is originally based on documentation in Ralf Brown's interrupt list.

The bit structures that are passed to printf, etc, are not portable
and give a structure passed by value warning under Borland C.
*/

#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

typedef unsigned char BYTE;
typedef unsigned short WORD;

#define FAR     _far

#include &quot;pifstruc.h&quot;

void display_NT(BLOCKNT *pPIF);
void display_386(DATA386 * pPIF);
void display_286(DATA286 * pPIF);
void display_comment(char * pPIFCOMMENT);
void usage(void);
void argcheck(int, char **);
void help(void);

/* make sure this is in public space &amp; cleared to ZERO! */
char tbuf[MAX_PIFFILE_SIZE + 10];
char *ifilename;
int lflag; /* list linked records                       */
int cflag; /* list comment records                      */
int nflag; /* NT records                                */
int vflag; /* verbose listing, including the kitchen sink */
int nfile;
int flag2; /* 286 records only                          */
int flag3; /* 386 records only                          */

main(int argc, char **argv)
{
    FILE *ifil;
    BYTE tChkSum;
    unsigned int offset;
    int i;
    PIF *pPIF;
    char *pPIFCOMMENT;
    DATA286 *pPIF286;
    DATA386 *pPIF386;
    BLOCKNT *pPIFNT;
    char *pPIFEX;
    SECTIONHDR *pPrevSect, *pCurSect;
    SECTIONNAME *pName;
    char *pLastByte;

    if (argc &lt; 2) usage();
    ifilename = *++argv;

    argcheck(argc,--argv);

    ifil = fopen(ifilename, &quot;rb&quot;);
    if(!ifil) {
        printf(&quot;Failed Open: %s\n&quot;, ifilename);
        exit(1);
    }

    fputs(&quot;\n\nReading PIF: &quot;, stdout);
    fputs(ifilename, stdout);
    fputs(&quot;\n&quot;, stdout);

    fread(tbuf, MAX_PIFFILE_SIZE ,1, ifil);
    fclose(ifil);

    for (i=2, tChkSum=0; i&lt; PIFEX_OFFSET; i++)
        tChkSum += tbuf[i];
    if(vflag)
        printf(&quot;calc.chksum = 0x%x\n\n&quot;,(tChkSum &amp; 0x00ff));

    pPIF = (PIF *)&amp;tbuf;

#define PIF_String(a, b)  if(pPIF-&gt;a) printf(&quot;%s\n&quot;,b)

    if(tChkSum != pPIF-&gt;checksum)
        fputs(&quot;Checksum ERROR!!\n&quot;, stdout);

    if(vflag)
    {
        printf(&quot;\
resv1        = 0x%x\n\
checksum     = 0x%x\n&quot;,
        pPIF-&gt;resv1, pPIF-&gt;checksum &amp; 0x00ff);

        printf(&quot;close_onexit = 0x%x  ,&quot;,pPIF-&gt;close_onexit);
    }/* vflag     */

    printf(&quot;\n\
title        = %.30s\n\
max_mem      = %d dec.\n\
min_mem      = %d dec.\n\
prog_path    = %.63s\n&quot;,
    pPIF-&gt;title, pPIF-&gt;max_mem,
    pPIF-&gt;min_mem, pPIF-&gt;prog_path);

    if(flag2)
    {
        PIF_String(close_onexit.Graph286, &quot;Graphics 286&quot;);
        PIF_String(close_onexit.NoScreenExch, &quot;No Screen Exchange 286&quot;);
        PIF_String(close_onexit.PreventSwitch, &quot;Prevent Switch 286&quot;);
        PIF_String(close_onexit.Close_OnExit, &quot;Close On exit&quot;);
        PIF_String(close_onexit.Com1, &quot;Com 1 - 286&quot;);
        PIF_String(close_onexit.Com2, &quot;Com 2 - 286&quot;);
    }/* flag2     */

    printf(&quot;def_drv = %s\n&quot;, pPIF-&gt;def_drv);
    printf(&quot;def_dir = %s\n&quot;, pPIF-&gt;def_dir);
    if(flag2)
        printf(&quot;286 opt. param = %.64s\n&quot;, pPIF-&gt;prog_param); /*vflag*/

    printf(&quot;\
initial_screenMode    = 0x%x\n\
text_pages            = 0x%x\n\
first_interrupt       = 0x%x\n\
last_interrupt        = 0x%x\n\
rows                  = %u dec.\n\
cols                  = %u dec.\n&quot;,
    pPIF-&gt;initial_screenMode &amp; 0x00ff,pPIF-&gt;text_pages&amp; 0x00ff,
    pPIF-&gt;first_interrupt&amp; 0x00ff,pPIF-&gt;last_interrupt&amp; 0x00ff,
    pPIF-&gt;rows &amp; 0x00ff, pPIF-&gt;cols&amp; 0x00ff);

    if(vflag) {
        printf(&quot;\
window_pos_row        = 0x%x\n\
window_pos_col        = 0x%x\n\
sys_memory            = 0x%x\n\
shared_prog_name      = %s\n\
shared_prog_data_file = %s\n\
flags1                = 0x%x\n\
flags2                = 0x%x\n&quot;,

        pPIF-&gt;window_pos_row&amp; 0x00ff, pPIF-&gt;window_pos_col&amp; 0x00ff,
        pPIF-&gt;sys_memory, pPIF-&gt;shared_prog_name,
        pPIF-&gt;shared_prog_data_file,
        pPIF-&gt;flags1&amp; 0x00ff, pPIF-&gt;flags2&amp; 0x00ff);
    }/* vflag     */

    pPIFEX = &amp;tbuf[PIFEX_OFFSET];
    if(strcmp(pPIFEX, &quot;MICROSOFT PIFEX&quot;))
    {
        fputs(&quot;NOT a MICROSOFT PIF FILE\n&quot;, stdout);
        return 1;
    }

    fputs(&quot; ********** pifex = &quot;,stdout);
    fputs(pPIFEX, stdout);
    fputs(&quot;  *********************\n&quot;, stdout);

    pPrevSect = (SECTIONHDR *)&amp;tbuf[PIFEX_OFFSET+sizeof(SECTIONNAME)];
    pName = (SECTIONNAME *)&amp;tbuf[pPrevSect-&gt;next_section];
    pLastByte = &amp;tbuf[MAX_PIFFILE_SIZE];

    for (i=0;i&lt;40;i++)  {
        if(lflag) {
            printf(&quot;\n\
next_offset = 0x%x, \
current_section = 0x%x, \
size_section = 0x%x\n&quot;,
            pPrevSect-&gt;next_section, pPrevSect-&gt;current_section,
            pPrevSect-&gt;size_section);
        }/* sflag */

        if(pPrevSect-&gt;next_section == 0xFFFF)
            break;
        fputs(&quot;============================================\n&quot;,stdout);

        offset = pPrevSect-&gt;next_section+sizeof(SECTIONNAME);
        pCurSect =(SECTIONHDR *) &amp;tbuf[offset];

        fputs(&quot;----------------- Record Type: &quot;,stdout);
        if(pName-&gt;name_string[0] != 0)
            fputc(pName-&gt;name_string[0], stdout);
        else fputc('\x20', stdout);

        /* if the first char position is zero, the section is not in use */
        /* however, since this is a dump program, we will dump the section */

        fputs(pName-&gt;name_string+1, stdout);
        fputs(&quot; ----\n&quot;, stdout);

        if(!strcmp(pName-&gt;name_string+1, &quot;INDOWS 386 3.0&quot;))
        {
            if(flag3)
            {
                pPIF386 = (DATA386 *)&amp;tbuf[pCurSect-&gt;current_section];

                display_386(pPIF386);
                if(pPIF386-&gt;zero1 != 0) fputs(&quot;\7 386.zero1 != 0 \n&quot;, stdout);

                if((pPIF386-&gt;zero2[0] == 0) ||
                    (pPIF386-&gt;zero2[1] == 0) || (pPIF386-&gt;zero2[2] == 0) ||
                    (pPIF386-&gt;zero2[3] == 0) ||(pPIF386-&gt;zero2[4] == 0)) ;
                else
                    fputs(&quot;\7 386.zero2 != 0 \n&quot;, stdout);

                if((pPIF386-&gt;hot_key_flag == 0) ||
                    (pPIF386-&gt;hot_key_flag == 0xF)) ;
                else
                    fputs(&quot;\7 386.hot_key_flag has strange value\n&quot;, stdout);
            }/* flag3 */
        }
        if(!strcmp(pName-&gt;name_string+1, &quot;INDOWS 286 3.0&quot;))
            if(flag2)
            {
                pPIF286 = (DATA286 *)&amp;tbuf[pCurSect-&gt;current_section];
                display_286(pPIF286);
            }/* vflag2 */

        if(!strcmp(pName-&gt;name_string+1, &quot;INDOWS NT  3.1&quot;))
            if(nflag)
            {
                pPIFNT = (BLOCKNT *)&amp;tbuf[pCurSect-&gt;current_section];
                display_NT(pPIFNT);
            }/* nflag */

        /* here we document a technique for supporting comments in PIFs */
        if(!strcmp(pName-&gt;name_string, &quot;COMMENT&quot;))
            if(cflag)
            {
                pPIFCOMMENT =
                    (char *)&amp;tbuf[pCurSect-&gt;current_section+sizeof(COMMENTS)];
                display_comment(pPIFCOMMENT);
            }/* cflag */

        pPrevSect = (SECTIONHDR *)&amp;tbuf[pPrevSect-&gt;next_section +
            sizeof(SECTIONNAME)];
        pName = (SECTIONNAME *)&amp;tbuf[pPrevSect-&gt;next_section];
        if((char *)pPrevSect &gt; pLastByte) break;

    }/* for */

    if(pPrevSect-&gt;next_section == 0xFFFF)
        fputs(&quot;\n\n----Success: Last Record Found---- \n\n&quot;, stdout);
    else
        fputs(&quot;\n\n----ERROR: Last Record NOT Found---- \n\n&quot;, stdout);

    /* the offset defintions labeled unknown should have some kind of
       code to check for any deviation from the usual contents */

    return 0;
}

void usage(void)
{
    fputs(&quot;readpif infile \n&quot;, stdout);
    fputs(&quot;readpif -?, for help\n&quot;, stdout);
    exit(1);
}

void display_NT(BLOCKNT *pPIF)
{
    char *ptr = (char *) pPIF;
    ptr += 12; /* padding ?? */
    fputs(ptr, stdout);
    fputs(&quot;\n&quot;, stdout);
    ptr += 64; /* start of next string */
    fputs(ptr, stdout);
    fputs(&quot;\n&quot;, stdout);
}

void display_386(DATA386 * pPIF)
{
    printf(&quot;\
mem_req   = %d dec.\n\
mem_limit = %d dec.\n\
for_pri   = %u\n\
back_pri  = %u\n\
ems_min   = %u\n\
ems_max   = %u\n\
xms_min   = %u\n\
xms_max   = %u\n&quot;,
    pPIF-&gt;mem_req, pPIF-&gt;mem_limit, pPIF-&gt;for_pri,
    pPIF-&gt;back_pri, pPIF-&gt;ems_min, pPIF-&gt;ems_max,
    pPIF-&gt;xms_min, pPIF-&gt;xms_max);

    if(vflag)
        printf(&quot;flags_386 = 0x%x  ,&quot;, pPIF-&gt;flags_386);

    PIF_String(flags_386.AllowCloseAct, &quot;Allow Close while Active&quot;);
    PIF_String(flags_386.ExclusiveON,&quot;Exclusive ON&quot;);
    PIF_String(flags_386.BackgroundON,&quot;Background ON&quot;);
    PIF_String(flags_386.FullScreenYes,&quot;Full Screen YES&quot;);
    PIF_String(flags_386.RSV_ALTESC,&quot;RSV_ALT ESC&quot;);
    PIF_String(flags_386.RSV_ALTTAB,&quot;RSV_ALT TAB&quot;);
    PIF_String(flags_386.RSV_ALTSPACE,&quot;RSV_ALT SPACE&quot;);
    PIF_String(flags_386.RSV_ALTENTER,&quot;Reserve ALT-ENTER&quot;);
    PIF_String(flags_386.RSV_ALTPRTSCR,&quot;Reserve ALT-PRT-SCR&quot;);
    PIF_String(flags_386.RSV_PRTSCR,&quot;Reserve PRT-SCR&quot;);
    PIF_String(flags_386.RSV_CTRLESC,&quot;Reserve CTRL-ESC&quot;);
    PIF_String(flags_386.Detect_Idle, &quot;Detect Idle&quot;);
    PIF_String(flags_386.EMS_Locked,&quot;EMS Locked&quot;);

    if(pPIF-&gt;flags_386.UseHMA) ;
    else fputs(&quot;Use HMA\n&quot;, stdout);

    if(vflag)
        printf(&quot;flagsXMS = 0x%x  &quot;, pPIF-&gt;flags_XMS);
    PIF_String(flags_XMS.XMS_Locked,&quot;XMS_Locked&quot;);
    PIF_String(flags_XMS.Allow_FastPst,&quot;Allow_FastPst&quot;);
    PIF_String(flags_XMS.Lock_App,&quot;Lock_App&quot;);
    fputs(&quot;\n&quot;,stdout);

    if(vflag)
        printf(&quot;video     = 0x%x, &quot;, pPIF-&gt;video);

    if(pPIF-&gt;video.MonitorText) ;
    else fputs(&quot;Monitor Text\n&quot;, stdout);
    if(pPIF-&gt;video.MonitorMGr) ;
    else fputs(&quot;Monitor Med Gr\n&quot;, stdout);
    if(pPIF-&gt;video.MonitorHiGr) ;
    else fputs(&quot;Monitor Hi Gr\n&quot;, stdout);

    PIF_String(video.InitModeText,&quot;Init Vid. Mode Text&quot;);
    PIF_String(video.InitModeHiGr,&quot;Init Vid. Mode Gr&quot;);
    PIF_String(video.InitModeHiGr,&quot;Init Vid. Mode Hi Gr&quot;);
    PIF_String(video.VidEmulateTxt,&quot;EmulateTxt&quot;);
    PIF_String(video.VidRetainVid,&quot;VidRetainVid&quot;);

    /* this test for a hot key defined may not be correct     */
    /* it may be that the test should be on hot_key_flag     */
    if(vflag)
        printf(&quot;hot key flag = 0x%x \n&quot;, pPIF-&gt;hot_key_flag);

    if(pPIF-&gt;hot_key_scan == 0)
        fputs(&quot;No Hot Key Defined\n&quot;,stdout);
    else {
        if(vflag)
            printf(&quot;hot_key_state = 0x%x\n&quot;, pPIF-&gt;hot_key_state);

        PIF_String(hot_key_state.HOT_KEYALT,&quot;HOT-KEY ALT&quot;);
        PIF_String(hot_key_state.HOT_KEYCTRL,&quot;HOT-KEY CTRL&quot;);
        PIF_String(hot_key_state.HOT_KEYSHIFT,&quot;HOT-KEY SHIFT&quot;);

        printf(&quot; - scan code = 0x%x hex\n&quot;, pPIF-&gt;hot_key_scan);
    }

    if(vflag)
    {
        printf(&quot; zero1 = %x\n&quot;, pPIF-&gt;zero1);
        printf(&quot; zero2 = %x %x %x %x %x\n&quot;, pPIF-&gt;zero2[0],
            (pPIF-&gt;zero2[1]), (pPIF-&gt;zero2[2]),
            (pPIF-&gt;zero2[3]), (pPIF-&gt;zero2[4]));
    }/* vflag */

    printf(&quot;386 optional parameters = %.64s\n&quot;,pPIF-&gt;opt_params );
}

void display_comment(char *p)
{
    fputs(p, stdout);
    fputs(&quot;\n&quot;, stdout);
}

void display_286(DATA286 * pPIF)
{
    if(vflag)
        printf(&quot;flags_286 = 0x%x  - &quot;, pPIF-&gt;flags_286);

    PIF_String(flags_286.AltTab286,&quot;286 ALT TAB&quot;);
    PIF_String(flags_286.AltEsc286,&quot;286 ALT ESC&quot;);
    PIF_String(flags_286.AltPrtScr286,&quot;286 ALT PRT SCR&quot;);
    PIF_String(flags_286.PrtScr, &quot;286 PRT SCR&quot;);
    PIF_String(flags_286.CtrlEsc286,&quot;286 CTRL ESC&quot;);
    PIF_String(flags_286.SaveScreen,&quot;Save Screen&quot;);

    printf(&quot;286 xms limits=%d req=%d\n&quot;,pPIF-&gt;xmsLimit286, pPIF-&gt;xmsReq286);
    printf(&quot;com_ports = 0x%x  - \n&quot;, pPIF-&gt;com_ports);

    PIF_String(com_ports.Com3,&quot;COM 3&quot;);
    PIF_String(com_ports.Com4,&quot;COM 4&quot;);
    fputs(&quot;\n&quot;, stdout);
}

void help(void)
{
    fputs(&quot;readpif -v  -l -n -2 -3 -c filename(.pif)\n&quot;, stdout);
    fputs(&quot;where -v = verbose\n&quot;, stdout);
    fputs(&quot;where -l = list linked records\n&quot;, stdout);
    fputs(&quot;where -n = print comment records\n&quot;, stdout);
    fputs(&quot;where -2 = print 286 records\n&quot;, stdout);
    fputs(&quot;where -3 = print 386 records\n&quot;, stdout);
    fputs(&quot;where -c = print comment records\n&quot;, stdout);
    exit(1);
}

#include &lt;ctype.h&gt;
void argcheck(int argc, char **argv)
{
    register char *p;
    register int c, i;
    int gotpattern;

    if (argc &lt;= 1)
        fputs(&quot;No arguments\n&quot;, stdout);
    if (argc == 2 &amp;&amp; argv[1][0] == '?' &amp;&amp; argv[1][1] == 0) {
        help();
        return;
    }
    nfile = argc-1;
    gotpattern = 0;
    for (i=1; i &lt; argc; ++i) {
        p = argv[i];
        if (*p == '-') {
            ++p;
            while (c = *p++) {
                switch(tolower(c)) {

                case '?': help();   break;
                case 'l': ++lflag;  break;
                case '2': ++flag2;  break;
                case '3': ++flag3;  break;
                case 'c': ++cflag;  break;
                case 'n': ++nflag;  break;

                case 'v': ++vflag;  ++lflag;    ++flag2;
                          ++flag3;  ++cflag;    ++nflag;  break;

                default:
                    fputs(&quot;Unknown flag\n&quot;, stdout);
                }
            }
            argv[i] = 0;
            --nfile;
        }
        else if (!gotpattern) {
            ifilename = p;
            argv[i] = 0;
            ++gotpattern;
            --nfile;
        }
    }
}



</pre><HR><P>Copyright &copy; 1993, <I>Dr. Dobb's Journal</I></P></BODY></HTML>
