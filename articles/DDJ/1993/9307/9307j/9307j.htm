<HTML>
<META NAME="year" CONTENT="1993">
<HEAD>
<TITLE>JUL93: C PROGRAMMING</TITLE></HEAD>
<BODY BGCOLOR="#ffffff">

<H1>C PROGRAMMING<a name="020c_0003"></A></H1>

<H2><a name="020c_0001"></A><a name="020c_0000"></A>C++ Templates and Filling
in some Historical Gaps</H2>

<H3>Al Stevens</H3>

<a name="020c_0002"></A><a name="020c_0000"></A>This month's column looks
at C++ templates. The template implements what Stroustrup calls "parameterized
types" in a paper in the <I>Winter 1989 Journal of the USENIX Association</I>.
His proposal for the addition of class templates and function templates
was ultimately implemented and released in the AT&amp;T 3.0 C++ system,
adopted by the ANSI C++ technical committee, and is now available in several
commercial compilers.

<P>&nbsp;Let's consider what templates do and where they are useful. A
class template is a generic class that takes on meaning when it is compiled
to support objects of some other concrete class.

<P>&nbsp;Consider data types that are maintained in collections of objects.
An application has many different classes and potentially many different
ways to organize them. Depending on how the application manages the objects,
it might use a number of different container organizations, such as trees,
queues, lists, and stacks. Each container type exists only to manage objects.
You could have a stack of pointers, a queue of integers, a balanced tree
of employee objects, a linked list of window handles, and so on. What is
more, you could have a stack of date objects, a queue of date objects,
and a tree of date objects, each container supporting different storage
and retrieval requirements, but all of them containing objects of the same
type. Each data type has its behavior, and each container type has its
behavior, and the behaviors of the two are unrelated. If I want to organize
my objects of type <I>SolidCube</I> into a stack in one part of the program
and into a list in another, that decision has nothing to do with the behavior
of the <I>SolidCube</I> class. Making that distinction is essential to
understanding templates.

<P>&nbsp;The template is a mechanism with which you define a class that
you instantiate only in conjunction with another type. Given a class template
for type <I>LinkedList&lt;T></I>, for example, you may declare an object
of that type only by associating it with another type, the type that the
linked list manages. The <I>LinkedList&lt;T></I> class template is the
"parameterized" type. The other type, represented by the <I>&lt;T></I>,
is the parameter. (There can be more than one.) Therefore, if you instantiate
the <I>LinkedList</I> class with, for example, the <I>Date</I> class, you
have declared an object that is a linked list of <I>Date</I> objects, or,
more precisely, of type <I>LinkedList&lt;Date></I>.

<P>&nbsp;Before looking at templates, let's consider ways to implement
such things with traditional C++. I'll discuss three alternatives for managing
objects in a linked list without using templates and give examples of two
of them. Then I'll build a class template to perform the same operation.

<P>&nbsp;
<H3>
<a name="020c_0004"></A>The Linked List<a name="020c_0004"></A></H3>
First, a brief explanation of the linked-list data structure. A list is
a collection of like objects, not necessarily in an array. They could be
on the heap, on the stack, declared as global or static variables, or any
combination of these. A linked list associates the objects with one another
in an incidental sequence unrelated to any particular collating sequence.
The first object points to the second object, which points to the third
object, and so on. If the list is bidirectional, the third object also
points to the second, which points to the first. So, each object in the
list has one or two pointers: a pointer to the next object and a pointer
to the previous object. To navigate the list, the program uses a <I>listhead</I>,
which contains a pointer to the first object in the list, and, if the list
is bidirectional, a pointer to the last object. If the list is bidirectional,
you can insert objects into, and delete objects from, the middle of the
list.

<P>&nbsp;There are two ways to look at such a container. The container
class can either be a repository that makes a copy of the object and puts
it in the container, or it can "containerize" the user's copy of the object.

<P>&nbsp;
<H3><a name="020c_0005"></A>First Alternative: Do It Yourself<a name="020c_0005"></A></H3>
A C++ programmer has at least three options without templates. The simplest
solution adds the next and previous pointers to the classes that need linked-list
management and builds a <I>listhead</I> that points specifically to objects
of that class. There are disadvantages to this approach. First, you have
to modify the class to add the behavior of a linked list, which is unrelated
to its original purpose. You would probably do that with inheritance. Now,
besides having your concrete <I>SolidCube</I> class, you have something
like a <I>LinkedListSolidCube</I> class, which is one more class than you
need, and not a particularly good application of inheritance. The other
disadvantage is that you have to write linked-list code for every such
derived class instead of having it be generic behavior. Duplicating that
code in multiple classes creates maintenance problems.

<P>&nbsp;
<H3>
<a name="020c_0006"></A>Second Alternative: An Embedded <I>LinkedList</I>
Class<a name="020c_0006"></A></H3>
Rather than duplicate the code for every class, you could build a generic
<I>LinkedList</I> class and embed an object of it in the target class.
This approach shares one disadvantage with the first alternative in that
it requires modifications to the class. It does, however, eliminate the
duplication of the linked-list code.

<P>&nbsp;<a href="#020c_000a">Listing
One</A>, page 138, is emblist.h, the header file that defines the <I>LinkedList</I>
class to embed in a target class. Two classes are defined: the <I>LinkedList</I>
class, which is the <I>listhead</I>; and the <I>ListEntry</I> class, which
encapsulates the linked list behavior. That behavior includes the <I>nextentry</I>
and <I>preventry</I> pointers to other <I>ListEntry</I> objects.

<P>&nbsp;<I>ListEntry</I> also includes the <I>listhead</I> pointer to
an object of type <I>LinkedList</I> to associate the object with a particular
list.

<P>&nbsp;Since a <I>ListEntry</I> object is embedded in the target object,
and since an embedded object cannot determine its owner's address, the
<I>ListEntry</I> class includes a void pointer named <I>thisentry</I>,
which points to the outer object. It must be void because the generic class
does not know about the type that it supports. That's where the "parameterized"
part of templates is going to help.

<P>&nbsp;The <I>ListHead</I> class contains pointers to the first and last
objects in the list. These point to embedded <I>ListEntry</I> objects.
The address of the listed object is dereferenced through the <I>thisentry</I>
pointer mentioned earlier.

<P>&nbsp;<a href="#020c_000c">Listing
Two</A>, page 138, is emblist.cpp, which contains member functions for
the <I>LinkedList</I> and <I>ListEntry</I> classes. It includes the constructors
and destructors and <I>ListEntry</I> member functions to append and remove
objects from the list. Observe that the <I>ListEntry</I> constructor's
parameter is a void pointer to the object of the outer class. This pointer
initializes the <I>ListEntry</I>'s <I>thisentry</I> pointer. This technique
is aesthetically displeasing. It offends me to know that an object stores
its own address, even in a data member of an embedded object. Furthermore,
it compromises the type safety of the linked list. The compiler can't prevent
me from passing any address as an argument to that parameter.

<P>&nbsp;The <I>ListEntry::AppendEntry</I> function appends the outer object
to the linked list by modifying the pointers in the <I>LinkedList</I> object
and by setting its own <I>nextentry </I>and <I>preventry </I>pointers.
The <I>ListEntry::RemoveEntry</I> function does the opposite, removing
the object from the list, patching any hole opened by its departure, and
repairing the <I>LinkedList</I> object's <I>firstentry</I> and <I>lastentry</I>
pointers if the departing object is the first or last object in the list.

<P>&nbsp;The destructor for the <I>ListEntry</I> class calls its own <I>ListEntry::RemoveEntry</I>
function, and the destructor for the <I>LinkedList</I> class calls the
<I>ListEntry::</I>

<P><I>RemoveEntry</I> function for every object in the list. That is because
this implementation of a linked list does not make copies of the objects.
It adds linked list behavior to the user's copies. When an object goes
out of scope, its destructor is called. The linked list has to expel the
object to preserve the list's integrity. If the <I>LinkedList</I> object
goes out of scope while objects are still in the list, the objects will
seem to be in a list that no longer exists.

<P>&nbsp;<a href="#020c_000e">Listing
Three</A>, page 139, is testemb.cpp, the program that uses the <I>LinkedList</I>
and <I>ListEntry</I> classes. It defines a <I>Date</I> class in a linked
list. The class has the usual day, month, and year data members, and it
overloads the &lt;&lt; insertion operator to display itself. There are
two additions to the class to support the linked list. First is the <I>ListEntry
le</I> data member. Second is the call to the <I>ListEntry</I> constructor
from the constructor for the <I>Date</I> object. This call initializes
the <I>thisentry</I> pointer with the <I>Date</I> object's <I>this </I>pointer,
which is where type safety breaks down. You could pass any address, including
a NULL address, and the compiler wouldn't complain.

<P>&nbsp;The program declares a <I>LinkedList</I> object and then gets
dates from the user and appends them to the linked list by calling the
<I>ListEntry le</I> object's <I>AppendEntry</I> function.

<P>&nbsp;After the last date entry, the program iterates through the list
and displays the dates on the console. The calls to <I>ListEntry::FirstEntry</I>
and <I>ListEntry::NextEntry</I> return void pointers, so they are cast
to <I>Date</I> pointers.

<P>&nbsp;I didn't bother deleting all of the dates from the heap in these
examples, and a more complete program would do that. Also, a more complete
<I>ListEntry</I> class would include member functions to retrieve the last
and previous entries as well as to insert entries into specified places
in the list.

<P>&nbsp;
<H3>
<a name="020c_0007"></A>Third Alternative: Inherit the Linked-list Behavior<a name="020c_0007"></A></H3>
We can eliminate some of our objections to the <I>LinkedList</I> and <I>ListEntry</I>
classes. Instead of embedding the <I>ListEntry</I> object, the <I>Date</I>
object is derived from the base <I>ListEntry</I> class, inheriting the
linked-list behavior. This approach improves the code's notation, and it
improves type safety by eliminating void pointers, but it introduces a
new objection. Inheritance is typically used to model the <I>is a </I>relationship
between classes. By deriving <I>Date</I> from <I>ListEntry</I>, we are
saying that a date <I>is a </I>list entry. Well, yes it is, but only in
the programmer's view. It is only incidental to the way the program manages
objects that a date <I>is a </I>list entry, and the model does not reflect
common-sense object-oriented design. Nonetheless, this approach is our
final alternative to templates.

<P>&nbsp;<a href="#020c_0010">Listing
Four</A> (page 139), inhlist.h, and <a href="#020c_0012">Listing
Five</A> (page 139), inhlist.cpp, modify the <I>LinkedList</I> class to
be a base class. The <I>thisentry</I> void pointer is gone, and the other
void pointers and void pointer functions are now pointers to type <I>ListEntry</I>.
Since the target object is derived from, rather than host to, the <I>ListEntry</I>
class, the <I>this</I> pointer serves as the address of the object.

<P>&nbsp;<a href="#020c_0014">Listing
Six</A>, page 139, is testinh.cpp, the test program modified to use the
base class. The only concession that the <I>Date</I> class makes to being
in a linked list is that it is derived from the <I>ListEntry</I> class.
<I>AppendEntry</I> is not called through an embedded object but directly
through the <I>Date</I> object itself. The calls to <I>ListEntry::FirstEntry</I>
and <I>ListEntry::NextEntry</I> still need casts, however. They return
pointers to the base <I>ListEntry</I> class which must be cast to pointers
to the <I>Date</I> class.

<P>&nbsp;
<H3>
<a name="020c_0008"></A>A <I>LinkedList</I> Class Template<a name="020c_0008"></A></H3>
We can eliminate all of our objections to the approaches just discussed
by using templates. Realize first, however, that when you declare an object
of a template class, the compiler builds source code that associates the
template with its parameter class. If you use the same template for a different
type, you get another copy of the source code, customized for the other
type. If the algorithm is big and your program needs many versions of it,
the template solution, while easier to code, might produce a bigger executable
program than you want.

<P>&nbsp;<a href="#020c_0016">Listing
Seven</A>, page 139, is linklist.h, the <I>LinkedList</I> class template.
The header file contains the class definition and the member-function templates.
The compiler uses these member-function templates to build source code
when your program declares an object of a class-template type. The template
is a form of macro, and all of its code must be visible wherever you declare
a parameterized type. This version of the linked list contains everything.
It includes functions to append, insert, remove, and find objects on the
list. This implementation makes copies of the objects that go into the
list, which means that your program can let the objects go out of scope
after you put them in the list, but also means that your classes must have
valid copy constructors.

<P>&nbsp;Only the <I>LinkedList&lt;T></I> class can declare objects of
the <I>ListEntry&lt;T></I> class because <I>ListEntry&lt;T></I> has no
public members and the <I>LinkedList&lt;T></I> class is a friend. The list-navigation
member functions are in the <I>LinkedList&lt;T></I> class instead of the
<I>ListEntry&lt;T></I> class. The user declares an object of the <I>LinkedList&lt;T></I>
class template with a parameter and adds to, deletes from, and navigates
that list through the <I>LinkedList&lt;T></I> object.

<P>&nbsp;<a href="#020c_0018">Listing
Eight</A>, page 140, is testtmpl.cpp, a program that tests the <I>LinkedList&lt;T></I>
class template. Its <I>Date</I> class is unaware that its objects are in
a linked list. This is the strength of the class template. You don't have
to monkey with the target class to get it into a container, and you don't
have to give up type checking.

<P>&nbsp;The program declares an object of type <I>LinkedList&lt;Date></I>,
then gets dates from the user and puts them into the list. The program
does not retain copies of the objects. This is another strength of the
class template: It knows its own size and can instantiate objects of itself.
A base class cannot do that and include the derived class's members in
the instantiated object. An embedded class cannot do that and include the
outer class. Templates solve that problem. In this example, the <I>ListEntry&lt;T></I>
class includes a copy of the parameterized type. The <I>LinkedList&lt;T>::AppendEntry</I>
and <I>LinkedList&lt;T>::InsertEntry</I> functions build an object of type
<I>ListEntry&lt;T></I> on the heap, initializing it with the object being
added to the list.

<P>&nbsp;
<H3>
<a name="020c_0009"></A>An Unabridged History of MSC/C++<a name="020c_0009"></A></H3>
There are two books out about Bill Gates and Microsoft. I reviewed one
of them, <I>Hard Drive</I>, by James Wallace and Jim Erickson (John Wiley,
1992) in the May 1993 "Programmer's Bookshelf." The other is <I>Gates</I>,
by Stephen Manes and Paul Andrews<I> </I>(Doubleday, 1993). They both tell
much the same story, although <I>Gates</I> is a better book with more information.

<P>&nbsp;I was disappointed that neither book gave any attention to Microsoft
C and C++ compilers. Maybe those products are more important from my perspective
than they are from that of the typical book consumer. Maybe the authors
don't understand these languages or the significance of their history with
respect to Microsoft's position in the languages market. <I>Hard Drive</I>
says that Cobol is "difficult to master," which shows what they know, and
does not mention C. I doubt that the authors, both newspaper reporters
and not programmers, could relate the importance of C to the story they
were telling. Manes and Andrews are seasoned journalists in the computer
world, and they should know better, but their mention of C and C++ is only
coincidental to other points that they make.

<P>&nbsp;So, to fill the void, here is the unauthorized history of Microsoft
C and C++, drawn from my own flawed memory, recalled without the benefit
of any research whatsoever, and rife with opinion.

<P>&nbsp;The first Microsoft C was Lattice C in a Microsoft binder. Lattice
C was an early and successful C compiler for the IBM PC. I remember it
from about 1983. Apparently Microsoft licensed the software to get into
the C marketplace before their compiler was ready. Neither book mentions
Lattice. Unlike the two books, I cannot offer any insight into the deals
that were made and broken, the careers that were crushed, or how Bill's
dandruff swirled around his head in an ephemeral cloud when he ran around
the room and yelled during negotiations.

<P>&nbsp;About 1984, Microsoft dropped Lattice C and came out with the
first of their own C compilers, which they dubbed "Version 3.0." It was
a typical K&amp;R compiler, and it worked well. Its successor, Version
4.0, was notable mainly for Codeview, a source-level debugger. I had been
using other compilers, debugging with the venerable <I>printf</I> function,
and became an immediate convert to Microsoft C. Codeview made the difference.

<P>&nbsp;In spring of 1987, Borland stirred up the market with Turbo C
1.0. It had no debugger, but it was faster than Microsoft C by several
factors, and it had a new feature called the integrated development environment
(IDE), which integrates the editor, compiler, and linker into one program.
Turbo C was hot stuff, and Microsoft announced QuickC in the fall of the
same year, finally delivering in the winter. QuickC was not ready for prime
time. It wasn't all that quick, its IDE supported only the medium memory
model, and the compiler generated huge executables. However, QuickC included
an integrated Codeview-style debugger, online help, and a graphics library,
features that Turbo C lacked. QuickC had more bugs than Bill Clinton has
encouraging words, but a lot of people bought it.

<P>&nbsp;Borland and Microsoft chased one another over the years with upgrade
after upgrade, each one playing catch-up and then upstaging the other with
new, unheard of features. Support for Windows programming became a big
deal. Naturally, Microsoft had their pricy SDK, and for a while it was
the only game in town. Then someone realized that the complete API is resident
in a DLL in every Windows installation. All you need is a way to call DLL
functions, a header file full of prototypes and message mnemonics, and
documentation. When Microsoft Press started selling the SDK documentation
in a three-volume set out of retail bookstores, every C compiler in the
business offered support for Windows programming almost overnight. Some
of them even bought the Microsoft books in volume and packaged them with
their compilers. Talk about competing with yourself.

<P>&nbsp;Then Borland got the jump with a C++ compiler fully a year ahead
of Microsoft. Since they had C++ and Microsoft didn't, Borland and Philippe
Kahn hit the conference circuit, carrying the good news to the natives,
promoting object-oriented design as the only true way to do anything, while
Gates and Microsoft grumbled about OOPS and dismissed it as just another
trendy fad.

<P>&nbsp;Microsoft C 5.1 was a rugged, reliable package. Version 6.0 was
buggy and had sparse documentation. Programmers howled. Version 7.0 corrected
those deficiencies and added--what else?--C++ to the package. Now it was
technologically correct to be an OOPS programmer. The fad of yesteryear
finally found validation at the Redmond altar and became a sanctified paradigm.
Next came the Microsoft Foundation Classes (MFC), a C++ class library that
encapsulates some of the Windows API. That product was a reaction to Borland's
ObjectLibrary for Windows (OWL), which does the same thing. Not to be left
at the gate, Borland added templates to their C++ compiler. Microsoft C++
does not have templates yet, although when packaged with Visual C++, the
compiler's version number got a boost to 8.0. It reminds me of movie sequels.

<P>&nbsp;Adding features and bumping version numbers is how a software
developer tries to keep market share. Those features add size and sink
resources, too. I used to run the Borland and Microsoft command-line C
compilers on an 8088 laptop with a 720-Kbyte diskette drive. Now you need
60 Mbytes of disk, several Mbytes of RAM, and a DPMI driver. I believe
in free enterprise and oppose monopolies, but I wonder how beneficial all
of this competition is. I guess without it we'd still be stuck in the '70s.

<P>&nbsp;Well, this historical account is surely full of holes and probably
has some inaccuracies, but we seem to be the only biographers who care,
so it's all we're going to get. I bought Manes and Andrews' <I>Gates</I>
book in an airport bookstore and found, to my surprise, that it was a first
edition, autographed by the authors. There was no sign advertising it as
such, and I wondered if it was excess stock from some promotional campaign.
Doesn't matter, but if either of those guys goes nuts and assassinates
somebody important like J.D. Hildebrand or John Dvorak, I'll have a valuable
collectible on my bookshelf. Anybody want to buy an option?

<P>&nbsp;<a name="020c_000a"></A><a name="020c_000b"></A><B>[LISTING ONE]</B>
<PRE><a name="020c_000b"></A>
// ------------ emblist.h
// a linked list class embedded in the listed class

#ifndef EMBLIST_H
#define EMBLIST_H

class LinkedList;

// --- the linked list entry
class ListEntry&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp; void *thisentry;
&nbsp;&nbsp;&nbsp; ListEntry *nextentry;
&nbsp;&nbsp;&nbsp; ListEntry *preventry;
&nbsp;&nbsp;&nbsp; LinkedList *listhead;
&nbsp;&nbsp;&nbsp; friend class LinkedList;
public:
&nbsp;&nbsp;&nbsp; ListEntry(void *entry, LinkedList *lh = 0);
&nbsp;&nbsp;&nbsp; ~ListEntry() { RemoveEntry(); }
&nbsp;&nbsp;&nbsp; void AppendEntry(LinkedList *lh = 0);
&nbsp;&nbsp;&nbsp; void RemoveEntry();
&nbsp;&nbsp;&nbsp; void *NextEntry()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { return nextentry ? nextentry->thisentry : 0; }
&nbsp;&nbsp;&nbsp; void *PrevEntry()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { return preventry ? preventry->thisentry : 0; }
};
// ---- the linked list
class LinkedList&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp; // --- the listhead
&nbsp;&nbsp;&nbsp; ListEntry *firstentry;
&nbsp;&nbsp;&nbsp; ListEntry *lastentry;
&nbsp;&nbsp;&nbsp; friend class ListEntry;
public:
&nbsp;&nbsp;&nbsp; LinkedList();
&nbsp;&nbsp;&nbsp; ~LinkedList();
&nbsp;&nbsp;&nbsp; void *FirstEntry() { return firstentry->thisentry; }
&nbsp;&nbsp;&nbsp; void *LastEntry()&nbsp; { return lastentry->thisentry; }
};
#endif
</PRE>

<H4>
<a name="020c_000c"></A><a name="020c_000d"></A><B>[LISTING TWO]</B></H4>

<PRE>

// ------------ emblist.cpp
// linked list class

#include "emblist.h"

// ---- construct a linked list
LinkedList::LinkedList()
{
&nbsp;&nbsp;&nbsp; firstentry = 0;
&nbsp;&nbsp;&nbsp; lastentry = 0;
}
// ---- destroy a linked list
LinkedList::~LinkedList()
{
&nbsp;&nbsp;&nbsp; while (firstentry)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; firstentry->RemoveEntry();
}
// ---- construct a linked list entry
ListEntry::ListEntry(void *entry, LinkedList *lh)
{
&nbsp;&nbsp;&nbsp; thisentry = entry;
&nbsp;&nbsp;&nbsp; listhead = lh;
&nbsp;&nbsp;&nbsp; nextentry = 0;
&nbsp;&nbsp;&nbsp; preventry = 0;
}
// ---- append an entry to the linked list
void ListEntry::AppendEntry(LinkedList *lh)
{
&nbsp;&nbsp;&nbsp; if (lh)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; listhead = lh;
&nbsp;&nbsp;&nbsp; if (listhead != 0)&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; preventry = listhead->lastentry;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (listhead->lastentry)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; listhead->lastentry->nextentry = this;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (listhead->firstentry == 0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; listhead->firstentry = this;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; listhead->lastentry = this;
&nbsp;&nbsp;&nbsp; }
}
// ---- remove an entry from the linked list
void ListEntry::RemoveEntry()
{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ---- repair any break made by this removal
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (nextentry)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nextentry->preventry = preventry;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (preventry)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; preventry->nextentry = nextentry;
&nbsp;&nbsp;&nbsp; if (listhead)&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // --- maintain listhead if this is last and/or first
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (this == listhead->lastentry)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; listhead->lastentry = preventry;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (this == listhead->firstentry)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; listhead->firstentry = nextentry;
&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; preventry = 0;
&nbsp;&nbsp;&nbsp; nextentry = 0;
}</PRE>

<H4>
<a name="020c_000e"></A><a name="020c_000f"></A><B>[LISTING THREE]</B></H4>

<PRE>

// -------- testemp.cpp

#include &lt;iostream.h>
#include "emblist.h"

class Date {
&nbsp;&nbsp;&nbsp; int mo, da, yr;
public:
&nbsp;&nbsp;&nbsp; ListEntry le;
&nbsp;&nbsp;&nbsp; Date(int m=0, int d=0, int y=0) : le(this)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { mo = m; da = d; yr = y; }
&nbsp;&nbsp;&nbsp; friend ostream&amp; operator &lt;&lt; (ostream&amp; os, Date&amp; dt)
&nbsp;&nbsp;&nbsp; { os &lt;&lt; dt.da &lt;&lt; &aelig;/' &lt;&lt; dt.mo &lt;&lt; &aelig;/' &lt;&lt; dt.yr; return os; }
};
void main()
{
&nbsp;&nbsp;&nbsp; LinkedList dtlist;
&nbsp;&nbsp;&nbsp; int d = 0, m, y;
&nbsp;&nbsp;&nbsp; Date *dt;
&nbsp;&nbsp;&nbsp; while (d != 99)&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; "Enter dd mm yy (99 .. .. when done): ";
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; flush;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cin >> d >> m >> y;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (d != 99)&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dt = new Date(m,d,y);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dt->le.AppendEntry(&amp;dtlist);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; dt = (Date *) dtlist.FirstEntry();
&nbsp;&nbsp;&nbsp; while (dt != 0)&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; &aelig;\n' &lt;&lt; *dt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dt = (Date *) dt->le.NextEntry();
&nbsp;&nbsp;&nbsp; }
}</PRE>

<H4>
<a name="020c_0010"></A><a name="020c_0011"></A><B>[LISTING FOUR]</B></H4>

<PRE>

// ------------ inhlist.h
// a linked list base class
#ifndef INHLIST_H
#define INHLIST_H

class LinkedList;

// --- the linked list entry
class ListEntry&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp; ListEntry *nextentry;
&nbsp;&nbsp;&nbsp; ListEntry *preventry;
&nbsp;&nbsp;&nbsp; LinkedList *listhead;
&nbsp;&nbsp;&nbsp; friend class LinkedList;
protected:
&nbsp;&nbsp;&nbsp; ListEntry(LinkedList *lh = 0);
&nbsp;&nbsp;&nbsp; virtual ~ListEntry() { RemoveEntry(); }
public:
&nbsp;&nbsp;&nbsp; void AppendEntry(LinkedList *lh = 0);
&nbsp;&nbsp;&nbsp; void RemoveEntry();
&nbsp;&nbsp;&nbsp; ListEntry *NextEntry() { return nextentry; }
&nbsp;&nbsp;&nbsp; ListEntry *PrevEntry() { return preventry; }
};
// ---- the linked list
class LinkedList&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp; // --- the listhead
&nbsp;&nbsp;&nbsp; ListEntry *firstentry;
&nbsp;&nbsp;&nbsp; ListEntry *lastentry;
&nbsp;&nbsp;&nbsp; friend class ListEntry;
public:
&nbsp;&nbsp;&nbsp; LinkedList();
&nbsp;&nbsp;&nbsp; ~LinkedList();
&nbsp;&nbsp;&nbsp; ListEntry *FirstEntry() { return firstentry; }
&nbsp;&nbsp;&nbsp; ListEntry *LastEntry()&nbsp; { return lastentry; }
};

#endif</PRE>

<H4>
<a name="020c_0012"></A><a name="020c_0013"></A><B>[LISTING FIVE]</B></H4>

<PRE>

// ------------ inhlist.cpp
// linked list base class
#include "inhlist.h"

// ---- construct a linked list
LinkedList::LinkedList()
{
&nbsp;&nbsp;&nbsp; firstentry = 0;
&nbsp;&nbsp;&nbsp; lastentry = 0;
}
// ---- destroy a linked list
LinkedList::~LinkedList()
{
&nbsp;&nbsp;&nbsp; while (firstentry)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; firstentry->RemoveEntry();
}
// ---- construct a linked list entry
ListEntry::ListEntry(LinkedList *lh)
{
&nbsp;&nbsp;&nbsp; listhead = lh;
&nbsp;&nbsp;&nbsp; nextentry = 0;
&nbsp;&nbsp;&nbsp; preventry = 0;
}
// ---- append an entry to the linked list
void ListEntry::AppendEntry(LinkedList *lh)
{
&nbsp;&nbsp;&nbsp; if (lh)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; listhead = lh;
&nbsp;&nbsp;&nbsp; if (listhead != 0)&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; preventry = listhead->lastentry;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (listhead->lastentry)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; listhead->lastentry->nextentry = this;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (listhead->firstentry == 0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; listhead->firstentry = this;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; listhead->lastentry = this;
&nbsp;&nbsp;&nbsp; }
}
// ---- remove an entry from the linked list
void ListEntry::RemoveEntry()
{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ---- repair any break made by this removal
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (nextentry)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nextentry->preventry = preventry;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (preventry)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; preventry->nextentry = nextentry;
&nbsp;&nbsp;&nbsp; if (listhead)&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // --- maintain listhead if this is last and/or first
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (this == listhead->lastentry)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; listhead->lastentry = preventry;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (this == listhead->firstentry)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; listhead->firstentry = nextentry;
&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; preventry = 0;
&nbsp;&nbsp;&nbsp; nextentry = 0;
}
</PRE>

<H4>
<a name="020c_0014"></A><a name="020c_0015"></A><B>[LISTING SIX]</B></H4>

<PRE>

// -------- testinh.cpp
#include &lt;iostream.h>
#include "inhlist.h"

class Date : public ListEntry {
&nbsp;&nbsp;&nbsp; int mo, da, yr;
public:
&nbsp;&nbsp;&nbsp; Date(int m=0, int d=0, int y=0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { mo = m; da = d; yr = y; }
&nbsp;&nbsp;&nbsp; friend ostream&amp; operator &lt;&lt; (ostream&amp; os, Date&amp; dt)
&nbsp;&nbsp;&nbsp; { os &lt;&lt; dt.da &lt;&lt; &aelig;/' &lt;&lt; dt.mo &lt;&lt; &aelig;/' &lt;&lt; dt.yr; return os; }
};
void main()
{
&nbsp;&nbsp;&nbsp; LinkedList dtlist;
&nbsp;&nbsp;&nbsp; int d = 0, m, y;
&nbsp;&nbsp;&nbsp; Date *dt;
&nbsp;&nbsp;&nbsp; while (d != 99)&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; "Enter dd mm yy (99 .. .. when done): ";
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; flush;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cin >> d >> m >> y;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (d != 99)&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dt = new Date(m,d,y);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dt->AppendEntry(&amp;dtlist);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; dt = (Date *) dtlist.FirstEntry();
&nbsp;&nbsp;&nbsp; while (dt != 0)&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; &aelig;\n' &lt;&lt; *dt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dt = (Date *) dt->NextEntry();
&nbsp;&nbsp;&nbsp; }
}
</PRE>

<H4>
<a name="020c_0016"></A><a name="020c_0017"></A><B>[LISTING SEVEN]</B></H4>

<PRE>

// ------------ linklist.h
// a template for a linked list

#ifndef LINKLIST_H
#define LINKLIST_H
template &lt;class T>
// --- the linked list entry
class ListEntry&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp; T thisentry;
&nbsp;&nbsp;&nbsp; ListEntry&lt;T> *nextentry;
&nbsp;&nbsp;&nbsp; ListEntry&lt;T> *preventry;
&nbsp;&nbsp;&nbsp; ListEntry(T&amp; entry);
&nbsp;&nbsp;&nbsp; friend class LinkedList&lt;T>;
};
template &lt;class T>
// ---- construct a linked list entry
ListEntry&lt;T>::ListEntry(T &amp;entry)
{
&nbsp;&nbsp;&nbsp; thisentry = entry;
&nbsp;&nbsp;&nbsp; nextentry = 0;
&nbsp;&nbsp;&nbsp; preventry = 0;
}
template &lt;class T>
// ---- the linked list
class LinkedList&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp; // --- the listhead
&nbsp;&nbsp;&nbsp; ListEntry&lt;T> *firstentry;
&nbsp;&nbsp;&nbsp; ListEntry&lt;T> *lastentry;
&nbsp;&nbsp;&nbsp; ListEntry&lt;T> *iterator;
&nbsp;&nbsp;&nbsp; void RemoveEntry(ListEntry&lt;T> *lentry);
&nbsp;&nbsp;&nbsp; void InsertEntry(T&amp; entry, ListEntry&lt;T> *lentry);
public:
&nbsp;&nbsp;&nbsp; LinkedList();
&nbsp;&nbsp;&nbsp; ~LinkedList();
&nbsp;&nbsp;&nbsp; void AppendEntry(T&amp; entry);
&nbsp;&nbsp;&nbsp; void RemoveEntry(int pos = -1);
&nbsp;&nbsp;&nbsp; void InsertEntry(T&amp;entry, int pos = -1);
&nbsp;&nbsp;&nbsp; T *FindEntry(int pos);
&nbsp;&nbsp;&nbsp; T *CurrentEntry();
&nbsp;&nbsp;&nbsp; T *FirstEntry();
&nbsp;&nbsp;&nbsp; T *LastEntry();
&nbsp;&nbsp;&nbsp; T *NextEntry();
&nbsp;&nbsp;&nbsp; T *PrevEntry();
};
template &lt;class T>
// ---- construct a linked list
LinkedList&lt;T>::LinkedList()
{
&nbsp;&nbsp;&nbsp; iterator = 0;
&nbsp;&nbsp;&nbsp; firstentry = 0;
&nbsp;&nbsp;&nbsp; lastentry = 0;
}
template &lt;class T>
// ---- destroy a linked list
LinkedList&lt;T>::~LinkedList()
{
&nbsp;&nbsp;&nbsp; while (firstentry)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RemoveEntry(firstentry);
}
template &lt;class T>
// ---- append an entry to the linked list
void LinkedList&lt;T>::AppendEntry(T&amp; entry)
{
&nbsp;&nbsp;&nbsp; ListEntry&lt;T> *newentry = new ListEntry&lt;T>(entry);
&nbsp;&nbsp;&nbsp; newentry->preventry = lastentry;
&nbsp;&nbsp;&nbsp; if (lastentry)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lastentry->nextentry = newentry;
&nbsp;&nbsp;&nbsp; if (firstentry == 0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; firstentry = newentry;
&nbsp;&nbsp;&nbsp; lastentry = newentry;
}
template &lt;class T>
// ---- remove an entry from the linked list
void LinkedList&lt;T>::RemoveEntry(ListEntry&lt;T> *lentry)
{
&nbsp;&nbsp;&nbsp; if (lentry == 0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;
&nbsp;&nbsp;&nbsp; if (lentry == iterator)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iterator = lentry->preventry;
&nbsp;&nbsp;&nbsp; // ---- repair any break made by this removal
&nbsp;&nbsp;&nbsp; if (lentry->nextentry)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lentry->nextentry->preventry = lentry->preventry;
&nbsp;&nbsp;&nbsp; if (lentry->preventry)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lentry->preventry->nextentry = lentry->nextentry;
&nbsp;&nbsp;&nbsp; // --- maintain listhead if this is last and/or first
&nbsp;&nbsp;&nbsp; if (lentry == lastentry)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lastentry = lentry->preventry;
&nbsp;&nbsp;&nbsp; if (lentry == firstentry)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; firstentry = lentry->nextentry;
&nbsp;&nbsp;&nbsp; delete lentry;
}
template &lt;class T>
// ---- insert an entry into the linked list
void LinkedList&lt;T>::InsertEntry(T&amp; entry, ListEntry&lt;T> *lentry)
{
&nbsp;&nbsp;&nbsp; ListEntry&lt;T> *newentry = new ListEntry&lt;T>(entry);
&nbsp;&nbsp;&nbsp; newentry->nextentry = lentry;
&nbsp;&nbsp;&nbsp; if (lentry)&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; newentry->preventry = lentry->preventry;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lentry->preventry = newentry;
&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; if (newentry->preventry)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; newentry->preventry->nextentry = newentry;
&nbsp;&nbsp;&nbsp; if (lentry == firstentry)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; firstentry = newentry;
}
template &lt;class T>
// ---- remove an entry from the linked list
void LinkedList&lt;T>::RemoveEntry(int pos)
{
&nbsp;&nbsp;&nbsp; FindEntry(pos);
&nbsp;&nbsp;&nbsp; RemoveEntry(iterator);
}
template &lt;class T>
// ---- insert an entry into the linked list
void LinkedList&lt;T>::InsertEntry(T&amp; entry, int pos)
{
&nbsp;&nbsp;&nbsp; FindEntry(pos);
&nbsp;&nbsp;&nbsp; InsertEntry(entry, iterator);
}
template &lt;class T>
// ---- return the current linked list entry
T *LinkedList&lt;T>::CurrentEntry()
{
&nbsp;&nbsp;&nbsp; return iterator ? &amp;(iterator->thisentry) : 0;
}
template &lt;class T>
// ---- return a specific linked list entry
T *LinkedList&lt;T>::FindEntry(int pos)
{
&nbsp;&nbsp;&nbsp; if (pos != -1)&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iterator = firstentry;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (iterator)&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (pos--)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iterator = iterator->nextentry;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; return CurrentEntry();
}
template &lt;class T>
// ---- return the first entry in the linked list
T *LinkedList&lt;T>::FirstEntry()
{
&nbsp;&nbsp;&nbsp; iterator = firstentry;
&nbsp;&nbsp;&nbsp; return CurrentEntry();
}
template &lt;class T>
// ---- return the last entry in the linked list
T *LinkedList&lt;T>::LastEntry()
{
&nbsp;&nbsp;&nbsp; iterator = lastentry;
&nbsp;&nbsp;&nbsp; return CurrentEntry();
}
template &lt;class T>
// ---- return the next entry in the linked list
T *LinkedList&lt;T>::NextEntry()
{
&nbsp;&nbsp;&nbsp; if (iterator == 0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iterator = firstentry;
&nbsp;&nbsp;&nbsp; else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iterator = iterator->nextentry;
&nbsp;&nbsp;&nbsp; return CurrentEntry();
}
template &lt;class T>
// ---- return the previous entry in the linked list
T *LinkedList&lt;T>::PrevEntry()
{
&nbsp;&nbsp;&nbsp; if (iterator == 0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iterator = lastentry;
&nbsp;&nbsp;&nbsp; else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; iterator = iterator->preventry;
&nbsp;&nbsp;&nbsp; return CurrentEntry();
}
#endif</PRE>

<H4>
<a name="020c_0018"></A><a name="020c_0019"></A><B>[LISTING EIGHT]</B></H4>

<PRE>

// -------- testtmpl.cpp
#include &lt;iostream.h>
#include "linklist.h"

class Date {
&nbsp;&nbsp;&nbsp; int mo, da, yr;
public:
&nbsp;&nbsp;&nbsp; Date(int m=0, int d=0, int y=0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { mo = m; da = d; yr = y; }
&nbsp;&nbsp;&nbsp; friend ostream&amp; operator &lt;&lt; (ostream&amp; os, Date&amp; dt)
&nbsp;&nbsp;&nbsp; { os &lt;&lt; dt.da &lt;&lt; &aelig;/' &lt;&lt; dt.mo &lt;&lt; &aelig;/' &lt;&lt; dt.yr; return os; }
};
void main()
{
&nbsp;&nbsp;&nbsp; LinkedList&lt;Date> dtlist;
&nbsp;&nbsp;&nbsp; int d = 0, m, y;
&nbsp;&nbsp;&nbsp; while (d != 99)&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; "Enter dd mm yy (99 .. .. when done): ";
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; flush;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cin >> d >> m >> y;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (d != 99)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dtlist.AppendEntry(Date(m,d,y));
&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; Date *dt = dtlist.FirstEntry();
&nbsp;&nbsp;&nbsp; while (dt != 0)&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; &aelig;\n' &lt;&lt; *dt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dt = dtlist.NextEntry();
&nbsp;&nbsp;&nbsp; }
}
End Listings</PRE>

<HR><P>Copyright &copy; 1993, <I>Dr. Dobb's Journal</I></P></BODY>
</HTML>
