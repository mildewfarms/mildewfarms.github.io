<HTML>
<META NAME="year" CONTENT="1993">
<HEAD>
<TITLE>JUL93: LETTERS</TITLE></HEAD>
<BODY BGCOLOR="#ffffff">
<h1>LETTERS<a name="01b6_0001"></h1><P>
<h3><a name="01b6_0002">Sometimes the Best Defense  Isn't a Good Offense<a name="01b6_0002"></h3><P>
Dear <I>DDJ</I>,<P>
Defensive programming is something many of us have consciously or unconsciously adopted over the years, usually from bitter experience of the kinds of things that can happen without it. Simple things like using possibly redundant parentheses to ensure that you get the precedence you want from a sequence of C operators, for example, or automatically using separate source files as a means of data hiding unless there are overwhelming reasons not to.<P>
OOP was originally touted as eliminating or greatly reducing the need for such strategies, and after a couple of years' C++, use I would agree that this is generally true. However, beware! The new languages and techniques can themselves call for new defensive ploys.<P>
For instance, take the increasingly common style being used for C++ class declarations. Everywhere I look--in textbooks, compiler manuals, help files, source code for professional class libraries, and, yes, even <I>DDJ</I> listings--I see code along the lines of <a href="#01b6_0007">Example 1</A>. This is perfectly legal C++ and will give you exactly the data protection you expect--as long as you get the code right. But sooner or later, Murphy's law will assert itself and that &quot;private&quot; statement will get left out. The code will still be legal; it will compile okay and your test programs will very likely run perfectly. The data protection is gone, however. Worse, if your formal documentation is done by someone else on the team or by some smart new documentation software, the ultimate users of your brilliant class library will be under the impression that it's perfectly okay to tinker with the very class members you wanted to hide from them. This is a surefire recipe for Interesting Times.<P>
The defensive programming strategy against Murphy and his law is simple--always put the &quot;private&quot; section first. If you leave out the &quot;private&quot; statement, the section members will stay private by default. And if Murphy trashes your &quot;public&quot; statement, you will find out all about it the minute you try to compile code testing the class &quot;public&quot; interface.<P>
Robert Sproat<P>
London, England<P>
<h3><a name="01b6_0003">LUC Redux<a name="01b6_0003"></h3><P>
Dear <I>DDJ</I>,<P>
My May 1993 letter to <I>DDJ </I>regarding Peter Smith's article, &quot;LUC Public-key Encryption&quot; (January 1993) had an important misprint (perhaps because of a poor fax transmission). The correct value for <I>r</I> should read: r=lcm(p<SUB>1</SUB><SUP>e<SUB>1</SUB>-1</SUP>(p<SUB>1</SUB><SUP>2</SUP>-1),...p<SUB>1</SUB><SUP>e-1</SUP>(p<SUB>1</SUB><SUP>2</SUP>-1)).
<P>
Willi More<P>
Klagenfurt, Austria<P>
<h3><a name="01b6_0004">mapdev()<B><I>for Fortran</I></B><a name="01b6_0004"></h3><P>
Dear <I>DDJ</I>,<P>
Ken Hamilton forgot one Fortran compiler in his article, &quot;Direct Memory Access from PC Fortrans&quot; (<I>DDJ</I>, May 1993)--Microway's NDP Fortran. Not only was NDP Fortran the first 32-bit Fortran for protected-mode DOS, but it was also the first to employ a concept called &quot;map device,&quot; which allows Fortran programmers to map physical or virtual memory and/or devices into their Fortran applications through the seamless interface. These mappings include video, BIOS, dongles, disk drives, the Weitek coprocessor, and so on, all of which can be driven by NDP Fortran.<P>
I've included a program that demonstrates the expressive power behind Microway's <I>mapdev()</I> function. See <a href="#01b6_0008">Example 2</A> for details. This program accomplishes what the other protected-mode Fortrans mentioned in Ken's article cannot.<P>
Mark J. Barrenechea<P>
Microway<P>
Kingston, Massachusetts<P>
<h4>Fortran Fan</h4><P>
Dear <I>DDJ</I>,<P>
I wanted to say how pleased I was to see an article employing the Fortran language in the May issue of <I>Dr. Dobb's Journal</I>. I very much enjoyed Kenneth Hamilton's article on &quot;Direct Memory Access from PC Fortrans&quot; and will be able to put the material to immediate use. Please consider giving greater prominence in the future to numerical scientific applications and the Fortran language in which they are commonly programmed.<P>
Michael L. Berbaum<P>
Research Social Scientist<P>
Tuscaloosa, Alabama<P>
DDJ<I> responds: Glad you enjoyed the Fortran coverage, Michael. Watch for our September 1993 issue which will examine numerics and numerical programming.</I><P>
<h3><a name="01b6_0005">C-like Assembler for DSP--Not!<a name="01b6_0005"></h3><P>
Dear <I>DDJ</I>,<P>
I recently learned that I will be writing code for an AT&amp;T DSP32C, so I was especially interested in Mac Cody's article, &quot;A Wavelet Analyzer&quot; (<I>DDJ</I>, April 1993), in which the implementation is based on that processor. This was the first programmer-oriented information I had found about any of AT&amp;T's DSPs since starting an informal search involving the Internet and trips to several technical bookstores. Are there any logical reasons for this surprising lack of publicly available information?<P>
When I looked at Mac's assembly-language source code and subsequently read that one of the reasons that he chose AT&amp;T's DSP32 and DSP32C was because of their &quot;C-like assembly languages,&quot; I almost screamed. I strongly feel that this is a great liability rather than a bonus. I've done a great deal of assembly-language programming (mainly in the field of real-time computer graphics), and there's a vastly different mindset needed to write &quot;good&quot; assembly language than that required to write &quot;good&quot; C. The different look of most assembly languages helps you get into that mindset. I greatly prefer the look-and-feel of Motorola 680x0 syntax (my favorite assembly language) to that of AT&amp;T DSP32 and DSP32C.<P>
I also feel that &quot;normal&quot; assembly language is much more straightforward than this &quot;C-like&quot; assembly language. Ask youself, for example, which instruction in <a href="#01b6_0009">Example 3</A> is easier to understand and deal with: the slightly modified Motorola 5600xMAC (Signed Multiply-Accumulate) or the example from the DECOMP routine?<P>
Both instructions do the same thing, but with the former you need to remember more rules about the construction of such expressions. The latter just requires you to chose the correct instruction for the risk. Using the same symbol for more than one thing can also add more chances for errors to occur (for example, + for addition vs. ++ for postincrement and * for multiply vs. * for indirect referencing).<P>
Occasionally, I accidentally do something like leave off an operand. The assembler tells me right away what's wrong and I feel a bit stupid while I fix it. With C-like syntax, an instruction with a missing operand could very easily turn out to be a valid different instruction. Bugs like that are much harder to find_. As an added bonus, the latter takes less time to type.<P>
Maybe my intense dislike for the AT&amp;T DSP32 and DSP32C assembly languages is rooted in the fact that I believe in highly optimized (speed and size) code, even on fast processors, and am the type of person who says things like, &quot;Gee, that's an interesting instruction_. Now how can I use it to my advantage?&quot;<P>
Jesse Michael<P>
Portland, Oregon<P>
<h3><a name="01b6_0006">So How Was Your Date?<a name="01b6_0006"></h3><P>
Dear <I>DDJ</I>,<P>
I greatly enjoyed Peter Meyer's &quot;Julian and Gregorian Calendars&quot; article (<I>DDJ</I>, May 1993). With many systems still relying on date formats that have only two digits for the year, there will be much more interest in date routines as the year 2000 approaches.<P>
His brief mention of Easter in the article brought to mind a ten-step algorithm that, according to one source I've seen, is over 100 years old. This routine is said to incorporate the paschal full- moon determinations and seems to work for &quot;modern&quot; years; see <a href="#01b6_000a">Table 1</A>, where Easter is the <I>n</I>th month and the <I>(P+1)</I>st day.<P>
Karl Hoppe<P>
Orange, California<P>
More Genetic Algorithms<P>
Dear <I>DDJ</I>,<P>
I was very excited to see the topic of your February '93 issue, &quot;Cognitive Computing.&quot; I enjoyed all four articles. Despite this, I was disappointed to see that your list of software included so little of the available genetic-algorithm software. My company produces a C++ package for the Macintosh and Windows called MicroGA. There are also a number of public-domain packages available. The easiest way to locate these is probably through the Internet discussion group of GAs. If you wish to join this group, send your name and e-mail address to <I>GA-List-Request@<P>AIC.NRL.NAVY.MIL</I>. I hope the staff at <I>DDJ</I> keeps up the good work, and keeps covering leading-edge technologies such as these.<P>
Stephen D. Wilson<P>
Emergent Behavior<P>
Palo Alto, California<P>
<h4><a name="01b6_0007"><B>Example 1<a name="01b6_0007"></B></h4><P>
<pre>
class SomeClass();
public:
int this;
char that;
void TheOther();
 ...
private
 long vulnerable;
 float risky;
 int Disastrous();
</pre><P>
<h4><a name="01b6_0008"><B>Example 2<a name="01b6_0008"></B></h4><P>
<pre>c  This program uses mapdev to map the video buffer into
c  data space and poke values into which  will be displayed.

c  grex.fh contains declarations for GREX (GRaphic EXtensions)
c  function get_bios_mode. os.fh contains declarations for mapdev,
c  peekb, and peekw
    include 'grex.fh'
    include 'os.fh'

  integer screen,addr,count
  integer bios_mode,lines,cols

  addr = z'b8000'
  if (get_bios_mode()eq 7 addr = z'b0000'

  screen = mapdev (addr,8192)
    write(*,*) 'scren pointer = ',screen
c   Get size of video page
  lines = 1 + peekb (z'484')
  cols = peekw (z'44A')
    call pauseb
c   write values to video buffer, to be displayed on screen
  call try_it (% VAL(screen),2*cols,lines)
  call pauseb
end
  subroutine try_it (a,m,n)
  integer m,n
  character a(m,n)
  do j = 1,n
k = ()
do i=1,m,2#
   k = k+1
   a(i,j) = char(k)
   a(i+1,j) = char(j)
enddo
enddo
  return
  end

</pre><P>
<h4><a name="01b6_0009"><B>Example 3<a name="01b6_0009"></B></h4><P>
<pre>
aO = aO + *r3++ **r1++;   /* AT&amp;T DSP32 and DSP32C syntax */

mac (r3)+,(r1)+,aO        ; Modified Motorola 6500x syntax


</pre><P>
<h4><a name="01b6_000a">Table 1<a name="01b6_000a"></h4><P>
<pre>
===========================================================================
   Step                          Result                   Values for 1993
                           Quotient  Remainder
===========================================================================
   Year/19                    --        A                   --       17
   Year/100                    B        C                   19       93
   B/4                         D        E                    4        3
   (B+8)/25                    F       --                    1
   (B-F+1)/3                   G       --                    6
   (19A+B-D-G+15)/30          --        H                   --       17
   C/4                        --        K                   23        1
   (2E-H+2I-K+32)/7           --        L                   --        3
   (A+11H+22L)/451             M       --                    0
   (H+L-7M+114)/31             N        P                    4       10
===========================================================================
</pre><P>

<HR><P>Copyright &copy; 1993, <I>Dr. Dobb's Journal</I></P></BODY></HTML>
