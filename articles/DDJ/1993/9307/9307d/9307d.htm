<HTML>
<META NAME="year" CONTENT="1993">
<HEAD>
<TITLE>JUL93: Image Processing Using Quadtrees</TITLE></HEAD>
<BODY BGCOLOR="#ffffff">
<h1>Image Processing Using Quadtrees<a name="01d1_0003"></h1><P>
<h2><a name="01d1_0001"><a name="01d1_0000">An efficient method for the compression and manipulation of raster images</h2><P>
<h3>Raj Kumar Dash</h3><P>
<p><i><a name="01d1_0002"><a name="01d1_0000">Raj is studying in the masters of computer science program at the University of Guelph in Ontario. He is a main designer for a new GIS package, and is the assistant editor for id Magazine. You can contact him at raj@snowhite.cis.uoguelph.ca.</i></p><hr><P>
There are a variety of methods for processing raster images, including the use of numeric quadcodes to represent a data structure known as the &quot;quadtree.&quot; While fractal compression and its cousins provide greater space savings, quadtrees (a term I'll use in the general sense) provide reasonable savings and retain an image's hierarchical information without loss of detail. This means you can perform image-processing operations on a quadtree and transfer the results of those operations when converting the quadtree back into a raster image. These characteristics are particularly useful when you're processing several images too large for storage in main memory. Still, there is one limitation: Quadtrees require that source images have a size of 2<SUP>n</SUP>x2<SUP>n</SUP> pixels (where <I>n</I>=0,1,2,_). This limitation isn't serious, and I'll present a workaround.<P>
Additionally, large sparse matrices can be compressed using quadtrees since they are effectively the same as a bitmap. Take, for example, a square, sparse matrix that represents the node connections of a large computer network. If the network has many nodes, and if the connections tend to cluster mainly in local groups, then a quadtree is an ideal structure for storing compressed link information for the network. A link between two computers is indicated by a black node. The lack of such a link is indicated by a white node.<P>
<h3><a name="01d1_0004">Quadtrees<a name="01d1_0004"></h3><P>
A quadtree can be represented as either a tree data structure or a linked list. To produce a quadtree, you recursively split an image of 2<SUP>n</SUP>x2<SUP>n</SUP> pixels into quadrants and subquadrants until all the pixels in a subquadrant are of the same color, or the subquadrant is 1-pixelx1-pixel. (If the size condition of 2<SUP>n</SUP>x2<SUP>n</SUP> doesn't hold, you can't partition the image into successive quadrants and subquadrants.)<P>
<a href="199301d3.htm">Figure 1</A> shows how to derive a quadtree from an image, illustrating that quadcoding is particularly useful for compressing images containing large, homogeneous blocks of color. In <a href="199301d4.htm">Figure 1</A>(a), the image has both single black and larger black quadrants. <a href="199301d5.htm">Figure 1</A>(b) is the same, but the thickness of the grid lines indicate the level of the corresponding quadrant. In <a href="199301d6.htm">Figure 1</A>(c), NW, NE, SW, and SE represent the northwest, northeast, southwest, and southeast quadrants, respectively. Each black circle represents either a single black pixel or a subquadrant of black pixels (and likewise for the white circles). A white square indicates that its component subquadrants are not all the same color. (Li and Loew use the term, &quot;elementary squares&quot; to describe any subimage of the size 2<SUP>m</SUP>x2<SUP>m</SUP>, where the full image is 2<SUP>n</SUP>x2<SUP>n</SUP> and <I>n</I><img src="gteq12.gif" alt="&gt;="><I>m</I><img src="gteq12.gif" alt="&gt;=">0. I'll use the term, &quot;quadrant&quot; to mean the same thing, but where <I>m</I><img src="gteq12.gif" alt="&gt;=">1.) Images that have a large number of individual pixels (<I>m</I>=0) take more space in quadtree format than an image of equal size with large quadrants; see <a href="199301d7.htm">Figure 2</A>. This is because of the increased number of quad partitions. Apart from this limitation, quadtrees produce compression ratios of 20--90 percent, depending on the contents of an image. The image in <a href="199301d8.htm">Figure 2</A> has no homogeneous subquadrant larger than 1x1 and takes more space to store as a quadtree than the image in <a href="199301d9.htm">Figure 1</A>(a). Both images have four levels of nodes in their quadtrees; however, all quadrants of the quadtree of the image in <a href="199301da.htm">Figure 2</A> will<P>
be a single pixel. Contrast this with <a href="199301db.htm">Figure 1</A>(c), where some quadrants are of size 2x2 pixels. The quadtree of the image in <a href="199301dc.htm">Figure 2</A> will be full, with a total of <img src="sum12.gif" alt="sigma">4<SUP>i</SUP>=4<SUP>0</SUP>+4<SUP>1</SUP>+4<SUP>2</SUP>+4<SUP>3</SUP>=85 nodes.<P>
<h3><a name="01d1_0005">Quadtrees for Monochrome Images<a name="01d1_0005"></h3><P>
Monochrome images encoded as quadtrees offer the best space savings. Since there are only two &quot;colors,&quot; you need only store information for one color explicitly and can imply information for the second. Suppose the images you're processing have large quadrants of color 0 (say, white). To save the most space, store information for only color 1 (say, black). <a href="199301dd.htm">Figure 3</A>, for instance, shows the quadtree for <a href="199301de.htm">Figure 1</A>(a), the same quadtree as in <a href="199301df.htm">Figure 1</A>(c), with the white circles (subquadrants) removed. Instead of allocating space in the quadtree for missing nodes, set their parent pointers to NULL. Notice there are 11 leaf nodes in this tree, compared to the 28 leaves in <a href="199301e0.htm">Figure 1</A>(c), a savings of more than 60 percent.<P>
<h3><a name="01d1_0006">Pointerless Quadtrees for <P>Monochrome Images<a name="01d1_0006"></h3><P>
A &quot;quadcode&quot; is a mathematical notation (for monochrome images) that eliminates quadtree pointers. The savings can be enormous; at least 66 percent over that of regular quadtrees, according to Gargantini.<P>
You can represent an entire quadtree with a sequence of numeric strings (quadcodes) by designating a subquadrant at any level by a quadcode from 0 to 3, preceded by the quadcode for its parent quadrant. (NW=0, NE=1, SW=2, and SE=3; thus, the SW child quadrant of NW has a quadcode of 02.) <a href="199301e1.htm">Figure 4</A> generates pointerless quadtrees using quadcodes. Each quadrant is assigned a numeric code from 0 to 3, preceded by its parent quadrant's code. If the image is 2<SUP>n</SUP>x2<SUP>n</SUP>, the longest possible quadcode is <I>n</I> digits long, and it represents a quadrant of one pixel. (Parent codes are shorter than their child codes.)<P>
<h3><a name="01d1_0007">Multicolor and Gray-scale Images<a name="01d1_0007"></h3><P>
Color and gray-scale images can be represented by either quadtrees or pointerless quadtrees (quadcodes), but quadtrees for color images require more space than monochrome images of the same size. Still, their quadtrees give favorable space savings, provided there are large quadrants of color. As with monochrome images, multicolor or gray-scale quadtrees imply information for one color--say, white. In <a href="199301e2.htm">Figure 5</A>, you can eliminate all the white circle nodes to save even more space.<P>
To create pointerless quadtrees for multicolor and gray-scale images, store a pair of values for each region of the image. The first value is the quadcode, the second, the color of the quadrant. For example, the image in <a href="199301e3.htm">Figure 5</A> is quadcoded as listed in <a href="#01d1_000f">Table 1</A>. Note that you don't code color 0 (white) regions. For images with <img src="lteq12.gif" alt="&lt;=">256 colors, represent each color by one of the ASCII characters from 0-255.<P>
<h3><a name="01d1_0008">Quadtrees for Rectangular Images<a name="01d1_0008"></h3><P>
Up to now, I've discussed only square images, although most computer screens have a rectangular bitmap (768x1024, 480x640, and so on). The easiest way to produce a quadtree for rectangular images is to use the smallest square grid that fully contains the image. For example, assume you have an image that's 480x640 pixels. The smallest square grid that fully contains this image is 1024x1024. Why? If you use <I>n</I>=9, you have a grid of size 512x512. That's enough to accommodate the 480-pixel dimension, but not the 640-pixel dimension. The only choice, then, is <I>n</I>=10, or a grid of 1024x1024. Treat the excess pixels as &quot;don't-care&quot; colors, chosen to minimize the number of subquadrants needed to partition the image. <a href="199301e4.htm">Figure 6</A> shows a quadtree for a 7x6 pixel image. The 7x6 image in <a href="199301e5.htm">Figure 6</A>(a) needs to be contained in an 8x8 grid before we can create its quadtree. Notice in the augmented image in <a href="199301e6.htm">Figure 6</A>(b) that the new row has pixels of both colors, whereas the two new columns have white pixels. This particular ordering ensures a minimal quadtree.<P>
<h3><a name="01d1_0009">General Quadtree Operations<a name="01d1_0009"></h3><P>
One advantage of quadtrees is that image manipulation becomes faster since operations apply to whole regions of pixels simultaneously. This is a necessity if you can't read an entire image into memory. Another advantage is that all operations performed on a quadtree transfer back to the image during conversion.<P>
It's no problem if you have an augmented rectangular image and alter some of the excess pixels. Why? Because you ignore excess pixels when converting the quadtree back into a raster image, so it does not matter what operations you perform on &quot;don't-care&quot; pixels.<P>
One quadtree operation is to contrast or change pixel colors. Suppose you have a gray-scale image that has large blocks of very light-gray pixels that you want to change to provide more contrast. By changing the color of the subquadrants containing the target pixels, you also change the component pixels. (This becomes obvious after the quadtree is converted back to its associated image.) See <a href="199301e7.htm">Figure 7</A>.<P>
Masking is an operation that &quot;cuts&quot; shapes in an image. Say you have a square monochrome image and you want to stamp it with the word &quot;hi.&quot; Create the &quot;mask&quot; image first, then apply the mask by XORing it with the test image; refer to <a href="199301e8.htm">Figure 8</A>.<P>
<h3><a name="01d1_000a">Spatial Operations<a name="01d1_000a"></h3><P>
A number of quadtree operations deal with the spatial attributes of an image, including those that determine the color of a particular pixel and calculate the area covered by a given color.<P>
<B>Attributes of a Given Pixel.</B> Given either the quadcode or the row/column position of a pixel, you can easily determine its color. (Note that row/column values range from 0 to 2<SUP>n</SUP>-1.) You first convert the row/column pair to the equivalent quadcode by converting both the row and column values into equivalent binary (base 2) strings. You then pad the strings on the left with 0s so that each string is <I>n </I>digits long. Then, for each pair of bits from left to right, use <a href="#01d1_0010">Table 2</A> to determine the equivalent quadcode digit.<P>
Now search the quadtree for either the calculated quadcode or an ancestor's code. If you can't find either, the pixel must be white (since this is the color left out of the quadtree). For example, suppose you use the pixel at <I>row</I>=2, <I>column</I>=2 (both of origin=0), as in <a href="199301e9.htm">Figure 5</A>(a). Both the <I>row</I> and <I>column</I> values convert to the binary string 010. Since the first pair of bits consists of 0 and 0, the corresponding <I>qcode</I> digit is 0. The next <I>qcode</I> digit is 3, followed by 0: <I>qcode</I>=030. You now search the list of quadcodes for 030 or an ancestor code, such as 03 or 0. Since the parent quadrant (<I>qcode</I>=03, <I>color</I>=1) is present in the quadtree, the pixel's color is 2.<P>
<B>Area of a Given Color.</B> The area covered by a particular color, c, is the sum of the areas of its component quadrants: A(color c)=<img src="sum12.gif" alt="sigma"><SUB>i</SUB>A(q<SUB>i</SUB>) for all leaf quadrants q<SUB>i</SUB> of color c.<P>
A single quadrant that has a quadcode of length <I>m</I> has an area equal to 2<SUP>n-m</SUP>x2<SUP>n-m</SUP>, n<img src="gteq12.gif" alt="&gt;=">m<img src="gteq12.gif" alt="&gt;=">0. For example, the quadcode 03 in <a href="199301ea.htm">Figure 5</A>(a) has color 1. The area is 2<SUP>3-2</SUP>x2<SUP>3-2</SUP>=2x2=4. (To determine the total area of color 1, search the quadtree for all leaf nodes having color 1, calculate each area as above, and then sum the individual areas.)<P>
<h3><a name="01d1_000b">Manipulation of Two or More Quadtrees<a name="01d1_000b"></h3><P>
Quadtrees can be used to manipulate several images simultaneously. In particular, you can perform image overlays and intersections on quadtrees when the associated images do not fit into memory. For example, take two images of size 1024x1024 pixels that have 512 nodes apiece in their respective quadtree structures. An image overlay then takes 512 operations instead of 1,048,576 (1024x1024).<P>
<B>Image Overlays.</B> Monochrome-image overlay operations include AND, OR, and XOR; see <a href="199301eb.htm">Figure 9</A>.<P>
<B>Image Intersection.</B> For monochrome images, you perform image intersections with the AND operator. For color and gray-scale images, the method is somewhat different, although the principle is the same. In this case, you test two corresponding pixels for equality of color, instead of True (color white) and False (color black) values. (Choose the color of the first image's pixel if the two pixels are not the same.)<P>
<h3><a name="01d1_000c">Implementating Quadtrees<a name="01d1_000c"></h3><P>
On a UNIX system, you can read into memory the entire bitmap of fairly large images, something you can't always do under MS-DOS. (Some of the newer C compilers allow for large data blocks, but we'll assume that such a compiler is not available.)<P>
You need to devise a method that will produce a quadtree while processing only two rows of an image at a time. (You read two rows at a time to produce both 1x1-pixel and 2x2-pixel quadrants simultaneously.) Space constraints don't allow me to go into detail about the code implementation. However, C source and sample input files that implement quadtrees are available electronically; see &quot;Availability,&quot; page 5. Note that the C code assumes that an input image file is in the form of a 2<SUP>n</SUP>x2<SUP>n</SUP> matrix of integers--one matrix row per file record. Each quadtree is implemented as a quadtree data structure. Each node consists of a triplet, (quadcode, color, childcount) and has four pointers to children nodes.<P>
I tested the code with Microsoft QuickC 2.0. With a few small modifications, the code should work with other C compilers. Since much of the code is recursive, remember to increase stack size before compiling. The code is presented as a library of functions, along with a sample main program. (I'm also developing a more comprehensive set of analysis tools that should be implemented later in the year. Please contact me by e-mail for information.)<P>
<h3><a name="01d1_000d">Summary<a name="01d1_000d"></h3><P>
Quadtrees are particularly useful for spatial analysis in desktop mapping, geographical information systems, pattern recognition, and CAD applications. If you're interested in learning more about them, I highly recommend Hanan Samet's detailed paper, &quot;The Quadtree and Related Hierarchical Data Structures.&quot; Articles by Gargantini and Li and Loew give good accounts of pointerless quadtrees and quadcode operations. Manohar et al. describe a variation called &quot;template quadtrees&quot;&quot; that theoretically reduces storage even further.<P>
<h3><a name="01d1_000e">References<a name="01d1_000e"></h3><P>
Gargantini, Irene. &quot;An Effective Way to Represent Quadtrees. Graphics and Image Processing.&quot; Edited by James Foley. <I>Communications of the ACM</I> (December, 1982).<P>
Li, Shu-Xiang and Murray H. Loew. &quot;Adjacency Detection Using Quadcodes. Image Processing and Computer Vision.&quot; Edited by Robert Haralick. <I>Communications of the ACM</I> (July, 1987).<P>
Li, Shu-Xiang and Murray H. Loew. &quot;The Quadcode and its Arithmetic. Image Processing and Computer Vision.&quot; Edited by Robert Haralick. <I>Communications of the ACM</I> (July, 1987).<P>
Samet, Hanan. &quot;The Quadtree and Related Hierarchical Data Structures.&quot; <I>Computing Surveys</I> (June, 1984).<P>
<h4><B> <a href="199301ec.htm">Figure 1</A>:</B> (a) Sample image; (b) same image but with level of corresponding quadrant indicated; (c) the quadtree for (a).</h4><P>
<h4><B> <a href="199301ed.htm">Figure 2</A>:</B> Sample image which has no homogeneous subquadrant larger than 1x1.</h4><P>
<h4><B> <a href="199301ee.htm">Figure 3</A>:</B> Same quadtree as for Figure 1(c) but with the white circles (subquadrants) removed, resulting in savings greater than 60 percent.</h4><P>
<h4><B> <a href="199301ef.htm">Figure 4</A>:</B> Generating pointerless quadtrees using quadcodes.</h4><P>
<h4><B> <a href="199301f0.htm">Figure 5</A>:</B> (a) Multicolor image; (b) multicolor quadtree.</h4><P>
<h4><a name="01d1_000f"><B>Table 1: </B>The image in Figure 5 is quadcoded like this.<a name="01d1_000f"></h4><P>
<pre><B>NW:</B>     (003,1), (012,1), (013,1), (021,1), (023,1), (03,1)
<B>NE:</B>     (103,2), (112,2), (113,2), (121,1), (123,2), (13,2)
<B>SW:</B>     (202,2), (203,2), (22,2), (23,1)
<B>SE:</B>     (3,3)</pre><P>
<h4><B> <a href="199301f1.htm">Figure 6</A>:</B> (a) Sample 7x6 image that needs to be contained in an 8x8 grid before we can create its quadtree; (b) augmented image.</h4><P>
<h4><B> <a href="199301f2.htm">Figure 7</A>:</B> Contrasting: Change all colors &lt; 4 to color 1 and the colors &gt; 3 to color 7. The result is a high-contrast image.</h4><P>
<h4><B> <a href="199301f3.htm">Figure 8</A>:</B> Filtering: (a) image; (b) mask; (c) masked (XORed result).</h4><P>
<h4><a name="01d1_0010"><B>Table 2:</B> Determining equivalent quadcode digits.<a name="01d1_0010"></h4><P>
<pre>
<B>     Row      Column      qcode digit</B>
<B>     bit     bit     (base 4)</B>
<B>digit</B>     0     0     0
     0     1     1
     1     0     2
     1     1     3
</pre><P>
<h4><B> <a href="199301f4.htm">Figure 9</A>:</B> (a) Image A; (b) image B; (c) C=A AND B; (d) C=A OR B; (e) C=A XOR B.</h4><P>

<HR><P>Copyright &copy; 1993, <I>Dr. Dobb's Journal</I></P></BODY></HTML>
