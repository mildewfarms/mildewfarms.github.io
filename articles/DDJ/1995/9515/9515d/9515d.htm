<HTML>
<META NAME="year" CONTENT="1995">

<HEAD>
<TITLE>SP95: A C++ Framework for DCE Threads</TITLE></HEAD>
<BODY BGCOLOR="#ffffff">
<h1>A C++ Framework for DCE Threads<a name="027d_00c6"><a name="027d_00c4"><a name="027d_0000"></h1><P>
<h2>Multitasking with pthreads</h2><P>
<h3>Michael Yam</h3><P>
<p><i><a name="027d_00c5"><a name="027d_0000">Michael is the founder of Y Technology Inc., a consulting company that serves New York's financial district. He can be reached on CompuServe at 76367,3040.</i></p><hr><P>
If you've done any serious programming under UNIX, you probably appreciate its multitasking capabilities and may want to add such capabilities to your application. Using threads to multitask pieces of your program, you can divide and conquer a problem, while improving a program's throughput. Threads are often used to build servers that handle multiple clients; their real-time nature also makes them effective for simulations and real-time data delivery. <P>
The OSF Distributed Computing Environment (DCE) supports a powerful, multithreaded programming facility through a set of API calls sometimes called &quot;pthreads.&quot; In a recent project, I created a C++ framework under HP-UX to cope with multithreaded programming using the DCE facilities. My pthread framework (PTF) consists of five classes and one template; see <a href="#027d_00ce">Table 1</A>. PTF makes no effort to encapsulate the entire DCE pthread API. For example, PTF creates only threads of equal priorities with round-robin scheduling. However, the framework can be extended to accommodate varied priorities and different schedules. (For more information on OSF DCE, see &quot;Distributed Computing and the OSF/DCE,&quot; by John Bloomer, <I>DDJ</I>, February 1995.)<P>
<h3><a name="027d_00c7">pthreads Explained<a name="027d_00c7"></h3><P>
DCE threads is a facility that supports multithreaded programming. On HP-UX, it is a set of nonkernel libraries to which you link your programs. The API consists of some 50-plus calls. It is based on a POSIX standard, which is why DCE threads are sometimes referred to as &quot;pthreads.&quot;<P>
Much as UNIX can multitask several processes, threads allow a program to multitask pieces of itself. Unlike processes, however, threads share the same address space and can communicate with one another without complex interprocess communications. Because threads are intraprocess, they can &quot;see&quot; the other's static variables while maintaining private automatic variables of their own. This is possible because every thread gets its own stack.<P>
Threads allow your program to divide and conquer a problem. For example, one thread can calculate the area under a curve between 0 and 1 while another thread does the same between 0 and -1. When the two threads complete their respective calculations, they join up and total their results for the area under the curve between -1 and +1. While nonthreaded algorithms exist to solve for an area under a curve, a threaded solution can transparently take advantage of a platform with multiple CPUs.<P>
Threads can be used to improve a program's throughput. At one client site, we've designed a multithreaded server to support up to 100 users concurrently. One thread manages connections and dynamically creates threads to service users, thus providing one thread per user. Helper threads within the server monitor connections, message statistics, and the general health of the server. A nonthreaded solution could not handle the same number of users as cleanly; see the accompanying text box entitled &quot;Unraveling DCE pthreads&quot; for details.<P>
<h3><a name="027d_00c8">Constructing Threads<a name="027d_00c8"></h3><P>
To create a thread under DCE, you call <I>pthread_create()</I>, which accepts a pointer to a function as one of its arguments. This function becomes the entry point of your thread. To create a thread using PTF, on the other hand, you must derive from the abstract base class, <I>PTObject</I>; instead of using a pointer to a function, you supply code for the virtual function <I>runPThread()</I>. This has three advantages. First, a thread as an object can store related data such as the thread ID, the thread handle, mutexes, condition variables, and any data that might be shared with other threads. Secondly, pointers to functions in C are natural candidates for virtual functions in C++. Third, deriving from <I>PTObject</I> gives you the <I>start()</I>, <I>tid()</I>, and <I>join()</I> member functions in addition to the constructor and destructor.<P>
The <I>start()</I> member function starts the thread object running. A thread can have four states: running, ready to run, waiting, and terminated. A running thread is one that is executing CPU instructions. Don't assume that a newly created thread starts in the running state; that will depend on the thread priority and scheduling policy, as well as CPU availability. Ideally, the constructor should start the thread, but if a CPU were available during thread creation, the thread could start running even before the constructor had completed! To prevent this, the thread object must be instantiated first, then followed with a call to <I>start()</I>. However, <I>start()</I> has its limitations. All it does is invoke DCE's <I>pthread_create()</I>. It cannot truly force a thread to start--that remains the responsibility of the scheduler. Still, <I>start()</I> gives the constructor a chance to complete its initializations and thus prevents the premature starting of a thread. Because <I>start()</I> invokes <I>pthread_create()</I>, you should not call <I>start()</I> more than once per <I>PTObject</I>.<P>
You might also be tempted to modify <I>start()</I> to accept arguments. As an example, for a thread to service a particular socket, it may seem desirable to pass the file descriptor into the <I>start()</I> member. However, it's better to avoid overloading <I>start()</I>. Instead, when you derive a class from <I>PTObject</I>, write your constructor to accept a file descriptor and store the value in your class (perhaps in the private section). The member function <I>tid()</I> returns the thread ID as a unique integer. I assign the ID during thread creation using the undocumented, nonportable DCE call, <I>pthread_getunique_np()</I>. If you're uncomfortable using nonportable calls, modify the class to generate and assign your own unique numbers. The idea behind <I>tid()</I> is to manage threads based on ID and to identify threads in debugging statements.<P>
The <I>join()</I> function, a wrapper for DCE's <I>pthread_join()</I>, allows the current thread to wait for the completion of another thread. In terms of DCE calls, <I>pthread_create()</I> and <I>pthread_join()</I> are opposites: <I>pthread_create()</I> splits single-threaded code for parallel processing, and <I>pthread_join()</I> serializes any parallel code. If the current thread calls <I>pthread_join()</I> on itself, the thread will deadlock. PTF's <I>join()</I>, however, checks for this condition. Instead of deadlocking, the thread will simply continue. <P>
Once a thread has completed running, it is in a terminated state. Normally, you would free resources by calling C++'s <I>delete </I>on your thread object. You can also have a thread self-destruct by coding a <I>delete </I>at the end of the <I>runPThread()</I> routine. Having a thread invoke its own destructor avoids storing and deleting the pointers to your thread objects. Finally, you can terminate running threads by just &quot;deleting&quot; the thread object. I don't recommend this, however, because your thread might be in a critical state. To interrupt your thread, set a flag in your thread object to mark it for termination. The thread itself can then poll this flag and self-destruct when it is not critical.<P>
<h3><a name="027d_00c9">Good Class Habits<a name="027d_00c9"></h3><P>
Good, safe, robust frameworks require other member functions in <I>PTObject</I> and all the PTF classes: a copy constructor, an assignment operator, <I>isValid()</I>, and <I>className()</I>. For simplicity and clarity, I have omitted the copy constructor and assignment operators from the framework, so the compiler supplies its own. This will probably work, assuming the class doesn't contain pointers. <I>PTObject</I> doesn't contain pointers today, but may in the future. Thus, to prevent a class user from accidentally copying or assigning a thread object, I've declared those members in the header file (see <a href="#027d_00d2">Listing One</A>), but haven't defined them in the .cpp file (<a href="#027d_00d4">Listing Two</A>). Should the class user try to copy or assign a thread object, an error would occur at link time.<P>
The <I>isValid()</I> function determines if the object was constructed properly. Recall that constructors do not return a value. Although <I>isValid()</I> usually acts like a <I>bool</I>, returning 1 or 0 for True or False, respectively, I've declared it to return an integer. I could have implemented a Boolean type, but there are endless variations that might clash with libraries from different vendors. Fortunately, a C++ <I>bool</I> type using &quot;true&quot; and &quot;false&quot; literals has been accepted by the ANSI/ISO committee. It's just a matter of time before compiler vendors implement the <I>bool</I> type, but until then, I prefer returning an integer. Checking for a bad constructor therefore involves ensuring that the object pointer is non-null and then invoking the <I>isValid()</I> member: 1 means the constructor completed successfully, and 0 indicates failure.<P>
Some favor exception handling for detecting construction problems, and in fact, exception handling is the preferred method in C++. However, I've used flags for simplicity, and because HP exception handling doesn't work properly with threads as of this writing. <I>className()</I> returns the class name like so: <I>const char *className() { return &quot;PTObject&quot; }</I>. A typical use for this function might be to display the class name in a title bar or a message log.<P>
<h3><a name="027d_00ca">Thread Synchronization<a name="027d_00ca"></h3><P>
Two classes, <I>PTMutex</I> and <I>PTCondVar</I>, manage thread synchronization. DCE mutexes come in three flavors: fast, recursive, and nonrecursive. A fast mutex is synchronous: A thread will wait indefinitely until it gets the lock. This is the most commonly used type of mutex. A recursive mutex allows a thread that has already locked a mutex to lock it again (it doesn't block itself). Since the mutex is recursive, it will take as many unlocks as there were locks to clear the mutex. A nonrecursive mutex, like a fast mutex, can only be locked once, but unlike a fast mutex, if the thread tries to lock it again, it will receive an error instead of waiting indefinitely.<P>
PTF provides the <I>PTMutex</I> class to encapsulate the DCE fast mutex. The constructor creates the mutex using DCE's <I>pthread_mutex_init()</I>, and the destructor deletes the mutex using <I>pthread_ mutex_destroy()</I>. Member functions <I>lock()</I>, <I>unlock()</I>, and <I>trylock()</I> wrap the DCE functions <I>pthread_lock()</I>, <I>pthread_ unlock()</I>, and <I>pthread_trylock()</I>, all returning the same respective error codes. Admittedly, <I>PTMutex</I> does not add much to DCE's mutex functionality, but it is important because it serves as a base class for <I>PTCondVar</I>. I've derived <I>PTCondVar</I> from <I>PTMutex</I> because a condition variable &quot;is a kind of&quot; mutex. Whereas a mutex synchronizes threads with data, a condition variable synchronizes threads with other threads. For a condition variable to be useful, it must also be paired with a mutex. A condition variable has Boolean properties and acts much like a traffic light, controlling whether the waiting thread(s) should go or continue to wait. The state of the condition variable is controlled by other threads with the help of the <I>PTCondVar</I> class members <I>signal()</I>, <I>broadcast()</I>, and <I>timedWait()</I>.<P>
The <I>signal()</I> function allows one thread to notify a waiting thread to continue. Threads that have a producer/consumer relationship often use this mechanism. In such a relationship, a producer thread would generate data while a consumer thread would process the data. When data is available, the producer thread would <I>signal()</I> the waiting thread, telling it that there is data to process. The <I>broadcast()</I> function is similar to <I>signal()</I>, except that <I>signal()</I> wakes the first waiting thread, and <I>broadcast()</I> wakes them all.<P>
A consumer thread waits for a signal or broadcast by calling the member <I>timedWait()</I>. A waiting thread will resume execution only when it receives a signal or broadcast, or when a specified number of seconds have elapsed, whichever comes first. I've written <I>timedWait()</I> to accept an integer representing the number of seconds to wait; passing in a zero will cause the thread to wait indefinitely for a signal or broadcast.<P>
<h3><a name="027d_00cb">Thread-Safe Objects<a name="027d_00cb"></h3><P>
<I>PTMutex</I> and <I>PTCondVar</I>, while handy, are still primitive. An entirely thread-safe class would be more convenient. For a class to be thread safe, operations on data must be atomic: Another thread must not be able to interrupt the current one during an update operation. A thread-safe object can be achieved with the classes <I>PTSafeObject</I> and <I>PTLock</I>. Derive your class from <I>PTSafeObject</I>. Then, for every member function that reads or writes data, instantiate <I>PTLock</I> on the stack, as in <a href="#027d_00cf">Figure 1</A>. Upon leaving the function, <I>PTLock</I> will automatically unlock and delete itself. If you design your application to access data through one class, this mechanism will ensure safe updates across multiple threads. Creating a mutex on the stack also prevents you from accidentally leaving the mutex in a locked state when returning early from a function (to handle an error).<P>
<I>PTSafeObject</I> and <I>PTLock</I> operate as a pair. Actually, <I>PTLock</I> is nested within <I>PTSafeObject</I> and is also a friend of <I>PTSafeObject</I>. When you derive from <I>PTSafeObject</I>, your class inherits a mutex that <I>PTLock</I> locks in its constructor and unlocks in its destructor. When you delete your object, the mutex also gets deleted. This allows only one mutex per <I>PTSafeObject</I>, thus precluding designs that dedicate a mutex for reading and another mutex for writing.<P>
A natural extension to <I>PTSafeObject</I> is to create a template version: PTTSafeType (the extra &quot;T&quot; denotes template); see Listings <a href="#027d_00d6">Three</A> and <a href="#027d_00d8">Four</A>. A template allows built-in types, such as an <I>int</I>, to be thread safe. I found this especially useful for managing sequence numbers, because several threads could simultaneously update the sequence number. The template provides thread-safe <I>get()</I> and <I>set()</I> functions and overloads the prefix and postfix increment and decrement operators, making them thread safe as well; see <a href="#027d_00d0">Figure 2</A>.<P>
<h3><a name="027d_00cc">Wrapping Up<a name="027d_00cc"></h3><P>
To test the thread framework, a sample program (available electronically; see &quot;Availability&quot; on page 3) creates a &quot;boss&quot; thread, which in turn creates ten &quot;worker&quot; threads. The pointers to the worker threads are stored in an array so that they can be deleted later. The worker threads wait on a condition variable for either a <I>broadcast()</I> from the boss thread or for 15 seconds to elapse, whichever comes first. To make the program a little more interesting, the boss thread issues a <I>signal()</I> rather than a <I>broadcast()</I>, thus waking up only one worker thread. The remaining worker threads sleep for 15 seconds before starting. All worker threads print &quot;Hello World&quot; to <I>stdout</I> along with their thread IDs. The worker threads then join the boss thread and are deleted.<P>
Under HP-UX, I compiled PTF with the following definitions: _REENTRANT, _POSIX_SOURCE, and _CMA_NOWRAPPERS. I had to use _REENTRANT because threaded code must be reentrant, and I opted for _POSIX_SOURCE because pthreads are based on a POSIX standard. As for _CMA_NOWRAPPERS, the threads package OSF provides to vendors was originally called CMA. HP offers CMA compatibility by providing wrappers in header files that redefine standard library calls with calls to <I>cma_</I> routines. For example, <I>read()</I> is replaced with <I>cma_read()</I>. Unfortunately, enabling CMA wrappers can lead to name collisions, especially in C++, where classes commonly have a member function named <I>read()</I>. When linking the test program, you'll need the following two libraries (shared or archive): libdce and libc_r. libdce provides DCE support. libc_r is HP's thread-safe library of system calls.<P>
Finally, developing PTF was hardly a one-man job. It takes support, criticism, and testing to produce reusable code. I'd like to thank David Potochnak, Chanakya Ganguly, Dan McCartney, and Anne Jata for helping make this framework possible.<P>
<h3><a name="027d_00cd">References<a name="027d_00cd"></h3><P>
Becker, Pete. &quot;Writing Multi-threaded Applications in C++.&quot; <I>C++ Report</I> (February 1994).<P>
Lockhart, Harold W. <I>OSF DCE</I>. New York, NY: McGraw Hill, 1994.<P>
Open Software Foundation. <I>OSF DCE Application Development Reference</I>. Englewood Cliffs, NJ: Prentice-Hall, 1993.<P>
Open Software Foundation. <I>OSF DCE Application Development Guide</I>. Englewood Cliffs, NJ: Prentice-Hall, 1993.<P>
<h2>Using Threads Effectively</h2><P>
Because a typical program can have more than 100 threads, using threads properly requires synchronization. Two mechanisms are available: mutual exclusion locks (mutexes) and condition variables. A mutex is used to protect data from simultaneous access by multiple threads (race condition). A thread would lock a mutex associated with a piece of data, update the data, then unlock the mutex. You'll need to guard against deadlocks. Deadlocks usually occur when working with more than one mutex. Imagine a problem where both threads A and B need to lock both mutexes 1 and 2. Thread A grabs mutex 1 and thread B grabs mutex 2. Both threads will wait indefinitely for the other's mutex to become available. You can also deadlock on one mutex if you attempt to lock the same mutex a second time, say in a recursive routine. DCE, however, supports a special recursive mutex for just such a situation.<P>
A condition variable can be considered as a kind of mutex, except that instead of synchronizing threads with data, it synchronizes threads with other threads. For example, if thread A needs an intermediate value calculated by thread B, thread A can wait for thread B to complete its computations. Thread B, when ready, can then signal thread A. This signal is not to be confused with UNIX signals. <P>
By default, DCE threads are scheduled with a round-robin (RR) policy in medium priority. If all your threads run at the same priority, the RR policy ensures that all threads get serviced eventually. Don't assume, however, that time-slicing occurs at a fine level (millisecond or smaller). If your platform has multiple CPUs, threads can run simultaneously, but on a single-CPU platform, time slicing can occur on the order of a minute or more, depending on your system configuration. This seemingly large time slice is efficient; context switching between threads can be expensive. <P>
DCE threads also support a first-in, first-out (FIFO) policy, whereby a thread will run uninterrupted by any other thread of equal priority. The thread will yield only when it's completed or when it blocks for I/O. FIFO is the most efficient policy, because it minimizes context switching. It is also the least fair, because short-running threads will have to wait for long-running threads. Long-running threads can, however, give up control with intelligently placed calls to <I>pthread_yield()</I>. Realize, though, that if the long running thread has locked a mutex needed by other threads, <I>pthread_yield()</I> will accomplish nothing and cost a context switch. Other scheduling policies are available, but RR and FIFO are the most commonly used ones.<P>
While the nature of an application will determine the proper scheduling policy, when it comes to thread priorities, simple is better. Use threads of identical priority or one high-priority thread and many with medium priority. Writing a program with clever scheduling priorities generally leads to unexpected performance issues. One such case is priority inversions, where a lower-priority thread can run before a higher-priority thread. For example, given three threads of different priorities, if low-priority thread C locks a mutex needed by high-priority thread A and thread C waits while medium-priority thread B runs, thread A must wait while thread B runs. <P>
Often, a low-priority thread can be replaced with a medium-priority thread that sleeps a lot. For example, a low-priority thread might make sense for such tasks as monitoring the state of a file, but a better solution would be to create the thread with the same priority as all the other threads (medium) and have it periodically &quot;sleep,&quot; or wait on a condition variable, for <I>n</I> seconds before checking the file. In addition, if the state of the file were to be changed by another thread, the thread making the change could wake (signal) the sleeping thread. Putting a thread to sleep avoids polling in a tight loop looking for work to do, thus saving CPU cycles and simulating a lower-priority schedule.<P>
Working with threads isn't easy. Their simultaneous execution and interaction often lead to conditions that are difficult to foresee. Troubleshooting a threaded application can be arduous if you don't have a debugger that can trace through threads. As of this writing, HP has a debugger for threads in beta. For the most part, I relied on old-fashioned debugging statements that also displayed the thread ID. I also developed and depended on PTF, a framework for pthreads, to reduce my chances for error. It's evident that threads require a fair amount of work, but the results are well worth the effort. <P>
--M.Y.<P>
<a name="027d_00ce"><a name="027d_00ce"><B>Table 1:</B> PTF classes and the PTTSafeType template.<pre>

<b>Class     Purpose</b>
<I>PTObject</I>     Threads are derived from this class.
<I>PTMutex</I>     Encapsulates DCE mutexes.
<I>PTCondVar</I>     Derived from <I>PTMutex</I>. Encapsulates DCE condition variables.
<I>PTSafeObject</I>     A thread-safe class can be derived from this class.
<I>PTLock</I>     Works with <I>PTSafeObject</I> to lock and unlock a mutex.
PTTSafeType     Template derived from <I>PTSafeObject;</I> makes built-in types thread safe.
</pre>

<a name="027d_00cf"><a name="027d_00cf"><B>Figure 1:</B> Code fragment using PTLock to make your derived class thread safe.<pre>
derivedClass::updateData()
{
    // Class is derived from PTSafeObject
    PTLock lock(this);  // mutex locked
    // safe to update data here.
    ...
    // return invokes PTLock's destructor
    // which unlocks the mutex.
}
</pre>
<a name="027d_00d0"><a name="027d_00d0"><B>Figure 2:</B> Code fragment illustrating thread-safe template.<pre>
PTTSafeType &lt;int&gt; sequenceNumber;
 ...
sequenceNumber.set (0);      // sets number to 0 safely.
++sequenceNumber;           // inc number safely.
// or sequenceNumber++;
 ...
 </pre><P>
<P>
<h4><a name="027d_00d1"><a name="027d_00d2"><a name="027d_00d2">Listing One</h4>
<pre>
/***** PTF.H -- Header file describes classes for pthread framework. *****/
#ifndef PTF_H
#define PTF_H
extern &quot;C&quot;
{
#include &lt;pthread.h&gt;
}
#define TRUE    1
#define FALSE   0
/*--- CLASS: PTMutex. Description: Create, destroy, lock, unlock a mutex. ---*/
class PTMutex 
{
public:
    PTMutex ();
    virtual ~PTMutex();
    int lock();
    int unlock();
    int tryLock();
    // dummy declarations to prevent copying by value. classes not having 
    // pointer members may remove these declarations. Note: operator=() 
    // should be chained in case of inheritance.
    PTMutex (const PTMutex &amp;);
    PTMutex&amp; operator=(PTMutex&amp;);
    virtual const char *className() { return &quot;PTMutex&quot;; }
    virtual int isValid();  
protected:
    pthread_mutex_t _hMutex;        // handle to mutex
private:
    int _validFlag;
};
/*--- CLASS: PTCondVar. 
 *--- Description: Manages condition variables and associated mutexes. ----*/
class PTCondVar : public PTMutex
{
public:
    PTCondVar ();               // pthread_cond_init()
    virtual ~PTCondVar ();      // pthread_cond_destroy()
    int signal ();
    int broadcast ();
    int timedWait (int seconds=0);
    pthread_cond_t hCondVar() { return _hCondVar; }
    // dummy declarations to prevent copying by value.
    // classes not having pointer members may remove these declarations.
    // Note: operator=() should be chained in case of inheritance.
    PTCondVar (const PTCondVar&amp;);
    PTCondVar&amp; operator=(PTCondVar&amp;);
    const char *className() { return &quot;PTCondVar&quot;; }
    virtual int isValid();  
protected:
    pthread_cond_t _hCondVar;       // handle to condition variable
private:
    int _validFlag; 
};
/*-- CLASS: PTObject. Description: Abstract class. Use to build a pthread. --*/
class PTObject 
{
public:
    PTObject ();            // use default schedule &amp; policy
    virtual ~PTObject ();
    int start ();
    virtual int runPThread() = 0;   // this gets called by start_routine()
    int tid () {return _tid;}
    int join ();
    // dummy declarations to prevent copying by value.
    // classes not having pointer members may remove these declarations.
    // Note: operator=() should be chained in case of inheritance.
    PTObject (const PTObject &amp;);
    PTObject&amp; operator=(const PTObject&amp;);
    
    const char *className() { return &quot;PTObject&quot;; }
    virtual int isValid();  
    pthread_addr_t exitStatus;      // thread's exit code (used by join()).
protected:
    pthread_t _hPThread;            // handle to thread
    // this static routine gets passed to pthread_create()
    static pthread_addr_t start_routine(void *obj);
private:
    int _validFlag;
    int _tid;
};
/*--- CLASS: PTSafeObject. Description: Derive from this to create a 
 *--- thread-safe class. ----*/
class PTSafeObject 
{
public:
    PTSafeObject ();
    ~PTSafeObject ();
    PTMutex *pPTMutex() const;
    // dummy declarations to prevent copying by value.
    // classes not having pointer members may remove these declarations.
    // Note: operator=() should be chained in case of inheritance.
    PTSafeObject (const PTSafeObject &amp;);
    PTSafeObject&amp; operator=(const PTSafeObject&amp;);
    
    const char *className() { return &quot;PTSafeObject&quot;; }
    virtual int isValid();  
protected:
    class PTLock
    {
    public:
        PTLock (PTSafeObject *ThreadSafe);
        ~PTLock ();
    private:
        PTMutex *_pPTLockMutex;
    };
private:
    // friend declaration needs to be here for nested classes. 
    // might be an HP compiler bug.
    friend class PTLock;
    PTMutex *_pPTMutex;
    int _validFlag;
};
#endif
</pre>
<h4><a name="027d_00d3"><a name="027d_00d4"><a name="027d_00d4">Listing Two</h4>
<pre>
/***** PTF.CPP -- Encapsulation of DCE PThreads. Classes include: PTObject,    
   derive from this to create your threads; PTMutex, creates a mutex;
   PTCondVar, derived from PTMutex. Creates a condition variable and 
   and an associated mutex; PTSafeObject, derive from this for classes 
   which update shared resources; PTLock, locks a mutex. Works with 
   PTSafeObject. Currently supports default thread creation: round-robin 
   scheduling and medium priority. Currently supports default mutex 
   creation: fast locks (as opposed to recursive and non-recursive locks). 
***************************************************************/
#include &quot;PTF.H&quot;
#include &lt;assert.h&gt;
#include &lt;sys/errno.h&gt;
#ifndef NDEBUG
#include &lt;stdio.h&gt;
#endif
extern int errno;
/*--- Function Name: PTObject::PTObject. Description: Constructor using 
 *--- default thread scheduling (Round-robin) and priority (medium). 
 *--- Returns: None ----*/
PTObject::PTObject()
{
    _validFlag = FALSE;
    _tid = 0;                   // id assigned when thread is created
    exitStatus = 0;             // initial thread return code
    _validFlag = TRUE;
}
/*--- Function Name: PTObject::~PTObject. Description: Destructor. Free 
 *--- resources allocated to PThread. Returns: None ---*/
PTObject::~PTObject()
{
    pthread_cancel (_hPThread);     // issue a cancel message to thread
    pthread_detach (&amp;_hPThread);    // free resources of cancelled thread
}
/*---- Function Name: PTObject::isValid. Description: Return private variable
 *---- _validFlag. The variable indicates the state of the object, whether it 
 *---- is valid or not. Returns: TRUE or FALSE ---*/
int
PTObject::isValid()
{
    return _validFlag;
}
/*--- Function Name: PTObject::join. Description: join() causes the calling 
 *--- thread to wait for the thread object to complete. See pthread_join() in 
 *--- DCE Dev. Ref. When the thread is complete, the thread's return code is 
 *--- stored in a public variable: exitStatus. Returns: 0, success; -1, Error. 
 *--- Check errno. ---*/ 
int
PTObject::join ()
{   
    pthread_t threadID = pthread_self();
    int uniqueID = pthread_getunique_np (&amp;threadID);
    if (uniqueID == tid())
    {
        printf (&quot;TID %d: Can't join thread to itself.\n&quot;, uniqueID);
        return -1;
    }
    return pthread_join (_hPThread, &amp;exitStatus);
}
/*--- Function Name: PTObject::start. Description: Explicitly starts the 
 *--- thread. Actually, thread creation is performed here as well. If thread 
 *--- were created in the constructor, thread may start before a derived class
 *---  had a chance to complete its constuctor which would lead to 
 *--- initialization problems. Returns: 0, success; -1, fail (errno = 
 *--- EAGAIN || ENOMEM) ---*/ 
int 
PTObject::start()
{
    // Create a thread using default schedule &amp; priority. Also, pass in *this 
    // ptr for argument to associate thread with an instance of this object.
    int status = pthread_create (&amp;_hPThread, pthread_attr_default,
            (pthread_startroutine_t)&amp;PTObject::start_routine,
            (void *)this);
    if (status == 0)
        _tid = pthread_getunique_np (&amp;_hPThread);
   return status;
}
/*--- Function Name: PTObject::start_routine. Description: Static function is 
 *--- passed into pthread_create. It is the start of the thread routine. In 
 *--- turn, it calls the virtual function runThread() which is written by the 
 *--- user of this class. Returns: None ---*/ 
pthread_addr_t 
PTObject::start_routine (void *obj)
{
    // get object instance
    PTObject *threadObj = (PTObject *)obj;
    int status = threadObj-&gt;runPThread();
    return (pthread_addr_t)status;
}
/*--- Function Name: PTMutex::PTMutex. Description: Constructor creates a 
 *--- mutex with a default attribute (fast mutex). Returns: None ---*/
PTMutex::PTMutex()
{
    _validFlag = FALSE;
    int status = pthread_mutex_init (&amp;_hMutex, pthread_mutexattr_default);
    if (status == -1)
       return;
    _validFlag = TRUE;
}
/*--- Function Name: PTMutex::~PTMutex. Description: Destructor destroys mutex.
 *--- Assumes mutex is unlocked. DCE doesn't provide a direct way to determine
 *--- the state of a mutex. In case of failure, use assert() macro. 
 *--- Returns: None ---*/ 
PTMutex::~PTMutex()
{
    // assumes mutex is unlocked. DCE doesn't provide a direct way to determine
    // the state of a lock so I'll just try to destroy it without any checks.
    // I'm using a long name for the return value so that
    // &quot;assert&quot; macro is self documenting.
    int ipthread_mutex_destroy = pthread_mutex_destroy (&amp;_hMutex);
#ifndef NDEBUG
    pthread_t threadID = pthread_self();
    int tid = pthread_getunique_np (&amp;threadID);
    if (ipthread_mutex_destroy == -1)
        printf (&quot;TID %d: Could not destroy mutex. errno=%d\n&quot;, tid, errno);
    assert (ipthread_mutex_destroy == 0);
#endif  
}
/*--- Function Name: PTMutex::isValid. Description: Used to determine if 
 *--- object has been constructed successfully. Returns: TRUE or FALSE ---*/ 
int
PTMutex::isValid()
{
    return _validFlag;
}
/*--- Function Name: PTMutex::lock. Description: Lock this mutex. If mutex is 
 *--- already locked, wait for it to become available. Returns: 0, success;
 *--- -1, fail  (errno = EINVAL or EDEADLK) ---*/ 
int
PTMutex::lock()
{
    return pthread_mutex_lock (&amp;_hMutex);      
}
/*--- Function Name: PTMutex::trylock. Description: Try and lock this mutex. 
 *--- If mutex is already locked, do not wait for it to become available. 
 *--- Just return. Returns: 1, success; 0, mutex already locked; -1,  fail, 
 *--- mutex handle invalid ---*/ 
int
PTMutex::tryLock()
{
    return pthread_mutex_trylock (&amp;_hMutex);
}
/*--- Function Name: PTMutex::unlock. Description: Unlock this mutex.
 *--- Returns: 0, success; -1,  fail, invalid mutex handle ---*/ 
int
PTMutex::unlock()
{
    return pthread_mutex_unlock (&amp;_hMutex);    
}
/*--- Function Name: PTCondVar::PTCondVar. Description: Constructor creates a 
 *--- condition variable. Returns: None ---*/ 
PTCondVar::PTCondVar()
{
    _validFlag = FALSE;
    int status = pthread_cond_init (&amp;_hCondVar, pthread_condattr_default);
    if (status == -1)
        return;         // errno = EAGAIN or ENOMEM
    _validFlag = TRUE;
    return;
}
/*--- Function Name: PTCondVar::~PTCondVar. Description: Destructor destroy a 
 *--- condition variable.  It can fail if the condition variable is busy. 
 *--- Returns: None --*/
PTCondVar::~PTCondVar()
{
    int ipthread_cond_destroy = pthread_cond_destroy (&amp;_hCondVar);
#ifndef NDEBUG
    pthread_t threadID = pthread_self();
    int tid = pthread_getunique_np (&amp;threadID);
    if (ipthread_cond_destroy == -1)
        printf (&quot;TID %d: Could not destroy condition variable. errno=%d\n&quot;, 
                                                                   tid, errno);
    assert (ipthread_cond_destroy == 0);
#endif  
}
/*--- Function Name: PTCondVar::broadcast. Description: Wakes all threads 
 *--- waiting on a condition variable object. Calling this routine means that 
 *--- data is ready for a thread to work on. A broadcast lets one or more 
 *--- threads proceed. Returns: 0, success; -1, fail (errno = EINVAL) ---*/ 
int
PTCondVar::broadcast()
{
    return pthread_cond_broadcast (&amp;_hCondVar);
}
/*--- Function Name: PTCondVar::isValid. Description: Used to determine if 
 *--- constructor succeeded or not. Returns: TRUE or FALSE ---*/ 
int
PTCondVar::isValid()
{
    return _validFlag;
}
/*--- Function Name: PTCondVar::signal. Description: Wakes one thread waiting 
 *--- on a condition variable. Thread to wake is determined by its scheduling 
 *--- policy. Returns: 0, on success; -1, on failure (errno = EINVAL) ---*/ 
int
PTCondVar::signal()
{
    return pthread_cond_signal (&amp;_hCondVar);
}
/*--- Function Name: PTCondVar::timedWait. Description: Will wait on a 
 *--- mutex/condition variable until thread receives a signal or broadcast, or
 *--- until specified number of seconds have elapsed, whichever comes first.
 *--- 0 seconds means wait forever. (default) Returns: 0, success. Thread was 
 *--- signalled; 1, wait timed out. No signal; -1, wait failed. See errno ---*/
int
PTCondVar::timedWait (int seconds)
{
    int status;
    lock();         // lock this condition vars' mutex
    if (seconds &lt;= 0)
    {
        // thread will wait here until it gets a signal
        // 0, default value, means wait forever.
        status = pthread_cond_wait (&amp;_hCondVar, &amp;_hMutex);
    }
    else
    {
        // wait for specified number of seconds
        // use non-portable dce routine to get absolute time from seconds.
        struct timespec delta;
        struct timespec abstime;
        
        delta.tv_sec = seconds;
        delta.tv_nsec = 0;
        
        // I'm using a long name for the return value so if &quot;assert&quot;
        // aborts, message is self-documenting.
        int  ipthread_get_expiration_np = pthread_get_expiration_np (&amp;delta, &amp;abstime);
        assert (ipthread_get_expiration_np == 0);   
        // thread will wait here until it gets a signal or
        // until abstime value is reached by system clock.
        status = pthread_cond_timedwait (&amp;_hCondVar, &amp;_hMutex, &amp;abstime);
        if (status == -1 &amp;&amp; errno == EAGAIN)
           status = 1;      // lock timed-out
    }
    unlock();       // unlock internal mutex
    return status;
}
/*--- Function Name: PTSafeObject::PTSafeObject. Description: Used to make a 
 *--- class thread-safe. Derive from this class, then add PTLock (this); to 
 *--- the first line of each member function in your derived class that 
 *--- accesses data. This class forms the outer part of a thread-safe class. 
 *--- It creates and deletes a PTMutex object. The inner class (nested class 
 *--- -- PTLock) locks and unlocks a PTMutex object. Returns: None ---*/
PTSafeObject::PTSafeObject()
{
    _validFlag = FALSE;
    _pPTMutex = new PTMutex;
    if (!_pPTMutex-&gt;isValid())
       return;
    _validFlag = TRUE;
    return;
}
/*--- Function Name: PTSafeObject::~PTSafeObject. Description: Delete internal
 *--- PTMutex object. Returns: None ---*/ 
PTSafeObject::~PTSafeObject()
{
    delete _pPTMutex;
}
/*--- Function Name: PTSafeObject::pPTMutex. Description: Retrieve a copy of 
 *--- the internal PTMutex object. Returns: None ---*/ 
PTMutex *
PTSafeObject::pPTMutex() const
{
    return _pPTMutex;
}
/*--- Function Name: PTSafeObject::isValid. Description: Determine if 
 *--- constructor succeeded or not. Returns: TRUE or FALSE. ---*/ 
int
PTSafeObject::isValid()
{
    return _validFlag;
}
/*--- Function Name: PTSafeObject::PTLock::~PTSafeObject::PTLock. Description:
 *--- Destructor for class nested within PTSafeObject. It just unlocks the 
 *--- PTMutex object. The outer class, PTSafeObject, deletes it. 
 *---  Returns: None ---*/ 
PTSafeObject::PTLock::~PTLock()
{
    (void)_pPTLockMutex-&gt;unlock();
}
/*--- Function Name: PTSafeObject::PTLock::PTLock. Description: This class 
 *--- forms inner (nested) class of a thread-safe object. The object is 
 *--- responsible for locking and unlocking a PTMutex object. This constructor
 *--- locks it. A user should not instantiate this object explicitly. Pass
 *--- a &quot;this&quot; pointer to this function to give access to outer class' private
 *--- variables. The outer part (PTSafeObject) creates and deletes a PTMutex 
 *--- object. Returns: None ---*/ 
PTSafeObject::PTLock::PTLock(PTSafeObject *ThreadSafe)
{
    _pPTLockMutex = ThreadSafe-&gt;_pPTMutex;
    (void)_pPTLockMutex-&gt;lock();
}
</pre>
<h4><a name="027d_00d5"><a name="027d_00d6"><a name="027d_00d6">Listing Three</h4>
<pre>
/***** PTTF.H -- Template to create thread-safe types. *****/
/*--- TEMPLATE: PTSafeType. Description: This inherits from class PTSafeObject.
 *--- Implemented as template, it can make a variety of types threadsafe.---*/ 
#ifndef PTTF_H
#define PTTF_H
#include &lt;PTF.H&gt;
template &lt;class T&gt;
class PTTSafeType : public PTSafeObject
{
public:
    void operator=(T threadSafeType) {set(threadSafeType);}
    operator T () {return get();}
    T operator ++();
    T operator --();
    T operator ++(T threadSafeType);
    T operator --(T threadSafeType);
    T get();
    T set(T threadSafeType);
private:
    T _threadSafeType;
};
#ifdef RW_COMPILE_INSTANTIATE
#include &quot;PTTF.CC&quot;
#endif
#endif
</pre>
<h4><a name="027d_00d7"><a name="027d_00d8"><a name="027d_00d8">Listing Four</h4>
<pre>
/**** PTTF.CC -- Template definition for PTTSafeType ****/
#ifndef PTTF_CC
#define PTTF_CC
/*--- Function Name: get. Description: retrieves a value safely in a threaded 
 *--- environment. Note that the value is invalid if a set() has never been 
 *--- called. Returns: value T. ---*/ 
template &lt;class T&gt; T PTTSafeType&lt;T&gt;::get()
{
    PTLock Lock(this);
    return _threadSafeType;
}
/*--- Function Name: set. Description:  sets a value safely in a threaded 
 *--- environment. Returns: previous value of T. ---*/ 
template &lt;class T&gt; T PTTSafeType&lt;T&gt;::set (T threadSafeType)
{
    PTLock Lock(this);
    T previous;
    previous = _threadSafeType;
    _threadSafeType = threadSafeType;
    return previous;
}
/*--- Function Name: prefix and postfix operators: ++ and --. Description: 
 *--- Increment and decrement a value safely in a threaded environment
 *--- Returns: value of T after incrementing or decrementing. ---*/ 
template &lt;class T&gt; T PTTSafeType&lt;T&gt;::operator ++()
{
    PTLock Lock(this);
    return ++_threadSafeType;
}
template &lt;class T&gt; T PTTSafeType&lt;T&gt;::operator --()
{
    PTLock Lock(this);
    return --_threadSafeType;
}
template &lt;class T&gt; T PTTSafeType&lt;T&gt;::operator ++(T threadSafeType)
{
    PTLock Lock(this);
    return _threadSafeType++;
}
template &lt;class T&gt; T PTTSafeType&lt;T&gt;::operator --(T threadSafeType)
{
    PTLock Lock(this);
    return _threadSafeType--;
}
#endif
End Listings&gt;&gt;

</pre>
<P>
<P>
<P>
<P>
<P>
<P>
<P>
<P>
<P>
<P>
<HR><P>Copyright &copy; 1995, <I>Dr. Dobb's Journal</I></P></BODY></HTML>
