<HTML>
<META NAME="year" CONTENT="1995">

<HEAD>
<TITLE>SP95: A Generic Parsing Engine in C++</TITLE></HEAD>
<BODY BGCOLOR="#ffffff">
<h1>A Generic Parsing Engine in C++<a name="027f_00c8"><a name="027f_00c6"><a name="027f_0000"></h1><P>
<h2>A portable engine for parsing using regular expressions</h2><P>
<h3>Todd D. Esposito and Andrew K. Johnson</h3><P>
<p><i><a name="027f_00c7"><a name="027f_0000">Todd is a systems architect with Prodis Inc., a systems integrator and custom-software development firm in Carol Stream, Illinois. Andrew is a development engineer with Prodis.  They can be reached at 708-462-8600 or on CompuServe at 70661,2717.</i></p><hr><P>
In building applications and user/management-level tools for our clients, we have found a recurring need for parsing technology. Whether for updating WIN.INI or running complicated macros within a custom applications, parsing keeps rearing its head. Our first few parsers were fitted to the content being parsed, with little or no room for deviation, and each new project started almost completely from scratch. <P>
After a few such projects, we found a better way. The result is the parsing engine presented in this article: a generic parser, requiring no specific knowledge of the source language, and with no ties to the underlying application. The engine is a collection of five objects. The interface is almost exclusively contained in two objects, and then only in a few member functions, so it is easily integrated into any project. In this article, we will examine the engine's design and operation, and use it to implement a Basic-like macro language.<P>
<h3><a name="027f_00c9">A Structural Overview of the Parsing Engine<a name="027f_00c9"></h3><P>
The parsing engine is generic in that it contains no application- or language-related code. The parser's five classes are each fitted to a particular aspect of the parsing strategy. The relationships between these objects are outlined in <a href="19950281.htm">Figure 1</A>. The application using the engine typically will create a <I>gpFlowControl</I> object and feed it the parameters needed to construct <I>Syntax</I> objects, which encapsulate the language constructs. This initializes the engine. The <I>gpFlowControl</I> object creates all the other objects and converts the supplied parameters to the appropriate object type. The application then sends input lines to the engine. The engine returns tokens, telling the application the meaning of the input, and extracts any parameters from the input.<P>
Starting from the top, we encounter the <I>gpFlowControl</I> class, which acts as traffic cop, ensuring that the correct code is executed in the proper order. Most of your application's calls will be to this object, which then passes control to its embedded <I>gpParser</I>. On the way back to your application, the <I>gpFlowControl</I> object takes a peek at the token the <I>gpParser</I> returned and decides if it needs to intercede. This will happen in the case of an If/Then/Else or other control structure.<P>
Each possible command in your macro language must be paired with a &quot;token,&quot; which is just a more-convenient representation of the command. The <I>gpParser</I> class substitutes tokens for the associated input patterns it receives. <I>gpParser</I> &quot;learns&quot; your language by way of the <I>AddSyntax()</I> member function, which takes as parameters either a string and a token, or a <I>Syntax</I> object. (<I>gpFlowControl</I>'s <I>AddSyntax()</I> function simply passes its parameters to the embedded <I>gpParser</I>.) <I>Syntax</I> objects encapsulate the pairing between syntax and token. Note the syntax/token relationship is not necessarily one-to-one: One token can represent many different syntactic constructs.<P>
The <I>gpRegExp</I> class implements regular expressions (string-matching templates), and is derived from <I>gpString</I>. <I>gpRegExp</I> overloads two key functions: the constructor and the equality operator (==).<P>
The <I>gpString</I> class handles character-string manipulation and provides overloaded operators to make using strings easier (see <a href="#027f_00d4">Listing One</A>). We built this class before the ANSI <I>string</I> class was sanctioned, and we still prefer ours to the ANSI version. It should be a simple matter to retrofit ANSI strings into the system. However, since we use our <I>gpString</I> class in all of our projects (rather than the ANSI class), this has not been a priority. <P>
<h3><a name="027f_00ca">The Macro Language<a name="027f_00ca"></h3><P>
Microsoft has popularized the use of Basic as a macro language for applications. While we won't comment on the wisdom of that practice, the Basic syntax structure provides a reasonable example of how to use our parsing engine. The result is the shell of a full-fledged macro language, ready to be embedded into an application. Due to space constraints, our discussion will focus on the operation of the parsing engine, leaving the implementation of the Basic constructs (such as variable typing and storage and retrieval) for you to explore.  <P>
Before we begin, we need to design and analyze our Basic syntax. The simplest macro selects a menu or invokes an application process; see <a href="#027f_00cf">Example 1(a)</A>. <a href="#027f_00cf">Example 1(b)</A> shows how to call a function in Basic. <a href="#027f_00cf">Example 1(c)</A> shows a more complex macro demonstrating conditional execution, and <a href="#027f_00cf">Example 1(d)</A> uses a loop to extend <a href="#027f_00cf">Example 1(c)</A>, allowing the user to try again.<P>
<h3><a name="027f_00cb">Regular Expressions Unveiled<a name="027f_00cb"></h3><P>
Regular expressions are tremendously powerful. They help propel the UNIX shells (sh, csh, ksh) and text-processing utilities (sed, grep, awk, perl, and so on) to an unparalleled level of sophistication. Regular expressions, as anyone who has worked with UNIX knows, are string templates. A regular expression matches a string if the string's content fits into the regular expression's template. The DOS command line, DIR *.BAT, for example, uses a limited form of regular expressions. In this case, &quot;*.BAT&quot; is the regular expression, and the names of the files are the content being matched. Normally, a regular expression is not position sensitive and will match a line if any substring of the line matches. For example, the regular expressions &quot;Goodbye,&quot; &quot;Cruel&quot; and &quot;World!&quot; will each match &quot;Goodbye Cruel World!&quot; This is useful, since we don't have to know a string's entire content to &quot;find&quot; it. <a href="#027f_00d1">Table 1</A> provides a description of various wildcards.<P>
The parsing engine makes constant use of regular expressions. In fact, most of its execution time is spent inside a member function of the <I>gpRegExp</I> class. We implemented regular-expression matching in two steps: decomposition in the <I>gpRegExp</I> class's constructor, and pattern matching in the overloaded equality operator. When you create a <I>gpRegExp</I> object, it breaks down each regular expression into several smaller atomic expressions, each of which is classified. <a href="19950282.htm">Figure 2</A> depicts how a sample regular expression is decomposed. This process creates a <I>gpRegExp</I> object for each atom in the expression, arranged in a typical linked list. A private member function, <I>ParseAtoms()</I>, serves as a common initializer for several different overloads of the constructor; see <a href="#027f_00d6">Listing Two</A>. <I>ParseAtoms()</I> performs the actual decomposition of the expression in an almost recursive manner.<P>
<I>ParseAtoms()</I> removes characters from its input and stores them in its internal string. It does this one character at a time, until the end of the string or some special character is reached (with two exceptions, &quot;^&quot; and &quot;&amp;,&quot; which are explained later). Once <I>ParseAtoms()</I> reaches a special character, it cuts the input string into two pieces: One, it retains and classifies; the other, it uses to construct the next atom, which will in turn go through the same process.<P>
Classification of the atom is all-important, because it drives the pattern-matching engine. <I>ParseAtoms()</I> classifies each atom for content. These classifications are defined by the enumerated type <I>ExpType_T</I>. For example, <I>Literal</I> is a string literal that must match exactly, <I>Wild</I> is a wildcard matching any single character, and so on. Additionally, <I>ParseAtoms()</I> will classify an atom in terms of positional requirement, based on the &quot;^&quot; and &quot;$&quot; special characters, and will mark <I>gpRegExp</I> as meaningful if the &quot;&amp;&quot; character precedes it. (Meaningful, in this sense, indicates the matched portion should be saved for later retrieval, because the calling application will need to know exactly what was matched.)<P>
The second parameter, called &quot;top,&quot; is a curious detail. Top controls whether the <I>gpRegExp</I> object is marked as a top-level (or root) atom in the linked list, and determines whether or not to handle the &quot;^&quot; special character. Normally, this parameter is not supplied, except that <I>ParseAtoms()</I> always sets it to 0 (no) when constructing the next atom. It defaults to 1 (yes), so the programmer need not think about it. In fact, it is important not to change this parameter.<P>
Once <I>ParseAtoms()</I> has completed decomposition, the <I>gpRegExp</I> object is ready. Its primary purpose is to match things with the overloaded equality operator. The process starts at the root and travels down the list of atoms. At each level, the <I>gpRegExp</I> object tries to match its input. If it succeeds, it passes what remains unmatched to the next atom. If that atom returns failure, so does the caller. Thus, the root can only succeed if all of the atoms in the list succeed.<P>
Matching is based on the atom's <I>ExpType_T</I>, as determined at construction time. The rules for the types <I>Literal</I>, <I>Wild</I>, <I>Range</I>, and <I>Optional</I> are simple; the <I>Multi-0</I> and <I>Multi-1</I> variants, however, bear investigation. Both of these attempt to match as much of the input as possible. If the next atom returns failure, the object will step back one character in the match, and try again. This process ends when the next atom returns success, or the <I>Multi</I> atom can no longer back up because too few characters were matched. Note that the <I>Multi-0</I> types, which specify zero or more occurrences of a given pattern, will match an empty string, whereas the <I>Multi-1</I> types consume at least one character.<P>
<h3><a name="027f_00cc">The Parser Itself<a name="027f_00cc"></h3><P>
The parser learns about the target language by means of a syntax table, which is a list of <I>Syntax</I> objects. These <I>Syntax</I> objects each contain a <I>gpRegExp</I> and a token. The <I>gpRegExp</I> defines the syntax of the command. The token indicates which command it represents and is usually put through a <I>switch </I>construct by the application to dispatch the proper handler, much like a WM_ message in the Windows <I>WndProc</I> function.<P>
The <I>gpParser</I> class takes all of the credit without doing any of the work. The constructor merely stores the <I>SyntaxList</I> that the caller passed in. The <I>Parse()</I> function does little more than pass its parameter to the <I>SyntaxList</I>'s <I>Seek()</I> function; see <a href="#027f_00d8">Listing Three</A>. <I>Seek()</I> simply walks through the list of <I>Syntax</I> pattern objects, asking each if it is equal to the parameter. The <I>Seek()</I> function doesn't know that regular-expression matching is going on, since it just uses the equality operator. If <I>Seek()</I> returns success, <I>Parse()</I> returns the token associated with the matching syntax pattern. This portion of the code shows the true power of overloaded operators in C++.<P>
<h3><a name="027f_00cd">Constructing the Language<a name="027f_00cd"></h3><P>
So, how do we use this to construct a macro language? First, we must construct our syntax table. In our example, the DoCmd command takes only one form; see <a href="#027f_00d0">Example 2</A>.<P>
This regular expression indicates we're looking for a line beginning with the literal &quot;DoCmd DoMenuItem&quot; and we want to capture the three possible comma-separated parameters. We also have to assign this command a token, so we choose to define this to be TK_DOMENUITEM, and give it an arbitrary value of (TK_USERDEF + 1) with a <I>#define</I>. We use TK_USERDEF as a base point, so we don't conflict with any predefined tokens.<P>
We continue this process for each command available in our language. When finished, we have produced the code in Listings <a href="#027f_00da">Four</A> and <a href="#027f_00dc">Five</A>. One word of caution: The most-specific syntax patterns must precede the more-general patterns so that a general pattern (such as <I>Call +&amp;.*(&amp;.*)</I>) does not get matched when a more-specific one (such as <I>Call +MessageBox *(&amp;.*)</I>) was called for.<P>
<a href="#027f_00de">Listing Six</A>, syntoken.h, contains definitions for tokens such as TK_IF and TK_USERDEF. In most cases, your application will have to handle predefined and user-defined tokens. <a href="#027f_00d2">Table 2</A> lists the predefined tokens and what they represent.<P>
After calling the <I>BuildMacroEngine()</I> function in <a href="#027f_00dc">Listing Five</A>, read lines from the input file and pass them to the <I>gpFlowControl</I> object that <I>BuildMacroEngine()</I> returned. Do this by calling its <I>Parse()</I> function, sending in the line to parse and an empty <I>StringList</I>, which <I>Parse()</I> will fill with the command's parameter before returning. <I>Parse()</I> will return the token associated with this command.<P>
Handling expressions, such as those between If and Then, is a simple matter of constructing a <I>gpParser</I> object that knows the rules of the expression's grammar. This is demonstrated in the <I>BuildExpEngine()</I> and <I>EvalExp()</I> functions in <a href="#027f_00dc">Listing Five</A>. The <I>gpFlowControl::Parse()</I> function returns TK_IF, TK_WHILE, or a similar token when an expression has to be evaluated before flow control can be determined. In this case, the expression should be in the first element of <I>StringList</I>, and can be passed directly to <I>EvalExp()</I>, which passes it into the <I>gpParser::Parse()</I> function. Breaking down expression syntax adequately can make this process quite powerful. Once <I>gpParser::Parse()</I> establishes a truth value for the expression, the application calls the <I>gpFlowControl::PostExpressionValue()</I> function. This sets the state of the <I>gpFlowControl</I> object and determines how the flow-control construct will be handled.<P>
<h3><a name="027f_00ce">Conclusion<a name="027f_00ce"></h3><P>
The parsing engine presented provides a very powerful and generalized solution. We have used it in products from simple utilities to embedded-application scripting languages. Its implementation in C++ makes good use of inheritance and polymorphism. We have attempted to keep the engine pure so that it will port easily. In fact, we used it under DOS, Windows 3.x, Win32s, Windows NT, and OS/2 platforms (in all cases, using the Borland C++ compiler).<P>
However, the engine does have some limitations. The <I>gpRegExp</I> class does not implement all of the UNIX-style, regular-expression special characters and functionality. We have designed the engine with this in mind, but have yet completed this work. And since our <I>gpRegExp</I> class makes all comparisons case insensitive, operations such as case-sensitive variable naming may not be supportable. Also, the <I>gpFlowControl</I> object does not handle flow-control constructs such as Switch/Case and For/Next. These would be relatively easy to add.<P>

<a name="027f_00cf"><a name="027f_00cf"><B>Example 1:</B> (a) Basic statement that invokes a menu command; (b) Basic function calls; (c) typical If/Then/Else construct; (d) While loop.
<pre>
(a)
DoCmd DoMenuItem FILE, OPEN, &quot;C:\DIRNAME\FILENAME.EXT&quot;

(b)
Call MessageBox (&quot;Invalid Type Code!&quot;, 0, &quot;Error&quot;)<P>Call RecalcBalances ()

(c)
If FileName$ &gt; &quot;&quot; Then<P>     DoCmd DoMenuItem FILE, OPEN, FileName$<P>Else<P>     Call MessageBox (&quot;You must type a file name!&quot;, 0, &quot;Error&quot;)<P>Endif

(d)
Let GotFile = 0<P>While GotFile = 0<P>     Call GetFileName (FileName$)<P>     If FileName$ &gt; &quot;&quot; Then<P>          DoCmd DoMenuItem FILE, OPEN, FileName$<P>          Call RecalcBalances ()<P>          Let GotFile = 1<P>     Else<P>          Call MessageBox (&quot;You must type a file name!&quot;, 0, &quot;Error&quot;)<P>     Endif<P>WEnd
</pre>
<a name="027f_00d0"><a name="027f_00d0"><B>Example 2:</B> A syntax rule specified via a regular expression, consisting of a string literal followed by three comma-separated parameters.
<pre>
DoCmd *DoMenuItem *&amp;[A-Z]+ *, *&amp;[A-Z]+ *, *&amp;.*
</pre>
<B><a href="19950283.htm">Figure 1</A>: </B>Structural overview of the parsing engine.<P>
<B><a href="19950284.htm">Figure 2</A>:</B> Decomposing the regular expression ^_*If +&amp;.+ +Then$. This implements the expression If &lt;&lt;expression&gt;&gt; Then.<P>

<a name="027f_00d1"><a name="027f_00d1"><B>Table 1:</B> Wildcards and their use.<pre>

<b>Wildcard     Description</b>
.     Period matches any one character. Using this character in
      the expression &quot;HEL.&quot; will match &quot;HELP,&quot; &quot;HELL,&quot; &quot;HELD,&quot;
      and so on. The <I>ExpType_T</I> value
      <I>Wild</I> represents this wildcard.

*     Asterisk matches zero or more of the previous character.
      This is useful if you don't know how many spaces are
      between two words, such as in: &quot;Goodbye Cruel World!&quot; or
      &quot;GoodbyeCruel     World!&quot; The regular expression to match
      this would be &quot;Goodbye *Cruel *World!&quot; Asterisk can be
      used to create <I>MultiWild0</I>, <I>MultiChar0,</I>
      and <I>MultiRange0</I> when paired with a period,
      regular character, or Range operator, respectively.

+     Plus matches one or more of the previous characters. This
      is useful if you don't know how many spaces are between
      two words, but know there must be at least one, such as
      in: &quot;Goodbye Cruel World!&quot; or &quot;Goodbye     Cruel World!&quot;
      The regular expression to match this would be
      &quot;Goodbye+Cruel+World!&quot;. Note that this would not match
      &quot;GoodbyeCruel     World!&quot;. Plus can be used to create
      <I>MultiWild1</I>, <I>MultiChar1,</I> and
      <I>MultiRange1</I> when paired with a period,
      regular character, or Range operator, respectively.

[x-y]     The Range operator pair, &quot;[&quot; and &quot;]&quot; provide for
      matching a specific character or range of characters. For
      example, if you are looking for &quot;ABC&quot; or &quot;BBC&quot; but not
      &quot;CBC&quot; or any other, you would use &quot;[A-B]BC&quot; as your
      regular expression. Range defines the <I>ExpType_T</I>
      for this construct.

{ s }     The Optional operator pair, &quot;{&quot; and &quot;}&quot; allow you to
      specify a string that may or may not be there, such as in
      &quot;Goodbye {Cruel} World!&quot;, which matches &quot;Goodbye Cruel
      World!&quot; and &quot;Goodbye World!&quot;  Braces result in an
      <I>ExpType_T </I>of <I>Optional</I>.

&amp;     Ampersand indicates the atom to follow is meaningful, and
      should be retained. A parsing application uses ampersand
      to extract parameters from commands. For example, if we
      need to know the name of the file passed to the File Open
      command, our regular expression is &quot;File Open &amp;.+&quot;
      Whatever is matched by the &quot;.+&quot; atom is saved, and will
      be passed back from <I>gpFlowControl::Parse()</I>
      in the <I>lsParms</I> List object. When using
      the <I>gpParser</I> object directly, you can get
      these parameters with a call to
      <I>gpParser::DumpParameters()</I>.

^     Caret matches beginning of line. If this character is the
      first character of the regular expression, it makes the
      expression position sensitive. &quot;^Good&quot; would match
      &quot;Goodbye Cruel World!&quot; but &quot;^Cruel&quot; and &quot;^World&quot; would
      not. If caret occurs anywhere else in the regular
      expression, it is treated as a literal (technically it
      should be quoted, but we're a bit more relaxed than UNIX).

$     Dollar matches end of line. Like caret, a dollar as the
      last character makes the expression position sensitive.
      So, &quot;Good$&quot; and &quot;Cruel$&quot; would not match &quot;Goodbye Cruel
      World!&quot; but &quot;rld!$&quot; would. Unlike caret, it cannot appear
      unquoted anywhere in the regular expression except at the
      end. Dollar effectively ends the regular expression,
      making any characters following it drop into the bit
      bucket.

\     Backslash is the &quot;quote&quot; character. If you need to find a
      special character in a file, such as when looking for
      &quot;$10,000,000 Winner&quot; in your e-mail, you have to quote
      the $ so that <I>gpRegExp </I>doesn't try to
      interpret it. A dollar in the first position of an
      Expression won't find the match. In this case, you would
      use &quot;\$10,000,000 Winner&quot; as your regular expression.
      </pre>
<a name="027f_00d2"><a name="027f_00d2"><B>Table 2:</B> Predefined tokens and their uses.<pre>

<b>Token         Description</b>
TK_UNRECOGNIZED      No match was found, meaning that a syntax
                     error has occurred in the input stream.
TK_NOOP              No-Operation. This is a comment, or no
                     action should be taken because we're inside
                     a not-taken Then or Else clause or a failed
                     While loop.
TK_REWIND            Rewind the input stream (loop back to a 
                     predetermined point). The line number is in
                     the first parameter.
TK_IF                Part of an IF structure was found. Normally,
TK_ELSE              only TK_IF requires action: An expression
TK_ENDIF             needs to be evaluated. The parameter list
TK_LABEL             contains the expression. TK_LABEL is usually
TK_GOTO              treated as a NOOP, but your application may
                     want to cache this location for faster
                     rewinding later. When TK_GOTO is encountered,
                     the label should be in the parameter list.
TK_WHILE             TK_WHILE begins a While loop. The expression
TK_ENDWHILE          needing evaluation is in the parameter list.
                     TK_ENDWHILE should be treated like TK_REWIND.
TK_COMMENT           A comment was encountered. This token is
                     included for convenience.
TK_EQUALS            These tokens are used in evaluating
TK_NOT_EQUAL         comparative expressions and are included
TK_GREATER_THAN      for convenience.
TK_LESS_THAN
TK_GREATER_OR_EQUAL
TK_LESS_OR_EQUAL
TK_AND               These tokens are used in evaluating logical
TK_OR                expressions and are included for convenience.
TK_NOT
TK_UNMATCHED_ELSE    These tokens are returned whenever a
TK_UNMATCHED_ENDIF   TK_ELSE, TK_ENDIF or TK_ENDWHILE is
                     encountered, and it is not matched
                     with a corresponding TK_IF or TK_WHILE.
TK_USERDEF           Acts as the base point for application-
                     specific verbs.
                     </pre><P>
<P>
<h4><a name="027f_00d3"><a name="027f_00d4"><a name="027f_00d4">Listing One</h4><pre>
//------------------------------------------------------------------
// gpString.h - Declaration of the gpString class.
// Copyright 1994 Prodis Incorporated.
// Architect: TDE
// Developer: AKJ
//------------------------------------------------------------------
#ifndef GPSTRING_H
#define GPSTRING_H
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;ctype.h&gt;
#define NPOS 32000
typedef unsigned size_t;
// StripType is used with ::Strip()
enum StripType { Trailing, Leading, Both, All };
// Direction and Inclusive are used with ::FindString() and ::FindChar()
enum Direction { Forward, Backward };
enum Inclusive { Of, NotOf };
class gpString
  {
    protected :
      char *cText;
      size_t nSize;
      int CharIsOfString(char cChar, char *cBuffer);
    public :
    // Constructors:
      gpString (const char *cString);
      gpString (char cChar);
      gpString (size_t nNewSize, char cFill = ' ');
      gpString ( );
      gpString (gpString &amp;sString);
    // Destructor:
      ~gpString ( );
    // Size-related functions:
      size_t Length ( ) {return strlen(cText);}
      void Resize (size_t nNew);
      size_t Size ( ) {return nSize;}
    // Case Conversion - returns a copy:
      gpString ToUpper ( );
      gpString ToLower ( );
    // Assignment Operators:
      // Return the character in the string at a given offset.
      char &amp;operator[] (int nPos) {return *(cText+nPos);}
      // Type conversion to char *.
      operator char *( );
      // Assign one string to another.
      gpString &amp;operator= (gpString &amp;oString);
      // Append another string to this one.
      gpString &amp;operator+= (gpString &amp;oString);
      // Concatenate two strings.
      gpString operator+ (gpString &amp;oString);
    // Relational operators:
      // Compare two strings for equality.
      virtual int operator== (gpString &amp;oString);
      virtual int operator== (char *cString)
            {return operator==(gpString(cString));}
      // Compare two strings for inequality.
      int operator!= (gpString &amp;oString);   
      int operator!= (char *cString) 
            {return operator!=(gpString(cString));}
      // Compare two strings for exclusive alphanumeric precedence. 
      int operator&lt; (gpString &amp;oString);        
      int operator&lt; (char *cString)
            {return operator&lt;(gpString(cString));}
      // Compare two strings for exclusive alphanumeric antecedence.
      int operator&gt; (gpString &amp;oString);
      int operator&gt; (char *cString)  
            {return operator&gt;(gpString(cString));}
      // Compare two strings for inclusive alphanumeric precedence. 
      int operator&lt;= (gpString &amp;oString);
      int operator&lt;= (char *cString) 
            {return operator&lt;=(gpString(cString));}
      // Compare two strings for inclusive alphanumeric antecedence.
      int operator&gt;= (gpString &amp;oString);
      int operator&gt;= (char *cString) 
            {return operator&gt;=(gpString(cString));}
    // Search Functions:
      // Find the target substring within this string.
      size_t FindSubstring (gpString &amp;sTarget
              , Direction dDirect = Forward, size_t nStart = 0);
      // Find any character of the target string.
      size_t FindChar (Inclusive iIsOf, gpString &amp;sTarget
              , Direction dDirect = Forward, size_t nStart = 0);
    // Edit Routines:
      // Insert the new string at the given position.
      gpString &amp;Insert (gpString &amp;sNew, size_t nPos);
      // Remove nSize characters starting with position nPos.
      gpString &amp;Remove (size_t nPos, size_t nSize = NPOS);
      // Replace nSize characters with the new string.
      gpString &amp;Replace (size_t nPos, size_t nSize, gpString &amp;sNew);
      // Remove the given characters at the given positions.
      // We default to stripping leading and trailing whitespace.
      gpString &amp;Strip (StripType s = Both
              , gpString &amp;sTarget = gpString (&quot; \t&quot;));
  };    
#endif
</pre>
<h4><a name="027f_00d5"><a name="027f_00d6"><a name="027f_00d6">Listing Two</h4><pre>
//------------------------------------------------------------------
// gpRegExp.cpp - Definition of the gpRegExp class.
// Copyright 1994 Prodis Incorporated.
// Purpose: The General Purpose Regular Expression class handles
//          pattern matching duties.
// Architect: TDE
// Developer: AKJ
// Modification History:
//      09/08/94 TDE: Original Code.
//      09/09/94 AKJ: Fixed TDE's stuff, and fleshed out functions.
//      01/17/95 AKJ: Added support for +.
//      02/22/95 AKJ: Minor fix to Opional to allow fallback.
//------------------------------------------------------------------
#include &lt;stdlib.h&gt;
#include &lt;gpregexp\gpregexp.h&gt;
#include &lt;gpstring\gpslist.h&gt;
#define LOWER_BOUND 1
#define UPPER_BOUND 3
// Create a gpRegExp object from a character string.
gpRegExp::gpRegExp (const char *cNewText)
        : gpString (cNewText)
  {
    nDoICount = 0;
    fTopLevel = top;
    NextAtom = 0;
    ParseAtoms ();
  }
gpRegExp::gpRegExp (char cChar, int top)
        : gpString (cChar)
  {
    nDoICount = 0;
    NextAtom = 0;    
    fTopLevel = top;
    ParseAtoms ();
  }
gpRegExp::gpRegExp (int top) : gpString ( )
  {
    nDoICount = 0;
    NextAtom = 0;    
    fTopLevel = top;
    ParseAtoms ();
  }
gpRegExp::gpRegExp (const gpString &amp;s, int top)
        : gpString (s)
  {
    nDoICount = 0;
    NextAtom = 0;    
    fTopLevel = top;
    ParseAtoms ();
  }
gpRegExp::~gpRegExp ( )
  {
    if (NextAtom) delete NextAtom;
  }
gpRegExp &amp;gpRegExp::operator= (gpString &amp;oString)
  {
    if (NextAtom) delete NextAtom;
    NextAtom = 0;
    fTopLevel = 1;
    (*this) = oString;
    ParseAtoms ();
              
    return *this;
  }
gpRegExp &amp;gpRegExp::operator= (char *cString)
  {
    if (NextAtom) delete NextAtom;
    (*this) = (cString);
    NextAtom = 0;
    fTopLevel = 1;
    ParseAtoms ();
                 
    return *this;
  }
//-------------------------------------------------------------
void gpRegExp::ParseAtoms ( )
  {
    int nPos = 0;
    int GotToken = 0;
    gpString *copy;
    ExpType = Literal;
    size_t nOffset;
    
    // Release the previous atoms and reset parameters.
    // This is ususally only for when an assign is done.
    firstOnly = 1;
    lastOnly = 0;
    if (fTopLevel)
      {
        // First, optimize by removing extraneous '.*'s 
        if (FindSubstring (&quot;^.*&quot;) == 0)
          {
            firstOnly = 0;
            Remove (0, 3);
          }  
        else if (FindSubstring (&quot;.*&quot;) == 0)
          {
            firstOnly = 0;
            Remove (0, 2);
          }
        // Next, check for &quot;Beginning-of-Line&quot;
        if (*this[0] == '^')
            Remove (0, 1);
        else
            firstOnly = 0;
      }
    // Strip out the first atom in the string.
    copy = new gpString (cText);
    while (nPos &lt; Length() &amp;&amp; ! GotToken)
      {
        switch ((*this)[nPos])
          {
          case '\\':                  // We have to Quote the next
            Remove (nPos, 1);         // character, so remove the
            copy-&gt;Remove (nPos, 1);   // slash and get the char.
            nPos++;
            break;
            
          case '.':                   // if we get a '.'
            if ((nPos) == 0)          // and it's the first char
              if ((*this)[1] == '*')  // and it's followed by a '*'
                {
                  Remove (2);         // Then we have a '.*' token.
                  copy-&gt;Remove (0, 2);
                  GotToken = 1;
                  ExpType = MultiWild0;
                }
              else if ((*this)[1] == '+')  // if followed by '+'
                {
                  Remove (2);         // Then we have a '.+' token.
                  copy-&gt;Remove (0, 2);
                  GotToken = 1;
                  ExpType = MultiWild1;
                }
              else
                {
                  Remove (1);          // we have a plain
                  copy-&gt;Remove (0, 1); // old '.' token.
                  GotToken = 1;
                  ExpType = Wild;
                }
            else
              {
                Remove (nPos);         // we have a literal token.
                copy-&gt;Remove (0, nPos);
                GotToken = 1;
                ExpType = Literal;
              }
            break;
          case '*':                 // if we get a '*'
            if (nPos == 1)          // and it's the second character
              {
                Remove (2);         // The we have a &lt;char&gt;* token.
                copy-&gt;Remove (0, 2);
                GotToken = 1;
                ExpType = MultiChar0;
              }
            else
              {
                Remove (nPos - 1);  // Or, we have a literal token.
                copy-&gt;Remove (0, nPos - 1);
                GotToken = 1;
                ExpType = Literal;
              }
            break;
          case '+':                 // if we get a '+'
            if (nPos == 1)          // and it's the second character
              {
                Remove (2);         // The we have a &lt;char&gt;+ token.
                copy-&gt;Remove (0, 2);
                GotToken = 1;
                ExpType = MultiChar1;
              }
            else
              {
                Remove (nPos - 1);  // Or, we have a literal token.
                copy-&gt;Remove (0, nPos - 1);
                GotToken = 1;
                ExpType = Literal;
              }
            break;
          case '$':                   
            Remove (nPos);          // the buck stops here.
            copy-&gt;Remove (0);       // And we won't have any kids.
            lastOnly = 1;
            GotToken = 1;
            ExpType = Literal;
            break;
          case '[':                 // if we get a '['
            if ((nPos) &gt; 0)         // and it's NOT the first char
              {
                Remove (nPos);      // we have a literal
                copy-&gt;Remove (0, nPos);
                ExpType = Literal;
                GotToken = 1;
              }   
            else                    // or we are beginning a range.
              nPos++;
            break;
          case ']':                 // when we get ']'
            if ((*this)[nPos + 1] == '*') // we may have [...]*
              {
                Remove (nPos + 2);
                copy-&gt;Remove (0, nPos + 2);
                GotToken = 1;
                ExpType = MultiRange0;
              }
            else if ((*this)[nPos + 1] == '+') // we may have [...]+
              {
                Remove (nPos + 2);
                copy-&gt;Remove (0, nPos + 2);
                GotToken = 1;
                ExpType = MultiRange1;
              }
            else        
              {
                Remove (nPos + 1);        // or just plain old [...]
                copy-&gt;Remove (0, nPos + 1);
                GotToken = 1;
                ExpType = Range;
              }
            break;
          case '{':                 // we have a brace
            if ((nPos) &gt; 0)         // and it's NOT the first char
              {
                Remove (nPos);      // we have a literal
                copy-&gt;Remove (0, nPos);
                ExpType = Literal;
                GotToken = 1;
              }   
            else                    // or we are beginning an 
                                    // Optional expression
              {
                nOffset = FindChar (Of, &quot;}&quot;);
                copy-&gt;Remove (0, nOffset+1);
                Remove (nOffset);
                Remove(0, 1);
                
                while ( (nOffset = FindChar (Of, &quot;|&quot;)) != NPOS )
                  {
                    (*this)[nOffset] = '\0';
                    lrChildren.AddItem (
                            new gpRegExp (*this, 0) );
                    Remove (0, nOffset+1);  
                  }
                lrChildren.AddItem (
                            new gpRegExp (*this, 0) );
                GotToken = 1;
                ExpType = Optional;
              }
            break;
          case '&amp;' :                // if we get ampersand
            if (nPos &gt; 0)           // and we've already got an atom
              {
                GotToken = 1;       // then we stop where we are
                ExpType = Literal;
                Remove (nPos);
                copy-&gt;Remove (0, nPos);
              }
            else
              {                     // otherwise, we are starting
                nDoICount = 1;      // a meaningful atom.
                Remove (0,1);
                copy-&gt;Remove (0,1);
              }
            break;      
          default: 
            // Just copy the character.
            nPos++;
          }
      }
    // Pass the rest along to the next atom.
    if (GotToken &amp;&amp; (*copy != &quot;&quot;))
        NextAtom = new gpRegExp (*copy, 0);
        // Flag this guy as NOT top level.
      
    if (copy)
        delete copy;  
  }
//------------------------------------------------------------------
//  Routine : operator== (gpString)
//  Function : sees if the given regular expression matches this gpString.  
//  Notes : Normally, the gpString may be longer than the regular
//          expression;  the comparison ends with the last character
//          in that expression.  However, if the last character of
//          the expression is '$', then an exact match is called
//          for, and the gpString may not have extra characters.
//------------------------------------------------------------------
int gpRegExp::operator==(gpString &amp;sExpress)
  {
    int nMin = 0;
    int lMatch = 0;     // Assume that the match will fail.
    int nPos;
    gpString sBuffer;
    char cBuffer;
    gpString sStringSaver;
    
    if (fTopLevel)
        sStringSaver = sExpress;
    sLastMatch = &quot;&quot;;
    switch (ExpType)
      {
        case Literal     : 
            nPos = sExpress.FindSubstring (cText);
            if ((firstOnly &amp;&amp; !nPos)||(!firstOnly &amp;&amp; (nPos != NPOS)))
              {
                sLastMatch = cText;
                sExpress.Remove (0, nPos);
                sExpress.Remove (0, Length () );
                lMatch = match_remainder (sExpress);
              }
            break;
        case MultiChar1  :
            nMin = 1;       // set our min chars to 1 and fall thru
        case MultiChar0  :
            nPos = sExpress.FindChar(NotOf,(*this)[0]);
            if (nPos == NPOS)
                nPos = sExpress.Length ();
            lMatch = DecrementingMatch(nMin, nPos, sExpress);    
            break;
        case Wild        : 
            if (sExpress.Length () )
              {
                sLastMatch = sExpress[0];
                lMatch = match_remainder(sExpress.Remove (0, 1) );
              }  
            break;
        case MultiWild1  : 
            nMin = 1;       // set our min chars to 1 and fall thru          
        case MultiWild0  : 
            nPos = sExpress.Length ();
            lMatch = DecrementingMatch(nMin, nPos, sExpress);    
            break;
        case Range       : 
            cBuffer = sExpress[0];
            cBuffer = toupper (cBuffer);    
            if ( (cBuffer &gt;= toupper(cText[LOWER_BOUND])) &amp;&amp; 
                 (cBuffer &lt;= toupper(cText[UPPER_BOUND])))
              {
                lMatch = match_remainder(sExpress.Remove (0,1));
                sLastMatch = cBuffer;
              }  
            break;
        case MultiRange1 : 
            nMin = 1;       // set our min chars to 1 and fall thru
        case MultiRange0 : 
            for (nPos = 0; 
                 (toupper(sExpress[nPos]) &gt;= 
                      toupper(cText[LOWER_BOUND])) &amp;&amp; 
                 (toupper(sExpress[nPos]) &lt;= 
                      toupper(cText[UPPER_BOUND]));
                 nPos++
                );
            lMatch = DecrementingMatch(nMin, nPos, sExpress);       
            break;                   
        case Optional  :
          { 
            gpString sBuffer(sExpress);
            if (lrChildren.Seek (sExpress))
                sLastMatch = lrChildren.Peek()-&gt;LastMatch();
            if ((lMatch = match_remainder (sExpress)) == 0)
              {
                sLastMatch = &quot;&quot;;
                lMatch = match_remainder (sBuffer);
              }
          }    
      }
    if (fTopLevel)
        sExpress = sStringSaver;
    return (lMatch);            
  }
// These helpers will keep trying to match a Multi-type atom.
// First, try to match as much as possible, then try to match
// the next atom.  If that atom succeeds, good.
// If not, we need to decrement our match string by one character
// and retry.  We do this until we have reached our minimum chars.
int gpRegExp::DecrementingMatch(int nMin, int nPos, gpString &amp;sExpress)
  {
    int lMatch = 0;
    gpString sBuffer;
    
    for (; !lMatch &amp;&amp; (nPos &gt;= nMin); nPos--)
      { 
        sBuffer = sExpress;
        sBuffer.Remove(0, nPos);
        lMatch = match_remainder(sBuffer);
      }  
    if (lMatch)
      {
        sLastMatch = sExpress;
        sLastMatch.Remove(++nPos);
      }
    return lMatch;         
  }
int gpRegExp::match_remainder (gpString &amp;sExpress)
  {
    int lMatch = 1;
    if (lastOnly)
      {
        if (sExpress.Length () )
            lMatch = 0;
      }
    else
      { 
        if (NextAtom)
            lMatch = ((*NextAtom) == sExpress);
      }    
    return lMatch;        
  }
//------------------------------------------------------------------
//  Routine : DumpParameters
//  Function : travers atom tree, creating list of meaningful parameters.
//------------------------------------------------------------------
void gpRegExp::DumpParameters (StringList &amp;lsParms)
  {
    if (nDoICount)
        lsParms.AddItem (new gpString (LastMatch () ));  
    if (NextAtom)
        NextAtom-&gt;DumpParameters (lsParms);
  }
//------------------------------------------------------------------
// The following code implements a List of gpRegExp's
// We keep it here because the Optional atoms use it.
//------------------------------------------------------------------
RegExpList::RegExpList ( ): List ()
  {
    pFirst = pLast = pCurrent = 0;
  }
RegExpList::~RegExpList ( )
  {
    for (gpRegExp *eRegExp = Reset ();
         eRegExp;
         eRegExp = GetNext ()
        )
         delete eRegExp;            
  }
gpRegExp *RegExpList::Seek (gpString &amp;sName)
  {
    int lFound = 0;
    Reset ();
    while (!lFound &amp;&amp; pCurrent)
      {
        if (*(Peek ()) == sName )
            lFound = 1;
        else
            GetNext ();
      }
    return pCurrent;
  }
gpRegExp *RegExpList::Seek (char *cName)
  {
    gpString sName (cName);
    return (Seek (sName) );
  }
gpRegExp *RegExpList::Reset ( ) 
  {
    return (pFirst = pCurrent = (gpRegExp *)List::Reset () );
  }
gpRegExp *RegExpList::GetNext ( ) 
  {
    return (pCurrent = (gpRegExp *)List::GetNext () );
  }
gpRegExp *RegExpList::AddItem (gpRegExp *eNew) 
  {
    pLast = pCurrent = (gpRegExp *)List::AddItem (eNew);
    if (!pFirst)
        pFirst = pLast;
    return (pCurrent);  
  }
gpRegExp *RegExpList::Peek ( ) 
  {
    return pCurrent;
  } 
gpRegExp *RegExpList::Seek (int nSequence)
  {
    if (nListSize &lt; nSequence)
        return 0;
    Reset (); 
    for (int i = 1; i &lt; nSequence; GetNext (), i++);
    return pCurrent;      
  }
gpRegExp &amp;RegExpList::operator[] (int nSequence)
  {
    return (*(Seek (nSequence)));
  }
void RegExpList::Clear ( )
  {
    for (gpRegExp *eRegExp = Reset ();
         eRegExp;
         eRegExp = GetNext ()
        )
         delete eRegExp;
    List::Clear ();
    pFirst = pLast = pCurrent = 0;
  }  
</pre>
<h4><a name="027f_00d7"><a name="027f_00d8"><a name="027f_00d8">Listing Three</h4><pre>
//------------------------------------------------------------------
// Syntax.cpp - Definition of the Syntax and SyntaxList classes.
// Copyright 1994 Prodis Incorporated.
// Purpose: The Syntax class pairs syntactic patterns (REs) with tokens (ints)
// Architect: AKJ
// Developer: AKJ
// Modification History:
//------------------------------------------------------------------
#include &lt;stdlib.h&gt;
#include &lt;parser\syntax.h&gt;
SyntaxList::SyntaxList ( ): List ()
  {
    pFirst = pLast = pCurrent = 0;
  }
SyntaxList::~SyntaxList ( )
  {
    for (Syntax *eSyntax = Reset ();
         eSyntax;
         eSyntax = GetNext ()
        )
         delete eSyntax;            
  }
Syntax *SyntaxList::Seek (gpString &amp;sName)
  {
    int lFound = 0;
    Reset ();
    while (!lFound &amp;&amp; pCurrent)
      {
        if ( (*(pCurrent-&gt;reSyntax)) == sName)
            lFound = 1;
        else
            GetNext ();
      }
    return pCurrent;
  }
Syntax *SyntaxList::Seek (char *cName)
  {
    gpString sName (cName);
    return (Seek (sName));
  }
Syntax *SyntaxList::Reset ( ) 
  {
    return (pFirst = pCurrent = (Syntax *)List::Reset () );
  }
Syntax *SyntaxList::GetNext ( ) 
  {
    return (pCurrent = (Syntax *)List::GetNext () );
  }
Syntax *SyntaxList::AddItem (Syntax *eNew) 
  {
    pLast = pCurrent = (Syntax *)List::AddItem (eNew);
    if (!pFirst)
        pFirst = pLast;
    return (pCurrent);  
  }
Syntax *SyntaxList::Peek ( ) 
  {
    return pCurrent;
  } 
//------------------------------------------------------------------
// Syntax object starts here:
Syntax::Syntax ()
  {
    reSyntax = 0;
    nToken = 0;
  }
Syntax::Syntax (gpRegExp *reExpress, int nNewToken)
  {
    reSyntax = reExpress;
    nToken = nNewToken;
  }
Syntax::Syntax (char *cExpress, int nNewToken)
  {
    reSyntax = new gpRegExp(cExpress);
    nToken = nNewToken;
  }   
</pre>
<h4><a name="027f_00d9"><a name="027f_00da"><a name="027f_00da">Listing Four</h4><pre>
// BasicMac.h - define tokens for the BASIC-Macro language.
// We need only include the FLOW.H file; it includes everything else we need.
#include &lt;parser\flow.h&gt;
// Function prototypes:
int EvaluateExpression (gpString &amp;sExpress);
gpFlowControl *BuildMacroEngine();
gpParser *BuildExpEngine( );
// These functions are prototyped, but not actually coded. These are just for 
// demonstration purposes, and need to be written in a production system.
int GetMacroLine (gpString &amp;sLine);
int RewindMacroSource (int nLine);
void ErrorHandler();
void SetVariableToValue (gpString &amp;p1, gpString &amp;p2);
void DoMenuItem (gpString &amp;p1, gpString &amp;p2, gpString &amp;p3);
void MessageBox (gpString &amp;p1, gpString &amp;p2, gpString &amp;p3);
void CallFunctionWithParms (gpString &amp;p1, gpString &amp;p2);
int CheckEquals (gpString &amp;p1, gpString &amp;p2);
int CheckGreater (gpString &amp;p1, gpString &amp;p2);
int CheckLessThan (gpString &amp;p1, gpString &amp;p2);
// Define our Tokens:
// We base each token on TK_USERDEF to avoid conflicts with predefined tokens.
#define TK_DOMENUITEM     (TK_USERDEF + 1)
#define TK_ASSIGN         (TK_USERDEF + 2)
#define TK_MBOX           (TK_USERDEF + 3)
#define TK_CALL           (TK_USERDEF + 4)
</pre>
<h4><a name="027f_00db"><a name="027f_00dc"><a name="027f_00dc">Listing Five</h4><pre>
// BasicMac.cpp - demonstration of using the Prodis Parsing Engine.
// Notes: We include BasicMac.h for our tokens, and it includes 
//   all other neccessary files.
#include &quot;basicmac.h&quot;
// Declare global variable, just for ease of demonstration
// flow control object for parsing input lines
gpFlowControl *fcMacEngine;
// parser object for parsing expressions
gpParser *pExpEngine;           
    
int main ( )
  {
    // Build the macro-language flow control object.
    fcMacEngine = BuildMacroEngine();
    // Build the expression parser object.
    pExpEngine = BuildExpEngine();
    gpString sLine;      // buffer for input lines
    int nLineNo, nToken; // line number, token
    StringList slParms;  // string list for holding parameters
    nLineNo = GetMacroLine(sLine); // Get the first line.
    
    // nLineNo will be zero when there are no more input lines.
    while(nLineNo)
      {
        // Parse the input line. The engine will return a token.
        nToken = fcMacroEngine-&gt;Parse(sLine, slParms);
        switch(nToken)
          {
            // no match was found for the line
            case TK_UNRECOGNIZED : 
                ErrorHandler();  //Send an error message
                break;
            case TK_ASSIGN :
                // first parm was the variable name
                // second parm was the value to set it to
                SetVariableToValue(slParms[1], slParms[2]);
                break; 
            case TK_IF :
            case TK_WHILE :
              { 
                // slParms[1] has the expression following the 'if'
                // or while. It must be parsed and evaluated.
                int IsTrue = EvalateExpression(slParms[1]);
                PostExpressionValue(IsTrue);
                break;
              }  
            case TK_DOMENUITEM :
                // The following function - not listed -
                // must implement the macro-language line :
                // DoCmd DoMenuItem [Parm1], [Parms2], [Parm3]
                DoMenuItem (lsParms[1], lsParms[2], lsParms[3]);
                break;
            case TK_MBOX :
                // The following function - not listed -
                // causes a Message Box to be displayed
                MessageBox(lsParms[1], lsParms[2], lsParms[3]);
                break;
            case TK_CALL :
                // The following function - not listed - 
                // Matches the first parameter with a 
                // function call and gets its arguments
                // from the second parameter.
                CallFunctionWithParms(lsParms[1], lsParms[2]);
                break;
            case TK_ENDWHILE :
                // When an ENDWHILE is returned, the first parameter
                // is the number of the line continaing the matching
                // WHILE clause, which will be re-evaluated.
                RewindMacroSource (atoi (lsParms[1]));
                break;
            case TK_ELSE :
            case TK_ENDIF :
                // We don't need to do anything here; gpFlowControl
                // will handle it all.  However, if we were 
                // interested, we could trap these lines.
                break;
          }
        nLineNo = GetMacroLine(sLine); // get the next line
      }
    return (1);           
  }
gpFlowControl *BuildMacroEngine( )
  {
    gpFlowControl fcNew = new FlowControl;
    
    fcNew.AddSyntax (&quot;^ *If +&amp;.+ +Then *$&quot;, TK_IF);
    fcNew.AddSyntax (&quot;^ *Else *$&quot;, TK_ELSE);
    fcNew.AddSyntax (&quot;^ *Endif *$&quot;, TK_ENDIF);
    fcNew.AddSyntax (&quot;^ *Let &amp;.+ *= *&amp;.+ *$&quot;, TK_ASSIGN);
    fcNew.AddSyntax (&quot;^ *While *&amp;.* *$&quot;, TK_WHILE);
    fcNew.AddSyntax (&quot;^ *WEnd *$&quot;, TK_ENDWHILE);
    fcNew.AddSyntax (&quot;^ *Call *MessageBox *(&amp;.+,&amp;.+,&amp;.+) *$&quot; , TK_MBOX);
    fcNew.AddSyntax (&quot;^ *Call *&amp;.+ *(&amp;.+) *$&quot;, TK_CALL);
    fcNew.AddSyntax (&quot;^ *DoCmd +DoMenuItem +&amp;.+,+&amp;.+,+&amp;.+ *$&quot;, TK_DOMENUITEM);
    return fcNew;
  }                                 
gpParser *BuildExpEngine( )
  {
    gpParser pNew = new gpParser;
    pNew.AddSyntax (&quot;&amp;.+ *= *&amp;.+&quot;, TK_EQUALS);
    pNew.AddSyntax (&quot;&amp;.+ *&lt; *&amp;.+&quot;, TK_LESS_THAN);
    pNew.AddSyntax (&quot;&amp;.+ *&gt; *&amp;.+&quot;, TK_GREATER_THAN);
    return pNew;
  }
int EvalExp (gpString &amp;sExpress)
  {
    int nReturn = 0;     //return value
    int nToken;          //token
    StringList lsParms;  //String list for parameters
    // parse the given line and get the token
    nToken = pExpEngine-&gt;Parse(sExpress, lsParms);
    switch (nToken)
      {
        //the line is : expression = expression
        //if the two expressions are equal, return TRUE
        case TK_EQUALS :
            if CheckEquals(lsParms[1], lsParms[2])
                nReturn = 1;
            break;
        //the line is : expression &gt; expression
        //if the first expression is greater, return TRUE
        case TK_GREATER_THAN :         
            if CheckGreater(lsParms[1], lsParms[2])
                nReturn = 1;
            break;
        //the line is : expression &lt; expression
        //if the second expression is greater, return TRUE
        case TK_LESS_THAN :                 
            if CheckLessThan (lsParms[1], lsParms[2])
                nReturn = 1;
      }
    return nReturn;  
  }
</pre>
<h4><a name="027f_00dd"><a name="027f_00de"><a name="027f_00de">Listing Six</h4><pre>
//------------------------------------------------------------------
// Syntoken.h - &quot;System&quot; Syntax tokens.
// Copyright 1994 Prodis Incorporated.
// Architect: AKJ
// Developer: AKJ
// Modification History:
//------------------------------------------------------------------
// Define &quot;non-language&quot; tokens:
#define TK_UNRECOGNIZED         0
#define TK_NOOP                 1
#define TK_REWIND               2
#define TK_COMMENT              3
// Define flow-control tokens:
#define TK_IF                   10
#define TK_ELSE                 11
#define TK_MISMATCHED_ELSE      12
#define TK_ENDIF                13
#define TK_MISMATCHED_ENDIF     14
#define TK_LABEL                15
#define TK_GOTO                 16
#define TK_WHILE                17
#define TK_ENDWHILE             18
#define TK_MISMATCHED_ENDWHILE  19
// Define Expression realational tokens:
// (These are just here because we ALWAYS seem to need them.)
#define TK_EQUALS               901
#define TK_NOT_EQUAL            902
#define TK_GREATER_THAN         903
#define TK_LESS_THAN            904
#define TK_GREATER_OR_EQUAL     905
#define TK_LESS_OR_EQUAL        906
#define TK_AND                  907
#define TK_OR                   908
#define TK_NOT                  909
// Define the base for &quot;user-defined&quot; (app-specific) tokens.
// Additional definitions should be of the form:
//      #define TK_SOMETOKEN  (TK_USERDEF + n)
#define TK_USERDEF              1000
End Listings

</pre>
<P>
<P>
<P>
<P>
<P>
<P>
<P>
<P>
<P>
<P>
<HR><P>Copyright &copy; 1995, <I>Dr. Dobb's Journal</I></P></BODY></HTML>
