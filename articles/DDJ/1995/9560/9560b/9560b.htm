<html><head><title>DDDU/Vol 2 No 10 October 95/ Tech Focus</title></head>
<body bgcolor="FFFFFF">
 


<H1>C/C++ Environments for Workstation Development</H1> 
 
<H3><i>by Tim Parker</i> </H3> 
 
<HR>
 
<p> 
 
Today's C/C++ development environments for workstation platforms
provide more than just a compiler. Typically, they also include an
integrated debugger, profiler, make utilities, graphical front end,
and more. In this article, I'll briefly examine a trio of tools for
the Solaris 2.4 operating system - CenterLine's CodeCenter, SunPro's
SPARCworks, and Hewlett-Packard's SoftBench. I used each toolset for a
minimum of two weeks as the sole environment to develop a number of
applications.<p>
 
<H3>SunPro SPARCworks 3.0.1</H3><p> 
 
SunPro's programming tools are the de facto toolset for any
Sun
platform. SPARCworks is the SunPro integrated development toolset that
sits on
top of SunPro languages. All the SPARCworks tools employ a common
interface
appearance (as you would expect with an integrated tool). The pop-up
menus are,
for the most part, self explanatory, and experienced programmers can
quickly
work their way through the SPARCworks system. <p> 
 
SPARCworks is controlled through a Manager dialog, which contains icons
for all
the parts of the product. Individual components of the system are
launched from
the Manager. You can also use SPARCworks from a shell window instead of
from
the Manager, but there is no benefit to that approach. You can add
projects and
tools to the Manager window to allow for easier access.<p> 
 
The toolset supplied with SPARCworks includes all the expected
components.
MakeTool uses a simple set of dialogs to control the make
utility's
use. The Properties window allows you to hide certain aspects of a
makefile
from the browser's display to simplify your view. For example,
you can
make it easier to navigate through your makefile by hiding any
statements that
define conditional macros or implicit rules.<p> 
 
The Debugger window has a source browser that takes up the majority of
the
default window, a command pane at the bottom, and buttons arranged in
two
groups: one at the top and one below the source browser. A pop-up
program I/O
browser can be added to the bottom of the window. Breakpoints are
handled
easily, with icons in the source browser showing their current
condition.
Breakpoint behavior is much the same as in any integrated debugger. A
backtrace
command and window lets you see the call stack.<p> 
 
A couple of useful features are buried in the debugger. A postbreak
modifier,
for example, allows you to instruct the debugger to test for a
condition after
a tracepoint or breakpoint has been hit. Only if the condition is
evaluated as
True is the execution halted. This can speed up testing of programs
where
conditions at breakpoints vary. You can also intercept and handle
signals, even
those that would normally cause a halt, by overriding the signal,
permitting
execution to continue. A thread viewer lets you see multithreaded
program
information cleanly.<p> 
 
The Visual Data Inspector (VDI) is available to Solaris 2.x users. It
lets you
track and display variables and data structures graphically. Launched
from the
debugger, VDI offers a pop-up window with basic information about a
variable,
such as its address and value. A pointer to other dependent variables
may be
available as well.<p> 
 
Performance data can be collected and analyzed (Solaris 2.x only). The
Collector lets you set the parameters for collecting information,
including the
resolution of the collection. Sampling of an executing program can be
automatic
or manual, allowing you to take performance snapshots at selected
times,
triggered from the keyboard. The Analyzer shows the results of the
collected
data, with bar graphs set as a default display mode for execution
information.
Information can be graphed for several different criteria.<p> 
 
For development teams, there's TeamWare, a set of utilities
that
manage simultaneous development. TeamWare is based on SCCS, managing
the
fileset of an application through simple windows. TeamWare is easy to
work with
and should pose no problems for any developer who has used a version
control
system and Make before. The ParallelMake utility in the toolset allows
compilation of large applications to be spread over a
workgroup's
available machines.<p> 
 
<H3>Hewlett-Packard C/C++ SoftBench 4.0</H3> <p> 
 
While HP's SoftBench is best known to users of HP 9000
workstations,
it is also available on platforms such as Solaris. The main difference
between
the versions (other than the look of the GUI) is the use of native
compilers - SoftBench for Solaris uses the SunPro (or any other C
compiler) that resides on the Sun machine. There are three different
versions
of SoftBench: The version to use depends on the language used. Although
they
don't differ dramatically in use, the tools are optimized for
the
supported language.<p> 
 
The SoftBench toolset is augmented by Encapsulator, a tool designed to
let you
add a SoftBench-style interface to applications. It also lets you
communicate
with the Broadcast Message Server (BMS), watching communications
between
applications. Some third-party development tools are distributed with
embedded
Encapsulated SoftBench code, making their use with SoftBench more
integrated
and efficient.<p> 
 
SoftBench is composed of about half a dozen primary utilities
integrated under
the Tool Manager, which shows the current status of each active tool,
and
allows control of context settings and other configuration information
for the
entire toolset. The Tool Manager window is not icon-based but uses
pull-down
menus for most functions. Learning SoftBench is made easier by a
computer-base
training (CBT) session that works through many aspects of the SoftBench
system
and shows you how to use SoftBench in application development.<p> 
 
You can use the integrated editor, or call your favorite editor.
SoftBench
includes both the SoftBench Program Editor and an encapsulated version
of vi,
tightly wound into the SoftBench toolset. Other editors, like Emacs,
are also
supported but are not as tightly wound with the entire development
toolkit. On
the whole, vi users will find SoftBench familiar.<p> 
 
The Development Manager handles files and directories, including
network-wide
resources. It also functions as an interface to some other tools, like
the
version-control system. The Program Builder handles compilation and
linking
(make). The C SoftBench tools are a debugger and Performance Analyzer.
The C++
Developer is a C++-specific tool for developing OO programs and
providing rule
checking functions. <p> 
 
SoftBench handles Source-code control based on a user-specified system.
For
example, most Solaris users will employ SCCS, but HP-UX users will
prefer RCS.
Other tools are also supported by SoftBench, including FSF's
CVS
(which is, essentially, multiuser RCS).<p> 
 
SoftBench users who run under HP-UX (but not Solaris) have a choice of
two
debuggers. The default debugger is DDE (Distributed Debugging
Environment)
based, while HP-UX makes the xdb debugger available, too. Either (or
both) can
be used on HP-UX platforms. The xdb debugger is provided primarily for
those
who have experience working with earlier versions of SoftBench. For HP
workstation users, SoftBench also combines beautifully with VUE.<p> 
 
The debugger is talented, offering all the features one would expect
from an
integrated tool. The debugging window is laid out cleanly, with a row
of
commonly used debugger buttons in the center of the window below the
source
browser. Tracepoints, breakpoints, and watchpoints are all cleanly
handled and
the output dialogs provide good information about the triggering code
or
condition. Dynamically loaded libraries are nicely managed by
SoftBench.<p> 
 
Tracing is handled well, supporting several levels of granularity,
including
procedure entry, procedure exit, statement, and assembly instruction.
This lets
you "zoom in" to program flow to examine particular
actions in
intricate detail, or reduce the level, and watch procedure calls. A
more-traditional call stack is also available.<p> 
 
Code analysis with SoftBench is performed by two tools. The Static
Analyzer
examines code for calls, function and procedure names, global
variables,
identifiers, and so on. These are easily viewed and can serve as a good
reference or design document. The Performance Analyzer is a run-time
analyzer,
providing time-based analysis. The graphics are somewhat simplistic. It
is text
based, relying on columns of data for its results window. A graphical
output
option would have been better.<p> 
 
One of the useful aspects of SoftBench is the ability to monitor all
intertool
communications with the message monitor. In case of problems, the
Message
Monitor is an easy diagnostic step. SoftBench includes a few utilities
that
have been designed with SoftBench integration in mind, such as
SoftBench Mail,
an e-mail package similar to mail that has a SoftBench-style interface.
An SQL
interface is also included.<p> 
 
<H3>CenterLine CodeCenter</H3><p> 
 
Built upon CenterLine's C and C++ compilers, CodeCenter adds a
tightly
integrated suite of development tools. CenterLine compilers are bundled
with
CodeCenter.<p> 
 
Most of the operation of CodeCenter is through the main window, which
also
functions as browser and debugger. The immediate impression is that
CodeCenter
doesn't include a full set of development tools, although this
impression is, for the most part, misleading. There are only a few
windows
involved in the CodeCenter toolset. This makes for a clean screen
layout: You
don't miss the plethora of windows that must be zoomed and
closed as
the different tools are called.<p> 
 
You are given your choice of editor, although all CodeCenter functions
are
surprisingly well integrated with Emacs, making it the editor of
choice.
Source-code control is through third-party tools such as SCCS or RCS.
Applications are controlled through the Project-Level Browser, which
tracks all
the code used in a project and manages access and versioning.<p> 
 
The core of the tool is, not surprisingly, the debugger, which provides
the
usual arsenal of tools. Aside from the breakpoints, actionpoints, and
watchpoints, CodeCenter allows conditional branching to code developed
in the
Interactive Workspace. This helps you test fixes, display test results,
or
verify that procedures are working as expected. It is also useful for
testing
alternate coding methods. The Data Browser is integrated with the
debugger,
providing a look at data structures and identifiers and their
references to
others. The Cross-Reference Browser shows interrelationships in a
useful,
graphical manner.<p> 
 
The Error Browser displays results from CodeCenter's code
testing. The
parser manages excellent code checking, catching errors that the usual
UNIX
code checkers pass through. It checks inconsistencies across large
applications
spread over many files. Error checking is both static and run-time,
with a very
good logging utility.<p> 
 
A neat feature of CodeCenter is the Interactive Workspace, which lets
you enter
a few lines of code and execute them as a fragment without all the
supporting
code. This lets you write tricky sections of code a few lines at a
time,
testing out the program as you go. Each section of code is linked
incrementally, with full error checking. This is like a smart
interpreter, and
provides a novel method for both learning C and developing complex
procedures.<p> 
 
<H3>Conclusion</H3><p> 
 
Which tool would I recommend? It comes as no surprise that this depends
on the
project you're developing. If you have a team-based
development
project, SunPro's SPARCworks with TeamWorks is a solid,
reliable
multiple-user environment. For small applications, CodeCenter is a good
choice,
offering speed and features for quick-and-dirty programming that the
others
don't have. For larger applications, SoftBench provides
excellent
messaging, integration, a powerful debugger, and a useful profiler.<p> 
 
Overall, SPARCworks and CodeCenter are more graphical than SoftBench.
SoftBench's Tool Manager interface is not as attractive to
work with
as SPARCworks' icon-driven Manager. While I found the
icon-based
windows preferable both from a usage and appearance point of view, this
really
doesn't affect the development process.<p> 
 
SPARCworks' graphical approach to tools like the analyzers is
also
notable, especially compared to SoftBench and CodeCenter. I really
liked the
SPARCworks analyzer and found I used it more often to optimize code
than I did
the other two tools' analyzers.<p> 
 
<HR ALIGN="center" WIDTH="33%"> <p>
 
Tim is the author of <I>Linux Unleashed</I> (Sams, 1995). He can be contacted
at
tparker@tpci.com.<p> 
 


</body>
</HTML>
