<HTML>
<META NAME="year" CONTENT="1995">

<HEAD>
<TITLE>AUG95: LETTERS</TITLE></HEAD>
<BODY BGCOLOR="#ffffff">
<h1>LETTERS<a name="0086_0001"></h1><P>
<h3><a name="0086_0002">C and History <a name="0086_0002"></h3><P>
Dear <I>DDJ</I>,<P>
Regarding Al Stevens' inquiry as to the choices behind the current structure of C parameter declarations (&quot;C Programming,&quot; <I>DDJ</I>, December 1994).<P>
Functions in K&amp;R C had arguments typed with <I>parameter-declaration</I>, allowing <a href="#0086_0006">Example 1(a)</A>. The argument would effectively be &quot;moved&quot; into register storage by the compiler. Prior to this arrangement (predating K&amp;R C), you had to do this manually; see <a href="#0086_0006">Example 1(b)</A>. In other words, this was an improvement in the language. (Early C compilers used many compromises of this ilk.) ANSI C, of course, uses <a href="#0086_0006">Example 1(c)</A>.<P>
When ANSI C came on the scene, compilers were allowed to intermix K&amp;R argument-declaration syntax with that of ANSI for backwards compatibility. Declaration semantics thus must be interchangeable. (All ANSI compilers will balk at this.) <P>
With declaration syntax set, prototypes <I>must</I> again use the same syntax, since they may be generated by automatic means. (It would be unwise to have different ones, although in effect, compilers restrict you to a &quot;specifier qualifier list.&quot;) However, in the case of prototypes, the point Al was making is well taken.<P>
In fact, we could take this inquiry further. For example, what if we were to extend the language and add new storage classes? Might these be desirable to include in a prototype? For that matter, could there be an advantage in allowing a function prototype to enforce a &quot;register&quot; storage class in a prototype (meaning that the argument was always passed via register)?<P>
One of the great strengths of C is that it permitted an implementor a good degree of latitude in exploiting machine architecture. Unlike PL/I, C attempts to be more of a high-level assembler than a high-level language. While PL/I allowed a rich set of operations to be embedded in the language itself, use of those features could involve considerable run-time overhead that the programmer needed to be aware of. However, with C, all of the operations typically matched the machine language almost one for one. (Many PL/I compilers of the time would detect and &quot;fix&quot; typing errors, allowing you to run programs with significant errors in the code. This went loggerheads with the obsessive type-checking of Pascal, which would flat-out refuse to execute any imperfect code--so much for the differences between the then &quot;old&quot; and &quot;new&quot; schools.)<P>
In sum, C's role as a language is tightly tied to low-level implementation details, so that the syntax and semantics of variables must be fluid enough to match machine characteristics of the future. This is completely unlike &quot;big&quot; high-level languages, which attempt to offer versatility for the price of the same old complexity we've seen before.<P>
Incidentally, what Al describes as &quot;C minus minus&quot; reminds me a lot of the B programming language. (B, the predecessor of C, was an inspired approximation of the Bootstrap Cambridge Programming Language, BCPL.) B was revived by Mark Horton (then at the University of California at Berkeley) for his thesis work on a language editor (bedit) that merged the concepts of text editor and incremental compiler. The language was simplified from C to allow for incremental parsing and &quot;code&quot; generation as the program was being composed in the editor (thus, it always was immediately syntax-checked and runable). In effect, it worked much like Microsoft's Visual products (which may not take the concept quite as far).<P>
The code was part of past Berkeley BSD releases (in the /usr/src/contrib directory) and is probably still available on the Internet.<P>
Bill Jolitz<P>
Oakland, California<P>
<h3><a name="0086_0003">More FFTs<a name="0086_0003"></h3><P>
Dear <I>DDJ</I>,<P>
In his article &quot;Faster FFTs&quot; (&quot;Algorithm Alley,&quot; <I>DDJ</I>, February 1995), Iwan Dobbe describes a fast radix 2 FFT algorithm for complex data. It is good to see some numerical-methods articles in <I>DDJ</I>; I hope we will see more. Here are a couple of minor changes that can be used to improve speed and accuracy.<P>
A small improvement in speed may be had by noting that in the routine <I>Shuffle2Arr</I> data is only swapped if the bit-reversed number is greater than the index. This means that you can avoid the unnecessary calls in <a href="#0086_0007">Example 2(a)</A> by using <a href="#0086_0007">Example 2(b)</A>. This works because all the numbers after 2<SUP>b</SUP>-2<SUP>((b+1)/2)</SUP> will become smaller (or remain the same) when bit reversed. Unfortunately, the savings are not great because the array shuffle is a minor component of total time. I liked the idea of tabulating the sin and cos coefficients.<P>
The second improvement involves the best way to generate the Q<SUP>k</SUP> phase factors by recurrence relation. This is worth optimizing because with large transforms, the numerical rounding errors accumulate quickly. Classical wisdom is to use double precision for the Q<SUP>k</SUP> relations. Starting from <a href="#0086_0007">Example 2(c)</A> and using the identity in <a href="#0086_0007">Example 2(d)</A> instead of using <I>cos(x)</I> directly, you can minimize rounding errors, as in <a href="#0086_0007">Example 2(e)</A>.<P>
Finally, and most interesting, because the coefficients have been stored in a table, it is possible to optimize them to minimize the rms error in the FFT phase factors, allowing for real truncation. This has to be done on the target hardware platform.<P>
Basically the idea is to minimize the difference between phase factors computed by recurrence and the true trigonometric functions. To do this, work out all the exact phase factors once using double-precision, standard trigonometric functions, then truncate to real precision and save them in arrays TQr[], TQi[]. Set initial values for s, s2, Qr[0], and Qi[0]. Generate Qr[], Qi[] using the recurrence formulas. Compute the chi-squared error in <a href="#0086_0007">Example 2(f)</A>. Then use any minimization routine that depends <I>only </I>on function evaluation (that is, Golden section search) to optimize chi-squared by varying the initial starting values and recompute Qr, Qi (a search range of +1e-6 is plenty). For example, calculated on a 486DX2, the chi-squared error made by using the recurrence relations instead of explicit trig functions works out as illustrated in <a href="#0086_0008">Table 1</A>.<P>
In other words, by optimizing the coefficients, you can decrease the rms errors by a factor of 60 for long transforms (=1.8 extra sig. fig.). Just put the optimized values for s and s2 into the coefficient tables. It is only worth optimizing if you will compute a lot of big FFTs. This is a useful gain in accuracy for signal-processing work.<P>
It is also worth mentioning that many experimental datasets are real, rather than complex data, and there is a useful trick to transform a real dataset to a complex conjugate symmetric form. (See, for example, <I>Numerical Recipes in C</I>.)<P>
Martin Brown<P>
East Rounton, England<P>
<h3><a name="0086_0004">Interoperable Objects<a name="0086_0004"></h3><P>
Dear <I>DDJ</I>,<P>
I read with interest the articles in <I>Dr. Dobb's Special Report on Interoperable Objects</I> (Winter, 1995). As a developer in a large corporation, I am very interested in choosing a technology to rebuild our applications for the hardware of today and tomorrow. We have found out the hard way that it is impossible to keep a business-application portfolio up to date without a great deal of reuse. The easiest way to write a new transaction may be to copy an old one, but it is impossible to keep hundreds of them up to date with the needs of the business.<P>
I am being asked to deliver new business functions to the users within a couple of weeks of the request. If someone is already marketing an object with the function I need, then there is no problem. But what if the best available object has only 90 percent of the function? What if I need to modify an object in some way? What if I need to develop it from scratch?<P>
I look for a few fundamental criteria in a software technology. Can it do what I want? How many lines of code will I have to write? How independent are the objects? How likely is it to succeed in the marketplace?<P>
I would give Microsoft OLE a high score on the last point. I expect that it will not be too long before I use some OLE components in a business application. But regardless of what Microsoft says, I believe that object-oriented technology with inheritance is the easiest way to reuse code. If an object has 90 percent of the function I need, then I get all that function with a few lines of code. I only need to write the 10 percent that is different. In my case, transactions, a large portfolio of similar objects, makes this especially powerful.<P>
The biggest shortcoming of object-oriented development tools has been the matter of independence. With SOM offering binary compatibility between different versions of an object, this problem is reduced. I can modify a SOM object that I bought without having access to its source code. I write a new object that inherits from the original one and override the methods I need to modify. The base class or the derived class can be changed without having to recompile the other.<P>
In short, Microsoft can say &quot;The problem with...&quot; all it wants. SOM seems to me to be the best available technology for me to begin to build systems that can keep up with the needs of the business.<P>
Ron Brubacher<P>
London, Ontario<P>
<h3><a name="0086_0005">Ewoes<a name="0086_0005"></h3><P>
Dear <I>DDJ</I>,<P>
Regarding &quot;Swaine's Flames&quot; in the March, 1995 <I>DDJ</I>: In medieval times, church was people's television, rock concert, and ball game all in one. Not only had the sermons (and writings and teachings) gotten self referential (religion talking about religion) but they were in Latin, a language most people did not even understand. Yet, people kept going to the show that the church gave. <P>
The most powerful institution of its day had created a totally artificial, self-referential reality in which people actually lived--they thought those things were real, and they saw their real lives in terms of these artificial creations.<P>
I think our popular culture is headed in the same direction. Writers write about writers. Violence in [Quentin] Tarantino's movies is inspired by violence he'd seen in other movies, and so on. You get e-mail about e-mail. These are baby steps, but as less and less time is spent feeding us and keeping us dry and warm, we can afford to create yet another artificial world. But this time the technology is going to be a lot better, so it is going to be a lot more real. Cathedrals are nothing compared to what we are going to build next. <P>
Wilhelm Sarasalo <P>
pacsoft@netcom.com<P>
Dear <I>DDJ</I>,<P>
I'm sorry to hear that Michael Swaine's elife collapsed under the estrain of the eresponses to his emoticontest. If I had had any suspicion that he was still taken of the madness that he could, as an ecelebrity, expect to eread and eanswer even a modest portion of his email, I would have eoffered a more friendly and voluble eletter than my (correct, eattached) eentry of November 8.<P>
Upon reading the March 1995 &quot;Swaine's Flames,&quot; I have decided to ewrite this emissive and esend it redundantly to you and the <I>DDJ</I> editors, to help limit the erisk that you might elose this one!<P>
Even if this isn't the right answer, the emoticons bear an uncanny resemblance to Siskel and Ebert.<P>
Lyle Wiedeman<P>
wiedeman@altair.acs.uci.edu<P>
<a name="0086_0006"><B>Example 1:</B> C and History.<a name="0086_0006"><p>
<pre>
(a) foo(a)
      register int a;
    {
      ...
    }

(b) foo(a)
      int a;
    {
      register int ra;
      ra = a;
      ...(code uses ra instead of a)
    }

(c) foo(register int a)
    {
      ...
    }
</pre>
<a name="0086_0007"><B>Example 2:</B> More FFTs.<a name="0086_0007"><p>
<pre>
(a) do
    {
        N = N*2;
        bitlength = bitlength-1;
    }  while (bitlength &gt;0)
    for (IndexOld = 0; IndexOld &lt;= N-1; IndexOld++)
    {....

(b) N =  (1&lt;&lt;bitlength) - (1&lt;&lt;((1+bitlength)/2));
    for (IndexOld = 0; IndexOld &lt; N; IndexOld++)
    {....

(c) c = cos(x); s = sin(x);  /* from table */
    temp = Qr;
    Qr   = Qr*c - Qi*s;
    Qi   = Qi*c + temp*s;

(d) cos(x) = 1 - 2.(sin(x/2))^2

(e) s2 = 2*(sin(x/2))^2 ;   /* from table - replaces c */
    temp = Qr;
    Qr   = Qr - Qi*s - Qr*s2;
    Qi   = Qi + temp*s - Qi*s2;  /* note this adds two extra
                                             subtractions */

(f) for (i=0; i&lt;= N; i++)
    {
    dr = (TQr[i]-Qr[i]);
    di = (TQi[i]-Qi[i]);
    chisq = chisq+ dr*dr + di*di
    }
</pre>    
<a name="0086_0008"><B>Table 1:</B> More FFTs.<a name="0086_0008"><p>
<pre>
Size       Original (c,s)  Modified (s2,s)  Optimized (s2,s)
   28        1.05E-11         5.83E-12       4.06E-14
 1024        6.90E-10         4.49E-10       2.17E-13
16384        5.83E -7         1.10E-7        1.49E-10
</pre>

<HR><P>Copyright &copy; 1995, <I>Dr. Dobb's Journal</I></P></BODY></HTML>
