<HTML>
<META NAME="year" CONTENT="1995">

<HEAD>
<TITLE>FEB95: PROGRAMMER'S BOOKSHELF</TITLE></HEAD>
<BODY BGCOLOR="#ffffff">
<h1>PROGRAMMER'S BOOKSHELF<a name="00e8_0040"></h1><P>
<h2><a name="00e8_003e"><a name="00e8_0000">SOM/DSOM and Object-Oriented Programming</h2><P>
<h3>Steve Gallagher</h3><P>
<p><i><a name="00e8_003f"><a name="00e8_0000">Steve is president of G&amp;A Consultants, an OS/2 consulting firm located in Research Triangle Park, NC. He can be contacted at sgallagher@delphi.com.</i></p><hr><P>
There's little question that the push for distributed component objects will accelerate over the coming months and years. As Mark Betz pointed out in his article, &quot;Interoperable Objects&quot; (<I>DDJ</I>, October 1994), the goal of component objects is to encapsulate all the ugly stuff--platform interfaces, communication protocols, language specifics, and addressing--to the point that it's not only transparent to the user, but to the programmer as well. The individual language-specific object model becomes irrelevant in this paradigm, thanks to a language-independent Interface Definition Language (IDL). In my opinion, IBM's System Object Model (SOM/DSOM) packs the gear to deliver what is needed now, as opposed to approaches such as Microsoft's Common Object Model and Object Linking and Embedding (COM/OLE), which are hobbled by the absence of distributed capability and limited to Windows only. Among other benefits that SOM/DSOM provides are: <P>
<UL>
<li>No more recompiling. As things stand now, C++ programmers must recompile every time the header file for the class library they're using is changed. With SOM, classes can undergo major structural changes, but as long as no changes to the source are needed, your application can continue to use the changed class library without a recompile.</li>
<li>Language neutrality. By providing a language-neutral object model, SOM enables classes built in Smalltalk to be used in a C++ program, and vice versa. The potential for code reuse and object sharing across language barriers is exciting to anyone who has had to code up some classes from ground zero when a perfectly outstanding set of classes to do the job existed--in another language.</li>
<li>Address space no longer matters. The objects you use can exist in a totally different address space, and objects deployed in a single environment are available to other machine environments.</li>
<li>CORBA++. With the latest version of SOM, IBM dropped OIDL, its object-based Interface Definition Language, in favor of full compliance with CORBA's IDL. IBM also added private methods, implementation statements, and instance variables.</li>
</UL>
Using other people's DLLs is nothing new; the idea of using someone else's classes--possibly written in a different language, running on a different machine, riding on top of a different operating system--takes some getting used to. But get used to it we must. The exponential increases in software-development complexity demand SOM, or something like it. <P>
<h3><a name="00e8_0041"><I>Object-Oriented Programming Using SOM and DSOM</I><a name="00e8_0041"></h3><P>
<I>Object-Oriented Programming Using SOM and DSOM</I>, by Christina Lau is both an enjoyable and enlightening introduction to SOM. Lau makes sense out of the often bewildering array of acronyms associated with the subject--DSOM, PSOM, IR, and the like--in a style that is simple, direct, and forthright. The book assumes a working knowledge of C and C++ and a grasp of object-oriented concepts. Given this as a base, you will be taken at a reasonable pace through SOM's various flavors. <P>
Lau begins with a solid introduction that gives you a one-page answer to the question, &quot;What is SOM?&quot;. IBM should make photocopies of this page and mail it to every programmer on the planet. The rest of the introductory chapter provides details that include concise explanations for the concepts of language neutrality, the IDL, SOM kernel, various SOM Frameworks, and collection classes. You also learn the CORBA baseline and the ways in which SOM extends the base. After developing a &quot;Hello World&quot; program using SOM, Lau takes you into the world of SOM objects. If you are familiar with OO concepts, you won't be intimidated when you meet <I>SomClass</I> (&quot;the mother of all classes&quot;), the detailed explanation of the difference between parent classes and metaclasses, and SOM's various schemes for dealing with method resolution. <P>
After explaining the advantages of SOM over stand-alone C++ and providing an excellent tutorial on DSOM concepts, Lau uses a &quot;Daily Planner&quot; applet to get to the heart of the matter. The requirements for the Planner are that it allow addition/deletion of items by multiple users on a network and that changes to any user's instance of the planner show up in real time on all other users' Planners. This is an ideal test project for working through SOM's various Frameworks. Using traditional programming methods to build a stand-alone Planner is boring; distributing or sharing that same Planner can be Byzantine, however. The SOM Frameworks make it relatively painless. Once you have built the base Planner using SOM, you find that by using DSOM you are able to register multiple Planner servers to enable distributed access across a network. Compared to traditional methods, DSOM enables this capability with surprisingly little code.<P>
Still, when the server process terminates, the states of the various Planner objects are not preserved. The Persistent SOM Framework (PSOM) comes to the rescue by allowing you to preserve the state of an object, even after the process that created the object terminates. You are able to store the object to a file, or some other method of persistent storage. PSOM requires that all Persistent objects be derived from a Persistent class, and the Persistent data must be explicitly spelled out. This is in contrast to DSOM, where a given object does not have to know in advance that it is going to be distributed. Once you derive your Persistent object from the <I>SOMPersistentObject</I> class, the rest is surprisingly straightforward.<P>
If you have multiple users sharing a Planner, any change one user makes to a Planner is not automatically reflected on other users' Planners. The Replicator SOM (RSOM) Framework is designed to propagate an update to a given object to all other replicated objects. Updates are propagated directly to the other objects, without the use of secondary storage. RSOM is the ideal Framework for groupware applications, such as real-time creation of compound documents, without the traditional bottleneck of a database server. In common with the PSOM Framework, RSOM objects are required to be RSOM-aware objects derived from the <I>SOMRreplb</I> class. After reviewing several important rules that replicated objects need to adhere to, Lau declares the Daily Planner applet complete. Different design decisions you could make in real-world situations are then reviewed: For example, should you use DSOM or RSOM? If you are programming to a single operating environment, RSOM's complete object-replication capability is ideal. Unfortunately, RSOM does not talk across different operating environments; in a situation where this is required, DSOM is the logical choice.<P>
Lau concludes with an insider's view of the future direction of SOM. Plans are afoot to port SOM to Windows, System 7, HP UNIX, and OS/400. Additionally, IBM is furiously developing SOM relationships with vendors as diverse as Hewlett-Packard, Digitalk, and Watcom. In the words of the Timbuk 3<B> </B>song, &quot;The future's so bright, I gotta wear shades.&quot;<P>
<h3><a name="00e8_0042"><I>Objects for OS/2</I><a name="00e8_0042"></h3><P>
As a consultant with a need to keep abreast of the latest technology, I found <I>Object-Oriented Programming with SOM and DSOM</I> to be the most solid &quot;platform-neutral&quot; introduction I've read. As a working programmer who cranks out OS/2 Presentation Manager code for a living, <I>Objects for OS/2</I> was the perfect follow-up that allowed me to take the generic SOM concepts and ground them in the OS/2 world I live in every day. Authors Danforth, Koenen, and Tate take you on a bit-twiddler's dream tour of OS/2's innards, tying it neatly into the application of SOM to real-world Presentation Manager (PM) programming scenarios. <I>Objects for OS/2</I> begins with a competent, basic tutorial on object-oriented programming, written on a level that will gently lure in the novice without putting the battered veterans to sleep. In several chapters crammed with useful source code, you are brought up to speed on the OS/2 kernel, the PM API, and GPI. This is by no means a definitive reference on these aspects of OS/2 programming, but it does lay the groundwork and serve as a solid overview.<P>
From here, you move into the realm of OS/2 C++, and the authors begin developing their persuasive arguments as to why they consider SOM to be such an important technology as it relates to C++. This exposition leads naturally into the three big chapters devoted exclusively to learn-by-example SOM programming under OS/2. The samples begin at a basic level so as not to intimidate the novice, then move down into the nuts-and-bolts level of hard-core OS/2 SOM programming. The subjects of SOM multiple inheritance and metaclasses are dissected in depth, followed by an outstanding summary of the entire SOM API. By this point you should be comfortable with SOM concepts and the API and be fully prepared to grapple with the next large portion of the book, devoted to working up various coding projects with SOM. Starting with an amusing variation on the traditional &quot;Hello World&quot; program, you rapidly progress to the fun stuff--the powerful combination of SOM and PM. The authors build a solid framework combining the flexibility of PM and the elegance of SOM, including an outstanding chapter on &quot;wrapping&quot; PM controls within SOM. This extensive tutorial, along with the code diskette that ships with the book, are worth enough on their own to justify the price of the book. <P>
<I>Objects for OS/2</I> delivers on its promise of getting the OS/2 programmer up and running with SOM, although I would have preferred a bit more depth on DSOM and possibly a section describing the innards of the biggest SOM project to date--the Workplace Shell. Nonetheless, <I>Objects for OS/2</I> is broad enough and solid enough that I expect it will develop its own large following of devotees, much the way Petzold's PM book and Orfali and Harkey's client/server book (<I>Client/Server Survival Guide</I>, Van Nostrand Reinhold, 1994) already have.<P>
<h3><a name="00e8_0043">Wrapping It Up<a name="00e8_0043"></h3><P>
As you may have guessed, these two books complement rather than compete with each other. You should read <I>Object-Oriented Programming with SOM and DSOM</I> for the best understanding of the concepts you're likely to find. Then you should turn to <I>Objects for OS/2</I> to enable you to take those concepts and apply them to real-world OS/2 programming problems.<P>
I don't normally read author biographies until after I've finished a book, so I was impressed to find that both books were written by IBMers, thus proving that IBM does have talented and articulate people who can put pen to paper and explain often-difficult concepts in ways we regular folks can both comprehend and enjoy. It's dang good stuff for the industry that IBM is finally making it easier for its &quot;wild ducks&quot; to come out and play with the rest of us kids.<P>
<h4>Object-Oriented Programming with SOM and DSOM</h4><P>
<h4><I>Christina Lau</I></h4><P>
<h4>VNR, 1994, 272 pp., $36.95</h4><P>
<h4>ISBN 0-442-01948-3</h4><P>
<h4>Objects for OS/2</h4><P>
<h4><I>Scott Danforth, Paul Koenen, and Bruce Tate </I></h4><P>
<h4>VNR, 1994, 446 pp., $36.95 </h4><P>
<h4>ISBN 0-442-01738-3</h4><P>
<P>
<HR><P>Copyright &copy; 1995, <I>Dr. Dobb's Journal</I></P></BODY></HTML>
