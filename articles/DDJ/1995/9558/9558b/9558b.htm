<html><head><title>DDDU/Vol 2 No 8 August 95</title></head>
<body bgcolor="FFFFFF">



<H1>Eurocrypt '95</H1>

<H3><i> by Bruce Schneier</i></H3>
<p>
Eurocrypt '95 was held a few weeks ago in St. Malo, in Brittany on the
northern coast of France. This was the most international Eurocrypt ever, with
over 350 participants from countries such as Russia, Rumania, Brazil, South
Africa, Bulgaria, Singapore, and the Czech Republic. It was a great conference
in a beautiful location (with more wine than you normally see at cryptography
conferences).<p>
The 33 papers presented were generally of high quality, although there were no
major revelations. From my perspective, the two most clever ideas came from the
rump session. (Rump sessions are reserved for unique ideas and works in
progress. This year, there were 24 talks of 5 minutes each.)<p>
The first clever idea is from Adi Shamir, one of the inventors of RSA. In RSA,
the modulus is <i>n=pq</i>, with public exponent <i>e</i> and private exponent
<i>d</i>. Shamir observed that if the receiver knows that the message to be
encrypted is smaller than <i>p</i>, then the recipient <i>only</i> needs to
decrypt <i>mod p</i>. In mathematical language, if the plaintext is
<i>x&lt;p</i>, then the ciphertext is <i>c=x<sup>e</sup> mod n</i>. Decryption
is simply <i>x = c<sup>d</sup> mod p</i>.<p>
Shamir's idea applies to especially paranoid users who want to use
enormous moduli - 5000 bits, for example. Factoring such a large modulus
is impossible with today's technology, but encryption and decryption
are slow if <i>p</i> and <i>q</i> are of equal size. However, if <i>p</i> is
500 bits long and <i>q</i> is 4500 bits long, then the best current factoring
algorithms - the quadratic sieve and the number field
sieve - don't work any faster. But if <i>x</i> is limited to 500
bits, decryption goes very quickly. Since we can always choose a small value
for <i>e</i>, encryption is still efficient.<p>
Another obvious application of Shamir's idea is in current
implementations with, for instance, <i>p</i> and <i>q</i> of about 256 bits. If
RSA is just used for key exchange, then <i>x</i> can almost always be less than
256 bits. The idea of decrypting <i>mod p</i> and <i>mod q</i> separately has
been around for some years, but as far as I know, Shamir is the first to make
this particular observation.<p>
The second clever idea was from Louis Guillou and Jean-Jacques Quisquater, who
questioned whether RSA signatures are really longer than DSA signatures. Since
an RSA modulus is usually at least 512 bits and DSA signatures are 320 bits, it
seems obvious that DSA is shorter.<p>
However, if you use a hash function (SHA, for example), then the actual message
signed will only be 160 bits long. This hash would normally be signed using the
RSA algorithm, and then appended to the message. The clever idea is to fill up
the remainder of the 512 bits with part of the message, rather than wasting it
by filling it up with padding. This part of the message is recovered during
signature verification. Thus, RSA uses 160 bits plus the message length, while
DSA uses 320 bits plus the message length!<p>
Actually, things are not quite this straightforward. For instance, an RSA
signature cannot be less than 512 bits, so DSA is faster for very short
messages. For large messages, RSA will always win, no matter how long a modulus
you use. This is an amazingly clever idea - simple and
useful - but one I have never seen before.<p>
If you're interested, the full Eurocrypt '95 conference
proceedings are available from Springer-Verlag in their <i>Lecture Notes for
Computer Science series: Advances in Cryptology - Eurocrypt
'95</i>, edited by Louis C. Guillou and Jean-Jacques Quisquater (ISBN
3-540-594-094).<p>
<HR AlIGN="CENTER" WIDTH="33%">
 Bruce, who is author of <I>Applied Cryptography</I> (John Wiley &amp; Sons, 1993), is
a <I>Dr. Dobb's Journal</I> contributing editor. He can be contacted at
schneier@chinet.com.<p>


</body> </HTML>

