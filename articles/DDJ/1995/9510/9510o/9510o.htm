<HTML>
<META NAME="year" CONTENT="1995">

<HEAD>
<TITLE>OCT95: PROGRAMMER'S BOOKSHELF</TITLE></HEAD>
<BODY BGCOLOR="#ffffff">
<h1>PROGRAMMER'S BOOKSHELF<a name="0198_007f"><a name="0198_007d"><a name="0198_0000"></h1><P>
<h2>A Sample of C++ Books</h2><P>
<h3>Ray Vald&eacute;s</h3><P>
<a name="0198_007e"><a name="0198_0000">When OOP and C++ were still new to the mainstream, there emerged a tremendous need on the part of programmers for books on C++. Five years or so ago, a familiar question in online forums was, I want to learn more about C++, where do I start? It's a sign of the times (as well as of the decade we live in) that today, the question often is, I'll be laid off next month <I>unless</I> I learn C++, where do I start?<P>
In response to this perceived need, book publishers unleashed a mountain of books on C++. A search through the Computer Literacy bookstore Web site (http://www. clbooks.com) now returns 376 books with &quot;C++&quot; in the title.<P>
Leafing through a few of these books, you'll notice that some bear the earmarks of haste: superficial coverage of the topic, example code that will not compile, sundry misconceptions, and nuggets of misinformation. On occasion, it seems that the author is only a few weeks ahead of the reader in grasping the subject.<P>
Some time ago, Andrew Schulman suggested a useful rule of thumb in weeding out the Johnny-come-lately novices from dyed-in-the-wool mavens: Consider only titles whose authors worked at or were once affiliated with Bell Labs. This filter would include worthwhile books by Bjarne Stroustrup, Margaret Ellis, Stan Lippman, Rob Murray, Jim Coplien, Stephen Dew-hurst, Kathy Stark, Andrew Koenig, Tom Cargill, Jonathan Shapiro and Martin Carroll, which should be plenty. The premise behind this rule is that C++ is a complex enough subject that only someone with years of hands-on experience can contribute useful advice, and for a long time, the only place one could get this experience was at Bell Labs. Obviously, this premise is less valid as C++ becomes more entrenched in the mainstream; even in times past, the stringent rule may have slighted some illuminating introductory treatments by outsiders. Nevertheless, I've found Schulman's suggestion useful when approaching a bookstore's sagging shelves.<P>
More recently, I've been considering a different rule of thumb: Never read anything you can't lift. Okay, I've had to break this rule, but let me explain its rationale. <P>
There's been an arms race among book publishers to make titles as physically wide as possible, to garner every last inch of shelf space and edge out competitors. This has resulted in overweight tomes of 800 pages or more, usually specific to a particular compiler or operating system, often released within a few weeks of the compiler's initial shipment, yet claiming to be the last word on the subject. Too often, you find inside a rehash of the vendor documentation, some toy programs, a few homilies, and well-worn bits of advice. The tips and suggestions therein take everything at face value, with little attempt to go beyond the manufacturer's feature list; there are few of the hard-won lessons that only extensive experience can provide.<P>
As a result, I'm drawn to slim books that carry more than their weight in knowledge and insight--classics such as Scott Meyer's <I>Effective C++</I> (Addison-Wesley, 1992), or James Coplien's <I>Advanced C++ Programming Styles and Idioms</I> (Addison-Wesley, 1992). These books cover material less likely to become obsolete with a new version of a particular compiler. C++ beginners have for a long time been well served by Stan Lippmann's <I>C++ Primer</I> (Addison-Wesley, 1991) and Stephen Dewhurst and Kathy Stark's <I>Programming in C++</I>, Second Edition (Prentice-Hall, 1995). These four books together take up about the same shelf space as one overweight, underpowered title.<P>
However, C++ continues to advance, and more programmers are involved in multiperson projects whose codebase evolves over time. Once you've learned the syntax and some language tips, object-oriented design becomes more of a concern. One recently released book that satisfies a range of needs is <I>Mastering Object-Oriented Design in C++,</I> by Cay Horstmann. The book lives up to its billing on the jacket: &quot;Everything you need in one manageable package!&quot; In this small-format volume, Horstmann provides both an introduction to the C++ language and a &quot;minimethodology&quot; for object-oriented design that emphasizes tractable, real-world use instead of the ivory-tower overkill that some methodologies promote.<P>
Horstmann is a man of few words, and he has packed just about every page in this book with useful information. The brevity is refreshing, and the clean and concise approach contrasts favorably with more-weighty tomes. For example, one popular C++ book has a 60-page chapter on pointers that begins around page 400. Horstmann dispenses with the subject in all of two pages. There are no long-winded explanations, drawn-out examples, padding of the book with page after page of repetitive listings, or half-page diagrams fluffed up with the currently fashionable 3-D, graduated-tint screens. The graphic design is as efficient and precise as the prose. There are many code fragments, usually two or three per page, woven naturally into the fabric of the discussion. Horstmann's book covers features recently added to C++, including exceptions, templates, namespaces, and run-time type. This coverage is not tacked on at the end, but is clearly part of the author's coding repertoire.<P>
Horstmann makes his points in a no-nonsense fashion that is sometimes opinionated but whose opinions carry the weight of experience. For example, when talking about adding new operations to an existing class implementation: &quot;Public data and cluttered interfaces must be avoided. You have no good choice but to stop coding your immediate task and to reexamine the overall class design.&quot;<P>
Every chapter ends with a list of design hints: &quot;Don't pollute the global namespace with constants,&quot; &quot;A class that has a destructor needs both a copy constructor and an assignment operator,&quot; &quot;Beware of constructors with a single integer argument,&quot; and &quot;Class types are the norm; challenge basic types.&quot; These epigrams are followed by a one- or two-paragraph explanation.<P>
Horstmann meticulously adheres to a coding style that &quot;stays away from a good number of C++ features I consider of marginal value (such as private inheritance or pointers to member functions).&quot; He acknowledges that coding preferences can be a matter of intense debate, and provides a 20-page appendix that lays out the guidelines formally so that you can modify them for personal or local taste.<P>
If he sounds like a stern schoolmaster, perhaps that's because he is. Horstmann teaches computer science at San Jose State University in California, and this book has been designed for classroom teaching as well as personal use. Every chapter has exercises that go beyond the rote repetition you may have encountered in school. For example, Exercise 13.1.1 is: &quot;Try corrupting the free list on purpose to see what happens on your system. Delete the same pointer twice. Then allocate pointers and check for duplicates or just for crashes.&quot;<P>
The writer is more than a detached academic. Not mentioned in the book is the fact that Horstmann is author of a commercial word-processing package for scientific documents called &quot;ChiWriter.&quot; This complex program has served as proving ground for the author's design hints and coding tips.<P>
Recently, I've encountered programmers who have already completed the slow march up the learning curve of C++ and are ready to embark on a project involving Microsoft Visual C++ (MSVC) and Microsoft Foundation Class (MFC), only to find themselves at sea in a new ocean of information: the 80,000 lines of dense C++ code that comprise MFC, and the way this codebase interacts with the underlying Windows API. Having been in the same boat, I empathize strongly. <P>
In contrast with the general topic of C++, there are very few independent sources of information on MSVC and MFC. One possible explanation, again, has to do with the complexity of the subject. Unless you work at Microsoft, you probably have not had the opportunity to work extensively with the latest compiler versions, given the rapid release rate of the languages division there.<P>
The bulk of published material on this topic originates from Microsoft--the documentation, tutorials, tech notes and sample code packaged with its compiler and also found on the Microsoft Developer Network CD-ROM (MSDN). There is also the Microsoft Press book, <I>Inside Visual C++</I>, Second Edition, by David Kruglinksi (covering MSVC 1.5 and MFC 2.5). Fortunately, all these official works are of uniformly high quality and go a long way towards providing the &quot;tribal knowledge&quot;--the accumulated wisdom about tips, traps, and techniques--necessary for being productive in a complex environment. The Books Online information packaged with MSVC, plus the additional information in the MSDN CD, is essential for any developer working on the Windows platform, even if you use another vendor's compiler. Having the material in electronic form facilitates browsing and searching, although it does hinder extended reading. If you have a laser printer, however, it's easy enough to print out even entire chapters for offline perusal.<P>
But what happens if your programming problem is not mentioned in this material? For example, I recently wanted to use the <I>CPropertySheet</I> class in MFC to implement a &quot;tabbed dialog&quot; app in 16-bit Windows. This class is supported in MSVC 2.1 for Windows 95 and Windows NT, but the 16-bit compiler (MSVC 1.5) isn't mentioned anywhere in the class reference docs. It turns out that <I>CPropertySheet</I> works fine with V1.52 or later; you just use it in the same manner as in V2.1. To find this out, I had to break my small-is-beautiful rule and consult some wide and heavy books.<P>
I was pleasantly surprised by the quality of the Kruglinski book and of three other recent books on MSVC and MFC: <I>Win32 Programming using Visual C++</I>, by Mike Blaszczak; <I>Visual C++ How-To</I>, by Scott Stanfield et al.; and <I>Visual C++ 2</I>, by Marshall Brain and Lance Lovette. All are safe choices and provide good hard-copy coverage of MSVC and MFC, although none contain information that goes substantially beyond the product documentation. The Kruglinski, Blaszczak, and Brain/Lovette books all follow the traditional approach of covering the MSVC package on a component-by-component basis, with a chapter on, say, AppWizard, another on dialogs, one on ODBC, and so on. <P>
The <I>Visual C++ How-To</I> is distinguished by its question-oriented problem-solving approach. There is no overview or introductory material; instead, the book presents a list of very specific questions, such as &quot;How do I write a customized DDX/DDV routine?&quot; or &quot;How do I display a progress meter in the status bar?&quot;. Each question is answered in a half-dozen or so pages, which contain step-by-step instructions for adding lines of code to compiler-generated source files. (As you perhaps know, much of MFC programming involves interacting with Class Wizard and related code generators.) Because of this approach, <I>Visual C++ How-To</I> complements the other three books--think of it as additional Tech Notes that Microsoft did not write.<P>
If I had to pick only one of the other three, I'd choose <I>Win32 Programming using Visual C++</I>. Perhaps because Blaszczak  was part of the MFC development team, his book seems to have that extra modicum of insight into the design motives behind some MFC constructs. He does first restate the party line, which is that you don't need to know how MFC (or any other app framework) works in order to use it. But then he admits that when things go wrong, everyone feels the need to understand the internals behind mechanisms such as message maps or DDX/DDV tables. Although the book has a more conventional purpose than delving under the hood of MFC, often you can read between the lines of his narrative and get a sense of the underlying design goals. In the case of message maps, he devotes ten full pages to unraveling the twisted set of macros that implement this peculiar mechanism.<P>
In summary, when you need the answer to a specific programming problem, it's fairly easy to sacrifice principles of elegance and conciseness. The Kruglinski, Blaszczak, and Brain/Lovette books contain plenty of answers (the Brain/Lovette book comes with an online index, not just a listings diskette). Any one of them would be a worthwhile addition to your library. Ironically, my particular question turned out not be found in any of these books, and I had to rely on the &quot;tribal knowledge&quot; of a friend to solve the <I>CPropertySheet</I> problem.<P>
<B>Mastering Object-Oriented Design in C++ </B><P>
<I>Cay S. Horstmann</I><P>
John Wiley, 1995, 454 pp., $43.95<P>
ISBN 0-471-59484-9<P>
<B>Inside Visual C++, Second Edition</B><P>
<I>David Kruglinksi</I> <P>
Microsoft Press, 1994, 768 pp., $39.95<P>
ISBN 1-55615-661-8<P>
<B>Visual C++ How-To</B><P>
<I>Scott Stanfield, Mickey Williams, Alan Light, and Ralph Arvesen</I><P>
Waite Group Press, 1995<P>
570 pp., $39.95<P>
ISBN 1-878739-82-4<P>
<B>Win32 Programming using Visual C++</B><P>
<I>Mike Blaszczak</I><P>
Wrox Press, 1995, 733 pp., $44.95<P>
ISBN 1-874416-47-8<P>
<B>Visual C++ 2</B><P>
<I>Marshall Brain and Lance Lovette</I><P>
Prentice Hall, 1995 <P>
834 pp., $42.95<P>
ISBN 0-13-305145-5<P>
<B>Development Library CD-ROM</B><P>
Microsoft Developer Network<P>
$195 for 4-issue subscription<P>
http://www.microsoft.com/msdn/<P>



<HR><P>Copyright &copy; 1995, <I>Dr. Dobb's Journal</I></P></BODY></HTML>
