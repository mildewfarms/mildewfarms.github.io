<HTML>
<META NAME="year" CONTENT="1995">

<HEAD>
<TITLE>APR95: LETTERS</TITLE></HEAD>
<BODY BGCOLOR="#ffffff">
<h1>LETTERS<a name="0140_0001"></h1><P>
<h3><a name="0140_0002">Woof, Woof (As in Dogma)<a name="0140_0002"></h3><P>
Dear <I>DDJ</I>,<P>
In his &quot;Swaine's Flames,&quot; February 1995, Michael is correct. The Supreme Court must absolutely avoid any deviation from the Constitution, legislated or not.<P>
Further, it would be criminal if even the Supreme Court ruled in a way that violated the Constitution. Thus even the Supreme Court must always cite legal or historical precedent whenever it rules. If not, it would be the duty of every American to oppose any ruling that unilaterally diverged from our Constitution. And thus has it always been--except once. <P>
In <I>Engel v. Vitale</I> when the (infamous) Warren court ruled to remove prayer from the public schools, it cited zero historical precedents and zero legal precedents. No court has done that before or since. Historical note: That was just a few months before the court obstructed justice in the Kennedy assassination.<P>
Michael would do well to remember Plato: &quot;The rejection of a dogma itself implies a dogma.&quot; Next thing to happen is that dogmatists like Michael will remove our freedom of expression.<P>
Stephen Lindner<P>
lindner@m-net.arbornet.org<P>
<h3><a name="0140_0003">Serial Port IRQs<a name="0140_0003"></h3><P>
Dear <I>DDJ</I>,<P>
I liked John Ridley's article, &quot;Identifying Serial Port IRQs&quot; (<I>DDJ</I>, February 1995), but couldn't get the listing to work until changing a port write in <I>Which IRQ()</I>. Setting bit 1 needs all the other bits unchanged. For example, <a href="#0140_0008">Example 1(a)</A> should be changed to <a href="#0140_0008">Example 1(b)</A>.<P>
Ken Lagace<P>
Baltimore, Maryland<P>
John responds: Thanks for your note, Ken. I have received a lot of e-mail regarding PORTINFO. As a result of some research into some problems a few people have been having with it, I have come up with the following changes. As a result, it is much more reliable; I haven't been able to break it so far with these changes in place. In addition, operation under Windows seems to be much improved (though still not perfect). In particular, <I>IsUART</I> has problems with some serial ports. Specifically, some internal modems use a microcontroller to emulate a UART, and it does not respond quickly enough in loopback mode for <I>IsUART</I> to identify it correctly. To remedy this situation, I've added the timing loop in <a href="#0140_0009">Example 2(a)</A>. <P>
Apparently, the enable/disable right next to each other don't always allow all pending interrupts to be processed. To remedy this, the relatively slow output statements that normally happen just before and after this pair are moved inside; see <a href="#0140_0009">Example 2(b)</A>.<P>
As a result of this slowdown, however, quite often two IRQs are generated. Since multiple interrupts are going to happen anyway, you can omit the first enable/disable pair, if you want. Their only purpose was to try to eliminate duplicate IRQs. <P>
To avoid printing of duplicate IRQs, the calling program should count bits in the return value, and loop until only one bit comes back. You may wish to limit the looping to 10 or 20 iterations, since a defective COM port may actually generate multiple interrupts; see <a href="#0140_0009">Example 2(c)</A>. Also, since the <I>IsUART</I> routine is now immensely slow, you may wish to remove the <I>IsUART</I> call from the beginning of the <I>WhichIRQ</I> routine. Just be sure not to call it unless you know there is a UART on the port.<P>
<h3><a name="0140_0004">Dave from Nebraska, You're on the Air<a name="0140_0004"></h3><P>
Dear <I>DDJ</I>,<P>
Part of Michael Swaine's &quot;Programming Paradigms&quot; (<I>DDJ</I>, January 1995) concerning the use of a portable radio to give voice to the loops in an executing program on an early Altair machine brought back memories.<P>
About a decade before the time being referred to in Michael's column, I was completing a Fortran program as part of a master's thesis in mathematics. This was at a small midwestern university at which the available computing facility was an IBM 1620; this was a hands-on situation in which you signed up for time on the machine. My original plan was to have the program produce a fairly large number of orbital coordinates, the final step for each point being the evaluation of a series to a sufficient level of convergence. <P>
When my results began to appear at a dismayingly slow rate, I stopped the program, and on a reexecution, listened to the portable radio sitting on the computer, with the frequency selector at the low end of the AM range. The sounds produced by the radio helped me understand where the real crunching was taking place. I wound up changing the program to output a pair of parameters which could be plugged into a table to obtain the final results I needed.<P>
David Moxness<P>
Fremont, Nebraska<P>
<h3><a name="0140_0005">Big Mac Attack<a name="0140_0005"></h3><P>
Dear <I>DDJ</I>,<P>
In his February 1995 &quot;Editorial,&quot; Jonathan Erickson made reference to ronald@macdonalds.com. An expanded version of the story was reported in <I>Wired</I> magazine (October, 1994). In fact, McDonalds has had a registered domain name for several years, mcd.com.<P>
That McDonalds is not particularly interested in trying to soak up all possible variations of its name, deserves praise and not the implied criticism that it and other corporations are not paying attention to the Internet. According to the <I>Wired</I> story, there was no extortion attempt by the macdonalds.com registrar towards McDonalds. <P>
Also, regarding that joke about Intel Pentium processors a couple of pages later--that is quite out of place as well. Instead of the joke, a little research into the problem and a paragraph or two regarding the types of software affected or an analysis of Intel's 27,000-year claim might be in order. Just how did Intel arrive at that number anyway ?<P>
Bill England<P>
Redmond, Washington<P>
<I>DDJ </I>responds: Sorry you didn't like the Intel joke, Bill. How about this one: Q: How many Pentium engineers does it take to screw in a light bulb? A: 2.9999999. In all seriousness, we did take the Pentium's <I>fdiv</I> problems to heart, witness this month's &quot;Undocumented Corner&quot; article by Tim Coe on page 129. Likewise, you might want to refer to the February 1995 issue of our <I>Dr. Dobb's Developer Update,</I> which had two articles on the Pentium problems, one by senior editor Ray Vald&eacute;s and another by Bill Jolitz. And finally, McDonalds has indeed been very aggressive in soaking up variations of its trademark.<P>
<h3><a name="0140_0006">Cybertorts<a name="0140_0006"></h3><P>
Dear <I>DDJ</I>,<P>
The bit in Jonathan Erickson's February 1995 &quot;Editorial'' about Microsoft going after somebody who posted a beta version of Windows 95 on the Internet was rich. Has there ever been a more widely distributed &quot;secret&quot; in history? Microsoft has sent me no less than three copies (to H. Helms, Harry Helms, and Harry L. Helms) of the latest beta version. It seems like Microsoft would thank the guy for saving a lot of time and distribution costs.<P>
Harry Helms <P>
Solano Beach, California<P>
<h3><a name="0140_0007">386BSD Serial Drivers<a name="0140_0007"></h3><P>
Dear <I>DDJ</I>,<P>
Regarding the discussion and code on ring buffers in Bill Wells's article, &quot;Writing Serial Drivers for UNIX&quot; (<I>DDJ</I>, December 1994), I am pleased to see further work with 386BSD ring buffers. After reading the article, however, I think Bill missed some of the reasons why I added ring buffers to 386BSD in the first place  (in Release 0.0 in March of 1992). Since Bill's ring buffers appear to be an extension of this work, knowing some of the background may allow even more enhanced operation of the concept.<P>
Prior to 386BSD Release 0.0, UNIX character lists (or <I>clist</I>s) were used in BSD systems to buffer terminal I/O. This abstraction dated back to the earliest Bell Labs UNIX system and was perfectly adapted for its original use in a timesharing system with limited memory resource (for example, a PDP 11/45 with a maximum of 252 Kbytes of memory running 15--30 users each on a terminal). Blocks of 16 characters (32 on VAX systems) were maintained on a single shared-free list, totaling 5--32 Kbytes in size. Primitive functions allocated/freed blocks in the course of implementing FIFO queues of single characters. Memory utilization was quite high, since all of the terminals could use the shared-buffer resource.<P>
However, in 386BSD, we determined that memory utilization of terminal buffers was not interesting. The average PC used with 386BSD (a console, two serial ports, and more than 4 Mbytes of memory) supported only a handful of users (typically, one). We could thus afford to allocate resources permanently to terminals, and interrupts did not have to be masked across the set of devices sharing the buffer pool. (Altering the interrupt mask on x86 PCs is considerably more expensive than on PDP-11s or VAXen, where it can be made into a single inline instruction. This is true across many other architectures besides the x86.) While in hindsight this may appear obvious, at the time we replaced the old encumbered <I>clist</I>s code this was considered controversial. In fact, some derivatives of 386BSD Release 0.0 and 0.1 went well out of their way to reimplement <I>clist</I>s (even though ring buffers were in other real-time operating systems) merely because they were being used in a BSD system in a &quot;new&quot; way. Although current versions of 386BSD have yet to take advantage of this, we intend to comprehensively replace shared interrupt masks and other exclusion mechanisms (for example, program-visible spin locks) with a new mechanism for exclusion that works well in multiprocessing environments. <P>
Bill also states that interrupt blocking between the top and bottom halves of the driver is no longer necessary, given that characters will just fall into additional consecutive storage. This is again a consequence of isolated buffer pools and can be used to great advantage in the terminal-driver implementation, which currently uses interrupt masking in sections no longer critical. But when are the terminal input queues really empty? Since the length of the queues can always increase, we may need to recheck the queue for characters to resolve the race multiple times (for instance, ring-buffer length is now &quot;volatile&quot;). Continuing on, what if we have the pathologic case of a character arriving exactly every loop interval? Then, the top half of the discipline waits indefinitely!<P>
While this may seem trivial, this has important implications for POSIX/UNIX terminal-driver implementations dealing with pending I/O during mode shifts that require the queues to be emptied <I>prior</I> to transition between modes (for instance, certain <I>ioctl</I> requests). The subtlety of this problem is that the interpretation of pending characters is now at risk--they may be incorrectly interpreted if a race occurs between the top and bottom halves of the terminal driver. In these cases, you still must mask interrupts.<P>
In a sense, you might even say that one set of critical sections has been exchanged for another set in the terminal driver. This and other subtle dilemmas in preserving the correct POSIX semantics caused us to adopt a conservative track in 386BSD versions.<P>
Another major consideration was the need to migrate the kernel to use dense storage for buffers instead of the sparse storage used in lists. With sparse storage, overhead in parceling up storage is endured as another price of increased memory utilization. Worse, sparse buffer storage has no locality of reference (for example, buckets of characters are not guaranteed to be consecutive)--thus, a memory-storage hierarchy may have unpredictable access timing. As a consequence, 386BSD Release 0.1 took advantage of dense storage to implement costly operations on a list as inline operations on a single segment in the ring buffer (two segments in the case of overlapping the end of the ring). Yet another consideration was to reduce unnecessary copy operations by redirecting the pointers of the buffers at will. As an example of this, Serial Line IP (SLIP) could transfer directly to a packet memory buffer in certain common cases, avoiding a copy entirely (this makes use of other mechanisms in BSD message buffers, of course).<P>
Another concern was the need for &quot;wide&quot; characters of 16 or 32 bits. In 386BSD Release 1.0, the structure of the line disciplines was rewritten to allow transparent use of the ring-buffer headers with internal implementations (within, say, a UNICODE terminal driver &quot;wtermios&quot; and corresponding serial/console drivers capable of implementing wide characters) different than the default 8-bit character size. We felt that the terminal driver should bear the burden of work, and that above the level of the terminal driver, the de facto view of buffer contents should only be a queue-item count This avoids duplicating knowledge of queue structure for 8, 16-, and 32-bit character implementations. <P>
One limitation of ring buffers occurs when stackable protocol modules replace the current line disciplines. In this case, one needs to &quot;switch&quot; ring-buffer contents further up the level-of-abstraction stack of the kernel. This then reintroduces many of the problems incurred with <I>clist</I>s. As such, we decided that a single, comprehensive mechanism used for high-speed  networking was better than ring buffers, and have been working in that direction with our internal 386BSD development. Ring buffers have been left in until SIGNA (the Simple Internet Gigabit Network Architecture) can encompass terminal drivers and disciplines.<P>
Another interesting aspect of ring buffers which is ripe for exploitation is that of &quot;chunking&quot; I/O to FIFO serial cards. As this article correctly points out, ring buffers cannot be completely filled--a single element must be free. However, if you change the quantization from byte to the size of the FIFO (in determining rollover and &quot;full&quot; state), the FIFO can conceivably be unloaded using a single I/O-port string instruction, since one would always be guaranteed contiguous buffer space. On VAXen in the &quot;old&quot; days of 4BSD, it was found that stuffing FIFOs in this manner was the most efficient way of handling serial I/O, beating out both pseudo-DMA and real DMA.<P>
Bill Jolitz<P>
Oakland, California<P>
<h4><a name="0140_0008"><B>Example 1:</B> Serial-port IRQs.<a name="0140_0008"></h4><P>
<pre>(a)
_disable();           /* Ready for the real thing now */
IRQ_Happened = 0;     /* Clear bitmap */ 
outp(CurPortBase+IER,0x02);     /* enable xmt empty int. */
(b)
_disable();                                 /* Ready for the real thing now */
IRQ_Happened = 0;                           /* Clear bitmap */
outp(CurPortBase+IER,(HoldIER | 0x02));    /* enable xmt empty int. */</pre><P>
<h4><a name="0140_0009"><B>Example 2:</B> Serial-port IRQ update.<a name="0140_0009"></h4><P>
<pre>(a)
/* routine IsUART(): code added between outp and if statements */
_outp(PortAddr+MCR, 0x0a | LOOPBIT);     /* Turn on RTS        */
{
long oldtick, far *ticks=0x0040006c;     /*points to timer ticks area*/
oldtick = *ticks+2;                     /*wait for ~1 or 2 ticks    */ 
while (oldtick != *ticks) ;
}
if ((_inp(PortAddr+MSR) &amp; 0xf0) == 0x90)  /* If CTS is on, there's a UART */
(b)
/* routine WhichIRQ(): move outp statements to between second enable/disable
pair */
enable();                                /* BANG!  */
_outp(CurPortBase+IER, 0x02);             /* enable xmt empty int. */
_outp(OCW1, (_inp(OCW1) &amp; (~IRQbit)) |    /* Restore 8259 */
(HoldOCW1   &amp; IRQbit));
disable();                              /* OK, we're done. */
(c)
(In module PORTINFO.C, added function:)
--begin--
short NumBits(unsigned short IRQ_bitmap)
{
short x,bits;
for (x=8,bits=0; x; x--,IRQ_bitmap &gt;&gt;=1)
if (IRQ_bitmap &amp; 1)
bits++;
return bits;
}
/* in function main(), put the call to WhichIRQ() in a loop */
do
IRQ_bitmap = WhichIRQ(PortAddr);
while (NumBits(IRQ_bitmap) &gt; 1);</pre><P>
<P>
<HR><P>Copyright &copy; 1995, <I>Dr. Dobb's Journal</I></P></BODY></HTML>
