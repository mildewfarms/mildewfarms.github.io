<HTML>
<META NAME="year" CONTENT="1995">

<HEAD>
<TITLE>APR95: Directed Acyclic Graph Unification</TITLE></HEAD>
<BODY BGCOLOR="#ffffff">
<h1>Directed Acyclic Graph Unification<a name="016f_006a"></h1><P>
<h2><a name="016f_0068"><a name="016f_0000">An object-oriented approach to building constraint systems</h2><P>
<h3>David Perelman-Hall</h3><P>
<p><i><a name="016f_0069"><a name="016f_0000">David earned his PhD in computational linguistics at the University of Texas at Austin. He can be contacted at phall@ccwf.cc.utexas.edu.</i></p><hr><P>
One approach to parsing natural language is to build a two-part parsing system, where one part is the grammar and the second part is a set of rules associated with the grammar. What I call the &quot;Part One&quot; grammar, commonly a set of rewrite rules in Backus-Naur form (BNF) used to recognize the tokens of the language, lays down the entire road map of the basic parsing process. The rules in &quot;Part Two&quot; constrain the parser's actions and serve as navigators, indicating which paths the Part One parser can investigate. Each constraint represents an assertion which linguists have determined to be a requirement for grammaticality.<P>
The familiar BNF rules that usually form Part One contain a left-hand side (LHS) and a right-hand side (RHS) separated by an arrow. The rules describe how one side of the arrow may be written as the other side, as in <a href="#016f_0072">Example 1</A>. These rules are order independent, so the arrows in <a href="#016f_0072">Example 1</A> don't actually imply that action must occur from left to right (top-down, from start node S to the terminal symbols). <P>
Linguists frequently refer to the rewrite rules of Part One as &quot;phrase-structure rules&quot; and use them to parse input; for example, the sentence, &quot;the cow eats the grass&quot; would be accepted by <a href="#016f_0072">Example 1</A>. However, using <I>only</I> Part One to parse natural language tends to fail because Part One accepts ungrammatical input strings as though they were grammatical. Suppose, for example, that you admit in <a href="#016f_0072">Example 1</A> the perfectly legitimate verb &quot;eat&quot; by introducing the rewrite rule: V<img src="arrow12.gif" alt="--&gt;">&quot;eat&quot;. The grammar then would accept the ungrammatical input, &quot;the cow eat the grass.&quot; With Part Two, you can at least try to prevent acceptance of ungrammatical input such as this.<P>
What linguists attempt to codify in Part Two is the inherent capacity of humans to determine what is or isn't grammatical. This is not an easy thing to do; most people can tell you only that a sentence is ungrammatical, but not why. The rule set which holds this knowledge, and its application, is what differentiates between a dumb token recognizer and an expert system.<P>
A commonly accepted method of employing Part Two is to associate one or more constraints (taken from the rule set of Part Two) with the terms of phrase-structure rules in such a way that the phrase-structure rules can be successfully applied only if all associated constraints are satisfied.<P>
For example, you can associate a value for <I>grammatical number</I> with the input terms forming verbs and nouns. Therefore, &quot;eat&quot; would have the value <I>plural</I>, while &quot;eats,&quot; &quot;grass,&quot; and &quot;cow&quot; would have the value <I>singular</I>. Now the rule S<img src="arrow12.gif" alt="--&gt;">NP VP can be rewritten only if the values for grammatical number match. In the association of the elaborated phrase-structure rule in <a href="#016f_0073">Example 2</A>, the value for <I>number</I> has been percolated up through the rule system from its original entry with the input terms. Use of this feature-value equivalence metric prevents the parsing system from accepting the ill-formed sentence, &quot;the cow eat the grass,&quot; because the required match between VP <I>number</I> and NP <I>number</I> would fail, and therefore the rewrite rule would not be applicable.<P>
In this article, I'll describe &quot;feature-value unification,&quot; a general, object-oriented method of enacting such a constraint system adapted from directed acyclic graph (DAG) unification. While feature-value unification can be used in natural-language parsing, it can also be used in applications where you want an object to enter into relations <I>only</I> with other objects that meet the constraints specified in the feature-value DAGs. In an object-oriented system, you would include DAG objects as data members in those objects whose behaviors must be constrained and require their successful unification before allowing the objects to interact. There are numerous issues surrounding natural-language parsing that I won't cover, including building DAGs directly from the elaborated phrase-structure rules and implementing a parsing engine. Instead, I'll focus on feature-value (or DAG) unification through an example drawn from natural-language processing.<P>
<h3><a name="016f_006b">Dispensing with the Formalities<a name="016f_006b"></h3><P>
A directed acyclic graph is rooted at a single node. Traversal through the graph is unidirectional (from root to node) and noncyclic (no arc can provide a path for returning to its originating node). DAG unification can net two results: <P>
<UL>
<li>A Boolean value based on the success of the unification.</li>
<li>A new DAG, bearing the results of the unification. </li>
</UL>
<a href="19950171.htm">Figure 1</A> shows a DAG which illustrates the number agreement between subject and predicate phrases of a sentence, and is the representation of the S node of the elaborated grammar in <a href="#016f_0074">Example 3</A>. This rule applies only if the value of <I>case</I> for the noun phrase (NP) is <I>nominative</I>, the <I>subcat</I> for the verb phrase (VP) is <I>intransitive, </I>and the <I>agreement</I> for NP matches that of VP. The value of <I>agreement</I> itself in this example is another DAG, which expands into feature-value constructs such as <I>number</I><img src="arrow12.gif" alt="--&gt;"><I>singular</I>, <I>gender</I><img src="arrow12.gif" alt="--&gt;"><I>masculine</I>, <I>animacy</I><img src="arrow12.gif" alt="--&gt;"><I>animate</I>, and so on.<P>
Structures in the feature-value notation which are merged during unification include:<P>
<UL>
<li>Atomic values, as for features <I>case</I> and <I>subcat</I> in <a href="19950172.htm">Figure 1</A>.</li>
<li>Variable values, or equivalencies, as for feature <I>agreement </I>of <a href="19950173.htm">Figure 1</A>.</li>
<li>Dag values, which themselves are comprised of atomic, variable, or DAG values, and so on, iteratively.</li>
</UL>
Successful unification produces a DAG that results from merging the information from two or more DAGs. Unification proceeds by iterating through the feature-value sets of both DAGs thus:<P>
<UL>
<li>Where the features of both DAGs match, and the associated values match if they are either atomic or variables instantiated with atomic values, add the feature-value to the resulting DAG. </li>
<li>Where the features of both DAGs match, but the value for the feature in one of the DAGs is a variable, add the feature-value found in the other DAG to the resulting DAG. </li>
<li>Where the features of both DAGs match, but the value for the feature in both of the DAGs is a variable, add a feature-value indicating the identity of the variables to the resulting DAG. </li>
<li>Where only one DAG contains the feature, add its feature-value pair to the resulting DAG.</li>
</UL>
DAG-valued features obey this algorithm recursively. Unification is an additive procedure. It can succeed or fail. Failed unification does not produce a resulting DAG. Failure occurs when atomic values do not match for like features. Possible results of unification are pictured in <a href="19950174.htm">Figure 2</A>. (In principle, you can unify as many DAGs as you want, but in practice I unify them two at a time.) <P>
<h3><a name="016f_006c">C++ Requirements<a name="016f_006c"></h3><P>
To use DAGs, you need a structure and mechanism to construct them and an algorithm for performing unification. I'll build DAGs using inheritance and C++ templates and unify them using virtual functions and double indirection. I have <I>typedef</I>ed sets, lists, and maps for use throughout the code, making extensive use of templates.<P>
In its abstract essence, feature-value unification relies on DAGs built from objects of types <I>Feature</I> and <I>Value</I>. A <I>Feature</I> is <I>typedef</I>ed as a <I>String</I>. A <I>Value</I> is either an <I>Atomic</I>, <I>Variable</I>, or <I>Dag</I> value--all of which are formed by inheritance from an abstract base <I>Value</I> class; see <a href="19950175.htm">Figure 3</A>. The physical representation, and hence the behavior, differs among the derived concrete atomic-, variable-, and DAG-valued classes; however, the types of activity in which they participate--most importantly, unification--are identical. This allows you to declare in an abstract base class a virtual <I>unify()</I> function that anything considered a <I>Value</I> should uniquely define in its derived concrete class. This lets you use polymorphism in the implementation of unification among differently valued DAGs.<P>
<a href="#016f_0075">Listing One</A> is the declaration of the <I>Value</I> and <I>ValuePtr</I> classes. (<a href="#016f_0076">Listing Two</A> is the <I>Value</I> class header file.) Notice that the <I>Value</I> class declares no data members; it merely proposes the behavior that a value should be able to implement. To take advantage of polymorphism with this class, I've implemented a smart-pointer wrapper class, <I>ValuePtr</I>, which takes as one of its constructors a reference to a <I>Value</I> object, but maintains as a data member a pointer to an object of type <I>Value</I>. The three <I>Value</I>s--<I>Atomic</I>, <I>Variable</I>, and <I>Dag</I>--are handled as <I>ValuePtr</I>s throughout the program. Because <I>ValuePtr</I>s internally handle <I>new</I>ing, <I>copy</I>ing, and <I>delete</I>ing of pointed-to <I>Value</I>s, you can safely ignore issues of memory management with DAGs by using <I>ValuePtr</I>s. <I>ValuePtr</I>s actually alias <I>Value</I>s, so they can be used to implement polymorphism.<P>
<h3><a name="016f_006d">The &quot;Value&quot; of Polymorphism<a name="016f_006d"></h3><P>
Every member function of the <I>Value</I> class is declared virtual, and many of them are pure virtual functions. This means that every function in the <I>Value</I> class can be redefined in classes derived from <I>Value</I>, and pure virtual functions must be redefined in derived classes in order for an object of that class to be constructed. We want the functionality of copying, writing to output, equality testing, and unifying to differ depending on the type of value.<P>
Notice in the base class that the <I>operator==()</I> and <I>unify()</I> functions each have four prototypes, differing in the type of the value parameter, taking references to a base <I>Value</I> class object and to all three derived classes. This arrangement lets you employ polymorphism and double indirection to gain default definitions for inequality and failed unification.<P>
Let's use the equality function to examine how polymorphism achieves the default behavior. The base class contains the only pure virtual version of the equality test, taking a base <I>Value</I> class reference, as might be expected. The base class also defines three (not pure) virtual equality tests. These tests take a reference to each of the derived types and by default returns False. If an object of the base <I>Value</I> class (actually a pointer or reference will be required) ever makes the call <I>ValueObject </I><img src="arrow12.gif" alt="--&gt;"><I>operator==(SomeDerivedValueType&amp; DV);</I> for any of the three derived <I>Value</I> types, it returns False by default.<P>
In Listings <a href="#016f_0077">Three</A> through <a href="#016f_007c">Eight</A>, each derived class defines two versions of the equality test: one taking a reference to an object of its own type, the other taking a reference to the base <I>Value</I> type. For example, the derived concrete <I>AtomicValue</I> class (<a href="#016f_0077">Listing Three</A>) defines an <I>operator==()</I> taking an <I>AtomicValue</I> reference, and one taking a <I>Value</I> reference. During program execution, the only type of object calling <I>operator==()</I> can be one of the concrete derived types. If one atomically valued DAG seeks to test equality with another, <I>AtomicValue::operator==(AtomicValue&amp;)</I> is called. This function performs an actual equality test between <I>AtomicValue</I> objects. Every equality test in a derived class defines the actual test for objects of its own class.<P>
If, however, the type of the object being tested for equality differs from the calling type, this scenario occurs: Because the type of the parameter differs from the type of the calling object, it can not test equality with an object of its own type, so by default the <I>operator==(Value&amp;)</I> of the derived class is called. This works because in each derived class there is no <I>operator==()</I> prototyped to take the other two derived classes, and each derived concrete value is by inheritance an instance of the base <I>Value</I> class. In each derived class, the equality test prototyped for a base <I>Value</I> reference is the same: It turns the <I>Value</I> reference parameter into the calling object, passing it the derived object as the parameter. This calls the specific <I>Value::operator==(someDerivedType&amp;)</I> that corresponds to the type of the derived-object parameter.<P>
In the example of the <I>AtomicValue</I>, the call would resolve to the base <I>Value</I> part of an <I>AtomicValue</I> testing equality with an <I>AtomicValue</I> (the call would be: <I>Value::operator==(AtomicValue&amp;)</I>). Recall that--as defined in the base class--any equality test made by a base <I>Value</I> object with a derived object returns False. Hence, the test between unlike derived classes for <I>operator==()</I> defaults to False in each derived class without actually testing the elements of the value objects. <a href="19950176.htm">Figure 4</A> shows the calling sequence for both <I>AtomicValue::operator==(AtomicValue&amp; avr)</I> and <I>AtomicValue::operator==(DagValue&amp;dvr)</I>.<P>
This handy method of relying on polymorphism to implement a default base behavior has a compile-time drawback: It results in warnings letting you know that the derived functions prototyped for the base class hide the base-class functions prototyped for the derived class. These warnings are correct, but in this case can be safely ignored because you make no calls to the base-class functions prototyped for the hidden derived classes.<P>
<h3><a name="016f_006e">Unifying DAGs<a name="016f_006e"></h3><P>
Unifying DAGs is more complicated than testing for equality of <I>Value</I>s. The same basic arrangement of double indirection exists (including that for each derived <I>Value</I> type, there is a definition of what it means for that type to unify with itself). DAG unification is also complicated by the fact that it produces more than a True or False; it yields both a resulting DAG (if successful) and a Boolean indication of the attempt to unify. Furthermore, as the unification results in <a href="19950177.htm">Figure 2</A> show, more than one possible unification of types has a legitimate chance of success. This means that, because <I>VariableValue</I>s can unify with any type of <I>Value</I>, there must be a way of tracking the <I>Value</I>s that <I>VariableValue</I>s acquire while unification takes place so that the final resulting DAG contains the proper <I>Value</I>s which instantiated the <I>VariableValue</I>s.<P>
The simple part is implementing atomically valued unification. If the atomically valued elements are identical, just add the identical <I>Feature</I>-<I>AtomicValue</I> pair to the resulting DAG (see <a href="#016f_0077">Listing Three</A>).<P>
Here the simplicity ends. The result of a call not prototyped for an <I>AtomicValue</I> depends on the type of the non-<I>AtomicValue</I>. Possibilities are either <I>DagValue</I> or <I>VariableValue</I>. The call prototyped for a <I>DagValue</I>, <I>AtomicValue::unify(DagValue&amp;,_)</I>, has no definition in the <I>AtomicValue</I> class. Eventually, it defaults to <I>AtomicValue::unify(Value&amp;,_)</I> via double indirection, returning FALSE from the base class without performing any unification.<P>
The same call in the <I>VariableValue</I> class, however, is a different story. A <I>VariableValue</I> has to attempt to unify with any type of <I>Value</I>. Consequently, the <I>VariableValue</I> class can't merely pass unification on to a base class for default behavior. Indeed, you can see in Listings <a href="#016f_0079">Five</A> and <a href="#016f_007a">Six</A> that the <I>VariableValue</I> class defines a unify function for all derived <I>Value</I> class parameters. In this case, <I>AtomicValue::unify(VariableValue&amp;,_)</I> is turned into the call <I>VariableValue::unify(AtomicValue&amp;,_)</I>, which has a legitimate chance of succeeding and therefore must have a definition.<P>
<I>DagValue</I>s can unify with themselves; however, the <I>DagValue</I> class's implementation of <I>unify()</I> uses double indirection (see Listings <a href="#016f_007b">Seven</A> and <a href="#016f_007c">Eight</A>). DAGs can't unify with atoms, so double indirection directs the calling sequence toward failure. DAGs might unify with <I>Variables</I>, so a call to <I>VariableValue::unify(DagValue&amp;, _)</I> might succeed. The qualification exists because there is always a chance that the variable has already been instantiated to some non-<I>VariableValue</I> which will not successfully unify with the other <I>Value</I>.<P>
DAG unification is implemented as a global function, taking the two DAGs under consideration. The complete set of features in both DAGs is culled together and iterated over. The <I>Dag::value(Feature&amp;)</I> method is used to acquire from both DAGs the values associated with the current feature. If the feature exists in both DAGs, attempt to unify the acquired values and add the resulting <I>Feature</I>-<I>Value</I> pair to the resulting DAG; if it exists in one DAG only, add that <I>Feature</I>-<I>Value</I> pair to the resulting DAG. If both values are <I>DagValue</I>s, then <I>DagValue::unify(DagValue&amp;, _)</I> calls the global unify function. <P>
<h3><a name="016f_006f">The Substitution List<a name="016f_006f"></h3><P>
DAG unification can be destructive or nondestructive. Destructive unification manipulates one of the original DAGs, changing its data structure so that it houses the unification of the two DAGs. The original DAG is permanently changed, hence the term &quot;destructive.&quot; I've opted to build the resulting unified DAG from scratch, nondestructively incorporating the elements of the participating DAGs into the newly created resulting DAG. To do this, there has to be a mechanism for tracking the various instantiations which <I>Variable</I>-valued DAGs take on. This tracking is done in the <I>SubstitutionList</I> class. To test or perform the unification of two DAGs, you need to supply a <I>SubstitutionList</I> object to track the variable instantiations.<P>
The <I>SubstitutionList</I> inherits privately from a <I>Map</I> template instantiated with <I>Variable</I>s as keys and <I>ValuePtr</I>s as values. The source code for the <I>SubstitutionList</I> class is provided electronically; see &quot;Availability,&quot; page 3. Private inheritance models the &quot;has-a&quot; relationship, and no portion of the base class is accessible outside of the inheriting class proper. The interface to the <I>SubstitutionList</I> class, therefore, is comprised of methods unique to the derived class which you declare public. These consist mostly of methods for setting <I>Value</I>s into the <I>SubstitutionList</I>, setting variables identical in the <I>SubstitutionList</I>, checking whether the <I>SubstitutionList</I> contains a variable, checking whether it is empty, returning from the <I>SubstitutionList</I> a <I>ValuePtr</I> associated with a variable, returning the set of variables set equal to each other.<P>
Not only is the <I>SubstitutionList</I> a map (thereby containing a private data-storage facility; see <a href="19950178.htm">Figure 5</A>), but it also contains as a private (protected) member a list of sets of variables. This protected member is a nested template instantiated as <I>ListOf &lt;SetOf&lt;VariableValues&gt;&gt;</I>. Each separate set of variables is a set for which all variables will bear the same value upon successful unification. If the value of at least one and only one variable within a set should instantiate to a nonvariable value (meaning that it is either <I>Dag</I> valued or <I>Atomic</I> valued), the value for that entire set of variables is obtained from the base variable-to-value map class. This is because if at least one and only one variable of a set bears a nonvariable value, then one variable from that set will also be in the map, acting as a kind of place holder to indicate the value to which every member of the set will instantiate (by mapping). The code prevents more than one place holder from being built. A set which will not instantiate to a nonvariable value will be a set of variables, all of which bear the same identity as a variable.<P>
Before unifying DAGs, a <I>SubstitutionList</I> is created to hold all substitutions made for variables during unification. During the actual unification, the <I>SubstitutionList</I> is filled with any substitutions made for variables. Immediately upon completion of unification, any variables in the resulting DAG that have substitutions as defined by the contents of the <I>SubstitutionList</I> are then replaced by the appropriate substitutions. In this sense, in order to accommodate variables in DAG unification, unification is a two-phase process: The first phase is unifying anything which isn't a variable, and the second is the exchange of values for variables.<P>
<h3><a name="016f_0070">How They All Operate Together<a name="016f_0070"></h3><P>
To illustrate the concepts presented here, I've written a demonstration program (available electronically) that builds a DAG compliant with Grammar 2 from an NP of &quot;the cow&quot; and a VP of &quot;eats grass&quot;. The construction of both DAGs involves building an inner DAG for the set of <I>Feature</I>-<I>Value</I> arcs which contain requirements under the agreement node. I have determined that these should be animacy and number. As long as the atomic values for animacy and number match, the agreement subDAGs will unify. The values for animacy and number can be supplied by the lexical items themselves, so that the word &quot;cow&quot;, for instance, supplies &quot;animate&quot; and &quot;singular&quot; for the animacy and number features, and &quot;eats&quot; supplies values for number and subcategorization.<P>
For a natural-language parser, once a sentence is presented for parsing, a lexical look-up routine can build the DAGs for each lexical item as each item is encountered (such a DAG factory is not supplied with this article). This allows you to create phrase-structure rewrite rules for terminal elements which bear fully informational DAGs--that is, adumbrating Grammar 1 with requirements for DAG unification to produce a flushed out Grammar 2. Once parsing starts, if a rewrite rule successfully applies to a terminal element, the result of the rewrite will contain a new DAG created by the unification of the DAGs specified in the addenda to the rewrite rule. In this way, each successfully applied rule results in the passing-on of DAGs so that the final end-state node (S in this case, working bottom-up) contains a single DAG bearing the complete history of its parse. This percolating activity is handy for investigating grammatical reasons for parse failure because it builds up a structure which may be examined for the semantics attached in the form of <I>Feature</I>-<I>Value</I>s.<P>
In fact, for grammar sticklers, the sentence being parsed in <I>main()</I> in accordance with Grammar 2 purposefully contains an additional inconsistency which should be remedied in order to conform with good grammar. Perhaps finding this breach of grammar is enough indication of the difficulty that people have in pointing out why some input is ungrammatical.<P>
<h3><a name="016f_0071">References<a name="016f_0071"></h3><P>
Kay, M. &quot;Functional Grammar.&quot; <I>5th Annual Meeting of the Berkeley Linguistic Society</I>, 1979. Berkeley: Berkeley Linguistics Society.<P>
Knight, Kevin. &quot;Unification: A Multidisciplinary Survey.&quot; <I>ACM Computing Surveys</I>. Vol. 21, 1989.<P>
<a href="19950179.htm">Figure 1</A>  DAG with equivalence for &quot;agreement.&quot;
<a href="1995017a.htm">Figure 2</A>  Possible results of unification.
<a href="1995017b.htm">Figure 3</A>  Value inheritance hierarchy and ValuePtr class relationship.
<a href="1995017c.htm">Figure 4</A>  Double-indirection function-call sequence.
<a href="1995017d.htm">Figure 5</A>  SubstitutionList's private data storage.
<h4><a name="016f_0072"><B>Example 1:</B> Part One grammar.<a name="016f_0072"></h4><P>
<pre>S     <img src="arrow12.gif" alt="--&gt;">   NP VP   (Sentence may be written as Noun Phrase then Verb Phrase)
VP    <img src="arrow12.gif" alt="--&gt;">   V NP    (Verb Phrase may be written as Verb then Noun Phrase)
NP    <img src="arrow12.gif" alt="--&gt;">   DET N   (Noun Phrase may be written as Determiner then Noun)
N     <img src="arrow12.gif" alt="--&gt;">   &quot;cow&quot;   (Noun may be written as &quot;cow&quot;)
N     <img src="arrow12.gif" alt="--&gt;">   &quot;grass&quot; (Noun may be written as &quot;grass&quot;)
V     <img src="arrow12.gif" alt="--&gt;">   &quot;eats&quot;  (Verb may be written as &quot;eats&quot;)
DET   <img src="arrow12.gif" alt="--&gt;">   &quot;the&quot;   (Determiner may be written as &quot;the&quot;)</pre><P>
<h4><a name="016f_0073"><B>Example 2:</B> The value for number has been percolated up through the rule system.<a name="016f_0073"></h4><P>
<pre>S <img src="arrow12.gif" alt="--&gt;"> NP VP
&lt;NP number&gt;=&lt;VP number&gt;</pre><P>
<h4><a name="016f_0074"><B>Example 3:</B> Part Two grammar.<a name="016f_0074"></h4><P>
<pre>S<img src="arrow12.gif" alt="--&gt;">NP VP
&lt;NP agreement&gt;=&lt;VP agreement&gt;
&lt;NP case&gt;=nominative
&lt;VP subcat&gt;=transitive
VP<img src="arrow12.gif" alt="--&gt;">V
&lt;VP agreement&gt;=&lt;V agreement&gt;
&lt;VP subcat&gt;=&lt;intransitive&gt;
&lt;VP subcat&gt;=&lt;V subcat&gt;
VP<img src="arrow12.gif" alt="--&gt;">V NP
&lt;VP agreement&gt;=&lt;V agreement&gt;
&lt;VP subcat&gt;=&lt;transitive&gt;
&lt;VP subcat&gt;=&lt;V subcat&gt;
NP<img src="arrow12.gif" alt="--&gt;">DET N
&lt;NP agreement&gt;=&lt;N agreement&gt;
&lt;NP agreement number&gt;=&lt;DET number&gt;
N<img src="arrow12.gif" alt="--&gt;">&quot;cow&quot;
&lt;N number&gt;=&lt;singular&gt;
N<img src="arrow12.gif" alt="--&gt;">&quot;grass&quot;
&lt;N number&gt;=&lt;singular&gt;
V<img src="arrow12.gif" alt="--&gt;">&quot;eat&quot;
&lt;V number&gt;=&lt;plural&gt;
&lt;VP subcat&gt;=&lt;transitive&gt;
V<img src="arrow12.gif" alt="--&gt;">&quot;eats&quot;
&lt;V number&gt;=&lt;singular&gt;
&lt;VP subcat&gt;=&lt;transitive&gt;
DET<img src="arrow12.gif" alt="--&gt;">&quot;the&quot;
&lt;N number&gt;=&lt;N agreement&gt;</pre><P>
<P>
<h4><a name="016f_0075">Listing One <a name="016f_0075"></h4><pre>

/*************************************************************************
       Base Value class and ValuePtr class 
       Copyright David Perelman-Hall &amp; Jamshid Afshar 1994.
*************************************************************************/

#ifndef VALUE_H
#define VALUE_H

#include &quot;misc.h&quot;    // GATHERED INCLUDES.  HELPS WITH PRE-COMPILED HEADERS.

// Forward References
class SubstitutionList;
class Value;

// Pointer (or Reference) class to a Value
class ValuePtr {
friend ostream&amp; operator &lt;&lt; (ostream&amp; os, const ValuePtr&amp; vp);
private:
   Value* _ptr;
public:
   ValuePtr();
   ValuePtr(const ValuePtr&amp; vp);
   ValuePtr(const Value&amp; v);
   ~ValuePtr();
   void operator=(const ValuePtr&amp; vp);
   bool operator==(const ValuePtr&amp; vp) const;
   bool operator!=(const ValuePtr&amp; vp) const;
   const Value* operator-&gt;() const;
   const Value&amp; operator*() const;
   operator const void*() const { return _ptr; }
};
// FORWARD REFERENCES TO CLASSES DERIVING FROM VALUE
class AtomicValue;
class VariableValue;
class DagValue;
class Value {
   public:
      //void CTOR
      Value() {}
      virtual Value* copy() const = 0;
      virtual void write(ostream&amp; os, int level=0) const = 0;
      virtual bool operator == (const Value&amp; value) const = 0;
      virtual bool operator == (const AtomicValue&amp;) const { return FALSE; }
      virtual bool operator == (const VariableValue&amp;) const { return FALSE; }
      virtual bool operator == (const DagValue&amp;) const { return FALSE; }
      virtual bool unify(const Value&amp; value, SubstitutionList&amp;, 
                                                          ValuePtr&amp;) const = 0;
      virtual bool unify(const AtomicValue&amp;, SubstitutionList&amp;, 
                                                              ValuePtr&amp;) const;
      virtual bool unify(const VariableValue&amp;, SubstitutionList&amp;, 
                                                              ValuePtr&amp;) const;
      virtual bool unify(const DagValue&amp;, SubstitutionList&amp;, ValuePtr&amp;) const;
      virtual ValuePtr substitute(const SubstitutionList&amp; substList) const = 0;
};
inline
ostream&amp; operator &lt;&lt; (ostream&amp; os, const Value&amp; v)
{
   v.write(os);
   return os;
}
inline ValuePtr::ValuePtr() : _ptr(0) { }
inline ValuePtr::ValuePtr(const ValuePtr&amp; vp) : _ptr(vp._ptr-&gt;copy()) { }
inline ValuePtr::ValuePtr(const Value&amp; v) : _ptr(v.copy()) { }
inline ValuePtr::~ValuePtr() { delete _ptr; _ptr=0; }
inline void ValuePtr::operator=(const ValuePtr&amp; vp){
   if(_ptr!=0)
      delete _ptr; 
   if(vp._ptr != 0)
      _ptr = vp._ptr-&gt;copy();
   else
      _ptr = 0;
}
inline bool ValuePtr::operator==(const ValuePtr&amp; vp) const
   { return (*_ptr) == *(vp._ptr); }
inline bool ValuePtr::operator!=(const ValuePtr&amp; vp) const
   { return !( *this == vp ); }
inline const Value* ValuePtr::operator-&gt;() const { assert(_ptr != 0); 
                                                                return _ptr; }
inline const Value&amp; ValuePtr::operator*() const { assert(_ptr != 0); 
                                                                return *_ptr; }
inline ostream&amp; operator &lt;&lt; (ostream&amp; os, const ValuePtr&amp; vp)
{
   assert(vp._ptr != 0);
   os &lt;&lt; *(vp._ptr);
   return os;
}
#endif


</pre>
<h4><a name="016f_0076">Listing Two<a name="016f_0076"></h4><pre>

#include &quot;misc.h&quot;    // GATHERED INCLUDES.  HELPS WITH PRE-COMPILED HEADERS
#pragma hdrstop      // END OF PRE-COMPILED HEADER INCLUDES

//PROTOTYPED FOR EACH DERIVED CLASS
bool Value::unify(const AtomicValue&amp;, SubstitutionList&amp;, ValuePtr&amp;) const
   { return FALSE; }
bool Value::unify(const VariableValue&amp;, SubstitutionList&amp;, ValuePtr&amp;) const
   { return FALSE; }
bool Value::unify(const DagValue&amp;, SubstitutionList&amp;, ValuePtr&amp;) const
   { return FALSE; }


</pre>
<h4><a name="016f_0077">Listing Three<a name="016f_0077"></h4><pre>

/*************************************************************************
   AtomicValue class -- Copyright David Perelman-Hall &amp; Jamshid Afshar 1994.
*************************************************************************/

#ifndef ATOMIC_H
#define ATOMIC_H

#include &lt;cstring.h&gt;    // BORLAND HEADER
#include &quot;value.h&quot;      // BASE VALUE &amp; VALUEPTR CLASSES

typedef string String;
#define Atomic String

class AtomicValue : public Value, public Atomic {
   public:
      //EMPTY CTOR
      AtomicValue(){}
      //COPY CTOR
      AtomicValue( const AtomicValue&amp; value ) : Atomic(value) { }
      //CONSTRUCTOR
      AtomicValue( const String&amp; str ) : Atomic(str) { }
      //CONSTRUCTOR
      AtomicValue( const char* s ) : Atomic(s) { }
      //RETURN POINTER TO NEW ATOMIC VALUE COPY CONSTRUCTED FROM THIS
      Value* copy() const { return new AtomicValue(*this); }
      // EXPLICIT STRING CONVERSION
      const String&amp; str() const { return (const Atomic&amp;)*this; }
      //ASSIGNMENT OPERATOR
      void operator = (const AtomicValue&amp; value) { Atomic::operator=(value); }
      //EQUALITY
      virtual bool operator == (const Value&amp; value) const;
      virtual bool operator == (const AtomicValue&amp; value) const;
      // UNIFY
      virtual bool unify(const Value&amp; value, SubstitutionList&amp; subst, 
                                                      ValuePtr&amp; result) const;
      virtual bool unify(const AtomicValue&amp; value, SubstitutionList&amp; /*subst*/,
                                                      ValuePtr&amp; result) const;
      // OUTPUT
      virtual void write(ostream&amp; os, int level) const 
                                                { os &lt;&lt; (const Atomic&amp;)*this; }
      // SUBSTITUTE
      virtual ValuePtr substitute(const SubstitutionList&amp; /*substList*/) const
         {  return *this; }
};
#endif


</pre>
<h4><a name="016f_0107"><a name="016f_0078">Listing Four<a name="016f_0078"></h4><pre>

#include &quot;misc.h&quot;
#pragma hdrstop

//PROTOTYPED FOR BASE CLASS
bool AtomicValue::operator == (const Value&amp; value) const
   { return value==*this; }
//PROTOTYPED FOR ATOMIC VALUE
bool AtomicValue::operator == (const AtomicValue&amp; value) const
   { return (Atomic&amp;)*this == (Atomic&amp;)value; }
//PROTOTYPED FOR BASE CLASS
bool AtomicValue::unify(const Value&amp; value, SubstitutionList&amp; subst, 
                                                       ValuePtr&amp; result) const
      { return value.unify(*this, subst, result); }
//PROTOTYPED FOR ATOMIC VALUE
bool AtomicValue::unify(const AtomicValue&amp; value, SubstitutionList&amp; /*subst*/,
                                                        ValuePtr&amp; result) const
{ 
   if (value == *this) {
      result = *this;
      return TRUE; 
   }
   else {
      return FALSE; 
   }
}


</pre>
<h4><a name="016f_0079">Listing Five<a name="016f_0079"></h4><pre>

/*************************************************************************
VariableValue class -- Copyright David Perelman-Hall &amp; Jamshid Afshar 1994.
*************************************************************************/

#ifndef VARIABLE_H
#define VARIABLE_H

#include &lt;cstring.h&gt;    // BORLAND HEADER
#include &quot;value.h&quot;      // BASE VALUE CLASS

typedef string Variable;  // BORLAND

Variable gensym();

class VariableValue : public Value {
private:
   Variable _v;
public:
   //empty constructor
   VariableValue(){}
   //copy constructor
   VariableValue( const VariableValue&amp; value ) : _v(value._v) { }
   VariableValue( const Variable&amp; var ) : _v(var) { }
   Value* copy() const { return new VariableValue(*this); }
   const Variable&amp; str() const { return _v; }

   //assignment operator
   void operator = (const VariableValue&amp; value) { _v = value._v; }
   virtual bool operator == (const Value&amp; value) const;
   virtual bool operator == (const VariableValue&amp; value) const;
   virtual bool unify(const Value&amp; value, SubstitutionList&amp; subst, 
                                                       ValuePtr&amp; result) const;
   virtual bool unify(const AtomicValue&amp;, SubstitutionList&amp;, 
                                                       ValuePtr&amp; result) const;

   virtual bool unify(const VariableValue&amp; var, SubstitutionList&amp; subst, 
                                                       ValuePtr&amp; result) const;
   virtual bool unify(const DagValue&amp;, SubstitutionList&amp;, 
                                                       ValuePtr&amp; result) const;
   virtual void write(ostream&amp; os, int level) const { os &lt;&lt; _v; }
   virtual void read(istream&amp; is) { is &gt;&gt; _v; }
   virtual ValuePtr substitute(const SubstitutionList&amp; substList) const;
};
#endif


</pre>
<h4><a name="016f_007a">Listing Six<a name="016f_007a"></h4><pre>

#include &quot;misc.h&quot;
#pragma hdrstop
#include &lt;stdio.h&gt;

Variable gensym()
{
   static unsigned i = 0;
   char sym[20];
   sprintf(sym, &quot;_X%ud&quot;, i++);
   return Variable(sym);
}
bool VariableValue::unify(const Value&amp; value, SubstitutionList&amp; subst, 
                                                        ValuePtr&amp; result) const
{ 
   if (!value.unify(*this, subst, result)) {
      if (!subst.set(_v, value)) 
         return FALSE;
      result = value;
   }
  return TRUE;
}
bool VariableValue::unify(const AtomicValue&amp; value, SubstitutionList&amp; subst, 
                                                        ValuePtr&amp; result) const
{ 
   if( !subst.set(_v, value) )
      return FALSE;
  result = value; 
  return TRUE;
}
bool VariableValue::unify(const VariableValue&amp; var, SubstitutionList&amp; subst, 
                                                        ValuePtr&amp; result) const
{ 
   if( !subst.set_identical(_v, var.str()) ) {
      //cerr &lt;&lt; &quot;unify vars (&quot; &lt;&lt; *this &lt;&lt; &quot;,&quot; &lt;&lt; var &lt;&lt; &quot;)\n&quot;; //##
      return FALSE;
   }
   result = var; 
   return TRUE;
}
bool VariableValue::unify(const DagValue&amp; value, SubstitutionList&amp; subst, 
                                                        ValuePtr&amp; result) const
{
   if( !subst.set(_v, value) )
      return FALSE;
   result = value; 
   return TRUE; 
}
ValuePtr VariableValue::substitute(const SubstitutionList&amp; substList) const
{ 
   if( substList.contains(_v) )
      return substList.val(_v);
   else
      return VariableValue(_v);
}
bool VariableValue::operator == (const Value&amp; value) const
{ return value==*this; }
bool VariableValue::operator == (const VariableValue&amp; /*value*/) const
{ return TRUE;/*## _v == value._v;*/ }


</pre>
<h4><a name="016f_007b">Listing Seven<a name="016f_007b"></h4><pre>

/*************************************************************************
   DagValue class -- Copyright David Perelman-Hall &amp; Jamshid Afshar 1994.
*************************************************************************/

#ifndef DAG_H
#define DAG_H

#include &quot;misc.h&quot;
#include &quot;value.h&quot;
#include &quot;atomic.h&quot;
#include &quot;variable.h&quot;

typedef MapOf&lt;Feature, ValuePtr&gt; FVList;
typedef MapOfIter&lt;Feature, ValuePtr&gt; FVListIter;

class Dag {
public:
   // CONSTRUCTOR
   Dag():_datap(new Data){}
   // COPY CONSTRUCTOR 
   Dag(const Dag&amp; dag): _datap(dag._datap){}
   // DESTRUCTOR
   ~Dag(){}
   // ASSIGNMENT OPERATOR
   void operator=(const Dag&amp; dag){_datap=dag._datap;}
   // ADD A FEATURE-VALUE PAIR TO THIS DAG
   void add(const Feature&amp; f, const ValuePtr&amp; vp){own_fvlist().enter(f,vp);}
   // EQUALITY OPERATORS
   bool operator==(const Dag&amp; dag) const;
   bool operator!=(const Dag&amp; dag) const {return !operator==(dag);}
   // CLEAR DATA FROM THIS DAG
   void clear(void){own_fvlist().clear();}
   // TEST FOR EXISTENCE OF FEATURE IN THIS DAG
   bool contains(const Feature&amp; feature) const {
      return fvlist().contains(feature);
   }
   // RETRIEVE VALUE ASSOCIATED WITH FEATURE 
   ValuePtr value(const Feature&amp; feature) const {
      if(!fvlist().contains(feature)){
         cerr &lt;&lt; &quot;Dag &quot; &lt;&lt; *this &lt;&lt; &quot; does not have feature &quot; &lt;&lt; feature
         &lt;&lt; endl;
      }
      assert(fvlist().contains(feature));
      return fvlist().valueOf(feature);
   }
   // RETRIEVE THE LIST OF FEATURES OF THIS DAG
   FeatureSet list_features() const;
   // SET SUBSTITUTION FOR VARIABLES 
   Dag substitute(const SubstitutionList&amp; substList) const;
   // APPLY SUBSTITUTION
   static Dag apply_substitution(const Dag&amp; dag,
      const SubstitutionList&amp; substList){return dag.substitute(substList);}
   // OUTPUT OPERATOR
   void write(ostream&amp; os, int level) const;
   // IOSTREAM OPERATORS
   friend ostream&amp; operator &lt;&lt; ( ostream&amp; os, const Dag&amp; dag );
   //friend istream&amp; operator &gt;&gt; ( istream&amp; is, Dag&amp; dag );
private:
   struct Data {
      FVList fvs;
      Data() {}
      Data(const FVList&amp; map) : fvs(map) {}
   };
   Data *_datap;
   const FVList&amp; fvlist() const {return _datap-&gt;fvs;}
   FVList&amp; own_fvlist() {return _datap-&gt;fvs;}
};
/*
inline
istream&amp; operator &gt;&gt; ( istream&amp; is, Dag&amp; dag )
{ 
   is &gt;&gt; dag.own_fvlist(); 
   return is;
}
*/
// DECLARATION OF GLOBAL UNIFY WHICH ACTUALLY UNIFIES TWO DAGs
bool unify(const Dag&amp; dag1, const Dag&amp; dag2, SubstitutionList&amp; subst,
                                                                  Dag&amp; result);
// DECLARATION &amp; DEFINITION OF GLOBAL UNIFY TAKING TWO DAG REFERENCES,
// DOES NOT ACTUALLY UNIFY, BUT RETURNS BOOLEAN TEST ON THEIR UNIFICATION
inline
bool unify(const Dag&amp; dag1, const Dag&amp; dag2){
   SubstitutionList subst;
   Dag result;
   return unify(dag1, dag2, subst, result);
}
// MAKE DAG_LIST CLASS
typedef ListOf&lt;Dag&gt; DagList;
typedef ListOfIter&lt;Dag&gt; DagIter;

ostream&amp; operator&lt;&lt;(ostream&amp; os, const ListOf&lt;Dag&gt;&amp; list);

class DagValue : public Value {
private:
   Dag _d;
public:
   //empty constructor
   DagValue(){}
   //copy constructor
   DagValue( const DagValue&amp; value ) : _d(value._d) { }
   DagValue( const Dag&amp; dag ) : _d(dag) { }
   Value* copy() const { return new DagValue(*this); }
   //assignment operator
   void operator = (const DagValue&amp; value) { _d = value._d; }

   virtual bool operator == (const Value&amp; value) const
      { return value==*this; }
   virtual bool operator == (const DagValue&amp; value) const
      { return _d==value._d; }
   virtual bool unify(const Value&amp; value, SubstitutionList&amp; subst, 
                                                        ValuePtr&amp; result) const
      { return value.unify(*this, subst, result); }
   virtual bool unify(const DagValue&amp; value, SubstitutionList&amp; subst, 
                                                       ValuePtr&amp; result) const;
   virtual void write(ostream&amp; os, int level) const;
   //virtual void read(istream&amp; is) { is &gt;&gt; _d; }
   virtual ValuePtr substitute(const SubstitutionList&amp; substList) const;
};
#endif


</pre>
<h4><a name="016f_007c">Listing Eight<a name="016f_007c"></h4><pre>

#include &quot;misc.h&quot;
#pragma hdrstop

// DAG SPECIFIC OSTREAM OPERATOR
ostream&amp; operator &lt;&lt; ( ostream&amp; os, const Dag&amp; dag )
{
   dag.write(os, 0);
   return os;
}
// DAG SPECIFIC OUTPUT OPERATOR
void Dag::write(ostream&amp; os, int level) const
{
   os &lt;&lt; &quot;[&quot;;
   for (FVListIter i(&amp;fvlist()); !i.offEnd(); i.next()) {
      os &lt;&lt; i.key() &lt;&lt; &quot; : &quot;;
      i.value()-&gt;write(os, level+1);
      if (!i.last()) {
               os &lt;&lt; &quot;\n&quot;;
               for (int i=0; i&lt;level; i++)
                  os &lt;&lt; &quot;   &quot;;
               os &lt;&lt; &quot; &quot;;
         os &lt;&lt; &quot; | &quot;;
         }
      }
   os &lt;&lt; &quot;]&quot;;
}
// RETRIEVE THE LIST OF FEATURES OF THIS DAG
FeatureSet Dag::list_features() const 
{
   // CREATE A SET OF KEYS TO RETURN
   FeatureSet tmp_features(fvlist().keys(),fvlist().size());
   // RETURN IT
   return tmp_features;
}
// EQUALITY OPERATOR
bool Dag::operator==(const Dag&amp; d) const
{
   // TYPEDEF AN ITERATOR OVER A MAP FROM FEATURES TO VALUE POINTERS
   typedef MapOfIter&lt;Feature, ValuePtr&gt; FVIter;
   // STEP SIUMULTANEOUSLY THROUGH LIST OF FEATURES 
   for (FVIter fv1(&amp;this-&gt;fvlist()), fv2(&amp;d.fvlist()); 
                       !fv1.offEnd() &amp;&amp; !fv2.offEnd(); fv1.next(), fv2.next()){
      // IF EITHER CURRENT FEATURES OR CURRENT VALUES DON'T MATCH, RETURN FALSE
      if (fv1.key()!=fv2.key() || fv1.value()!=fv2.value())
         return FALSE;
   }
   // RETURN TRUE IF STEPPED ENTIRELY THROUGH BOTH LISTS, ELSE RETURN FALSE
   return fv1.offEnd() &amp;&amp; fv2.offEnd();
}
// SUBSTITUTE
Dag Dag::substitute(const SubstitutionList&amp; substList) const
{
   // RETURN DAG
   Dag tmpDag;
   // LIST OF FEATURES IN THIS DAG
   FeatureSet features=list_features();
   // STEP THROUGH LIST OF FEATURES FROM THIS DAG
   for (SetOfIter&lt;Feature&gt; feature(&amp;features); feature; ++feature)
      // ADD TO RETURN DAG THE FEATURE AND ANY VALUE LISTED FOR IT IN THE
      // SUBSTITUTION LIST, AS FOLLOWS:
      // 1) IF THERE IS A SUBSTITUTION FOR IT AND THE VALUE IS A
      //    VARIABLE, ADD WHATEVER EXISTS IN THE SUBSTITUTION LIST
      //    FOR THAT VARIABLE,
      // 2) IF THERE IS NO SUBSTITUTION FOR IT AND THE VALUE IS A
      //    VARIABLE, ADD THE VARIABLE,
      tmpDag.add(feature(),value(feature())-&gt;substitute(substList));
   // RETURN THE CREATED DAG
   return tmpDag;
}
// OUTPUT OPERATOR FOR A DAGVALUE
void DagValue::write(ostream&amp; os, int level) const
{
   _d.write(os, level);
}
bool DagValue::unify(const DagValue&amp; value, SubstitutionList&amp; subst, 
                                                        ValuePtr&amp; result) const
{
   Dag unification;
   // CALL GLOBAL FUNCTION, PASSING 2 DAGs
   if (::unify(_d, value._d, subst, unification)) {
      result = DagValue(unification);
      return TRUE;
   }
   else {
      return FALSE;
   }
}
ValuePtr DagValue::substitute(const SubstitutionList&amp; substList) const
{ return DagValue(_d.substitute(substList)); }
// GLOBAL UNIFY FUNCTION
bool unify(const Dag&amp; dag1,const Dag&amp; dag2,SubstitutionList&amp; subst,Dag&amp; result)
{
   // GET SET OF ALL FEATURES FROM BOTH DGAS
   FeatureSet features = dag1.list_features() + dag2.list_features();
   {
   for (SetOfIter&lt;Feature&gt; feature(&amp;features); feature; ++feature) {
      // TRY TO UNIFY VALUES WHERE FEATURE IS COMMON TO BOTH DAGS
      if (dag1.contains(feature()) &amp;&amp; dag2.contains(feature())) {
         // cout &lt;&lt; &quot;Attempting to unify feature &quot; &lt;&lt; feature() 
                                                   &lt;&lt; &quot; in both dags.&quot; &lt;&lt; endl;
         ValuePtr unified_value; // HOLD THE RESULT OF SUCCESSFUL UNIFICATION

         // CALL VALUE::UNIFY THROUGH VALUEPTR WRAPPER, BUILD UP SUBSTITUTION 
         // LIST &amp; RESULTING DAG
         if (dag1.value(feature())-&gt;unify(*(dag2.value(feature())), subst, 
                                                              unified_value)) {
            result.add(feature(), unified_value);
         }
         else { // FAILED TO UNIFY VALUES FOR FEATURE COMMON TO BOTH DAGS
            cout &lt;&lt; dag1.value(feature()) &lt;&lt; &quot; and &quot; &lt;&lt; dag2.value(feature()) 
                                                  &lt;&lt; &quot; did not unify.&quot; &lt;&lt; endl;
            return FALSE;
            }
      }
      else { // ADD FEATURE-VALUE WHERE EXISTS IN ONE DAG ONLY
         if(dag1.contains(feature()))
            result.add(feature(), dag1.value(feature()));
         else
            result.add(feature(), dag2.value(feature()));
      }
   }
   }
   Dag result_with_subst;
   {
   // DO VARIABLE SUBSTITUTIONS BUILT UP IN PREVIOUS LOOP
   for (SetOfIter&lt;Feature&gt; feature(&amp;features); feature; ++feature) {
      result_with_subst.add(feature(), 
                                   result.value(feature())-&gt;substitute(subst));
   }
   }
   result = result_with_subst;
   return TRUE;
}     End Listings



</pre>
<HR><P>Copyright &copy; 1995, <I>Dr. Dobb's Journal</I></P></BODY></HTML>
