<HTML>
<META NAME="year" CONTENT="1995">

<HEAD>
<TITLE>NOV95: Data Models, CASE Tools, and Client/Server Development</TITLE></HEAD>
<BODY BGCOLOR="#ffffff">
<h1>Data Models, CASE Tools, and Client/Server Development<a name="01d7_0096"><a name="01d7_0094"><a name="01d7_0000"></h1><P>
<h2>Creating a two-way link between a CASE tool and DBMS</h2><P>
<h3>Tim Wittenburg</h3><P>
<p><i><a name="01d7_0095"><a name="01d7_0000">Tim, who is a team leader at AmeriData Consulting, has designed and developed  client/server applications for six years and is the author of Photo-Based 3D Graphics in C++ (John Wiley &amp; Sons, 1995). Tim can be reached on CompuServe at 70403,3570.</i></p><hr><P>
Building client/server applications often involves getting business experts together with modelers, GUI designers, and developers. The activities of these teams are usually divided into phases. In the first phase, a modeling team gathers requirements from key persons within the organization. Process models and/or a data model are then constructed using a computer assisted software engineering (CASE) tool. Once the data model is completed, the modeling team passes off the project to the development team. This begins the second phase, in which the requirements and data model are merged into a functioning information-management system. <P>
The transition between phases is critical because intangibles (user expectations, for instance) can be lost in the shuffle. In this article, I'll present DBA Assistant, a tool designed to smooth the transition between the project phases in two ways: <P>
<UL>
<li>Transforming the data model developed in the first phase directly into a physical database. </li>
<li>Reverse-engineering the schema of an existing ODBC-compliant database and exporting it to a CASE tool that prepares a physical entity-relationship model. Exporting schemata is useful if the database moves from one database management system (DBMS) to another.</li>
</UL>
Depending on the modeling tools, a direct link between the data model and the DBMS may or may not exist. If not, database administrators (DBAs) must manually enter the entire database definition into the DBMS. Despite the important differences between a logical model and its physical-data-model counterpart, a one-to-one correspondence exists between a percentage of the entities and attributes in the logical and physical model. Because the percentage of correspondence is often high, significant time could be saved if a data definition language (DDL) description were generated directly from the data model. This is precisely what my DBA Assistant program does.<P>
When there is no clean break between the modeling and development efforts, it is desirable to keep the data model synchronized with the physical database definition as the model and database are refined. In many situations, no convenient synchronization mechanisms exist. DBA Assistant can reduce the synchronization effort.<P>
DBA Assistant also lets the modeling team move the data model into an approximation of a functioning database suitable for efficient prototyping of client/server application screens. The drag-and-drop screen-building features of most GUI development tools (PowerBuilder, Access, Visual Basic, and the like) can only be used if an underlying database is available. Having a representative database allows prototype screens to be prepared for the purpose of exploring and resolving GUI design issues before full-scale development begins. <P>
DBA Assistant, which is written in Microsoft Access Basic, provides a two-way link between a CASE tool (System Architect from Popkin Software, in this case) and a target DBMS. The program provides two essential capabilities: <P>
<UL>
<li>Enabling a logical data model to be translated into a physical database, as in <a href="199501d9.htm">Figure 1</A>. </li>
<li>Enabling documentation of an existing database by exporting a database structure such that it can be imported into a CASE tool and translated into an entity-relationship diagram; see <a href="199501da.htm">Figure 2</A>.</li>
</UL>
A database schema can be imported into a CASE tool for generating an ER diagram. This is useful when a database has been maintained over a long period of time, perhaps by several individuals. Microsoft Access's data access object (DAO) encapsulates many aspects of a relational database (including its schema) in a set of objects which have been exposed in the Access Basic development environment. DBA Assistant traverses the DAO to translate schema information into a series of text files which can be imported into the System Architect, from which a physical ER diagram or model can be prepared. In addition, a text file is created to contain the database schema as represented by a series of ANSI SQL Create Table statements. <P>
Most of Access's internal objects have been organized into the DAO hierarchy and can be manipulated using the Access Basic language. My approach utilizes properties of the DAO to describe the physical structure of a selected database. My goal is to collect a description of all the tables in an Access database (including descriptions of each column associated with a database table) along with the data types and column lengths. To accomplish this, I'll focus on two DAO collections--<I>TableDefs</I> and <I>Fields</I>. <P>
<h3><a name="01d7_0097">DAO Collections and Schema Exports<a name="01d7_0097"></h3><P>
The <I>TableDefs</I> collection contains a description of all tables visible to an Access database, including attached tables (for which read permission has been granted). The number of tables in <I>TableDefs</I> is a property of the collection <I>numTables=localDB.tableDefs.count</I>, where <I>localDB</I> is a pointer to the local Access database. Table names can be retrieved by <I>tableName=localDB.tableDefs(i).name</I>, and the entire list of tables can be obtained by varying <I>i</I> from 0 to <I>numTables-1</I>. Once a table is identified, the <I>Fields</I> collection lets you identify its attributes or fields.<P>
After the table name is obtained from <I>TableDefs</I>, you must determine which fields are associated with the table. The number of fields in each table in <I>Table-Defs</I> can be obtained with <I>numFields=localDB.tableDefs(i).fields.count</I>. You get the properties of each field in the table using <I>property=localDB.table Defs(i).fields (j). prop</I>. By varying <I>j</I> from 0 to <I>numFields-1</I>, you can get the properties of each field in a table in <I>TableDefs</I>. For example, to get the name of the first column in the first table, enter <I>fieldName=localDB.tableDefs(0).fields(0).name</I>. You can also get the <I>datatype</I> and <I>length</I> of the field in bytes this way. <P>
<a href="#01d7_009e">Listing One</A> presents the Access Basic function <I>read-AccessDB</I>, which traverses the DAO, extracting the database schema from the DAO <I>TableDefs</I> and <I>Fields</I> collections. The resulting schema information is stored in the <I>dbDictionary </I>Access database table.  Once the database dictionary is created by <I>readAccessDB</I>, the CASE-tool-compatible text files and the DDL files are created.<P>
To export to System Architect, you first create the entity.txt file (all files are available electronically; see &quot;Availability,&quot; page 3) that lists the entities to appear in the ER model. Next, create the datastrc.txt file, which contains System Architect data structures that link the appropriate attributes for each entity. A third text file, element.csv, is created in comma separated value (CSV) format and lists all the data elements in the entire database, along with the associated table and data type. Finally, table.sql is created; it contains a description of the database using DDL statements. Each of these text files is created in the procedure <I>readAccessDB</I> in <a href="#01d7_009e">Listing One</A>.<P>
The schema-export approach assumes a one-to-one correspondence between physical database tables and entities in a physical ER diagram. Similarly, a one-to-one correspondence is assumed between the columns in a database table and attributes associated with an entity in a physical model. This means that primary and foreign keys appear as attributes in the physical ER model prepared from the exported schema. DBA Assistant assumes that the primary key in each table is indicated by the prefix <I>PK_</I> followed by the name of the table. (For example, the primary key for the <I>dbDictionary</I> table would be <I>PK_dbDictionary</I>.) When a member of the DAO <I>Fields</I> collection conforms to this assumption, DBA Assistant adds a &quot;@&quot; prefix to the column name while creating the exported-schema text files. System Architect then interprets the column as a primary key and indicates it as such in the physical ER diagram.<P>
At this point, you can generate a DDL statement that defines a database table and all its columns; in other words, it defines an entity and its attributes, together with a portion of the metadata. This requires the SQL Create Table statement, a permutation of the schema information obtained earlier by traversing the DAO (for example, <I>CREATE TABLE table (field1 type [(size)] [index1] [, field2 type [(size)] [index2] [, ...]])</I>). The Access Basic procedure <I>readAccessDB</I> generates the file table.sql at the same time the CASE-compatible text files are generated.<P>
Since Access's set of database data types differ from those which can be selected in System Architect, you need a mapping function to transform the data type of each Access database attribute into a corresponding data type compatible with System Architect. To build this, you simply use a look-up scheme; see the <I>mapSATypeToAccessType</I> function in <a href="#01d7_00a0">Listing Two</A>, which returns the Access data type that most closely corresponds to a System Architect-compatible data type supplied as the function's argument.<P>
<h3><a name="01d7_0098">Using DBA Assistant<a name="01d7_0098"></h3><P>
DBA Assistant is an Access application. To use the tool's schema-export feature, open DBA Assistant. When <a href="199501db.htm">Figure 3</A> appears, press the &quot;Export a dB Schema&quot; button; <a href="199501dc.htm">Figure 4</A> will appear. Choose the Access database from which to export by pressing the upper &quot;Locate&quot; button and selecting the desired .mdb file. Specify the directory in which to place the exported schema text files by pressing the lower &quot;Locate&quot; button. When the &quot;Export the DB&quot; button is pressed, the schema of the selected Access database is exported. When the procedure is complete, the four text files described previously should exist in the same directory as the Access application.<P>
To import definitions into System Architect, first create a new System Architect encyclopedia. Select &quot;Import Data&quot; from the Definition menu; <a href="199501dd.htm">Figure 5</A> appears. Select &quot;Entity&quot; from the first combo box, then Text. Supply the name of the entity text file produced by DBA Assistant (entity.txt) and click the &quot;OK&quot; button. Repeat this for the data-structure file. Next, elements are imported by choosing &quot;.CSV&quot; format and &quot;Data&quot; element from the appropriate combo boxes. Enter the pathname of the element file created by DBA Assistant (element.csv in <a href="199501de.htm">Figure 5</A>) and click &quot;OK.&quot; <P>
At this point, all of the relevant information has been imported into System Architect and the encyclopedia needs to be updated. Select &quot;Dictionary Update&quot; from the System Architect File menu and answer &quot;yes&quot; to the question: Do you wish to update all definitions? At this point a new ER diagram can be created, and you can create entities by dragging and dropping onto it. <P>
<h3><a name="01d7_0099">Exporting the Data Model from System Architect<a name="01d7_0099"></h3><P>
Building an Access database from an ER diagram begins by exporting a physical data model from System Architect. First you export its statement, then import the physical model into Access using DBA Assistant. A new ODBC-compliant database is created from the model by generating and executing the appropriate DDL statements. <P>
You can export the data-model elements from System Architect. ER model attributes marked by the modeling team as primary keys in System Architect are indicated in the element.csv file by an @ sign preceding the element name. <P>
<h3><a name="01d7_009a">Creating a Database from a Model<a name="01d7_009a"></h3><P>
A database is created by reading the exported data model in element.csv into Access using <I>readElementsfile</I>, which reads the ER model definition and populates the <I>dbDictionary</I> table. Next, the entities and attributes defined in <I>dbDictionary</I> generate the tables in the Access database file; see the Access Basic procedure <I>makeAccessTables</I>. These procedures appear in <a href="#01d7_00a0">Listing Two</A>.<P>
The procedure <I>mapSATypetoAccessType</I> performs a lookup-style substitution of System Architect C Storage types to Access database data types. Character strings longer than 255 are converted to the Access memo type. You may wish to add other types of mappings for Access types such as Date/Time and Yes/No. <P>
The Access Basic procedure <I>makeAccessTables</I> constructs an SQL Create Table statement from information contained in the internal <I>dbDictionary</I> table. This statement executes in the remote database using the ODBC connection created between DBA Assistant and the remote Access database file identified by the user. This procedure could easily be extended to accept an ODBC data-source name instead of an Access .mdb file name. In this way, databases could be created in any ODBC-compliant DBMS.<P>
The System Architect data-element export file contains only data elements. Any additional elements designated as keys in the model are exported in the System Architect entities export file. To transfer the keys, the entity.csv file is entered into the DBA Assistant. When &quot;Create Database&quot; is pressed, the data element and entity .csv files are processed to remove extra carriage returns. This converts the entity export from System Architect into a valid .csv file. This file is then imported into Access via <I>TransferText</I>. The resulting table has the name &quot;entity&quot; and contains one record for each entity defined in the System Architect model. The first column indicates the entity name; the second contains the description of all the attributes associated with this entity. Unique keys have an @ prefix, and foreign keys are indicated by the keyword &quot;FKFROM.&quot;<P>
The Access Basic <I>CreateKeys</I> procedure reads the entity table, identifies all keys of both types, and saves the key definitions in the <I>dbKey </I>Access table. Once the keys are saved, the additional key columns are added to the existing Access table definitions using the SQL Alter Table statement.<P>
An associative entity or class defined in the data model may have attributes that consist entirely of keys. In this case, the associative entity would not have been defined in System Architect's data-element export file because technically, none of the entity's attributes are data elements--they are keys. Consequently, the entity name indicated in the System Architect entity export file may not exist in the partially created database. In this case, issuing an SQL Alter Table statement to the database for a table which does not exist will result in an error. Fortunately, you can detect this error and respond appropriately. The procedure first issues an Alter Table statement. If a &quot;table doesn't exist&quot; error results, it constructs a SQL Create Table statement using only the single key column. Subsequent key columns defined in the model for this entity will be added using alternative table statements as additional records in the <I>dbKey</I> table are processed. Since the key attributes are not contained in the data element's exported file, there is no way to determine the key column's data type from the information exported from System Architect. Consequently, DBA Assistant assumes that all keys are of type <I>long integer</I>. A workaround is to encode the data-type information in the data-element name; for example, add a <I>_Date</I> suffix to the data-element name for keys of type <I>Date</I>. Then, a mapping function can be constructed in Access to identify the suffix and create the keys with the desired type information.<P>
Finally, for each key column indicated in the <I>dbKeys</I> table, <I>CreateKeys</I> creates a simple database index to speed performance during queries. Data-integrity constraints can be placed on each index to indicate that the column is, say, mandatory, or must be unique. DBA Assistant creates the simplest type of index using the SQL Create Index statement as in <I>CREATE INDEX IndexName ON TableName (ColumnName);</I>. A test data model (element.csv) lets you create databases.<P>
<h3><a name="01d7_009b">Summary<a name="01d7_009b"></h3><P>
DBA Assistant is useful for bridging the gap between modeling efforts and creating the physical database upon which client/server applications are constructed. The use of tools such as DB Assistant can result in more-effective management of client/server development projects because the amount of time and effort required to synchronize a physical ER Model to a corresponding database is reduced.<P>
<h3><a name="01d7_009c">For More Information<a name="01d7_009c"></h3><P>
System Architect<P>
Popkin Software &amp; Systems<P>
11 Park Place <P>
New York, NY 10007<P>
800-732-5227<P>
<P>
Microsoft Access <P>
Microsoft Corp.<P>
One Microsoft Way<P>
Redmond, WA 98052<P>
206-882-8080<P>
<B><a href="199501df.htm">Figure 1</A>:</B> Path from a DBMS to a CASE tool.<P>
<B><a href="199501e0.htm">Figure 2</A>: </B>Path from a CASE tool to a DBMS.<P>
<B><a href="199501e1.htm">Figure 3</A>: </B>Opening DBA Assistant screen.<P>
<B><a href="199501e2.htm">Figure 4</A>:</B> DBA Assistant Export screen.<P>
<B><a href="199501e3.htm">Figure 5</A>:</B> System Architect Import Data screen.<P>
<P>
<h4><a name="01d7_009d"><a name="01d7_009e">Listing One<a name="01d7_009e"></h4><pre>
Sub readAccessDB (myDB As Database, theControl As Control, rootDirectory)
'  save the structure of an Access database using the DAO hierarchy
'  Access  --&gt; CASE Tool
    Dim crlf, dbName, numTables, counter, sql, tableName, foreignKeys
    Dim sqlTableName,createTable,theTypeCode,theLength,theName,theColumnName
    Dim thePureColumnName, sqlCol
    Dim theDescription
    crlf = Chr(10)
    Dim localDB As Database
    Set localDB = dbengine.workspaces(0).databases(0)
    Dim i As Integer, j As Integer, cols As Integer
    Dim theType
    DoCmd Hourglass True
    If Mid(rootDirectory, Len(rootDirectory), 1) &lt;&gt; &quot;\&quot; Then
      rootDirectory = rootDirectory &amp; &quot;\&quot;
    End If
    Open rootDirectory &amp; &quot;entity.txt&quot; For Output As #1
    Open rootDirectory &amp; &quot;datastrc.txt&quot; For Output As #2
    Open rootDirectory &amp; &quot;element.csv&quot; For Output As #3
    Open rootDirectory &amp; &quot;table.sql&quot; For Output As #4
    Print #3, &quot;Name,Description,Domain,Comments,Length,Business Unit,
      Column Name,Database,Table,Version,C Storage Type,C Storage Occurrences,
      Storage Class,Storage Picture,Display Picture&quot;
    dbName = myDB.name
    numTables = myDB.tabledefs.count
    counter = 0
    sql = &quot;delete from dbDictionary;&quot;      ' clear the dictionary
    localDB.Execute (sql)
    For i = 0 To numTables - 1
    tableName = myDB.tabledefs(i).name
    theControl = &quot;Exporting table: &quot; &amp; tableName
    DoEvents
    foreignKeys = &quot;&quot;
    If (tableName &lt;&gt; &quot;Paste Errors&quot;) And (Mid(tableName, 1, 4) &lt;&gt; &quot;MSys&quot;) 
     Then   'ignore system tables
       Print #1, &quot;&lt;&lt;&quot; &amp; tableName &amp; &quot;&gt;&gt;&quot;
       Print #2, &quot;&lt;&lt;&quot; &amp; tableName &amp; &quot;&gt;&gt;&quot;
       Print #1, tableName
    cols = myDB.tabledefs(i).fields.count
    sqlTableName = &quot;[&quot; &amp; tableName &amp; &quot;]&quot;
    createTable = &quot;drop table &quot; &amp; sqlTableName &amp; &quot;;&quot;
    Print #4, createTable
    createTable = &quot;create table &quot; &amp; sqlTableName &amp; &quot; (&quot;
    Print #4, createTable
    For j = 0 To cols - 1
    theTypeCode = myDB.tabledefs(i).fields(j).type
    theLength = myDB.tabledefs(i).fields(j).size
    theName = myDB.tabledefs(i).fields(j).name
    theColumnName = myDB.tabledefs(i).fields(j).name
    theDescription = &quot; &quot;  ' none for now.  see TechNet article Q109136
    theType = &quot;Undefined&quot;
    Select Case theTypeCode
      Case DB_SINGLE
        theType = &quot;Float&quot;
      Case DB_TEXT
        theType = &quot;Char&quot;
      Case DB_DOUBLE
        theType = &quot;Float&quot;
        theLength = 8
      Case DB_MEMO
        theType = &quot;Char&quot;
        theLength = 1024
      Case DB_DATE
        theType = &quot;Char&quot;
        theLength = 8
      Case DB_LONG
        theType = &quot;Long&quot;
        theLength = 4
      Case DB_BYTE
        theType = &quot;Byte&quot;
      Case DB_integer
        theType = &quot;integer&quot;
        theLength = 2
      Case DB_BOOLEAN
        theType = &quot;Char&quot;
        theLength = 1
      Case DB_CURRENCY
        theType = &quot;Float&quot;
        theLength = 4
      Case Else
       theType = &quot;Undefined:&quot; &amp; theTypeCode
    End Select
'  identify the primary key to system architect by adding the @ prefix
        theColumnName = theName
        thePureColumnName = theName
        If Len(theName) &gt; Len(tableName) And Mid(theName, 4, 
           Len(tableName)) = tableName And Mid(theName, 1, 3) = &quot;PK_&quot; 
                                       Then theColumnName = &quot;@&quot; &amp; theName
        If Len(theName) &gt; Len(tableName) And Mid(theName, 4, 
           Len(tableName)) = tableName And Mid(theName, 1, 3) = &quot;FK_&quot; 
           Then foreignKeys = foreignKeys &amp; theName
        Print #3, &quot;&quot;&quot;&quot; &amp; theName &amp; &quot;&quot;&quot;,,,,&quot;&quot;&quot; &amp; theLength &amp; &quot;&quot;&quot;,
           Engineering,&quot;&quot;&quot; &amp; theColumnName &amp; &quot;&quot;&quot;,&quot;&quot;&quot; &amp; dbName &amp; &quot;&quot;&quot;,
           &quot;&quot;&quot; &amp; tableName &amp; &quot;&quot;&quot;,,&quot;&quot;&quot; &amp; theType &amp; &quot;&quot;&quot;,,,,&quot;
        sql = &quot;insert into dbDictionary (tableName,columnName,columnType,
                                                          width,description) &quot;
        sql = sql &amp; &quot;values (&quot;&quot;&quot; &amp; tableName &amp;&quot;&quot;&quot;,&quot;&quot;&quot; &amp; thePureColumnName &amp;&quot;&quot;&quot;,
            &quot;&quot;&quot; &amp; theType &amp; &quot;&quot;&quot;,&quot; &amp; theLength &amp; &quot;,&quot;&quot;&quot; &amp; theDescription &amp; &quot;&quot;&quot;);&quot;
        localDB.Execute (sql)
        If j &lt; cols - 1 Then
          Print #2, &quot;&quot;&quot;&quot; &amp; theColumnName &amp; &quot;&quot;&quot; + &quot;
        Else
          Print #2, &quot;&quot;&quot;&quot; &amp; theColumnName &amp; &quot;&quot;&quot;&quot;
        End If
        sqlCol = Mid(thePureColumnName, 1, 18)
        createTable = &quot;[&quot; &amp; sqlCol &amp; &quot;]&quot; &amp; &quot; &quot; &amp; UCase$(theType)
        If theType = &quot;Text&quot; Then
          createTable = createTable &amp; &quot; (&quot; &amp; theLength &amp; &quot;)&quot;
        End If
        If j &lt;&gt; cols - 1 Then createTable = createTable &amp; &quot;,&quot;
        Print #4, createTable
        counter = counter + 1
    Next j
      createTable = &quot;);&quot;
      Print #1,
      Print #2,
      Print #4, createTable
      Print #4, &quot;Create unique index PKI_&quot; &amp; sqlTableName &amp; &quot; on &quot; &amp; 
                 sqlTableName &amp; &quot;(&quot; &amp; &quot;PK_&quot; &amp; sqlTableName &amp; &quot;);&quot;
      Print #4, &quot;Grant all on &quot; &amp; sqlTableName &amp; &quot; to public;&quot;
      Print #4,       ' sql statement
    End If
     Next i
     localDB.Close
     Close #1
     Close #2
     Close #3
     Close #4
     DoCmd Hourglass False
End Sub
Sub readElementsFile (elementsFilePath, theControl As Control)
    Dim sql, recordCounter, errCounter
    Dim myDB As Database
    Dim i As Integer, j As Integer, cols As Integer
'    DoCmd Hourglass True
    Set myDB = dbengine.workspaces(0).databases(0)
    sql = &quot;delete from dbDictionary&quot;    'clear the existing db definition
    myDB.Execute sql
    Open elementsFilePath For Input As #1
      Dim aName, description, domain, Comments, length, BusinessUnit, 
        columnName,aDatabase,aTable,Version, CStorageType, CStorageOccurrences,
        StorageClass, StoragePicture, DisplayPicture, a1, a2, a3
      recordCounter = 0
     Open &quot;DBAssist.log&quot; For Output As #2
     Do While Not EOF(1)
     Input #1,aName,description,domain,Comments,length,BusinessUnit,columnName,
         aDatabase,aTable,Version,CStorageType,CStorageOccurrences,
         StorageClass,StoragePicture,DisplayPicture,a1,a2,a3
       If recordCounter &gt; 0 Then
'        If Mid(columnName, 1, 1) = &quot;@&quot; Then
'          columnName = Mid(columnName, 2, Len(columnName))
'        End If
         If Len(aTable) = 0 Or Len(columnName) = 0 
                 Or Len(CStorageType) = 0 Then
           Print #2, &quot;Table, Column or Storage Type not defined. record: &quot;, 
                 recordCounter, aName, description
           errCounter = errCounter + 1
         Else
          theControl = aTable &amp; &quot;, &quot; &amp; columnName
          DoEvents
          sql = &quot;insert into dbDictionary &quot;
          sql = sql &amp; &quot;(columnName,width,tableName,columnType,description,
                  sysArchColName) &quot;
          sql = sql &amp; &quot;values (&quot;&quot;&quot; &amp; columnName &amp; &quot;&quot;&quot;,&quot; &amp; length &amp; &quot;,
                 &quot;&quot;&quot; &amp; aTable &amp; &quot;&quot;&quot;,&quot;&quot;&quot; &amp; CStorageType &amp; &quot;&quot;&quot;,
                 &quot;&quot;&quot; &amp; description &amp; &quot;&quot;&quot;,&quot;&quot;&quot; &amp; aName &amp; &quot;&quot;&quot; );&quot;
          myDB.Execute sql
        End If
      End If
      recordCounter = recordCounter + 1
     Loop
    myDB.Close
    Close #1
    Close #2
    DoCmd Hourglass False
    If errCounter &gt; 0 Then theControl = &quot;Errors occurred. check DBAssist.log&quot;
End Sub
Sub readEntity (theControl As Control)
' create indices from information in the entity table
    Dim sql, recordCounter, errCounter
    Dim i As Integer, j As Integer, cols As Integer
'    DoCmd Hourglass True
    Dim atsign, keyCounter, tableName, columnName, keyType, keyName
    Dim localDB As Database
    Set localDB = dbengine.workspaces(0).databases(0)
    localDB.Execute &quot;delete from dbKey&quot;
    
    Dim sn As Recordset
    sql = &quot;select * from entity&quot;
    Set sn = localDB.OpenRecordset(sql, DB_OPEN_SNAPSHOT)
    If sn.recordcount = 0 Then
      MsgBox &quot;Entity table is empty&quot;
      Exit Sub
    End If
    keyCounter = 1
      Dim theLine, firstquote, numItems As Integer
      recordCounter = 0
      sn.MoveFirst
     Dim tableDescription As String
     Do While Not sn.EOF
     tableName = sn(&quot;name&quot;)
     If Not IsNull(sn.description) Then
     tableDescription = sn.description
     numItems = getNumItems(tableDescription, &quot;+&quot;)
     For j = 1 To numItems
     theLine = getItem(tableDescription, &quot;+&quot;, j)
     atsign = InStr(theLine, &quot;@&quot;)
     If atsign &gt; 0 Then
       If atsign &gt; 1 Then       'beginning of new table definition
         columnName = Mid(theLine, InStr(theLine, &quot;&quot;&quot;&quot;) + 1, 99)
         columnName = Mid(columnName, 1, InStr(columnName, &quot;&quot;&quot;&quot;) - 1)
         
         keyType = &quot;Unique&quot;
         If InStr(theLine, &quot;FKFROM&quot;) &gt; 0 Then keyType = &quot;Foreign&quot;
         keyName = &quot;index&quot; &amp; keyCounter
         keyCounter = keyCounter + 1
         theControl = &quot;Reading key: &quot; &amp; keyName &amp; &quot; on &quot; &amp; columnName
         DoEvents
         sql = &quot;insert into dbKey &quot;
         sql = sql &amp; &quot;(keyName,tableName,columnName,keyType) &quot;
         sql = sql &amp; &quot;values (&quot;&quot;&quot; &amp; keyName &amp; &quot;&quot;&quot;,&quot;&quot;&quot; &amp; tableName &amp; &quot;&quot;&quot;,
             &quot;&quot;&quot; &amp; columnName &amp; &quot;&quot;&quot;,&quot;&quot;&quot; &amp; keyType &amp; &quot;&quot;&quot;);&quot;
         localDB.Execute sql
     Else            'this line is part of a composite key
         firstquote = InStr(theLine, &quot;&quot;&quot;&quot;)
         columnName = Mid(theLine, firstquote + 1, InStr(firstquote + 1, 
             theLine, &quot;&quot;&quot;&quot;) - (firstquote + 1))
         keyType = &quot;Unique&quot;
         keyName = &quot;index&quot; &amp; keyCounter
         keyCounter = keyCounter + 1
         If InStr(theLine, &quot;FKFROM&quot;) &gt; 0 Then keyType = &quot;Foreign&quot;
         keyCounter = keyCounter + 1
         theControl = &quot;Reading key:&quot; &amp; keyName &amp; &quot; on &quot; &amp; columnName
         DoEvents
         sql = &quot;insert into dbKey &quot;
         sql = sql &amp; &quot;(keyName,tableName,columnName, keyType) &quot;
         sql = sql &amp; &quot;values (&quot;&quot;&quot; &amp; keyName &amp; &quot;&quot;&quot;,&quot;&quot;&quot; &amp; tableName &amp; &quot;&quot;&quot;,
               &quot;&quot;&quot; &amp; columnName &amp; &quot;&quot;&quot;,&quot;&quot;&quot; &amp; keyType &amp; &quot;&quot;&quot;);&quot;
         localDB.Execute sql
     End If
   Else
   ' no at sign - check for foreign key
   Dim foreignKey, k, firstChar
   firstChar = -1
   foreignKey = InStr(theLine, &quot;&quot;&quot; / FKFROM&quot;)
   If foreignKey &gt; 0 Then
   ' check if the first char is a quote
   If Mid(theLine, 1, 1) = &quot;&quot;&quot;&quot; Then
     columnName = Mid(theLine, 2, InStr(2, theLine, &quot;&quot;&quot;&quot;) - 2)
   Else
   ' Look for the columnName. Search backward from token until a &quot; is found
   For k = foreignKey - 1 To 1 Step -1
   If Mid(theLine, k, 1) = &quot;&quot;&quot;&quot; Then
     firstChar = k + 1
     Exit For
   End If
   Next k
   columnName = Mid(theLine, firstChar, foreignKey - firstChar)
'   Debug.Print columnName
   End If
     keyType = &quot;Foreign&quot;
     keyName = &quot;index&quot; &amp; keyCounter
     keyCounter = keyCounter + 1
     theControl = &quot;Reading foreign key:&quot; &amp; keyName &amp; &quot; on &quot; &amp; columnName
     DoEvents
     sql = &quot;insert into dbKey &quot;
     sql = sql &amp; &quot;(keyName,tableName,columnName, keyType) &quot;
     sql = sql &amp; &quot;values (&quot;&quot;&quot; &amp; keyName &amp; &quot;&quot;&quot;,&quot;&quot;&quot; &amp; tableName &amp; &quot;&quot;&quot;,
            &quot;&quot;&quot; &amp; columnName &amp; &quot;&quot;&quot;,&quot;&quot;&quot; &amp; keyType &amp; &quot;&quot;&quot;);&quot;
     localDB.Execute sql
   End If
   End If
   Next j
   End If
   recordCounter = recordCounter + 1
   sn.MoveNext
  Loop
  sn.Close
  localDB.Close
  DoCmd Hourglass False
End Sub
</pre>
<h4><a name="01d7_009f"><a name="01d7_00a0">Listing Two <a name="01d7_00a0"></h4><pre>
Option Compare Database   'Use database order for string comparisons
Option Explicit
Sub createAccessTables (accessDBPath, theControl As Control)
'  Create an Access database by reading the DB dictionary, generating and
'  executing SQL DDL statements
'  CASE Tool --&gt; Access
'
On Error GoTo DBErrHandler
Dim localDB As Database, remoteDB As Database
Dim localSN As Recordset, remoteSN As Recordset
Dim localSQL, remoteSql
Set localDB = dbengine.workspaces(0).databases(0)
Set remoteDB = OpenDatabase(accessDBPath)
localSQL = &quot;select * from dbDictionary order by tableName&quot;
Set localSN = localDB.OpenRecordset(localSQL, DB_OPEN_SNAPSHOT)
If localSN.recordcount = 0 Then
  MsgBox &quot;DB dictionary is empty.  Cannot continue&quot;
  Exit Sub
End If
Dim oldTableName, tableName, inType, outType, inLength,outLength,theColumnName
Dim lengthPhrase, sql
Dim createPrimaryKeys, indexColName
Dim theDescription, SAName
localSN.MoveFirst
tableName = localSN.tableName
oldTableName = tableName
'start the new SQL statement
remoteSql = &quot;create table [&quot; &amp; tableName &amp; &quot;] 
                              ([&quot; &amp; getKeyName(tableName) &amp; &quot;] Counter, &quot;
createPrimaryKeys = True
Do Until localSN.EOF
  If tableName &lt;&gt; oldTableName Then
    remoteSql = Mid(remoteSql, 1, Len(remoteSql) - 1) 
    remoteSql = remoteSql &amp; &quot;);&quot;                      
    theControl = &quot;Creating table: &quot; &amp; oldTableName
    DoEvents
    sql = &quot;drop table [&quot; &amp; oldTableName &amp; &quot;]&quot;
    remoteDB.Execute (sql)
nextStatement:
     remoteDB.Execute (remoteSql)         'create table in remote DB
    '  using standard SQL, create a primary key for this table
    If createPrimaryKeys Then
      remoteSql = &quot;create unique index &quot; &amp; &quot;pki_primary&quot; &amp; 
                   &quot; on [&quot; &amp; oldTableName
      remoteSql = remoteSql &amp; &quot;] ([&quot; &amp; getKeyName(oldTableName) &amp; &quot;]) 
                     with primary;&quot;
      remoteDB.Execute (remoteSql)
    End If
    'start the new SQL statement
    remoteSql = &quot;create table [&quot; &amp; tableName &amp; &quot;] ([&quot; &amp; getKeyName(tableName) 
                     &amp; &quot;] Counter, &quot;
  End If
  inType = localSN.columnType
  inLength = localSN.Width
  theColumnName = localSN.columnName
  theDescription = localSN.description
  SAName = localSN.sysArchColName
  Dim aType, aLength
  '  SA does not have a Date/Time type. Retrieve from SA logical attribute name
  Call mapColNameToType(SAName, aType, aLength)
  Call mapSATypeToAccessType(inType, inLength, outType, outLength)
  If aType = &quot;Date&quot; And outType = &quot;Text&quot; Then outType = aType
  If aType = &quot;Currency&quot; And outType = &quot;Float&quot; Then outType = aType
  lengthPhrase = &quot;&quot;
  If outType = &quot;Text&quot; Then lengthPhrase = &quot; (&quot; &amp; outLength &amp; &quot;) &quot;
  remoteSql = remoteSql &amp; &quot;[&quot; &amp; theColumnName &amp; 
                                        &quot;] &quot; &amp; outType &amp; lengthPhrase &amp; &quot;,&quot;
  oldTableName = tableName
  localSN.MoveNext
  If Not localSN.EOF Then tableName = localSN.tableName
Loop
Exit Sub
DBErrHandler:
Select Case Err
  Case 3376  'Table doesn't exist
  Case Else
   MsgBox Error(Err)
   MsgBox remoteSql
End Select
Resume nextStatement:
End Sub
Sub createKeys (mdbPath, theControl As Control)
  On Error GoTo errHandler
  Dim remoteDB As Database, localDB As Database
  Dim sn As Recordset
  Dim sql, indexSql,aTableName,aKeyName,aType,aKeyType,aColumnName,loopCounter
  Set localDB = dbengine.workspaces(0).databases(0)
  Set remoteDB = OpenDatabase(mdbPath)
  indexSql = &quot;&quot;
  loopCounter = 1
  sql = &quot;select * from dbKey order by tableName, keyType desc&quot;
  Set sn = localDB.OpenRecordset(sql, DB_OPEN_SNAPSHOT)
  If sn.recordcount = 0 Then
    MsgBox &quot;DB key table is empty&quot;
    Return
  End If
  Do While Not sn.EOF
    aTableName = sn.tableName
    sql = &quot;alter table [&quot; &amp; aTableName &amp; &quot;] Add column &quot;
    aKeyName = sn.keyName
    aKeyName = &quot;index&quot; &amp; loopCounter
    aKeyType = sn.keyType
    aColumnName = sn.columnName
    aType = &quot;Long&quot;
    sql = sql &amp; &quot;[&quot; &amp; aColumnName &amp; &quot;] &quot; &amp; aType
    theControl = &quot;Adding &quot; &amp; aKeyName &amp; &quot; to table: &quot; &amp; aTableName
    DoEvents
    remoteDB.Execute (sql)
    '  create simple keys
    indexSql = &quot;create index &quot; &amp; aKeyName &amp; &quot; on [&quot; &amp; aTableName &amp; &quot;] 
            ([&quot; &amp; aColumnName &amp; &quot;] &quot;
    indexSql = indexSql &amp; &quot;)&quot;
    remoteDB.Execute (indexSql)
    indexSql = &quot;&quot;
    loopCounter = loopCounter + 1
    sn.MoveNext
  Loop
Exit Sub
errHandler:
Select Case Err
  Case 3380  'Ignore the error: Column already exists
  Case 3375  'Ignore the error: Table already has an index named ...
  Case 3376  'Handle the error: Table doesnt exist
  ' We assume: This table doesn't exist because all its columns are keys. 
  ' Create the table
    indexSql = &quot;create table [&quot;&amp; aTableName &amp;&quot;] ([&quot; &amp; aColumnName &amp; &quot;] long )&quot;
    remoteDB.Execute (indexSql)
  Case Else
   MsgBox Error(Err)
   MsgBox sql
End Select
Resume Next
End Sub
Function getKeyName (columnName)
  Dim keyName
  keyName = &quot;PK_&quot; &amp; columnName
  getKeyName = keyName
End Function
Sub mapAccessTypeToAccessType (inType, inLength, outType, outLength)
  outType = inType
  outLength = inLength
End Sub
Sub mapColNameToType (colName, aType, aLength)
'  This mapping assumes the column names consist of several words separated
'  by spaces. Last grouping of letters is a mneumonic which indicates type and 
' length of the variable
Static inTypes(16), outTypes(16), lengths(16)
Dim numValues
numValues = 16
inTypes(0) = &quot;ADD&quot;
inTypes(1) = &quot;CD&quot;
inTypes(2) = &quot;Ct&quot;
inTypes(3) = &quot;DT&quot;
inTypes(4) = &quot;DESC&quot;
inTypes(5) = &quot;FT&quot;
inTypes(6) = &quot;HR&quot;
inTypes(7) = &quot;ID&quot;
inTypes(8) = &quot;NM&quot;
inTypes(9) = &quot;NO&quot;
inTypes(10) = &quot;PCT&quot;
inTypes(11) = &quot;RT&quot;
inTypes(12) = &quot;TYP&quot;
inTypes(13) = &quot;YR&quot;
inTypes(14) = &quot;YN&quot;
inTypes(15) = &quot;Amt&quot;
outTypes(0) = &quot;Text&quot;
outTypes(1) = &quot;Text&quot;
outTypes(2) = &quot;Long&quot;
outTypes(3) = &quot;Date&quot;
outTypes(4) = &quot;Memo&quot;
outTypes(5) = &quot;Long&quot;
outTypes(6) = &quot;Integer&quot;
outTypes(7) = &quot;Text&quot;
outTypes(8) = &quot;Text&quot;
outTypes(9) = &quot;Long&quot;
outTypes(10) = &quot;Double&quot;
outTypes(11) = &quot;Double&quot;
outTypes(12) = &quot;Text&quot;
outTypes(13) = &quot;Integer&quot;
outTypes(14) = &quot;Yes/No&quot;
outTypes(15) = &quot;Currency&quot;
lengths(0) = &quot;50&quot;
lengths(1) = &quot;3&quot;
lengths(2) = &quot;&quot;
lengths(3) = &quot;&quot;
lengths(4) = &quot;&quot;
lengths(5) = &quot;&quot;
lengths(6) = &quot;&quot;
lengths(7) = &quot;15&quot;
lengths(8) = &quot;50&quot;
lengths(9) = &quot;&quot;
lengths(10) = &quot;&quot;
lengths(11) = &quot;&quot;
lengths(12) = &quot;3&quot;
lengths(13) = &quot;&quot;
lengths(14) = &quot;&quot;
lengths(15) = &quot;&quot;
' get the type code from the column name
Dim i As Integer
Dim lastSpace
' find the last space in the columnName
lastSpace = 0
For i = 1 To Len(colName)
  If Mid(colName, i, 1) = &quot; &quot; Then lastSpace = i
Next i
If lastSpace = 0 Then
  MsgBox &quot;Column name must contain at least one space: &quot; &amp; colName
  Exit Sub
End If
Dim inType
inType = Mid(colName, lastSpace + 1, Len(colName))
'Debug.Print inType
Dim found, j As Integer
found = 0
For j = 0 To numValues - 1
  If inType = inTypes(j) Then
    found = 1
    aType = outTypes(j)
    aLength = lengths(j)
'    Debug.Print aType &amp; &quot;:&quot;; aLength
    Exit Sub
  End If
Next j
If found = 0 Then
'  MsgBox &quot;mapColNameToType. Unknown type: &quot; &amp; inType
  aType = &quot;&quot;
  aLength = &quot;&quot;
End If
End Sub
Sub mapSATypeToAccessType (inType, inLength, outType, outLength)
'  This mapping converts an SA &quot;C Type&quot; to a valid Access Type
'  An input type of Char with length &gt; 255 is converted to Access type Memo
Static inTypes(10), outTypes(10)
Dim numValues
numValues = 9
inTypes(0) = &quot;char&quot;
inTypes(1) = &quot;int&quot;
inTypes(2) = &quot;unsigned&quot;
inTypes(3) = &quot;char near *&quot;
inTypes(4) = &quot;char far *&quot;
inTypes(5) = &quot;long&quot;
inTypes(6) = &quot;unsigned long&quot;
inTypes(7) = &quot;float&quot;
inTypes(8) = &quot;double&quot;
outTypes(0) = &quot;Text&quot;
outTypes(1) = &quot;Integer&quot;
outTypes(2) = &quot;Long&quot;
outTypes(3) = &quot;Text&quot;
outTypes(4) = &quot;Memo&quot;
outTypes(5) = &quot;Long&quot;
outTypes(6) = &quot;Long&quot;
outTypes(7) = &quot;Single&quot;
outTypes(8) = &quot;Double&quot;
Dim found, j As Integer
found = 0
For j = 0 To numValues - 1
  If inType = inTypes(j) Then
    found = 1
    outType = outTypes(j)
    outLength = inLength
    If outType = &quot;Memo&quot; Then outLength = &quot;&quot;
'    Debug.Print outType &amp; &quot;:&quot;; outLength
    Exit Sub
  End If
Next j
If found = 0 Then
  MsgBox &quot;Unknown type: &quot; &amp; inType
End If
End Sub
Sub preprocessEntityFile (entityFilePath, processedFilePath)
    On Error Resume Next    'turn off error reporting
    ' remove the extra carriage returns to make a valid .csv file, then
    ' import the file into access for further processing
    Dim recordCounter, errCounter
    Dim i As Integer, commasPerRecord As Integer
    Dim lineLength As Integer
    Dim theLine As String, lineBuffer As String
    Dim totalCommas As Integer, commaCount As Integer
    Open entityFilePath For Input As #1
    Open processedFilePath For Output As #2
    
    commasPerRecord = 12
    lineBuffer = &quot;&quot;
    totalCommas = 0
     Do While Not EOF(1)
     Line Input #1, theLine
     lineLength = Len(theLine)
     commaCount = 0
     For i = 1 To lineLength
       If Mid(theLine, i, 1) = &quot;,&quot; Then
         commaCount = commaCount + 1
       End If
     Next i
     totalCommas = totalCommas + commaCount
     If totalCommas &lt; commasPerRecord Then
       lineBuffer = lineBuffer &amp; theLine
     Else
       lineBuffer = lineBuffer &amp; theLine
       Print #2, lineBuffer
       lineBuffer = &quot;&quot;
       totalCommas = 0
     End If
     Loop
     Close #1
     Close #2
     DoCmd SetWarnings False
     Dim localDB As Database
     Set localDB = dbengine.workspaces(0).databases(0)
     localDB.Execute (&quot;drop table entity&quot;)
     DoCmd TransferText , , &quot;Entity&quot;, processedFilePath, True
     DoCmd SetWarnings True
     localDB.Close
     On Error GoTo 0    'turn on error reporting
End Sub
DDJ
</pre>
<P>
<P>
<P>
<P>
<P>
<P>
<P>
<P>
<P>
<P>
<HR><P>Copyright &copy; 1995, <I>Dr. Dobb's Journal</I></P></BODY></HTML>
