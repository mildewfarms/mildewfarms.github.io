<HTML>
<META NAME="year" CONTENT="1995">

<HEAD>
<TITLE>NOV95: LETTERS</TITLE></HEAD>
<BODY BGCOLOR="#ffffff">
<h1>LETTERS<a name="01a0_0001"></h1><P>
<h3><a name="01a0_0002">C/C++ Compiler Comparison<a name="01a0_0002"></h3><P>
Dear <I>DDJ</I>,<P>
In his article &quot;Comparing C/C++ Compilers&quot; (<I>DDJ</I>, September 1995), Tim Parker states: &quot;Performance-wise, the GNU C compiler is unremarkable. It was about average in speed tests during our first trials.&quot; Fair enough, I suppose. But was he referring to compilation speed, or speed of the executed code?<P>
He continues: &quot;It has no optimizing capability, so we spent a couple of days playing with flags and options. Eventually, we managed to find several useful tweaks that improved performance a little, but the compiler still didn't win any prizes.&quot;<P>
Bzzzt. The only thing I can imagine is that Mr. Parker completely neglected to read either the man page or the (very thorough) TeXinfo documentation for gcc. Here's an excerpt from the gcc man page:<P>
Optimization Options<P>
<pre>-fcaller-saves -fcse-follow-jumps <P>  -fcse-skip-blocks
-fdelayed-branch -felide-constructors
-fexpensive-optimizations -ffast-math <P>  -ffloat-store
-fforce-addr -fforce-mem -finline<P>  -functions
-fkeep-inline-functions -fmemoize<P>  -lookups
-fno-default-inline -fno-defer-pop
-fno-function-cse -fno-inline -fno<P>  -peephole
-fomit-frame-pointer -frerun-cse<P>  -after-loop
-fschedule-insns -fschedule-insns2
-fstrength-reduce -fthread-jumps <P>  -funroll-all-loops
-funroll-loops -O -O2</pre><P>
And those are just the vanilla optimizations. There are also a few language extensions that can improve efficiency. For example, first-class labels, which can allow direct threading in interpreters (similar to continuation-passing style) or computed jumps. Also, specification of return-value destination, which is vaguely like the placement option in C++'s <I>new</I> operator.<P>
I can't comment much on the quality of generated code, but I do know that, for speed of compilation, GCC 2.5.8 under Linux is noticeably faster than Watcom C++ 10.0 under DOS (the same 486/66 for both). And the Watcom compiler is <I>fast</I>.<P>
Todd Eigenschink <P>
eigenstr@CS.Rose-Hulman.Edu<P>
<I>Tim responds</I>: Thanks for your note, Todd. Indeed, I did read the GCC man pages and all other accompanying documentation you mention. My point in the article was that, although you can set optimization through careful use of options and flags, there is no &quot;optimize&quot; mode as with almost every other compiler. I didn't offer my opinion on whether or not this is good or bad--just that it was missing. As for speed, I double-checked my benchmarks several times, and the results are applicable for both compilation and execution.<P>
<h3><a name="01a0_0003">MFC versus OWL<a name="01a0_0003"></h3><P>
Dear <I>DDJ</I>,<P>
In his September 1995 &quot;C Programming&quot; column, Al Stevens wrote that &quot;MFC is not only the de facto standard Windows framework, it's the best one available.&quot; Ugh!<P>
I've been using Borland C++ and OWL for a few years, so I'll make comparisons directly between MFC and OWL. I will not say that OWL is the best Windows framework. I think it's very good, but I suspect that some of the commercial frameworks (zApp, Zinc, and the like) are even better. <P>
<UL>
<li>How much does the framework cover? MFC totals about 45 classes; OWL, about 150 classes. MFC doesn't even cover all the basic Windows window types; for example, it has no class to encapsulate radio buttons, nor one for check boxes.</li>
<li>How much does the framework take advantage of object-oriented design? OWL: Pretty well. OWL uses inheritance (including multiple inheritance); the class hierarchy is fairly clean, and makes a lot of sense to anyone familiar with Windows. For example, <I>TRadioButton</I> is a descendent of <I>TCheckBox</I>, which is a descendent of <I>TButton</I>; <I>TComboBox</I> is a descendent of <I>TListBox</I>; and <I>TEdit</I> is a descendent of <I>TStatic</I>. In contrast, MFC is a very &quot;flat&quot; class hierarchy. <I>CStatic</I>, <I>CEdit</I>, <I>CListBox</I>, <I>CButton</I>, and <I>CComboBox</I> are all at the same level in the class hierarchy.</li>
<li>How well does the framework allow the programmer to use object-oriented design? Again, OWL does a pretty good job, and again, MFC does not. In particular, I've found that writing object-oriented code for dialog boxes is (in some ways) impossible with MFC. One of the things that I find myself doing a lot in OWL is customizing dialog controls: If I need some new behavior from a list box, I write a descendent class of <I>TListBox</I>, and in the dialog's constructor I attach an instance of my list-box class to the list-box control defined in the dialog's resource template. In MFC, a class instance can only be attached to a dialog control defined in the dialog resource template through the use of a temporary pointer. Since the attachment is temporary, the class you've defined has no opportunity to modify the control's behavior. Of course, there are ways around this, but they're somewhat ugly and, of course, completely unnecessary in a well-designed framework.</li>
</UL>
Furthermore, there are issues related to 16-bit versus 32-bit platforms. Borland uses the same compiler and same framework to generate both 16-bit and 32-bit applications; Microsoft has different compilers and (slightly) different versions of MFC for the two different platforms. The separate compiler issue is especially irritating for me--I have to support 16-bit platforms for another two or three years; Visual C++ 1.52 doesn't even support all the C++ language features I like to use (in particular, templates and structured exception handling), and Microsoft has stated that they are never going to add new C++ language features to Visual C++ 1.5x.<P>
On the other hand, there are a lot of things to like about Visual C++ 2.x. I suspect that when combined with a good third-party class framework, it would be hard to beat as a development platform.<P>
Jim King <P>
jim.king@mail.sstar.com<P>
Dear <I>DDJ</I>,<P>
I take exception to Al Stevens' opinion of OWL versus MFC (&quot;C Programming&quot;  September 1995). Not only do I feel that OWL is superior to MFC in every way, shape, and form, but I also don't think that de facto standards are determined by fiat or by the massive amounts of propaganda for MFC that Microsoft has created to promote its own Windows application framework. I have found that there is hardly a single area of Windows programming that is not easier to implement using OWL than MFC, and I do not want to use an interface that makes my job harder and programming less fun. Why don't we let programmers decide what they like rather than attempt to coerce them into using a supposedly more popular platform? Just because it is Microsoft does not make it the best, and in this case, OWL does a magnificent job of creating an application framework while MFC is only a slightly better than mediocre implementation. If you like being as close as possible to the Windows SDK, you might want to stick with MFC, but if you want to do real object-oriented programming with tremendous flexibility and extensibility, OWL is the clear choice.<P>
Edward Diener <P>
70304.2632@compuserve.com<P>
<I>Al responds</I>: I agree with Edward when he asserts that the de facto standards should not and cannot be created by decree. They occur naturally as the result of the wide acceptance and usage of a convention by the practitioners in an industry. MFC passes that test. Most compilers have licensed MFC, most programmers prefer it, and most Windows-programming employment opportunities require it.<P>
Edward and I have different opinions about what we prefer in a framework class library. Both libraries have their technical strengths and weaknesses. I prefer MFC's close-to-the-bones approach over OWL's would-be object-oriented shroud. A translucent veil rather than a blackout curtain. My opinion is, I think, more mainstream than his. I did not, however, mean to suggest that he and other OWL users should be forced to change. But I am flattered that he thinks that my influence could coerce programmers to do anything they don't want to do. <P>
<h3><a name="01a0_0004">PNG Patents?<a name="01a0_0004"></h3><P>
Dear <I>DDJ</I>,<P>
Jonathan Erickson's &quot;Editorial&quot; about PNG (<I>DDJ</I>, September 1995) claims that &quot;PNG is free and open, and available for use without fear of patent infringement.&quot; How is it possible to write a new and useful program of significance without fear of patent infringement? That is, how can you know &quot;there are no patents associated with PNG&quot;? Has someone reviewed all existing patents to ensure that PNG does not infringe? Even if this complete review of all patents could be done, isn't this process subject to interpretation? What about patent applications that are being reviewed at PTO and may be issued in the future?<P>
While it may be true that the inventors of PNG have not filed any patents, isn't it possible that PNG could still infringe on one or more existing or future patents? Isn't it possible that several years from now, PNG could be in a state similar to that of GIF today?<P>
Christopher Glaeser<P>
cdg@nullstone.com<P>
<h3><a name="01a0_0005">Satan Revisited <a name="01a0_0005"></h3><P>
Dear <I>DDJ</I>,<P>
I have concerns over Jonathan Erickson's &quot;Editorial&quot; on the Satan program (<I>DDJ</I>, June 1995). <P>
I installed and used Satan at my last job (at a university) and think that Satan has gotten a bad rap for no real reason at all. Satan has come under fire by the press, users, and system administrators alike. I just do not see what the big problem is.<P>
Contrary to (popular?) belief, Satan does not use any kind of magic to test a system. In fact, to my knowledge, all of the so-called holes that it scans for are <I>documented</I>, and can be found by anyone looking in the right places. Holes that are discovered are posted to the Internet on a regular basis by CERT (if memory serves correctly).<P>
Anyone can find out this information by doing some footwork. I find that most of the people who are having problems with Satan are the system administrators that are not doing their job (IMHO) and are bitching about it. <P>
Use of Satan is not a concern if you do not have the holes that it looks for (all the more reason to have Satan test your system before someone else does). If people take the time to research the program, and the holes that it looks for, they will find that it is not as bad as it seems. I believe that this is one case where word-of-mouth just got outta hand.<P>
James R. Twine<P>
SJMR66B@prodigy.com<P>
<h3><a name="01a0_0006">Thinking about Thunks<a name="01a0_0006"></h3><P>
Dear <I>DDJ</I>,<P>
Having written extensive thunking libraries for the x86 under OS/2 (refer to CompuServe's OS2DF1 library 9), I wish to warn other developers about some pitfalls which exist in the segmented x86 architecture when going from 32-bit to 16-bit code. Because many of the 32-bit API calls in Windows 95 use thunks back to underlying 16-bit code, these x86 architectural problems may cause even flawlessly written application code which calls the 32-bit APIs to encounter problems.<P>
Thunking, for those not familiar with it, is the process of changing an x86 processor between the flat model of 32-bit protected mode and the 16:16 model of 16-bit protected mode. In the 32-bit flat model, stack, code, and data are addressed as simple linear 32-bit offsets from a starting position. In the 16-bit protected mode, all of these entities are addressed as a 16-bit segment selector and a 16-bit offset from the start of the selector. In 16-bit mode, the x86 segment can be no more than 64K in size. When thunking, you convert between these two addressing schemes. Under both OS/2 and Windows 95, the 16-bit selectors are tiled; that is, where one 16-bit selector ends, the next one starts. In other words, the 16-bit selectors are not overlapped. Not only does this maximize the memory space available to the 16-bit mode, it prevents a nasty block-move overlap bug from occurring. This scheme allows 16-bit code access to any individual byte of data available to the 32-bit code.<P>
Notice the careful wording of the last sentence: I talked about &quot;individual&quot; bytes, saying nothing about &quot;arrays&quot; of such bytes. If an array in 32-bit mode crosses one of the 64K boundaries between the tiled 16-bit selectors, it is not accessible to underlying 16-bit code as a contiguous array. The physical address of an array in 32-bit memory depends not only on what variables precede it in your program, but also on what other programs are running. The probability of a thunked API call failing randomly is given by the equation: ((size of passed array-1)/65,536. If array is one byte in length, the probability of failure is zero; if array is 65,536 bytes long, only the one correct alignment can succeed. Any array larger than 65,536 bytes in length is guaranteed to fail. This problem is particularly insidious for any passed array existing in application-program heap space--which may have a variable location, depending on the options selected during the operation history of the program. The result of this thunking problem is that even an application program which contains no bugs can fail in a nonrepeatable, intermittent fashion.<P>
The stability of OS/2 jumped dramatically between revision 2.1 and 3.0 when the entire graphics system was rewritten in 32-bit code. Thunked APIs are a classic example of something which almost works. It has become difficult enough to write stable, usable applications without the operating system introducing intermittent problems. Unless--and until--Microsoft demonstrates to the developer community that it has a stable, reentrant solution to this array-boundary condition problem built into its thunking routines, the release of Windows 95 is, in my opinion, inherently unstable, premature, and unacceptable.<P>
Bob Canup<P>
73513.216@compuserve.com<P>
<h3><a name="01a0_0007">Silicon Fixes<a name="01a0_0007"></h3><P>
Dear <I>DDJ</I>,<P>
In his column &quot;Apple Talks the Talk and Walks the Dog at WWDC&quot; (<I>DDJ</I>, &quot;Programming Paradigms,&quot; August 1995), Michael Swaine attributes SuperCard to Silicon Graphics. The company that developed and distributes SuperCard is Silicon Beach Software, makers of SuperPaint. It's my understanding that Silicon Beach has no connection with Silicon Graphics.<P>
Jack Herrington<P>
jackh@axonet.com.au<P>
<I>DDJ responds:</I> Right you are, Jack. Thanks.<P>
<P>
<P>
<P>
<P>
<P>
<P>
<P>
<P>
<P>
<P>
<P>
<P>
<P>
<P>
<P>
<HR><P>Copyright &copy; 1995, <I>Dr. Dobb's Journal</I></P></BODY></HTML>
