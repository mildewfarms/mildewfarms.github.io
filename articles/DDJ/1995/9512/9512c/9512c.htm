<HTML>
<META NAME="year" CONTENT="1995">

<HEAD>
<TITLE>DEC95: Extending Visual Basic's Comm Control</TITLE></HEAD>
<BODY BGCOLOR="#ffffff">
<h1>Extending Visual Basic's Comm Control<a name="0218_00a7"><a name="0218_00a5"><a name="0218_0000"></h1><P>
<h2>Adding Xmodem support</h2><P>
<h3>Michael Floyd</h3><P>
<p><i><a name="0218_00a6"><a name="0218_0000">Michael is executive editor for DDJ and author of Developing Visual Basic 4 Communications Applications (Coriolis Group, 1995). He can be contacted at the DDJ offices or 76703.4057@compuserve.com.</i></p><hr><P>
Support for OLE custom controls (OCXs) is a new feature in Visual Basic 4.0 (VB4). One OCX, the Visual Basic communications (Comm) control, hides the low-level details of serial communications (fetching characters from the UART and the like) while providing a high-level interface based on the event-driven model. You simply write code in response to events. When a character comes through the serial port, you can grab it using an <I>Input</I> method. Thus, the Comm control works fine when streaming text from the serial port into a terminal window. However, the Visual Basic Comm control does not directly support protocols such as Xmodem for transferring binary files--a necessity for any real communications program.<P>
There are several options for supporting binary transfers. You can, for instance, buy an enhanced, add-on Comm control from Crescent Software (the original developer of the bare-bones Visual Basic Comm control) that supports most popular file-transfer protocols--Xmodem, Ymodem, Zmodem, and the like. Alternatively, you can write your own Comm control, or extend the minimal control included with VB4. In this article, I'll describe how to extend the Comm control by adding support for the Xmodem protocol (sometimes called &quot;Modem7&quot;). Although this implementation only supports checksums for error detection, you can easily add a cyclic redundancy check (CRC).<P>
<h3><a name="0218_00a8">Comm-Control Crash Course<a name="0218_00a8"></h3><P>
The Comm control supports both event-driven and polling methods to send and receive data through the serial port. It generates a single event, <I>OnComm</I>, which can trap events such as receiving data through the serial port and errors such as a full transmit buffer. You can control how often the <I>CommEvReceive</I> event is generated by setting the <I>RThreshold</I> property. For example, setting <I>RThreshold</I> to 1 causes an <I>CommEvReceive</I> event to be generated each time a character is received in the input buffer. The value of an event or error is stored as an integer in the <I>CommEvent</I> property, so you can use <I>CommEvent</I> to determine the most recent event or error. For polling, you can disable the generation of the <I>CommEvReceive </I>event by setting the <I>RThreshold</I> property to 0.<P>
You can begin &quot;talking&quot; to the serial port in as few as ten lines of code. Characters are sent using the <I>Output</I> function and received using the <I>Input</I> function; see <a href="#0218_00ad">Example 1</A>. You start by setting the <I>CommPort</I> property to establish which serial port your modem is connected to. If you are on COM1:, set <I>ComPort=1</I>. You then establish the port settings with the <I>Settings</I> property. A typical setting might be <I>Settings=</I>&quot;<I>9600,n,8,1</I>&quot;. Before opening the communications port, you also need to tell the Comm control how many characters to fetch from the input buffer. The <I>InputLen</I> property sets or returns the number of characters to be read when using the <I>Input </I>procedure. Setting <I>InputLen</I> to 0 tells the communications control that the entire receive buffer should be read when using the <I>Input</I> procedure. <P>
<h3><a name="0218_00a9">TinyComm<a name="0218_00a9"></h3><P>
To demonstrate how to develop a serial-communications program, I've written a terminal program called &quot;TinyComm.&quot; One of the reasons I chose this name is that the program's Xmodem code is based on that presented by Al Stevens in his &quot;C Programming&quot; column (<I>DDJ</I>, February and March 1989). TinyComm is a minimal implementation of a terminal program, but despite its simplicity, TinyComm is more robust than the sample VBTERM application supplied with Visual Basic. TinyComm allows you to select a remote system from a phone-book entry and dial that system. Once connected, you can log in and interact with the remote system. Here, I will focus on just a few of TinyComm's subroutines; the complete project is available electronically (see &quot;Availability,&quot; on page 3). <P>
TinyComm consists of three forms: a main window (TinyCom.frm), a phone-book-dialer window (Phonebk.frm), and an About box (AboutBox.frm). The main window consists of the terminal window and six pull-down menus. The terminal window presents some interesting challenges. A text-box control provides much of the functionality this window will require. However, some modifications must be made to support communications. For instance, characters typed into the text box must be sent to the serial port and echoed back on the screen. Additionally, when data comes through the serial port, you need to display it to the screen. You would also like to be able to resize the window, and have the data adjust itself properly.<P>
<I>CommCtrl.OnComm()</I> (I've named this instance of the control <I>CommCtrl</I>) uses a <I>Case</I> statement to direct the program to the proper handler. When data is received through the serial port, the <I>CommEvReceive</I> case is triggered. <I>CommEvReceive</I> first grabs data from the communications control's receive buffer and assigns it to the <I>TerminalTxt</I> string variable. This gives us a chance to filter the data before displaying it on the screen. Next, the cursor position in the terminal window is determined by calculating the length of text in the Window and assigning that value to <I>TerminalWindow.SelStart</I>. Normally, the <I>SelStart</I> property determines the starting point of text that has been highlighted and selected in the text box. If no text has been selected, as in this case, <I>SelStart</I> indicates the position to begin inserting text.<P>
To handle backspace characters, you test for the ASCII-character value 8H. If a backspace is detected, you subtract 1 from the current cursor position and assign that as the new <I>SelStart</I> position. On the screen, this moves the cursor back one space and erases the character that was in this position. Finally, the filtered text is displayed on the screen using <I>SelText</I>. Of course, there are plenty of other things you could filter and handle here, including special characters used in terminal emulation.<P>
The other important form involves the phone book, an Access database (.MDB) file. This version of TinyComm provides no direct interface to the phone book, so you must add entries using the Data Manager. The <I>PhoneBook</I> form consists of a data grid and five button controls, three of which are currently disabled. The fourth button control closes the <I>PhoneBook</I> form, and the final button, Dial, dials the phone number of the system currently selected in the data grid.<P>
The <I>DialBtn_Click()</I> subroutine retrieves the dialup information from the database and passes Comm control settings and the phone number to <I>CallNum()</I>. <I>DialBtn_Click()</I> first disables the Dial and Quit buttons and enables the Cancel button (which aborts the dialing process). Next, the database is opened and the record pointer is moved to the first record in the database. I use <I>FindFirst</I> to locate the <I>NameStr</I> in the database, so a SQL query is constructed and stored in the <I>Query</I> variable. The phone number associated with <I>NameStr</I> is placed in the <I>Number</I> variable and passed to <I>CallNum</I> for dialing. When control returns from <I>CallNum</I>, the buttons are reset to their prior state. <P>
<h3><a name="0218_00aa">Xmodem Refresher<a name="0218_00aa"></h3><P>
The Xmodem protocol is well documented and has been covered extensively in <I>DDJ</I> (most recently in &quot;Intelligent XYModem,&quot; by Tim Kientzle, December 1994). Still, a quick refresher is in order. According to the Xmodem protocol, data are broken into 128-byte chunks and packaged into blocks (or packets) for transmission. Each data packet is prefixed with a special Start of Header (SOH) character, a block number, and the one's complement of the block number. This is followed by 128 bytes of data. Finally, a checksum character is appended to the data packet. <a href="1995021a.htm">Figure 1</A> shows how the message block is packaged.<P>
In general terms, the transfer begins with the receiver sending out a series of Negative Acknowledgment (NAK) characters at ten-second intervals. When the sending program sees a NAK, it sends the first block of data. The receiving program examines the data block and checks it for problems. If there are none, the receiver sends an Acknowledgment (ACK) character indicating the block is fine. If, on the other hand, there is a problem with the transmission, a NAK is sent. The sender responds to a NAK by resending the bad block, and to an ACK, by sending the next block. The process continues until an End of Transmission (EOT) character is received or the file transfer is aborted. <P>
When the first packet is received, the receiver examines the first byte for the SOH character (01H). If the header character is found, the receiver assumes that the message block is valid and begins the file transfer in earnest. The receiving program next takes the block number and calculates the one's complement to the block number. This value is compared to the one's complement sent by the sending program. If the two values match, everything is fine and the receiver extracts the 128 bytes of data. The one's complement is computed in VB by performing a bitwise <I>Not()</I>. If the two values do not match, there is an error in the transmission and the packet must be resent. The receiving program notifies the sender by sending a NAK (&amp;H15).<P>
The next step in the process is for the receiver to calculate a checksum of the 128 bytes and compare this value to the checksum that was sent by the remote system. Assuming the two checksum values match and the one's complement values match, the receiver sends an ACK character (&amp;H6). The checksum is calculated by summing each of the data bytes. <a href="#0218_00ae">Figure 2</A> shows the algorithm for downloading a file using Xmodem.<P>
<h3><a name="0218_00ab">Implementing Xmodem<a name="0218_00ab"></h3><P>
<a href="#0218_00b1">Listing One</A> shows the <I>download_xmodem()</I> routine, which is based on C code written by Al Stevens. Thus, if you're a C programmer, you should be able to follow the Visual Basic code without difficulty. However, while variables and subroutines may follow the general structure of Al's code, there are some significant differences. <P>
The <I>download_xmodem()</I> routine takes a file handle as an argument. Thus, the calling routine must create a valid file handle and open the file prior to calling <I>download_xmodem()</I>. The calling routine is also responsible for closing the file after the file transfer is complete. The code in <a href="#0218_00af">Figure 3</A> can be used to call the <I>download_xmodem()</I> subroutine.<P>
My version of <I>download_xmodem()</I> polls the serial port for input rather than using event-driven methods. This is accomplished by first setting the <I>InputLen</I> property to 1, which tells the control to receive characters through the comm port, one at a time. Next, the Comm control's <I>RThreshold</I> property is set to 0, thus disabling the generation of the <I>OnComm</I> event. In TinyComm, disabling <I>CommEvReceive</I> has the side effect of disabling output to the terminal window. Unfortunately, this also disables all other events and error messages processed by this event. I've temporarily disabled the <I>CommEvReceive</I> event to simplify the discussion and to focus on Xmodem rather than event processing. Note, however, that the global <I>TerminalMode</I> variable has been set to False at the beginning of <a href="#0218_00b1">Listing One</A>. Code in <I>OnComm</I>'s receive event handler checks <I>TerminalMode</I> and disables output to the window when the variable is set to False. <P>
One difference between the C and Visual Basic versions of <I>download_xmodem()</I> shows up in the <I>ReadComm()</I> subroutine. To be useful to <I>download_xmodem()</I>, each string character retrieved from the Comm control's <I>Input</I> method must be converted to an integer value representing its ASCII equivalent. The <I>ReadComm()</I> subroutine shown in <a href="#0218_00b1">Listing One</A> grabs a string character from the serial port, converts it to an integer, and returns the result. Visual Basic's <I>Asc() </I>function performs the conversion. If a null string is encountered, <I>ReadComm()</I> returns 0. <P>
Another difference involves the <I>Delay()</I> function (which Al calls the <I>sleep()</I> function). <I>Delay()</I> is used to pause the system for a predetermined period of time. For example, to initiate the file transfer, <I>download_xmodem()</I> sends a NAK and checks the input buffer to see if an ACK response character has been sent. If not, the subroutine waits approximately six seconds (I've shortened the delay time), then sends out another NAK. Visual Basic provides a Timer control that can be used for just this purpose. The Timer control uses the PC's system clock to generate an event after a set period of time (specified in milliseconds). However, the accuracy of the Timer control is limited by the system clock, which generates a clock tick every 1/18th of a second. When the Timer event is generated, I increment a global variable called <I>SecondsElapsed</I>. The <I>Delay()</I> subroutine loops until the desired number of seconds have elapsed. <P>
<I>Delay()</I> also periodically issues a <I>DoEvents()</I>, which hands control over to Windows to process other events within the system. Without <I>DoEvents()</I>, the system appears to be hung. I've found <I>Delay()</I> useful in many situations, and have even included it as part of a scripting language for TinyComm that I call &quot;TinyScript.''<P>
<h3><a name="0218_00ac">Conclusion<a name="0218_00ac"></h3><P>
Clearly, I've only touched on TinyComm's highlights. You can add many features, including more event and error handlers. Most terminal programs support file capture, as well as ASCII file send and receive capability. I have also shown only the basics of Xmodem support. There is, of course, a complimentary <I>upload_xmodem()</I> subroutine. In addition, it is  rather easy to add CRC support to the Xmodem subroutines, and you will undoubtedly want to take full advantage of the visual controls supplied by Visual Basic. <P>

<a name="0218_00ad"><a name="0218_00ad"><B>Example 1:</B> Opening the serial port and initializing the modem.
<pre>
CommCtrl.CommPort = 1
CommCtrl.Settings = &quot;9600,n,8,1&quot;
CommCtrl.InputLen = 0
CommCtrl.PortOpen = True
CommCtrl.Output = &quot;ATZ&quot; + Chr(13) + chr(10)
Do
    DummyVar = DoEvents()
Loop Until CommCtrl.InBufferCount &gt;= 2
InString$ = CommCtrl.Input
CommCtrl.PortOpen = False
</pre>
<B><a href="1995021b.htm">Figure 1</A>: </B>Xmodem data packet.<P>
<a name="0218_00ae"><a name="0218_00ae"><B>Figure 2:</B> Xmodem's download algorithm.
<pre>
Send NAKs every 10 seconds until a packet is received
If packet received then check for SOH
If SOH then
    get block number
    calculate One's complement to block number
    compare complement to the complement sent in the packet
    If local complement &lt;&gt; remote complement then
        Send NAK and repeat process
    Else
        get 128 bytes of data
        calculate checksum
        compare local checksum to packet checksum
        If local checksum &lt;&gt; packet checksum then
            Send NAK and repeat process
        Else
            write data to file
            send ACK
        End If
    End If
Read next SOH
If SOH = EOT then transmission successful
If SOH = CAN then transmission aborted
If SOH = &amp;H01 then get next packet (repeat)
</pre>
<a name="0218_00af"><a name="0218_00af"><B>Figure 3:</B> Calling download_xmodem().
FileHandle = FreeFile   'Get the next free file handle
FileName = &quot;SomeFile&quot;
Open FileName For Output As FileHandle
download_xmodem (FileHandle)
Close</pre><P>
<P>
<h4><a name="0218_00b1"><a name="0218_00b0"><a name="0218_00b1">Listing One</h4>
<pre>
' xmodem.bas  -- Michael Floyd -- Dr. Dobb's Journal, December 1995.)
Global Const RETRIES = 12
Global Const CRCTRIES = 2
Global Const PADCHAR = &amp;H1A
Global Const SOH = &amp;H1
Global Const EOT = &amp;H4
Global Const ACK = &amp;H6
Global Const NAK = &amp;H15
Global Const CAN = &amp;H18
Global Const CRC = &quot;C&quot;
Global tries, SecondsElapsed As Integer           
Global InBuffer As String
Sub Delay(Seconds)   
    SecondsElapsed = 0
    If Seconds &lt; 1 Then
        Terminal.Timer1.Interval = 1000 * Seconds
    Else
        Terminal.Timer1.Interval = 1000
    End If
    Terminal.Timer1.Enabled = True       'Enable timer
    Do While SecondsElapsed &lt;= Seconds
        If I Mod 10 = 0 Then DoEvents
        Terminal.Label1.Caption = SecondsElapsed
        I = I + 1
    Loop
    Terminal.Timer1.Enabled = False
End Sub
Sub download_xmodem(FileNum)
Dim buffer, Checksum, Block, RemoteChecksum, RemoteComplement, _____LINEEND____
    RemoteBlockNumber, SOHChar As Integer
Dim ByteArray$(1 To 128)
    TerminalMode = False                'Disable output to terminal
    Block = 0
    SOHChar = 0
    fst = True
    Terminal.CommCtrl.InBufferCount = 0  'Flush the Input buffer
    Terminal.CommCtrl.InputLen = 1       'Receive one char at a time
    Terminal.CommCtrl.RThreshold = 0     'Disable generation  of OnComm Event
    tries = 0
    TIMEOUT = 6
    test_wordlen
    ' send NAKs until the sender starts sending
    Do While (SOHChar &lt;&gt; SOH) And (tries &lt; RETRIES)
        tries = tries + 1
        Terminal.CommCtrl.Output = Chr$(NAK)
        Delay 1
        SOHChar = ReadComm()
        If SOHChar &lt;&gt; SOH Then
            Delay 6
        End If
    Loop
    Do While tries &lt; RETRIES
        ' -- Receive the data and build the file --
        Terminal.Label1.Caption = &quot;Block  &quot; + Str(Block + 1)
        If Not (fst) Then
            TIMEOUT = 10
            SOHChar = ReadComm()
            If TimedOut() Then
                MsgBox &quot;Timed Out&quot;
            End If
            If SOHChar = CAN Then
                MsgBox &quot;CAN Received&quot;
                Exit Do
            End If
            If SOHChar = EOT Then
                Terminal.CommCtrl.Output = Chr$(ACK)
                MsgBox &quot;EOT Received&quot;
                Exit Do
            End If
            If SOHChar &lt;&gt; SOH Then
                If SOHChar = EOT Then
                    Terminal.CommCtrl.Output = Chr$(ACK)
                    MsgBox &quot;EOT Received&quot;
                    Exit Do
                End If
                Do While (SOHChar &lt;&gt; SOH)
                    If tries &gt;= RETRIES Then
                        MsgBox &quot;SOH errors!&quot;
                        Exit Do
                    End If
                    tries = tries + 1
                    Terminal.CommCtrl.InBufferCount = 0  'Flush Input buffer
                    Terminal.CommCtrl.Output = Chr$(NAK)
                    Delay 1
                    SOHChar = ReadComm()
                Loop
            End If
        End If
        fst = False
        TIMEOUT = 1                         ' Switch to one sec. timeouts
        
        RemoteBlockNumber = ReadComm()      ' Read block number
        RemoteComplement = ReadComm()       ' Read 1's complement
        Checksum = 0
        DLInfo.Label1.Caption = &quot;Block: &quot; + Str(RemoteBlockNumber) + _____LINEEND____
        &quot; SOHChar: &quot; + Str(SOHChar)
        ' ---- data block -----
        For I = 1 To 128
            buffer = ReadComm()
            Buf$ = Buf$ + Chr$(buffer)
            Checksum = Checksum + buffer
        Next
        Checksum = Checksum And 255
        ' ---- checksum  from sender ----
        RemoteChecksum = ReadComm()
        ' --- Handle resent blocks ---
        If RemoteBlockNumber = Block Then
            FilePos = Seek(FileNum)
            Seek FileNum, FilePos - 128
        ' --- handle out of synch block numbers ---
        ElseIf RemoteBlockNumber &lt;&gt; (Block + 1) Then
            receive_error &quot;No next sequential block&quot;, CAN
            Exit Do
        End If
        Block = RemoteBlockNumber
        ' --- test the block # 1's complement ---
        BlocksComplement = (Not RemoteBlockNumber And &amp;HFF)
        If (RemoteComplement And &amp;HFF) &lt;&gt; BlocksComplement Then
            receive_error &quot;One's complement does not match&quot;, NAK
        End If
        ' --- test chksum or crc vs one sent ---
        If Checksum &lt;&gt; RemoteChecksum Then
            receive_error &quot;non-matching Checksums&quot;, NAK
        End If
        ' --- write the block to disk ---
        For I = 1 to Len(Buf$)
            Print #FileNum, Mid(Buf$, I, 1)
        Next I
        Terminal.CommCtrl.Output = Chr$(ACK)
        Delay 0.5
    Loop
    If SOHChar = EOT Then
        MsgBox &quot;Transfer Complete&quot;
    Else
        MsgBox &quot;Transfer Aborted&quot;
    End If
    TIMEOUT = 10
    Terminal.CommCtrl.InBufferCount = 0  'Flush the buffer
    Terminal.CommCtrl.InputLen = 0       'Receive all chars in buffer
    Terminal.CommCtrl.RThreshold = 1     'Enable generation of OnComm Event
    TerminalMode = True                  'Enable output to terminal
End Sub
 Function ReadComm() As Integer
 Dim Tmp As String
 ' ReadComm reads a character from the Comm control's input buffer
 ' and returns the ASCII value of that character. If a null string is
 ' encountered, ReadComm returns 0.
 
    If Terminal.CommCtrl.InBufferCount &gt; 0 Then
        Tmp = Terminal.CommCtrl.Input
        If Tmp &lt;&gt; &quot;&quot; Then
            ReadComm = Asc(Tmp)
        Else
            ReadComm = 0
        End If
    Else
        ReadComm = 0
    End If
End Function
Static Sub receive_error(ErrorMsg, Rtn)
    tries = tries + 1
    If TIMEOUT = 1 Then
        MsgBox &quot;error  &quot; + ErrorMsg
    End If
End Sub
Sub test_wordlen()
    Settings = Terminal.CommCtrl.Settings
    If InStr(Settings, &quot;,8,&quot;) = 0 Then
        MsgBox &quot;Must be 8 Data Bits&quot;
        tries = RETRIES
    End If
End Sub
Function TimedOut() As Integer
    Ticker = 1
    If Ticker = 0 Then
        TimedOut = True
    Else
        TimedOut = False
    End If
End Function
</pre>
<P>
<P>
<P>
<P>
<P>
<P>
<P>
<P>
<P>
<P>
<HR><P>Copyright &copy; 1995, <I>Dr. Dobb's Journal</I></P></BODY></HTML>
