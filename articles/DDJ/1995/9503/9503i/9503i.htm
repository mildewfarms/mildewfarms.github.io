<HTML>
<META NAME="year" CONTENT="1995">

<HEAD>
<TITLE>MAR95: Examining the PowerBASIC Developer Kit</TITLE></HEAD>
<BODY BGCOLOR="#ffffff">
<h1>Examining the PowerBASIC Developer Kit<a name="011f_0055"></h1><P>
<h2><a name="011f_0053"><a name="011f_0000">Vocabulary-frequency analysis moves from DOS to Windows</h2><P>
<h3>Raymond J. Schneider</h3><P>
<p><i><a name="011f_0054"><a name="011f_0000">Ray is the director of engineering at ComSonics and a doctoral candidate at George Mason University. He can be reached at rschneider@global.net.</i></p><hr><P>
Language--the most significant of human inventions--is to a great extent the medium of thought. Through the development of language we enlarge the scope of that which is thinkable. The act of composing computer programs is not unlike the use of natural language, though more formal and less flexible. The history of software engineering is the history of computer languages, beginning with Fortran, Cobol, and Lisp, and continuing to more recent languages such as Prolog, Smalltalk, C++, and others.<P>
With this in mind, while working on my doctoral research at George Mason University in software-engineering methodologies, I explored the vocabulary used by authors writing professional papers in the software-engineering field. In the process, I developed some relatively simple tools to perform vocabulary-frequency analysis. As originally written, these programs run in a typical command-line environment under DOS. In a recent encounter with the PowerBASIC Developer Kit (PBDK), I dusted off these routines, extending and migrating them to Windows using the PBDK. The complete source code to both versions is available electronically; see &quot;Availability,&quot; page 3.<P>
<h3><a name="011f_0056">English Riches<a name="011f_0056"></h3><P>
English has the largest vocabulary of any human language. Among the reasons for this are that it springs from a relatively rich core vocabulary drawn from Anglo-Saxon, Latin, and Greek. Furthermore, English has adopted interesting words from all other languages, so-called &quot;loan&quot; words. The simplest structure of an English sentence is a noun phrase (NP), followed by a verb phrase (VP) (also known as the &quot;subject&quot; followed by a &quot;predicate&quot;). Thus, this simple structure could be expressed as NP+VP. <P>
In the sentence, &quot;The programmer wrote the application,&quot; <I>The programmer</I> is the NP (subject) and <I>wrote the application</I> is the VP (predicate). In her book, <I>Understanding English Grammar</I> (McMillan, 1982), Martha Kolln distinguishes &quot;_ten sentence patterns which account for the underlying skeletal structure of almost all the possible grammatical sentences in English. All are elaborations on this simple underlying pattern.&quot;<P>
To understand English with a computer, it is necessary to incorporate both a large dictionary of words and rules for word transformation, sentence composition, and some linkage into machine-based semantics to allow some degree of understanding. According to Bill Bryson in <I>The Mother Tongue</I> (William Morrow, 1990), Webster's <I>Third New International Dictionary</I> lists 450,000 words, while the revised <I>Oxford English Dictionary</I> has 615,000. If we include all the scientific and technical terms and all the transformational words created by various formation rules, we easily get into the range of many millions of words. This is well beyond any reasonable tabular scheme, so obviously we must devise some rules.<P>
Many Prolog implementations incorporate definite clause grammar (DCG), a scheme for parsing sentences. The DCG is basically a set of rewrite rules which use the infix operator --&gt;. Thus our simple sentence definition, NP+VP would be written <I>sentence </I>--&gt;<I> noun-phrase, verb-phrase</I>.<P>
<h3><a name="011f_0057">Vocabulary and Frequency<a name="011f_0057"></h3><P>
Words embody ideas. To study a subject, you need to learn the meaning of the words which are used and the way they are combined. This is true not only of natural language but of formal languages such as mathematics and computer programming. The importance of a concept expressed in a particular fragment of text may be measured by the frequency with which the words are used. Of course, some words occur with great frequency because they form part of the syntactic structure that holds the linguistic forms together. Reporting on a 1923 study by lexicographer G.H. McKnight, Cullen Murphy lists the infamous nine which account for one-quarter of all spoken words: and, be, have, it, of, the, to, will, and you (&quot;The Big Nine,&quot; <I>Atlantic</I>, March 1988). Once we are past these and two score or more glue and structure words, we encounter the vocabulary that holds the ideas and relations which are the core of the communication.<P>
<a href="19950121.htm">Figure 1</A> illustrates the system structure of a small set of programs I wrote to collect frequency data on text fragments. The structure centers on text and alpha files. The text file is assumed to be a set of lines encoded in ASCII. An alpha file is a comma-delimited file whose first field is an ASCII string (normalized to all capital letters) and whose second field is the integer number of times that the word appears in the text fragment. The four functions shown in <a href="#011f_005f">Figure 2</A> make up the system. <P>
The system is implemented using PowerBASIC, the current embodiment of Borland's Turbo BASIC, written by Bob Zale. Like most Basics, PowerBASIC has powerful string-handling facilities. It is a fast native-code compiler, and the resulting programs are also fast. Additionally, PowerBASIC includes a variety of enhancements not found in many other Basics. I found the REPLACE statement, VERIFY function, and ARRAY SORT statement particularly helpful. The REPLACE statement replaces all occurrences of a given string with a new string which is specified; the VERIFY function determines whether each character of a string is present in another string; and ARRAY SORT allows you to sort all or part of an array into ascending or descending order. You can also include a TAGARRAY, an array associated and sorted with the main array. Thus, to sort the alpha files into alphabetical order, sort with the words using the frequencies as a TAGARRAY and vice versa when sorting in frequency order.<P>
<h3><a name="011f_0058">DOS and the COUNT Algorithm<a name="011f_0058"></h3><P>
The COUNT algorithm (see <a href="#011f_0061">Listing One</A>) simply processes lines of ASCII text one line at a time. COUNT isolates the words in the line by replacing all nonalpha characters (numbers, punctuation, brackets, and so on), except hyphens and apostrophes, with blanks using the VERIFY command. (Note that in <a href="#011f_0061">Listing One</A>, I first used the REPLACE command to replace numbers, brackets, and punctuation.) The VERIFY is open ended and cleans up anything that is <I>not</I> an alpha character or a hyphen or an apostrophe. Then the words are isolated as blank, separated character substrings, and any trailing or isolated hyphens or apostrophes are eliminated. Thus, a word is defined as a character string with embedded hyphens and apostrophes. This allows contractions such as &quot;can't&quot; and hyphenated words such as &quot;high-brow&quot; to get through the system whole. <P>
As written, lines terminating in a hyphen are handled improperly. Also, some word structures fairly common in computer-science literature--&quot;dot&quot; notations referring to structures and the common use of underscore characters in variable names, for example--will be split. While these limitations are acceptable for my needs, this might be a good place to start when considering extensions to the code.<P>
After getting all the words into an array, the array is sorted and scanned. Words that are spelled the same are adjacent in the sorted array, so the scan is performed, the frequency is accumulated, and the word array is reduced to an alpha array of words and their associated frequencies. This array is written out as a file with the same DOS name as the original, but with the .CNT extension. The rest of the programs--SORTA, MERGEA, and STATA--are available electronically (see &quot;Availability,&quot; page 3). The programs parse the command line, read in the input file or files, perform the operation and write an output file, or in the case of STATA, the word counts are simply printed to standard output. <P>
The process is a bit trickier in the case of MERGEA. The command line can include up to five files to be merged, as well as the name that the output file is to take. The alpha lines are simply appended, and the file is sorted with the frequency numbers as a TAGARRAY. Then the file is scanned in a fashion similar to COUNT except that alpha lines are scanned and the frequency counts of repeated words between files are accumulated.<P>
<h3><a name="011f_0059">Inside the PBDK<a name="011f_0059"></h3><P>
PowerBASIC recently added the PowerBASIC Developer Kit (PBDK) to its family of support tools. PBDK is a shell over the Windows API that simplifies Windows programming dramatically. Simple but complete access to Windows, dialog boxes, menus, DDE, clipboard, DLLs, and preemptive multitasking are all provided and relatively easy to use. Since it is not intrinsically event driven like Visual Basic, the PBDK provides a more graceful introduction to the Windows environment without the &quot;sink-or-swim&quot; feeling. The PBDK also provides PowerBASIC developers with a migration path to Windows that does not require a major rewrite of DOS application code.<P>
The PBDK run time consists of three files: the DVSERVER.EXE server, DVDLL.DLL, and Windows virtual driver VDV.386. The DLL and driver are contained within DVSERVER.EXE, which will extract them transparently at run time and do so only once. The server shields you from much of the complexity of the Windows environment. From PowerBASIC, the server simply looks like a standard library.<P>
Although Windows is message based, the PBDK handles all the low-level messages, leaving you to handle only those messages that are application dependent. The components of a Windows application as implemented by PBDK include the session, the working area of a PBDK application where it will open other windows and where any menus will be installed, and then various user-defined dialogs containing the controls the application will use. To make the application operate you must use event loops. The event loop uses the <I>GetMessage()</I> function to read the message queue maintained by the DV server. <a href="#011f_0060">Figure 3</A> shows the steps required to create an application. <P>
<h3><a name="011f_005a">Migrating to Windows<a name="011f_005a"></h3><P>
Implementing the application required a bit of thought. The functions were generally independent in the DOS implementation. Creating a Windows implementation, however, implies a higher degree of integration. My first thought was simply to create a menu structure whose elements (<I>Count</I>, <I>Sort</I>, <I>Statistics</I>, and <I>Merge</I>) corresponded to one of the DOS commands. The implementation would just get the command parameters, and the only change necessary to the original DOS code would be to change from parsing a COMMAND$ line argument to passing the string to a subroutine for parsing. <P>
However, it quickly became obvious that this simple approach would not be satisfactory by itself. The problem is that Windows is a very visual environment, while the DOS command line is a very nonvisual environment. Moreover, many capabilities available in the DOS environment--file management, browsers, and editors, for example--are not as immediately available under Windows. Thus, the application that I collectively call &quot;Fun With Words&quot; would have to incorporate visual elements that are not part of the DOS implementation.<P>
<a href="19950122.htm">Figure 4</A> shows the Windows version of the application. There is the Session window containing the menu bar. Note that the additional menu item Get has been added to allow access to a .CNT file directly. Within the Session window is a dialog containing a variety of controls used to add visual elements to Fun With Words. The controls are two edit boxes and two list boxes together with three buttons labeled OK, GO, and End Merge. During the development I found this arrangement fairly intuitive. However, I suspect that users will find it a bit confusing since the dialog is used in more than one way.<P>
<a href="19950123.htm">Figure 5</A> shows the application with annotations showing how the menus and controls operate. Both Count and Get open the <I>OpenFileName</I> common dialog. With <I>OpenFileName</I>, users can select a filename which is then passed to the edit box with the label Active Word File, which holds an alpha filename. The list box is loaded with the alpha file lines, generally in alpha order. Selecting Sort causes the alpha file to be put in frequency order in the list box. Statistics opens a message box with the total word count and the distinct word count for the file in the Active Word File edit box. Selecting Merge makes the dialog box modal and puts it in merge mode; see <a href="19950124.htm">Figure 4</A>. In merge mode, the Active Word File can be used as a source of alpha filenames by putting the appropriate wild cards in the edit box. The list box is loaded when the OK button is clicked. Double-clicking on an alpha filename causes it to appear in the Merge File Selection list box. Adding an output filename in the associated edit box and selecting Go causes the files to be merged and written to the output file. Clicking on End Merge clears the edit and list boxes and reactivates the main menu.<P>
<h3><a name="011f_005b">Coding with the PBDK <a name="011f_005b"></h3><P>
The <I>OpenSession()</I> subroutine in <a href="#011f_0062">Listing Two</A> initializes the session, sets the opening size of the window and the <I>Txt$=&quot;Fun With Words</I>&quot; in the title bar, and returns the session handle, <I>hSession%</I>. The menu is defined in a resource file created with the Symantex Resource Toolkit included with the PBDK. You can also create menus directly in the code, but it's more cumbersome.<P>
The menu is loaded with the <I>LoadResources()</I> subroutine and set with <I>SetMenu()</I>. The main dialog illustrated in <a href="19950125.htm">Figure 4</A> is loaded with <I>LoadResources()</I> and then the various buttons and boxes are loaded with the <I>GetDlgItem()</I> subroutine. Once all the menus, dialog, and controls are in place, the program launches the main event loop. This is a straightforward loop which can be implemented in a number of ways. In <a href="#011f_0062">Listing Two</A>, a WHILE loop is used.<P>
The key to handling PBDK messages is to set up appropriate conditions in the event loop. You can go a long way without getting too fancy. The parameters in the <I>GetMessage()</I> subroutine call provide you with all the information necessary to interpret the messages. <I>hMsgWnd%</I> is the handle of the object sending the message. <I>Msg%</I> is the message number denoting the kind of message. <I>wP%</I> is the main parameter of the message, which depends on the message number. <I>XCursor%</I>, <I>YCursor%</I> is the position of the cursor. <I>XParam%()</I> is a parameter array whose meaning is dependent on <I>Msg%</I>. <I>Cmd$</I> is a string with additional information.<P>
All controls (buttons, list, edit boxes, and so on) send the value <I>Msg%=WMCOMMAND%</I> and the ID of the control in the variable <I>wP%</I>. Numerical values in <I>XParam%(2)</I> give notification codes such as LBNDBLCLK% (List Box Notification Double Click), which is used to transfer filenames from the left list box to the right list box. <P>
In Fun With Words, the global event loop looks for menu selections. With each selection, it does what is indicated (Count, Get, and so on). With Merge, it sets the main dialog box modal and sets off a local event loop to handle the Merge functionality. Clicking on the button End Merge causes the program to clear the boxes and return to the menu loop.<P>
<h3><a name="011f_005c">Pitfalls<a name="011f_005c"></h3><P>
Most of the problems in coding Fun With Words resulted from weak PBDK documentation in certain areas. The examples tend to be somewhat superficial, something not particularly surprising in a new toolkit. The two-volume manual covers a lot of territory, but Windows is a big topic. The PBDK is now being shipped with improved documentation.<P>
I found that the <I>GetOpenFileName()</I> subroutine to use the <I>OpenFileName</I> common dialog was bombing the application when the Cancel button was clicked--my window would just collapse. After struggling and failing to find out why, I called PowerBASIC technical support. It turns out that you must execute a <I>ReadErrorNumber()</I> after calling <I>GetOpenFileName()</I> and test for error conditions. In my case, <I>ReadError-Number()</I> returned a value of 3. This is not exactly intuitive and I'm sure many more of these little tidbits of information are not clearly documented in the manuals.<P>
Another problem I encountered was with the file buffers in many of the DV subroutines. Buffers had to be initialized with a command like <I>FileName$=SPACE$(32)</I>, providing a 32-character buffer. When a string was returned, it was left-justified and space filled to the extent of the buffer. This caused a few problems when I simplistically concatenated filenames for the merge command. The parse instructions just weren't expecting really big strings. To find the problem, I scattered line numbers through the merge routine and created a MessageBox to tell me where I was blowing up. I left these in the code as warnings to stray passers-by. I also put a MessageBox out for every filename to establish that it was parsed correctly.<P>
<h3><a name="011f_005d">Conclusion<a name="011f_005d"></h3><P>
My initial experience using the PowerBASIC Developer Kit was positive and the effort, very productive. Although there were some difficulties and false starts, the product shields the programmer from many of Windows programming details, while allowing very functional use of the Windows environment. A strong point was the ability to easily port code created in the DOS environment to Windows with minimal change. I found the use of event loops somewhat more forgiving for a programmer unfamiliar with the Windows environment than a full-blown, event-driven interface would be. I was slightly disappointed that PBDK does not currently support the use of Visual Basic VBX-custom controls, nor does it support OLE 2. Bob Zale, PowerBASIC's author, assured me that VBX support is coming in the next release, with OLE 2 support to follow.<P>
<h3><a name="011f_005e">For More Information<a name="011f_005e"></h3><P>
PowerBASIC Developer Kit<P>
PowerBASIC Inc.<P>
316 Mid Valley Center<P>
Carmel, CA 93923<P>
800-780-7707<P>
$299.00<P>
<a href="19950126.htm">Figure 1</A>  Structure of the command-line word-frequency system.
<h4><a name="011f_005f"><B>Figure 2:</B> Functions that make up the command-line word-frequency system.<a name="011f_005f"></h4><P>
<pre>COUNT    count &lt;filename.ext&gt; -&gt; &lt;filename.cnt&gt;, 
         where &lt;filename.ext&gt; is an ASCII text file
         in free format and &lt;filename.cnt&gt; is
         an alpha file, comma delimited in the
         form &lt;word&gt;, &lt;frequency&gt;. The count
         function preserves hyphens and
         apostrophes in words and produces
         an alpha file in alphabetical order.
MERGEA   mergea &lt;file1&gt; &lt;file2&gt; _ / &lt;fileout&gt;. Input 
         files are alpha files; output is a combined 
         alpha file that adds together the frequencies 
         of the same words and produces a single, 
         merged alpha file. The alpha input files may
         be ordered in any fashion; the output file is 
         in alphabetical order.
SORTA    sorta &lt;filename&gt; [/A, /F] //. Accepts an 
         alpha file of unknown order and puts it in 
         either alphabetical or frequency order. If no 
         flag is provided, /F is assumed, and it will 
         be put into frequency order.
STATA    stata &lt;filename&gt;. Prints the total number of 
         words and the number of distinct words on the 
         screen. </pre><P>
<h4><a name="011f_0060"><B>Figure 3:</B> Steps to creating a Windows application using the PBDK.<a name="011f_0060"></h4><P>
<pre>1. Initialize PowerBASIC to link to the DVSERVER.
2. Initialize the DVSERVER.
3. Open the session.
4. Attach menus.
5. Add dialogs and controls.
6. Create global event loop.
7. Incorporate message handling and minor event loops as
   needed to implement application.
8. Disconnect server when finished: END.</pre><P>
<a href="19950127.htm">Figure 4</A>  Windows version of the vocabulary-frequency-analysis application. 
<a href="19950128.htm">Figure 5</A>  Annotated version of the vocabulary-frequency-analysis application.
<P>
<h4><a name="011f_0061">Listing One <a name="011f_0061"></h4><pre>

$ERROR ALL
InputFileName$=COMMAND$
CALL Mergea(InputFileName$)
END
'Program to read files and isolate and count occurances of words
' file should have the extension .TXT however the program will
' attempt to read any file so long as the user insists.

'OUTLINE
' 1. READ A LINE -- Drop if it is a comment line (i.e preceeded with ')
' 2. PARSE INTO WORDS
' 3. ADD WORDS TO AN ARRAY
' 4. WHEN LAST LINE, GO BACK AND...
' 5. ANALYZE ARRAY FOR REPEATED OCCURANCES OF WORDS
' 6. INITIALLY BY SORTING THE CONTENTS OF THE ARRAY AND
' 7. THEN GOING THROUGH THE ARRAY AND ACCUMULATING REPEATED WORDS.
' 8. WHEN FINISHED PRINT OUT TOTAL WORDS AND DISTINCT WORDS TO SCREEN.
' 9. WRITE THE ALPHA FILE &lt;WORD&gt;,&lt;# OCCURANCES&gt; IN SORTED ALPHA ORDER
'10. BUT THIS IS NOT AN ASSUMPTION ABOUT ALPHA FILES, THEY CAN BE IN ANY
'    ORDER Alpha File line::= &lt;word&gt;,&lt;frequency&gt;
'******************************************
'6/5/94 Added LinkBack: to drop comment lines so that input files could
'contain embedded comments without affecting the word counts
'6/7/94 Dropping word print outs and adding a stats line at end of run
'******************************************
 SUB Mergea (InputFileName$)
 'OPEN FILE
 $DYNAMIC
 MaxWords%=20000
 MaxWordsOnLine%=500
 DIM Word$(MaxWordsOnLine%)  'Assumes no more than MaxWordsOnLine%
 DIM AllWord$(MaxWords%), Vocab$(MaxWords%), VFreq%(MaxWords%)
 'String Constants Required
 UpperCase$=&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;
 LowerCase$=&quot;abcdefghijklmnopqrstuvwxyz&quot;
 Punctuation$=&quot;,.:;?&quot;
 Brackets$=&quot;&lt;&gt;{}[]()&quot;
 Digits$=&quot;0123456789&quot;

 'Now create OutputFileName$ by parsing COMMAND$
 FileRootName$=EXTRACT$(InputFileName$,&quot;.&quot;)
 '********* Note that this Output FileName creation may be Error Prone
 OutputFileName$=FileRootName$+&quot;.CNT&quot;
 'Ready to Open input file
 ON ERROR GOTO ErrorHandler
 OPEN InputFileName$ for input as #1
 WordCount=0 'This is the overall wordcount for the Input File
 WHILE NOT EOF(1)
 '*******************Get a Line$ and Parse it into words ************
 'Read Line In
LinkBack:
  LINE INPUT #1, Lin$
  'Parse Line Into Words
'First check line for apostrophe ... and skip lines with apostrophes
IF LEFT$(Lin$,1)=&quot;'&quot; THEN Goto LinkBack 'this drops comment lines
'Then Eliminate non-alpha characters replacing them with spaces
  REPLACE ANY &quot;,.:;?&lt;&gt;{}[]()0123456789&quot; WITH &quot;                       &quot; IN Lin$
Again:
  L=VERIFY(Lin$,UpperCase$+LowerCase$+&quot; &quot;+&quot;'&quot;+&quot;-&quot;) 'note apostrophe so as to 
                                                   '    capture contractions
  'Note this process will accept hyphens as a word and we want only
  'internal hyphens -- see below at EXTRACT$
  IF L=0 THEN Goto Success
  'Otherwise L points to a non alpha non space character
  'replace it with a space and continue
  MID$(Lin$,L)=&quot; &quot;
  Goto Again
Success:
  Lin$=LTRIM$(Lin$)
  Lin$=RTRIM$(Lin$)
  'Now spaces are stripped from front and back of string
  i=0 'Word Counter for # for Word(s) in Line$
KeepGoing:
  IF Len(Lin$)=0 THEN Goto Done
  Word$(i)=EXTRACT$(Lin$,&quot; &quot;) 'Finds ith word but it may just be hyphens
  Lin$=LTRIM$(Lin$,Word$(i)) 'Strips found word from string
  Lin$=LTRIM$(Lin$) 'Strips leading blacks
  Word$(i)=LTRIM$(Word$(i),ANY &quot;-'&quot;)
  Word$(i)=RTRIM$(Word$(i),ANY &quot;-'&quot;)
  IF Len(Word$(i))=0 THEN Goto KeepGoing
  i=i+1 'Increment counter
  Goto KeepGoing 'this will loop collecting the words in Lin$
Done:
'****************** End of Line$ Parse *************************
  'i enters Done as the # of words collected indexed from 0 to n-1
  'Note that this is done with a line not the whole file so now we have
  'to add the words to the AllWord$() array
  'Now we must put the indicated # of words in an array which is
  ' large enough to hold all the words in the file.
'************** Assemble the Line$ words into the AllWord$ Array *******
  For j=0+WordCount to i-1+WordCount
  AllWord$(j)= Word$(j-WordCount)
  Next j
  WordCount=WordCount + i 'Increments after assigning all Word$(s) from line
WEND
CLOSE #1
'*********************************Word Collection Complete ************
' **** SORT the AllWord$(0 to WordCount-1) Array **********************
ARRAY SORT AllWord$(0) FOR WordCount,COLLATE UCASE
IF WordCount&gt;0 THEN GOTO Proceed
Print &quot;No Words Found&quot;
END
Proceed:
'Variables are NumWords which counts the Vocabulary Additions AllWordPointer 
' which indexes through the AllWord$() array WordCount which holds the number 
' of words in the AllWord$() array indexed from 0 to WordCount-1
'Vocab$() the Vocabulary Array and VFreq%() the frequency array
NumWords=0
AllWordPointer=0 'Initialize NumWords and AllWordPointer
Vocab$(NumWords)=AllWord$(AllWordPointer) 'Initializes 1st word
VFreq%(NumWords)=1 'One occurrance of the 1st word
VocabAgain:
  AllWordPointer=AllWordPointer+1 'Now has # of words scanned
  IF UCASE$(AllWord$(AllWordPointer))=UCASE$(AllWord$(AllWordPointer-1)) THEN
     'Word is repeated so
     VFreq%(NumWords)=VFreq%(NumWords)+1
     IF AllWordPointer=WordCount-1 THEN Goto VDone
     Goto VocabAgain
  ELSE
     NumWords=NumWords+1
     Vocab$(NumWords)=AllWord$(AllWordPointer)
     VFreq%(NumWords)=1
     IF AllWordPointer=WordCount-1 THEN Goto VDone
     Goto VocabAgain
  END IF
VDone:
OPEN OutputFileName$ for output as #1
For j=0 to NumWords
PRINT #1,UCASE$(Vocab$(j));&quot;,&quot;;STR$(VFreq%(j))
next j
CLOSE #1
Print &quot;Total Number of Words= &quot;;WordCount
Print &quot;Number of Different Words is= &quot;;NumWords+1
END SUB
'********************************************************
' SUBROUTINES
'********************************************************
 ErrorHandler:
 E=ERRTEST
 IF E=53 then Print &quot;Input File Not Found&quot;:END
 Print &quot;Error&quot;;E;&quot; Occurred&quot;


</pre>
<h4><a name="011f_0062">Listing Two<a name="011f_0062"></h4><pre>

$ERROR ALL
'Fun With Words -- an example of the conversion of DOS BASIC programs to 
' Windows using the PowerBASIC Development Kit -- Copyright R.Schneider 1994

$INCLUDE &quot;PB3DV.PB3&quot;
CALL InitExecution( &quot;FWW&quot;, RESETAPP% )
CALL ReadErrorNumber( DVError% )
IF DVError% &gt; 0 THEN END

'*****
'Creation of a Session, required to use Menus.
'*****
Txt$  =  &quot;Fun With Words&quot;
CALL OpenSession( Txt$, 0, 0, 639, 479, hSession% )

'Open Menu Resource
MenuResName$=&quot;WFMENU.RC&quot;
CALL LoadResources(MenuResName$,hMenuRes%)
MenuName$=&quot;MainMenu&quot;
CALL OpenMenuRes(hMenuRes%,0,MenuName$,hMenu%)
' Setting the new Menu in the current Session. The Menu is now
' displayed, and it starts emitting messages.
CALL SetMenu(hMenu%)

'Load MainDialog Box
ResName$=&quot;wfmndlg.rc&quot;
CALL LoadResources(ResName$,hDlg%)
DlgName$=&quot;MAINDLG&quot;
CALL OpenDlgRes(hDlg%,DlgName$,hWnd%)
CALL SetWindowModal(hWnd%,NOTMODAL%)

'Open Resources in Main Dialog Box
hEditBox%=101
CALL GetDlgItem(hWnd%,hEditBox%,hEdit%) 'hEdit% set by Windows
hListBox%=103
CALL GetDlgItem(hWnd%,hListBox%,hList%)
hGOButton%=107
CALL GetDlgItem(hWnd%,hGOButton%,hGO%)
hEndMergeButton%=110
CALL GetDlgItem(hWnd%,hEndMergeButton%,hEndMerge%)
hMergeFileEdit%=108
CALL GetDlgItem(hWnd%,hMergeFileEdit%,hMergeEdit%)
hMergeListBox%=109
CALL GetDlgItem(hWnd%,hMergeListBox%,hMergeList%)
hOKButton%=111
CALL GetDlgItem(hWnd%,hOKButton%,hOK%)
' Event Loop
DIM XParam%(4)
GetMsg%  =  1
WHILE GetMsg% &lt;&gt; 0
CALL GetMessage( hMsgWnd%, Msg%, wP%, XCursor%,_YCursor%, XParam%(1), Cmd$)
' When no message is available, GetMessage returns a Msg=0 Message.
  IF Msg% &lt;&gt; 0 THEN
  ' The Msg%=WMCOMMAND% messages come from the Menu.
  ' wP% contains the ID of the clicked Item.

    IF Msg% = WMCOMMAND% THEN
     IF wP%= 100 THEN 'Menu Count was selected
      Flags&amp;=0
      Filter$=&quot;Filter 1 $.TXT $.BAK |*.TXT *.BAK | 
                                     Filter 2 $.C $.DOC $.BAK|*.C *.DOC *.BAK&quot;
      CustomFilter$=&quot;CFilter 1 $.TXT $.BAK |*.TXT *.BAK&quot;
      FileTitle$=&quot;&quot;
      Title$=&quot;Get ASCII Test File to Count&quot;
      FileName$=SPACE$(32)
      Directory$=&quot;C\&quot;
      DExt$=&quot;&quot;
      CALL GetOpenFileName(0,Filter$,CustomFilter$,0,_
           FileName$,64,_
           FileTitle$,Directory$,Title$,Flags&amp;,_
           FileOffset%,FileExt%,DExt$,xError&amp;)
           CALL ReadErrorNumber(ErrNum%)
         IF ErrNum%=0 THEN
           'Load Edit Box and Read .CNT file into ListBox
           DistinctWords%=0
           CALL Count(FileName$,hEdit%,OutFileName$,DistinctWords%)
           'Now load ListBox
           CALL ResetListBox(hList%)
           Open OutFileName$ for input as #1
           lnum%=0
           for num%=1 to DistinctWords%
           Line Input #1, WordF$
           CALL AddStringListBox(hList%,WordF$,lnum%)
           next num%
           close #1
         END IF
         IF ErrNum%=3 THEN
         END IF 'do nothing
           END IF 'menu 100 COUNT
           IF wP%=200 THEN
           ' Sort File Program Calls etc. Need to check for sort 
               ' variable /F or /A and check that edit box has a file in it.
          IF OutFileName$&lt;&gt;&quot;&quot; THEN
            Path$=OutFileName$
            CALL SetSelEdit(hEdit%,0,32)'Don-t like absolute #s
            CALL ReplaceSelEdit(hEdit%,Path$)
            CALL SortIt(OutFileName$,DWords%)
            CALL ResetListBox(hList%)
            Open OutFileName$ for input as #1
            lnum%=0
            FOR num%=1 to DWords%
            Line Input #1, WordF$
            CALL AddStringListBox(hList%,WordF$,lnum%)
            NEXT num%
            CLOSE #1
          END IF 'OutFileName
        END IF 'menu 200 SORT
        IF wP%=300 THEN
        'Statistics Program
          Print OutFileName$
          'Note should check EditBox for contents and use that!
          IF OutFileName$=&quot;&quot; THEN
          ELSE
            CALL Statistics(OutFileName$)
          END IF 'OutFileName
          END IF 'menu 300 STATISTICS
          IF wP%=400 THEN
          'Merge Code
            CALL SetWindowModal(hWnd%,TASKMODAL%)
            CALL ResetListBox(hList%)
            CALL ResetListBox(hMergeList%)
            CALL SetSelEdit(hMergeEdit%,0,32)
            'Set Edit Box to Default Value, *.CNT
            Path$=&quot;*.CNT&quot;
            CALL SetSelEdit(hEdit%,0,32)
            CALL ReplaceSelEdit(hEdit%,Path$)
            'Get directory based on DefaultValue
            CALL AddDirListBox(hList%,Path$,DDLREADWRITE%)
            'Setup Local Event Loop
            Cmd$=SPACE$(32)
            DIM Xp%(4)
            GetLocalMsg%=1
            WHILE GetLocalMsg%&lt;&gt;0
              Call GetMessage(hLMsgWnd%, LMsg%, LwP%, Xc%, Yc%, Xp%(1), Cmd$)
              IF LMsg%=0 THEN
            CALL ReleaseTimeSlice
              ELSE 'LMsg% is not equal to zero
            IF LMsg%=WMCOMMAND% THEN
               IF LwP%=hEndMergeButton% THEN
                  GetLocalMsg%=0
               END IF  'hEndMergeButton
               IF LwP%=hListBox% THEN
                  Notification%=Xp%(2)
                  IF Notification%=LBNDBLCLK% THEN
                  'Get the selected item from ListBox
                  'first get # lines in list box
                CALL StatusListBox(hList%,l%,top%,w%,height%,
                                  _MaxWidth%,Index0%,NbLines%,
                                  _SelectedLine%,selcnt%)
                'SelectedLine% is the index of the selected 
                                ' line or it is negative
                ThisLine$=SPACE$(32)
                CALL GetTextListBox(hList%,SelectedLine%,ThisLine$,32)
                Print ThisLine$
                'then look for selected line. put selected line
                'in merge listbox. get # of items in listbox
                CALL StatusListBox(hMergeList%,l%,top%,w%,
                                       height%,_MaxWidth%,Index0%,
                                       NbLines%,_SelectedLine%,selcnt%)
                IF NbLines%&lt;5 THEN
                    CALL AddStringListBox(hMergeList%,ThisLine$,Rank%)
                    Print &quot;Got to NbLine%&lt;5 IF Statement&quot;
                ELSE
                    'List Box has 5 items in it now! No more 
                    'will be accepted. Put up a message box.
                    Txt$  =  &quot;Only 5 files can be merged at a time!&quot;
                    Caption$  =  &quot;Informative Message&quot;
                    CALL MessageBox( 0, Txt$, Caption$,
                                                  MBOK% OR MBTASKMODAL%, Code%)
                END IF 'NbLines&lt;5
                  END IF 'Notification
                END IF 'hListBox
                IF LwP%=hGOButton% THEN
                  'Enter a Merge File Name
                Size%=MAXSTR%
                MergeFileName$=SPACE$(MAXSTR%)
                CALL GetCTLText(hMergeEdit%,MergeFileName$,Size%)
                MergeFileName$=RTRIM$(MergeFileName$)
                MergeFileName$=LTRIM$(MergeFileName$)
                IF MergeFileName$=&quot;&quot; THEN GOTO NoGood
                CALL StatusListBox(hMergeList%,l%,top%,w%,
                                   height%,_MaxWidth%,Index0%,
                                   NbLines%,_SelectedLine%,selcnt%)
                CtlString$=&quot;&quot;
                for i%=Index0% to Index0%+NbLines%-1
                Size%=MAXSTR%
                Text$=SPACE$(MAXSTR%)
                CALL GetTextListBox(hMergeList%,i%,Text$,Size%)
                Text$=RTRIM$(Text$)
                CtlString$=CtlString$+&quot; &quot;+Text$
                next i%
                CtlString$=CtlString$+&quot; /&quot;+MergeFileName$
                CALL Merge(CtlString$)
                 Print CtlString$
                NoGood:
                END IF 'hGOButton%
                IF LwP%=hMergeListBox% THEN
                  'if doubleclick on filename. then delete filename
                  'if no filename, then do nothing
                  Notification%=Xp%(2)
                  IF Notification%=LBNDBLCLK% THEN
                'Get the selected item from ListBox
                'first get # lines in list box
                CALL StatusListBox(hMergeList%,l%,top%,w%,
                                    height%,_MaxWidth%,Index0%,
                                    NbLines%,_SelectedLine%,selcnt%)
                'SelectedLine% is the index of the selected 
                                'line or it is negative
                ThisLine$=SPACE$(32)
                CALL GetTextListBox(hMergeList%,SelectedLine%,ThisLine$,32)
                Print ThisLine$
                'then look for selected line
                'delete the selected line in merge list box
                IF ThisLine$ &lt;&gt; &quot;&quot;  THEN
                  CALL DeleteStringListBox(hMergeList%,SelectedLine%)
                END IF 'ThisLIne
                  END IF 'Notification
                END IF 'hMergeListBox -- to delete entries

                IF LwP%=hOKButton% THEN
                  'a file name has been entered
                  ' in the edit box with wildcards
                Size%=MAXSTR%
                EditFileName$=SPACE$(MAXSTR%)
                CALL GetCTLText(hEdit%,EditFileName$,Size%)
                PRINT EditFileName$
                'reset the edit box and then
                CALL ResetListBox(hList%)
                'add the directory or file name
                CALL AddDirListBox(hList%,EditFileName$,DDLREADWRITE%)
                END IF   'hOKButtion%
               END IF 'WMCOMMAND
            END IF 'LMsg%=0
              WEND 'Local Event Loop
              'Clear Everything
              CALL SetWindowModal(hWnd%,NOTMODAL%)
              CALL SetFocus(hSession%)
              CALL ResetListBox(hList%)
              CALL ResetListBox(hMergeList%)
              CALL SetCTLText(hEdit%,SPACE$(32))
              CALL SetCTLText(hMergeEdit%,SPACE$(32))
            END IF 'Merge Menu Item #400
            IF wP%=500 THEN Msg%=WMSYSCOMMAND%:wP%=SCCLOSE%
            IF wP%=600 THEN
             'Get an alphafile name and display the file in listbox--
             ' use same strategy as with the Count menu item without 
                     ' calling the count function
             Flags&amp;=0
             Filter$=&quot;Filter 1 $.CNT $.BNT |*.CNT *.BNT&quot;
             CustomFilter$=&quot;CFilter 1 $.CNT $.BNT |*.CNT *.BNT&quot;
             FileTitle$=&quot;&quot;
             Title$=&quot;Get Alpha File&quot;
             FileName$=SPACE$(32)
             Directory$=&quot;C\&quot;
             DExt$=&quot;&quot;
             CALL GetOpenFileName(0,Filter$,CustomFilter$,0,_
              FileName$,64,_
              FileTitle$,Directory$,Title$,Flags&amp;,_
              FileOffset%,FileExt%,DExt$,xError&amp;)
              CALL ReadErrorNumber(ErrNum%)
             IF ErrNum%=0 THEN
              'Load Edit Box and Read .CNT file into ListBox
              Path$=FileName$
              CALL  SetSelEdit(hEdit%,0,32)'Don-t like absolute #s
              CALL ReplaceSelEdit(hEdit%,Path$)
              OPEN FileName$ for INPUT as #1
              LinCount%=0
              CALL ResetListBox(hList%)
              WHILE NOT EOF(1)
               LINE INPUT #1, Lin$
               CALL AddStringListBox(hList%,Lin$,lnum%)
               LinCount%=LinCount% + 1
              WEND
              CLOSE #1
              OutFileName$=FileName$
              CALL Statistics(OutFileName$)
             END IF
             IF ErrNum%=3 THEN
             END IF 'do nothing
            END IF 'Menu 600 GET
        END IF 'Msg WMCOMMAND
        ' The Msg=WMSYSCOMMAND messages come from the System Menu of 
        ' the current Session. wP contains the ID of the clicked Item.
        ' Event Loop ends when System Menu CLOSE Item is activated.
        IF Msg% = WMSYSCOMMAND% THEN
            IF wP% = SCCLOSE% THEN
            ' Opening a Message Box to ask the user if he really 
                        ' wants to end the program.
            Txt$  =  &quot;Do you really want to end Fun With Words?&quot;
            Caption$  =  &quot;Goodbye Message&quot;
            CALL MessageBox( 0, Txt$, Caption$, MBYESNO% OR MBTASKMODAL%, Code%)
            ' Code receives a value related to the user answer:
            ' IDYES%, or IDNO% in this case.
            IF Code%  =  IDYES% THEN GetMsg%  =  0
            END IF 'SCCLOSE
        END IF 'WMSYSCOMMAND
    ELSE
        ' If no message is available, the application releases its Time
        ' Slice to let other applications run.
        CALL ReleaseTimeSlice
    END IF
WEND 'Main Event Loop
CALL EndExecution
END
'******************* EXTERNAL SUBROUTINES ***************
'***** Slightly Modified Original DOS Code **************
$INCLUDE &quot;merge.bas&quot;
$INCLUDE &quot;cnt.bas&quot;
$INCLUDE &quot;sortwin.bas&quot;
$INCLUDE &quot;statist.bas&quot;
'********************************************************
' SUBROUTINES
'********************************************************
 ErrorHandler:
 E=ERRTEST
 'IF E=53 then Print &quot;Input File Not Found&quot;:END
 Print &quot;Error&quot;;E;&quot; Occurred&quot;
 Txt$  =  &quot;Error=&quot;+STR$(E)+&quot; Occurred at Line &quot;+STR$(ERL)
 Caption$  =  &quot;Error Box&quot;
 CALL MessageBox( 0, Txt$, Caption$,MBYESNO% OR MBTASKMODAL%, Code%)
            ' Code receives a value related to the user answer:
            ' IDYES%, or IDNO% in this case.
            IF Code%  =  IDYES% THEN END
 END

</pre>
<HR><P>Copyright &copy; 1995, <I>Dr. Dobb's Journal</I></P></BODY></HTML>
