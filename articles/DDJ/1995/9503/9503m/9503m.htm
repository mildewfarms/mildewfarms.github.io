<HTML>
<META NAME="year" CONTENT="1995">

<HEAD>
<TITLE>MAR95: ALGORITHM ALLEY</TITLE></HEAD>
<BODY BGCOLOR="#ffffff">
<h1>ALGORITHM ALLEY<a name="0136_005d"></h1><P>
<h2><a name="0136_005b"><a name="0136_0000">Algorithm Analysis</h2><P>
<h3>Micha Hofri </h3><P>
<p><i><a name="0136_005c"><a name="0136_0000">Micha, who is the author of Probabilistic Analysis of Algorithms (Springer-Verlag, 1987), can be contacted at hofri@cs.rice.edu.</i></p><hr><P>
Introduction <P>
<h3><I>by Bruce Schneier</I></h3><P>
Anyone can open a book and find an algorithm that sorts an array of numbers. It's much harder to choose--or invent--the sorting algorithm that works <I>best</I> for a particular job. It's about noticing the strengths and weaknesses of different algorithms that do the same thing, and figuring out which set of characteristics most closely matches the needs of the situation at hand.<P>
You can see this distinction in many off-the-shelf software products. The behemoths that most large application-software products have become take up tens of megabytes of memory and are sluggish on all but the fastest of computers. Like sledgehammers, they do the job--effectively, but without flourish.<P>
More interesting are applications on the cutting edge of computing. Missile-guidance systems, where shaving a few clock cycles off the running time of an algorithm can mean the difference between success and failure. Smart cards, where complex applications are crammed into a credit-card device with processors eight bits wide and total RAM measuring in hundreds--not millions--of bytes.<P>
In this month's column, Micha Hofri looks at the analysis of algorithms--specifically, at time/memory trade-offs. With this technique, a programmer can throw extra memory at a problem in order to improve performance, or sacrifice performance in order to decrease memory requirements.<P>
Algorithms can be analyzed with qualitative and quantitative objectives. &quot;Qualitative analysis&quot; answers questions about correctness, termination, freedom from deadlock, and predictability. These questions occasionally need quantitative calculations as well, but we reserve the latter adjective for analysis that concerns performance, which is what this article is all about.<P>
Since the algorithms we look at are performed in digital computers, the two resources of importance are time and space. &quot;Time&quot; is the run time to completion, and &quot;space,&quot; the storage area required to hold code and data. Both are always needed, but in most cases, the analysis of only one type of resource is of practical interest. Sometimes the designer can trade off the two to some extent. <P>
Analysts do not use seconds to express results about run time; it is too implementation and platform dependent. Sometimes we count machine instructions, but this, too, is rarely a good idea. It is better to count &quot;roughly similar&quot; source instructions or just the main, dominating, characterizing operations. For example, when analyzing sorting algorithms performed completely in main memory, we could concentrate on counting comparisons that are needed; we could then claim that some part of the rest is proportional to this count, and that whatever remains is negligible. For higher precision, we could count exchanges as well. However, if the sort required frequent disk accesses, we would count only those operations that take much longer to complete. Except in particularly simple situations, there is art to this science.<P>
Space requirements are normally simpler. The area needed for code is rarely interesting for two reasons: It is usually not controllable and, when space is an issue, it is far smaller than the demands of temporary storage for data. An algorithm may have some natural space unit to use: a record, word, node, or fixed-size vector. Otherwise, we simply count bytes.<P>
<h3><a name="0136_005e">Techniques of Analysis<a name="0136_005e"></h3><P>
The analysis we consider skirts issues of platform, language, and compiler dependence. The results have wider validity and do not date as fast. In other words, we analyze algorithms, not programs. An important benefit is that this approach simplifies the needed mathematical models of the algorithms, and eventually, the analysis of those models. The analysis itself is mathematical, and the kinds of mathematics are determined by the model--typically, they include some algebra and combinatorics. Generating functions are often helpful as well. If we want asymptotic results, this immediately raises the ante: We need to use functions of complex variables. Due to space limitations, in this article I'll stick to &quot;back-of-envelope&quot; calculations.<P>
When you need to select a machine or a compiler, the dependencies we shunned earlier are the center of interest. This is a different ball game: Except for statistics, mathematics is rarely any help; the key words here are &quot;measurement&quot; and &quot;benchmarking.&quot; <P>
Somewhere in between is simulation. In the present context, it is used as a substitute for mathematical analysis, when the going gets too rough, when our model gives rise to an equation we cannot solve, for example, or when we cannot write meaningful equations. (The latter might be an indication that we do not yet have a good grip on the underlying problem.)<P>
<h3><a name="0136_005f">Modes of Analysis<a name="0136_005f"></h3><P>
&quot;Mode&quot; refers to the kind of answer the analysis provides. Let us restrict attention for the moment to running time, an issue that<B> </B>arises when an algorithm needs different times to process different inputs (of similar size). This is not always the case: Most algorithms to invert a matrix, run for essentially the same time for all matrices of a given size. This is typical when the algorithm only computes. Algorithms that search for a solution, rather than calculating it, show huge variations.<P>
If the answer of the analysis has to be a bound, then the analyst must find a function f(<I>n</I>) with the following property: To process <I>n</I> items, algorithm A will never use more than f(<I>n</I>) instructions, iterations, or other relevant unit. This is sometimes a desirable assurance, and this is what worst-case analysis provides. The designer of a real-time system may need it in order to prove that his design is within specs.<P>
Such guarantees are reassuring, but not always practical. Consider an example where an algorithm has 4<I><SUP>n</SUP></I> possible inputs of size <I>n</I>. A bound of 3<SUP>4<I>n</I></SUP> operations is not only frightening, it is also nearly meaningless when it is reached in a few--or even <I>n</I>--problem instances only, or even in 10<I>n</I> of the 4<I><SUP>n</SUP></I> possible inputs. One reason is that even with these large run times, the average time on all 4<I>n</I> possible instances could be far more modest; 2<I>n</I>+7, for example. Second, if <I>n</I> exceeds 30 or so, the probability of hitting one of the unlucky instances is infinitely smaller than that of the machine being shredded by a meteorite. The immensely popular simplex algorithm for linear optimization has exactly such a skewed profile.<P>
Averages are especially important when we consider algorithms that are used repeatedly, such as those that compute trigonometric functions or perform joins over a relational database. These algorithms require an estimate of both the average resource requirements and the likely deviations. This calls for probabilistic analysis that provides the expected run time and its variance (because of the need for the variance to estimate the probable deviations, I shy away from the term &quot;average-case analysis&quot;). <P>
The issue just raised  is important in the following scenario: You need to choose between two algorithms. Should you choose on the basis of worst-case or average behavior? Often, if one algorithm is better in one mode, it is also better in the other. But in any number of situations, the ordering according to the two modes is reversed. So the answer depends on the more pressing criteria of performance: guarantee versus overall efficiency.<P>
Naturally, there is an in-between mode. It is meaningful for algorithms that live a long time, such as those that maintain data structures, route messages in a network, or supervise a disk channel. Such algorithms may use foresight to advantage and periodically restructure the data or collect statistics to recompute optimal parameters. Then it may be more meaningful to consider the average cost of an operation in a sequence of operations, where such computational &quot;investments&quot; are prorated on the entire sequence, than to look at an isolated operation. The term &quot;amortized analysis&quot; describes such analysis done in the worst-case behavior mode. Because those &quot;investments&quot; can be controlled by user-supplied parameters, this approach is equally meaningful when considering average behavior.<P>
<h3><a name="0136_0060">Example: Space/Time Trade-Off<a name="0136_0060"></h3><P>
A trade-off is possible if you can save on one resource by spending more on a less critical one. Consider computing a trigonometric function. This is normally done by evaluating the ratio of two polynomials of moderate degree (depending on the desired precision). We could drastically reduce the required time by keeping in storage a table with a few hundred values (or thousands--again, this is determined by the required precision) and using low-level interpolation to derive the desired result. With a very large table we might even skip the interpolation, saving 90 percent or so of the needed time.<P>
A related but different situation arises when computing one value of the function is relatively slow, compared with constructing a complete table. Computing the binomial coefficient <I>BC(n,k)</I> for <I>0&lt;k<img src="lteq12.gif" alt="&lt;=">n/2</I> needs 3k additions/multiplications. Constructing a table of all such coefficients for <I>0<img src="lteq12.gif" alt="&lt;=">k<img src="lteq12.gif" alt="&lt;=">n<img src="lteq12.gif" alt="&lt;=">N</I> requires approximately N<SUP>2</SUP>+N additions using the standard recursion. If we expect an algorithm to use at least some portion of the table (a common situation), we can save a lot of time by preparing it during the initialization phase.<P>
In contrast to these examples, which choose between two methods, there are situations where the trade-off can be parameterized. Here is a simple example: We need to sort a large file on disk. The file is too large to be accommodated in the main memory available for this application. (For now, forget about virtual storage, even if it's technically possible; using it here effectively calls for virtuoso programming and a good deal of a priori information about the original order of the file.) A naive mergesort algorithm reads chunks of the file into storage, sorts each chunk internally, and writes it as a separate file on disk (which we assume has enough free space). Then the chunks are read in parallel and merged into one fully sorted file. Word is the sorting unit, and the file has N words. Let the size of a chunk be <I>n</I>, so that <I>k=N/n</I> chunks are created. Strictly speaking, we would have <img src="hfbrulf12.gif" alt="half brace">N/n<img src="hfbrurt12.gif" alt="half brace"> chunks, but to keep it simple we'll assume that N/<I>n</I> is an integer. Let's also assume that with buffers and caches, other tasks running in parallel and sufficient disk bandwidth, the bottleneck is the CPU. We want to optimize the use of this resource.<P>
The &quot;time&quot; needed to sort <I>n</I> words is <I>An*ln(n)</I> comparisons. A is a constant that we assume known and that depends on the selected algorithm. Several algorithms for internal sort reach this optimal goal (optimal for comparison-based sort, on information-theoretic grounds) on the average, and some variants approach it even in the worst case--with larger constants, but still quite reasonably. The time to merge <I>k</I> streams of size <I>n</I> each is <I>Bk(k-1)n</I>, where B is another constant we assume known (because when we sort in increasing order, <I>k</I>-1 comparisons are needed to determine the smallest word out of the <I>k</I> currently at the heads of the <I>k</I> chunks, and this must be done for all the <I>N=nk</I> words).<P>
The total time is <I>T=Akn ln(n)+Bk(k-1)n=N(A ln(n)+B(k-1))</I>. The storage used is essentially the one buffer of size <I>n</I>. How large should it be? T is minimized when <I>k=1</I>, and as we increase it, the needed storage goes down, and the run time goes up. Where we stop depends on the available physical storage and the demands of concurrent operations. If this sort is needed often enough and the sorting time we get with the current storage limitation is unacceptable, the designer may consider purchasing main memory, and the saved time will be expressed in dollars and cents.<P>
A still-different space/time trade-off appears in the suggestion made by Tom Swan (&quot;Algorithm Alley,&quot; <I>DDJ</I>, April 1994) to replace binary search (trees) by search tries with higher fan-out degree. In fact, several variations on the theme expose a variety of trade-offs. The simplest one arises from using more space for internal nodes to represent successive characters in the key, yielding a large reduction in search time.<P>
<h3><a name="0136_0061">Further Reading<a name="0136_0061"></h3><P>
By far, the richest source for a variety of algorithms and their analyses is still Donald Knuth's <I>The Art of Computer Programming</I> (Addison-Wesley, 1981). <P>
Two additional good sources for algorithms are <I>Algorithmics: Theory and Practice</I>, by Gilles Brassard and Paul Bratley (Prentice-Hall, 1988), and <I>Introduction to Algorithms,</I> by Thomas H. Cormen, Charles E. Leiserson, and Ronald L. Rivest (MIT Press and McGraw-Hill, 1990). The analyses in these books are less ambitious, and usually bounds are considered. The second book gives examples of amortized analysis, as well.<P>
Finally, my book, <I>Probabilistic Analysis of Algorithms</I> (Springer-Verlag, 1987), is mathematical and intended to supply the tools for analysis. However, it is not an &quot;algorithms book.&quot; A new, more comprehensive version is due later this year from Oxford University Press.<P>
<P>
<HR><P>Copyright &copy; 1995, <I>Dr. Dobb's Journal</I></P></BODY></HTML>
