<HTML>
<META NAME="year" CONTENT="1995">

<HEAD>
<TITLE>JUN95: Coding with HTML Forms</TITLE></HEAD>
<BODY BGCOLOR="#ffffff">
<h1>Coding with HTML Forms<a name="0285_00b0"></h1><P>
<h2><a name="0285_00ae"><a name="0285_0000">HTML goes interactive</h2><P>
<h3>Andrew Davison</h3><P>
<p><i><a name="0285_00af"><a name="0285_0000">Andrew is a lecturer in the department of computer science at the University of Melbourne, Australia. He can be reached at ad@cs.mu.oz.au.</i></p><hr><P>
The World Wide Web (WWW) is a hypertext-based system that allows users to &quot;surf&quot; the Internet, accessing information on topics as diverse as astronomy, the Marx brothers, and kite making. The most common WWW browser is Mosaic, a graphical tool from the National Center for Supercomputing Applications (NCSA) that's been ported to most operating systems. In addition, a plethora of new browsers are currently being released, offering similar (usually extended) capabilities for Windows, Macintosh, and the X Window system. (There are even text-based browsers such as Lynx.)<P>
Underpinning the WWW is a page-description language called the &quot;hypertext markup language&quot; (HTML), derived from the &quot;standard generalized markup language&quot; (SGML). Essentially, HTML offers a small set of commands which, when embedded in a text file, allow a browser to display the text, replete with fancy fonts, graphics and, most importantly, hypertext links to other hypertext documents.<P>
One feature of HTML is its simplicity: An HTML document can be produced in a few minutes, as Douglas McArthur demonstrated in his article, &quot;World Wide Web and HTML&quot; (<I>DDJ</I>, December 1994). However, HTML lacks support for writing documents which interact with the user. Interaction in most documents consists of the user deciding which hypertext link to follow next. <P>
Fortunately, HTML is still evolving. The current specification of the language is Document Type Definition (DTD) level 2, which includes &quot;forms&quot; that allow a document to include text-entry fields, radio boxes, selection lists, check boxes, and buttons. These can be used to gather information for an application &quot;behind&quot; the document, to guide what is offered to the user next. Some typical forms documents include a movie database (see http://www.cm.cf.ac.uk/Movies/moviequery.html), weather-map order form (http://rs560.cl.msu.edu/weather/getmegif.html), questionnaires, surveys, and Pizza Hut's famous PizzaNet (http://www.pizzahut.com/). A problem with forms is that many older WWW browsers (such as the most-common Macintosh version of Mosaic) do not support them, although this problem is rapidly disappearing as browsers are updated.<P>
In this article, I'll detail the steps in writing forms-based applications. Although I'll use NCSA Mosaic for X Windows 2.0, the approach is applicable to all WWW browsers with forms capabilities. <P>
<h3><a name="0285_00b1">HTML Forms <a name="0285_00b1"></h3><P>
There are three basic stages in creating a forms-based document:<P>
<OL>
<LI>Design the input form and write the corresponding HTML document.</LI>
<LI>Write the application program that interprets the data from the input form.</LI>
<LI>Design the document generated by the program as the reply to the user. Usually, this document is written in HTML, but this is not mandatory.</LI>
</OL>
Before describing how to do a forms application, let's review the HTML features for defining forms. A form begins with <I>&lt;FORM ACTION=&quot;URL address of application&quot; METHOD=&quot;POST</I>&quot;<I>&gt;</I> and ends with <I>&lt;/FORM&gt;</I>. The METHOD attribute specifies how the data entered in the various fields of the form is transmitted to the application. It is best to use the POST method, since the data is then sent to the standard input of the application, as a string of the form <I>name=value&amp;name=value&amp;_</I>, where <I>name</I> is the name of the form's data-entry field, and <I>value</I> is its associated data. <P>
The other method for sending data is GET. This causes the string to arrive at the server in the environment variable QUERY_STRING, which may result in the string being truncated if it exceeds the shell's command-line length. For that reason, GET should be avoided.<P>
A form can contain six types of data-entry fields: single-line text-entry fields, as in <a href="#0285_00b8">Figure 1</A>(a); check boxes, radio boxes, and selection lists, as in <a href="#0285_00b8">Figure 1</A>(b); multiline text-entry fields; and submit and reset buttons, as in <a href="#0285_00b8">Figure 1</A>(c). Single-line text-entry fields, check boxes, and radio boxes are specified using the same basic HTML syntax: <I>&lt;INPUT TYPE=&quot;field-type&quot; NAME=Name of field&quot; VALUE=&quot;default value&quot; &gt;</I>, where <I>field-type</I> can be either: text, check box, radio, hidden, or password.<P>
For a check box or radio box, the VALUE field specifies the value of the field when it is checked; unchecked check boxes are disregarded when <I>name=value</I> substrings are posted to the application.<P>
If several radio boxes have the same name, they act as a one-of-many selection: Only one of them can be switched &quot;on&quot; and have its value paired with the name. A hidden text field does not appear on the form, but it can have a default value which will be sent to the application. A password text field will echo asterisks (*) when a value is typed into it. A selection list is specified using the code in <a href="#0285_00b9">Example 1(a)</A>. The option chosen will become the value associated with the selection list's name. It is also possible to include the attribute MULTIPLE after the NAME string to allow multiple selections. This maps to multiple <I>name=value</I> substrings, each with the same name. A multiline text-entry field has the form of <a href="#0285_00b9">Example 1(b)</A>.<P>
The submit button causes the document to collect the data from the various form fields, pair it with the names of the fields, and post it to the application. The reset button resets the fields to their default values. <a href="#0285_00b9">Example 1(c)</A> illustrates button syntax. All of these form constructs are illustrated on Douglas McArthur's form at http://www.biodata.com/douglas/form.html.<P>
The form's HTML code is shown in <a href="#0285_00bc">Listing One</A>. <a href="#0285_00b8">Figure 1</A> shows how part of the form looks on an X-terminal running Mosaic for X Windows. Thirteen other form examples are accessible through http://www.ncsa.uiuc.edu/SDG/Software/Mosaic/Docs/fill-out-forms/overview.html (overview.html also contains more details on the syntax of form fields).<P>
Stylists recommend that a form be separated from the rest of a document by a horizontal rule (&lt;HR&gt;). Rules are also useful for subdividing logical subcomponents within a form. The submit button should always be placed at the end of the form.<P>
<h3><a name="0285_00b2">Document and Application Communication<a name="0285_00b2"></h3><P>
When the submit button is clicked, the POST method causes a string to be sent to the application. The string consists of a series of <I>name=value</I> substrings, separated by ampersands (&amp;). An added complication is that <I>name </I>and <I>value </I>are encoded so that spaces are changed into plus signs (+) and some characters are encoded as hexadecimals. Fortunately, form-application programmers have written routines for handling these coded strings.<P>
The POST method means that the form application will receive the string on its standard input. This protocol is defined by the Common Gateway Interface (CGI) specification, which also states that an application can respond by generating suitable code on its standard output. Details on the CGI specification can be found at http://hoohoo.ncsa.uiuc.edu/cgi/interface.html.<P>
The CGI specification permits an application to output many different types of documents (for example, an image, audio code, plain text, HTML, or references to other documents). The application determines the output type by writing a header string to standard output, of the form: <I>Content-type: type/subtype</I>, where <I>type</I> and <I>subtype</I> must be MIME (Multipurpose Internet Mail Extensions) types; two common types are <I>text/html </I>for HTML output and <I>text/plain </I>for ASCII text. There must be two blank lines after the header, and then the data can begin. For instance, an application (coded in C) could output <a href="#0285_00ba">Example 2</A>. More details on the CGI output protocol can be found at http://hoohoo.ncsa.uiuc.edu/cgi/primer.html, while documentation on MIME begins at http://info.cern.ch/hypertext/WWW/Protocols/rfc1341/0_Abstract.html.<P>
<h3><a name="0285_00b3">The Echoer Example Program<a name="0285_00b3"></h3><P>
I'll now turn to a complete example--an &quot;echoer&quot; application. This example's input document consists of a form with five single-line text-entry fields. The application processes it by outputting an HTML document containing the text entered in the fields. In other words, the user's input is echoed.<P>
<a href="19950287.htm">Figure 2</A> shows the input document. The form is quite simple: five text-entry fields, plus submit and reset buttons labeled Start, Search, and Clear, respectively. <a href="#0285_00bd">Listing Two</A> is the HTML code for the document (it is also available at http://www.cs.mu.oz.au/~ad/code/form-gp.html). <P>
The text-field constructs include extra attributes to limit the size of both the input and the boxes drawn on the screen. The fields are named <I>pat1</I> through <I>pat5</I>, although these are not displayed as part of the input document. When the terms &quot;John&quot; and &quot;uk&quot; are input and the Start Search button is clicked, the application returns <a href="19950288.htm">Figure 3</A>.<P>
In form-gp.html, the name of the application is given in the FORM ACTION attribute as http://www.cs.mu.oz.au/cgi-bin/qgp, where qgp's actual location on the server depends on the configuration file for the httpd daemon (called http.conf). The relevant line in that file is <I>Exec /cgi-bin /* /local/dept/wwwd/scripts/*</I>. In other words, qgp must be placed in /local/dept/wwwd/scripts for the form to invoke it. This step in linking the input HTML document to the application varies from system to system. <a href="#0285_00be">Listing Three</A>, qgp.c (which can also be found at http://www.cs.mu.oz.au/~ad/code/qgp.c), consists mostly of utility functions for processing <I>name=value</I> substrings; consequently, these appear in almost every form application. The functions were written by Rob McCool and can be accessed at http://hoohoo.ncsa.uiuc.edu/cgi/forms.html. Also available from that page are similar utilities for writing applications in the Bourne Shell, Perl, and Tcl, along with several excellent small programs showing how the utilities can be used.<P>
The qgp.c program uses five utility functions: <I>makeword()</I>, <I>fmakeword()</I>, <I>unescape_url()</I>, <I>x2c()</I>, and <I>plustospace()</I>.  <I>makeword()</I> builds a word by extracting characters from a larger string up to a stopping character (or the end of the longer string). <I>fmakeword()</I> performs a similar operation but reads from a file and is also supplied with the length of the string left unread in the file. <I>unescape_url()</I> converts hexadecimal characters in a string into ordinary characters, by calling <I>x2c()</I>. <I>plustospace()</I> converts the plus signs (+) in a string into spaces.<P>
<I>main()</I> begins by outputting the header line for the reply document, an HTML document in this case. The If tests perform standard error checking: The first determines whether the delivery METHOD is something other than POST; the second checks the encoding strategy for the <I>name=value</I> substrings. In fact, the only encoding supported by Mosaic for X Windows 2.0 is x-www-form-urlencoded, but this may not be the case for other browsers.<P>
The If tests and the use of CONTENT_LENGTH illustrate the importance of environment variables for conveying information from the input document to the application. A complete list of environment variables supported by the CGI specification can be found at http://hoohoo.ncsa.iuc.edu/cgi/env.html.<P>
CONTENT_LENGTH contains the length of the string sent to the application and is used by the For loop to build the <I>entries </I>array. Each <I>name=value</I> substring is extracted by a call to <I>fmakeword()</I>. The pluses (+) and hexadecimal URL encodings are replaced, and then the <I>name </I>part of the substring is removed, leaving only the <I>value</I>. More output to the HTML reply document follows, then the final For loop cycles through the <I>entries</I> array and prints the <I>name </I>and <I>value </I>strings.<P>
<h3><a name="0285_00b4">The File-Searcher Example Program<a name="0285_00b4"></h3><P>
The next example, a file-searcher application, uses the input document in <a href="19950289.htm">Figure 2</A>, but the application now searches through a text file holding a membership list. It looks for lines containing the strings entered in the text-entry fields of the form. A maximum of ten matching lines are printed, together with the total number of matching lines.<P>
Querying again for &quot;John&quot; and &quot;uk&quot; results in the HTML document in <a href="1995028a.htm">Figure 4</A> being generated by the application. It can also produce an error document if no strings are entered before a search is initiated.<P>
<a href="#0285_00bf">Listing Four</A> is the C code for qdir.c (it can also be found at http://www.cs.mu.oz.au/~ad/code/qdir.c). The compiled version, qdir, is in /local/dept/wwwd/scripts, and form-gp.html now uses http://www.cs.mu.oz.au/cgi-bin/qdir as the URL in the FORM ACTION attribute.<P>
<I>main()</I> begins with the same preliminaries as qgp.c and uses the same utility functions. The call to <I>record_details()</I> logs information about the user in a file and has no effect on the subsequent code. <I>get_pats()</I> searches through the <I>entries</I> array and copies the nonempty strings into a <I>patterns</I> array. If there are no strings in <I>entries</I>, then <I>get_pats()</I> outputs an HTML error document.<P>
<I>build_re()</I> translates the strings in the <I>patterns</I> array into part of a UNIX command. The idea is to translate a single search string (such as &quot;John&quot;) into the command <I>fgrep 'John' search-file &gt; temp-file</I>. Multiple search strings like &quot;John,&quot; &quot;uk,&quot; and &quot;LPA&quot; would be utilized in the command <I>fgrep 'John' search-file | fgrep </I>'<I>uk' | fgrep </I>'<I>LPA' &gt; temp-file</I>. The trick is to pipe the matching lines of one call to fgrep into another call which further filters the selection. <P>
The matching lines are printed by a While loop which reads at most ten lines from the temporary file. The total number of lines in the temporary file is counted by the UNIX wc command (<I>wc -l temp-file &gt; second-temp-file</I>). The value is read in from the second temporary file and printed to the reply document.<P>
This approach demonstrates how to utilize UNIX as part of an application. UNIX features are preferable in this case because of the size of the file being searched and the potentially large number of matching lines that need to be manipulated. UNIX can also be employed to create forms that edit files, send mail, read news, or monitor the network, for example.<P>
<h3><a name="0285_00b5">A Note on Testing<a name="0285_00b5"></h3><P>
You'll find it useful in the early stages of form design to test the form without having to write the accompanying application. For instance, early form testing involves checking what default values are posted if the user immediately presses the &quot;submit&quot; button.<P>
One possibility is to set the FORM ACTION to point to qgp (or a program like it), which returns <I>name/value</I> pairs. An alternative is to set ACTION to http://hoohoo.ncsa.uiuc.edu/htbin-post/post-query. This program does much the same thing as qgp. The drawbacks are longer network-access time and the inability to modify the application to test specific form features.<P>
Testing is also a problem with form applications, since it is not possible to run their user interface (for example, the input form and a browser) inside a source-level debugger. In normal circumstances, if the application fails, the browser returns a cryptic message. The easiest way to avoid this problem is to test a modified version of the application that reads <I>name </I>and <I>value </I>pairs from the keyboard. <a href="#0285_00bb">Example 3</A>, a fragment of code that illustrates this for qdir.c, reads strings straight into the <I>val</I> fields of the <I>entries</I> array. Since the <I>name </I>fields are not used in this application, they are not assigned values. Output can be sent to the screen and is quite readable even when mixed with HTML formatting instructions.<P>
<h3><a name="0285_00b6">Logging<a name="0285_00b6"></h3><P>
Remember that data may already be available in an access-log file that records all browser accesses to the server and is set up through the httpd configuration file. For many applications, however, such general-purpose logging may not capture all the information required. For instance, a common reason for recording accesses is to have the application offer different facilities to different users. Thus, in a video-ordering service, it might be useful to record the types of films that a user likes, so that similar films can be pointed out when that user next makes an order. For such specific information, it is better to have the application carry out the necessary logging.<P>
In the logging version of qdir.c, access details are collected from four environment variables: REMOTE_USER, REMOTE_IDENT, REMOTE_HOST, and REMOTE_ADDR. In addition, the local time on the server is recorded.<P>
The extra code is wrapped up inside the <I>record_details()</I> function called early in qdir.c. The code for <I>record_details()</I> is included in <a href="#0285_00bf">Listing Four</A>. One drawback with the first three environment variables is that they are not guaranteed to have values. REMOTE_USER is only bound if the client and server support user authentication, and REMOTE_IDENT relies on support for RFC 931 identification. REMOTE_HOST may not be bound, but the IP address equivalent will be assigned to REMOTE_ADDR.<P>
<h3><a name="0285_00b7">Conclusion<a name="0285_00b7"></h3><P>
Forms are an extremely useful mechanism, since they transform HTML from a hypertext page-description language into a tool for creating interactive documents. Forms and their associated programs are straightforward to write, due to the availability of examples, utilities, and documentation accessible through the WWW.<P>
<h4><a name="0285_00b8"><B>Figure 1:</B> <a href="1995028b.htm">(a)</A> Form showing text fields; <a href="1995028c.htm">(b)</A> form with check boxes and radio buttons; <a href="1995028d.htm">(c)</A> form with submit and reset buttons.<a name="0285_00b8"></h4><P>
<a href="1995028e.htm">Figure 2</A>  Typical input document.<P>
<a href="1995028f.htm">Figure 3</A>  HTML document generated by echoing example application.<P>
<a href="19950290.htm">Figure 4</A>  HTML document generated by the file-search application.<P>
<h4><a name="0285_00b9"><B>Example 1:</B> (a) Code that specifies a selection list; (b) multiline text-entry field; (c) button syntax.<a name="0285_00b9"></h4><P>
<pre>(a)
&lt;SELECT NAME=&quot;list title&quot;&gt;
     &lt;OPTION&gt;first option
     &lt;OPTION&gt;second option
                :
&lt;/SELECT&gt;

(b)
&lt;TEXTAREA NAME=&quot;text area name&quot; ROWS=no-of-rows COLS=no-of-columns &gt;
Default text goes here
&lt;/TEXTAREA&gt;

(c)
&lt;INPUT TYPE=&quot;submit&quot; VALUE=&quot;text on button&quot; &gt;
&lt;INPUT TYPE=&quot;reset&quot; VALUE=&quot;text on button&quot; &gt;</pre><P>
<h4><a name="0285_00ba"><B>Example 2:</B> C code that generates the first two lines of <a href="19950291.htm">Figure 2</A>.<a name="0285_00ba"></h4><P>
<pre>printf(&quot;content-type: text/html%c%c&quot;,10,10);     /* 10 is a linefeed */
printf(&quot;&lt;H1&gt;Search String Error!&lt;/H1&gt;&quot;);
printf(&quot;&lt;BR&gt;Must specify at least 1 pattern&lt;p&gt;&quot;);</pre><P>
<h4><a name="0285_00bb"><B>Example 3:</B> Code that reads strings straight into the val fields of the entries array.<a name="0285_00bb"></h4><P>
<pre>char line[LINELEN];
etnum = 0;
while (etnum &lt; PATNO) {
        printf(&quot;Enter pattern %d:&quot;,etnum+1);
        if (gets(line) == NULL)    /* input terminated? */
                break;
        entries[etnum].val = (char *) malloc(sizeof(char)*(strlen(line)+1));
        strcpy(entries[etnum].val, line);
        etnum++;
}</pre><P>
<P>
<h4><a name="0285_00bc">Listing One<a name="0285_00bc"></h4><pre>
&lt;HTML&gt;
&lt;HEAD&gt;
&lt;!-- ------------------------------------------------------------------- --&gt;
&lt;!-- http://www.biodata.com/douglas/form.html - Modified 9/20/94 -=DCM=- --&gt;
&lt;!-- ------------------------------------------------------------------- --&gt;
&lt;TITLE&gt;Prototypical HTML Forms&lt;/TITLE&gt;
&lt;H1&gt;Prototypical HTML Forms&lt;/H1&gt;
&lt;/HEAD&gt;
This document displays the various form gadgets currently supported.
&lt;P&gt;
&lt;FORM ACTION=&quot;http://hoohoo.ncsa.uiuc.edu/htbin-post/post-query&quot; METHOD=&quot;POST&quot;&gt;
&lt;HR&gt;
&lt;H1&gt;Text Fields&lt;/H1&gt;
Basic text entry field:
&lt;INPUT TYPE=&quot;text&quot; NAME=&quot;entry1&quot; VALUE=&quot;&quot;&gt; 
&lt;P&gt;
Text entry field with default value:
&lt;INPUT TYPE=&quot;text&quot; NAME=&quot;entry2&quot; VALUE=&quot;This is the default.&quot;&gt; 
&lt;P&gt;
Text entry field of 40 characters:
&lt;INPUT TYPE=&quot;text&quot; NAME=&quot;entry3&quot; SIZE=40 VALUE=&quot;&quot;&gt; 
&lt;P&gt;
Text entry field of 5 characters, maximum:
&lt;INPUT TYPE=&quot;text&quot; NAME=&quot;entry5&quot; SIZE=5 MAXLENGTH=5 VALUE=&quot;&quot;&gt; 
&lt;P&gt;
Password entry field (*'s are echoed):
&lt;INPUT TYPE=&quot;password&quot; NAME=&quot;password&quot; SIZE=8 MAXLENGTH=8 VALUE=&quot;&quot;&gt; 
&lt;HR&gt;
&lt;H1&gt;Textareas&lt;/H1&gt;
A 60x3 scrollable textarea:
&lt;P&gt;
&lt;TEXTAREA NAME=&quot;textarea&quot; COLS=60 ROWS=3&gt;NOTE:
Default text can be entered here.
&lt;/TEXTAREA&gt;
&lt;HR&gt;
&lt;H1&gt;Checkboxes&lt;/H1&gt;
Here is a checkbox
&lt;INPUT TYPE=&quot;checkbox&quot; NAME=&quot;Checkbox1&quot; VALUE=&quot;TRUE&quot;&gt;,
and a checked checkbox
&lt;INPUT TYPE=&quot;checkbox&quot; NAME=&quot;Checkbox2&quot; VALUE=&quot;TRUE&quot; CHECKED&gt;
. 
&lt;HR&gt;
&lt;H1&gt;Radio Buttons&lt;/H1&gt;
Radio buttons (one-of-many selection):
&lt;OL&gt;
&lt;LI&gt;
&lt;INPUT TYPE=&quot;radio&quot; NAME=&quot;radio1&quot; VALUE=&quot;value1&quot;&gt;
First choice. 
&lt;LI&gt;
&lt;INPUT TYPE=&quot;radio&quot; NAME=&quot;radio1&quot; VALUE=&quot;value2&quot; CHECKED&gt;

Second choice. (Default CHECKED.)
&lt;LI&gt;
&lt;INPUT TYPE=&quot;radio&quot; NAME=&quot;radio1&quot; VALUE=&quot;value3&quot;&gt;
Third choice. 
&lt;/OL&gt;
&lt;HR&gt;
&lt;H1&gt;Option Menus&lt;/H1&gt;
One-of-many (Third Option selected by default):
&lt;SELECT NAME=&quot;first-menu&quot;&gt;
&lt;OPTION&gt;First Option
&lt;OPTION&gt;Second Option
&lt;OPTION SELECTED&gt;Third Option
&lt;OPTION&gt;Fourth Option
&lt;OPTION&gt;Last Option
&lt;/SELECT&gt;
&lt;P&gt;
Many-of-many (First and Third selected by default):
&lt;SELECT NAME=&quot;second-menu&quot; MULTIPLE&gt;
&lt;OPTION SELECTED&gt;First Option
&lt;OPTION&gt;Second Option
&lt;OPTION SELECTED&gt;Third Option
&lt;OPTION&gt;Fourth Option
&lt;OPTION&gt;Last Option
&lt;/SELECT&gt;
&lt;P&gt;
&lt;B&gt;NOTE: Hold down CTRL and click to multiple-select.&lt;/B&gt;
&lt;!-- You can also assign VALUEs using TYPE=&quot;hidden&quot; --&gt;
&lt;INPUT TYPE=&quot;hidden&quot; NAME=&quot;hidden&quot; VALUE=&quot;invisible&quot;&gt;
&lt;HR&gt;
&lt;H1&gt;Special Buttons&lt;/H1&gt;
Submit button (mandatory):
&lt;INPUT TYPE=&quot;submit&quot; VALUE=&quot;Submit Form&quot;&gt;
&lt;P&gt;
Reset button (optional):
&lt;INPUT TYPE=&quot;reset&quot; VALUE=&quot;Clear Values&quot;&gt;
&lt;P&gt;
&lt;/FORM&gt;
&lt;HR&gt;
&lt;H1&gt;References&lt;/H1&gt;
Heres a link to
&lt;A HREF=&quot;http://www.ncsa.uiuc.edu/SDG/Software/Mosaic/Docs/
                                                 fill-out-forms/overview.html&quot;&gt;
a handy HTML forms reference
&lt;/A&gt;.
&lt;P&gt;
&lt;HR&gt;
&lt;ADDRESS&gt;
Prototypical HTML Form /
&lt;A HREF=&quot;http://www.biodata.com/douglas/people/douglas.html&quot;&gt;
douglas@BioData.COM 
&lt;/A&gt;
&lt;/ADDRESS&gt;
&lt;/HTML&gt;

</pre>
<h4><a name="0285_00bd">Listing Two<a name="0285_00bd"></h4><pre>
&lt;HTML&gt;
&lt;HEAD&gt;
&lt;TITLE&gt;ALP Membership Search&lt;/TITLE&gt;
&lt;/HEAD&gt;
&lt;BODY&gt;
&lt;H1&gt;&lt;img src=&quot;../alp/symbol.gif&quot;&gt;  ALP Membership Search&lt;/H1&gt;
&lt;BR&gt;
&lt;ul&gt;
&lt;li&gt;Enter at most 15 characters in a box (e.g. &lt;code&gt;Melbo&lt;/code&gt;). &lt;p&gt;
&lt;li&gt;At least one box should contain something. &lt;p&gt;
&lt;li&gt;Matches are lines in the membership list which contain all 
the box entries. &lt;p&gt;
&lt;li&gt;The first 10 matches will be returned, together with the total
number of matches. &lt;p&gt;
&lt;li&gt;Click the &lt;b&gt;Start Search&lt;/b&gt; button to start the search. &lt;p&gt;
&lt;li&gt;All the boxes can be cleared by clicking on the &lt;b&gt;Clear&lt;/b&gt; button. &lt;p&gt;
&lt;/ul&gt;
&lt;BR&gt;
&lt;H2&gt;&lt;img src=&quot;gball.gif&quot;&gt; Search Boxes&lt;/H2&gt;

&lt;FORM ACTION=&quot;http://www.cs.mu.oz.au/cgi-bin/qgp&quot; METHOD=&quot;POST&quot;&gt;
&lt;INPUT TYPE=&quot;text&quot; NAME=&quot;pat1&quot; SIZE=&quot;15&quot; MAXLENGTH=&quot;15&quot; VALUE=&quot;&quot;&gt; 
&lt;INPUT TYPE=&quot;text&quot; NAME=&quot;pat2&quot; SIZE=&quot;15&quot; MAXLENGTH=&quot;15&quot; VALUE=&quot;&quot;&gt;
&lt;INPUT TYPE=&quot;text&quot; NAME=&quot;pat3&quot; SIZE=&quot;15&quot; MAXLENGTH=&quot;15&quot; VALUE=&quot;&quot;&gt;
&lt;INPUT TYPE=&quot;text&quot; NAME=&quot;pat4&quot; SIZE=&quot;15&quot; MAXLENGTH=&quot;15&quot; VALUE=&quot;&quot;&gt;
&lt;INPUT TYPE=&quot;text&quot; NAME=&quot;pat5&quot; SIZE=&quot;15&quot; MAXLENGTH=&quot;15&quot; VALUE=&quot;&quot;&gt;
&lt;P&gt;
&lt;BR&gt;
&lt;INPUT TYPE=&quot;submit&quot; VALUE=&quot;Start Search&quot;&gt;
&lt;INPUT TYPE=&quot;reset&quot; VALUE=&quot;Clear&quot;&gt;
&lt;P&gt;
&lt;/FORM&gt;
&lt;HR&gt;

&lt;br&gt;
&lt;img src=&quot;gball.gif&quot;&gt;
USE OF THIS MEMBERSHIP LIST FOR COMMERCIAL OR PROMOTIONAL PURPOSES IS
PROHIBITED. &lt;p&gt;

&lt;img src=&quot;gball.gif&quot;&gt;
If you have any problems using this service, contact
&lt;a href=&quot;http://www.cs.mu.oz.au/~ad&quot;&gt;Andrew Davison&lt;/a&gt;. &lt;p&gt;

&lt;img src=&quot;gball.gif&quot;&gt;
If you would like changes made to the membership list,
contact the ALP Administrative Secretary. &lt;p&gt;
&lt;HR&gt;
&lt;ADDRESS&gt;
&lt;/BODY&gt;
&lt;a href=&quot;../alp/alp-news/dir.html&quot;&gt;To Membership List Info&lt;/a&gt;
&lt;/A&gt;
&lt;/ADDRESS&gt;
&lt;/HTML&gt;

</pre>
<h4><a name="0285_00be">Listing Three<a name="0285_00be"></h4><pre>

/* Echo name=value substrings posted from Form */
/* HTML utilities written by Rob McCool */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define LF 10
#define CR 13
#define MAX_ENTRIES 5       /* number of input fields */

typedef struct {
    char *name;
    char *val;
} entry;

char *makeword(char *line, char stop);
char *fmakeword(FILE *f, char stop, int *len);
void unescape_url(char *url);
char x2c(char *what);
void plustospace(char *str);

main() {
  entry entries[MAX_ENTRIES];          /* HTML name-val pairs */
  int x, cl, etnum;

  printf(&quot;Content-type: text/html%c%c&quot;,LF,LF);
  if(strcmp(getenv(&quot;REQUEST_METHOD&quot;),&quot;POST&quot;)) {
    printf(&quot;This script should be referenced with a METHOD of POST.\n&quot;);
    printf(&quot;If you don't understand this, read &quot;);
    printf(&quot;&lt;A HREF=\&quot;http://www.ncsa.uiuc.edu/SDG/Software/Mosaic/
                Docs/fill-out-forms/overview.html\&quot;&gt;forms overview&lt;/A&gt;.%c&quot;,LF);
    exit(1);
  }
  if(strcmp(getenv(&quot;CONTENT_TYPE&quot;),&quot;application/x-www-form-urlencoded&quot;)) {
    printf(&quot;This script can only be used to decode form results. \n&quot;);
    exit(1);
  }
  cl = atoi(getenv(&quot;CONTENT_LENGTH&quot;));

  etnum = 0;
  for(x=0;cl &amp;&amp; (!feof(stdin));x++) {
    entries[x].val = fmakeword(stdin,'&amp;',&amp;cl);
    plustospace(entries[x].val);
    unescape_url(entries[x].val);
    entries[x].name = makeword(entries[x].val,'=');

    etnum++;
  }
  printf(&quot;&lt;H1&gt;Query Results&lt;/H1&gt;&quot;);
  printf(&quot;You submitted the following name/value pairs:&lt;p&gt;%c&quot;,LF);
  printf(&quot;&lt;ul&gt;%c&quot;,LF);

  for(x=0; x &lt; etnum; x++)
    printf(&quot;&lt;li&gt; &lt;code&gt;%s = %s&lt;/code&gt;%c&quot;,entries[x].name,entries[x].val,LF);
  printf(&quot;&lt;/ul&gt;%c&quot;,LF);
}
/* HTML utilities */
char *makeword(char *line, char stop) {
  int x = 0,y;
  char *word = (char *) malloc(sizeof(char) * (strlen(line) + 1));
  for(x=0;((line[x]) &amp;&amp; (line[x] != stop));x++)
     word[x] = line[x];
  word[x] = '\0';
  if(line[x]) ++x;
  y=0;
  while(line[y++] = line[x++]);
  return word;
}
char *fmakeword(FILE *f, char stop, int *cl) {
  int wsize;
  char *word;
  int ll;

  wsize = 102400;
  ll=0;
  word = (char *) malloc(sizeof(char) * (wsize + 1));

  while(1) {
    word[ll] = (char)fgetc(f);
    if(ll==wsize) {
       word[ll+1] = '\0';
       wsize+=102400;
       word = (char *)realloc(word,sizeof(char)*(wsize+1));
    }
    --(*cl);
    if((word[ll] == stop) | (feof(f)) | (!(*cl))) {
       if(word[ll] != stop) ll++;
       word[ll] = '\0';
       return word;
    }
    ++ll;

  }
}
void unescape_url(char *url) {
  register int x,y;
  for(x=0,y=0;url[y];++x,++y) {
    if((url[x] = url[y]) == '%') {
        url[x] = x2c(&amp;url[y+1]);
        y+=2;
    }
  }
  url[x] = '\0';
}
char x2c(char *what) {
  register char digit;
  digit = (what[0] &gt;= 'A' ? ((what[0] &amp; 0xdf) - 'A')+10 : (what[0] - '0'));
  digit *= 16;
  digit += (what[1] &gt;= 'A' ? ((what[1] &amp; 0xdf) - 'A')+10 : (what[1] - '0'));
  return(digit);
}
void plustospace(char *str) {
  register int x;
  for(x=0;str[x];x++) 
    if(str[x] == '+') str[x] = ' ';
}
</pre>
<h4><a name="0285_00bf">Listing Four<a name="0285_00bf"></h4><pre>

/* Search file FNM via a HTML form. This version logs user in file RFNM */
/* Executable is in /local/dept/wwwd/scripts/qdir */
/* HTML utilities written by Rob McCool */
/* The rest by Andrew Davison (ad@cs.mu.oz.au), December 1994 */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;
#include &lt;string.h&gt;

#define LF 10
#define CR 13

#define MAX_ENTRIES 5   /* number of input fields */
#define PATNO 5         /* max number of patterns  */
#define RESNO 10        /* max number of matching lines */
#define CMDLEN  200     /* max length of cmd */
#define LINELEN 240     /* max length of input line */
#define NAMELEN 40      /* max length of a file name */

#define FNM &quot;/home/staff/ad/www_public/code/dir.alp&quot;      /* file searched */
#define RFNM  &quot;/home/staff/ad/www_public/code/people.txt&quot;   /* log file */

typedef struct {
    char *name;
    char *val;
} entry;

void get_pats(entry entries[], int etnum, char pat[][LINELEN], int *pno);
char *build_re(char pat[][LINELEN], int tot, char re[]);
void back_to_form(void);
void record_details(void);

char *makeword(char *line, char stop);
char *fmakeword(FILE *f, char stop, int *len);
void unescape_url(char *url);
char x2c(char *what);
void plustospace(char *str);

main() 
{
  char gcmd[CMDLEN];               /* fgrep command string */
  char restexpr[CMDLEN];           /* part of fgrep string */
  char wcmd[CMDLEN];               /* line count cmd string */
  char result[LINELEN];            /* matching line */
  char patterns[PATNO][LINELEN];   /* patterns */

  char tmp_gfname[NAMELEN], tmp_wfname[NAMELEN];
  FILE *gtfp, *wtfp;    /* temp file ptrs */
  int rno, pno, nmatch, nlines;

  entry entries[MAX_ENTRIES];    /* HTML name-val pairs */
  int x, w, cl, etnum;

  printf(&quot;Content-type: text/html%c%c&quot;,LF,LF);
  if(strcmp(getenv(&quot;REQUEST_METHOD&quot;),&quot;POST&quot;)) {
    printf(&quot;This script should be referenced with a METHOD of POST.\n&quot;);
    printf(&quot;If you don't understand this, read &quot;);
    printf(&quot;&lt;A HREF=\&quot;http://www.ncsa.uiuc.edu/SDG/Software/Mosaic/
                Docs/fill-out-forms/overview.html\&quot;&gt;forms overview&lt;/A&gt;.%c&quot;,LF);
    exit(1);
  }
  if(strcmp(getenv(&quot;CONTENT_TYPE&quot;),&quot;application/x-www-form-urlencoded&quot;)) {
    printf(&quot;This script can only be used to decode form results. \n&quot;);
    exit(1);
  }
  cl = atoi(getenv(&quot;CONTENT_LENGTH&quot;));
  etnum = 0;
  for(x=0;cl &amp;&amp; (!feof(stdin));x++) {
    entries[x].val = fmakeword(stdin,'&amp;',&amp;cl);
    plustospace(entries[x].val);
    unescape_url(entries[x].val);
    entries[x].name = makeword(entries[x].val,'=');
    etnum++;  
  }
  record_details();        /* log the user */
/* collect non-empty strings into patterns[] */
  get_pats(entries, etnum, patterns, &amp;pno);

  printf(&quot;&lt;H1&gt;Search Results&lt;/H1&gt;&quot;);
  printf(&quot;&lt;BR&gt;Maximum of 10 matching lines are shown for any search.&lt;p&gt;&quot;);
  printf(&quot;&lt;BR&gt;The following strings are being used for the search:&lt;p&gt;%c&quot;,LF);
  printf(&quot;&lt;ul&gt;%c&quot;,LF);
  for(x=0; x &lt; pno; x++) 
    printf(&quot;&lt;li&gt; %s%c&quot;,patterns[x],LF);
  printf(&quot;&lt;/ul&gt;%c&quot;,LF);

/* get at most RESNO matching lines */
  tmpnam(tmp_gfname);
  build_re(patterns,pno,restexpr);
  sprintf(gcmd,&quot;fgrep '%s' %s %s &gt; %s&quot;,patterns[0], FNM, restexpr, tmp_gfname);
  system(gcmd);

  printf(&quot;&lt;BR&gt;&lt;b&gt;The lines found are:&lt;/b&gt;&lt;P&gt;&quot;);
  printf(&quot;&lt;ul&gt;%c&quot;,LF);
  gtfp = fopen(tmp_gfname,&quot;r&quot;);
  rno = 0;
  while (rno &lt; RESNO) {
    if (fgets(result, LINELEN, gtfp) == NULL)
      break;
    printf(&quot;&lt;li&gt; &quot;); puts(result); printf(&quot;&lt;P&gt;&quot;);
    rno++;
  }
  printf(&quot;&lt;/ul&gt;%c&quot;,LF);
  fclose(gtfp);
/* count the total number of matching lines */
  tmpnam(tmp_wfname);
  sprintf(wcmd, &quot;wc -l %s &gt; %s&quot;, tmp_gfname, tmp_wfname);
  system(wcmd);
  wtfp = fopen(tmp_wfname,&quot;r&quot;);
  fscanf(wtfp,&quot;%d&quot;, &amp;nlines);
  fclose(wtfp);
  if (nlines &gt; RESNO)
    printf(&quot;&lt;BR&gt;&lt;b&gt;%d lines printed from a total of %d.&lt;/b&gt;&lt;P&gt;&quot;,RESNO,nlines);
  else if (rno == 0)
    printf(&quot;&lt;BR&gt;&lt;b&gt;No matching lines.&lt;/b&gt;&lt;P&gt;&quot;);
  else

    printf(&quot;&lt;BR&gt;&lt;b&gt;%d line(s) printed.&lt;/b&gt;&lt;P&gt;&quot;, rno);
  back_to_form();
  remove(tmp_gfname);
  remove(tmp_wfname);
}
void get_pats(entry entries[], int etnum, char pat[][LINELEN], int *pno)
{
  int x;
  *pno = 0;
  for (x=0; x &lt; etnum; x++) {
    if (entries[x].val[0] != '\0') {
      strcpy(pat[*pno], entries[x].val);
      (*pno)++;
    }
  }
  if (*pno == 0) {
    printf(&quot;&lt;H1&gt;Search String Error!&lt;/H1&gt;&quot;);
    printf(&quot;&lt;BR&gt;Must specify at least 1 pattern&lt;p&gt;&quot;);
    back_to_form();
    exit(1);
  }
}
char *build_re(char pat[][LINELEN], int total, char re[])
{
  char part [NAMELEN];
  int idx;
    re[0]='\0';
    for (idx=1; idx&lt;total; idx++){
       sprintf(part,&quot;| fgrep '%s'&quot;,pat[idx]);
        strcout(re,part);
   }
}
void back_to_form(void)
{
  printf(&quot;&lt;HR&gt;&lt;BR&gt;&lt;i&gt;&lt;a href=\&quot;http://www.cs.mu.oz.au/~ad/code/form-gp.html\&quot;&gt;
                                                      Back to Form&lt;/a&gt;&lt;/i&gt;.&quot;);
}
void record_details(void)
{
  char *ruser, *rid, *rhost, *raddr;
  struct tm *tp;
  time_t now;
  FILE *rfp;

  rfp = fopen(RFNM,&quot;a&quot;);

  ruser = getenv(&quot;REMOTE_USER&quot;);

  if (strcmp(ruser,&quot;&quot;) == 0)
    fprintf(rfp,&quot;no_ruser  &quot;);
  else
    fprintf(rfp, &quot;%s  &quot;,ruser);
  rid = getenv(&quot;REMOTE_IDENT&quot;);
  if (strcmp(rid,&quot;&quot;) == 0)
    fprintf(rfp,&quot;no_rid  &quot;);
  else
    fprintf(rfp, &quot;%s  &quot;,rid);
 rhost = getenv(&quot;REMOTE_HOST&quot;);
 if (strcmp(rhost,&quot;&quot;) == 0)
    fprintf(rfp,&quot;no_rhost  &quot;);
 else
    fprintf(rfp, &quot;%s  &quot;,rhost);
  raddr = getenv(&quot;REMOTE_ADDR&quot;);
  if (strcmp(raddr,&quot;&quot;) == 0) 
    fprintf(rfp,&quot;no_raddr  &quot;);
  else
    fprintf(rfp, &quot;%s  &quot;,raddr);
  now = time(NULL);
  tp = localtime(&amp;now);
  if (tp == NULL)
    fprintf(rfp,&quot;no_ltime\n&quot;);
  else
    fprintf(rfp, &quot;%s&quot;,ctime(&amp;now));
  fclose(rfp);
}
/* HTML utilities */
char *makeword(char *line, char stop) {
  int x = 0,y;
  char *word = (char *) malloc(sizeof(char) * (strlen(line) + 1));
  for(x=0;((line[x]) &amp;&amp; (line[x] != stop));x++)
    word[x] = line[x];
  word[x] = '\0';
  if(line[x]) ++x;
  y=0;

  while(line[y++] = line[x++]);
  return word;
}
char *fmakeword(FILE *f, char stop, int *cl) {
  int wsize;
  char *word;
  int ll;


  wsize = 102400;
  ll=0;
  word = (char *) malloc(sizeof(char) * (wsize + 1));

  while(1) {
    word[ll] = (char)fgetc(f);
    if(ll==wsize) {
        word[ll+1] = '\0';
        wsize+=102400;
        word = (char *)realloc(word,sizeof(char)*(wsize+1));
    }
    --(*cl);
    if((word[ll] == stop) | (feof(f)) | (!(*cl))) {
        if(word[ll] != stop) ll++;
        word[ll] = '\0';
        return word;
    }
    ++ll;
  }
}
void unescape_url(char *url) {
  register int x,y;
  for(x=0,y=0;url[y];++x,++y) {
    if((url[x] = url[y]) == '%') {
        url[x] = x2c(&amp;url[y+1]);
        y+=2;
    }
  }
  url[x] = '\0';
}
char x2c(char *what) {
  register char digit;
  digit = (what[0] &gt;= 'A' ? ((what[0] &amp; 0xdf) - 'A')+10 : (what[0] - '0'));
  digit *= 16;
  digit += (what[1] &gt;= 'A' ? ((what[1] &amp; 0xdf) - 'A')+10 : (what[1] - '0'));
  return(digit);
}
void plustospace(char *str) {
  register int x;
  for(x=0;str[x];x++) 
    if(str[x] == '+') str[x] = ' ';
}
</pre>
<HR><P>Copyright &copy; 1995, <I>Dr. Dobb's Journal</I></P></BODY></HTML>
