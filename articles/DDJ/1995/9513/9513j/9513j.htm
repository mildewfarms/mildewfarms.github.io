<HTML>
<META NAME="year" CONTENT="1995">

<HEAD>
<TITLE>SP95: PATTERNS AND SOFTWARE DESIGN</TITLE></HEAD>
<BODY BGCOLOR="#ffffff">
<h1>PATTERNS AND SOFTWARE DESIGN<a name="02f2_00d3"></h1><P>
<h2><a name="02f2_00d1"><a name="02f2_0000">Designing Objects for Extension</h2><P>
<h3>Richard Helm and Erich Gamma </h3><P>
<p><i><a name="02f2_00d2"><a name="02f2_0000">Richard and Erich are coauthors  of Design Patterns: Elements of Reusable Object-Oriented Software (Addison-Wesley, 1994). They can be reached at Richard .Helm@dmr.ca and Erich_Gamma@Taligent.com, respectively.</i></p><hr><P>
The key to creating reusable software lies in knowing people's needs and anticipating how those people might reuse your software to meet those needs. To accomplish this, you must consider how your system might change over its lifetime and be aware of typical causes of redesign. Among the many causes for changes are the evolving requirements of current users and the needs of new users. Other causes might be intrinsic to the business environment in which your software is used, or stem from changes in technology or platforms. <P>
If places where such modifications occur are not isolated or decoupled from the rest of the system, the resulting changes will cause modifications throughout the software and risk the introduction of reuse errors. The design issue then is to find and separate the potentially changing parts of an application from its more stable parts. This idea is not new, and analogies can be found in other domains--building and architecture, for instance.<P>
In his wonderful and thoughtful book <I>How Buildings Learn</I> (Viking, 1994), Stewart Brand considers buildings as consisting of six layers: site (its physical space on ground), structure (exterior and load-bearing walls), skin (exterior brickwork, cladding), services (electrical, plumbing), space plan (interior walls, windows, ceilings), and stuff (furniture). Brand notes that these layers evolve at different rates during the life of a building. Sites of buildings often exist for hundreds of years, whereas the furniture tends to move frequently. Brand also notes that these layers shear against each other as they change at different rates. The slow-moving site and structure systems dominate the fast-moving space-plan and stuff systems. He observes that &quot;an adaptive building has to allow slippage between the differently paced systems. If not, the slow systems block the fast ones, and the fast ones tear up the slow.&quot; If you lay your electrical and plumbing services within the concrete slab of your house, you'll have trouble adding new wiring or fixing blocked drains. <P>
The same ideas apply to software. There is typically a relatively stable, core application architecture (event driven, client/ server, blackboard, or whatever), around which exist less stable layers, from slow-moving subsystem structures, to fast-moving details of the user interface. Just as in buildings, the key to developing an extensible software system is for these layers to be able to slip and shear against each other. When they cannot, you often have a reuse error. There are multiple causes of reuse errors:<P>
Algorithmic dependencies. Algorithms are often extended, optimized, and replaced during development and reuse. Objects that depend on an algorithm (both its behavior and data structures) will have to change when the algorithm changes. Therefore, algorithms likely to change should be isolated from the rest of the application.<P>
Tight coupling. Classes that are tightly coupled are hard to reuse in isolation, since they depend on each other. Tight coupling leads to monolithic systems, where you can't change or remove a class without understanding and changing many other classes. The system becomes a dense, brittle mass that's hard to learn, port, and maintain. Techniques such as abstract coupling and layering help create loosely coupled systems. Abstract coupling means that an object talks to another object by using an interface defined by an abstract class. This enables the object to communicate with objects of different concrete subclasses.<P>
Creating an object by specifying a class explicitly. Specifying a class name when you create an object commits you to a particular implementation instead of a particular interface. This commitment can complicate future changes if the implementations change. One way to avoid such commitment is to make requests to instantiate classes through a third-party factory object.<P>
Dependence on specific operations. When you specify a particular operation in a request, you commit to a particular way of satisfying that request. By avoiding hard-coded requests for operations, you make it easier to change the way a request gets satisfied.<P>
Design patterns can help you avoid many reuse errors by ensuring that a system can change in specific ways. Each design pattern lets you vary some aspect of system structure independently of other aspects, thereby making a system more robust to a particular kind of change. There are patterns which concern the extensibility of objects, the flexible creation of objects, the distribution of responsibilities, and patterns in managing relationships between objects. We will look at some of these patterns in later columns. This month we will look at patterns for designing extensible objects. <P>
<h3><a name="02f2_00d4">Creating Extensible Objects<a name="02f2_00d4"></h3><P>
Since an object is defined by its class, extensions to the object are usually defined through class inheritance--by creating subclasses of the original class. Inheritance is a compile-time mechanism for extending a class and reusing implementations. While simple and supported in most object-oriented languages, class inheritance does have some problems: <P>
<UL>
<li>It exposes subclasses to their parent class's implementation, which introduces dependencies and breaks encapsulation of the parent with respect to the child. Parent classes appear as <I>White Boxes</I>.</li>
<li>It implies a commitment to a particular implementation rather than an interface (unless the class is derived from an abstract class with no representation).</li>
<li>Extensions defined through inheritance are defined at compile time and can't be redefined or changed at run time.</li>
<li>Inheritance doesn't extend a particular object; rather it specifies a new implementation of the object based on the implementation of an old. To actually use the extension, you must be able to instantiate the extended class where you instantiated the old.</li>
</UL>
As we discussed in our previous column, object composition offers an alternative to inheritance. Instead of composing classes to create new functionality, object composition creates new functionality by combining objects in new ways. <P>
However, object composition is a little more difficult to use than inheritance. It requires careful attention to interfaces defined by objects. It also increases the difficulty in understanding a system: Relationships between objects are more implicit, most of the code only uses objects through interfaces, and the implementation classes of the objects behind these interfaces are unknown. Despite these difficulties, object composition can offer a more flexible alternative to inheritance as a reuse mechanism. <P>
So how do you use object composition to create extensible objects? First, you need to consider what it is you are extending: an object's behavior for particular states, the algorithms it uses, properties and individual operations, or its interface. There are four patterns that address these extensions, three of which--Decorator, Strategy, and State--are discussed in our book <I>Design Patterns: Elements of Reusable Object-Oriented Software</I>. The fourth is a new pattern called &quot;Extension Objects,&quot; which we introduce in this column. To simplify the discussion and permit comparison, we will name the class to be extended <I>ExtendedObject</I>.<P>
<h3><a name="02f2_00d5">Extending Algorithms<a name="02f2_00d5"></h3><P>
Objects employ algorithms to implement their operations. The Strategy pattern, which we discussed in our previous column, allows an object to be extended with new kinds of algorithms. The basic idea behind the Strategy pattern is that each algorithm is encapsulated and accessed through a common interface to create a family of strategies. At run time, the <I>ExtendedObject</I> instance is configured with a particular Strategy class.<P>
<h3><a name="02f2_00d6">Extending State-Specific Behavior<a name="02f2_00d6"></h3><P>
All objects have internal state. Sometimes the behavior of an object depends on this state. At issue is how to represent this state-specific behavior, isolate each state's behavior, and permit new states and behaviors to be added. The State pattern does this as follows: It encapsulates all state-specific behavior as a state object and creates state objects for each distinct state. The <I>ExtendedObject</I> forwards state-specific behavior to the state object. To change the <I>ExtendedObject</I>'s behavior, configure it with a different state object.<P>
<h3><a name="02f2_00d7">Extending Properties and Operations<a name="02f2_00d7"></h3><P>
How can you extend properties and operations? How can you add state and alter the behavior of operations? The Decorator pattern does this by &quot;wrapping&quot; up the <I>ExtendedObject</I> in a decorator object. The decorator presents the same interface to clients as the decorated object (clients will therefore not notice the presence of the decorator object). Most requests made of the decorator are forwarded directly to the decorated object. However, for some requests the decorator adds, removes, or modifies the behavior of the decorated object. <P>
<h3><a name="02f2_00d8">Extending Interface<a name="02f2_00d8"></h3><P>
All objects present interfaces to clients to allow manipulation. However, it is difficult to anticipate how clients will want to use an object, and so it is hard to create a general-purpose interface for all possible clients. Attempts to do so will result in large, clumsy, bloated interfaces which tend to detract from the abstraction the object represents. <P>
The Extension Objects pattern describes a solution to this problem of extending interfaces. There are many different ways to write patterns. This one is based on the format we introduced in our book<I>.</I><P>
<h3><a name="02f2_00d9">Extension Objects     <a name="02f2_00d9"></h3><P>
<B>Category</B>: <I>Object Structural</I><P>
Intent. Enable clients to extend the interface of an object. Additional interfaces are defined by extension objects.<P>
Motivation. Consider a compound- document architecture as currently promoted by OLE 2, OpenDoc, and soon Taligent's CommonPoint. A compound document is made of components that are managed and arranged by container components. The infrastructure for a compound document requires a common interface to various components such as text, graphics, or spreadsheets. Let's assume that this interface is defined by an abstract class <I>Component</I>. How can we define additional interfaces for components that allow clients to use component-specific functionality?<P>
You cannot define all possible operations on components as part of the general <I>Component</I> abstraction. First, it is not possible to foresee all operations that component writers would like to perform. Second, even if we could, the result would be a bloated interface reflecting all possible uses of components. For example, a spell checker requires a specific interface to enumerate the words of a text component. The spell checker should operate on any component that provides this interface, independent of its concrete type.<P>
One solution is to provide a mechanism allowing clients to define additional interface extensions and to let clients query whether an object provides a certain extension. There is a spectrum of techniques for how this mechanism can be implemented.<P>
The key idea is to define extensions to the interface as separate objects. The extension object implements this extension interface, knows about the object it extends, and implements the extension interface in terms of the extended object's interface. Extensions themselves aren't useful--there needs to be an interface that defines which extension is provided by <I>Component</I>. For our purpose, the extensions will be identified by a name. To avoid conflicts, this name should be registered at a central place. A client can query whether a component provides a certain extension by calling the <I>GetExtension(extensionName)</I> operation. If the component provides an extension with the given name, it returns a corresponding extension object. All extensions are derived from an abstract <I>Extension</I> class which provides only a minimal interface used to manage the extension itself. For example, it can provide an operation that a <I>Component</I> can call to notify its <I>Extension</I>s when it is about to be deleted.<P>
In the case of the spell checker, we define an extension named &quot;TextAccessor.&quot; The corresponding interface is defined by the abstract class <I>TextAccessor</I>. Its key operations are <I>GetNextWord(),</I> which returns the next word in the text, and <I>ReplaceCurrentWord(),</I> to replace a misspelled word. Let's assume that there are two different implementations of text components: <I>SimpleTextComponent</I> and <I>FancyTextComponent</I>. Both components want to provide spell-checking support. To do so, both derive their own <I>TextAccessor</I> subclass that implements the interface for their text implementation. The <I>SimpleTextComponent</I> and <I>FancyTextComponent</I> classes implement <I>GetExtension(</I>&quot;<I>TextAccessor</I>&quot;<I>)</I> to return their specific extension object.<P>
<a href="199502f4.htm">Figure 1</A> summarizes the class relationships using <I>OMTnotation</I> (abstract operations and abstract classes are shown in italics). The implementation of <I>SimpleText Accessor::GetExtension(_)</I> is shown in <a href="#02f2_00da">Example 1</A>. The extension object stores a reference back to the extended object. It typically implements the extension by forwarding requests to the extended object. <P>
Based on this extension infrastructure, a spell checker for a compound document is implemented as follows: Traverse the components in the document. Ask each component for its <I>TextAccessor</I> extension. If the component returns a corresponding <I>TextAccessor</I> extension object, use it (after down casting it to <I>TextAccessor</I>) to spell check the component. Otherwise, skip the component and move on to the next.<P>
Applicability. You use the Extension Objects pattern when: <P>
<UL>
<li>You need to support the addition of new interfaces. </li>
<li>An interface to an abstraction should not be tied to a specific, existing inheritance hierarchy.</li>
<li>An abstract class has a large, bloated interface reflecting its use by multiple clients.</li>
</UL>
Structure. The structure for the Extension Objects pattern is shown in <a href="199502f5.htm">Figure 2</A>.<P>
Participants. The participants for the Extension Objects patterns are: <P>
<UL>
<li><I>ExtendedObject(Component)</I>, which defines an interface to query whether an object has a particular named extension. </li>
<li><I>ConcreteExtendedObject(FancyTextComponent,SimpleTextComponent)</I>, which returns appropriate extension objects when queried for a specific extension.</li>
<li><I>Extension(Extension)</I>, the common base class for all extensions.</li>
<li><I>SpecificExtension(TextAccessor)</I>, which defines the interface of a specific extension.</li>
<li><I>ConcreteExtension(FancyTextAccessor, SimpleTextAccessor)</I>, which implements the extension interface by calling operations on the <I>ConcreteExtended</I> object. To do so, it maintains a reference back to the <I>ConcreteExtended</I> object.</li>
</UL>
Collaborations. The client negotiates with an <I>ExtendedObject</I> for a named extension. If it exists, it is returned. The client subsequently uses the extension to access additional behavior of the <I>ExtendedObject</I>.<P>
Consequences. The Extension Object pattern has several consequences:<P>
<UL>
<li>The base class <I>ExtendedObject</I> does not require a large interface for all its clients. This avoids monolithic interfaces for the <I>ExtendedObject</I>.</li>
<li>Peer objects can use extension objects to negotiate a more specific interface (it could be more efficient or support better abstractions) between them.</li>
<li>An interface is not attached to a particu-lar class definition. Classes providing an interface don't have to be related through inheritance. In the spell-checker example, text components don't have to inherit from a general <I>TextComponent</I> base class, but they can still participate in spell checking.</li>
<li>An extended interface is more complicated to use than one which is provided by the extended object itself. It requires more work to obtain the interface.</li>
</UL>
Implementation. The implementation must define how the extension objects are managed by <I>ExtendedObject</I>. A simple solution is to store an extension object in an instance variable that is returned to clients when the extension is requested. An alternative is to dynamically allocate the extension on demand when it is requested. A further variation is to provide support for clients to attach <I>Extension</I>s to existing objects. In this case, the <I>ExtendedObject</I> has to maintain a dictionary that maps an attached extension to its name. <P>
In C++, the extension returned from <I>GetExtension</I> has to be cast to its corresponding extension class. If the C++ implementation provides run-time type identification, this can be achieved with <I>dynamic_cast</I>. <P>
To permit the extension to have full access to the <I>Extended</I> object, it can be declared as its friend. <P>
Strings are a primitive way to identify extensions. Better solutions are to use special interface identifiers or some internalized form of strings.<P>
An alternative implementation is to use multiple inheritance and run-time type identification. An extension interface can be defined as a <I>mixin</I> class. An object that supports a given extension inherits from this <I>mixin</I> class and implements the extension. See <a href="199502f6.htm">Figure 3</A>.<P>
The operations of the <I>mixin</I> class are all abstract and have to be implemented by derived classes. To query an object for an extension, the client uses run-time type information. For example, in C++, the spell checker would query a component whether or not it is (inherits from) a <I>TextAccessor</I>; see <a href="#02f2_00db">Example 2</A>.<P>
The use of a dynamic cast is often suspicious and can point out a design flaw. However, in this case it is okay since a dynamic cast is only used to ask an object whether it supports a certain interface.<P>
This pattern is less important in dynamic languages like Smalltalk. These languages typically provide enough run-time information to allow asking an object whether  it responds to a specific request.<P>
Known uses. Support for extension interfaces is common in Compound Document architectures. The example from the Motivation discussion is based on OpenDoc. In OpenDoc, the common base class <I>ODObject</I> provides the access to the extension interface. <P>
Extension objects are related to Microsoft's Component Object Model (COM) and its <I>QueryInterface</I> mechanism. <I>QueryInterface</I> enables a client to query an object for an interface. In COM there is no extended object to start with, and all interfaces of an object are accessed by <I>QueryInterface</I>.<P>
Related patterns. One related pattern is Adapter which adapts an existing interface. Extension Objects provide additional interfaces.<P>
<a href="199502f7.htm"><B>Figure 1</B></A>  Class relationships using OMTnotation.<P>

<a name="02f2_00da"><a name="02f2_00da"><B>Example 1:</B> SimpleTextAccessor::GetExtension(...) implementation.<P>
<pre>Extension*SimpleTextComponent::GetExtension(char* extensionName)
{
    ...  if ( strcmp(extensionName, &quot;TextAccessor&quot;) == 0)
    return new SimpleTextAccessor(this);
    else if ( strcmp(extensionName, &quot;AnotherExtension&quot;) == 0)
    ...
    else
    return 0;
}</pre><P>
<a href="199502f8.htm"><B>Figure 2</B></A>  Structure for the Extension Objects pattern.<P>
<a href="199502f9.htm"><B>Figure 3</B></A>  Using multiple inheritance and run-time type identification.<P>

<a name="02f2_00db"><a name="02f2_00db"><B>Example 2:</B> Querying a component.<P>
<pre>Component*component;
TextAccessor* accessor =dynamic_cast&lt;TextAccessor*&gt;(component);
if (accessor != 0)
    // use the text accessor interface</pre><P>
<P>
<HR><P>Copyright &copy; 1995, <I>Dr. Dobb's Journal</I></P></BODY></HTML>
