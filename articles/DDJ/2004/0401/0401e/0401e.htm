<html><head><title>Jan04: Double Dispatch Revisited</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Double Dispatch Revisited</h1><p><i>Dr. Dobb's Journal</i> January 2004</p><h2>Making functions virtual on more than one argument</h2><h3>By Nat Goodspeed</h3><I>Nat is a product architect at CogniToy LLC. He can be contacted at nat@cognitoy.com.</I><hr><p>Item 31 of Scott Meyers's book <i>More Effective C++</i> (Addison-Wesley, 1996) discusses the problem of making a C++ function virtual on more than one of its arguments. To paraphrase Meyers's example: Say you're writing a simple game program set in space, using a collection of polymorphic <i>GameObjects</i>: <i>SpaceShip</i>, <i>SpaceStation</i>, and <i>Asteroid</i>, that move around and sometimes collide. Clearly, it matters a great deal which two objects are colliding. An <i>Asteroid</i> colliding with a <i>SpaceShip</i> might do major damage, whereas a low-speed collision between a <i>SpaceShip</i> and a <i>SpaceStation</i> could be regarded as a successful attempt to dock. So when you discover that two <i>GameObjects</i> are colliding, how should you invoke the appropriate code to process the collision?</p><p>Meyers presents&#151;and dismisses&#151;a couple of obvious, but unfortunate, approaches: using the C++ virtual-function machinery on each argument and writing a series of <i>if</i> statements that test runtime type information (RTTI) from <i>typeid()</i>. From a maintenance perspective, each of these is far too similar to the dreaded "Big Switch Statement."</p><DDJADVERTISEMENT INLINE><p>Instead, he suggests the clever technique of initially using <i>typeid(type).name()</i> on each argument type to obtain a distinct string, and building a <i>map&lt;pair&lt;string, string&gt;, function_ptr&gt;</i> to register each processing function. Then, given a pair of actual arguments, Meyers uses <i>typeid(reference).name()</i> on each argument to get the strings with which to perform a map lookup.</p><p>He points out that there is a drawback to this technique&#151;it doesn't deal with inheritance. In his example, there's a registered processing function, <i>shipAsteroid()</i>, that expects actual parameters (<i>SpaceShip</i>, <i>Asteroid</i>). If you derive <i>CommercialShip</i> and <i>MilitaryShip</i> from <i>SpaceShip</i>, you might expect that when a <i>MilitaryShip</i> collides with an <i>Asteroid</i>, you'd call <i>shipAsteroid()</i> as before. Alas, it doesn't work that way. "Even though a <i>MilitaryShip</i> can be treated like a <i>SpaceShip</i>," notes Meyers, "<i>lookup()</i> has no way of knowing that. Furthermore, there is no easy way of telling it."</p><p>In <i>Modern C++ Design: Generic Programming and Design Patterns Applied</i> (Addison-Wesley, 2001), Andrei Alexandrescu also discusses multiple dispatch. "I am convinced," he writes, "there is a solution to the inheritance problem. But, alas, writers of books have deadlines, too."</p><p>I am indebted to both writers for most of what follows. I have found that with a somewhat different container, you can get reasonably good results. </p><p>Consider a small class (<A NAME="rl1"><A HREF="#l1">Listing One</A>) to represent an arbitrary pair of <i>GameObject</i> subclass types. You can define a subclass to represent the types (<i>SpaceShip</i>, <i>Asteroid</i>) as in <A NAME="rl2"><A HREF="#l2">Listing Two</A>, where you take advantage of <i>dynamic_cast</i> to do the type matching. It's important to work with pointers because <i>dynamic_cast</i> produces a zero pointer if the actual object in question cannot be downcast to the specified pointer type.</p><p>When you generalize that subclass (as in <A NAME="rl3"><A HREF="#l3">Listing Three</A>), you just construct a container of such objects and search that. The important point is that, even for a subclass object <i>myMilitaryShip, dynamic_cast&lt;const SpaceShip*&gt;</i> produces a nonzero pointer. The catch is that this test is ambiguous. You still have the general-purpose processing function <i>shipAsteroid(SpaceShip</i>&amp;<i>, Asteroid</i>&amp;<i>)&#151;</i>but suppose that <i>MilitaryShip</i>s get special treatment (maybe they're more heavily armored) and need a special routine such as <i>militaryShipAsteroid(MilitaryShip</i>&amp;<i>, Asteroid</i>&amp;<i>)</i>. Every <i>MilitaryShip</i> object actually matches both routines, so this registry can't rely on unique lookup.</p><p>The problem resembles catching an exception of a particular type. Suppose you have an <i>Error</i> base class with a subclass <i>ErrorRuntime</i>, which in turn has a subclass <i>ErrorBounds</i>. You could write incorrect code like that in <A NAME="rl4"><A HREF="#l4">Listing Four</A> where, if <i>dubiousRoutine()</i> throws an <i>ErrorBounds</i> exception, it will not be caught by the <i>ErrorBounds</i> clause. Every <i>ErrorBounds</i> object is an <i>ErrorRuntime</i> as well, so that exception will be caught by the <i>ErrorRuntime</i> clause instead. To distinguish between <i>ErrorBounds</i> and all other <i>ErrorRuntime</i> exceptions, the classes in question must be written like <A NAME="rl5"><A HREF="#l5">Listing Five</A>.</p><p>In the same spirit, you can construct a sequence container (a list) of <i>EntryBase</i> objects and perform a linear search. Invoke the first <i>Entry</i> for which <i>matches()</i> returns <i>true&#151;</i>thus, the burden is on you to populate the list in a reasonable order.</p><p>Naturally, you can't just construct a <i>list&lt;EntryBase&gt;</i>: That would slice every <i>Entry</i> subclass object, which is hardly what you want. To be properly polymorphic, your list must store pointers to <i>EntryBase</i>. But that raises uncomfortable questions about the life span of the <i>EntryBase</i> objects: When the list is destroyed, what happens to all of those objects?</p><p>This is what smart pointers are all about. <i>std::auto_ptr</i> can't be used in STL containers. But the Boost Library (http://www .boost.org/) provides a couple of varieties of smart pointers, and <i>boost::shared_ptr</i> seems ideal for the job. For convenience, I'll typedef <i>boost::shared_ptr&lt;EntryBase&gt;</i> as <i>EntryPtr</i>.</p><p>The container, then, is a <i>list&lt;EntryPtr&gt;</i>; see <A NAME="rl6"><A HREF="#l6">Listing Six</A>. How will you actually search it? Well, you'll be called with two specific <i>GameObject</i> (subclass) references, as in <A NAME="rl7"><A HREF="#l7">Listing Seven</A>.<i></p><p>boost::bind()</i> is so cool that it deserves more discussion than I can give it here. For our purposes, the <i>boost::bind() </i>syntax in <A NAME="rl7"><A HREF="#l7">Listing Seven</A> essentially says: For each item in <i>mDispatch</i>, call <i>matches(param1, param2)</i>, and stop when it returns <i>true</i>. <i>boost::bind() </i>automatically handles the fact that the items in <i>mDispatch</i> are smart pointers, as well as the fact that <i>matches() </i>is actually a member function of the referenced class. </p><p>Once we've found the right <i>EntryPtr</i>, calling it isn't hard. You must bind some sort of function or function object (called a "functor"); see <A NAME="rl8"><A HREF="#l8">Listing Eight</A>. Any class with an <i>operator()</i> method accepting two <i>GameObject</i>&amp; parameters works.</p><p>Since each <i>Entry</i> subclass already knows its <i>Functor</i>'s parameter types, you can also equip it with a virtual method to perform the appropriate downcasting, as in <A NAME="rl9"><A HREF="#l9">Listing Nine</A>. Therefore, you can provide a function like <A NAME="rl10"><A HREF="#l10">Listing Ten</A>. This lets you code each <i>Functor</i> using the specific <i>GameObject</i> subclasses that it expects to process. For example, you can write <i>shipAsteroid(SpaceShip</i>&amp;<i>, Asteroid</i>&amp;<i>)</i> rather than <i>shipAsteroid(GameObject</i>&amp;<i>, GameObject</i>&amp;<i>)</i> with internal downcasts.</p><p>All that remains is to populate the <i>DispatchTable</i>. You want to provide a function to append new <i>Entry</i> objects to the existing container. Naturally, since this function must instantiate a template class, it must be a template function.</p><p>The template function must accept two "types" as well as a <i>Functor</i>. While it should be possible to provide those types as explicit template parameters (for example, <i>add&lt;SpaceShip, Asteroid&gt;(shipAsteroid)</i>), the Microsoft Visual C++ 6 compiler (to name one example) doesn't support that construct.</p><p>But you can borrow again from Alexandrescu and wrap these types as lightweight objects:</p><blockquote><p>template&lt;typename T&gt;</p><p>struct Type {};</p></blockquote><p>This lets you pass these types to the template function as extra parameters; see <A NAME="rl11"><A HREF="#l11">Listing Eleven</A>. Then, as both Meyers and Alexandrescu suggest, you can add support for symmetry. Your collision-detection algorithm might turn up a given pair of colliding <i>GameObjects</i> in either order, <i>(SpaceShip, Asteroid)</i> or <i>(Asteroid, SpaceShip)</i>. You don't want your collision-processing code to have to be sensitive to that.</p><p><A NAME="rl12"><A HREF="#l12">Listing Twelve</A> shows an <i>add()</i> function that supports inserting symmetrical <i>Entry</i> objects. This usage of <i>boost::bind()</i> simply reverses the <i>Functor</i>'s actual arguments. Having symmetrical entries in the registry lets you write <A NAME="rl13"><A HREF="#l13">Listing Thirteen</A> without worrying about whether the collision pair was actually detected as <i>(Asteroid, SpaceShip)</i>. Both cases are handled by the same code.</p><p>I generalized the resulting <i>DoubleDispatch</i> class (available electronically; see "Resource Center," page 7) as a template so that you need not constrain the client to use a specific parameter base class&#151;or a specific return type for the registered functions. </p><p>To illustrate how you can use this class, I've included a test program (also available electronically). </p><p>The excerpt in <A NAME="rl14"><A HREF="#l14">Listing Fourteen</A> shows the calls that instantiate and populate the dispatcher, along with some hardcoded test collisions. That program produces the output in <A NAME="rl15"><A HREF="#l15">Listing Fifteen</A>. </p><p>A number of refinements are possible:</p><ul>  <li>It would be useful to be able to <i>erase()</i> a specific <i>Entry</i> from the <i>DoubleDispatch</i> table. This is relatively straightforward: The <i>Entry</i> template class can capture its parameter types' <i>typeid()</i> values and implement an <i>operator==()</i> method that compares them directly. I wanted to avoid cluttering this discussion with that mechanism, though; the lookup and dispatch code does not depend on <i>typeid()</i> comparisons.  <li>Not every C++ compiler accepts <i>void</i> as the <i>ReturnType</i> template parameter because of the constructs shown in <A NAME="rl16"><A HREF="#l16">Listing Sixteen</A>. There's template magic you can use to address that, but for present purposes, it only obscures the code.  <li>A more serious limitation is the need to register processing functions in a specific order. That implies that all registration calls are made by a central piece of code, which means that adding new <i>GameObject</i> subclasses requires maintaining that code.</ul><p>I've also built a Java variation on <i>DoubleDispatch</i> (available electronically) where you need not break out <i>EntryBase</i> and <i>Entry</i>: Each <i>Entry</i> simply references the <i>Class</i> objects representing its two parameter types. And given the <i>Class.isAssignableFrom(Class)</i> method, I built an <i>Entry.shouldPrecede(Entry)</i> method that permits <i>DoubleDispatch.add()</i> to search the existing list for a good place to insert the new <i>Entry</i>. So in Java, you can call <i>DoubleDispatch.add()</i> to register new processing routines from many places in your program.</p><p>I would like to do the same in C++, but it's hard to compare two <i>Entry</i> template objects constructed at different times. I want to be able to examine the class types embedded in each <i>Entry</i> object to discover inheritance relationships&#151;but I know of no way to do that without actually attempting to instantiate an object of one of the parameter types, which seems like a bad idea.</p><p>It's worth noting that Alexandrescu describes template magic that you can use to discover the inheritance relationship between two classes. To do that, however, both class types must be available at the same point in the code. And if you're willing to stipulate that the relevant types must all be available at the same place, then you don't need to extend <i>DoubleDispatch</i> because you can simply write the <i>add()</i> calls in an appropriate order.</p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>class EntryBase{public:    virtual bool matches(const GameObject&amp; param1,                         const GameObject&amp; param2) const = 0;};</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>class Entry: public EntryBase{public:    virtual bool matches(const GameObject&amp; param1,                         const GameObject&amp; param2) const    {        return (dynamic_cast&lt;const SpaceShip*&gt;(&amp;param1) != 0 &amp;&amp;                dynamic_cast&lt;const  Asteroid*&gt;(&amp;param2) != 0);    }};</pre><P><A HREF="#rl2">Back to Article</A></P><H4><A NAME="l3">Listing Three</H4><pre>template&lt;typename Type1, typename Type2&gt;class Entry: public EntryBase{public:    virtual bool matches(const GameObject&amp; param1,                         const GameObject&amp; param2) const    {        return (dynamic_cast&lt;const Type1*&gt;(&amp;param1) != 0 &amp;&amp;                dynamic_cast&lt;const Type2*&gt;(&amp;param2) != 0);    }};</pre><P><A HREF="#rl3">Back to Article</A></P><H4><A NAME="l4">Listing Four</H4><pre>try{    dubiousRoutine();}catch (const ErrorRuntime&amp; e){    ...}catch (const ErrorBounds&amp; e)        // whoops, never reached!{    ...}catch (const Error&amp; e){    ...}</pre><P><A HREF="#rl4">Back to Article</A></P><H4><A NAME="l5">Listing Five </H4><pre>try{    dubiousRoutine();}catch (const ErrorBounds&amp; e)        // better{    ...}catch (const ErrorRuntime&amp; e){    ...}catch (const Error&amp; e){    ...}</pre><P><A HREF="#rl5">Back to Article</A></P><H4><A NAME="l6">Listing Six</H4><pre>typedef boost::shared_ptr&lt;EntryBase&gt; as EntryPtr;typedef std::list&lt;EntryPtr&gt; DispatchTable;DispatchTable mDispatch;</pre><P><A HREF="#rl6">Back to Article</A></P><H4><A NAME="l7">Listing Seven</H4><pre>// Look up the first matching entry.EntryPtr lookup(const GameObject&amp; param1, const GameObject&amp; param2) const{    DispatchTable::const_iterator found =        std::find_if(mDispatch.begin(), mDispatch.end(),                     boost::bind(&amp;EntryBase::matches, _1,                                 boost::ref(param1), boost::ref(param2)));    if (found != mDispatch.end())        return *found;    return 0;}</pre><P><A HREF="#rl7">Back to Article</A></P><H4><A NAME="l8">Listing Eight</H4><pre>template&lt;typename Type1, typename Type2, class Functor&gt;class Entry: public EntryBase{    // Bind whatever function or function object the instantiator passed.    Functor mFunc;public:    Entry(Functor func): mFunc(func) {}    virtual bool matches(const GameObject&amp; param1,                         const GameObject&amp; param2) const { ... }};</pre><P><A HREF="#rl8">Back to Article</A></P><H4><A NAME="l9">Listing Nine</H4><pre>class EntryBase{public:    ...    virtual void operator()(GameObject&amp; param1,                            GameObject&amp; param2) const = 0;};template&lt;typename Type1, typename Type2, class Functor&gt;class Entry: public EntryBase{    Functor mFunc;public:    Entry(Functor func): mFunc(func) {}    ...    virtual void operator()(GameObject&amp; param1,                            GameObject&amp; param2) const    {        mFunc(dynamic_cast&lt;Type1&amp;&gt;(param1),              dynamic_cast&lt;Type2&amp;&gt;(param2));    }};</pre><P><A HREF="#rl9">Back to Article</A></P><H4><A NAME="l10">Listing Ten</H4><pre>void call(GameObject&amp; param1, GameObject&amp; param2) const{    EntryPtr found = lookup(param1, param2);    if (found.get() == 0)        return;     (*found)(param1, param2); // call the Functor we found}</pre><P><A HREF="#rl10">Back to Article</A></P><H4><A NAME="l11">Listing Eleven</H4><pre>template&lt;typename Type1, typename Type2, class Functor&gt;void insert(const Type&lt;Type1&gt;&amp;, const Type&lt;Type2&gt;&amp;, Functor func){    mDispatch.insert(mDispatch.end(),                     EntryPtr(new Entry&lt;Type1, Type2, Functor&gt;(func)));}</pre><P><A HREF="#rl11">Back to Article</A></P><H4><A NAME="l12">Listing Twelve</H4><pre>template&lt;typename Type1, typename Type2, class Functor&gt;void add(const Type&lt;Type1&gt;&amp; t1, const Type&lt;Type2&gt;&amp; t2, Functor func,         bool symmetrical = false){    insert(t1, t2, func);    if (symmetrical)        insert(t2, t1, boost::bind(func, _2, _1));}</pre><P><A HREF="#rl12">Back to Article</A></P><H4><A NAME="l13">Listing Thirteen</H4><pre>void shipAsteroid(SpaceShip&amp; ship, Asteroid&amp; rock){  cout &lt;&lt; rock.stringize() &lt;&lt; " has pulverized " &lt;&lt; ship.stringize() &lt;&lt; endl;}</pre><P><A HREF="#rl13">Back to Article</A></P><H4><A NAME="l14">Listing Fourteen</H4><pre>typedef DoubleDispatch&lt;int, GameObject&gt; DD;DD dispatcher;dispatcher.add(DD::Type&lt;SpaceShip&gt;(), DD::Type&lt;Asteroid&gt;(),               shipAsteroid, true);dispatcher.add(DD::Type&lt;SpaceShip&gt;(), DD::Type&lt;SpaceStation&gt;(),               shipStation, true);dispatcher.add(DD::Type&lt;Asteroid&gt;(), DD::Type&lt;SpaceStation&gt;(),               asteroidStation, true);    // Instantiate a few GameObjects.  Make sure we refer to them    // polymorphically, and don't let them leak.    std::auto_ptr&lt;GameObject&gt; home(new SpaceStation("Terra Station"));    std::auto_ptr&lt;GameObject&gt; obstacle(new Asteroid("Ganymede"));    std::auto_ptr&lt;GameObject&gt; tug(new CommercialShip("Pilotfish"));    std::auto_ptr&lt;GameObject&gt; patrol(new MilitaryShip("Enterprise"));    // Try colliding them.    dispatcher(*home, *tug);        // reverse params, SpaceShip subclass    dispatcher(*patrol, *home);     // forward params, SpaceShip subclass    dispatcher(*obstacle, *home);   // forward params    dispatcher(*home, *obstacle);   // reverse params    dispatcher(*tug, *obstacle);    // forward params, SpaceShip subclass    dispatcher(*obstacle, *patrol); // reverse params, SpaceShip subclass</pre><P><A HREF="#rl14">Back to Article</A></P><H4><A NAME="l15">Listing Fifteen</H4><pre>class CommercialShip Pilotfish has docked at class SpaceStation Terra Stationclass MilitaryShip Enterprise has docked at class SpaceStation Terra Stationclass Asteroid Ganymede has damaged class SpaceStation Terra Stationclass Asteroid Ganymede has damaged class SpaceStation Terra Stationclass Asteroid Ganymede has pulverized class CommercialShip Pilotfishclass Asteroid Ganymede has pulverized class MilitaryShip Enterprise</pre><P><A HREF="#rl15">Back to Article</A></P><H4><A NAME="l16">Listing Sixteen</H4><pre>ReturnType operator()(ParamBaseType&amp; param1, ParamBaseType&amp; param2) const{  EntryPtr found = lookup(param1, param2);   if (found.get() == 0)     return ReturnType();          // return void() ?!?  return (*found)(param1, param2); //return (value returned by void function)}</pre><P><A HREF="#rl16">Back to Article</A></P></body></html>