<html><head><title>Jan04: Radical Refactoring</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Radical Refactoring</h1><p><i>Dr. Dobb's Journal</i> January 2004</p><h2>Let refactoring tools do the walking for you</h2><h3>By Eugene Belyaev, Maxim Shafirov, and Ann Oreshnikova</h3><I>Eugene is president and CTO of JetBrains, Maxim is a senior developer for the IntelliJ IDEA Java IDE development project, and Ann is head of the Documentation and Support Department. They can be contacted at http://www.jetbrains.com/.</I><hr><a name="rs1"><a href="0401bs1.htm">Doing It the Hard Way</a><hr><p>According to Martin Fowler, "Refactoring is the process of changing a software system in such a way that it does not alter the external behavior of the code yet improves its internal structure. It is a disciplined way to clean up code that minimizes the chances of introducing bugs." (<i>Refactoring: Improving the Design of Existing Code, </i>Addison-Wesley, 2000). Clearly, refactoring is something all developers do, even when you hand-code and don't realize you're actually doing it. Despite its association with Extreme Programming (XP) and other radical coding methods, refactoring is a basic process. </p><p>When you edit code to make it more rational, portable, modular, or readable, much of that process almost always consists of applying refactorings&#151;systematic changes that satisfy Fowler's definition. Refactoring can be as straightforward as renaming a method or variable, then updating all related references across the entire project so it doesn't break the build. Even in simple examples, few of us would refactor completely by hand&#151;we're more likely to use automated search-and-replace tools, whether in GUI dialogs or via grep and sed.</p><DDJADVERTISEMENT INLINE><p>Unfortunately, basic search-and-replace tools cannot ensure consistent modifications, since they lack the context-sensitive logic needed to determine the function of a particular bit of code. This means that you must verify all changes by hand. Even with simple refactorings, such tedium can discourage refactoring. Many developers have bemoaned the state of a large project as poorly structured, badly implemented, unscalable, and kludged&#151;but still too complex to fix within the current budget or timeframe.</p><p>Refactoring becomes more powerful if you combine individual refactorings into a series. Together, they can help you accomplish complicated tasks that, at first glance, may seem impossible to automate and nearly as difficult to do by hand. In this article, we show how refactoring&#151;treated as a process integral to development itself&#151;is as frequently needed and crucial to projects as the initial coding itself.</p><h3>When Refactoring Is Needed</h3><p>Refactoring can dramatically increase development efficiency during four main stages of software development:</p><p>1.	Architectural/design decisions and design changes.</p><p>2.	Reusing existing code.</p><p>3.	Global changes that entail repetitive tasks, such as switching to newer APIs or eliminating deprecated APIs.</p><p>4.	Everyday coding.</p><p>To illustrate, we use IntelliJ IDEA 3.0, a tool our company (Jetbrains Inc.) produces. Other tools may use different commands and results may vary. However, what's important is the sequence of refactorings.</p><h3>Refactoring Scenarios</h3><p>Imagine a generic client-server application with its server portion originally designed on a single-threaded model. At some point, the number of client users grows rapidly and long delays occur before requests get handled. Switching to a multithreaded server model would solve the problem&#151;but the original code made no provision for the required synchronized locks.</p><p>In <A NAME="rl1"><A HREF="#l1">Listing One</A>, a Singleton server object <i>UserManagement</i> provides access to an <i>AccessRightsTable</i>, which allows read access to user rights. <A NAME="rl1"><A HREF="#l1">Listing One</A> is the initial state of the <i>UserManagement</i> class, while <A NAME="rl2"><A HREF="#l2">Listing Two</A> is the initial state of the <i>AccessRightsTable</i> class. The <i>Client</i> class, among others, has two methods that refer to <i>UserManagement'</i>s and <i>AccessRightsTable</i>'s methods; see <A NAME="rl3"><A HREF="#l3">Listing Three</A>, the initial state of the <i>Client</i> class. </p><p>To switch to a multithreaded model, you need both synchronized (safe but slow) and nonsynchronized (fast but unsafe) versions of the class <i>AccessRightsTable</i>. At the same time, you need to ensure <i>copyTable</i>&#151;returned by the <i>createImmutableCopy()</i> method&#151;remains immutable.</p><p>You can accomplish this complex task through a series of refactorings and smart edits&#151;just apply the following refactorings in order, which will change the application design without affecting the consistency of the existing code.<b></p><p>Step 1.</b> Open the AccessRights<i> </i>Table.java file and choose Refactor|Extract Interface (<A NAME="rf1"><A HREF="0401bf1.htm">Figure 1</A>). Specify <i>AbstractAccessRightsTable</i> as the name for the new interface and select all methods from the list to be declared in it. The program creates a new interface with the methods declared, then automatically changes usages of <i>AccessRightsTable</i> to <i>AbstractAccessRightsTable</i> everywhere relevant in your project.<b></p><p>Step 2.</b> Using Alt+Insert (or the New popup menu item) in Project view, create the new classes <i>MutableAccessRightsTable</i> and <i>ImmutableAccessRightsTable</i> to implement <i>AbstractAccessRightsTable</i>. In both classes, declare the <i>myDelegate</i> field of type <i>AbstractAccessRightsTable</i> and call the Code|Delegate Methods main menu item. Choose the <i>myDelegate</i> field and select all methods from the list to be delegated to this field.<b></p><p>Step 3.</b> In <i>MutableAccessRightsTable</i>, go to each generated method body in sequence, highlight it, and press Ctrl+Alt+T to call the Surround With lookup list. Then select <i>synchronized{}</i> to automatically enclose the method body in this block (<A NAME="rf2"><A HREF="0401bf2.htm">Figure 2</A>).<b></p><p>Step 4.</b> In <i>ImmutableAccessRightsTable</i>, go to the methods that allow write access to the object and type <i>throw new UnsupportedOperationException("&lt;Your exception text here&gt;")</i> instead of the method body.<b></p><p>Step 5. </b>Search for use of the <i>AccessRightsTable</i> constructor, using Alt+F7, and decide where its mutable or immutable version should be used. In this case, you need the mutable one in the <i>UserManagement</i> Singleton class's constructor, and the immutable wrapper in the return statement of the <i>createImmutableCopy()</i> method of the <i>Client</i> class.</p><p>Refactoring tools make this process easy&#151;these steps took us only seven minutes. The refactorings produce <A NAME="rl4"><A HREF="#l4">Listings Four</A>, <A NAME="rl5"><A HREF="#l5">Five</A> and <A NAME="rl6"><A HREF="#l6">Six</A> and guarantee synchronized access to <i>AccessRightsTable</i> as well as the immutability of the copy created for read-only use. (By contrast, see the accompanying text box entitled "Doing It the Hard Way" for an equivalent solution done by hand.)</p><h3>Reuse of Existing Code</h3><p>Most of us have needed to reuse code, whether our own or someone else's. We now present a real-world example that illustrates how refactoring makes code reuse much easier. </p><p>Imagine in your application a dialog window with two interacting components. It might be a tree-like list of options and a preview pane that is automatically modified at runtime to reflect the options selected or deselected. The dialog was written long ago by someone else. Now you need to create a similar dialog to work with alternative data. Your first approach might be to create a copy of the existing class containing the requisite dialog code, then simply make multiple corrections so that the new code reflects your new requirements. This may work, but the approach makes no provision for you (or your colleagues) to integrate another, similar dialog or multiple dialogs in the future.</p><p>Refactoring provides a better solution by generalizing the design for all such dialogs, while requiring only minimal corrections on your part to perform manually.</p><p>1.	Open the existing class for the dialog.</p><p>2.	Find the code block that creates the pane with the tree-like list of options and perform the Extract Method refactoring on it.</p><p>3.	Do the same for the code block responsible for the preview pane.</p><p>4.	Call the Extract Superclass refactoring, select all members to be moved to the superclass, and mark the two newly created methods to be declared abstract.</p><p>5.	Create a new class for your new dialog, extending the newly created superclass.</p><p></p><p>Now you have an identical dialog and only need to define the two methods that accept your data. Better yet, in future uses, the superclass becomes a base for creating additional dialogs of the same type.</p><p>We often use such refactorings to produce GUI modules. This keeps the UI consistent and guards against possible bugs that can creep into the code when using a copy/paste approach.</p><h3>Boring and Repetitive Tasks</h3><p>A few years ago, like many other developers, we frequently utilized the class <i>java.util.Vector</i> in our Java applications. In large applications, such as our IntelliJ IDEA Java IDE, this class could be used in thousands of places. The main problem was the synchronized behavior of this class, but there was no way to avoid using it until the nonsynchronized <i>ArrayList</i> class appeared in the new Java SDK API, as a substitute for <i>java.util.Vector</i>. This new class improved application performance, so we decided to switch to this newer API. Doing so manually would take hundreds of man hours, but there was no obvious way to automate the task. After analyzing several approaches, however, we found we could use our own tool's refactoring support to make sequenced, automated changes and save an incalculable amount of time and money.</p><p>Here is how we used refactoring to switch to a newer API (or eliminate a deprecated API). <A NAME="rl7"><A HREF="#l7">Listing Seven</A> uses <i>java.util.Vector</i> and its methods. To switch to the <i>ArrayList</i>, we only needed to:</p><p>1.	Create a new class <i>Vector</i> in one of the project's packages and make it extend <i>ArrayList</i>.</p><p>2.	Define a method lacking in <i>ArrayList</i> but available in <i>java.util.Vector</i>; see <A NAME="rl8"><A HREF="#l8">Listing Eight</A>. (For similar tasks, you need to redefine all differing methods.)</p><p>3.	Migrate the project globally from <i>java.util.Vector</i> to your newly created <i>Vector</i>, calling the migration utility with the Tools|Migrate... command (<A NAME="rf3"><A HREF="0401bf3.htm">Figure 3</A>).</p><p>4.	In the new <i>Vector</i> class, call the Refactor Inline... command for each method (in the example,<i> elementAt()</i>). <A NAME="rl9"><A HREF="#l9">Listing Nine</A> shows the resulting changes in the <i>SampleClass</i>.</p><p>5.	Finally, migrate the project globally from <i>Vector</i> to <i>java.util.ArrayList</i>.</p><p>Bingo! We switched from <i>java.util.Vector</i> to <i>java.util.ArrayList</i> with no remaining inconsistency. We could then easily delete your custom <i>Vector</i> class as unnecessary (<A NAME="rl10"><A HREF="#l10">Listing Ten</A>).</p><h3>Refactoring as a Third Hand</h3><p>The previous scenario illustrated how refactoring serves as an extra mechanism that lets you alter and improve application design. If you have access to advanced refactoring tools, you quickly find that individual refactorings are applicable to a wider spectrum of common development procedures. No one on our team could imagine their everyday coding tasks without the use of sophisticated refactoring tools. In the next scenario, we show you the potential of some particular refactoring procedures in everyday production to help develop streamlined and efficient code.</p><p>The <i>Sample</i> class (the fragment between delimiters; <A NAME="rl11"><A HREF="#l11">Listing Eleven</A>) includes a block of code that selects users with read-access rights. Say you want to create a new method that selects users with particular rights. In IntelliJ IDEA, you select the fragment between delimiters and press Ctrl+Alt+M, or call the Refactor|Extract Method command. You then specify a new method name (<i>getUsersWithRight</i>, for example), press OK, and it becomes <A NAME="rl12"><A HREF="#l12">Listing Twelve</A>.</p><p>For a truly generic new method, avoid using the constant variable (READ_ACCESS), and instead pass the value as a parameter. To do so, select the field (within the <i>if</i> condition; <A NAME="rl12"><A HREF="#l12">Listing Twelve</A>) and press Ctrl+Alt+P, or call the Refactor|Introduce Parameter command. We specify the new parameter name as <i>pRight</i> and the field is now passed as a parameter (the fragment between delimiters; <A NAME="rl13"><A HREF="#l13">Listing Thirteen</A>). </p><p>The two variables of different scopes having the same name (<i>rightfulUsers</i>) reduce the code's readability and, in larger projects, we would probably rename one of these variables (Refactor|Rename...). In this scenario, you do better to just inline the variable used in <i>arrangeUsersByRight()</i> (by calling the Refactor|Inline... command), so it becomes:</p><blockquote><p>myUsersWithRights = </p><p>               getUsersWithRight{READ_ACCESS);</p></blockquote><h3>Conclusion</h3><p>Automated refactoring tools are incredibly powerful and deserve a place in every developer's arsenal. For complex code modification on large source trees, automated refactoring is especially useful. However, by staying aware of both the process of refactoring and the tools that make that process easier, refactoring's usefulness can extend to all stages of project development. Used properly, refactoring makes even the most routine development processes much more efficient. </p><p></p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>public class UserManagement {   private static UserManagement ourSingleInstance;   private AccessRightsTable myRightsTable;   private UserManagement() {      myRightsTable = new AccessRightsTable();   }   public static UserManagement getInstance() {      if (ourSingleInstance == null) {         ourSingleInstance = new UserManagement();      }      return ourSingleInstance;   }   public AccessRightsTable getRightsTable() {      return myRightsTable;   }}</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>public class AccessRightsTable {    private Map myUserToRightsSet;    public AccessRigtsTable() {        myUserToRightsSet = newHashMap();    }    public void grantRight(User user, Right right){        Set rightsSet = (Set) myUserToRightsSet.get(user);        if(rightsSet == null) {            rightsSet = new HashSet ();            myUserToRightsSet.put(user, rightsSet);        }        rightsSet.add(right);    }    public void revokeRight(User user, Right right) {...}    public Boolean checkRight(User user, Right right) {...}    public User[] getAllUsers() {...}     public Right[] getUserRights(User user) {...}}</pre><P><A HREF="#rl2">Back to Article</A></P><H4><A NAME="l3">Listing Three</H4><pre>public class Client {   /** This method revokes CREATE_NEW_ACCOUNT right from all users     * currently registered in rights table.     */   public static void revokeCreateNewAccount() {      AccessRightsTable rightsTable =                           UserManagement.getInstance().getRightsTable();      User[] allUsers = rightsTable.getAllUsers();      for (int i = 0; i &lt; allUsers.length; i++) {         User user = allUsers[i];         rightsTable.revokeRight(user, Right.CREATE_NEW_ACCOUNT);      }   }   /** This method creates new AccessRightsTable copy. This table is not     * intended to be modified. @return new copy table. NOT TO BE MODIFIED!    */   public static AccessRightsTable createImmutableCopy() {      AccessRightsTable rightsTable =                            UserManagement.getInstance().getRightsTable();      AccessRightsTable copyTable = new AccessRightsTable();      User[] allUsers = rightsTable.getAllUsers();      for (int i = 0; i &lt; allUsers.length; i++) {         User user = allUsers[i];         Right[] rights = rightsTable.getUserRights(user);         for (int j = 0; j &lt; rights.length; j++) {            Right right = rights[j];            copyTable.grantRight(user, right);         }   }      return copyTable;      }}</pre><P><A HREF="#rl3">Back to Article</A></P><H4><A NAME="l4">Listing Four</H4><pre>public class UserManagement {   private static UserManagement ourSingleInstance;   private AbstractAccessRightsTable myRightsTable;   private UserManagement() {      myRightsTable = new MutableAccessRightsTable(new AccessRightsTable());   }   public static UserManagement getInstance() {      if(ourSingleInstance == null) {         ourSingleInstance = new UserManagement();      }      return ourSingleInstance;   }   public AbstractAccessRightsTable getRightsTable() {      return myRightsTable;   }}</pre><P><A HREF="#rl4">Back to Article</A></P><H4><A NAME="l5">Listing Five</H4><pre>public class MutableAccessRightsTable implements AbstractAccessRightsTable {   private AbstractAccessRightsTable myDelegate;   public MutableAccessRightsTable(AbstractAccessRightsTable pDelegate) {      myDelegate = pDelegate;   }   public void grantRight(User user, Right right) {      synchronized (this) {         myDelegate.grantRight(user, right);      }   }   public void revokeRight(User user, Right right) {      synchronized (this) {          myDelegate.revokeRight(user, right);      }   }}</pre><P><A HREF="#rl5">Back to Article</A></P><H4><A NAME="l6">Listing Six</H4><pre>public class Client {   public static void revokeCreateNewAccount() {...}   public static AbstractAccessRightsTable createImmutableCopy() {      AbstractAccessRightsTable rightsTable =                              UserManagement.getInstance().getRightsTable();      AbstractAccessRightsTable copyTable = new AccessRightsTable();      User[] allUsers = rightsTable.getAllUsers();      for (int i = 0; i &lt; allUsers.length; i++) {         User user = allUsers[i];         Right[] rights = rightsTable.getUserRights(user);         for (int j = 0; j &lt; rights.length; j++) {            Right right = rights[j];            copyTable.grantRight(user, right);         }     }     return new ImmutableAccessRightsTable(copyTable);  }}</pre><P><A HREF="#rl6">Back to Article</A></P><H4><A NAME="l7">Listing Seven</H4><pre>public class SampleClass {   public Vector createSampleVector() {      Vector vector = new Vector();      vector.add("ItemOne");      vector.add("ItemTwo");      vector.add("ItemThree");      return vector;   }   public void useSampleVector(Vector vector) {      for (int i = 0; i &lt; vector.size(); i++) {         String s = (String) vector.elementAt(i);         System.out.println("s = " + s);      }   }  }</pre><P><A HREF="#rl7">Back to Article</A></P><H4><A NAME="l8">Listing Eight</H4><pre>public class Vector extends ArrayList {   public Object elementAt (int index) {      return get(index);   }}</pre><P><A HREF="#rl8">Back to Article</A></P><H4><A NAME="l9">Listing Nine</H4><pre>public class SampleClass {   public Vector createSampleVector() {      Vector vector = new Vector();      vector.add("ItemOne");      vector.add("ItemTwo");      vector.add("ItemThree");      return vector;   }   public void useSampleVector(Vector vector) {      for (int i = 0; i &lt; vector.size(); i++) {         String s = (String) vector.get(i);         System.out.println("s = " + s);      }       }}</pre><P><A HREF="#rl9">Back to Article</A></P><H4><A NAME="l10">Listing Ten</H4><pre>public class SampleClass {   public ArrayList createSampleVector() {      ArrayList vector = new ArrayList();      vector.add("ItemOne");      vector.add("ItemTwo");      vector.add("ItemThree");      return vector;   }   public void useSampleVector(ArrayList vector) {      for (int i = 0; i &lt; vector.size(); i++) {         String s = (String) vector.get(i);         System.out.println("s = " + s);      }   }}</pre><P><A HREF="#rl10">Back to Article</A></P><H4><A NAME="l11">Listing Eleven</H4><pre>public class Sample {   static final int READ_ACCESS = 1;   static final int WRITE = 2;   ArrayList myUsers;   ArrayList myUsersWithRights;   public void arrangeUsersByRight() {      ... &lt;some code here&gt; ...      ArrayList rightfulUsers = new ArrayList();      for (int i = 0; i &lt; myUsers.size(); i++) {         User user = (User) myUsers.get(i);         if ((user.myAccessRight &amp; READ_ACCESS) != 0) {            rightfulUsers.add(user);         }     }     myUsersWithRights = rightfulUsers;     ... &lt;some code here&gt; ...   }}</pre><P><A HREF="#rl11">Back to Article</A></P><H4><A NAME="l12">Listing Twelve</H4><pre>public void arrangeUsersByRight() {      ... &lt;some code here&gt; ...      ArrayList rightfulUsers = getUsersWithRight();      myUsersWithRights = rightfulUsers;      ... &lt;some code here&gt; ...}private ArrayList getUsersWithRight() {      ArrayList rightfulUsers = new ArrayList();      for (int i=0; i &lt; myUsers.size(); i++) {            User user = (User) myUsers.get(i);            if ((user.myAccessRight &amp; READ_ACCESS) != 0) {                  rightfulUsers.add(user);            }      }      return rightfulUsers;}</pre><P><A HREF="#rl12">Back to Article</A></P><H4><A NAME="l13">Listing Thirteen</H4><pre>public void arrangeUsersByRight() {      ...&lt;some code here&gt;...      ArrayList rightfulUsers = getUsersWithRight(READ_ACCESS);      myUsersWithRights = rightfulUsers;      ...&lt;some code here&gt;...}private ArrayList getUsersWithRight(int pRight) {      ArrayList rightfulUsers = new ArrayList();      for (int i = 0; i &lt; myUsers.size(); i++) {            User user = (User) myUsers.get(i);            if ((user.myAccessRight &amp; pRight) !=0) {                  rightfulUsers.add(user);            }      }      return rightfulUsers;}</pre><P><A HREF="#rl13">Back to Article</A></P></body></html>