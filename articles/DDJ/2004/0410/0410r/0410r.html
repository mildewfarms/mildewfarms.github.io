
<html>
<head>
<title>October, 2004: The New  Standard Model</title>
</head>

<body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000">
<!--Copyright &#169; Dr. Dobb's Journal-->

<h1>The New  Standard Model</h1>
<p><i>Dr. Dobb's Journal</i> October, 2004</p>
<h2></h2>


<h3>By Gregory V. Wilson</h3>


<I>Greg is a DDJ contributing editor and can be contacted at gvwilsonddj.com.</I>

<hr>


<p><b>Java Open Source  Programming</b><br>
<i>Joe Walnes,  Ara Abrahamian, Mike Cannon-Brookes, and Pat Lightbody</i><br>
Wiley, 2004<br>
459 pp., $45.00<br>
ISBN 0471463620<br>
<b>Coder to Developer: Tools and Strategies for Delivering Your Software</b><br>
<i>Mike Gunderloy </i><br>
Sybex, 2004<br>
297 pp., $29.99<br>
ISBN 078214327X<br>
<b>Effective Software Test  Automation: Developing an  Automated Software Testing Tool</b><br>
<i>Kanglin Li and Mengqi Wu</i><br>
Sybex, 2004<br>
408 pp., $44.99<br>
ISBN 0782143202<br></p>

In physics, the Standard Model is today's baseline explanation of How It All Works. It encompasses quarks, leptons, force-carrying particles&#151;pretty much everything except gravity. From subatomic physics to cosmology, practically everyone builds their theory in its image.

<p>For programmers of my generation, the Standard Model of programming consisted of C, Emacs, Make, UNIX command-line tools such as cat and grep, CVS, and character streams. Now, 25 years later, a replacement is taking shape. Its main elements are Java, the Eclipse IDE, Ant (for building), JUnit (for testing), Subversion (for version control), reflection (for extensibility), and XML (as a universal data-storage format).</p>

<p>So much of this New Standard Model is open source that most of the books describing it&#151;including <i>Java Open Source Programming</i> by Joe Walnes and company&#151;have the phrase in their titles. The first half of <i>JOSP</i> shows you how to build yet another online pet store. Instead of starting with servlets, however, the authors begin by explaining how they will test the application with JUnit and dynamically generated mock objects, and how they will use Hibernate to handle database persistence.</p>

<p>The application itself is then built using WebWork (a Model-View-Controller framework) and SiteMesh (for layout). Search is added using Lucene, XDoclet is used to generate configuration files from metadata embedded in the Java source, and then the authors pause to describe how they communicate via CVS, wikis, mailing lists, IRC, and so on.</p>

<p>And we're not even at page 200 yet...</p>

<p>The second half of the book goes back over the application, replacing the simple throwaway prototypes of the first half with versions that could carry their weight in the real world. Want to know how experienced developers figure out how to manage object lifecycles and dependencies? That's Chapter 14. Look and feel? Chapter 17. There's even some discussion of security, although this material felt like an afterthought and didn't quite live up to the standard set by the rest of the book, which is quite high. The writing is clean, the examples are explained well, and the authors didn't waste time grinding methodological axes. It's definitely not for beginners, but every professional developer will find something useful in this clear, topical survey.</p>
<h3>Coder to Developer</h3>

<p>When I was a young lad, there weren't many books that would teach you how to program. Oh, there were plenty that talked about this language or that algorithm, but if you wanted to learn the mechanics of developing software that worked, there was Brian Kernighan's <i>Software Tools in Pascal</i>, and very little else.</p>

<p>Twenty-two years later, there's still only a handful to choose from. The good news about Mike Gunderloy's <i>Coder to Developer</i> is that it increases the number by one. This practical, readable book is subtitled, "Tools and Strategies for Delivering Your Software," and that's exactly what it's about. Project planning, source-code control, unit testing, logging, and build management are all there. Importantly, so are newer topics, like building plug-ins for your IDE, code generation, and things you can do to protect your intellectual property.</p>

<p><i>Coder to Developer</i> is a little more nuts and bolts than Andy Hunt and Dave Thomas's <i>Pragmatic Programmer</i>, but just as well written and just as useful. Two thumbs up.</p>
<h3>Effective Software Test Automation</h3>

<p>One of the most important features of the "New Standard Model" of programming is its emphasis on unit testing. Just five years after the first version of JUnit was written, an ever-increasing number of programmers actually create and run tests as a matter of course.</p>

<p>But writing tests by hand is still tedious and still requires a fair degree of programming skill. Enter Kanglin Li and Mengqi Wu's <i>Effective Software Test Automation</i>. Over the course of 12 detailed (and sometimes rather intense) chapters, the authors explain how to build a higher level testing tool for .NET programs using reflection (to find and call the methods being tested), CodeDOM (to generate testing code from specifications), and Excel (as a user interface).</p>

<p>Using an application like Excel as a UI may sound strange to UNIX programmers, but thanks to its COM interface, programs can drive it and read data from it with ease. Once QA staff have created a spreadsheet full of tests, the tool described in this book reads in their test cases, generates code to implement those tests, loads the classes to be tested, and runs that code.</p>

<p>The testing tool by itself is interesting and useful, but what I really enjoyed about this book was the authors' explanation of how to build it. Flat text files and handwritten code will always be with us, but structured data and machine-generated code are becoming more important with every passing day. If you'd like a glimpse at how the next generation is going to program, this book is a good place to start.</p>


<p><b>DDJ</b></p>




</body>
</html>