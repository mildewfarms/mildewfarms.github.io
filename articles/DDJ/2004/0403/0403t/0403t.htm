<html><head><title>Mar04: Letters</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Letters</h1><p><i>Dr. Dobb's Journal</i> March 2004</p><p><b>Double Dispatch Again Revisited </b></p><p>Dear <i>DDJ</i>,</p><DDJADVERTISEMENT INLINE><p>On reading Nat Goodspeed's interesting article "Double Dispatch Revisited" (<i>DDJ</i>, January 2004), another approach to the described problem came into my mind. It is explained in detail in Jeff Alger's <i>Secrets of the C++ Masters </i>(AP Professional, 1995; ISBN 0-12-049940-1), which is still one of my favorite books on practical C++ programming. </p><p>Here, the double dispatch problem is solved by two consecutive virtual function calls (see <A NAME="rl1"><A HREF="#l1">Listing One</A>). Consider two <i>GameObject</i> pointers <i>p1</i> and <i>p2</i>; the first actually being an <i>Asteroid</i> and the other a <i>SpaceShip. </i>Calling<i> p1-&gt;collideWith(</i>*<i>p2) </i>forces the first <i>vtable</i> lookup, yielding <i>virtual void Asteroid::collideWith(GameObject</i>&amp;<i> g)  { g.collideWith(</i>*<i>this); }. </i>At this point, the compiler knows that <i>this</i> is an asteroid. The trick is to swap the parameter, forcing a second <i>vtable</i> lookup that correctly brings us to the desired implementation:<i> virtual void SpaceShip::collideWith(Asteroid</i>&amp;<i>).</i> </p><p>In my opinion, this approach is superior to the one Nat describes for the following reasons:</p><ul>  <li>It is more efficient (two <i>vtable</i> lookups versus a linear function list scan).  <li>It is more readable, does not contain ugly template code.  <li>It naturally solves the inheritance problem, as shown for the class <i>CommercialShip</i>, which behaves all the way as a <i>SpaceShip</i> except for the overwritten method <i>collideWith(Asteroid</i>&amp;<i>).</i></ul><p>Wolfgang Stephan</p><p>wolfgang.stephan@web.de</p><p><b>Who's On First?</b></p><p>Dear <i>DDJ</i>,</p><p>Ed Nisley had a huge oversight in his recapitulation of the history of computing in his "Recovered Memories" article (<i>DDJ</i>, December 2003). It was not ENIAC, but the Atanasoff-Berry Computer that was the world's first electronic digital computer. </p><p>Built by John Vincent Atanasoff and Clifford Berry at Iowa State University during 1937-42, the Atanasoff-Berry Computer's memory was a rotating drum that stored 30 numbers of 50 bits each. This drum memory was capacitor based rather than magnetic. It is well documented, for instance, at http://inventors.about.com/library/inventors/blatanasoff_berry.htm that "a 1973, patent infringement case (Sperry Rand vs. Honeywell), voided the ENIAC patent as a derivative of Atanasoff's invention." Indeed, Atanasoff had a chance meeting with Mauchly on a fateful train ride in 1940 and passed on the basic concepts or the so-called von Neumann Machine (I/O, CPU, memory). "The story starts in the mid 1930s with Atanasoff driving 100 mph down a yardstick-straight Iowa road." The rest is the real history.</p><p>Ron Wolf</p><p>ron.e.wolf@ieee.org</p><p><b>Ed responds: </b>Ron, thanks for your note. Scott McCartney covers the Atanasoff story in the book<i> ENIAC: The Triumphs and Tragedies of the World's First Computer</i>, which I mentioned in the column. Here's the bottom line (page 212-213):</p><blockquote><p>...Eckert said, "The work by Dr. Atanasoff in Iowa was, in my opinion, a joke. He never really got anything to work. He had no programming system. He tried for a patent and was told the work he had done was too incomplete to get a patent. A competitor in a patent suit convinced what in my mind was a very confused judge to believe Atanasoff's story, even though it had no real relation to the case at hand."</p><p>   "Mauchley and I achieved a complete workable computing system. Others had not," Eckert said. "If Edison is the inventor of the incandescent lamp it would appear that by the same yardstick Mauchley and I are clearly the inventors of the computer."</p></blockquote><p>McCartney notes that the relevant court case was <i>Sperry versus Honeywell</i>, not <i>Atanasoff versus Mauchley </i>and that the decision broke the Sperry/IBM lock on the key patents. By invalidating the ENIAC patent, the judge ensured that everybody had access to the raw materials of the computer age. Blowing away Eckert and Mauchley's claim to inventing the computer was just regrettable collateral damage.</p><p>The details of what Atanasoff did and did not accomplish, who he met with, what they knew and when they knew it, are all covered in reasonable detail. Atanasoff had several opportunities over the course of many years to stake his claim and did not, despite running a well-funded Navy computer program into the ground, so his claims came rather late in the day.</p><p><b>DDJ</b></p><hr><H4><A NAME="l1">Listing One</H4><pre>// Demonstrates double dispatch using two consecutive vtable lookups// based on Jeff Alger, 'Secrets of the C++ Masters' ISBN 0-12-049940-1// author: Wolfgang Stephan wolfgang.stephan@web.de#include &lt;stdio.h&gt;class Asteroid;class SpaceStation;class SpaceShip;class GameObject{public:	virtual void collideWith(GameObject&amp;)=0;	virtual void collideWith(Asteroid&amp;)=0;	virtual void collideWith(SpaceStation&amp;)=0;	virtual void collideWith(SpaceShip&amp;)=0;};class Asteroid : public GameObject{public:	virtual void collideWith(GameObject&amp; g)  { g.collideWith(*this); }                                    // double dispatch via 2nd vtable lookup	virtual void collideWith(Asteroid&amp;)      { printf("Asteroid &lt;-&gt; Asteroid\n"); }	virtual void collideWith(SpaceStation&amp;)  { printf("Asteroid &lt;-&gt; SpaceStation\n"); }	virtual void collideWith(SpaceShip&amp;)     { printf("Asteroid &lt;-&gt; SpaceShip\n"); }};class SpaceStation : public GameObject{public:	virtual void collideWith(GameObject&amp; g)   { g.collideWith(*this); }	virtual void collideWith(Asteroid&amp;)     { printf("SpaceStation &lt;-&gt; Asteroid\n"); }	virtual void collideWith(SpaceStation&amp;) { printf("SpaceStation &lt;-&gt; SpaceStation\n"); }	virtual void collideWith(SpaceShip&amp;)    { printf("SpaceStation &lt;-&gt; SpaceShip\n"); }};class SpaceShip : public GameObject{public:	virtual void collideWith(GameObject&amp; g)  { g.collideWith(*this); }	virtual void collideWith(Asteroid&amp;)     { printf("SpaceShip &lt;-&gt; Asteroid\n"); }	virtual void collideWith(SpaceStation&amp;) { printf("SpaceShip &lt;-&gt; SpaceStation\n"); } 	virtual void collideWith(SpaceShip&amp;)    { printf("SpaceShip &lt;-&gt; SpaceShip\n"); }};// behaves same way as SpaceShip, except for special collision with asteroidsclass CommercialShip : public SpaceShip{public:	virtual void collideWith(GameObject&amp; g)  { g.collideWith(*this); }	virtual void collideWith(Asteroid&amp;)     { printf("CommercialShip &lt;-&gt; Asteroid\n"); }};int main(int argc, char* argv[]){	GameObject* p1 = new Asteroid;	GameObject* p2 = new SpaceShip;	p1-&gt;collideWith(*p2);	GameObject* gameObjs[4];	gameObjs[0]= new Asteroid;	gameObjs[1]= new SpaceStation;	gameObjs[2]= new SpaceShip;	gameObjs[3]= new CommercialShip;	// start the battle...	for (unsigned i=0;i&lt;4;++i)		for (unsigned k=0;k&lt;4;++k)			gameObjs[i]-&gt;collideWith(*gameObjs[k]);	return 0;}</pre><P><A HREF="#rl1">Back to Article</A></P></body></html>