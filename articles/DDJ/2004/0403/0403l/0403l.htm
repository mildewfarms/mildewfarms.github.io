<html><head><title>Mar04: Tech Tips</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Tech Tips</h1><p><i>Dr. Dobb's Journal</i> March 2004</p><h3>By Edited by George Frazier</h3><I>George is a software engineer in the System Design and Verification group at Cadence Design Systems. He can be reached at georgefrazier@yahoo.com.</I><hr><h3>Cleaning up Component Categories</h3><p><i>by Gregory Peet and Matthew Wilson</i></p><DDJADVERTISEMENT INLINE><p>admin@gregpeet.com</p><p>matthew@synesis.com.au</p><p></p><p>While developing a sample program for the STLSoft libraries, we came across a rather nasty bug in Microsoft's support for Component Categories. The program is a Component Categories Viewer (available from STLSoft 1.6.5 onwards), and uses the standard component category manager component, created through <i>CLSID_StdComponentCategoriesMgr</i>.</p><p>The problem is that some components that have been designed to be marked as "Safe For Scripting and Safe For Initialization" enter these CATIDs into the <i>HKEY_CLASSES_ROOT\Component Categories</i> key. Unfortunately, the CATIDs registered are incorrect. Both component categories are registered missing the closing curly brace of the GUID, as follows:</p><blockquote><p>Safe for scripting</p><p>{7DD95801-9882-11CF-9FA9-00AA006C42C4</p><p>Safe for initialization</p><p>{7DD95802-9882-11CF-9FA9-00AA006C42C4</p></blockquote><p>It's a reasonable guess that the author was using ATL registry scripts, and copied in the erroneous strings as the key names. Further, since those categories would already have been (correctly) registered on the development systems, the authors of the controls would never have noticed the error. These errors are found in the registries of all the systems to which we have access, including NT 4.0, 2000, and XP, so it is probably a widely used component that is causing the problem. Apart from reinstalling a system we cannot know its source. It may even be a component that is installed with the operating system, although we must stress that we have <i>no</i> evidence to its source.</p><p>Whatever the source, the result of these bad keys is that a call to <i>ICatInformation::EnumCategories</i> on the standard component category manager balks at the first broken key, returning the misleading error of <i>E_OUTOFMEMORY</i>. This is a truly nasty problem. Of course, you wonder why the component categories manager was not written more robustly; the registry is alterable by any process, so such an erroneous registration is hardly surprising. But the cat's (pardon the pun) out of the bag. Even if Microsoft enhanced the robustness of the component categories manager in subsequent releases, your code that uses the component may run on a system where it is broken.</p><p>So what's the solution? Well, since you cannot be sure that the component category manager can work with a corrupt registry, and you cannot be sure of an uncorrupted registry, the only pragmatic answer is to clean the registry before you use it. In this tip we present an API that provides functions for detecting and/or cleansing the <i>HKEY_CLASSES_ROOT\ Component Categories</i> key, which you can (and probably should) call before every use of the component categories manager.</p><p>The API consists of the following two <i>typedef</i>s and three functions:</p><blockquote><p>typedef BOOL (WINAPI PfnHandleBadKeyA) 		(LPCSTR, DWORD);</p><p>typedef BOOL (WINAPI PfnHandleBadKeyW) 		(LPCWSTR, DWORD);</p><p>ULONG WINAPI CompCat_FindBadA</p><p>    (PfnHandleBadKeyA pfn, DWORD param);</p><p>ULONG WINAPI CompCat_FindBadW</p><p>    (PfnHandleBadKeyW pfn, DWORD param);</p><p>ULONG WINAPI CompCat_DeleteBad(void);</p></blockquote><p>The <i>CompCat_FindBadA/W()</i> functions take a callback function, and a caller-supplied parameter, and inspect every subkey of the <i>HKEY_CLASSES_ROOT\Component Categories </i>key. For each key found, it is tested (see <A NAME="rl1"><A HREF="#l1">Listing One</A>) for validity, using the <i>CLSIDFromString()</i> COM API function, and if this test fails, the callback function is called, passing the name of the key, and the callback parameter.</p><p>The functions enumerate through the component category keys using the WinSTL (a subproject of STLSoft; http:// winstl.org/) component <i>reg_key_sequence</i>. The value type of the sequence is the <i>reg_key</i> class, on which is called <i>name()</i> to get the subkey name to test with <i>CLSIDFromString()</i> and to pass to the callback function. If the callback function returns FALSE, then the enumeration is terminated, otherwise it goes to completion. In either case, <i>CompCat_FindBadA/W()</i> returns the number of invalid keys found.</p><p>The other API function, <i>CompCat_DeleteBad()</i>, is implemented in terms of <i>CompCat_FindBadA(),</i> and an (internal) callback function <i>CompCat_DeleteBadKeyA().</i> <A NAME="rl2"><A HREF="#l2">Listing Two</A> shows the implementation of both of these functions. <i>CompCat_DeleteBadKeyA()</i> is itself implemented as a call to <i>Reg_DeleteKey()</i> (described in the next tech tip). The third parameter to <i>Reg_DeleteKey()</i> indicates whether to delete all subkeys. In this case, since we know that the component category key is badly formed, it is not useful to any client process, so it's a pretty safe bet that we can delete it. If you're not comfortable with that, you can stick with <i>CompCat_FindBadA/W()</i> and your own callback method that prompts a user for confirmation.</p><p>The API is included in STLSoft 1.7.1 onwards (in the extras directory), and available electronically (see "Resource Center," page 5). Also included is a command-line program, ccc, which can optionally report and/or delete bad keys. Project files for C++ Builder, Digital Mars, Metrowerks CodeWarrior, and Visual C++ are provided.</p><h3>An Even Better <i>RegDeleteKey</i></h3><p><i>by Matthew Wilson</i></p><p>matthew@synesis.com.au</p><p>The May 1999 issue of <i>Windows Developer's Journal </i>included a "Tech Tip" from Fran Heeran, "A Better <i>RegDeleteKey()</i>," that highlighted the inconsistent implementation of <i>RegDeleteKey()</i> between the Windows 9x and NT platforms, and describing a corrective solution, the function <i>wdjRegDeleteKey().</i></p><p>The tip highlighted the fact that on Windows 9x platforms, a call to <i>RegDeleteKey()</i> deletes all subkeys, whereas on Windows NT platforms, the function fails if the specified key has any subkeys. Quite an inconsistency!<i></p><p>wdjRegDeleteKey()</i> handled this issue by recursively deleting subkeys, if any, irrespective of platform so that the call is the semantic equivalent to that implemented on the Windows 9x platforms. A useful tip.</p><p>However, there are times when the rejection of a key deletion due to the presence of child keys is desirable, in which case, Fran's powerful function may actually be too powerful, and a function that mimics the NT semantics may be desired.</p><p>In addition, there was a slight logic problem in the implementation of <i>wdjRegDeleteKey()</i> in so far as the error code returned to the caller may not actually be the error code that causes the recursive deletion to terminate. Furthermore, it is conceivable, though quite unlikely, that this could lead to an implementation difference on 9x and NT platforms: This is because, at an arbitrary level in the recursion, the function attempts to delete the given key irrespective of whether all its subkeys are successfully deleted. This could still result on the platform difference due to the 9x platform situation of successfully deleting all subkeys when they shouldn't be.</p><p>What I describe here is a simple function, <i>Reg_DeleteKey(),</i> that builds on Fran's function to address the issue of high- or low-power setting, and also corrects the slight problem in the initial implementation; see <A NAME="rl3"><A HREF="#l3">Listing Three</A>.</p><p>As with <i>RegDeleteKey()</i> and <i>wdjRegDeleteKey(),</i> <i>Reg_DeleteKey()</i> takes as arguments a root HKEY and the name of a subkey to delete. In addition, it takes a BOOL parameter <i>bRecurse</i>. If <i>bRecurse</i> is True, then it recursively deletes the subkey and all its child subkeys in the same manner as <i>wdjRegDeleteKey().</i> If <i>bRecurse</i> is False, then it checks that there are no child subkeys of the given subkey, returning the <i>ERROR_KEY_HAS_CHILDREN</i> error code.</p><p>The implementation of <i>Reg_DeleteKey()</i> follows a similar format to that of <i>wdjRegDeleteKey()</i>: Open the named key, enumerate and delete its children, delete the key itself. However, there are two key differences.</p><p>First, the return type of the <i>RegEnumKeyEx()</i> call is preserved, in case it is required to be returned to the caller in an erroneous condition.</p><p>Second, if <i>bRecurse</i> is False the <i>ERROR_KEY_HAS_CHILDREN</i> error code is returned. If <i>bRecurse</i> is True, however, then <i>Reg_DeleteKey()</i> is called for each enumerated child key name.</p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>/////////////////////////////////////////////////////////////////////////////// Extract from compcatutil.cpp// License:     (Licensed under the Synesis Software Standard Source License)//              http://synesis.com.au/licenses/ssssl.html//              Copyright (C) 2003, Gregory Peet &amp; Matthew Wilson.//              All rights reserved./////////////////////////////////////////////////////////////////////////////extern "C"ULONG WINAPI CompCat_FindBadA(PfnHandleBadKeyA pfn, DWORD param){  using winstl::a2w;  using winstl::reg_key_a;  typedef winstl::reg_key_sequence_a  sequence_t;  ULONG       cInvalid = 0;  sequence_t  cc_keys(HKEY_CLASSES_ROOT, "Component Categories");  sequence_t::const_iterator  begin = cc_keys.begin();  sequence_t::const_iterator  end   = cc_keys.end();  for(; begin != end; ++begin)  {    CLSID           clsid;    reg_key_a const key(*begin);    if(CLSIDFromString(a2w(key.name().c_str()), &amp;clsid) != NOERROR)    {      if((*pfn)(key.name().c_str(), param))      {        ++cInvalid;      }      else      {        break;      }    }  }  return cInvalid;}</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>/////////////////////////////////////////////////////////////////////////////// Extract from compcatutil.cpp// License:     (Licensed under the Synesis Software Standard Source License)//              http://synesis.com.au/licenses/ssssl.html//              Copyright (C) 2003, Gregory Peet &amp; Matthew Wilson.//              All rights reserved.////////////////////////////////////////////////////////////////////////////namespace {  BOOL WINAPI CompCat_DeleteBadKeyA(char const *key_name, DWORD param)  {    return ERROR_SUCCESS == Reg_DeleteKey((HKEY)param, key_name, true);  }}extern "C"ULONG WINAPI CompCat_DeleteBad(){  winstl::reg_key_a;  reg_key_a key_root(HKEY_CLASSES_ROOT, "Component Categories");  return CompCat_FindBadA(CompCat_DeleteBadKeyA, (DWORD)key_root.get_key_handle());}</pre><P><A HREF="#rl2">Back to Article</A></P><H4><A NAME="l3">Listing Three</H4><pre>LONG Reg_DeleteKey(HKEY hkey, LPCTSTR lpszSubKey, BOOL bRecurse){    /* Open the sub-key. */    HKEY    hkeySub;    LONG    lRet = RegOpenKeyEx(hkey, lpszSubKey, 0,                                           KEY_READ | KEY_WRITE, &amp;hkeySub);    if(lRet == ERROR_SUCCESS)    {        /* Enumerate all of the decendents of this child. */        for(; lRet == ERROR_SUCCESS; )        {            FILETIME    time;            TCHAR       szChildKey[MAX_PATH + 1];            DWORD       dwSize = sizeof(szChildKey) / sizeof(szChildKey[0]);            lRet = RegEnumKeyEx(hkeySub, 0, szChildKey, &amp;dwSize,                                                   NULL, NULL, NULL, &amp;time);            if(lRet != ERROR_SUCCESS)            {                if(lRet == ERROR_NO_MORE_ITEMS)                {                    /* The enumeration is complete, so break main                      * loop, but indicate success.                     */                    lRet = ERROR_SUCCESS;                    break;                }            }            else            {                if(!bRecurse)                {                  /* Can't delete keys with children, unless requested to. */                    lRet = ERROR_KEY_HAS_CHILDREN;                }                else                {                    /* Recursively delete this child. */                    lRet = Reg_DeleteKey(hkeySub, szChildKey, bRecurse);                }            }        }        /* Close the sub-key. */        RegCloseKey(hkeySub);        /* Delete the sub-key. */        if(lRet == ERROR_SUCCESS)        {            lRet = RegDeleteKey(hkey, lpszSubKey);       }    }    return lRet;}</pre><P><A HREF="#rl3">Back to Article</A></P></body></html>