
<html>
<head>
<title>June, 2004: Programmer's Bookshelf</title>
</head>

<body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000">
<!--Copyright &#169; Dr. Dobb's Journal-->

<h1>Lies My Process  Told Me</h1>
<p><i>Dr. Dobb's Journal</i> June, 2004</p>
<h2></h2>

<h3>By Gregory V. Wilson </h3>

<I>Greg works for Hewlett-Packard and is a DDJ contributing editor. He can be contacted at gvwilsonddj.com. </I>

<hr>


<p><b>UML by Example<br>
<i></b>Ghinwa Jalloul <br>
</i>Cambridge University Press, 2004<br>
249 pp., $35.00<br>
ISBN 0521008816<br>
<br>
<b>Extreme Software Engineering:  A Hands-On Approach  <br>
<i></b>Daniel H. Steinberg and  Daniel W. Palmer <br>
</i>Pearson, 2003<br>
273 pp., $32.00<br>
ISBN 0130473812<br>
<br>
<b>Software Development for Small Teams: A RUP-Centric Approach  <br>
<i></b>Gary Pollice, Liz Augustine, Chris Lowe, and Jas Madhur<br>
</i>Addison-Wesley, 2004<br>
272 pp., $39.99<br>
ISBN 0321199502<br>
<br>
<b>Applied Software  Engineering with Apache Jakarta  Commons<br>
<i></b>Christian Gross <br>
</i>Charles River Media, 2004<br>
416 pp., $49.95<br>
ISBN 1584502460<br></p>

All right, it's time to be honest. No one I know actually follows the rules of any particular software development process. From the Rational Unified Process to eXtreme Programming&#151;and at points in between&#151;process models are about as accurate a description of how programmers work as <i>Robert's Rules of Order </i>are of how politicians turn bills into laws.

<p>But that doesn't mean process models are useless. In the real world, good programmers pick and choose ideas from various process models according to the needs of the moment. Have some tricky code to write? Grab a friend, and do some pair programming. Afraid that your customers might change their minds about deliverables halfway through a fixed-deadline project? Do a lot of up-front design and get them to sign off on it. For most programmers, process models are a source of ideas and a reminder that if they're doing <i>X,</i> they should probably do <i>Y</i> as well.</p>

<p>I therefore think that students ought to learn at least two different process models while pursuing their degrees (where "learn" means "use in one or two large projects"). Ghinwa Jalloul's <i>UML by Example,</i> and Daniel Steinberg and Daniel Palmer's <i>Extreme Software Engineering</i>, would be a good pair of textbooks for such a course.</p>

<p>Jalloul's book focuses on the Bridge model, which is based on up-front design and iterative implementation. The first third of the book is a condensed, and rather dry, introduction to the Unified Modeling Language (UML). Part II then presents two detailed case studies, from the initial statement of the customer's needs, through requirements gathering, to class design. Part III contains fragments of three more case studies; filling in the gaps is left as an exercise for readers.</p>

<p>Steinberg and Palmer's book takes a different approach. Chapters 1 and 2 are a broad-brush overview of XP's key practices. Their aim is to let you start programming together. Subsequent chapters then revisit these chapters, expanding on earlier points  and exploring the ways in which the practices depend on each other.</p>

<p>Both books are well written, although you will probably find Steinberg and Palmer's easier to read. Jalloul's would benefit from having some actual code in the examples so that students could see the end product of their designs. <i>Extreme Software Engineering,</i> on the other hand, would benefit from a little more critical commentary&#151;while the authors never claim that XP is a silver bullet, they don't go out of their way to draw attention to its limitations, either.</p>

<p>Like Jalloul's book, <i>Software Development for Small Teams,</i> by Gary Pollice et al., aims to teach a more-formal-than-not approach to software development. It is built around one extended example&#151;the design and development of a tool for gathering information about programmers' performance.</p>

<p>The book is much more code-centric than Jalloul's, and I think you will enjoy its discussion of particular tools (such as various Java IDEs). However, I found it slow: The authors frequently took a paragraph, or a page, to say something that could have been explained in a single sentence.</p>

<p>I also came away feeling that the book's title was somewhat misleading. The "RUP" in the title is the Rational Unified Process, but in several places, the authors skipped over some of RUP's steps or did only part of the work that "real" RUP requires. This is the right thing to do in the real world, but in a tutorial whose aim is to teach a particular process, skipping steps is a little like cheating.</p>

<p>Last on this month's list is Christian Gross's <i>Applied Software Engineering Using Apache Jakarta Commons.</i> The book isn't really about software engineering, at least, not in the same way as the other titles reviewed this month. Instead, its purpose is to show you how best to use the Java packages developed and/or hosted by the Apache Jakarta Project. Want to log events? Serialize objects? This book shows you some good open-source libraries, and more.</p>

<p>This book falls somewhere between a tutorial and a reference guide. Its pattern-based view of how different components fit together helped me understand how Jakarta's various offerings collaborate, though it didn't go far enough for the book to be used as a standalone text. If you have to do one thing in a hurry, this probably isn't the book for you. If you have a lot of things to do, and can take some time to figure out how to do them well, this book may be just what you're looking for.</p>




<p><b>DDJ</b></p>




</body>
</html>