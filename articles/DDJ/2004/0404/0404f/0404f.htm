<html><head><title>Apr04:  Genetic Algorithms & Optimal Solutions </title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1> Genetic Algorithms &amp; Optimal Solutions </h1><p><i>Dr. Dobb's Journal</i> April 2004</p><h2>Solving for the  best congressional redistricting  solution in Texas</h2><h3>By Michael Larson</h3><I>Michael is a principal software engineer at Proficient Networks. He can be reached at mike@lrlart.com.</I><hr><a name="rs1"><a href="0404fs1.htm">Genetic Algorithms</a><hr><p>A few months ago, the Texas legislature was in the midst of a slugfest over the state's congressional redistricting efforts. Republicans were in the driver's seat with 17 of 32 districts and Democrats were trying like anything to avoid losing additional seats. How bad was it? Well, Democrats were mad at Republicans for trying to pull a fast one; Republicans were mad at Democrats for leaving the state to avoid voting on the plan; Democrats were mad at Democrats for jumping ship and returning to Texas; and Republicans were mad at Republicans as they bickered over the spoils.</p><p>What a mess. You'd think that there would be an equitable and fair approach in creating these districts. Well, all this led my friend Noah Kennedy to suggest that perhaps the problem could be solved in a more equitable (and perhaps "technocratic") manner&#151;maybe just a simple matter of some well thought-out and executed software. </p><DDJADVERTISEMENT INLINE><p>"Fair and equitable congressional redistricting" can be defined as: 1. Districts of equivalent population size, while; 2. minimizing a district's perimeter. The subdivision of the population would obviously be performed with a blind eye to the voting preferences of a given region. Given these parameters, this problem started to feel as if it might yield to an optimization-solving algorithm. </p><p>While there are many approaches to solve for an optimal solution of this type, this looked similar to a genetic algorithm approach I've used to solve the traveling salesman problem. Perhaps, I could use a variation of the same approach to find an optimal redistricting solution for Texas? I was determined to help Texas.</p><p>A fair and equitable redistricting solution should provide:</p><ul>  <li>Thirty-two equal population groups.  <li>Compact district land representation to avoid gerrymandering. </ul><p>Given these two points, how would you go about finding an optimal solution (the needle) among all the suboptimal solutions (the haystack)?</p><p>The first criteria (equal population size) appears easy enough to apply&#151;just divide the districts into 32 equal population groups. The second criteria becomes a constraint to the first criteria and complicates matters. One tactic to satisfy the second condition would be to select 32 "centroids" within the state of Texas. A centroid would "attract" all the near or local population and, therefore, construct a congressional district. These 32 districts would then satisfy the second condition&#151;ensuring a district's compactness (that is, minimizing its perimeter length).</p><p>To test this approach, I used a year 2000 census dataset of 4390 data points with latitude, longitude, and population data. Population for each data point varied in size from 1000 to 12,000, with an average of about 5000 people. The job, therefore, was to find the set of 32 centroids out of the 4390 available points such that each district would have equal population sizes.</p><h3>Genetic Algorithms </h3><p>Genetic algorithms are a rather straightforward, flexible optimization-solving technique that are modeled after evolutionary forces in nature (see the text box "Genetic Algorithms" for more details). </p><p>A typical genetic-algorithms approach uses an array of Booleans to represent an organism (each Boolean is considered a gene). An example of an organism is:</p><blockquote><p>| 1 | 0 | 1 | 1 | 1 | 0 | 1 |...| 0 | 0 | 1 |</p><p>  1   2    3   4   5   6   7      n-2  n-1 n</p></blockquote><p>The district representation cannot use Boolean values but needs to represent each gene as belonging to a specific district (therefore, a gene can have a value of 1 to 32):</p><blockquote><p>| 1...32 | 1...32 | 1...32 |... | 1...32 | 1...32 |</p><p>  1         2         3               4389    4390</p></blockquote><p>There would be 4390 genes in this representation (one for each point in the dataset). The array of genes within an organism represents a solution to the problem being solved (in this case, Texas redistricting). All possible combinations of genes within the array are considered a valid organism (or solution). Unfortunately, this representation does not lend itself well to the problem at hand (most organisms would violate the compact district representation constraint). The internal representation of the organism should be further simplified for this problem. </p><p>You can modify the organism such that each gene represents a centroid and can have a value of 1 to 4390 (one value for each point in the dataset), then the organism contains 32 genes:</p><blockquote><p>|1...4390|1...4390|1...4390|...|1...4390|1...4390|</p><p>  1               2               3                        31            32</p></blockquote><p>Each gene now represents a centroid that will be used to assign all remaining local population data points. A limitation with this representation is that a gene's value must be unique within the organism (that is, no duplicate centroids within an organism). These changes force modifications to the standard genetic-algorithm operations (crossover and mutation) performed on the organism.</p><p>One final feature needs to be defined for this technique to work&#151;rating an organism's fitness. How will the genetic algorithm determine whether a particular organism represents a good or poor solution? The fitness criteria can be defined as a partial, standard deviation calculation performed on the population spread within an organism. This is sufficient to rate the fitness of a solution. The lower the standard deviation, the better the solution; that is, the more equal the population sizes are across the 32 congressional districts. An important aspect of a good fitness criterion is that it represents a continuous solution space&#151;there are no or few discontinuities. A discontinuity may prevent convergence to an optimal solution. The partial standard deviation equation as it applies to the fitness function is:</p><blockquote><p>Fit = (PopDist - PopAvg) * (PopDist - PopAvg)</p></blockquote><p>where <i>PopDist</i> is the population of the district and <i>PopAvg</i> is the average population size for all districts. Now, technocrats, flex your fingers and warm up your keyboards as we are ready to go to work and show the world what a little magic can do.</p><h3>Implementation and Design</h3><p>The design consists of two main object hierarchies&#151;the organism and the genetic population. The genetic population is a collection of organisms (see <A NAME="rf1"><A HREF="0404ff1.htm">Figure 1</A>). Both the organism and population behaviors have been generalized into base class implementations. Primitive data types have been templatized for these classes to allow for greater flexibility over the range of behaviors and characteristics for the organisms and populations.</p><p><i>GENOrganismBase</i> is the base class for the organism (see <A NAME="rf1"><A HREF="0404ff1.htm">Figure 1</A>). It is templatized with the data type that represents each gene. The type is specified by the derived class <i>DistrictOrganism</i>&#151;in this case, the <i>PopPoint </i>data structure. The <i>PopPoint</i> structure represents a single centroid location, the size of the centroid data point itself, plus the size of the total population assigned to this centroid.</p><blockquote><p>    float m_fLat; //latitude</p><p>    float m_fLon; //longitude</p><p>    unsigned long m_ulPop; </p><p>                     //gene's population only</p><p>    unsigned long m_ulTotalPop; </p><p>                    //total district population </p><p>   unsigned short m_usID;</p><p>                    //pop ID</p></blockquote><p>With a typical genetic algorithm approach, the template argument would normally be a Boolean rather than <i>PopPoint</i>. Again, using the <i>PopPoint</i> representation does affect the mutation and crossover operations (and are implemented in the derived class: <i>DistrictOrganism</i>). <i></p><p>GENOrganismBase</i> methods <i>mateWith()</i> and <i>mutate()</i> are pure virtual methods and are required to be overridden by the derived class (<i>DistrictOrganism</i>). The method <i>mateWith()</i> supports crossover operations, while <i>mutate()</i> supports (wild guess here) mutation. <i>DistrictOrganism</i> derives from <i>GENOrganismBase</i> and provides this specialization in behavior. </p><p>Within <i>DistrictOrganism::mutate() </i>(<A NAME="rl1"><A HREF="#l1">Listing One</A>), mutation is no longer a random toggling of a Boolean cell value, but instead a random selection of one of 4390 values (provided that that value is not already represented within the gene sequence). Therefore, the 32 genes are passed in as a constraint to the <i>mutate()</i> method. Access to the full set of data is through the helper object <i>DistrictBucket</i>, which provides the method <i>randomPick()</i>. <i>randomPick()</i> lets the <i>DistrictOrganism</i> pass in a collection of data points to be excluded from the random- selection process, thereby preventing duplicate genes from being represented within the organism. The randomly selected <i>PopPoint</i> then replaces the selected gene. This condition operates at a frequency of <i>fRate</i>, which should be rare enough that convergence to an optimal solution is allowed, but not infrequent enough so that new paths to the optimal solution are not tested.</p><p>Crossover behaves in a similar fashion to mutation. In <i>DistrictOrganism::mateWith()</i> (<A NAME="rl1"><A HREF="#l1">Listing One</A>), the crossing point of two organisms is a random location within the sequence of genes that is constrained to the unique set of genes between the two organisms (<i>iLoc</i>). This constraint is required so that duplicate cells don't appear as a result of a crossover operation. The organism is then spliced together with a partial set of the genes from the other organism at the crossover point.</p><h3>Population of Organisms</h3><p>The <i>DistrictPopulation</i> class derives from the <i>GenPopulation</i> base class. The <i>GenPopulation</i> base class is templatized on the data type representing the organism (which needs to derive from <i>GENOrganismBase</i>); in this case, the derived <i>DistrictOrganism</i> implementation. Within the <i>DistrictPopulation</i> class, the main method of interest is the <i>evolve()</i> method (<A NAME="rl2"><A HREF="#l2">Listing Two</A>). This method contains the processing loop that evolves each organism within a generation. Reproduction, crossover, and mutation are performed to produce a new generation of organisms based on the previous generation. Each iteration of the population selects two adjacent organisms and determines if they should reproduce (at the reproduction rate). If these organisms reproduce, organisms possessing a higher fitness rating will be given preference. Crossover and mutations operations are applied on each organism. Finally, at the end of an evolution sequence, the method <i>GENPopulation::evolutionComplete()</i> is called, which performs a rating of the new generation of solutions.</p><p>The <i>DistrictFitness</i> class contains the fitness computation (derived from base class <i>GENFitness</i>) that performs the final and critically important step, rating the organisms according to their worthiness. Within this specific solution, the algorithm accesses the complete set of population data and assigns each population point to a gene until all population points have been assigned. Assignment is applied via a simple rule, where each population point is assigned to the nearest gene (centroid). Total populations are computed for each district, then a partial standard deviation is computed. The reason that this is a partial deviation (without applying the square root) is that the comparison of the fitness is the same with or without the square root; therefore, the computation can skip the CPU-expensive square root. </p><p>The fitness computation is followed by a scaling operation. Scaling lets the implementation adjust the dynamic range of the fitness values and therefore aid the search for the optimal solution. The scaling can be overridden by the implementer just as the fitness is allowed to be overridden. <i></p><p>DistrictScale</i> is implemented and overrides the base class implementation <i>ScaleFitness</i>. This class provides an adjustment to the dynamic range of the fitness values. The <i>ScaleFitness</i> base class provides no modification (that is, it multiplies the passed-in value by one). To improve the chances of good organisms surviving into future generations, the fitness value is squared in the derived implementation. In initial runs of the genetic-algorithm system, I found that good organisms were often dying out before they were allowed to propagate to the next generation; therefore, I wanted to give good organisms an additional weight to survive the reproduction stage. By applying the square of the fitness, this skews the survival rate in favor of more fit organisms. In general, the scaling, if applied correctly, provides for a faster convergence to an optimal solution.</p><h3>Optimal Solutions</h3><p><A NAME="rf2"><A HREF="0404ff2.htm">Figure 2</A> shows the convergence of the best gene by generation. The convergence trend shows that this approach continues to search and find better solutions&#151;note that the x-axis is a log scale; therefore, to continue that same rate of improvement will take exponentially more time. The shape of the convergence plot can dramatically be affected by the reproduction rate, crossover rate, and mutation rate. For example, a higher mutation rate gives a less smooth convergence plot.</p><p>The best solution found is in <A NAME="rf3"><A HREF="0404ff3.htm">Figure 3</A> (computed after 9176 generations). The district population points are color coded to show where the optimal districts would exist in the state of Texas. Centroid points that constitute the center of a district are shown as numbers (black). <A NAME="rt1"><A HREF="0404ft1.htm">Table 1</A> shows the same solution but with the population for each district and the difference from the average population each district would optimally have. This is a good solution, but further processing would probably yield an even better solution.</p><p>Given the structure of the data (4390 population points) and the limitation that districts were centered around "centroids," it would be possible to further converge on population equivalence between the congressional districts. Two approaches not applied here could be used to further improve this solution:</p><ul>  <li>Change the nature of the centroid picking such that a finer granularity of selection on the centroid would be found.  <li>Change the fitness function such that the fitness would allow "trading" population between adjacent districts to further even out the population differential between districts.</ul><p>Additional work should be done to define district boundaries. One approach to defining a boundary representation for each district would be to compute the convex hull around each district (the group of population points) and then generate a voronoi graph around these regions. </p><h3>Conclusion</h3><p>This work probably took less time than the effort expended in the halls of the Texas legislature. However, I suspect that the current political process in Texas would find little to embrace in this fair (and optimal) solution&#151;so this becomes an exercise in possibilities. An infinitely more complex problem would be to model the political process and resulting redistricting solution&#151;for that, probably no amount of optimization magic can be applied.</p><p></p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>void DistrictOrganism::mateWith(GENOrganismBase&lt;PopPoint&gt;                                                  &amp;otherOrg, float fWhere){   int iCt = 0, iLoc;   GENOrganismBase&lt;PopPoint&gt;::GeneIter iter, iterMatch;   //get number of unique cells between two genes   iter = m_geneColl.begin();   while (iter != m_geneColl.end())   {      if (otherOrg.has(*iter) == false)         ++iCt;      ++iter;   }   //scale cell to this number   iLoc = int(fWhere * float(iCt));   iCt = 0;   //splice at this location ensuring uniqueness   iter = m_geneColl.begin();   while (iter != m_geneColl.end() &amp;&amp; iCt &lt; iLoc)   {      if (otherOrg.has(*iter) == false)      {         *iter = otherOrg.get(iCt);      }      ++iCt;      ++iter;   }}void DistrictOrganism::mutate(float fRate){   int iCell;   PopPoint point;   GENOrganismBase&lt;PopPoint&gt;::GeneIter iter;   iter = m_geneColl.begin();   while (iter != m_geneColl.end())   {      if (FLIP(fRate))      {        *iter = m_pDistrictBucket-&gt;randomPick(m_geneColl); //passes in list of                                                           // exclusion points      }      ++iter;   }}</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>void DistrictPopulation::evolve(){   OrganismIter iterOne, iterTwo;   DistrictOrganism geneOne, geneTwo;   if (m_popPool-&gt;size() &lt; 2)      return;   iterOne = m_popPool-&gt;begin();   iterTwo = ++(m_popPool-&gt;begin());   while (iterOne != m_popPool-&gt;end() &amp;&amp; iterTwo != m_popPool-&gt;end())   {      orgOne = *iterOne;      orgTwo = *iterTwo;      if (FLIP(m_fRepro))      {         orgOne = doReproduction(orgOne);         orgTwo = doReproduction(orgTwo);      }      doCrossover(orgOne, orgTwo);      doMutation(geneOne);      doMutation(geneTwo);      addToNewGeneration(geneOne);      addToNewGeneration(geneTwo);      ++iterOne;++iterOne;      ++iterTwo;++iterTwo;   }   evolutionComplete();}</pre><P><A HREF="#rl2">Back to Article</A></P></body></html>