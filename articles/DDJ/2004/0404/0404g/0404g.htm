<html><head><title>Apr04: Building  Little Languages  With Macros</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Building  Little Languages  With Macros</h1><p><i>Dr. Dobb's Journal</i> April 2004</p><h2>Picking up where  language designers  leave off</h2><h3>By Matthias Felleisen, Robert Bruce Findler, Matthew Flatt, and Shriram Krishnamurthi</h3><I>Matthias is a professor at the College of Computer Science at Northeastern University; Robert is an assistant professor of computer science at the University of Chicago; Matthew is an assistant professor in the School of Computing at the University of Utah; and Shriram is an assistant professor of computer science at Brown University. They can be contacted at matthias@ccs.neu.edu, robby@cs.uchicago.edu, mflatt@cs.utah.edu, and sk@cs.brown.edu, respectively.</I><hr><p>At some point, every language design has to end. The design of Java, for example, includes constructs from <i>for</i> loops to inner classes, but does not include a <i>foreach</i> construct, a lex/yacc-style parser-generator form, call-by-reference methods, or many other constructs.</p><p>Macro systems let programmers continue where language designers left off and extend languages with new constructs. Furthermore, macro-extended languages continue to work with the basic tool chain&#151;in contrast to lex- and yacc-style language extensions, for example, which require modified code generators, makefiles, and the like. Finally, if the macro system uses patterns to specify language extensions, macros are easily defined and understood in terms of a simple rewriting process.</p><DDJADVERTISEMENT INLINE><p>One apparent drawback of pattern-based macros is that they cannot express interesting language extensions, such as new forms of variable binding or new forms of control. Macros in C are certainly limited in this regard, but pattern-based macros can be considerably more expressive in principle. In this article, we show how pattern-based macros in Scheme can express interesting language extensions, such as a call-by-reference extension of a call-by-value language.</p><p>A second drawback of macros in general is that they interact poorly with programming tools, such as type checkers and debuggers, which have difficulty correlating a program's original source and its macro-expanded version. Again, C macros certainly exhibit this problem, but Scheme macros play well with source-correlating tools, and they play well for much the same reason that they can implement interesting language extensions. Scheme macros thus provide a foundation for building little languages that fit neatly into existing programming environments.</p><h3>Pattern-Based Macros</h3><p>Most programmers are familiar with C-style pattern-based macros. In general, pattern-based macro definitions include pattern variables that match syntax fragments in a macro use. To expand a macro use, each pattern variable in the macro's template is replaced by the matching syntax fragment. For instance, in the ever-popular <i>swap</i> in <A NAME="re1"><A HREF="0404ge1.htm">Example 1</A>(a), the <i>swap(x,y)</i> part is the pattern, <i>x</i> and <i>y</i> are pattern variables, and the<i> {int tmp=y; y=x; x=tmp;}</i> part is the template. <A NAME="re1"><A HREF="0404ge1.htm">Example 1</A>(b) matches the pattern <i>swap(x,y),</i> where <i>x</i> is matched to <i>c.red</i> and <i>y</i> is matched to <i>d-&gt;blue.</i> Expansion proceeds by substituting <i>c.red</i> for <i>x</i> and <i>d-&gt;blue</i> for <i>y</i> in the template, producing <A NAME="re1"><A HREF="0404ge1.htm">Example 1</A>(c). Although C macros are easy to understand, they have a deservedly poor reputation in that expansion is the only way to understand the macro. In particular, <A NAME="re1"><A HREF="0404ge1.htm">Example 1</A>(d) expands to <A NAME="re1"><A HREF="0404ge1.htm">Example 1</A>(e), which does not actually swap the values in <i>tmp</i> and <i>other</i>. The underlying problem is that the macro system manipulates plaintext instead of structured syntax fragments. As a result, the macro cannot implement your true intent, which is to have a private temporary variable, and it cannot help programming tools accurately relate the original source and its macro-expanded version. These problems with C macros are absent from Scheme's macro system.</p><h3>Scheme Macro Basics</h3><p>For simple tasks, Scheme macros look similar to C macros. The C macro header in  <A NAME="re2"><A HREF="0404ge2.htm">Example 2</A>(a) translates to Scheme as in  <A NAME="re2"><A HREF="0404ge2.htm">Example 2</A>(b). The <i>syntax-rules</i> part of the definition indicates that the macro takes "arguments," just as the parentheses after <i>swap</i> in C indicate a macro with arguments.</p><p>A C macro with arguments matches only one pattern&#151;a certain number of comma-separated elements within parentheses. In contrast, a Scheme macro can match multiple patterns, and each pattern can have a specific structure, such as auxiliary keywords or nested parentheses. Therefore, <i>syntax-rules</i> in a macro definition is followed by a sequence of auxiliary keywords (to distinguish them from pattern variables), then a sequence of pattern-template pairs. For <i>swap</i>, you have no keywords and you have only one pattern, as in <A NAME="re2"><A HREF="0404ge2.htm">Example 2</A>(c).</p><p>A use of <i>swap</i> such as in <A NAME="re3"><A HREF="0404ge3.htm">Example 3</A>(a) roughly expands to <A NAME="re3"><A HREF="0404ge3.htm">Example 3</A>(b), which is Scheme notation for introducing a local variable <i>tmp</i><i><sub>1</i></sub>, then assigning <i>y=x</i> and <i>x=tmp</i><i><sub>1</i></sub>. In other words, <i>let</i> acts like a new block for variable bindings, and <i>set!</i> acts like "<i>=</i>" for assignment.</p><p>The macro system adds the subscript in <i>tmp</i><i><sub>1</i></sub> to indicate that <i>tmp</i> was introduced by the macro, and it has no relationship to other existing syntax. Thus, even if <i>swap</i> is used with a variable named <i>tmp</i>, as in <A NAME="re3"><A HREF="0404ge3.htm">Example 3</A>(c), this use of <i>swap</i> behaves as expected because the variables <i>tmp</i> and <i>tmp</i><i><sub>1</i></sub> are different in the expansion; see <A NAME="re3"><A HREF="0404ge3.htm">Example 3</A>(d). Introducing subscripts, as in <i>tmp</i><i><sub>1</i></sub>, ensures that language extensions play well with the lexically scoped base language. Avoiding unintentional capture by introduced variable declarations, as in <A NAME="re3"><A HREF="0404ge3.htm">Example 3</A>(d), is only half of the problem, however. The macro system must also prevent unintended capture of introduced variables, as in <A NAME="re3"><A HREF="0404ge3.htm">Example 3</A>(e) where<i> (define (f x) ...)</i> is Scheme notation for defining a function <i>f</i> that takes a single argument, <i>x</i>. The body of the function contains a local macro definition, <i>swap-with-arg</i>, followed by a block with local bindings of <i>z</i> and <i>x</i> and a body that uses <i>swap-with-arg</i>.</p><p>The local macro <i>swap-with-arg</i> swaps a variable's value with the value of<i> f</i>'s <i>x</i> argument. Even if <i>x</i> has a different binding in the context where <i>swap-with-arg</i> is used, the <i>x</i> introduced by the macro expansion always refers to the function argument. In other words, in expanding the aforementioned definition, the second <i>x</i> must be renamed to preserve lexical scope; see <A NAME="re3"><A HREF="0404ge3.htm">Example 3</A>(f).</p><p>In general, the macro system adds subscripts and superscripts as necessary to preserve lexical scope for the original identifiers.</p><h3>Matching Multiple Patterns</h3><p>A natural generalization of <i>swap</i> is the <i>rotate</i> macro, which rotates the values of a set of variables to the left. For example, <i>(rotate bucket box bin)</i> moves the value of <i>box</i> to <i>bucket</i>, the value of <i>bin</i> to <i>box</i>, and the value of <i>bucket</i> to <i>bin</i>. The <i>rotate</i> form should also work on four variables, as in <i>(rotate n e s w)</i>, or any number of variables.</p><p>Rotating a set of variables is the same as swapping the first two, then rotating all but the first variable. Rotating a single variable has no effect. Based on these two observations, you can implement the <i>rotate</i> macro as in <A NAME="re4"><A HREF="0404ge4.htm">Example 4</A>(a). The first pattern, <i>(rotate a)</i>, matches when a single variable is supplied, and the expansion is the nonoperational <i>(void)</i> expression. The second pattern,<i> (rotate a b c ...)</i>, contains ellipses that allow any number of matches for <i>c</i>&#151;including zero matches. Thus, the macro use <i>(rotate n e s w) </i>matches the second case, and expands to <A NAME="re4"><A HREF="0404ge4.htm">Example 4</A>(b), which in turn expands to <A NAME="re4"><A HREF="0404ge4.htm">Example 4</A>(c), and so on, ending with <A NAME="re4"><A HREF="0404ge4.htm">Example 4</A>(d). The Scheme <i>begin</i> form combines and orders statements, so the expansion in <A NAME="re4"><A HREF="0404ge4.htm">Example 4</A> rotates <i>n</i> through <i>w</i> by bubbling <i>n</i>'s value through the other variables. </p><p>Instead of bubbling one value through all of the variables, you can define a <i>rotate</i> macro that directly moves each value to its target. The new <i>rotate</i> uses a helper macro, and it shows how ellipses can be placed after any subpattern or subtemplate to generate multiple instantiations of the subpattern or subtemplate; see <A NAME="re5"><A HREF="0404ge5.htm">Example 5</A>(a). Using these definitions, <i>(rotate n e s w) </i>expands to a kind of parallel assignment in <A NAME="re5"><A HREF="0404ge5.htm">Example 5</A>(b), which in turn expands to <A NAME="re5"><A HREF="0404ge5.htm">Example 5</A>(c). The use of ellipses after the subtemplate <i>(set! to from) </i>causes <i>to</i> and <i>from</i> matches to be paired up and instantiated together. The <i>shift-to</i> macro fails if the number of <i>from</i> matches is not the same as the number of <i>to</i> matches, but the use in <i>rotate</i> always creates the same number of each. </p><h3>Identifier Macros</h3><p>The C macro system supports two kinds of macros&#151;function-shaped macros like <i>swap</i>, and identifier-shaped macros that match only the macro name. For example:</p><blockquote><p>#define MAX_INT 0x7ffffff</p></blockquote><p>defines a macro<i> MAX INT </i>so that it is replaced in any context with <i>0x7ffffff</i>. A <i>syntax-rules</i> macro is always a <i>swap</i>-style macro. A <i>syntax-id-rules</i> macro is more like<i> MAX INT</i>, but the identifier's expansion can be made sensitive to the way that it's used&#151;as the target of a <i>set!</i> assignment, immediately after an open parenthesis, or as an immediate expression. (In Scheme, the position after <i>set!</i> or after an open parenthesis is generally special.)</p><p>For example, the definition in <A NAME="re6"><A HREF="0404ge6.htm">Example 6</A> causes <i>clock</i> to act like a normal Scheme variable, but assignments and uses of the variable are implemented through a <i>set-time!</i> mutator function and a <i>get-time</i> accessor function. With this macro, <i>clock</i> expands to<i> (get-time)</i>, while<i> (set! clock 5) </i>expands to<i> (set-time! 5)</i>.</p><p>The middle case in the macro causes <i>(clock 8) </i>to expand to an error because applying <i>clock</i> as a function is useless. For other macros, the middle case is useful. In fact, the <i>syntax-rules</i> form could be considered a special case of <i>syntax-id-rules</i> with only the middle case.</p><h3>Macro-Generating Macros</h3><p>Macro-generating macros let you create new forms for defining other macros. For example, suppose you want to convert many sets of mutator-accessor functions to pseudovariables like <i>clock.</i> Instead of copying the definition of <i>clock</i> and replacing the names, you would instead prefer to write <A NAME="re7"><A HREF="0404ge7.htm">Example 7</A>(a). The <i>define-get/set-var</i> form can be implemented as a macro-generating macro, as in <A NAME="re7"><A HREF="0404ge7.htm">Example 7</A>(b).</p><p>The<i> (... ...) </i>combination in a template produces a plain <i>...</i> in the macro expansion. In other words, the first ellipses escape the second ellipses so that the macro-produced macro contains pattern- and template-duplicating ellipses.</p><h3>Extended Example: Call-by-Reference</h3><p>The <i>swap</i> and <i>rotate</i> examples are special cases of call-by-reference functions. Using only the pattern-based macro tools described so far, you can implement an extension of Scheme for defining call-by-reference functions. Our new <i>define-cbr</i> form allows programs such as <A NAME="re8"><A HREF="0404ge8.htm">Example 8</A>(a). Since <i>f</i> is a call-by-reference function, the swap in <i>f</i> swaps the values of the <i>x</i> and <i>y</i> variables passed to <i>f</i> in the example call. </p><p>The expansion of <i>define-cbr</i> consists of two parts. The first part introduces a <i>do-f</i> call-by-value function that acts like a call-by-reference version of <i>f.</i> Instead of accepting <i>f</i>'s arguments directly, it accepts accessor and mutator functions. In particular, the <i>f</i> definition in <A NAME="re8"><A HREF="0404ge8.htm">Example 8</A>(a) expands to 8(b). Where the original function had two arguments, <i>a</i> and <i>b</i>, the expanded function has four arguments: <i>get</i><i><sub>1 </i></sub>and <i>set</i><i><sub>1</i></sub>, which are functions to get and set <i>a</i>; and <i>get</i><i><sub>2</i></sub> and <i>set</i><i><sub>2</i></sub>, which get and set <i>b</i>. Inside the function, <i>a</i> and <i>b</i> are mapped to the accessor and mutator functions using our <i>define-get/set-var</i> macro. The other half of the transformation affects uses of <i>f.</i> The use of <i>f</i> in <A NAME="re8"><A HREF="0404ge8.htm">Example 8</A>(c) expands to a call to <i>do-f</i>, where the arguments <i>x</i> and <i>y</i> are replaced with functions that get and set the values of <i>x</i> and <i>y</i>; see <A NAME="re8"><A HREF="0404ge8.htm">Example 8</A>(d).</p><p>The <i>lambda</i> keyword in Scheme means "anonymous function," and <i>(lambda () x)</i> is an anonymous function that accepts no arguments and returns <i>x</i>. Similarly, <i>(lambda (v) (set! x v)) </i>is an anonymous function that accepts one argument and puts it into <i>x</i>.</p><p>The key to connecting the definition of <i>f</i> to uses of <i>f</i> is that <i>define-cbr</i> is a macro-defining macro. It defines <i>f</i> as a macro that expands to uses of <i>do-f</i>. In other words, the<i> (define-cbr (f a b) (swap a b)) </i>definition actually expands to <A NAME="re8"><A HREF="0404ge8.htm">Example 8</A>(e).</p><p>Our task, then, is to implement a <i>define-cbr</i> macro that expands as above. Half of this macro is straightforward; see <A NAME="re9"><A HREF="0404ge9.htm">Example 9</A>(a). The <i>???</i> part turns out to be more complex. If <i>define-cbr</i> allowed only a single <i>arg</i> for the defined function, then <i>???</i> could be simply <A NAME="re9"><A HREF="0404ge9.htm">Example 9</A>(b). To support multiple arguments, however, you must generate many distinct <i>get</i> and <i>put</i> names to go with many <i>arg</i>s. To generate the names, you can exploit the way the macro expander adds subscripts to introduced variables. The idea is to take one <i>arg</i> at a time and introduce a corresponding <i>get</i> and <i>set</i>, leaving the rest of the <i>arg</i>s to further expansion. Each expansion then adds a unique subscript to the just-introduced <i>get</i> and <i>put</i>.</p><p>The name-generating sequence of expansions requires a helper macro, which we name <i>define-cbr-as-cbv</i>, so that the <i>??? </i>in <i>define-cbr</i> is replaced with <A NAME="re10"><A HREF="0404ge10.htm">Example 10</A>(a). Then the extra <i>()</i> in this template provides a place to accumulate generated names. Initially, <A NAME="re10"><A HREF="0404ge10.htm">Example 10</A>(b) expands to 10(c), but after two expansions, this code changes to 10(d), at which point it is easily converted to the final definition of <i>do-f</i>, since <i>a</i> is grouped with <i>get</i><i><sub>1</i></sub> and <i>set</i><i><sub>1</i></sub> and <i>b</i> is grouped with <i>get</i><i><sub>2</i></sub> and <i>set</i><i><sub>2</i></sub>. </p><p>The implementation of <i>define-cbr-as-cbv</i> in <A NAME="re11"><A HREF="0404ge11.htm">Example 11</A> implements both phases of this translation.</p><h3>Beyond Patterns</h3><p>With the definitions of the<i> define-get/set-var, define-cbr, </i>and <i>define-cbr-as-cbv</i> macros, we have added call-by-reference functions to Scheme, using only 33 lines of pattern-based macro definitions. For many purposes, the implementation is complete, though it suffers some obvious limitations:</p><p></p><ul>  <li>Call-by-value functions in Scheme are higher order, which means that they can be passed to other functions or returned from other functions. Our call-by-reference functions are first-order, which means they can only be used in a direct call.  <li>When arguments are not variables, as in<i> (f 1 2),</i> the result is a <i>set!</i> syntax error. In most languages with call-by-reference functions, nonvariable arguments are effectively placed into a fresh dummy variable at the call site.</ul><p>These problems cannot be solved using only pattern-matching macros in Scheme, and many other kinds of language extensions fall outside the capabilities of pattern-matching macros. Nevertheless, the ideas behind Scheme's pattern-matching macros provide a solid foundation for more elaborate macro systems.</p><p>The next level of macro sophistication in Scheme is the <i>syntax-case</i> macro system. A <i>syntax-case</i> macro can perform arbitrary computation (using Scheme) on the results of a pattern match. For example, a <i>syntax-case</i> macro can distinguish call-by-reference calls that have variable arguments from those that do not, and it can produce a different expansion in each case.</p><p>A <i>syntax-case</i> macro does not manipulate plain text, or even plain symbols and lists (as does a Lisp macro). Instead, the macro manipulates syntax objects, which encode the lexical context and source locations of program fragments. Consequently, just like a <i>syntax-rules</i> macro, a <i>syntax-case</i> macro respects the lexical structure of the source program (by default) and it plays well with source-correlating tools. </p><p>Syntax objects enable the implementation of most any little language or language extension. Using <i>syntax-case</i>, we have implemented a Java-like class system for Scheme, lex- and yacc-like forms for building parsers, and constructs for defining and linking program components. Programmers using these constructs do not reason about them in terms of their expansion. Instead, syntax objects allow the expansion to be hidden behind abstract definitions of the constructs, just as the inner workings of any compiler are hidden behind a language definition.</p><p>A language's concrete syntax need not be parenthesized to make use of syntax objects. In particular, we are currently developing implementations of Java and ML for our programming environment, DrScheme (see "Fostering Little Languages," <i>DDJ</i>, March 2004). Since our parsing tools produce syntax objects, we can treat Java and ML like macro extensions of Scheme. These macro implementations resemble typical Java-to-Scheme and ML-to-Scheme compilers, but little additional work is needed to adapt our entire programming environment to new languages.</p><p><b>DDJ</b></p></body></html>