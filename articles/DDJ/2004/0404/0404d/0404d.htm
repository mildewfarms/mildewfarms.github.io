<html><head><title>Apr04: Adventures in Palindromes</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Adventures in Palindromes</h1><p><i>Dr. Dobb's Journal</i> April 2004</p><h2>Putting backtracking strategies to work</h2><h3>By William R. Mahoney, Ph.D.</h3><I>William is the senior vice president of Technical Support and a part-time computer- science faculty member at the University of Nebraska at Omaha. He can be contacted at bill@techsi.com.</I><hr><p>The other day, I was thinking about a college friend of mine whose last name is Hannah. "Don't spell it backwards!" he would always intone me. Which, of course, leads you to realize that it is a palindrome, one of those words that reads the same in both directions.</p><p>Sentences, too, can be palindromes if you remove the punctuation and spaces. "Madam, I'm Adam!" said the man to the woman. Her name was a palindrome as well, so possibly this is an appropriate first thing to say. And how do all of those gifts really get delivered in December? "A Santa at Nasa," of course. Ferdinand de Lesseps, a Frenchman who wanted to link the Atlantic and Pacific, may have had "A man, a plan, a canal, Panama!" in mind when he started to dig. Another Frenchman by the name of Napoleon had earlier mentioned "Able was I 'ere I saw Elba" right before his demise.</p><DDJADVERTISEMENT INLINE><p>It's a common assignment in early programming classes to determine whether a string, assuming the spaces and punctuation are removed, is or is not a palindrome. The basic idea is to take the length of the string, cut it in half, and then examine the first with the last, second with the next to last, and so on. The subject comes up again when learning or teaching about compilers; a compiler grammar for a palindrome makes an excellent and short example for students to visualize what's going on during a language parse. So, when I was out with my coworker, Bob, and my thoughts turned to palindromes, I was thinking about the usual algorithms for detecting them.</p><p>But a subject that does not seem to receive much attention is how to create them in the first place. Certainly, there are a number of gifted linguists, or maybe palindromists, who can retire up to "Ned's den" and churn them out like "so many dynamos." "Was It A Car Or A Cat I Saw?" "Nate bit a Tibetan!"</p><p>Since I do not happen to be a gifted linguist, and rather then let my "rotor" spin endlessly thinking about them, I instead  turned to the task of generating them algorithmically. I started by thinking about short palindromes in general. An obvious first approach is to just start randomly mashing words together and testing them with the simple algorithm to determine if you have a palindrome or not. While this might work for a small dictionary, it becomes impractical rather quickly. If the dictionary has <i>N</i> words in it, a two-word palindrome such as "lion oil" would require one of a possible <i>N</i> first words, with one of a possible <i>N</i> second words, or <i>N</i><sup>2</sup> combinations.</p><p>The number of words strung along in the palindrome is the exponent, and my value of <i>N</i> starts off rather large to begin with. I have a dictionary of 45,812 words that I have accumulated for just such a purpose. For this, <i>N</i><sup>2</sup> is somewhere over 2 billion sentences of two words each. If you want to generate something more substantial with five or six, or even a dozen words, this word-mashing method is not going to work. Also, I would really rather create some longer palindromes&#151;if only because they are more fun.</p><p>Possibly, a better method is to start from what I will call a "seed word" and grow the palindrome out from the seed. For example, consider "LionOil." (I remove the spaces for clarity. I also use mixed case to make it clear where word boundaries are in the palindromes, but they are case-insensitive for the purpose of these experiments.) This string has a central point at the character <i>n</i>, around which the letters are symmetric. Call this character the pivot, and the position, the pivot point. In <i>LionOil</i> the pivot point is three&#151;just count the characters from zero.</p><p>Intuitively, if a seed word has <i>C</i> characters, it would have <i>C</i> pivot points. Actually it has 2<i>C</i>+1 pivot points:</p><ul>  <li>Before the <i>L</i> of Lion, denoted "<IMG SRC="dot10.gif" WIDTH="5" HEIGHT="8">Lion"   <li>At the <i>L</i> of Lion  <li>Between the <i>L</i> and <i>i</i>, denoted "L<IMG SRC="dot10.gif" WIDTH="5" HEIGHT="8">ion"  <li>At the <i>i</i>   <li>Between the <i>i</i> and <i>o</i>, denoted "Li<IMG SRC="dot10.gif" WIDTH="5" HEIGHT="8">on"  <li>And so on.</ul><p>The reason for the added tests is that some words contain complete or partial palindromes to begin with. An example is <i>Ada</i>, with a pivot point of one at the <i>d</i>. But <i>Hannah</i> has a pivot between characters; thus, it is <i>Han</i><IMG SRC="dot10.gif" WIDTH="5" HEIGHT="8"><i>nah</i> with pivot point three.</p><p>Obviously, you can apply the palindrome test from the pivot outwards and quickly determine whether there is even any reason to continue. Getting back to <i>LionOil</i> and the seed word <i>lion</i>, testing <i>Li</i><IMG SRC="dot10.gif" WIDTH="5" HEIGHT="8"><i>on</i> quickly fails because <i>i</i> is not equal to <i>o</i>.</p><p>Conversely, <i>L</i> is not equal to <i>n</i>, but you shall see that it is fortuitous to work from the center outwards.</p><p>So my basic idea was to take a word like <i>Lion</i> and try to grow it out from the pivot point, while moving or changing the pivot point left to right through 2<i>C</i>+1 positions. At each position, one can easily tell whether the string thus far is at least a partial palindrome. And if it is, we can determine where to expand next. A string is a partial palindrome if, working from the pivot point outwards, either the left or right end of the string is encountered before a mismatch occurs.</p><p>Suppose you start with <IMG SRC="dot10.gif" WIDTH="5" HEIGHT="8"><i>Lion,</i> where the pivot is left of the actual word. I can calculate the center of the string, which is position two. The pivot is at zero, so the string is too heavy on the right, but at the moment, <IMG SRC="dot10.gif" WIDTH="5" HEIGHT="8"><i>Lion</i> qualifies as a partial palindrome. The "dot" at the pivot point matches the dot at the pivot point, so there is at least one correct character, albeit the same character. You now wish to prepend words that end with <img src="alpha14.gif"><i>noil</i>, attempting to convert the string to <img src="alpha14.gif"><i>noil.Lion</i>. I use <img src="alpha14.gif"> to mean any string of characters. If you're successful, then you need to locate words starting with <img src="alpha14.gif"> so that they can be appended to the string.</p><p>How you locate words with certain front and back strings will be detailed later. For now, note that there are no words that qualify, at least in my dictionary. Since no words end in <i>noil</i>, the algorithm should try the next best thing, <img src="alpha14.gif"><i>oil</i>. That is, strings ending in <i>oil</i>. Obviously, there is such a string, making a new partial palindrome: <i>Oil</i><IMG SRC="dot10.gif" WIDTH="5" HEIGHT="8"><i>Lion</i>, which is still too heavy on the right. You need to prepend words ending in "<img src="alpha14.gif">n" to try to balance things out again. Suppose you pick <i>Man</i>, generating <i>ManOil.Lion</i>, with too many characters on the left. But you can locate words matching <img src="alpha14.gif"><i>ma</i> to append. </p><p>This process, which makes a nice recursive algorithm, eventually yields, with my punctuation added, "A car, a man, oil, lion, a maraca!" Possibly, this is a party at a circus in Mexico. The pivot is in the center and the letters match out to either end. It is a palindrome and prints from the algorithm as <i>ACarAManOil</i><IMG SRC="dot10.gif" WIDTH="5" HEIGHT="8"><i>LionAMaraca</i>. </p><p>With this general idea, I started to implement a backtracking strategy to grow palindromes from my dictionary of words. A backtracking algorithm is one that is normally implemented recursively, where a partial solution is passed to the algorithm, modified, passed to the same algorithm, modified, and so forth. Backtracking is similar to a depth-first traversal of a tree or graph-data structure. Once a backtracking algorithm finds an answer, it returns from all of the recursion with a True result. </p><p>In the algorithm, backtracking is used to first determine whether the string passed to the function is a partial palindrome; in other words, one that can be grown some more. Receiving <i>Li</i><IMG SRC="dot10.gif" WIDTH="5" HEIGHT="8"><i>on</i> obviously fails immediately, but <i>Lion</i><IMG SRC="dot10.gif" WIDTH="5" HEIGHT="8"> might have some chances. Another example might be <i>Aback</i> with the pivot at the <i>b</i>. So far so good, assuming you can prepend words ending with <i>kc</i>. On the off chance that the string passed to the backtracking algorithm is a complete palindrome, the function just prints that it has found one and returns a True value. This causes all of the recursion to unwind back to the main function.</p><p>Calling the backtracking algorithm with each pivot point in each dictionary word thus starts churning out palindromes.</p><p>Quickly locating words ending in <i>k</i> poses some problems, though. Linearly scanning the dictionary would be far too time consuming. Instead, I devised a combination of lazy binary search when looking up words, and sorting via indirect pointers when initializing the dictionary.</p><p>When the dictionary is set up, it does considerable behind the scenes work. The class constructor reads in the entire dictionary, which is already sorted lexicographically in the file. The dictionary resides in memory for the duration of the program. The constructor then creates two arrays of pointers; the first is one-to-one with the ordering in the dictionary, and is called <i>ltr</i>&#151;left to right. The other array, <i>rtl</i>, is precisely the same, but when sorted, it considers the strings as if they were reversed&#151;right to left. Thus, the last word in <i>ltr</i>, which is <i>zygote</i>, is reversed to <i>etogyz</i> when accessed from the <i>rtl</i> array. It would be located, if it existed, between <i>etiquette</i> and <i>Etruscan</i>.</p><p>Using these two arrays of pointers, you can quickly look for words ending in <i>kc</i>, for example, by doing a lazy binary search on the <i>rtl</i> array and comparing the strings using <i>strncasecmp</i>. Many people do not realize that there are actually a few variations on the binary search theme. The differences are not marked unless there are duplicate keys in the data being searched. But that is the case here&#151;there may be many words ending in <i>kc</i>, and you wish to be able to try each of them in turn from the backtracking algorithm. </p><p>A lazy binary search compares the test string to the dictionary to split the dictionary into keys strictly less than the string or greater than or equal to the string. This continues until there is only one element left, which may or may not be what we are looking for. Overall, it looks like <A NAME="re1"><A HREF="0404de1.htm">Example 1</A>.</p><p>The thing to remember about lazy binary search that it partitions the array into elements strictly less than the search string, or elements greater than or equal to the search string. It is also pessimistic, assuming that it is necessary to whittle the search down to one element before determining its presence. But most important, because of this, it finds the first of potentially many occurrences of the string in the dictionary. From that point, you can iterate through the <i>ltr</i> or <i>rtl</i> indices as needed, either prefixing or appending each word in turn.</p><p>Thus, the overall strategy for the backtracking algorithm is as in <A NAME="rf1"><A HREF="0404df1.htm">Figure 1</A>.</p><p>Once the basic algorithm is constructed, there are a few heuristics that need to be adjusted according to personal preference and running time. Obviously, there are an infinite number of palindromes that can be generated, because, for example, one can keep adding reflections on the front and back of the string; put <i>I</i> on the front, <i>I</i> on the back. Put <i>Was</i> on the front, <i>Saw</i> on the back, and so on. Repeat as needed.</p><p>So, it is entirely possible for a string to grow ad infinitum. Not shown in <A NAME="re1"><A HREF="0404de1.htm">Example 1</A> is a parameter to track the depth of the recursion. If the depth is greater than a set limit, the function just returns False and gives up. This backs up a level. Certainly, you can return False all the way back to the first word, completely failing at palindromes with this seed.</p><p>The second difficulty is in the availability of short words like <i>a</i> or <i>I</i>. It is much more interesting to make an effort to append longer words first, which the algorithm attempts to do. For example, it is more interesting to try words starting with <i>oila</i> instead of just <i>oa</i>, unless the longer attempts all fail. This prevents really bad palindromes with very short words. (And if you are on a UNIX or Linux system, many versions of /usr/dict/words include all single letters as words, which makes the situation considerably worse. Every word is immediately a success after gluing on the appropriate single-letter words.)</p><p>The problem with this approach, though, is that it tends to make palindromes that  are similar, with certain combinations of words appearing often at the front and others at the rear. Another variant is to select a number at random in the range from one through the required length, and search words with this length of matching key. </p><p>Finally, once the algorithm was basically working, it was apparent that certain words quickly dominate, and a palindrome with 15 or 16 words might have the same word included five or more times! Words like <i>a</i> and <i>ad</i> might appear so often that the sentence is a palindrome but also really quite boring. Thus, I imposed a limit on the number of occurrences of an individual dictionary word in a palindrome. Currently, setting this to two or three is plenty, although it prevents the backtracking from finding the Panama canal string discussed at the beginning. But it does find other appealing palindromes such as <i>Panama nap, Ad: "no canal, anaconda!"</i>, and <i>Tibetan, ameba, canal, Lana cab emanate bit</i>. I really have no idea what that last one could mean...</p><p>To implement these ideas, I have implemented the dictionary as a C++ class. A friend class called <i>dict_iterator</i> provides the searching capabilities. The dictionary object itself cannot do this because there needs to be one iterator per recursive call, each remembering where it left off in case subsequent recursive calls fail. A user of the class <i>dict_iterator</i> indicates what the partial key string is, and whether the search should consider the dictionary words in left to right or right to left order. Then, calling a <i>next</i> member function walks through all dictionary words matching the criteria. </p><p>A driver function searches in <i>ltr</i> order starting with an empty string. This generates a sequential listing of each and every word in the dictionary. As each word is found, the 2<i>C</i>+1 possible pivot points are attempted, in turn, as the seed word for growing a palindrome. The backtracking function <i>expand</i> is called with the string, the pivot point, and the current recursive depth. To make the searching faster, the number of bytes in agreement out from the pivot point is passed so that characters already known to be partial palindromes need not be checked again.<i></p><p>expand</i> calls the aforementioned <i>dict_iterator</i> class to scan either the left to right or right to left ordering of words. Each dictionary word has an overloaded "++" and "- -" operator so that the count of that word in the growing string can be incremented if the word is selected, or decremented if it is later removed from the string. This permits the checking of excessive words in a palindrome.</p><p>The entire code (available electronically; see "Resource Center" page 5) is only about 700 lines of C++ and uses the STL for string handling. I did not use the STL for vectors, as the necessity of the dictionary and its friend class for an iterator made it simpler to just do the work in the code. </p><p>The algorithm was compiled and run on a true IBM PC, 1.4 GHz, running Red Hat Linux. It reads-in the dictionary, generates 33,852 palindromes, and exits. The entire process takes about two-and-a-half hours. Implementing with a random number for the length of string to add, the same dictionary generates 16,508 palindromes in about 33 minutes. Many are duplicates, but adding both results, sorting, and eliminating the duplicates leaves 41,501 palindromes. Removing one and two letter words from the dictionary, running again, and merging the results brings the total up to 55,674. </p><p>Here are a few, with punctuation added as best I can:</p><blockquote><p>Nora, adopting nit pod Aaron!</p><p>Allegro, or gel? La!</p><p>Margaretta&#151;fatter! A gram!</p><p>Mussolini los sum...</p><p>A-ha! Mob Omaha!</p><p>Sad...No can anacondas...</p><p>Sam? Oh. Thomas!</p><p>Slip up, pupils.</p></blockquote><p>And then there are a few that are elegant because they are long, but not really that much fun:</p><blockquote><p>Semite mosaic, a cab, a Jamaica cab, a Jamaica cab, besiege is ebb acacia. Ma, jab acacia! Ma, jab acacia! Sometimes.</p><p>Mae tan, ameba, Jamaica, cab, a Caleb, a bet, a generate, tare, negate babe! La cab acacia ma jab emanate am!</p></blockquote><p>The vast majority of these, alas, are boring. And believe me, when reading 56,000 palindromes, you quickly learn to skim the results looking for the gems. But on occasion you are rewarded. The rest of the time, you may as well take a "Panama nap."</p><p><b>DDJ</b></p></body></html>