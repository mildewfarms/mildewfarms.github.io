<html><head><title>Apr04: Tech Tips</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><H1>Tech Tips</H1><p><i>Dr. Dobb's Journal</i> April 2004</p><h3>By Edited by George Frazier</h3><I>George is a software engineer in the System Design and Verification group at Cadence Design Systems. He can be reached at georgefrazier@yahoo.com.</I><hr><h3>Sharing the Clipboard</h3><p><i>by Gigi Sayfan</i></p><DDJADVERTISEMENT INLINE><p>the_gigi@hotmail.com</p><p></p><p>The little program I present here lets multiple computers on a LAN share a clipboard. This is useful in situations where a single person is operating multiple computers at the same time. Think about developing and testing client-server applications, administering several machines through a KVM switch, or simply using one machine for Internet browsing while working on the other. You can even use it for ad hoc instant messaging.</p><p> The trick is to use a shared file as a repository for clipboard content. The ShareClipboard programs that run on each computer monitor both this file and the real clipboard. If the file content has been modified, it means that the clipboard content on some other machine has changed and all the monitoring machines will synchronize. If the clipboard content has changed, the program will place the new content on the shared file for other machines to synchronize.</p><p>I provide two functionally equivalent versions: Python (<A NAME="rl1"><A HREF="#l1">Listing One</A>) and C/C++ (<A NAME="rl2"><A HREF="#l2">Listing Two</A>) (compiled using Visual C++.NET 2003). You will need the win32extensions modules for Python to run the Python version. </p><p>You can download a free and fully functional Python implementation from ActiveState at http://www.activestate.com/Products/ActivePython/.</p><h3>Accessing C-String Representations of Strings in Managed C++</h3><p><i>by Matthew Wilson</i></p><p>matthew@synesis.com.au</p><p></p><p>In Managed C++, you can create instances of a .NET <i>System::String</i> class from C++ C-style strings (null-terminated <i>char/wchar_t const </i>*). However, getting a null-terminated C-style string from a <i>String</i> is much less simple. Since <i>String</i>s may not use the same encoding that you want, or store the characters contiguously, or be null terminated, it is not as simple as returning a pointer.</p><p>If you have the spare time, you can create a <i>char/wchar_t</i> buffer of the appropriate length, and then use the <i>Char</i>s property (the <i>String::get_Chars()</i> method in Microsoft C++) to retrieve each character, thereby manually building you a C-string. Tedious.</p><p>The .NET libraries have thought about this for you, and provided you with the <i>System::Runtime::InteropServices::Marshal </i>methods <i>StringToHGlobalAnsi()</i>, <i>StringToHGlobalUni()</i>, and <i>FreeHGlobal()</i>, which are used as in <A NAME="rl3"><A HREF="#l3">Listing Three</A>(a). The pointer returned from <i>StringToHGlobalAnsi()</i> is not part of the managed heap and must be free, by the call to <i>FreeHGlobal()</i>. This is classic resource-scoping, where the native pointer may be leaked if an exception is thrown before it is freed, and is crying out for a touch of Resource Acquisition Is Initialization.</p><p>The STLSoft subproject .netSTL (http://dotnetstl.org/) contains just such a scoping class, in the form of the template c_string_accessor, defined in <A NAME="rl4"><A HREF="#l4">Listing Four</A>. This simplifies the code (both in terms of lines of code, and in removing the need to "use" the <i>System::Runtime::InteropServices::Marshal</i> type), as well as handling exceptional circumstances. <A NAME="rl3"><A HREF="#l3">Listing Three</A>(a) changes to <A NAME="rl3"><A HREF="#l3">Listing Three</A>(b).</p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>#!/usr/local/bin/pythonimport timefrom win32clipboard import *id = 0clipboard_file = r'\\home\Clipboard\clipboard.txt'prev_data = ''while (True):   time.sleep(1)   if OpenClipboard() != None:      print 'OpenClipboard() failed'      continue   try:      data = prev_data      if    IsClipboardFormatAvailable(CF_TEXT):         data = GetClipboardData()      if data != prev_data:         open(clipboard_file, 'w').write(data)         print 'writing %s to file' % data         prev_data = data      else:         data = open(clipboard_file, 'r').read()         if data != prev_data:            EmptyClipboard()            SetClipboardData(CF_TEXT, data)            print 'putting %s in clipboard' % data            prev_data = data      CloseClipboard()   except:      pass</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>#include &lt;fstream&gt;#include &lt;iostream&gt;#include &lt;string&gt;int APIENTRY _tWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,                     LPTSTR lpCmdLine, int nCmdShow){   const char * clipboard_file = "\\\\home\\Clipboard\\clipboard.txt";   std::string prev_data;   std::string data;   while (true)   {      ::Sleep(1000);      if (::OpenClipboard(0) == FALSE)         continue;      data = prev_data;      if (::IsClipboardFormatAvailable(CF_TEXT) != FALSE)      {         HANDLE h = ::GetClipboardData(CF_TEXT);         if (h)         {            const char * buf = (const char *)::GlobalLock(h);            data = buf;            if (!data.empty())               ::GlobalUnlock(h);         }      }      if (data != prev_data)      {         std::ofstream f(clipboard_file);         if (!f.is_open())         {            ::CloseClipboard();            continue;         }         f &lt;&lt; data;         f.close();         prev_data = data;      }      else      {         std::ifstream f(clipboard_file);         if (!f.is_open() || f.eof())         {            ::CloseClipboard();            continue;         }         data = "";         char c;         f.get(c);         while(!f.eof())         {            data += c;            f.get(c);         }         f.close();         if (data != prev_data)         {            BOOL rc = ::EmptyClipboard();            if (rc == FALSE)            {               ::CloseClipboard();               continue;            }            HGLOBAL hMem = ::GlobalAlloc(GMEM_MOVEABLE, data.length()+1);            void * buf = ::GlobalLock(hMem);            ::memcpy(buf, (const void *)data.c_str(), data.length()+1);            ::GlobalUnlock(hMem);            HANDLE h = ::SetClipboardData(CF_TEXT, hMem);            if (h == NULL)            {               ::CloseClipboard();               continue;            }            prev_data = data;         }      }      ::CloseClipboard();   }}</pre><P><A HREF="#rl2">Back to Article</A></P><H4><A NAME="l3">Listing Three</H4>(a)<pre>using System::String;using System::Runtime::InteropServices::Marshal;String  *s = ... // get a string from somewherechar  *ansi = (char*)(Marshal::StringToHGlobalAnsi(s).ToPointer());puts(ansi);Marshal::FreeHGlobal(ansi);</pre>(b)<pre>using dotnetstl::c_string_accessor;String  *s = ... // get a string from somewhereputs(c_string_accessor&lt;char&gt;(s));</pre><P><A HREF="#rl3">Back to Article</A></P><H4><A NAME="l4">Listing Four</H4><pre>template &lt;typename C&gt;class c_string_accessor{public:  typedef C                     char_type;  typedef C                     *pointer;  typedef C const               *const_pointer;  typedef c_string_accessor&lt;C&gt;  class_type;// Constructionpublic:  ///   explicit c_string_accessor(System::String *s)    : m_s(_get_cstring(s))  {}  ~c_string_accessor()  {    System::Runtime::InteropServices::Marshal::FreeHGlobal(m_s);  }// Implementationpublic:  operator const_pointer() const  {    return m_s;  }// Implementationprivate:  pointer _get_cstring(System::String *s);// Membersprivate:  pointer m_s;// Not to be implementedprivate:  c_string_accessor(class_type const &amp;);  c_string_accessor &amp;operator =(class_type const &amp;);};// Specialization for chartemplate &lt;&gt;inline c_string_accessor&lt;char&gt;::pointer    c_string_accessor&lt;char&gt;::_get_cstring(System::String *s){  return reinterpret_cast&lt;char*&gt;(System::Runtime::      InteropServices::Marshal::StringToHGlobalAnsi(s).ToPointer());}// Specialization for wchar_ttemplate &lt;&gt;inline c_string_accessor&lt;wchar_t&gt;::pointer    c_string_accessor&lt;wchar_t&gt;::_get_cstring(System::String *s){  return reinterpret_cast&lt;wchar_t*&gt;(System::Runtime::      InteropServices::Marshal::StringToHGlobalUni(s).ToPointer());}</pre><P><A HREF="#rl4">Back to Article</A></P></body></html>