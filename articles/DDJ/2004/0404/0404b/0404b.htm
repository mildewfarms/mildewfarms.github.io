<html><head><title>Apr04: Simulating  Small-World Networks</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Simulating  Small-World Networks</h1><p><i>Dr. Dobb's Journal</i> April 2004</p><h2>Algorithms for studying everything from movie stars to electrical grids</h2><h3>By Mary Lynn Reed</h3><I>Mary Lynn is a mathematician, programmer, and writer who lives in Tampa, Fl. She can be reached at marylynnreed@ yahoo.com.</I><hr><p>Remember the last time you met someone and suddenly realized there was something major you had in common&#151;a city you'd both lived in or a mutual friend or acquaintance you shared? </p><p>"Small world," you said to your new acquaintance as you both pondered the odds. It turns out that the odds are pretty good, and these "small worlds" are everywhere. Studying this small-world phenomenon started out as a psychology experiment in the 1960s. With today's data and computer power, it's now a serious science.</p><DDJADVERTISEMENT INLINE><p>Physicists, biologists, mathematicians, and computer scientists have joined the sociologists and psychologists in studying and modeling small-world networks. While each of these specialists has their own scientific reason to be interested in small worlds, they all have the desire to simulate small-world networks. In this article, I examine a few of the most popular algorithms for simulating small-world networks, and show how you can grow your own networks.</p><h3>What Is a Small-World Network?</h3><p>One popular example of a small-world network today is the movie actor's network. In all likelihood, you've played the Six Degrees of Kevin Bacon game. Pick a celebrity&#151;any celebrity, even a dead one. The game is to connect your celebrity to Kevin Bacon in the fewest steps possible by naming other celebrities and the movies they've starred in together. What makes the game interesting is that it can be challenging to find the path between Kevin Bacon and your celebrity, but it is there! Here's an example. Doris Day. A tough one, right? </p><p>It turns out Doris Day is only two degrees of separation from Kevin Bacon. She was in <i>It Happened to Jane</i> in 1959 with Jack Lemmon, who was in <i>JFK</i> in 1991 with Kevin Bacon. (The University of Virginia has an entertaining on-line version of this game at http://www.oracleofbacon .org/. For kicks, you can code one up yourself with data from the Internet Movie Database, http://www.imdb.com/, and a shortest path algorithm.)</p><p>The movie actor's network is one example of a small world. It can be represented mathematically as a graph (a collection of nodes and edges). In this case, nodes are movie actors and an edge connects two actors when they've appeared in a movie together. This graph has the property that the length of the shortest path between any two nodes is pretty small (usually less than 3 or 4 and almost always less than 6 or 7). <A NAME="rf1"><A HREF="0404bf1.htm">Figure 1</A> illustrates a small piece of the movie actor's network. (Can you figure out what movies all of the edges represent?)</p><h3>Why Do Scientists Care About This?</h3><p>Serious scientists care about small-world networks because they appear to be everywhere&#151;and scientists love unifying theories. The Web, for example, is a small-world network (nodes are web pages and edges are the links between them). Of course, navigating the Web is important for lots of folks&#151;and it turns out that the best search engines today are exploiting the linked nature of the Web. There are also examples of small-world networks in the growing field of computational biology. Protein networks are the most studied (nodes are proteins and edges are bindings between them). Other well-studied small-world networks include scientific coauthorship graphs (the only thing scientists love more than unifying theories are their own papers). Nodes in a coauthorship graph are authors of papers and an edge between two nodes represents a coauthored paper.  </p><p>Many small-world networks affect our lives in major ways. The power grid that supplies electricity is one example. In this case, the nodes are generators, transformers, and substations, and the edges are the high-voltage transmission lines between them. The airport network is another interesting example. The nodes are the airports and the edges are the nonstop flights between them. Even proteins have small-world networks: <A NAME="rf2"><A HREF="0404bf2.htm">Figure 2</A> illustrates a small part of the yeast protein network.</p><h3>Small Worlds and Power-Laws</h3><p>If you think about all of these examples of small-world networks, one thing they all have in common is the concept of a "hub." Some nodes are more popular than others and have many more edges passing through them. This is a key element of small-world networks and it leads to other interesting mathematical properties that many of these networks have in common. The most important of those properties is something called a "power-law degree distribution." The "degree" of a node is defined to be the number of edges connected to it. In <A NAME="rf1"><A HREF="0404bf1.htm">Figure 1</A>, for example, Clint Eastwood has degree three. Every network has a "degree distribution," which is simply a function taking a degree to the number of nodes in the network that have that degree. <A NAME="rt1"><A HREF="0404bt1.htm">Table 1</A> illustrates the degree distribution of the tiny network in <A NAME="rf1"><A HREF="0404bf1.htm">Figure 1</A>. Also, the nodes in <A NAME="rf1"><A HREF="0404bf1.htm">Figure 1</A> are color coded by their degree. (For example, Doris Day and Kevin Bacon both have degree two and their nodes are both shaded yellow.)</p><p>A power-law degree distribution is a degree distribution that follows a power-law. In algebraic terms, if <i>X</i><i><sub>k</i></sub> denotes the number of nodes with degree <i>k</i>, then <i>X</i><i><sub>k</i></sub><i> </i>follows a power-law if <i>X</i><i><sub>k</i></sub> is proportional to <i>k</i><i><sup>-a</i></sup>. In graphical terms, if you plot <i>k</i> versus <i>X</i><i><sub>k</i></sub> on log-log paper, then the distribution follows a power-law if the log-log plot is roughly linear. <A NAME="rf3"><A HREF="0404bf3.htm">Figure 3</A> illustrates the log-log plot of the degree distribution of the yeast protein network in <A NAME="rf2"><A HREF="0404bf2.htm">Figure 2</A>.  </p><h3>First Simulation</h3><p>What does all this have to do with programming? Well, it is not just about efficient algorithms for finding the shortest path to Kevin Bacon in the movie actor network. Scientists want to simulate their small worlds to better understand them. Consequently, they've developed models and algorithms for doing just that. To simulate the networks, the scientific theory must be turned into computer code. That's where the fun begins. The algorithms presented in this article are simple and easy to implement in any language. I chose to demonstrate them here in Perl, mainly for the built-in hash data structure.</p><p>Start by simulating something simple&#151;a completely random network. Granted, random networks aren't good models for small-world networks, but this is just a starting point. In the 1950s, mathematicians Erd&ouml;s and R&eacute;nyi introduced the notion of a random graph. A random graph has two parameters&#151;<i>N</i>, the number of nodes that will be in the graph, and <i>p</i><i><sub>,</i></sub> the probability that any pair of nodes will be connected. To simulate a random graph, you generate a random number <i>r</i> for every pair of nodes. If <i>r&lt;p</i>, then you place an edge between that pair of nodes; otherwise, no edge is placed between the pair of nodes. <A NAME="rl1"><A HREF="#l1">Listing One</A> implements this algorithm.</p><p>Simulating a random graph is so straightforward&#151;you don't even have to hold the graph in a data structure. You can just print out the edges as they are simulated. In <A NAME="rl1"><A HREF="#l1">Listing One</A>, there are a few <i>print</i> statements  that probably seem unnecessary. Of course, there is a reason for them. The output from <A NAME="rl1"><A HREF="#l1">Listing One</A> is a graph in "dot" format, a special format for graphs that is used by the Graphviz open-source graph drawing and visualization package developed by AT&amp;T Lab researchers (http://www.research.att.com/sw/tools/graphviz/).</p><p>Once you have Graphviz installed, you can run <A NAME="rl1"><A HREF="#l1">Listing One</A> and pipe the output into a file called (for instance) ER.dot. Then use the Neato graph visualization program (that comes with Graphviz) with ER.dot as your input. To produce <A NAME="rf4"><A HREF="0404bf4.htm">Figure 4</A>, I used the command:</p><blockquote><p>&gt; neato -Tps -Gcenter -Gsize="6,6" ER.dot -o ER.ps</p></blockquote><h3>A First Small-World Model</h3><p>One of the first mathematical models built specifically for small-world networks was the Watts-Strogatz model. It is a brilliantly simple model that provides the ability to calibrate between a ring lattice (a completely structured regular graph) and a random graph. The motivation for this approach was to model a few properties that Watts and Strogatz discovered in real social networks. The first property was the "small-world property"&#151;the existence of short paths between most nodes in the network. The other property was something they called "clustering." In a network with a high clustering coefficient if two nodes are connected to a common node, then the two original nodes are likely to be connected to each other. This is a common phenomenon in social networks. It shouldn't be a surprise that in many real situations, cliques form. Friends come in groups larger than two. That is the central notion behind clustering.</p><p>In this initial Watts-Strogatz small-world model, the idea of a power-law degree distribution was not considered. As a result, the graphs simulated with the Watts-Strogatz algorithm do not possess this property. But it is a nifty model that has generated an enormous amount of enthusiasm in the scientific community.  </p><p>There are three parameters to the Watts-Strogatz model. <i>N</i> is the number of nodes in the graph you want to simulate. <i>K</i> is the degree of each node at the initial step of the algorithm. And <i>p</i> is the probability of randomly rewiring each edge in the second step of the algorithm.</p><p>1.	The Initial Step in the Watts-Strogatz model is to start with <i>N</i> nodes. Place them in a "ring." Connect every node to its <i>K</i> neighbors (<i>K/</i>2 on each side). This is called a "ring lattice" on <i>N</i> nodes with degree <i>K</i>.</p><p>2.	Next is the Randomization Step, where you randomly rewire each edge with probability <i>p</i> such that self-connections and duplicate edges are excluded.</p><p></p><p>That's it. Simple, but powerful. <A NAME="rl2"><A HREF="#l2">Listing Two</A> is my Perl implementation of this model. Notice that this algorithm does require storing the graph in a data structure. Since I'm using Perl, I have access to a double hash structure that is perfect for this job. This method may not prove scalable enough to simulate massive graphs, but will easily handle moderately large graphs. And the state-of-the art graph visualization algorithms will bog down long before Perl's ability to store a graph during  simulation.</p><p><A NAME="rf5"><A HREF="0404bf5.htm">Figure 5</A> is a graph simulated by the Watts-Strogatz model with <i>N=</i>80, <i>K=</i>2, and <i>p=</i>0.3.  </p><h3>The Rich Get Richer</h3><p>Another group of scientists took a different approach to modeling small-world networks. Barab&aacute;si and Albert developed a model they called the "Scale-Free Model" that uses the age-old notion of "the rich get richer, while the poor stay poor" to explain the power-law degree distribution present in many real networks. Barab&aacute;si and Albert didn't want a model that started with <i>N</i> nodes, like the Watts-Strogatz algorithm. Instead, they wanted to grow a network over a series of time steps. Remarkably, graphs simulated with their basic "growth by preferential attachment" algorithm all end up with power-law degree distributions.  </p><p>There are really only two parameters to the Barab&aacute;si/Albert algorithm, <i>m</i><i><sub>0 </i></sub>and <i>m.m</i><i><sub>0</i></sub> is the number of nodes present at time <i>0</i>. (There are no edges present at time <i>0</i>.) <i>m</i> is the number of edges added at each time <i>t</i>. I add a third parameter, <i>N</i>, which will be the final number of nodes in the graph. By specifying <i>N</i> at the start, this determines how many time steps to take in the simulation algorithm. Here are the details of the Barab&aacute;si and Albert (Scale-Free) Model:</p><p>1.	Growth. Start with a small number (<i>m</i><i><sub>0</i></sub>) of nodes. At every time step, add a new node with <i>m(<IMG SRC="lteq12.gif" WIDTH="6" HEIGHT="7">m</i><i><sub>0</i></sub><i>)</i> edges that link the new node to <i>m</i> nodes in the network.</p><p>2.	Preferential Attachment. At each time step, choose the <i>m</i> nodes to connect to the new node by giving preference to the nodes with larger degrees. Specifically, the probability that a new node will connect to a node with degree <i>k</i> will be <i>k</i> divided by the sum of the degrees of all the nodes in the graph.    </p><p></p><p>At time <i>t</i>, there will be <i>N = t + m</i><i><sub>0 </i></sub>nodes in the graph and <i>mt</i> edges.  </p><p><A NAME="rl3"><A HREF="#l3">Listing Three</A> is my Perl implementation of the Barab&aacute;si/Albert simulation algorithm. To keep the code simple, I don't test whether the <i>m</i> nodes that are connecting to the new node are all different. Simple variations to a model's implementation like this can have a significant impact on the graphs you can simulate. </p><p><A NAME="rf6"><A HREF="0404bf6.htm">Figure 6</A> is a graph simulated from this algorithm with <i>N=</i>500, <i>m</i><i><sub>0</i></sub>=10, and <i>m</i>=1. <A NAME="rf7"><A HREF="0404bf7.htm">Figure 7</A> is the log-log plot of the degree distribution of this simulated graph, which demonstrates that this algorithm does produce graphs that have a power-law degree distribution.  </p><h3>New Models, New Science</h3><p>The models I've described in this article are just the tip of the iceberg in simulating small-world networks. Interesting new properties are being discovered in real-world networks all the time. As new properties are discovered, new models are needed that can simulate graphs with those properties. It is an exciting new science that is relying on clever algorithms and computer simulations for experimentation and discovery. You can start by searching the science literature for "complex networks" or "small worlds." Develop new models, tweak old ones, code them up. Who knows. You could discover the next big thing. </p><h3>Bibliography</h3><p>Barab&aacute;si, A.L. and R. Albert, "Emergence of Scaling in Random Networks," <i>Science</i>, 286, 509-512 (1999).</p><p>Milgram, S. "The Small World Problem," <i>Psychology Today</i> 2, 60-67 (1967).</p><p>Watts, D.J. and S.H. Strogatz, "Collective Dynamics of 'Small-World' Networks," <i>Nature</i>, 393, 440-442 (1998). </p><p>Xenarios I, Rice D.W., Salwinski L., Baron M.K., Marcotte E.M., Eisenberg D. (2000) "DIP: The Database of Interacting Proteins." <i>Nucleic Acids Research</i> 28:289-91. The DIP database is available online at http://dip.doe-mbi.ucla.edu/dip/Main.cgi.</p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>#!/usr/bin/perl# Generate an Erdos-Renyi Random Graph with $N nodes # and edge probability $p using random seed $seed$N = 50;$p = 0.2;$seed = 11967;print "graph ER { \n";print "node [shape=point,color=blue,width=.1,height=.1];\n";srand($seed);foreach $i (1..$N){    foreach $j ($i+1..$N){      $r = rand();      if($r &lt; $p){        print "$i -- $j;\n";      }      }}print "}\n";</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>#!/usr/bin/perl# Generate a Watts-Strogatz Small World Network# with $N nodes, starting degree $K, and probability of rewiring $p$N = 80;$K = 4;$p = .3;$seed = 189123;print "graph WS { \n";print "node [shape=point,color=blue,width=.1,height=.1];\n";srand($seed);# initial step -- set up ring lattice with $N nodes, each of degree $Kforeach $i (0..$N-1){    $left = int($K/2); # num nodes to connect to left    $right = $K - $left; # num nodes to connect to right    foreach $j (1..$left){      $ln = ($i-$j) % $N;           $graph{$i}{$ln} = 1;          $graph{$ln}{$i} = 1;        }    foreach $j (1..$right){      $rn = ($i+$j) % $N;           $graph{$i}{$rn} = 1;          $graph{$rn}{$i} = 1;        }}# Rewire each edge with probability $pforeach $i (keys %graph){       foreach $j (keys %{$graph{$i}}){      $r = rand();          if($r &lt; $p){        # randomly select a new node $jnew to connect to $i        $done = 0;              while(!$done){           $jnew = int($N*rand());            if( ($jnew != $i) &amp;&amp; ($jnew != $j) ){              $done = 1;                          }        }           # remove edge $i &lt;-&gt; $j        undef $graph{$i}{$j};               undef $graph{$j}{$i};               # add edge $i &lt;-&gt; $jnew        $graph{$i}{$jnew}++;                $graph{$jnew}{$i}++;              }    }}# print graphforeach $i (keys %graph){       foreach $j (keys %{$graph{$i}}){                print "$i -- $j\n";         }}print "}\n";      </pre><P><A HREF="#rl2">Back to Article</A></P><H4><A NAME="l3">Listing Three</H4><pre>#!/usr/bin/perl# Generate a Barabasi-Albert Scale-Free Network with $N nodes,# starting with $m_0 nodes and adding $m edges at each timestep$N = 500;$m_0 = 10;$m = 1;$seed = 5255221;print "graph BA { \n";print "node [shape=point,color=blue,width=.1,height=.1];\n";srand($seed);# start with $m_0 nodes and no edges. First step--add 1 node and $m new edges# no preferential attachment here since no edges exist yetforeach $i (1..$m){    # select one of first $m_0 nodes (labeled 0..$m_0-1) to attach to node $m_0    $j = int($m_0*rand());        $graph{$m_0}{$j} = 1;        $graph{$j}{$m_0} = 1;    }# Preferential Attachment Growth$num_steps = $N - $m_0 - 1;foreach $t (1..$num_steps){    $new_node = $m_0 + $t;        #calculate degree seq and sum of degrees    $sumdeg = 0;        if(exists $graph{$i}){        $degree{$i} = keys %{$graph{$i}};             } else {          $degree{$i} = 0;              }      $sumdeg += $degree{$i};         }        foreach $j (1..$m){    # preferentially select node    $R = int($sumdeg*rand());       $cS = 0;    $i = 0;     while($cS &lt; $R){        $cS += $degree{$i};        $i++;           }    $sel_node = $i ? $i-1 : 0;      # add edge $new_node &lt;-&gt; $sel_node    $graph{$new_node}{$sel_node} = 1;       $graph{$sel_node}{$new_node} = 1;     }}# print graphforeach $i (keys %graph){       foreach $j (keys %{$graph{$i}}){                print "$i -- $j\n";         }}print "}\n";                 </pre><P><A HREF="#rl3">Back to Article</A></P></body></html>