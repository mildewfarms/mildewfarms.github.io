<html><head><title>Feb04: Integrating XML Web Services with VB6 Applications</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Integrating XML Web Services with VB6 Applications</h1><p><i>Dr. Dobb's Journal</i> February 2004</p><h2>Putting the SOAP Toolkit to work</h2><h3>By Max I. Fomitchev</h3><I>Max is the author of .NET Programming with Visual C++ and can be contacted at fomitchev@cox.net.</I><hr><p>While VB .NET supports web-service integration natively with Visual Studio .NET, no such built-in support exists for VB6. Consequently, you must use the Microsoft SOAP Toolkit if VB6 clients are to consume web services. In this article, I present a method and a couple of scenarios that illustrate how legacy VB6 applications can consume web services written in C++. The complete UltraMaxService web service, which I present as an example along with a sample VB6 consumer application, is available electronically; see "Resource Center" (page 5).</p><p>The easiest way to integrate XML web services with VB6 applications involves installation of Microsoft's freely available SOAP Toolkit 3.0 (http://msdn.microsoft.com/library/default.asp?url=/downloads/ list/websrv.asp). Although the SOAP Toolkit was originally designed to provide XML web-service functionality for existing COM components (that is, to convert COM components into XML web services), it can also be used for consuming virtually any web service designed from scratch.</p><DDJADVERTISEMENT INLINE><p>The first SOAP Toolkit scenario involves wrapping existing COM components as web services for replacing an existing COM-server/COM-client integration with an instantly distributed web-service provider/web-service consumer architecture. In this case, you must install the Toolkit on both the server and client machines. On the server, the SOAP Toolkit provides a SOAP wrapper for registered COM components by means of the <i>SoapServer</i> object. On the client, the Toolkit serves as an interface between SOAP messages and COM method calls by means of the <i>SoapClient</i> client. The <i>SoapServer</i> and <i>SoapClient</i> objects communicate with each other by means of SOAP messages, and perform mapping of the SOAP messages into COM method calls internally. Wrapping COM components as web services usually involves running the WSDL Generator program (included with the Toolkit) to generate Web Service Description Language (WSDL) and Web Service Meta Language (WSML) files for existing registered COM components. The resulting WSDL/WSML pair can be used by the <i>SoapClient</i> object to consume the COM-generated web service (see <A NAME="rf1"><A HREF="0402bf1.htm">Figure 1</A>).</p><p>While the WSDL file adheres to a standardized web-service description (http://www.w3.org/TR/wsdl12/), the WSML file is a pure Microsoft extension for mapping the web-service methods (SOAP actions) described in the WSDL into COM method calls.</p><p>A second SOAP Toolkit scenario involves consuming existing XML web services. In this case, you only need to install the Toolkit on a client machine and rely on the <i>SoapClient</i> object for parsing, generating SOAP messages, and masquerading web-method invocations as ordinary COM method calls. Here, you should rely on the WSDL file provided by the web service itself, and a WSML file is generally not required.</p><h3>Consuming Web Services in VB6</h3><p>To consume web services in VB6, you must create an instance of the <i>SoapClient</i> object and initialize the object by invoking the <i>mssoapinit</i> method and specifying the URL of the web-service WSDL file. Assuming that a reference to the Microsoft Soap Type Library (mssoap1.dll) has been added to the VB6 project, <A NAME="rl1"><A HREF="#l1">Listing One</A> consumes a C++/ATL web service with dynamically generated WSDL. The URL of the web-service WSDL file can correspond to a local file&#151;UltraMax.wsdl or C:\Projects\UltraMax.wsdl, for instance. Once the <i>SoapClient</i> object is initialized, you can invoke web-service methods directly on the <i>SoapClient</i> object instance (<A NAME="rl2"><A HREF="#l2">Listing Two</A>) where the <i>LogOn</i> is one of the UltraMax web-service methods.</p><p>Because web-service methods are resolved dynamically by parsing the web-service WSDL, these methods are not available in the dropdown list of object methods provided by the VB6 editor. Therefore, you must examine the web-service WSDL (or any other pertinent web-service documentation) for information on the available web methods and their parameters. <A NAME="rt1"><A HREF="0402bt1.htm">Table 1</A> summarizes the <i>SoapClient</i> object properties and methods. Note that the <i>SoapClient</i> object provides data properties such as <i>detail, faultactor, faultcode, </i>and <i>faultstring</i> for conveying SOAP fault information. These properties are set when a SOAP fault occurs, which typically corresponds to a web-service or communication error. If in response to invoking a web-service method the <i>SoapClient</i> object receives a SOAP fault message, it raises an error, which can be caught using <i>On Error GoTo</i> (see <A NAME="re1"><A HREF="0402be1.htm">Example 1</A>). You usually get SOAP faults when calling nonexistent web-service methods or when supplying incorrect web-service parameters.</p><h3>SOAP Type Mapping</h3><p>Although the SOAP Toolkit enables invoking web-service methods with minimal effort, additional code is required to handle complex user-defined types. The <i>SoapClient</i> object automatically parses web-service method parameters corresponding to primitive types, such as <i>String, Long, Single, Date,</i> and so on (in VB6 terms), but represents output parameters corresponding to hierarchical data structures as XML DOM objects. For automatic parsing of complex user-defined types (UDTs), you must develop a custom type-mapper object and register it in the WSML file used to initialize a <i>SoapClient</i> instance.</p><p>To create a type-mapper class, you create a new VB6 COM DLL containing a:</p><ul>  <li>Simple class corresponding to a UDT being mapped.  <li>Type-mapper class implementing the <i>ISoapTypeMapper</i> interface.</ul><p>The created VB6 project should reference the Microsoft Soap Type Library (mssoap1.dll) and Microsoft XML 3.0 (msxml3.dll). The <i>ISoapTypeMapper</i> interface allows specifying how an arbitrary data type is serialized to or deserialized from XML. <A NAME="rt2"><A HREF="0402bt2.htm">Table 2</A> summarizes the <i>ISoapTypeMapper</i> interface methods.</p><p>To illustrate complex type mapping, consider the simple complex type <i>FileInfo</i> defined as in <A NAME="rl3"><A HREF="#l3">Listing Three</A>(a), and the corresponding type-mapper class <i>FileInfoMapper</i> in <A NAME="rl3"><A HREF="#l3">Listing Three</A>(b). </p><p>When implementing the custom type-mapper class, you must override all four <i>ISoapTypeMapper</i> methods that by default perform serialization/deserialization of a single <i>String</i> value.</p><p>The <i>mStringMapper</i> member corresponding to a default <i>ISoapTypeMapper</i> implementation is used to serialize/deserialize individual properties of the <i>FileInfo</i> class, which must be serialized and deserialized in the same order.</p><p>A more sophisticated example involves a situation when a complex type contains other complex types as members. Consider the <i>SongInfo</i> type in <A NAME="rl4"><A HREF="#l4">Listing Four</A>(a), which contains a property of the <i>FileInfo</i> type. <A NAME="rl4"><A HREF="#l4">Listing Four</A>(b) is required for the <i>SongInfoMapper</i> object to serialize/deserialize <i>SongInfo</i> to/from XML. The <i>SongInfoMapper</i> class contains an additional member <i>mFileInfoMapper</i> of type <i>FileInfoMapper</i> to serialize/deserialize <i>FileInfo</i> structure independently. The <i>mFileInfoMapper</i> member must be initialized in the <i>ISoapTypeMapper_Init</i> method and its corresponding <i>ISoapTypeMapper_ Init</i> must be invoked with the same parameters as the parent <i>ISoapTypeMapper_Init</i> call.</p><p>When it comes to serializing the <i>MP3Info</i> member, the <i>mFileInfoMapper.ISoapTypeMapper_write</i> method is invoked to serialize the nested complex type, and the <i>mFileInfoMapper.ISoapTypeMapper_read</i> method is invoked for deserialization. Since the <i>FileInfoMapper</i> class is used explicitly in the <i>SongInfoMapper</i> class its methods must be declared as <i>Public,</i> whereas <i>SongInfoMapper</i> methods can be declared as <i>Private.</i></p><p>When the type-mapper classes are ready, you next create a WSML file to associate the type-mapper classes with the UDTs in SOAP messages.</p><h3>WSML Files</h3><p>The main purpose of WSML files is to define how COM object methods are mapped into web methods, which is necessary only for SOAP-wrapped COM components. An additional function of a WSML file, which comes in handy for both SOAP-wrapped and generic web services, is to specify type-mapping handler classes for UDTs.</p><p>To enact type mapping for the <i>FileInfo</i> and <i>SongInfo</i> types for the UltraMaxService web service, the contents of the associated WSML file must be like <A NAME="rl5"><A HREF="#l5">Listing Five</A>. The <i>&lt;servicemapping&gt; </i>element wraps the <i>&lt;service&gt;</i> element, which defines operation and type mapping for a particular web service. Therefore, the name attribute of the <i>&lt;service&gt;</i> element must be set to the name of a web service for which the mapping is created (that is, the same as the name in the <i>&lt;service&gt;</i> element specified in the web-service WSDL file).</p><p>The series of <i>&lt;using&gt;</i> elements describes COM objects involved in type mapping and web-method (that is, SOAP operation) mapping. The PROGID attribute of the <i>&lt;using&gt;</i> element specifies the COM object textual name, while the ID attribute specifies the object's alias, which is going to be used throughout the WSML file. The cachable attribute of the <i>&lt;using&gt;</i> element specifies whether the COM component is kept in memory as long as the corresponding <i>SoapServer</i> instance is in memory. The cachable attribute is ignored for apartment and single-threaded COM components, however.</p><p>The <i>&lt;types&gt;</i> section is responsible for type mapping. The section contains a series of <i>&lt;type&gt; </i>elements, with each element specifying a concrete type-mapper handler for a particular UDT. The name attribute of a<i> &lt;type&gt;</i> element specifies the type name the way it is spelled in the web-service WSDL file, while the <i>targetNamespace</i> attribute specifies the namespace in which the complex type is defined. The value of the <i>targetNamespace</i> attribute should be extracted from the web-service WSDL file and, if the complex type is defined in the web- service WSDL itself, it is usually formatted as <i>urn:&lt;WebServiceName&gt;.</i> Lastly, the <i>uses</i> attribute specifies the ID of a COM component used for type mapping defined in one of the preceding <i>&lt;using&gt;</i> elements.</p><p>To enact the type mapping when invoking web-service methods, the URL of the resulting WSML file must be specified as a parameter to the <i>mssoapinit</i> call for initializing of the <i>SoapClient</i> object:</p><blockquote><p>Dim WebService As New MSSOAPLib.SoapClient</p><p>WebService.mssoapinit _</p><p> http://www.UltraMax-Music.com/</p><p>   UltraMax.dll?Handler=GenUltraMaxWSDL, , , _</p><p> http://www.UltraMax-Music.com/UltraMax.wsml</p></blockquote><p>Again, the actual location of the WSML file is not important: The file can be stored either on the server along with the corresponding web-services files, or reside locally on the client side.</p><h3>Session State with SOAP Headers</h3><p>A principle difference between COM components and web services is that the state of a web service is not preserved between web-method calls automatically. To enable state persistence, a web service must contain some kind of built-in session-state support. Furthermore, to ensure proper discrimination between sessions originating from different clients, session identifiers must be communicated between a web service and its clients.</p><p>When programming with ASP the session ID is usually communicated via a cookie. With web services, however, it is possible to communicate session ID in the SOAP header, which is easier in our case.</p><p>To make sure that the web-service client can receive and submit session ID with each web-method call, the <i>SoapClient</i> interface provides the <i>HeaderHandler</i> property, which can be initialized with a user-defined class for generating/parsing SOAP headers implementing the <i>IHeaderHandler</i> interface. <A NAME="rt3"><A HREF="0402bt3.htm">Table 3</A> lists members of the <i>IHeaderHandler</i> interface.</p><p>When implementing the <i>IHeaderHandler</i> interface, you must override all <i>IHeaderHandler</i> interface methods. If the session ID is communicated in a SOAP header element called <i>m_SessionID,</i> <A NAME="rl6"><A HREF="#l6">Listing Six</A> is the <i>SessionHeader</i> class implementing the <i>IHeaderHandler</i> interface.</p><p>The <i>IHeaderHandler_readHeader</i> function is called for each data element found in the received SOAP header. Therefore, it is necessary to examine the <i>baseName</i> attribute of the <i>IXMLDOMNode</i> to make sure that the currently processed SOAP header element is the one you are interested in. It is possible to read several SOAP header elements in this function by adding more case comparisons on element <i>baseName</i>.</p><p>The <i>IHeaderHandler_willWriteHeaders</i> method should return True because it is necessary to transmit session ID back to web service for proper session identification.</p><p>The <i>IHeaderHandler_readHeader</i> method simply serializes the SOAP header element called <i>m_SessionID</i> into an appropriate section of a transmitted SOAP message&#151;provided the <i>IHeaderHandler_willWriteHeaders</i> method returns True. It is possible to serialize more than one SOAP header element in the <i>IHeaderHandler_readHeader</i> method by repeating the<i> pSerializer.startHeaderElement,pSerializer.writeString,</i> and <i>pSerializer.endHeaderElement</i> statements for each header element that needs to be written.</p><p>Finally, to hook up the SOAP header handler to a particular <i>SoapClient</i> instance one must set the HeaderHandler property of the <i>SoapClient</i> object to an instance of a user-defined SOAP header handler class; for instance:</p><blockquote><p>Dim SOAPHeader As New SessionHeader</p><p>Set ws.HeaderHandler = SOAPHeader</p></blockquote><p>At this point, any subsequent call web-method invocation enacted through the <i>SoapClient</i> object results in transmission of a value stored in the <i>SessionID</i> property of the <i>SOAPHeader</i> object, as well as parsing the returned SOAP message header to update the <i>SessionID</i> property with a new value returned by the web service (if any). Remember, that it is up to web service to initialize and maintain the session ID value on its side.</p><h3>Conclusion</h3><p>The SOAP Toolkit provides sufficient means for consuming generic web services in VB6 clients. Although the amount of work associated with implementing custom type mapping and SOAP header handling is somewhat greater than in VB.NET, which supports web services natively, the SOAP Toolkit provides a well-defined interface for tapping into the wealth of XML web services from legacy VB6 projects.</p><p></p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>Dim WebService As New MSSOAPLib.SoapClientWebService.mssoapinit _  "http://www.UltraMax-Music.com/UltraMax.dll?Handler=GenUltraMaxWSDL"</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>' Log on...WebService.LogOn "MyUserName", "MyPassword"</pre><P><A HREF="#rl2">Back to Article</A></P><H4><A NAME="l3">Listing Three</H4><pre><b>(a)</b>Public FileName As StringPublic Quality As Integer<b>(b)</b>Implements ISoapTypeMapperPrivate mStringMapper As ISoapTypeMapperPublic Sub ISoapTypeMapper_Init( _    ByVal pFactory As MSSOAPLib.ISoapTypeMapperFactory, _    ByVal pSchema As MSXML2.IXMLDOMNode, _    ByVal xsdType As MSSOAPLib.enXSDType)        Set mStringMapper = pFactory.getMapper(enXSDstring, Nothing)End SubPublic Function ISoapTypeMapper_read(ByVal pNode As MSXML2.IXMLDOMNode, _    ByVal bstrEncoding As String, ByVal encodingMode As _    MSSOAPLib.enEncodingStyle, ByVal lFlags As Long) As Variant    Dim fi As New FileInfo    Dim Node As IXMLDOMNode    fi.FileName = mStringMapper.read(pNode.selectSingleNode("FileName"), _        bstrEncoding, encodingMode, lFlags)    fi.Quality = mStringMapper.read(pNode.selectSingleNode("Quality"), _        bstrEncoding, encodingMode, lFlags)    Set ISoapTypeMapper_read = fiEnd FunctionPrivate Function ISoapTypeMapper_varType() As Long    ISoapTypeMapper_varType = vbObjectEnd FunctionPublic Sub ISoapTypeMapper_write(ByVal pSoapSerializer As _    MSSOAPLib.ISoapSerializer, ByVal bstrEncoding As String, _    ByVal encodingMode As MSSOAPLib.enEncodingStyle, _    ByVal lFlags As Long, pvar As Variant)    Dim fi As New FileInfo    Set fi = pvar    pSoapSerializer.startElement "FileName"    mStringMapper.write pSoapSerializer, bstrEncoding, encodingMode, _        lFlags, fi.FileName    pSoapSerializer.endElement    pSoapSerializer.startElement "Quality"    mStringMapper.write pSoapSerializer, bstrEncoding, encodingMode, _        lFlags, fi.Quality    pSoapSerializer.endElementEnd Sub</pre><P><A HREF="#rl3">Back to Article</A></P><H4><A NAME="l4">Listing Four</H4><pre><b>(a)</b>Public SongTitle As StringPublic AlbumTitle As StringPublic Duration As SinglePublic MP3Info As FileInfo<b>(b)</b>Implements ISoapTypeMapperPrivate mStringMapper As ISoapTypeMapperPrivate mFileInfoMapper As FileInfoMapperPrivate Sub ISoapTypeMapper_Init( _    ByVal pFactory As MSSOAPLib.ISoapTypeMapperFactory, _    ByVal pSchema As MSXML2.IXMLDOMNode, _    ByVal xsdType As MSSOAPLib.enXSDType)    Set mStringMapper = pFactory.getMapper(enXSDstring, Nothing)    Set mFileInfoMapper = New FileInfoMapper    mFileInfoMapper.ISoapTypeMapper_Init pFactory, pSchema, xsdTypeEnd SubPrivate Function ISoapTypeMapper_read(ByVal pNode As MSXML2.IXMLDOMNode, _    ByVal bstrEncoding As String, ByVal encodingMode As _    MSSOAPLib.enEncodingStyle, ByVal lFlags As Long) As Variant    Dim si As New SongInfo    Dim Node As IXMLDOMNode    si.SongTitle = mStringMapper.read(pNode.selectSingleNode("SongTitle"), _        bstrEncoding, encodingMode, lFlags)    si.AlbumTitle = mStringMapper.read(pNode.selectSingleNode("AlbumTitle"), _        bstrEncoding, encodingMode, lFlags)    si.Duration = mStringMapper.read(pNode.selectSingleNode("Duration"), _        bstrEncoding, encodingMode, lFlags)    Set si.MP3Info =      mFileInfoMapper.ISoapTypeMapper_read(pNode.selectSingleNode("MP3Info"), _     bstrEncoding, encodingMode, lFlags)    Set ISoapTypeMapper_read = siEnd FunctionPrivate Function ISoapTypeMapper_varType() As Long    ISoapTypeMapper_varType = vbObjectEnd FunctionPrivate Sub ISoapTypeMapper_write(ByVal pSoapSerializer As _    MSSOAPLib.ISoapSerializer, ByVal bstrEncoding As String, _    ByVal encodingMode As MSSOAPLib.enEncodingStyle, _    ByVal lFlags As Long, pvar As Variant)    Dim si As New SongInfo    Set si = pvar    pSoapSerializer.startElement "SongTitle"    mStringMapper.write pSoapSerializer, bstrEncoding, encodingMode, _        lFlags, si.SongTitle    pSoapSerializer.endElement    pSoapSerializer.startElement "AlbumTitle"    mStringMapper.write pSoapSerializer, bstrEncoding, encodingMode, _        lFlags, si.AlbumTitle    pSoapSerializer.endElement    pSoapSerializer.startElement "Duration"    mStringMapper.write pSoapSerializer, bstrEncoding, encodingMode, _        lFlags, si.Duration    pSoapSerializer.endElement    pSoapSerializer.startElement "MP3Info"    mFileInfoMapper.ISoapTypeMapper_write pSoapSerializer, _                         bstrEncoding, encodingMode, lFlags, si.MP3Info    pSoapSerializer.endElementEnd Sub</pre><P><A HREF="#rl4">Back to Article</A></P><H4><A NAME="l5">Listing Five</H4><pre>&lt;?xml version='1.0' ?&gt; &lt;servicemapping name='UltraMaxService'&gt;    &lt;service name='UltraMaxService'&gt;        &lt;using PROGID='UltraMaxMapper.FileInfoMapper' cachable='0'             ID='UltraMaxFileInfoMapperObject' /&gt;        &lt;using PROGID='UltraMaxMapper.SongInfoMapper' cachable='0'            ID='UltraMaxSongInfoMapperObject' /&gt;        &lt;types&gt;            &lt;type name='FileInfo' targetNamespace='urn:UltraMaxService'                uses='UltraMaxFileInfoMapperObject'/&gt;            &lt;type name='SongInfo' targetNamespace='urn:UltraMaxService'                uses='UltraMaxSongInfoMapperObject'/&gt;        &lt;/types&gt;    &lt;/service&gt;&lt;/servicemapping&gt;</pre><P><A HREF="#rl5">Back to Article</A></P><H4><A NAME="l6">Listing Six</H4><pre>Option ExplicitImplements IHeaderHandlerPublic SessionID As StringPrivate Const NAMESPACE As String = "urn:UltraMaxService"Private Const SESSIONID_NAME As String = "m_SessionID"Private Function IHeaderHandler_readHeader(ByVal pHeaderNode _    s MSXML2.IXMLDOMNode, ByVal pObject As Object) As Boolean    If pHeaderNode.baseName = SESSIONID_NAME And _        pHeaderNode.namespaceURI = NAMESPACE Then        ' Read session ID        SessionID = pHeaderNode.Text        IHeaderHandler_readHeader = True    Else        IHeaderHandler_readHeader = False    End IfEnd FunctionPrivate Function IHeaderHandler_willWriteHeaders() As Boolean    IHeaderHandler_willWriteHeaders = TrueEnd FunctionPrivate Sub IHeaderHandler_writeHeaders(ByVal pSerializer As _                    MSSOAPLib.ISoapSerializer, ByVal pObject As Object)    ' Write session ID    pSerializer.startHeaderElement SESSIONID_NAME, NAMESPACE    pSerializer.writeString SessionID    pSerializer.endHeaderElementEnd Sub</pre><P><A HREF="#rl6">Back to Article</A></P></body></html>