<html><head><title>Feb04: Regular Expression Mining</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Regular Expression Mining</h1><p><i>Dr. Dobb's Journal</i> February 2004</p><h2>Ensuring data quality</h2><h3>By Sergei Savchenko</h3><I>Sergei is a researcher with DecisionsToday Inc. in Ottawa, Canada. He can be contacted at sergei_savchenko@hotmail.com.</I><hr><p>Regular expressions are convenient devices to identify common patterns in collections of strings. Search engines, text editors, and other textdata-oriented tools use them to widen search targets. </p><p>The simplest regular expression over some alphabet, say <i>{a,b,c},</i> is an atomic expression emitting a string consisting of a single symbol from an alphabet (<i>a,b,</i> or <i>c</i>). More complex expressions are constructed from simpler expressions:</p><DDJADVERTISEMENT INLINE><ul>  <li>If <i>r</i><sub>1</sub> and <i>r</i><sub>2</sub> are regular expressions, then so is the sequence of expressions <i>r</i><sub>1 </sub><i>r</i><sub>2</sub>, producing strings where the prefixes are emitted by the first expression and the suffixes by the second one.   <li>If <i>r</i><sub>1</sub> and <i>r</i><sub>2</sub> are regular expressions, then so is a disjunction of the expressions <i>r</i><sub>1</sub>| <i>r</i><sub>2</sub>, producing strings of either expression <i>r</i><sub>1</sub> or <i>r</i><sub>2</sub>.  <li>If <i>r</i> is a regular expression, then so is <i>r</i>*, where symbols produced by <i>r</i> are repeated 0 to <i>n</i> times.</ul><p>Additionally, brackets are used to clarify operator precedence. </p><p>Although the constructive rules I've described are sufficient, software that uses regular expressions often introduces syntactic additions. It is possible, for instance, to denote <i>rr</i>* as <i>r</i><sup>+</sup>, thus describing a regular expression occurring 1 to <i>n</i> times. Also common are character classes, such as <i>[a-z], </i>which denote a disjunction of all letters between <i>a</i> and <i>z</i> (for instance, <i>a</i>|<i>b</i>|...|<i>z</i>). For example, the regular expression (<i>ab</i><sup>+</sup>)<sup>+</sup> denotes the family of strings <i>ab, abb, abab, abbbabb, ababbbabb, </i>and so on.</p><p>An interesting problem involving regular expressions revolves around regular expression mining (also known as "regular expression induction"). The problem is this: Given a set of strings, you want to automatically derive a regular expression that is likely to describe strings in the set. As it turns out, this isn't an easy problem to solve. </p><p>To begin with, it can be difficult to express in algorithmic terms exactly what you are looking for. You don't necessarily want an expression that <i>exactly</i> describes <i>only</i> a given ("training") set. Expressions such as these can be easily obtained as a disjunction of all strings in the training set. Besides, you probably want to find a pattern to help you identify previously unseen strings and determine whether they belong to the same class as the strings in the training set. Thus, some generalization of the training set must occur. However, an ultimate generalization is simply a disjunction of all symbols in the alphabet repeated multiple times. While an expression such as this describes the strings in the training set, it also describes any other strings over the same alphabet. This is not particularly helpful. What you want is a certain number of reasonable generalizations to obtain an expression that describes the training set, yet which is not so broad that it includes strings unlike the ones in the training set. It is hard, however, to quantitatively express these criteria.</p><p>The field of grammatical inference offers some approaches as to how regular expressions can be induced given a training set of strings. In this article, I present an algorithm&#151;based on several of these approaches&#151;that produces satisfactory results. Java source code that implements this algorithm is available electronically; see "Resource Center," page 5.</p><p>With this algorithm, you begin by constructing an overly specific automaton that represents all strings in the training set. Nodes in this automaton are marked with emitted symbols, whereas directed edges represent which nodes follow which nodes in the produced strings. You start construction of an overly specific automaton when you create two special nodes that do not emit symbols to represent the beginning and end. You can further represent each string as a node chain connecting the initial and final nodes. Clearly, this automaton exactly describes the training set and nothing else.</p><p>To illustrate, suppose you are given a training set consisting of only the two strings:</p><blockquote><p>abb</p><p>abab</p></blockquote><p><A NAME="rf1"><A HREF="0402ff1.htm">Figure 1</A>(a) is an overly specific automaton for this set. </p><p>The algorithm proceeds by merging pairs of similar nodes in the automaton. You are looking for such nodes that have similar predecessor nodes, are similar in terms of symbols that they produce, and have similar successor nodes. The comparison criteria could potentially be recursive or limited to immediate neighbors. The comparison criteria I use is the weighted sum in <A NAME="re1"><A HREF="0402fe1.htm">Example 1</A>, where <i>p</i><sub>1</sub> and <i>p</i><sub>2</sub> are:</p><ul>  <li><i>p</i><sub>1</sub> and <i>p</i><sub>2</sub> are sets of symbols emitted by immediate predecessor nodes.  <li><i>n</i><sub>1</sub> and <i>n</i><sub>2</sub> are sets of symbols produced by the nodes being compared.  <li><i>	t</i><sub>1 </sub>and <i>t</i><sub>2</sub> are the types of symbols in the compared nodes.  <li><i>s</i><sub>1 </sub>and <i>s</i><sub>2</sub> are sets of symbols produced by immediate successor nodes. </ul><p>Ratios of the size of the intersection over the size of the union describe the similarity of individual components of the weighted sum. Every node is only allowed a single type (such as a character, number, or separator type). Thus, the intersection of types is 1 if the nodes are of the same type; otherwise 0. The weight coefficients used could be as simple as 0.3, 0.3, 0.1, and 0.3 for <i>c</i><sub>1</sub>,<i>c</i><sub>2</sub>,<i>c</i><sub>3</sub>, and <i>c</i><sub>4</sub>, respectively. The weighted sum gives a value between 0 and 1 so that it is close to 1 for similar nodes, and close to 0 for dissimilar ones.</p><p>The algorithm proceeds iteratively at each step, merging a pair of nodes with the best comparison coefficient. When the comparison coefficients fall below a certain threshold (0.4, for instance), the merging process stops.</p><p><A NAME="rf1"><A HREF="0402ff1.htm">Figure 1</A> illustrates this process for a sample training set. The broken line identifies nodes to be merged. For example, initially in <A NAME="rf1"><A HREF="0402ff1.htm">Figure 1</A>(a), the two nodes producing symbol <i>a</i> are similar since they share the same predecessor node and their successor nodes emit the same symbol. Thus they are merged. </p><p>To merge two nodes, you create a new node such that it emits any symbol emitted by the parents and shares all of the arriving and departing edges. Although originally, any node produces only a single symbol, it is possible that after a merge a node will be producing one of several symbols.</p><p>Loops can be obtained in the merging process; see <A NAME="rf1"><A HREF="0402ff1.htm">Figure 1</A>(f). It is not hard to see that the resulting automaton represents the training set. Indeed it describes strings containing multiple blocks of repeating <i>b</i>s separated by <i>a</i>s&#151;exactly what the training set seems to suggest.</p><p>Once the automaton is derived, you want to turn it into a regular expression. The next algorithm I present does this. You can iteratively delete every node in the automaton (with the exception of the initial and the final nodes) by replacing it with edges marked with symbols that the node used to emit. For instance, assume in <A NAME="rf2"><A HREF="0402ff2.htm">Figure 2</A>(a) that you want to delete a node producing symbol <i>s</i>. Since this node has a loop, you will necessarily produce a string of at least one repeating <i>s</i> when passing through it. Thus, any two nodes that are connected via the current node can be joined directly by an edge marked with such an expression. When this is done for all nodes connected via the current one, the node itself can be safely deleted.</p><p>It may be beneficial to allow only a single marked edge to connect any two nodes. When another marked edge between the pair of nodes has to be created, you can update the expression marking the original edge. The new expression is simply a disjunction of the new and old expressions.</p><p><A NAME="rf2"><A HREF="0402ff2.htm">Figure 2</A> illustrates a trivial case. In the general case in <A NAME="rf3"><A HREF="0402ff3.htm">Figure 3</A>, there could already exist marked edges and marked loops. Since you are imposing a condition to allow only one edge to connect any two nodes in one direction, there may not be more than a single marked and single unmarked loop. Thus, <A NAME="rf3"><A HREF="0402ff3.htm">Figure 3</A> represents the general transformation to delete a node by replacing it with marked edges.</p><p>Assuming that the arriving edge was marked by an expression <i>a</i>, the node emits an expression <i>s</i>, the departing edge is marked by an expression <i>d</i>, and there is a loop marked with expression <i>l</i> (as well as an unmarked loop); the resulting expression on the new marked edge is <i>as</i><sup>+</sup><i>(ls</i><sup>+</sup><i>)</i>*<i>d.</i> Why? Because on entering the node, the unmarked loop can be taken multiple times (represented by the first <i>s</i><sup>+</sup> in the expression). At an arbitrary point, the marked loop can be taken 0 to <i>n</i> times. However, on every new arrival back to the node, the unmarked loop may be used once again. Thus, to delete a node, all arriving edges must be reconnected with every departing edge using the procedure just described. Eventually, all nodes are deleted except for the initial and final nodes that, in the end, must be connected with a single edge marked with the expression we are seeking. <A NAME="rf4"><A HREF="0402ff4.htm">Figure 4</A> illustrates the entire derivation process for this example. Postprocessing could shorten the resulting expression even further. In the particular case of the example, it can be shortened to just (<i>ab</i><sup>+</sup>)<sup>+</sup>.</p><p>The algorithm just described runs in <i>O</i>(<i>n</i><sup>3</sup>) time, where <i>n</i> is the number of symbols (not strings) in the training set. This order of complexity exists because, during automaton derivation to determine appropriate merge candidates, it is necessary to compare every node with every remaining node (thus, <i>n</i><sup>2</sup>), and there are as many as <i>n</i>-1 pairs of nodes to merge (thus, <i>n</i><sup>3</sup>). If you used recursive comparison criteria, the complexity would have been even higher.</p><p>Although this algorithm works well on small alphabets, it is not particularly useful on practical sets of strings in its unmodified form. One modification you can add to improve performance has to do with character classes. It is also based on the observation that regular expressions in practical applications often contain such classes as<i> [a-z], [A-Z], </i>and<i> [0-9].</i> You can explicitly examine every node in the automaton during the derivation. If a subset of departing (or arriving) nodes produces a significant portion of some character class, you can collapse all these nodes together into just one marked with appropriate character class expression.</p><p>Another modification is based on the observation that many types of strings are of finite length. In this case, you want to avoid excessive generalizations. For instance, a ZIP code is a number occurring five times&#151;not an arbitrary number of times. If a training set is determined to have a predominant length (or lengths), you can introduce a restriction to rule out merges that result in loops in the automaton.</p><p>You can also use knowledge of separator characters that occur exactly once in all strings in the training set. Such characters should be prohibited from appearing in any loop. These heuristics seem to significantly enhance practical performance of the algorithm. </p><p>In conclusion, the regular expression mining approach augments other techniques used in data mining. In a modified form, regular expression mining can be used to ensure data quality when the nature of data is not known beforehand. </p><p><b>DDJ</b></p></body></html>