<html><head><title>May04: Implementing  Screen Savers in .NET</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Implementing  Screen Savers in .NET</h1><p><i>Dr. Dobb's Journal</i> May 2004</p><h2>The Windows Forms  library makes it simple  to write screen savers</h2><h3>By Richard Grimes</h3><I>Richard is the author of Programming with Managed Extensions for Microsoft Visual C++ .NET 2003 (Microsoft Press, 2003). He can be contacted at richard@richardgrimes.com.</I><hr><p>The first Windows program I ever wrote was a screen saver because I wanted to write some code that would let me do some graphical manipulation, and a screen saver seemed the ideal project. Since then, I have written many other screen savers to exercise new facilities as they are released for Windows. With this in mind, when .NET was first released, I took that as an opportunity to write yet another screen saver.</p><p>.NET has a library called "Windows Forms" that provides basic windowing features. In terms of windowing, there really isn't much new in Windows Forms. Sure, there are some new controls, and it makes existing controls easier to use, but it has the same look and feel as Visual Basic Forms and is based on Win32 Windows messages, handles, and device contexts. If you are comfortable with Visual Basic, you'll be comfortable with Windows Forms. However, I came to .NET as a C++ Win32 programmer, so Windows Forms was alien to me, especially since it was not obvious how to do many of the things that came as second nature to me as a C++ programmer. In this article, I describe the screen-saver library I developed to do most of the work of a screen saver&#151;all you have to provide is the graphics code. </p><h3>Windows Screen Savers</h3><p>Typically when you create Win32 screen savers, you link to scrnsave.lib. The library does much of the work that your screen saver should do and ensures that the window is created in the right style. My first task was to reverse engineer this library using DUMPBIN. <A NAME="rt1"><A HREF="0405lt1.htm">Table 1</A> lists the basic properties of a screen saver gleaned from this library. Notice that screen savers can be started in one of three distinct modes:</p><p></p><ul>  <li>Full-Screen Mode. This is when the screen saver is started by the system and it covers the entire screen. The screen-saver process runs until the mouse is moved or a key is pressed  <li>Preview Mode. The user starts the screen saver using the Screen Saver tab of the Display Properties dialog. When the Screen Saver tab is shown, the current screen saver covers the small preview window in the center of the tab, as in <A NAME="rf1"><A HREF="0405lf1.htm">Figure 1</A>. The process runs until the user moves to another tab or closes the dialog.  <li>Configuration Mode. The user has clicked on the Settings button on the Screen Saver.</ul><p>The screen-saver process is informed about the mode through the command line passed to the process; see <A NAME="rt2"><A HREF="0405lt2.htm">Table 2</A>. I decided that I should write a .NET library that can be used to do most of the work of a screen saver using a Windows Forms class. Users of the library only have to derive from this class and provide the drawing routine. One of the first problems to solve was keeping check of the instance that is run. When the Screen Saver tab is shown, the dialog runs the screen-saver process with <i>/p</i>, but when users click the Preview button, another instance of the screen saver is started full screen with <i>/s</i>. When the full-screen mode ends, the Screen Saver tab is shown again and another instance of the process is started with <i>/p</i>. I had to find a way of identifying other instances of the process, then telling those instances to shut down.</p><h3>Forms and Windows</h3><p>The <i>System.Windows.Forms.Control </i>class, at first glance, appears to let you create an object based upon an arbitrary windows handle through the <i>Control.FromHandle</i> method. However, if you try to pass the handle of a window that was not created by a Windows Forms process, this method fails&#151;even if the window was created by a Windows Forms process, the method may still fail. The reason lies in the way that Windows Forms implements its event-based message handling scheme. </p><p>Win32 processes get a message from the user interface thread's message queue with a call to <i>GetMessage</i>. This message is then handled by the appropriate message handler procedure (the windows procedure) by passing information about the message to <i>DispatchMessage</i>. This information includes the handle of the window and <i>DispatchMessage</i> uses this handle to get the windows class, and from the class it can obtain the address of the windows procedure for the window type. Thus, in Win32 the windows class is very important.</p><p>In contrast, the <i>Control</i> class shows no outward appearance that a windows class has been registered, nor do you see the <i>GetMessage/DispatchMessage</i> message pump. Closer inspection suggests that the call to <i>Application.Run</i> that all graphical .NET applications make implements the message pump. The <i>Control</i> class, and its child class <i>Form</i>, handle messages through events: Your code provides an event handler for each of the messages that you want handled. Under the covers, <i>Control</i> does register a windows class. This does not occur when an instance is created, so when a class's constructor is called, there is no window. The first time that a <i>Control</i> object is told to show itself (<i>Control.Visible</i> set to True, which occurs when the form object is passed to <i>Application.Run</i>), a call is made to <i>NativeWindow.CreateHandle</i>. This method registers a windows class and creates the window. <i></p><p>CreateHandle</i> does this through a <i>WindowClass</i> nested class and, specifically, the <i>RegisterClass </i>method. <i>DispatchMessage</i> calls the windows procedure, and so it expects to receive a function pointer to a native function. The <i>WindowClass.RegisterClass</i> method passes a structure to the Win32 <i>RegisterClass</i> function and the managed signature of this structure has a delegate called <i>WndProc</i> for the windows procedure member. This is important because, when the managed structure is marshaled to the unmanaged world, .NET automatically marshals the delegate as a thunk to the managed method contained in the delegate. The thunk is native code that performs the conversion from the unmanaged context to the managed context and, in this way, <i>DispatchMessage</i> gets access to what appears to be a native function pointer.</p><p>The important part of the managed <i>RegisterClass</i> method is that, usually, only a single windows class is registered and its name takes the form:</p><blockquote><p>&lt;windowsformsversion&gt;.&lt;windowstyle&gt;.</p><p>                  app&lt;hexappdomainhash&gt;</p></blockquote><p>Here,<i> &lt;windowsformsversion&gt;</i> is the version of the library and is a fixed string "WindowsForms10." <i>&lt;windowstyle&gt;</i> is in the form of <i>Window.&lt;hexstyle&gt;</i>, where <i>&lt;hexstyle&gt;</i> is the style of the window in hex. Finally, <i>&lt;hexappdomainhash&gt;</i> is the hash code of the current app domain given in hex. It is not clear how the hash code for an <i>AppDomain</i> is calculated but it appears to return the same value of 2 for the first application domain created in a process. This means that windows with the same style can have the same class name regardless of the process that created the window. Once the <i>windows</i> class is registered, the window is created with a call to the Win32 <i>CreateWindowEx</i>, the <i>Control</i> object is then added to a table indexed by its Windows handle (HWND). <i>Control.FromHandle</i> only returns values from this table because it guarantees that the windows will have been created in the current process.</p><p>My initial idea to ensure that only one instance of the screen-saver process runs was to use the Win32 <i>FindWindowEx</i> to search for windows with the class name of the screen saver's window, but the earlier discussion suggests that I would get back windows created in other .NET applications. Then I thought that I could use some identification string stored, for example, in the <i>Form.Tag</i> property, but I would only be able to create a Form from a HWND if the window was created in the current process. So, instead, I used a different approach.</p><h3>.NET Process Class</h3><p>The <i>System.Diagnostics.Process</i> class gives access to information about all processes running on the current machine through the static <i>GetProcesses</i> method. This returns an array of <i>Process</i> objects and each one has properties identifying the process. <A NAME="rl1"><A HREF="#l1">Listing One</A>, my first attempt, iterates through all the processes and checks the full path of the main module of each process to see if it is the same as the full path to the main module of the current process. If this path is the same, then either the process is another instance or it is the running process. So that I don't attempt to close the running process, I check the process ID. In this code, the Win32 class is a class that I use to import Win32 functions through platform invoke, and in this listing I use it to send the WM_CLOSE message using the <i>SendMessage</i> function.</p><p>However, this routine fails when the process is either the <i>System</i> process or the <i>Idle</i> process because these are special "processes"&#151;the <i>Idle</i> process is not a process at all, and the <i>System</i> process refers to several processes running in kernel mode. Attempting to get the <i>MainModule</i> for either of these throws an exception. Consequently, I use the altered routine in <A NAME="rl2"><A HREF="#l2">Listing Two</A>, which performs an initial filtering based on the name of the process. Whenever the screen saver is run, this routine is called to make sure that the running instance is the only instance of the screen-saver process.</p><h3>The Display Properties Dialog</h3><p>A screen saver is chosen and configured through the Display Properties dialog; see <A NAME="rf1"><A HREF="0405lf1.htm">Figure 1</A>. This dialog shows a preview of the selected screen saver in a small window in the center. My first attempt was to place my window over the dialog's preview window, but this failed because if the user moved the dialog, the window would remain in the same place. Then I wrote some code to track the position of the preview window and moved my window appropriately, but then I got into difficulties determining the <i>Z</i> order of my window and rejected the whole idea.</p><p>As mentioned, Windows Forms is a veneer over Win32 windowing. Windows Forms uses device contexts to draw on a window, and it wraps a device context in a class called <i>System.Drawing.Graphics</i>. An instance of this class can be created from a call to the static method <i>Graphics.FromHwnd</i> and it does not matter if the window is in another process. Thus, I can draw on the device context of the preview window by passing the value passed by the <i>/p</i> switch to <i>FromHwnd</i>. I still have a Form window, which I initialize with the properties of the preview window so that these are available to the developer; however, I have to make sure that this Form window is not visible, otherwise it appears as an unpainted window on the screen. </p><p>To let the screen saver be animated, I create a timer to fire repeatedly with the intention of calling the user-defined paint routine. However, this can cause a flicker, so I remedy this with double buffering by creating a separate buffer based on the <i>Graphics</i> object created from the preview window, and passing this buffer to the painting routine.</p><p>However, if users click on another tab or close the dialog, the screen-saver process is not informed about this and continues to run. To detect this, I create a second timer to fire repeatedly and when this happens, I test to see if the preview window still exists (by calling the Win32 function <i>IsWindow</i>). If the window no longer exists, it means that the dialog has closed. If the user has clicked on another tab, the preview window will still exist, but it will be invisible, and I test this by calling the Win32 <i>GetWindowInfo</i> and test the result. In both of these cases (the preview window is invisible or no longer exists), I close the screen-saver process because the next time users show the Screen Saver tab, a new instance of the process is started by the system.</p><h3>Configuration</h3><p>Many screen savers have configuration settings. You alter these settings by clicking on the Settings button on the Display Properties dialog and the dialog starts the screen-saver process with the <i>/c</i> switch. In my screen-saver library, I obtain the configuration dialog by calling the virtual method <i>GetConfigForm</i>&#151;your screen-saver class should override this method appropriately. This dialog is responsible for obtaining configuration settings when it is created and to save the settings when the dialog is closed and the user has clicked on the OK button. </p><p>There are several ways to store configuration data: For example, you could save it in the registry or in a file. The registry is a good place if the changes must be read by a process that is already running because the registry supports read and write access by multiple threads. You do not need simultaneous read and write access with my screen-saver library because only one instance of the screen-saver process can run at any time. Since my screen-saver process is a .NET process, I could use the .NET configuration file; however, I decided not to use this because in the current version of .NET, there is no supported mechanism to write to a configuration file. I also wanted to provide a generic way to read and write settings and if I used the configuration file, the screen saver would have to make multiple reads from the file. Instead I decided to write a class that is intended to be serialized. </p><p><A NAME="rl3"><A HREF="#l3">Listing Three</A> shows this base class. Your screen saver derives from this class and adds fields to the derived class for each of the settings you want to save. When you call <i>Serialize</i>, the code serializes the whole object using the standard SOAP formatter. This is then saved as an XML file in the user's local application data folder. The <i>Deserialize</i> method initializes the object's fields using the data in the XML file. Because the formatter <i>Deserialize</i> method creates a new object, the <i>ConfigurationBase.Deserialize</i> method uses reflection to access all of the serialized fields on the current object and initializes them with the same named fields on the deserialized object.</p><h3>Writing Your Own Screen Saver</h3><p>The source code for the library (available electronically; see "Resource Center," page 5) documents the code that you should write. There are also examples illustrating how to write your own screen saver.</p><p>Once you have compiled the screen-saver library, writing your own screen saver is straightforward. Create a Windows Application in Visual Studio.NET, add the screen-saver library to the project references, and then derive the project's main form from the <i>Screensaver</i> class. The screen saver should be installed in the %systemroot% or %systemroot%\system32 folder and should have an extension of .scr. To achieve this with a C# project in VS.NET, I add a post build event:</p><blockquote><p>copy /y $(TargetPath) %systemroot%\$</p><p>                            (TargetName).scr</p></blockquote><p>The screensaver.dll library should also be copied to this folder. In the example project, I achieve this with a similar post build event. If you do not add the screen-saver library as a project to the solution, you can copy the library from the output folder where it is automatically added by the build process. The additional line that you should add to the post build event should look like this:</p><blockquote><p>copy /y $(TargetDir)\screensaver.dll </p><p>                           %systemroot%</p></blockquote><p>I also change the wizard-generated file so that I have a two-stage construction, as in <A NAME="rl4"><A HREF="#l4">Listing Four</A>. The important point here is that the same process should show the configuration dialog, show the window full screen, or show it in preview mode. The inherited <i>InitScreenSaver</i> method determines the mode and shows the configuration dialog if required. This method returns a <i>Boolean</i>, which is True if the process requires a message pump. At this point, the screen saver must read its configuration before starting and this is the purpose of the derived class method, <i>Initialize</i>, called in <A NAME="rl4"><A HREF="#l4">Listing Four</A>. </p><p>In the derived class in <A NAME="rl5"><A HREF="#l5">Listing Five</A>, the class must call the base class constructor, so that in the full-screen mode the window has the correct style. It also must implement a <i>PaintHandler</i> method, which draws the screen saver. The <i>Graphics</i> object passed to this method is the device context where the drawing should occur, which is either the full screen, or the preview window. Double buffering is enabled by default, but if you do not want this (for example, you only want to update part of the device context on each call to <i>PaintHandler</i>), you can set <i>ScreenSaver.DoubleBuffering</i> to False. In this example, I supply a configuration dialog, so I have to provide a <i>GetConfigForm</i> method that returns an instance of this class.</p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>Process[] processes = Process.GetProcesses();// Get the name of the file of this processstring thisProcess = Process.GetCurrentProcess().MainModule.FileName;foreach (Process process in processes){   // Check the file name of the processes main module   if (thisProcess.CompareTo(process.MainModule.FileName) != 0)       continue;   // Found an instance of the process   if (Process.GetCurrentProcess().Id == process.Id)    {      // We don't want to commit suicide      continue;   }   // Tell the other instance to die   Win32.SendMessage(      process.MainWindowHandle, Win32.WM_CLOSE, 0, 0);}</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>Process[] processes = Process.GetProcesses();string thisProcess = Process.GetCurrentProcess().MainModule.FileName;string thisProcessName = Process.GetCurrentProcess().ProcessName;foreach (Process process in processes){   // Compare process name, this will weed out most processes   if (thisProcessName.CompareTo(process.ProcessName) != 0) continue;   // Check the file name of the processes main module   if (thisProcess.CompareTo(process.MainModule.FileName) != 0) continue;   if (Process.GetCurrentProcess().Id == process.Id)    {     // We don't want to commit suicide     continue;   }   // Tell the other instance to die   Win32.SendMessage(process.MainWindowHandle, Win32.WM_CLOSE, 0, 0);}</pre><P><A HREF="#rl2">Back to Article</A></P><H4><A NAME="l3">Listing Three</H4><pre>[Serializable]public abstract class ConfigurationBase{   public ConfigurationBase(string name);   // Call this on the derived object to write the config data to disk   public void Serialize();   // Call this on the derived object to read the config data into the   // derived object   public void Deserialize();}</pre><P><A HREF="#rl3">Back to Article</A></P><H4><A NAME="l4">Listing Four</H4><pre>[STAThread]static void Main() {   Saver saver = new Saver();   // Test to see if the screen saver is full screen, preview, or started for   // the config or password dialogs   bool animate = saver.InitScreenSaver();   // Preview or full screen   if (animate)   {      saver.Initialize();      Application.Run(saver);   }}</pre><P><A HREF="#rl4">Back to Article</A></P><H4><A NAME="l5">Listing Five</H4><pre>public class Saver : ScreenSaver{   public Saver() : base();   protected void Initialize();   protected override void PaintHandler(Graphics g);   protected override Form GetConfigForm();}</pre><P><A HREF="#rl5">Back to Article</A></P></body></html>