<html><head><title>May04: Backtracking Algorithms</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Backtracking Algorithms</h1><p><i>Dr. Dobb's Journal</i> May 2004</p><h2>Finding all the solutions</h2><h3>By Timothy Rolfe</h3><I>Timothy is a professor of computer science at Eastern Washington University. He can be contacted at trolfe@ewu.edu.</I><hr><p>Backtracking algorithms let you systematically search for solutions to problems among all available options. Backtracking is illustrated in the Eight-Queens problem&#151;finding the chessboard configurations for eight queens in which no queen is attacking another queen. You start in the first row of the chessboard and generate candidate solutions by positioning your first queen in each of the eight positions. After each positioning, you move to the second row and position your second queen on each of that row's squares. Each time that the queen on the current row is under attack from above, you can simply move on to the next square, and you need not examine any boards generated from the partial board.</p><p>There is, however, another interesting problem that can also be approached with backtracking algorithms.</p><p>In his August 1986 column for<i> Isaac Asimov's Science Fiction Magazine </i>(http://www.asimovs.com/), Martin Gardner presented this problem:</p><blockquote><p>Now for a curious little combinatorial puzzle involving the twelve numbers on the face of a clock. Can you rearrange the numbers (keeping them in a circle) so no triplet of adjacent numbers has a sum higher than 21? This is the smallest value that the highest sum of a triplet can have.</p><p>  I know of no procedure for finding such a permutation, but there must be a way to write a computer program that will print all such permutations in a reasonable time.*</p><p>*see Dean S. Clark, "A Combinatorial Theorem on Circulant Matrices," American Mathematics Monthly, December 1985 (http://www.maa.org/pubs/monthly.html).</p></blockquote><p>This puzzle amounts to constraining a circular permutation of the numbers from 1 to 12, but you can start with a simpler problem. Just as the Eight-Queens problem can be generalized to an <i>N</i>-Queens problem, you can generalize the clock-face puzzle to faces with fewer numbers than 12. After all, there are 12! permutations of the numbers from 1 to 12. You can also ignore configurations that only amount to rotations of other configurations. You can do that by nailing down one number&#151;comparable with nailing down the "12" in the 12:00 position on the standard clock face. That at least brings you down from <i>N</i>! to (<i>N</i>-1)!, but you're still dealing with a rather ugly number of potential configurations. You can reduce the number just a bit more: Ignore each configuration that is just the mirror image of another configuration, something you can do by forcing an order on the two numbers adjacent to the top number. In terms of the standard clock face, those would be the numbers in the 11:00 position and the 1:00 position. <A NAME="rf1"><A HREF="0405hf1.htm">Figure 1</A> shows the single circular permutation of the numbers from 1 to 6, where we enforce 11 as the largest sum.</p><p>Now you've taken the <i>N</i>-entry clock face from <i>N</i>! potential configurations down to (<i>N</i>-1)!/2 configurations, but that is still a huge number. For instance, if you don't find an intelligent approach, the standard clock face would require checking 11!/2 configurations&#151;to be precise, 19,958,400 configurations. (At least that's better than 12!&#151;479,001,600&#151;without the symmetry corrections.)</p><p>This problem was used in the Pacific Northwest Regional part of the ACM International Collegiate Programming Contest (http://icpc.baylor.edu/icpc/). It is possible that some of the contestants ran afoul of this nasty exponential explosion. The C++ STL's <i>next_permutation</i> function provides a snare and a trap. While 6! isn't too bad, 12! (and especially 13!) gets truly nasty&#151;and the contest rules require that programs finish within 120 seconds. When I encoded the direct calculation using <i>next_permutation(),</i> the 12-entry clock face required 36 seconds to test for the triple sum of 21, but checking the 13-entry clock face for the triple sum of 22 required 416 seconds.</p><p>With backtracking, however, you can start building your permutations and, at the point where a candidate partial permutation has a triple that sums to more than the allowed value, you can discard all the permutations generated beyond that.</p><p>If you use a queue, generating the permutations is also easy. First, you enter all of the digits from 1 to <i>N</i> into your queue. If you have an array <i>face[]</i> to hold the current permutation, you can initialize <i>face[0]</i> with whatever value you want to nail to the top of the clock face by dequeuing a value into that position. After that, recursion is your friend. You position digits into <i>face[1]</i> (rotating available digits from the queue into that position) and, for each of those, you position remaining digits into <i>face[2],</i> on up. The following is the pseudocode for this.</p><p>To build a clock face in position <i>k</i>:</p><p>1.	If the queue is empty, all positions are filled&#151;you have a winner.</p><p>2.	Otherwise, retain the value of the next item from the queue.</p><p>3.	Loop (bottom driven) until that value comes back around.</p><p>(a)	Remove a value from the queue and put it into <i>face[k].</i></p><p>(b)	If the resulting partial clock face is still valid, recursively fill position<i> k+</i>1.</p><p>(c)	Return the value in <i>face[k]</i> back into the queue.</p><p><A NAME="rl1"><A HREF="#l1">Listing One</A> implements this in C++; the Java version differs only in declaring the method to be <i>public.</i></p><p>The validity check can also take advantage of the fact you have a valid partial solution up to the position you are filling. This is something that I failed to notice 15 years ago, when I first played with this puzzle in an article that appeared in <i>Mathematics and Computer Education </i>(Spring 1987; http://www.macejournal.org/). The pseudocode for the check looks like this: </p><p>To check position <i>k</i> of the clock face:</p><p>1.	Generate the total from <i>face[k-2]</i> up to <i>face[k],</i> being careful to only go back to subscript 0, if appropriate.</p><p>2.	If the total exceeds limits, return failure.</p><p>3.	Else, if this isn't the last position on the face, return success.</p><p>4.	Else, this is the last position on the face. Check the remaining two triples.</p><p>5.	If <i>face[N-2]+face[N-1]+face[0] </i>exceeds limits, return failure.</p><p>6.	Else, if <i>face[N-1]+face[0]+face[1]</i> exceeds limits, return failure.</p><p>7.	Else, return success.</p><p><A NAME="rl2"><A HREF="#l2">Listing Two</A> implements this in C++; the Java version differs only in declaring the method to be <i>private</i> and calling the return value <i>boolean</i>.</p><p>The complete program (in C++ and Java) is available electronically; see "Resource Center," page 5. (The archive also includes BadNews.cpp, the version that uses the STL <i>next_permutation</i> function.) </p><p>Runs of the Java version generated the output in <A NAME="rf2"><A HREF="0405hf2.htm">Figure 2</A>. In the first run, rather than doing a check of 19,958,400 configurations requiring up to 12 checks each, we only ran 2,168,123 checks of configurations, mostly requiring a single check. The time reflects executing the program on a Compaq Presario (AMD Athlon Processor 1.2 GHz) under Java SDK 1.4.0_01 running Windows ME.</p><h3>Optimization</h3><p>I also used this problem as a programming assignment in my Data Structures II course, providing the students with a draft of this paper (minus the code listings, of course) to explain the problem. That motivated me to experiment with other methods to solve the problem that might execute more quickly. Some students also suggested ideas to speed execution.</p><p>Robert Lyon's implementation moved the rejection of mirror images from where I have it (after completion of the permutation) to a check when there are only three elements in the partial permutation. This has a dramatic effect, thanks to the early backtracking. Brendan Cassida's implementation moved the check from a function call to inline code, providing another speed increase.</p><p>I noted that I could dispense with the queue altogether, simply moving values around within the permutation array in a controlled fashion. Unlike the queue-based implementation, I also wanted to generate candidate permutation in lexicographic order. This means that, for four items, you're looking for the following sequence:</p><blockquote><p>1 2 3 4    etc.</p><p>2 1 3 4    etc.</p><p>3 1 2 4    etc.</p><p>4 1 2 3    etc.</p></blockquote><p>This suggests that you perform a single swap with the current position, eventually moving the last entry to the front, but having the rest in order and offset by one position. The restoration is a matter of saving the front value, then moving the rest of the array forward by one position and placing the saved value at the back&#151;effectively rotating the array left by one position. Here's what the pseudocode looks like:</p><p>To build a clock face in position <i>k</i> more quickly:</p><p>1.	If <i>k</i> is past the end of the array, all positions are filled&#151;you have a winner.</p><p>2.	Otherwise, loop as <i>j</i> takes on values from <i>k</i> to the end of the array.</p><p>(a)	Swap entries <i>j</i> and <i>k.</i></p><p>(b)	If the resulting partial clock face is still valid, recursively fill position <i>k</i>+1. </p><p>3.	Restore the initial state of the array.</p><p>(a)	Save the value in position <i>k.</i></p><p>(b)	As <i>j</i> goes from <i>k</i>+1 to the end, move elements from <i>[j]</i> to <i>[j-1].</i></p><p>(c)	Position the saved value at the end of the array.</p><p><A NAME="rl3"><A HREF="#l3">Listing Three</A> dispenses with having a clock class and passes all necessary information as function parameters. As you'd expect with optimizations, it is longer than the earlier implementation.</p><h3>Acknowledgments</h3><p>Thanks to Kris Rudin, director of the Pacific Northwest Region for the ACM International Collegiate Programming Contest, and Tom Capaul, faculty advisor for the ACM student chapter at Eastern Washington University, for giving me the motivation to revisit and rethink this problem in preparation for the 2002 regional competition. Thanks also to Tom Capaul for providing some useful suggestions on this article. A special thanks to the students in the Fall-2002 CScD-327 class at Eastern Washington University, particularly Robert Lyon and Brendan Cassida.</p><p></p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>// Set remaining values into position size and recurse (if needed)void Cloque::build ( IntQueue &amp;work, int posn ){   if ( work.isEmpty() )  // Face has been completed   {  if ( face[posn-1] &lt; face[1] )  // Omit the mirror image         process();       // Process as a valid clock face.   }   else   {  int marker = work.nextItem();      do      {  face[posn] = work.dequeue();         if (check(posn))            build(work, posn+1);         work.enqueue(face[posn]);      }  while ( marker != work.nextItem() );   } // end if ( work.isEmpty() ) / else} // end build()</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>// Check whether the current clock face meets the restriction on// the maximum allowed triplet sum.  Note that this presumes that// the face is valid UP TO making an entry into this position.bool Cloque::check ( int posn )  // I.e., position being filled{  int idx,       total = 0;   numCheckCalls ++;   idx = posn - 2;   if ( idx &lt; 0 )      idx = 0;   while ( idx &lt;= posn )      total += face[idx++];   if ( total &gt; maxTot )      return false;// At the end, test the wrap-around cases:   if ( posn == size-1 )   {      total = face[posn-1] + face[posn] + face[0];      if ( total &gt; maxTot )         return false;      total = face[posn] + face[0] + face[1];      if ( total &gt; maxTot )         return false;   } // end if ( posn...   return true;} // end check()</pre><P><A HREF="#rl2">Back to Article</A></P><H4><A NAME="l3">Listing Three</H4><pre>void  Permute ( int X[], int Lim, int N, int MaxSum ){  int j;     // Loop variable// First possibility:  start-up case moving values through [0]   if ( Lim == 0 )   {      Permute (X, 2, N, MaxSum);      for ( j = 2; j &lt; N; j++ )      {         Swap ( j, 0, X );      // Note that X[1] is left unchanged at N-1.         Permute (X, 2, N, MaxSum);      }   // We will not bother regenerating the array here.   }// Next possibility:  intermediate case (incomplete permutation)   else if ( Lim &lt; N-1 )   {  int hold;      int PairSum = X[Lim-2] + X[Lim-1];   // Check the initial state      if ( X[Lim]+PairSum &lt;= MaxSum )         Permute (X, Lim+1, N, MaxSum);      for ( j = Lim+1; j &lt; N; j++ )      {         Swap ( j, Lim, X );      // Omit work if it gives an invalid result         if ( X[Lim]+PairSum &gt; MaxSum )            continue;      // Check for mirror-image rejection      // Note that X[1] contains the value N-1.         if ( Lim == 2 &amp;&amp; X[0] &gt; X[Lim] )            continue;         Permute (X, Lim+1, N, MaxSum);      }   // Regenerate the array state.      hold = X[Lim];      for ( j = Lim+1; j &lt; N; j++ )         X[j-1] = X[j];      X[N-1] = hold;   }// Final possibility:  complete permutation, so check for validity   else if ( Check(X, Lim, N, MaxSum) )         Process (X, N);// else it fails at the very end!}</pre><P><A HREF="#rl3">Back to Article</A></P></body></html>