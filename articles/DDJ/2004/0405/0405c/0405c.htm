<html><head><title>May04: Optimizing for  Intel Architecture CPUs</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Optimizing for  Intel Architecture CPUs</h1><p><i>Dr. Dobb's Journal</i> May 2004</p><h2>Taking advantage of computational units</h2><h3>By Victor J. Duvanenko</h3><I>Victor is a senior software engineer at Pinnacle Systems where he's been implementing image/video processing algorithms in silicon and software for the last 12 years. He can be contacted at vduvanenko@ pinnaclesys.com.</I><hr><p>Intel architecture CPUs are made of several parts working together to execute code&#151;execution units that actually do the computation, each with its own specialization. One unit is dedicated to integer computation, another to floating-point computation, and another executes specialized instructions that operate on multiple pieces of data simultaneously. The Pentium 4, for example, has two scalar integer execution units that are double-speed, one normal-speed scalar integer execution unit, a floating-point unit, and memory load/store execution units. Several of these units can&#151;and do&#151;run concurrently.</p><p>Furthermore, most Intel architecture (IA) CPUs also have two levels of cache that hold the most recently used data and instructions, in the statistical hopes that data near the current access point will also be accesses soon. The Pentium 4 level-one cache is 8 KB and much smaller than the level-two cache, which is 512 KB. The CPU looks for the data in the level-one (L1) cache first. If it does not find it there, then it looks in the level-two (L2) cache. If it does not find it there, then it looks in main memory. The Pentium 4 also has a separate cache for instructions.</p><h3>MMX, SIMD, SSE, SSE2</h3><p>Before the Pentium, IA CPUs operated on a single piece of data at a time; see <A NAME="rl1"><A HREF="#l1">Listing One</A>(a). On the Pentium 4, if these values are in CPU registers, then each of these additions takes 1/2 of a clock cycle to execute. This is amazing&#151;addition runs at twice the clock frequency. In other words, on a 3-GHz Pentium 4, addition runs at 6 GHz&#151;a peak rate of 6 Giga additions per second! These kinds of computations that operate on single pieces of data at a time are generally referred to as "scalar operations."</p><p>Starting with a special version of the Pentium, Intel added specialized instructions for processing multiple pieces of data simultaneously. These instructions fit into a category of operations that are generally called "Single Instruction Multiple Data" (SIMD). In other words, a single instruction is used to operate on multiple data items. These instructions are good at working on four, eight, or even on sixteen pieces of data simultaneously, and are efficient when you have lots of data to process, such as images or large arrays. Intel called these instructions "MultiMedia eXtensions" (MMX); see <A NAME="rl1"><A HREF="#l1">Listing One</A>(b).</p><p>The strange types<i> Iu8vec8, Iu16vec4, </i>and <i>Iu32vec2</i> being manipulated in <A NAME="rl1"><A HREF="#l1">Listing One</A>(c) are classes that Intel defined and delivers with its C++ compiler. Using these predefined types makes programming with MMX/SIMD instructions simpler than coding in assembly language. All of these types are 64 bits in total width, which is the width of the MMX integer registers.</p><p>In the first line of <A NAME="rl1"><A HREF="#l1">Listing One</A>(c), eight additions are performed simultaneously (each of these eight additions adds two 8-bit values together). In the second line, four additions are performed simultaneously. In the last line, two additions are performed simultaneously. On the Pentium 4, if these values are in CPU registers, then each of these MMX additions take 1 clock cycle to execute. Thus, on a 3-GHz Pentium 4, MMX additions run at the following peak rates:</p><ul>  <li>For 8-bit additions, 3 GHz&times;8 additions= 24 Giga additions per second.  <li>For 16-bit additions, 3 GHz&times;4 additions= 12 Giga additions per second.  <li>For 32-bit additions, 3 GHz&times;2 additions= 6 Giga additions per second.</ul><p>In theory, you can achieve substantial peak speedup by using MMX addition instead of scalar additions:</p><ul>  <li>8-bit additions. 24 Giga additions versus scalar 6 Giga additions, for a 4&times; speedup.  <li>16-bit addition. 12 Giga additions versus scalar 6 Giga additions, for a 2&times; speedup.  <li>32-bit addition. 6 Giga additions versus scalar 6 Giga additions, for no speedup.</ul><p>You'll see this pattern repeatedly for the amount of acceleration that MMX/SIMD instructions bring&#151;the larger the data size being manipulated, the smaller the amount of potential acceleration. The reason for this is simple&#151;the SIMD processing pipeline (unit) is fixed at 64 bits, and the scalar processing unit is 32-bits wide. Within these SIMD 64 bits, a greater number of smaller sized items can be processed in parallel and, of course, fewer larger sized items. This leads to a realization that for the greatest speedup, it is best to operate on the smallest possible items whenever possible and for as long as possible.</p><h3>A Little Bit of History</h3><p>MMX was the first set of instructions Intel added to its Pentium and Pentium II CPUs. MMX instructions operated on 64 bits at a time&#151;eight elements of 8 bits, four elements of 16 bits, two elements of 32 bits, or one element of 64 bits. All operations were on signed or unsigned integers.</p><p>With the Pentium 3, Intel added more integer instructions, as well as instructions to operate on four elements of 32-bit floating point. Instructions for data prefetching and caching control were also added. Eight registers were added for manipulating these quad 32-bit floating-point values (128-bit registers in width). Intel called these additions "Streaming SIMD Extensions" (SSE).</p><p>With the Pentium 4, Intel added a huge number of new instructions for integer and floating-point manipulation. Now, the 128-bit registers can be used to manipulate integers; for instance, 16 elements of 8 bits, eight elements of 16 bits, four elements of 32 bits, two elements of 64 bits, and one element of 128 bits. Intel also added more efficient memory read and write instructions. All of these additions went under the label of SSE2.</p><p>Sadly, on the Pentium 4, most of the execution units that process MMX/SSE/SSE2 instructions remained 64-bits wide, probably for economic and power usage reasons. This meant that the majority of the 128-bit SSE2 operations ended up running at 1/2 of the throughput of 64-bit SSE operations.</p><p>It is interesting that the same is true of SIMD floating-point instructions (Pentium 3 and Pentium 4), which run at half the peak throughput because the processing unit is only 64-bits wide and thus can process only two 32-bit single-precision floating-point values in each clock cycle. Processing four 32-bit floating-point values takes two cycles. With throughput being 1/2 of the possible peak (one instruction per clock cycle), most of the 128-bit instructions are running at half the clock rate.</p><h3>By Example</h3><p>To illustrate, say you want to initialize a block of contiguous memory to a certain value. You would write <A NAME="rl2"><A HREF="#l2">Listing Two</A>(a) in normal (scalar) C++ code, which writes every byte of the <i>memoryBuffer</i> array&#151;one byte at a time&#151;with whatever value that you specify.</p><p>With MMX instructions, you would accomplish the same task as in <A NAME="rl2"><A HREF="#l2">Listing Two</A>(b), which first initializes a 64-bit value, then uses that 64-bit value to initialize the <i>memoryBuffer</i> array 64 bits at a time. In theory, this MMX implementation should be eight times faster than our scalar implementation. Another way to accomplish the same task is to use the standard <i>memset()</i> function as in <A NAME="rl2"><A HREF="#l2">Listing Two</A>(c).</p><p>Benchmarking performance of these three examples for a 10,000,000-byte <i>memoryBuffer</i> array (on a 2.8-GHz Pentium 4 with a 533-MHz front-side bus, and 800-MHz Rambus system memory) you get:</p><ul>  <li><i>initMemoryByByte()</i> does 1.2 GB/sec.  <li><i>initMemoryByMMX()</i> does 1.2 GB/sec.  <li><i>initMemoryByMemset()</i> does 1.2 GB/sec.</ul><p>Hmmm...This doesn't seem right. Where is the 8&times; speedup? It seems that you aren't getting any speed up at all using MMX instructions and all implementations are the same speed. Maybe memory initialization does not benefit from MMX instructions at all? How about trying to improve the scalar code by storing more than just a byte at a time, as in <A NAME="rl3"><A HREF="#l3">Listing Three</A>(a). Benchmarking the performance of these functions, you get:</p><ul>  <li><i>initMemoryByShort()</i> does 1.2 GB/sec.  <li><i>initMemoryByLong()</i> does 1.2 GB/sec.</ul><p>But you're still not getting anywhere. Okay, now try the Pentium 4 SSE2 instructions in <A NAME="rl3"><A HREF="#l3">Listing Three</A>(b), which let you write 128 bits at a time to memory. Benchmarking the <i>initMemoryBySSE2()</i> function gives us 1.2 GB per second.</p><p>Is there anything else that can be done? Since you are initializing such a large array (10,000,000 elements), the array does not fit into the processor cache, which is 512 KB. Plus, when you initialize <i>memoryBuffer</i>, you touch each of the elements only once and never touch them again. The Pentium 3 and Pentium 4 have the capability of writing data around the cache. Try using this facility in <A NAME="rl3"><A HREF="#l3">Listing Three</A>(c) and see what happens. Benchmarking <i>initMemoryByMMXaroundCache()</i> gives us 2.6 GB per second.</p><p>Finally&#151;improved performance! This implementation is 2.6/1.2=2.2X speedup. But what's going on here? In all the cases except the last one, the data was first written into the cache, then taken from the cache and into the system memory. This was a two-step process. In the last implementation, the data went directly into the system memory, and was never placed into the cache. This is the main reason for the speedup. Can you go even faster? Try using SSE2 instructions in <A NAME="rl3"><A HREF="#l3">Listing Three</A>(d) and write around the cache. Benchmarking <i>initMemoryBySSE2aroundCache()</i> gives you 2.6 GB per second.</p><p>This 128-bit implementation seems to be going at the same speed as the 64-bit implementation. Could you have reached some other limit? The processor front-side bus runs at 533 MHz and is 64-bits wide (8 bytes). Thus, the peak bandwidth that can be transferred across the front-side bus is 533&times;8=4.2 GB per second. Also, the system memory subsystem in this machine is an 800-MHz Rambus, which is 32-bits wide (4 bytes). Thus, the peak bandwidth of system memory is 800&times;4=3.2 GB per second&#151;this must be the bandwidth limit you are hitting, and is most likely the best that you can do. Getting 2.6/3.2&times;100%=81% of peak possible performance is pretty incredible.</p><p>Is it possible to do even better? Since you reached the limit of the current machine, the only way to do better is to change machines. Intel has increased the speed of the front-side bus to 800 MHz, which gives a peak bandwidth of 800&times;8= 6.4 GB per second. System memory bandwidth has also been improved to 400-MHz dual-channel DDR (two channels of 64-bits wide), which provides 400&times;16=6.4 GB per second of bandwidth. I benchmarked the same code on one of these newer machines and measured 4.1 GB per second.</p><h3>Writing to Cache</h3><p>To this point, I've only examined the bandwidth limits of writing to system memory. I did this by writing a very large memory buffer, which does not fit into the processor cache. Now I explore the bandwidth limits of the processor cache by writing a smaller memory buffer, which fits into the processor cache. To do this, I benchmarked all of the implementations once again, but used a memory buffer of 100,000 bytes, which fits easily into the processor cache. The results of the benchmarks are:</p><ul>  <li><i>initMemoryByByte()</i> does 1.5 GB/sec.  <li><i>initMemoryByShort()</i> does 2.8 GB/sec.  <li><i>initMemoryByLong()</i> does 5.6 GB/sec.  <li><i>initMemoryByMemset()</i> does 12 GB/sec.  <li><i>initMemoryByMMX()</i> does 9.6 GB/sec.  <li><i>initMemoryByMMXaroundCache()</i> does 2.6 GB/sec.  <li><i>initMemoryBySSE2()</i> does 12 GB/sec.  <li><i>initMemoryBySSE2aroundCache()</i> does 2.6 GB/sec.</ul><p>These performance results make sense. The processor must have a much faster connection between the execution units and cache. As you write larger data items at a time, the bandwidth goes up by a similar amount; for instance, writing 16-bit items goes twice as fast as 8-bit items, and writing 32-bit items double the bandwidth once again. Writing 64 bits at a time nearly doubles the performance, but writing 128 bits at a time seems to hit a bandwidth limit of 12 GB per second.</p><p>Also amazing is that, if you try to unroll the loops in these examples, the performance does not increase. This means that the computational units, most likely working in parallel within each iteration of the loop, are much faster than the memory (L2 cache or system memory) in the Pentium 4.</p><h3>Conclusion</h3><p>In this paper, I analyzed just a small portion of the Intel processor architecture&#151;bandwidth of writes to the processsor cache and bandwidth of writes to system memory. The peak performance of these operations was 12 GB/sec. versus 4.1 GB/sec. Armed with this knowledge, you will be able to write code that extracts the maximum available performance.</p><p></p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4>(a)<pre>unsigned char a = 0, b = 1, c;c = a + b;unsigned short a = 0, b = 1, c;c = a + b;unsigned long a = 0, b = 1, c;c = a + b;</pre>(b)<pre>Iu8vec8  a, b, c;   // Iu8vec8 is array with 8 elements of unsigned charc = a + b;Iu16vec4  a, b, c;  // Iu16vec4 is array with 4 elements of unsigned shortc = a + b;Iu32vec2  a, b, c;  // Iu32vec4 is array with 2 elements of unsigned longc = a + b;</pre>(c)<pre>Iu8vec8 is really equivalent to "unsigned char  tmp[8]".Iu16vec4 is really equivalent to "unsigned short tmp[4]"Iu32vec2 is really equivalent to "unsigned long tmp[2]"</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4>(a)<pre>void initMemoryByByte( unsigned char * memoryBuffer,                       unsigned long length, unsigned char value ){    for( unsigned long i = 0; i &lt; length; i++ )        memoryBuffer[ i ] = value;}</pre>(b)<pre>void initMemoryByMMX( unsigned char * memoryBuffer,                      unsigned long length, unsigned char value ){    Iu8vec8            initValue;    unsigned long  i;    for( i = 0; i &lt; sizeof( Iu8vec8 ); i++ )        initValue[ i ] = value;    for( i = 0; i &lt; ( length / sizeof( Iu8vec8 )); i++ )        ((Iu8vec8 *)memoryBuffer )[ i ] = initValue;    empty();}</pre>(c)<pre>void initMemoryByMemset( unsigned char * memoryBuffer,                         unsigned long length, unsigned char value ){    memset( memoryBuffer, value, length );}</pre><P><A HREF="#rl2">Back to Article</A></P><H4><A NAME="l3">Listing Three</H4>(a)<pre>void initMemoryByShort( unsigned char * memoryBuffer,                        unsigned long length, unsigned char value ){    unsigned short  initValue = (((unsigned short) value ) &lt;&lt; 0 ) |                                (((unsigned short) value ) &lt;&lt; 8 );    for( unsigned long i = 0; i &lt; ( length / sizeof( unsigned short)); i++ )        ((unsigned short *)memoryBuffer )[ i ] = initValue;}void initMemoryByLong( unsigned char * memoryBuffer,                       unsigned long length, unsigned char value ){    unsigned long  initValue = (((unsigned long) value ) &lt;&lt;  0 ) |                               (((unsigned long) value ) &lt;&lt;  8 ) |                               (((unsigned long) value ) &lt;&lt; 16 ) |                               (((unsigned long) value ) &lt;&lt; 24 );    for( unsigned long i = 0; i &lt; ( length / sizeof( unsigned long )); i++ )        ((unsigned long *)memoryBuffer )[ i ] = initValue;}</pre>(b)<pre>void initMemoryBySSE2( unsigned char * memoryBuffer,                       unsigned long length, unsigned char value ){    Iu8vec16      initValue;    __m128i *      memoryBuffer128bitPtr = (__m128i *) memoryBuffer;    unsigned long i;    for( i = 0; i &lt; sizeof( Iu8vec16 ); i++ )   initValue[ i ] = value;    for( i = 0; i &lt; ( length / sizeof( Iu8vec16 )); i++ )        _mm_store_si128( memoryBuffer128bitPtr++, initValue );}</pre>(c)<pre>void initMemoryByMMXaroundCache( unsigned char * memoryBuffer,                                 unsigned long length, unsigned char value ){    Iu8vec8       initValue;    __m64 *       memoryBuffer64bitPtr = (__m64 *) memoryBuffer;    unsigned long i;    for( i = 0; i &lt; sizeof( Iu8vec8 ); i++ )        initValue[ i ] = value;    for( i = 0; i &lt; ( length / sizeof( Iu8vec8 )); i++ )        store_nta( memoryBuffer64bitPtr++, initValue );    empty();}</pre>(d)<pre>void initMemoryBySSE2aroundCache( unsigned char * memoryBuffer,                                  unsigned long length, unsigned char value ){    Iu8vec16      initValue;    __m128i *      memoryBuffer128bitPtr = (__m128i *) memoryBuffer;    unsigned long i;    for( i = 0; i &lt; sizeof( Iu8vec16 ); i++ )        initValue[ i ] = value;    for( i = 0; i &lt; ( length / sizeof( Iu8vec16 )); i++ )       _mm_stream_si128( memoryBuffer128bitPtr++, initValue );}</pre><P><A HREF="#rl3">Back to Article</A></P></body></html>