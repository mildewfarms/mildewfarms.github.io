<html><head><title>May04: To Inline or Not to Inline</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>To Inline or Not to Inline</h1><p><i>Dr. Dobb's Journal</i> May 2004</p><h2>A numerical model of inlining decision criteria</h2><h3>By Richard Vaughan</h3><I>Richard lives and works in London, where he provides development, training, and consultancy services. He can be contacted at http://www.dodeca.co.uk/</I><hr><p>Inline functions, supported by programming languages such as C++, can deliver dramatic performance improvements while preserving proper design semantics. However, the misuse of inlining can be detrimental to an application's performance. While certain classes of functions are obvious candidates for inlining, others are not. Moreover, inlining a given set of functions can affect performance in unexpected ways. Of course, profiling tools can be useful, but they don't always tell the whole story. Compounding this, profiling is a postcompilation step, which runs contrary to the idea of pushing as much of the development process into design time as is possible, instead of compile  time and runtime. To address problems such as these, I present in this article a way of visualizing the interplay between the different factors involved in making inlining decisions. </p><h3>The Problem</h3><p>In terms of source code, an inline function is virtually the same as any other function. When compiled, however, the body of the function is inserted at every call site, as opposed to a jump to a single instance of the body that is held elsewhere in the executable. Given that this obviates the overhead associated with the normal call mechanism, execution of the function should be faster. </p><p>But as straightforward as it seems, this is not a mandate for inlining everything. Compilation dependencies aside, there are three factors that affect your decision to inline or "outline" a given function:</p><ul>  <li>Compiled function size (assuming uniform size and machine cycles for each instruction).  <li>Static (or spatial) frequency (the number of places the function is called from).  <li>Dynamic (or temporal) frequency (the number of times the function is called in a typical run).</ul><p>Within these criteria, small functions are clear candidates for inlining because the proportion of overhead to real execution costs is very large. Inlining these will always result in faster and smaller executables. Moreover, a smaller executable contributes to faster execution. </p><p>However&#151;and this is the pivotal issue&#151;the effect is reversed with large functions because the proportion of overhead to body execution costs tends to be very small. Given that inlining, in principle, replicates the function body at each call site, many call sites lead to larger executables, which significantly impairs performance regardless of the faster execution that results from the calling overhead. </p><p>Generally, therefore, the benefits of inlining larger functions will only be retained if they are called from only one location (that is, Singletons). However, this principle can be offset by how often a function is called in a typical run of the program&#151;the more calls there are, the more the overhead-free benefit of inlining may be felt. Thus, runtime popularity may justify inlining a relatively large statically frequent function, and here lies the challenge: Can we construct a numerical model that better resolves the boundary between favorable and unfavorable inlining candidates?</p><h3>Calculating Inlining Favorability</h3><p>Even though a given function's performance metrics are highly platform dependent, you can quantify the three variables&#151;compiled function size, static frequency, and dynamic frequency&#151;as proportions. Moreover, you can try to determine whether a function's call overhead is paying its way or proving to be deadweight. Therefore, it follows that subtracting the cost of inlining from that of outlining yields the overall savings that results if the function is inlined&#151;its inlining "favorability." A negative result means that the cost of inlining exceeds that of outlining, meaning that the function should remain out of line. Expressed symbolically:</p><blockquote><p>Favorability=Outlining Cost-Inlining Cost</p></blockquote><p>An out-of-line call incurs an overhead in space because storage is consumed by the calling overhead instructions. However, an outlined call also incurs a cost in time because the CPU is delayed as it executes the calling overhead. Given this, you can define the total cost of outlining as a combination of the temporal and spatial costs. However, since we are dealing with proportions, the arithmetically correct method is to first take the sum and then subtract the product; for example:</p><blockquote><p>Outlining Cost = </p><p>Spatial Overhead+</p><p>Temporal Overhead-Spatial Cost&times;Temporal Cost</p></blockquote><p>From this, the favorability of inlining a given function can be expressed formally as follows, where <i>F, s</i>, <i>fs</i>, and <i>ft</i> denote favorability, size, spatial frequency, and temporal frequency, respectively:</p><blockquote><p><i>F</i>=(1-<i>s</i>)<i>f<sub>s</sub></i>+(1-<i>s</i>)<i>f<sub>t</sub></i>-<i>f<sub>s</sub></i>f<sub>t</sub>(1-<i>s</i>)<sup>2</sup>-<i>sf<sub>s</sub></i></p></blockquote><h3>Visualizing the Space</h3><p>Putting real numbers through this equation, you can map the results to a color scheme, where:</p><ul>  <li>Red means that the function should not be inlined.  <li>Yellow means that the merits/demerits of inlining a given function cancel each other out.  <li>Green indicates that inlining is beneficial. </ul><p>This lets you depict a three-dimensional "inlining-decision space," as in <A NAME="rf1"><A HREF="0405nf1.htm">Figure 1</A>.</p><p>What is immediately apparent (and as intuition suggests) about <A NAME="rf1"><A HREF="0405nf1.htm">Figure 1</A> is that the space is skewed towards choosing not to inline. Mostly, it is colored red, orange, and yellow because it is a situation of two against one&#151;plurality and size, against temporal popularity, which translates to the deleterious effects of inlining (executable bloat) against our desire to hurry the processor along. </p><p>In the best-case scenario (the lower front-right of the space), it is those CPU-popular little minnows that are called everywhere that make a real difference when inlined. Conversely, the functions that should remain forever out of line are very large, temporally unpopular, and spatially frequent (the top front-left of the space). Not that such behemoths should ever arise in any self-respecting developer's code; they indicate a poor understanding of design, coding, and compilation issues, one in which the issue of inlining is superfluous.</p><h3>The Boundary</h3><p>Given this distribution, the unfavorable part can be excised to leave just the area where inlining is beneficial. By adopting a linear scale for function size, then concentrating only on the 0.500 to 0.905 range, you can zoom in on the boundary and answer the original question. As <A NAME="rf2"><A HREF="0405nf2.htm">Figure 2</A> demonstrates, for example, temporally popular Singletons have an upper limit (in this model) of 0.86 in terms of real costs to overhead costs; past that, it is not worth inlining them.</p><h3>An Optimistic Nature</h3><p>So far, I have not addressed the nature of the function in question. Semantically, one block of source code differs radically from another, and this can have a great bearing on the decision to inline. First of all, functions can range from being entirely compute bound to entirely I/O bound, the latter being poor candidates for inlining. Second, different functions can be considerably more or less amenable to compiler optimizations. This is because, while inlining is an optimization in itself (when used correctly), the fact that it renders the function body visible from within the caller makes additional, powerful optimizations available. This can have a great bearing on your decision to inline because, viewed in this light, a previously unfavorable candidate can suddenly become favorable.</p><p>Given this, you can extend the aforementioned equation to yield the following, where <i>c</i> and <i>o</i> denote "compute binding" and "optimizability," respectively:</p><blockquote><p><i>F</i>=(1-<i>s</i>)<i>f</i><i><sub>s</i></sub>+(1-<i>s</i>)<i>f</i><i><sub>t</i></sub>-<i>f</i><i><sub>s</i></sub><i>f</i><i><sub>t</i></sub>(1-<i>s</i>)<sup>2</sup>-<i>sf</i><i><sub>s</i></sub>(1-(<i>c</i>+<i>o</i>-<i>co</i>))</p></blockquote><p>However, you run into difficulties here: First, it is not possible to (usefully) render a five-dimensional space in two dimensions, in a manner akin to my treatment of the original equation (although you could use a workaround). Second, determining a function's true potential for optimization is challenging and depends on the most intimate knowledge of your compiler, as well as a deep understanding of the language. Moreover, if an inline function contains other inline calls (and so on, recursively), then calculating its favorability metric is redundant because the code that is generated could be very distant from the code that you originally wrote.</p><h3>Show Me the Numbers</h3><p>Bear in mind that the C++ <i>inline</i> keyword is only a hint to the compiler; therefore, this discussion is in part academic, aside from the problem of incorporating compute binding and optimizability. In addition to this, seasoned developers may opine that they understand the various trade-offs intuitively. </p><p>Here lies an important lesson, however. This project began life as an ad hoc handout for a group of developers who attended a high-performance C++ training course. As a somewhat rough-and-ready illustration of inlining criteria, the decision space presented was, in part, an educated guess; <A NAME="rf3"><A HREF="0405nf3.htm">Figure 3</A> shows this. Comparing <A NAME="rf3"><A HREF="0405nf3.htm">Figure 3</A> with <A NAME="rf1"><A HREF="0405nf1.htm">Figure 1</A>, which was generated numerically, is revealing. Specifically, I overestimated the degree to which a high temporal frequency compensates for a high spatial frequency with larger functions. Clearly, the numbers do not support my sunny optimism and the upshot is that, while intuition gets us most of the way, to be absolutely sure, you must go to hard data. </p><p>For further explanation/exploration of issues pertaining to inlining and performance-oriented C++,<i> Efficient C++: Performance Programming Techniques </i>by Dov Bulka and David Mayhew (Addison-Wesley, 2000; ISBN 0201379503) is an excellent starting point. However, note that while the authors discuss static call frequency as a criterion, the inlining-decision matrix they present only plots function size against temporal frequency and is not founded on a numerical model.</p><p><b>DDJ</b></p></body></html>