<html><head><title>May04: Letters</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Letters</h1><p><i>Dr. Dobb's Journal</i> May 2004</p><p><b>I/O Multiplexing </b></p><p>Dear <i>DDJ</i>,</p><p>I found Ian Barile's article "I/O Multiplexing &amp; Scalable Sockets" (<i>DDJ</i>, February 2004) of grand proportions to be quite enlightening. I would, however, like to comment a bit on his mention of existing implementations. Ian posits that there are few I/O multiplexing implementations out there (which is true). However, I must point out that FreeBSD has an (quite powerful) alternative to traditional <i>select/poll&#151;kevent/kqueue</i>. Besides being far more efficient than <i>select/poll</i>, it also acts upon a larger set of system objects than just file descriptors. For example, predefined system filters make it possible to monitor for: <i>vnode</i> events (UFS filesystems only), socket/file/pipe/BPF descriptor events, network device events, timer events, asynchronous I/O (AIO) events, and process events. The API provides not only an adequate interface for the scalable I/O multiplexing that Ian seeks, but it also provides a means for monitoring for events generically.</p><p>Anthony Schneider</p><p>anthony@x-anthony.com</p><p><b>Who's On First Redux</b></p><p>Dear <i>DDJ</i>,</p><p>In regards, to Ron Wolf's "Letter" and Ed Nisley's response concerning the Atanasoff versus Univac debate (<i>DDJ</i>, March 2004), a new book entitled <i>Who Invented the Computer?: The Legal Battle That Changed Computing History,</i> by Alice R. Burks (Prometheus Books, 2003) adds more weight on Atanasoff's side. A grain of salt: Consider that Eckert and Mauchly stood to lose large amounts of money if their claims were invalidated.</p><p>Also in the March issue, the title of the article "Fostering Little Languages" by John Clements et al., rang a bell. "Little Languages" is a chapter heading in the book <i>The AWK Programming Language</i>, by Aho, Weinberger, and Kernighan. Their examples include designs for translators for <i>really</i> little languages. Examples include an assembler and interpreter, a graphing language, a language to describe sort commands in English, RP and infix calculators, and simple parsers. The assembler example has been adapted to real-world code generation for special-purpose processors built in programmable-logic arrays.</p><p>Bill Hickok </p><p>hickok@eznet.net</p><p><b>Doubling Down On Double Dispatch </b></p><p>Dear <i>DDJ</i>,</p><p>In his letter, "Double Dispatch Again Revisited" (<i>DDJ</i>, March 2004), Wolfgang Stephan comes full circle in the quest for an elegant solution to the double dispatch problem, which would allow for inheritance. Wolfgang's proposed solution appears identical to Scott Meyers's second attempt, quickly discarded, to address this problem in Item 31 of <i>More Effective C++: 35 New Ways to Improve Your Programs and Designs </i>(Addison-Wesley, 1996). The "fatal flaw" with this approach, according to Meyers, is that every existing <i>GameObject</i>-derived class must be modified whenever a new <i>GameObject</i>-derived class is added to the class hierarchy. His goal was to make the solution extensible without requiring changing, much less recompiling every existing class when a new derived class is added. Meyers's finally arrived at a solution both elegant and flawed. His idea was to create a map that associates pairs of class names with function pointers. The elegance of this approach was that it made use of Run-Time Type Identification (RTTI) to create the key strings, eliminating the need to add any extra members to the classes in the hierarchy in order to manage them. The flaw, of course is that type names in the map had to match the class names exactly, short circuiting inheritance. </p><p>Nat Goodspeed attempted in "Double Dispatch Revisited" (<i>DDJ</i>, January 2004) to address this new problem by replacing the <i>std::pair&lt;std::string,std::string&gt;</i> object that Meyers used as the key in his map with a functor class. I'm not going to completely summarize the article here, since clearly Wolfgang has taken the time to read it. But perhaps Wolfgang should (re)read the original item in Meyers's book, which inspired Nat's article.</p><p>David M. Miller </p><p>dmmiller@acm.org</p><p><b>Java 2D &amp; Web Pages</b></p><p>Dear <i>DDJ</i>,</p><p>Late last year, I was contacted by Dav Coleman asking if I could help him with some code that appeared in my article "Java 2D &amp; Web Pages" (<i>DDJ</i>, October 2003). The next time I heard from him, he had built an XMLRPC based on my code, turned it into a web service, and was using it on his site. Later on, somebody told me that I showed up on SourceForge. Turns out, Dav turned the whole thing into an open-source project. If readers want a peek at what he did, they can go to http://akuaku.org/archives/001138.shtml.</p><p>Paul Tremblett </p><p>ptremblett@audioaudit.com</p><p><b></p><p>Tech Support</b></p><p>Dear <i>DDJ</i>,</p><p>In his editorial "Small Is Beautiful" (<i>DDJ</i>, March 2004), Jonathan Erickson writes "Getting up early is a small price to pay to talk to a qualified engineer." I disagree. Dell (and other companies) owe their customers a qualified support technician no matter what time they call, and no matter where the call is routed. If they can't do that, the customers can, should, and eventually will find another company with which to do business.</p><p>Steve Greenland</p><p>steveg@moregruel.net</p><p><b>Porting Small-C</b></p><p>Dear <i>DDJ</i>,</p><p>Kudos to Pete Gray for his article "Porting Small-C" (<i>DDJ</i>, March 2004). Reference is made to "versions for the original 8086," but in fact the original <i>Small-C Handbook,</i> by James E Hendrix, which I have now on my desk, was written using the 8-bit 8080 processor. The software ran under the CP/M operating system. Reference is made to "the 8086 is an 8-bit microprocessor." The 8086 was a 16-bit microprocessor. Instructions, registers, and data transfer were all 16 bits. Perhaps part of the confusion arises from the fact that the particular variant used in the original IBM PC&#151;the 8088&#151;had an 8-bit data path. This did not affect the program, however, only slowing data fetch (two fetches for 16 bits instead of one) and was invisible to programmers who wrote for 16-bit computers. Finally, in regards to Pete's complaint that "documentation for the assembly language and 8086 processor is difficult to come by": The original reference manuals were available on the Intel web site until recently, and many books were written on the assembly language, some still current; for instance, <i>Assembly Language for Intel-Based Computers, </i>by Kip Irvine (Prentice Hall, 2002).</p><p>Harvey Nice</p><p>harvey@cti.depaul.edu</p><p><b>DDJ</b></p><hr></body></html>