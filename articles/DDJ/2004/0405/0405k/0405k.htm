<html><head><title>May04: Spam Filters &  .NET 2003 COM Add-Ins</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Spam Filters &amp;  .NET 2003 COM Add-Ins</h1><p><i>Dr. Dobb's Journal</i> May 2004</p><h2>Creating an HTML spam filter for Outlook</h2><h3>By Steve Goyette</h3><I>Steve is a senior web developer for CMP Media. He can be contacted at sgoyette@cmp.com.</I><hr><p>You'll try filters, you'll try rules, you'll try just about anything to stop e-mail spam from getting through&#151;but as hard as you try, there's always something that makes it through. The latest trick from our friends in black hats is to use HTML to send spam. Lately, for example, I've been inundated by spam that says I can get free cable TV. Now, I like free things as much as the next guy, but in my experience "free" usually means paying lots of money and getting little in return. No problem, I thought as I added "Free Cable" to my spam filter list. Thinking I'd fixed the problem, I went about my business only to receive four more e-mails offering me free cable. Deciding to get to the root of the problem, I started poking around and discovered that the e-mail is HTML encoded. Viewing the source I found this:</p><blockquote><p>&lt;enjoy&gt;F&lt;/enjoy&gt;r&lt;babble&gt;ee&lt;/babble&gt; 		    C&lt;thingie&gt;abl&lt;/thingie&gt;e</p></blockquote><p>What's happening here is that, because the viewer in Outlook is actually an embedded instance of Internet Explorer (IE), it's decoding this line and ignoring the tags that aren't part of the HTML standard. Once you remove them, you get "Free Cable." Thinking there must be some way around this with a rule, I poked around some more and ended up trying a VBA macro solution. What the macro (<A NAME="rl1"><A HREF="#l1">Listing One</A>) did was to strip anything inside "&lt;" and "&gt;" and check for specific words or phrases. This worked but evoked a bit of gotcha, as you can see in <A NAME="rf1"><A HREF="0405kf1.htm">Figure 1</A>.</p><p>It turns out that, at one time, Microsoft enabled automation of its Office products and, for a while, it was good. Then somebody figured out that if they put it inside an e-mail message, a script that would read the user's address list and send itself to all of the users contained therein would make a nasty little worm&#151;and it did. Seeing the error of its ways, Microsoft tightened security. This is fine if you're only running a script once but, in this case, I wanted to use it every time a new e-mail arrived. While there are probably other solutions to this issue, the one I chose was to convert my code to a COM add-in.</p><p>Microsoft Visual Studio .NET 2003 contains a nifty wizard for building Office add-ins. This wizard guides you through creating a project and ends up generating code. On the File menu, choose New -&gt; Project and Select Other Projects, then Extensibility Projects. The one you want is Shared Add-in (<A NAME="rf2"><A HREF="0405kf2.htm">Figure 2</A>). Click Next on the first page of the wizard (it's pretty, but not very useful), then choose Create an Add-in using Visual C# on the second page and hit Next. </p><p>For purposes here, we're only interested in creating an add-in for Microsoft Outlook, so uncheck all the rest and click Next. Enter a name and description of the add-in. In my case, it's "HTMLSpamFilter." Once you're done, click Next</p><p>The next step is important: Click the checkbox beside the option "I would like my Add-in to load when the host application loads," but leave the other one blank (<A NAME="rf3"><A HREF="0405kf3.htm">Figure 3</A>). The reason for this is that the add-in becomes an option in the COM add-in manager in Outlook only if you haven't marked it available to all users. If this isn't important to you, then choose the second option as well. Click Finish on the next page and you're presented with the skeleton code that loads the add-in every time Outlook loads. At the bottom of this code are two important objects:</p><blockquote><p>private object applicationObject;</p><p>private object addInInstance;</p></blockquote><p>You're going to change the <i>applicationObject</i> to be an instance of <i>Outlook.Application</i>; but first, you need to add Outlook as a reference in the project. You do this by going to the Project, Add Reference menu and selecting Microsoft Outlook from the COM tab (<A NAME="rf4"><A HREF="0405kf4.htm">Figure 4</A>). You can also add a reference to System.Windows.Forms.dll in the .NET tab. Once this is done, add this to the top of the file:</p><blockquote><p>using System.Windows.Forms;</p><p>using Outlook;</p></blockquote><p>Then, at the bottom of the file, change <i>private object applicationObject;</i> to <i>private Outlook.Application applicationObject;</i>. You connect the <i>applicationObject</i> to Outlook in the <i>onConnection</i> function, changing this function as in <A NAME="rl2"><A HREF="#l2">Listing Two</A>. This initializes the application object and casts it to an Outlook <i>Application</i> object. You can safely do this because, in the wizard, you chose <i>only</i> Outlook as the add-in host. You also have to add some clean-up code to the <i>onDisconnection </i>function (<A NAME="rl3"><A HREF="#l3">Listing Three</A>) to ensure that things are dereferenced properly.</p><p>The final important addition to the skeleton code is in the <i>OnStartupComplete</i> function, which ties the <i>NewMailEx </i>event to a function that you want called when a new mail item is received; see <A NAME="rl4"><A HREF="#l4">Listing Four</A>. The last thing to do is to add the function stub (<A NAME="rl5"><A HREF="#l5">Listing Five</A>) that gets called every time new mail is received.</p><p>If you build the solution and install it, the next time you run Outlook, you'll get a message box stating, "New Mail Received" whenever new messages are received. Neat, but not particularly useful.</p><p>To filter the spam, you need to access the actual message content. However, to do that, you first need to retrieve the message from the store. You do that by calling the function <i>GetItemFromID</i> like so:</p><blockquote><p>Outlook.MailItem item = </p><p>(Outlook.MailItem)outlookNamespace.Get-</p><p>                    ItemFromID(mailId, null);</p></blockquote><p>Use <i>null</i> as the second parameter (the <i>StoreID</i>) to tell it to use the default message store. Once you have the item, you can determine if it's in a nonplain format by testing the <i>BodyFormat</i> of the item like so:</p><blockquote><p>if ( item.BodyFormat != Outlook.OlBody-			Format.olFormatPlain ) {</p></blockquote><p>If it's not plaintext, then you'll want to strip out any HTML. You can do this with a simple state machine (<A NAME="rl6"><A HREF="#l6">Listing Six</A>). While this won't catch everything (entire libraries are written for that), it should suffice.</p><p>All that's left is to test for the inclusion of specific phrases. You do this by hard-coding the phrases into an array, such as:</p><blockquote><p>private String[] supressList = { "free cable",  	          "prescription", "mortgage" };</p></blockquote><p>If you find one of these bad boys, then move the message off to another folder (for this example, I'm using the "Junk E-mail" folder created by Outlook in the Personal Folders). <A NAME="rl7"><A HREF="#l7">Listing Seven</A> is the entire <i>NewMail</i> function. </p><p>Now I'll sit back and wait until somebody comes up with some new way to bug me. That's only a matter of time.</p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>' Function that will move e-mail that contains HTML spam to a specific folderPublic Sub FilterHTMLSpam(opMail As MailItem)   Dim slBody As String   On Error GoTo ErrorHandler   If opMail.BodyFormat &lt;&gt; olFormatPlain Then      Set myOlApp = CreateObject("Outlook.Application")      Set myNameSpace = myOlApp.GetNamespace("MAPI")      Set myPersonalFolders = myNameSpace.Folders("Personal Folders")      Set myDestFolder = myPersonalFolders.Folders("Junk E-mail")      ' We have an HTML message.  Flatten it      slBody = stripHTML(opMail.HTMLBody)      ' If after we strip and trim it's empty then it's VERY likely spam      If (Len(Trim(slBody)) &lt; 1) Then         opMail.Move myDestFolder      Else         ' See what we've got         If Contains(slBody, "descramble", "Medication", "Doctor", _                     "porn", "viagra", "cash", "Prescribes", _                     "naked", "adult", "%", "sell") Then            opMail.Move myDestFolder         End If      End If   End If   Exit SubErrorHandler:   Msg = "Error # " &amp; Str(Err.Number) &amp; " was generated by " _         &amp; Err.Source &amp; Chr(13) &amp; Err.Description   MsgBox Msg, , "Error", Err.HelpFile, Err.HelpContextEnd Sub' Function that will return true if any of the values in the ParamArray' are contained within the Body textPrivate Function Contains(spBody, ParamArray spText() As Variant) As Boolean  Dim slText As Variant  tempTest = LCase(spBody)  For Each slText In spText()    If InStr(tempTest, LCase(slText)) Then      Contains = True      Exit For    End If  NextEnd Function' Simple state machine to remove html tags from the input stringFunction stripHTML(HTMLString As String)    result = ""    pos = 1    skipping = False    While (pos &lt; Len(HTMLString))       enable = False       current = Mid(HTMLString, pos, 1)       If (current = "&lt;") Then skipping = True       If (current = "&gt;") Then enable = True       If (Not skipping) Then result = result + current       If (enable) Then skipping = False       pos = pos + 1    Wend    stripHTML = resultEnd Function</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>public void OnConnection(object application,     Extensibility.ext_ConnectMode connectMode,     object addInInst, ref System.Array custom) {applicationObject = (Outlook.Application)application;    mAddInInstance = addInInst;      if(connectMode != Extensibility.ext_ConnectMode.ext_cm_Startup) {        OnStartupComplete(ref custom);      }}</pre><P><A HREF="#rl2">Back to Article</A></P><H4><A NAME="l3">Listing Three</H4><pre>public void OnDisconnection(Extensibility.ext_DisconnectMode     disconnectMode, ref System.Array custom) {if(disconnectMode != Extensibility.ext_DisconnectMode.ext_dm_HostShutdown) {            OnBeginShutdown(ref custom);      }      applicationObject = null;}</pre><P><A HREF="#rl3">Back to Article</A></P><H4><A NAME="l4">Listing Four</H4><pre>public void OnStartupComplete(ref System.Array custom) {// Setup a function to be called on the NewMailEx Event      Outlook.NameSpace outlookNamespace =                                     mApplicationObject.GetNamespace("MAPI");      try {        utlookNamespace.Application.NewMailEx +=          new Outlook.ApplicationEvents_11_NewMailExEventHandler(this.NewMail);      } catch (System.Exception ex) {System.Windows.Forms.MessageBox.Show(ex.ToString());      }}</pre><P><A HREF="#rl4">Back to Article</A></P><H4><A NAME="l5">Listing Five</H4><pre>private void NewMail( String mailId ) {System.Windows.Forms.MessageBox.Show( "New Mail Received" );}</pre><P><A HREF="#rl5">Back to Article</A></P><H4><A NAME="l6">Listing Six</H4><pre>private string stripHTML( string source ) {System.Text.StringBuilder builder = new System.Text.StringBuilder();      int pos = 0;      bool skipping = false;        while ( pos &lt; source.Length ) {        if ( !skipping ) {                if ( source[pos] == '&lt;' ) {                    skipping = true;                } else {                    builder.Append( source[pos] );                }            } else {                if ( source[pos] == '&gt;' ) skipping = false;            }            pos ++;      }return builder.ToString();}</pre><P><A HREF="#rl6">Back to Article</A></P><H4><A NAME="l7">Listing Seven</H4><pre>// The list of words or phrases that we want to suppress/Mark as spamprivate String[] supressList = { "free cable", "prescription", "mortgage" };private void NewMail( String mailId ) {   try {      // First obtain the MAPI namespace from the Outlook Application      Outlook.NameSpace outlookNamespace =                                     applicationObject.GetNamespace("MAPI");      // Now retrieve the MailItem from the default store.      Outlook.MailItem item =            (Outlook.MailItem)outlookNamespace.GetItemFromID( mailId, null );      // Figure out where we want to put the junk mail      Outlook.MAPIFolder personalFolders =                                 outlookNamespace.Folders["Personal Folders"];      Outlook.MAPIFolder junkFolder = personalFolders.Folders["Junk E-mail"];      // See if the message is in a non plain format      if ( item.BodyFormat != Outlook.OlBodyFormat.olFormatPlain ) {         // Strip the body text         string body = stripHTML( item.HTMLBody );         for ( int i = 0; i &lt; supressList.Length; i ++ ) {            if ( body.IndexOf( supressList[i].ToLower() ) &gt;= 0 ) {               // We've got spam...move it to the junk folder               item.UnRead = true;               item.Move( junkFolder );            }         }      }   } catch ( System.Exception e ) {      System.Windows.Forms.MessageBox.Show( e.ToString() );   }}</pre><P><A HREF="#rl7">Back to Article</A></P></body></html>