<HTML>
<META NAME="year" CONTENT="1991">
<HEAD>
<TITLE>AUG91: A SOURCE CODE GENERATOR FOR C</TITLE></HEAD>
<BODY BGCOLOR="#ffffff">
<h1>A SOURCE CODE GENERATOR FOR C<a name="01ba_0003"></h1><P>
<h2><a name="01ba_0001"><a name="01ba_0000">A language-independent means of building programs that are consistent, elegant, and fast</h2><P>
<h3>Karl Vogel</h3><P>
<p><i><a name="01ba_0002"><a name="01ba_0000">Karl is a programmer for Control Data Corporation.  Contact him at 2970 Presidential Dr., Suite 200, Fairborn, OH 45324.</i></p><hr><P>
I have been writing code for about nine years, and one thing I've noticed is that programming can usually be divided into three phases.  Phase 1 (getting the idea) takes all of a millisecond and usually occurs somewhere really convenient, like in the shower.  Phase 3 (running the finished program on the machine) takes a few seconds or minutes for the type of applications I usually deal with.  Phase 2 (actually writing the bloody thing) usually takes a few orders of magnitude longer than Phases 1 and 3 put together.  I know life's not supposed to be fair, but this is ridiculous.<P>
Ever since I started working in a Unix shop, I've always wanted a &quot;programmer's assistant&quot; for C, kind of an invisible HAL 9000 sitting behind me and whispering things like &quot;I'm sorry, Dave, but I don't think that you should cast that pointer.  Malloc will barf, and your program will go west, taking me with it.&quot;  I don't have a clue about how to write something like that, so the next best thing is to take the 80 percent trashwork of coding away and leave me with the 20 percent that's fun.  I needed a code generator and my requirements were simple:<P>
<UL>
<li>It had to be very simple to use, with a minimum amount of nonsense to remember.</li>
<li>It had to run from the command line like any other program, with a minimum of options.</li>
<li>It had to be extensible, handling different coding conventions and languages if needed.</li>
<li>It had to write the outline of a program and then put me right into the editor of my choice.</li>
<li>It had to be simple enough to put together in a few hours, because a good idea now beats a great one on the drawing board any day.</li>
</UL>
The program I came up with is called &quot;new.&quot;  The source code for &quot;new&quot; is shown in <a href="#01ba_000b">Listings One through Ten</A>.  <a href="#01ba_000b">Listing One</A> (page 102) is new.h, which holds the data structure for the command line options, plus general definitions. <a href="#01ba_000d">Listing Two</A> (page 102) is macro.h, the header file for macro substitutions.  <a href="#01ba_000f">Listing Three</A> (page 102) shows new.c, which creates and optionally edits one or more new C programs.  <a href="#01ba_0011">Listing Four</A> (page 102) is CreateCode.c, which accepts the substitution structure, the input file, and the new C file to be created.  It also reads the template file, fills it in with the contents of the substitution structure, and writes the results to the new C file.<P>
<a href="#01ba_0013">Listing Five</A> (page 103) lists EditCode.c, which edits the new C file using either vi or whatever you have in your EDITOR environment variable.  <a href="#01ba_0015">Listing Six</A> (page 103) is GetOptions.c, which accepts the command line arguments and a pointer to a structure that holds the options.  It also parses the arguments into the structure.  <a href="#01ba_0017">Listing Seven</A> (page 104) shows Help.c, which prints help information to stdout.  <a href="#01ba_0019">Listing Eight</A> (page 106) lists OutString.c, which decides which macro string to return based on the current token character.  <a href="#01ba_001b">Listing Nine</A> (page 108), ReplaceMacros.c, accepts the macro structure holding the variables to be replaced, an input filepointer, and an output filepointer.  It also does token substitution from input to output.  Finally, <a href="#01ba_001d">Listing Ten</A> (page 108) is SetMacros.c, which sets up the MACRO structure used for token replacement.<P>
The &quot;new&quot; program works very much like the Unix program &quot;nroff.&quot;  The command nroff -mx file formats a file using a list of text formatting macros specified, by the -mx flag.  In a similar fashion, new -mx file creates a source code file using a template which is specified by the -mx flag.  In both cases, x is simply a file extension which identifies a given template file in a given directory.<P>
There is no reason for x to be restricted to a single character, although to save typing I've chosen single-character names for my programming templates.<P>
I have six C programming templates which manage to cover most of my needs:<P>
<UL>
<LI> -mf writes a generic C function other than main( ).  This is the default, because I use it most often.  <a href="#01ba_0004">Figure 1</A> shows the template itself, while <a href="#01ba_0011">Listing Four</A> shows an example of the expanded template put to use.</LI>
<LI> -mm writes a generic main routine with the standard arguments argc and argv.</LI>
<LI> -mh writes the comment section of a basic C include file.</LI>
<LI> -md writes a short main routine which is nothing but a driver/testbed for a function.</LI>
<LI> -ms writes a short stub function which is meant to serve as a placeholder.</LI>
<LI> -mi writes a simple I/O routine which reads from stdin (standard input) and writes to stdout (standard output).</LI>
</UL>

<h4><a name="01ba_0004">Figure 1: Generic function template</h4><P>
<pre>
  #ifndef lint
  static char      *    $n_$e_rcsid =
  &quot;$Header: $n.$e, v $r $y/$c/$d $h: $m:
                        $s $w Exp $&quot;;

  static char      * $n_$e_source =
  &quot;$Source$&quot;;
  #endif

  /*
   * NAME:
   * $n
   *
   * SYNOPSIS:
   * $t $n ($1)
   *
   * DESCRIPTION:
   * $u
   *
   * ARGUMENTS:
   * Describe any function arguments.
   *
   * AUTHOR:
   * $x
   *
   * BUGS:
   * None noticed.
   *
   * REVISIONS:
   *
   * $Log$
   */

  $i
  $p
  $g

  $t $n ($1)
  $a{
  /*
   * Functions.
   */

  $f
  /*
   * Variables.
   */

  $v
  /*
   * Processing.
   */

  $b
  return (0);
  }


</pre><P>

Due to space constraints, all of the templates and fully commented versions of the source files are available electronically; see &quot;Availability&quot; on page 3.  The source code listings presented here are complete, except for comments.<P>
In order to make this as flexible as possible, I used a simple token-substitution scheme in each template.  A template consists of straight text plus reserved tokens of the form $a, $b, and so on.  The dollar sign specifies the (possible) beginning of a token, and the first character after it tells the code generator what is to be inserted in place of the token.  If a dollar sign is followed by any character other than one of the ones recognized by the code generator, then the dollar sign and the character are simply passed along to the program file being generated.<P>
You don't have to live with the dollar sign as the start of a token; the code generator allows the token delimiter to be specified in one of the header files.  I use the dollar sign as the token delimiter throughout this article.<P>
Each token has a specific meaning: $a will be replaced by the argument list to a function, $d by the current day of the month, and so on.  A complete list of the recognized tokens and the substituted text for each one is provided in <a href="#01ba_0005">Table 1</A>.  I did my best to keep them reasonably mnemonic.<P>
<a href="#01ba_0006">Example 1(a)</A> shows a template for a header file, <a href="#01ba_0006">1(b)</A> some sample values for the reserved tokens, and <a href="#01ba_0006">1(c)</A> the resulting generated source code.  The line numbers in the example are for your convenience; they are not included in the template or the generated code.  Making the templates was easy; in each case, I picked a coding standard I could live with, copied a C program that reflected it into the template file, and replaced the guts of the program with tokens.<P>
The main data structure in &quot;new&quot; consists of a C structure which has one entry for each reserved token.  Some of the entries in the structure are filled using information from the command line, but most are not.  You may notice that a lot of the entries in the C token structure are not filled from within the code generator at all.  This is because someday when I have time (translation: When I get an initiative attack I can't talk myself out of), I want to write a screen-oriented version of the source code generator which would allow someone to fill some or all of the entries in the token structure interactively.  <a href="#01ba_0007">Figure 2</A> shows pseudocode which lays out the structure of the code generator as it currently exists.<P>
<h4><a name="01ba_0005">Table 1: Token substitution list</h4><P>
<pre>
  Token  Replacement string for the token

    a    Arguments for the function.  Full declarations separated by
            semicolons and newlines.
    b    Body of the function.  Comes under the first comment after the
            variable declarations.  Can include tabs and newlines.
    c    Current month
    d    Current day
    e    File extension
    f    Functions declared internally
    g    Global variables separated by semicolons
    h    Current hour
    i    &quot;Include&quot; commands, #include &lt;stdio.h&gt;
    l    Function argument list.  Variable names separated by commas
    m    Current minute
    n    Function name
    p    Preprocessor macros -- #define commands separated by newlines
    r    Revision level for a Revision Control System, the system I
            used in  this case
    s    Current second
    t    Type of function, such as char * or int
    u    Function usage.  This comes right after the first use of the
            name, and tells what the function is supposed to do.  Not
            to be confused with the &quot;Usage&quot; section in the intro
            comments.  This is the only &quot;smart&quot; macro: It won't let
            you put too many words on a line and starts each line with
            a comment indicator.  The comment indicator is a space
            followed by an asterisk; &quot;new&quot; assumes that there is both a
            leading /* and a trailing */ on some other line.
    v    Internal variables separated by semicolons, tabs, and newlines
    w    Who wrote the function
    x    Full name of the function author, extracted from the comment
            field in the /etc/passwd file
    y    Current year</pre><P>
<P>
<h4><a name="01ba_0006">Example 1: (a) Template file; (b) token replacement values; (c) generated code.</h4><P>
<pre>
  (a)  1  #ifndef lint
       2  static char  * $n_$e_rcsid =
       3      &quot;$Header: $n.$e,v $r $y/$c/$d $h:$m:$s $w Exp $&quot;;
       4
       5  static char  * $n_$e_source  =
       6      &quot;$Sources$&quot;;
       7  #endif
       8
       9  /*
       10  *  Header file for &quot;$n&quot;.
       11  *
       12  * $Log$
       13  */
       14
       15  #include  &lt;stdio.h&gt;

  (b)  $c  &quot;09&quot;
        $d  &quot;23&quot;
        $e  &quot;h&quot;
        $h  &quot;00&quot;
        $m  &quot;25&quot;
        $n  &quot;program&quot;
        $r  &quot;1.1&quot;
        $s  &quot;44&quot;
        $w  &quot;vogel&quot;
        $y  &quot;90&quot;

  (c)  1  #ifndef lint
       2  static char  *  program_h_rcsid  =
       3      &quot;$Header: program.h,v 1.1 90/09/23 00:25:44 vogel Exp $&quot;;
       4
       5  static char  *  program_h_source  =
       6      &quot;$Sources$&quot;;
       7  #endif
       8
       9   /*
       10   *  Header file for &quot;program&quot;.
       11   *
       12   *  $Log$
       13   */
       14
       15  #include  &lt;stdio.h&gt;</pre><P>
<P>
<h4><a name="01ba_0007">Figure 2: Pseudocode that illustrates the structure of the code generator</h4><P>
<pre>
  begin
  look for some sensible command line options and one or more files to
   create
      if (none found)
      then

             print help
             bail out
      endif
      for (each file on the command line)
      do

             set up the structure holding the tokens to be substituted
             filter text from the template file to the output program,
                                   doing appropriate token replacement
             edit the output program

      done
  end</pre><P>
<P>
I'm a big believer in separating the user interface part of a program from the part that does the actual work.  Keeping all of the information needed to generate a C function within a single data structure makes a special-purpose code generator much easier to write, because it doesn't matter where the information stored in the token structure comes from: an input screen, another program, a file, or any combination thereof.  The code generator needs only a filled token structure.<P>
If I ever had to write a &quot;mass-code&quot; generator to read a bunch of input files and generate a bunch of functions and programs, the token structure would make it possible for me to write code that looks like <a href="#01ba_0008">Example 2</A>.<P>
<h4><a name="01ba_0008">Example 2: A flexible data structure leads to code that looks like this.</h4><P>
<pre>
  while (getinfo (input file, pointer to the C token structure))
  do
     putfunction (output file, pointer to the C token structure)
  done</pre><P>
<P>
In this case, getinfo would read a file and fill the token structure, and putfunction would read the stuff in the token structure and write the C code.  The input file format has no necessary connection to the output file format, and this is a case of two totally dissimilar data structures which have to peacefully coexist in the same program.  Whenever you have a case like this, either marry the data structures or divorce them, but don't let them live in sin.  A divorce seemed the cleanest solution; input and output functions only communicate through the token structure, and otherwise know nothing about each other.<P>
<h3><a name="01ba_0009">Why a Code Generator?<a name="01ba_0009"></h3><P>
Whether you use this code generator, buy a commercial one, or gird up your loins and roll your own doesn't matter.  What does matter is getting one and using it, and here's why:<P>
Consistency This is one reason I can't emphasize enough.  With so many projects involving multiple programmers and even multiple teams, anything that helps communication between the worker bees isn't to be sneered at.  Consistent code appearance doesn't guarantee understandable code, but it doesn't hurt, and a code generator makes enforcement of coding standards easier.<P>
As I see it, the main problem with coding standards is that they don't take into account the fact that coding usually boils down to some poor schlub typing at a terminal.  If you don't at least try to make that person's life easier when imposing your standard, forget it, you'll get lip service at best and outright rebellion at worst.  In the area of software, a poor solution is actually worse than none at all, because it lulls people into thinking that the &quot;problem&quot; is being &quot;solved.&quot;  (Isn't this how we wound up with Ada?)<P>
Beauty There's something about a well-crafted piece of code that makes it very easy on the eyes, but occasionally appearance suffers when deadlines loom.  Instead of sprucing up every function by hand, spruce up your templates and let the code generator do the boring stuff.<P>
Generality The templates and code here are presented in C, but there is no reason for it to be that way.  One code generator can handle C, Pascal, Modula-2, or whatever you have the patience to write a template for.  I used one-letter template names because I'm not a typing fan, not because it's a requirement of the code generator.<P>
Economy One of the things I admire most about Unix is what they left out.  Unix handles files, processes, and nothing else.  This type of code generator encourages you to develop your code one function at a time, but Unix doesn't &quot;know&quot; anything about functions.  To teach Unix about functions, you can use a tool such as &quot;ctags&quot; to make editing source files easier, but &quot;ctags&quot; must be kept up to date every time you make a significant change to your source. The code generator encourages the idea of &quot;one function, one file,&quot; and if you make a one-to-one correspondence between functions and files, then Unix knows about functions too. This enables you to use the power of the Unix toolset (and mindset) on each separate compilable portion of a C program, and for me that equates to finer control over the whole process.<P>
I certainly respect companies that care enough about their programmers to buy CASE tools, but I've noticed that the current products have a bit of an attitude: &quot;Be reasonable, write your code, and design your products OUR way.&quot;  Instead of buying a CASE tool and changing your methods to suit the machine (or another vendor), why not expand the capacities of the operating system you have now?<P>
Speed Placing one function in one file puts a permanent end to the game of &quot;let's find the function,&quot; and in combination with a decent &quot;make&quot; tool for generating executables from a list of dependencies, it also ensures that you are doing the minimum amount of recompilation when you modify source during development.  Goodbye &quot;ctags&quot;!<P>
Program Tracing If I write any program which is going to receive widespread use by a lot of different people, I like to impress the customer by being aware of problems before I get the irate phone call, not after.  One easy way to do this is to build an ErrorMsg function which accepts the arguments: ErrorMsg (file, line, format, arg1, arg2, ...) where file is the name of the function (stored in the __FILE__ preprocessor variable), line is the line number at which the problem occurred (stored in the __LINE__ preprocessor variable), format is the output format used by functions in the printf family, and the remaining arguments are variables which get referenced from within the output format.  The ErrorMsg function appends an appropriate message to an error file, and just before the main routine exits, another function, AnyErrors, checks the error file to see if it contains anything.  If AnyErrors returns TRUE, a third function, MailMsg, mails the error file to me.<P>
The important point here is that with one function per file, the __FILE__ pre-processor variable always tells me exactly what function is messing up, so I don't have to look at a source listing somewhere and mutter &quot;Let's see, line 600 is function foobar, I think, but what's at line 700?&quot;  I know immediately what functions were called in what order, and if the ErrorMsg function was called enough times with enough information, I may have everything I need to fix the problem without having to use a debugger.  I've always believed that if you have to fire up a debugger to fix a problem, then you have a much more basic problem with your code that a debugger can't fix.<P>
Flexibility Having one function per file makes writing all kinds of neat tools much easier. For example, I have another program called &quot;doc&quot; which looks through one or more directories, and prints the comment header from a given function, in case I forget the order of the arguments or something.  It won't cure cancer but it does save time, and I didn't have to put in too many late evenings to write it, either. doc reads a function name from the argument list, appends .c to it if it's not there already, and uses the Unix access call to see if a file by that name exists in one of several directories.  If such a file is found, the comment header is written to stdout.<P>
<h3><a name="01ba_000a">Conclusion<a name="01ba_000a"></h3><P>
Of course, you can make just as big a mess with a code generator as without, and you can do it faster; a fool with a tool is just a well-equipped fool.  Like any other tool, a code generator can save beaucoup time only if it's used with some common sense.  I tend to be wary of any CASE product that claims to let you write code &quot;without thinking about it;&quot; anyone who writes code for someone else's use without thinking is dangerous.<P>

<PRE>

_A SOURCE CODE GENERATOR FOR C_
by Karl Vogel

<a name="01ba_000b">
<a name="01ba_000c"></pre><B>[LISTING ONE]</B><pre><a name="01ba_000c">

/* File &quot;new.h&quot; */

#ifndef   lint
static char    *new_h_rcsid =
&quot;$Header: new.h,v 1.5 91/03/29 19:23:08 vogel Exp $&quot;;

static char    *new_h_source =
&quot;$Source: /d/cdc/vogel/source/new/RCS/new.h,v $&quot;;

#endif

/*
 * NAME:
 *   new.h
 *
 * SYNOPSIS:
 *   #include &quot;new.h&quot;
 *
 * DESCRIPTION:
 *   Holds the data structure for the command line options, plus
 *   general definitions.
 *
 * AUTHOR:
 *   Karl Vogel
 *
 * BUGS:
 *   None noticed.
 *
 * REVISIONS:
 *
 * $Log:   new.h,v $
 * Revision 1.5  91/03/29  19:23:08  vogel
 * 1.  Renamed the directory holding the templates.
 *
 * Revision 1.4  91/03/15  16:56:33  vogel
 * 1.  Ran indent on the code and reformatted the comment header.
 *
 * Revision 1.3  90/07/03  14:21:20  vogel
 * 1.  Added a new field:  extension of the program to be created.  This is also
 *     in &quot;macro.h&quot;, but it can be most easily set from examining the command
 *     line options.
 *
 * Revision 1.2  90/07/03  12:07:06  vogel
 * 1.  Added a flag to the OPTIONS structure which is TRUE if the created file
 *     is to be edited, FALSE otherwise.
 *
 * Revision 1.1  90/06/29  15:32:04  vogel
 * Initial revision
 *
 */

#include   &lt;stdio.h&gt;

#define      YES      1
#define      NO      0

/* Error codes.  */
#define      OK      0
#define      EMALLOC      1

/* Set directory holding templates, and prefix of each template file.  */
#define      DIRECTORY   &quot;/d/cdc/vogel/source/new/&quot;
#define      PREFIX      &quot;template.&quot;

/* Set up the options structure.  */
struct options_data
{
   char          **files;      /* NULL-terminated array of C files
                * to be created. */
   char           *template;   /* Full name of the desired
                * template file. */
   char            exten[5];   /* Extension of the program to be
                * created.  */
   int             edit;      /* True if the created program is to
                * be edited. */
   int             help;      /* True if help is needed. */
};

typedef struct options_data OPTIONS;




<a name="01ba_000d">
<a name="01ba_000e"></pre><B>[LISTING TWO]</B><pre><a name="01ba_000e">


/* File &quot;macro.h&quot; */

#ifndef   lint
static char    *macro_h_rcsid =
&quot;$Header: macro.h,v 1.2 91/03/15 16:56:28 vogel Exp $&quot;;

static char    *macro_h_source =
&quot;$Source: /d/cdc/vogel/source/new/RCS/macro.h,v $&quot;;

#endif

/*
 * NAME:
 *   macro.h
 *
 * SYNOPSIS:
 *   #include &quot;macro.h&quot;
 *
 * DESCRIPTION:
 *   Header file for macro substitutions.
 *
 * AUTHOR:
 *   Karl Vogel
 *
 * BUGS:
 *   Any problems or suggestions.
 *
 * REVISIONS:
 *
 * $Log:   macro.h,v $
 * Revision 1.2  91/03/15  16:56:28  vogel
 * 1.  Ran indent on the code and reformatted the comment header.
 *
 * Revision 1.1  90/06/29  17:40:15  vogel
 * Initial revision
 *
 */

#define      BUFFER      512

struct macro_data
{
   char            args[BUFFER];   /* Arguments for the function: full
                * declarations separated by
                * semicolons and newlines. Replaces
                * $a in a template.  */
   char            body[BUFFER];   /* Body of the function.  Comes under
                * the first comment after the
                * variable declarations. Includes
                * tabs and newlines. Replaces $b in
                * a template.  */
   char            exten[5];   /* Extension of the created file,
                * usually &quot;.c&quot;.  Replaces $e in a
                * template. */
   char            functions[BUFFER];   /* Internal function
                   * declarations. Comes just
                   * after the start of the
                   * function itself.  Includes
                   * tabs and newlines.
                   * Replaces $f in a template. */
   char            globals[BUFFER];/* External global variables. Comes
                * just before the start of the
                * function itself.  Includes tabs
                * and newlines.  Replaces $g in a
                * template. */
   char            include[BUFFER];/* External include files.  Comes
                * just before the start of the
                * function itself.  Includes tabs
                * and newlines.  Replaces $i in a
                * template.  */
   char            alist[BUFFER];   /* Short form of the argument list,
                * consisting of just the variable
                * names separated by commas.
                * Replaces $l in a template. */
   char            name[64];   /* Name of the function being
                * created.  May or may not be the
                * same as the filename. Replaces $n
                * in a template.  */
   char            define[BUFFER];   /* Holds preprocessor #define
                * statements separated by newlines.
                * Replaces $p in a template. */
   char            rev[16];   /* Current revision level of the
                * created function.  Replaces $r in
                * a template. */
   char            type[32];   /* Type of function created, i.e.
                * char * or int.  Replaces $t in a
                * template.  */
   char            usage[BUFFER];   /* Comes right after the first use of
                * the function name, and tells you
                * what the function is supposed to
                * do.  Just above the Usage section
                * in the intro comments.  This is
                * the only &quot;smart&quot; macro: won't let
                * you put too many words on a line,
                * and starts each line with a
                * comment indicator.  Replaces $u in
                * a template. */
   char            vars[BUFFER];   /* Holds internally-declared
                * variables, separated by tabs,
                * semicolons, and newlines. Replaces
                * $v in a template.  */
   char            userid[16];   /* Holds the author's userid.
                * Replaces $w in a template.  */
   char            username[BUFFER];   /* Holds the author's full
                   * name. Replaces $x in a
                   * template.  */
   char            token;      /* Holds the character to be used as
                * a token indicator.  Shown as a
                * dollar sign in this file.  */
   int             year;      /* Current year.  Replaces $y in a
                * template. */
   int             month;      /* Current month.  Replaces $c in a
                * template. */
   int             day;      /* Current day.  Replaces $d in a
                * template. */
   int             hour;      /* Current hour.  Replaces $h in a
                * template. */
   int             minute;      /* Current minute.  Replaces $m in a
                * template.  */
   int             second;      /* Current second.  Replaces $s in a
                * template.  */
};
typedef struct macro_data MACRO;




<a name="01ba_000f">
<a name="01ba_0010"></pre><B>[LISTING THREE]</B><pre><a name="01ba_0010">

/* File &quot;new.c&quot; */

#ifndef   lint
static char    *new_c_rcsid =
&quot;$Header: new.c,v 1.6 91/03/15 16:55:42 vogel Exp $&quot;;

static char    *new_c_source =
&quot;$Source: /d/cdc/vogel/source/new/RCS/new.c,v $&quot;;

#endif

/*
 * NAME:
 *   new
 *
 * SYNOPSIS:
 *   new [-c] [-h] [-mx] file [file ...]
 *
 * DESCRIPTION:
 *   Creates and optionally edits one or more new C programs.
 *
 *   &quot;new&quot; makes extensive use of templates to create new C files.
 *   A template file has the name &quot;template.x&quot;, where 'x' is the string
 *   which follows '-m' in the program arguments.
 *
 *   You can create other templates by adding template files to the
 *   template directory specified in the header file &quot;new.h&quot;.
 *
 * OPTIONS:
 *   &quot;-c&quot;   creates a new program but does NOT edit it.
 *
 *   &quot;-h&quot;   prints help information if improper or no arguments at all
 *      are given.
 *
 *   &quot;-mx&quot;   creates a program of type 'x', where x is one of the following:
 *      d - function driver.
 *      f - normal function (default).
 *      h - header file.
 *      i - program to handle simple I/O.
 *      m - main routine with arguments.
 *      o - function to handle command line arguments.
 *      s - stub (placeholder) function.
 *
 *   &quot;file&quot;   is one or more C files to be created.  A suffix of &quot;.c&quot; will
 *      be appended if it isn't there already.  If the file already
 *      exists, you will be asked if you want to overwrite it.
 *
 * AUTHOR:
 *   Karl Vogel
 *
 * BUGS:
 *   None noticed.
 *
 * REVISIONS:
 *
 * $Log:   new.c,v $
 * Revision 1.6  91/03/15  16:55:42  vogel
 * 1.  Ran indent on the code and reformatted the comment header.
 *
 * Revision 1.5  90/09/24  16:42:03  vogel
 * 1.  Corrected a typo in the comments.
 *
 * Revision 1.4  90/07/03  14:20:23  vogel
 * 1.  Copied the desired file extension into the MACRO structure.
 *
 * Revision 1.3  90/07/03  12:05:23  vogel
 * 1.  Added &quot;nextfile&quot; variable, to hold the next file to be created.
 * 2.  Got rid of debugging print statements for the macros structure.
 * 3.  Added code to create and optionally edit each file in turn.
 *
 * Revision 1.2  90/06/29  17:40:04  vogel
 * 1.  Added header file and definitions for the macro substitution strings.
 * 2.  Added code to print help if needed.
 *
 * Revision 1.1  90/06/29  15:27:52  vogel
 * Initial revision
 *
 */

#include   &quot;new.h&quot;
#include   &quot;macro.h&quot;
#include   &lt;strings.h&gt;
#include   &lt;sys/param.h&gt;

main (argc, argv)
int             argc;
char          **argv;
{

/* Variables. */
   MACRO          *macros;
   MACRO           macbuffer;

   OPTIONS        *options;
   OPTIONS         opbuffer;

   char            nextfile[MAXPATHLEN];

   int             k;
   int             status;

/* Process command line options. If they aren't OK, offer help and exit. */
   options = &amp;opbuffer;
   status = GetOptions (argc, argv, options);

   if (status == EMALLOC)
   {
      fprintf (stderr, &quot;Severe memory error -- please call the &quot;);
      fprintf (stderr, &quot;System Administrator.\n&quot;);
      exit (1);
   }

   if (options-&gt;help)
   {
      (void) Help ();
      exit (1);
   }

/* Set up the substitution macros.  */
   macros = &amp;macbuffer;
   SetMacros (macros);
   (void) strcpy (macros-&gt;exten, options-&gt;exten);

/* Create and optionally edit each file in turn.  */
   for (k = 0; options-&gt;files[k]; ++k)
   {
      (void) strcpy (nextfile, options-&gt;files[k]);

      if (CreateCode (macros, options-&gt;template, nextfile) == 0)
         if (options-&gt;edit)
            EditCode (nextfile);
   }

   exit (0);
}





<a name="01ba_0011">
<a name="01ba_0012"></pre><B>[LISTING FOUR]</B><pre><a name="01ba_0012">

/* File &quot;CreateCode.c&quot; */

#ifndef   lint
static char    *CreateCode_c_rcsid =
&quot;$Header: CreateCode.c,v 1.2 91/03/15 16:55:25 vogel Exp $&quot;;

static char    *CreateCode_c_source =
&quot;$Source: /d/cdc/vogel/source/new/RCS/CreateCode.c,v $&quot;;

#endif

/*
 * NAME:
 *   CreateCode
 *
 * SYNOPSIS:
 *   #include &quot;macro.h&quot;
 *
 *   int CreateCode (macros, template, nextfile)
 *   MACRO * macros;
 *   char * template;
 *   char * nextfile;
 *
 * DESCRIPTION:
 *   Accepts the substitution structure, the input file, and the new C
 *   file to be created.  Reads the template file, fills it in with the
 *   contents of the substitution structure, and writes the results to
 *   the new C file.
 *
 *   A function value of 0 is returned if everything is OK.
 *   A function value of 1 is returned if the template could not be read.
 *   A function value of 2 is returned if the output could not be written.
 *
 * ARGUMENTS:
 *   &quot;macros&quot; is the structure holding the macro substitution values.
 *   &quot;template&quot; is the name of the input template file.
 *   &quot;nextfile&quot; is the name of the next output file.
 *
 * AUTHOR:
 *   Karl Vogel
 *
 * BUGS:
 *   None noticed.
 *
 * REVISIONS:
 *
 * $Log:   CreateCode.c,v $
 * Revision 1.2  91/03/15  16:55:25  vogel
 * 1.  Ran indent on the code and reformatted the comment header.
 *
 * Revision 1.1  90/07/03  11:59:45  vogel
 * Initial revision
 *
 */

#include   &quot;macro.h&quot;
#include   &lt;stdio.h&gt;
#include   &lt;strings.h&gt;
#include   &lt;sys/file.h&gt;

#define      SMALLBUF   20

int             CreateCode (macros, template, nextfile)
MACRO          *macros;
char           *template;
char           *nextfile;
{

/* Variables. */

   FILE           *in;
   FILE           *out;

   char           *base;
   char           *dot;
   char            last[SMALLBUF];
   char            prompt[SMALLBUF];

   int             length;
   int             status;

/* If filename already has default extension specified in MACRO structure, zap
 * it so we can store the function name in the MACRO structure. */
   status = 0;
   in = (FILE *) NULL;
   out = (FILE *) NULL;

   last[0] = '.';
   last[1] = '\0';

   (void) strcat (last, macros-&gt;exten);
   length = strlen (last);

   if (dot = rindex (nextfile, '.'))
      if (strcmp (dot, last) == 0)
         *dot = '\0';

   if (base = rindex (nextfile, '/'))
      base++;
   else
      base = nextfile;

   (void) strcpy (macros-&gt;name, base);
   (void) strcat (nextfile, last);

/* If output file already exists, make sure that user wants to overwrite it. */
   if (access (nextfile, F_OK) == 0)
   {
      printf (&quot;File \&quot;%s\&quot; exists.  Overwrite?  &quot;, nextfile);
      fflush (stdout);
      fgets (prompt, SMALLBUF, stdin);

      if (prompt[0] != 'y' &amp;&amp; prompt[0] != 'Y')
      {
         printf (&quot;\&quot;%s\&quot; not overwritten.\n&quot;, nextfile);
         goto done;
      }
   }

/* Open the input template file. */
   if ((in = fopen (template, &quot;r&quot;)) == (FILE *) NULL)
   {
      printf (&quot;Unable to open template file \&quot;%s\&quot;\n&quot;, template);
      status = 1;
      goto done;
   }

/* Open the output C file. */
   if ((out = fopen (nextfile, &quot;w&quot;)) == (FILE *) NULL)
   {
      printf (&quot;Unable to open C file \&quot;%s\&quot;\n&quot;, nextfile);
      status = 2;
      goto done;
   }

/* Do the macro substitution, clean up, and return. */
   ReplaceMacros (in, macros, out);
done:
   if (in)
      (void) fclose (in);
   if (out)
      (void) fclose (out);
   return (status);
}



<a name="01ba_0013">
<a name="01ba_0014"></pre><B>[LISTING FIVE]</B><pre><a name="01ba_0014">

/* File &quot;EditCode.c&quot; */

#ifndef   lint
static char    *EditCode_c_rcsid =
&quot;$Header: EditCode.c,v 1.2 91/03/15 16:55:28 vogel Exp $&quot;;

static char    *EditCode_c_source =
&quot;$Source: /d/cdc/vogel/source/new/RCS/EditCode.c,v $&quot;;

#endif

/*
 * NAME:
 *   EditCode
 *
 * SYNOPSIS:
 *   int EditCode (nextfile)
 *   char * nextfile;
 *
 * DESCRIPTION:
 *   Edits the new C file using either &quot;cvi&quot; or whatever the user has in
 *   his &quot;EDITOR&quot; environment variable.
 *
 * ARGUMENTS:
 *   &quot;nextfile&quot; is the new C file.
 *
 * AUTHOR:
 *   Karl Vogel
 *
 * BUGS:
 *   None noticed.
 *
 * REVISIONS:
 *
 * $Log:   EditCode.c,v $
 * Revision 1.2  91/03/15  16:55:28  vogel
 * 1.  Ran indent on the code and reformatted the comment header.
 *
 * Revision 1.1  90/07/03  12:00:13  vogel
 * Initial revision
 */

#include   &lt;stdio.h&gt;

int             EditCode (nextfile)
char           *nextfile;
{

/* Functions.  */
   char           *getenv ();

/* Variables.  */
   char           *editor;
   char            cmd[BUFSIZ];

   int             status;

/* Create and execute the edit command.  */
   if (editor = getenv (&quot;EDITOR&quot;))
      (void) strcpy (cmd, editor);
   else
      (void) strcpy (cmd, &quot;cvi&quot;);
   (void) strcat (cmd, &quot; &quot;);
   (void) strcat (cmd, nextfile);
   (void) system (cmd);

   return (0);
}




<a name="01ba_0015">
<a name="01ba_0016"></pre><B>[LISTING SIX]</B><pre><a name="01ba_0016">

/* File &quot;GetOptions.c&quot; */

#ifndef   lint
static char    *GetOptions_c_rcsid =
&quot;$Header: GetOptions.c,v 1.4 91/03/15 16:55:31 vogel Exp $&quot;;

static char    *GetOptions_c_source =
&quot;$Source: /d/cdc/vogel/source/new/RCS/GetOptions.c,v $&quot;;

#endif

/*
 * NAME:
 *   GetOptions
 *
 * SYNOPSIS:
 *   #include &quot;new.h&quot;
 *
 *   int GetOptions (argc, argv, options)
 *   int argc;
 *   char ** argv;
 *   OPTIONS * options;
 *
 * DESCRIPTION:
 *   Accepts the command line arguments and a pointer to a structure which
 *   holds the options, and parses the arguments into the structure.
 *
 * ARGUMENTS:
 *   &quot;argc&quot; and &quot;argv&quot; are the normal C program variables holding the
 *   argument list.
 *
 *   &quot;options&quot; is the structure meant to hold the options.
 *
 * AUTHOR:
 *   Karl Vogel
 *
 * BUGS:
 *   Any problems or suggestions.
 *
 * REVISIONS:
 *
 * $Log:   GetOptions.c,v $
 * Revision 1.4  91/03/15  16:55:31  vogel
 * 1.  Ran indent on the code and reformatted the comment header.
 *
 * Revision 1.3  90/07/03  14:19:49  vogel
 * 1.  Added code to set up the file extension based on the command line options.
 *     &quot;new -mh&quot; gives you a file with name ending in &quot;.h&quot;, anything else gives
 *     you a file with name ending in &quot;.c&quot;.
 *
 * Revision 1.2  90/07/03  12:01:01  vogel
 * 1.  Added new option '-c'.
 * 2.  Added code to make sure that default template is properly set up.
 *
 * Revision 1.1  90/06/29  15:28:13  vogel
 * Initial revision
 *
 */

#include   &quot;new.h&quot;
#include   &lt;strings.h&gt;

#define      SMALL      10

int             GetOptions (argc, argv, options)
int             argc;
char          **argv;
OPTIONS        *options;
{

/* Functions. */
   char           *malloc ();

/* Variables. */
   char           *next;
   char            extension[SMALL + 1];

   int             count;
   int             flags;
   int             k;
   int             status;

   unsigned int    length;

/* Initialize options to defaults.  */
   options-&gt;files = (char **) NULL;
   options-&gt;template = (char *) NULL;
   options-&gt;edit = YES;
   options-&gt;help = NO;

   (void) strcpy (extension, &quot;f&quot;);

   count = 0;
   status = OK;

/* Handle the flags, and count the files. */
   for (k = 1; k &lt; argc; ++k)
   {
      next = argv[k];

      if (*next == '-')
      {
         next++;

         if (*next == 'm')
         {
            (void) strncpy (extension, next + 1, SMALL);
            extension[SMALL] = '\0';
         }

         else
         if (*next == 'c')
            options-&gt;edit = NO;

         else
         {
            options-&gt;help = YES;
            goto done;
         }
      }

      else      /* option does not start with a dash  */
         count++;
   }

/* If no files were specified, set help flag. Otherwise, store filenames. */
   if (count)
   {
      length = (unsigned) ((count + 1) * (sizeof (char *)));
      if (options-&gt;files = (char **) malloc (length))
      {
         for (k = 1, count = 0; k &lt; argc; ++k)
            if (*argv[k] != '-')
               options-&gt;files[count++] = argv[k];
         options-&gt;files[count] = (char *) NULL;
      }
      else
      {
         status = EMALLOC;
         goto done;
      }
   }
   else
   {
      options-&gt;help = YES;
      goto done;
   }

/* Set up the file extension. */
   if (strcmp (extension, &quot;h&quot;) == 0)
      options-&gt;exten[0] = 'h';
   else
      options-&gt;exten[0] = 'c';

   options-&gt;exten[1] = '\0';

/* Set up the template pathname.  */
   length = (unsigned) (strlen (DIRECTORY) + strlen (PREFIX) +
              strlen (extension) + 1);
   if (options-&gt;template = malloc (length))
      (void) sprintf (options-&gt;template, &quot;%s%s%s&quot;, DIRECTORY,
            PREFIX, extension);
   else
      status = EMALLOC;
done:
   return (status);
}




<a name="01ba_0017">
<a name="01ba_0018"></pre><B>[LISTING SEVEN]</B><pre><a name="01ba_0018">

/* File &quot;Help.c&quot; */

#ifndef   lint
static char    *Help_c_rcsid =
&quot;$Header: Help.c,v 1.4 91/03/15 16:55:33 vogel Exp $&quot;;

static char    *Help_c_source =
&quot;$Source: /d/cdc/vogel/source/new/RCS/Help.c,v $&quot;;

#endif

/*
 * NAME:
 *   Help
 *
 * SYNOPSIS:
 *   int Help ()
 *
 * DESCRIPTION:
 *   Prints help information to stdout.
 *
 * ARGUMENTS:
 *   None.
 *
 * AUTHOR:
 *   Karl Vogel
 *
 * BUGS:
 *   None noticed.
 *
 * REVISIONS:
 *
 * $Log:   Help.c,v $
 * Revision 1.4  91/03/15  16:55:33  vogel
 * 1.  Ran indent on the code and reformatted the comment header.
 *
 * Revision 1.3  90/09/24  16:40:47  vogel
 * 1.  Corrected a typo.
 *
 * Revision 1.2  90/07/03  12:01:42  vogel
 * 1.  Changed print strings to reflect new '-c' option.
 *
 * Revision 1.1  90/06/29  17:40:46  vogel
 * Initial revision
 *
 */

#include   &lt;stdio.h&gt;

int             Help ()
{

/* Variables.  */
   int             k;

   static char    *array[] =
   {
    &quot;&quot;,
    &quot;\tnew:\t\tcreates and optionally edits one or more new C&quot;,
    &quot;\t\t\tprograms.&quot;,
    &quot;&quot;,
    &quot;\t\tUsage:\tnew [-c] [-h] [-mx] file [file ...]&quot;,
    &quot;&quot;,
    &quot;\t\tWhere:\t\&quot;-c\&quot;\tcreates a new program but does NOT edit it.&quot;,
    &quot;&quot;,
    &quot;\t\t\t\&quot;-h\&quot;\tprints a help file.  Help is also given if&quot;,
    &quot;\t\t\t\tno arguments at all are given.&quot;,
    &quot;&quot;,
    &quot;\t\t\t\&quot;-mx\&quot;\tcreates a program of type 'x', where x is&quot;,
    &quot;\t\t\t\tone of the following:&quot;,
    &quot;\t&quot;,
    &quot;\t\t\t\td - function driver.&quot;,
    &quot;\t\t\t\tf - normal function (default).&quot;,
    &quot;\t\t\t\th - header file.&quot;,
    &quot;\t\t\t\ti - program to handle simple I/O.&quot;,
    &quot;\t\t\t\tm - main routine with arguments.&quot;,
    &quot;\t\t\t\to - function to handle command line arguments.&quot;,
    &quot;\t\t\t\ts - stub (placeholder) function.&quot;,
    &quot;&quot;,
    &quot;\t\t\t\&quot;file\&quot;\tis one or more C files to be created.  A&quot;,
    &quot;\t\t\t\tsuffix of \&quot;.c\&quot; will be appended if it isn't&quot;,
    &quot;\t\t\t\tthere already.&quot;,
    &quot;\t&quot;,
    &quot;\t\t\t\tIf the file already exists, you will be asked&quot;,
    &quot;\t\t\t\tif you want to overwrite it.&quot;,
    &quot;&quot;,
    &quot;&quot;,
    &quot;\t\t\&quot;new\&quot; makes extensive use of templates to create new C files.&quot;,
    &quot;\t\tA template file has the name \&quot;template.x\&quot;, where 'x' is the&quot;,
    &quot;\t\tstring which follows '-m' in the program arguments.&quot;,
    &quot;\t&quot;,
    &quot;\t\tYou can create other templates by adding template files to&quot;,
   &quot;\t\tthe template directory specified in the header file \&quot;new.h\&quot;.&quot;,
    (char *) NULL
   };

/* Write the help information. */
   for (k = 0; array[k]; ++k)
      puts (array[k]);
   return (0);
}




<a name="01ba_0019">
<a name="01ba_001a"></pre><B>[LISTING EIGHT]</B><pre><a name="01ba_001a">

/* File &quot;OutString.c&quot; */

#ifndef   lint
static char    *OutString_c_rcsid =
&quot;$Header: OutString.c,v 1.2 91/03/15 16:55:35 vogel Exp $&quot;;

static char    *OutString_c_source =
&quot;$Source: /d/cdc/vogel/source/new/RCS/OutString.c,v $&quot;;

#endif

/*
 * NAME:
 *   OutString
 *
 * SYNOPSIS:
 *   #include &quot;new.h&quot;
 *   #include &quot;macro.h&quot;
 *
 *   int OutString (macros, current, string)
 *   MACRO * macros;
 *   char current;
 *   char * string;
 *
 * DESCRIPTION:
 *   Decides which macro string to return based on the current token
 *   character.
 *
 *
 * ARGUMENTS:
 *   &quot;macros&quot; holds the current macro replacement values.
 *
 *   &quot;current&quot; is the value of the token character following a dollar sign.
 *
 *   &quot;string&quot; is the replacement value of that token.
 *
 * AUTHOR:
 *   Karl Vogel
 *
 * BUGS:
 *   None noticed.
 *
 * REVISIONS:
 *
 * $Log:   OutString.c,v $
 * Revision 1.2  91/03/15  16:55:35  vogel
 * 1.  Ran indent on the code and reformatted the comment header.
 *
 * Revision 1.1  90/07/03  12:02:28  vogel
 * Initial revision
 *
 */

#include   &quot;new.h&quot;
#include   &quot;macro.h&quot;
#include   &lt;stdio.h&gt;
#include   &lt;ctype.h&gt;
#include   &lt;strings.h&gt;

int             OutString (macros, current, string)
MACRO          *macros;
char            current;
char           *string;
{

/* Variables.  */
   char           *blank;
   char           *s;
   char           *t;
   char            temp[BUFFER];

   int             col;
   int             first;
   int             length;
   int             status;

/* Do the simple string replacements, and numeric conversion.  */
   switch (current)
   {
      case 'a':
         (void) strcpy (string, macros-&gt;args);
         break;
      case 'b':
         (void) strcpy (string, macros-&gt;body);
         break;
      case 'c':
         (void) sprintf (string, &quot;%2.2d&quot;, macros-&gt;month);
         break;
      case 'd':
         (void) sprintf (string, &quot;%2.2d&quot;, macros-&gt;day);
         break;
      case 'e':
         (void) strcpy (string, macros-&gt;exten);
         break;
      case 'f':
         (void) strcpy (string, macros-&gt;functions);
         break;
      case 'g':
         (void) strcpy (string, macros-&gt;globals);
         break;
      case 'h':
         (void) sprintf (string, &quot;%2.2d&quot;, macros-&gt;hour);
         break;
      case 'i':
         break;
      case 'l':
         (void) strcpy (string, macros-&gt;alist);
         break;
      case 'm':
         (void) sprintf (string, &quot;%2.2d&quot;, macros-&gt;minute);
         break;
      case 'n':
         (void) strcpy (string, macros-&gt;name);
         break;
      case 'p':
         (void) strcpy (string, macros-&gt;define);
         break;
      case 'r':
         (void) strcpy (string, macros-&gt;rev);
         break;
      case 's':
         (void) sprintf (string, &quot;%2.2d&quot;, macros-&gt;second);
         break;
      case 't':
         (void) strcpy (string, macros-&gt;type);
         break;
      case 'u':
         break;
      case 'v':
         (void) strcpy (string, macros-&gt;vars);
         break;
      case 'w':
         (void) strcpy (string, macros-&gt;userid);
         break;
      case 'x':
         (void) strcpy (string, macros-&gt;username);
         break;
      case 'y':
         (void) sprintf (string, &quot;%2.2d&quot;, macros-&gt;year);
         break;
      default:
         *string = '\0';
         break;
   }

/* Handle &quot;Usage&quot; string. Write no more than 50 characters/line, indented
 *3 tab spaces in. */
   if (current == 'u')
   {
      (void) strcpy (temp, macros-&gt;usage);
      t = temp;
      *string = '\0';
      first = YES;
      while (length = strlen (t))
      {
         if (!first)
            (void) strcat (string, &quot;\n * \t\t\t&quot;);

         first = NO;
         if (length &lt;= 50)
         {
            (void) strcat (string, t);
            break;
         }
         else
         {
            blank = (char *) NULL;
            col = 25;
            for (s = t; *s &amp;&amp; col &lt; 75; ++s, ++col)
               if (isspace (*s))
                  blank = s;
            if (blank)
            {
               *blank = '\0';
               (void) strcat (string, t);
               t = blank + 1;
            }
            else
            {
               (void) strcat (string, t);
               break;
            }
         }
      }
   }

/* Handle the &quot;include&quot; strings. */
   if (current == 'i')
   {
      for (s = string, t = macros-&gt;include; *t; ++s, ++t)
      {
         if (*t == ' ')
            *s = '\t';
         else
            *s = *t;
      }
      *s = '\0';
   }
   return (0);
}




<a name="01ba_001b">
<a name="01ba_001c"></pre><B>[LISTING NINE]</B><pre><a name="01ba_001c">

/* File &quot;ReplaceMacros.c&quot; */

#ifndef   lint
static char    *ReplaceMacros_c_rcsid =
&quot;$Header: ReplaceMacros.c,v 1.2 91/03/15 16:55:37 vogel Exp $&quot;;

static char    *ReplaceMacros_c_source =
&quot;$Source: /d/cdc/vogel/source/new/RCS/ReplaceMacros.c,v $&quot;;

#endif

/*
 * NAME:
 *   ReplaceMacros
 *
 * SYNOPSIS:
 *   #include &quot;macro.h&quot;
 *
 *   int ReplaceMacros (in, macros, out)
 *   FILE * in;
 *   MACRO * macros;
 *   FILE * out;
 *
 * DESCRIPTION:
 *   Accepts the macro structure holding the variables to be replaced,
 *   an input filepointer, and an output filepointer.  Does token
 *   substitution from input to output.
 *
 * ARGUMENTS:
 *   Described above.
 *
 * AUTHOR:
 *   Karl Vogel
 *
 * BUGS:
 *   None noticed.
 *
 * REVISIONS:
 *
 * $Log:   ReplaceMacros.c,v $
 * Revision 1.2  91/03/15  16:55:37  vogel
 * 1.  Ran indent on the code and reformatted the comment header.
 *
 * Revision 1.1  90/07/03  12:02:42  vogel
 * Initial revision
 *
 */

#include   &quot;macro.h&quot;
#include   &lt;stdio.h&gt;
#include   &lt;ctype.h&gt;
#include   &lt;strings.h&gt;

int             ReplaceMacros (in, macros, out)
FILE           *in;
MACRO          *macros;
FILE           *out;
{

/* Variables. */
   char           *s;
   char            string[BUFFER];
   char            current;
   char            previous;

/* Start the main loop which looks ahead one character. */
   previous = getc (in);
   if (previous == EOF)
      return (0);

/* Decide what to do if we get a token character. */
   while ((current = getc (in)) != EOF)
   {
      if (previous == macros-&gt;token)
      {
         if (index (&quot;abcdefghilmnprstuvwxy&quot;, current))
         {
            OutString (macros, current, string);
            for (s = string; *s; ++s)
               putc (*s, out);
            previous = getc (in);
         }
         else
         {
            putc (previous, out);
            previous = current;
         }
      }
      else
      {
         putc (previous, out);
         previous = current;
      }
   }

/* Don't forget to write the last character. */
   putc (previous, out);
   return (0);
}




<a name="01ba_001d">
<a name="01ba_001e"></pre><B>[LISTING TEN]</B><pre><a name="01ba_001e">

/* File &quot;SetMacros.c&quot; */

#ifndef   lint
static char    *SetMacros_c_rcsid =
&quot;$Header: SetMacros.c,v 1.4 91/03/15 16:55:40 vogel Exp $&quot;;

static char    *SetMacros_c_source =
&quot;$Source: /d/cdc/vogel/source/new/RCS/SetMacros.c,v $&quot;;

#endif

#include   &quot;macro.h&quot;
#include   &lt;stdio.h&gt;
#include   &lt;strings.h&gt;
#include   &lt;pwd.h&gt;
#include   &lt;sys/time.h&gt;

int             SetMacros (macros)
MACRO          *macros;
{

/* Functions. */
   char           *getenv ();
   struct passwd  *getpwuid ();

/* Variables. */
   char           *s;
   int             offset;
   long            clock;
   struct passwd  *ptr;
   struct tm      *now;

/* Set up the internal C stuff.  The &quot;name&quot; entry will be set later. */
   macros-&gt;args[0] = '\0';
   macros-&gt;body[0] = '\0';
   macros-&gt;functions[0] = '\0';
   macros-&gt;globals[0] = '\0';
   macros-&gt;alist[0] = '\0';
   macros-&gt;name[0] = '\0';
   macros-&gt;define[0] = '\0';
   macros-&gt;usage[0] = '\0';
   macros-&gt;vars[0] = '\0';

   (void) strcpy (macros-&gt;exten, &quot;c&quot;);
   (void) strcpy (macros-&gt;rev, &quot;1.1&quot;);
   (void) strcpy (macros-&gt;type, &quot;int&quot;);

   (void) strcpy (macros-&gt;include,
             &quot;#include &lt;stdio.h&gt;\n#include &lt;ctype.h&gt;&quot;);

/* Set up userid and full name of program author. See if we can get the
 * information from the environment. If that fails, look it up from userid
 * and passwd file. */
   macros-&gt;userid[0] = '\0';
   macros-&gt;username[0] = '\0';

   if (s = getenv (&quot;USER&quot;))
      (void) strcpy (macros-&gt;userid, s);
   if (s = getenv (&quot;USERNAME&quot;))
      (void) strcpy (macros-&gt;username, s);
   if (strlen (macros-&gt;userid) == 0 || strlen (macros-&gt;username) == 0)
   {
      if (ptr = getpwuid (getuid ()))
      {
         (void) strcpy (macros-&gt;userid, ptr-&gt;pw_name);
         if (strncmp (ptr-&gt;pw_gecos, &quot;Civ &quot;, 4) == 0)
            offset = 4;
         else
            offset = 0;
         (void) strcpy (macros-&gt;username,
                   ptr-&gt;pw_gecos + offset);
         if (s = index (macros-&gt;username, ';'))
            *s = '\0';
      }
      else
      {
         (void) strcpy (macros-&gt;userid, &quot;unknown&quot;);
         (void) strcpy (macros-&gt;username, &quot;unknown&quot;);
      }
   }

/* Set the character which we will recognize as the start of a token.  */
   macros-&gt;token = '$';

/* Set up the current date and time.  */
   (void) time (&amp;clock);
   now = localtime (&amp;clock);
   macros-&gt;second = now-&gt;tm_sec;
   macros-&gt;minute = now-&gt;tm_min;
   macros-&gt;hour = now-&gt;tm_hour;
   macros-&gt;day = now-&gt;tm_mday;
   macros-&gt;month = now-&gt;tm_mon + 1;
   macros-&gt;year = now-&gt;tm_year;

   return (0);
}
</pre>

<HR><P>Copyright &copy; 1991, <I>Dr. Dobb's Journal</I></P></BODY></HTML>
