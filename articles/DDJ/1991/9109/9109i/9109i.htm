<HTML>
<META NAME="year" CONTENT="1991">
<HEAD>
<TITLE>SEP91: A BRIEF MACRO PACKAGE FOR EDITING BINARY FILE SYSTEMS</TITLE></HEAD>
<BODY BGCOLOR="#ffffff">
<h1>A BRIEF MACRO PACKAGE FOR EDITING BINARY FILE SYSTEMS<a name="020d_0003"></h1><P>
<h2><a name="020d_0001"><a name="020d_0000">Synchronized side-by-side windows -- and mouse support, too</h2><P>
 This article contains the following executables: BRIEF.ARC<P>
<h3>James Rodriguez</h3><P>
<p><i><a name="020d_0002"><a name="020d_0000">Jim is a technical support engineer and BRIEF macro enthusiast who has acted as technical advisor to several third-party developers.  He can be reached at Solution Systems, 372 Washington Street, Wellesley, MA 02191.</i></p><hr><P>
The programmer's editor known as BRIEF (Basic Reconfigurable Interactive Editing Facility) is built on the concept of extensibility and programmability.  Macros are so ingrained in the design of BRIEF that many of the standard editing functions are implemented in the macro language, rather than in compiled code.  By writing your own BRIEF macros, you can tailor the standard editor in both small ways (such as setting start-up colors, tab settings, or window positions), and large ways (such as modifying existing commands or creating new commands of your own design).<P>
This article describes a package of BRIEF macros that lets you edit binary files in BRIEF, using two side-by-side windows that display both hex and ASCII representations of binary data.<P>
The BRIEF Macro Language CBRIEF, the macro language used here, has a syntax that resembles C. Earlier versions of BRIEF used a LISP-like macro language, which is still supported.  In fact, CBRIEF macros are translated to the older LISP syntax before being compiled into a bytecode representation.<P>
The primitives in CBRIEF fall into three categories: language primitives, editing primitives, and DOS primitives.  The language primitives provide the usual programming language control structures, operators, and data types.  The editing primitives control the core functionality of the text editing engine -- manipulating resources such as windows, buffers, keyboards, cursor position, and other state variables.  The DOS primitives let you query the environment for system information, as well run stand-alone DOS programs from within BRIEF.<P>
<h3><a name="020d_0004">Text Files vs. Binary Data<a name="020d_0004"></h3><P>
The core engine that underlies the standard set of BRIEF macros is designed for editing text files, not binary files.  When reading in a file, for example, it converts all zero-valued characters (that is, the ASCII NUL) to spaces.  It also expects lines to end with the CR/LF sequence (as found in standard DOS text files), but will also wrap lines when a lone CR is encountered.  Editing beyond the end of a screen line or file automatically repositions the terminator character and pads the file accordingly.<P>
A file that contains binary data will therefore obviously conflict with BRIEF's default actions.  The default behavior is bound in at a low level -- part of the compiled executable. Unless you want to patch machine-language code, it is hard to modify this behavior directly. Fortunately, BRIEF provides a means of intercepting the default processing of a file by using a &quot;registered&quot; macro.  When a macro is registered (with the register_macro primitive), it will be executed every time a particular event occurs.  In our case, we will intercept processing whenever a buffer is created by the standard edit_file primitive.<P>
Once this is done, you can spawn an external program to convert the binary file into a corresponding text representation.  The user can then edit the resulting text file within BRIEF, and, upon completion, convert it back to its binary form.  Actually, our conversion program, BBE, creates two files from the one binary file: a .HEX (hex representation) file and an .ASC file (printable ASCII characters).  The hex and ASCII files are displayed in two side-by-side windows and are modified simultaneously by the user.  When editing the file, the keyboard bindings are changed to enable newly defined movement keys, 0-F typeable keys, and several function keys.<P>
<h3><a name="020d_0005">&quot;Language&quot; Macros<a name="020d_0005"></h3><P>
Before going over the listing, some background on &quot;language macros&quot; is necessary.  The purpose of language macros is to execute a specific package of language-specific macros associated with a particular file type (a file's type is determined by its file extension, such as .HEX, .C, or .ASM).<P>
All package macros are activated by a registered macro named _call_packages found in LANGUAGE.CB, a standard BRIEF file.  This language macro is executed every time a new file is edited or a different buffer is attached to the current window.  This mechanism is implemented by creating and maintaining a system buffer database of information specific to file extensions.  Whenever a different file extension is encountered, new information is added to the system buffer by parsing the BPACKAGES environment variable.<P>
The _call_packages macro then accesses this information and executes the macros listed for that particular event.  A full discussion of this is beyond the scope of this article.  For our purposes, what is important is the parsing and execution of the _on event.  In the system buffer, we first remove any existing references to .HEX extensions, and then add our package information.  The most important of these insertions is the enhancement of the .hex_on line. The macros listed on this line will be called by the language macros every time a .HEX file is attached to the current window.<P>
The name _bin_on was chosen as an example of how _call_package would have created the name if the bin package were being loaded via BPACKAGES.  In our case, we modify the system buffer directly, so we can use any arbitrary name.  All of this will become more clear as we discuss the implementation.<P>
<h3><a name="020d_0006">The Package Implementation<a name="020d_0006"></h3><P>
My macro package for editing binary files is shown in <a href="#020d_000c">Listings One</A>  (page 98) and <a href="#020d_000e">Two</A> (page 100).  Note that space restrictions do not allow printing all the source code for the entire package, which amounts to 3000 lines.  The complete version is available in electronic form; see &quot;Availability,&quot; on page 3.<P>
Whenever any macro file is loaded into BRIEF, the _init macro within the file will be executed.  In the case of the binary editing macro package, my_init macro creates a system buffer (__hex _files) which acts as the database for storing the names and true file extensions of files which have been converted.  The _init macro also registers the macro (_bin_edit) that intercepts the file editing process and specifies the keyboard assignments used for hex editing.  (The use of a leading underscore in a macro name is to prevent it from being called by the user with the F10 key -- the execute_macro command.)<P>
The registered macro _bin_edit recognizes a binary file by the error message &quot;Null characters in file fixed,&quot; displayed by BRIEF's edit_file primitive whenever a binary 0 is converted to a space.<P>
After prompting the user for confirmation, _bin_edit calls _hex_edit.  Two parameters are passed to _hex_edit: the original filename and a flag.  The flag allows a text file to be edited as if it were binary.  The system buffer database __hex_files is searched to see if the file is already controlled by the macro package.  If not, a command line is created with sprintf, and a DOS program is run to accomplish the file conversion.<P>
<h3><a name="020d_0007">Conversion and Reconversion<a name="020d_0007"></h3><P>
Writing a program to convert a binary file into formatted hex and ASCII files and back again is not a difficult exercise.  The interesting decisions are: how to represent the nondisplayable ASCII characters (NULL, CR, TAB), how to control the program with command-line parameters, and how to format each group of bytes.  Parameters to the stand-alone converter, BBE, specify the conversion mode and the names of resulting output files.<P>
BBE accommodates conversions from binary to hex, from Unix to DOS line termination, and from raw data file to fixed-length records.  The Unix and fixed-length record features of the package will not be discussed here.  The conversion from binary to hex creates two files: an ASCII hex representation with 50 characters per line (representing 25 binary bytes) terminated with a CR-LF sequence and an ASCII representation with the 25 corresponding ASCII text characters.<P>
The reconversion process is handled by write_buffer, a &quot;replacement macro.&quot;  A replacement macro is a function that can completely replace a standard editor primitive with the same name.  More typically, replacement macros are used to alter the default behavior of the original function, by doing a little bit of processing and then calling the original function to complete the processing.  This saves having to reimplement complex code from scratch.<P>
A potential problem for the reconversion utility is encountering a byte with a value of 26 (Control-Z, which serves as the DOS end-of-file marker).  This is dealt with by ignoring any line whose length is less than 50 characters.<P>
Note that, during the reconversion process, any bytes with the &quot;XX&quot; character sequence are not converted.  This is an easy way to implement byte deletion: During interactive editing, when the user presses the delete key, the selected bytes are replaced with Xs in the hex buffer.<P>
<h3><a name="020d_0008">Editing Converted Files<a name="020d_0008"></h3><P>
After the standalone converter has run, the resulting contents are displayed in two side-by-side windows for interactive editing.  The dual-window presentation simplifies the logic for updating the screen display.  In the ASCII text window, characters such as CR, TAB, and NULL are represented by a period.<P>
The ASCII buffer is created as a system buffer, in effect hiding it from direct manipulation.  The buffer IDs of both buffers, as well as the original filename and extension, are then concatenated into a formatted record to be added to the database.  The first two characters in the hex buffer are highlighted to give the visual effect of a two-character byte.  If this is the first time the macro has been executed during the edit session, the package information is modified.  The removal of existing package information for .HEX files is important because of any default package or equivalencing which may exist.  The hex_template_first is used to disassociate the current local keyboard.  The _bin_on will then be executed by _call_on_packages due to the modifications.  If the flag parameter is set, _call_on_packages may not have been executed, so these are run.<P>
The _bin_on macro accesses the __hex_files database to extract the buffer ID of the system buffer containing the ASCII representation of the converted file.  The macro then creates side-by-side windows and attaches the buffers to their respective windows.  Each window in BRIEF is associated with a window ID.  These values are stored in global variables to allow synchronized updates to the buffers.  The _bin_on macro also enables the hex editing keyboard and activates the mouse handler before returning.  Because _bin_on creates and changes windows, the language macros must be disabled to avoid recursion during the process of instantiating windows.  The registered macros are therefore toggled off using the unregister_macro command.<P>
<h3><a name="020d_0009">The Mouse Event Handler<a name="020d_0009"></h3><P>
Mouse support is new in version 3.1, so specific discussion of this subject is necessary. BRIEF macros support mouse interaction through mouse events and event handler macros.  BRIEF comes supplied with a default mouse event handler, _mouse_action, which can be called from within a mouse macro that you create.  My mouse event handler is called _bin_mouse.<P>
Events are passed as parameters to the currently defined mouse macro whenever a mouse event occurs.  There are two kinds of events: simple and complex.  My _bin_mouse macro uses a separate method to deal with each.  Simple events have parameters based on relative position or a static operation.  Vertical scroll bar events are a typical example.  The parameters passed to the scroll bar events define the position on the scroll bar relative to the thumb button.  The processing of simple events in _bin_mouse is done by executing the macro assigned to the corresponding movement key.  The inq_assignment primitive is used to obtain the macro name to execute.  Mouse macros are associated with a keyboard definition and are only active while that keyboard definition is used.<P>
Complex events receive literal parameters.  A &quot;CLICK&quot; event is passed the actual line and column location of the mouse cursor within the buffer where the event occurred. Interpretation of these coordinates is usually required before the desired action is performed.  In this example, the parameters are manipulated to position the cursor at the parameter coordinates before the desired action is taken.<P>
Mouse events are passed to the mouse event handler only when they occur in the current window.  When an event occurs in a different window, a SET_WIN event is passed to the mouse macro.  When this event is interpreted, the _bin_mouse macro uses the set_window primitive to make the window ID parameter the current window.  The CLICK event will not be passed to the mouse macro unless the window is changed.  Positioning is done from either window by manipulating the column parameter dependent on which window the mouse event occurred in.<P>
<h3><a name="020d_000a">Conclusion<a name="020d_000a"></h3><P>
Although BRIEF is a full-featured editor, no editor can cover every possible use. Fortunately, the macro language in BRIEF is powerful enough to let you modify even the most intrinsic functions of the standard program.<P>
<h3><a name="020d_000b">Products Mentioned<a name="020d_000b"></h3><P>
BRIEF, Version 3.1 Solution Systems 372 Washington Street Wellesley, MA 02181 800-677-0001 $249<P>

<PRE>

_A BRIEF MACRO PACKAGE FOR EDITING BINARY FILES_
by James Rodriguez


<a name="020d_000c">
<a name="020d_000d"></pre><B>[LISTING ONE]</B><pre><a name="020d_000d">

/* _init _hex_edit _bin_on _bin_off _bin_mouse write_buffer */

#define HEX

#define SHOW_DELAY 50
#define UP        -11
#define DOWN       11
#define LEFT       -1
#define RIGHT       1
#define PGUP      -21
#define PGDN       21
#define TOP        30
#define BOTTOM    -31
#define HOME      -40
#define END       -41

extern   _package_buf,  delete_curr_buffer;

int  __hex_files, __bin_keyboard, __hex_window, __asc_window, __unix_files;
_init ()
{  __hex_files  = create_buffer (&quot;HEXFILES&quot;, NULL, 1);  //Binary file database
   __unix_files = create_buffer (&quot;UNIXFILE&quot;, NULL, 1);  //Unix file database
   register_macro (6, &quot;_bin_edit&quot;);
   keyboard_push ();                   // Create a new keyboard
   set_mouse_action(&quot;_bin_mouse&quot;);     // Define the mouse handler
   add_hex_keys();                     // Add key assignments
   __bin_keyboard = inq_keyboard ();   // Store the keyboard identifier
   keyboard_pop (1);                   // Reset the stack
}
// _hex_edit: associates a system buffer with a hex buffer and modifies
//            the package information for .HEX files. Called by _bin_edit.
void _hex_edit (string file_name, int in_memory)
{  int   __hex_buffer, __asc_buffer, tmp_buf, current_buffer;
   string   buffer_name, file_ext, buffer_id, file_path;
   global   __hex_buffer, __asc_buffer;

   if (get_parm (0, file_name))
   { get_parm (1, in_memory);   //  Check any flag passed
     if (index (file_name, &quot;.&quot;))
     { file_ext  = substr (file_name, 1 + rindex (file_name, &quot;.&quot;));
       file_name = substr (file_name, 1,  rindex (file_name, &quot;.&quot;) - 1);
     }
     else  file_ext = &quot;&quot;;
     buffer_name = substr (file_name, rindex (file_name, &quot;\\&quot;) + 1);
     current_buffer = inq_buffer ();
     if (inq_called () == &quot;_bin_edit&quot;)
       delete_buffer (current_buffer);
     // Error check for bad buffer name
     tmp_buf = create_buffer (buffer_name + &quot;.hex&quot;, file_name + &quot;.hex&quot;, 0);
     if (tmp_buf)
     { set_buffer (__hex_files);
       top_of_buffer ();
       if (search_fwd (file_name + &quot;,&quot;, 0, 0))
         edit_file (file_name + &quot;.hex&quot;);        // It's already in a buffer
       else
       { delete_buffer (tmp_buf);
         sprintf (file_path, &quot;bbe BH %s.%s %s.hex %s.asc&gt;&amp;nul&quot;, file_name,
            file_ext, file_name, file_name);
         // Do the hex files already exist?
         if (!exist (file_name + &quot;.hex&quot;) &amp;&amp; !exist (file_name + &quot;.asc&quot;))
         {  message (&quot;Generating hex file&quot;);
            dos (file_path);  // spawn standalone program to convert file
         }
         else
            message (&quot;Editing existing files.&quot;);
         __hex_buffer = create_buffer (buffer_name + &quot;.hex&quot;, file_name +
            &quot;.hex&quot;, 0);
         __asc_buffer = create_buffer (buffer_name + (&quot;.&quot; + file_ext),
            file_name + &quot;.asc&quot;, 1);
         // Save info in the database for later.
         sprintf (buffer_id, &quot;oldb=%10d,newb=%10d,file=%s,ext=%s&quot;,
            __hex_buffer, __asc_buffer, file_name, file_ext);
         set_buffer (__hex_files);
         beginning_of_line ();
         insert (buffer_id + &quot;\n&quot;);
         set_buffer (__hex_buffer);
         top_of_buffer ();
         drop_anchor ();
         move_rel (0, 1);
         // Access the package buffer and configure for the hex extension.
         if (first_time ())
         {  if (!_package_buf)   load_macro (&quot;language&quot;);
            set_buffer (_package_buf);
            top_of_buffer ();
            while (search_fwd (&quot;&lt;.hex&quot;, 1, 0))
              delete_line ();
            // Add the correct lines in packages to make this work.
            insert (&quot;.hex_equivalents\n&quot;);
            insert (&quot;.hex_new;\n&quot;);
            insert (&quot;.hex_existing;\n&quot;);
            insert (&quot;.hex_first;\n&quot;);
            insert (&quot;.hex_on;_on,_bin_on\n&quot;); // Enabled _bin_on
            insert (&quot;.hex;=hex,,=hex\n&quot;);
            top_of_buffer ();
         }
         set_buffer (__hex_buffer);
         if (! in_memory)
            call_registered_macro (1);
       }
     }
   }
}
// _bin_on:  edits the hex and ascii files in side by side windows by creating
// and moving an edge. Insures correct local keyboard by setting it explicitly.
// Looks in hex_files buffer for filename and extract buffer ids. Associate
// buffers with windows and return.
string _bin_on ()
{  int   i;
   string   buf_to_find,  exten;
   inq_names (buf_to_find, exten);
   buf_to_find = substr (buf_to_find, 1, (rindex (buf_to_find, exten) -
                                                       strlen (exten)) + 1);
   i = inq_buffer();
   set_buffer (__hex_files);  // Edit the system buffer to find buffer id's.
   top_of_buffer ();
   if (search_fwd (buf_to_find + &quot;,&quot;, 0, 0))  // Find the line with filename.
   {
     keyboard_flush();                // Remove any pending keystrokes
     use_local_keyboard (0);          // Detach the local keyboard
     keyboard_push (__bin_keyboard);  // Activate the hex keyboard
     set_mouse_action(&quot;_bin_mouse&quot;);  // Attach the mouse event handler
     beginning_of_line ();
     buf_to_find = trim (read ());    // Parse out the buffer ids
     buf_to_find = ltrim (substr (buf_to_find, index (buf_to_find, &quot;oldb=&quot;)
                                                           + 5, 10));
     __hex_buffer = atoi (buf_to_find, 1);
     beginning_of_line ();
     buf_to_find = read ();
     buf_to_find = ltrim (substr (buf_to_find, index (buf_to_find, &quot;newb=&quot;)
                                                         + 5, 10));
     __asc_buffer = atoi (buf_to_find, 1);
     set_buffer (__hex_buffer);
     // Unregister the registered macro so a recursive situation does not
     // arise from the window manipulations.
     unregister_macro (1, &quot;_call_on_packages&quot;);
     create_edge (3);
     __hex_window = inq_window ();
     move_edge (1, 12);
     change_window (1);
     __asc_window = inq_window ();
     attach_buffer (__asc_buffer);  // Attach the system buffer to a window
     if (!inq_marked ())
          drop_anchor (2);
     else
          refresh ();
     refresh ();
     change_window (3);
     register_macro (1, &quot;_call_on_packages&quot;); // Enable the language macro.
     returns &quot;_bin_off&quot;; // Return the off event for the language package.
     }
   else
   { set_buffer(i); // This is an error check to allow editing
     returns &quot;&quot;;    // of files with .hex extensions which are not
   }                // under the binary package control.
}
// _bin_off --  deletes the created window and resets the keyboard.
void _bin_off ()
{  keyboard_flush();
   keyboard_pop ();
   keyboard_push ();
   add_hex_keys();
   __bin_keyboard = inq_keyboard ();
   delete_edge (1);   // Delete the window
   keyboard_pop (1);
   set_mouse_action(&quot;_mouse_action&quot;); // Reset the mouse handler
}
#define BUTTON_1_CLICK     10
#define BUTTON_2_CLICK     11
#define BUTTON_1_DBLCLK    13
#define BUTTON_2_DBLCLK    14
#define VERTICAL_SCROLL    17
#define CLOSE_WINDOW       19
#define SET_WINDOW         20
#define STATUS_AREA        21
#define SCROLLBAR__LINEUP   0
#define SCROLLBAR__LINEDOWN 1
#define SCROLLBAR__PAGEUP   2
#define SCROLLBAR__PAGEDOWN 3
#define SCROLLBAR__TOP      6
#define SCROLLBAR__BOTTOM   7
#define TITLE_BAR           1

void _bin_mouse(int action, int modifier, int line, int col)
{ if (inq_window() == __asc_window)
       col = col*2; // Modify the column parameter if clicked in ascii window
   switch (action)
   {
     case STATUS_AREA:   // Go to offset on status area click
       execute_macro(inq_assignment(&quot;&lt;Alt-g&gt;&quot;));
     case SET_WINDOW:     // A different window was selected
     {
       if (col!=TITLE_BAR &amp;&amp; line == __asc_window)  // Disregard mouse action
       {                                            // on the border.
         unregister_macro (1, &quot;_call_on_packages&quot;);
         set_window (__asc_window);
       }
     }
     case BUTTON_2_CLICK:
     case BUTTON_2_DBLCLK:
     case BUTTON_1_CLICK:
     case BUTTON_1_DBLCLK:
     { int lines,cols;
       if (col % 2)    // Modify column parameter to event byte value
         col++;
       if (col &gt; 50)   // If past formatted string length go to the end of
         col = 50;     // the string.
       unregister_macro (1, &quot;_call_on_packages&quot;);
       set_window (__hex_window);
       inq_position(lines, cols);
       raise_anchor ();
       move_rel(0,-1);
       save_position();
       if (move_abs(line,col))
       {
         // If beyond the end of buffer ignore the action
         if (! inq_position(lines,cols) &amp;&amp; lines==line &amp;&amp; cols == col)
         {  restore_position(0);
            move_rel(0,-1);
            set_window (__asc_window);
            raise_anchor ();
            move_abs(line,col / 2);
            drop_anchor (2);
            refresh ();
            set_window (__hex_window);
         }
         else
            restore_position();
       }
       else
          restore_position();
       drop_anchor ();
       move_rel (0, 1);
       register_macro (1, &quot;_call_on_packages&quot;);
       refresh ();
       switch (action)
       {
         case BUTTON_2_DBLCLK:  // Opens a line (feature not shown)
         {  execute_macro(inq_assignment(&quot;&lt;Ctrl-Enter&gt;&quot;));
         }
         case BUTTON_1_DBLCLK: // Double click modifies current byte.
         {  string sread, character;
            int hex_val;
            raise_anchor ();
            move_rel (0, -1);
            sread = &quot;Enter new value for &quot;;
            if (read (1) != &quot;\n&quot;)
              sread += read (2);
            sread += &quot;: &quot;;
            if (get_parm (NULL, character, sread, 2))
            { hex_val = _bin_atoh (character);
              sprintf (character, &quot;%02x&quot;, hex_val); // Convert int to hex
              unregister_macro (1, &quot;_call_on_packages&quot;);
              set_window (__asc_window);
              switch (hex_val) // Make sure the value is displayable.
              { case 13:
                case 9:
                case 0:
                    sread = &quot;.&quot;;
                default:
                    sprintf (sread, &quot;%c&quot;, hex_val);
                }
              /* Insert the value in the hex and ascii buffers
              ** rehighlight both windows and return. */
              insert (&quot;%s&quot;, sread);
              raise_anchor ();
              delete_char ();
              move_rel (0, -1);
              drop_anchor (2);
              refresh ();
              set_window (__hex_window);
              insert (&quot;%s&quot;, upper (character));
              delete_char (2);
              move_rel (0, -2);
            }
            drop_anchor ();
            move_rel (0, 1);
            refresh ();
            register_macro (1, &quot;_call_on_packages&quot;);
            refresh ();
         }
       }
     }
     case VERTICAL_SCROLL:  // Vertical scroll bar events.
     {
       switch (line)
       {
         case SCROLLBAR__LINEUP:               // Click on up arrow
            execute_macro(inq_assignment(&quot;&lt;Left&gt;&quot;));
         case SCROLLBAR__LINEDOWN:             // Click on down arrow
            execute_macro(inq_assignment(&quot;&lt;Right&gt;&quot;));
         case SCROLLBAR__PAGEUP:               // Click above thumb button
            execute_macro(inq_assignment(&quot;&lt;PgUp&gt;&quot;));
         case SCROLLBAR__PAGEDOWN:             // Click below thumb button
            execute_macro(inq_assignment(&quot;&lt;PgDn&gt;&quot;));
         case SCROLLBAR__TOP:               // Double click on up arrow
            execute_macro(inq_assignment(&quot;&lt;Ctrl-PgUp&gt;&quot;));
         case SCROLLBAR__BOTTOM:               // Double click on down arrow
            execute_macro(inq_assignment(&quot;&lt;Ctrl-PgDn&gt;&quot;));
       }
     }
   }
}
// write_buffer:  A replacement for write_buffer. Checks file extension, cleans
// up system buffers. Note: conversion back to binary is not done if buffer
// has not been modified.
replacement int write_buffer ()
{
   int   buf_to_edit, buf_to_delete, file_is_controlled, file_was_modified;
   string   file_name, ext, response, response2, old_buffer, write_command;
   inq_names (file_name, ext);
   /* if write_buffer was not called from the keyboard and the extension
   ** isn't .hex or .unx call write_buffer. */
   if (&quot;&quot; == inq_called () &amp;&amp; (ext == &quot;hex&quot; || ext == &quot;unx&quot;))
     if (get_parm (0, response, &quot;Convert file? &quot;, 1, &quot;Y&quot;))
       if (get_parm (1, response2, &quot;Delete buffer? &quot;, 1, &quot;Y&quot;))
       { int   file_is_hex;
         file_is_hex = 0;
         buf_to_edit = inq_buffer (); // Store the current buffer id
         raise_anchor ();         // Remove the highlight
         if (inq_modified ())  // Only write and convert if changed
         {
            returns write_buffer ();  // Preserve the return value
            file_was_modified = 1;
         }
         else
            file_was_modified = 0; // if not changed don't reconvert
         // Remove the extension.
         if (index (file_name, &quot;.&quot;))
            file_name = substr (file_name, 1, rindex (file_name, &quot;.&quot;) - 1);
         // Make the system buffer database current
         if (ext == &quot;hex&quot;)
         {
            set_buffer (__hex_files);
            file_is_hex = 1;
         }
         else
            set_buffer (__unix_files); // Not used in this example
         top_of_buffer ();
         // Try to find filename record and extract original extension.
         if (search_fwd (file_name + &quot;,ext=&quot;, 0, 0))
         {  beginning_of_line ();
            ext = trim (read ());
            file_is_controlled=1;
            // Find the ascii buffer associated with the hex buffer
            if (file_is_hex)
            { int temp_buffer=inq_buffer();
              ext = ltrim (substr (ext, index (ext, &quot;newb=&quot;) + 5));
              old_buffer = substr (ext, 1, 10);
              // Retrieve the buffer id
              buf_to_delete = atoi (old_buffer, 1);
              set_buffer(buf_to_delete);
              raise_anchor();
              write_buffer();
              drop_anchor(2);
              set_buffer(temp_buffer);
              if (upper (response2) == &quot;Y&quot;)
                delete_buffer (buf_to_delete);
            }
            ext = trim (substr (ext, rindex (ext, &quot;=&quot;) + 1));
            beginning_of_line ();
            if (upper (response2) == &quot;Y&quot;)
              delete_line (); // Delete the record
         }
         // Reset the current buffer
         set_buffer (buf_to_edit);
         if (file_is_hex)
            sprintf (write_command, &quot;bbe HB %s.hex %s.%s&gt;&amp;nul&quot;, file_name,
              file_name, ext);
         else
            sprintf (write_command, &quot;bbe DU %s.unx %s.%s&gt;&amp;nul&quot;, file_name,
              file_name, ext);
         if (file_was_modified &amp;&amp; upper (response) == &quot;Y&quot; &amp;&amp;
            file_is_controlled)
         {
            message (&quot;%s&quot;, write_command);
            dos (write_command);        // Call DOS to execute the conversion
            message (&quot;Conversion complete&quot;);
         }
         // Delete the current buffer and the converted file(s).
         if (upper (response2) == &quot;Y&quot;)
         {
            if (1 != delete_curr_buffer())
            {
              file_is_controlled=-1;
              delete_buffer(buf_to_edit);
            }
            if (file_is_hex)
            {
              sprintf (response, &quot;%s.hex&quot;, file_name);
              del (response);
              sprintf (response, &quot;%s.asc&quot;, file_name);
            }
            else
              sprintf (response, &quot;%s.unx&quot;, file_name);
            del (response);
            if (file_is_controlled == -1)  // No other buffers
              exit(&quot;y&quot;);
         }
         else
            if (file_is_hex &amp;&amp; file_is_controlled)
            {
              move_rel (0, -1);
              drop_anchor ();
              move_rel (0, 1);
            }
         }
       else ;
     else ;
   else // Call the primitive
     return write_buffer ();
}



<a name="020d_000e">
<a name="020d_000f"></pre><B>[LISTING TWO]</B><pre><a name="020d_000f">

/* _bin_add _bin_atoh add_hex_keys _bin_edit _bin_delete */

// _bin_move -- this macro handles synchronized positioning.
void _bin_move (int direction)
{  int   col, line;
   get_parm(0,direction);
   raise_anchor ();
   unregister_macro (1, &quot;_call_on_packages&quot;);  // Remove the language control
   set_window (__asc_window);
   raise_anchor ();
   inq_position (line, col);
   switch (direction)
   { case LEFT:
     case RIGHT:
     {
       if ((col == 25 &amp;&amp; direction == RIGHT) || (col==1 &amp;&amp; direction==LEFT))
       {  // Scrolling is needed
         move_rel (direction,0);
         col = (direction == LEFT ? 25 : 1);
         move_abs (0,col);
       }
       else
         move_rel (0,direction);
     }
     case UP:
     case DOWN:
       move_rel (direction % 10,0);
     case PGUP:
     case PGDN:
     { inq_window_size(line);  // Get the number of lines in the window
       move_rel ((direction % 20) * line,0);
     }
     case HOME:
       move_abs(0,1); // Beginning of line
     case END:
       move_abs(0,25); // End of line
     case TOP:
         move_abs(1,1); // Top of buffer
     case BOTTOM:
     { end_of_buffer();
       move_abs(0,25);  // End of buffer
     }
   }
   while (inq_position (line,col))  // We might be in virtual space if
     move_rel (-1, 0);           // so move up until we're not.
   drop_anchor (2);
   refresh ();
   set_window (__hex_window);
   move_abs(line,col * 2);   // Reposition in the hex buffer
   move_rel (0, -1);     // Highlight the current byte.
   drop_anchor ();
   move_rel (0, 1);
   refresh ();
   register_macro (1, &quot;_call_on_packages&quot;);
}
// _bin_add: overwrites the byte in hex window. It is assigned to all of valid
//  hex editing keys and uses push_back to get the original key.
void _bin_add (string key_read)
{  string   character,  sread;
   int      hex_val, temp_hex;
   // Get the parameter which is key pressed and push it back on keyboard
   // buffer so that it displays in prompt as if it were typed there.
   get_parm (0, key_read);
   push_back (key_to_int (key_read));
   raise_anchor ();
   // Read the text from the buffer to display the old value at the prompt.
   move_rel (0, -1);
   sread = &quot;Enter new value for &quot;;
   if (read (1) != &quot;\n&quot;)
     sread += read (2);
   sread += &quot;: &quot;;
   if (get_parm (1, character, sread, 2))
   {                            // Limit the prompt response to two characters
     hex_val = _bin_atoh(character);
     sprintf (character, &quot;%02x&quot;, hex_val); // Convert the int to hex.
     unregister_macro (1, &quot;_call_on_packages&quot;);  // Don't disturb the windows.
     set_window (__asc_window);
     switch (hex_val)  // Make sure the value typed is displayable
     { case 13:
       case 9:
       case 0:
         sread = &quot;.&quot;;
       default:
         sprintf (sread, &quot;%c&quot;, hex_val);
     }
     raise_anchor ();
     delete_char ();  // Remove the old character and insert the new.
     insert (&quot;%s&quot;, sread);
     move_rel(0,-1);
     drop_anchor (2);
     refresh ();
     set_window (__hex_window);
     delete_char (2); // Remove the old byte and insert the new.
     insert (&quot;%s&quot;, upper (character));
     }
   drop_anchor ();
   move_rel (0, 1);
   refresh ();
   register_macro (1, &quot;_call_on_packages&quot;); // Reenable the language macro
   refresh ();
   execute_macro(inq_assignment(&quot;&lt;Right&gt;&quot;)); // Move to the next byte.
}
// _bin_delete: converts the current byte to XX which will be ignored when
// reconverted. Parameter is for deleting a full line.
void _bin_delete (~int line)
{  get_parm(0,line);
   unregister_macro (1, &quot;_call_on_packages&quot;);
   set_window (__asc_window);
   raise_anchor ();
   if (line)
   { save_position();
     move_abs(0,1);
     drop_anchor(3);
     translate(&quot;?&quot;,&quot;.&quot;,1,1,1,1);  // Change any character to a &quot;.&quot;
     raise_anchor ();
     restore_position();
   }
   else
   { delete_char ();
     insert (&quot;.&quot;);
     move_rel (0, -1);
   }
   drop_anchor (2);
   refresh ();
   set_window (__hex_window);
   raise_anchor ();
   if (line)
   { save_position();
     move_abs(0,1);
     drop_anchor(3);
     translate(&quot;?&quot;,&quot;X&quot;,1,1,1,1);  // Change any character to &quot;X&quot;
     raise_anchor ();
     restore_position();
     move_rel (0, -1);
   }
   else
   { move_rel (0, 1);
     insert (&quot;XX&quot;);
     move_rel (0, -4);
     delete_char (2);
   }
   drop_anchor ();
   move_rel (0, 1);
   register_macro (1, &quot;_call_on_packages&quot;);
   refresh ();
}
// _bin_atoh --  accepts a &quot;hex&quot; string and returns an integer.
int _bin_atoh (string to_convert)
{  string   str_rev;
   int      converted, loop_count,  t_int;

   get_parm (0, to_convert);

   // Read a character from the end of the string and multiply
   // it by the loop count which is multiplied by 16 on each iteration.
   while (strlen (trim (to_convert)))
   { str_rev = substr (to_convert, strlen (to_convert), 1);
     t_int = index(&quot;123456789ABCDEF&quot;,upper(str_rev));
     loop_count *= 16;
     if (0 == loop_count)
       loop_count = 1;
     converted += t_int * loop_count;
     to_convert = substr (to_convert, 1, strlen (to_convert) - 1);
   }
   return converted;
}
// add_hex_keys -- adds hex editing keys to the keyboard.
add_hex_keys()
{  string macro_name, key_name;
   int loop;
   for (loop=48; loop&lt;58; loop++)   // Assign the numeric keys
   {                              // to the keyboard
     sprintf (key_name, &quot;&lt;%c&gt;&quot;,loop);
     sprintf (macro_name, &quot;_bin_add \&quot;%c\&quot;&quot;,loop);
     assign_to_key (key_name, macro_name);
   }
   for (loop=65;loop&lt;71;loop++)  // Assign the a-f Hex keys
   {                             // to the keyboard
     sprintf (key_name, &quot;&lt;%c&gt;&quot;,loop);
     sprintf (macro_name, &quot;_bin_add \&quot;%c\&quot;&quot;,loop);
     assign_to_key (key_name, macro_name);
     assign_to_key (lower(key_name), macro_name);
   }
   assign_to_key (&quot;&lt;Alt-n&gt;&quot;, &quot;edit_next_buffer&quot;);
   assign_to_key (&quot;&lt;Alt-e&gt;&quot;, &quot;edit_file&quot;);
   assign_to_key (&quot;&lt;Alt-w&gt;&quot;, &quot;write_buffer&quot;);
   assign_to_key (&quot;&lt;Alt-x&gt;&quot;, &quot;exit&quot;);
   sprintf (macro_name, &quot;_bin_move %d&quot;, UP);
   assign_to_key (&quot;&lt;Up&gt;&quot;, macro_name);
   sprintf (macro_name, &quot;_bin_move %d&quot;, DOWN);
   assign_to_key (&quot;&lt;Keypad-Enter&gt;&quot;, macro_name);
   assign_to_key (&quot;&lt;Down&gt;&quot;, macro_name);
   sprintf (macro_name, &quot;_bin_move %d&quot;, LEFT);
   assign_to_key (&quot;&lt;Left&gt;&quot;, macro_name);
   sprintf (macro_name, &quot;_bin_move %d&quot;, RIGHT);
   assign_to_key (&quot;&lt;Right&gt;&quot;, macro_name);
   sprintf (macro_name, &quot;_bin_move %d&quot;, PGUP);
   assign_to_key (&quot;&lt;PgUp&gt;&quot;, macro_name);
   sprintf (macro_name, &quot;_bin_move %d&quot;, PGDN);
   assign_to_key (&quot;&lt;PgDn&gt;&quot;, macro_name);
   sprintf (macro_name, &quot;_bin_move %d&quot;, TOP);
   assign_to_key (&quot;&lt;Ctrl-Pgup&gt;&quot;, macro_name);
   sprintf (macro_name, &quot;_bin_move %d&quot;, BOTTOM);
   assign_to_key (&quot;&lt;Ctrl-PgDn&gt;&quot;, macro_name);
   sprintf (macro_name, &quot;_bin_move %d&quot;, HOME);
   assign_to_key (&quot;&lt;Home&gt;&quot;, macro_name);
   sprintf (macro_name, &quot;_bin_move %d&quot;, END);
   assign_to_key (&quot;&lt;End&gt;&quot;, macro_name);
}
// _bin_edit -- registered macro for trapping Null files message.
void _bin_edit ()
{  if (inq_message () == &quot;Null characters in file fixed.&quot;)
   { string   okay;
     string   file;
     inq_names (file);
     // See if the conversion is requested.
     if (get_parm (0, okay, &quot;Okay to create HEX file to edit? &quot;, 1, &quot;Y&quot;))
       if (upper (okay) == &quot;Y&quot;)
         _hex_edit (file, 0); // Call _hex_edit to do conversion
       else // Other wise let the user frustrate themselves.
         message (&quot;You asked for it.&quot;);
   }
}
on_packages&quot;);  // Don't disturb the windows.
     set_window (__asc_window);
</pre>

<HR><P>Copyright &copy; 1991, <I>Dr. Dobb's Journal</I></P></BODY></HTML>
