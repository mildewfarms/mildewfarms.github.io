<HTML>
<META NAME="year" CONTENT="1994">
<HEAD>
<TITLE>SP 94: Morphing on Your PC</TITLE></HEAD>
<BODY BGCOLOR="#ffffff">
<h1>Morphing on Your PC<a name="01de_0003"></h1><P>
<h2><a name="01de_0001"><a name="01de_0000">An easy-to-use algorithm for animation and morphing</h2><P>
<h3>Scott Anderson</h3><P>
<p><i><a name="01de_0002"><a name="01de_0000">Scott is the president of Wild Duck, a software publishing and development company in Rohnert Park, California. He is also the author of the animation program <I>Fantavision</I>, and the recently released book Morphing Magic from SAMS. He can be reached at 73710,1055 on CompuServe.</i></p><hr><P>
Morphing has become almost as ubiquitous as bubble-gum under theater seats. As the July 1993 issue of <I>Dr. Dobb's Journal</I> illustrated, from autos turning into tigers to bulls into bears, we see examples of morphing everywhere on television and in movies. While the effect is compelling, morphing is useful beyond the magical transformations we've grown used to seeing.<P>
This article examines the history and mathematics behind morphing, and includes three utility programs that allow you to run full-screen animated morphs on your PC.<P>
<h3><a name="01de_0004">Warping, Tweening, and Dissolving<a name="01de_0004"></h3><P>
Morphing is a blend of three separate algorithms: warping, tweening, and dissolving. <I>Warping</I> is the mathematical trick of stretching and squashing an image as if it were painted on rubber. This article discusses an implementation of one of the latest warping routines, based on the method used by Pacific Data Images (PDI) to make the Michael Jackson video &quot;Black or White.&quot; The algorithm uses <I>lines</I> to control the warping. Lines make the warping specification much easier than using points, giving the artist a break.<P>
Tweening is short for in-betweening, the interpolation of two images to yield a smooth-flowing animation. Tweening is typically done with points, lines, or polygons. Since this warping algorithm is line oriented, tweening fits right in. By tweening the position of the control lines, you can smoothly warp an image around. With warping and tweening alone, you can create photorealistic animations from single photographs. And it's simple to do. (For more details, see my book <I>Morphing Magic</I>, SAMS, 1993.)<P>
Dissolving, or cross-dissolving, is Hollywood-speak for fading out one scene while fading in the next. In the middle, you have a double exposure. This powerful effect was used in the early Wolfman movies. While poor Lon Chaney, Jr. stuck his head in a vice, makeup people swarmed about, adding hair and putty. After each little change in makeup was completed, another few frames of film were squeezed off. Each short take was cross-dissolved with the previous one to complete the illusion.<P>
When you put all three of these effects together, you end up with morphing. Here's how it works. Let's say you want to morph yourself into a tiger. On the first frame of your self-portrait, you mark the key areas with lines. You might place a control line from one eye to the other, down the nose, and across the lips. These three lines capture the most important aspects of a face. Then, on the tiger's ferocious countenance, you would draw control lines on the same features: eyes, nose, and mouth. That's enough information for the computer to morph the two. To create a single morph in the middle, the control lines are tweened halfway and then the images are warped to follow the new lines. The algorithm warps your face midway to the tiger, and warps the tiger midway to you. This is the fifty-fifty interpolation between the two sets of control lines--the central tween. It is also simply the average of the two sets.<P>
After creating the two warped images, the routine cross-dissolves them, finally producing the morph. If you use more tweens, say ten interpolations between you and the tiger, you can make a smoothly animated sequence of you turning into the tiger. The first frame uses 10 percent of the tiger mixed with 90 percent of you. The second frame has 20 percent of the tiger with 80 percent of you. By the ninth frame, there is 90 percent tiger, and you have faded out to 10 percent.<P>
<h3><a name="01de_0005">Warping Algorithms<a name="01de_0005"></h3><P>
There are as many ways to warp as there are sort routines. The method employed here is a variation on the PDI line method. As I mentioned before, this approach is friendly to the artist. Other routines use dots to warp the image. These changes are local and act only over a short distance, so you need hundreds of them. Misplacing some of these dots and ruining the warp isn't at all difficult. With the new method, each line represents the string of points that compose it, so a few short lines can stand in for hundreds of points. As you move a control line, the pixels around it are pulled as well.<P>
One of the interesting peculiarities of this algorithm is the global nature of the warping. A single line can specify any combination of scaling, translation, and rotation. This can be a nice effect in itself. Just draw, say, a vertical line, rotate it 90 degrees, and the image will also be rotated. When there are more lines (as there usually are), they will each compete for influence, but the effect will still be global. The downside is that it takes a little longer to perform the warping.<P>
In the algorithm presented here, the influence of the line falls off as <I>1/distance<SUP>2</SUP></I>. This is just like the influence of gravity, but you can select any variation on this that you desire. This formulation was chosen based largely on speed considerations. A mathematical discussion of the warping algorithm is in the text box entitled, &quot;Warping with Control Lines.&quot; The basic warping algorithm is as follows:<P>
<OL>
<LI>Find the distance between a pixel and the source line by dropping the perpendicular <I>d</I> (see <a href="199401e0.htm">Figure 1</A>).</LI>
<LI>Find the fractional distance <I>f</I> along the source line to the perpendicular. The fraction is normalized to go from 0 to 1.</LI>
<LI>Move the point to a spot that is the same distance from, and fraction of, the <I>target</I> line.</LI>
</OL>
This algorithm is carried out by two routines, <I>sumLines</I> and <I>getSourceLoc</I>; see <a href="#01de_0013">Listing One</A>, page 75. In <I>getSourceLoc</I>, the warped pixel is determined for each line, while <I>sumLines</I> adds up the influence of each line. <I>GetSourceLoc</I> performs the mathematics given in the text box entitled, &quot;Warping with Control Lines.&quot; <I>SumLines</I> uses the distance returned by <I>getSourceLoc</I> to determine the weight contributed by each control line. In a loop through the lines, <I>SumLines</I> calculates the individual weights, as shown in <a href="#01de_000b">Figure 2</A>. You can experiment with the weight calculation (.001 is added to avoid division-by-zero errors). Try equations that depend on the length of the line, or inversely on the cube of the distance. The method used here is simple and fast, but don't be afraid to try something new. You never know what will happen!<P>
<h3><a name="01de_0006">Tweening Algorithm<a name="01de_0006"></h3><P>
The second piece of the morphing trio is tweening. Compared with warping, tweening is a piece of cake. In the simplest case of linear tweening, all you do is interpolate. <I>Linear</I> interpolation is just finding a point on the <I>line</I> connecting two others. Although there are dozens of ways to interpolate, for our purposes linear tweening is just fine. All we do is take the lines describing the source image and tween them into the lines describing the target. For each intermediate tween, we warp the images accordingly.<P>
For speed, divide the distance between the points into as many steps as you desire, say ten. You will have an X and a Y component for the length of these segments, called &quot;deltas.&quot; For a regular division of the line, all these deltas will be equal to one-tenth of the line distance, so you only need to calculate it once and then simply add it to the starting point. After ten additions of this delta, you will have arrived at the target point. The deltas are given by the simple equations in <a href="#01de_000c">Figure 3</A>. Adding a delta in this fashion is fast, but care must be taken to avoid round-off errors.<P>
<h3><a name="01de_0007">Dissolving Algorithm<a name="01de_0007"></h3><P>
Now we are at the third and final part of morphing, the dissolve. This is where you combine the two images you are warping and tweening. Mix any two colors just the way you might expect. The color midway between two colors is given by the formulas in <a href="#01de_000d">Figure 4</A>. On a 24-bit color system, the color you get from this calculation will always be another color you can display. Not so with color-mapped graphics cards. You can easily derive a color that isn't in the puny list of displayable colors called the &quot;palette.&quot; The best most VGA cards can offer is 256 colors, which is pretty sad for this application.<P>
To fix this you need to calculate all the colors as if you had 24 bits to play with. Then, you need to create a new palette that uses the 256 most popular colors. The rest of the colors must be forced into the closest color available from those 256. This process is referred to as &quot;palette mapping.&quot;<P>
So dissolving, which should be the smallest part of this whole algorithm, suddenly swells into an unsightly carbuncle on this otherwise straightforward code. Those are the basics of morphing. There are many different algorithms for performing this terrific effect, but this should serve as a good jumping-off point for further experimentation.<P>
<h3><a name="01de_0008">The Morphing Programs<a name="01de_0008"></h3><P>
So that you can experiment, I've included three programs: MORPH.C (<a href="#01de_0017">Listing Three</A>, page 77), LOAD.C (<a href="#01de_0019">Listing Four</A>, page 78), and FIX.C (<a href="#01de_001b">Listing Five</A>, page 78). The header containing the <I>#define</I>s for all three of these utilities is in <a href="#01de_0015">Listing Two</A>, page 76. MORPH gets the user input and creates the morphing sequence, FIX finds a good palette and LOAD plays the sequence back from memory. All the programs work with PCX files having 256 colors and 320x200 resolution. You can capture your own PCX files with any screen-capture program, or you can find GIF images on CompuServe and convert them with a program such as ZSoft's Paint Shop. Remember to convert the number of colors to 256. If you have access to a scanner, then your troubles are over. You can scan in your own photos and magazine clips and go from there.<P>
When specifying a PCX file, you don't need to type in the file extension. The programs automatically append &quot;.PCX&quot; to the end of each filename, saving you the trouble.<P>
Some of these programs produce a numbered sequence of output files. These are also PCX files. The maximum sequence size is 99. The sequence number, from 1 to 99, is appended to the root name of the file sequence. This takes two characters away from the already-tiny DOS allotment of eight. Therefore, the &lt;OutFile&gt; name must be six characters or less.<P>
<a href="#01de_000e">Figure 5</A> shows the syntax used on the command line to call the MORPH program. MORPH first reads the two input files: the source and target PCX images. Then it looks on the disk for any existing control lines that might be associated with the source or target image. If the user okays it, these line files are loaded in. Otherwise, the user creates a new set of control lines from scratch, and these are saved to the disk. Morph metamorphoses between the two in the given number of steps, to make a sequence of files. The files are numbered and can be displayed by the LOAD program. As an example, issuing the command line MORPH JIM BOB will cause MORPH to load the files JIM.PCX and BOB.PCX. It will create the middle tween and display it. No files are created. However, MORPH JIM BOB 7 will load the files JIM.PCX and BOB.PCX, create a sequence of seven frames, and display them. No files are created. Finally, MORPH JIM BOB 7 JIMBOB will also load JIM.PCX and BOB.PCX and create a sequence of seven frames. Each frame is displayed while it is saved to the disk. The files will be named JIMBOB1.PCX, JIMBOB2.PCX, and so on.<P>
<a href="#01de_000f">Figure 6</A> shows the syntax used to call the LOAD program. LOAD reads a sequence of PCX files indicated by the given name. It reads as many as it can fit into memory, then it displays them sequentially. You can control the playback rate by pressing a number from 1 (slow) to 9 (fast). To single-step through the pictures, press Spacebar. To continue playback, press Enter. To quit, press Esc. The number of images that can be animated depends on how much free RAM you have. Get rid of your TSRs and use the new memory features of DOS 6.0. The best you can do in 640K is about eight images.<P>
The command-line syntax used to call FIX is in <a href="#01de_0010">Figure 7</A>. FIX takes a sequence created by MORPH and forces each picture in the sequence to have the same palette. FIX then writes the sequence out under the new name. The command FIX JIM FXJIM reads the sequence JIM1.PCX, JIM2.PCX, and so on, outputting the same number of files named FXJIM1.PCX, FXJIM2.PCX, and so. Also, FIX JIM JIM reads the JIM sequence and writes over the original files. Be careful! Make sure you don't need the originals before you do this.<P>
<h3><a name="01de_0009">Compiling<a name="01de_0009"></h3><P>
These programs were all compiled with Microsoft C/C++ 7.0. If you didn't include the graphics library when you installed your compiler, you will need to link that library in at compile time. I've included a makefile, which is available electronically; see &quot;Availability,&quot; page 2. The makefile is set up assuming that you <I>haven't</I> installed the graphics library. If you <I>have</I> installed the graphics library, then you'll have to modify this makefile accordingly.<P>
To make the programs work with other C compilers, you will probably need to make some changes to the non-ANSI library calls. In Microsoft C, these library calls are prefixed with the underscore character. The non-ANSI library calls are all in IO.C (available electronically) and LINECALC.C (<a href="#01de_0013">Listing One</A>).<P>
<h3><a name="01de_000a">Conclusion<a name="01de_000a"></h3><P>
The most obvious upgrade to this program is the ability to use extended RAM, so you can hold more frames in memory. If you have access to some of the new software on the market that attempts to leap the 640K barrier, use it. If you can work with smaller images, say, quarter-screen, 160x100 resolution, you should be able to quadruple the number of frames that can be held in memory, not to mention speeding up the animation. The display-picture routines you need to change are in <a href="#01de_001b">Listing Five</A>. Currently, they slam a continuous string of bytes into memory. For smaller screens, you will need to move the image a line at a time.<P>
If you have a true-color card, you don't need the agonizing color-collapsing routines from <a href="#01de_001d">Listing Six</A> (page 79). Just yank them all out. You will need to save the files in 24-bit color mode, which can present some data problems, so look at the drivers and documentation for your particular graphics card.<P>
With these programs, you can create some amazing morphs. With a video capture board and a computer capable of displaying 30 frames per second, you can output to videotape. Now you can play with some of the same toys they have at Industrial Light and Magic and Pacific Data Images. Have fun!<P>
<h4><B> <a href="199401e1.htm">Figure 1</A>: </B>A given point <B>P </B>has a relationship to the line <B>AB </B>that gets mapped to the warping line <B>A</B>'<B>B</B>'.</h4><P>
<h4><a name="01de_000b"><B>Figure 2:</B> Calculating individual weights.<a name="01de_000b"></h4><P>
<pre>distance      = getSourceLoc(&amp;orig,origline,warp,warpline);
weight      = 1/(.001+distance*distance);
deltaSumX      += (orig.x - warp-&gt;x) * weight;
deltaSumY      += (orig.y - warp-&gt;y) * weight;

</pre><P>
<h4><a name="01de_000c"><B>Figure 3:</B> Equations to calculate the interpolation deltas.<a name="01de_000c"></h4><P>
<pre>DeltaX = (TargetX - SourceX) / (Tweens + 1)
DeltaY = (TargetY - SourceY) / (Tweens + 1)

</pre><P>
<h4><a name="01de_000d"><B>Figure 4:</B> Calculating the color midway between two colors.<a name="01de_000d"></h4><P>
<pre>NewRed = (SourceRed + TargetRed) / 2
NewGreen = (SourceGreen + TargetGreen) / 2
NewBlue = (SourceBlue + TargetBlue) / 2

</pre><P>
<h4><a name="01de_000e"><B>Figure 5:</B> Command-line syntax for calling MORPH.<a name="01de_000e"></h4><P>
<pre>MORPH &lt;File1&gt; &lt;File2&gt; [&lt;Steps&gt; [&lt;OutFile&gt;]]

&lt;File1&gt; is the name of the source PCX file to morph.
&lt;File2&gt; is the name of the target PCX file.
&lt;Steps&gt; is the optional number of output files.

If you don't specify the number of steps in your sequence, the program produces one in-between morph. You must specify &lt;Steps&gt; if you want to output files.
&lt;OutFile&gt; is the root name of the optional output files. The value of &lt;Steps&gt; determines the number of files to output. The step number is appended to the root name, so the &lt;OutFile&gt; name must be six characters or less.</pre><P>
<h4><a name="01de_000f"><B>Figure 6:</B> Using the LOAD program.<a name="01de_000f"></h4><P>
<pre>LOAD &lt;File&gt;

&lt;File&gt; is the root name of a PCX sequence to display.</pre><P>
<h4><a name="01de_0010"><B>Figure 7:</B> Command-line syntax used to invoke the FIX program.<a name="01de_0010"></h4><P>
<pre>FIX &lt;InFile&gt; &lt;OutFile&gt;

&lt;InFile&gt; is the root name of the PCX sequence to fix.
&lt;OutFile&gt; is the root name of the fixed PCX sequence.</pre><P>
<a name="01de_0011">A History of Warping<a name="01de_0011"><P>
Warping's history reaches back to the '60s space program, when NASA was snapping shots of the earth like an eager tourist. But when it came time to put all the pictures together, NASA discovered that nothing quite lined up correctly because of the different altitudes, angles, times, and optics for each shot. Consequently, researchers at NASA developed algorithms that treated the digitized data as points on a polynomial surface that could be stretched to fit a set of reference points. They called their efforts <I>image registration</I>. Those marvelous Landsat pictures were thus stretched and pulled into a big quilt of pictures blanketing the globe. This was a great start for a little warping routine.<P>
Warping was dusted off in the mid-seventies, when Viking 2 landed on Mars. Unfortunately, Viking came to rest at an angle, with its camera pointing down. The landscape it depicted looked like the Big Valley, with the horizon strongly curved. All the images of Mars were pushed through a warping algorithm that corrected for the odd optics before the public ever saw them.<P>
Warping has found its way into the medical world, too. In a procedure called &quot;digital subtraction angiography,&quot; an X-ray of a patient is taken before and after the injection of a dye into the area of interest. By subtracting the first image from the second, everything is removed but the dyed arteries. This uncluttered image is of great value to the diagnostician. Unfortunately, if the patient moves, the effect is wrecked. And, except for tree surgeons, moving patients are the norm. As you might have guessed, warping is the perfect tool to ensure registration.<P>
-- S.A.<P>
<a name="01de_0012">Warping with Control Lines<a name="01de_0012"><P>
Given point <B>P </B>in the source image, you want to deduce point <B>P</B>'<B> </B>in the target image (see <a href="199401e2.htm">Figure 1</A>). The distance d is the projection of vector <B>AP </B>on the perpendicular, which yields<B> |</B>AP| cos a, where |<B>AP|</B> <B>represents the magnitude of the vector. The dot product of vector </B>AP <B>with the perpendicular to </B>AB<B> (denoted ^</B>AB<B>) is defined in <a href="199401e3.htm">Example 1(a)</A>, where |</B>AP|<B> </B>and |<B>AB|</B> <B>are the magnitudes, and the subscripted variables are the x and y components of the vectors. You can see that this solution in terms of components, (APx*^ABx+APy*^ABy), doesn't involve any trigonometry. <a href="199401e4.htm">Example 1(b)</A> solves for d.</B><P>
The magnitude of the line itself, |<B>AB|</B> <B>is used instead of the magnitude of the perpendicular, |^</B>AB|. The reason is that these two are equal, and you can reuse this number. The vector dot product allows you to calculate the desired values without computing any angles or using any transcendental functions. That makes it both simple and fast. From <a href="199401e5.htm">Figure 1</A>, note that the distance represented by f is the projection of <B>AP </B>on <B>AB </B>itself, |<B>AP| cos b, which is the quantity: (</B>AP_AB<B>)/|</B>AB|. We want the fractional part of line <B>AB</B>, so we divide by the length of <B>AB </B>again as shown in <a href="199401e6.htm">Example 1(c)</A>.<P>
Examples 1(b) and 1(c) represent a translation into a new-scaled orthogonal coordinate system based on d and f, instead of x and y. Now you are ready to transfer these two important relationships over to the new line, <B>A</B>'<B>B</B>'. The fractional part, the &quot;f-axis,&quot; is simply the fractional part of the <I>new</I> line, <B>A</B>'<B>B</B>': f*<B>A</B>'<B>B</B>' Next, apply the distance to the &quot;d-axis,&quot; which is perpendicular to the new line. The unit d-vector is (^<B>A</B>'<B>B</B>')/|<B>A</B>'<B>B</B>'|. So, with the new origin at <B>A</B>', the source pixel <B>P </B>(represented as a vector from the origin) is transformed into the destination pixel <B>P</B>'; see <a href="199401e7.htm">Example 1(d)</A>. This algorithm uses the relationship a point has with the original line and applies it to the new line. To be of real use, however, you need more lines. They all have to compete for pixels. As mentioned in the text, this implementation uses a weighting proportional to one over the distance squared.<P>
In the calculation for two control lines, the distance to the point is computed from each line, and a new pixel is calculated as before. But this time there are two lines and therefore two warped pixels, so some further work is needed. As shown in <a href="199401e8.htm">Figure 8</A>, from the original point <B>P</B> to the new points <B>P</B>1' and <B>P</B>2' there are two displacements, <B>D</B>1 and <B>D</B>2; see <a href="199401e9.htm">Example 1(e)</A>. The routine calculates the weighted average of the two displacements to arrive at the final position, <B>P</B>'; see <a href="199401ea.htm">Example 1(f)</A>. If there are three lines, there are three displacements to average, and so on. Finally, the general equation for calculating with n lines is shown in <a href="199401eb.htm">Example 1(g)</A>.<P>
--S.A.<P>
<h4><B> <a href="199401ec.htm">Example 1(a)</A>:</B>  Dot product of vector <B>AP </B>with the perpendicular to <B>AB</B>; (b) solving for d; (c) calculating the fractional part of line <B>AB</B>; (d) transforming the source pixel <B>P </B>into the destination pixel <B>P</B>'; (e) determining the displacements <B>D</B>1 and <B>D</B>2; (f) weighted average of the two displacements; (g) solving for the general case using n lines.</h4><P>
<h4><B> <a href="199401ed.htm">Figure 8</A>: </B>Where two lines contribute influence, the warped point is the weighted average of the displacements <B>D</B>1 and <B>D</B>2.</h4><P>

<h4><a name="01de_0013"><a name="01de_0014"><B>[LISTING ONE]</B></H4>

<PRE>

/****************************************************************
* FILE: linecalc.c
* DESC: Warping calculations and line-handling functions.
* HISTORY:  Created   3/11/1993   LAST CHANGED:  5/ 6/1993
*   Copyright (c) 1993 by Scott Anderson
****************************************************************/

/* ----------------------INCLUDES----------------------------- */
#include &lt;conio.h&gt;
#include &lt;stdio.h&gt;
#include &lt;io.h&gt;
#include &lt;math.h&gt;
#include &lt;graph.h&gt;
#include &lt;malloc.h&gt;
#include &lt;memory.h&gt;
#include &lt;string.h&gt;
#include &quot;define.h&quot;

/* -----------------------MACROS------------------------------ */
#define PIXEL(p,x,y)    (p-&gt;pixmap[y * (long) p-&gt;wide + x])
#define SQUARE(x)       (((long) x)*(x))

/* ----------------------PROTOTYPES--------------------------- */
/**** line routines ****/
int     xorLine(int x1, int y1, int x2, int y2);
int     getLine(int *argx1, int *argy1, int *argx2, int *argy2);
int     findPoint(LINE_LIST *lineList, int * line, int * point, int x, int y);
int     movePoint();
/**** warping and morphing routines ****/
int     sumLines(PICTURE *picture, COLOR *color, LINE *origline,
                                                 POINT *warp, LINE *warpline);
float   getSourceLoc(POINT *orig, LINE *origline, POINT *warp, LINE *warpline);
int     setLength(LINE *line);
void    setupScreen(PICTURE *pic, int editFlag);

/* ----------------------EXTERNALS---------------------------- */
/* set from last picture loaded */
extern int      Xmin, Ymin, Xmax, Ymax;
extern int      NumLines;
extern LINE     SrcLine[MAX_LINES];
extern LINE     DstLine[MAX_LINES];

/* ----------------------GLOBAL DATA-------------------------- */
int     TargFlag=0;
/********   These are the basic warping calculations   **********/
* FUNC: int sumLines(PICTURE *picture, COLOR *color,
*               LINE *origline, POINT *warp, LINE *warpline)
* DESC: Sum and weight the contribution of each warping line
*****************************************************************/
int
sumLines(PICTURE *picture, COLOR *color, LINE *origline,
                                                   POINT *warp, LINE *warpline)
{
    int     x, y;
    float   weight, weightSum;
    float   distance;
    int     line;
    POINT   orig;
    int     paletteIndex;
    float   deltaSumX = 0.0;
    float   deltaSumY = 0.0;
    /* if no control lines, get an unwarped pixel */
    if (NumLines == 0)
        orig = *warp;
    else {
        weightSum = 0.0;
        for (line = 0; line &lt; NumLines; line++, origline++, warpline++) {
            distance = getSourceLoc(&amp;orig,origline,warp,warpline);
            weight = 1/(.001+distance*distance);
            deltaSumX += (orig.x - warp-&gt;x) * weight;
            deltaSumY += (orig.y - warp-&gt;y) * weight;
            weightSum += weight;
        }
        orig.x = warp-&gt;x + deltaSumX / weightSum + .5;
        orig.y = warp-&gt;y + deltaSumY / weightSum + .5;
    }
    /* clip it to the nearest border pixel */
    x = clip(orig.x, Xmin, Xmax);
    y = clip(orig.y, Ymin, Ymax);
    paletteIndex = PIXEL (picture, x, y);
    color-&gt;r = picture-&gt;pal.c[paletteIndex].r;
    color-&gt;g = picture-&gt;pal.c[paletteIndex].g;
    color-&gt;b = picture-&gt;pal.c[paletteIndex].b;
    return (paletteIndex);
}
/*****************************************************************
* FUNC: float getSourceLoc(POINT *orig, LINE *origline,
*                                 POINT *warp, LINE *warpline)
* DESC: For a given line, locate the corresponding warped pixel
*****************************************************************/
float
getSourceLoc(POINT *orig, LINE *origline, POINT *warp, LINE *warpline)
{
    float fraction, fdist;
    int dx, dy;
    float distance;
    dx = warp-&gt;x - warpline-&gt;p[0].x;
    dy = warp-&gt;y - warpline-&gt;p[0].y;
    fraction = (dx * (long) warpline-&gt;delta_x + dy
             * (long) warpline-&gt;delta_y) / (float) (warpline-&gt;length_square);
    fdist = (dx * (long) -warpline-&gt;delta_y + dy
             * (long) warpline-&gt;delta_x) / (float) warpline-&gt;length;
    if (fraction &lt;= 0 )
        distance = sqrt(dx*(long) dx + dy * (long) dy);
    else if (fraction &gt;= 1) {
        dx = warp-&gt;x - warpline-&gt;p[1].x;
        dy = warp-&gt;y - warpline-&gt;p[1].y;
        distance = sqrt(dx*(long) dx + dy * (long) dy);
    }
    else if (fdist &gt;= 0)
        distance =  fdist;
    else
        distance = -fdist;
    orig-&gt;x = origline-&gt;p[0].x + fraction * origline-&gt;delta_x -
                fdist * origline-&gt;delta_y / (float) origline-&gt;length + .5;
    orig-&gt;y = origline-&gt;p[0].y + fraction * origline-&gt;delta_y +
                fdist * origline-&gt;delta_x / (float) origline-&gt;length + .5;
    return distance;
}
/*****************************************************************
* FUNC: int setLength(LINE *line)
* DESC: Set the deltas, the length and the length squared for a given line.
*****************************************************************/
int
setLength (LINE *line)
{
    line-&gt;delta_x = line-&gt;p[1].x - line-&gt;p[0].x;
    line-&gt;delta_y = line-&gt;p[1].y - line-&gt;p[0].y;
    line-&gt;length_square = SQUARE(line-&gt;delta_x) + SQUARE(line-&gt;delta_y);
    line-&gt;length = sqrt(line-&gt;length_square);
}
/*********************  The line routines  **********************/
* FUNC: int xorLine(int x1, int y1, int x2, int y2)
* DESC: Draw a line on the screen using the XOR of the screen index.
*****************************************************************/
int
xorLine(int x1, int y1, int x2, int y2)
{
    int oldcolor = _getcolor();
    _setcolor(WHITE);   /* Use white as the xor color */
    _setwritemode(_GXOR);
    _moveto (x1,y1);
    _lineto (x2,y2);
    _setcolor(oldcolor);    /* restore the old color */
}
/*****************************************************************
* FUNC: int getLine(int *argx1, int *argy1, int *argx2, int*argy2)
* DESC: Input a line on the screen with the mouse.
*****************************************************************/
int
getLine (int *argx1, int *argy1, int *argx2, int *argy2)
{
    int     x1,y1, x2,y2;
    int     oldx, oldy;
    int     input;
    /* save the current mode */
    short   old_mode = _getwritemode();
    /* get input until we have a real line, not just a point */
    do {
        /* wait for button or key press */
        while (!(input = mousePos (&amp;x1, &amp;y1)));
        if (input &amp; KEYPRESS) {
            _setwritemode(old_mode);
            return 1;
        }
        oldx=x1, oldy=y1;
        hideMouse();
        /* prime the pump with this dot */
        xorLine (x1, y1, oldx, oldy);
        showMouse();
        while (input = mousePos (&amp;x2, &amp;y2)) {
            /* rubber band a line while the mouse is dragged */
            if (x2 != oldx || y2 != oldy)
            {
                hideMouse();
                xorLine (x1, y1, oldx, oldy);
                xorLine (x1, y1, x2, y2);
                showMouse();
                oldx=x2, oldy=y2;
            }
        }
    } while (x1 == x2 &amp;&amp; y1 == y2);
    *argx1 = x1, *argy1 = y1;
    *argx2 = x2, *argy2 = y2;
    _setwritemode(old_mode);        /* get out of XOR mode */
    return (0);
}
/*****************************************************************
* FUNC: int findPoint(LINE_LIST *lineList,int * line,int * point,int x, int y)
* DESC: loop thru dstline and find point within GRAB_DISTANCE,
*       return 1 if found, 0 otherwise.
*****************************************************************/
int
findPoint (LINE_LIST *lineList, int * line, int * point, int x, int y)
{
    int l, p;
    int minl, minp;
    long length;
    long minlength = SQUARE(640) + SQUARE(480);
    for (l = 0; l &lt; lineList-&gt;number; l++) {
        for (p = 0; p &lt;= 1; p++) {
            length = SQUARE(lineList-&gt;line[l].p[p].x - x)
                   + SQUARE(lineList-&gt;line[l].p[p].y - y);
            if (length &lt; minlength) {
                minlength = length;
                minl = l;
                minp = p;
            }
        }
    }
    if (minlength &gt; GRAB_DISTANCE)
        return 0;
    *line = minl;
    *point = minp;
    return 1;
}
/*****************************************************************
* FUNC: int movePoint(LINE_LIST *lineList)
* DESC: Grab a point and move it. Return 1 when key is pressed, else return 0.
*****************************************************************/
int
movePoint(LINE_LIST *lineList)
{
    int     stuckx, stucky, movex,movey;
    int     oldx, oldy;
    int     input;
    int     line, point;
    /* save the current mode */
    short   old_mode = _getwritemode();
    do {
        /* keep getting input until we have a mouse button */
        while (!(input = mousePos (&amp;movex, &amp;movey)));
        if (input &amp; KEYPRESS) {
            _setwritemode(old_mode);
            return 1;
        }
        if (!findPoint(lineList, &amp;line, &amp;point, movex, movey)) {
            _setwritemode(old_mode);
            return 0;
        }
        /* establish fixed end point */
        stuckx = lineList-&gt;line[line].p[1-point].x;
        stucky = lineList-&gt;line[line].p[1-point].y;
        oldx=movex, oldy=movey;
        hideMouse();
        /* erase the old line */
        xorLine (stuckx, stucky,
                lineList-&gt;line[line].p[point].x,
                lineList-&gt;line[line].p[point].y);
        /* and prime the pump with the new line */
        xorLine (stuckx, stucky, oldx, oldy);
        showMouse();
        while (input = mousePos (&amp;movex, &amp;movey)) {
            /* rubber band a line while the mouse is dragged */
            if (movex != oldx || movey != oldy) {
                hideMouse();
                xorLine (stuckx, stucky, oldx, oldy);
                xorLine (stuckx, stucky, movex, movey);
                showMouse();
                oldx=movex, oldy=movey;
            }
        }
    } while (stuckx == movex &amp;&amp; stucky == movey);
    lineList-&gt;line[line].p[point].x = movex;
    lineList-&gt;line[line].p[point].y = movey;
    _setwritemode(old_mode);        /* get out of XOR mode */
    return (0);
}
/*****************************************************************
* FUNC: void    createLines(PICTURE *pic, LINE_LIST *lineList)
* DESC: create a list of line segments for a picture
*****************************************************************/
void
createLines(PICTURE *pic, LINE_LIST *lineList)
{
    setupScreen(pic, 0);    /* set for enter prompt */
    initMouse();
    showMouse();
    for (lineList-&gt;number = 0;lineList-&gt;number &lt; MAX_LINES;
                                                        lineList-&gt;number++) {
        if (getLine(&amp;lineList-&gt;line[lineList-&gt;number].p[0].x,
            &amp;lineList-&gt;line[lineList-&gt;number].p[0].y,
            &amp;lineList-&gt;line[lineList-&gt;number].p[1].x,
            &amp;lineList-&gt;line[lineList-&gt;number].p[1].y))
            break;
    }
    hideMouse();
}
/*****************************************************************
* FUNC: void    editLines(PICTURE *pic, LINE_LIST *lineList)
* DESC: move around some existing lines
*****************************************************************/
void
editLines(PICTURE *pic, LINE_LIST *lineList)
{
    int segment;
    setupScreen(pic, 1);    /* set for edit prompt */
    initMouse();
    for (segment = 0; segment &lt; lineList-&gt;number; segment++) {
       xorLine(lineList-&gt;line[segment].p[0].x, lineList-&gt;line[segment].p[0].y,
               lineList-&gt;line[segment].p[1].x, lineList-&gt;line[segment].p[1].y);
    }
    showMouse();
    /* move the endpoints around */
    while(!movePoint(lineList));
    hideMouse();
}
/*****************************************************************
* FUNC: void    setupScreen(PICTURE *pic, int editFlag)
* DESC: Print a message introducing the screen, wait for input,
*       then set the graphics mode and display the screen.
*****************************************************************/
void
setupScreen(PICTURE *pic, int editFlag)
{
    static char *editMess[2] = {&quot;enter&quot;, &quot;edit&quot;};
    static char *targMess[2] = {&quot;source&quot;, &quot;target&quot;};
    setTextMode();
    _settextposition(VTAB, HTAB);
    printf(&quot;When you are ready to %s the control lines&quot;, editMess[editFlag]);
    _settextposition(VTAB+2, HTAB);
    printf(&quot;for the %s image, press any key.&quot;, targMess[TargFlag]);
    waitForKey();
    setGraphicsMode();
    displayPicture(pic);
}


</PRE>

<h4><a name="01de_0015"><a name="01de_0016"><B>[LISTING TWO]</B></H4>

<PRE>


/****************************************************************
* FILE: define.h
* DESC: These are the main defines for dissolve, warp,  morph, load and fix.
* HISTORY:  Created  1/11/1993   LAST CHANGED:  5/ 6/1993
*   Copyright (c) 1993 by Scott Anderson
****************************************************************/

/* ----------------------DEFINES------------------------------ */
#define ON              1
#define OFF             0
#define MAX_TWEENS      99      /* Maximum tweens (2 digits) */
/* minus 2 digit tween# appended to end */
#define MAX_NAME_SIZE   (8-2)
#define HEADER_LEN      128     /* PCX header length */
/* Number of colors in the palette */
#define COLORS          256
/* bytes in palette (COLORS*3) */
#define PALETTE_SIZE    (3*COLORS)
/* Maximum number of morphing lines */
#define MAX_LINES       32
/* max number of pixels wide we handle */
#define MAX_WIDE        320
/* max number of pixels tall we handle */
#define MAX_TALL        200
/* Size of screen buffer */
#define MAX_BYTES       (MAX_WIDE*(long) MAX_TALL)
/* Number of components per color (RGB) */
#define COMPS           3
/* largest color component value */
#define MAX_COMP        32
/* the midpoint of the colors - for gray */
#define MID_COMP        (MAX_COMP/2)
/* enough to handle about 10 different palettes */
#define MAX_FREQ        1023
#define MAX_FILES       10
/* length of a file name including directory */
#define MAX_PATHLEN             80
#define ENTER           13  /* Keyboard values */
#define ESC         27
#define HTAB            18  /* Position for text messages */
#define VTAB            8
/* The mouse button &amp; keyboard constants */
#define NO_BUTTON       0
#define LEFT_BUTTON     1
#define RIGHT_BUTTON            2
#define KEYPRESS        4
/* the square of min dist for grabbing pt */
#define GRAB_DISTANCE   25
/* Some of the graphics colors */
#define BLACK           0
#define WHITE           255
#define EXT_PCX         &quot;.PCX&quot;  /* pcx file extension */
/* primary line file holder extension */
#define EXT_LINE1       &quot;.LN1&quot;
#define EXT_LINE2       &quot;.LN2&quot;  /* aux file for warp lines */
#define ERROR           -1  /* General-purpose error code */

typedef enum {
    NO_ERROR,              /* first entry means everything is ok */
    MEMORY_ERR,            /* Not enough memory */
    READ_OPEN_ERR,         /* Couldn't open file for reading */
    READ_ERR,              /* Trouble reading the file */
    WRITE_OPEN_ERR,        /* Couldn't open the file for writing */
    WRITE_ERR,             /* Couldn't write the file */
    MOUSE_ERR,             /* No mouse driver found */
    WRONG_PCX_FILE,        /* PCX file format not supported yet */
    READ_CONTENTS_ERR      /* error in .LN file */
}
ERR;
/* -----------------------MACROS------------------------------ */
#define MIN(a,b)        (((a)&lt;(b)) ? (a) : (b))
#define PIXEL(p,x,y)    (p-&gt;pixmap[y * (long) p-&gt;wide + x])
#define SQUARE(x)       (((long) x)*(x))
/* ----------------------TYPEDEFS----------------------------- */
typedef struct {
    int x,y;        /* the screen coordinates of the point */
}
POINT;
typedef struct {
    POINT p[2];
}
LINE_SEGMENT;
typedef struct {
    int number;     /* number of segments to follow */
    LINE_SEGMENT line[MAX_LINES];
    char *filename; /* name of file holding the line list */
}
LINE_LIST;
typedef struct {
    POINT p[2];             /* the endpoints */
    int delta_x, delta_y;   /* x &amp; y displacement */
    float length;           /* the precalculated length of the line */
    long length_square;     /* the length squared */
}
LINE;
typedef struct {
    /* red, green, and blue color components */
    unsigned char r, g, b;
}
COLOR;
typedef struct {
    COLOR c[COLORS];        /* a 256 entry palette */
}
PALETTE;
typedef struct {
    int xmin, ymin;         /* the upper left corner */
    int xmax, ymax;         /* the lower right corner */
    int wide, tall;         /* the width and height */
    int pal_id;         /* an ID number for each palette */
    PALETTE pal;            /* the actual palette is here */
    unsigned char far *pixmap;  /* a pointer to the pixel map */
}
PICTURE;
typedef struct linko {
    struct linko *next;
    char        *str;
}
LINKED_LIST;
/* ----------------------PROTOTYPES--------------------------- */
/**** file handling routines ****/
extern PICTURE  *loadPicture(char *filename);
extern int      loadPalette(FILE *fp, PALETTE *palette);
extern int      getBlock (unsigned char *byte, int *count, FILE *fp);
extern int      mustRead(FILE *fp, char *buf, int n);
extern int      saveScreen(PALETTE *pal);
extern int      putBlock(unsigned char num, unsigned char color, FILE *fp);
extern int      writeByte(unsigned char *byte, FILE *fp);
/**** screen and color routines ****/
extern int      defaultPalette(PALETTE *palette);
extern int      setPalette(PALETTE *palette);
extern int      displayPicture(PICTURE *picture);
extern int      displayNoPal(PICTURE *picture);
extern int      freePicture(PICTURE *pic);
/**** mouse routines ****/
extern int      initMouse();
extern int      hideMouse();
extern int      showMouse();
extern int      mousePos(int *x, int *y);
/**** general purpose routines ****/
extern int      clip(int num, int min, int max);
extern int      quitCheck();
extern void     quit(int err, char *name);
extern int      wait(int count);
extern int      waitForKey();
extern char     lineAsk(char *name);
/* ----------------------GLOBAL DATA-------------------------- */
extern int      TargFlag;
extern int      Key;


</PRE>

<h4><a name="01de_0017"><a name="01de_0018"><B>[LISTING THREE]</B></H4>

<PRE>


/****************************************************************
* FILE: morph.c
* DESC: Create a metamorphosing sequence between two given images. This
*     program lets you specify two files to morph, then prompts you for
*     control lines. It uses the lines to warp the underlying images a step
*     at a time, combine them, and optionally save them as numbered PCX files.
* HISTORY:  Created  1/13/1993    LAST CHANGED:  5/ 6/1993
*   Copyright (c) 1993 by Scott Anderson
****************************************************************/

/* ----------------------INCLUDES----------------------------- */
#include &lt;conio.h&gt;
#include &lt;stdio.h&gt;
#include &lt;io.h&gt;
#include &lt;math.h&gt;
#include &lt;graph.h&gt;
#include &lt;malloc.h&gt;
#include &lt;memory.h&gt;
#include &lt;string.h&gt;
#include &quot;define.h&quot;

/* ----------------------DEFINES------------------------------ */
#define MORPH_TWEENS    1

/* ----------------------PROTOTYPES--------------------------- */
int     tweenMorph(PICTURE *src, PICTURE *dst);

/* ----------------------EXTERNALS---------------------------- */
/**** color routines ****/
extern int  closestColor(int r, int g, int b, PALETTE *palPtr);
extern void collapseColors(PALETTE *palPtr);
/**** line routines ****/
extern int  setLength(LINE *line);
extern int  sumLines(PICTURE *picture, COLOR *color,
                LINE *origline, POINT *warp, LINE *warpline);
/**** io routines ****/
extern LINE_LIST    *loadLines(char *filename, char *extension);
extern void          saveLines(char *filename,
                    LINE_LIST *lineList, char *extension);

/***** variables used to compute intermediate images ****/
/* number of colors in tweened image before reduction*/
extern int  Ncolors;
/* r, g, b frequency counter array */
extern unsigned int far Freq[MAX_COMP][MAX_COMP][MAX_COMP];
/* tweened images red, grn, and blu components*/
extern unsigned char far Red[MAX_WIDE][MAX_TALL];
extern unsigned char far Grn[MAX_WIDE][MAX_TALL];
extern unsigned char far Blu[MAX_WIDE][MAX_TALL];
extern PALETTE TweenPal;            /* resulting palette */

/**** other variables ****/
extern char     *OutFilename;
/* set from last picture loaded */
extern int      Xmin, Ymin, Xmax, Ymax;
/* ID of palette currently being displayed */
extern int      CurrentPal;

/* ----------------------GLOBAL DATA-------------------------- */
PICTURE *Src;       /* source &amp; destination picture pointers */
PICTURE *Dst;
LINE    SrcLine[MAX_LINES];
LINE    DstLine[MAX_LINES];
int     Tweens;
int     NumLines;

/*****************************************************************
* FUNC: main (int argc, char *argv[])
* DESC: Read in a filename to load
*****************************************************************/
main (int argc, char *argv[])
{
    int     segment;
    LINE_LIST *lineSrcList;
    LINE_LIST *lineDstList;
    char    answer;
    /* load the pcx file if one is given */
    if ((3 &gt; argc) || (argc &gt; 5)) {
        printf(&quot;Usage: morph &lt;source&gt;&lt;dest&gt; [&lt;steps&gt; [&lt;output&gt;]]\n\n&quot;);
        printf(&quot;Where: &lt;source&gt; is the source PCX filename\n&quot;);
        printf(&quot;       &lt;dest&gt;   is the destination filename\n&quot;);
        printf(&quot;       &lt;steps&gt;  is the optional sequence size\n&quot;);
        printf(&quot;                (the max is %d, the default is %d)\n&quot;,
                        MAX_TWEENS, MORPH_TWEENS+2);
        printf(&quot;       &lt;output&gt; is the optional output filename\n&quot;);
        printf(&quot;                (defaults to no output)\n\n&quot;);
        printf(&quot;Note:  The output filename can be at most %d
                                         characters long.\n&quot;, MAX_NAME_SIZE);
        printf(&quot;       The PCX extension is added automatically,
                                                                 so don't\n&quot;);
        printf(&quot;       include it in the filename.\n&quot;);
        printf(&quot;       Morph only accepts PCX files with %d X %d
                                            resolution\n&quot;, MAX_WIDE, MAX_TALL);
        printf(&quot;       and %d colors.\n&quot;, COLORS);
        exit(0);
    }
    if (argc &gt; 3) {
        /* subtract two from the series count to get the tweens
         * since the starting and ending frame are included. */
        Tweens = clip (atoi(argv[3]) - 2, 1, MAX_TWEENS);
        if (argc &gt; 4)
            OutFilename = argv[4];
    }
    else
        Tweens = MORPH_TWEENS;
    printf(&quot;Loading the file %s\n&quot;, argv[1]);
    Src = loadPicture(argv[1]);
    if (Src == NULL)
        quit(MEMORY_ERR, &quot;&quot;);
    printf(&quot;Loading the file %s\n&quot;, argv[2]);
    Dst = loadPicture(argv[2]);
    if (Dst == NULL)
        quit(MEMORY_ERR, &quot;&quot;);
    lineSrcList = loadLines(argv[1], EXT_LINE1);
    if (lineSrcList-&gt;number != 0) {
        if (lineAsk(argv[1]) == 'N')
            createLines(Src, lineSrcList);
        else
            editLines(Src, lineSrcList);
    }
    else
        createLines(Src, lineSrcList);

    TargFlag = 1;   /* For the screen intro message */
    NumLines = lineSrcList-&gt;number;
    if (NumLines) {
        lineDstList = loadLines(argv[2], EXT_LINE1);
            /* inconsistent warp target*/
        if (lineDstList-&gt;number !=  NumLines)
            lineDstList-&gt;number = 0;
        if (lineDstList-&gt;number) {  /* ask what he wants to do */
            if (lineAsk(argv[2]) == 'N')
                lineDstList-&gt;number = 0;
        }
        if (lineDstList-&gt;number == 0) { /* create a warp target */
            /* copy the source lines */
            lineDstList-&gt;number = NumLines;
            for (segment = 0; segment &lt; NumLines; segment++)
                lineDstList-&gt;line[segment] = lineSrcList-&gt;line[segment];
        }
        editLines(Dst, lineDstList);
        saveLines(argv[1], lineSrcList, EXT_LINE1);
        saveLines(argv[2], lineDstList, EXT_LINE1);
        beep();
        for (segment = 0; segment &lt; NumLines; segment++) {
            DstLine[segment].p[0]=lineDstList-&gt;line[segment].p[0];
            DstLine[segment].p[1]=lineDstList-&gt;line[segment].p[1];
            setLength(&amp;DstLine[segment]);
            SrcLine[segment].p[0]=lineSrcList-&gt;line[segment].p[0];
            SrcLine[segment].p[1]=lineSrcList-&gt;line[segment].p[1];
            setLength(&amp;SrcLine[segment]);
        }
    }
    tweenMorph(Src, Dst);
    setTextMode();
}
/*****************************************************************
* FUNC: int tweenMorph(PICTURE *src, PICTURE *dst)
* DESC: calculate a pixel to plot, from the warping function
*****************************************************************/
#define TOTAL_WEIGHT        (100)   /* Good for up to 99 tweens */
tweenMorph(PICTURE *src, PICTURE *dst)
{
    int color;
    POINT warp;
    int x,y;
    COLOR scolor, dcolor;
    LINE warpLine[MAX_LINES];
    int t, i, p;
    int r, g, b;
    unsigned int srcweight, srcpaletteindex;
    unsigned int dstweight, dstpaletteindex;
    displayPicture(src);
    saveScreen(&amp;src-&gt;pal);
    /* src is on screen, now tween to the target */
    for (t = 1; t &lt;= Tweens; t++) {
        /* Tween the lines used to warp the images */
        for (i = 0; i &lt; NumLines; i++) {
            for (p = 0; p &lt; 2; p++) {
                warpLine[i].p[p].x = SrcLine[i].p[p].x +
                  ((DstLine[i].p[p].x - SrcLine[i].p[p].x) * t)
                  /(Tweens+1);
                warpLine[i].p[p].y = SrcLine[i].p[p].y +
                  ((DstLine[i].p[p].y - SrcLine[i].p[p].y) * t)
                  /(Tweens+1);
            }
            setLength(&amp;warpLine[i]);
        }
        dstweight = t * TOTAL_WEIGHT / (Tweens+1);
        srcweight = TOTAL_WEIGHT - dstweight;
        /* Zero out the buffers */
        initFreq();
        /* set background to black */
        _fmemset(Red, 0, sizeof Red);
        _fmemset(Grn, 0, sizeof Grn);
        _fmemset(Blu, 0, sizeof Blu);
        /* Go through the screen and get warped source pixels */
        for (warp.y = Ymin; warp.y &lt;= Ymax; warp.y++)   {
            if (quitCheck())
                quit(0, &quot;&quot;);
            for (warp.x = Xmin; warp.x &lt;= Xmax; warp.x++)   {
                 sumLines(src, &amp;scolor, SrcLine, &amp;warp, warpLine);
                 sumLines(dst, &amp;dcolor, DstLine, &amp;warp, warpLine);
                 r = (scolor.r * srcweight + dcolor.r * dstweight)
                            / TOTAL_WEIGHT;
                 g = (scolor.g * srcweight + dcolor.g * dstweight)
                            / TOTAL_WEIGHT;
                 b = (scolor.b * srcweight + dcolor.b * dstweight)
                            / TOTAL_WEIGHT;
                 if (Freq[r][g][b] == 0)    /* A new color */
                    Ncolors++;
                /* Keep it to one byte */
                if (Freq[r][g][b] &lt; MAX_FREQ)
                    Freq[r][g][b]++;
                /* put RGB components into temporary buffer */
                Red[warp.x][warp.y] = r;
                Grn[warp.x][warp.y] = g;
                Blu[warp.x][warp.y] = b;
            }
        }
        collapseColors(&amp;TweenPal);
        setPalette(&amp;TweenPal);
        for (y = Ymin; y &lt;= Ymax; y++)  {
            if (quitCheck())
                quit(0, &quot;&quot;);
            for (x = Xmin; x &lt;= Xmax; x++)  {
                color = closestColor(   Red[x][y], Grn[x][y],
                                        Blu[x][y], &amp;TweenPal);
                _setcolor (color);
                _setpixel (x, y);
            }
        }
        /* no output file name on command line */
        if (!OutFilename) {
            beep();
            waitForKey();   /* so pause to enjoy the pictures */
        }
        else
            saveScreen(&amp;TweenPal);
    }
    if (OutFilename) {  /* save the last pic in this series */
        CurrentPal = 0;         /* force a new palette */
        displayPicture(dst);
        saveScreen(&amp;dst-&gt;pal);
    }
}


</PRE>

<h4><a name="01de_0019"><a name="01de_001a"><B>[LISTING FOUR]</B></H4>

<PRE>


/****************************************************************
* FILE: load.c
* DESC: This program loads a PCX file or a list of them. It crams as
*       many into memory as it can, then it flips quickly through them.
* HISTORY:  Created  1/13/1993   LAST CHANGED:  3/20/1993
*   Copyright (c) 1993 by Scott Anderson
****************************************************************/
/* ----------------------INCLUDES----------------------------- */
#include &lt;conio.h&gt;
#include &lt;stdio.h&gt;
#include &lt;io.h&gt;
#include &lt;math.h&gt;
#include &lt;graph.h&gt;
#include &lt;string.h&gt;
#include &quot;define.h&quot;
/* ----------------------EXTERNALS---------------------------- */
/* External functions */
extern int  quitCheck();
extern LINKED_LIST  *rootSequence(int argc, char *argv[]);
/* External variables */
extern int  Wait;
extern int  Key;
extern int  EndWait;
/* ----------------------GLOBAL DATA-------------------------- */
PICTURE *Src[MAX_FILES];            /* source picture pointer */
/*****************************************************************
* FUNC: main (int argc, char *argv[])
* DESC: Display the file or sequence passed on the command line. Read in as
*       many files as will fit in memory, then display them in a loop.
*****************************************************************/
main (int argc, char *argv[])
{
    int file, fileNum;
    int direction;
    int i;
    LINKED_LIST *pcxList;
    LINKED_LIST *pcxListHead;
    if (argc == 1) {
        printf(&quot;Usage: load &lt;name&gt;\n\n&quot;);
        printf(&quot;Where: &lt;name&gt; is the root name of a sequence\n&quot;);
        exit(23);
    }
    setGraphicsMode();
    file = 1;
    pcxListHead =  rootSequence(argc, argv);
    for (pcxList=pcxListHead; pcxList; pcxList = pcxList-&gt;next) {
        Src[file] = loadPicture(pcxList-&gt;str);
        if (Src[file] == NULL)
            break;
        displayPicture(Src[file++]);
    }
    fileNum = file - 1;
    if (fileNum == 1)   /* there's only one file */
        waitForKey();   /* so wait for the user to quit */
    else if (fileNum &gt; 1) {
        file = 1;
        direction = 1;
        while (!(quitCheck())) {
            if ((file += direction) &gt;= fileNum)
                direction = -1;
            if (file &lt;= 1)
                direction = 1;
            displayPicture(Src[file]);
            if (EndWait &amp;&amp; (file == 1 || file == fileNum))
                wait(Wait);
        }
    }
    /* Reset to original mode, then quit */
    setTextMode();
}


</PRE>

<h4><a name="01de_001b"><a name="01de_001c"><B>[LISTING FIVE]</B></H4>

<PRE>


/****************************************************************
* FILE: fix.c
* DESC: This program inputs a list of pictures, creates a best
*       fit palette, remaps the pictures, and writes them out.
* HISTORY:  Created  1/13/1993   LAST CHANGED: 3/10/1993
*   Copyright (c) 1993 by Scott Anderson
****************************************************************/
/* ----------------------INCLUDES----------------------------- */
#include &lt;conio.h&gt;
#include &lt;stdio.h&gt;
#include &lt;io.h&gt;
#include &lt;math.h&gt;
#include &lt;graph.h&gt;
#include &lt;malloc.h&gt;
#include &lt;memory.h&gt;
#include &lt;string.h&gt;
#include &quot;define.h&quot;
/* ----------------------EXTERNALS---------------------------- */
extern LINKED_LIST  *rootSequence(int argc, char *argv[]);
/**** color routines ****/
extern int      closestColor(int r, int g, int b, PALETTE *pal);
extern void     collapseColors(PALETTE *palPtr);
extern int      mergePalette(PICTURE *pic);
extern int      remapPicture(PICTURE *picPtr, PALETTE *palPtr);
/**** line routines ****/
extern int      getLine(int *argx1, int *argy1, int *argx2, int *argy2);
extern int      movePoint();
extern int      setLength(LINE *line);
/**** other variables ****/
extern char     *OutFilename;
/* set from last picture loaded */
extern int      Xmin, Ymin, Xmax, Ymax;
/* ----------------------GLOBAL DATA-------------------------- */
PICTURE *Src;       /* source &amp; destination picture pointers */
/***** variables used to compute intermediate images ****/
/* number of colors in tweened image before reduction*/
extern int  Ncolors;
/* r, g, b frequency counter array */
extern unsigned int far Freq[MAX_COMP][MAX_COMP][MAX_COMP];
/* tweened images red, grn, and blu components*/
extern unsigned char far Red[MAX_WIDE][MAX_TALL];
extern unsigned char far Grn[MAX_WIDE][MAX_TALL];
extern unsigned char far Blu[MAX_WIDE][MAX_TALL];
extern PALETTE TweenPal;            /* resulting palette */
/*****************************************************************
* FUNC: main (int argc, char *argv[])
* DESC: Read in a list of filenames to load, change their palettes
*       to the best-fit palette, and write them out.
*****************************************************************/
main (int argc, char *argv[])
{
    int     file;
    LINKED_LIST *pcxList, *pcxListHead;
    /* load the pcx file if one is given */
    if (argc &lt; 3) {
        printf(&quot;Usage: fix &lt;infile&gt; &lt;outfile&gt;\n\n&quot;);
        printf(&quot;Where: &lt;infile&gt;  is the input sequence name\n&quot;);
        printf(&quot;       &lt;outfile&gt; is the output sequence name\n&quot;);
        exit(0);
    }
    OutFilename = argv[argc-1];
    initFreq();
    pcxListHead =  rootSequence(argc-1, argv);
    for (pcxList = pcxListHead; pcxList; pcxList=pcxList-&gt;next) {
        printf(&quot;Loading the file %s\n&quot;, pcxList-&gt;str);
        Src = loadPicture(pcxList-&gt;str);
        if (Src == NULL)
            quit(MEMORY_ERR, &quot;&quot;);
        mergePalette(Src);
        freePicture(Src);
    }
    collapseColors(&amp;TweenPal);
    setGraphicsMode();
    setPalette(&amp;TweenPal);
    for (pcxList = pcxListHead; pcxList; pcxList=pcxList-&gt;next) {
        Src = loadPicture(pcxList-&gt;str);
        if (Src == NULL)
            quit(MEMORY_ERR, &quot;&quot;);
        remapPicture(Src, &amp;TweenPal);
        displayNoPal(Src);
        saveScreen(&amp;TweenPal);
        freePicture(Src);
    }
    setTextMode();
}


</PRE>

<h4><a name="01de_001d"><a name="01de_001e"><B>[LISTING SIX]</B></H4>

<PRE>


/****************************************************************
* FILE: color.c
* DESC: This file contains the color routines used by morph, dissolve and fix.
* HISTORY:  Created  3/18/1993  LAST CHANGED: 5/ 6/1993
*   Copyright (c) 1992 by Scott Anderson
****************************************************************/
#include &lt;stdio.h&gt;
#include &lt;memory.h&gt;
#include &quot;define.h&quot;
/* ----------------------DEFINES------------------------------ */
/* ----------------------TYPEDEFS/STRUCTS--------------------- */
/* ----------------------PROTOTYPES--------------------------- */
int     closestColor(int r, int g, int b, PALETTE *palPtr);
void    collapseColors(PALETTE *palPtr);
int     mergePalette(PICTURE *pic);
int     remapPicture(PICTURE *picPtr, PALETTE *palPtr);
int     initFreq();
/* ----------------------EXTERNALS---------------------------- */
/* set from last picture loaded */
extern int      Xmin, Ymin, Xmax, Ymax;
/* ----------------------GLOBAL DATA-------------------------- */
/* number of colors in tweened image before reduction*/
int     Ncolors;
/* r, g, b frequency counter array */
unsigned int far Freq[MAX_COMP][MAX_COMP][MAX_COMP];
/* tweened images red, grn, and blu components*/
unsigned char far Red[MAX_WIDE][MAX_TALL];
unsigned char far Grn[MAX_WIDE][MAX_TALL];
unsigned char far Blu[MAX_WIDE][MAX_TALL];
PALETTE TweenPal;           /* resulting palette */
/*****************************************************************
* FUNC: void    collapseColors(PALETTE *palPtr)
* DESC: Collapse the colors in the Freq table until
*       Ncolors &lt; COLORS, then put it in the given color palette.
*****************************************************************/
void
collapseColors(PALETTE *palPtr)
{
    int freqCutoff;
    int r, g, b;
    int index;
    int ncolors;
    static int freqCount[MAX_FREQ+1];
    memset(freqCount, 0, sizeof freqCount);
    for (r = 0; r &lt; MAX_COMP; r++)
        for (g = 0; g &lt; MAX_COMP; g++)
            for (b = 0; b &lt; MAX_COMP; b++)
                freqCount[Freq[r][g][b]]++;
    ncolors = 0;
    for (freqCutoff = COLORS-1; freqCutoff &gt; 1; freqCutoff--) {
        ncolors += freqCount[freqCutoff];
        if (ncolors &gt; COLORS) break;
    }
    /* Collapse color space to 256 colors */
    r = g = b = 0;
    while (Ncolors &gt;= COLORS) {
        for (; r &lt; MAX_COMP; r++, g=0) {
            for (; g &lt; MAX_COMP; g++, b=0) {
                for (; b &lt; MAX_COMP; b++) {
                    if (Freq[r][g][b] &amp;&amp; Freq[r][g][b]
                        &lt;= freqCutoff)
                goto castOut;   /* the ultimate no no */
                }
            }
        }
        r = g = b = 0;
        freqCutoff++;
        continue;
    castOut:
        Freq[r][g][b] = 0;  /* just remove this low freq color */
        Ncolors--;
    }
    /* build a palette out of all the remaining non zero freq's */
    index = 0;
    for (r = 0; r &lt; MAX_COMP; r++)
        for (g = 0; g &lt; MAX_COMP; g++)
            for (b = 0; b &lt; MAX_COMP; b++)
                /* we have a color we need to map */
                if (Freq[r][g][b]) {
                    palPtr-&gt;c[index].r = r;
                    palPtr-&gt;c[index].g = g;
                    palPtr-&gt;c[index].b = b;
                    /* remember index in palette */
                    Freq[r][g][b] = index;
                    index++;
                }
}

/*****************************************************************
* FUNC: int closestColor(int r, int g, int b, PALETTE *palPtr)
* DESC: return the palette index of the color closest to rgb.
*****************************************************************/
int
closestColor(int r, int g, int b, PALETTE *palPtr)
{
    int index;
    int distance;
    int min_distance = 3200;    /* a big number */
    int min_index;
    /* The value in Freq is now the index into the color table */
    if (Freq[r][g][b]) return Freq[r][g][b];
    /* If zero, search for the closest color */
    for (index = 1; index &lt; Ncolors; index++) {
        /* this is really the distance squared, but it works */
        distance =  SQUARE (r - palPtr-&gt;c[index].r) +
                    SQUARE (g - palPtr-&gt;c[index].g) +
                    SQUARE (b - palPtr-&gt;c[index].b);
        if (distance &lt; min_distance) {
            min_distance = distance;
            min_index = index;
            if (distance &lt;= 2) break;   /* close enough! */
        }
    }
    /* New index - for future reference */
    Freq[r][g][b] = min_index;
    return min_index;
}
/*****************************************************************
* FUNC: int mergePalette(PICTURE *picPtr)
* DESC: Merge a palette into Freq count table.
*****************************************************************/
int
mergePalette(PICTURE *picPtr)
{
    int     r, g, b;
    unsigned int    pos;
    unsigned char   index;
    PALETTE *palPtr = &amp;picPtr-&gt;pal;
    unsigned char far *bufPtr = picPtr-&gt;pixmap;
    for (pos = 0; pos &lt; MAX_BYTES; pos++) {
        index = *bufPtr++;
        r = palPtr-&gt;c[index].r;
        g = palPtr-&gt;c[index].g;
        b = palPtr-&gt;c[index].b;
        if (Freq[r][g][b] == 0)     /* A new color */
            Ncolors++;
        if (Freq[r][g][b] &lt; MAX_FREQ)   /* Keep it managable */
            Freq[r][g][b]++;
    }
}
/*****************************************************************
* FUNC: int remapPicture(PICTURE *picPtr, PALETTE *palPtr)
* DESC: Remap a picture with a different palette.
*****************************************************************/
int
remapPicture(PICTURE *picPtr, PALETTE *palPtr)
{
    int     x, y;
    int     index;
    int     r, g, b;
    unsigned int    pos;
    unsigned char   lookup[COLORS];
    unsigned char far *bufPtr;
    /* Create the cross-reference lookup table */
    for (index = 0; index &lt; COLORS; index++) {
        r = picPtr-&gt;pal.c[index].r;
        g = picPtr-&gt;pal.c[index].g;
        b = picPtr-&gt;pal.c[index].b;
        lookup[index] = closestColor(r, g, b, palPtr);
    }
    /* Save the new palette in the picture's palette */
    for (index = 0; index &lt; COLORS; index++) {
        picPtr-&gt;pal.c[index].r = palPtr-&gt;c[index].r;
        picPtr-&gt;pal.c[index].g = palPtr-&gt;c[index].g;
        picPtr-&gt;pal.c[index].b = palPtr-&gt;c[index].b;
    }
    /* Remap the individual pixels to point to the new colors */
    for (bufPtr = picPtr-&gt;pixmap, pos = 0; pos &lt; MAX_BYTES;
                        bufPtr++, pos++)
        *bufPtr = lookup[*bufPtr];
}
/*****************************************************************
* FUNC: int initFreq()
* DESC: zero out the frequency color space table
*****************************************************************/
int
initFreq()
{
    int bytes = (sizeof Freq) / 2;
    _fmemset(Freq, 0, bytes);
    /* divide because of element size */
    _fmemset(Freq+(bytes/sizeof *Freq), 0, bytes);
    /* Guarantee a black color */
    Freq[0][0][0] = MAX_FREQ;
    /* a grey color */
    Freq[MID_COMP-1][MID_COMP-1][MID_COMP-1] = MAX_FREQ;
    /* and a white color */
    Freq[(long)MAX_COMP-1][MAX_COMP-1][MAX_COMP-1] = MAX_FREQ;
    Ncolors = 3;
}
</pre><HR><P>Copyright &copy; 1994, <I>Dr. Dobb's Journal</I></P></BODY></HTML>
