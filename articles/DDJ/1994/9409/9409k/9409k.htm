<HTML>
<META NAME="year" CONTENT="1994">
<HEAD>
<TITLE>SEP94: C PROGRAMMING</TITLE></HEAD>
<BODY BGCOLOR="#ffffff">
<h1>C PROGRAMMING<a name="010c_0058"></h1><P>
<h2><a name="010c_0056"><a name="010c_0000">Patterns, New C++ Features, and OS/2</h2><P>
<h3>Al Stevens</h3><P>
<a name="010c_0057"><a name="010c_0000">I spoke last week at the Borland International Conference in Orlando, Florida. The conference was held on Disney property in the Swan and Dolphin resort hotels. In true Philippe style, the parties were the highlight, and there were several conference-hosted trips to the Disney theme parks. The vision of Borland's David Intersimone dressed like an Egyptian and getting shot by a bad guy in the Indiana Jones attraction is something that we'll not soon forget. <P>
Several sessions at the conference addressed <I>patterns</I>, a newly evolving design approach being studied by a small group of industry collaborators. Kent Beck, one of the group, has written about patterns in <I>DDJ</I> and elsewhere; see, for instance, &quot;Patterns and Software Development&quot; (<I>DDJ</I>, February 1994). Jim Coplien and Grady Booch are also members of the patterns group, which is attempting to define how designers can identify and reuse patterns that repeat themselves in the expression and solution of software-design problems. Correlations exist between patterns in architecture, which is centuries old, and patterns in software design, which is only decades old. A pattern is an expression of both the problem and its solution. This is not a new idea. In the early 1970s, we taught that the solution to a problem should resemble the problem; that you should be able to derive the problem by looking at the solution. Patterns in solutions are things that we recognize from experience, and they should clearly express their purpose. Putting this recognition to advantage involves recording the nature of patterns and identifying where they apply in the expression of other problems and solutions. Expect to see a lot more about patterns in the next couple of years. Jim Coplien expresses concerns that zealous book writers will rush to publish and eager toolmakers will crank out early CASE tools well before anyone clearly understands patterns. His advice: Try this at home, not at work. <P>
<h3><a name="010c_0059">C++ Enhanced<a name="010c_0059"></h3><P>
The ANSI/ISO X3J16 committee's standard definition for C++ includes extensions to the language that the C++ programming community at large wants and needs. The principal new features--those not supported by all current C++ implementations--are templates, exception handling, namespaces, new-style casts, and run-time type information.<P>
Although several contemporary compilers support templates, the definition is changing significantly. The view of a template as a kind of macro is gone. In some implementations, the template member functions must be in view during the instantiation of a parameterized type object. The template header file has not only the template class declaration but must have the member-function definitions, too. The new language definition provides for the member functions to be in their own translation unit, unseen by the code that uses the template. The binding of unique parameterized functions to types is done by the linker, rather than during the compile, to suppress code generation for multiple uses of the same template for the same type in different translation units. The former is the preferred model, according to Bjarne Stroustrup in <I>The Design and Evolution of C++</I> (Addison-Wesley, 1994). Not all existing compilers work this way, and some will have to change.<P>
Several compilers now support exception handling. Its behavior is well understood, and the design is nailed down. The efficiency with which compilers will implement exception handling remains to be seen. I discussed the subject in two successive columns last year.<P>
I have not yet experimented with namespaces. They have not been implemented in the PC compilers that I have. The feature is designed to eliminate a problem that occurs when multiple libraries in a project use colliding global identifiers. The namespace feature places independent global declarations within unique namespaces to isolate them from one another. Tom Pennello, vice-president of engineering for MetaWare (developers of a compiler which does support namespaces) wrote on the topic last month; see &quot;C++ Namespaces&quot; (<I>DDJ</I>, August 1994).<P>
<h3><a name="010c_005a">Casts<a name="010c_005a"></h3><P>
New-style casts are replacing traditional C and C++ typecast notation, providing safer notation that can reflect the design of polymorphic class hierarchies and that can be readily located in code with text-searching tools such as grep. The old-style casts are still supported by the language, but their use is discouraged and they will gradually disappear as new programs replace old ones. In a perfect universe, programs need no casts at all, and the framers of the language would like to have eliminated them altogether. Research shows, however, that many idioms require them, particularly in systems programming. The old-style cast is known to be unsafe, error prone, and difficult to spot when we read programs. The new-style casts are an attempt to improve the casting situation.<P>
There are four new casting operators. Each one returns an object converted according to the rules of the operator. They use the syntax <I>cast_operator &lt;type&gt; (object)</I>, where the <I>cast_operator</I> is either <I>dynamic_cast</I>, <I>static_cast</I>, <I>reinterpret_cast</I>, or <I>const_cast</I>; the <I>type</I> argument is the type being cast to; and the <I>object</I> argument is the object being cast from.<P>
<h3><a name="010c_005b"><I>dynamic_cast</I><a name="010c_005b"></h3><P>
The <I>dynamic_cast</I> operator casts a base-class reference or pointer to a derived-class reference or pointer. You can use it only when the base class has virtual functions. It provides a way to determine at run time if a base-class reference or pointer refers to an object of a specified derived class or to an object of a class derived from the specified class. <a href="#010c_0061">Example 1</A> shows how you use it. If you use references rather than pointers, <I>dynamic_cast</I> throws a <I>bad_cast</I> exception when the target is not of the specified class.<P>
The <I>dynamic_cast</I> operator provides a form of run-time type identification (not to be confused with run-time type information, RTTI, discussed shortly). A program can determine at run time which of several known, derived types a base-class reference or pointer refers to. This feature supports idioms that virtual functions might not. The <I>Control</I> class in <a href="#010c_0061">Example 1</A> knows that a derived <I>EditBox</I> object has unique requirements not shared by all derived <I>Control</I> objects. Rather than burden all classes derived from <I>Control</I> with empty virtual functions to emulate those unique to <I>EditBox</I>, the design casts the object's base pointer to point to an <I>EditBox</I> object. If the object is not an <I>EditBox</I> or of a class derived from <I>EditBox</I>, the cast returns a 0 value, and the program knows not to call functions unique to <I>EditBoxe</I>s.<P>
<h3><a name="010c_005c"><I>static_cast</I><a name="010c_005c"></h3><P>
Unlike <I>dynamic_cast</I>, the <I>static_cast</I> operator makes no run-time check and is not restricted to base and derived classes in the same polymorphic class hierarchy.<P>
If you are casting from a base to a derived type (not always a safe conversion) <I>static_cast</I> assumes that its argument is an object of (or pointer or reference to an object of) the base class <I>within an object of the derived class</I>. The cast can result in a different, possibly invalid address. In <a href="#010c_0062">Example 2</A>, if the <I>bp</I> pointer does, in fact, point to an object of type C, the cast works correctly. If it points to an object of type B, the cast makes the conversion, but the effective address is less than the address of the B object with the difference representing the size of the B class. This address is incorrect.<P>
Similarly, if the pointer points to an object of the base class, using the derived class pointer to dereference members of the nonexisting, derived class object causes unpredictable behavior.<P>
If you are unsure about the safety of the cast, use <I>dynamic_cast</I> and check the result.<P>
If you are casting from a derived to a base type (a safe conversion), <I>static_cast</I> assumes that its argument is a valid object of the derived class or a pointer or reference to an object of the derived class.<P>
You can also use <I>static_cast</I> to invoke implicit conversions between types that are not in the same hierarchy. Type checking is static. That is, the compiler checks to ensure that the conversion is valid. Assuming that you did not subvert the type system with an old-style cast or <I>reinterpret_cast</I> to coerce an invalid address into a pointer or initialize a pointer with 0, <I>static_cast</I> is a reasonably safe typecasting mechanism.<P>
<h3><a name="010c_005d"><I>reinterpret_cast</I><a name="010c_005d"></h3><P>
The <I>reinterpret_cast</I> operator replaces most other uses of the old-style cast except those where you are casting away &quot;<I>const-</I>ness.&quot; It will convert pointers to other pointer types, numbers to pointers, and pointers to numbers. You should know what you are doing when you use <I>reinterpret_cast</I> just as you should when you use old-style casts. That is not to say that you should never use <I>reinterpret_cast</I>. There are times when nothing else will do.<P>
<h3><a name="010c_005e"><I>const_cast</I><a name="010c_005e"></h3><P>
The three cast operators just discussed respect <I>const-</I>ness. That is, you cannot use them to cast away the <I>const-</I>ness of an object. For that, use the <I>const_cast</I> operator. Its type argument must match the type of the object argument except for the <I>const</I> and volatile keywords.<P>
When would you want to cast away <I>const-</I>ness? Class designs should take into consideration the user who declares a <I>const</I> object of the type. They do that by declaring as <I>const</I> any member functions that do not modify any of the object's data-member values. Those functions are accessible through <I>const</I> objects. Other functions are not. Some classes, however, have data members that contribute to the management rather than the purpose of the objects. They manipulate hidden data that the user is unconcerned about, and they must do so for all objects, regardless of <I>const-</I>ness.<P>
For example, suppose there is a global counter that represents some number of actions taken against an object of the class, <I>const</I> or otherwise. In <a href="#010c_0063">Example 3</A>, if the declaration of the <I>A::report()</I> member function was not <I>const</I>, the using program could not use the function for <I>const</I> objects of the class. The function itself needs to increment the <I>rptct</I> data member, which it normally could not do from a <I>const</I> member function. <I>const</I> functions cannot change data values. To cast away the <I>const-</I>ness of the object for that one operation, the function uses the <I>const_cast</I> operator to cast the <I>this</I> pointer to a pointer to a non-<I>const</I> object of the class.<P>
<h3><a name="010c_005f">Run-time Type Information (RTTI)<a name="010c_005f"></h3><P>
The <I>typeid</I> operator supports the new run-time type-information feature. Given an expression or a type as an argument, the operator returns a reference to a system-maintained object of type <I>Type_info</I>, which identifies the type of the argument. There are only a few things that you can do with the <I>Type_info</I> object reference. You can compare it to another <I>Type_info</I> object for equality or inequality. You can initialize a <I>Type_info</I> pointer variable with its address. (You cannot assign or copy a <I>Type_info</I> object or pass it as a function argument.)  You can call the member function <I>Type_info::name()</I> to get a pointer to the type's name. You can call the member function <I>Type_info::before()</I> to get a 0 or 1 integer that represents the order of the type in relation to another type.<P>
How would you use <I>typeid</I>? What purpose is gained by determining the specific type of an object? The <I>dynamic_cast</I> operator is more flexible in one way and less in another. It tells you that an object is of a specified class or of a class derived from the specified class. But to use it, the specified class needs at least one virtual member function. And <I>dynamic_cast</I> does not work with intrinsic types.<P>
Consider a persistent-object database manager. It scans the database and constructs memory objects from the data values that it finds. How does it determine which constructors to call? RTTI can provide that intelligence. If the first component of a persistent-object record is the class name (or, better yet, a subscript into an array of class names), the program can use RTTI to select the constructor. Consider this example, where the database scanner retrieves the class name of the next object and calls the <I>DisplayObject</I> function. <a href="#010c_0064">Example 4</A>, where only three classes are recorded in the database, assumes that the database manager knows how to construct each object when the file pointer is positioned just past the type identifier in the record. This technique assumes that the scanner program knows about all the classes in the database and is similar to one that I use in the Parody object-database manager. I'll be discussing Parody in detail in future columns.<P>
<h3><a name="010c_0060">OS/2: Seven Points on the Richter Scale<a name="010c_0060"></h3><P>
I am writing this column with Word for Windows 6.0 running as an OS/2-Win application, and I am not a happy scribe. I just spent three days installing OS/2. I spent those three days watching OS/2 and its installation procedure crash with regularity.<P>
Associates have been telling me that I need OS/2, the better Windows than Windows, the better DOS than DOS, and the best environment for developing DOS and Windows applications. They smugly point out that their operating system is better than mine. OS/2 uses preemptive multitasking in protected mode, and applications cannot take out the operating system when they blow up. Just flush that sucker out and keep moving along. They say that high-tech programmers shouldn't piddle around with low-tech software like MS-DOS and Windows.<P>
Until now, I organized programming projects into Windows Program Manager groups with icons for the word processor, the C++ compiler, the program itself, and so on. I jumped from task to task using Windows' simple multitasking capabilities. It worked well enough, but from time to time a program would blow up and take Windows, DOS, and anything I hadn't saved along with it.<P>
A copy of OS/2 2.1 has been on the shelf for a couple of months now, and Borland's OS/2 C++ compiler arrived recently, something I've been wanting to try. You can install OS/2 all by itself or with DOS in a dual-boot configuration. You can use the OS/2 improved file system only if you do not use the dual-boot feature. Praise glory that I did not go the full high-tech route. I set up a DOS boot diskette just to be safe and left the FAT file system intact. A prudent battle plan includes the retreat. Right out of the box, the installation program died. It got just so far and left me staring at a dark screen. The installation manual said that it might do that--brand new software telling me to try it and see if it blows up. What will they think of next? OS/2 had decided that I had some particular video display configuration, so it installed itself accordingly. Then, when trying to use the video mode, OS/2 changed its mind and quit.<P>
The procedure said to restart the installation, press Esc at a certain place, and run the SETVGA program to reconfigure everything to VGA, the lowest common video denominator. SETVGA asked me to insert Display Driver Diskette 1. But I was installing from a CD-ROM--and there is no Diskette 1. SETVGA, apparently not mindful of how things are being done, wants that diskette. I located a set of the 19 OS/2 installation diskettes and went from there. SETVGA ran for a while and said it couldn't find a file to complete the reinstallation. It didn't say which file, just that it couldn't find one.<P>
I tried booting, which did not work. An error message said that OS/2 couldn't find VVGA.SYS, a clue to the previously unnamed missing file. Using my boot diskette and trusty, clunky old DOS, I determined that OS/2's CONFIG.SYS was trying to load a VVGA.SYS device driver, which was nowhere to be found. I couldn't find it on the hard disk, the diskettes, or the CD-ROM. There was a file named VSVGA.SYS, so I changed CONFIG.SYS to load that one. OS/2 booted to a dark screen again.<P>
Eventually, the display problem mysteriously went away. I had been messing with the video adaptor's installation program and something I did made the display start working. I continued the installation, and it ran for a while and locked up. Several restarts had similar results but at different places.<P>
After deleting everything and starting over, the installation went without a hitch, and OS/2 was running. Still, OS/2 has decided that my video display is 480x640 VGA only. I want 600x800, which Windows 3.1 under DOS finds perfectly acceptable. OS/2 refuses to install itself that way. When I finally got through the selective installation of Super VGA, OS/2 wouldn't run. The only high-resolution configuration that works is 8514 emulation, which produces a washed-out look that I don't like. <P>
I set up a folder and installed Word for Windows 6.0 into it. Ideally, the first thing you do in the morning is start all the programs you use and leave them running as icons. Then you activate them when you need them and minimize them when you don't. With Word running, I pressed Alt+Tab to get back to the desktop, which is when the unthinkable happened--the system locked up tighter than a harp string. I had to reboot.<P>
Next I installed WinCIS, the CompuServe Information System for Windows program. OS/2 claims to be able to handle communications in the background while you do other things, but the program will not run in the background without locking up OS/2. Likewise, the CD-ROM-based CorelDraw setup program crashes the system.<P>
Before you OS/2 mavens rush to write letters telling me what I did wrong, how unfair I'm being, how OS/2 deserves a more thorough and comprehensive look-see, listen up. First, this isn't the whole story. I left out a lot of details because they're more crashingly boring than these. Second, software needs to be easy to install and use. Nobody should have to go through what I did, particularly not the typical, nontechnical user. The only reason I got it running is because, as a programmer, I know how to get around things, deduce the meaning of arcane system constructs, and find and try alternatives. Average users are not ready for this. Maybe OS/2 is great with powerful native OS/2 applications. But OS/2 is promoted as being able to run Windows applications in an armored environment. It doesn't. This highly touted, protected-mode, bullet-proof operating system cannot install itself or install and run three of my favorite Windows applications without crashing.<P>
I'm using OS/2 now to develop C++ programs mainly to use the Borland compiler and the flat 32-bit memory model. OS/2's DOS emulation is indeed better than a Windows DOS box. Windows under OS/2 is definitely not better than Windows running under DOS. Programs take longer to load, they run slower, and the screen is jumpy and uncomfortable to use.<P>
Things still crash the system. Quincy aborts OS/2 when the help database is not properly built. The GUI goes off somewhere into the ether, and full text-screen messages display with codes, memory addresses, and instructions to write everything down and call my service representative, whoever that is. Word for Windows 6.0 is sluggish and maims OS/2 from time to time. You can see it coming. <P>
The user's manual and online help documentation don't help. I am still trying to figure out how to get a document on the desktop that associates with Word for Windows. Sure, tell me how easy it is, but try figuring out how when you don't already know.<P>
Last week at the Borland International Conference, IBM had their usual array of PCs with OS/2 installed for test driving. I wanted to look into OS/2 word processors. They had WordPerfect, Ami Pro, and a third one whose name I forget. I tried the third one first. Guess what--it locked up OS/2. The attendant suggested that I move to another PC and not try that program again. I took his advice and moved to another PC--in a different exhibit.<P>
<h4><a name="010c_0061"><B>Example 1:</B> Using the dynamic_cast operator.<a name="010c_0061"></h4><P>
<pre>class EditBox : public Control { ... };
void Paint(Control *cp)
{
    EditBox *ctl = dynamic_cast&lt;EditBox*&gt;(cp);
    if (ctl != 0)
        // ctl points to an EditBox
    else
      // cp points to a non-EditBox Control
}</pre><P>
<h4><a name="010c_0062"><B>Example 2:</B> Using the static_cast operator.<a name="010c_0062"></h4><P>
<pre>class C : public A,
public B { /* ... */ };
B *bp;
C *cp = static_cast&lt;C*&gt;(bp);</pre><P>
<h4><a name="010c_0063"><B>Example 3:</B> Using the const_cast operator.<a name="010c_0063"></h4><P>
<pre>#include &lt;iostreams.h&gt;
class A {
    int val;
    int rptct;  // number of times the object is reported
public:
    A(int v) : val(v)
, rptct(0) { }
    ~A()
    { cout &lt;&lt; val &lt;&lt; &quot; was reported &quot; &lt;&lt; rptct &lt;&lt; &quot; times.&quot;; }
    void report() const;
}  ;
void A::report() const
{
    const_cast&lt;A*&gt;(this)-&gt;rptct++;
    cout &lt;&lt; val &lt;&lt; '\n';
}
int main()
{
    const A a(123);
    a.report();
    a.report();
    a.report();
    return 0;
}</pre><P>
<h4><a name="010c_0064"><B>Example 4:</B> Using RTTI.<a name="010c_0064"></h4><P>
<pre>void DisplayObject(char *cname)
{
    if (strcmp(cname, typeid(Employee).name())==0) {
        Employee empl;
        empl.Display();
    }
    else if (strcmp(cname, typeid(Department).name())==0) {
     Department dept;
     dept.Display();
     }
     else if (strcmp(cname, typeid(Project).name())==0) {
            Project proj;
         proj.Display();
     }
}</pre>

<HR><P>Copyright &copy; 1994, <I>Dr. Dobb's Journal</I></P></BODY></HTML>
