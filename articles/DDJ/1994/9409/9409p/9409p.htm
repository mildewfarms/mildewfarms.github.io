<HTML>
<META NAME="year" CONTENT="1994">
<HEAD>
<TITLE>SEP94: LETTERS</TITLE></HEAD>
<BODY BGCOLOR="#ffffff">
<h1>LETTERS<a name="00c0_0001"></h1><P>
<h3><a name="00c0_0002">3-D Morphing <a name="00c0_0002"></h3><P>
Dear <I>DDJ</I>,<P>
I really enjoyed the fine article, &quot;Morphing 3-D Objects in C++&quot; by Glenn Lewis (<I>DDJ</I>, July 1994) and would like to congratulate Glenn, as well as discuss a few points with him. How can I get in touch with him?<P>
Ben Allen<P>
Los Angeles, California<P>
<I>DDJ</I> <I>Responds:</I> Thanks for your note, Ben. Glenn is an engineer with Intel's real-time group and can be contacted at glewis @pcocd2.intel.com.<P>
<h3><a name="00c0_0003">Timing is Everything<a name="00c0_0003"></h3><P>
Dear <I>DDJ</I>, <P>
I just read Tom Swan's June 1994 &quot;Algorithm Alley&quot; column, where he shows how recursion can be removed by essentially replacing the system stack with a private stack. At the end of the column he says: &quot;I didn't profile any of the code listed here...but removing recursion usually produces a speed boost.&quot;<P>
I have read similar statements in many algorithm books, but I have not found any evidence for the general validity of this rule of thumb. Over the years, I have used many techniques to enhance performance, including recursion removal, and I have learned to <I>always</I> time code if time is important. What I have found (in general) is:<P>
<OL>
<LI>Tail recursion removal is always beneficial. It is also a very simple adaptation. </LI>
<LI>General recursion removal requires a private stack and routines to deal with this private stack. It depends on the algorithm, the compiler, and the operating system whether you may expect an increase in performance. C has very little overhead for a function call, so recursion can be very fast. C++ and Windows require more function prologue and epilogue, which makes recursion slower.</LI>
<LI>A benefit of recursion routines is that they are very simple. But similar to their nonrecursive brothers, recursive routines can be optimized. Most recursive routines begin by testing whether to exit immediately. A very simple optimization is to move this test before each recursive call; if the recursive function call would exit immediately, there is no need to call the routine.</LI>
<LI>Sometimes you find a nonrecursive routine that does not need a stack. Here you have, in fact, found a completely different algorithm. This algorithm is often much faster then the recursive routine.</LI>
<LI>Don't trust profilers. Use a stopwatch or the internal timer of the computer.</LI>
</OL>
Thiadmer Riemersma  <P>
Bussum, Netherlands<P>
<h3><a name="00c0_0004">The Right Tool_<a name="00c0_0004"></h3><P>
Dear <I>DDJ</I>, <P>
I read Jay Frederick Ransom's letter (&quot;Letters,&quot; <I>DDJ</I>, April 1994) commenting on P.J. Plauger's &quot;Programming Language Guessing Games&quot; (<I>DDJ</I>, October 1993). I agree with Mr. Plauger, C/C++ is a complex language. Not everybody, unless you have special training, can read this cryptic language. C was written by two excellent professionals (Kernighan and Ritchie) to create an operating system--UNIX. Since C and C++ are actually high-level assemblers, why would you use them to write scientific and mathematical or financial and commercial applications? Why use a plier to tighten a nut if you can use a wrench? Fortran is the correct tool for the first, and Cobol is the correct tool for the second.<P>
Simple programs, like that shown by Mr. Ransom, can be written in any language (he chose C++). <a href="#00c0_0008">Example 1</A> is the same solution written in Visual Cobol (I must admit that I originally wrote it in Fortran), but with a great difference: I'm sure everybody can read and understand it. [Editor's Note: Executables and related files are available electronically; see &quot;Availability,&quot; page 3.] And using his words, note the &quot;simple and elegant'' code used to solve the problem. No tricks, no hidden features; and straightforward, too.<P>
Jaime Orozco-V.<P>
Santaf&eacute; de Bogot&aacute;, Colombia<P>
<h3><a name="00c0_0005">More on Secure Algorithms<a name="00c0_0005"></h3><P>
Dear <I>DDJ</I>,<P>
In a recent &quot;Letters&quot; column discussing secure algorithms (<I>DDJ</I>, July 1994), William Hause suggested what's essentially the one-time pad system. Although unbreakable, it produces many security difficulties in practical use--especially with multiple correspondents, where every pair exchanging messages must always use <I>different</I> random keys. <I>If any two messages use the same key, decryption becomes much easier.</I><P>
All users must take great care not to reuse any part of any key, yet must ensure that the recipient always know where to start. This point is a major problem with the system, exaggerated by the weaknesses of human nature.<P>
Natural random numbers require a high-quality electronic source not available to most people. The British government uses a complex electronic device (ERNIE) to generate the random numbers used for the monthly national-savings-prize draw. A technical article describing the equipment stated that each number combined two electronic sources to avoid any risk of nonrandom output. Additionally, actual output is checked statistically after every use.<P>
The distribution of keys produces a major security problem. How does one ensure--even with a personal messenger--that no one has taken a copy en route? Even sending multiple keys by different routes and combining them for use must always leave some element of doubt.<P>
The most secure methods avoid transmission of any data sensitive to interception. Widely published data, such as new books in the lists of agreed large publishers, easily provide the several numerical values to derive <I>indirectly</I> the multiple seeds necessary for a secure key. Each pair of correspondents agrees--and keeps secret from all others--when to change lists and books and how to calculate the several seeds from each chosen book.<P>
Although every message requires a completely different key, book references may be infrequent. The message date, time, number, and so on can provide--again <I>indirectly</I>--some of the necessary variability in seeds.<P>
A Poisson test provides the most critical test of randomness, sensitive to any trace of sequence repetition. Many computer algorithms pass more-popular tests but fail with a Poisson test. The best methods encipher each bit independently. Check for and avoid correlations between bits in the same sequence, as found with most shift-register designs.<P>
Do not delete zeros from any random key; omission of the expected plaintext characters actually assists decryption.<P>
For any message, there are 128<I>N</I> possible different keys (one is plain language), where <I>N</I> is the number of characters in the message. The best methods approach this limit.<P>
R.G. Silson<P>
Tring, Herts, England<P>
<h3><a name="00c0_0006">Big Numbers, Cont.<a name="00c0_0006"></h3><P>
Dear <I>DDJ</I>,<P>
I would like to take you up on an offer which was extended to <I>DDJ</I> readers in the September 1993 issue, page 10. You were responding to Mike Neighbors, who wrote a letter entitled &quot;Searching for Mr. Big Number,&quot; in which he asked readers for good references on high-precision arithmetic. <P>
I am the founder of Nth Power Software, a software-development company  which specializes in symbolic-algebra applications. Currently, we have a symbolic-algebra programming language called the &quot;Nth Programming Language,'' which runs on DOS- and Windows-based systems. Nth has been under development for several years, and Version 1.0 was released in December of 1993. Nth has a robust, multiple-precision number capability with far more than the 40-decimal-place accuracy mentioned by Mike Neighbors. Its key features include multiple-precision numbers, multivariate rational polynomial procedures, and the capability for you to build your own distributable applications which utilize the full power of the Nth language via the NthDX module. <P>
Lloyd E. Nesbitt, <P>
Nth Power Software<P>
Adair, Oklahoma<P>
<h3><a name="00c0_0007">Ray Tracing and POV-Ray <a name="00c0_0007"></h3><P>
Dear <I>DDJ</I>,<P>
As a member of the POV-Team, I was pleased to see Craig Lindley's  article, &quot;Ray Tracing the POV-Ray Toolkit&quot; (<I>DDJ</I>, July 1994). While the article was essentially correct for POV-Ray Version 1.0, it contains some outdated information that may cause some confusion with users of the current version.<P>
Craig's article and sample code was based on POV-Ray 1.0. The current version of POV-RAY is 2.2. While the sample code that was provided will run, POV-Ray 2.x must be run in &quot;backwards-compatibility mode&quot; to prevent syntax errors. This mode can be set via the command line or by using the <I>#version 1.0</I> directive in the scene file itself. More information is available in the POV-Ray documentation.<P>
Also, Drew Wells is still a POV-Team member, but the job of coordinator has been assumed by Chris Young (CompuServe 76702,1655) and inquiries should be addressed to him.<P>
Because of the large number of platforms that POV-Ray can run on, it is advised that downloaders first look for the file POVINF.DOC, which will explain a little about POV-Ray and which files are necessary to get it working on any particular platform. An alternate Internet site for POV-Ray related files is now available at uniwa.uwa.edu.au in the pub/povray directory.<P>
While the article mentioned POVCAD as one possible modeler for the PC, it should be noted that another modeler, Moray, is probably in more common use. There is a great need for a portable modeler for POV-Ray. <P>
There are a couple of DOS modelers, but nothing for non-DOS platforms. Because of POV-Ray's portable nature, it would be extremely desirable to have a freeware portable modeler. Many issues arise from this, some of which have been covered in <I>DDJ</I>, particularly portable GUI issues. I have tried to get a group of Internetters together to work on this, but it's been really tough and I'm not so sure that it'll happen. It'd sure make an interesting <I>DDJ</I> project for someone, though.<P>
Dan Farmer, <P>
POV-Team Member<P>
CompuServe 74431,1075<P>
<I>DDJ</I> <I>Responds:</I> You're absolutely right, Dan. A portable modeler for POV-Ray would be a great project. If any readers are interested in working on such a project, please contact Dan or <I>DDJ</I>. <P>
<h4><a name="00c0_0008"><B>Example 1:</B> The right tool...<a name="00c0_0008"></h4><P>
<pre>Id Division.
 Program-Id.            TeamPlay.

 Data Division.
 Working-Storage Section.
 01  TeamsTable.
     05  Team Occurs 100 Times, indexed by TeamX, TeamY
                        Pic  X(25).
 01  Temp               Pic  X(25).

 01  NroTeams           Pic  9(3).
 01  LastTeam           Pic  9(3).

 01  Dia                Pic  9(3).

 Procedure Division.
 Begin-TeamPlay.
*----------------------------------------------------------------*
*    Read in Team names... And no more than expected!            *
*----------------------------------------------------------------*
     Display &quot;Enter Teams Names... Ends with *&quot;
     Perform With Test After Varying NroTeams From 1 By 1 Until
          Team (NroTeams) (1:1) Equal &quot;*&quot; or
          NroTeams Greater 100
          Accept Team (NroTeams)
     End-Perform
*----------------------------------------------------------------*
*    Delete the &quot;*&quot; Team and calculate an even number of teams   *
*----------------------------------------------------------------*
     Subtract 1 from NroTeams
     Compute LastTeam = Function Integer ((NroTeams + 1) / 2) * 2
*----------------------------------------------------------------*
*    Print out playing schedule                                  *
*----------------------------------------------------------------*

     Perform Varying Dia From 1 by 1 Until
          Dia Greater LastTeam - 1
          Display &quot;Day &quot; Dia

          Set TeamY to LastTeam
          Perform Varying TeamX from 1 by 1 Until
               TeamX Greater TeamY
               Display Team (TeamX) &quot; .VS. &quot; Team (TeamY)
               Set TeamY Down by 1
          End-Perform
*----------------------------------------------------------------*
*         Rotate Teams for next day                              *
*----------------------------------------------------------------*
          Move Team (LastTeam) to Temp
          Perform Varying TeamX from LastTeam by -1 Until
               TeamX Equal 2
               Move Team (TeamX - 1) to Team (TeamX)
          End-Perform
          Move Temp to Team (2)
     End-Perform
     Stop Run.</pre><P>
<P>
<HR><P>Copyright &copy; 1994, <I>Dr. Dobb's Journal</I></P></BODY></HTML>
