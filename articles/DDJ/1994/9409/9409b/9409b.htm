<HTML>
<META NAME="year" CONTENT="1994">
<HEAD>
<TITLE>SEP94: K-Tree Container Data Structures</TITLE></HEAD>
<BODY BGCOLOR="#ffffff">
<h1>K-Tree Container Data Structures<a name="00c6_0046"></h1><P>
<h2><a name="00c6_0044"><a name="00c6_0000">Fast subscripting, slicing, and concatenation of sequences</h2><P>
<h3>Rodney Bates</h3><P>
<p><i><a name="00c6_0045"><a name="00c6_0000">Rod is an engineer with Boeing aircraft and can be contacted at bates@salsv3.boeing.com.</i></p><hr><P>
In dealing with the problem of browsing and debugging incomplete programs, I needed to efficiently handle tree nodes with variable (possibly large) numbers of children. To address this problem, I developed a data structure called a &quot;K-tree,&quot; which also has general applicability.<P>
K-trees are container data structures that represent linear sequences of integers, pointers, and the like. There are countless ways of representing a sequence, but almost all are variations on arrays or linked lists.<P>
Arrays are very fast when you have a subscript, say, <I>I</I>, and want to find the <I>I</I>th element of the sequence. The time required by the address computation does not increase as the sequence gets longer. This is called a &quot;constant-time&quot; operation. On the other hand, if you want to concatenate two sequences or extract a subsequence (a slice), part of some array must be copied. The time this requires increases in direct proportion to the length of the sequences. This is a &quot;linear-time&quot; operation.<P>
The many variants of linked-list representations tend to be just the opposite. You can cut apart pieces of a linked list and splice them together in constant time. But finding the <I>I</I>th element requires traversing from one end of the list, which is linear.<P>
Now, suppose you need to do a mixture of constant-time operations and linear operations. As the problem gets bigger, linear operations will account for almost all the time the program takes to run, while the overall effect of constant-time operations is negligible. In an application where both kinds of operations are needed, performance is indicated by the most inefficient operation--linear, in this case.  <P>
With K-trees, subscripting, slicing, and concatenation all take time proportional to the logarithm of the length of the sequence. This is not as good as constant time, but it's much better than linear time. Since no operation is worse than logarithmic time, the logarithmic performance dominates.<P>
K-trees have one other important characteristic that I needed in my application. When you extract a slice, the original sequence from which it was taken is preserved. The same goes for concatenation and subscripted assignment. Most of the array and linked representations have some operation which destroys operands, unless you first make a copy, which is, of course, linear.<P>
To make this preservation of operands happen, K-trees use heap objects that are immutable--once created, they never change. These objects can be shared among several sequences, and this is vital to making the operations logarithmic. On the downside, some kind of garbage collection is needed to reclaim objects no longer used in any sequence.<P>
<h3><a name="00c6_0047">The K-tree Data Structure<a name="00c6_0047"></h3><P>
A K-tree is a pointer to one of two kinds of nodes, both of which contain an integer field named <I>Height</I>. If <I>Height=1</I>, the node is a leaf node and contains a field named <I>LeafElems</I> (a small array of sequence elements). If <I>Height&gt;1</I>, the node is a nonleaf node and contains a field named <I>NonleafElems</I> (a small array of records). Each record contains two fields named <I>CumChildCt</I> and <I>ChildRef</I>. <I>CumChildCt</I> has the type of sequence subscripts. <I>ChildRef</I> is a K-subtree pointer.<P>
Every node has a field named <I>ElemCt</I> which gives the number of elements. The elements of both leaf and nonleaf nodes have subscripts in the range 0..<I>ElemCt</I>--1. Each node is dynamically allocated when created, with exactly enough space to hold <I>ElemCt</I> elements.<P>
<a href="199400c8.htm">Figure 1</A> shows a graphical notation for both kinds of nodes. The fields and array subscripts are labeled, showing how to interpret the nodes in the examples that follow.<P>
There is a global maximum, N, for the number of array elements in any node of either kind. N must be at least 3. A leaf node with one element occurs only in the representation of a singleton sequence. Every other node always has at least two elements. <a href="199400c9.htm">Figure 2</A> shows some examples of small K-trees and the sequences they represent. The elements of sequences are integers. <a href="199400ca.htm">Figures 2(b) and 2(c)</A> are two different K-trees which represent the same sequence. In general, there are many K-tree representations for a given sequence. A given K-tree represents only one sequence, according to the following rules:<P>
<UL>
<li>A NIL pointer represents the empty sequence. A pointer to a leaf node represents just the elements of <I>LeafElems</I>. A pointer to a nonleaf node represents the concatenation of the sequences represented by the <I>ChildRef</I> fields.</li>
<li>The value of <I>CumChildCt</I> in the <I>J</I>th element of a nonleaf node is the sum of the lengths of the subsequences represented by the <I>ChildRef</I> fields of <I>NonleafElems[0..J]</I>. This means that <I>NonleafElems[ElemCt  --1].CumChildCt</I> is the length of the sequence represented by this node.</li>
<li>From a given node, all paths to leaves have the same length. This value is stored in the <I>Height</I> field. K-trees are always full in the sense that, although <I>ElemCt</I> may vary, there are no NIL pointers in <I>ChildRef</I> fields.</li>
<li>No node contains any information derived from its parent or siblings. Since the nodes are immutable, any subtree can be shared among many parents, each of which belongs to a different K-tree.</li>
</UL>
<h3><a name="00c6_0048">Subscripted Fetching<a name="00c6_0048"></h3><P>
Subscripted fetching proceeds top-down, using an intermediate subscript I that is always relative to the current K-subtree. If the K-subtree is a leaf, the sequence subscript is the subscript to <I>LeafElems</I> and leads directly to the desired sequence element.<P>
If the K-subtree is a nonleaf, fetch must determine to which of the node's subtrees it should descend by comparing <I>I</I> with the values of <I>CumChildCt</I> in the elements of <I>NonleafElems</I>. These values are, by definition, in ascending order, so this can be done using a classic binary search.<P>
Before fetch descends into the subtree, it must reduce the sequence subscript by <I>CumChildCt</I> of the subtree to the left of the one it is about to descend into.<P>
<h3><a name="00c6_0049">Subscripted Assignment<a name="00c6_0049"></h3><P>
Subscripted assignment begins like subscripted fetching, proceeding top-down through the K-tree to the desired leaf element. However, the located element cannot be altered in place, as this would violate the preservation-of-operands property.<P>
Instead, <I>store</I> allocates a copy of the old leaf node and alters the <I>I</I>th element of the copy. It then returns the pointer to the new node to the level above. Each nonleaf level does essentially the same thing, except it replaces only the <I>ChildRef</I> field of the selected element of its copied node with the pointer it receives from below.<P>
The result is a new K-tree, in which all nodes on the path from the root to the leaf node containing the <I>I</I>th sequence element have been replaced, while all nodes off this path are shared with the original K-tree.<P>
<a href="199400cb.htm">Figure 3</A> shows the result of assigning value 8 to element number 4 of the K-tree in <a href="199400cc.htm">Figure 2</A>(d). The shaded nodes have identical contents and are the same nodes as before the assignment. The other nodes are new. The two new nonleaf nodes look the same as before, but have different values in one of the <I>ChildRef</I> fields. To illustrate this, pointer values which have changed are shown as dashed arrows.<P>
<h3><a name="00c6_004a">Concatenation<a name="00c6_004a"></h3><P>
Concatenation is done by constructing a <I>seam</I> along the right edge of the left-operand K-tree and the left edge of the right-operand K-tree. The seam is constructed bottom-up, matching, and possibly joining, pairs of nodes of the same height from both sides of the seam.  <P>
The K-tree representation rules leave some choices as to how the seam is constructed. If the two operand K-trees have the same height, <I>concatenate </I>could just create a new nonleaf node of two elements, with the operand K-trees as its two children. This is simple, but building tends toward binary trees. It would be better to try to keep nodes more nearly full.<P>
Starting from the bottom in the algorithm I chose, <I>concatenate</I> moves higher as long as the total number of elements in the nodes on either side of the seam at a given level is greater than N. Once it reaches a level with N or fewer elements, it allocates a new node and repacks the elements.<P>
Once repacking has started, every level above has to have one or two new nodes allocated because some changes in child pointers will be needed to reflect the replacement of old nodes at the level below.<P>
If the total number of new elements along the seam is greater than N, two new nodes will be needed. In this case, I divide the elements equally between the new nodes, so as to keep node sizes equal.<P>
<a href="#00c6_004d">Figure 4</A> gives an example of K-trees before and after concatenation, showing only the nodes along the seam. The <I>CumChildCt</I> fields are omitted in this example. The small numbers in circles represent nodes to either side of the seam without showing their contents. All these nodes are reused.<P>
At height one, the two leaf nodes collectively have seven elements, which can't be repacked into one node. They are reused intact in the result. At height two, there are six elements altogether, so they are repacked into one new nonleaf node.  <P>
At height three, there are initially eight elements. Two point to nodes that are not reused in the result and whose replacement consists of only one node. This leaves a total of seven new elements needed along the seam. These are distributed into the two new nodes, three elements in one node and four in the other.<P>
At height four, only the right-operand K-tree has a node. The root pointer of the left operand is treated as a fictitious, one-element node, which must be repacked with the elements from the right side of the seam. This requires a total of seven elements: Two point to replacements for old nodes, and the rest point to reused nodes to the right of the seam.<P>
Finally, a new node at height five is needed to collect the two nodes of height four. Thus the height of the result K-tree is one greater than the highest-operand K-tree.<P>
Implementing concatenation is somewhat more complex than the concept. A recursive procedure has to start at the top of the K-trees, descend to the leaves, and then do its work on the way back up. The operand K-trees could have different heights. The <I>Height</I> field allows the descent to synchronize itself so it is working on nodes of the same height on each side of the seam. Unequal heights also create some special cases for node construction during the return to the top.<P>
<h3><a name="00c6_004b">Slicing<a name="00c6_004b"></h3><P>
K-trees are sliced bottom-up by constructing two cuts through the operand K-tree along the left and right edges of what will become the result K-tree. At each level, the node is divided between the elements belonging to the slice and those outside the slice. The <I>node slice</I> of the divided node on its &quot;sliceward&quot; side must be included in the result K-tree.  <P>
The node slice could have only one element. If this happens, it is repacked with the adjacent node in the sliceward direction. This will give a total of at least three and at most N+1 elements, which can always be packed into either one or two new nodes. As an optimization to keep nodes more nearly full, the node slice and the adjacent node are also repacked any time they will collectively fit into one new node.<P>
As with concatenation, the slice algorithm must start at the top of the operand K-tree, descend recursively, and do its reconstruction on the way back up. However, when slicing, the descending phase must determine, at each level, which child to descend to, using the starting and ending slice subscripts. This is done using the same binary-search technique used in subscripting.<P>
When computing a wide-enough slice at low-enough levels, the left and right cuts are separated by other K-tree nodes, which will be reused in the result K-tree. Whenever at least two nodes separate those containing the two cuts, each side of the slice can be constructed independently.<P>
At higher levels, the two cuts must be handled interdependently whenever they are spread over three or fewer nodes,  since a sliceward node adjacent to a cut is involved. In these cases, the new elements will fit in at most three new nodes. When only one element exists, no new node is constructed. Instead, the single pointer is passed up, eventually to become the result K-tree, which will be lower than the operand K-tree.<P>
<a href="#00c6_004e">Figure 5</A> gives an example of slice construction, showing only relevant nodes along the cuts. The notation is the same as in <a href="#00c6_004d">Figure 4</A>, except that wavy lines through nodes are used to show the location of the left and right cuts.<P>
At height one, the two cuts are independent. On the left, the node slice of the leftmost node shown in full contains one element whose value is 20. This is repacked with the three elements 19, 4, and 25 of the next rightward node. On the left, the entire node containing element values 16 and 10 is reused.<P>
At height two, three nodes are involved in the slice. At the left end, two elements have been replaced by one new element, returned from below. All other elements involved are reused. This gives a total of seven elements, which are repacked into two new nodes.<P>
At height three, only two nodes are involved. The two new pointers returned from the level below are packed into a single new node.<P>
Finally, at height four, only one node is involved. Two of its elements are replaced by one new node. Since one pointer does not require a node at this level, it becomes the entire result K-tree.  <P>
<h3><a name="00c6_004c">The Implementation<a name="00c6_004c"></h3><P>
The source-code implementation of K-trees (along with programmer notes) is available electronically; see &quot;Availability&quot; on page 3. I implemented K-trees in Modula-3 for a couple of reasons. First, it has sufficient richness in its type system to handle K-tree data structure without resorting to type-unsafe tactics. Secondly, it has built-in garbage collection. <P>
I tested the K-Tree program with many randomly generated cases. If you run the test program, be aware that the large number of trees and the brute-force verification make it a memory and CPU hog. You might want to reduce <I>SingletonCt</I>, <I>CatCt</I>, <I>CatOfSliceCt</I>, and <I>StoreCt</I>, for a more modest test run.<P>
<H4><a href="199400cd.htm">Figure 1</A>  Notation for K-tree nodes.<P>
<a href="199400ce.htm">Figure 2</A>  K-trees and their sequences; (a) 13; (b) 7, 25, 19, 47, 5; (c) 7, 25, 19, 47, 5; (d) 16, 0, 15, 23, 6, 14, 11, 7, 3, 19, 29.<P>
<a href="199400cf.htm">Figure 3</A>  New K-trees after assignment of value 8 to element number 4.<P></H4>
<h4><a name="00c6_004d"><B>Figure 4:</B>  <a href="199400d0.htm">(a)</A> Before concatenation; <a href="199400d1.htm">(b)</A> after concatenation; N=6.<a name="00c6_004d"></h4><P>
<h4><a name="00c6_004e"><B>Figure 5:</B>  <a href="199400d2.htm">(a)</A> Before slicing; <a href="199400d3.htm">(b)</A> after slicing.<a name="00c6_004e"></h4><P>
<P>
<HR><P>Copyright &copy; 1994, <I>Dr. Dobb's Journal</I></P></BODY></HTML>
