<HTML>
<META NAME="year" CONTENT="1994">
<HEAD>
<TITLE>OCT94: C PROGRAMMING</TITLE></HEAD>
<BODY BGCOLOR="#ffffff">
<h1>C PROGRAMMING<a name="0181_0075"></h1><P>
<h2><a name="0181_0073"><a name="0181_0000">Lexical Scanning and Symbols</h2><P>
<h3>Al Stevens</h3><P>
<a name="0181_0074"><a name="0181_0000">This month I'll look at the lexical scan that Quincy uses to build a run-time interpretable token stream and at the symbol-table process. Quincy is operational: I finished the tutorial book it was designed to support and integrated its tutorial mode with the book's exercises. I'll devote the next several columns to the completion of the project.<P>
<h3><a name="0181_0076">On and Off the Road Again<a name="0181_0076"></h3><P>
I'm back at home after a two-week tour of the Midwest, playing the piano at jazz festivals and concerts. I always figure I'll get a lot of day-gig work done on the road by taking the laptop. I've got one of those converters that you plug into the car cigarette lighter to get household current. The idea is to pound out columns, books, and software while Judy drives. (Dream on, Al.) That converter would heat a small stadium. Luckily, the minivan has an adequate air conditioner. Judy has been working on her family tree, so between the two of us, we got a lot of computing mixed in with the commuting. She uses a program called &quot;Family Tree Maker for Windows,&quot; and that is one slick program. Being a devoted DOS user, Judy reluctantly switched to Windows because she hit the wall on FTM's DOS version. It holds only about 1200 people, and there are a lot more Stauffers than that in Ringtown, Pennsylvania.<P>
Upon our return, I hooked the laptop into the network to upload all our road work to the desk machines. I have one of those dongle-like Ethernet adaptors that plugs into the laptop printer port. Without it I'd have to move files around on diskettes. Since I was in a hurry, Murphy's law kicked in, and the network device's AC/DC adaptor fell apart when I plugged it into the wall. The tiny ends of the transformer winding were sheared off and too short to solder. A search of the workshop turned up no other adaptor that delivers 12 volts DC and 500 milliamps. The garage, however, provided the solution. I am now making high-speed file transfers across my high-tech network through a state-of-the-art network adaptor powered by a 30-year-old automobile battery charger/eliminator. Greasy, dented, bigger than a hatbox, with bug-eyed volt and amp meters, fat cables, and brass clamps, it squats on my desk next to all the fancy stuff and proudly does what it does best--delivers a well-regulated, flat, clean, 12 volts that you could weld with.<P>
<h3><a name="0181_0077">Lexical Scanning<a name="0181_0077"></h3><P>
A language translator has several processes. When the language is C, the first process is the preprocessor. Not all languages have preprocessors; the operations served by C's preprocessor are often built-in operators in other languages. C's preprocessor converts C code and preprocessing directives into C code ready to be translated. I discussed Quincy's preprocessor in the June and July issues.<P>
The first part of translation beyond preprocessing is the lexical scan, which reads the source code and translates it into tokens--single-character codes that represent discrete language elements. Subsequent translation operates on this stream of tokens. When the translator is an interpreter, the token stream is what the interpreter reads to execute the program.<P>
Tokens represent identifiable language elements. The lexical scan parses the source code from beginning to end, extracting code fragments and translating them into tokens. The four discrete parts of C code are keywords, operators, constants, and identifiers. When the interpreter is integrated with a debugger, the token stream must also identify line numbers from the original source code.<P>
<h3><a name="0181_0078">Syntax Checking<a name="0181_0078"></h3><P>
The main purpose of the lexical scan is to reduce source code into smaller, more easily interpreted code. The code's grammatical correctness is the concern of a later process. Compilers do that in the code-generation process when they compile tokens into executable code. An interpreter such as Quincy involves some mix of compile-time and run-time grammatical-syntax checking. In general, the lexical scan determines only that each element of code is translatable into a language token without respect to its grammatical context, but there are exceptions. For example, the colon character has four uses in the C language. It terminates statement labels; terminates case expressions; serves as the second, <I>else</I> delimiter of the ?: conditional operator; and may appear in string and character constants. (Its potential appearance in comments is unimportant in this context because the preprocessor strips comments from the source code.) The same thing applies to the dot, which can be part of a floating-point constant, the structure-member dereferencing operator, or one-third of the ellipse token. The lexical scan recognizes and translates constants, ellipses, and statement labels, so it must do some contextual analysis of the source code.<P>
<h3><a name="0181_0079">The <I>tokenize</I> Function<a name="0181_0079"></h3><P>
<a href="#0181_0084">Listing One</A> is scanner.c, Quincy's lexical scanner, which consists of the <I>tokenize</I> function and some local functions. The <I>tokenize</I> function accepts two pointer arguments. The first points to a buffer to receive the token stream, and the second, to the preprocessed source code. The scanner reads the source code a character at a time and determines which token to build, based on the character's value. First the scanner calls the <I>FindOperator</I> function to see if the current character and the next one constitute a two-character operator, such as the != not-equal operator. That function returns the token when it finds such an operator and 0 when it does not. If <I>FindOperator</I> returns a token, the scanner copies it to the token stream. If the token is one of the shift operators, the scanner tests to see if it is followed by an equal sign, which signifies a shift-assignment operator. If so, the token is modified accordingly. <P>
<h3><a name="0181_007a">Newlines and Line-Number Information<a name="0181_007a"></h3><P>
The scanner recognizes the newline character to identify the file and line number for the debugger. The preprocessor inserts a newline and comment for each nonblank source-code line. The comment has the format <I>/*01:02*/</I>, where the first value is the file number of the source-code file, and the second is the line number within that file. The preprocessor assigns a file number to each included file and puts the filename in a global table that the interpreter and debugger can use to report errors to the programmer. The token stream for a newline contains a T_LINENO token followed by two unsigned character integers containing the file and line numbers.<P>
<h3><a name="0181_007b">String Constants<a name="0181_007b"></h3><P>
A double quote in the source code indicates the beginning of a string constant. The scanner copies the T_STRCONST token to the token stream, followed by the length of the string and the null-terminated string value itself. The scanner remembers that it just processed a string constant so that if another one immediately follows, it can properly concatenate adjacent strings. Translation of the string calls the <I>uncesc</I> function for each character, which returns the character value or its value as represented by a backslash-escape sequence.<P>
<h3><a name="0181_007c">Character Constants<a name="0181_007c"></h3><P>
Character constants are like string constants except that character constants occupy one character position. The scanner builds a character constant when it sees an apostrophe, inserting a T_CHRCONST token and the character-constant value into the token stream. The scanner gets the character value from the <I>unesc</I> function, which decodes escape sequences.<P>
<h3><a name="0181_007d">Operators<a name="0181_007d"></h3><P>
The scanner converts C operators into their token equivalents, which are the same as the operators themselves. If the operator is one of those that can combine with the equal sign to form an assignment operation (+=, --=, etc.), the scanner puts a true value into the <I>op</I> variable. Then, if the next character in the source-code stream is an equal sign, the scanner sets the operator's most significant bit, which identifies the operator as an assignment operation. <P>
<h3><a name="0181_007e">Dots, Braces, Colons, and Question Marks<a name="0181_007e"></h3><P>
If a dot is followed by two more dots, they are converted into the T_ELLIPSE token. If the dot is followed by a digit, however, the scanner calls the <I>fltnum</I> function to build a floating-point constant.<P>
The scanner counts and balances pairs of left and right braces and then copies them into the token stream as their own tokens. It uses the brace count when it builds statement labels, and it uses a brace count of 0 to know that it can assume an external function declaration or definition.<P>
The question mark is the <I>if</I> part of a conditional expression. The scanner remembers that one has been seen so that it does not try to interpret a subsequent identifier/colon pair as a statement label.<P>
<h3><a name="0181_007f">Numerical Constants<a name="0181_007f"></h3><P>
When the scanner sees a digit in the source code, it assumes a numerical constant. It calls the <I>intnum</I> function to decide which kind of constant to build into the token stream.<P>
The <I>intnum</I> function scans the characters from the point of the digit until it finds a nondigit character. If that character is a dot or an upper- or lowercase &quot;E,&quot; the constant is a floating constant, and <I>intnum</I> calls <I>fltnum</I> to translate it. Otherwise, <I>intnum</I> looks at the first digit. If it is a 0 and the next character is a digit, the constant is an octal number. If the first two characters are 0x, the constant is a hexadecimal number. Otherwise, the constant is a decimal integer. Depending on the range of the number and whether or not it is followed by L, the constant is either short or long. Accordingly, the program builds either the T_INTCONST or T_LNGCONST token into the token stream followed by the constant's integer value of the appropriate length.<P>
The <I>fltnum</I> function builds a floating constant, which follows the T_FLTCONST token in the token stream.<P>
<h3><a name="0181_0080">Keywords and Identifiers<a name="0181_0080"></h3><P>
An alphabetic character or an underscore means that the next language element is either a keyword or an identifier. The scanner calls the <I>FindKeyword</I> function, which returns a keyword's token if the text is a keyword, and 0 if not.<P>
If the text is not a keyword, it is either a variable, a function identifier, or a statement label. If it is followed by a colon (and a <I>case</I> or conditional expression is not being built), the identifier is a statement label, so the scanner builds and installs a <I>Variable</I> structure for the label. The label includes the current brace-nesting count, which helps the interpreter to find its way to the label when it processes a matching <I>goto</I> statement.<P>
If the text is neither a keyword nor a statement label, the scanner calls <I>AddSymbol</I> to add the identifier to the symbol table and to get an integer value to represent the symbol. The <I>AddSymbol</I> function adds the symbol to the table and returns its integer value or, if the symbol is already in the table, returns the previously assigned integer value. The scanner is not interested in identifier scope or reuse. It needs only a unique integer offset for each unique identifier.<P>
An identifier can be either a variable reference, a function declaration/definition, or a call to a function, for which the scanner assigns the tokens T_SYMBOL, T_FUNCTION, and T_FUNCTREF, respectively.<P>
The interpreter does not deal with actual identifiers. It uses the integer offsets that the scanner assigns to represent unique identifier values. The interpreter keeps the symbol table throughout the run so that the user can name identifiers to watch, examine, and modify from within the debugger.<P>
You might wonder why <a href="#0181_0084">Listing One</A> includes a preprocessing directive statement that undefines <I>isxdigit</I>, forcing the compiler to use the function version of <I>isxdigit</I> rather than the macro version. For some reason, the Borland C++ compilers (3.1 and 4.0) that I use to compile Quincy do not compile the macro version correctly all the time.<P>
<h3><a name="0181_0081">Symbol Tables<a name="0181_0081"></h3><P>
Quincy uses five symbol tables during translation. Four of them are static; they record library-function identifiers, keywords, multiple-character operators, and preprocessor directives. The fifth is the dynamic table of identifiers that the program declares.<P>
<a href="#0181_0085">Listing Two</A> is symbols.c, the program that declares and manages symbol tables. The tables are arrays of SYMBOLTABLE objects. SYMBOLTABLE is a structure defined by the qnc.h header file. <a href="#0181_0085">Listing Two</A> declares and initializes the static symbol tables. <P>
Each symbol table associates its symbols with an integer code. Library functions are associated with codes that tell the interpreter which functions to execute. Keywords and operators are associated with interpreter tokens. Preprocessor identifiers are associated with a value that the preprocessor uses to determine which directive to process. Declared identifiers are associated with unique integer values that the scanner assigns in the order in which the identifiers occur.<P>
Symbol tables are maintained in identifier sequence to facilitate a binary search on an identifier argument. The <I>SearchSymbols</I> function implements the binary search and is followed by several specialized functions that call <I>SearchSymbols</I> to search the individual tables. (The <I>FindOperator</I> function mentioned earlier is one such function.) Each of these functions takes an identifier as an argument and returns the code that matches the identifier or 0 if the identifier is not in the table. The <I>FindSymbolName</I> function takes an identifier code and returns a pointer to the matching identifier. The debugger uses this function to display function lists and matched variable names. The <I>AddSymbol</I> function adds an identifier to the dynamic symbol table and returns the code that the function associates with the new entry.<P>
<h3><a name="0181_0082">Run Time versus Compile Time<a name="0181_0082"></h3><P>
Quincy's lexical scanner and linker--the process that follows the scanner--defers until run time some of the language translation and error checking. This approach reflects the compromises that I made in the interest of performance. Inasmuch as Quincy is an interactive interpreter, I want to get the program running as soon as possible after the user makes some changes and chooses the run command. Therefore, some of the operations normally done by a compiler are done during run time by the interpreter. As a result, the program does not run as efficiently as it would if things such as the recursive-descent parser were earlier done by the translator. The performance hit does not concern me; Quincy's purpose is to support an interactive C-language tutorial, not to be a comprehensive software-development environment. Sometimes I mull over design changes that would support object linking, build stand-alone EXE files, optimize the run-time token interpretation, or yield some other slick improvement. After pondering those subjects for a while, it occurs to me that I would just be rebuilding Turbo C 1.0, and nobody needs that.<P>
<h3><a name="0181_0083">Book Report: <I>The Zen of Code Optimization</I><a name="0181_0083"></h3><P>
It's supposed to be hip to name a book the &quot;Zen&quot; of something. The local library lists over a dozen such books on as many subjects. The classic standard-bearer of that title is <I>Zen and the Art of Motorcycle Maintenance</I>, by Robert M. Pirsig, which had a lot to do with Zen and something to do with motorcycle maintenance. Most of the others have very little to do with Zen and a lot to do with the other part of their titles. <I>The Zen of Code Optimization</I>, by Michael Abrash (Coriolis Group Books, 1994, ISBN 1-883577-03-9) falls into that category. It is one of a series of Zen books from the publisher who dubs his authors &quot;Zen masters.&quot; This represents, I suppose, the other side of the world--far away from a population of Dummies who talk about computers and programming in spite of their doubts, lack of confidence, and low self-esteem. It also reflects a trend among book publishers to create &quot;lines&quot; of books with titles that are like one another, usually following an unexpected success. Thus, we might see <I>Advanced C++ Class Design for Dummies</I>, <I>Teach Yourself Quantum Mechanics</I>, and <I>OLE2 Made Easy in 21 Days</I>.<P>
Zen is a school of Buddhism wherein enlightenment is attained through meditation, self-contemplation, and intuition rather than through scriptures. A Zen Buddhist would therefore conclude that such a line of contemporary scriptures could not lead the reader anywhere near enlightenment. So, do not buy this book expecting to learn about Zen or to attain perfect programming enlightenment.<P>
But, by all means, buy this book.<P>
<I>The Zen of Code Optimization</I> is about writing fast code for the PC. More to the point, it is about viewing code that you've written with an eye to optimizing its performance. To optimize is to make as good as possible. What's good? Fast? Cheap? Small? Portable? On time? Depends on who you ask. In this case, only fast is good. Use the fewest processor cycles to do the same job. Optimize for speed. The book takes the position that you, the programmer, are the best speed optimizer. Only you can find the bottlenecks and only you can widen them. When is speed important? Are all bottlenecks bad? Why worry about cutting down on the cycles used waiting for a keystroke? Where in your program is valuable time wasted? This book encourages you to ask and answer such questions and does so by example. It starts with a program that works but that is not as fast as it might be. Then it moves the program through successive performance enhancements, explaining each time, the implication of the change, why it speeds things up, and what there is about the earlier version that should call your attention to the change. That's the important lesson. Learn how to spot the performance bottlenecks. Can you remove them without compromising the program's readability and maintainability? If not, is it worth it?<P>
To help spot the bottlenecks, Abrash provides a timer program written in assembly language that uses the PC's 8253 timer chip to measure the performance in C programs. The C program links with these functions and calls them to record the elapsed times of processes that you want to measure. A poor man's profiler, of sorts. <P>
The book teaches about exploiting hardware, using assembly language where it makes sense, and not using assembly language where it doesn't matter; it also includes several chapters on the Pentium. There are examples that optimize the game of Life, the Boyer-Moore string-searching algorithm, and much more. The book includes a diskette. Perhaps you will use the code in a project, perhaps not. The important contribution is not so much Abrash's code, which is certainly good, but his influence on your view and attitude toward your own code. When a book keeps you thinking well after you are finished reading it, then it has served you well, and this is such a book.<P>
<P>
<h4><a name="0181_0084">Listing One <a name="0181_0084"></h4><pre>


/* --- scanner.c - Quincy's lexical scanner --- */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &quot;qnc.h&quot;
#undef isxdigit

static int uncesc(char **);
static void fltnum(char **, char **);
static void intnum(char **, char **);

/* --- Convert C in srcbuf to tokens in tknbuf --- */
int tokenize(char *tknbuf, char *srcbuf)
{
    char *start, *laststring = NULL, *cp, c, c2, c3, op;
    char buf[8];
    int i;
    int BraceCount = 0;
    char *tknptr = tknbuf;
    int sawCond = 0;
    int sawCase = 0;
    while (*srcbuf)    {
        /* --- search for 2-char C operators --- */
        if ((i = FindOperator(srcbuf)) != 0)    {
            srcbuf+=2;
            if ((i == T_SHL || i == T_SHR) &amp;&amp; *srcbuf == '=')  {
                srcbuf++;
                i |= 0x80; /* encode op= operator */
            }
            *tknptr++ = i;
            continue;
        }
        c = *srcbuf++;    /* next src code char */
        c &amp;= 0x7f;
        op = 0;
        c2 = *srcbuf;     /* lookahead 1 */
        c3 = *(srcbuf+1); /* lookahead 2 */
        if (c != '&quot;' &amp;&amp; c != '\n')
            laststring = NULL;
        switch (c)    {
            case '\n':  /* File/Line */
                /*  _____________
                 * | T_LINENO    |
                 * |_____________|
                 * |fileno (byte)|
                 * |_____________|
                 * |lineno (word)| 
                 * |_____________| */
                handshake();   /* keep D-Flat clock ticking */
                *tknptr++ = T_LINENO;
                Ctx.CurrFileno = atoi(srcbuf+2);
                *tknptr++ = (unsigned char) Ctx.CurrFileno;
                srcbuf = strchr(srcbuf, ':');
                Assert(srcbuf != NULL);
                srcbuf++;
                Ctx.CurrLineno = atoi(srcbuf);
                *(int*)tknptr = Ctx.CurrLineno;
                tknptr += sizeof(int);
                srcbuf = strchr(srcbuf, '/');
                Assert(srcbuf != NULL);
                srcbuf++;
                break;
            case '&quot;': /* string constant */
                /*  ___________
                 * | T_STRCONST|
                 * |___________|
                 * |   length  |
                 * |___________|
                 * |  char(s)  |
                 * |___________|
                 * |     0     |
                 * |___________| */
                if (laststring != NULL)
                    /* ---- concatenated string ---- */
                    tknptr = laststring+strlen(laststring);
                else    {
                    *tknptr++ = T_STRCONST;
                    laststring = tknptr++;
                }
                while ((c = *srcbuf) != '&quot;' &amp;&amp; c)
                    *tknptr++ = uncesc(&amp;srcbuf);
                *tknptr++ = '\0';
                *laststring = tknptr - laststring;
                if (c)
                    ++srcbuf;
                break;
            case '\'': /* character constant */
                 /*  ___________
                  * | T_CHRCONST|
                  * |___________|
                  * |   value   |
                  * |___________| */
                *tknptr++ = T_CHRCONST;
                *tknptr++ = uncesc(&amp;srcbuf);
                /* --- Skip to delimiting apostrophe --- */
                while ((c = *srcbuf++) != '\'' &amp;&amp; c)
                    ;
                if (!c)
                    --srcbuf;
                break;
            /* --- operators --- */
            /*  ___________
             * |  op token |
             * |___________| */
            case '*':
            case '^':
            case '%':
            case '&amp;':
            case |:
            case '+':
            case '-':
            case '/':
                op = c;
            case '=':
            case '!':
            case '&lt;':
            case '&gt;':
            case '[':
            case ']':
            case '(':
            case ')':
            case ',':
            case '~':
            case ' ':
            case ';':
                /* --- single character operator --- */
                *tknptr++ = c;
                break;
            case '?':
                sawCond++;
                *tknptr++ = c;
                break;
            case ':':
                if (sawCond)
                    --sawCond;
                sawCase = 0;
                *tknptr++ = c;
                break;
            case '{':
                BraceCount++;
                *tknptr++ = c;
                break;
            case '}':
                --BraceCount;
                *tknptr++ = c;
                break;
            case '.':
                if (c2 == '.' &amp;&amp; c3 == '.')    {
                    *tknptr++ = T_ELLIPSE;
                    srcbuf += 2;
                }
                else if (isdigit(c2)) {
                    /*
                     * floating pointer number.
                     */
                    --srcbuf;
                    fltnum(&amp;srcbuf, &amp;tknptr);
                }
                else 
                    *tknptr++ = c;

                break;
            default:
                if (isdigit(c))    {
                    /* --- constant --- */
                    /*  ___________
                     * | T_INTCONST| (or T_LNGCONST, 
                     * |___________|  T_FLTCONST, etc.)
                     * |   value   | &lt;- binary value of the
                     * |___________|    number. Number of
                     * |     .     |    bytes depends on type
                     * |___________| */
                    --srcbuf;
                    intnum(&amp;srcbuf, &amp;tknptr);
                }
                else if (alphanum(c))    {
                     /* --- identifier --- */
                    start = cp = tknptr+2;
                    --srcbuf;
                    while (alphanum(*srcbuf))
                        *cp++ = *srcbuf++;
                    *cp++ = 0;
                    if ((i = FindKeyword(start)) != 0)    {
                        /* --- keyword --- */
                        /*  ___________
                         * | key token |
                         * |___________| */
                        *tknptr++ = i;
                        if (i == T_CASE)
                            sawCase = 1;
                    }
                    else if (!sawCond &amp;&amp; !sawCase &amp;&amp;
                                        *srcbuf == ':')    {
                        /* --- label for gotos --- */
                        VARIABLE var, *lvar;
                        NullVariable(&amp;var);
                        var.vkind = LABEL;
                        var.vsymbolid = AddSymbol(start);
                        var.vclass = BraceCount;
                        lvar = InstallVariable(&amp;var,
                            &amp;Ctx.Curfunction-&gt;locals, 0,0,1,0);
                        lvar-&gt;voffset = tknptr - tknbuf;
                        srcbuf++;
                    }
                    else    {
                        /* symbol, function declaration,
                           prototype, or call? */
                        FUNCTION *funcp;
                        int fsymbol = AddSymbol(start);
                        
                        if ((funcp =
                              FindFunction(fsymbol)) != NULL) {
                            /* decl, func call, or addr */
                            /*  ____________
                             * | T_FUNCTREF |
                             * |____________|
                             * | Function   |
                             * | Number     |
                             * |____________| */
                            *tknptr++ = T_FUNCTREF;
                            *(unsigned *)tknptr =
                                (funcp - FunctionMemory);
                            tknptr += sizeof(unsigned);
                        }
                        else if (*srcbuf == '(' &amp;&amp;
                                    BraceCount == 0)    {
                            FUNCTION func;
                            NullFunction(&amp;func);
                            /* declaration or prototype */
                            /*  _____________
                             * | T_FUNCTION  |
                             * |_____________|
                             * |symbol offset|
                             * |_____________| */
                            /* --- install the function --- */
                            func.symbol = fsymbol;
                            func.libcode = SearchLibrary(start);
                            func.ismain =
                                (strcmp(start, &quot;main&quot;) == 0);
                            func.fileno = Ctx.CurrFileno;
                            func.lineno = Ctx.CurrLineno;
                            Ctx.Curfunction = NextFunction;
                            InstallFunction(&amp;func);
                            *tknptr++ = T_FUNCTION;
                            *(int *)tknptr = func.symbol;
                            tknptr += sizeof(int);
                        }
                        else    {
                             /* variable reference */
                             /*  _____________
                              * |  T_SYMBOL   |
                              * |_____________|
                              * |symbol offset|
                              * |_____________| */
                            *tknptr++ = T_SYMBOL;
                            *(int *)tknptr = fsymbol;
                            tknptr += sizeof(int);
                        }
                    }
                }
                else
                     /* --- Bad character in input line --- */
                    error(LEXERR);
        }
        if (*srcbuf == '=' &amp;&amp; op)    {
            tknptr[-1] |= 128;
            ++srcbuf;
        }
    }
    *tknptr++ = T_EOF;
    *tknptr = '\0';
    return tknptr - tknbuf;
}
static int uncesc(char **bufp)
{
    /* Unescape character escapes */
    char *buf, c;

    buf = *bufp;
    if ((c = *buf++)  == '\\')    {
        int i;
        char n[4];

        switch (c = *buf++)    {
            case 'a':  c = '\a'; break;
            case 'b':  c = '\b'; break;
            case 'f':  c = '\f'; break;
            case 'n':  c = '\n'; break;
            case 'r':  c = '\r'; break;
            case 't':  c = '\t'; break;
            case 'v':  c = '\v'; break;
            case '\\': c = '\\'; break;
            case '\'': c = '\''; break;
            case '&quot;':  c = '&quot;';  break;
            case 'x':
                sscanf(buf, &quot;%x&quot;, &amp;i);
                c = i;
                while (isxdigit(*buf))
                    buf++;
                break;
            default:
                if (isdigit(c))    {
                    --buf;
                    for (i=0; i&lt;3 &amp;&amp; isdigit(*buf); ++i)
                        n[i] = *buf++;
                    n[i] = 0;
                    sscanf(n, &quot;%o&quot;, &amp;i);
                    c = i;
                }
                break;
        }
    }
    *bufp = buf;

    return c;
}
static void fltnum(char **srcstr, char **tknstr)
{
    /* Parse a floating point number */
    char *srcp, *cp;
    char numbuf[64];
    char c, n, dot, e, sign;
    double f;
    n = dot = e = sign = 0;
    srcp = *srcstr;
    **tknstr = T_FLTCONST;
    ++(*tknstr);

    while (*srcp)    {

        if ((c = *srcp++) == '.')    {
            if (dot)    {
                /* Already saw a dot */
                --srcp;
                break;
            }
            ++dot;
        }
        else if (c=='e' || c=='E')    {
            if (!(dot || n) || e)    {
                /* 'E' does not immediately follow dot
                    or number */
                --srcp;
                break;
            }
            ++e;
        }
        else if (c=='+' || c=='-')    {
            if (e!=1 || sign)    {
                /* Sign does not immediately follow an 'E' */
                --srcp;
                break;
            }
            ++sign;
        }
        else if (isdigit(c))    {
            ++n;
            if (e)    {
                /* number follows an 'E' - don't allow
                   the sign anymore */
                ++e;
            }
        }
        else    {
            --srcp;
            break;
        }
    }
    /* copy number into local buffer and null terminate it */
    n = 0;
    cp = *srcstr;
    while (cp &lt; srcp)
        numbuf[n++] = *cp++;
    numbuf[n] = 0;
    f = atof(numbuf);
    *((double*)*tknstr) = f;
    *srcstr = srcp;
    *tknstr += sizeof(double);
}
/* --- Parse a decimal, octal or hexadecimal number --- */
static void intnum(char **srcstr, char **tknstr)
{
    char *srcp, *cp, c;
    int i;
    long j;
    int isDecimal = 1;
    /* ---- test for float number ---- */
    srcp = *srcstr;
    while (isdigit(*srcp))
        ++srcp;
    if (*srcp == '.' || *srcp == 'e' || *srcp == 'E')    {
        fltnum(srcstr, tknstr);
        return;
    }
    /* ----- not a float ----- */
    c = T_INTCONST;
    srcp = *srcstr;
    if (*srcp++ == '0')    {
        if (isdigit(*srcp))    {
            /* --- octal constant --- */
            sscanf(srcp, &quot;%o&quot;, &amp;i);
            while (isdigit(*srcp))
                ++srcp;
            isDecimal = 0;
        }
        else if (tolower(*srcp) == 'x')    {
            /* --- hexadecimal constant --- */
            sscanf(++srcp, &quot;%x&quot;, &amp;i);
            while (isxdigit(*srcp))
                ++srcp;
            isDecimal = 0;
        }
    }
    if (isDecimal)    {
        cp = --srcp;
        while (isdigit(*cp))
            ++cp;
        /* --- decimal integer number --- */
        i = atoi(srcp);
        j = atol(srcp);
        if (*cp == 'U')
            cp++;
        if (*cp == 'l' || *cp == 'L')    {
            c = T_LNGCONST;
            ++cp;
        }
        else if (j != (long)i)
            c = T_LNGCONST;
        srcp = cp;
    }
    *srcstr = srcp;
    **tknstr = c;
    ++(*tknstr);
    if (c == T_LNGCONST)    {
        *((long *)*tknstr) = j;
        *tknstr += sizeof(long);
    }
    else    {
        *((int *)*tknstr) = i;
        *tknstr += sizeof(int);
    }
}



</pre>
<h4><a name="0181_0085">Listing Two<a name="0181_0085"></h4><pre>

/* --------- symbols.c --------- */
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &quot;qnc.h&quot;
#include &quot;sys.h&quot;

SYMBOLTABLE LibraryFunctions[] = {
   /* --- These have to be maintained in alphabetic order --- */
   { &quot;_Errno&quot;,    SYSERRNO     },
   { &quot;_filename&quot;, SYSFILENAME  },
   { &quot;_lineno&quot;,   SYSLINENO    },
   { &quot;abs&quot;,       SYSABS       },    
   { &quot;acos&quot;,      SYSACOS      },    
   { &quot;asctime&quot;,   SYSASCTIME   },
   { &quot;asin&quot;,      SYSASIN      },
   { &quot;atan&quot;,      SYSATAN      },
   { &quot;atan2&quot;,     SYSATAN      },
   { &quot;atof&quot;,      SYSATOF      },
   { &quot;atoi&quot;,      SYSATOI      },
   { &quot;atol&quot;,      SYSATOL      },
   { &quot;ceil&quot;,      SYSCEIL      },
   { &quot;clrscr&quot;,    SYSCLRSCRN   },
   { &quot;cos&quot;,       SYSCOS       },
   { &quot;cosh&quot;,      SYSCOSH      },
   { &quot;cprintf&quot;,   SYSCPRINTF   },
   { &quot;cursor&quot;,    SYSCURSOR    },
   { &quot;exit&quot;,      SYSEXIT      },    
   { &quot;exp&quot;,       SYSEXP       },
   { &quot;fabs&quot;,      SYSFABS      },
   { &quot;fclose&quot;,    SYSFCLOSE    },
   { &quot;fflush&quot;,    SYSFFLUSH    },
   { &quot;fgetc&quot;,     SYSFGETC     },
   { &quot;fgets&quot;,     SYSFGETS     },
   { &quot;findfirst&quot;, SYSFINDFIRST },
   { &quot;findnext&quot;,  SYSFINDNEXT  },
   { &quot;floor&quot;,     SYSFLOOR     },
   { &quot;fopen&quot;,     SYSFOPEN     },    
   { &quot;fprintf&quot;,   SYSFPRINTF   },
   { &quot;fputc&quot;,     SYSFPUTC     },
   { &quot;fputs&quot;,     SYSFPUTS     },
   { &quot;fread&quot;,     SYSFREAD     },
   { &quot;free&quot;,      SYSFREE      },
   { &quot;fscanf&quot;,    SYSFSCANF    },    
   { &quot;fseek&quot;,     SYSFSEEK     },
   { &quot;ftell&quot;,     SYSFTELL     },
   { &quot;fwrite&quot;,    SYSFWRITE    },
   { &quot;getch&quot;,     SYSGETCH     },
   { &quot;getchar&quot;,   SYSGETCHAR   },
   { &quot;gets&quot;,      SYSGETS      },
   { &quot;gmtime&quot;,    SYSGMTIME    },
   { &quot;localtime&quot;, SYSLOCALTIME },
   { &quot;log&quot;,       SYSLOG       },
   { &quot;log10&quot;,     SYSLOG10     },
   { &quot;longjmp&quot;,   SYSLONGJMP   },
   { &quot;malloc&quot;,    SYSMALLOC    },
   { &quot;mktime&quot;,    SYSMKTIME    },
   { &quot;pow&quot;,       SYSPOW       },
   { &quot;printf&quot;,    SYSPRINTF    },
   { &quot;putch&quot;,     SYSPUTCH     },
   { &quot;putchar&quot;,   SYSPUTCHAR   },
   { &quot;puts&quot;,      SYSPUTS      },
   { &quot;remove&quot;,    SYSREMOVE    },
   { &quot;rename&quot;,    SYSRENAME    },
   { &quot;rewind&quot;,    SYSREWIND    },
   { &quot;scanf&quot;,     SYSSCANF     },    
   { &quot;setjmp&quot;,    SYSSETJMP    },
   { &quot;sin&quot;,       SYSSIN       },
   { &quot;sinh&quot;,      SYSSINH      },
   { &quot;sprintf&quot;,   SYSSPRINTF   },
   { &quot;sqrt&quot;,      SYSSQRT      },
   { &quot;sscanf&quot;,    SYSSSCANF    },    
   { &quot;strcat&quot;,    SYSSTRCAT    },    
   { &quot;strcmp&quot;,    SYSSTRCMP    },    
   { &quot;strcpy&quot;,    SYSSTRCPY    },
   { &quot;strlen&quot;,    SYSSTRLEN    },
   { &quot;strncat&quot;,   SYSSTRNCAT   },    
   { &quot;strncmp&quot;,   SYSSTRNCMP   },
   { &quot;strncpy&quot;,   SYSSTRNCPY   },
   { &quot;system&quot;,    SYSSYSTEM    },
   { &quot;tan&quot;,       SYSTAN       },
   { &quot;tanh&quot;,      SYSTANH      },
   { &quot;time&quot;,      SYSTIME      },
   { &quot;tmpfile&quot;,   SYSTMPFILE   },
   { &quot;tmpnam&quot;,    SYSTMPNAM    },
   { &quot;ungetc&quot;,    SYSUNGETC    }
};
#define MAXLIBFUNCTIONS (sizeof(LibraryFunctions)/sizeof(SYMBOLTABLE))
/* --------- keyword lookup table ------------ */
static SYMBOLTABLE Keywords[] = {
   /* --- These have to be maintained in alphabetic order --- */
   { &quot;auto&quot;,     T_AUTO     },
   { &quot;break&quot;,    T_BREAK    },
   { &quot;case&quot;,     T_CASE     },
   { &quot;char&quot;,     T_CHAR     },
   { &quot;const&quot;,    T_CONST    },
   { &quot;continue&quot;, T_CONTINUE },
   { &quot;default&quot;,  T_DEFAULT  },
   { &quot;do&quot;,       T_DO       },
   { &quot;double&quot;,   T_DOUBLE   },
   { &quot;else&quot;,     T_ELSE     },
   { &quot;enum&quot;,     T_ENUM     },
   { &quot;extern&quot;,   T_EXTERN   },
   { &quot;float&quot;,    T_FLOAT    },
   { &quot;for&quot;,      T_FOR      },
   { &quot;goto&quot;,     T_GOTO     },
   { &quot;if&quot;,       T_IF       },
   { &quot;int&quot;,      T_INT      },
   { &quot;long&quot;,     T_LONG     },
   { &quot;register&quot;, T_REGISTER },
   { &quot;return&quot;,   T_RETURN   },
   { &quot;short&quot;,    T_SHORT    },
   { &quot;sizeof&quot;,   T_SIZEOF   },
   { &quot;static&quot;,   T_STATIC   },
   { &quot;struct&quot;,   T_STRUCT   },
   { &quot;switch&quot;,   T_SWITCH   },
   { &quot;typedef&quot;,  T_TYPEDEF  },
   { &quot;union&quot;,    T_UNION    },
   { &quot;unsigned&quot;, T_UNSIGNED },
   { &quot;void&quot;,     T_VOID     },
   { &quot;volatile&quot;, T_VOLATILE },
   { &quot;while&quot;,    T_WHILE    }
};
#define MAXKEYWORDS (sizeof(Keywords)/sizeof(SYMBOLTABLE))
/* -------- multi-character operator lookup tbl ------------ */
static SYMBOLTABLE Operators[] = {
   /* --- These have to be maintained in collating order --- */
   { &quot;!=&quot;,      T_NE    },
   { &quot;&amp;&amp;&quot;,      T_LAND  },
   { &quot;++&quot;,      T_INCR  },
   { &quot;--&quot;,      T_DECR  },
   { &quot;-&gt;&quot;,      T_ARROW },
   { &quot;&lt;&lt;&quot;,      T_SHL   },
   { &quot;&lt;=&quot;,      T_LE    },
   { &quot;==&quot;,      T_EQ    },
   { &quot;&gt;=&quot;,      T_GE    },
   { &quot;&gt;&gt;&quot;,      T_SHR   },
   { ||,      T_LIOR  }
};
#define MAXOPERATORS (sizeof(Operators)/sizeof(SYMBOLTABLE))
static SYMBOLTABLE PreProcessors[] = {
   /* --- These have to be maintained in collating order --- */
   { &quot;define&quot;,  P_DEFINE  },
   { &quot;elif&quot;,    P_ELIF    },
   { &quot;else&quot;,    P_ELSE    },
   { &quot;endif&quot;,   P_ENDIF   },
   { &quot;error&quot;,   P_ERROR   },
   { &quot;if&quot;,      P_IF      },
   { &quot;ifdef&quot;,   P_IFDEF   },
   { &quot;ifndef&quot;,  P_IFNDEF  },
   { &quot;include&quot;, P_INCLUDE },
   { &quot;undef&quot;,   P_UNDEF   }
};
#define MAXPREPROCESSORS (sizeof(PreProcessors)/sizeof(SYMBOLTABLE))
/* --- search a symbol table for matching entry --- */
int SearchSymbols(char *arg, SYMBOLTABLE *tbl, int siz, int wd)
{
   int i, mid, lo, hi;

   lo = 0;
   hi = siz-1;
   while (lo &lt;= hi)   {
      mid = (lo + hi) / 2;
      i = wd ? strncmp(arg, tbl[mid].symbol, wd) :
             strcmp(arg, tbl[mid].symbol);
      if (i &lt; 0)
         hi = mid-1;
      else if (i)
         lo = mid + 1;
      else
         return tbl[mid].ident;
   }
   return 0;
}
/* --- search for library function identifier --- */
int SearchLibrary(char *fname)
{
   return SearchSymbols(fname,LibraryFunctions,MAXLIBFUNCTIONS,0);
}
/* --- search for keyword --- */
int FindKeyword(char *keyword)
{
   return SearchSymbols(keyword, Keywords, MAXKEYWORDS, 0);
}
/* --- search for two-character operator --- */
int FindOperator(char *oper)
{
   return SearchSymbols(oper, Operators, MAXOPERATORS, 2);
}
/* --- search for preprocessing directive --- */
int FindPreProcessor(char *preproc)
{
   return SearchSymbols(preproc,PreProcessors,MAXPREPROCESSORS,0);
}
/* --- search for user-declared identifier --- */
int FindSymbol(char *sym)
{
   if (SymbolTable != NULL)
      return SearchSymbols(sym, SymbolTable, SymbolCount, 0);
   return 0;
}
/* --- find identifier given code --- */
char *FindSymbolName(int id)
{
   int i;
   for (i = 0; i &lt; SymbolCount; i++)
      if (SymbolTable[i].ident == id)
         return SymbolTable[i].symbol;
   return NULL;
}
/* --- add identifier to symbol table --- */
int AddSymbol(char *sym)
{
   int symbolid = 0;
   if (SymbolTable != NULL)   {
      symbolid = FindSymbol(sym);
      if (symbolid == 0)   {
         if (SymbolCount &lt; qCfg.MaxSymbolTable)   {
            int i, j;
            int len = strlen(sym)+1;
            char *s = getmem(len);
            strcpy(s, sym);
            for (i = 0; i &lt; SymbolCount; i++)
               if (strcmp(sym, SymbolTable[i].symbol) &lt; 0)
                  break;
            for (j = SymbolCount; j &gt; i; --j)
               SymbolTable[j] = SymbolTable[j-1];
            SymbolTable[i].symbol = s;
            SymbolTable[i].ident = ++SymbolCount;
            symbolid = SymbolCount;
         }
         else
            error(SYMBOLTABLERR);
      }
   }
   return symbolid;
}
/* --- delete the symbol table entries --- */
void DeleteSymbols(void)
{
   int i;
   for (i = 0; i &lt; SymbolCount; i++)
      free(SymbolTable[i].symbol);
}
</pre><HR><P>Copyright &copy; 1994, <I>Dr. Dobb's Journal</I></P></BODY></HTML>
