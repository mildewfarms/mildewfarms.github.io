<HTML>
<META NAME="year" CONTENT="1994">
<HEAD>
<TITLE>SP 94: The Tcl Programming Language</TITLE></HEAD>
<BODY BGCOLOR="#ffffff">
<h1>The Tcl Programming Language<a name="0260_00d9"></h1><P>
<h2><a name="0260_00d7"><a name="0260_0000">A powerful scripting language designed for ease of use</h2><P>
<h3>John K. Ousterhout</h3><P>
<p><i><a name="0260_00d8"><a name="0260_0000">John is creator of the Tcl language, author of Tcl and the Tk Toolkit, and a professor at the University of California at Berkeley. He can be contacted at ouster@allspice.cs.berkeley.edu. This article is excerpted from Tcl and the Tk Toolkit, by John K. Ousterhout. Copyright (C) 1994 by Addison-Wesley Publishing Company. Reprinted by permission of Addison-Wesley.</i></p><hr><P>
Tcl, short for &quot;tool command language&quot; (and pronounced &quot;tickle&quot;), is a simple scripting language for controlling and extending applications. Tcl provides generic programming facilities, such as variables, loops, and procedures, useful for a variety of applications. Furthermore, Tcl is an embeddable command language. Its interpreter is a library of C procedures that can easily be incorporated into applications, and each application can extend the core Tcl features with additional commands for that application.<P>
The core Tcl facilities can be extended with Tk, a toolkit for the X Window System. Tk includes commands for building user interfaces so that you can construct Motif-like UIs by writing Tcl scripts instead of C code. Like Tcl, Tk is implemented as a library of C procedures, so it can be used in many different applications. Individual applications can also extend the base Tk features with new UI widgets and geometry managers written in C.<P>
One benefit of Tcl and Tk is that they lend themselves to rapid development. Many GUI applications can be written entirely as Tcl scripts, using a windowing shell called &quot;wish&quot; that allows you to program at a higher level than you would in C/C++. Compared to toolkits in which you program in C (such as Motif), there is much less code to write and certainly much less to learn.<P>
Another reason Tcl and Tk development is rapid is that Tcl is an interpreted language. When you use a Tcl application, you can generate and execute new scripts on the fly without recompiling or restarting the application. This allows you to test out new ideas and fix bugs rapidly. Interpreted code executes more slowly than compiled C code, but today's workstations are surprisingly fast. For example, you can execute scripts with hundreds of Tcl commands on each movement of the mouse with no perceptible delay. In rare cases where performance becomes an issue, you can reimplement the performance-critical parts of your Tcl scripts in C.<P>
Tcl also makes it easy for applications to have their own powerful scripting languages. To create a new application, you simply implement a few new Tcl commands that provide the basic features of your application. Then you can link your new commands with the Tcl library to produce a full-function scripting language that includes both the commands provided by Tcl (the &quot;Tcl core&quot;) and those that you wrote, as in <a href="19940262.htm">Figure 1</A>(a). For example, an application for reading electronic bulletin boards (BBSs) might contain C code that implements one to query a BBS for new messages and another Tcl command to retrieve a given message. Once these commands exist, Tcl scripts can be written to cycle through the new messages from all the BBSs and display them one at a time, keep a record in disk files of which messages have been read and which haven't, or search one or more BBSs for messages on a particular topic. <P>
Furthermore, Tcl is an excellent glue language. A Tcl application can include many different library packages, each of which provides an interesting set of Tcl commands, as in <a href="19940263.htm">Figure 1</A>(b). Tk is just one example library package; many others exist. Tcl scripts for such applications can include commands from any of the packages.<P>
Tcl scripts can also be used as a communication mechanism to allow different applications to work together. For example, any windowing application based on Tk can send a Tcl script to any other Tk application to be executed there. Among other things, this makes multimedia effects much more accessible: Once audio and video applications have been built with Tk, any Tk application can issue record and play commands to them. Indeed, an audio extension for Tcl called &quot;Ak&quot; provides Tcl commands for file playback, recording, telephone control, and synchronization. In addition, spreadsheets can update themselves from database applications, UI editors can modify the appearance and behavior of live applications as they run, and so on. In fact, Tcl's use of a common, interpreted language for communication between applications is more powerful and flexible than static approaches such as Microsoft's OLE and Sun Microsystems' ToolTalk.<P>
<h3><a name="0260_00da">Getting Started<a name="0260_00da"></h3><P>
To invoke Tcl scripts, you must run a Tcl application. The Tcl system includes a simple Tcl shell application called &quot;tclsh,&quot; on which the examples presented here are based. To run the application, simply type <I>tclsh</I> to your shell and the program will start up in interactive mode, reading Tcl commands from the keyboard and passing them to the Tcl interpreter for evaluation. Entering <I>tclsh expr 2 + 2</I>, for example, prints the result (4) and prompts you for another command. <P>
This simple example illustrates several Tcl features. First, Tcl commands are similar in form to shell commands, each consisting of one or more command words separated by spaces or tabs. This example has four words: <I>expr</I>, 2, +, and 2. The first word of each command, or &quot;name,&quot; selects a C procedure in the application to carry out the command's function. The other words are &quot;arguments&quot; passed to the C procedure. <I>expr</I>, a core command provided by the Tcl library that exists in every Tcl application, concatenates its arguments into a single string and evaluates the string as an arithmetic expression.<P>
Each Tcl command returns a result string. For the <I>expr</I> command, the result is the value of the expression. Results are always returned as strings, so <I>expr</I> converts its numerical result back to a string in order to return it. If a command has no meaningful result, it returns an empty string.<P>
Commands are normally terminated by newlines, so each line that you type to tclsh becomes a separate command. Semicolons also act as command separators, just in case you want to enter multiple commands on a single line. Single commands can also span multiple lines.<P>
The <I>expr</I> command supports an expression syntax similar to that in ANSI C, including the same precedence rules and most of the C operators. <a href="#0260_00e3">Example 1</A> provides a few examples that you could enter into tclsh. Invoking the <I>exit</I> command terminates the application and returns you to your shell.<P>
<h3><a name="0260_00db">Hello World with Tk<a name="0260_00db"></h3><P>
Although Tcl provides a full set of programming features such as variables, loops, and procedures, it is not typically used by itself. It is intended to be used as part of applications that contain their own Tcl commands, in addition to those in the Tcl core. The application-specific extensions provide interesting primitives, and Tcl is used to assemble the primitives into useful functions. It is easier to understand Tcl's facilities if you have seen some application-specific commands to use with Tcl.<P>
One of the most interesting extensions to Tcl is the set of windowing commands provided by the Tk toolkit. Most of the examples in this article use an application called &quot;wish&quot; (short for &quot;windowing shell&quot;) which is similar to tclsh except that it includes the commands defined by Tk that allow you to create GUIs. If Tcl and Tk have been installed on your system, you can invoke wish from your shell; it will display a small empty window on your screen and then read commands from standard input. <a href="#0260_00e4">Example 2</A> is a simple wish script. If you type these two Tcl commands to wish, the window's appearance will change to that shown in <a href="19940264.htm">Figure 2</A>. If you move the pointer over the &quot;Hello, world!&quot; text and click mouse button 1 (usually the left-most button), the window will disappear and wish will exit.<P>
Several things about this example are worth noting. First, the example contains two commands, <I>button</I> and <I>pack</I>, both of which are implemented by Tk. Although these commands do not look like the <I>expr</I> command, they have the same basic structure as all Tcl commands: one or more words, separated by white space. The <I>button</I> command contains six words, and <I>pack</I> two.<P>
The fourth word of the <I>button</I> command is enclosed in double quotes. This allows the word to include white-space characters; without the quotes, &quot;Hello,&quot; and &quot;world!&quot; would be separate words. The double quotes are not part of the word itself; they are removed by the Tcl interpreter before the command is executed. <P>
The word structure doesn't matter for the <I>expr</I> command since <I>expr</I> concatenates all its arguments. For <I>button</I> and <I>pack</I> (and most other Tcl commands), however, the word structure is important. The <I>button</I> command expects its first argument to be the name of a new window to create. Subsequent arguments must come in pairs, where the first argument of each pair is the name of a configuration option and the second is a value for that option. Thus if the double quotes were omitted, the value of the <I>--text</I> option would be &quot;Hello,&quot; and &quot;world!&quot; would be treated as the name of a separate configuration option. Since no option is defined with the name &quot;world!&quot;, the command would return an error.<P>
The basic building block for a GUI in Tk is a &quot;widget&quot;--a window with a particular appearance and behavior (the terms &quot;widget&quot; and &quot;window&quot; are used synonymously in Tk). Widgets are divided into classes such as <I>buttons</I>, <I>menus</I>, and <I>scroll bars</I>. All the widgets in the same class have the same general appearance and behavior. For example, all <I>button</I> widgets display a text string or bitmap and execute a Tcl command when invoked with the mouse.<P>
Widgets are organized hierarchically in Tk, with names that reflect their positions in the hierarchy. The &quot;main widget,&quot; which appears on the screen when you start wish, has the name &quot;.&quot;. The name <I>.b</I>, for instance, refers to a child <I>b</I> of the main widget. Widget names in Tk are like filenames in UNIX except that they use a period as a separator character instead of a slash. Thus, <I>.a.b.c</I> refers to a widget that is a child of widget <I>.a.b</I>, which is a child of <I>.a</I>, which is a child of the main widget.<P>
Tk provides one &quot;class command&quot; for each class of widgets, which you invoke to create widgets of that class. For example, the <I>button</I> command creates button widgets. All of the class commands have the same form: The first argument is the name of a new widget to create, and additional arguments specify configuration options. Different widget classes support different sets of options. Widgets typically have many options (about 20 different options are defined for buttons, for example), and default values are provided for the options that you don't specify. When a class command like <I>button</I> is invoked, it creates a new widget with the given name and configures it as specified by the options.<P>
The command in <a href="#0260_00e4">Example 2</A> specifies two options: --<I>text</I>, a string to display in the button, and --<I>command</I>, a Tcl script to execute when the user invokes the button. In <a href="#0260_00e4">Example 2</A>, the --<I>command</I> option is <I>exit</I>. Other button options are listed in <a href="#0260_00e5">Table 1</A>.<P>
The <I>pack</I> command causes the button widget to appear on the screen. Creating a widget does not automatically cause it to be displayed. Independent entities called &quot;geometry managers&quot; are responsible for computing the size and location of widgets and making them appear on the screen. The <I>pack</I> command in <a href="#0260_00e4">Example 2</A> asks a geometry manager called the &quot;packer&quot; to manage <I>.b</I>. The command asks that <I>.b</I> fill the entire area of its parent window; if the parent has more space than needed by its child, the parent is shrunk so that it is just large enough to hold the child. Thus when you type the <I>pack</I> command, the main window shrinks from its original size to the size in which it appears in <a href="19940265.htm">Figure 2</A>.<P>
<h3><a name="0260_00dc">Script Files<a name="0260_00dc"></h3><P>
You can also place commands into script files and invoke the script files just like shell scripts. To do this for <a href="#0260_00e4">Example 2</A>, place the text in <a href="#0260_00e6">Example 3</A> in a file named &quot;hello.&quot; This script is the same as <a href="#0260_00e4">Example 2</A> except for the first line. As far as wish is concerned, this line is a comment, but if you make the file executable (type <I>chmod +x hello</I> to your shell, for example) you can invoke the file directly by typing <I>hello</I> to your shell. The system will then invoke wish, passing it the file as a script to interpret; wish will display the same window and wait for you to interact with it. In this case, you will not be able to type commands interactively to wish; all you can do is click on the button. (Note: This script will work only if wish is installed in /usr/local/bin. If wish has been installed elsewhere, you will need to change the first line to reflect its location on your system. Some systems will misbehave in confusing ways if the first line of the script file is longer than 32 characters, so beware if the full pathname of the wish binary is longer than 27 characters.)<P>
In practice, Tk application users rarely type Tcl commands; they interact with the applications using the mouse and keyboard in ways normal for graphical applications. Tcl works behind the scenes. The hello script behaves just the same as an application coded in C with a toolkit such as Motif and compiled into a binary executable file.<P>
During debugging, however, it is common for application developers to type Tcl commands interactively. For example, you could test the hello script by starting wish interactively. Type <I>wish</I> to your shell instead of <I>hello</I>. Then enter the Tcl command <I>source hello</I> where <I>source</I> is a Tcl command that takes a filename as an argument. It reads the file and evaluates it as a Tcl script. This generates the same UI as if you had invoked <I>hello</I> directly from your shell, but you can now type Tcl commands interactively. For example, you could edit the script file to change the --<I>command</I> option to <a href="#0260_00e7">Example 4(a)</A>, then interactively type the commands in <a href="#0260_00e7">Example 4(b)</A> to wish without restarting the program. The first command in <a href="#0260_00e7">Example 4(b)</A> deletes the existing button, and the second recreates the button with the new --<I>command</I> option. When you click on the button, the <I>puts</I> command prints a message on standard output before wish exits.<P>
<h3><a name="0260_00dd">Variables and Substitutions<a name="0260_00dd"></h3><P>
Tcl allows you to store values in variables and use those values in commands. For instance, you could enter the script in <a href="#0260_00e8">Example 5</A> into either tclsh or wish. <a href="#0260_00e8">Example 5(a)</A> assigns the value <I>44</I> to variable <I>a</I> and returns the variable's value. In <a href="#0260_00e8">Example 5(b)</A>, the <I>$</I> causes Tcl to perform &quot;variable substitution,&quot; replacing the dollar sign and the variable name following it with the value of the variable, so that the actual argument received by <I>expr</I> is <I>44*4</I>. Variables need not be declared in Tcl; they are created automatically when set. Variable values are stored as strings, and arbitrary string values of any length are allowed. Of course, in this example an error will occur in <I>expr</I> if the value of <I>a</I> doesn't make sense as an integer or real number (try other values and see what happens).<P>
Tcl also provides command substitution, which allows you to use the result of one command in an argument to another. Square brackets invoke command substitution: Everything inside the brackets is evaluated as a separate Tcl script, the result of which is substituted into the word in place of the bracketed command. In <a href="#0260_00e8">Example 5(c)</A>, the second argument of the second <I>set</I> command will be <I>176</I>.<P>
The final form of substitution in Tcl is backslash substitution, which allows you to use various special characters in a command, as in <a href="#0260_00e8">Example 5(d)</A>. The first command sets variable <I>a</I> to the string <I>$a</I> (the characters <I>\$</I> are replaced with a dollar sign and no variable substitution occurs). The second command sets variable <I>newline</I> to hold a string consisting of the newline character (the characters <I>\n</I> are replaced with a newline character).<P>
<h3><a name="0260_00de">Control Structures<a name="0260_00de"></h3><P>
<a href="#0260_00e9">Example 6</A> uses variables and substitutions along with some simple control structures to create a Tcl procedure called &quot;power,&quot; which raises a base to an integer power. If you enter <a href="#0260_00e9">Example 6(a)</A> into wish or tclsh, or if you enter them into a file and then source the file, a new command <I>power</I> will become available. The command takes two arguments, a number and an integer power, and its result is the number raised to the power; see <a href="#0260_00e9">Example 6(b)</A>. This example uses Tcl braces which are like double quotes in that they can be placed around a word that contains embedded spaces. However, braces are different from double quotes in two respects. First, braces nest. The last word of the <I>proc</I> command starts after the open brace on the first line and contains everything up to the close brace on the last line. The Tcl interpreter removes the outer braces and passes everything between them, including several nested pairs of braces, to <I>proc</I> as an argument. The second difference between braces and double quotes is that substitutions cannot occur inside braces. All of the characters between the braces are passed verbatim to <I>proc</I> without any special processing.<P>
The <I>proc</I> command takes three arguments: the name of a procedure, a list of argument names separated by white space, and the body of the procedure, which is a Tcl script. <I>proc</I> enters the procedure name into the Tcl interpreter as a new command. Whenever the command is invoked, the body of the procedure is evaluated. While the procedure body is executing, it can access its arguments as variables: <I>base</I> will hold the first argument to <I>power</I> and <I>p</I> will hold the second.<P>
The body of the <I>power</I> procedure contains the Tcl commands <I>set</I>, <I>while</I>, and <I>return</I>. The <I>while</I> command does most of the procedure's work. It takes two arguments: an expression <I>$p&gt;0</I> and a body, which is another Tcl script. The <I>while</I> command evaluates its expression argument; if the result is nonzero, it evaluates the body as a Tcl script. It repeats this process until eventually the expression evaluates to zero. In <a href="#0260_00e9">Example 6</A>, the body of the <I>while</I> command multiplies the result value by <I>base</I> and then decrements <I>p</I>. When <I>p</I> reaches zero, the result contains the desired power of <I>base</I>.<P>
The <I>return</I> command causes the procedure to exit with the value of variable <I>result</I> as the procedure's result. If it is omitted, the return value of the procedure will be the result of the last command in the procedure's body. In the case of <I>power</I>, this would be the result of <I>while</I>, which is always an empty string.<P>
The use of braces in this example is crucial. The single most difficult issue in writing Tcl scripts is managing substitutions: making them happen when you want them and preventing them when you don't. The body of the procedure must be enclosed in braces because you don't want variable and command substitutions to occur at the time the body is passed to <I>proc</I> as an argument; you want the substitutions to occur later, when the body is evaluated as a Tcl script. The body of the <I>while</I> command is enclosed in braces for the same reason: You want the substitutions to be performed each time the body is evaluated, rather than once, while parsing the <I>while</I> command. Braces are also needed in the <I>{$p&gt;0}</I> argument to <I>while</I>. Without them, the value of variable <I>p</I> would be substituted when parsing the <I>while</I> command; the expression would have a constant value and <I>while</I> would loop forever. <P>
Although Tcl doesn't require it, for readability I'm using a syntax where the open brace for an argument that is a Tcl script appears at the end of one line, the script follows on successive lines indented, and the close brace is on a line by itself after the script. Arguments that are scripts are subject to the same syntax rules as any other arguments; in fact, the Tcl interpreter doesn't even know that an argument is a script at the time it parses it. One consequence is that the open brace must be on the same line as the preceding portion of the command. If the open brace is moved to a line by itself, the newline before the open brace will terminate the command.<P>
The variables in a procedure are normally local to that procedure and will not be visible outside it. In <a href="#0260_00e9">Example 6</A>, the local variables include the arguments <I>base</I> and <I>p</I> as well as the variable <I>result</I>. A fresh set of local variables is created for each call to a procedure (arguments are passed by copying their values), and when a procedure returns, its local variables are deleted. Variables named outside any procedure are &quot;global&quot;--they last forever unless explicitly deleted. <P>
<h3><a name="0260_00df">The Tcl Language<a name="0260_00df"></h3><P>
As a programming language, Tcl is defined quite differently than most other languages. In most languages, a grammar defines the entire language. In <a href="#0260_00ea">Example 7(a)</A>, for instance, the grammar for C defines the structure of this C statement in terms of the reserved word <I>while</I>, an expression, and a substatement to execute repeatedly until the expression evaluates to 0. The C grammar defines both the overall structure of the <I>while</I> statement and the internal structure of its expression and substatement.<P>
In Tcl, no fixed grammar explains the entire language. Instead, it is defined by an interpreter that parses single Tcl commands, plus a collection of procedures that execute them. The interpreter and its substitution rules are fixed, but new commands can be defined at any time and existing commands can be replaced. Features such as control flow, procedures, and expressions are implemented as commands; they are not understood directly by the Tcl interpreter. For example, the Tcl command in <a href="#0260_00ea">Example 7(b)</A> is equivalent to the C <I>while</I> loop in <a href="#0260_00ea">Example 7(a)</A>. <P>
When the command in <a href="#0260_00ea">Example 7(b)</A> is evaluated, the Tcl interpreter knows only that it has three words, the first of which is a command name. The Tcl interpreter has no idea that the first argument to <I>while</I> is an expression and the second is a Tcl script. Once the command has been parsed, the Tcl interpreter passes the words of the command to <I>while</I>, which treats its first argument as an expression and the second as a Tcl script. If the expression evaluates to nonzero, then <I>while</I> passes its second argument back to the Tcl interpreter for evaluation. At this point, the interpreter treats the contents of the argument as a script (that is, it performs command and variable substitutions and invokes the <I>expr</I> and <I>set</I> commands).<P>
As far as the Tcl interpreter is concerned, the <I>set</I> command in <a href="#0260_00ea">Example 7(c)</A> is identical to <I>while</I> except that it has a different command name. Therefore, the interpreter handles the two commands identically, except that it invokes a different procedure to execute <I>set</I>. The <I>set</I> command treats its first argument as a variable name and its second as a new value for that variable, so it will set a variable with the name <I>$p&gt;0</I>.<P>
The most common mistake made by new Tcl users is trying to understand Tcl scripts in terms of a grammar; this leads them to expect much more sophisticated behavior from the interpreter than actually exists. For example, a C programmer using Tcl for the first time might think that the first pair of braces in the <I>while</I> command serves a different purpose than the second pair. In reality, there is no difference. In each case, the Tcl interpreter passes the characters between the braces to the command without performing any substitutions.<P>
Thus the entire Tcl &quot;language&quot; consists of about a half-dozen simple rules for parsing arguments and performing substitutions. At the same time, Tcl is powerful enough to allow a rich set of structures such as loops and procedures to be built as ordinary commands. Applications can extend Tcl not just with new commands but also with new control structures.<P>
<h3><a name="0260_00e0">Event Bindings<a name="0260_00e0"></h3><P>
A binding causes a certain Tcl script to be evaluated whenever a particular event occurs in a particular window. The --<I>command</I> option for buttons is an example of a simple binding implemented by a particular widget class. Tk also includes a more general mechanism that can be used to extend the behavior of widgets in nearly arbitrary ways.<P>
When copied into a file and invoked from your shell, the script in <a href="#0260_00eb">Example 8</A> will produce a screen display like that in <a href="19940266.htm">Figure 3</A>. The display has two entry widgets in which you can click with the mouse and type numbers. If you press the Return key in either of the entries, the result will appear on the right side of the window. You can compute different results by modifying either the base or the power and then pressing Return again.<P>
This application consists of five widgets: two entries and three labels. Entries are widgets that display one-line text strings that you can edit interactively. The two entries, <I>.base</I> and <I>.power</I> are used for entering the numbers. Each entry is configured with a --<I>width</I> of 6 (large enough to display about six digits) and a <I>--relief</I> of &quot;sunken&quot; (which gives the entry a depressed appearance). The <I>--textvariable</I> option for each entry specifies the name of a global variable to hold the entry's text; any changes you make in the entry will be reflected in the variable and vice versa.<P>
Two of the labels, <I>.label1</I> and <I>.label2</I>, hold decorative text; the third, <I>.result</I>, holds the result of the power computation. The <I>--textvariable</I>' option for <I>.result</I> causes it to display whatever string is in the global variable <I>result</I> and to update itself whenever the variable changes. In contrast, <I>.label1</I> and <I>.label2</I> display constant strings.<P>
The <I>pack</I> command arranges the five widgets in a row from left to right. The command occupies two lines in the script; the backslash at the end of the first line is a line-continuation character, which causes the newline to be treated as a space. The --<I>side</I> option means that each widget is placed at the left side of the remaining space in the main widget: first <I>.base</I> is placed at the left edge of the main widget, then <I>.label1</I> is placed at the left side of the space not occupied by <I>.base</I>, and so on. The --<I>padx</I> and --<I>pady</I> options make the display more attractive by arranging for one millimeter of extra space on the left and right sides of each widget, plus two millimeters of extra space above and below it. The <I>m</I> suffix specifies millimeters; you could also use <I>c</I> for centimeters, <I>i</I> for inches, <I>p</I> for points, or no suffix for pixels.<P>
The <I>bind</I> commands connect the UI to the <I>power</I> procedure. Each <I>bind</I> command has three arguments: the name of a widget, an event specification, and a Tcl script to invoke when the given event occurs in the given widget. <I>&lt;Return&gt;</I> specifies an event consisting of the user pressing the Return key on the keyboard. Other useful event specifiers are listed in <a href="#0260_00ed">Table 2</A>.<P>
The scripts for the bindings invoke <I>power</I>, passing it the values in the two entries and storing the result in the <I>result</I> variable so that it will be displayed in the <I>.result</I> widget. These bindings extend the generic, built-in behavior of the entries (editing text strings) with application-specific behavior (computing a value based on two entries and displaying that value in a third widget).<P>
The script for a binding has access to several pieces of information about the event, such as the location of the pointer when the event occurred. For example, if you start up wish interactively, type the command <I>bind.&lt;Any-Motion&gt; {puts &quot;pointer at %x,%y&quot;}'&gt;</I>, and move the pointer over the window, each time the pointer moves, a message will be printed on standard output giving its new location. When the pointer motion event occurs, Tk scans the script for <I>%</I> sequences and replaces them with information about the event before passing the script to Tcl for evaluation. <I>%x</I> is replaced with the pointer's <I>x-</I>coordinate, and <I>%y</I> is replaced with the pointer's <I>y-</I>coordinate.<P>
<h3><a name="0260_00e1">Subprocesses<a name="0260_00e1"></h3><P>
Normally, Tcl executes each command by invoking a C procedure in the application to carry out its function. This is different from a shell program such as sh, where each command is executed in a separate subprocess. However, Tcl also allows you to create subprocesses using the <I>exec</I> command; see <a href="#0260_00ec">Example 9</A>.<P>
The <I>exec</I> command treats its arguments much like the words of a shell command line. In <a href="#0260_00ec">Example 9(a)</A>, <I>exec</I> creates a new process to run the grep program and passes it <I>#include</I> and tk.h as arguments, just as if you had typed <I>grep #include tk.h</I> to your shell. The grep program searches file tk.h for lines that contain the string <I>#include</I> and prints those lines on its standard output. However, <I>exec</I> arranges for standard output from the subprocess to be piped back to Tcl. <I>exec</I> waits for the process to exit, then returns all of the standard output as its result. With this mechanism you can execute subprocesses and use their output in Tcl scripts. <I>exec</I> also supports input and output redirection using standard shell notation such as &lt;, &lt;&lt;, and &gt;, pipelines with |, and background processes with &amp;.<P>
<a href="#0260_00ec">Example 9(b)</A> creates a simple UI for saving and reinvoking commonly used shell commands. If you type the script into a file named &quot;redo&quot; and invoke it, the script initially creates an interface with a single entry widget. You can type a shell command such as <I>ls</I> into the entry, as shown in <a href="19940267.htm">Figure 4</A>(a). If you press Return, the command gets executed as if you had typed it to the shell from which you invoked redo; the <I>&lt;@</I> and <I>&gt;@</I> arguments to <I>exec</I> cause the standard input and output files for the command to be the same as those for wish. Furthermore, the script creates a new button widget that displays the command, and you can reinvoke the command later by clicking on the button; see <a href="19940268.htm">Figure 4</A>(b). As you type more commands, more buttons appear, up to a limit of five remembered commands, as in <a href="19940269.htm">Figure 4</A>(c). <P>
The most interesting part of the redo script is in the <I>bind</I> command. The binding for <I>&lt;Return&gt;</I> must execute the command, which is stored in the <I>cmd</I> variable, and create a new button widget. First it creates the widget. The button widgets have names like <I>.b1</I>, <I>.b2</I>, and so on, where the number comes from the variable <I>id</I> which starts at 0 and increments before each new button is created. The notation <I>.b$id</I> generates a widget name by concatenating <I>.b</I> with the value of <I>id</I>. Before creating a new widget, the script checks to see if there are already five saved commands; if so, the oldest existing button is deleted. The notation <I>.b[expr $id </I>--<I>5]</I> produces the name of the oldest button by subtracting five from the number of the new button and concatenating it with <I>.b</I>. The --<I>command</I> option for the new button invokes <I>exec</I> and redirects standard input and output for the subprocess(es) to wish's standard input and standard output, which are the same as those of the shell from which wish was invoked. This causes output from the subprocesses to appear in the shell's window instead of being returned to wish.<P>
The command <I>pack .b$id </I>--<I>fill x</I> makes the new button appear at the bottom of the window. The option<I> </I>--<I>fill x</I> improves the appearance by stretching the button horizontally so that it fills the width of the window even if the text doesn't really need that much space. <P>
The last two commands of the binding script are called &quot;widget commands.&quot; Whenever a new widget is created, a new Tcl command with the same name is created, and you can invoke this command to communicate with the widget. The first argument to a widget command selects one of several operations, and additional arguments are used as parameters for that operation. In the redo script, the first widget command causes the button widget to invoke its --<I>command</I> option, just as if you had clicked the mouse button on it. The second widget command clears the entry widget in preparation for a new command to be typed.<P>
Each class of widget supports a different set of operations in its widget commands, but many of the operations are similar from widget to widget. For example, every widget class supports a <I>configure widget</I> command that can be used to modify any of the configuration options for the widget. If you run the redo script interactively, you can type in the command in <a href="#0260_00ee">Example 10(a)</A> to change the background of the entry widget to yellow or the command in <a href="#0260_00ee">Example 10(b)</A> to change the color of the text in button <I>.b1</I> to brown and then cause the button to flash.<P>
One of the most important things about Tcl and Tk is that they make every aspect of an application accessible and modifiable at run time. For example, the redo script modifies its own interface on the fly. In addition, Tk provides commands that you can use to query the structure of the widget hierarchy, and you can use <I>configure widget</I> commands to query and modify the configuration options of individual widgets.<P>
<h3><a name="0260_00e2">Conclusion<a name="0260_00e2"></h3><P>
There's much more to Tcl and Tk than I've presented here. Also available, for instance, is Extended Tcl (TclX), a library package that augments the built-in Tcl commands by providing access to POSIX functions and system calls, file scanning similar to awk, keyed lists, online help, and so on. Tcl Distributed Programming (Tcl-DP) is a collection of Tcl commands that simplify the development of distributed programs, while XF is an interactive interface builder that was actually written in Tcl. For additional information on these and other Tcl, refer to my book, <I>Tcl and the Tk Toolkit</I>.<P>
<h2>Additional Tcl and Tk Features</h2><P>
Tcl and Tk contain many other facilities not discussed in this article, including:<P>
<B>Arrays and lists:</B> arrays, for efficiently storing key value pairs; and lists, for managing aggregates of data.<P>
<B>Control structures</B> for controlling the flow of execution, such as <I>eval</I>, <I>for</I>, <I>foreach</I>, and <I>switch</I>.<P>
<B>String manipulation:</B> measuring their length, regular-expression pattern matching and substitution, and format conversion.<P>
<B>File access:</B> You can read and write files from Tcl scripts and retrieve directory information and file attributes, such as length and creation time.<P>
<B>Widgets:</B> menus, scroll bars, a drawing widget called a &quot;canvas,&quot; and a text widget for achieving hypertext effects.<P>
<B>Access to X facilities:</B> access to all major facilities in the X Window System, such as commands for communicating with the window manager, retrieving the selection, and managing the input focus.<P>
<B>Interapplication communication:</B> a <I>send</I> command can be used to issue arbitrary Tcl/Tk scripts to other Tk-based applications.<P>
<B>C interfaces: </B>C-library procedures to define new Tcl commands in C and a library for creating new widget classes and geometry managers in C.<P>
--J.K.O.<P>
<h4><a name="0260_00e3"><B>Example 1:</B> (a) Using the bitwise left-shift operator &lt;&lt;; (b) expressions that contain real values as well as integer values; (c) use of relational operators &gt; and &lt;= and the logical OR operator ||. As in C, Boolean results are represented numerically with 1 for true and 0 for false.<a name="0260_00e3"></h4><P>
<pre>(a) Enter:           expr 3 &lt;&lt; 2
    Returned value:  12

(b) Enter:           expr 14.1*6
    Returned value:  84.6

(c) Enter:           expr (3 &gt; 4) ||
                                (6 &lt;= 7)
    Returned value:  1
</pre><P>
<h4><a name="0260_00e4"><B>Example 2:</B> Simple wish script.<a name="0260_00e4"></h4><P>
<pre>button .b -text &quot;Hello, world!&quot; -
                     command exit
pack .b</pre><P>
<a href="1994026a.htm">Figure 1</A>  Simple TCL application consisting of the Tcl interpreter plus a few application-specific commands; (b) complex application which includes the commands defined by Tk plus additional commands defined by other packages.
<a href="1994026b.htm">Figure 2</A>  Tcl &quot;hello world&quot; program.
<h4><a name="0260_00e5"><B>Table 1:</B> Typical button options.<a name="0260_00e5"></h4><P>
<PRE>
 Option         Description

 --background   Background color for the button, such as blue.
 --foreground   Color of the text in the button, such as black.
 --font         Name of the font to use for the button, such as
                 <I>*--times--medium--r--normal*120*</I> for a 12-point 
                 Times Roman font.
</pre><P>
<h4><a name="0260_00e6"><B>Example 3:</B> Typical script file.<a name="0260_00e6"></h4><P>
<pre>#!/usr/local/bin/wish -f
button .b -text &quot;Hello, world!&quot; -
                      command exit
pack .b
</pre><P>
<h4><a name="0260_00e7"><B>Example 4:</B> Interactively entering data into a Tcl script file.<a name="0260_00e7"></h4><P>
<pre>(a)  -command &quot;puts Good-bye!; exit&quot;

(b)  destroy .b
     source hello</pre><P>
<h4><a name="0260_00e8"><B>Example 5:</B> Tcl variables and substitution.<a name="0260_00e8"></h4><P>
<pre>(a) Enter:           set a 44
    Returned value:  44

(b) Enter:           expr $a*4
    Returned value:  176

(c) Enter:          set a 44
                    set b [expr $a*4]
    Returned value:  176

(d) set x \$a
    set newline \n
</pre><P>
<h4><a name="0260_00e9"><B>Example 6:</B> Tcl control structures.<a name="0260_00e9"></h4><P>
<pre>(a) proc power {base p} {
       set result 1
       while {$p0} {
          set result [expr $result*$base]
          set p [expr $p-1]
        }
    return $result

(b) Enter:             power 2 6
    Returned value:   64
 
    Enter:            power 1.15 5
    Returned value:  2.01136
</pre><P>
<h4><a name="0260_00ea"><B>Example 7:</B> (a) Typical C statement; (b) Tcl equivalent; (c) using the Tcl set command.<a name="0260_00ea"></h4><P>
<pre>(a) while (p&gt;0) {
       result *= base;
        p -= 1;
    }

(b) while {$p&gt;0} {
       set result [expr $result*$base]
       set p [expr $p-1]
    }

(c) set {$p&gt;0} {
        set result [expr $result*$base]
        set p [expr $p-1]
    }
</pre><P>
<h4><a name="0260_00eb"><B>Example 8:</B> A Tcl script.<a name="0260_00eb"></h4><P>
<pre>#!/usr/local/bin/wish -f
proc power {base p} {
   set result 1
   while {$p&gt;0} {
          set result [expr $result*$base]
          set p [expr $p-1]
   }
   return $result
}
entry .base -width 6 -relief sunken -textvariable base
label .label1 -text &quot;to the power&quot;
entry .power -width 6 -relief sunken -textvariable power
label .label2 -text &quot;is&quot;
label .result -textvariable result
pack .base .label1 .power .label2 .result -side left \
   -padx 1m -pady 2m
bind .base &lt;Return&gt; {set result [power $base $power]}
bind .power &lt;Return&gt; {set result [power $base $power]}</pre><P>
<a href="1994026c.htm">Figure 3</A>  A GUI that computes powers of a base.
<h4><a name="0260_00ec"><B>Example 9:</B> Tcl lets you create subprocesses using the exec command.<a name="0260_00ec"></h4><P>
<pre>(a)
 Enter:            exec grep #include tk.h
 Returned value:   #include &lt;tcl.h&gt;
                   #include &lt;X11/Xlib.h&gt;
                   #include &lt;stddef.h&gt;
(b)
#!/usr/local/bin/wish -f
set id 0
entry .entry -width 30 -relief sunken -textvariable cmd
pack .entry -padx 1m -pady 1m
bind .entry &lt;Return&gt; {
   set id [expr $id + 1]
   if {$id &gt; 5} {
        destroy .b[expr $id - 5]
   }
   button .b$id -command &quot;exec &lt;@stdin &gt;@stdout $cmd&quot; \
        -text $cmd
   pack .b$id -fill x
   .b$id invoke
   .entry delete 0 end
}
</pre><P>
<h4><a name="0260_00ed"><B>Table 2:</B> Typical event specifiers.<a name="0260_00ed"></h4><P>

<PRE>
    Event Specifier    Description

    &lt;Button1&gt;          Mouse button 1 is pressed.
    &lt;1&gt;                Shorthand for &lt;Button1&gt;.
    &lt;ButtonRelease1&gt;   Mouse button 1 is released.
    &lt;Double-Button1&gt;   Double-click on mouse button 1.
    &lt;Keya&gt;             The &quot;a&quot; key is pressed.
    &lt;Motion&gt;           Pointer motion with no buttons or modifier keys
                        pressed.
    &lt;B1-Motion&gt;        Point motion with button 1 pressed.
    &lt;Any-Motion&gt;       Pointer motion with any (or no) button or modifier
                        keys pressed.
</pre><P>
<a href="1994026d.htm">Figure 4</A>  The redo application.
<h4><a name="0260_00ee"><B>Example 10:</B> (a) Changing the background of the entry widget to yellow; (b) changing the color of the text in button to brown, then causing it to flash.<a name="0260_00ee"></h4><P>
<pre>(a) .entry configure -background yellow

(b) .b1 configure -foreground brown
    .b1 flash&gt;
</pre><P>
<P>
<HR><P>Copyright &copy; 1994, <I>Dr. Dobb's Journal</I></P></BODY></HTML>
