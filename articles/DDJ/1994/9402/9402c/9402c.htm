<HTML>
<META NAME="year" CONTENT="1994">
<HEAD>
<TITLE>FEB94: Computer-Aided Software Testing</TITLE></HEAD>
<BODY BGCOLOR="#ffffff">
<h1>Computer-Aided Software Testing<a name="0082_0003"></h1><P>
<h2><a name="0082_0001"><a name="0082_0000">Simulating user interaction via interclient communication</h2><P>
<h3>Birger Baksaas</h3><P>
<p><i><a name="0082_0002"><a name="0082_0000">Birger is a software consultant based in Tnsberg, Norway. He can be reached by phone at +47 94 26 27 52 or +47 33 31 97 64 or by fax at +47 22 55 33 77.</i></p><hr><P>
According to the Quality Assurance Institute, as much as 80 percent of all software is tested manually. Generally, this is expensive, boring, and inefficient. Consequently, testing is usually kept to a minimum and often squeezed in at the end of the development process. Yet, to be competitive, all parts of software products must be thoroughly tested and verified. Furthermore, quality-assurance programs are necessary to meet emerging standards like the ISO 9000-3. (For more on this subject, see the accompanying text box entitled &quot;ISO 9000-3 and Software Quality Assurance.&quot;)<P>
Test drivers, most often written to test individual routines, can be applied to the complete application. Especially with modular designs (such as with X Windows), it's possible to write a computer-aided software-testing system that simulates user interactions. The system can perform a sequence of operations predefined in script files.<P>
The advantages of even a simple automatic test system are obvious: Long-lasting testing is enabled by automatically repeating the script, control of memory consumption and other errors (which appear after long and heavy use) is made easier, and regression testing is facilitated by rerunning the scripts.<P>
<h3><a name="0082_0004">The X Windows Approach<a name="0082_0004"></h3><P>
In X Windows, the X server is software which manages the keyboard, screen, and mouse. When the user presses a button or key, the X server sends events to the right window of the client (application). The server is responsible for managing the hierarchy of overlapping windows on the screen and gives notice about changes to the client's windows via events. The events are true messages sent over an asynchronous communication channel.<P>
The test system I'll describe here simulates user interaction by producing events and sending them to the applications. The applications' event-dispatching mechanism doesn't distinguish between events generated by the server and those sent by another client; it reacts similarly to both. Most of the code is placed in the test driver, a separate process that sends events to all applications initialized for the test system, based on button or key commands from a script file.<P>
<a href="#0082_0008">Example 1</A> shows the format of a typical script file. The <I>process_name</I> token is the name of the application program. The <I>widget_name</I> is the name of the widget that will eventually receive and act on the events. The input file is parsed using <I>strtok</I>. (The process is straightforward and is therefore not detailed in this article.) A test script for opening a file is shown in <a href="#0082_0009">Example 2</A>.<P>
<h3><a name="0082_0005">The Application<a name="0082_0005"></h3><P>
External test drivers keep the extra test code linked into the applications to a minimum. The production system can then be released with that code still in place exactly as it was tested.<P>
Some test-related code is needed in the application because the test driver doesn't know the IDs or internal addresses of all the application's widgets and gadgets. The test driver sends the events to one known widget in each application; code associated with that widget reroutes all test events to the individual widgets within the same process.<P>
First, let's look at initialization. During this process, the test driver is able to pick up the IDs of the application's main widgets via two interclient communication facilities: properties and atoms.<P>
The main widgets of each application (in Motif, the <I>XmMainWindow</I>) receive all the events from the test driver. The window IDs of these <I>MainWindow</I>s are stored as properties--data maintained by the X server and available to all other processes running on the display that know the properties' names.<P>
The window IDs of the <I>MainWindow</I>s are obtained by calling <I>XtWindow</I> with a widget structure as input. To identify properties, X uses unique resource IDs, called &quot;atoms&quot; which are created by the Xlib function <I>XInternAtom</I>. The input to <I>XInternAtom</I> is a string (in this case the name of the receiving application) taken directly from the test scripts. The routine <I>XChangeProperty</I> creates the properties, which are also associated with windows. We use the root window because the data is shared by multiple windows and processes; see <a href="#0082_000a">Listing One</A> (page 78). <a href="#0082_000c">Listing Two</A> (page 78) is the general routine for sending an event from the test process to the applications.<P>
In each application, a table is created to keep track of all of its widgets. In this system, this array is called the <I>WidgetTable</I>. Symbolic widget names are <I>#define</I>d (<a href="#0082_0012">Listing Five</A>, page 80) and used as indexes into <I>WidgetTable</I>. When the widgets are created, the returned addresses are put into the array. Apart from being necessary for this test system, <I>WidgetTable </I>simplifies all later operations on widgets and gadgets and also follows the example set by the demo programs shipped along with Motif.<P>
<h3><a name="0082_0006">The Test Driver<a name="0082_0006"></h3><P>
The test driver declares and sends <I>ClientMessage</I> events to the <I>MainWindow</I> widget of the application processes. <I>ClientMessage</I> events carry a data area which is a union structure of 20 bytes, 10 shorts, or 5 long values. By selecting one of these data types, the events can be used to send an array between clients on the display. In this case, we use them to give information to the applications about the commands in the test script.<P>
The test driver has to translate a widget name found in the test script to the number used as an index into the <I>WidgetTable</I> of the relevant application. This is done most easily by scanning a table, as shown in Listings Six and Seven (page 80). The test driver puts the widget index into one of the locations of the <I>ClientMessage</I> event's data field. The type of operation is put into the next data-field location, and in case of key events, the keycode is put into the third.<P>
Then the test driver sends the <I>XClientMessage</I> events to the application via the <I>XSendEvent</I> function call to the window ID (found as a property in the X server; see <a href="#0082_000e">Listing Three</A>, page 78).<P>
To enable a <I>MainWidget</I> to receive events, <I>XtAddEventHandler</I> must be called for it. <I>ClientMessage</I> events should not be specifically selected by <I>XSelectInput</I>; they are always received by the window they are sent to.<P>
When the <I>MainWidget</I> receives a <I>ClientMessage</I>, the event handler uses the destination widget's index placed in the data field to look up the widget structure in the <I>WidgetTable</I>. The receiving-window ID is obtained by calling <I>XtWindow</I> on this widget structure. The desired event type (<I>XButtonEvent</I>, for example) is declared, initialized, and passed to the intended window by <I>XSendEvent</I> and is therefore handled by Xlib's ordinary event-dispatch mechanism. The receiving widgets react by calling their callback routines as if the events were coming from the server; see <a href="#0082_0010">Listing Four</A>, page 78. The application is also able to process events sent by the X server. Manual user interaction is therefore possible, whether automatic tests are running or not.<P>
This automatic test method gives a true simulation of user action because the exact same code is executed in the application in both situations. A system like this won't replace manual test methods, but it can certainly improve their performance.<P>
<a name="0082_0007">ISO 9000-3 and Software Quality Assurance<a name="0082_0007"><P>
ISO 9000 was established to facilitate the international exchange of goods and services. ISO 9000-3 (officially titled &quot;Guidelines for the Application of ISO 9001 to the Development, Supply, and Maintenance of Software&quot;) is a subset of the original standard established to set international guidelines for software quality assurance. Although ISO 9000-3 addresses several issues, standardized software testing and validation procedures are central to the proposal. It also covers related areas, including internal audits, purchasing specifications, training, and the like.<P>
Generally speaking, ISO 9000-3 describes uniform software-development methods that meet client requirements, as defined by a specification. To be ISO 9000-3 compliant, the development process must adhere to a standard set of procedures by documenting the use of a formal life-cycle model governing the design, development, and maintenance processes. These formal procedures are referred to in terms of the development <I>framework</I> (in-house quality-assurance programs), <I>life-cycle activities</I> (the overall software-development process), and <I>supporting activities</I> (those necessary to qualify, conform, and confirm that the software product was developed properly). Conformance to ISO 9000 is certified by third-party auditors, and certification is valid for three years.<P>
If you're interested in implementing ISO 9000 guidelines, a video course entitled, &quot;Understanding and Implementing ISO 9000&quot; developed by The Media Group (Williston, VT) is one place to start. The training video, which is one in a series of ISO 9000-related courses, details the 20 elements of ISO 9000-1, including subsets ISO 9000-2 and 9000-3, and includes practical suggestions from companies such as Polaroid and Bachman, which comply with the standard. For more information, call The Media Group at 800-678-1003.<P>
As with many ISO standards, 9000-3 has gained more momentum in Europe than North America. However, U.S. software vendors with plans for cultivating a global client base may find it necessary to seek ISO 9000 certification. Likewise, implementing a certification software quality-assurance program may also provide a competitive edge when cracking non-U.S. markets. In any event, establishing well-defined software testing and quality-assurance programs makes good sense for all software developers.<P>
--editors<P>
<a name="0082_0008"><B>Example 1: </B>Typical test script.<a name="0082_0008"><P>
<pre>

B[uttonPress]
&lt;process_name&gt;
&lt;widget_name&gt;
K[eyPress]
&lt;process_name&gt;
&lt;widget_name&gt;
&lt;key&gt;

</pre><P>
<a name="0082_0009"><B>Example 2: </B>Sample test-script syntax.<a name="0082_0009"><P>
<pre>ButtonPress  myapp  file-cascade
ButtonPress  myapp  open-button
KeyPress  myapp  open-file-field  n
KeyPress  myapp  open-file-field  e
KeyPress  myapp  open-file-field  w
KeyPress  myapp  open-file-field  .
KeyPress  myapp  open-file-field  t
KeyPress  myapp  open-file-field  x
KeyPress  myapp  open-file-field  t
ButtonPress  myapp  open-ok-button
</pre>

<h4><a name="0082_000a"><a name="0082_000b"><B>[LISTING ONE]</B></H4>

<PRE>

void APPstoreMainID(Widget W,      /* I: Widget of MainWindow */
             char *ProcessName)    /* I: Name of the property */
{
 /* Code to initialization the test system within the application. Stores
    the Main Widget window ID as a property in the X server */

    Atom atom;
    Display *display;
    Window window;

    display = XtDisplay(W);
    window = XtWindow(W);
    /* Atoms are the addressing mechanism for properties */
    atom = XInternAtom(display, ProcessName, 0);
    /* Adding property for ProcessName. The property is associated
       with the root window  */
    XChangeProperty(display, DefaultRootWindow(display), atom,
         XA_WINDOW, 32, PropModeReplace, (unsigned char *)&amp;window, 1);
  }


</PRE>

<h4><a name="0082_000c"><a name="0082_000d"><B>[LISTING TWO]</B></H4>

<PRE>


int GENsendEvent(Widget FromW,       /* Widget the event is sent from,
                                        used to get the display ID. */
          XEvent *Event,             /* Event to be sent */
          char *ProcessName)         /* Destination process name */
/* Description: General routine to send an event, here used to send events
   from the test process to the applications. */
{
  int ret, format;
  unsigned long nitems, left;
  Display *display=NULL;
  Window window, *retData=NULL;
  Atom atom, type;
  long eventMask = 0;

  display = XtDisplay(FromW);
   /* Get propery identifier. */
  atom = XInternAtom(display, ProcessName, 1);
   /* Get the receiving window ID, stored as a property in the server. */
  ret = XGetWindowProperty(display, DefaultRootWindow(display), atom,
               0, 4, False, XA_WINDOW, &amp;type, &amp;format, &amp;nitems,
               &amp;left, (unsigned char **)&amp;retData);
  /* Check ret: Success value is special for XGetWindowProperty, see Ref Man.*/
  if (retData != NULL) {
    window = *retData;
    eventMask |= ButtonPressMask;
    eventMask |= ButtonReleaseMask;
    eventMask |= NoEventMask;
    Event-&gt;xany.window = window;
    Event-&gt;xany.display = display;
    ret = XSendEvent(display, window, TRUE, eventMask, Event);
  }
  XFree((caddr_t)retData);
}


</PRE>

<h4><a name="0082_000e"><a name="0082_000f"><B>[LISTING THREE]</B></H4>

<PRE>


int TESTsendButtonEvent(int Down,       /* I: TRUE if ButtonPress */
         int WidgetIndex,               /* I: Destination widget number
                                           converted from the name read
                                           from the test script via a table */
                  char *ProcName,       /* I: Name of application read
                                           from test script*/
          Widget FromWidget)            /* I: Main widget of test driver */
 /* Declares and sends events from the Test Driver to the applications */
{
  int eventType;
  XClientMessageEvent event;
  if (Down)
    eventType = ButtonPress;
  else
    eventType = ButtonRelease;
  event.type    = ClientMessage;
  event.format  = 32;
  event.data.l[0] = eventType;
  event.data.l[1] = WidgetIndex;
  GENsendEvent(FromWidget, (XEvent *)&amp;event, ProcName);
  /* GENsendEvent is shown in <a href="#0082_000c">Listing Two</A> */
}


</PRE>

<h4><a name="0082_0010"><a name="0082_0011"><B>[LISTING FOUR]</B></H4>

<PRE>


#include &lt;Xm/PushBGP.h&gt;
void APPdistributeEvent(Widget W, XtPointer ClientData,
                          XClientMessageEvent *Event,
                          Boolean *ContToDispatch)
/* Receives events from the test driver and passes the events to individual
   widgets based on the message received by the test driver. This is a standard
   callback routine. Therefore the parameters are not explained.  */
{
  int ret, format, widgetIndex, eventType, keyCode;
  Display *display;
  Window window;
  long eventMask = 0;
  XButtonEvent newEvent; /* Used both for button and key events. The structures
                            are identical, except for the button/code field. */
  eventType = (int)Event-&gt;data.l[0];
  widgetIndex = (int)Event-&gt;data.l[1];
  if ((eventType == KeyPress) || (eventType == KeyRelease)) {
    keyCode = (int)Event-&gt;data.l[2];
  }
/* Checks should be performed to ensure that widget index is within legal
   range, skipped in this listing */
  if (XtIsWidget(WidgetTable[widgetIndex])) {
    display = XtDisplay(WidgetTable[widgetIndex]);
    window = XtWindow(WidgetTable[widgetIndex]);
    /* Position is set inside the window */
    newEvent.x = 4;
    newEvent.y = 4;
  }
  else {    /* gadgets */
    display = XtDisplay(((XmGadget)WidgetTable[widgetIndex])-&gt;object.parent);
    window = XtWindow(((XmGadget)WidgetTable[widgetIndex])-&gt;object.parent);
    /* Gadgets are part of their parent widget's window. Below is code to find
       where gadget is positioned inside parent. Event is sent to parent
       in the case of gadgets. */
    newEvent.x = ((XmGadget)WidgetTable[widgetIndex])-&gt;rectangle.x + 4;
    newEvent.y = ((XmGadget)WidgetTable[widgetIndex])-&gt;rectangle.y + 4;
  }
  newEvent.window = window;
  newEvent.display = display;
  newEvent.subwindow = 0;
  newEvent.root = XRootWindowOfScreen(XtScreenOfObject(W));
  newEvent.type = eventType;
  newEvent.time = CurrentTime;
  newEvent.state = 0;
  if ((eventType == KeyPress) || (eventType == KeyRelease)) {
    /* The field below is the only difference between the event types used. */

    newEvent.button = keyCode;
  }
  else {
    newEvent.button = Button1;
  }
  ret = XSendEvent(display, window, TRUE, eventMask, (XEvent *)&amp;newEvent);
  /* Error checks should be done on ret */
}


</PRE>

<h4><a name="0082_0012"><a name="0082_0013"><B>[LISTING FIVE]</B></H4>

<PRE>


/* Application include file which defines widget names used as
index into WidgetTable */

#define file-cascade      1
#define open-button       2
#define open-file-field   3
#define open-ok-button    4


</PRE>

<h4><a name="0082_0014"><a name="0082_0015"><B>[LISTING SIX]</B></H4>

<PRE>


/* Table used to find widget indexes of application App1 in test driver */
TEST_ITEM App1TestTable[] = {
{&quot;file-cascade&quot;,      1},
{&quot;open-button&quot;,       2},
{&quot;open-file-field&quot;,   3},
{&quot;open-ok-button&quot;,    4}
};
int App1TableSize = (sizeof App1TestTable / sizeof App1TestTable[0]);


</PRE>

<h4><a name="0082_0016"><a name="0082_0017"><B>[LISTING SEVEN]</B></H4>

<PRE>


/* Definition of the TEST_ITEM structure */
typedef struct {
    char *WidgetName;
    int  WidgetIndex;
} TEST_ITEM;
End Listings
</pre>

<HR><P>Copyright &copy; 1994, <I>Dr. Dobb's Journal</I></P></BODY></HTML>
