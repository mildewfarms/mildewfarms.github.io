<HTML>
<META NAME="year" CONTENT="1994">
<HEAD>
<TITLE>DEC94: LETTERS</TITLE></HEAD>
<BODY BGCOLOR="#ffffff">
<h1>LETTERS<a name="01e0_0001"></h1><P>
<h3><a name="01e0_0002">More on Fractal Rulers <a name="01e0_0002"></h3><P>
Dear <I>DDJ</I>, <P>
I was pleased that you published my letter regarding Fractal Rules (<I>DDJ</I>, October 1994). However, a typographical error crept into the program listing (my fault, no doubt). The expression <I>min(x^(unsigned long)(x+1),ticksPerSegment--1)</I> should have read <I>min(i^(unsigned long)(i+1),ticksPerSegment--1)</I>. My apology to anyone confused by this. <P>
Michael Lee Finney<P>
Lynchburg, Virginia<P>
<h3><a name="01e0_0003">CISC is Dead--Long Live CISC!<a name="01e0_0003"></h3><P>
Dear <I>DDJ</I>,<P>
I experienced a bit of d&eacute;j&agrave; vu while reading &quot;Programming Paradigms&quot; (<I>DDJ</I>, September 1994). All that talk of a new hardware platform with limited development tools made me think that I was back in 1984 listening to the latest Apple dogma.<P>
I just don't understand why Apple expects everyone to buy into the RISC religion. They push RISC's speed but fail to emphasize that the larger programs will require at least double the memory ($$$), more hard-disk space ($$$), and longer load times (@#%^&amp;*!).<P>
In the meantime, many RISC concepts have found their way back into the CISC technology. If Apple wanted my 2 cents worth, I'd ask them to build a new line of machines based upon the Motorola 68060. CISC is not dead.<P>
Neil Rieck<P>
Kitchener, Ontario<P>
<h3><a name="01e0_0004">OS/2 Woes<a name="01e0_0004"></h3><P>
Dear <I>DDJ</I>,<P>
I just finished reading Al Stevens' article on C++ and OS/2. I no longer feel bad for consistently crashing OS/2. I, too, am a software developer and have to write apps for Windows and OS/2. Some days it is a challenge just to get OS/2 to stay running long enough to get the project done. I have had many of the &quot;OS/2 gurus&quot; at my company look at my system to try to fix this problem; they all say it's not OS/2's fault, it's something I am doing. I do not  subscribe to this point of view at all. Lowly DOS/Windows doesn't crash this much during development; why does &quot;almost uncrashable OS/2&quot; do it so much more often? Anyway, thanks for providing a little validation to my OS/2 frustrations. <P>
Michael Miller<P>
Atlanta, Georgia<P>
<h3><a name="01e0_0005">OS/2 2.1 Executable File Formats Corrections<a name="01e0_0005"></h3><P>
Dear <I>DDJ</I>,<P>
I would like to point out some problems with the article, &quot;Examining OS/2 2.1 Executable File Formats,&quot; by John Rodley (<I>DDJ</I>, September 1994). In describing the fixup format, John has confused the meanings of fixup source and fixup target. On page 73, he states, &quot;The target is the place in the code where a symbolic reference must be replaced by a real address,&quot; and further on, &quot;The fixup record contains the offset of the target and the object number and offset of the source.&quot; However, on the following page, Figure 2 clearly shows that it is the source, not the target, which is specified by an offset on a physical page, and it is the target which is specified by an object number and offset.<P>
Had John simply reversed the meanings of these terms, the error would be understandable. But he states that &quot;LX uses the more obvious one-[fixup record]-per-target strategy.&quot; This contradicts his previously stated definitions of source and target.<P>
Finally, on page 73 John states that &quot;each page in the Object Page Table contains an index into the Fixup Record Table pointing to the first fixup record for that page.&quot; This is incorrect. It is the Fixup Page Table, not the Object Page Table, whose records contain pointers into the Fixup Record Table.<P>
Fred Hewett<P>
Watertown, Massachusetts<P>
<I>John responds:</I> Thanks for responding to my article on the LX file format, Fred. I often wonder if anyone is reading these things-- now I know.  <P>
I have to tell you, my day is ruined. You're right, I reversed the definitions of source and target, further muddying a subject I was trying to clarify. In my defense, the Schmitt <I>PC Tech Journal</I> article I used as a reference for the NE format uses my (reversed) definition for target. The IBM LX format doc uses the opposite definition. In my head, I was simply switching definitions depending on which reference I was looking at. I didn't catch that until sitting down with your letter, the source, and both references.<P>
In the code that attaches sources to targets, (lx_exe.c lines 412--471), I use the proper (nonreversed) definition, which is why tables 3 and 4 come out right. What I do is print column headings that say &quot;Target Source&quot; while actually printing in the column data &quot;source target.&quot;<P>
In summary, the definitions of source and target on page 73 should be reversed along with the column headings on Tables 3 and 4, and the statement about one-record-per-target should read &quot;LX uses the more obvious one-fixup-record-per- source strategy.&quot; Also page 74, paragraph 4 should say &quot;source'' where it says &quot;target.''  <P>
Sigh.<P>
You are also correct about Object Page and Fixup Record Tables. If you look close enough in the source (lx_exe.c lines 415--420) that connection is visible, but I certainly forgot it when I wrote that sentence.<P>
Thanks for the corrections, Fred. Frankly, I'm astonished that anyone caught this. How do you know so much about executable file formats?<P>
<h3><a name="01e0_0006">Bar Codes<a name="01e0_0006"></h3><P>
Dear <I>DDJ</I>,<P>
In regards to the article, &quot;A C++ Class for Generating Bar Codes&quot; by Douglas Reilly (<I>DDJ</I>, July 1994), readers should know that the AIM Uniform Symbology Specification Code 128 specification (June 1993) is the definitive reference source for bar-code character labels. You can contact AIM at 634 Alpha Drive, Pittsburgh, PA 15238-2802.<P>
The AIM document says that the STOP character shall be 13 units wide, ending in a double unit bar. Doug's CODE 128 routines only specify the first 11 units of the STOP character and instead use a <I>printCode128Term()</I> routine to print the final bar; this yields correct bar codes but seems to me (in a picky way) to violate the specification's intent.<P>
Also, the codes 28, 30, and 62 have incorrect display values in the <I>DDJ</I> routine code structure. The bad routine values and correct AIM values are shown in <a href="#01e0_000a">Table 1</A>.<P>
Harold T. Salive<P>
Auckland, New Zealand<P>
<I>Doug responds:</I> Thanks, Harold, for pointing out the correct codes for 28 and 30. The value for 62 is a space in my reference. Obviously, I should have referred to the original standard. In any event, I'll obtain the text of the standard ASAP and post a corrected version of the code.<P>
As to my treatment of the STOP character, while I understand your concern, my goal was to generalize the creation of individual characters as much as possible. Placing the final bar of a STOP character outside the normal character routine seemed (and seems) reasonable to me.<P>
The STOP character is the single character that extends beyond 11 units. Perhaps it would have been clearer to encapsulate all of the stop code printing within <I>printCode128Term()</I>. Thanks again for your thoughtful reading of the code.<P>
<h3><a name="01e0_0007">Mind and Life<a name="01e0_0007"></h3><P>
Dear <I>DDJ</I>,<P>
Regarding Michael Swaine's, &quot;Mind and Life as Mechanism&quot; (<I>DDJ</I>, October 1994), mechanical models of life have always been repugnant to many. However, throughout history new knowledge about living creatures has only served to strengthen the hand of those who tout such models. Knowledge now culminates in the discovery that DNA governs the physical development of living creatures from birth. The ongoing genome-mapping project is writing a new chapter.<P>
The brain/mind seems to be the final frontier in the search for a mechanical basis for life. I, for one, am ready to accept it. I've come to think of life simply as a fifth state of matter--after solid, liquid, gas, and plasma--to put it in prosaic terms. It seems that living creatures need not be considered anything more than complex, highly organized systems of molecules. How that organization continually fine tunes itself in an evolutionary sense is a central question. I cannot believe it is due strictly to random mutations triggered by cosmic rays as some say. Behavioral aspects affect and reflect neural interconnection patterns. Perhaps information of changes in those patterns tends to feed back into the genes somehow.<P>
The earliest reference of the brain as mechanism in my library is <I>Design For a Brain,</I> by W. Ross Ashby (John Wiley &amp; Sons, 1952), which predates our modern computers and is centered around a special-purpose computer called a &quot;homeostat.&quot; It's an interesting book filled with diagrams and equations, not just text. Chapter 8's title is, &quot;The Animal as Machine.&quot; Compare that with &quot;Mind and Life as Mechanism.&quot;<P>
&quot;Roger Penrose,&quot; Michael states, &quot;has presented an approach that rests ultimately on quantum uncertainty.&quot; I presume that refers to the Heisenberg uncertainty principle from quantum physics. If so, here's a late flash: Along comes Sallhofer (<I>Z.Naturforsch</I>, Hans Sallhofer, Maxwell-Dirac-Isomorphism, 1986) in Austria to proclaim, with some authority, that the probabilistic interpretation of quantum theory is a mistake. That it is due simply to a &quot;lack of clarity&quot; in the theory which is not present in the Dirac formulation. So that catchall phrase, &quot;quantum uncertainty,&quot; may be on its way out.<P>
Homer B. Tilton<P>
Tucson, Arizona<P>
<h3><a name="01e0_0008">Programming-Language Syntax<a name="01e0_0008"></h3><P>
Dear <I>DDJ</I>,<P>
Many years ago, Niklaus Wirth proposed a notation for defining the syntax of programming languages called, &quot;extended Backus-Naur Form,&quot; or EBNF. Although its earliest publication seems to have been in a very short article in the <I>Communications of the ACM</I> in 1977, it is still alive and well. Recent ANSI/IEEE and ISO/IEC standards have made use of it.<P>
So why am I writing this letter? Partly because EBNF is a good thing in and of itself: It is clear, unambiguous, readable, easy to learn, machine processable, and is not dependent on multiple fonts. I'm also writing this because I'd like to see a standard combining the various dialects of EBNF that have cropped up over the years. In fact, I'm probably willing to write the first draft of the standard. (I also hope to make some money by coming up with my own EBNF-based products.)<P>
Are you or any <I>DDJ</I> readers aware of any ongoing work on standardizing EBNF? Perhaps an ANSI, IEEE, IEC, or ISO committee? If nothing is ongoing, then I might be interested in creating an informal committee for this. Would you be interested in being involved in the committee? Or would you just like me to keep you posted?<P>
The first thing I would like to add to EBNF is a way of indicating comments. Before I invent something, is there any existing technique for this?<P>
Anyone who is interested, or aware of any other EBNF-based software, is invited to send me e-mail or regular mail.<P>
John Rogers<P>
11604 104th Ave. NE<P>
Kirkland, Washington 98034-6606<P>
CompuServe 72634,2402<P>
<I>DDJ responds:</I> This sounds like a worthwhile project, John, and hopefully, other readers will work with you on it. Keep us posted on your progress and let us know how we can help out.<P>
Hause's Method<P>
Dear <I>DDJ</I>,<P>
I read your magazine for the first time in July. This is the best programming magazine I ever picked up: intelligent, unpretentious, and aware of the context of software engineering in the world outside. Jack Woehr's interview with Lotfi Zadeh was a pleasure to read and reread.<P>
Now talking of fuzzy logic, what was Mr. Williams D. Hause's letter (<I>DDJ</I>, July 1994) trying to prove. I just bought a copy of Schneier's wonderfully plaintext <I>Applied Cryptography</I>. Mr. Hause was talking about a one-time pad! My sister and I used to send messages to each other like this. Mathematically unbreakable, except that our mother would tidy up our messages and one-time pads from inside the sofa to the kitchen bin.<P>
I couldn't believe that Mr. Hause's nonsensical letter wasn't a joke. Here is my proof: <P>
Theorem:<I> </I>Any notion N, when obscured by ridiculous pseudoformal reasoning R, produces a ridiculous nonsense.<I> </I>Proof:<P>
<OL>
<li>Let <I>K</I> be a ridiculous, pseudoformal reasoning of <I>X</I> number of lines.</li>
<li>Let <I>P</I> be the plain notion encrypted in Hause's letter, of length <I>X</I>.</li>
<li>Let <I>C</I> be the confusion produced by <I>K</I> <I>obx P</I>. (<I>obx</I> is the Hause &quot;obscure pseudoformal reasoning&quot; operator.)</li>
<li>From the theorem I am trying to prove, we know that <I>C</I> is ridiculous nonsense and is therefore unbelievable.</li>
</OL>
<B>Corollary</B>: Using Hause's method I have discovered a truly remarkable four-line proof of the four-color map theorem, but my margin of credibility is too small to contain it.<P>
Sandy Anderson<P>
London, England<P>
<h3><a name="01e0_0009">Another Approach to Callbacks<a name="01e0_0009"></h3><P>
Dear <I>DDJ</I>,<P>
I read with interest the article, &quot;Associations in C++&quot; by Dan Ford (<I>DDJ</I>, August 1994) because a team member of mine wrote an almost identical class with a slightly different twist. Instead of indirectly calling a method through a function, we simply called the method directly. To do this, the user of the callback registers calls not only the object pointer, but also the pointer to the method he wishes to have called. The method is then called in the standard way of calling methods through pointers: <I>(objectPointer-&gt;*methodPointer)(param1, _;</I>.<P>
In this way, objects can directly register their own methods to be called on specific events. Of course, the obvious constraint on this is that the object and method pointers that are used are all derived from a common class. This is because the callback manager object must be able to hold the pointers in a variable of the appropriate type. In other words, you could not store the object and method pointers as void pointers and expect it to work (too bad, I say!). However, it is my opinion that this constraint is not a factor when properly designing application-domain frameworks. Of course, if you use Smalltalk, all of these problems that arise from using such a hybrid language become NULL and void! <P>
Kevin W. Beam<P>
Omaha, Nebraska<P>
<h4><a name="01e0_000a"><B>Table 1:</B> Bar codes.<a name="01e0_000a"></h4><P>
<PRE>
Code          Routine         AIM
              Errval          Value
28             {              &lt;
30             }              &gt;
62                            ^
</pre><HR><P>Copyright &copy; 1994, <I>Dr. Dobb's Journal</I></P></BODY></HTML>
