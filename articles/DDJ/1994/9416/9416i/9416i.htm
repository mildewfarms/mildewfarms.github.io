<HTML>
<META NAME="year" CONTENT="1994">
<HEAD>
<TITLE>SP 94: Distributed Applications and NeXT's PDO</TITLE></HEAD>
<BODY BGCOLOR="#ffffff">
<h1>Distributed Applications and NeXT's PDO<a name="02c1_00f1"></h1><P>
<h2><a name="02c1_00ef"><a name="02c1_0000">PDO brings distributed objects to non-NextStep environments</h2><P>
<h3>Dennis Gentry</h3><P>
<p><i><a name="02c1_00f0"><a name="02c1_0000">Dennis is a member of the developer-support team at NeXT. You can reach him by e-mail at dennis_gentry@next.com.</i></p><hr><P>
The Portable Distributed Objects system (PDO) is a powerful subset of NextStep technology. It's an extension of Distributed Objects (DO) and is part of the NextStep development environment. Distributed Objects and Portable Distributed Objects enable developers to efficiently construct, operate, and maintain complex client/server applications in a heterogeneous computing environment. <P>
What happens when more people need to use your application than you had initially planned, so that you need to split the processing load across several computers? Or, what happens when you want to use NextStep to build the user interface to a database application, but the database server runs on an HP server? Perhaps your company needs to build a groupware application that lets people work together interactively. DO and PDO were designed for these situations.<P>
<h3><a name="02c1_00f2">Share and Share Alike<a name="02c1_00f2"></h3><P>
The DO system provides a way to share objects among multiple client/server applications running on separate computers on a network--distributed over both client and server machines. In this model, the server application consists of a collection of objects that are intended for use by cooperating client applications. The server publishes some of its objects to make them available to client applications on the same computer, and on other computers on the network. To the clients, the published objects are messaged as if they were in the same process as the rest of the client. This transparent messaging is much cleaner than older-generation remote procedure call (RPC) mechanisms. DO preserves the power and benefits of object-oriented programming, even in a distributed application environment.<P>
The PDO system extends the power of Distributed Objects to non-NextStep computers. It allows a core section of the NextStep environment to run on other systems. Objects in the PDO environment can communicate over networks with other PDO and DO objects. The PDO system includes all the parts of NextStep necessary to run distributed-object servers--plus some additional common functionality (such as NextStep's file-stream functions and portable BuildServer). PDO facilitates reusability of objects developed under NextStep and doesn't require additional software on NextStep clients or servers. It lets you use objects remotely as either clients or servers, even on machines that aren't running NextStep.<P>
The components that make up PDO are:<P>
<UL>
<li>Objective C, which is the language used to create objects and interact with other objects.</li>
<li>The Objective C run time, which are extensions to the Objective C language environment that provide for dynamic binding at run time.</li>
<li>The NextStep Core Classes, which is a library that provides classes such as Object, List, and HashTable.</li>
<li>The Distributed Object system, which is a set of classes that manages the brokering of server objects and provides transparent connections to remote objects in the network.</li>
<li>The Transport Mechanism, which is built into the DO classes and provides an independent transport mechanism for communicating between objects over a network.</li>
<li>The Portable nmserver, which is a portable version of the Mach Network Name Server used in DO to provide object naming over the network.</li>
</UL>
The first targeted platforms for PDO are mainstream UNIX-server environments such as HP-UX and Solaris. The design of PDO is not restricted to UNIX platforms, so that future support of environments such as NetWare and Windows NT is possible. With regard to the emerging CORBA standard for object interoperability, Next has submitted an Objective C binding for the IDL interface description language so that CORBA clients and servers can be written in Objective C.<P>
<h3><a name="02c1_00f3">PDO/DO Advantages<a name="02c1_00f3"></h3><P>
Compared to other popular RPCs (such as Sun RPC and Mach RPC), DO and PDO have a number of advantages that make developing with them nearly transparent. They allow you to cleanly design client/server application architectures without the usual hassles that come with other RPC mechanisms.<P>
One important aspect of DO is that it is dynamic. Other RPC systems require you to specify the exact procedures that you'll call remotely. Likewise, they require you to indicate the exact types and sizes of the arguments and return values. When you add a procedure to your RPC project's list of remotely callable procedures, you must recompile all affected code on the server and the client. In contrast, DO allows you to send messages to objects that don't exist, or haven't even been defined. If a new DO server implements and exports an object that conforms to some message protocol, previously running clients that use that protocol can begin using the new object immediately.<P>
Another advantage is that DO frees you from many memory-management concerns. You can't completely ignore memory management, because there's no automatic garbage collection in NextStep. However, if you're just sending and receiving parameters and return values, you generally don't need to explicitly deal with memory as you would with other RPC systems.<P>
<h3><a name="02c1_00f4">Divide and Conquer<a name="02c1_00f4"></h3><P>
With some RPC systems, you must decide that you're writing an RPC program before you start. If your existing single-machine code was not written with RPC in mind and you later need to scale up your application as your business grows, you'll have to rewrite and extend your program to distribute it across multiple machines. If you're concerned about decent performance with your RPC application, you have even more work to do. <P>
In contrast, you can often take a nondistributed NextStep application and make it distributed with little trouble. Your NextStep application already should be composed of objects. In such a case, distributing your application might involve merely identifying the relevant objects and moving them to a server program.<P>
DO and PDO also benefit from the advantages of object-oriented programming over procedural programming. Because your application is made up of objects, and because of the encapsulation properties of objects, your application will likely be composed of well-contained computational units from the start. These units often can be relatively easily distributed across multiple machines because of their clean interfaces to other objects, and their locality of reference will foster better performance in a distributed environment.<P>
<h3><a name="02c1_00f5">Choosing Between DO and PDO<a name="02c1_00f5"></h3><P>
Ordinarily, most programmers probably would choose to use DO instead of PDO because DO runs under the full NextStep environment and is, therefore, more powerful (and simpler to use). For example, the full Application Kit (a general-purpose application framework) is available under NextStep, but not under PDO. Also, some PDO operating systems don't have the functionality to support preemptive threads that you may need to build your server. (The PDO comes with Distributed Object Event Loop to work around this limitation.)<P>
However, you might consider using PDO rather than DO to build a server for your application in situations such as these:<P>
<UL>
<li>A central machine must serve many requests.</li>
<li>Your applications have occasional compute- or memory-intensive requests, or need a fail-safe or easily recoverable server.</li>
<li>A non-NextStep machine is already set up to parcel out a centralized data feed. </li>
<li>You'd like to take advantage of your heterogeneous network to perform tasks in parallel.</li>
</UL>
If you don't have one or more of these requirements, you might find a NextStep-based DO server more convenient than a PDO server. If your site outgrows your NextStep server, it's relatively easy to move your server to a PDO platform.<P>
<h3><a name="02c1_00f6">How to Distribute Objects<a name="02c1_00f6"></h3><P>
Applications take advantage of Distributed Objects by sending ordinary Objective C messages to objects in remote applications. The program that implements and makes an object available for remote use is called the &quot;server,&quot; and a program that takes advantage of that object by sending it messages is a &quot;client.&quot; A single application can easily play both the client and server roles.<P>
To set up servers and clients, you must add a few additional lines of code to each cooperating application to specify which applications and objects are involved. Both DO and PDO can handle most data types as arguments or return values--including structures, pointers, strings, and, most importantly, objects (ids). <P>
To make an object distributed (and, therefore, available to other applications), a server program must first &quot;vend&quot; (make publicly available) the object. <a href="#02c1_00fd">Example 1(a)</A> shows a simple application that shares a central stock-price data feed. The <I>NXConnection</I> class provides other, more commonly used methods than <I>run</I> that allow the waiting to take place asynchronously. <a href="#02c1_00fd">Example 1(a)</A> instantiates a price server, then registers that server with the network name server <I>stockPriceServer</I>. The last line loops to wait for remote messages. You must include this code in each application that will participate in Distributed Objects.<P>
To use an object that has been vended, a client looks up the desired server object and stores a handle to it in a local <I>NXProxy</I> object. <a href="#02c1_00fd">Example 1(b)</A> gets a handle and stores it in the variable <I>theServer</I>. If this code returns a non-<I>nil</I> value to <I>theServer</I>, the client may then refer to the stock-price server on the server machine as if it were implemented in the client, with only a few exceptions; see <a href="#02c1_00fd">Example 1(c)</A>. This transparency is at the heart of Distributed Objects. <P>
<h3><a name="02c1_00f7">Passing Objects<a name="02c1_00f7"></h3><P>
Perhaps the most important data type that clients and servers can pass to each other is the id. In the example application, the server explicitly vends and the client looks up only one serving object. After that, either the client or the server may pass ids of objects that each wishes to implicitly vend as arguments or return values. <P>
As long as the client is prepared to handle remote messages by way of some form of <I>NXConnection</I>-run message, and as long as the client vends an object to the server in this way, the server may then use objects in the client. Thus, the client and server switch roles. More commonly, the original server can make additional objects available that are useful to the client, without additional setup code overhead.<P>
For example, suppose the stock price server needs to return more attributes than just the price of the stock. A good way to do this is to have the server return a <I>Stock</I> object that the client can then query for the stock attributes. The client code might look like <a href="#02c1_00fe">Example 2</A>. Executing the first line implicitly vends a <I>Stock</I> object from the server, which is then accessible by way of the id <I>mystock</I>. Each <I>printf</I> statement invokes the remote stock object in the server, even though the client refers to <I>myStock</I> just like any local object.<P>
<h3><a name="02c1_00f8">Multithreaded Servers <a name="02c1_00f8"></h3><P>
In <a href="#02c1_00fd">Example 1(a)</A>, the last line of the program, <I>[myConnection run]</I>, never returns--it just loops while waiting for incoming remote messages. However, in most applications, a server must do more than simply service remote messages. For example, a real stock-price server also might update a database from a real-time data feed. Multiple threading is the mechanism that allows a server to continue with other tasks while it also waits for messages to objects it has vended. The DO system makes multithreading very easy for programs built with the Application Kit, using the <I>NXConnection</I> method <I>runFromAppkit</I>.<P>
Although in most applications, you can use PDO objects in exactly the same way as DO objects, you can't currently write multithreaded PDO servers. This is because there are no tools for threads in the HP operating system. For example, the DO code from the server shown previously might be enhanced to look like that in <a href="#02c1_00ff">Example 3</A>. The <I>runFromAppkit</I> method creates a new thread whose sole purpose is to loop, waiting for remote method invocations. The <I>runFromAppkit</I> method also is aware that the Application Kit isn't thread-safe, so it waits to dispatch remote methods until your application is between Application Kit events. If your server doesn't use the Application Kit and requires finer-grained parallelism, other methods let you create threads that dispatch remote methods without waiting for the Application Kit. These methods are documented in the <I>NextStep General Reference </I>book.<P>
<h3><a name="02c1_00f9">Avoiding Pitfalls<a name="02c1_00f9"></h3><P>
If your application is simple (like the example shown here), you'll find that making your application distributed is fairly transparent. However, if you're building a more complex, robust application, you must be aware of a few more issues.<P>
One is that the semantics of returning <I>self</I> are different. In Objective C, it's common to return the id <I>self</I> to indicate success of a method. While this has reasonable performance for local objects, returning <I>self</I> to a remote caller actually vends the object to which <I>self</I> refers, with all the overhead involved. Unused object vending is not excessively expensive, but for maximum efficiency, objects should return a more appropriate type than <I>self</I>. <P>
For example, to indicate success or failure, an object should return a scalar type such as YES or NO, instead of <I>self</I> or <I>nil</I>. If the server doesn't need to return a status at all, it can return <I>void,</I> and the method call can use the <I>oneway</I> keyword. This results in a very fast one-way asynchronous call--meaning that the caller doesn't even have to wait for the remote method to finish.<P>
Another issue in distributed applications is how to handle a failure in the network or in remote machines. You must make sure that cooperating programs deal gracefully with the failure of their clients or servers. The exact action an application should take depends on the nature of the cooperating programs, but DO provides a reasonably simple mechanism that allows programs to notice the loss of a cooperating program. To be notified of the loss of a cooperating program, an object must request notification and implement a <I>senderIsInvalid:</I> method. When the object is asynchronously notified by way of this method, it must determine which remote objects have become inaccessible, and decide what to do about it.<P>
Another pitfall in making an application distributed is that a few data types can't be passed and returned transparently. These types are unions, void pointers, and pointers inside structures other than <I>id</I>s and <I>char *</I>s. The basic problem with these types is that, in general, the compiler can't know the size of the data being referenced, so it can't pass the data to a remote program in a meaningful way. Another problem is that the computer on which the remote object is running might deal with the data differently (for example, it might use different byte ordering). The result is that it's not possible to pass data types whose layout can't be known. <P>
Presently, there are at least two ways to deal with this limitation. One is to type-cast pointers, which works around the void pointer problem, as long as the pointer is to a nonrecursive structure. Another approach is to enclose complex structures into an object and transmit that object. However, if you find yourself often transmitting objects around, you might consider redesigning or repartitioning your application to lessen network traffic.<P>
To transmit object copies instead of vending them, use the new <I>bycopy</I> Objective C keyword in the parameter list. Be sure to conform to the <I>NXTransport</I> protocol, which requires that you write three simple methods: <I>encodeRemotelyFor:freeAfterEncoding:isBycopy:</I>, <I>encodeUsing:</I>, and <I>decodeUsing:</I>. The first of these is actually implemented in the Object class. You typically override it with a simple two-line method that uses the <I>isByCopy</I> parameter to decide whether to send a copy of the object. If a copy is to be sent, the other two methods cooperate to send the data necessary to create a copy of the object at its new location. The <I>encodeUsing:</I> method runs locally and packs up the unique data of the object. On the remote computer, the <I>decodeUsing:</I> method unpacks the object to instantiate a copy.<P>
With regard to strings, a nontransparency arises in the current version of DO, which manages the memory for storing pointers to <I>char</I>s (strings) differently than it does for pointers to other data types. Normally, pointer data is automatically freed when the server returns. However, in the current DO, the server must explicitly free strings when it has finished with them. If your server code doesn't free strings, the memory for those strings is lost. In a future version, DO will manage the memory for strings just as it currently does for other data types. <P>
<h3><a name="02c1_00fa">Pitfalls in Scalability <a name="02c1_00fa"></h3><P>
Performance, deadlock avoidance, and transaction management are issues that you don't need to worry about in smaller or simpler DO applications. However, in large distributed applications, these issues can become very important. With a larger network that has complex needs, latent problems in your existing DO applications may then become apparent. This isn't completely bad news, because once problems are apparent, you have a better chance of fixing them. <P>
Dealing with these advanced issues is beyond the scope of this article. However, it behooves you to consider the inherent complexity involved in writing distributed applications before you begin work on a large-scale distributed application. To deal with deadlock, you must carefully think through the behavior of cooperating and competing servers to make sure they can never mutually rely on the same resources at the same time in order to make progress. Likewise, to deal with managing atomic transactions, you should consider using a two-phase commit protocol. <P>
If you plan to put compute-intensive tasks on a server, keep an eye on scaling issues. For example, no current PDO server has the aggregate computing power of 500, or even ten Pentium-based NextStep machines. Therefore, if you might eventually decentralize your application, you shouldn't plan to saturate a single central server. Rather, consider distributing compute-intensive tasks across multiple server machines.The trade-off, of course, is that it can be more difficult and time consuming to correctly implement your computation for parallel processing.<P>
If you decide to distribute a task across several computers, keep in mind that the network has a finite bandwidth that can be saturated by a few high-performance machines sending remote messages extensively. Design your application to take advantage of the facility in DO for moving objects from one machine to another. This can reduce the amount of remote messaging that might otherwise occur.<P>
<h3><a name="02c1_00fb">Conclusion<a name="02c1_00fb"></h3><P>
DO and PDO offer excellent tools for developing client/server applications. Their design also provides the flexibility to expand applications as NextStep and PDO become available on more platforms. <P>
<h3><a name="02c1_00fc">References<a name="02c1_00fc"></h3><P>
Andleigh, Prabhat and Michael Gretzinger. <I>Distributed Object-Oriented Data-Systems Design</I>. Englewood Cliffs, NJ: Prentice Hall, 1992. ISBN 0-13-174913-7.<P>
Elmasri, Ramez and Shamkant B. Navathe. <I>Fundamentals of Database Systems</I>. Menlo Park, CA: Benjamin/Cummings, 1994. ISBN 0-8053-1748-1.<P>
NeXT Computer Inc. <I>NEXTSTEP 3.2 General Reference, Volume II</I>. Reading, MA: Addison-Wesley, 1992. ISBN 0-201-62221-1.<P>
NeXT Computer Inc. <I>NEXTSTEP 3.2 Release Notes</I>. NeXT Computer, 1993.<P>
NeXT Computer Inc. <I>Object-Oriented Programming and the Objective C Language</I>. Reading, MA: Addison Wesley, 1993.<P>
NeXT Computer Inc. <I>Portable Distributed Objects 1.0 Release Notes</I>. NeXT Computer, 1993.<P>
<h4><a name="02c1_00fd"><B>Example 1:</B> (a) Server code for an application that provides a stock-price data feed; (b) client code that connects to the stock-price server; (c) client code that accesses data from the server.<a name="02c1_00fd"></h4><P>
<pre>(a)  id myServer = [ [PriceServer alloc] init];
     id myConnection = [NXConnection
                            registerRoot: myServer
                            withName: &quot;stockPriceServer&quot;];
     // the following statement does not return
     [myConnection run];

(b)  id theServer = [NXConnection connectToName:&quot;stockPriceServer&quot;];

(c)  printf(&quot;IBM is currently at %d\n&quot;, [theServer priceFor:&quot;IBM&quot;]);
</pre><P>
<h4><a name="02c1_00fe"><B>Example 2:</B> Client code that gets an object from the server and sends messages to that object.<a name="02c1_00fe"></h4><P>
<pre>id myStock = [theServer stockFor:&quot;IBM&quot;];
struct tm today = gmtime();
printf(&quot;IBM is currently at %d\n&quot;, [myStock priceAtTime:today]);
printf(&quot;IBM's last dividend was %d\n&quot;, [myStock dividend]);
</pre><P>
<h4><a name="02c1_00ff"><B>Example 3:</B> Server code that uses multiple threads.<a name="02c1_00ff"></h4><P>
<pre>id myServer = [[PriceServer alloc] init];
id myConnection = [NXConnection
                         registerRoot: myServer
                         withName: &quot;stockPriceServer&quot;];

// the following line creates a new thread that waits
[myConnection runFromAppkit];

// Code to receive the data feed goes here
// and is executed in the original thread...
</pre>

<HR><P>Copyright &copy; 1994, <I>Dr. Dobb's Journal</I></P></BODY></HTML>
