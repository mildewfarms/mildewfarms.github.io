<HTML>
<META NAME="year" CONTENT="1994">
<HEAD>
<TITLE>SP 94: OLE Integration Technologies</TITLE></HEAD>
<BODY BGCOLOR="#ffffff">
<h1>OLE Integration Technologies<a name="02a7_00ed"></h1><P>
<h2><a name="02a7_00eb"><a name="02a7_0000">Building on the Component Object Model</h2><P>
<h3>Kraig Brockschmidt</h3><P>
<p><i><a name="02a7_00ec"><a name="02a7_0000">Kraig is the author of Inside OLE 2, published by Microsoft Press. Kraig can be contacted at Microsoft Corp., One Microsoft Way, Redmond, WA 98052-6399.</i></p><hr><P>
OLE 2, along with the technologies that fall under the OLE umbrella, is all about integration--integration between functional components of all sorts, wherever they may be. These components can be located in the system, inside applications, inside in-process DLLs or out-of-process EXEs, and, in the future, even in modules distributed across a network.<P>
The basis for this integration is the Component Object Model (COM), described in the article, &quot;The Component Object Model,&quot; by Sara Williams and Charlie Kindel on page 14 of this issue. OLE uses COM as the low-level plumbing that provides transparent communication between components through a binary standard (COM interfaces and structures). As COM evolves, OLE will automatically benefit and gain support for diverse system services, from database access, to messaging services, to system management, and more.<P>
OLE's history is concerned primarily with the creation and management of compound documents, but now OLE is much more than that. OLE integrates components that can come in many shapes and sizes. The interfaces provided on those components can also vary widely. In some cases, a particular component is implemented by OLE itself (to form a standard on which applications can depend). Other components are implemented by various types of applications. Components that are primarily users of interfaces implemented on other components are called &quot;clients&quot; or &quot;containers,&quot; depending on what they do with those interfaces. Modules that implement components with interfaces are called &quot;servers.&quot; All components based on COM are called &quot;Component Objects.&quot; For convenience, the use of the word &quot;object&quot; by itself in this article means &quot;component object.&quot; <P>
OLE is not an all-or-nothing technology. When using or implementing a component, you can use as little or as much of OLE as you find appropriate. This article examines the OLE technologies that build upon COM, as shown in <a href="199402a9.htm">Figure 1</A>. You'll see that OLE is a very rich collection of features to integrate data storage and exchange, programmability, compound documents, and controls.<P>
<h3><a name="02a7_00ee">Structured Storage<a name="02a7_00ee"></h3><P>
Today's world of component integration requires the ability for many components to share a common, byte-oriented storage medium (whether a disk file or a record in a database). Each component needs storage in which to save its persistent state. OLE's Structured Storage is an abstraction layer for accomplishing this level of integration. Structured Storage can be built on top of any file or other storage system, as shown in <a href="199402aa.htm">Figure 2</A> for a hard-disk system.<P>
In Structured Storage, any byte array can be structured into two types of elements: storages and streams. Each element has a name, which can be up to 31 Unicode characters in length. A storage implements the <I>IStorage</I> interface, which has directory-type functions for creating, destroying, moving, renaming, or copying other elements. A stream implements the <I>IStream</I> interface, with functions analogous to traditional file I/O (such as read, write, seek, and so on). In fact, <I>IStream</I> members have a direct one-to-one correspondence with the file I/O functions in the Win32 API and in the ANSI C run-time library. <a href="#02a7_00fc">Example 1</A> illustrates Win32 and <I>IStream</I> similarities.<P>
A storage can contain any number of other storages and streams within it, just like a directory can contain files and subdirectories. However, a storage isn't restricted only to being disk-based. Structured storage can be implemented on top of any byte-oriented storage system (or byte array), such as a disk file, a block of memory, a database field, and the like. Regardless of the medium, however, structured storage provides uniform access through the standard <I>IStorage</I> and <I>IStream</I> interfaces. The storage model also defines transactioning for these elements, where you can create or open an element in &quot;transacted&quot; mode (in which changes are not permanent until committed) or &quot;direct mode&quot; (where changes are immediately permanent).<P>
In effect, this &quot;file system within a file&quot; leaves the exact layout of the file to the system, but makes incremental access to elements the default mode of operation. With such a system, the application can effortlessly give individual streams (or even entire storages) to other components in which those components can save whatever persistent information they desire.<P>
This system is perfect for creating compound documents, and the technology known as &quot;OLE Documents&quot; relies on this structured storage facility. To further facilitate the creation and sharing of files (even across platforms), OLE provides a standard implementation of disk-based storages and streams in what are called &quot;Compound Files.&quot; This facility is compatible with future versions of Windows (the code is being written by the same developers at Microsoft). Furthermore, Microsoft licenses the Compound File source code to other vendors for use on other operating systems.<P>
A major benefit of having a single, standard implementation of structured storage on a given platform is that any application (including the system shell) can open and navigate through anyone's compound file. Elements of data are no longer hidden inside a proprietary file format. You can freely browse the hierarchy of storage and stream elements. With additional naming standards and standardized stream formats for specific information, every application can retrieve significant information from any given file without having to load the application that created that file.<P>
Microsoft Windows95 will exploit this browsing ability by offering shell-level document searching. Windows 95 looks in compound files for a stream called &quot;Summary Information,&quot; in which applications store data such as creation and modification times, author, title, subject, revision number, keywords, and so on. Windows 95 can match this information against a user query. What was once a feature buried inside applications for one document type is now a standard part of the system itself for all documents.<P>
<h3><a name="02a7_00ef">Object Persistence<a name="02a7_00ef"></h3><P>
Structured storage is necessary to allow multiple components to share the same disk file or other storage. A component indicates its ability to save its persistent state to a storage or stream by implementing the interface <I>IPersistStorage</I> or <I>IPersistStream</I>, respectively. (There is also an <I>IPersistFile</I> interface for components that save to separate files.)<P>
The container application that manages such persistent objects creates the instances of <I>IStorage</I> or <I>IStream</I> to give to components that implement <I>IPersistStorage</I> and <I>IPersistStream</I>. The container tells components to save or load their persistent states from the storages or streams. Thus, the container remains in control of the overall document or file, but gives each component individual control over a storage or stream within that file. This tends to make structures within a file more intelligent--that is, placing more of the code knowing how to handle the structures into components rather than in the container.<P>
<a href="#02a7_00fd">Example 2</A> shows how a container would open an <I>IStorage</I> and have a component save into it through <I>IPersistStorage</I>. If the component doesn't support <I>IPersistStorage,</I> then the container cannot possibly try to save the component that way. This shows the power of the <I>QueryInterface</I> function and the interface-oriented architecture of OLE. You can't ask a component to do an operation it doesn't support.<P>
<h3><a name="02a7_00f0">Persistent, Intelligent Names (Monikers)<a name="02a7_00f0"></h3><P>
Think for a moment about a conventional filename that refers to data stored somewhere on disk. The filename essentially describes the &quot;somewhere,&quot; and so the name identifies a file that could be called an &quot;object&quot; (in a primeval sort of way). However, this is limited, because filenames have no intelligence. All knowledge about how the name is used exists elsewhere, in whatever application uses that filename.<P>
Now think about a name that describes the result of a database query, or a range of spreadsheet cells, or a paragraph in a document. Then think about a name to identify a piece of code that executes some operation on a network server. Each different name, if unintelligent, would require every application to redundantly understand the use of that name. In a component-integration system, this is far too expensive. To solve the problem, OLE has &quot;persistent, intelligent names,&quot; otherwise known as &quot;monikers.&quot;<P>
A moniker is a component that encapsulates a type of name and the intelligence to work with that name behind an interface called <I>IMoniker</I>. Thus, users of the moniker pass control to the moniker whenever they want to work with the name. While <I>IMoniker</I> defines the standard operations you can perform with a moniker, each different moniker class defines what data makes up the name and how that name is used in binding. A moniker also knows how to serialize itself to a stream, because <I>IMoniker</I> is derived from <I>IPersistStream</I>.<P>
The most basic operation in the <I>IMoniker</I> interface is that of binding to the object. <I>IMoniker::BindToObject</I> runs whatever algorithm is necessary in order to locate the object of reference and returns an interface pointer to the component that works with that information (this pointer is unrelated to the moniker itself). Once a client has bound to the referenced object, the moniker falls out of the picture entirely. <P>
<h3><a name="02a7_00f1">Types of Monikers<a name="02a7_00f1"></h3><P>
OLE defines and implements five basic type of monikers: file, item, generic composite, anti, and pointer. A file moniker maintains a text filename persistently and the binding means to locate a suitable application and have it load the file (returning an interface pointer to the &quot;file&quot; object). Item monikers are used in conjunction with file monikers to describe a specific part of a file that can be treated as a separate &quot;item&quot; object. To put a file and item moniker together requires the generic composite moniker. This type exists only to contain other monikers (including other composites), and its persistent data is just the persistent data of all the contained monikers in series (separated by a delimiter). Binding a generic composite means binding those it contains in turn.<P>
A composite moniker is used whenever you cannot create a reference that is described by a single, simple moniker. A range of cells in a sheet of a Microsoft Excel workbook requires a file moniker to identify the workbook, an item to identify the sheet, and an item to identify the range in the sheet. Such a composite moniker is shown in <a href="199402ab.htm">Figure 3</A>. Code that would create this moniker is shown in <a href="#02a7_00fe">Example 3</A>.<P>
The antimoniker and pointer moniker are special types. An antimoniker annihilates the last moniker in the series in a composite. A pointer moniker wraps an interface pointer into a moniker where binding is nothing more than a <I>QueryInterface</I> call. These are provided for uniformity, and neither supports persistence.<P>
Of course, if OLE's standard monikers are not suitable for your naming purposes, you can always implement your own component with <I>IMoniker</I>. Since you encapsulate your functionality behind the interface, your moniker is immediately usable in any other application that knows how to work with <I>IMoniker</I>.<P>
Working with monikers is generally called &quot;linking,&quot; the moniker's information being the &quot;link&quot; to some other data. OLE uses monikers to implement linked compound-document objects. This involves other user-interface standards for managing links. OLE also implements a central &quot;running object table&quot; in which monikers for already-running objects are stored. This prevents excess processing when a file is already loaded or when other data is already available in some other application. <P>
<h3><a name="02a7_00f2">Uniform Data Transfer and Drag-and-Drop<a name="02a7_00f2"></h3><P>
Structured storage and monikers integrate storage and naming functions. Once you have found a component that can read from storage, you'd normally like to have it render data for you. OLE's Uniform Data Transfer mechanism is the technology for data transfers and notifications of data changes between some source (called the &quot;data object&quot;) and something that uses the data (called the &quot;consumer&quot;). All of this happens through the <I>IDataObject</I> interface implemented by the data object. <I>IDataObject</I> includes functions to get and set data, query and enumerate available formats, and establish a notification loop with the data source.<P>
The &quot;uniform&quot; aspect arises from the fact that <I>IDataObject</I> separates exchange operations (get, set, and so on) from specific transfer protocols like that of the clipboard. Thus, a data source implements one data object and uses it in any OLE transfer protocol: clipboard, drag-and-drop, or compound documents. The OLE protocols (unlike the existing Windows protocols) are only concerned with getting an <I>IDataObject</I> pointer from the source to the consumer. Once transferred, the protocol disappears and the consumer just has to deal with a uniform <I>IDataObject</I>. Source and consumers can thus implement a core set of functions based on <I>IDataObject</I> and build little protocol handlers on top of that code.<P>
<h3><a name="02a7_00f3">Data Formats and Transfer Mediums<a name="02a7_00f3"></h3><P>
Besides the separation of transfer from protocol, OLE also makes data transfer much more powerful and flexible with two data structures: FORMATETC and STGMEDIUM. FORMATETC improves on the clipboard format of Windows--hence its name (&quot;Format_&quot;). The Windows clipboard format only describes the layout of a data structure (for example, CF_TEXT describes a null-terminated ANSI character string). FORMATETC adds a detail field (full content, thumbnail sketch, and so on), a device description (the device for which the data is rendered), and a transfer-medium identifier.<P>
This last field brings us to STGMEDIUM, an improvement over the global memory handles. Existing Windows protocols only allow data exchange via global memory, which can be inefficient for large data. STGMEDIUM allows you to reference data stored in either global memory or in another medium--which could be a disk file, an <I>IStorage,</I> or an <I>IStream</I>.<P>
Together, FORMATETC and STGMEDIUM allow you to keep data stored in the most appropriate (and efficient) medium and still ship it off to other applications. This can result in significant performance gains for applications that would otherwise load large data sets into global memory, only to have these swapped out to disk again by the virtual-memory system.<P>
<h3><a name="02a7_00f4">Clipboard and Drag-and-Drop<a name="02a7_00f4"></h3><P>
Other OLE technologies build upon the uniform data-transfer concept so you can take advantage of the improvements, regardless of how you transfer data.<P>
First, the OLE DLLs provide functions to work with the system clipboard through <I>IDataObject</I>. A source cuts or copies data by packaging it into a data object and handing an <I>IDataObject</I> pointer to OLE's <I>OleSetClipboard</I> function. OLE, in turn, makes the formats therein available to all other applications (non-OLE applications can only see global-memory-based formats). When a consumer of data wants to paste from the clipboard, it calls <I>OleGetClipboard</I> to obtain an <I>IDataObject</I> representing the clipboard contents. Through <I>IDataObject,</I> the consumer checks formats or requests renderings. Data placed on the clipboard by non-OLE applications are completely available through this interface. So, you can toss out your old clipboard code and switch easily to the more powerful OLE mechanism.<P>
Another technology that builds on data transfer is OLE's Drag-and-Drop feature, really nothing more than a slick way to get an <I>IDataObject</I> pointer from a source to a consumer, or &quot;target.&quot; The source decides what starts a drag-and-drop operation (usually a mouse click-plus-move in a specific place). It then packages up its data into a data object--exactly as it does for the clipboard--and calls OLE's <I>DoDragDrop</I>, passing a pointer to its implementation of the <I>IDropSource</I> interface. Through this interface, the source controls the mouse cursor and drop or cancellation times.<P>
The target, on the other hand, implements the interface <I>IDropTarget</I> and registers it with OLE for a specific window. When the mouse moves over that window, OLE calls functions in that <I>IDropTarget</I> according to what is happening with the mouse: enter window, move in window, leave window, or drop in window.<P>
In these functions, the target indicates the effect of a drop at the mouse location point, modified by the Ctrl and Shift keys. Valid effects are a move (no keys), copy (Ctrl), link (Shift+Ctrl), or &quot;no-drop.&quot; These are specified using DROPEFFECT_* flags. The effect is handed back to the source to indicate which cursor to show; see <a href="199402ac.htm">Figure 4</A>. These default cursors are handled by OLE itself, leaving little for the source to do, as shown in the typical implementation of <I>IDropSource</I> (excluding <I>IUnknown</I> functions) in <a href="#02a7_00ff">Example 4</A>. Sources do have the ultimate say as to which cursor is shown, of course.<P>
Note that <I>DoDragDrop</I>, in addition to watching mouse motion and the Ctrl/Shift keys, also watches the Esc key (used to cancel the operation) and the mouse button for an &quot;up&quot; message (used to cause a drop), as illustrated in <a href="199402ad.htm">Figure 5</A>.<P>
When a drop occurs on a target, that target just ends up with the source's <I>IDataObject</I> pointer--exactly as it would after a call to <I>OleGetClipboard</I>. At this point, the transfer protocol again disappears, and the consumer only must deal with <I>IDataObject</I>. The same is true for the source, which packages data into a data object for clipboard or drag-and-drop. Because drag-and-drop works equally well within and between applications, you get considerable mileage from one piece of code. The icing on the cake is that by adding a few formats for compound-document objects, you can suddenly start exchanging compound-document objects and controls by using the same protocols and the same code!<P>
<h3><a name="02a7_00f5">Notification<a name="02a7_00f5"></h3><P>
Consumers of data from an external source might want to know (asynchronously) when data in that source changes. OLE handles notifications of this kind through a component called an &quot;advise sink&quot; that implements an interface called <I>IAdviseSink</I>. This &quot;sink&quot; absorbs asynchronous notifications from a data source and can receive a new copy of the data if desired. The consumer that implements the advise sink connects it to the source's <I>IDataObject</I> through a member function called <I>DAdvise</I>. Disconnection happens through <I>DUnadvise</I>. In making the connection, the consumer indicates whether it would like a fresh data rendering. When the data object detects a change, it then calls <I>IAdviseSink::OnDataChange</I> to notify the consumer, as shown in <a href="199402ae.htm">Figure 6</A>.<P>
The <I>IAdviseSink</I> interface contains additional member functions that are used with other interfaces (such as <I>IViewObject</I> for notifications when a component's display image changes and <I>IOleObject</I> for state changes in compound-document objects). However, it's not designed to handle arbitrary notifications from arbitrary components. Such a task requires &quot;events,&quot; which are introduced with OLE Controls (but which are more fundamental than controls, of course). OLE Controls are discussed a bit later.<P>
<h3><a name="02a7_00f6">OLE Automation<a name="02a7_00f6"></h3><P>
Another key aspect of integrating components is the ability to drive them programmatically--that is, to control them without requiring an end user's presence. This means having components expose their end-user functionality (for example, menu commands and dialog-box interaction), as well as properties by way of interfaces so that a scripting tool can be used to invoke that functionality.<P>
There are two sides to this picture. On the one hand are components that are programmable by way of interfaces, or &quot;automation objects.&quot; On the other hand is an application that provides a programming environment in which a developer or advanced user can write scripts or create applications that use other automation objects. These are called &quot;automation controllers.&quot; To make all this happen, objects need a way to programmatically publish their interfaces (the method names and parameter types, as well as object properties) at run time such that the controller can perform type-checking and present lists of callable functions to the programmer.<P>
The technology that supports this is OLE Automation, primarily through an interface called <I>IDispatch</I>. Applications that expose functions and properties for various application objects (the window frame, document windows, parts of the document, and so on) do so by implementing <I>IDispatch</I> on each of those components. However, <I>IDispatch</I> has only a fixed set of member functions. How, then, does each component supply its unique features?<P>
The answer is an OLE Automation entity called the &quot;dispinterface&quot;--an implementation of <I>IDispatch</I> that responds to a specific set of custom methods and properties. An application frame and a document would both implement <I>IDispatch,</I> but would have different dispinterfaces.<P>
Dispinterface uses the function <I>IDispatch::Invoke</I>, the prototype for which is shown in <a href="#02a7_0100">Example 5</A>. The <I>dispID</I> &quot;dispatch identifier&quot; parameter tells <I>Invoke</I> which method is being called, or which property of this object is being get or set. The <I>wFlags</I> parameter indicates whether this call to <I>Invoke</I> is a method call or a property get or set operation. An object's dispinterface, then, is primarily the set of <I>dispID</I>s to which the object will respond through <I>Invoke</I>, and this varies from object to object, of course. Since some methods take parameters, and properties have types associated with them, the dispinterface also includes all of this &quot;type information.&quot; Other functions in <I>IDispatch</I> make the type information available to automation controllers, so those controllers can use the types to enhance their programming environments.<P>
When creating an automation object, you create a file using the Object Definition Language (ODL) to define a dispinterface. This file is then run through a special compiler that generates a &quot;type library&quot; containing all the type information for any number of automation objects and dispinterfaces. This type library, which can be kept in a separate file or attached to a server module (DLL or EXE) as a resource, provides a way for automation controllers to discover what automation objects and dispinterfaces are available, without actually having to instantiate components just to ask for the information through <I>IDispatch</I>.<P>
The type library itself is a component that implements the interfaces <I>ITypeLib</I>, <I>ITypeInfo</I>, and <I>ITypeComp</I>. You generally don't have to implement these interfaces. OLE provides the implementations that work on any underlying type library. Automation controllers use these interfaces to navigate through all the information in the library so as to present the programmer with lists of callable functions on an object, to extract parameter types to perform checking, and so forth.<P>
Visual Basic (VB) and the related dialect Visual Basic for Applications are both automation controllers. When you run a piece of VB code such as that shown in <a href="#02a7_0101">Example 6</A>, VB will translate the method calls and property manipulations in the VB code that uses the dot operator into <I>IDispatch::Invoke</I> calls to the component in question. Ultimately, all the calls are being made through the binary standard of COM interfaces, so VB doesn't care what language was used to implement the automation object.<P>
This illustrates the integration power of automation. VB can create and manage many automation objects from many different applications at once, and use them to programmatically combine information from a variety of sources. Automation is exceptionally powerful for developers who are using off-the-shelf applications such as Microsoft Word or Shapeware Visio to create custom solutions. Adding automation support to an application opens up that application to a tremendous number of new uses. In addition, developers can encapsulate business logic into components, and make this functionality accessible through high-level, third-party tools, including fourth-generation programming languages and even productivity-application macro languages.<P>
<h3><a name="02a7_00f7">OLE Documents<a name="02a7_00f7"></h3><P>
Built on top of Structured Storage, Uniform Data Transfer, and Monikers, is the technology known as &quot;OLE Documents.&quot; This technology supports the creation and management of compound documents. Two types of components are at work here. The container is the component that controls the document and manages relationships between the pieces of information in that document (such as layout). Compound-document objects are pieces that make up the content put into that document, and these pieces are supplied by servers (DLLs or EXEs).<P>
OLE Documents is thus a way to integrate containers and servers through compound-document objects. The objects themselves can be shared in two ways. The first is embedding, where the entire object is &quot;embedded&quot; within the container--that is, the object's persistent state is kept in the document itself. Embedded objects always implement the <I>IPersistStorage</I> interface for this purpose, and containers that support embedding typically use a compound file to provide <I>IStorage</I> instances to embedded objects (but they don't have to).<P>
The other way to share an object is linking, in which a graphic image of the object is cached in the container document along with a moniker that refers to the location of the object's actual data. The object's persistent state exists elsewhere, and the moniker provides the link to that data. Since a moniker can be as complex as desired, the path from the compound document to the source of the link can be very complex. Therefore, a document can contain linked objects to things as simple as a file, or as complex as a cell in a table in a document that is embedded within an e-mail message that exists in a particular field of a database on a particular network server. Monikers impose no limits.<P>
Embedding is normally optimal for objects with small data sets, while linking is more efficient for large data sets (especially ones that are shared between multiple users on a network). Each link is a reference to a single source. By contrast, embedding the data means making a copy.<P>
<h3><a name="02a7_00f8">Compound-Document Objects<a name="02a7_00f8"></h3><P>
Compound document objects are nothing more than regular OLE objects that have a particular combination of interfaces. This is shown in <a href="199402af.htm">Figure 7</A>, along with the interfaces a container exposes to its objects. Note that the object interfaces shown in the figure are those seen by the container. Those in parentheses are implemented only by objects in DLLs. Those in EXEs implement only the unmarked interfaces and rely on DLL &quot;object handlers&quot; for the others.<P>
The most important interfaces are <I>IPersistStorage</I>, <I>IDataObject</I>, <I>IViewObject2</I>, and <I>IOleObject</I>. The first two interfaces mean that compound-document objects support persistence to <I>IStorage</I> elements and that they support exchange of their data--primarily bitmap and metafile renderings of their display images that can be cached and displayed in the document. Caching allows the container to open a document for viewing or printing even when the code to handle the object is unavailable--the cached images are suitable for these purposes.<P>
If an object implements the <I>IViewObject2</I> interface, it has the ability to render itself directly to an hDC, usually the screen DC of the container's display or a printer DC on which the document is being printed. This gives control over rendering quality to the object itself. This interface is not limited to compound documents. Any object can implement it and possess this ability. <P>
<I>IOleObject</I> is the primary (and rather sizable) interface that says, &quot;This object supports the OLE Documents standard for compound documents.&quot; A container uses this interface for many purposes, the most important of which is activation. Activation means instructing the object to perform some action, called a &quot;verb.&quot; The container will, as part of its user interface, show these verbs to the end user and forward them to the object when the user selects them. The object has full control over what verbs it wants to expose. Many objects have an &quot;Edit&quot; verb, which means &quot;display a window in which this object's data can be modified.&quot; Others, like a sound and a video clip, have a &quot;Play&quot; verb, which means &quot;play the sound&quot; or &quot;run the video.&quot; While the object defines what verbs it supports and what those verbs mean, the container is responsible for making the commands available to the end user and invoking them when necessary.<P>
On the other side of the fence, the container must provide a &quot;site&quot; object for each embedded or linked object in the container. The site implements the interfaces <I>IOleClientSite</I> (which provides container information to the object) and <I>IAdviseSink</I> (which notifies the container when changes occur).<P>
<h3><a name="02a7_00f9">In-Place Activation<a name="02a7_00f9"></h3><P>
In cases other than playing a sound or a video clip, activation of an object generally requires that the object display another window in which the operation takes place (such as editing). For example, if you have a table from a spreadsheet embedded within a document, and you would like to edit that table, you would need to get the table back into the spreadsheet application to make changes. Right?<P>
Not necessarily. OLE Documents includes In-Place Activation, also known as Visual Editing. This is a set of interfaces and negotiation protocols through which the container and the object merge their user-interface elements into the container's window space. In-place activation allows the object to bring its editing tools to the container, instead of taking the object to the editing tools. This includes menus, toolbars, and small child windows that are all placed within the container.<P>
A number of interfaces are required to make all this work, on both the container and compound-document object. The interface names all start with the prefix <I>IOleInPlace</I>. By way of these interfaces, the two sides can create a mixed menu (composed of pop-up menus from both container and object), share keyboard accelerators, and negotiate the space around the container's frame and document windows in which the object would like to display toolbars and the like.<P>
Because in-place activation is handled solely through additional interfaces for both container and object, support for it is entirely optional (but encouraged, of course). If a fully in-place-capable container meets an in-place-capable embedded object, then they achieve a high level of integration. If either side doesn't support the technology, however, then they can still work together by using the lower-level activation model that requires a separate window. Even when in-place is supported all around, the user can still decide to work in a separate window if desired.<P>
In-place activation is not limited to just activating one object at a time, or activating objects only on user command. Objects can mark themselves to be in-place activated, without the mixed menu or toolbar negotiation, whenever visible. This means that each object can have an editing window in its space in the container. These objects respond immediately to mouse clicks and the like because their windows are in the container, and those windows receive the mouse messages. Only one object, however, can be &quot;UI Active,&quot; which means that its menus and toolbars are also available. Of course, the UI Active object switches (and the user interface changes correspondingly) as the user moves between objects.<P>
With multiple objects active within a document, you can imagine how useful it would be if some of those objects were buttons or list boxes. You could create forms with such objects, and create an arbitrary container that could hold objects from any source and benefit from all the other integration features of OLE. This is the reason for OLE Controls.<P>
<h3><a name="02a7_00fa">OLE Controls<a name="02a7_00fa"></h3><P>
An OLE Control is a compound-document object extended with Automation to support properties and methods through <I>IDispatch</I>. It relies on a mechanism called an &quot;event,&quot; a notification that is fired whenever something happens to the controls (such as a state change or user input). A control transforms different types of external events such as mouse clicks and keystrokes (or application-specific events like the pickle vat on the factory floor springing a leak) into meaningful programmatic events. When these programmatic events occur, an event handler can execute code--such as showing a button pressdown, transmitting a character over a modem, or calling the pickle-vat repair company.<P>
For the most part, OLE Controls is a set of extensions to the other OLE technologies such as Structured Storage (by way of adding an <I>IPersistStreamInit</I> interface) and automation (adding new ODL attributes for dispinterfaces, methods, and properties). OLE Controls defines a generic notification mechanism called &quot;Connectable Objects&quot; that is used to connect some sink object to a source, where the source wishes to call the functions of a certain interface implemented on the sink. This is like the <I>IAdviseSink</I> interface working with <I>IDataObject</I>, but more generic. This mechanism is used to implement events are actually meaningful and useful outside of controls. An object expresses the events it can fire as a dispinterface, which the event handler (such as a container application) implements with an <I>IDispatch</I> and connects to the object using the connectable objects technology. A similar extension involves property-change notification, which applies very well to controls, but is useful for any object that has properties of any kind to notify a sink when those properties change.<P>
OLE Controls also introduces a technology called &quot;Property Pages.&quot; This is a flexible user-interface model that any object can use to allow an end user to directly modify its properties. A property page is easily integrated into a tabbed dialog box, along with property pages from other objects as well, to create a consistent, easy-to-use environment for manipulating such data.<P>
The new interfaces involved for connectable objects, property pages, property-change notification, and events make up the bulk of the additions to an OLE control over a regular in-place compound-document object. So, what actually is specific to controls? Not a lot, but a few key enhancements to the OLE Documents technology (through the interfaces <I>IOleControl</I> and <I>IOleControlSite</I>) comprise the final difference between a compound-document object and a control. For example, in compound documents, only the UI Active object can trap keyboard messages. By contrast, any control in a form or document should be able to respond to keystrokes at any time, so OLE Controls provides the mechanism to make it work. OLE Controls also defines mechanisms for handling special controls like labels, pushbuttons (where one can be the &quot;default&quot;), and exclusive button sets. In addition, the container application that manages the controls exposes a set of &quot;ambient properties&quot; (through a dispinterface) to all the controls to provide general defaults (such as colors and fonts). These additions, combined with property pages, property-change notification, events, and automation enhancements, make up &quot;OLE Controls.&quot;<P>
Since being a control or a container for controls is primarily being a compound-document object or container, OLE Controls leverages any work you do to support OLE Documents. Furthermore, applications such as Microsoft Access and Visual Basic support OLE Controls in form creation. With a few good controls, you can quickly create powerful front ends or custom business solutions with a minimal amount of code--all you have to do is add some VB code to the event handlers that these applications supply. As happened with VBX controls, you can expect the market to provide numerous, useful third-party OLE controls.<P>
<h3><a name="02a7_00fb">Conclusion<a name="02a7_00fb"></h3><P>
OLE is about integration on many levels. Components can come in various forms, be they simple functional objects with a straightforward interface (such as a string object), automation objects, data sources, compound-document objects, or controls.<P>
Implementing a simple OLE object is very easy (as it should be). Implementing support for more complex technologies like compound documents and controls is a little more complex, but more help (in the form of books, articles, and tools) is available to developers as each month passes.<P>
For example, Visual C++ 1.5 supports OLE by way of the Microsoft Foundation Classes (MFC), which greatly simplifies adding OLE automation, drag-and-drop, and compound documents to your app. Visual C++ 2.0 adds support for OLE Controls.<P>
Regardless of your tools, if integration is what you seek, OLE is an answer. OLE helps you integrate components with many features and capabilities, allowing the features of those components to evolve over time. OLE is a complete solution to integration that will grow over time, to support distributed objects, for example, without requiring changes to existing code. Together, the integration technologies in OLE may make the dream of true component software become a reality.<P>
<a href="199402b0.htm">Figure 1</A>  All OLE technologies build upon COM and one another.
<a href="199402b1.htm">Figure 2</A>  Structured Storage sits above a file as a file system sits above a disk volume.
<h4><a name="02a7_00fc"><B>Example 1: Comparison of code to read a structure from:</B> (a) a Win32 file; and (b) a stream.<a name="02a7_00fc"></h4><P>
<pre>(a) BOOL MyObject::ReadFromFile
      (LPSTR pszFile)
      {
      OFSTRUCT     of;
      HFILE        hFile;
      UINT         cb=-1;
      if (NULL==pszFile)
          returnFALSE;

      hFile=OpenFile(pszFile, &amp;of,OF_READ);
      if (HFILE_ERROR==hFile)
          return FALSE;

      cb=_lread(hFile, (LPSTR)&amp;m_data, sizeof(MYDATA));
      _lclose(hFile);
      return (SIZEOF(MYDATA)==cb);
    }

(b) BOOL MyObject::ReadFromStorage
      (LPSTORAGE pIStorage)
      {
      HRESULT        hr;
      IStream       *pIStream;
      LARGE_INTEGER  li;
    
      if (NULL==pIStorage)
          return FALSE;

      hr=pIStorage-&gt;OpenStream(&quot;MyStruct&quot;, 0
          ,STGM_DIRECT | STGM_READ
          | STGM_SHARE_EXCLUSIVE, 0, &amp;pIStream);

      if (FAILED(hr))
          return FALSE;

      hr=pIStream-&gt;Read((LPVOID)&amp;m_data
          , sizeof(MYSTRUCT), NULL);
      pIStream-&gt;Release();
      return (SUCCEEDED(hr));
      }
</pre><P>
<h4><a name="02a7_00fd"><B>Example 2:</B> Saving persistent data through IPersistStorage.<a name="02a7_00fd"></h4><P>
<pre>BOOL SaveObject(IStorage *pIStorage, IUnknown *pObject)
    {
    IPersistStorage *pIPS;
    HRESULT          hr;
    hr=pObject-&gt;QueryInterface(IID_IPersistStorage, (void **)&amp;pIPS);
    if (SUCCEEDED(hr))
        {
        hr=pIPS-&gt;Save(pIStorage);
        pIPS-&gt;SaveCompleted(NULL);
    }
    return SUCCEEDED(hr);
    }</pre><P>
<a href="199402b2.htm">Figure 3</A>  A sample composite moniker with a file and two item monikers to identify a range of cells in a particular sheet of a spreadsheet file.
<h4><a name="02a7_00fe"><B>Example 3:</B> Code that creates a composite moniker with a file and two items.<a name="02a7_00fe"></h4><P>
<pre>IMoniker * MakeMonikerToRange(char *pszFile, char *pszSheet
    , char *pszRange)
    {
    IMoniker *pmkComp, *pmkFile, *pmkSheet, *pmkRange;    pmkComp=NULL;
    //&quot;!&quot; is a delimeter between monikers
    if (SUCCEEDED(CreateItemMoniker(&quot;!&quot;, pszRange, &amp;pmkRange)))
        {
        if (SUCCEEDED(CreateItemMoniker(&quot;!&quot;, pszSheet, &amp;pmkSheet)))
            {
            if (SUCCEEDED(CreateFileMoniker(&quot;!&quot;, pszFile, &amp;pmkFile)))
                {
                //This creates a File!Item(Sheet) composite
                if (SUCCEEDED(CreateGenericComposite(pmkFile, pmkSheet
                    , &amp;pmkComp)))
                    {
                    //Tack on the range to the File!Item(Sheet)
                    if (FAILED(pmkComp-&gt;ComposeWith(pmkRange, FALSE)))
                        {
                        pmkComp-&gt;Release();
                        pmkComp=NULL;
                        }
                    }
                pmkFile-&gt;Release();
                }
            pmkSheet-&gt;Release();
            }
        pmkRange-&gt;Release();
        }
    return pmkComp;
    }</pre><P>
<a href="199402b3.htm">Figure 4</A>  Cursors used in Drag-and-Drop.
<h4><a name="02a7_00ff"><B>Example 4:</B> The usual implementation of an IDropSource interface.<a name="02a7_00ff"></h4><P>
<pre>STDMETHODIMP CDropSource::QueryContinueDrag(BOOL fEsc, DWORD grfKeyState)
    {
    if (fEsc)
        return ResultFromScode(DRAGDROP_S_CANCEL);
    if (!(grfKeyState &amp; MK_LBUTTON))
        return ResultFromScode(DRAGDROP_S_DROP);
    return NOERROR;
    }
STDMETHODIMP CDropSource::GiveFeedback(DWORD dwEffect)
    {
    return ResultFromScode(DRAGDROP_S_USEDEFAULTCURSORS);
    }</pre><P>
<a href="199402b4.htm">Figure 5</A>  The DoDragDrop function enters a message loop that watches the mouse and keyboard and calls the IDropSource and IDropTarget functions.
<a href="199402b5.htm">Figure 6</A>  A source notifies a consumer of data changes through IAdviseSink.
<h4><a name="02a7_0100"><B>Example 5:</B> Signature of the IDispatch::Invoke function.<a name="02a7_0100"></h4><P>
<pre>interface IDispatch : public IUnknown
    {
    ...
    virtual HRESULT Invoke(DISPID dispID, REFIID riid, LCID lcid,
         WORD wFlags, DISPPARAMS *pdispparams,  VARIANT *pvarResult,
         EXCEPINFO *pexcepinfo, UINT *puArgErr)=0;
    }</pre><P>
<h4><a name="02a7_0101"><B>Example 6:</B> Visual Basic code that translates to IDispatch calls.<a name="02a7_0101"></h4><P>
<pre>Sub Form_Load ()
    Dim Cube as Object
    Set Cube = CreateObject(&quot;CubeDraw.Object&quot;)   'Creates the object
    'Each line of code here calls IDispatch::Invoke with different flags
    x = Cube.Theta                        'Property Get on &quot;Theta&quot;
    Cube.Declination=.0522                 'Property Set on &quot;Declination&quot;
    Cube.Draw                             'Method call
End</pre><P>
<a href="199402b6.htm">Figure 7</A>  The interfaces of a compound-document object and container.
<P>
<HR><P>Copyright &copy; 1994, <I>Dr. Dobb's Journal</I></P></BODY></HTML>
