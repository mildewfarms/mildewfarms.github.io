<HTML>
<META NAME="year" CONTENT="1994">
<HEAD>
<TITLE>SP 94: sGs: A Simple Gopher Server </TITLE></HEAD>
<BODY BGCOLOR="#ffffff">
<h1>sGs: A Simple Gopher Server <a name="023f_00c6"></h1><P>
<h2><a name="023f_00c4"><a name="023f_0000">A menu-based searching utility--written in Perl!</h2><P>
<h3>Bob Kaehms and Jonny Goldman</h3><P>
<p><i><a name="023f_00c5"><a name="023f_0000">The authors are programmers in the San Francisco Bay Area. Bob can be contacted at cames@well.sf.ca.us and Jonny at jonny@synopsys.com.</i></p><hr><P>
If you've followed the explosive growth in network activity, you know that three predominant applications--Gopher, Wide Area Information Servers (WAIS), and the World Wide Web (WWW)--have transformed the use of the Internet.<P>
WAIS, developed by Thinking Machines Corp. (Cambridge, MA) is a client/server full-text search system based on a standard library-science network protocol (ANSI Z39.50--1988). Gopher, developed by the microcomputer laboratory of the University of Minnesota, is a menu-based Campus Wide Information System (CWIS) that simplifies the dissemination of information by presenting a uniform user interface to the campus network (and the Internet as a whole). The World Wide Web, developed at the European Laboratory for Particle Physics (CERN) in Geneva, is a distributed hypertext system designed to provide a way for physicists to collaborate on research in high-energy physics.<P>
Along with networking tools such as ftp, telnet, usenet, and mail, Gopher, WAIS, and WWW each have a place in the overall design of an information infrastructure. In this article, we'll present a simple Gopher server written in Perl and discuss the basic Gopher protocol. We'll also show how this server can be extended and combined with other Internet tools to provide more sophisticated network information systems.<P>
<h3><a name="023f_00c7">About Gopher<a name="023f_00c7"></h3><P>
The Gopher protocol is a file-system-based model extended to allow &quot;files&quot; to reside on many computers. Clients (often, but not exclusively, represented as user interfaces) run on a local computer connected to a server which manages the information (the files). The Gopher protocol was designed to be human-readable, so all transactions through the protocol are done using the U.S. ASCII character set and consist of lines separated by carriage return/line feed (CR/LF). The first character on the line is a tag that informs the client that the remaining information on the line is of a particular, well-defined type. The types specified by the original protocol were minimal: just enough to provide a simple interface to a distributed file system. This base set included ASCII files (tag=0), directory listings (tag=1), or searchable indexes (tag=7). <a href="#023f_00d0">Table 1</A> presents the complete list of types.<P>
The Gopher protocol can be extended by defining additional tags, although 0 through Z have been reserved by the original developers. Gopher+, a new Gopher protocol, extends this idea, passing additional type information both through a filename extension (such as movie.mpg), and by appending information to the original Type-1 response returned by the server.<P>
<h3><a name="023f_00c8">Type 1: A Directory Listing<a name="023f_00c8"></h3><P>
Much of the work in Gopher is done through Type 1 responses, which consist of a set of lines, each containing a single character type. This is followed by a tab-separated quadruple (4-tuple) of a string to be displayed as the heading by the client, a selector string that can be returned to the server for subsequent processing, a host name (usually the server), and a TCP port.<P>
<a href="#023f_00cd">Figure 1</A>, which is a typical Type 1 response, shows that an item is an ASCII file. The client would display the string following the &quot;0&quot; up to the first tab as a menu item (<I>About this Gopher Article</I>). The remaining information (<I>0/About this GopherArticle&lt;tab&gt;g.host&lt;tab&gt;port&lt;CR&gt;&lt;LF&gt;</I>) is used to retrieve the next piece of information. The client parses this substring to get the selector, the host, and the port. In this example, the client makes another connection to the host <I>gopher.host</I> via a socket connection at port 70 and sends the string<I>0/About this GopherArticle&lt;CR&gt;&lt;LF&gt;</I> to the Gopher server to request the item referred to in the previous response. All requests from the client are performed in a single TCP/IP connection and are terminated by a CR/LF. The server responds to the request and closes the connection.<P>
<h3><a name="023f_00c9">Why sGs?<a name="023f_00c9"></h3><P>
Faced with uncertain commercial-use licensing for the University of Minnesota's Gopher server, we decided to develop a simple prototype server to help bootstrap Lockheed onto the information highway. This code is a modification of the Perl program waismail.pl (written by Jonny Goldman), which is a gateway to the WAIS systems through Internet electronic mail. <P>
In providing a systems-engineering organization with a graphical front end to existing, internally written requirements-traceability software, we saw an opportunity to explore solutions to information processing available on the Internet. We chose to implement a client/server system based on the emerging technologies of WAIS and Gopher.<P>
We leveraged our efforts against other pockets of Internet development existing in the corporation. Known as the &quot;Technology Broker System&quot; (TBS), the aim of our project was to simplify and validate the terminology of the Internet within the Lockheed corporate community. sGs quickly took off inside the corporation because it was highly portable and easy to configure. (See <I>Information Week</I>, June 27, 1994, for more information on Lockheed and the Internet.) <P>
<h3><a name="023f_00ca">sGs Code<a name="023f_00ca"></h3><P>
As <a href="#023f_00d9">Listing One</A> illustrates, sGs is an excellent example of a hacker's program. It was my second attempt at a real Perl program, with a little help from &quot;the net,&quot; especially Jonny Goldman, who was  still actively supporting the Public Domain WAIS software at the time. My first program was a modification of Jonny's public-domain waismail.pl program so that it could be used for handling additions, modifications, and deletions to WAIS databases.<P>
sGs is built upon the simple client/server socket example in <I>Programming Perl,</I> by Larry Wall (O'Reilly &amp; Associates, 1990). As you examine the code, notice that the subroutine <I>initialize_socket()</I> looks similar to the sample server code of his book. Wall notes how concisely the socket, bind, listen, and accept calls can be written in Perl; see <a href="#023f_00ce">Example 1</A>. For more information on Perl, we recommend both Wall's book and &quot;Networking with Perl,&quot; by Oliver Sharp (<I>DDJ</I>, October 1993). The client/server example in Wall's book provides a firm foundation on how sockets work. In <a href="#023f_00ce">Example 1</A>, the subroutine creates and initializes a socket to which clients can connect.<P>
We extended Wall's example in two ways: First, instead of echoing the lines sent by the client as Wall did, the server interprets the string (up to the CR/LF) and acts upon it in some way. Second, we reap the child processes spawned to handle each request that would otherwise become &quot;zombies.&quot; <P>
All of this fits neatly into the <I>trap_gophers</I> subroutine which forms the core event loop in the server; see <a href="#023f_00cf">Example 2</A>. <I>trap_gopher</I> simply sits and waits for connections on the open socket. (Imagine a cat sitting patiently on the back lawn waiting for gophers. When it sees one, it has a kitten that chases and eats the gopher. When the kitten is finished, the parent cat consumes the kitten.)<P>
This completes the basic mechanics of the server. For requests made to the server by the client, we'll start with the simplest request: a &quot;Type 0&quot; request which is used to retrieve a plain text (ASCII) file. The section of <a href="#023f_00cf">Example 2</A> beginning with <I>while (&lt;NS&gt;) { _</I> illustrates how this is implemented. In effect, this code works as follows:<P>

<OL>
<LI>Wait for input on the socket.</LI>
<LI>Check to make sure the request is valid. This has the side-effect of removing the first character from the input line and putting the result in the variable <I>$request</I>.</LI>
<LI>Check to see if the first character of the line is the number 0.</LI>
<LI>If so, execute the subroutine <I>sendfile</I>.</LI>
</OL>

Perl provides an easy mechanism for handling lines. We have created a stream called &quot;NS&quot; from the socket using the <I>accept</I> call and processed it one record at a time with the <I>while(&lt;NS&gt;)</I> call. By default, the end of a record in Perl is CR/LF. Conveniently enough, this is the end of a Gopher request. If this subroutine fails to recognize a valid type--the first character of the line--it simply closes the socket.<P>
This routine does some simple preprocessing of the request string, which is passed to the subroutine through the Perl variable <I>$request</I>. The subroutine <I>send-file</I> (see <a href="#023f_00d1">Example 3</A>) prepends the Gopher root-level data directory to the request, opens the file, and sends it back to the client one line at a time. If the file doesn't exist, the connection simply closes.<P>
The Type 1 request is similar. We prepend the root-level Gopher directory to the request. If the directory is dynamic, we create a directory listing using the UNIX <I>ls</I> command and process the output, tagging the resulting lines with the base Gopher types and processing any link files that might be found. If the directory is static, we just open the &quot;cachefile&quot; and send it back to the client; see <a href="#023f_00d2">Example 4</A>. Note that the server sets the type using filename extensions and the standard UNIX tests for binary, text, and directory.<P>
In the Type 7 request section, the server implements a gateway to a search tool, in this case, WAIS. The subroutine <I>wa2go</I> (see <a href="#023f_00d3">Example 5</A>) serves two functions: First, it takes a list of keywords, which it hands to the WAIS server. It receives the list of results from the WAIS server and rewrites them to conform to the Gopher protocol before returning them to the client. Second, it receives a result from a previous search, rewrites it to the WAIS protocol, and passes that back to the WAIS server. It receives the result from the WAIS server and passes that back to the client. It would be relatively simple to replace the WAIS gateway with a gateway to some other search tool (like UNIX grep, for instance).<P>
There are several ways that sGs can be configured. Modifications can be made directly to the code inside the subroutine <I>init_program_vars</I>. Configurable parameters can also be passed to the program as command-line options or through a configuration file. Perl allows for a simple syntax for processing the command line. In <a href="#023f_00d4">Example 6</A>, <I>@ARGV</I> is an array containing the command line. Elements from the array are shifted into the stream variable <I>$_</I> and processed until the end of the array is reached. The variables themselves can be easily understood by looking at a configuration file such as <a href="#023f_00d5">Example 7</A>, where the server would be started either from a command line, or through an rc file as: <I>sGs -c sGs.cnf</I>.<P>
If the server is running with dynamic menuing, link files can also be placed in any directory below Gopher root and are identified as &quot;dot&quot; files. The server assumes that any such dot file is a link and tries to process it accordingly. If it finds any data within the file that it doesn't understand, it exits the subroutine, ignoring the file; see <a href="#023f_00d6">Example 8</A>. These link files are what makes Gopher so powerful and allow a Gopher administrator to tunnel far and wide throughout the Internet. <a href="#023f_00d7">Example 9</A> is an example link file conforming to sGs's format.<P>
Provided that you were &quot;on the net,&quot; putting such a link into your Gopher data directory would let you jump to the place where it all started, where you would find plenty of additional information and support.<P>
<h3><a name="023f_00cb">Conclusion<a name="023f_00cb"></h3><P>
By utilizing this type of server, an organization can utilize other freely available software--in particular, clients for most hardware platforms. <a href="#023f_00d8">Table 2</A> is a short list of what's currently available.<P>
Also, keep in mind that the official Gopher software is always available from boombox.micro.umn.edu and should not be overlooked when considering an information architecture. The Gopher team provides excellent support and constant improvements to their code, such as the three-dimensional-space user interface for Gopher that's currently under development.<P>
As a development platform, Perl provides a rich, portable language for developing network-based services. Organizations need access to the huge amounts of information available on the net, and they need to provide customized servers to their users. sGs is a marriage of two useful tools that provide such a solution.<P>
<h3><a name="023f_00cc">References<a name="023f_00cc"></h3><P>
Wall, Larry and Randall Schwartz, <I>Programming Perl</I>. O'Reilly &amp; Associates, 1992. <P>
Anklesaria, A. et al. RFC 1436 &quot;The Internet Gopher Protocol&quot; available from ftp.internic.net.<P>
&quot;Guide to Network Resource Tools.&quot; EARN Association, May 20, 1994, Document Number: 3.0. Available in electronic form from LISTSERV@EARNCC.EARN.NET (or LISTSERV@EARNCC.BITNET). Send the command: GET filename where the filename is either: NETTOOLS PS or NETTOOLS TXT. <P>
Kahle, Brewster. &quot;Wide Area Information Servers.&quot; April, 1991. One-page overview of Internet release of WAIS. Available via anonymous ftp: /pub/wais/wais-discussion/wais-overview.text@quake.think.com or WAIS server wais-discussion-archive.src.<P>
Sharp, Oliver &quot;Networking With Perl.&quot; <I>Dr. Dobb's Journal</I> (October 1993).<P>
<h4><a name="023f_00cd"><B>Figure 1:</B> A Type 1 response.<a name="023f_00cd"></h4><P>
<pre>0About this Gopher  
 Article&lt;tab&gt;0/gopher-data/About&lt;tab&gt;gopher.host&lt;tab&gt;70&lt;CR&gt;&lt;LF&gt;

* &lt;tab&gt; = ASCII 9
  &lt;CR&gt;  = ASCII 13
  &lt;LF&gt;  = ASCII 10
</pre><P>
<h4><a name="023f_00ce"><B>Example 1:</B> This code creates and initializes a socket to which clients can connect. The variable $WNOHANG is used to collect child processes that would otherwise result in  &quot;zombie'' processes.<a name="023f_00ce"></h4><P>
<pre>sub init_socket {

 $AF_INET = 2;
 $SOCK_STREAM = 1;
 $sockaddr = 'S n a4 x8';
($name, $aliases, $proto) = getprotobyname('tcp');
 if ($port !~ /^\d+$/) {
  ($name, $aliases, $proto) = getservbyport($port, 'tcp');
 }
 $this = pack($sockaddr, $AF_INET, $port, &quot;\0\0\0\0&quot;);

 select(NS); $| = 1; select(stdout);

 socket(S,$AF_INET, $SOCK_STREAM, $proto) || die &quot;socket: $!&quot;;
 bind(S,$this) || die &quot;bind: $!&quot;;
 listen(S,5) || die &quot;connect:$!&quot;;

 select(S); $| = 1; select(stdout);
 $WNOHANG =1;
}
</pre><P>
<h4><a name="023f_00cf"><B>Example 2:</B> The trap_gophers subroutine forms the core event loop in the server.<a name="023f_00cf"></h4><P>
<pre>sub trap_gophers {

 for($con = 1; ; $con++) {
  ($addr = accept(NS,S)) || die $!;
FORK:
  if (($pid = fork()) != 0) {   # parent
   close(NS);
   while (1) { last if (waitpid(-1,$WNOHANG) &lt; 1);}
  } elsif (defined $pid) {  # child

   ($af,$port,$inetaddr) = unpack($sockaddr,$addr);
   @inetaddr = unpack('C4',$inetaddr);
   while (&lt;NS&gt;) {
    if (! &amp;valid_request($_)) {close(NS);exit(-1);}
    if (/^\r/)    {&amp;log_request(&quot;CONNECT\n&quot;);&amp;senddir();}
    if (/^1/)     {&amp;senddir();}
    if (/^0|^4|^9|^g|^h/) {&amp;sendfile();}
    if (/^7/) {&amp;wa2go();}

    close(NS);
    exit(0);
   }
  } elsif ($! =~ /No more process/) { #EAGAIN is recoverable
   sleep 2;
   redo FORK;
  } else {  # weird fork error
   die &quot; could not fork child to handle connection!!!: $!\n&quot;;
  }
 }
 close(NS);
}
</pre><P>
<h4><a name="023f_00d0"><B>Table 1:</B> Gopher types.<a name="023f_00d0"></h4><P>

<PRE>
    Type   Description

    0      A readable ASCII file.
    1      A simple directory listing.
    2      A CSO phonebook (a special kind of directory listing).
    3      An Error was detected by the server.
    4      A BinHexed Macintosh file.
    5      A DOS binary archive.
    6      A UNIX uuencoded file.
    7      A keyword searchable index.
    8      A telnet session.
    9      A binary file.
</pre><P>
<h4><a name="023f_00d1"><B>Example 3:</B> The subroutine sendfile prepends the Gopher root-level data directory to the request, opens the file, and sends it back to the client one line at a time.<a name="023f_00d1"></h4><P>
<pre>sub sendfile {
 &amp;log_request(&quot;FILE:$request&quot;);
 open(REPLY, &quot;&lt;$gopher_root/$request&quot;);
 while (&lt;REPLY&gt;){send(NS,&quot;$_&quot;,0);}
}
</pre><P>
<h4><a name="023f_00d2"><B>Example 4:</B> Processing a Type 1 request.<a name="023f_00d2"></h4><P>
<pre>sub senddir {
 &amp;log_request(&quot;DIR:$request&quot;);

 if ($menutype eq &quot;d&quot;) {
  open(REPLY, &quot;ls -a1 '$gopher_root/$request' |);
  while (&lt;REPLY&gt;){
   chop $_;
   $file= $_;
   if (/^\./) { &amp;process_link($_);}
   else {
    $type=&quot;0&quot; if -T &quot;$gopher_root/$request/$file&quot;;
    $type=&quot;9&quot; if -B &quot;$gopher_root/$request/$file&quot;;
    $type=&quot;1&quot; if -d &quot;$gopher_root/$request/$file&quot;;
    $type=&quot;7&quot; if &quot;$gopher_root/$request/$file&quot; =~/\.src$/;
    $type=&quot;g&quot; if &quot;$gopher_root/$request/$file&quot; =~/\.gif$/;
    $type=&quot;4&quot; if &quot;$gopher_root/$request/$file&quot; =~/\.hqx$/;
    $type=&quot;h&quot; if &quot;$gopher_root/$request/$file&quot; =~/\.html$/;
    if ($type == 0 || $type == 1 || $type eq &quot;g&quot; || $type eq &quot;9&quot; || 
                                                    $type eq &quot;4&quot; ||
                                                    $type eq &quot;h&quot;) {
     send(NS,&quot;$type$file\t$type$request/$file\t$thishost\t$thisport\r\n&quot;,0);
    }
    $waissourcedir = &quot;&quot;; $ENV{'WAISCOMMONSOURCEDIR'} = $waissourcedir;

    if ($type == 7 &amp;&amp; $wais_op) {
     $waissourcedir = &quot;$gopher_root/$request&quot;; #chop $waissourcedir;
     $ENV{'WAISCOMMONSOURCEDIR'} = $waissourcedir;
     send(NS,&quot;$type$file\t$type::search::$waissourcedir::$file::\t$thishost
                                                        \t$thisport\r\n&quot;,0);
    }
   }
  }
  send(NS,&quot;.\r\n&quot;,0);
 } else {           #menutype is static
  open (CACHE, &quot;&lt; $gopher_root/$request/$cachefile&quot;) || print &quot;error opening
                                                           $cachefile $!\n&quot;;
  while (&lt;CACHE&gt;){send(NS,&quot;$_&quot;,0); }
 }
}
</pre><P>
<h4><a name="023f_00d3"><B>Example 5:</B> The subroutine ws2go takes a list of keywords, which it hands to the WAIS server and receives a result from a previous search, rewrites it to the WAIS protocol, and passes that back to the WAIS server.<a name="023f_00d3"></h4><P>
<pre># do a WAIS search
sub wa2go { #Modified from Jonny Goldman's waismail.pl &lt;jonathan@think.com&gt;
 [...]
 if (/^7::search|^7::Search|^7::SEARCH/) {
  [...]
  &amp;dosearch();
 }
 if (/^7::retrieve|^7::Retrieve|^7::RETRIEVE|^[ \t]{0,}DocID: /) {
  [...]
  &amp;doretrieve();
 }
 [...]
}
</pre><P>
<h4><a name="023f_00d4"><B>Example 6:</B> @ARGV is an array containing the command line.<a name="023f_00d4"></h4><P>
<pre>while (@ARGV) {
  $_=shift @ARGV;

  if (/-c/) {
   $c_file=shift @ARGV;
   [...]
  }

  if (/^-l/) { $logfile=shift @ARGV;}
  [...]
</pre><P>
<h4><a name="023f_00d5"><B>Example 7:</B> A configuration file.<a name="023f_00d5"></h4><P>
<pre># sGs.cnf
# port to run on.
# NOTE: official gopher port is 70, but requires root privilege

-p 1492

# gopher root level data dir
# this is where you put the data you want to publish

-d /my-gopher/data

# where you keep your wais binaries (remove or comment the following
# line if no wais)
-w /wais/bin

# gopher log file
-l ./sGs.log

# how to set up menus... if &quot;-m d&quot; then they are dynamic
#                     if &quot;-m s&quot; then they are static, and cache files must
#                     be created manually. sGsCache.pl can be used

#      NOTE:
#      static menus allow finer control over what a gopher menu will look
#      like, more control and security, but in general may be harder to
#      maintain. Properly constructed gopher filesystems on a unix system
#      utilizing long filenames and whitespace allow for very readable
#      client menus.
-m d

# the hostname you wish to have created in your gopher replies
# normally the default is fine &quot;`hostname`.`domainname`&quot;.
-H gopher.chaser.com
</pre><P>
<h4><a name="023f_00d6"><B>Example 8:</B> Gopher link files.<a name="023f_00d6"></h4><P>
<pre>sub process_link {
[...]
 if (-T &quot;$gopher_root/$request/$file&quot;) {
  open(LINK,&quot;&lt; $gopher_root/$request/$file&quot;) || die &quot;can't...&quot;;
  while (&lt;LINK&gt;) {
  [...]
    if(/^Name|^Type|^Port|^Path|^Host/) {
    [...]
   }
   else { return }              # funny garbage in link file
  }
</pre><P>
<h4><a name="023f_00d7"><B>Example 9:</B> An example link file that conforms to sGs's format.<a name="023f_00d7"></h4><P>
<pre>
Name=The Original Gopher at UofM
Type=1
Port=70
Path=1/
Host=boombox.micro.umn.edu
</pre>

<h4><a name="023f_00d8"><B>Table 2:</B> Freely available software samplers.<a name="023f_00d8"></h4>
<PRE>
Platform  Application   Author          ftp Site                 Comments

PC        gopher_p.exe  Martyn Hampson                           Gopher+
                                                                  client
PC        gophbook.exe  Kevin Gamiel                             Cute client
                                                                  that uses 
                                                                  a book
                                                                  metaphor
                                                                  for
                                                                  displaying                  
                                                                  data.
Mac       GopherApp     Don Gilbert     xxxxxxxxxxTKxxxxxxxxxx   Uses MacApp
                                                                  extensible
                                                                  Macintosh
                                                                  programming
                                                                  framework.
                                                                  Highly
                                                                  reliable.
                                                                  Some
                                                                  problems
                                                                  with 32K
                                                                  text-file
                                                                  limits.
UNIX      Xgopher       Allan Tuchman   xxxxxxxxxxTKxxxxxxxxxx
</pre>

<h4><a name="023f_00d9">Listing One <a name="023f_00d9"></h4>

<pre>

#!/usr/local/bin/perl
$program=&quot;sGs.pl&quot;; # (a simple Gopher server)
$revision=&quot;2.0      &quot;;
#
############################################################################
$maintainer_person=&quot;Your Name Here&quot;;
$maintainer_address=&quot;Your Email Address Here&quot;;
&amp;register();
#############################################################################
#                DESCRIPTION
#  A simple gopher server which handles type 0,1, g, and 7 gopher requests.
#
############################## MAIN #########################################
#
&amp;init_program_vars();

#############################################################################
#               RUN AS A DAEMON
fork &amp;&amp; exit;
setpgrp(0,$$);

#############################################################################

&amp;init_socket();

&amp;trap_gophers();

#############################  END ##########################################
sub init_program_vars {
 $host=`hostname`;chop($host);$domain=`domainname`;chop($domain);
 if ($domain) { $thishost=&quot;$host.$domain&quot;; }
 else { $thishost=$host; }
 $port=&quot;1470&quot;;$thisport=$port;$gopher_root=&quot;/&quot;;
 $wais_op=&quot;0&quot;;$waisq=&quot;waisq&quot;;$menutype=&quot;d&quot;;$cachefile=&quot;.cache&quot;;
 $maxres = 200;
 $errorlog = &quot;./sGs.err&quot;;
 $logfile = &quot;./sGs.log&quot;;

 # process the command line
 while (@ARGV) {
  $_=shift @ARGV;
  if (/^-c|^-C|^-l|^-h|^-p|^-d|^-m|^-u|^-v|^-w|^-H/) { #good arguments

   if (/-c/) {
    $c_file=shift @ARGV;
    if ( -T &quot;$c_file&quot; ) { &amp;process_config_file(); }
    else { die &quot;-c: improper filename $c_file\n&quot;;}
   }

   if (/^-l/) { $logfile=shift @ARGV;}
   if (/^-p/) { $port=shift  @ARGV;$thisport=$port;}
   if (/^-d/) { $gopher_root=shift  @ARGV;
        if (! -d &quot;$gopher_root&quot;){die &quot;Not a valid directory: $gopher_root\n&quot;;}}

   if (/^-m/) {         # menu type (d)ynamic (default)  or (s)tatic
    $menutype=shift @ARGV;
    if (!($menutype eq &quot;s&quot; || $menutype eq &quot;d&quot;))
    {die &quot;-m: bad option $menutype  (use d or s) \n&quot;}
   }

   if (/^-C/) { $cachefile=shift @ARGV;}

   if (/^-u/) {         # setuid to user  (default whoever starts it)
    print &quot;-u option not implemented yet\n&quot;;
   }

   if (/^-v/) {&amp;print_version(); die &quot;\n&quot;;}
   if (/^-w/) {
    $wais_op=&quot;1&quot;;
    $waisq = shift @ARGV.&quot;/waisq&quot;;
    if (! -x &quot;$waisq&quot;) {die &quot;$waisq... not executable\n&quot;}
   }

   if (/^-H/) {
    $host=shift @ARGV;$thishost=$host;
   }

   if (/^-h|^-\?/) { &amp;print_help(); die &quot;\n&quot;;}
  } else {&amp;print_help(); die &quot;\n&quot;;} # bad arguments
 }

 if ($logfile){ #we do this once to make sure we can.
  open (LOG,&quot;&gt;&gt;$logfile&quot;) || die &quot;can't open logfile: $logfile: $!\n&quot;;
  close (LOG);
 }
 open(ELOG,&quot;&gt;&gt;$errorlog&quot;) || die &quot;can't open error log\n&quot;;
 close (ELOG);  #just checking...

 $with_options=&quot;-h $thishost -p $port -d $gopher_root -m $menutype -w 
                                                                    $wais_op &quot;;
 $start_mess=&quot;$timestamp Starting sGs: $with_options&quot;;
 &amp;print_version(); sleep 2;
 print &quot;\n&quot;;
 print &quot;$start_mess\n&quot;;
 sleep 4;system(&quot;clear&quot;);print &quot;Welcome to sGs....\n&quot;;
 &amp;log_request(&quot;sGs Started $with_options\n&quot;);
}

#############################################################################
sub process_config_file {
#
# a config file is just a bunch of command line options put into a file
# one line at a time.
# Example:
#   -d /users/gopher/gopher-data
#   -p 1500
#   -w /users/wais/w8b5bio/bin
#   -l /your/gopher/log


 open (CONFIG, &quot;&lt;$c_file&quot;) || die &quot;cant open $c_file&quot;;
 while (&lt;CONFIG&gt;) {
  @op= split(/\s/, $_);
  $_=shift(@op);
  if (/^-H/) { $host=shift(@op); $thishost=$host;}
  if (/^-l/) { $logfile=shift(@op); }
  if (/^-p/) { $port=shift(@op);$thisport=$port } # port
  if (/^-d/) {          # gopher directory
   $gopher_root=shift(@op);
   if (! -d &quot;$gopher_root&quot; ) { die &quot;Not a valid directory: $gopher_root\n&quot;;}
  }
  if (/^-m/) {          # menu type (d)ynamic (default)  or (s)tatic
   $menutype=shift(@op);
   $menutype=shift @ARGV;
   if (!($menutype eq &quot;s&quot; || $menutype eq &quot;d&quot;))
   {die &quot;-m: bad option $menutype  (use d or s) \n&quot;}
  }

  if (/^-C/) { $cachefile=shift(@op); } # default is .cache
  if (/^-u/) {          # setuid to user  (default whoever starts it)
   print &quot;-u option\n&quot;;
  }
  if (/^-w/) {          # WAIS SEARCH OPTION default nowais
   $wais_op=&quot;1&quot;;
   $waisq=shift(@op).&quot;/waisq&quot;;
   if (! -x &quot;$waisq&quot;) {die &quot;$waisq... not executable\n&quot;}
  }
 }
}

###############################################################################
sub print_version {

 system(&quot;clear&quot;);
 print &quot;\n\n&quot;;
 print &quot;
 ##############################################################################
 #                                        
 #                     sGs                
 #                                        
 #                    Gopher                      
 #               simple   server                  
 #                                        
 #              Version: $revision               
 #                                        
 ################################# For Support ################################
 #                                        
     contact: $maintainer_person
      e-mail: $maintainer_address
 #                                        
 ##########################################################################\n&quot;;
     }

#############################################################################
sub print_help {

print &quot;
sGs [-c &lt;configfile&gt;] [-p &lt;port&gt;] [-d &lt;gopher-data-dir&gt;] [-l &lt;logfile&gt;]
    [-m &lt;s || d&gt;] (static or dynamic {default} menus)  [-u &lt;user&gt;]
    [-h|-H|-?|?] (prints this file)  [-v] (prints version)  [-w] (allow WAIS)
    [-C &lt;cachefile&gt;] (when running with static menus.  Default .cache)
    \n&quot;;
}

#############################################################################
sub init_socket {

 $AF_INET = 2;
 $SOCK_STREAM = 1;
 $sockaddr = 'S n a4 x8';

($name, $aliases, $proto) = getprotobyname('tcp');
 if ($port !~ /^\d+$/) {
  ($name, $aliases, $proto) = getservbyport($port, 'tcp');
 }
 $this = pack($sockaddr, $AF_INET, $port, &quot;\0\0\0\0&quot;);

 select(NS); $| = 1; select(stdout);

 socket(S,$AF_INET, $SOCK_STREAM, $proto) || die &quot;socket: $!&quot;;
 bind(S,$this) || die &quot;bind: $!&quot;;
 listen(S,5) || die &quot;connect:$!&quot;;

 select(S); $| = 1; select(stdout);
 $WNOHANG =1;
}

#######################################################################
sub trap_gophers {

 for($con = 1; ; $con++) {
  ($addr = accept(NS,S)) || die $!;
FORK:
  if (($pid = fork()) != 0) {   # parent
   close(NS);
   while (1) { last if (waitpid(-1,$WNOHANG) &lt; 1);}
  } elsif (defined $pid) {  # child

   ($af,$port,$inetaddr) = unpack($sockaddr,$addr);
   @inetaddr = unpack('C4',$inetaddr);
   while (&lt;NS&gt;) {
    if (! &amp;valid_request($_)) {close(NS);exit(-1);}
    if (/^\r/)            {&amp;log_request(&quot;CONNECT\n&quot;);&amp;senddir();}
    if (/^1/)             {&amp;senddir();}
    if (/^0|^4|^9|^g|^h/) {&amp;sendfile();}
    if (/^7/) {&amp;wa2go();}
    close(NS);
    exit(0);
   }
  } elsif ($! =~ /No more process/) { #EAGAIN is recoverable
   sleep 2;
   redo FORK;
  } else {          # wierd fork error
   die &quot; could not fork child to handle connection!!!: $!\n&quot;;
  }
 }
 close(NS);
}

######################################################################
sub sendfile {
 &amp;log_request(&quot;FILE:$request&quot;);
 open(REPLY, &quot;&lt;$gopher_root/$request&quot;);
 while (&lt;REPLY&gt;){send(NS,&quot;$_&quot;,0);}
}

######################################################################
sub senddir {           #NEED TO PUT IN A FLAG FOR STATIC/DYNAMIC
 &amp;log_request(&quot;DIR:$request&quot;);

 if ($menutype eq &quot;d&quot;) {
  open(REPLY, &quot;ls -a1 '$gopher_root/$request' |); 
  while (&lt;REPLY&gt;){
   chop $_;
   $file= $_;
   if (/^\./) { &amp;process_link($_);}
   else {
    $type=&quot;0&quot; if -T &quot;$gopher_root/$request/$file&quot;;
    $type=&quot;9&quot; if -B &quot;$gopher_root/$request/$file&quot;;  
    $type=&quot;1&quot; if -d &quot;$gopher_root/$request/$file&quot;;
    $type=&quot;7&quot; if &quot;$gopher_root/$request/$file&quot; =~/\.src$/;
    $type=&quot;g&quot; if &quot;$gopher_root/$request/$file&quot; =~/\.gif$/;
    $type=&quot;4&quot; if &quot;$gopher_root/$request/$file&quot; =~/\.hqx$/;
    $type=&quot;h&quot; if &quot;$gopher_root/$request/$file&quot; =~/\.html$/;

    if ($type == 0 || $type == 1 || $type eq &quot;g&quot; || $type eq &quot;9&quot; || 
                                                $type eq &quot;4&quot; || $type eq &quot;h&quot;) {
     send(NS,&quot;$type$file\t$type$request/$file\t$thishost\t$thisport\r\n&quot;,0);
    }
    $waissourcedir = &quot;&quot;; $ENV{'WAISCOMMONSOURCEDIR'} = $waissourcedir;

    if ($type == 7 &amp;&amp; $wais_op) {
     $waissourcedir = &quot;$gopher_root/$request&quot;; #chop $waissourcedir;
     $ENV{'WAISCOMMONSOURCEDIR'} = $waissourcedir;
     send(NS,&quot;$type$file\t$type::search::$waissourcedir::$file::
                                               \t$thishost\t$thisport\r\n&quot;,0); 
    }
   }
  }
  send(NS,&quot;.\r\n&quot;,0);
 } else {           #menutype is static
  open (CACHE, &quot;&lt; $gopher_root/$request/$cachefile&quot;) || print &quot;error opening 
                                                              $cachefile $!\n&quot;;
  while (&lt;CACHE&gt;){send(NS,&quot;$_&quot;,0); }
 }
}

############################################################################
# do a WAIS search
sub wa2go { #Modified from Jonny Goldman's waismail.pl &lt;jonathan@think.com&gt;
 $tmpfile = &quot;/tmp/sGs.$$&quot;;
 $sfile   = &quot;sGs.$$.src&quot;;
 $outfile = &quot;/tmp/sGs.out.$$&quot;;
 $errfile = &quot;/tmp/sGs.err.$$&quot;;
 $goph_string=$_;
 ($gophertype, $action, $wais_src_dir, $source, @words) = split(/::/,$_);
 if (/^maxres (\d+)/) { $maxres = $1;}
 
 if (/^7::search|^7::Search|^7::SEARCH/) {
  ($gophertype, $action, $wais_src_dir, $source, @words) = split(/::/,$_);
  $search=1;
  @sources=split(&quot;.src&quot;,$source);
  $ENV{'WAISCOMMONSOURCEDIR'} = $wais_src_dir;
  $maxres = 200;
  $waissourcedir=$wais_src_dir;
  &amp;dosearch();
 }

 if (/^7::retrieve|^7::Retrieve|^7::RETRIEVE|^[ \t]{0,}DocID: /) {
  ($gophertype, $action, $docid) = split(/::/,$_);
  $retrieve = 1; $indocid = 1; chop($docid); chop($docid);
  &amp;log_request(&quot;RETRIEVING: $docid\n&quot;);
 }
 
 if ($indocid == 1) {
  $indocid = 0;
  &amp;doretrieve();
 }

 open(RESPONSE,&quot;&lt;$outfile&quot;);
 while (&lt;RESPONSE&gt;){
  if ($retrieve) {
   send(NS,&quot;$_&quot;,0);
  }

  if ($search) {
   $/ = &quot;&quot;;         #paragraph mode
   ($result,$heading,$DOCID) = split(/\n/,$_);
   if ($heading =~/Headline/){

    if ($DOCID =~/GIF/) {
     send(NS,&quot;g$heading\t7::retrieve::$DOCID\t$thishost\t$thisport\r\n&quot;,0);
    }
    else {
     send(NS,&quot;0$heading\t7::retrieve::$DOCID\t$thishost\t$thisport\r\n&quot;,0);
    }
   }
  }
 }
 send(NS,&quot;.\r\n&quot;,0);

 unlink $outfile;
 unlink $tmpfile;
 unlink $errfile;
 unlink $sfile;
}

###############################################################################
sub dosearch {
 foreach $source (@sources) {
  if(!(-f &quot;$waissourcedir/$source.src&quot;)) {
   &amp;logerror(&quot;could not find source: $waissourcedir/$source.src&quot;);
  }
 }

 open(TMP, &quot;&gt;$tmpfile&quot;);
 printf TMP &quot;(:question :version  2\n :seed-words \&quot;&quot;;
 foreach $w (@words) { printf TMP &quot;$w &quot;;};
 printf TMP &quot;\&quot;\n :relevant-documents\n ( &quot;;

 if ($relevant) {
  foreach $rel (@reldocs) {
   $_ = $rel;
   /@/ &amp;&amp;  ($_ = $`) &amp;&amp; (/:/) &amp;&amp; ($id = $`) &amp;&amp; ($db = $');
   printf TMP &quot;\n  (:document-id \n   :document \n   (:document \n    
                                                                  :doc-id \n&quot;;
   printf TMP &quot;     (:doc-id \n      :original-database %s \n      
                                                   :original-local-id %s\n)\n&quot;;
   &amp;stringtoany($db), &amp;stringtoany($id);
   printf TMP &quot;    :source (:source-id :filename \&quot;$source.src\&quot; )\n&quot;;
   printf TMP &quot;    ) )\n&quot;;
  }
 }

 printf TMP &quot; )\n&quot;;
 printf TMP &quot; :sourcepath \&quot;$waissourcedir/:\&quot; \n&quot;;
 printf TMP &quot; :sources (\n&quot;;
 
 foreach $source (@sources) {
  printf TMP &quot;  (:source-id :filename \&quot;$source.src\&quot; )\n&quot;;
 }

 printf TMP &quot; )\n&quot;;
 printf TMP &quot; :maximum-results %d )\n&quot;, $maxres;
 close(TMP);
 system(&quot;cp $tmpfile /tmp/TESTSEARCH&quot;);
 &amp;log_request(&quot;WAISSEARCH: @sources, words: @words&quot;);

 if ($relevant) {
  foreach $rel (@reldocs) {
   $_ = $rel;
   { &amp;log_request(&quot;RelDocID: \&quot;$rel\&quot; &quot;);}
  }
 }
 open (OUT, &quot;&gt;&gt;$outfile&quot;);
 printf OUT &quot;Searching: &quot;;
 foreach $source (@sources) {
  printf OUT &quot;$source &quot;;
 }

 printf OUT &quot;\nKeywords: &quot;;
 foreach $w (@words) { printf OUT &quot;$w &quot;; };
 if ($relevant) {
  foreach $rel (@reldocs) {
   $_ = $rel;
   { printf OUT &quot;\nRelDocID: \&quot;$rel\&quot;&quot;;}
  }
 }
 printf OUT &quot;\n&quot;;
 system(&quot;$waisq -f $tmpfile -m $maxres -g &gt;&gt; /dev/null 2&gt; $errfile&quot;);
 open(ERR, &quot;$errfile&quot;);

 while (&lt;ERR&gt;) {
  if (/Connect to socket did not work:/) {
   &amp;log_request(&quot;Error Searching @sources for @inetaddr: Bad connect 
                                                              (source down?)&quot;);
   &amp;log_request(&quot;Error: $_&quot;);
   printf OUT &quot;\n**** Error Searching @sources: not responding ****\n&quot;;
   printf OUT &quot;\tPlease send mail to the maintainer.\n&quot;;
  }
 }
 close(ERR);
 #unlink($errfile);
 open(TMP, &quot;$tmpfile&quot;);
 $inres = 0;

 while(&lt;TMP&gt;) {
  /:result-doc/ &amp;&amp; ($inres = 1);
  if ($inres == 1) {
   /:score\s+(\d+)/ &amp;&amp; ($score = $1);
   ((/:headline &quot;(.*)&quot;$/ &amp;&amp; ($headline = $1)) ||
    (/:headline &quot;(.*)$/ &amp;&amp; ($headline = $1))); # one little &quot;&quot; any 
                                                            my formatter dies.
   /:number-of-bytes\s+(\d+)/ &amp;&amp; ($bytes = $1);
   /:type &quot;(.*)&quot;/ &amp;&amp; ($type = $1);
   /:filename &quot;(.*)&quot;/ &amp;&amp; ($sourcename = $1);
   /:original-local-id &quot;(.*)&quot;/ &amp;&amp; ($docid = $1);
   /:original-local-id  (\(:any.*\))/ &amp;&amp; ($docid = &amp;anytostring($1));
   /:original-database &quot;(.*)&quot;/ &amp;&amp; ($database = $1);
   /:original-database  (\(:any.*\))/ &amp;&amp; ($database = &amp;anytostring($1));
   /:date &quot;(\d+)&quot;/ &amp;&amp; ($date = $1, &amp;docdone);
  }
 }
 printf OUT 
&quot;\n______________________________________________________________________\n\n&quot;;
 close(TMP);
 close(OUT);
 $relevant = ''; @reldocs = '';
# unlink($tmpfile);
}

##############################################################################
sub doretrieve {
 $port = &quot;0&quot;;
 $_ = $docid;
 s/^DocID: //g;
 if (/%/) {
  $docid = $`;
  $type = $';
  #print &quot;in doretrieve type = :$type:...\n&quot;;
 }
 $_ = $docid;
 /:/ &amp;&amp; ($id = $`) &amp;&amp; ($db = $');
 /@/ &amp;&amp;  ($_ = $`) &amp;&amp; (/:/) &amp;&amp; ($id = $`) &amp;&amp; ($db = $');
 $_ = $docid;
 /@/ &amp;&amp;  ($_ = $') &amp;&amp; (/:/) &amp;&amp; ($host = $`) &amp;&amp; ($port = $');
 open(SRC, &quot;&gt;/tmp/$sfile&quot;);
 printf SRC &quot;(:source :version 3 \n&quot;;
 printf SRC &quot; :database-name \&quot;$db\&quot;\n&quot;;
 if ($port != 0) {
  printf SRC &quot; :ip-name \&quot;$host\&quot; :tcp-port $port\n&quot;;
 }
 printf SRC &quot;)\n&quot;;
 close(SRC);
 open(TMP, &quot;&gt;$tmpfile&quot;);
 printf TMP &quot;(:question :version 2 :result-documents \n&quot;;
 printf TMP &quot;  ( (:document-id :document (:document :doc-id\n&quot;;
 printf TMP &quot;    (:doc-id :original-database %s\n&quot;, &amp;stringtoany($db);
 printf TMP &quot;     :original-local-id %s )\n&quot;, &amp;stringtoany($id);
 printf TMP &quot;     :number-of-bytes -1 :type \&quot;$type\&quot;\n&quot;;
 printf TMP &quot;     :source (:source-id :filename \&quot;$sfile\&quot;) ) ) ) )\n&quot;;
 close(TMP);
 $timestamp = &amp;date() . &quot; &quot; . &amp;time() . &quot;:&quot;;
 &amp;log_request(&quot;WAISSEND:\&quot;$docid%%$type\&quot; to @inetaddr\n&quot;);
 open(OUT, &quot;&gt;&gt;$outfile&quot;);
# printf OUT &quot;______________________________________________________________________\n&quot; if 
 ! ($type=~/GIF/);
 close(OUT);
 $docid = $docid.&quot;%&quot;.$type;
 if ($type eq &quot;&quot; || $type eq &quot;TEXT&quot; || $type eq &quot; TEXT&quot; ||$type eq &quot;WSRC&quot; 
      ||$type eq &quot;GIF&quot; || $type eq 
     &quot;HTML&quot; || $type eq &quot;html&quot;) {
  $exres = system(&quot;$waisq -s /tmp/ -f $tmpfile -v 1 &gt;&gt; $outfile 2&gt; $errfile&quot;);
 }
 else {
  $exres = system(&quot;($waisq -s /tmp/ -f $tmpfile -v 1 | uuencode WAIS.res &gt;&gt; 
                                                       $outfile) 2&gt; $errfile&quot;);
 }
 unlink(&quot;/tmp/$sfile&quot;);
 open(OUT, &quot;&gt;&gt;$outfile&quot;);
 open(ERR, &quot;$errfile&quot;);
 while (&lt;ERR&gt;) {
  if (/Missing DocID in request|Could not find Source/) {
   s/done//g;
   printf OUT &quot;Error getting document:\n $_\n&quot;;
   printf OUT &quot;(This is usually a bad DocID,\n or the server has deleted the 
                                         document since you ran the search)\n&quot;;
   $timestamp = &amp;date() . &quot; &quot; . &amp;time() . &quot;:&quot;;
   &amp;log_request(&quot;Error Sending \&quot;%s\&quot; to @inetaddr: Bad DocID,\n $docid&quot;);
  }
 }
 close(ERR);
 #unlink($errfile);
# printf OUT &quot;______________________________________________________________________\n&quot; if 
 ! ($type=~/GIF/);
 close(OUT);
}

############################################################################
sub docdone {
 open(SRC, &quot;$waissourcedir/$sourcename&quot;);
 while(&lt;SRC&gt;) {
  /:ip-name[ \t]{0,}&quot;(.*)&quot;/ &amp;&amp; ($ipname = $1);
  /:database-name[ \t]{0,}&quot;(.*)&quot;/ &amp;&amp; ($databasename = $1);
  /:tcp-port[ \t]{0,}&quot;(.*)&quot;/ &amp;&amp; ($tcpport = $1);
  /:tcp-port[ \t]{0,}(\d+)/ &amp;&amp; ($tcpport = $1);
  /:maintainer[ \t]{0,}&quot;(.*)&quot;/ &amp;&amp; ($maintainer = $1);
 }
 close(SRC);
 select(OUT); $num++;
 printf &quot;\nResult #%2d Score:%4d lines:%3d bytes:%7d Date:%6d Type: %s\n&quot;, 
     $num,  $score,  $lines, 
     $bytes, $date, $type;
 printf &quot;Headline: %s\n&quot;, $headline;
 printf &quot;DocID: %s:%s&quot;, $docid, $database;
 if ($tcpport != 0) { printf &quot;@%s:%d&quot;, $ipname, $tcpport; }
 printf &quot;%%$type\n&quot;;
 $score = $headline = $lines = $bytes = $type = $date = '';
 select STDERR;
}

############################################################################
# a couple of WAIS utility functions
sub anytostring {
 local($any) = pop(@_);
 $res = '';
 $_ = $any;
 if (/:bytes            #\((.*)\)(.*)\)/ &amp;&amp; ($string = $1)) {
     @chars = split(' ', $string);
     foreach $c (@chars) {
      $res = $res.sprintf(&quot;%c&quot;, $c);
     }
    }
 $res;
}

sub stringtoany {
 local($str) = pop(@_);
 $len = length($str);
 $res = sprintf(&quot;(:any  :size  %d :bytes #(  &quot;, $len);
     for ($i = 0; $i &lt; $len; $i++) {
      $res = $res.sprintf(&quot;%d  &quot;, ord(substr($str,$i,1)));
     }
 $res = $res.&quot;)  )&quot;;
 $res;
}
############################################################################
# error logging
sub logerror {
 $timestamp = &amp;date() . &quot; &quot; . &amp;time() . &quot;:&quot;;
 open(ELOG,&quot;&gt;&gt;$errorlog&quot;) || die &quot;can't open error log\n&quot;;
 printf ELOG &quot;$timestamp @_\n&quot;; close (ELOG);
 system(&quot;echo \&quot;$timestamp @_\n\&quot; | $maintainer_address&quot;);
}
############################################################################
# date and time functions
sub date {
 local ($when) = `date '+%m/%d/%y'`; chop $when;
 return $when;
}

sub time {
 local ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst);
 ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime(time);
 $mon = $mon + 1;
 return  sprintf(&quot;%02d:%02d:%02d&quot;, $hour,$min,$sec);
}

###########################################################################
# general logging
sub log_request {
 local ($request)=@_;
 $timestamp = &amp;date() . &quot; &quot; . &amp;time();
 open (LOG,&quot;&gt;&gt;$logfile&quot;) || &amp;logerror(&quot;can't open logfile: $logfile: $!\n&quot;);
 printf LOG 
     &quot;%s::%s.%s.%s.%s::%s&quot;,
     $timestamp,
     @inetaddr[0],@inetaddr[1],@inetaddr[2],@inetaddr[3],$request;
 close (LOG);
}

###########################################################################
sub process_link {
 local ($lname,$ltype,$lport,$lpath,$lhost);
 if (-T &quot;$gopher_root/$request/$file&quot;) {
  open(LINK,&quot;&lt; $gopher_root/$request/$file&quot;) || die &quot;cant open 
                                            $gopher_root/$request/$file: $!\n&quot;;
  while (&lt;LINK&gt;) {
   @L=split(&quot;=&quot;); chop(@L);#print &quot; @L\n&quot;;
   if(/^Name|^Type|^Port|^Path|^Host/) {
    if (/^Name/) {$lname=@L[1]}
    if (/^Type/) {$ltype=@L[1]}
    if (/^Port/) {$lport=@L[1]}
    if (/^Path/) {$lpath=@L[1]}
    if (/^Host/) {$lhost=@L[1]}
   }
   else { return }      # funny garbage in link file
  }

  if ($ltype == 0 || $ltype == 1 || $ltype eq &quot;g&quot; ) {
   print &quot;$ltype$lname\t$lpath\t$lhost\t$lport\r\n&quot;;
   send(NS,&quot;$ltype$lname\t$lpath\t$lhost\t$lport\r\n&quot;,0);
  }
  if ($type == 7 &amp;&amp; $wais_op) {
   $waissourcedir = &quot;$gopher_root/@tmp&quot;; #chop $waissourcedir;
   $ENV{'WAISCOMMONSOURCEDIR'} = $waissourcedir;
   send(NS,&quot;$ltype/$lname\t$ltype::search::$waissourcedir::$lpath::
                                                      \t$lhost\t$lport\r\n&quot;,0);
  }
 }
}
###########################################################################
# validity check
sub valid_request {
 $request=$_;chop $request;chop $request;
 substr($request,0,1)=&quot;&quot;;
 if ($request=~/\.\./) { return 0;}
 else { return 1}
}

##############################################################################
# registration functions
sub register {
 $c=&quot;./.sgsc&quot;;
 if  ( ! -r $c) { &amp;cop();&amp;reg();&amp;sen();return}
 if (&amp;bf() == 1) {&amp;sen(); &amp;cop(); &amp;reg();&amp;sen();return}
}

sub cop {
 print&quot;
                   sGs.pl

                (C) COPYRIGHT
               1993 Bob Kaehms
                cames@well.com

This software is provided free, AS IS, and neither the author, nor any person
or entity associated with the author in producing this software is responsible
for the condition of the software, it's use, or any damage to a computer or
the information therein, from using this software.

In short, LET THE USER BEWARE. If you plan on running this software you should
be familar with TCP/IP and network security.

You may do what you want with the program as long as the original copyright
and the following notice remain attached.

      Press &lt;RETURN&gt; when you've read and accept the above caveate&quot;;
 $OK=&lt;STDIN&gt;; system(&quot;clear&quot;);

 print&quot;

 A. BECAUSE THE PROGRAM IS AVAILABLE FREE OF CHARGE, THERE IS NO WARRANTY
    FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
    OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDER AND/OR OTHER PARTIES
    PROVIDE THE PROGRAM \&quot;AS IS\&quot; WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
    OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
    MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
    TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
    PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF NECESSARY SERVICING,
    REPAIR OR CORRECTION.

 B. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
    WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
    REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
    INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
    ARISING OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT
    NOT LIMITED TO THE LOSS OF DATA BEING RENDERED INACCURATE OR
    LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO
    OPERATE WITH ANY OTHER PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS
    BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.

    Press RETURN if you've read and accept the above.Else Cnt C&quot;;
 $OK=&lt;STDIN&gt;; system(&quot;clear&quot;);
}

sub reg {
 $hdr=&quot;/tmp/HDR&quot;;
 local($d) = `date`;
 local($h) = `uname -a`;local($da)=`domainname`;local ($w)=`whoami`;
 open(H,&quot;&gt; $hdr&quot;);printf H &quot;From: $w@$hTo: $$maintainer_address\nSubject: 
                                                                        Gopher 
Registration\n\n&quot;;close H;
 print &quot;Please enter the following:\n\n&quot;;
 print &quot;NAME    COMPANY               PHONE         e-mail address\n&quot;;
 $user_contact = &lt;STDIN&gt;;
 print &quot;thanks.....\n&quot;;
 open(F,&quot;&gt;$c&quot;);
printf F &quot; sGs.pl\n $revision\n $d HARDWARE\n $h $da $w CONTACT PERSON\n 
$user_contact&quot;;
 close F;
}

sub sen {
 system(&quot;cat $hdr $c |  /usr/lib/sendmail '$maintainer_address'&quot;);
}

###########################################################################
# special check to see if we've registered once
#
sub bf {
 local ($h) = `uname -a`;local ($da)=`domainname`;local ($w)=`whoami`;
 $/ = &quot;&quot;;           #Enable paragraph mode
 open (F,&quot;&lt;$c&quot;);
 while (&lt;F&gt;){
  if (/$h/ &amp;&amp; /$da/ &amp; /$w/){$/ = &quot;\n&quot;;close F;return &quot;0&quot;;}
  close F;$/ = &quot;\n&quot;;return &quot;1&quot;}
}
</pre>

<HR><P>Copyright &copy; 1994, <I>Dr. Dobb's Journal</I></P></BODY></HTML>
