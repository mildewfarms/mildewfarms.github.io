<HTML>
<META NAME="year" CONTENT="1994">
<HEAD>
<TITLE>APR94: Algorithms for Directed Graphs</TITLE></HEAD>
<BODY BGCOLOR="#ffffff">
<h1>Algorithms for Directed Graphs<a name="0134_0003"></h1><P>
<h2><a name="0134_0001"><a name="0134_0000">A unique approach using genetic algorithms</h2><P>
<h3>Salvatore R. Mangano</h3><P>
<p><i><a name="0134_0002"><a name="0134_0000">Sal is president of Man Machine Interfaces. He can be reached at 555 Broad Hollow Road, Suite 230, Melville, NY 11747 or on CompuServe at 72053,2032.</i></p><hr><P>
Directed graphs underlie any tool that displays a tree diagram, class-relationship diagram, or entity-relationship diagram. As such, you might expect a CASE tool to provide an optimized directed-graph drawer. However, most CASE tools I'm familiar with punt when addressing this problem. Although an algorithm for drawing a directed graph like that shown in <a href="19940136.htm">Figure 1</A> is straightforward, a general-purpose graph drawer that draws graphs in an aesthetically pleasing format is difficult to create and computationally expensive. So, CASE tools usually use a few simple rules to get an initial layout and then allow the user to clean things up by dragging objects around. Putting the burden of &quot;pretty drawing&quot; on the user wastes time better spent on the design.<P>
This article looks at a novel solution to this problem using the emerging technology of genetic algorithms (GAs). Specifically, I'll use EOS, my company's C++ GA application framework, and Microsoft's Visual C++ to develop a module for optimizing the aesthetic layout of directed graphs. I'll create a Windows-hosted test application that exercises this module on randomly created graphs. The intent of this article is not to produce a commercial-grade graph drawer, but rather to demonstrate the use of GA technology on a nontrivial and unique problem. Since most programmers' first exposure to GAs is usually on a function-optimization problem, this article provides some insights on the advanced use of GA techniques.<P>
<h3><a name="0134_0004">The Technique<a name="0134_0004"></h3><P>
A GA is an algorithm that works with a population of potential solutions to a problem. Through means analogous to biological natural selection, it evolves better and better solutions to the problem. To accomplish this, the user of a GA must first find a way to encode the problem into a string of bits. The bits are analogous to genes and the strings to chromosomes. The encoding of a solution as bit strings is often called the &quot;genotype&quot; and the decoded solution, the &quot;phenotype.&quot; The genotype is mapped to the phenotype by the decoding function. The next step after the encoding is the measure of fitness. Fitness is one of the core elements that appear in every variation of a GA. Calculation of fitness involves mapping a solution onto a positive number such that greater numbers correspond to better solutions. This mapping is accomplished by the fitness or objective function.<P>
The second core feature of every genetic algorithm is a population of individuals. At any time during the execution of a genetic algorithm, there exists a population of candidate solutions to the problem (individuals consisting of a genotype and a phenotype). The initial population is usually generated randomly. The process of transforming this initial, mediocre population into a population containing near-optimal solutions is the heart of the GA. It proceeds by iterations of the following genetic operators: selection, reproduction, crossover, and mutation.<P>
Selection is the process by which candidate individuals from the current generation are chosen to produce the next generation. Selection is a survival-of-the-fittest strategy. After two individuals are selected, a weighted coin is flipped to determine if the individuals will mate to produce two new offspring or simply be placed in the next generation as is. Mating is accomplished by the crossover operation. The probability of mating is called the &quot;crossover probability&quot; (pc). The simplest form of crossover, called &quot;single point,&quot; is shown in <a href="19940137.htm">Figure 2</A>. As each bit is copied from parent to child, it is subject to mutation based on the mutation probability (pm). Pm is usually very small, relative to pc. Iterations of selection, reproduction, and mating are repeated until a new population is created. At this point, the fitness values of the new population are recalculated, and the process repeats until either some acceptable solution is found or an upper time limit has been reached. The GA described above can be summarized by the procedure shown in <a href="#0134_000c">Figure 3</A>.<P>
<h3><a name="0134_0005">The Tools<a name="0134_0005"></h3><P>
A GA framework is useful due to the large number of GA variants that can be produced by altering one or many of the steps in the basic algorithm. GA researchers have invented several variations on selection, reproduction, crossover, and mutation. Each variation can be mixed and matched to produce a unique GA variant. Object orientation turns out to be an ideal technique for expressing these variations. Through an adept combination of inheritance and composition, all the GA variants can be expressed. This ultimately allows you to code a GA using the basic technique and then try variations by instantiating different classes.<P>
Although EOS consists of over 80 classes, I'll restrict this discussion to a small relevant subset--<I>TBasicGA</I>, <I>TPopulation</I>, <I>TEnvironment</I>, <I>TBinaryIndividual</I>, <I>TGenotype</I>, <I>TPhenotype</I>, <I>TBinaryCrossoverFunctor</I>, and <I>TBinaryMutation- Functor</I>. These bases consist of many derived classes that implement variants of the basic GA. Other classes exist to implement special-purpose features. Each of the classes listed encapsulates a different behavior of the overall GA. <I>TBasicGA</I> is the genetic-algorithm interface class. <I>TPopulation</I> is a collection class that holds instances of <I>TIndividual</I>. <I>TPopulation</I> encapsulates the selection operation. <I>TEnvironment</I> encapsulates the GA's parameters--pc, pm, the random-number generator, and other statistical information. <I>TBinaryIndividual</I> is an interface class that unifies instances of <I>TGenotype</I> and <I>TPhenotype</I> into a single object. <I>TBinaryGenotype</I> encapsulates the binary genetic coding of the problem as strings, and it provides an interface to the crossover and mutation classes. <I>TPhenotype</I> encapsulates the decoding function and the fitness function. It is the main class from which you derive to build a GA-based application. <I>TBinaryCrossoverFunctor</I> and <I>TBinaryMutationFunctor</I> are classes that encapsulate the operations of crossover and mutation. These classes are called functors because they are functional objects. Functors are used so various flavors of crossover and mutation can be plugged in or out of a genotype without recoding any of the genotype's methods. <a href="19940138.htm">Figure 4</A> shows the relationship between these classes.<P>
<h3><a name="0134_0006">The GA Module<a name="0134_0006"></h3><P>
To derive a genetic encoding, I'll formalize the problem we are attempting to solve. We are given some arbitrary directed graph, as well as a grid where each cell represents a potential home for the graphical depiction of a node in the graph. The goal is to find an assignment of nodes to cells such that when the arcs are drawn, we get an aesthetically pleasing picture. Stating the problem in this way makes some crucial assumptions that may not be true in a real situation. First, I assume that the nodes, when drawn, are of equal size. Second, I assume that once I have assigned nodes to cells, the arcs can easily be drawn to complete the best possible drawing. (In other words, we need not optimize the drawing of arcs.) Third, I assume that the nodes are equally spaced in a grid and not arbitrarily placed on the output screen. I make these assumptions to simplify the example and the code. A more general solution is certainly possible using GAs.<P>
<h3><a name="0134_0007">Genetic Encoding<a name="0134_0007"></h3><P>
If each node in the graph is assigned a sequential number, then the problem can be viewed as a mapping of each node number onto an (x, y) coordinate in the grid. The mapping that keeps connected nodes close together and produces the fewest arc crossings will yield more aesthetically pleasing drawings. Other domain-dependent criteria may come into play when determining better drawings, but I ignore this possibility to expedite the solution.<P>
Given the above formalism, the encoding treats the bit string as a series of (x, y) pairs. The first pair assigns node0 to grid cell (x0, y0). The second assigns node1 to (x1, y1), and so on. This encoding allows collisions (two or more nodes are assigned to a single cell), so I need a collision-resolution procedure. A problem like this often arises in GAs, and there are several approaches to handling it. Some programmers assign very low fitness values to illegal genotypes. Others attempt to repair illegal genotypes before decoding them. Still others create special-purpose crossover and mutation operators that do not allow illegal genotypes to arise in the first place. In this case, I'll resolve a collision by searching for the closest empty cell to the one assigned, according to a fixed procedure. This is similar to a repair technique, but we are repairing the phenotype instead of the genotype.<P>
Given that I have a graph with N nodes and a grid that is X cells wide and Y cells high, I can calculate the required length of the bit string using the equation in <a href="1994013d.htm">Figure 5</A>. If X and Y are not powers of 2, then it is possible that (x, y) pairs can be encoded such that either x or y is greater then X or Y. I resolve this problem by always decoding x modulo X and y modulo Y. The decoding is implemented by a <I>TPhenotype</I> derived class called <I>CGraphDrawingPheno</I>. This class contains a two-dimensional matrix that will represent the grid. The genotype will be decoded so that each entry in the matrix will receive the node number of the node assigned to that grid position. Empty positions will be assigned a value of 0. The decoding of the genotype is implemented by <I>CGraphDrawingPheno::Decode()</I> member function; see Listings One and Two, page 106. This function uses a reference to a graph drive class to determine the number of bits in each component in the encoding. It copies these bits to buffers to be converted to integers by the utility functions <I>AllelesToInt()</I>. &quot;Allele,&quot; a term borrowed from biology, refers to the value expressed by a gene. Once the node, its row, and column in the grid are decoded, the member function <I>GetNearestEmptyCell()</I> is called to resolve the possibility of a node already existing at the desired location.<P>
<h3><a name="0134_0008">The Fitness Function<a name="0134_0008"></h3><P>
Now that I have a way to encode the placement of a graph's nodes on a grid, I need a technique for evaluating each placement's fitness. There are many ways to do this, depending on what you consider to be an aesthetically pleasing layout. When deriving this fitness function, I let intuition guide me in the initial derivation and then experiment to tweak the function so it works well for a variety of graphs. The function I ultimately arrived at can be seen in the <I>CGraphDrawingPheno</I> class's <I>CalcFitness()</I> member function; see <a href="#0134_000f">Listing Two</A>. The idea behind this function is to reward genotypes that decode into drawings where nodes connected by an arc are adjacent or close and to penalize when nodes are adjacent but not connected. This is done on a node-by-node basis so the resulting fitness value is a measure of how well nodes of the entire graph were assigned to grid locations. Notice that I completely ignore arc drawing for simplicity. The remaining members of <I>CGraphDrawingPheno</I> implement construction, destruction and copying. I also include some private-utility functions that encapsulate the testing for adjacency and the calculation of distance between grid cells. These can be used in experimenting with variations of the fitness function.<P>
I include three other classes in this module: <I>CGAGraphDriver, CGraphDrawerGA</I>, and <I>CWordMatrix</I>. <I>CGAGraphDriver</I> is an interface class that collects information (such as number of nodes in the graph and the size of the grid) before the GA and its associated objects are initialized; see Listings Three and Four (page 107). A very important function in this class is <I>CalcChromosomeLength()</I>, which, based on the number of nodes and the size of the grid, determines the number of bits necessary in a chromosome to encode the problem. Also included in this class are functions for drawing the optimized and unoptimized views of the graph. These use Windows-specific functions, but the logic can be easily ported to other graphics systems.<P>
<I>CGraphDrawerGA</I> is derived from the EOS class <I>TBasicGA</I>. It overrides the population-creation function and several reporting functions useful for testing the GA's performance before it is embedded into a larger application. Listings Five and Six (page 147) show the class declaration and implementation of <I>CGraphDrawerGA</I>. The important function here is <I>CreatePopulation()</I>. This function determines the characteristics of the genotype, phenotype, and the population. I use a two-point crossover-operator genotype (instead of single point) because this tends to work better with longer chromosomes. I also use a population technique known as <I>Elitism</I>, which ensures that a certain number (in our case, two) of the best individuals from the previous generation make it to the next generation. This improves performance on some types of problems.<P>
The utility class <I>CWordMatrix</I> implements a 2-D matrix of WORDS. Its implementation makes use of the MFC's <I>CObArray</I> and <I>CWordArray</I> to create <P>an array of <I>CWordArrays</I>.<P>
<h3><a name="0134_0009">The Test Program<a name="0134_0009"></h3><P>
To test the graph-optimizing GA, I created a simple Windows-hosted application using Visual C++. I used AppStudio, AppWizard, and ClassWizard to automate the creation of this program. The program uses two dialog boxes. The first dialog box allows me to specify the graph logically in terms of the number of nodes and their connections. The second allows me to specify the bounds of the grid and trigger the GA optimization of the graph on the grid. I also include options for displaying the optimized and unoptimized views of the graph. The optimized view is the best solution found by the GA; the unoptimized view is an arbitrary drawing of the graph from first node to the last. Due to the length of the test program, the complete listings for this project are available electronically; see &quot;Availability,&quot; page 3.<P>
<h3><a name="0134_000a">Conclusion<a name="0134_000a"></h3><P>
Experiments that I have conducted using the GA-based graph-drawing module demonstrate that GAs present a viable solution to the problem. By improving the fitness function and by possible use of custom genetic operators, I believe that this technique will also work in commercial CASE tools.<P>
<h3><a name="0134_000b">References<a name="0134_000b"></h3><P>
Coplien, James O. <I>Advanced C++: Programming Styles and Idioms</I>. Reading, MA: Addison-Wesley, 1992.<P>
Goldberg, David E. <I>Genetic Algorithms in Search, Optimization, and Machine Learning</I>. Reading, MA: Addison-Wesley, 1989.<P>
Michalewicz, Zbigniew. <I>Genetic Algorithms + Data Structures = Evolution Programs</I>.  New York, NY: Springer-Verlag, 1992.<P>
<h4><B> <a href="1994013a.htm">Figure 1</A>:</B> Typical directed graph.</h4><P>
<h4><B> <a href="1994013b.htm">Figure 2</A>:</B>Single-point crossover.</h4><P>
<h4><a name="0134_000c"><B>Figure 3:</B> Pseudocode detailing the GA process.<a name="0134_000c"></h4><P>
<pre>Initialize a random population and measure its fitness.
WHILE (stopping criteria has not been reached)
BEGIN
    WHILE (next generation is not full)
    BEGIN
        Select 2 parents randomly based on fitness.
        IF (Flip(pc)) THEN
            Cross parents (mutating with probability pm)
            and place children in next generation.
        ELSE
            Place parents into next generation untouched.
    END
END

Solution with highest fitness is the answer.
</pre><P>
<h4><a href="1994013c.htm">Figure 4</A>: Relationship between classes.</h4><P>
<h4><a href="1994013d.htm">Figure 5</A>: Equation to calculate the required length of a bit string.</h4><P>

<h4><a name="0134_000d"><a name="0134_000e"><B>[LISTING ONE]</B></H4>

<PRE>

//File: GRPHPHEN.H
#ifndef __GRPHPHEN_H
#define __GRPHPHEN_H

//Header for EOS class representing a phenotype.
//You need EOS v1.1 to compile this code
#ifndef __PHENO_H
#include &quot;pheno.h&quot;
#endif //__PHENO_H

class CGraphDrawingPheno : public TPhenotype
{
   public:
    CGraphDrawingPheno(CGAGraphDriver &amp;driver,int width, int height) ;
    ~CGraphDrawingPheno() ;
    double CalcFitness() ;
    void Decode(PTGenotype geno) ;
    PTPhenotype Copy()  ;
    void GetPhenoInfo(void *pInfoStruct)  ;
    void GetNearestEmptyCell(const int row, const int col, int &amp;actualRow,
                                                             int &amp;actualCol) ;
    BOOL Adjacent(WORD node1, WORD node2) ;
    BOOL Diagonal(WORD node1, WORD node2) ;
    BOOL FindNode(const WORD node, int &amp;row, int &amp;col) ;
    double Distance(WORD node1, WORD node2) ;
    double RectDistance(WORD node1, WORD node2) ;
private:
    int m_Width  ;
    int m_Height ;
    CWordMatrix *m_pGrid ;      //grid where each entry is a node
                                    //                 number or EMPTY_CELL
    CGAGraphDriver &amp;m_Driver ;  //interface to the graph driver class
    int * m_GridIndex[2] ;      //index into grid to quickly locate nodes
};


</PRE>

<h4><a name="0134_000f"><a name="0134_0010"><B>[LISTING TWO]</B></H4>

<PRE>


//File: GRPHPHEN.CPP
#include &quot;stdafx.h&quot;
//eos headers
#include &quot;eos.h&quot;
#include &quot;eosutil.h&quot;
#include &quot;geno.h&quot;

//graph GA headers
#include &quot;grphphen.h&quot;
#include &quot;wmatrix.h&quot;
#include &quot;gdriver.h&quot;
#include &quot;grphutil.h&quot;

const HIGHEST_REWARD = 10 ;
const MEDIUM_REWARD = 5 ;
const SMALLEST_REWARD = 1 ;
const HIGHEST_PENALTY = 10 ;
const MEDIUM_PENALTY = 5;
const SMALLEST_PENALTY = 1;

CGraphDrawingPheno::CGraphDrawingPheno(CGAGraphDriver &amp;driver, int width,
                                                                   int height)
    : m_Driver(driver)
{
    m_Width = width ;
    m_Height = height ;
    m_pGrid = new CWordMatrix(height,width,EMPTY_CELL) ;
    m_GridIndex[0] = new int [m_Driver.GetNumNodes()];
    m_GridIndex[1] = new int [m_Driver.GetNumNodes()];
}
CGraphDrawingPheno::~CGraphDrawingPheno()
{
    delete m_pGrid ;
    delete [] m_GridIndex[0] ;
    delete [] m_GridIndex[1] ;
}
double CGraphDrawingPheno::CalcFitness()
{
    WORD numNodes = (WORD) m_Driver.GetNumNodes() ;
    long maxDist = (m_Width + m_Height) ;
    maxDist*=maxDist;
    //set base fitness so even the worst case phenotype
        //           will not bring fitness below 0
    int connectivity = m_Driver.GetConnectivity() ;
    double base_fitness = numNodes*(numNodes-1) * maxDist ;
                                                            //* connectivity;
    double fitness = base_fitness ;
    for (WORD node1=0;node1&lt;numNodes;node1++) {
        int node1Connections=Max(m_Driver.GetNumConnections(node1),1);
        for (WORD node2=0;node2&lt;numNodes;node2++) {
            if (node1 == node2)
                continue ;
            BOOL bConnected = m_Driver.Connected(node1,node2) ;
            int node2Connections =
                                      Max(m_Driver.GetNumConnections(node2),1);
            double distance = Distance(node1,node2) ;
            distance*=distance;
            if (bConnected &amp;&amp; distance &gt; 4)  {
                fitness -= distance ;
                                       //(node1Connections+node2Connections) ;
                continue ;
                }
            if (!bConnected &amp;&amp; distance &lt;= 4)  {
                fitness -= 4/distance ;
                                        //(node1Connections+node2Connections) ;
                continue ;
                }
            }
        }
    ASSERT(fitness &gt;= 0);
    return fitness ;
}
void CGraphDrawingPheno::Decode(PTGenotype pGeno)
{
    WORD numNodes = (WORD) m_Driver.GetNumNodes() ;
    int rowAlleleLen =  m_Driver.CalcRowAlleleLength() ;
    int colAlleleLen =  m_Driver.CalcColAlleleLength() ;
    int offset = 0 ;
    for (WORD node=0;node&lt;numNodes;node++) {
        char rowAllele[16], colAllele[16] ;
                           //we know that these are no bigger than sizeof(WORD)
        for(int bit=0;bit&lt;rowAlleleLen;bit++)
            rowAllele[bit] =
                                     pGeno-&gt;GetExpressedGeneValue(offset++,0) ;
        for(bit=0;bit&lt;colAlleleLen;bit++)
            colAllele[bit] =
                                     pGeno-&gt;GetExpressedGeneValue(offset++,0) ;
        int codedRow = AllelesToInt(rowAllele,0, rowAlleleLen-1) ;
        int codedCol = AllelesToInt(colAllele,0, colAlleleLen-1) ;
        int actualRow, actualCol ;
        GetNearestEmptyCell(codedRow,codedCol,actualRow,actualCol) ;
        m_pGrid-&gt;SetAt(actualRow, actualCol, node) ;
        m_GridIndex[0][node] = actualRow ;
        m_GridIndex[1][node] = actualCol ;
        }
}
PTPhenotype CGraphDrawingPheno::Copy()
{
    CGraphDrawingPheno * pPheno =
                            new CGraphDrawingPheno(m_Driver,m_Height,m_Width) ;
    return pPheno ;
       //don't copy values because these are derived by the genotype via Decode
}
void CGraphDrawingPheno::GetPhenoInfo(void *pInfoStruct)
{
    *((CWordMatrix **)pInfoStruct) = m_pGrid ;
}
//Algorithm resolves collisions by searching around the neighborhood of
// (row,col) in the grid for an empty cell. The row and col of the empty cell
// is returned in actualRow and actualCol.
void CGraphDrawingPheno::GetNearestEmptyCell(const int row, const int col,
                                                 int &amp;actualRow,int &amp;actualCol)
{
    //insure we are in range!
    actualRow = row % m_Height ;
    actualCol = col % m_Width ;
    //if we find and empty cell then no search necessary
    if (m_pGrid-&gt;GetAt(actualRow,actualCol) == EMPTY_CELL)
        return ;
    else { //search for &quot;nearest&quot; empty cell
        int maxDist=Max(m_Height,m_Width) ;
        int actualRow2 = actualRow ; //save actuals
        int actualCol2 = actualCol ;
         //start at a distance of 1 and search outward
        for (int dist=1;dist&lt;maxDist;dist++) {
            //First check &quot;sides&quot;
            for(int i=-dist; i&lt;=dist;i++) {
                for(int j=-dist;j&lt;=dist;j++) {
                         if (i!=j &amp;&amp; (j==dist || j==-dist ||
                                                        i==dist || i==-dist)) {
                        actualCol = actualCol2+j ;
                        actualRow = actualRow2+i ;
                        if(actualCol &gt;= 0 &amp;&amp; actualCol
                                                                 &lt; m_Width &amp;&amp;
                           actualRow &gt;= 0 &amp;&amp; actualRow
                                                                 &lt; m_Height &amp;&amp;
                    m_pGrid-&gt;GetAt(actualRow,actualCol) == EMPTY_CELL)
                            return ;
                        } //if
                    } // for j
                } //for i
                //Now check 4 corner cells
                actualCol = actualCol2+dist ;
                actualRow = actualRow2+dist ;
                if(actualCol &lt; m_Width &amp;&amp;
                    actualRow &lt; m_Height &amp;&amp;
                        m_pGrid-&gt;GetAt(actualRow,actualCol) ==
                                                                   EMPTY_CELL)
                    return ;
                actualCol = actualCol2-dist ;
                actualRow = actualRow2+dist ;
                if(actualCol &gt;= 0 &amp;&amp;
                    actualRow &lt; m_Height &amp;&amp;
                    m_pGrid-&gt;GetAt(actualRow,actualCol) ==
                                                                    EMPTY_CELL)
                    return ;
                actualCol = actualCol2+dist ;
                actualRow = actualRow2-dist ;
                if(actualCol &lt; m_Width &amp;&amp;
                    actualRow &gt;= 0 &amp;&amp;
                    m_pGrid-&gt;GetAt(actualRow,actualCol) ==
                                                                    EMPTY_CELL)
                    return ;
                actualCol = actualCol2-dist ;
                actualRow = actualRow2-dist ;
                if(actualCol &gt;= 0 &amp;&amp;
                    actualRow &gt;= 0 &amp;&amp;
                    m_pGrid-&gt;GetAt(actualRow,actualCol) ==
                                                                    EMPTY_CELL)
                    return ;
            } //for dist
        } //else
    return ;
}
//Return TRUE if node1 is adjacent to node2 on the grid
BOOL CGraphDrawingPheno::Adjacent(WORD node1, WORD node2)
{
    int row1, col1 ;
    if (!FindNode(node1,row1,col1))
        return FALSE ;
    int row2, col2 ;
    //look up
    row2=row1-1 ;
    if (row2 &gt;= 0 &amp;&amp; m_pGrid-&gt;GetAt(row2,col1) == node2)
        return TRUE ;
    //look down
    row2=row1+1 ;
    if (row2 &lt; m_Height &amp;&amp; m_pGrid-&gt;GetAt(row2,col1) == node2)
        return TRUE ;
    //look left
    col2=col1-1 ;
    if (col2 &gt;= 0 &amp;&amp; m_pGrid-&gt;GetAt(row1,col2) == node2)
        return TRUE ;
    //look right
    col2=col1+1 ;
    if (col2 &lt; m_Width &amp;&amp; m_pGrid-&gt;GetAt(row1,col2) == node2)
        return TRUE ;
    return FALSE ;
}
//Return TRUE if node1 is diagonal to node2 on the grid
BOOL CGraphDrawingPheno::Diagonal(WORD node1, WORD node2)
{
    int row1, col1 ;
    if (!FindNode(node1,row1,col1))
        return FALSE ;
    int row2, col2 ;
    //look upper left
    row2=row1-1 ;
    col2=col1-1 ;
    if (row2 &gt;= 0 &amp;&amp; col2 &gt;= 0 &amp;&amp; m_pGrid-&gt;GetAt(row2,col2) == node2)
        return TRUE ;
    //look lower left
    row2=row1+1 ;
    col2=col1-1 ;
    if (row2 &lt; m_Height &amp;&amp; col2 &gt;= 0 &amp;&amp; m_pGrid-&gt;GetAt(row2,col1) == node2)
        return TRUE ;
    //look lower right
    row2=row1+1 ;
    col2=col1+1 ;
    if (row2 &lt; m_Height &amp;&amp; col2 &lt; m_Width &amp;&amp; m_pGrid-&gt;GetAt(row1,col2) ==
                                                                         node2)
        return TRUE ;
    //look upper left
    row2=row1-1 ;
    col2=col1+1 ;
    if (row2 &gt;= 0 &amp;&amp; col2 &lt; m_Width &amp;&amp; m_pGrid-&gt;GetAt(row1,col2) == node2)
        return TRUE ;
    return FALSE ;
}
//Return the Euclidean distance between nodes on the grid
double CGraphDrawingPheno::Distance(WORD node1, WORD node2)
{
    int row1, col1, row2, col2 ;
    if (FindNode(node1,row1,col1) &amp;&amp; FindNode(node2,row2,col2)) {
        double diffRow = row1 - row2 ;
        double diffCol = col1 - col2 ;
        return sqrt(diffRow*diffRow + diffCol*diffCol) ;
        }
    else
        return sqrt(m_Height*m_Height + m_Width*m_Width) ;
}
//Return the recti-linear distance between nodes on the grid
double CGraphDrawingPheno::RectDistance(WORD node1, WORD node2)
{
    int row1, col1, row2, col2 ;
    if (FindNode(node1,row1,col1) &amp;&amp; FindNode(node2,row2,col2)) {
        double diffRow = row1 - row2 ;
        double diffCol = col1 - col2 ;
        return Abs(diffRow) + Abs(diffCol) ;
        }
    else
        return m_Height + m_Width ; //really an error ?!?
}
//Use an index to quickly locate a node on the grid
BOOL CGraphDrawingPheno::FindNode(const WORD node, int &amp;row, int &amp;col)
{
    if (node &gt;= m_Driver.GetNumNodes())
        return FALSE ;
    row = m_GridIndex[0][node] ;
    col = m_GridIndex[1][node] ;
    return TRUE ;
}


</PRE>

<h4><a name="0134_0011"><a name="0134_0012"><B>[LISTING THREE]</B></H4>

<PRE>


//File: GDRIVER.H
#ifndef __GDRIVER_H__
#define __GDRIVER_H__
//flag an empty cell in the grid
const EMPTY_CELL = 0xFFFF ;

class CGAGraphDriver
{
    //Interface
public:
    CGAGraphDriver(int numNodes, int width, int height) ;
    ~CGAGraphDriver() ;
    void SetGraph(CWordMatrix &amp;graph) ;
    void Optimize(int numGenrations) ;
    void DrawOptimized(CDC &amp;dc) ;
    void DrawUnOptimized(CDC &amp;dc) ;
    //Query members (const)
    //Calc the length of a chromosome
    //needed based on the graph and grid
    UINT CalcChromosomeLength() const ;
    UINT CalcRowAlleleLength() const ; ;
    UINT CalcColAlleleLength() const ; ;
    int GetWidth() const ;
    int GetHeight() const ;
    int GetNumNodes() const ;
    BOOL Connected(WORD node1, WORD node2)  const;
    int GetNumConnections(WORD node) const ;
    int GetConnectivity() ;
    void Stop() ;
    PTIndividual m_pBest ;
    PTIndividual m_pWorst ;
    BOOL m_Stop ;
    //Implementation
private:
    //Draw the graph in this grid
    void Draw(CDC &amp;dc, CWordMatrix &amp;Grid) ;
    //num nodes in the graph
    int m_NumGraphNodes ;
    //width of grid to draw on (in cells)
    int m_GridWidth ;
    //height of grid to draw on (in cells)
    int m_GridHeight ;
    //connection table representation of a graph
    CWordMatrix *m_pGraph ;
    //GA that will find the &quot;optimal&quot; drawing
    //of the graph on the grid
    TBasicGA  *m_pTheGA ;
} ;


</PRE>

<h4><a name="0134_0013"><a name="0134_0014"><B>[LISTING FOUR]</B></H4>

<PRE>


//File: GDRIVER.CPP
//Used as an interface class to the GA.
//Stores the representation of the graph as
//a connection grid.

//required headers
#include &quot;stdafx.h&quot;

//Headers needed for EOS programs
//You need EOS v1.1 to compile this code
#include &quot;eos.h&quot;
#include &quot;eosutil.h&quot;
#include &quot;geno.h&quot;
#include &quot;individ.h&quot;
#include &quot;gaenviro.h&quot;

//headers specific to graph GA
#include &quot;wmatrix.h&quot;
#include &quot;gdriver.h&quot;
#include &quot;grphutil.h&quot;
#include &quot;graphga.h&quot;

//GA parameters used, these need not be
//hard coded in advanced implementations
const int POP_SIZE = 20 ;
const double PX = 0.7 ;
const double PM = 0.03 ;
const double RAND_SEED=0.76451 ;

//DRAWING parameters used, these need not be
//hard coded in advanced implementations
const int CELL_WIDTH = 30 ;
const int CELL_HEIGHT = 30  ;
const int CELL_SPACE = 30 ;

//Driver constructor initializes a graph with  numNodes and a
//grid that the graph will be optimized to draw on (width x height)
CGAGraphDriver::CGAGraphDriver(int numNodes, int width, int height)
{
    m_NumGraphNodes = numNodes;
    m_GridWidth = width ;
    m_GridHeight = height ;
    //graph represented as boolean connection matrix
    m_pGraph = new CWordMatrix(m_NumGraphNodes,m_NumGraphNodes) ;
    //The Graph GA object
    m_pTheGA = new CGraphDrawerGA(*this) ;
    m_pBest = NULL ;
    m_pWorst = NULL ;
    m_Stop = FALSE ;
}
//Clean up in the destructor
CGAGraphDriver::~CGAGraphDriver()
{
    delete m_pGraph ;
    delete m_pTheGA ;
}
//set the conections from graph into the member m_pGraph
void CGAGraphDriver::SetGraph(CWordMatrix &amp;graph)
{
    for (int row = 0 ; row &lt; m_NumGraphNodes; row++)
        for (int col = 0 ; col &lt; m_NumGraphNodes; col++)
            m_pGraph-&gt;SetAt(row,col,graph[row][col]) ;
}
// Optimize the drawing of the graph by first initializing the GA's population
// and environment. Then execute the GA for numGenerations generations
void CGAGraphDriver::Optimize(int numGenerations)
{
    m_pTheGA-&gt;CreatePopulation(POP_SIZE) ;
    m_pTheGA-&gt;CreateEnvironment(PX,PM,RAND_SEED) ;
    m_pTheGA-&gt;Evolve(numGenerations) ;
}
//Draw the optimized graph on the Windows DC
void CGAGraphDriver::DrawOptimized(CDC &amp;dc)
{
    CWordMatrix *pGrid ;
    m_pBest-&gt;GetPhenoInfo(&amp;pGrid) ;
    Draw(dc,*pGrid) ;
}
//Draw the un-optimized graph on the Windows DC
void CGAGraphDriver::DrawUnOptimized(CDC &amp;dc)
{
    CWordMatrix *pGrid ;
    m_pWorst-&gt;GetPhenoInfo(&amp;pGrid) ;
    Draw(dc,*pGrid) ;
}
void CGAGraphDriver::Draw(CDC &amp;dc, CWordMatrix &amp;Grid)
{
    CPen *pPen = (CPen *) dc.SelectStockObject(BLACK_PEN) ;
    for (int row = 0 ; row &lt; m_GridHeight; row++)
        for (int col = 0 ; col &lt; m_GridWidth; col++) {
           if (Grid[row][col] != EMPTY_CELL)  {
              int x1 = col * (CELL_WIDTH + CELL_SPACE) + CELL_SPACE ;
              int x2 = x1 + CELL_WIDTH    ;
              int y1 = row * (CELL_HEIGHT + CELL_SPACE)  + CELL_SPACE ;
              int y2 = y1 + CELL_HEIGHT   ;
              dc.Ellipse(x1,y1,x2,y2) ;
              char buffer[4] ;
              sprintf(buffer,&quot;%d&quot;,Grid[row][col]) ;
              dc.TextOut(x1+CELL_WIDTH/4,y1+CELL_HEIGHT/4,buffer,
                                                              strlen(buffer)) ;
              }
           }
    //draw arcs
    for (int node1 = 0 ; node1 &lt; m_NumGraphNodes; node1++)
        for (int node2 = 0 ; node2 &lt; m_NumGraphNodes; node2++)
            if (m_pGraph-&gt;GetAt(node1,node2)) {
               int row1, col1 ;
               Grid.Find(node1, row1, col1) ;
               int row2, col2 ;
               Grid.Find(node2, row2, col2) ;
               int x1 = col1 * (CELL_WIDTH + CELL_SPACE) + CELL_SPACE ;
               int x2 = col2 * (CELL_WIDTH + CELL_SPACE) + CELL_SPACE ;
             int y1 = row1 * (CELL_HEIGHT + CELL_SPACE)  + CELL_SPACE ;
             int y2 = row2 * (CELL_HEIGHT + CELL_SPACE)  + CELL_SPACE ;
             if (x1 &lt; x2)
             x1 += CELL_WIDTH ;
             else
                if (x2 &lt; x1)
                    x2 += CELL_WIDTH ;
                else
                if (x1 == x2) {
                    if (Abs(row1 - row2) &gt; 1) { //route around!
                        y1 += CELL_WIDTH/2 ;
                        y2 += CELL_WIDTH/2 ;
                        int x3 = x1 - CELL_WIDTH/2 ;
                        dc.MoveTo(x1,y1) ;
                        dc.LineTo(x3,y1) ;
                        dc.LineTo(x3,y2) ;
                        dc.LineTo(x2,y2) ;
                        continue ;
                        }
                    x1 += CELL_WIDTH/2 ;
                    x2 += CELL_WIDTH/2 ;
                    }
                if (y1 &lt; y2)
                    y1 += CELL_HEIGHT ;
                else
                if (y2 &lt; y1)
                    y2 += CELL_HEIGHT ;
                else
                if (y1 == y2) {
                    if (Abs(col1 - col2) &gt; 1) { //route around!
                        if (x1 &lt; x2) {
                            x1 -= CELL_WIDTH/2 ;
                            x2 += CELL_WIDTH/2 ;
                            }
                        else {
                            x1 += CELL_WIDTH/2 ;
                            x2 -= CELL_WIDTH/2 ;
                            }
                        int y3 = y1 - CELL_HEIGHT/2 ;
                        dc.MoveTo(x1,y1) ;
                        dc.LineTo(x1,y3) ;
                        dc.LineTo(x2,y3) ;
                        dc.LineTo(x2,y2) ;
                        continue ;
                        }
                    y1 += CELL_HEIGHT/2 ;
                    y2 += CELL_HEIGHT/2 ;
                    }

                dc.MoveTo(x1,y1) ;
                dc.LineTo(x2,y2) ;
                }

    dc.SelectObject(pPen ) ;
}
//Calculate the length of the chromosome needed to encode
//a drawing of the graph in a grid
UINT CGAGraphDriver::CalcChromosomeLength() const
{
       return m_NumGraphNodes*(GetNumBitsToEncode(m_GridHeight) +
                                              GetNumBitsToEncode(m_GridWidth));
}
UINT CGAGraphDriver::CalcRowAlleleLength() const
{
    return (UINT) GetNumBitsToEncode(m_GridWidth) ;
}

UINT CGAGraphDriver::CalcColAlleleLength() const
{
    return (UINT) GetNumBitsToEncode(m_GridHeight) ;
}
//Return TRUE if node1 is connected to node2
BOOL CGAGraphDriver::Connected(WORD node1, WORD node2) const
{
    return  m_pGraph-&gt;GetAt(node1,node2) ;
}
//Returns the  number of connection leaving node
int CGAGraphDriver::GetNumConnections(WORD node) const
{
    int count = 0 ;
    for (WORD i=0;i&lt;m_NumGraphNodes;i++)
        if (i != node &amp;&amp; m_pGraph-&gt;GetAt(node,i))
            count++ ;
    return count ;
}
//Returns the total number of connections in the graph
int CGAGraphDriver::GetConnectivity()
{
    int count = 0 ;
    for (WORD node1=0;node1&lt;m_NumGraphNodes;node1++)
        for (WORD node2=0;node2&lt;m_NumGraphNodes;node2++)
            if (node1 != node2 &amp;&amp; m_pGraph-&gt;GetAt(node1,node2))
                count ++ ;
    return count ;
}
void CGAGraphDriver::Stop()
{
    m_Stop = TRUE ;
}


</PRE>

<h4><a name="0134_0015"><a name="0134_0016"><B>[LISTING FIVE]</B></H4>

<PRE>

//File: GRAPHGA.H
#ifndef __GRAPHGA_H__
#define __GRAPHGA_H__

//Headers needed for EOS programs
//You need EOS v1.1 to compile this code
#ifndef __BASICGA_H
#include &quot;basicga.h&quot;
#endif

class CGraphDrawerGA : public TBasicGA
{
public:
    CGraphDrawerGA(CGAGraphDriver &amp;driver) ;
    void CreatePopulation(long size, PTIndividual prototype = NULL) ;
    void ExitReport() ;
private:
    BOOL Stop() ;
    void InterGeneration(ulong, PTIndividual, PTIndividual, PTIndividual,
                                                                PTIndividual) ;
    CGAGraphDriver &amp; m_Driver ;
};
#endif


</PRE>

<h4><a name="0134_0017"><a name="0134_0018"><B>[LISTING SIX]</B></H4>

<PRE>


//File: GRAPHGA.CPP

#include &quot;stdafx.h&quot;

//Headers needed for EOS programs
//You need EOS v1.1 to compile this code
#include &quot;eos.h&quot;
#include &quot;geno.h&quot;
#include &quot;basicga.h&quot;
#include &quot;nptxgeno.h&quot;
#include &quot;genrepop.h&quot;
#include &quot;gaenviro.h&quot;

//headers specific to graph GA
#include &quot;gdriver.h&quot;
#include &quot;graphga.h&quot;
#include &quot;graphind.h&quot;
#include &quot;grphphen.h&quot;
#include &quot;wmatrix.h&quot;

CGraphDrawerGA::CGraphDrawerGA(CGAGraphDriver &amp;driver)
    : m_Driver(driver)
{
}
//Create the population of individuals
//We use 2 Point Crossover and Elitism
void CGraphDrawerGA::CreatePopulation(long size, PTIndividual prototype)
{
    //Create a genotype with 1 chromosome and 2 point crossover
    //The graph driver is queried to determine the chromosome length
    PTNPtCrossGenotype pGeno =
                   new TNPtCrossGenotype(m_Driver.CalcChromosomeLength(),1,2) ;
    CGraphDrawingPheno * pPheno =
        new CGraphDrawingPheno(m_Driver,m_Driver.GetWidth(),
                                m_Driver.GetHeight()) ;
    CGraphDrawingInd indiv(pGeno,pPheno);
    m_pPopulation = new TGenReplacePopulation(size,&amp;indiv) ;
    m_pPopulation-&gt;SetElitism(2) ;
}
//When the GA is done set the best and worst individuals in the driver
void CGraphDrawerGA::ExitReport()
{
    m_Driver.m_pBest = m_pEnvironment-&gt;GlobalFittestIndivid ;
    m_Driver.m_pWorst = m_pEnvironment-&gt;GlobalWorstIndivid ;
}
//allow for windows processing!
void CGraphDrawerGA::InterGeneration(ulong, PTIndividual, PTIndividual,
                                                   PTIndividual, PTIndividual)
{
    MSG msg ;
    //while there are msgs for status window
    while (PeekMessage(&amp;msg,AfxGetApp()-&gt;m_pMainWnd-&gt;
                                                    m_hWnd,0,0,PM_REMOVE)) {
        TranslateMessage(&amp;msg) ;
        DispatchMessage(&amp;msg) ;
        }
    SetCursor(LoadCursor(NULL, IDC_WAIT));
}
//GA calls this function to determine if it should stop
BOOL CGraphDrawerGA::Stop()
{
    return m_Driver.m_Stop ;
}
</pre><HR><P>Copyright &copy; 1994, <I>Dr. Dobb's Journal</I></P></BODY></HTML>
