<HTML>
<META NAME="year" CONTENT="1994">
<HEAD>
<TITLE>MAR94: LETTERS</TITLE></HEAD>
<BODY BGCOLOR="#ffffff">
<h1>LETTERS<a name="00ba_0001"></h1><P>
<h3><a name="00ba_0002">Comparing Object-oriented Languages<a name="00ba_0002"></h3><P>
Dear <I>DDJ</I>,<P>
Referring to &quot;Comparing Object-oriented Languages&quot; by Michael Floyd (<I>DDJ</I>, October 1993), lines of code (LOC) is not at all a poor measure of programmer productivity. On the contrary, it is an excellent measure of unprofessional and careless programming.<P>
For example, if a certain piece of code can be done in 100 lines in two days (50 LOC/day), and someone does it in 1000 lines in four days (250 LOC/day), he isn't five times more productive--he's 50 percent less productive. The elapsed time is double, and the product is ten times larger with the corresponding additional costs for verification, distribution, and maintenance.<P>
Assuming that these additional costs are half the cost of the project, and that they grew just a factor of 5 because the larger code is simpler (which is not necessarily true), the cost of the project is now three times what it should have been.<P>
Professor E.W. Dijkstra once rightly said that programmers should be charged for every line of code they write, rather than get paid for it.<P>
If you look at the numbers in Table 1 of the article, someone whose pay is based on LOCs would think that the &quot;best&quot; object-oriented language is Eiffel. Assuming experienced programmers require about the same effort, the Eiffel programmer was 80 percent more &quot;productive&quot; than the C++ programmer!<P>
Jony Rosenne<P>
Tel Aviv, Israel<P>
<I>Michael responds</I>: Thanks for your comments, Jony. I believe that you present valid arguments when coding with procedural languages. But object-oriented programming adds a new variable to the equation, namely reusability. Designing a class to be reusable takes longer than its procedural counterpart. The process usually involves an analysis of the overall design to identify components that may be useful in more than one context. Such components are likely candidates for abstraction. Often, however, this is an iterative process of designing, coding, redesigning, and recoding. Ultimately, a full-featured class designed for reuse is sure to increase the overall line count. The short-term result is that building reusable classes takes longer, costs more to develop each line of code, and increases the overall line count. However, the long-term benefit is that the same code costs no more to use again.<P>
The point of my ending comment was to raise the reader's awareness of a new problem. Assuming you can measure code reuse in the first place, is the pain of developing reusable classes worth the gain? And, if you're ready to buy into it, how do you promote reuse in your company? More to the point, how do you reward the programmer for developing reusable code?<P>
Dear <I>DDJ</I>,<P>
I was dumbfounded by your inclusion of an obscure language such as Drool and exclusion of as popular a language as Actor from your article in the October 1993 issue of <I>DDJ</I>. There are over 30,000 registered users of Actor. It is up-to-date with Windows 3.1, and it's commercially available today (Version 4.0) despite serious disinterest by its new owner, Symantec.<P>
Actor is very much in use and very much an issue in Windows-based OO development. It was, after all, the first OOPL available commercially for Windows development. It was and is still a purely object-oriented language. A number of its most vocal enthusiasts have begun a constant drumbeat in the technical media, which we hope will culminate in the language's separation from Symantec and reentry into the Windows commercial-development arena (see my article in the August 1993 <I>Windows/DOS Developer's Journal</I> on Actor 4.1). Most of Actor's third-party supporters--Tempus Software, BOK Technologies, and The Windows Wurx--have agreed to bundle their Actor add-ons with the product at virtually no cost to infuse some new life.<P>
I find it very hard to believe <I>DDJ </I>doesn't keep up on Actor at all but manages to keep in touch with the likes of Drool, Beta, Sather, and Eiffel.<P>
Richard L. Warren<P>
CompuServe 70750,3436<P>
Dear <I>DDJ</I>,<P>
Your October, 1993 article, &quot;Comparing Object-oriented Languages&quot; provided just the sort of information that keeps me buying <I>DDJ</I>. Articles about OOP are always of interest to me, and it is refreshing to see languages other than C/C++ receive coverage.<P>
Another object-oriented language readers may be interested in is &quot;Mops.&quot; Mops is the work of one (very talented) individual, Michael Hore of Australia. The language is consistent and easy to learn, benefitting from one man's vision. The basic syntax is derived from a commercial product that first appeared in 1984 (Neon), so the language is &quot;proven.&quot;<P>
<a href="#00ba_0004">Example 1</A> shows a Mops coding example that's very short because it conveniently already has number (<I>var</I>) and point classes that respond in a meaningful way to a print message (<I>print:</I>). <a href="#00ba_0004">Example 1</A> shows how the point class might be defined in Mops.<P>
Doug Hoffman<P>
CompuServe 72310,1743<P>
Dear <I>DDJ</I>,<P>
I read your October 1993 issue with great dismay--here is an issue ostensibly devoted to object-oriented programming languages that does not mention Oberon-2. I am disturbed because: 1. Somehow Oberon-2 was not selected for illustration; and 2. it was not even mentioned in the discussion of OOP languages. While I understand that there are many such languages and that in depth coverage of all would likely be impossible, I am puzzled since some of the languages you <I>did </I>see fit to cover probably do not have a volume of written code comparable to that of Oberon-2. Several excellent code examples as well as the Oberon operating system illustrate the capabilities of this well-thought-out evolution of structured, modular programming languages.<P>
Also not included was Modula-3. It is distressing that in the article, &quot;Comparing Object-Oriented Languages,&quot; Ada is used to provide an approximation of the doubly linked list example. Modula-3 would have been, in my opinion, a better choice. In fact, there is an excellent set of software components that includes the doubly linked list case, but also provides iterators and the like for accessing and operating on this list of possibly heterogeneous node types: It is written with Modula-2! (<I>The Modula-2 Software Component Library</I>, C. Lins, Springer-Verlag.)<P>
The second matter that concerns me is the lexicon that has developed in the object-oriented programming arena. I have difficulty when simple concepts such as type extension and procedure variables (and their combinations) become mired in terminology that largely obscures rather than describes or defines. I will agree that OOP comes into its own under large, complex system conditions and certainly impacts program design in a fundamental manner, but then this is analogous to the effect on programming that record, enumeration and pointer types, and structured-programming constructs had at their introduction. Unfortunately, in the case of object-oriented programming languages, we are speaking of enhancements to existing concepts, principally type extension and broad use of procedure variables, rather than the introduction of new concepts. Yet these relatively simple (and powerful) notions are confounded or lost in the egregious sea of OOP-speak.<P>
Perhaps I must simply give in and recognize that we (in the U.S., anyway) are living in a &quot;mono-C-istic'' programming society. I hope, however, that this is not, and will not be the case.<P>
Michael A. McGaw<P>
Fairview Park, Ohio<P>
<I>DDJ responds: </I>Our thanks to the many readers who wrote in with similar concerns about the coverage of so-called &quot;obscure'' languages like Drool, Beta, Sather, and Parasol. Because space considerations prevent analysis of every object-oriented language in a single issue, the October issue provided a cross-section with special attention given to nonproprietary languages. In particular, Drool and Parasol are in the public domain with complete source code available in the DDJ Forum on CompuServe.<P>
<h3><a name="00ba_0003"><I>Now On To Forth_<a name="00ba_0003"></I></h3><P>
Dear <I>DDJ</I>,<P>
Forth <I>is </I>an extensible language but Michael Swaine's example in <I>DDJ </I>(November 1993) doesn't extend Forth any more than writing a function extends C. Extending a language would be like adding the syntax:<P>
<pre>
LOOP
<B>_</B>
EXIT  IF  (condition)
<B>_</B>
ENDLOOP
</pre><P>
to Fortran or making <I>complex </I>a new elementary data type in C with exactly the same standing as <I>int </I>--reserved word and all.<P>
The syntax of Forth is extremely simple: &quot;Words'' are character strings delimited by whitespace. The semantics of Forth are simple, too; nearly all words are imperative verbs:<P>
<UL>
<li>Some few &quot;defining'' words add words to the dictionary, so the first time a user-defined word appears, the defining word puts it in the dictionary.</li>
<li>Thereafter, the newly defined word is an imperative verb.</li>
<li>A few &quot;immediate&quot; words are executed during compilation.</li>
<li>Most words are not executed during compilation--they are &quot;compiled&quot; into the dictionary during compilation.</li>
</UL>
Because of these two simplicities, the Forth compiler can be exposed to the programmer. (The source code for the fig-Forth text interpreter, compiler, and keyboard debugger fits on a screen of 16 lines of 64 characters with plenty of whitespace.) Extending Forth consists of defining: 1. new immediate words which have a compile-time effect, and 2. new defining words.<P>
A truly marvelous feature of Forth allows the programmer to specify the compile-time effect of new defining words and the run-time effect of words defined by the new defining word. The corresponding chore in, for example, C would require:<P>
<UL>
<li>Defining the new syntax so that it isn't ambiguous and doesn't conflict with existing syntax (nontrivial).</li>
<li>Defining the semantics of the new syntax (pretty easy).</li>
<li>Altering the parser and diagnostics of the compiler to recognize and diagnose the new syntax (without impact on parsing or diagnosing old syntax!).</li>
<li>Altering the code generator so that the new target code implements the new semantics (without impacting such things as register usage, optimizers, and so forth).</li>
</UL>
The fig-Forth text interpreter, keyboard debugger and compiler looks something like <a href="#00ba_0005">Example 2</A>. While some programmers are attracted to Forth by its simplicity and compactness, others are attracted by extensibility. Some of the first object-oriented languages I ever saw were implemented by extension of Forth.<P>
William E. Drissel<P>
Grand Prairie, Texas<P>

<h4><a name="00ba_0004"><B>Example 1:</B> Mops code sample.<a name="00ba_0004"></h4><P>
<pre>:class point super{ object }  \ begin class definition, superclass is object
    int x   \ declare an instance variable of type integer, named x
    int y   \ declare an instance variable of type integer, named y

:m put:  ( x y -- )      \ begin put: method definition. x, y passed via Forth stack
    put: y   \ use put: methods of the int ivars to store values from stack
    put: x
;m  \ end method definition

:m get:  ( -- x y )  \ stuff between parentheses is just a Forth stack picture
     get: x  \ x and y will be &quot;gotten&quot; to the Forth stack, ready for any use
     get: y
;m

:m print:
    get: self . . \ finally, we actually use some Forth, the dot (.) to print
;m

;class  \ end class definition
</pre><P>
<h4><a name="00ba_0005"><B>Example 2: </B>A Forth interpreter, compiler and debugger, in pseudocode.<a name="00ba_0005"></h4><P>
<pre>
forever {
     get the next word (delimited by whitespace)
     look it up in the dictionary
     if found
          if we are compiling
               if the word is immediate
                    execute the word
               else
                  &quot;compile&quot; the word into the dictionary
          else
               execute the word
     else //(not found, must be a number or undefined)
          if it's a number
               &quot;compile&quot; a literal into the dictionary
          else
               send word followed by &quot;?&quot; to screen
               stop compiling
               flush interpreter into buffer
}  // end of forever
</pre><HR><P>Copyright &copy; 1994, <I>Dr. Dobb's Journal</I></P></BODY></HTML>
