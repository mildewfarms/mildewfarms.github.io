<HTML>
<META NAME="year" CONTENT="1994">
<HEAD>
<TITLE>JUN94: PROGRAMMING PARADIGMS</TITLE></HEAD>
<BODY BGCOLOR="#ffffff">
<h1>PROGRAMMING PARADIGMS<a name="01cb_0003"></h1><P>
<h2><a name="01cb_0001"><a name="01cb_0000">Mushroom Programming for Newton</h2><P>
<h3>Michael Swaine</h3><P>
<a name="01cb_0002"><a name="01cb_0000">I admit, somewhat sheepishly, that the source code for a Newton application accompanies this column.  Why, you ask; and I ask myself, is this an exercise in futility?<P>
The computer press has not been easy on Apple's Newton MessagePad, the purported realization of John Sculley's dream of a Personal Digital Assistant. Jokes are made, and references to the Apple III and the Lisa occur with distressing frequency.<P>
Distressing, at least, to someone who has invested in Newton's future by buying a MessagePad, a developer's kit, a place at the developer's conference, and so on. I have the receipts in front of me now, as motivation.<P>
But I am not downhearted. I take solace in this truth: Newton is a technology, not a platform. Writing for Newton doesn't mean writing for the MessagePad, or the MessagePad 100, as the original has been renamed now that there's a new and improved model 110. Certainly there were problems with the 100, and certainly not all of them have been solved in the 110, although it is a significant improvement on the original design.<P>
The 110 has a faster infrared beaming port (38.4 kbps instead of 19.2), different power system, more internal RAM (1 Mbyte total rather than 640 Kbytes, which works out to a big proportional increase in user-usable RAM), a slightly different form factor, a slightly different size of screen, a different pen, a flip-up lid, and a new ROM that includes deferred recognition and a try-by-letter recognition option. The ROM is available as an upgrade for the original MessagePad. Deferred recognition should mean the difference between usability and unusability in some note-taking situations.<P>
<h3><a name="01cb_0004">Newton's Flaws<a name="01cb_0004"></h3><P>
But I believe that the significance of the MessagePad's handwriting deficiencies has been inflated. In my humble opinion, the main technical problems with the original Newton MessagePad, in decreasing order of importance, were:<P>
<OL>
<LI>There was no built-in modem. Isn't that a rather serious flaw in a so-called communication device?</LI>
<LI>It didn't fit in the average pocket. It just missed, but that was a big miss for a so-called portable device. Maybe everybody at Apple carries a bag, but some of us out here grew up in the Midwest and rely on our pockets.</LI>
<LI>It was buggy. This was less serious. Okay, it was unacceptable, but it was also predictable. This is a very new technology. This was version 1.0. There's a ROM upgrade.</LI>
<LI>The handwriting recognition failed to recognize handwriting often enough to make the device unusable as a meeting note-taker, which is just what any computer journalist would try to use it for if given the slightest encouragement.</LI>
</OL>
I regard the handwriting problem as being not as serious as the other problems mentioned, although it has received most of the press. That was Apple's fault. The worst problem with the machine, in fact, was Apple's positioning of it. If you ask me, it should have been sold as a device for communications, name-and-address storage, to-do lists, and appointment reminders. The note-taking capability and handwriting recognition should have been presented as a novelty feature, a hands-on demo of technology under development, an ATG (Advanced Technology Group, also known as &quot;Alan's Toys and Games&quot;) freebie.<P>
<h3><a name="01cb_0005">Life Stinks, or <I>BYTE</I>'s Reality<a name="01cb_0005"></h3><P>
Which brings me back to the question that motivated my writing a Newton app: What is a Newton good for?<P>
Apparently not for implementing the game of Life. <I>DDJ</I> contributing editor David Betz described his efforts in this direction in the March 1994 issue of <I>BYTE</I>. He found NewtonScript grindingly slow for this application. Okay, scratch that.<P>
For what it's worth, I'd say that the current Newton devices are well adapted to three kinds of applications:<P>
<OL>
<LI>Personal Information Manager (PIM) stuff. Electronic to-do lists, appointment calendars, name-and-address databases. Small apps you'd like to carry around in your pocket. (Oops. The pocket problem again.)</LI>
<LI>Communications. A built-in modem is still lacking, but the pager on a PCMCIA card is amazing, and the two-way cellular communication from a Newton device redefines portable computing.</LI>
<LI>What I think of as &quot;tap apps&quot;--applications that don't require much typing or writing. These apps just ask the user to tap a few buttons or menu choices, then return some brief text or illustration. Mobile kiosks, you might call them. This is not a real category, of course; it could include anything from a calculator to an expert system for medical diagnosis. But it seems like a reasonable way of thinking about the question of how to make the Newton useful, a question that would be heavy on your mind, too, if you had these receipts in front of you.</LI>
</OL>
And in fact I think expert systems are not at all a bad idea for Newton applications.<P>
<h3><a name="01cb_0006">AI Lite<a name="01cb_0006"></h3><P>
Why expert systems?<P>
The interface seems right. Expert systems, at least those I've come across, typically take input from users in small chunks and return brief textual opinions (possibly augmented by lengthy explanations). Sounds good for a device with a small black-and-white screen.<P>
Expert systems need not be compute-heavy apps that require heavy iron. Even a Newton ought to have the horsepower for a simple expert system. That suggests a subtle third point.<P>
Devices like Newton could spur interest in truly simple expert systems. AI lite. Users might have quite different expectations of an expert system that can be carried in the pocket (oops, the pocket problem again) and that boots (machine and app) in four seconds or so.<P>
Imagine using an expert system in the field on your conventional portable computer. If you have to turn on the portable, wait through its boot cycle, load the app, and take an occasional hike in the middle of using it to get an answer to a question (portable or not, you don't want to move a computer while it's running), you probably aren't going to be satisfied with a response of &quot;Gee, I dunno.&quot;<P>
Now picture using a handheld device that is carried in your pocket (let's imagine that Apple can crack the pocket problem) and can be consulted in a few seconds. You might shrug off a &quot;Gee, I dunno&quot; response more philosophically.<P>
For some situations, it seems to me, the place where you need that expert advice is in the field, and the time when you need it is ASAP, and pretty good right now is better than excellent some time later. Small expert systems might be ideal in such situations. (You'll notice that I don't actually name any such situations, but take it on faith that there are some.)<P>
Anyway, whether there's a market or not, I'm writing a small expert system for Newton. This month you'll see the application shell and the user interface. Next month, I'll present the inference engine and the knowledge-base structure.<P>
A two-part presentation actually makes sense. The project as I've conceived it breaks down nicely into the front-end and back-end components: the UI and the smarts. Since the Newton Toolkit (NTK) provides an abundance of templates for user-interface development, this first part of the project is mainly an exercise in using the NTK and its templates. On the other hand, the NTK doesn't provide any templates or classes for what I'll be doing in the second half, so that'll be more an exercise in writing NewtonScript code. Just so you know, I mean an exercise for the author, not the reader. You'll be watching me learn here. Scary for all concerned.<P>
<h3><a name="01cb_0007">A Fungus Amongus<a name="01cb_0007"></h3><P>
I wanted a tool I could take with me into the woods when I go hunting for mushrooms. It didn't have to give authoritative advice on mushroom species, but it should help me decide whether it was worth throwing the latest find in the basket to take home and look up in my mushroom books. A fallible but helpful advisor.<P>
That sounded like a good candidate for a tap app. Tap to select mushroom features like color and cap shape, tap a button to start the identification, and read off the identification in a text field.<P>
Some mushrooms can be identified from a few features, some require more. The program should accept partial data. It should also allow refinement of the feature list: Hmm, that identification doesn't look right; let's try calling this thing red rather than brown. Or: Here's another mushroom like that last one I identified, but it has a scaly stem; I'll change just that feature and ask for another identification. And, so that I can learn which features matter in identifying different kinds of mushrooms, it should give feedback on what features it used in making its decision, but this information should be shown only on request.<P>
It was clear that the program would need to display a hierarchy of mushroom features, since over 100 features might be relevant for some identifications. For the current version, though, I restricted it to a single screen of feature choices.<P>
<h3><a name="01cb_0008">Frame and Fortune<a name="01cb_0008"></h3><P>
A frame is a ubiquitous data structure in NewtonScript, and <a href="#01cb_000b">Listing One</A> (page 137) consists of a collection of frames. A frame consists of an unordered collection of slots, each of which comprises a label and a value. The slot's value can be any data type, including a frame or a function. You access a slot's value using dot notation; see <a href="#01cb_000a">Example 1(a)</A>.<P>
Methods are defined for frames by creating slots whose values are functions. NewtonScript uses braces to enclose the frame and commas to separate the slots, so you can create a frame like <a href="#01cb_000a">Example 1(b)</A>. The top-level frames in <a href="#01cb_000b">Listing One</A> define views, which are UI components.<P>
In creating views, NTK lets you select from a lot of predefined elements called &quot;prototypes,&quot; or &quot;protos.&quot; I used the supplied application-shell proto named <I>protoApp</I> to create the base view, <I>Mushrooms</I>, for the program Fungus. ProtoApp comes with slots for a title, view bounds, format, various flags, attributes, methods, and a required slot named <I>declareSelf</I>, which has a default value of <I>'base</I> for an application, and which identifies the view to the system. (The single quote in front of base identifies it as a symbol.)<P>
You can add slots, of course, to any view that you construct using this or any proto. <I>ViewSetupFormScript</I> is a standard method, executed before any of a view's other slots are evaluated. It's the place to set screen coordinates of the view, for example. Now that Apple has come out with a second MessagePad (the 110) with different screen dimensions, it's important to create views that work with different screen sizes. The code in <I>viewSetupFormScript</I> sizes the view to fit the screen. All subviews should then be sized to fit in this view, and I confess I haven't done that yet.<P>
The observations frame holds the features selected by the user. Its collection of frames will grow as I add more features to be identified, and I'll probably have to rework other parts of the program if these features become hierarchical, as they should; see <a href="#01cb_000a">Example 1(c)</A>.<P>
The <I>advisor</I> method will be replaced by a simple expert-system advisor. These are just a few If/Then tests to let the app return some kind of identification based on the observations.<P>
The <I>_proto</I> slot identifies this view as having been derived from the <I>protoApp</I> proto. The <I>_proto</I> slot defines an inheritance path in one of NewtonScript's two inheritance mechanisms. A view can inherit from its proto (in this case a system proto residing in ROM) and from its parent view. This base view, <I>Mushrooms</I>, is the parent view for all the other views in this program. They normally have access to its slots, but not vice versa. There is a mechanism for making child views visible to the parent: You declare the child to the parent. This installs an extra slot in the parent, pointing to the child. It has some overhead, and you should only do it when necessary. I use it with the <I>MessageBox</I> and <I>Size</I> views in this app.<P>
<h3><a name="01cb_0009">The Kids Are All Protos<a name="01cb_0009"></h3><P>
Most of the user's selection of mushroom features is handled using views based on the <I>protoLabelInputLine</I> proto. This displays a label with a dotted line next to it. When you tap on the label, a list of possible values pops up. Tapping on one of these selects it, displays it on the dotted line, and places it in a slot of the view. <a href="#01cb_000b">Listing One</A> shows one of the views based on this proto.<P>
The normal way of reading off the user's selection with this proto is by using the <I>textChanged</I> method. The <I>MessagePad</I> has a fixed Undo button at the bottom of its screen, so you can add undo capability wherever it's appropriate. Undoing a selection in this view is a simple matter of putting back the previous selection, so I implemented that. It's necessary to register the undo method with the system, since the Undo button belongs to the system, rather than to your app.<P>
<a href="#01cb_000b">Listing One</A> also shows how I implemented a slider, adding two extra views, one to display a label like those of the <I>protoLabelInputLine</I> views, and one to display the slider's value as a number of centimeters. Declaring the latter to the base view and having the slider view message the base view to update the centimeter display view is one way to synchronize these two sibling views, the slider, and the centimeter display. I doubt, however, that it's the best way.<P>
The last two views in the listing are the <I>Advise</I> and <I>MessageBox</I> views. The only interesting thing about the <I>Advise</I> view, which defines the button the user taps to start the identification, is that it's a picture button. You can include PICT-format pictures in Newton apps, for illustrations or icons, by placing them in resource files and choosing a menu item that adds the files. Figuring I'd let Apple do as much work for me as possible, I created this button's icon using a mushroom picture that I found in the Apple-supplied HyperCard art-bits stack.<P>
The <I>MessageBox</I> view displays the identification to the user. Its text slot is initialized to a brief introductory message. <I>MessageBox</I> is declared to the base view, <I>Mushrooms</I>, so that the base view can update its text slot with the identification.<P>
Programming with the NTK at this level is a mixture of coding and visual programming. You do a certain amount of clicking and dragging to initially create your views, then add functionality by writing methods. Next month will be all coding, though, as I try to put some smarts into the <I>Advisor</I> method.<P>
<pre></pre><P>
<h4><a name="01cb_000a"><B>Example 1: </B>(a) Accessing a slot's value using dot notation; (b) using braces to enclose the frame and commas to separate the slots so as to create a frame; (c) hierarchical approach to mushroom program.<a name="01cb_000a"></h4><P>
<pre>
<b>(a)</b>
viewBounds.top := b.appAreaTop + 2

<b>(b)</b>
myFrame := {
  slot1 : 1000,
  frameSlot : {
    name : &quot;David&quot;,
    game : &quot;Life&quot;
  },
  methodSlot : 
    fun()
      begin
        // method body;
      end
}

<b>(c)</b>
observations := {
  cap := {
    cap_surface : &quot;&quot;,
    cap_color : &quot;&quot;,
    cap_shape : &quot;&quot; },
  gills := {
    ... }
}
</pre><P>

<h4><a name="01cb_000b"><a name="01cb_000c"><B>[LISTING ONE]</B></H4>

<PRE>


// Fungus -- A Mushroom Identification Program for Newton by Mike Swaine
// Fungus presents a single screen of mushroom attributes, lets the user set
// values for some or all of them, and tries to identify the mushroom based
// on these values. NB: This is a demo of NewtonScript, not a useful app.
// Its &quot;advice&quot; is NOT to be relied upon! The base view of the application is
// a frame named Mushrooms. It's based on the protoapp proto.
Mushrooms :=
  { viewSetupFormScript: /* executed during view creation */
      func()
      begin
        // Set view bounds relative to screen dimensions.
        local b := GetAppParams();
        self.viewBounds.top := b.appAreaTop + 2;
        self.viewBounds.left := b.appAreaLeft + 2;
        self.viewBounds.bottom := self.viewBounds.top+b.appAreaHeight-4;
        self.viewBounds.right := self.viewBounds.left+b.appAreaWidth-4;
      end,
    title: &quot;Mushroom Field Guide&quot;,
    viewflags: 5, /* visible, clickable, etc. */
    viewFormat: 328017, /* pen, frame, etc. */
    declareSelf: 'base, /* required for base view */

    observations: /* attributes of mushroom to be identified */
      {color : &quot;&quot;, /* all initialized to emptiness */
        size : 0,
        cap_shape : &quot;&quot;,
        cap_surface : &quot;&quot;,
        gill_type : &quot;&quot;,
        gill_attachment : &quot;&quot;,
        stem_position : &quot;&quot;,
        stem_surface : &quot;&quot;,
        veils : &quot;&quot;},

    advisor: /* the mushroom identification engine */
      func()
      begin
        // Dummy code. Could be extended to a humungous list of IF-THEN tests,
        // but plan is to replace with a simple expert system. Note: in
        // NewtonScript, all = tests on structured objects compare pointers,
        // while &lt; and &gt; tests compare contents. Hence variations in syntax.
        if strEqual(base.observations.color,&quot;brown&quot;)
          AND base.observations.size &gt; 3
          AND strEqual(base.observations.gill_type,&quot;absent&quot;)
        then base : advise(&quot;a Bolete&quot;,1);
        else if strEqual(base.observations.color,&quot;brown&quot;)
          AND base.observations.size &lt;= 3
        then base : advise(&quot;an LBM (little brown mushroom)&quot;,1);
        else base : advise(&quot;too little data for a conclusion&quot;,0);
      end,

    advise: /* outputs the identification */
      func(m,c)
      begin
        setValue(MessageBox,'text,&quot;It looks like you have&quot; &amp;&amp; m &amp; &quot;.
        \n Confidence level:&quot; &amp;&amp; c &amp; &quot;.&quot;);
      end,

    showSize: /* updates Size display to current SizeSlider value */
      func(n)
      begin
        setValue(Size,'text,n &amp;&amp; &quot;cm&quot;); /* value shown as centimeters */
      end,

    _proto: protoapp, /* proto inheritance link */
  };

// Cap Shape, based on the protolabelinputline proto, is a child view of
// base view. It displays a label and an input line. Tapping the label
// shows a list of values. Tapping a value puts it in the input line.
Cap Shape :=
  { viewSetupFormScript: /* executed during view creation */
      func()
      begin
        // This should set base-relative view bounds.
        // The protolabelinputline proto that this view is based on
        // has a child view, entryLine, responsible for the input line.
        // This is how its slots are accessed:
        entryLine.viewFont := userFont10;
        entryLine.text := &quot;&quot;;
        prevText := entryLine.text; /* save for undo */
      end,
    label: &quot;Cap Shape&quot;, /* the label */
    labelCommands:      /* the values displayed */
      [&quot;cylindrical&quot;, &quot;conical&quot;, &quot;bell&quot;, &quot;convex&quot;, &quot;flat&quot;, &quot;concave&quot;],

    textChanged: /* invoked when text in input line is changed */
      func()
      begin
        // Store user selection in slot in observations frame.
        base.observations.cap_shape := entryline.text;
        // Register this method's undo method with the system
        // so the Undo button will know what to do.
        AddUndoAction('undoTextChange,[prevText]);
      end,

    labelClick: /* invoked when user taps the label */
      func(unit)
      begin
        prevText := entryLine.text; /* save for undo */
        return nil; /* otherwise method is not passed */
      end,
    undoTextChange: /* the undo method for this method */
      func(t)
      begin
        entryLine.text := t;
        base.observations.cap_shape := entryline.text;
      end,
    _proto: protolabelinputline, /* proto inheritance link */
  };
// ...and so on. There are also frames for user input of Cap Surface, Gill
// Type, etc., but they look like this frame for Cap Shape.
// The frame(s) for input of Size, though, are a little different:
// SizeSlider, SizeLabel, and Size are views that implement a kind of slider,
// an alternative to the protolabelinputline used in Cap Shape.
// SizeSlider is based on the protoslider proto.
SizeSlider :=
  { viewSetupFormScript: /* executed during view creation */
      func()
      begin
        viewValue := 5; /* initial setting */
        / Display initial slider setting in Size view.
        base : showSize(self.viewValue);
        prevValue := viewValue; /* save for undo */
      end,

    // Slider settings are interpreted by interpolating between
    // minValue and maxValue. This app treats the result as centimeters.
    minValue: 0,
    maxValue: 24,
    changedSlider: /* invoked when slider is moved to a new position */
      func()
      begin
        // Store user selection in slot in observations frame.
        base.observations.size := viewValue;
        // Register this method's undo method with the system
        // so the Undo button will know what to do.
        AddUndoAction('undoValueChange,[prevValue]);
      end,
    trackSlider: /* invoked as slider is moved */
      func()
      begin
        // Display slider setting in Size view.
        base : showSize(self.viewValue);
      end,
    viewClickScript: /* invoked when user touches slider */
      func(unit)
      begin
        prevValue := viewValue; /* save for undo */
        return nil; /* otherwise method is not passed */
      end,
    undoValueChange: /* the undo method for this method */
      func(v)
      begin
        viewValue := v;
        base.observations.size := viewValue;
      end,
    _proto: protoslider, /* proto inheritance link */
  };
// SizeLabel, based on the protostatictext proto, labels SizeSlider.
SizeLabel :=
  { text: &quot;Size&quot;,
    _proto: protostatictext, /* proto inheritance link */
  };
// Size displays the setting of SizeSlider numerically.
// It's based on the protostatictext proto.
Size :=
  { text: &quot;&quot;,
    _proto: protostatictext, /* proto inheritance link */
  };
// View Size is accessible from Mushrooms.

// Advise is the button pressed to start the identification.
// It's based on the protopicturebutton proto.
Advise :=
  { icon: GetPictAsBits(&quot;Mushrooms&quot;, 1),
    buttonClickScript: /* invoked when button clicked */
      func()
      begin
        base : advisor(); /* fire up the identification engine */
      end,
    _proto: protopicturebutton, /* proto inheritance link */
  };
// Messagebox displays messages to user. Based on clParagraphView view class.
MessageBox :=
  { text: /* initial value */
      &quot;Select the characteristics that best describe your find
      and tap the picture of the mushroom.&quot;,
    viewclass: 81,
  };
// View MessageBox is accessible from Mushrooms.
</pre><HR><P>Copyright &copy; 1994, <I>Dr. Dobb's Journal</I></P></BODY></HTML>
