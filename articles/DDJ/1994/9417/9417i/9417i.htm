<HTML>
<META NAME="year" CONTENT="1994">
<HEAD>
<TITLE>SP 94: Exception Handlers and Windows Applications</TITLE></HEAD>
<BODY BGCOLOR="#ffffff">
<h1>Exception Handlers and Windows Applications<a name="0307_0106"></h1><P>
<h2><a name="0307_0104"><a name="0307_0000">Here's an invaluable debugging tool</h2><P>
<h3>Joseph Hlavaty</h3><P>
<p><i><a name="0307_0105"><a name="0307_0000">Joe is a systems programmer at a major hardware vendor. He is a graduate of Georgetown University and currently lives and works in South Florida. He can be contacted at 72370,1265.</i></p><hr><P>
Every Windows user has at one time or another faced the dreaded UAE (Unrecoverable Application Error) or Application Execution Error. This is certainly frustrating for the user and can result in lost time and perhaps effort because the faulting application is removed from Windows. It can be troublesome for the application developer, too, because the user may not be able to effectively communicate the problem to the developer. Scenarios leading up to such errors can often be difficult, if not impossible, to reproduce.<P>
While there are tools (such as Dr. Watson) that extract information about an exception, there are no tools for debugging a currently trapping application. Nor is there a general reference for writing exception handlers under Windows. Other than a few ToolHelp functions, there is little available to help you debug traps in Windows applications. Consequently, I've written TrapMan, the Windows Trap Manager--a debugging tool for analyzing exceptions in Windows applications. <P>
TrapMan runs in any currently available protected-mode version of Windows. I've tested TrapMan extensively in Windows 3.0 and 3.1 (Standard and Enhanced modes), Win-OS/2 2.0 (Standard-mode Windows 3.0-compatible support under OS/2 2.0), and Win-OS/2 2.1 (Standard- and Enhanced-mode Windows 3.1-compatible support found in OS/2 2.1). TrapMan will not run in real mode--it is a protected-mode-only application. Additionally, if you wish to debug a currently faulting application caught in one of TrapMan's handlers, you must be running a debugger capable of processing unowned INT 3hs in code. I prefer Nu-Mega's Soft-Ice for Windows for debugging DOS-based versions of Windows and the OS/2 kernel debugger for debugging OS/2-based versions (I use both almost on a daily basis). Both debuggers can handle an INT 3h instruction in code that they did not place there. <P>
Before discussing exception handlers, I'll review a number of concepts central to their understanding, namely, the System VM in Windows, DPMI (DOS Protected Mode Interface), protected-mode selectors, and interrupts and exceptions in 286 or greater (286/386/i486, and Pentium) processors. The complete source code and binaries for TrapMan (including DeadMan, a sample application program) are provided electronically; see &quot;Availability,&quot; page 3.<P>
<h3><a name="0307_0107">The System VM<a name="0307_0107"></h3><P>
System VM technically refers to the first VDM (or virtual-DOS machine) started in Windows 3.0 or 3.1 in Enhanced mode. A VM (or virtual machine) is an emulated (virtual) 8086 processor available as a special mode on 386 (and higher) processors for use in Windows and Windows applications. Here, I'll use the term &quot;System VM&quot; somewhat loosely, referring to some address space where all Windows applications reside, which may or may not be equivalent to a virtual machine. (For example, Windows 3.0 Standard mode does not use virtual-8086 mode.) Why is this System VM so important? First, separate page tables are kept for each VM. If all Windows applications were not run in the same VDM, then they would be inaccessible to each other. Under OS/2 2.x, you can run multiple copies of Windows. Each copy is run in a separate VM and cannot access or interfere with any other.<P>
There is another feature of System VM that makes programs such as TrapMan possible. Protected-mode Intel processors such as the 386 can access memory through one of two tables. These tables are the GDT (Global Descriptor Table) and the LDT (Local Descriptor Table), and they are used by operating systems to limit memory access among applications. Simply stated, a protected-mode program has access to memory addressable by the GDT and by one LDT. No other memory is accessible.<P>
In OS/2, separate OS/2 programs are assigned separate LDTs, so one program cannot accidentally or intentionally modify the memory of another. The information in an individual program's LDT simply does not include information about the memory of any other process unless it is explicitly shared by the owning process.<P>
As a second option, Intel specifications permit tasks to share a single LDT, and this is how Windows operates under both OS/2 and DOS. Because of this, TrapMan (and any other Windows program) can access memory in any Windows program or within the Windows kernel itself. This foregoes protection from interapplication corruption, but gives Windows applications great flexibility in how they interact with each other and with Windows itself.<P>
<h3><a name="0307_0108">DPMI<a name="0307_0108"></h3><P>
The DOS Protected Mode Interface (DPMI) is a set of entry points that permit protected-mode applications (&quot;DPMI clients&quot;) to perform various tasks involving selector allocation, interrupt hooking, and the like, without affecting the integrity of the overall operating system.<P>
Such tasks are generally considered privileged in multiprogram systems such as Windows, and applications are not permitted to implement these tasks themselves. However, they can request that a more privileged program (in this case the &quot;DPMI host&quot;) make these changes for them.<P>
I'll use a small subset of the available DPMI calls: <I>GetVersion()</I>, <I>GetProcessorExceptionHandler()</I>, <I>SetProcessorExceptionHandler()</I>, <I>AllocateLDTDescriptors()</I>, <I>FreeLDTDescriptor()</I>,<I>GetSegmentBaseAddress()</I>, <I>SetSegmentBaseAddress()</I>, and <I>SetSelectorLimit()</I>. These are only a few of the 50 or so DPMI calls available under the 0.90 specification. Microsoft officially supports only a few DPMI functions (see the <I>Microsoft SDK 3.1 Programmer's Reference</I>, Chapter 20) and the <I>Microsoft Windows Guide to Programming</I> warns &quot;Do not use DPMI services for hooking interrupts or faults.&quot; However, all DPMI functions used in TrapMan are available in all DPMI implementations tested. Those more familiar with DPMI may notice that I do not (and should not) call the DPMI functions for placing the processor in protected mode. Windows does this before TrapMan (or any other application) is loaded. <P>
<h3><a name="0307_0109">Protected-Mode Selectors<a name="0307_0109"></h3><P>
In real mode, a segment register's value can be directly mapped to a physical address. A CS:IP of 197:0 refers directly to address 1970 (197h &lt;&lt; 4). In protected mode, however, there is a level of indirection. The same CS:IP cannot be directly mapped to a physical address. A segment register such as CS is loaded with a segment-selector value in protected mode, and this value must be translated to get a physical address. (Paging on 386-family processors differs. With paging enabled, the value calculated is actually a linear address that must be converted to a physical address. For the purposes of this article, <I>linear address</I>=<I>physical address</I>.)<P>
A selector is read as <I>197 hex = 0000 0001 1001 0111 binary</I>, where <I>0000 0001 1001 0 (190)</I> is the selector index (all numbers are in hex unless otherwise noted), bit 2 is the table indicator (a 1 value indicates that this is an LDT selector), and bits 1 and 0 give the requested privilege level (11 is ring 3, the least privileged). Inside the LDT entry for 190 is a base address (for example, 0040 0000). It is this base address that must be added to the offset to get the resulting physical address. For debugging traps in protected mode, a basic understanding of selectors is essential. However, much of the difficult work of selector translation is done automatically by the processor.<P>
<h3><a name="0307_010a">Protected-Mode Interrupts and Exceptions<a name="0307_010a"></h3><P>
Interrupts in protected mode are similar to their real-mode counterparts. However, instead of the interrupt-vector table (IVT) in low memory, interrupts are processed based on a protected-mode interrupt-descriptor table (IDT). For this reason, protected-mode interrupts cannot be watched by changing the interrupt vector table; instead, DOS or DPMI calls must be used to get or set a protected-mode handler.<P>
There are three classes of exceptions: FAULTS, TRAPS, and ABORTS. Basically, a FAULT happens before any changes are made in the system. An example is the general-protection fault, or &quot;GPFault,&quot; as it is known to Windows users. Such a fault might be the pseudocode fragment in <a href="#0307_010e">Example 1</A> (which is not valid Intel assembler), which attempts to get the address of the current INT 3h handler in the real-mode interrupt-vector table (4 bytes, starting at physical address 0Ch) by placing 0 in a segment register. This procedure is perfectly valid in real mode; however, in protected mode a selector of 0 is not valid, and the actual use of this invalid selector in the third instruction will cause a fault <I>before</I> the third instruction is executed. CS:IP will still point to the faulting instruction. Faults are restartable. It is the restartability of faults that permits TrapMan (and Windows) to terminate faulting applications.<P>
A TRAP, on the other hand, is caught <I>after</I> any changes are made to the system. An example of a trap is the special 1-byte INT 3h (0CCh) instruction used by TrapMan to break to a debugger. The INT 3h handler is called <I>after</I> the INT 3h is executed by the processor, CS:IP now points to the instruction after the INT 3h.<P>
Another type of exception is an ABORT. Since these are generally caused by things such as hardware errors, I'll not discuss them here.<P>
TrapMan was designed for debugging FAULTS. Some common faults found on 80286/80386/80486 Intel processors are listed in <a href="#0307_010f">Table 1</A>. <P>
<h3><a name="0307_010b">TRAPMAN.C<a name="0307_010b"></h3><P>
TrapMan is written almost entirely in C (with the exception of some inline assembler) using Microsoft C 6.0a. For reasons I'll discuss later, C is not really the best choice for writing exception handlers. Because it is comfortable for most programmers, however, I used C here to show the basic ideas behind exception handlers and debugging with them.<P>
The file trapman.c (<a href="#0307_0113">Listing One</A>) is fairly straightforward code. The first thing unusual about TrapMan's source is in the global data area. To set and reset the handlers for various exceptions as the user changes exception handlers, you must always query the current handler for a particular exception (such as <I>trap D</I>, which would be stored in the <I>_Prev13</I> code pointer). For this version of TrapMan, you can install up to four handlers independently (Traps 0, 6, 12, and 13, also known as <I>DivideByZero</I>, <I>InvalidOpCode</I>, <I>StackFault</I>, and <I>GPFault</I>, respectively). Additionally, you keep flags marking whether or not the <I>Previous</I> handler code is current (that is, whether or not we are currently watching a particular exception). See <a href="#0307_0110">Figure 1</A>. <P>
Execution of TrapMan begins in the same manner as all Windows applications in <I>WinMain()</I>. To avoid parsing TrapMan arguments, TrapMan accesses the C run-time globals <I>__argc</I> and <I>__argv</I>; see <a href="#0307_0114">Listing Two</A>, page 71.) If any arguments are passed in on TrapMan's command line (<I>argc &gt;1</I>), then <I>argv[1]</I> is taken as a program name to be debugged and passed to <I>WinExec()</I>. This name should be a fully qualified path to the application, if it is not on the path or in one of the directories searched by <I>WinExec()</I>.<P>
Additionally, TrapMan will not permit multiple instances of itself to be run. While this is not important in the C version, the versions given in future modules have handlers that contain extensive amounts of self-modifying code. You can't have multiple instances of an application modifying the same code--it just doesn't work very well! For the same reason, all TrapMan code is <I>preload nondiscardable</I> (although only the handlers and certain support functions actually need to be nondiscardable). <P>
The instance initialization processing (<I>InitInstance</I>) does some important bookkeeping work for TrapMan. First, it gets handles to the main window's Trap and Option menus so that we can modify them later as the user selects and deselects various menu items. It also sets up the default TrapMan configuration. While this configuration is not used with the C handlers described in this article, this section is left in both for completeness and to give an idea of what the user interface of future versions will look like. <P>
All possible exit points to the application must be covered in the window procedure for the main window (<I>MainWndProc</I>) because in all cases you must reset any set trap handlers to their previous values before exiting the application. <P>
For our purposes, I'm assuming that all previous handlers belong to Windows or DPMI, so I won't check them for validity. If private exception handlers become more common, you'll need to verify that the current handlers are your own (that is, they have not been replaced by another app) before resetting them. You'll also need to verify that the code is valid. (To do this, you'll need to keep track of the signature for the previous handler to make sure that it has not been replaced by another application's code.)<P>
The <I>PutInEditControl()</I> routine creates a 10K buffer that it uses to manipulate the contents of the edit control. The routine is sufficient for explanatory purposes, although handlers in your applications may not use an edit control. I felt it essential that users be able to update the TrapMan window's text as required (with a description of events leading up to the trap, for example), either before or after the trap occurred. An edit control seemed the most straightforward manner to do this, but flicker is a problem. No matter where the text cursor is in the buffer, new text from TrapMan is always placed at the bottom of the buffer. This is done so that users can manipulate the buffer while maintaining synchronous messaging from TrapMan or the operating system.<P>
The <I>SaveBuffer()</I> routine simply writes the buffer to the given filename, and it will warn the user before replacing an existing file on disk. The <I>HandleTraps()</I> and <I>HandleOptions()</I> routines process WM_COMMAND messages for the Trap and Options pulldowns, respectively.<P>
TrapMan uses a number of DPMI calls. DPMI uses registers to pass arguments, and all the functions we'll need will use the INT 31h interface. Note that DPMI functions consistently return with the carry flag set to mark failure (as does DOS). All of these functions assume that AX is to be used to return 16-bit values, and DX:AX to return 32-bit values. This is consistent with the Windows API and with most DOS C compilers, and is done so that DPMI calls can be conveniently made from C code. This module contains wrappers for the following functions:<P>
<UL>
<li><I>DPMIGetVersion</I> returns the version number of the DPMI host. Windows 3.0/3.1 and OS/2 2.0 return 005a (90 decimal); OS/2 2.1 returns 005f (95 decimal), due to some additional features.</li>
<li><I>DPMIGetProcessorExceptionHandlr</I> returns the current exception handler for the exception number passed in as its argument, or 0 for failure.</li>
<li><I>DPMISetProcessorExceptionHandlr</I> returns 0 if okay. It takes two arguments: the exception number and a far pointer to the routine that will handle it.</li>
<li><I>DPMIAllocateLDTDescriptors</I> returns a base selector or 0=error. It takes one argument: the number of descriptors to allocate (usually 1).</li>
<li><I>DPMIFreeLDTDescriptor</I> returns the selector freed if successful, otherwise returns 0. It takes one argument: a selector allocated via <I>DPMIAllocateLDTDescriptors</I>.</li>
<li><I>DPMIGetSegmentBaseAddress</I> returns the base address of the given selector.</li>
<li><I>DPMISetSegmentBaseAddress</I> returns AX=0 if failure. It takes three arguments: the selector whose base is to be modified, the <I>hiword</I> of the new base, and the <I>loword</I> of the new base.</li>
</UL>
The HANDLER.C file contains the handlers for exceptions that TrapMan watches. Note: <P>
<UL>
<li>Exception handlers are far procedures (they must far return--RETF--back to DPMI). </li>
<li>Exception handlers take no parameters (although DPMI does push a 16-bit exception frame onto the stack before calling).</li>
<li>Exception handlers must be preloaded and nondiscardable.</li>
<li>When called, an exception handler has only <I>cs:ip</I> valid and pointing to the handler's code. All other registers belong either to the faulting application or to DPMI. The handler must change them, so many exception handlers push the client registers first. TrapMan's assembly-language handlers will do the same.</li>
</UL>
At the INT 3h in our GPFault handler, for example, the DPMI fault-exception frame begins at SS:SP+8. One GPFault had an exception frame that looked something like <a href="#0307_0111">Figure 2</A>. At <I>ErrorFrame+0</I>, you find the return address to DPMI (3b:0204); at <I>ErrorFrame+4</I>, the error code (a 0 selector); and at <I>ErrorFrame+6</I>, the address of the faulting instruction (1c7f:45d).<P>
Upon disassembling the faulting instruction address, you find a STOSB. Since we know that a <I>stosb</I> instruction takes the value in AL and puts it in ES:DI, we know that a bad ES value can cause the trap. We see that ES is 0--this is the cause of the trap. Finally, at <I>ErrorFrame+ah</I> you find the flags, and at <I>ErrorFrame+ch,</I> a far pointer to the application's stack (1c77:15e8 in this case).<P>
<h3><a name="0307_010c">Using TrapMan to Debug a Trap or Fault <a name="0307_010c"></h3><P>
Both Windows and Win-OS/2 exception handlers are 16-bit handlers. On entry to a handler, all registers of the faulting application are preserved except CS, IP, SS, and SP. These registers are available in the exception stack frame. The stack frame begins at SS:SP and is laid out as in <a href="#0307_0112">Table 2</A>.<P>
The <I>far ptr</I> at SS:SP+0Ch is that of the application's stack at fault time. It may be used to trace back a C calling stack or to examine the parameters of the faulting procedure (if a suitable stack frame has been set up). This is done by dumping data using the SS of the faulting app with the current bp or the value of SP of faulting app. The <I>far ptr</I> at SS:SP+6h is the instruction of the app whose attempted execution has generated the fault.<P>
The error code is very similar to a selector in protected mode. The high 13 bits are the selector index (bits 3--15), and bit 2 is the table index. However, instead of an RPL (requested privilege level), bits 0 and 1 have the following meaning: Bit 0 (EXT) is set if the fault was called by an event external to the program; bit 1 (IDT) is set if the selector index refers to a gate descriptor in the IDT.<P>
<h3><a name="0307_010d">Closing Notes<a name="0307_010d"></h3><P>
The DPMI offsets described here are valid only at entry to the exception handler, as further modification of the stack will change SP. TrapMan's exception handlers are written so that the DPMI stack and registers are valid on the fault INT 3h (if Break On Fault option is checked).<P>
You <I>must</I> be running a protected-mode debugger if you wish to stop on INT 3h during faults. Otherwise, a debugger is not necessary to use TrapMan. Currently, TrapMan does not add handlers for INT 3h, nor are there plans to do so.<P>
Certain portions of the Windows and Win-OS/2 debug kernels do <I>not</I> use <I>OutputDebugString()</I> to write to the debugger. Their output will not be trapped even if <I>OutputDebugString()</I> is hooked. The functionality to add this hook (K328 or <I>_DebugOutput</I>, see <I>Undocumented Windows</I>, p.205) will be included in a future version of TrapMan. Executing random sections of memory frequently causes Trap D or Trap 7 faults.<P>
<h4><a name="0307_010e"><B>Example 1:</B> Pseudocode fragment that leads to a GPFault.<a name="0307_010e"></h4><P>
<pre>mov  ds, 0
mov  bx, 0Ch
mov  OffInt3, word ptr ds:bx     ; GPFault in protected mode!
                                ; Trying to access selector of 0!
mov  SegInt3, word ptr ds:bx+2</pre><P>
<h4><a name="0307_010f"><B>Table 1:</B> Some common faults found on 80286, 80386, and 80486 Intel microprocessors.<a name="0307_010f"></h4><P>
<PRE>
    Fault                              Description

    Interrupt 0: Divide-by-zero        Trap 0
    Interrupt 6: Invalid opcode        Trap 6
    Interrupt 8: Double
    Interrupt 12: Stack                Trap C or Trap 12
    Interrupt 13: General protection   Trap D or Trap 13
</pre>

<h4><a name="0307_0110"><B>Figure 1:</B> TrapMan in action. Only the default handlers (Traps 6, 12, and 13) are set.<a name="0307_0110"></h4><P>
<pre>This instance's DS is 12AF
The DPMI Version is 5A
Trapping apps will be terminated
Enabling breaking to debugger on traps
Enabling beeping on traps
Prev Trap 13 handler is 1175FA2
Trap 13 (general protection fault) handler installed
Prev Trap 12 handler is 1175F93
Trap 12 (stack fault) handler installed
Prev Trap 6 handler is 1175FB1
Trap 6 (invalid opcode) handler installed
Trap 13!
E:\DEADMAN\DEADMAN.EXE
DPMI app regs:
   CS:IP = 1307:056C
   SS:SP = 12FF:15AE
   with selector 7470 (flags=0212)
App regs:
   AX=15AC BX=15EC CX=0000 DX=1800
   IP=**** SP=**** BP=15AE SI=15EC DI=1800
   CS=**** SS=**** DS=12FF ES=12FF
Dump of 12FF:15AE:
00___02___04___06__+__08___0A___0C___0E====0123456789ABCDEF
7473  6E69  2167  2020     4144  474E  5245  2121       sting!  DANGER!!
2021  5453  4341  204B     564F  5245  5257  5449       ! STACK OVERWRIT
Trap 6!
E:\DEADMAN\DEADMAN.EXE
DPMI app regs:
   CS:IP = 130F:04F4
   SS:SP = 131F:1596
   with selector 6E58 (flags=0287) App regs:
   AX=159A BX=04F2 CX=131F DX=130F
   IP=**** SP=**** BP=159C SI=15D8 DI=1800
   CS=**** SS=**** DS=131F ES=131F
Dump of 131F:1596:
00___02___04___06__+__08___0A___0C___0E====0123456789ABCDEF
15D8  1800  131F  15AF     0278  130F  15D8  1800       ########x#######
0001  0201  130F  131F     15C9  27BB  04A7  0000       ###########'####</pre><P>
<h4><a name="0307_0111"><B>Figure 2:</B> Typical GPFault exception frame.<a name="0307_0111"></h4><P>
<pre>87:fd0   0204   003b   0000   45d   1c7f   0287   15e8   1c77
Offset   0      2      4      6     8      ah     ch     eh</pre><P>
<h4><a name="0307_0112"><B>Table 2:</B> Exception stack frame.<a name="0307_0112"></h4><P>
<pre>SS of faulting app   0Eh
SP of faulting app   0Ch
Flags                0Ah
CS of faulting app   08h
IP of faulting app   06h
Error Code           04h
Return CS            02h
Return IP            00h</pre><P>
<P>
<h4><a name="0307_0113">Listing One<a name="0307_0113"></h4><pre>
/****************************************************************************
    FILE: trapman.c -- a trap manager for Windows 3.x and Win-OS/2
       Copyright (c) 1994, Joseph Hlavaty This product is CAREWARE. Please
       refer to the licensing agreement LICENSE.AGR on the diskette.
    PURPOSE: source file for trapman.exe, contains WinMain, window procedure
             and menu processing routines
****************************************************************************/
#define NOSOUND
#define NOCOMM
#define NODRIVERS
#define NOMINMAX
#define NOLOGERROR
#define NOPROFILER
#define NOLFILEIO
#define NOOPENFILE
#define NOATOM
#define NOLANGUAGE
#define NODBCS
#define NOKEYBOARDINFO
#define NOGDICAPMASKS
#define NOCOLOR
#define NODRAWTEXT
#define NOTEXTMETRIC
#define NOSCALABLEFONT
#define NOMETAFILE
#define NOSYSMETRICS
#define NOSYSTEMPARAMSINFO
#include &quot;windows.h&quot;
#include &quot;trapman.h&quot;
#include &quot;DPMI.h&quot;
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;
#define SYSCOMMAND_MASK   0xFFF0
// this is our global data area
HANDLE hwndTrapMenu ;        // for checking and unchecking our trap options
void (_far *Prev13) () = NULL;
void (_far *Prev12) () = NULL;
void (_far *Prev6) () = NULL;
void (_far *Prev0) () = NULL;
int  WeGot13 = 0 ;
int  WeGot12 = 0 ;
int  WeGot6  = 0 ;
int  WeGot0  = 0 ;
WORD wDPMIVersion = 0xFFFF ;
char *TrapMsgs[15] = {
          &quot;Trap 0 (divide by zero fault) handler installed&quot;,     // 0
          &quot;       **** undefined msg ***     &quot;,                  // 1
          &quot;       **** undefined msg ***     &quot;,                  // 2
          &quot;       **** undefined msg ***     &quot;,                  // 3
          &quot;       **** undefined msg ***     &quot;,                  // 4
          &quot;       **** undefined msg ***     &quot;,                  // 5
          &quot;Trap 6 (invalid opcode) handler installed&quot;,           // 6
          &quot;       **** undefined msg ***     &quot;,                  // 7
          &quot;       **** undefined msg ***     &quot;,                  // 8
          &quot;       **** undefined msg ***     &quot;,                  // 9
          &quot;       **** undefined msg ***     &quot;,                  // A
          &quot;       **** undefined msg ***     &quot;,                  // B
          &quot;Trap 12 (stack fault) handler installed&quot;,             // C
          &quot;Trap 13 (general protection fault) handler installed&quot; // D
       } ;
char szBuffer[255] ;
/****************************************************************************
    PROGRAM: Trapman.c
    PURPOSE: Creates an edit window
****************************************************************************/
HANDLE hInst;
HWND hEditWnd;                /* handle to edit window */
HWND hwnd;                    /* handle to main windows  */
/****************************************************************************
    FUNCTION: WinMain(HANDLE, HANDLE, LPSTR, int)
    PURPOSE: calls initialization function, processes message loop
****************************************************************************/
int PASCAL WinMain(hInstance, hPrevInstance, lpCmdLine, nCmdShow)
HANDLE hInstance;
HANDLE hPrevInstance;
LPSTR lpCmdLine;
int nCmdShow;
{
    MSG msg;
    if (!hPrevInstance)
        if (!InitApplication(hInstance))
            return (FALSE);
    if (!InitInstance(hInstance, nCmdShow))
        return (FALSE);
    while (GetMessage(&amp;msg, NULL, NULL, NULL))
    {
        TranslateMessage(&amp;msg);
        DispatchMessage(&amp;msg);
    }
    return (msg.wParam);
}
/****************************************************************************
    FUNCTION: InitApplication(HANDLE)
    PURPOSE: Initializes window data and registers window class
****************************************************************************/
BOOL InitApplication(hInstance)
HANDLE hInstance;
{
    WNDCLASS  wc;
    wc.style = NULL;
    wc.lpfnWndProc = MainWndProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = 0;
    wc.hInstance = hInstance;
//  wc.hIcon = LoadIcon(NULL, IDI_APPLICATION);
    wc.hIcon = LoadIcon(hInstance, MAKEINTRESOURCE( TRAPMANICON ));
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = GetStockObject(WHITE_BRUSH);
    wc.lpszMenuName =  &quot;TrapManMenu&quot;;
    wc.lpszClassName = &quot;TrapManWClass&quot;;
    return (RegisterClass(&amp;wc));
}
/****************************************************************************
    FUNCTION:  InitInstance(HANDLE, int)
    PURPOSE:  Saves instance handle and creates main window
****************************************************************************/
BOOL InitInstance(hInstance, nCmdShow)
    HANDLE          hInstance;
    int             nCmdShow;
{
    RECT            Rect;
    int             OurDS ;
    hInst = hInstance;
    hwnd = CreateWindow(
        &quot;TrapManWClass&quot;,
        &quot;TrapMan&quot;,
        WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT,
        CW_USEDEFAULT,
        400, 100,
        NULL,
        NULL,
        hInstance,
        NULL
    );
    if (!hwnd)
        return (FALSE);
    GetClientRect(hwnd, (LPRECT) &amp;Rect);
    /* Create a child window */
    hEditWnd = CreateWindow(&quot;Edit&quot;,
        NULL,
        WS_CHILD | WS_VISIBLE |
        ES_MULTILINE |
        WS_VSCROLL | WS_HSCROLL |
        ES_AUTOHSCROLL | ES_AUTOVSCROLL,
        0,
        0,
        (Rect.right-Rect.left),
        (Rect.bottom-Rect.top),
        hwnd,
        IDC_EDIT,                          /* Child control i.d. */
        hInst,
        NULL);
    if (!hEditWnd)
    {
        DestroyWindow(hwnd);
        return (NULL);
    }
    ShowWindow(hwnd, nCmdShow);
    UpdateWindow(hwnd);
    wsprintf((LPSTR) szBuffer,&quot;PLEASE USE THE FULL VERSION OF TRAPMAN&quot;);
    PutInEditControl(szBuffer, 1) ;
    wsprintf((LPSTR) szBuffer,&quot; (INCLUDED ON DISK) FOR DEBUGGING.  
                                                               This version &quot;);
    PutInEditControl(szBuffer, 1) ;
    wsprintf((LPSTR) szBuffer,&quot;  is meant to be used only for a better&quot;);
    PutInEditControl(szBuffer, 1) ;
    wsprintf((LPSTR) szBuffer,&quot;  understanding of the article.&quot;);
    PutInEditControl(szBuffer, 1) ;
    wsprintf((LPSTR) szBuffer,&quot;                                       &quot;);
    PutInEditControl(szBuffer, 1) ;
    _asm push ds
    _asm pop OurDS
    wsprintf((LPSTR) szBuffer,&quot;This instance's DS is %0X&quot;, OurDS) ;
    PutInEditControl(szBuffer, 1) ;
    wDPMIVersion = DPMIGetVersion() ;
    wsprintf((LPSTR) szBuffer,&quot;The DPMI Version is %0X&quot;, wDPMIVersion) ;
    PutInEditControl(szBuffer, 1) ;
// standard mode Win300 returns '90h' instead of 0x5A required by the DPMI ...
    if ((wDPMIVersion &gt; 0x005a) &amp;&amp;
        (wDPMIVersion != 0x90)){ // 1.0+ not supported 0x5A is 0.9
       MessageBox(NULL, &quot;Warning:  Unknown DPMI Host!&quot;, &quot;TRAPMAN&quot;,
           MB_ICONEXCLAMATION | MB_OK) ;
//       return 0 ;
       }
    #define     TRAPMENU   1 // the SECOND pull down (0 is first)
    hwndTrapMenu = GetSubMenu (GetMenu(hwnd), TRAPMENU);
    return (TRUE);
}
/****************************************************************************
    FUNCTION: MainWndProc(HWND, unsigned, WORD, LONG)
****************************************************************************/
long FAR PASCAL MainWndProc(hWnd, message, wParam, lParam)
HWND hWnd;
unsigned message;
WORD wParam;
LONG lParam;
{
    FARPROC lpProcAbout;
    switch (message) {
        case WM_SYSCOMMAND:
            switch (wParam &amp; SYSCOMMAND_MASK) {
                // make sure we restore old trap handlers...
                case SC_CLOSE:
                    SendMessage(hWnd, WM_COMMAND, IDM_EXIT, 0L) ;
                    break;
                default:
                   return (DefWindowProc(hWnd, message, wParam, lParam));
                }
            break ;
        case WM_COMMAND:
            switch (wParam) {
                case IDM_ABOUT:
                    lpProcAbout = MakeProcInstance(About, hInst);
                    DialogBox(hInst, &quot;AboutBox&quot;, hWnd, lpProcAbout);
                    FreeProcInstance(lpProcAbout);
                    break;
                /* file menu commands */
                  case IDM_NEW:
                    if (IDYES == MessageBox(NULL, &quot;Erase current edit buffer?&quot;,
                                                       &quot;TrapMan&quot;, MB_OKCANCEL))
                       SendMessage(hEditWnd, WM_SETTEXT, 0, (LONG) (LPSTR) &quot;&quot;);
                    break ;
                case IDM_SAVE:
                case IDM_SAVEAS:
                    SaveBuffer(&quot;(Untitled).trp&quot;) ;
                    break ;
                case IDM_OPEN:
                    MessageBox (
                          GetFocus(),
                          &quot;Command not implemented&quot;,
                          &quot;TrapMan&quot;,
                          MB_ICONASTERISK | MB_OK);
                    break;
               case IDM_EXIT:
                    // reset the previous trap handlers...if any existed
                    if (WeGot13 &amp;&amp; Prev13)
                       DPMISetProcessorExceptionHandlr( 13 , (void _far *) 
                                                                     Prev13 ) ;
                    if (WeGot12 &amp;&amp; Prev12)
                       DPMISetProcessorExceptionHandlr( 12 , (void _far *) 
                                                                     Prev12 ) ;
                    if (WeGot6 &amp;&amp; Prev6)
                       DPMISetProcessorExceptionHandlr( 6 , (void _far *) 
                                                                      Prev6 ) ;
                    if (WeGot0 &amp;&amp; Prev0)
                       DPMISetProcessorExceptionHandlr( 0 , (void _far *) 
                                                                      Prev0 ) ;
                    DestroyWindow(hWnd);
                    break;
                /* trap menu commands */
                case IDM_GP:
                    if (!WeGot13)
                    {
                       SetFaultProc(13, (long *) &amp;Prev13,
                       (void _far *) MyGPProc,
                       TrapMsgs[13]) ;
                       CheckMenuItem(hwndTrapMenu,wParam,
                               MF_CHECKED | MF_BYCOMMAND) ;
                       WeGot13 = 1 ;
                    }
                    else
                    {
                       CheckMenuItem(hwndTrapMenu,wParam,
                               MF_UNCHECKED | MF_BYCOMMAND) ;
                       WeGot13 = 0 ;
                       if (Prev13)
                       {
                          PutInEditControl(&quot; *** Resetting previous trap 13 
                                                                 handler&quot;, 1) ;
                          DPMISetProcessorExceptionHandlr( 13 , (void _far *) 
                                                                     Prev13 ) ;
                          Prev13 = NULL ;
                       }
                    }
                    break;
                case IDM_STACK:
                    if (!WeGot12)
                    {
                       SetFaultProc(12, (long *) &amp;Prev12,
                       (void _far *) MySPProc,
                       TrapMsgs[12]) ;
                       CheckMenuItem(hwndTrapMenu,wParam,
                               MF_CHECKED | MF_BYCOMMAND) ;
                       WeGot12 = 1 ;
                    }
                    else
                    {
                       CheckMenuItem(hwndTrapMenu,wParam,
                               MF_UNCHECKED | MF_BYCOMMAND) ;
                       WeGot12 = 0 ;
                       if (Prev12)
                       {
                          PutInEditControl(&quot; *** Resetting previous trap 12 
                                                                 handler&quot;, 1) ;
                          DPMISetProcessorExceptionHandlr( 12 , (void _far *) 
                                                                     Prev12 ) ;
                          Prev12 = NULL ;
                       }
                    }
                    break;
                case IDM_INVALIDOP:
                    if (!WeGot6)
                    {
                       SetFaultProc(6, (long *) &amp;Prev6,
                       (void _far *) MyInvalidOpProc,
                       TrapMsgs[6]) ;
                       CheckMenuItem(hwndTrapMenu,wParam,
                               MF_CHECKED | MF_BYCOMMAND) ;
                       WeGot6 = 1 ;
                    }
                    else
                    {
                       CheckMenuItem(hwndTrapMenu,wParam,
                               MF_UNCHECKED | MF_BYCOMMAND) ;
                       WeGot6 = 0 ;
                       if (Prev6)
                       {
                          PutInEditControl(&quot; *** Resetting previous trap 6 
                                                                 handler&quot;, 1) ;
                          DPMISetProcessorExceptionHandlr( 6 , (void _far *) 
                                                                      Prev6 ) ;
                          Prev6 = NULL ;
                       }
                    }
                    break;
                case IDM_TRAPZERO:
                    if (!WeGot0)
                    {
                       SetFaultProc(0, (long *) &amp;Prev0,
                       (void _far *) MyDivideByZeroProc,
                       TrapMsgs[0]) ;
                       CheckMenuItem(hwndTrapMenu,wParam,
                               MF_CHECKED | MF_BYCOMMAND) ;
                       WeGot0 = 1 ;
                    }
                    else
                    {
                       CheckMenuItem(hwndTrapMenu,wParam,
                               MF_UNCHECKED | MF_BYCOMMAND) ;
                       WeGot0 = 0 ;
                       if (Prev0)
                       {
                          PutInEditControl(&quot; *** Resetting previous trap 0 
                                                                 handler&quot;, 1) ;
                          DPMISetProcessorExceptionHandlr( 0 , (void _far *) 
                                                                      Prev0 ) ;
                          Prev0 = NULL ;
                       }
                    }
                    break;
                case IDM_DEFAULT:
                    if (!WeGot13)
                       PostMessage(hWnd, WM_COMMAND, IDM_GP, 0L) ;
                    if (!WeGot12)
                       PostMessage(hWnd, WM_COMMAND, IDM_STACK, 0L) ;
                    if (!WeGot6)
                       PostMessage(hWnd, WM_COMMAND, IDM_INVALIDOP, 0L) ;
                    break;
                case IDC_EDIT:
                    if (HIWORD (lParam) == EN_ERRSPACE)
                    {
                        MessageBox (
                              GetFocus ()
                            , &quot;Out of memory.&quot;
                            , &quot;TrapMan&quot;
                            , MB_ICONHAND | MB_OK
                        );
                    }
                    break;
            }
            break;
        case WM_SETFOCUS:
            SetFocus (hEditWnd);
            break;
        case WM_SIZE:
            MoveWindow(hEditWnd, 0, 0, LOWORD(lParam), HIWORD(lParam), TRUE);
            break;
        case WM_DESTROY:
            PostQuitMessage(0);
            break;
        default:
            return (DefWindowProc(hWnd, message, wParam, lParam));
    }
    return (NULL);
}
/****************************************************************************
    FUNCTION: About(HWND, unsigned, WORD, LONG)
    PURPOSE:  Processes messages for &quot;About&quot; dialog box
    MESSAGES:
        WM_INITDIALOG - initialize dialog box
        WM_COMMAND    - Input received
****************************************************************************/
BOOL FAR PASCAL About(hDlg, message, wParam, lParam)
HWND hDlg;
unsigned message;
WORD wParam;
LONG lParam;
{
    switch (message)
    {
        case WM_INITDIALOG:
            return (TRUE);
        case WM_COMMAND:
            if (wParam == IDOK
                || wParam == IDCANCEL)
            {
                EndDialog(hDlg, TRUE);
                return (TRUE);
            }
            break;
    }
    return (FALSE);
}
int SetFaultProc(unsigned char ThisTrap, long *PrevHandler,
                 void _far *MyFaultHandler, char *Msg )
{
  *PrevHandler = (void _far *) DPMIGetProcessorExceptionHandlr( ThisTrap ) ;
  wsprintf((LPSTR) szBuffer,&quot;Prev Trap %d handler is %0lX&quot;, ThisTrap, 
                                                                *PrevHandler) ;
  PutInEditControl(szBuffer, 1) ;
  DPMISetProcessorExceptionHandlr(ThisTrap, MyFaultHandler ) ;
  PutInEditControl(Msg, 1) ;
  return TRUE ;
}
// passing in a NULL msg pointer should cause us to free any alloced buffer
BOOL PutInEditControl(char *Msg, int bWithReturn)
{
static HANDLE hBuff = NULL ;
static LPSTR  lpBuff ;
  int    iSizeOfBuff = 10 * 1024 ; // 10K
  if (NULL == hEditWnd)  // edit window is non-existent
     return FALSE ;
  if (NULL == Msg)
  {
     if (hBuff)
     {
        GlobalFree(hBuff) ;
        hBuff = NULL ;
        return 0 ;
     }
  }
  if (NULL == hBuff)
  {
     hBuff = GlobalAlloc(GMEM_MOVEABLE, iSizeOfBuff) ;
     if (!hBuff)
        return 0 ;
     lpBuff = GlobalLock(hBuff) ;
     if (!lpBuff)
        return 0 ;
  }
  SendMessage(hEditWnd, WM_GETTEXT, iSizeOfBuff, (LONG) lpBuff) ;
  lstrcat(lpBuff, Msg) ;
  if (bWithReturn)
  {
     lstrcat(lpBuff, &quot;\015\012&quot;) ;
  }
  SendMessage(hEditWnd, WM_SETTEXT, 0, (LONG) lpBuff) ;
  return TRUE ;
}
int KillCurrentDOSProcess()
{
  _asm mov  ah,  4Ch
  _asm mov  al, 0FFh
  _asm int  21h
  if (0)
     return 0 ; // get rid of no return code error message
}
// note this allocates and deletes a save buffer each time... We should really
// query the edit control to see how big it is, instead of assuming 10K is big
// enough. This is fine for as it shouldn't generate that much output!
BOOL SaveBuffer(char *filename)
{
  HANDLE hBuff ;
  PSTR   pBuff ;
  FILE  *flOutput ;
  int    NoOfChars, iSizeOfBuff = 10 * 1024 ;
  hBuff = LocalAlloc(GMEM_MOVEABLE, iSizeOfBuff) ;
  if (!hBuff)
     return 0 ;
  pBuff = LocalLock(hBuff) ;
  if (!pBuff)
     return 0 ;
  SendMessage(hEditWnd, WM_GETTEXT, iSizeOfBuff, (LONG) (LPSTR) pBuff) ;
_asm int 3h
  if (pBuff)
  {
     flOutput = fopen(filename, &quot;rb&quot;) ;
     if (flOutput)
     {
         // warn user file exists -- only continue if they permit it!
         //   ow return
     }
     flOutput = fopen(filename, &quot;w&quot;) ;
     if (flOutput)
     {
        NoOfChars = strlen(pBuff) ;
        fwrite(pBuff, sizeof(char), NoOfChars, flOutput) ;
        fclose(flOutput) ;
     }
     LocalUnlock(hBuff) ;
     LocalFree(hBuff) ;
  }
  // ow edit control error!
}
BOOL PrintOutTrapRegs( unsigned int BPofFrame )
{
// a NOP in the C version of TrapMan
  if (0)
     return 0 ;
}

</pre>
<h4><a name="0307_0114">Listing Two<a name="0307_0114"></h4><pre>
#define argc __argc
#define argv __argv
extern int     argc ;
extern char  **argv ;
if (argc &gt; 1) {
   int rc ;
   rc = WinExec(argv[1], SW_SHOW) ;
   if (rc &lt; 0x20) {
      wsprintf( szBuffer, &quot;Cannot load '%s', error code=%d&quot;,
                 (LPSTR) argv[1], rc) ;
      MessageBox(NULL, szBuffer, &quot;TrapMan&quot;, MB_ICONEXCLAMATION | MB_OK) ;
      }
   }

</pre>

<HR><P>Copyright &copy; 1994, <I>Dr. Dobb's Journal</I></P></BODY></HTML>
