<HTML>
<META NAME="year" CONTENT="1994">
<HEAD>
<TITLE>SP 94: Avoiding Windows PATH Cram </TITLE></HEAD>
<BODY BGCOLOR="#ffffff">
<h1>Avoiding Windows PATH Cram <a name="02fb_0104"></h1><P>
<h2><a name="02fb_0102"><a name="02fb_0000">FreePath solves the problem by not adding new directories </h2><P>
<h3>Joseph M. Newcomer</h3><P>
<p><i><a name="02fb_0103"><a name="02fb_0000">Joe received his PhD in 1975 in the area of compiler optimization. He is a Windows consultant and applications developer based in Pittsburgh, PA. His past experience has included computer graphics, document-processing software, operating-systems development, compiler development, CASE tooling, computer music, and real-time and embedded-systems development.</i></p><hr><P>
Back in the old days of DOS, we suffered with &quot;RAM cram.&quot; We had large TSRs and device drivers that consumed massive amounts of lower 640K memory, leaving insufficient memory for running applications. Windows solved this by using VxDs to provide some of these capabilities and multitasking Windows apps to provide most of the others.<P>
However, Windows has subjected us to a far worse problem: &quot;PATH cram.&quot; How many times have you installed a new application, only to find out that it has added itself at the front of your PATH? If you remove it, the application doesn't run. And what happens when that miniscule 127-byte PATH limit is reached? You lose even more than with TSRs because the limit is so much lower. <P>
A massive PATH means that the cost of loading a DLL or executable becomes incredibly high because each directory must be searched. If you spawn a DOS shell and type some nonexistent command, plenty of time can pass before the error message appears. With DOS 6.0 and higher (as well as other MS-DOS-compatible operating systems) this can be solved using separate, often empty configuration sections in the CONFIG.SYS. These set the %CONFIG% variable that can be tested in AUTOEXEC.BAT to select among several PATH statements. However, having to reboot between applications is not exactly user friendly. Alternately, all the necessary DLLs can be dumped into a single directory in the PATH, but this creates a directory full of incomprehensible files. Removing or updating a program then becomes a nightmare, particularly if DLLs are shared by several applications. This also results in &quot;disk cram,&quot; in which each install dumps five or ten megabytes of DLLs into your Windows directory. The install procedures are often rather crude, and if there is not enough free space on the drive containing Windows, the install will usually refuse to attempt the installation. <P>
Another disadvantage of PATH is that it allows one program to mask another; for example, if an application is delivered with a DLL, then exactly which DLL is invoked may depend upon whether you have added the new directory at the front or back of your PATH. If you have put it at the end of the PATH, then a DLL of the same name (but possibly with different interfaces!) found earlier in the PATH will be used, with potentially disastrous consequences. If you put the new directory at the front of your PATH, the program that previously used the DLL of the same name will now see the new DLL instead.<P>
Typical DLLs first try the current directory, then the Windows and Windows\SYSTEM directories, then the directory containing the executable file, then the directories listed in the PATH, and finally the list of directories mapped in a network. Normally the DLL will be stored with the executable file and found before the PATH is searched; it is becoming more common, however, to have shared DLLs placed in a separate directory, forcing <I>LoadLibrary</I> to use the PATH. Thus, two identical systems loaded with the same executables might exhibit completely different behavior based solely upon the differences in their PATH variables. Fundamentally, the PATH mechanism is a poorly designed, inefficient abbreviation mechanism for translating from an unqualified program name to a particular instance of executable code. Its great charm is that it is easy to implement, which explains its survival.<P>
My normal DOS approach was to have a minimal PATH and execute programs with .BAT files that either gave an explicit path to the executable or temporarily set the PATH to a new value. But the PATH must be set before you start Windows, so you cannot change it dynamically. DOS-based software should function correctly if invoked by an explicit directory path on the DOS command line, even if the user's PATH is empty. Trivial as this is to accomplish (use <I>argv[0]</I> to derive the home directory of the program), many commercial DOS applications fail if the program's directory is not in the PATH. For Windows, I use <I>GetModuleFileName</I> to obtain the program directory, and consequently never have to depend upon the PATH to find those DLLs, executables, or data files that would reside there. Finally, you can use an application-specific .INI file initialized during the setup to hold a section that locates other executables or DLLs: <I>[programs] mumble.exe=d:\mumble\bin\mumble.exe</I>. <P>
Using <I>LoadLibrary</I> with an explicit path, followed by a series of <I>GetProcAddress</I> calls to initialize a series of pointers, makes it relatively easy to avoid requiring an implicitly loaded DLL. This eliminates the need for PATH; a simple macro makes the code look as if an implicitly loaded library were used.<P>
All of these techniques can bulletproof an application from the vagaries of PATH; unfortunately, most commercial applications do not practice PATH-safe computing. For me, the breaking point came when I recently installed the OLE 2.0 (April 1993) SDK from the MSDN CD-ROM. It wanted not just one, but three new directories with long names in my PATH! This was simply impossible; the PATH is already too long to hold what is needed. I needed a way to avoid putting anything else in my PATH so that it could be found by Windows.<P>
My solution to PATH cram is a program called &quot;FreePath.&quot; It is designed to be loaded from the LOAD= line in your WIN.INI file, and it handles the PATH problem by simulating the effect of PATH without actually requiring new directories to be added to the PATH. <P>
<h3><a name="02fb_0105"><I>ProcHook</I> to the Rescue <a name="02fb_0105"></h3><P>
Key to making FreePath work is the <I>ProcHook</I> DLL presented in the article &quot;Hook and Monitor Any 16-bit Windows Function with our ProcHook DLL,&quot; by James Finnegan in <I>Microsoft Systems Journal</I> (January 1994). Finnegan's DLL allows an application to provide a callback function which will intercept any selected Windows API call. A &quot;hook&quot; to this function is then set in the selected API call, allowing you to do anything with this API call, including calling the underlying API that had been hooked. Hooks are set by the <I>SetProcAddress</I> call, temporarily removed and restored by the <I>ProcHook</I> call, and permanently removed from the hook database by the <I>SetProcRelease</I> call. <a href="#02fb_0111">Table 1</A> provides relevant information about the <I>ProcHook</I> DLL. Hooks are implemented by actually modifying the code of the procedure to contain a JMP to either the hook handler or its instance thunk. To call the actual API call, you must replace the 5-byte JMP instruction with the original code sequence using <I>ProcUnhook</I>, then perform the call again; this time it will not be intercepted by the hook procedure. I hooked the <I>LoadLibrary</I>, <I>LoadModule</I>, and <I>WinExec</I> calls. The real work, as you'll see, is done in <I>LoadModule</I>. <P>
The initial design was simple: My hook procedure would first try to load the module using the base <I>LoadModule</I> call. If <I>LoadModule</I> succeeded, it would rehook the callback and return the HINSTANCE value to the caller. If the call failed, I would then look at the filename that was passed in. If it were an absolute pathname, I would simply return the error code. However, if it were a simple name--such as FOOBAR.DLL, FOOBAR.EXE, or the like--I would find a corresponding complete path and try again. If this second attempt failed, I would return the error code of the first call; otherwise, I would return the newly obtained instance handle. This would successfully simulate the PATH without doing a search! As it turned out, the final implementation was much more complicated.<P>
<h3><a name="02fb_0106">Maintaining the Mappings <a name="02fb_0106"></h3><P>
I had to decide where to store the path-mapping information--in the overused and much-abused WIN.INI file, in an application-specific .INI file, or in the &quot;more-modern&quot; registration database. The registration database has several potential advantages: <P>
<UL>
<li>It is considered to be the successor of the .INI file.</li>
<li>There is a tool to manipulate it (regedit), and its interface is cleaner than that of .INI files.</li>
<li>It allows for hierarchical key/value pairs.</li>
<li>It does not require textual processing (parsing the entries).</li>
<li>A simple add-and-delete capability could be incorporated into my hook processor without much programming.</li>
</UL>
The registration database also seemed to have significant performance improvement over the alternative methods because it keeps a cached copy of some of its information in memory. Although less efficient than writing my own binary database system, it involved considerably less effort.<P>
I could not find any good documentation on the &quot;proper&quot; use of the registration database (all existing documentation concentrates on its use for OLE servers), so I adopted some conventions. The first-level key is the name of my application, FreePath. Below this are names of some FreePath-related options, and under each option is a list of program name/pathname pairs. <P>
An entry in the registration database is obtained by passing in a pointer to a string that looks like a directory string, for example, <I>FreePath\Active\foobar.dll</I>. The text string, which in my case is the full pathname, can be obtained by using the <I>RegQueryValue</I> API call. If I cannot find a full pathname to substitute in the registration database, I just return the error code of the <I>LoadModule</I> that failed.<P>
I required that the mapping from a program name to a pathname be complete, rather than just a path to be prefixed; not only was this a bit simpler, but it also meant that the user could redirect to another DLL that had the same interface! <P>
The code that locates a mapping is shown in <a href="#02fb_0113">Listing One</A> . It uses a static variable for its scratch area so that it does not consume any more stack space than necessary for calls (see &quot;Conserving Resources: Stack Space&quot;). There is no way to tell how much stack is available when <I>LoadModule</I> is ultimately called, so the callback code should not be profligate of stack space (see Finnegan's article). The code simply forms the key &quot;FreePath\Active&quot; and opens the registration database for that key. If it finds the key, the code queries the subkey value, which is the filename of the module to be loaded--that is, it locates the value associated with FreePath\Active\filename. If the value is found, it is returned via the parameter pointer <I>newfile</I>. <P>
<a href="199402fd.htm">Figure 1</A> is a sample of the registration database, as shown by regedit. Note that several other keys appear here. The distributed version lets you disable a definition (for example, for testing); disabled mappings are under the disabled key. You can also instruct FreePath to log any requests that generate errors or any requests for names which are not found; these are kept under the keys <I>BadPath</I> and <I>NoPath</I>, respectively. This can help determine why a load failed; for example, you may not realize that an executable needs a certain DLL; just turn on the error logging and the failing name will appear in the database! A simple pushbutton will clear these failure entries from the database, so you don't have to search through hundreds of two-week-old failure requests, or delete them one at a time. <P>
<h3><a name="02fb_0107">The User Interface<a name="02fb_0107"></h3><P>
The FreePath control panel is shown in <a href="199402fe.htm">Figure 2</A>. This provides an application-specific editor for the registration database, and makes it easy to, for example, move a mapping from the Active to Disabled section, and back. The Display check boxes allow for selective display of information from the registration database, and the API check boxes allow for the API calls to be selectively enabled or disabled. A global Disable check box not only disables the actions, but completely removes the hooks set by <I>ProcHook</I>, leaving your system in its pre-FreePath condition. <P>
I added the Performance section to determine FreePath's effectiveness. To improve its own performance, FreePath does not attempt to update this display when it is minimized; if it is visible, you see the numbers update in real time as modules are loaded. The counters are maintained internally even when the display is minimized (the overhead of a simple &quot;++&quot; operation is very small). When the icon is opened, the WM_SIZE handler posts a message to update the Performance display.<P>
The Browse button brings up a file dialog and lets you locate a file to enter. It automatically sets the name to correspond to the filename part of the full pathname. You may also type a full pathname directly and FreePath will automatically fill in the filename.<P>
The status of all the check boxes is stored in the FREEPATH.INI file in the Windows directory. When FreePath is started, its initial settings are taken from this initialization file. If you change any of the settings, the Save Now button will become active; clicking it will save the profile settings. Normally the profile is saved upon program exit, but since this program normally doesn't exit unless Windows shuts down successfully, I wanted to provide an option to guarantee that a particular configuration could be saved.<P>
The Enable (alternatively Disable) button becomes active if a disabled or Active entry is selected from the list box, allowing the entry to be transferred between the two categories; Delete will delete a selection, and Add will add (or replace) an Active entry from the contents of the Name and Path input boxes. <P>
<h3><a name="02fb_0108">The Callback Table<a name="02fb_0108"></h3><P>
Certain actions had to be performed for all callbacks, while others had to be performed for specific callbacks only. Rather than hardwire all the values for generic actions into the program, I simply constructed a table which pointed to individual entries; see <a href="#02fb_0114">Listing Two</A> . The table contains a printable name (primarily for the debugging output), the address of the &quot;real&quot; procedure, a pointer to the handler procedure <I>MakeProcInstance</I> thunk, an entry for the hook argument to the <I>ProcHook</I> and <I>ProcUnhook</I> calls, the control id that enables the check box, and a set of Boolean flag values that indicate flag status. <P>
The table is initialized using the code shown in <a href="#02fb_0115">Listing Three</A> . I immediately <I>ProcUnhook</I> the hook set by <I>SetProcAddress</I>; if a hook fails to take, I make the check box that selects it invisible. (Initially, I had simply disabled the check box, but I found the distinction too subtle to detect, so I changed it to completely hide the box in question.) The use of <I>MakeProcInstance</I>, now largely obsolete because of smart callbacks, is absolutely mandatory for <I>ProcHook</I> (see Finnegan's article).<P>
The callback table is initialized via a <I>PostMessage</I> call set up during the <I>OnInitDialog</I> handler. This is because <I>WinExec </I>does not return control to the calling application until the first Yield, typically implied by the <I>GetMessage</I> of the top-level message loop. Hooking the <I>WinExec</I> function before <I>WinExec</I> completes (in particular, the WinExec that launched FreePath) can cause a catastrophe. Finnegan recommends performing the hook initialization via a handler invoked from the top-level message loop via a <I>PostMessage</I>; see <a href="#02fb_0115">Listing Three</A>.<P>
Once the table is initialized, <I>SetHooks </I>establishes the settability of its hooks, after which the <I>EnableHooks</I> call actually places them; see <a href="#02fb_0116">Listing Four</A> . Note that the <I>m_API</I> variables (<I>m_LoadLibrary</I>, for example) are variables maintained by the Microsoft Foundation Class (MFC) library to reflect the status of the check boxes; <I>m_Disabled</I> represents the state of the &quot;disabled&quot; check box that renders the program totally inactive, even to the point of removing its physical hooks. <P>
<h3><a name="02fb_0109">The Hook Handlers <a name="02fb_0109"></h3><P>
The hooking is handled by callback procedures. Each API procedure to be intercepted has its own callback procedure as a hook handler. The handler's signature is the same as that of the API procedure. When a hook is set, any call to the API procedure will transfer control to its associated handler. The callback can do anything it wants, including calling the hooked API procedure. To prevent infinite recursion, the hook handler must first unhook the API procedure that calls it, then rehook it before returning. <P>
The simplest callback is the <I>WinExec</I> callback, <I>Free_WinExec</I>, in <a href="#02fb_0117">Listing Five</A> . Following the algorithm described, I unhook the procedure, perform certain actions, call the underlying &quot;real&quot; procedure, perform more actions, and return. In this case, I wanted to &quot;activate&quot; the <I>LoadModule</I> handler, whether the user had explicitly checked <I>LoadModule</I> as a trappable API call or not. If called from <I>WinExec</I>, its performance would be dictated by the <I>WinExec</I> check box, hence the assignment <I>p_LoadModule.active = p_WinExec.active</I>. <P>
The <I>LoadLibrary</I> handler, <I>Free_LoadLibrary</I>, is a bit more complex because after reading Matt Pietrek's <I>Windows Internals </I>(Addison-Wesley, 1993), I was under the impression that <I>LoadLibrary</I> would be implicitly called to load related DLLs.<P>
Pietrek correctly pointed out that <I>LoadLibrary</I> is just a shell around <I>LoadModule</I> and that WinExec is a wrapper around <I>LoadModule</I>. Consequently, I thought I could do everything just by hooking <I>LoadModule</I>. However, I realized that some users might not want everything redirected, so I gave the option of specifying which API calls were to be redirected. I mistakenly assumed, however, that <I>LoadModule</I> could call <I>LoadLibrary</I> to load any implicit libraries, which, of course, would call <I>LoadModule</I>. (The alleged relationships between the API calls are shown in <a href="199402ff.htm">Figure 3</A>, and this seems to be supported by the pseudocode on page 259 of Pietrek's book.) This led me into a recursive situation--once I unhooked <I>LoadLibrary</I> to call the &quot;real&quot; <I>LoadLibrary</I>, I ran the risk of getting another call to <I>LoadLibrary</I>; because I had removed the hook, however, my callback would not see the call, and the real <I>LoadLibrary</I> would end up calling the real <I>LoadModule</I>. This complicated the implementation somewhat. <P>
According to Pietrek, the &quot;helper function&quot; <I>LMImports</I> (called by <I>LoadModule</I>) calls <I>LoadLibrary </I>to load any related implicitly linked libraries. In fact, I discovered that it does not, and the true structure was inferred by setting a breakpoint at <I>LoadModule</I> and examining the callback stack from CodeView; see <a href="19940300.htm">Figure 4</A>. <P>
The effects of this difference were nearly enough to kill the whole project. Fortunately, some of the code was salvageable because it handles a related problem, where the <I>LibMain</I> of a DLL explicitly calls <I>LoadLibrary</I>; see <a href="#02fb_0118">Listing Six</A> . <P>
The <I>LoadLibrary</I> handler works much like the <I>WinExec</I> handler: It is unhooked, and ultimately I call the underlying &quot;real&quot; <I>LoadLibrary</I> call. If the <I>LoadModule</I> check box wasn't selected on the user interface, it will not be active. But since I have to intercept <I>LoadModule</I> to complete <I>LoadLibrary</I>, I activate it by setting the active field TRUE. In addition, <I>LoadModule</I> might not actually have a hook set because <I>Free_LoadModule</I> unhooked itself to call <I>LoadModule</I>; if necessary, <I>ProcHook</I> is called to reset the <I>LoadModule</I> hook. If the hook was set active and the user doesn't want <I>LoadLibrary</I> mapping, we deactivate the <I>LoadModule</I> hook. After I call the &quot;real&quot; <I>LoadLibrary</I> routine, I reset the <I>LoadModule.active</I> state. If <I>LoadModule</I> has been hooked from within <I>LoadLibrary</I>, I unhook it and restore its active flag.<P>
<h3><a name="02fb_010a"><I>LoadModule</I><a name="02fb_010a"></h3><P>
First, I'll illustrate <I>Free_LoadModule</I>'s basic operation. Then I'll detail the consequences of the differences between the ideal implementation (<a href="19940301.htm">Figure 1</A>) and the real implementation (<a href="19940302.htm">Figure 2</A>), and aspects of subtler interactions such as <I>SetErrorMode</I>. The <I>Free_LoadModule</I> code and its associated helper function <I>Call_LoadModule</I> are in <a href="#02fb_0119">Listing Seven</A> .<P>
One little glitch was the error notification built into Windows. To handle this correctly, I had to add the <I>SetErrorMode</I> processing. The error-reporting dialog box that normally pops up when a load fails should be suppressed, but I must pop it up if I cannot remap the load request and if the prevailing error mode would have popped it up had FreePath not been handling the load operation. I must properly simulate the Windows behavior that would have occurred without FreePath. The handler and helper functions appear in <a href="#02fb_011e">Listing Twelve</A> . For now, assume that <I>Call_SetErrorMode</I> is just <I>SetErrorMode</I>.<P>
After setting the error mode, I unhook the <I>LoadModule</I> procedure, as expected. For now, ignore the pong-related code and the strange handling of the <I>filename_stack</I> and <I>filename_ptr</I>; these will be discussed later. <P>
To avoid potential mutual recursion with <I>LoadLibrary</I>, if the <I>LoadLibrary</I> handler is unhooked I rehook it at this point (note that I will have to unhook it upon exit). Next, I perform the actual call on the base <I>LoadModule</I> function via <I>Call_LoadModule</I>. This is just a convenient way to package the pong-related code; substituting <I>LoadModule</I> for <I>Call_LoadModule</I> gives a good approximation of program execution. If the call to the base <I>LoadModule</I> succeeds, I increment a counter (for the Performance display on the FreePath control panel), notify the panel that an update is requested, clean up all the state I have modified, and return the instance handle to the caller. If the <I>LoadModule</I> call does not succeed, and <I>LoadModule</I> is &quot;active,&quot; life becomes far more interesting_.<P>
At this point, I am dealing with the &quot;primary load&quot; failure case. It is not clear exactly why the base <I>LoadModule</I> call failed. Consider the case of loading a program, TOP.EXE, which requires the implicit library DLL1.DLL. The DLL1.DLL library requires the loading of the implicit library DLL2.DLL. Therefore, when I get an error return, I don't know exactly why TOP.EXE failed to lead; either TOP.EXE, DLL1.DLL, or DLL2.DLL was not found. This is another use for the <I>LoadModule_Depth</I> counter: If the failure occurred at the immediate call to <I>LoadModule</I>, then the <I>Failure_Depth</I> will be zero because it is set to zero before the call to the base <I>LoadModule</I> and no recursive calls to <I>LoadModule</I> failed. In this case, I can attempt a retry. If, however, the <I>Failure_Depth</I> is nonzero, the failure must have occurred at a much lower level, because the <I>LoadModule_Depth</I> was stored at the time the failure occurred. I have already issued an error message for it, and retrying the operation with a mapped name will not help, so I just go directly to the failure exit.<P>
Next, I check whether the path given was absolute or just an unqualified name. The code for <I>RelativePath</I> is in <a href="#02fb_011a">Listing Eight</A> . I did not wish to implement a parser for pathnames, especially when the C library already had one; unfortunately, it was model specific. This meant that it wanted a <I>char *</I> pointer, which in medium model is 16 bits of DS-relative offset, whereas I had passed in an LPCSTR, a 32-bit FAR pointer. The solution was to copy the string to a local (near) variable and apply<I> _splitpath</I>. I also test whether the string length is acceptable and return FALSE if it is too long. If there is a drive or directory in the path, I assume that it is not mappable and return FALSE; otherwise it is mappable. While it is certainly possible to create mappings for fully qualified names, there are some problems with the backslash characters, and in any case, the point is to simulate the PATH environment, which only deals with unqualified names. (Note the use of static variables to avoid stack consumption.)<P>
If the path is unqualified, I call <I>GetMappedFile</I> to map the file to a new name. If this fails, I take the failure exit. The code for <I>GetMappedFile</I> is shown in <a href="#02fb_0113">Listing One</A>. If I find a mapping, I attempt to issue the base <I>LoadModule</I> call using the new filename. If this call fails, I increment a counter for the Performance display and take the error exit. If it succeeds, I increment a success counter for the Performance display.<P>
In the exit code, I deal with more pong-related processing, unhook the <I>LoadLibrary </I>hook if it was set, rehook the <I>LoadModule</I> intercept if necessary, restore the error mode, and return. The desire to put the pong-related code in one place resulted in the helper function <I>Call_LoadModule</I>. <P>
In the failure exit code, I examine the prevailing <I>SetErrorMode</I> state. If it is not SEM_NOOPENFILEERRORBOX, I reset the error mode to the prevailing error mode and issue a <I>LoadModule</I> call. This will force the standard (and expected) Windows error box to appear. <P>
<h3><a name="02fb_010b">Playing &quot;Pong&quot; with Hooks <a name="02fb_010b"></h3><P>
After the entire user interface was developed and the first-level functions were operational, I then tackled the <I>LoadModule/LoadLibrary</I> recursion problem. I came up with a brute-force solution, as follows: <P>
<OL>
<LI>A hook is set at <I>LoadModule</I> that transfers control to the handler <I>Free_LoadModule</I>.</LI>
<LI><I>Free_LoadModule</I> unhooks the hook but sets a new one at a later point in <I>LoadModule</I>. </LI>
<LI><I>Free_LoadModule</I> calls the base <I>LoadModule</I>.</LI>
<LI>The secondary hook transfers control to the secondary-hook handler.</LI>
<LI>The secondary-hook handler rehooks the <I>LoadModule</I> hook.</LI>
<LI>The secondary hook removes itself and resumes execution of <I>LoadModule</I>.</LI>
</OL>
Because these hooks alternate back and forth, with control bouncing from one to the other, I named the secondary hook the &quot;pong hook,&quot; in honor of that first video game. Now I had to come up with a feasible and reasonable implementation. I rejected several alternatives for the same reason that Finnegan did; for example, using an INT3 interrupt would cause problems if you were running a debugger. Clearly there was a nice hook-setting mechanism in PROCHOOK.DLL. But the hook mechanism of <I>ProcHook</I> inserted direct JMP instructions to the handler thunk so that the stack frame would be correct in the handler. If I did a JMP from the middle of the code, I would get control with the stack frame in some undefined state that certainly would not cause the handler procedure to return to the desired location. To resume, the ordinary hook handler depends upon the RETF that it executes to return to the caller of the hooked function because that is how the stack frame is set up. In my case, I had to insert a hook that would allow the handler to return to the point that I had intercepted. In debugging at the code level, I discovered that the calls beyond the API entry point for <I>LoadModule</I> passed parameters via the registers, for example, CX:AX. If I placed my intercept code after this point, I would have to preserve CX:AX, which is not an assumed condition for the C compiler; in particular, the thunk code modifies AX. The internal calls were also NEAR rather than FAR calls, which would make setting intercepts at the called procedure difficult and potentially hazardous. The actual code for the first few instructions of the Windows 3.1 <I>LoadModule</I> is shown in <a href="#02fb_011b">Listing Nine</A> . Not knowing what that first Call instruction called, I wanted to do my intercept before it was reached. But I had to set the new hook in such a way that when it rehooked <I>LoadModule,</I> the placement of the hook would not interfere with the execution of the instructions. Therefore, the secondary hook had to be at least five bytes into the <I>LoadModule</I> code so that the 5-byte far JMP that <I>ProcHook</I> installed could be safely placed.<P>
My solution was to plant a <I>ProcHook</I> <I>within </I>the <I>LoadModule</I> code. Careful inspection of the code determined that the earliest feasible place was also at least five bytes into the code (and, of course, on an instruction boundary). I placed it at <I>LoadModule+5</I>. However, a JMP instruction would not transfer control properly to the handler. I therefore modified the hook instruction after the hook was set to be a CALL instruction. In order that <I>ProcHook</I> continue to work correctly, I restored the operation to a JMP instruction before unhooking it. In the handler, I modify the return address to point to the location where the hook was set. This implementation is void where prohibited by law.<P>
Creating the pong handler required careful reading of the generated entry and exit code of the <I>Free_Pong</I> routine in <a href="#02fb_011c">Listing Ten</A> . As I expected, the instruction-pointer portion of the far-return address was two bytes above SS:BP. I reset this value to be the pointer to the pong hook location, using the <I>__asm</I> insertion shown. The complete pong code outside <I>Free_LoadModule</I> is in <a href="#02fb_011d">Listing Eleven</A> . Note the use of the undocumented <I>AllocCStoDSAlias</I> call, the same one Finnegan uses to map the selectors. <I>AllocCStoDSAlias</I> must be declared as <I>extern &quot;C&quot; UINT WINAPI AllocCStoDSAlias(UINT);</I> and the .DEF file must contain the declaration: <P>
IMPORTS <P>
AllocCStoDSAlias = KERNEL.170 <P>
The pong code is quite fragile and could, with a minor change in the code for <I>LoadLibrary</I>, seriously corrupt the system. Before I set the hook, I verify that the bytes found at the location where I place this internal hook are those that I expected. This code does not show that I have let the offset and signature to be specified by the .INI file, to allow for unforeseen circumstances. Such capabilities should not be used casually! <P>
<h3><a name="02fb_010c">Handling <I>SetErrorMode</I> <a name="02fb_010c"></h3><P>
The first time I tried to load a complex system (Quattro Pro for Windows), Windows complained that it could not find one of its DLLs by popping up a <I>MessageBox</I>. This suggested that my code was suddenly failing for some unknown reason. Yet after I clicked on OK, Quattro Pro came right up, which it could not have done if the DLL had actually failed to load. In examining the log data I wrote with <I>OutputDebugString</I>, I saw that the first attempt to load it had indeed failed, and the second (mapped) attempt had succeeded. I added the <I>SetErrorMode</I> call so that (expected) failing load attempts would not notify the user. Of course, this behavior is also unacceptable if the FreePath remapping attempt fails or can not be attempted because no remapping was found. Therefore, in the failure exit, unless the user has externally set the error mode to SEM_NOOPENFILEERRORBOX, I simply re-issue the base <I>LoadModule</I> call. I could have done my own <I>MessageBox</I>, but that would lead to problems in internationalization; it would be confusing if some messages came up in the user's native language, and one that looked remarkably like a Windows message popped up in English. To avoid this, I force the underlying <I>LoadModule</I> code to issue the error. <P>
This suppression of the error message introduces yet another problem: Suppose that TOP.EXE requires DLL1.DLL, and DLL1.DLL requires DLL2.DLL. I come in, set the error mode off, and load TOP.EXE successfully. TOP.EXE calls <I>LoadModule</I> to load DLL1.DLL, which also is successful; <I>LoadModule</I> is called again to load DLL2.DLL, which fails. By the time it gets to DLL2.DLL, I have already turned the error reporting off (at the highest level, when attempting to load TOP.EXE). <I>LoadModule</I> would typically have no history as to whether it was called from a user application or from an internal recursive call. Thus, I might fail to issue the error message because the error mode is incorrect. So I added two variables: <I>LoadModule_Depth</I> and the <I>Prevailing_ErrorMode</I> array. Note that I use the <I>Prevailing_ErrorMode</I> for the current <I>LoadModule_Depth</I> as the context in which I issue the <I>LoadModule</I> attempt that should generate the error message. Of course, now <I>LoadModule</I> must properly maintain the <I>Prevailing_ErrorMode</I>, so I set a <I>ProcHook</I> in <I>SetErrorMode</I>. This allows my own <I>SetErrorMode</I> handler, <I>Free_SetErrorMode</I>, to intercept the <I>SetErrorMode</I> calls and maintain the <I>Prevailing_ErrorMode</I>. This handler is in <a href="#02fb_011e">Listing Twelve</A>.<P>
The hooking of <I>SetErrorMode</I> rendered my code undebuggable, due to the interaction of CodeView with the <I>SetErrorMode</I> handler. I had made a minor error in the code which I didn't see immediately, so I brought up CodeView. I discovered that attempting to debug the code resulted in an infinite recursion entering <I>Free_SetErrorMode</I>. This seemed even less explicable than the bug I was looking for, which was that the <I>SetErrorMode</I> was not yet correctly maintained. In single-stepping, I discovered that I went into the infinite loop when I called <I>ProcHook</I>, which was even more confusing! I started single-stepping into <I>ProcHook</I> and got a fault in KRNL386.EXE in an <I>_fmemcpy</I> call. Suddenly, I remembered that one of the options to <I>SetErrorMode</I> is SEM_NOGPFAULTERRORBOX, which has the annotation &quot;This flag should be set only by debugging applications that handle GP faults themselves.&quot; The code in <I>ProcHook</I> that sets the hook consists of two <I>_fmemcpy</I> calls; see <a href="#02fb_0112">Example 1</A>.<P>
While single-stepping, CodeView apparently calls <I>SetErrorMode</I> just before control returns to the user prompt. The internal failure occurred as I single-stepped across the first <I>_fmemcpy</I>. This has just changed the first instruction of <I>SetErrorMode</I> to a JMP, but the jump address, installed by the second <I>_fmemcpy</I>, has not yet been installed, which explains that failure. I wanted to rewrite <I>ProcHook</I> so that a single <I>_fmemcpy</I> would set the hook in one 5-byte transfer--that way, when CodeView called <I>SetErrorMode</I> before returning control to the user, a valid hook would have been set. But take a look at <a href="#02fb_011e">Listing Twelve</A>. In <I>Free_SetErrorMode</I>, I call <I>Call_SetErrorMode</I>, which determines if the <I>.set </I>flag is TRUE and the hook pointer is not NULL. But since control has not yet returned to my code, I have not stored the result of <I>ProcHook</I>, so the value of the hook is NULL; I certainly would not have executed the next statement, so the value of the <I>.set </I>field would be FALSE. Thus, I would not call <I>ProcUnhook</I>, and the infinite recursion would happen. Now, all this would happen if I were single-stepping inside <I>ProcHook</I> itself, but it happens even when I am single-stepping my own code. Unfortunately, because I would have stored the <I>.hook</I> field, but not the <I>.set</I> flag, my test would again fail. Of course, I could set the <I>.set</I> flag first, but this would only be a partial solution. To fix this, I would have to actually test the first instruction of <I>SetErrorMode</I> to see if it was a JMP, and if so, unhook the handler before calling <I>SetErrorMode</I>. But this would work as long as I did not single-step into <I>ProcHook</I> and try to trace it; for complete success, I would have to modify <I>ProcHook</I> to set the hook in a single 5-byte transfer. I would also have to add an <I>IsHooked </I>call to tell me if the API is already hooked to me. These would be changes to the <I>ProcHook </I>library, and I did not wish to have a private, customized version of it. For now, I just avoid single-stepping into a <I>ProcHook</I> call on <I>SetErrorMode</I>, and set my breakpoint after I have successfully stored <I>p_SetErrorMode.set</I>. <P>
<h3><a name="02fb_010d">Conserving Resources: Message Queue <a name="02fb_010d"></h3><P>
When writing a program that attaches itself symbiotically into a system, it must not have a significant impact on the system's overall resource requirements or performance. I did not want to slow the system down by updating the Performance display if it was not necessary, or impose the additional stack space requirements for calling the update routine, as would be required for a <I>SendMessage</I>. Therefore, I used a <I>PostMessage</I> call to post an update request. The <I>PostMessage</I> queue size is usually very small and could overflow if a complicated module suite were loaded. Therefore, I set a flag after issuing the first <I>PostMessage</I>, and I issue no subsequent <I>PostMessage</I> calls until the message was handled and the flag was cleared. For performance reasons, the display need not be updated if the program is iconized, so I don't even bother with <I>PostMessage</I> when the window is iconized. <P>
The interface here spans both C++ (in which the user interface is written) and pure C (in which the callbacks must be written), so I reflect some of the C++ state (from members of the class) into static C variables. One such variable is the window handle to which to post messages, <I>C_var_PostWnd</I>. If the window is iconized, I set it to NULL; if the window is restored, I set it to the window handle. The full posting code is shown in <a href="#02fb_011f">Listing Thirteen</A> . The <I>NotifyUpdate</I> procedure is called from the callback for <I>LoadModule</I>; it does not attempt <I>PostMessage</I> if the <I>C_var_PostWnd</I> is NULL. Note that an update request is posted in the restoration of the window. <P>
<h3><a name="02fb_010e">Conserving Resources: Stack Space<a name="02fb_010e"></h3><P>
Generally, I have conserved stack space by making local variables static so that they are allocated in the program's DGROUP. However, in one case this was not possible: Keeping the local name of the mapped file required keeping a local copy in each recursive incarnation. I had initially done this in the obvious way, by allocating a local <I>char[_MAX_PATH]</I> array. Unfortunately, I would occasionally get a fatal stack overflow (which would crash all of Windows) when loading a complex program. Some careful investigation suggested that this might be caused by overconsumption of stack space. The only culprit I could find was the large <I>char</I> array that held the filename. <P>
I therefore chose the implementation shown in <a href="#02fb_0119">Listing Seven</A>. On each recursive entry, I store the current value of the <I>filename_ptr</I> in <I>new_filename</I>. After I fill in the new filename string in the location pointed to by <I>new_filename</I>, I increase <I>filename_ptr</I> by the length of the string plus one byte for the terminating NUL byte. When I exit the procedure, I reset <I>filename_ptr</I> to the value I stored in <I>new_filename</I>. This gives me a very compact filename stack. From a viewpoint of language purity this is outrageous; our languages are supposed to handle this for us. However, it reduces consumption of the application stack (SS:SP), a scarce resource over which I have no control, and increases consumption local DGROUP space, which is comparatively plentiful, essentially unrestricted, and over which I have complete control. I chose a large limit, MAX_PATH_DEPTH, on the length of the mapped strings, which in general should translate to several times that capability for realistic path lengths. <P>
Note that I only use static temporaries in those procedures that can be called via the callbacks, where SS!=DS. For other uses, such as working with the user interface, the stack is our own, and SS==DS; the stack for the program is large enough to handle these cases, and there is no potential recursion, so large limits (such as 256 bytes) are acceptable.<P>
<h3><a name="02fb_010f">Conclusions<a name="02fb_010f"></h3><P>
Finnegan's <I>ProcHook</I> DLL is critical to this operation. It allows (nominally) any API call to be intercepted and routed to a handler. The binary code for PROCHOOK.DLL is provided electronically; see &quot;Availability,&quot; page 3. The source code is available on CompuServe, Microsoft Download Service (206-936-6735), and several other services cited in <I>MSJ</I>. <P>
A complete running version of FreePath is also available electronically in binary, along with the source for the critical subroutines shown in these listings. The package is being distributed as shareware, and registered users will get the complete source to FreePath and an online Help file. <P>
Finnegan's <I>ProcHook</I> article discusses a very important limitation of <I>ProcHook</I> when it interacts with <I>WinExec</I>: Because <I>WinExec</I> does not get control back until after the WM_CREATE message, it is possible to get into unrecoverable situations if you attempt to <I>ProcHook</I> while in <I>WinExec</I>. This can be fixed by using <I>PostMessage</I> to trigger the hooking request, as my application does. If your handlers are in your main executable, it is critical that the code be compiled with the /Gw switch so that the call via the instance thunk will set DS properly. <P>
<h3><a name="02fb_0110">Acknowledgments <a name="02fb_0110"></h3><P>
I particularly want to thank James Finnegan, the author of <I>ProcHook</I>, without whose work this would not have been possible, and both the author and <I>Microsoft Systems Journal</I> for permission to distribute the <I>ProcHook</I> DLL with FreePath. I would also like to thank Matt Pietrek for answers and observations that helped me get this up quickly, and the many correspondents on CompuServe's MSLANG and MSMFC forums, especially the Microsoft engineers who have been helping me learn the MFC library.<P>
<h4><a name="02fb_0111"><B>Table 1:</B> The PROCHOOK.DLL interface.<a name="02fb_0111"></h4><P>
<pre><I>NPHOOKCHILD SetProcAddress( FARPROC OriginalFunc, FARPROC NewFunc, BOOL</I>
  exclusive)
  Sets up a hook to the function specified in <I>OriginalFunc</I>by redirecting 
  the entry point to the function specified by <I>NewFunc</I>. The pointer
  specified by <I>NewFunc</I> must either be in a DLL, or it must be an instance
  thunk returned by <I>MakeProcInstance</I>. Smart callbacks will not work! The
  exclusive flag specifies whether this hook will be exclusive to the
  function. It returns a near pointer to an NPHOOKCHILD if successful,
  or NULL if not.

<I>BOOL SetProcRelease(NPHOOKCHILD hookptr)</I>
  Permanently removes the hook specified by <I>hookptr</I>. Returns FALSE if  
  successful, TRUE if not.

<I>BOOL ProcHook(NPHOOKCHILD hookptr)</I>
  Rehooks the function specified by <I>hookptr</I>. The function should have been  
  previously unhooked by <I>ProcUnhook</I>. It returns FALSE if successful, TRUE 
  if not.

<I>BOOL ProcUnhook(NPHOOKCHILD hookptr)</I>
  Temporarily unhooks the function specified by <I>hookptr</I>. Should be matched
  by a subsequent call to <I>ProcHook</I>. It returns FALSE if successful, TRUE 
  if not.</pre><P>
<a href="19940303.htm">Figure 1</A>  Registration database editor.<P>
<a href="19940304.htm">Figure 2</A>  FreePath control panel.<P>
<a href="19940305.htm">Figure 3</A>  Alleged component relationships.<P>
<a href="19940306.htm">Figure 4</A>  Actual component relationships.<P>
<h4><a name="02fb_0112"><B>Example 1:</B> Two _fmemcpy calls. <a name="02fb_0112"></h4><P>
<pre>// Change the first 5 bytes to JMP 1234:5678 (EA 78 56 34 12)
_fmemcpy(lpJmpPtr++,&amp;wJmp,1);
_fmemcpy(lpJmpPtr, &amp;npHookChild-&gt;lpfnNewFunc,4);</pre><P>
<P>
<h4><a name="02fb_0113">Listing One<a name="02fb_0113"></h4><pre>

#define KEY_APPNAME &quot;FreePath&quot;
#define KEY_ACTIVE &quot;Active&quot;

BOOL CPromptDlg::GetMappedFile(LPCSTR filename, LPSTR newfile, int 
newfile_len)
    {
     static char key[256];  // Dont eat stack, make this static
     HKEY subkey;
     
     lstrcpy(key, KEY_APPNAME);
     lstrcat(key, &quot;\\&quot;);
     lstrcat(key, KEY_ACTIVE);

     // At this point we have formed
     // FreePath\KEY_ACTIVE

     LONG retval = RegOpenKey(HKEY_CLASSES_ROOT, key, &amp;subkey);

     if (retval != ERROR_SUCCESS)
    { /* missing key KEY_ACTIVE */
     RegCloseKey(subkey);
     return FALSE;
    } /* missing key KEY_ACTIVE */
     else
    { /* has key KEY_ACTIVE */
     LONG len = newfile_len;
     // Ask for the value of
     //     FreePath\path\foo.dll
     retval = RegQueryValue(subkey, filename, (LPSTR)newfile, &amp;len);
     if(retval != ERROR_SUCCESS)
        { /* failed */
         RegCloseKey(subkey);
         return FALSE;
        } /* failed */

     // We have found the mapped path
     RegCloseKey(subkey);
     return TRUE;
    } /* has key KEY_ACTIVE */
     
    }




</pre>
<h4><a name="02fb_0114">Listing Two<a name="02fb_0114"></h4><pre>

typedef struct {
    char * name;          // Printable name
    FARPROC proc;         // &quot;Real&quot; proc address
    BOOL enable;          // do we want this hook set?
    FARPROC handler;      // Free_ handler for this proc
    int id;               // control ID that is associated with this entry
    FARPROC callback;     // MakeProcInstance(handler)
    BOOL set;             // Hook has been set
    NPHOOKCHILD hook;     // ProcHook magic cookie
    BOOL active;          // We are active
    BOOL settable;        // we can set this hook
           } hook_entry;
//--------------------------------
// p_LoadLibrary
//--------------------------------
hook_entry p_LoadLibrary =
{&quot;LoadLibrary&quot;,         // Name
 (FARPROC) LoadLibrary,     // Address
 FALSE,             // enable
 (FARPROC)Free_LoadLibrary, // local callback
 IDC_LOADLIBRARY,       // checkbox 
 NULL,              // MakeProcInstance pointer
 FALSE,             // set
 NULL,              // hook
 FALSE,             // active
 TRUE               // settable
}; 
//--------------------------------
// p_LoadModule
//--------------------------------
hook_entry p_LoadModule = 
{&quot;LoadModule&quot;,          // Name
 (FARPROC) LoadModule,      // address
 FALSE,             // enable
 (FARPROC)Free_LoadModule,  // local callback
 IDC_LOADMODULE,        // checkbox
 NULL,              // MakeProcInstance pointer
 FALSE,             // set
 NULL,              // hook
 FALSE,             // active
 TRUE               // settable
};
//--------------------------------
// p_WinExec
//--------------------------------
hook_entry p_WinExec =
{&quot;WinExec&quot;,         // Name
 (FARPROC) WinExec,     // address
 FALSE,             // enable
 (FARPROC)Free_WinExec,     // local callback
 IDC_WINEXEC,           // checkbox
 NULL,              // MakeProcInstance pointer
 FALSE,             // set
 NULL,              // hook
 FALSE,             // active
 TRUE               // settable
};
//--------------------------------
// p_Pong
//--------------------------------
hook_entry p_Pong =
{&quot;Pong&quot;,            // Name
 (FARPROC) 0,           // address
 FALSE,             // enable
 (FARPROC)Free_Pong,        // local callback
 0,             // checkbox (none corresponds to this)
 NULL,              // MakeProcInstance pointer
 FALSE,             // set
 NULL,              // hook
 FALSE,             // active
 FALSE              // settable
};
//--------------------------------
// p_SetErrorMode
//--------------------------------
hook_entry p_SetErrorMode =
{&quot;SetErrorMode&quot;,        // Name
 (FARPROC) SetErrorMode,    // address
 FALSE,             // enable
 (FARPROC)Free_SetErrorMode,    // local callback
 0,             // checkbox (none corresponds to this)
 NULL,              // MakeProcInstance pointer
 FALSE,             // set
 NULL,              // hook
 FALSE,             // active
 FALSE              // settable
};



</pre>
<h4><a name="02fb_0115">Listing Three<a name="02fb_0115"></h4><pre>

hook_entry * hook_table[] = {
           &amp;p_LoadLibrary,
       &amp;p_LoadModule,
       &amp;p_WinExec,
       NULL     };

void CPromptDlg::InitProcTable()
    {
     int i;

     for(i=0; hook_table[i] != NULL; i++)
        { /* initialize it */
    hook_table[i]-&gt;callback = MakeProcInstance(hook_table[i]-&gt;handler,
                    AfxGetInstanceHandle());
    hook_table[i]-&gt;hook = SetProcAddress((FARPROC)hook_table[i]-&gt;proc,
                         hook_table[i]-&gt;callback,
                         FALSE);
    if(hook_table[i]-&gt;hook != NULL)
       ProcUnhook(hook_table[i]-&gt;hook); // unhook immediately

    hook_table[i]-&gt;set = FALSE;

    // If the hook could not be set, do not show it as a possibility
    // for being hooked (This used to be EnableWindow but the 
    // difference is too subtle to notice, so I just make it go away)

    if(hook_table[i]-&gt;id != 0)
       GetDlgItem(hook_table[i]-&gt;id)-&gt;ShowWindow(
                        (hook_table[i]-&gt;hook != NULL 
                            ? SW_SHOW 
                            : SW_HIDE));
    } /* initialize it */
    }

#define UWM_INITIALIZE (WM_USER+1)

BOOL CPromptDlg::OnInitDialog()
{
    // ...
    PostMessage(UWM_INITIALIZE, 0, 0L);
    // ...
}

BEGIN_MESSAGE_MAP(CPromptDlg, CDialog)
    ...
    ON_MESSAGE(UWM_INITIALIZE, OnUserInitialize)
    ON_MESSAGE(UWM_UPDATE, OnUserUpdate)
    ...
END_MESSAGE_MAP()

LONG CPromptDlg::OnUserInitialize(WPARAM wParam, LPARAM lParam)
    {
     InitProcTable();
     SetHooks();
     EnableHooks();
     return 0;
    }


</pre>
<h4><a name="02fb_0116">Listing Four<a name="02fb_0116"></h4><pre>

void CPromptDlg::SetHooks()
    {
     p_LoadLibrary.active = p_LoadLibrary.enable = m_LoadLibrary;
     p_LoadLibrary.settable = TRUE;

     p_LoadModule.active  = p_LoadModule.enable  = m_LoadModule;
     p_LoadModule.settable = TRUE;

     p_WinExec.active     = p_WinExec.enable     = m_WinExec;
     p_WinExec.settable = TRUE;
    }


void CPromptDlg::EnableHooks()
    {
     int i;
     for(i=0; hook_table[i] != NULL; i++)
    { /* check it */
     if(!m_Disabled &amp;&amp; !hook_table[i]-&gt;set)
        { /* set it */
         if(hook_table[i]-&gt;hook != NULL &amp;&amp; hook_table[i]-&gt;settable)
            { /* settable */
         ProcHook(hook_table[i]-&gt;hook);
         hook_table[i]-&gt;set = TRUE;
        } /* settable */
        } /* set it */
     else
     if(m_Disabled &amp;&amp; hook_table[i]-&gt;set)
        { /* release it */
         if(hook_table[i]-&gt;hook != NULL)
            { /* unsettable */
         ProcUnhook(hook_table[i]-&gt;hook);
         hook_table[i]-&gt;set = FALSE;
        } /* unsettable */
        } /* release it */
    } /* check it */
    }


</pre>
<h4><a name="02fb_0117">Listing Five<a name="02fb_0117"></h4><pre>

HINSTANCE __export WINAPI Free_WinExec(LPCSTR filename, UINT cmdshow)
    {
     HINSTANCE inst;
     BOOL LoadModule_active = p_LoadModule.active;

     // Unhook the procedure

     ProcUnhook(p_WinExec.hook);
     p_WinExec.set = FALSE;

     /*
    Since WinExec eventually calls LoadModule, we want LoadModule to
    do the mapping.  If LoadModule is not active, we activate it so it
    will do the remapping.  Note that this is independent of the
    LoadModule check box, which says that *all* LoadModule calls
    will be mapped.
     */

     p_LoadModule.active = p_WinExec.active;

     // Now call the real, underlying version

     inst = (HINSTANCE)WinExec(filename, cmdshow);

     p_LoadModule.active = LoadModule_active;

     // Rehook WinExec so we get called again

     ProcHook(p_WinExec.hook);
     p_WinExec.set = TRUE;

     return inst;  // return failure code
    }


</pre>
<h4><a name="02fb_0118">Listing Six<a name="02fb_0118"></h4><pre>

HINSTANCE __export WINAPI Free_LoadLibrary(LPCSTR filename)
    {
     HINSTANCE inst;  // return instance

     // Unhook the procedure and mark it as unhooked

     ProcUnhook(p_LoadLibrary.hook);
     p_LoadLibrary.set = FALSE;

     /*
    Note that LoadLibrary calls LoadModule, which may in turn call
    LoadLibrary.  If LoadLibrary is active we want name mapping, so
    we have to make sure LoadModule is hooked.  It might be unhooked
    because it unhooked itself to call the *real* LoadModule which has
    now called LoadLibrary.
     */

     BOOL need_unhook_LoadModule = FALSE;
     BOOL prev_active = p_LoadModule.active;

     if(p_LoadLibrary.active)
        { /* we want LoadLibrary calls */
     if(!p_LoadModule.set)
        { /* enable LoadModule hook */
         ProcHook(p_LoadModule.hook);
         need_unhook_LoadModule = TRUE;
         // mark it has both hooked and active
         p_LoadModule.set = TRUE;
         p_LoadModule.active = TRUE;
        } /* enable LoadModule hook */
    } /* we want LoadLibrary calls */
     else
        { /* we don't want LoadLibrary calls */
     if(p_LoadModule.set)
        { /* disable LoadModule hook */
         p_LoadModule.active = FALSE;
        } /* disable LoadModule hook */
    } /* we don't want LoadLibrary calls */

     // Now call the real, underlying version

     inst = LoadLibrary(filename);

     // If we had hooked LoadModule to do the mapping, unhook it how
     if(need_unhook_LoadModule)
        { /* was set */
     ProcUnhook(p_LoadModule.hook);
     // mark it as unhooked and restore its active flag
     p_LoadModule.set = FALSE;
    } /* was set */

     // Restore the LoadModule.active flag to its incoming setting
     p_LoadModule.active = prev_active;

     // Reset the LoadLibrary hook 
     ProcHook(p_LoadLibrary.hook);
     p_LoadLibrary.set = TRUE;

     return inst;  // return failure code
    }


</pre>
<h4><a name="02fb_0119">Listing Seven<a name="02fb_0119"></h4><pre>

HINSTANCE Call_LoadModule(LPCSTR filename, LPVOID parms)
    {
     HINSTANCE inst;

     // Unhook the procedure

     if(p_LoadModule.set)
        { /* unset it */
     ProcUnhook(p_LoadModule.hook);
     p_LoadModule.set = FALSE;
    } /* unset it */

     // Now hook in the Pong hook (we &quot;pong&quot; the hooks between the ponghook
     // and the LoadModule hook)

     if(!p_Pong.set &amp;&amp; p_Pong.hook != NULL)
        { /* set it */
     PongHook();
     p_Pong.set = TRUE;
    } /* set it */
     inst = LoadModule(filename, parms);

     return inst;
    }

#define MAX_LOADMODULE_DEPTH 25
static UINT Prevailing_ErrorMode[MAX_LOADMODULE_DEPTH];
static int LoadModule_Depth = 0;

HINSTANCE __export WINAPI Free_LoadModule(LPCSTR filename, LPVOID parms)
    {
     static int Failure_Depth = 0;
     static char filename_stack[MAX_LOADMODULE_DEPTH * _MAX_PATH];
     static char * filename_ptr = filename_stack;

     HINSTANCE inst;
     char * new_filename = filename_ptr;

     // We first set it up so that if the &quot;direct&quot; load fails, we don't
     // get an error message that would confuse and annoy the user.
     // If a box was supposed to pop up, and we can't redirect the
     // load, we will force it to pop up before we leave this procedure

     LoadModule_Depth++;

     UINT Old_ErrorMode = Call_SetErrorMode(SEM_NOOPENFILEERRORBOX);

     // If this is the first call to LoadModule, either from the user
     // or via WinExec or LoadLibrary, save the current error mode
     // so we can issue error messages correctly

     if(LoadModule_Depth &lt; MAX_LOADMODULE_DEPTH)
    Prevailing_ErrorMode[LoadModule_Depth] = 
        Prevailing_ErrorMode[LoadModule_Depth - 1];

     // Prepare to maintain the error mode by SetErrorMode
     BOOL must_unhook_SetErrorMode = !p_SetErrorMode.set;
     if(!p_SetErrorMode.set &amp;&amp; p_SetErrorMode.hook != NULL)
        { /* set it */
     ProcHook(p_SetErrorMode.hook);
     p_SetErrorMode.set = TRUE;
    } /* set it */

     /*
    Here's a tricky bit.  

    LoadModule can cause LoadLibrary to be called, which in turn calls
    LoadModule.  But loading a DLL could cause loading of another DLL
    and we want to keep the chain going all the way.  
     */

     // If the LoadLibrary mapping option is set, we make sure that
     // LoadLibrary is hooked, and also that it is active
     // This prepares us for half of the recursion

     BOOL must_unhook_LoadLibrary = FALSE;

     if(p_LoadLibrary.enable &amp;&amp; !p_LoadLibrary.set)
        { /* set it */
     ProcHook(p_LoadLibrary.hook);
     p_LoadLibrary.set = TRUE;
     must_unhook_LoadLibrary = TRUE;
    } /* set it */

     // Now call the *real* LoadModule, which may yet call LoadLibrary
     // or it may call LoadModule recursively.

     Failure_Depth = 0;  // do we fail immediately or at lower level?
     inst = Call_LoadModule(filename, parms);

     if(inst &lt; HINSTANCE_ERROR)
        { /* failed, do our special retry */
     // If we are not &quot;active&quot;, we just return the failure code
     if(!p_LoadModule.active)
        { /* not active */
         goto bad_exit;
        } /* not active */

     // If we failed at a lower level, don't retry the operation
     if(Failure_Depth &gt; 0)
        { /* already issued message */
         goto bad_exit;
        } /* already issued message */

     if(!RelativePath(filename))
        { /* not relative path */
         // It wasn't a relative path, we can't do anything
         // so just undo what is done and return to the caller with
         // the error code
         goto bad_exit;
        } /* not relative path */
     
     // Try to find a mapping for the file

     if(!GetMappedFile(filename, new_filename, _MAX_PATH))
        { /* no mapping found */
         // We don't know why it failed, but we can't recover
         // Log the &quot;NoMap&quot; entry for this one
         RecordFailure(filename, KEY_NOMAP, NULL, -1);
         goto bad_exit;
        } /* no mapping found */

     // We have now consumed some of our &quot;filename stack&quot;.  Update
     // the filename stack pointer to point just beyond this:

     filename_ptr += lstrlen(new_filename) + 1;
     
     // We found a mapping for the top-level file.  It almost certainly
     // means that it was not on the path, so let's try to load it from
     // the mapped name

     // First, we have to unhook LoadModule which has been rehooked
     // by the 'pong' hook, then rehook the ponghook:

     
     HINSTANCE new_inst = Call_LoadModule(new_filename, parms);

     if(new_inst &lt; HINSTANCE_ERROR)
        { /* failed secondary load */
         // This may have been due to a bad mapping, or a missing DLL
         // at a lower level.  Assume it is a bad mapping (most likely)
         C_var_BadMap++;
         NotifyUpdate();
         RecordFailure(filename, KEY_BADMAP, new_filename, (int)new_inst);
         goto bad_exit;
        } /* failed secondary load */

     // It loaded!  Congratulate ourselves and return the instance handle
     inst = new_inst;

     // Indicate that our remapped load succeeded
     C_var_Remaps++;
     NotifyUpdate();
    } /* failed, do our special retry */
     else
        { /* direct load succeeded */
     // Well!  It worked the first time with the name we were given,
     // either because it was already in the PATH or it was an absolute
     // name.  Makes no matter, record the success.
     C_var_Direct++;
     NotifyUpdate();
    } /* direct load succeeded */
exit:
     // Restore the filename stack pointer to its value when we came in
     filename_ptr = new_filename;

     if(p_Pong.set)
        { /* unhook Pong */
     PongUnhook();
     p_Pong.set = FALSE;
    } /* unhook Pong */

     // If we had hooked the LoadLibrary call, unhook it so it is back in
     // its original state.

     if(must_unhook_LoadLibrary &amp;&amp; p_LoadLibrary.set)
        { /* unhook it */
     ProcUnhook(p_LoadLibrary.hook);
     p_LoadLibrary.set = FALSE;
    } /* unhook it */

     // Unhook SetErrorMode if we hooked it at this level
     if(must_unhook_SetErrorMode &amp;&amp; p_SetErrorMode.set)
        { /* unhook it */
     ProcUnhook(p_SetErrorMode.hook);
     p_SetErrorMode.set = FALSE;
    } /* unhook it */

     // Hook LoadModule back into the chain
     if(!p_LoadModule.set)
        { /* re-set it */
     ProcHook(p_LoadModule.hook);
     p_LoadModule.set = TRUE;
    } /* re-set it */

     // Reset the error mode (if we haven't already)
     Call_SetErrorMode(Old_ErrorMode);

     // Decrement the depth count
     LoadModule_Depth--;

     // return handle or failure code
     return inst;

bad_exit:
     // This may look strange, but what we want to do is force the
     // dialog box to come up if it would have on a straight call

     
     // First, we set the depth based on the current LoadModule depth,
     // including a depth limit
     int depth = (LoadModule_Depth &lt; MAX_LOADMODULE_DEPTH 
                        ? LoadModule_Depth
                    : MAX_LOADMODULE_DEPTH - 1);
     
     Call_SetErrorMode(Prevailing_ErrorMode[depth]);
     if(Prevailing_ErrorMode[depth] != SEM_NOOPENFILEERRORBOX)
        { /* force error message */
     HINSTANCE err;
     err = Call_LoadModule(filename, parms);
    } /* force error message */

     // Now record the failure depth so we can tell where we failed
     Failure_Depth = LoadModule_Depth;
     goto exit;
    }


</pre>
<h4><a name="02fb_011a">Listing Eight<a name="02fb_011a"></h4><pre>

BOOL RelativePath(LPCSTR filename)
    {
     static char nearfile[_MAX_PATH];
     static char drive[_MAX_DRIVE];
     static char path[_MAX_DIR];
     static char file[_MAX_FNAME];
     static char ext[_MAX_EXT];

     if(lstrlen(filename) &gt; _MAX_PATH)
      return FALSE;
     lstrcpy(nearfile, filename);
     _splitpath(nearfile, drive, path, file, ext);
     return !(strlen(drive) &gt; 0 || strlen(path) &gt; 0);
    }


</pre>
<h4><a name="02fb_011b">Listing Nine<a name="02fb_011b"></h4><pre>

IP      instr   disassembly
244:    45  inc bp     
245:    55  push    bp     
246:    8bec    mov bp,sp  
248:    1e  push    ds     
249:    1f  pop ds         &lt;= Pong hook placed here
24a:    687502  push    0275
24d:    8b460a  mov ax, [word ptr bp+0a]
250:    8b4e0c  mov cx, [word ptr bp+0c]
253:    e82f01  call    385


</pre>
<h4><a name="02fb_011c">Listing Ten<a name="02fb_011c"></h4><pre>

=============================================================================
Prolog code
=============================================================================
; void __export WINAPI Free_Pong()
;     {
                    ?Free_Pong@@ZCXXZ:
    *** 000c0c  8c d8           mov ax,ds
    *** 000c0e  90          xchg    ax,ax
    *** 000c0f  45          inc bp
    *** 000c10  55          push    bp
    *** 000c11  8b ec           mov bp,sp
    *** 000c13  1e          push    ds
    *** 000c14  8e d8           mov ds,ax
    *** 000c16  b8 00 00        mov ax,OFFSET L21402
    *** 000c19  9a 00 00 00 00      call    FAR PTR __aFchkstk
    *** 000c1e  56          push    si
    *** 000c1f  57          push    di
=============================================================================
Epilog code
=============================================================================

;      UINT off = OFFSETOF(p_Pong.proc);
    *** 000cc5  a1 02 00        mov 
                                         ax,WORD PTR ?p_Pong@@3Uhook_entry@@A+2
    *** 000cc8  8b 16 04 00         mov 
                                         dx,WORD PTR ?p_Pong@@3Uhook_entry@@A+4
    *** 000ccc  89 46 fa        mov WORD PTR -6[bp],ax
;      __asm {  // In some places in the world, doing this would be a capital
;        // offense.  Void where prohibited by law.
;          mov ax, off
    *** 000ccf  8b 46 fa        mov ax,WORD PTR -6[bp]
;      mov [word ptr BP+2],ax
    *** 000cd2  89 46 02        mov WORD PTR 2[bp],ax
;     }
;     }
    *** 000cd5  e9 00 00        jmp L20315
                    L20315:
    *** 000cd8  5f          pop di
    *** 000cd9  5e          pop si
    *** 000cda  8d 66 fe        lea sp,WORD PTR -2[bp]
    *** 000cdd  1f          pop ds
    *** 000cde  5d          pop bp
    *** 000cdf  4d          dec bp
    *** 000ce0  cb          ret OFFSET 0



</pre>
<h4><a name="02fb_011d">Listing Eleven<a name="02fb_011d"></h4><pre>

static WORD pong_datasel;  // DS: based selector for pong hook
static WORD pong_codesel;  // CS: based selector for pong hook

void WritePong(unsigned char val)
    {
     unsigned char FAR * p;
     p = (unsigned char FAR *)MAKELP(pong_datasel, OFFSETOF(p_Pong.proc));
     *p = val;  // change from JMP to CALL or back
    }

void PongHook()
    {
     ProcHook(p_Pong.hook);
     WritePong(0x9A); // JMP =&gt; CALL
    }

void PongUnhook()
    {
     WritePong(0xEA);  // =&gt; JMP
     ProcUnhook(p_Pong.hook);

    }
void __export WINAPI Free_Pong()
    {
     PongUnhook();
     p_Pong.set = FALSE;

     if(!p_LoadModule.set)
        { /* rehook LoadModule */
     ProcHook(p_LoadModule.hook);
     p_LoadModule.set = TRUE;
    } /* rehook LoadModule */

     // Now reset the return address pointer to point to the place we
     // had set the PongHook
     UINT off = OFFSETOF(p_Pong.proc);
     __asm {  // In some places in the world, doing this would be a capital
         // offense.  Void where prohibited by law.
           mov ax, off
       mov [word ptr BP+2],ax
      }
    }
// The following lines are added to CPromptDlg::InitProcTable:

p_Pong.proc = (FARPROC) ((char _huge *)p_LoadModule.proc + pong_offset);

pong_codesel = SELECTOROF((p_Pong.proc));
pong_datasel = AllocCStoDSAlias(pong_codesel);

// The following line is added before the program terminates

FreeSelector(pong_datasel);


</pre>
<h4><a name="02fb_011e">Listing Twelve<a name="02fb_011e"></h4><pre>

UINT Call_SetErrorMode(UINT mode)
    {
     UINT oldmode;
     BOOL set = p_SetErrorMode.set;

     if(p_SetErrorMode.set &amp;&amp; p_SetErrorMode.hook != NULL)
        { /* unset it */
     ProcUnhook(p_SetErrorMode.hook);
     p_SetErrorMode.set = FALSE;
    } /* unset it */
     oldmode = SetErrorMode(mode);
     if(set &amp;&amp; p_SetErrorMode.hook != NULL)
        { /* reset it */
     ProcHook(p_SetErrorMode.hook);
     p_SetErrorMode.set = TRUE;
    } /* reset it */
     return oldmode;
     
    }

UINT __export WINAPI Free_SetErrorMode(UINT mode)
    {
     // Set the prevailing mode to be the one we want
     int depth = (LoadModule_Depth &lt; MAX_LOADMODULE_DEPTH 
                        ? LoadModule_Depth
                    : MAX_LOADMODULE_DEPTH - 1);
     Prevailing_ErrorMode[depth] = mode;

     int oldmode;
     oldmode = Call_SetErrorMode(mode);

     return oldmode;
    }


</pre>
<h4><a name="02fb_011f">Listing Thirteen<a name="02fb_011f"></h4><pre>

static HWND C_var_PostWnd = NULL;
static BOOL C_var_Posted = FALSE;

void NotifyUpdate()
    {
     if(C_var_PostWnd != NULL &amp;&amp; !C_var_Posted)
        { /* post it */
     PostMessage(C_var_PostWnd, UWM_UPDATE, 0, 0L);     
     C_var_Posted = TRUE;
    } /* post it */
    }
LONG CPromptDlg::OnUserUpdate(WPARAM wParam, LPARAM lParam)
    {
     C_var_Posted = FALSE;  // allow more posts to come thru
     if(IsIconic())
    return 0;  // don't update iconic window

     char val[20];

     wsprintf(val, &quot;%ld&quot;, C_var_NoMap);
     c_NoMap.SetWindowText(val);

     // ... other values formatted and displayed here

     return 0;
    }
void CPromptDlg::OnSize(UINT nType, int cx, int cy)
{
 // If we have a minimized window, we don't want to spend any time 
 // updating its performance display, so NULL out the PostWnd used by
 // the callbacks

 if(nType == SIZE_MINIMIZED)
    C_var_PostWnd = NULL;
 else
    C_var_PostWnd = m_hWnd;
 
 if(nType == SIZE_MINIMIZED &amp;&amp; m_Hide)
    { /* hide icon */
     ShowWindow(SW_HIDE);
     return;
    } /* hide icon */

 // Since it was not a minimzation request, suggest that we should update
 // the performance display
 PostMessage(UWM_UPDATE, 0, 0L);

 // Now do usual WM_SIZE processing...
 CDialog::OnSize(nType, cx, cy);
    
}
</pre>
<HR><P>Copyright &copy; 1994, <I>Dr. Dobb's Journal</I></P></BODY></HTML>
