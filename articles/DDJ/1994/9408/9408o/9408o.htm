<HTML>
<META NAME="year" CONTENT="1994">
<HEAD>
<TITLE>AUG94: PROGRAMMER'S BOOKSHELF</TITLE></HEAD>
<BODY BGCOLOR="#ffffff">
<h1>PROGRAMMER'S BOOKSHELF<a name="00b8_003f"></h1><P>
<h2><a name="00b8_003d"><a name="00b8_0000">C++ and the PowerPC</h2><P>
<h3>Al Stevens</h3><P>
<a name="00b8_003e"><a name="00b8_0000">This month's &quot;Programmer's Bookshelf&quot; looks at two books on completely different subjects that have two things in common. First, both provide historical accounts of events that shaped specific niches within the computer industry. Second, the subjects of these books will influence what we programmers do for the next several years. The first book relates the history of C++ from its beginning, up through the near future, when C++, as defined and invented by ANSI/ISO, will be available. The second book is about the PowerPC microprocessor, which could become a dominant software-development platform.<P>
<h3><a name="00b8_0040"><B>The Design and Evolution of C++<a name="00b8_0040"></B></h3><P>
<I>The Design and Evolution of C++</I> is Bjarne Stroustrup's account of the events and people that contributed to the current condition of C++. In widespread use for many years, C++ has grown into a formidable software-development environment that has progressed from a preprocessor that added classes to C to the acknowledged language of choice for a generation of programmers. It is now about 15 years old, sports compilers for virtually every major operating system and environment, and is undergoing formal standardization and augmentation at the able hands of ANSI/ISO committees.<P>
This isn't for everyone. You will understand and appreciate the story much better if you are a C++ programmer. Sometimes the book describes characteristics of the language and then explains the rationale behind their inclusion in the language. Other times, it delves into particular arcane behaviors of C++. You need to understand the nature of C++ and the potential implications of the hidden aspects of the language in order to keep up. A lot of the book uses code to illustrate the point at hand, and a programmer who already reads C++ has an advantage over one who does not.<P>
This is an important book, an important addition to the culture, not only for its historical perspective, but for the insight that it provides into the process of language definition, development, and specification.<P>
You learn a lot about C++ programming, even though that's not Stroustrup's primary purpose. In explaining why he accepted or rejected proposed features, Stroustrup offers examples of alternatives that reveal better ways to use C++--ways made possible by the underlying behavior of the language, ways that programmers discovered rather than designed. He often expresses his own surprise at their discovery, which adds insight to the complexities of the language: Even its creator has to discover (or be told about) an idiom that applies the language's underlying behavior to the expression of a particular solution.<P>
<I>The Design and Evolution of C++</I> is a study in language structure and design, revealing Stroustrup's resolute philosophy about how a programming language should work and what compromises are necessary to assure its success. Most criticisms of C++ fall into two categories--the legacy of language constructs that descended from C, and its static (compile-time) type checking system, which purists view as being less than object-oriented. Stroustrup deals with both of these. First, he could have built a better language instead of a better C. He could have assigned less importance to compatibility with C. &quot;Within C++, there is a much smaller and cleaner language struggling to get out,&quot; which he says, &quot;would ... have been an unimportant cult language.&quot; Second, he is committed to the concept of static (as opposed to dynamic) type checking as being inherently safer and essential to retain the efficiency of C. Without that guarantee, programmers used to C's efficiency will not switch to a new language, no matter what promise it holds.<P>
The book is Stroustrup's personal-historical perspective of the growth of C++. He approaches it chronologically to provide a sense of when different features were realized. Then he addresses individual programming issues and the features that support them without regard to their place in time. He chronicles the successes, the failures, and the forces brought to bear on his decisions about the growth of C++.<P>
We programmers sometimes believe that programming languages come from one of two places: large paradigm-polluting bureaucracies belching out behemoths such as Cobol and Ada, or independent free spirits, in one bright light of inspiration, sit down and cobble a terse, elegant, language like C and C++ to endure for generations. This book tells a different tale, and you learn of the contributions of a number of collaborators both within AT&amp;T and later on the Committee. Stroustrup gives credit where it is due and names. Whether or not you like a feature or bemoan the absence of another, you can usually find out whose idea it was by reading this book. C++ is the product of the minds of many participants over a long period of time, with Stroustrup as the focal point.<P>
The book is at times a study in group dynamics. Not bound by the limits that the ANSI X3J11 Committee imposed upon themselves--to codify existing C practice--X3J16 is inventing a lot of new language, and the exercise makes for some dynamic interplay. Stroustrup chairs the Extensions group and tries to manage the spate of new feature requests that pour in from users. He openly discusses his attitudes about features and tells about the arguments and forces of logic that bear him out in some cases and convince him to change his mind in others.<P>
C++ is what is it is because of several criteria that the Extensions group applies before accepting a feature. Those criteria reflect ones that Stroustrup applied as the language grew before the Committee was formed. First, each feature is scrutinized for its need. Is it a provincial demand, or will the programming community benefit from it? Passing that test, the feature is implemented and used before being formalized in a release. Its acceptability is based on that experience. If the feature cannot be easily implemented, it is suspect. If it cannot be explained to a C++ programmer in short order, it is suspect. If there are reasonable alternatives existing in the language, the feature is suspect. If it breaks a significant amount of existing code, it is almost sure to be rejected. If it involves a new keyword, it has two strikes going in. (Stroustrup has no apparent strong bias against new keywords--he's introduced plenty of them himself--but he does want to avoid the inevitable outcry of protest. Sometimes, he says, it's easier to find an alternative notation than to fight the new keyword fight.) You will learn how these criteria were applied to requested features that were accepted or rejected based on the outcome. It is as interesting to learn what didn't make it and why as to learn what did. If your favorite feature isn't there, chances are it's been considered and rejected. Now you will know why.<P>
Finally, this book prepares you for the inventions that are coming from the committee. We are properly concerned about new language features that fall out of the deliberations of large numbers of people with shared and diverse interests. We worry about issues being resolved with compromise based on the strength of the debaters rather than technical merit. This book discusses them all and relates the content and context of those deliberations and, for the most part, puts our fears to rest. What's coming? Templates are changing significantly over their first definition in the ARM and from existing and different implementations. Run time type identification has been approved and is already implemented in some compilers. Stroustrup explains his theories about how this feature should and should not be used. There are a number of new cast conventions intended to obviate C's inherently unsafe typecast mechanism. The new namespace feature solves a long standing problem with name collisions among user code, standard libraries, and third party libraries. The namespace mechanism reflects differing opinions about how names ought to be managed in a programming environment. The results are several notations from which you can choose depending on where you stand on the issue. They all work, and you can use the ones you like. The book explains the situation and how it came to be.<P>
<I>The Design and Evolution of C++</I> expands your understanding of C++ by explaining how and why it evolved. You will be more tolerant of some of its vagaries once you understand the alternatives. You will embrace new features after you've learned their motivations. You will anxiously wait for your favorite compiler vendor to release versions that implement the new features so that you can try them out. If you write C++ code, you need this book.<P>
<h3><a name="00b8_0041"><I>Inside the PowerPC Revolution</I><a name="00b8_0041"></h3><P>
<I>Inside the PowerPC Revolution,</I> by former <I>DDJ</I> columnist Jeff Duntemann and Ron Pronk, is many things. First and foremost, it is a wall-to-wall treatment of a totally new computer architecture, designed by an alliance formed between Apple, IBM, and Motorola. Beyond that, the book is a foundation technical overview of traditional and future computer architectures, a history of processor evolution and the development of RISC technology in particular, an analysis of corporate dynamics when foes form friendships, and an abundance of projections, plans, rumors, and speculation.<P>
The book reveals a PowerPC bias. The authors don't come right out and say so, but you can tell that if they aren't altogether convinced that the PowerPC will rule, they at least hope that it will.<P>
In 1991, Apple, IBM, and Motorola formed an alliance to define a standard for desktop workstations and computers based on a family of RISC processors. Motorola and IBM would cooperate with complementing chip design and fabrication technologies. IBM and Apple would produce desktop systems that complied with the standard specification and that would run PC and Mac systems software and applications. Motorola and Apple would coordinate the issues of compatibility between the Mac's 680x0 and the PowerPC. At the time of the announcement, industry interest centered on the unlikely nature of the alliance rather than its goals. In March of this year, the lid came off. Apple introduced several models of the Power Mac based on the new architecture with processor chips manufactured by IBM.<P>
The implications of the alliance and the new architecture were not clear to the marketplace because the media did not cover it with much enthusiasm. For now, many computer buyers and software developers are uneducated about what's coming. This book fills that void.<P>
The most enduring part of <I>Inside the PowerPC Revolution</I> is its historical account of the evolution of desktop computers in the first two chapters. The authors repeat information that has been widely reported, but they are brief, do not belabor the subject, and lay the foundation for what follows. No matter what else happens, Chapters 1 and 2 will always be relevant. Chapter 3 compares RISC and CISC. It starts out by asserting that <I>&quot;There is no such thing as RISC&quot;</I> [their italics]. The reason behind this position is that so-called RISC chips have as many or more instructions in their repertoire as so-called CISC chips. The chapter goes on to say that the real differences are: the RISC architecture minimizes memory access by working mostly in registers; instructions are of uniform length to eliminate complex instruction fetch operations; and RISC manufacturers discard rather than sell the processors that don't run fast. Chapter 3 is also a tutorial on caching, pipelining, superscalar execution, and parallelism, which are techniques that processors use to run programs faster, techniques that do not usually involve cognizant cooperation from the programmer.<P>
Past Chapter 3, the book gets into the dynamics, politics, and market implications of the alliance. This part of the book has an almost tabloid attraction. We like to read about unlikely alliances, declared wars on competing alliances (like Intel/Microsoft), deal-making, and the like. But there are benefits to this insight. To decide to purchase and develop software for a different architecture, you need as much information as you can get about its chances to succeed. Contributing to these chances are the strengths of the agreements, the degree of financial commitment each party makes to them, and the potential for hidden agendas that could compromise their future.<P>
Chapter 9 describes the Power Macs that you can buy today from Apple. Chapters 10 discusses IBM's yet-to-be announced PowerPCs. These chapters address how the PowerPC emulates Mac, DOS, and Windows to run applications from each of these platforms. Chapter 10 discusses IBM's <I>human-centered computing</I> paradigm, which, the authors' enthusiasm notwithstanding, reminds me of those exciting multimedia demonstrations of a few years back--birds flying, music playing, spreadsheets talking, databases listening, and the like. Impressive, but disappointing in view of what has actually materialized in the way of useful applications.<P>
Chapter 10 also talks about IBM's operating-system crisis. For users to buy the machine and developers to write software, the computer needs a popular PC operating system that will run Windows 3.x applications--and IBM doesn't have one. The operative work is &quot;popular,&quot; which rules out OS/2. Apparently IBM's first offering will run their AIX UNIX-lookalike and NT, which, if anything, are both less popular than OS/2. Later comes Workplace/OS, which is somehow supposed to become popular and fix everything.<P>
Chapter 11 gets into emulation and compatibility. Although the PowerPC is supposed to be a standard architecture for desktop computers, IBM's operating systems will not run on the Power Mac, and System 7 will run only on the Power Mac. The situation with respect to applications, operating systems, and hardware, and what runs on what is complex enough that the book uses two tables to chart it. So much for the promise of an open architecture.<P>
Operating systems--specifically so-called <I>object-oriented</I> operating systems--are the subject of Chapter 12. Apparently users are going to have to make a paradigm shift the same way we programmers did. That will be interesting to watch. <P>
Interviews with major players in the PowerPC project are scattered throughout the book. These interviews provide insight into plans and motivations, although they sometimes seem to be vehicles to entrench the interviewee's agenda. The interviews do convey information, but because of the time-dependent perishability of that information, the interviews seem to be more suitable for magazines than a book.<P>
I have two criticisms of <I>Inside the PowerPC Revolution</I>, but they are not big ones. First, the book repeats itself too often. I was treated to a detailed explanation of clean-room BIOS cloning twice. I learned at least three times that pundits without vision predicted failure first for the PC and then for Windows because of the lack of applications. I lost count of the times that I found out that without a 486DX, you need a separate numerical coprocessor to do floating point math in hardware. These kinds of repetitions are typical when more than one author writes a book and no one takes charge and pulls it together. At least this book does not contradict itself, and that is to its credit.<P>
My second criticism involves the chapter and paragraph headings in the book. Many of them are too cute and cloying. In their attempt to be chummy and funny (which fails), the authors do not let the headings tell you what the chapters and paragraphs teach. As a result, the table of contents is about half as effective as it ought to be.<P>
I was glad to get this book to review because the PowerPC is one of those things in the industry that kind of snuck up on me. Like most programmers, I get mired down in the current project and come up for air and revelation only every now and then. I did, and everyone was oohing and ahhing over something new called the PowerPC. I wanted information and found hype. Since then, having read <I>Inside the PowerPC Revolution</I>, I feel like I know as much as a potential user and programmer can know about the PowerPC without joining the alliance and making a financial commitment. Because of the infancy of the technology, the uncertainty of its direction, and the vagaries of a fickle marketplace, this book might have a short life. Its necessary dependence on speculation could guarantee its obscurity fairly soon. Nonetheless, the book represents the orderly presentation of a significant body of research on a relevant and current topic, and is the only work I've seen on the PowerPC that can be called comprehensive. Soon there will be a glut of PowerPC books, good and bad, just as there are C++ books, Internet books, Windows books, and John Grishom mysteries. Until then, <I>Inside the PowerPC Revolution</I> is the only game in town, and it will be hard to beat.<P>
<h4><B><I>The Design and Evolution of C++</I></B></h4><P>
<h4><I>Bjarne Stroustrup</I></h4><P>
<h4>Addison-Wesley, 1994, 461 pp.</h4><P>
<h4>$26.95</h4><P>
<h4>ISBN 0-201-54330-3</h4><P>
<h4><B><I>Inside the PowerPC Revolution</I></B></h4><P>
<h4><I>Jeff Duntemann and Ron Pronk</I></h4><P>
<h4>Coriolis Group Books, 1994, 395 pp.</h4><P>
<h4>$24.95</h4><P>
<h4>ISBN 1-883577-04-7</h4><P>
<P>
<HR><P>Copyright &copy; 1994, <I>Dr. Dobb's Journal</I></P></BODY></HTML>
