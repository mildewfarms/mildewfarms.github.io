<html>
<head>
<title>The Agile End Game</title>
<link rel="Stylesheet" rev="Stylesheet" href="../../../../forms/Layout.css" type="text/css">
<link rel="Stylesheet" rev="Stylesheet" href="../../../../forms/FontStyles.css" type="text/css">
<link rel="Stylesheet" rev="Stylesheet" href="../../../../forms/newarticle.css" type="text/css">
<script src="../../../../forms/popwindow.js"></script>
</head>

<body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000">
<!--Copyright &#169; Dr. Dobb's Journal-->
<p><i>Dr. Dobb's Journal</i> May 2007</p>

<h1>The Agile End Game</h1>
<h2>Catch and release in software development</h2>


<h3>By Scott Ambler</h3>


<I>Scott is a DDJ Senior Contributing Editor and author of numerous IT books. He can be contacted at www.ambysoft.com/scottAmbler.html.</I>

<hr>




<p>And now for something completely different. Agile software developers love to talk about the construction aspects of software development, but rarely do we discuss the other, "uncool" issues faced by IT departments. These include project issues such as initiation and release, and enterprise issues such as governance, enterprise architecture, portfolio management, and operations. It is of little use being really good at building software if you can't manage projects effectively or run them once they are in production. This month, I discuss the release-related activities that occur at the end of a development project.</p>

<p>Figure 1 depicts a generic lifecycle for agile software projects. As you can see, there are several different types of iterations, or as Gary Evans would say, "seasons of a project." One important aspect of the lifecycle is the release iteration, also referred to as the transition phase in the Open Unified Process (OpenUP), the release sprint in Scrum, or the end game in the Eclipse Way. The goal of the release iteration(s) is to successfully deploy your system into production. For complex projects, you may require several release iterations (more on this later).</p>

<div>
    
<div class="smallcap">&#91;Click image to view at full size&#93;</div>
<!-- http://i.cmpnet.com/ddj/images/article/2007/07/ -->    
<img class="illowide" src="070401sa01_f1.gif" onclick = "popimage(this,'www.ddj.com - The Agile End Game - Figure 1')">

<div class="caption">
Figure 1: The agile software development lifecycle. 
</div>
</div>

<p>There are several ways to enter the end game of an agile project. Ideally, you do so because it makes sense, which occurs when you've built sufficient functionality for your stakeholders and your defect rate is down to an acceptable level. A common practice on Scrum teams is to create a "burn down chart," which tracks the number of requirements still left on the requirements stack. However, in practice, I've found them to be more effort than they're worth unless they're automatically generated for you by your toolset. Value is in the eye of the beholder, and because stakeholders actively participate on agile projects, it's usually straightforward for them to identify when they've achieved sufficient new functionality since the last release of the system. Your defect rate can easily be calculated by counting the number of defect stories generated by your investigative testing efforts (see my column "Agile Testing Strategies," January 2007).  </p>

<p>There are two other common ways to enter the end game, both of which can be spectacularly bad experiences if you haven't met the previously described criteria. One motivation to release your system in production is simply because you're scheduled to do so, often for contractual or regulatory reasons. I would rather ship a solid product a few months late than ship an inadequate and/or buggy system on time. Another potentially problematic motivation to release your system is because your stakeholders have stopped funding your project and want you to ship what you've got done. Because agile teams produce "production ready" code each iteration, they are more likely than traditional teams to be able to actually deliver something of value in this situation, but it's rarely a pleasant situation to find yourself in.</p>








<h3>Final Testing</h3>

<p>Repeat after me: The release iteration is not a testing phase. The release iteration is not a testing phase. The release iteration is not a testing phase. The majority of testing occurs throughout the project in the form of confirmatory testing performed by the development team itself, or investigative testing performed by independent testers to catch any pernicious bugs that slip through the cracks (again see "Agile Testing Strategies," January 2007). Having said that, as indicated in Figure 2, you will still do some testing during the release iteration. </p>

<ul>
    <li>First, the independent investigative testing efforts to verify the output of the last construction iteration still need to occur. Some of the defect stories will be addressed during the release iteration, although many will be put on the work items stack for "Release N+1" of the system.  </li>
  <li>Second, some release-specific testing efforts, in particular pilot/beta testing where you deploy your system to a subset of your end-user community, may occur. You may also need to do true acceptance testing where authorized project stakeholders work with the system and decide whether it truly meets their needs.  </li>
</ul>

<p>Although "agile acceptance testing," also known as "customer testing," is a part of the confirmatory testing efforts that occur throughout a project, you may still need to perform a final release acceptance testing effort where people outside of the team are involved. Testing of your installation/deployment scripts is particularly important during the release iteration because you don't want any surprises when you actually try to deploy.</p>

<p>Don't get me wrong, the activities that I've described as release testing in Figure 2 can and should be done much earlier in the lifecycle. My point is that these forms of testing are particularly pertinent during the release iteration to assure your stakeholders that your system is truly ready for deployment. Many organizations require that a system be put through some sort of formal sign-off process before deployment regardless of the development paradigm. The good news is that the increased focus on quality and testing by agile teams streamlines this effort.    </p>


<div>
    
<div class="smallcap">&#91;Click image to view at full size&#93;</div>
<!-- http://i.cmpnet.com/ddj/images/article/2007/07/ -->    
<img class="illowide" src="070401sa01_f2.gif" onclick = "popimage(this,'www.ddj.com - The Agile End Game - Figure 2')">

<div class="caption">
Figure 2: Testing during the release iteration.  
</div>
</div>


<table height="0" border="0" cellpadding="10" cellspacing="5" vspace="15">
  <tr> 
    <td valign="top" bgcolor="CCCC99">
    <p><b>More Than You Think to Releasing a System</b></p> 

<p>The common rhetoric within the agile community is that our software is always "production ready" because we deliver tested, working software at the end of each construction iteration. This is a good thing, and for simple systems, you might be able to simply copy the software onto a production server and declare success. In more complicated situations, you may need to:</p>

<ul>
  <li>	Hold acceptance reviews with stakeholders.</li>
  <li>	Finalize relevant documentation.</li>
  <li>	Translate the UI and supporting documentation into other languages.</li>
  <li>	Finalize and validate testing efforts.</li>
  <li>	Create physical collateral, such as manuals and installation media, for disbursement to end users and your operations and support (O&amp;S) staff.</li>
  <li>	Ship physical collateral and hardware.</li>
  <li>	Replace and/or install physical assets, including workstations, servers, and network components.</li>
  <li>	Replace existing software with new versions.</li>
  <li>	Update existing databases, including any relevant data migration and/or database schema changes.</li>
  <li>	Update any O&amp;S test environments used to simulate production problems.</li>
  <li>	Train end users and O&amp;S staff.</li>
  <li>	Run the existing system in parallel with the new release during a defined transition period.</li>
  <li>	Fix any discrepancies discovered during the transition period.</li>
  <li>	Train the team that is taking over maintenance and evolution of the system.</li></ul>

	</td>
  </tr>
</table>









<h3>Release Iteration(s)?</h3>

<p>The release iteration is often the perfect time to finalize your documentation. As I described in "Agile Documentation Strategies" (March 2007), you want to wait until information has stabilized before you invest time putting it down on paper. The whiteboard sketches that overview the high-level requirements supported by your system, and the technical architecture of it, might now be recorded using more sophisticated drawing tools to form part of your system overview documentation. Any operations and system (O&amp;S) manuals, as well as end-user documentation for this release, must also be finished. Hopefully, the majority of it was written during later construction iterations as you neared the release iteration; otherwise, you may find that your single release iteration has now expanded to several iterations.</p>

<p>Due to their complexity, some systems will require several iterations prior to release. Common reasons to stage your system release in multiple iterations include:</p>



<ul>
  <li>You need to train large numbers of users, but have a limited number of training resources.  </li>
  <li>You have different release dates for different parts of the world because you need to wait for translation of your system.  </li>
  <li>A "big bang release" of the system is deemed too risky.</li>
  <li>You have different groups of stakeholders, each of which work on different business cycles.</li>
  </ul>

<p>The end game of a project can be a difficult endeavor, one that shouldn't be underestimated. A valuable resource pertaining to the release iteration is <i>The Unified Process Transition and Production Phases </i>(CMP Books, 2001). Edited by Larry Constantine and myself, the book includes articles by Cem Kaner, Norm Kerth, Karl Wiegers, Steve Adolph, Martin Fowler, and Jim Highsmith.</p>




<table height="0" border="0" cellpadding="10" cellspacing="5" vspace="15">
  <tr> 
    <td valign="top" bgcolor="CCCC99">
    <p><b>Release Planning "Don't Forgets"</b></p> 

<p></p>

<p>Successful releases, particularly for complex projects, are planned almost from the very beginning of a project. The following are issues you want to consider long before you get to the release iteration:</p>

<ul>
  <li>	Involve operations and support (O&amp;S) departments early in the project.  O&amp;S people are critical stakeholders, so you want to understand their requirements and how to work with them effectively.</li>
  <li>	Identify the legal and/or regulatory compliancy issues.  Food and Drug Administration (FDA) guidelines or the Sarbanes-Oxley (SOX) act may be applicable to your system, increasing the required levels of documentation and internal auditing.</li>
  <li>	Identify potential release windows. Your operations department may have strict rules as to when a system may or may not be released, and you may need to compete for a slot within their overall release schedule (your system is just one of many).</li>
  <li>	Identify anyone who must sign off that the system is ready for deployment. This includes end-user management, internal audit groups, and O&amp;S management.</li>
  <li>	Identify any marketing or communication planning needs. For commercial software, you clearly want to market it well in advance of the actual release. For internal systems, which will have a large effect on end users, you may want to describe the coming changes well in advance.</li>
  <li>	Identify any dependencies with other systems. You may need to coordinate the release of your system with the release of several other systems; sometimes, a little bit of initial architecture modeling early in the lifecycle can go a long way towards avoiding problems later in a project.</li></ul>

	</td>
  </tr>
</table>



</body>
</html>