<html>
<head>
<title>The Value of Pattern Implementations</title>
<link rel="Stylesheet" rev="Stylesheet" href="../../../../forms/Layout.css" type="text/css">
<link rel="Stylesheet" rev="Stylesheet" href="../../../../forms/FontStyles.css" type="text/css">
<link rel="Stylesheet" rev="Stylesheet" href="../../../../forms/newarticle.css" type="text/css">
<script src="../../../../forms/popwindow.js"></script>
</head>

<body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000">
<!--Copyright &#169; Dr. Dobb's Journal-->
<p><i>Dr. Dobb's Journal</i> June 2007</p>

<h1>The Value of Pattern Implementations</h1>
<h2>Going beyond pattern specifications</h2>


<h3>By Lee Ackerman and Celso Gonzalez</h3>


<I>Lee is a Senior Product Manager with the IBM Rational Learning Services &amp; Solutions team. 
Celso is a World Wide Analysis, Design, and Construction Community of Practice leader in IBM Rational. They can be contacted at ackerman@ca.ibm.com and cgonzale@ca.ibm.com,  respectively.</I>

<hr>




<p>Over the past decade or so, we've heard about using patterns when designing software solutions. Much of this discussion started with Design Patterns: Elements of Reusable Object-Oriented Software, by Erich Gamma, et al., which showed how to use the patterns concept in software development&#151;where a pattern is a proven solution to a known problem within a given context. The patterns in Design Patterns and books that followed let us improve designs, communicate with others, and learn about design best practices. </p>

<p>The patterns story becomes even more interesting when we look at pattern implementations. In this article, we explore the benefits of pattern implementations.</p>


<h3>Pattern Specification versus Pattern Implementation</h3>

<p>In the literature, patterns are often described in a formal manner. This description usually includes a detailed description of the pattern, the context to apply the pattern, and the forces that it addresses. This overall information is what is called the "pattern specification" and its purpose is to describe the pattern and help you determine how and when the pattern should be applied. Architects or designers can then use the pattern specification as a model to apply the pattern.</p>

<p>The idea of a "pattern implementation" came from the desire to go further than simply using pattern specifications as a blueprint. As architects, designers, and developers, we continuously look for ways to automate and speed up the mundane and mechanical parts of our work. The pattern implementation is an artifact that allows the codification of a pattern specification and automates its application in a particular environment.  </p>

<p>A key point is that pattern implementations can generate many types of artifacts. They can be used to generate UML models, code, or other text-based artifacts such as JSPs, JSF pages, deployment scripts, test scripts, Eclipse project artifacts, and so on. In addition, pattern implementations can be created and used at different phases in the lifecycle as well as at different levels within an application. This means that you can use pattern implementations at high levels of abstraction, such as when you are discussing requirements or performing an initial analysis of a system. It also means that you can use pattern implementations when transitioning from analysis to design, then into an implementation&#151;all the while moving from a more abstract representation (a series of models) to a representation that is very specific (code). </p>

<p>Using Rational Software Architect to illustrate, you can see that pattern implementations surface in two ways:</p>

<ul>
    <li>UML Patterns. A UML Pattern is applied within the scope of a model and can apply markup to a model, add model elements, or create relationships between new or existing elements (Figure 1).</li>
  <li>Transformations. In contrast to UML Patterns, a Transformation usually converts elements from a source model into elements in a different target model. In the case of a Transformation, the supported input and output models go beyond UML. We use the term "model" in a broader sense to refer to a semantically rich representation of elements and their relationships. The model is usually specified using a formal language with well-defined structure and semantics. As such, UML is one choice, but you could also use other languages based on the Eclipse Modeling Framework (EMF). In addition, we can work with models that leverage Java, XML, or other languages to define the elements that they contain (Figure 2).</li>
</ul>



<div>
    
<div class="smallcap">&#91;Click image to view at full size&#93;</div>
<!-- http://i.cmpnet.com/ddj/images/article/2007/07/ -->    
<img class="illowide" src="070501cg01_f1.gif" onclick = "popimage(this,'www.ddj.com - The Value of Pattern Implementations - Figure 1')">

<div class="caption">
Figure 1: The upper part shows the pattern implementation; the lower part shows the classes and relationships generated by the pattern implementation. 
</div>
</div>



<div>
    
<div class="smallcap">&#91;Click image to view at full size&#93;</div>
<!-- http://i.cmpnet.com/ddj/images/article/2007/07/ -->    
<img class="illowide" src="070501cg01_f2.gif" onclick = "popimage(this,'www.ddj.com - The Value of Pattern Implementations - Figure 2')">

<div class="caption">
Figure 2: Mapping transformation that generates a &lt;&lt;Boundary&gt;&gt; class in the analysis model for every Actor.
</div>
</div>




<p>Creating pattern implementations is possible only because of the convergence of three streams with IT thinking, namely: Pattern Specifications, Model-Driven Development (MDD), and Metatooling.</p>











<h3>Patterns, MDD, &amp; Metatooling</h3>

<p>When looking at the convergence of pattern specifications, MDD, and metatooling, we note that none of these disciplines is particularly new. Each is associated with a community that has been developing and maturing its domain for a number of years. The new and interesting aspect is when we bring these three concepts together in a mainstream development environment.</p>

<p>Model-driven development is an approach in which models are a key development artifact. The models are used to capture and communicate design&#151;and preferably used to generate the solutions they represent.</p>

<p>MDD provides a strategy for raising the productivity and quality of software development by requiring you to think about the essential variables in design; so the model lets you work at the appropriate level of abstraction for the task at hand. The standard, repetitive, and algorithmic activities of expressing these variables in a particular technology environment is delegated to tooling.</p>

<p>The idea of metatooling is that you have tooling that lets you build tooling. In particular, for creating pattern implementations, which are tools themselves, we are interested in two metatools:</p>

<ul>
    <li>Modeling tools (such as Rational Software Architect) provide frameworks that codify best practices for reuse. With these tools, you can create, reuse, and execute pattern implementations to automate design and development.</li>
  <li>EMFT JET, an Eclipse-enabled template engine for generating applications based on customizable, model-driven architecture transformations. This plug-in can speed up the development of common types of applications via transformations that capture best (or current) practices for the design and implementation of those applications. Associated exemplar authoring tools let you quickly create pattern implementations.</li>
</ul>

<p>These can be used in combination to provide a platform for pattern implementations.</p>











<h3>Why Bother?</h3>

<p>The main benefits of pattern implementation use can be summarized as:</p>

<ul>
    <li><b>Increased productivity</b> accelerates the building and testing of software, and ease of use for beginners.</li>
  <li><b>Improved software governance</b> enforces architectural, design, and coding standards, and increased quality. Higher quality end products due to a higher level of consistency. Greater leverage of expert skills within the development organization.</li>
  <li><b>Architecture simplification </b>provides both a vocabulary and set of widgets used to design and implement a solution, and automates how you deal with complexity.</li>
</ul>

<p>With a pattern implementation, the key idea is that we've codified and automated a best practice. When it comes time to use the pattern implementation, we're able to perform the work much faster than if we were doing it manually. The pattern implementations can be used to generate both the code (and related artifacts that comprise the solution) as well as the artifacts used to test the solution. We always have to pay some price to develop the asset initially. However, if we use the asset many times, we save each time we use the automation, versus performing the task manually.</p>

<p>The use of pattern implementations also lets those new to the team use the asset without necessarily having the experience or knowledge required to actually create the pattern. They just need to know how to use the resulting asset, which of course, represents the best practices. As such, they are able to operate at a much higher level than if they were forced to struggle ahead on their own.  </p>

<p>As team sizes increase and members of the team specialize, we often find it challenging to ensure that those implementing the architecture and design stay true to the intentions of the architects and designers. An additional challenge here is that team members often may not be colocated, but distributed around the globe.</p>

<p>To address this issue, you can leverage pattern implementations in two ways:</p>

<ul>
    <li>To transform the design into the desired code artifacts. In this way, little is left open to interpretation, manual error, or undesired/unintentional creativity.  </li>
  <li>To transform the code artifacts into design elements. In this way, you can reconcile the current code artifacts with what was specified in the design.</li>
</ul>

<p>Governance also involves determining and managing the relationship between requirements and the solution that is built to meet those requirements. You should be able to trace all code back to requirements. We call this concept "traceability," and it is used to manage both what code is written in the first place as well as to assist us when it comes time to determine the impact of change. </p>

<p>To support traceability within the model, you can add connections that show the relationship between the elements in the design and the requirements. The pattern implementations are able to mimic this behavior&#151;so that as we apply the patterns in the solution, they automatically create traceability links between model elements that were the input to the pattern and those artifacts that end up being generated.</p>

<p>Because of these links, you can show how the elements of the solution map back to requirements. If those requirements change, you can answer the question, "What is the impact of the change?" If you need to change the code, you can answer the question, "Why is this coded to behave this way?"</p>

<p>Regardless of how fast you build your solutions, all is lost if the quality is not at an acceptable level. The first way pattern implementations can assist here is obvious&#151;the pattern implementation is an embodiment of our best practice solution. By using the pattern, the generated output is the best that you can generate and should meet quality requirements.</p>

<p>There are also less obvious ways that pattern implementations can improve the quality of solutions. For instance, if an error in a pattern is found, you can update the pattern implementation and reapply the pattern. Reapplication means that you just rerun the pattern and have it regenerate output that contains the fix. If you had performed the work manually, you would have to manually fix the code in each place where the error occurred. And since you would be performing that work manually, odds are that you would introduce a new defect somewhere in the updated code.</p>

<p>When we codify our best practices in the pattern implementation, we are implicitly stating that we are working with experts to create a representation of the best practice. If we left this work to be done manually, it might be performed by a group of people with varying skill levels. That we are able to replicate the work of the most skilled team members leads to a higher level of quality.</p>











<h3>Architecture Simplification</h3>

<p>Over the years of software development, we have continued to leverage abstraction and tooling to build ever more complex solutions. Pattern implementations let us take the next step in this progression. Again, pattern specifications gave us a vocabulary to use when designing and building solutions. We no longer had to discuss things at a code or module level. Patterns let us communicate in a known, shared language that carried with it best practices and proven solutions.</p>

<p>As we move forward with pattern implementations, we can leverage this communication mechanism and build upon it. With pattern implementations, we now have a set of widgets within our tools that we can bring to bear on our projects. We can use them to communicate, design, and generate. These widgets abstract away much of the complexity, letting us focus on the problem at hand.</p>


<h3>Conclusion</h3>

<p>In this article, we explored the benefits of using pattern implementations as a generating artifact. Other aspects worth exploring are the different types of pattern implementations, how they can be built, and the best practices supporting their creation. But that will have to wait for another article.</p>















</body>
</html>