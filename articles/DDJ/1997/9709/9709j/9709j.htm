<html>
<META NAME="year" CONTENT="1997">
<head>
<title>Dr. Dobb's Journal September 1997: </title>
</head>

<body bgcolor="FFFFFF">
<!--Copyright &#169; Dr. Dobb's Journal-->
<h2>Client/server visual applications</h2>

<h3>By Douglas C. McArthur</h3>

<I>Douglas is a senior scientific programmer for MDL Information Systems, and is project leader for MDLSCREEN. He can be contacted at douglasm@mdli.com.</I>

<hr>

<p>High-throughput screening (HTS) is an automated research technique being adopted by pharmaceutical and biotechnology companies. In a typical HTS scenario, one or more robots handle and track specific tests (assays) of various chemical compounds (samples), associate the resultant data with the correct sample, then store that information in an efficient manner. In a laboratory, 10,000 samples may be tested across seven different assays by a robot operating continuously for a week. The immense amount of information being analyzed in a relatively short time clearly presents a significant data-management challenge. Addressing such challenges, MDL Information Systems (the company where I work) developed MDLSCREEN, an Oracle-based client/server data-management system for automated drug discovery and high-throughput screening.</p>

<p>Storing the enormous amounts of scientific data generated by HTS experiments is just the first step, however. The most important task in automated drug discovery is identifying which samples exhibit a desired behavior. Therefore, the data-management system needs to support powerful data-analysis capabilities, too. It is also essential to perform complex calculations based on experimental and control data, then represent this information so that researchers can identify patterns using a graphical user interface (GUI). Approximately 50 percent of the scientists in HTS laboratories are Macintosh users, so finding a cross-platform (Windows and Macintosh) client development tool was important. For this reason, we selected Oracle Power Objects (OPO).</p>

<p>OPO Version 2.1 is a visual client/server development tool that focuses on database integration, creating reusable components visually, and building database applications using drag-and-drop techniques. OPO is available in both professional and client/server editions. Among other features, the Professional Edition supports Basic, OLE, and Netscape's Plug-in architecture for intranet-enabled applications. The Client/Server Edition provides additional support for ODBC and SQL*Net database connections.</p>

<p>Compared to two-tier client/server development tools such as PowerBuilder 5 or Delphi 3, OPO 2.1 is still the new kid on the block. Like those tools, OPO 2.1 builds 32-bit Windows 95/NT applications. Unlike them, it also targets native Power Macintosh applications with little or no modification to existing code. 16<sub></sub>bit Windows and 68K Macintosh are also supported. Version 2.1 also offers ODBC support and a new high-performance local database. The design environment offers a Windows Explorer-like object browser, in addition to a number of new built-in objects, properties, and methods. These features, combined with OPO's existing visual object orientation, drag-and-drop GUI construction, and tight database integration, make it ideal for cross-platform client/server rapid application development (RAD).</p>

<h3>Visual Object Orientation</h3>

<p>As <a name="rf1"><a href="9709jf1.htm">Figure 1</A> illustrates, OPO's visual-programming paradigm is similar to Visual Basic, with an object containment hierarchy. Forms, reports, and classes are containers into which controls such as fields or scrollbars, or other containers (such as radio button frames or rectangles) can be added using drag and drop. Classes are actually a special type of form, instantiated by dropping the icon representing the class into another container. Properties and methods of the class are inherited as expected, and can be overridden. While it is possible to add new methods and properties to a class, they only exist within the framework of the class container. This can be a little frustrating at first, but the benefit is straightforward visual object orientation.</p>

<p>While the visual-programming approach is useful for RAD tools, it poses a problem for generating meaningful code listings. Method code is spread among various objects, which also are created by a series of drag-and-drops. For instance, connecting to a remote server might be accomplished by method code like <a name="rl1"><a href="9709j.htm#l1">Listing One</A> However, creating the referenced fields, radio button frame, and so on, requires a complex series of drag-and-drop actions and tweaking of object properties.</p>

<h3>The Session Object</h3>

<p>OPO uses a session object to establish a database connection. The method in <a href="9709j.htm#l1">Listing One</A> sets the <i>RunConnect</i> property of the session object to the proper connection string for an ODBC or SQL*Net connection. The <i>Connect()</i> method attempts the connection, and the <i>IsConnected()</i> function returns the connection status. Expanding the session object in the Designer object browser displays database objects (tables, views, and so on), which can be further expanded to view the constituent columns and their datatypes; see <a name="rf2"><a href="9709jf2.htm">Figure 2</A>. Icons of tables can be dropped into container objects (a form, for example) to create fields that are bound to the columns in the table through an intermediary object called a <i>recordset</i>.</p>

<h3>The <i>recordset</i> Object</h3>

<p>The <i>recordset</i> object works behind the scenes as a transaction buffer, allowing sophisticated client-side data manipulations without having to create in-memory data arrays. Containers such as forms, embedded forms, and classes associated with a specific table or view (by dropping a table into the container or by manually setting the <i>RecordSource</i> property) will have an associated <i>recordset</i> object automatically created at run time. A display control (such as a field object) is considered "data aware" if it can be bound to a specific column in a recordset (specified by its <i>DataSource</i> property). The <i>DataSource</i> is essentially a pointer to part of the <i>recordset</i>. The <i>recordset</i> usually contains a subset of rows from the bound table, automatically buffered as needed for display or update. <a name="rl2"><a href="9709j.htm#l2">Listing Two</A> shows how to access data in a <i>recordset</i>.</p>

<p>The function <i>udmFindString()</i> takes the parameters:</p>

<ul>
  <li><i>pRecordSet</i>, an object reference to a <i>recordset</i>.
  <li><i>pColumnName</i>, a string defining the column name in the table bound by the <i>recordset</i>.
  <li><i>pString</i>, a string defining the value to search for.
</ul>

<p>The OPO convention for returning a value from a function is to set the function name to the return value. <i>GetRowCount(),</i> <i>SetCurRow()</i>, and <i>GetColVal()</i> are standard methods of a <i>recordset</i>. The <i>recordset</i> is a powerful OPO feature. Manipulating data within the <i>recordset</i> avoids creating unwieldy data arrays. In addition, display controls bound to the <i>recordset</i> are automatically updated as needed when the <i>recordset</i> is modified.</p>

<h3>Bound Controls</h3>

<p>The field object is one type of bound control. OPO 2.1 also adds the grid control to OPO's tool palette. Familiar to Visual Basic programmers, the grid control displays data in a spreadsheet-like grid of resizable columns (see <a name="rf3"><a href="9709jf3.htm">Figure 3</A>). Additionally, a number of data-aware ActiveX display controls ship with OPO 2.1. However, they will only allow 32-bit Windows applications to be built, which defeats one of OPO's strongest advantages -- cross-platform portability. (OPO's planned support of OpenDoc for cross-platform component extensibility never materialized; OLE and ActiveX are currently Windows-only features.) Luckily, most programming needs can be met using the built-in OPO display objects.</p>

<h3>Cross-Platform Support</h3>

<p>Cross-platform portability is a goal of most client/server developers. Tools like Delphi do offer impressive performance and power, but only for Windows. OPO applications, on the other hand, can be created as:</p>

<p></p>

<ul>
<li>Platform-independent bytecode (similar to Java), which requires a run-time engine; or as  <li>Stand-alone executables, which are actually the bytecode bundled with the run-time engine for the desired platform. 
</ul>

<p></p>

<p>OPO performs a sort of just-in-time (JIT) compilation for both bytecode and stand-alone applications.</p>

<p>There are many programming issues to keep in mind if an OPO application is to be successfully deployed for both Windows and Macintosh environments. OPO 2.1 has the ability to set the default unit of measurement (inches or pixels) required by the specific platform. (OPO 1.0 defaulted to inches instead of pixels, which caused undesirable scaling effects when designing for Windows versus Macintosh. Font scaling continues to pose a problem.) Additionally, OPO 2.1's DECLARE syntax allows calls to Windows DLLs or Macintosh resources to be sensitive to the compilation or run-time environment.</p>

<p>Still, OPO 2.1 clearly favors Windows development. Perhaps this is to be expected, since OPO is fashioned after Visual Basic. Nevertheless, OPO applications developed on the Macintosh generally look better under Windows than those developed under Windows and run on the Macintosh. As long as the use of OLE and ActiveX controls is avoided, the cross-platform challenges in OPO are mostly cosmetic.</p>

<h3>Using the Designer</h3>

<p>Like many client/server development tools, OPO is focused primarily on client-side GUI building to create a database front end. While OPO provides graphical tools for creating and managing database objects such as tables, views, and indexes, you will still need to resort to DDL scripts for creating referential constraints, check constraints, and the like. Where OPO really shines is in the rapid creation of highly functional interfaces and the ability to easily create reusable objects (using classes) that can be shared across applications.</p>

<p>While drag-and-drop will take you a long way in building simple forms (binding controls to database objects), more sophisticated forms may require adding user-defined properties or methods to various objects within your application. For example, the built-in OPO field object can be extended to automatically resize itself to fit its container by adding a user-defined method <i>udmResizeToContainer()</i>. Putting this field in a class allows the additional functionality to be reused. Since classes in OPO are themselves container objects, the class and the field must be resized.</p>

<p><a name="rl3"><a href="9709j.htm#l3">Listing Three</A> shows example method code for <i>udmResizeToContainer()</i>. The newly created class can either be part of the OPO application file or part of an OPO library. The benefit of creating a class in a library is that it can be shared across applications. Moving a class from an application to a library, or vice versa, is performed via drag and drop.</p>

<h3>Automating the Build Process</h3>

<p>With OPO 2.1, Windows versions of the OPO Designer act as an OLE automation server. This allows OLE automation clients to drive the application building process. For example, Oracle's Designer/2000 contains a code generator that will automatically build OPO forms based on the table definitions and design preferences stored in its repository of database objects. One added benefit of this approach is a consistent, standardized UI. Manual additions can then be made to the generated application.</p>

<h3>Web Deployment</h3>

<p>OPO 2.1 also includes a Netscape plug-in for running OPO applications within web pages. Currently only available for Windows 95, the plug-in allows OPO bytecode files to be downloaded from within an HTML document using the &lt;EMBED&gt; tag, similar to a Java applet. There is one caveat, however: Database connection is still performed via a SQL*Net connection, which limits deployment to mainly intranet solutions.</p>

<p>Notice that, when writing applications for web deployment, toolbars are not displayed, and you should avoid use of the <i>TestCommand()</i> method.</p>

<h3>Less is More</h3>

<p>One final note: <i>recordset</i> objects can help to greatly reduce the number of lines of code required, facilitating rapid development and reducing maintenance effort. One common mistake made by beginner OPO programmers is writing many unnecessary lines of method code instead of taking advantage of the methods already available in existing objects. You need to become familiar with the <i>recordset</i> object; it is one of the most powerful and time-saving tools in OPO. In addition, built-in support for creating and maintaining master-detail relationships and shared <i>recordset</i>s can potentially save hundreds of lines of code that would be needed for synchronizing data display.</p>

<h3>Conclusion</h3>

<p>The gradual movement toward <i>n</i>-tier client/server architectures and distributed objects could eventually leave two-tier development tools like PowerBuilder, Delphi, and OPO behind. While OPO 2.1 adds support for more client platforms, such as Windows NT, I suspect that future versions of OPO will add the Java Virtual Machine to the list. Oracle has already hinted that its Network Computing Architecture will support an OPO application cartridge, perhaps allowing OPO applications to run on an application server and display client interfaces using Java. In any case, OPO's cross-platform support, visual object orientation, and rapid development via drag-and-drop make it ideal for developing an HTS data-management solution. </p>
<HR>
<H4><a name="l1">Listing One</H4>

<pre>'Sub Click()' Connect to database using proper connection string syntax
' for ODBC or ORACLE connection as specified in the popup
' list "popConnectionType" with radio buttons for "ODBC" and
' "ORACLE" values, and using values from fields "fldLogin",
' "fldPassword", and "fldDatabase" on user click.
' ==========================================================
<p></p>
DIM vConnectString as String
<p></p>
SELECT CASE popConnectionType.Value
  CASE "ODBC"
    vConnectString = "odbc:UID=" &amp; fldLogin.Value &amp;      &amp;
                     ";PWD="     &amp; fldPassword.Value &amp;   &amp;
                     ";DB="      &amp; fldDatabase.Value
  CASE "ORACLE"
    vConnectString = "oracle:" &amp; fldLogin.Value &amp;        &amp;
                     "/"       &amp; fldPassword.Value &amp;     &amp;
                     IIF( ISNULL( fldDatabase.Value ),   &amp;
                          "", "@" &amp; fldDatabase.Value    &amp;
                        )
END SELECT
 
sesDatabase.RunConnect = vConnectString
sesDatabase.Connect()
<p></p>
IF sesDatabase.IsConnected() THEN
    frmMainMenu.OpenWindow()
ELSE
   MsgBox( "Unable to connect to database.  " &amp;  &amp;
           "Check login name, password, and database name." )
END IF
<p></p>
'End Sub Click()
</pre>
<P>
<a href="#rl1">Back to Article</A>
</P>
<H4><a name="l2">Listing Two</H4>

<pre>'Function udmFindString( pRecordset, pColumnName, pString ) as Integer' Loop through each row in pRecordSet, checking if
' pColumnName is equal to pString.  Return the row
' if a match is found, or a zero when no match.
' ====================================================================
<p></p>
FOR vRow = 1 TO pRecordset.GetRowCount()
  pRecordset.SetCurRow( vRow )
  IF pRecordset.GetColVal( pColumnName ) = pString THEN
     udmFindString =3D vRow
     EXIT FUNCTION
  END IF
NEXT
udmFindString = 0
'End Function udmFindString()
</pre>
<P>
<a href="#rl2">Back to Article</A>
</P>
<H4><a name="l3">Listing Three</H4>

<pre>'Sub udmResizeToContainer()' Set SizeX of field's class container and field itself to the number
' of pixels from class's PositionX and its container's SizeX.  
' ======================================================================
Container.SizeX = Container.GetContainer().SizeX - Container.PositionX
<p></p>
Self.SizeX = Container.SizeX
<p></p>
'End Sub udmResizeToContainer()
</pre>
<P>
<a href="#rl3">Back to Article</A>
</P>

<p><b>DDJ</b></p>


<HR><I>Copyright &copy; 1997, Dr. Dobb's Journal</I><BR>

</BODY>
</html>
