<html>
<META NAME="year" CONTENT="1997">
<head>
<title>Dr. Dobb's Journal February 1997: Examining C++ Program Analyzers</title>
</head>

<body bgcolor="FFFFFF">
<!--Copyright &#169; Dr. Dobb's Journal-->
<h1>Examining C++ Program Analyzers</h1>

<p><i>Dr. Dobb's Journal</i> February 1997
</p>
<h2>Finding out how programs really behave</h2>

<I>Scott, a software-development consultant and author of Effective C++ and More Effective C++, can be contacted at smeyers@ netcom.com. Martin holds a degree in computer science from the Johannes Kepler University, in Linz, Austria, and can be contacted at mklaus@swe.uni-linz.ac.at.</I>

<hr>
Sidebar:<a name="rs1"> <a href="9702hs1.htm">"Constraint Expression Languages"</A>
<HR>

<p>C++ has a well-deserved reputation for power and flexibility. It has an equally well-deserved reputation for complexity -- its "gotchas" are legion. For example, omitting a virtual destructor in a base class typically leads to incomplete destruction of derived class objects when they are deleted through base-class pointers.</p>

<p>Experienced C++ programmers learn to avoid these kind of problematic constructs, but experience should not be necessary: Troublesome C++ can often be detected by static analysis, using tools that parse and analyze C++ source code. Such tools are becoming available, and during the summer and fall of 1996, we undertook an investigation to identify these tools and to assess their capabilities. In this article, we summarize the initial results of our investigation.</p>

<p>We were interested in answering three questions.</p>

<p>First, what tools statically analyze C++ programs and issue warnings about likely trouble spots? By focusing on static analysis, we limited our research to tools spiritually akin to lint. We explicitly ignored tools designed to detect dynamic (run-time) errors, such as programs that monitor memory usage and report on leaks. Such tools are important, but they offer functionality that complements -- not replaces -- static analysis. We also ignored tools that focus on lexical issues (identifier names, indentation style); our interest was in tools that identify constructs that affect program behavior.</p>

<p>Second, how comprehensive are the tools in identifying suspect C++ constructs? C++ has many facets, including data abstraction, inheritance, templates, and exception handling, and we wanted to find tools that checked for likely errors in many of these areas. A few tools checked only the C subset of C++; we ignored those offerings. Our interest was in tools for C++ programmers, and C++ programmers have different needs than C programmers.</p>

<p>Third, how well do the tools work on real programs? Can they parse real source code? Do they scale well when run on large projects? Are they robust enough to handle complex template instantiations, including those generated by the Standard Template Library? </p>

<p>In this article, we will address only the first two questions. </p>

<h3>Identifying Tools</h3>

<p>When we began this project, we were aware of several static-analysis tools for C++, but we suspected there were others we didn't know about. Consequently, we posted a request for information to several USENET newsgroups, including groups devoted to C++ programming, OOP, and programming on various platforms. Based on the responses, we ultimately identified the tools discussed here.</p>

<p></p>

<ul>
<li> CodeCheck from Abraxas Software. CodeCheck is a stand-alone tool for DOS, Windows, and UNIX that lets you use a C-like language to specify what kinds of program analysis to perform. It comes with several predefined analysis programs, including some for computing program-complexity metrics and identifying non-portable code.  <li> C++Expert from CenterLine Software. Also a stand-alone tool, C++Expert performs static and dynamic analyses of C and C++ programs. Its static checks are drawn from Scott Meyers' <i>Effective C++</i> and <i>More Effective C++</i>, and its diagnostics contain hypertext links to online versions of those books. At this time, it supports only UNIX.
  <li> FlexeLint/PC-Lint from Gimpel Software. Another stand-alone tool (the name is FlexeLint for UNIX, and PC-Lint for DOS, Windows, and OS/2), FlexeLint/PC-Lint is perhaps truest to the classic lint tradition. It can check for over 600 potential error conditions in C and C++ source code, including conditions that affect more than one translation unit or that require detailed dataflow analysis. 
  <li> CodeAdvisor from Hewlett-Packard. CodeAdvisor is a part of HP's SoftBench development environment for UNIX. It enforces 23 predefined rules, and you can extend its capabilities by coding new analyses in C++, then linking them in. Source-code information is stored in a database, so it is possible to perform checks that involve multiple translation units.
  <li> CodeWizard from ParaSoft. CodeWizard is a stand-alone UNIX tool designed to enforce a set of 24 rules selected from <i>Effective C++</i>.
  <li> QA/C++ from Programming Research. Another stand-alone tool for UNIX, QA/C++ works in two phases. First, it examines C or C++ source code and stores the results in a database. Different Programming Research analysis tools may then be run against the database; these tools generate warning messages. There is no database API that lets programmers develop their own analyses.
  <li> The Apex C/C++ Development Environment from Rational Software. Among other capabilities, the Apex environment enforces 22 predefined rules for C and C++ programming under UNIX.
</ul>

<p>To these choices, we added our noncommercial program, CCEL, purely for purposes of comparison. CCEL began as a research project on static analysis of C++ programs under the direction of one of us (Meyers) and was eventually fully implemented through independent work by the other (Klaus). We added CCEL to our investigation because we were familiar with its capabilities and limitations, and we felt it would be interesting to compare commercial approaches to our research-based initiative.</p>

<h3>Our Approach</h3>

<p>There were three phases in our testing process.</p>

<p>1.We developed a set of benchmark rules constraining the structure of C++ programs. For example, one rule is that all base classes must have virtual destructors. We tried to develop a set of rules that was representative of the kinds of rules that real programmers would find useful.</p>

<p>2.We contacted vendors and asked which rules their tool could enforce. This information proved useful during our empirical tests, because discrepancies between vendor claims and our findings often identified subtle differences between our rules and those enforced by vendors.</p>

<p>3.We developed of a set of sample source files seeded with rule violations. We ran each tool on each source file to see whether the seeded rule violation was correctly identified.</p>

<p>Our results yielded <a name="rt2"><a href="9702ht2.htm">Table 2</A>, which shows how well each tool enforced our benchmark rules on our benchmark programs.</p>

<h3>Choosing Rules</h3>

<p>There are many ways to compose a set of benchmark rules for C++ programs, but it is difficult to argue that one set is "better" than another. As a result, we made no attempt to develop the "best" set of rules. Instead, we fell back on the fact that one of us (Meyers) has authored two books containing guidelines for C++ programming and we chose nearly all our rules from those books.</p>

<p>This approach is not as gratuitous as it might appear. Meyers' <i>Effective C++</i> and <i>More Effective C++</i> have been well-received in the C++ programming community, and one or both form the basis for many sets of corporate-coding guidelines. In addition, these books form the basis for at least two of the static-analysis tools in our investigation. Finally, by drawing our rules from well-known and easily accessible sources, we avoided the need to explicitly justify individual rules in our benchmark set. Instead, the justification for nearly every rule is available in the books, and we simply refer to the appropriate book location as the rationale for each rule.</p>

<p>We chose 36 rules divided into eight categories; see <a name="rt1"><a href="9702ht1.htm">Table 1</A>. Each rule begins with its "Rule" number, followed by a reference to either <i>Effective C++</i> (E) or <i>More Effective C++</i> (M). Next is a reference to the book "Item" number from which the rule is derived. The text of the rule is often different from the text of the book Item, because the book Items tend to be worded too generally to be checked. </p>

<p>Some of the rules may seem controversial, especially in light of the C++ found in many popular class libraries. Rule 15 (no public data members) is widely violated in the MFC, for example, while almost no library adheres to Rule 19 (make all nonleaf classes abstract). With the exceptions of Rules 13 and 23 (which we hope are self explanatory), <i>Effective C++</i> and <i>More Effective C++</i> offer firm technical foundations for each rule. We believe it is therefore important that programmers be able to enforce those constraints, even if the majority of programmers choose not to. Furthermore, our decision to include rules that are commonly violated helps us evaluate the effectiveness of the tools' filtering capabilities. (We do not report on this aspect of the tools in this article, but it is an important consideration in the practical application of any tool.)</p>

<h3>Benchmark Programs</h3>

<p>For each of our 36 rules, we developed a source file seeded with a violation of the rule. We then executed each tool on each source file to see if the tools correctly identified the seeded errors. These source files were truly trivial -- many were under ten lines long. Our goal was not to provide a realistic test of the tools -- just to see whether or not the tools could identify rule violations in the simplest of cases. (Sometimes, this backfired and yielded misleading results.) <a name="rl1"><a href="9702h.htm#l1">Listing One</A> s the source code for the file used to test Rule 20. </p>

<h3>Compilers versus Special Tools</h3>

<p>Several people responded to our request for information on static-analysis tools by remarking that they found little need for such tools. Instead, they relied on compilers to flag conditions that were likely to lead to trouble ("I find GNU<b> </b>G++ with -ansi -pedantic -Wall -O flags useful," was a typical comment).</p>

<p>In fact, the GNU compiler was singled out as being especially good at warning about troublesome C++. This piqued our curiosity about compiler warnings. How many of our candidate rules would compilers identify?</p>

<p>To find out, we submitted our benchmark programs to five compilers, in each case enabling as many warnings as possible. As <a href="9702ht2.htm">Table 2</A> shows, the results were disappointing. Even G++ identified, at most, 2 of the 36 rule violations, and three of the compilers identified none. This confirmed our impression (based on our experience as C++ programmers) that while compilers -- at least the compilers with which we have had experience -- are good at many things, identifying legal, but potentially troublesome, C++ source code is not one of them.</p>

<h3>Specifying Constraints</h3>

<p>The tools in our study let you specify what conditions to check for in one of two ways. Most tools follow the lint model, whereby the tool is created with the ability to enforce some set of predefined constraints, and you turn these constraints on or off. There is no way to extend the capabilities of such tools. For example, a tool is either capable of detecting that an exception may leave a destructor (Rule 31) or it's not. If it's not, there is no way for a tool user to add that capability.</p>

<p>A different approach -- employed by Abraxas' CodeCheck, HP's CodeAdvisor, and our CCEL -- is to provide tool users with a language in which to express constraints of their own. Such tools may or not be useful "out of the box" (it depends on the existence and utility of predefined rule libraries), but can be extended to check for new, user-defined conditions. This approach is more powerful, but, as in the case of C++ itself, complexity often accompanies power; the power is inaccessible until you have mastered the constraint-expression language. Furthermore, the addition of user-defined constraints may affect an analysis tool's performance, because enforcement of such constraints may require arbitrary amounts of time, memory, or other resources.</p>

<p>We made no attempt to master the various constraint-expression languages used by the different tools, but the examples we saw (see the accompanying text box entitled "Constraint Expression Languages") reinforced the lessons we learned during the design and implementation of CCEL -- it's hard to design a language for expressing constraints on a language as feature-filled as C++, and such a constraint language is nontrivial to learn. Abraxas, for example, reports that it takes between three and six months to become proficient in the CodeCheck constraint language. Most Abraxas customers want to hire specialists to compose rules instead of having to learn to write the rules themselves.</p>

<p>Most programmable tools attempt to offer the best of both worlds by shipping a set of predefined rule libraries that check for commonly desired constraints. This eliminates the need to write rules to cover common constraints.</p>

<h3>Results and Discussion</h3>

<p><a href="9702ht2.htm">Table 2</A> presents the results of running the various tools on the collection of benchmark programs. Several features are of interest. First, no tool was able to enforce all of our 36 benchmark rules, not even the tools supporting user-defined constraints. Thus, even the best of tools currently available offers only partial coverage of C++. This is especially noteworthy because our benchmark rules themselves failed to exercise all major language features; templates are a particularly obvious omission.</p>

<p>Second, the number of benchmark rules that can be enforced without programming (out of the box) is, at most, 17 of 36. (CCEL supports 19, but CCEL is a research project, not a commercial tool.) If we speculate that our set of benchmark rules is somehow representative of the kinds of constraints real programmers might want to enforce, this suggests that current tools cover, at best, only about half of those constraints. Of course, automatic enforcement of half a set of requirements is better than no enforcement at all, but the data in <a href="9702ht2.htm">Table 2</A> suggest that there is much room for increased language coverage by static-analysis tools for C++.</p>

<p>Third, it is not uncommon to have subtle mismatches between a benchmark rule and the conditions detected by the analysis tools. In most cases, this is an outgrowth of the vendors' attempts to avoid generating warning messages when no truly harmful condition exists. For example, consider Rule 10: "Make destructors virtual in base classes." Many programmers consider this rule too aggressive, and a common alternative form of the same rule is: "Make destructors virtual in classes containing virtual functions." This form has the advantage that no virtual table pointer is added to a class simply to satisfy the rule. (This is the rule variant that's employed by the GNU C++ compiler, HP's CodeAdvisor, and Programming Research's QA/C++.)</p>

<p>The motivation for this rule (in any form) is that <a name="rl2"><a href="9702h.htm#l2">Listing Two</A> is generally harmful if the base class lacks a virtual destructor. In truth, <a href="9702h.htm#l2">Listing Two</A> is only harmful if one or more of the following conditions holds:</p>

<ul>
  <li>D has a destructor.
  <li> D has data members that have destructors.
  <li> D has data members that contain data members (that contain data members, and so on) with destructors.
</ul>

<p>At least one tool vendor attempts to issue a diagnostic only if these more stringent conditions exist, and the conditions do not exist in our test program (<a name="rl3"><a href="9702h.htm#l3">Listing Three</A>). The tool in question thus issues no diagnostic on our sample program, but if class <i>Derived</i> were nontrivial, the tool might issue a warning.</p>

<p>This more precise analysis should be beneficial for users, because a diagnostic should be issued only if a problem truly exists. However, the rules of C++ can be both complicated and unintuitive, and their subtlety can cut both ways. In the case of the vendor attempting to check for the more detailed conditions outlined earlier, the test for data members with destructors in the derived class was omitted. Hence, though the tool avoids issuing warnings in harmless cases, it also avoids issuing warnings in some harmful, but rare cases. These are precisely the cases in which static-analysis tools that correctly understand the detailed rules of C++ are most useful!</p>

<p>Another tool had trouble issuing correct diagnostics when compiler-generated functions -- default constructors, copy constructors, assignment operators, and destructors (especially derived-class destructors) -- were involved. Because of the minimalist nature of our test cases, our programs had many instances of such functions; this led to incorrect results from some tools.</p>

<p>Whether such shortcomings would cause problems when the tools are applied to real programs is unknown, but it hints at a deeper problem we found: Vendors don't seem to understand the subtleties of C++ as well as they should. We believe that vendors of C++ analysis tools must understand C++ as well as compiler vendors, but based on our experience with the tools in this study, we must report that such expertise cannot yet be taken for granted.</p>

<h3>Caveats</h3>

<p>While <a href="9702ht2.htm">Table 2</A> provides insight into the state of existing lint-like tools for C++, it is important to recognize what it does not show. We were interested only in the capability of such tools to handle the "++" part of C++, but most of the tools also provide significant other capabilities. </p>

<p>Most tools also check the "C" part of C++, some quite extensively. This can be useful. By limiting our tests specifically to C++ capabilities, we were able to sharpen our focus, but we also screened out the majority of some tools' functionality.</p>

<p>Many tools offer stylistic and lexical checks in addition to the semantic issues we looked at. For example, if you wish to ensure that classes never use the default access level of <i>private,</i> but instead declare it explicitly, at least one tool will note violations of that constraint.</p>

<p>Some tools offer complementary analyses in addition to checking coding "style." For example, Programming Research's QA/C++ can calculate various program-complexity metrics.</p>

<p>In addition, our set of benchmark rules was far from exhaustive. Some vendors check for C++-specific conditions we didn't consider; <a href="9702ht2.htm">Table 2</A> says nothing about such capabilities.</p>

<p>All this is to say that <a href="9702ht2.htm">Table 2</A> is anything but a buyer's guide. Furthermore, there are many nontechnical characteristics of analysis tools you should consider before deciding which, if any, is suitable for your circumstances. The following questions come to mind:</p>

<ul>
<li>How easy is it to install, configure, and use the tool? These factors are especially important for tools with equivalent (or close to equivalent) capabilities. For example, Gimpel Software's FlexeLint and Productivity Through Software's ProLint use the same underlying analysis engine, but offer quite different user interfaces.  <li>How easy is it to filter out unwanted diagnostics? The traditional Achilles Heel of lint-like tools is an unacceptable signal-to-noise ratio, so it's important that users be given fine-grained control over what code is analyzed and which diagnostics appear. In fact, some vendors deliberately avoided offering checks for some conditions (for example, the use of preprocessor macros to define constants -- our Rule 1) because they felt it would be more bothersome than useful to their customers. (Respondents to our newsgroup postings indicated that a bad signal-to-noise ratio is a continuing problem, even with some of the tools considered here.)
  <li>How robust and up-to-date is the C++ parser? To be maximally useful, a C++ analyzer must parse exactly the same language as the compiler(s) you use. It's particularly frustrating if the analyzer rejects code your compiler accepts.
  <li>Can the tool handle large projects -- those with multiple libraries and hundreds or thousands of source files? Based on the responses we got from our USENET postings, the answer too often is that it cannot.
  <li>Is the documentation complete, accurate, accessible, and comprehensible? 
  <li>Does the vendor offer adequate customer service, including technical support?
  <li>How well established is the vendor? Is the vendor likely to continue to support the tool for years to come?
</ul>


<p>Our study considered none of these issues.</p>

<p>Finally, it is important to remember that <a href="9702ht2.htm">Table 2</A> is based on tests we performed in August/September 1996. Virtually all of the tools we examined are under active development, so it's likely that new versions exist even as you read this report. For example, we know that Abraxas is currently beta-testing a set of predefined constraints derived from material in Meyers' books, and CenterLine and Rational are planning upgrades to C++Expert and Apex, respectively, that will allow users to define new constraints. Other vendors are similarly active. <a href="9702ht2.htm">Table 2</A> represents a mere snapshot of the commercial state of the art in September 1996.</p>

<h3>Summary</h3>

<p>A number of analysis tools are now available that read C++ source code and warn about possible behavioral problems. They cover varying aspects of C++, though none offers truly comprehensive coverage of the language. Based on simple tests, we believe that many dangerous C++ constructs can be detected, though the complexity of C++ leads to incorrect behavior on the part of some tools, especially where compiler-generated functions are concerned. C++ analysis tools are under active development, and it is likely that the data in this article fails to accurately reflect the current capabilities of the tools we examined. If you are interested in static-analysis tools for C++, we encourage you to contact the vendors, conduct your own tests, come to your own conclusions -- then share them with us.</p>

<h3>Acknowledgment</h3>

<p>We are grateful to Jill Huchital for her comments on a draft of this article.</p>

<h3>References</h3>

<p>Meyers, Scott. <i>Effective C++</i>, Reading, MA: Addison-Wesley, 1992.</p>

<p> --  --  -- <i>More Effective C++</i>, Reading, MA: Addison-Wesley, 1996.</p>

<p>Meyers, Scott, Carolyn K. Duby, and Steven P. Reiss. "Constraining the Structure and Style of Object-Oriented Programs." <i>Principles and Practice of Constraint Programming</i>. Cambridge, MA: MIT Press, 1995. </p>

<p>Musser, David R. and Atul Saini. <i>STL Tutorial and Reference Guide</i>, Reading, MA: Addison-Wesley, 1996.</p>
<H3>For More Information</H3>
<P>
Abraxas Software<br>
5530 SW Kelly Avenue<br>
Portland, OR 97201 <br>
503-244-5253<br>
http://www.abxsoft.com/<br>
<br>
Centerline Software<br>
10 Fawcett Street<br>
Cambridge, MA 02138-1110<br>
617-498-3000<br>
http://www.centerline.com/<br>
<br>
Gimpel Software<br>
3207 Hogarth Lane<br>
Collegeville, PA 19426 <br>
610-584-4261<br>
http://www.gimpel.com/ <br>
<br>
Hewlett-Packard <br>
19410 Homestead Road<br>
Cupertino, CA 95014-0604<br>
408-725-8900<br>
http://www.hp.com/sesd/CA/<br>
ParaSoft Corp.<br>
2031 South Myrtle Avenue<br>
Monrovia, CA 91016<br>
818-305-0041<br>
http://www.parasoft.com/<br>
<br>
Productivity Through Software Inc.<br>
555 Bryant, Suite 555<br>
Palo Alto, CA 94301<br>
415-934-3200<br>
http://www.pts.co.uk/<br>
<br>
Programming Research Ltd.<br>
1/11 Molesey Road, Hersham<br>
Surrey KT12 4RH, UK<br>
+44-1932-88 80 80<br>
http://www.prqa.co.uk/<br>
<br>
Rational Software Corp.<br>
2800 San Tomas Expressway<br>
Santa Clara, CA 95051-0951<br>
408-496-3600<br>
http://www.rational.com/<br>
</P>


<p><b>DDJ</b></p>

<H4><a name="l1">Listing One</H4>

<pre>//  20  M24  S   Avoid gratuitious use of virtual inheritance, i.e., make//  sure there are at least two inheritance paths to each virtual base class.
class Base { int x; };
class Derived: virtual public Base {};
Derived d;
</pre>
<P>
<a href="#rl1">Back to Article</A>
</P>
<H4><a name="l2">Listing Two</H4>

<pre>class B { ... };             // base class;  assume no virtual dtorclass D: public B { ... };   // derived class
void f(B *p);                // f is some function taking a B*
D *pd = new D;               // pd points to a D
f(pd);                       // pass pd to f, binding pd to p in f
void f(B *p)
  {
    delete p;                // this calls only B's dtor, not D's!
  }
</pre>
<P>
<a href="#rl2">Back to Article</A>
</P>
<H4><a name="l3">Listing Three</H4>

<pre>// test program for rule 10<p></p>
class Base {};
class Derived: public Base {};
<p></p>
<p></p>
int main()
{
  Base *pb = new Derived;
  delete pb;
  return 0;
}
<p></p>
<P>
<a href="#rl3">Back to Article</A>
</P>

<HR><I>Copyright &copy; 1997, Dr. Dobb's Journal</I><BR>

</BODY>
</html>
