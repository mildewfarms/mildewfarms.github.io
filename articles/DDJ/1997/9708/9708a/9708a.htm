<html>
<META NAME="year" CONTENT="1997">
<head>
<title>Dr. Dobb's Journal August 1997: The SGI Standard Template Library </title>
</head>

<body bgcolor="FFFFFF">
<!--Copyright &#169; Dr. Dobb's Journal-->
<h1>The SGI Standard Template Library </h1>

<p><i>Dr. Dobb's Journal</i> August 1997
</p>
<h2>Efficient and interoperable software components</h2>

<h3>By Matthew H. Austern </h3>

<I>Matt is a member of the technical staff at Silicon Graphics. Matt is coauthor, along with Alexander Stepanov and Hans Boehm, of the SGI STL. He is currently working on a book about the STL, to be published by Addison-Wesley. Matt can be contacted at austern@isolde.mti.sgi.com.</I>

<hr>

<p>The C++ community was introduced to generic programming in 1994, when Hewlett-Packard released a demonstration implementation of the Standard Template Library (STL). The STL was subsequently adopted as part of the C++ Standard Library. Late in 1996, Silicon Graphics released (and made freely available at http://www.sgi.com/Technology/STL/) a new version of the Standard Template Library.</p>

<p>Although the STL is often thought of as a library of container classes, that is not the most appropriate starting point for understanding it. The STL is, more than anything else, a collection of generic algorithms combined with the support apparatus that the algorithms require. It is possible to understand most of the structure of the STL by examining a single algorithm in depth. </p>

<h3>Algorithms</h3>

<p>The crucial insight that underlies the STL is that most of the fundamental algorithms of computer science are, in fact, abstract. That is, the precise details of data structures are usually irrelevant when describing a fundamental algorithm: What matters are certain abstract properties of the data. If these properties are precisely specified, then the algorithm can be written so that it is as general as possible -- it can operate on every type and every structure for which the operation itself could sensibly be defined. Most importantly, a generic algorithm can be written so that it is no less efficient than if it had been written for one specific data structure. </p>

<p>Consider a linear search, for example. Given a range of elements, we are to find the first element that is equal to a particular value. </p>

<p>The basic outline of the algorithm is immediately obvious: Step through the range, from beginning to end, testing each element to see if it is equal to the desired value. If it is, then return; if not, advance to the next element. If there is no next element, then return some indication of failure. </p>

<p>This general description leaves some details of the interface unspecified. If you are searching for a particular <i>int</i> in an array of <i>int</i>s, then <i>find1</i> (see <a name="rl1"><a href="9708a.htm#l1">Listing One</A> is one plausible implementation. The first argument, <i>first</i>, points to the beginning of the array, and the second argument, <i>last</i>, points one element past the end of the array. The third argument, <i>value</i>, is the value to be searched for. The return value is a pointer to the first element that is equal to <i>value</i>; if there is no such element, then the return value is <i>last</i>. </p>

<p>This interface relies on a C/C++ "past-the-end" pointer. That is, if <i>A</i> is an array with <i>n</i> elements, then <i>A+n</i> is a valid pointer even though it does not actually point to anything. (The elements of <i>A</i> are <i>A[0]</i> through <i>A[n-1]</i>.) Because of this rule, you can specify ranges in the asymmetric form [<i>first, last</i>), meaning everything from <i>first</i> up to, but not including, <i>last</i>. This rule makes it possible for <i>find1</i> to use <i>last </i>as an indicator of failure, and it makes it possible for <i>find1</i> (and other algorithms) to treat empty ranges the same way as nonempty ranges. A function like <i>find1 </i>is useful, and most of us have written something of the sort. The trouble, though, is precisely that most of us have had to write something of the sort. The Standard C Library contains a function, <i>strchr,</i> that is similar to <i>find1</i>. <i>strchr</i>, though, can only be used to find an element in an array of <i>char</i>, just as <i>find1</i> can only be used to find an element in an array of <i>int</i>s. <i>strchr</i> can't be used for the related problem of finding an element in an array of unsigned <i>char</i>s. </p>

<p>The STL generalizes <i>find1</i> to <i>find</i>; see <a name="rl2"><a href="9708a.htm#l2">Listing Two</A>. This is no longer C, but C++. Superficially, <i>find</i> looks similar to <i>find1</i>. And, in fact, if <i>find</i>'s first two arguments are of type <i>int*</i> and the third is of type <i>int</i>, then <i>find</i> and <i>find1</i> are equivalent. </p>

<p>This generic version of <i>find</i> uses C++'s template mechanism: The formal generic types <i>InputIterator</i> and <i>T</i> represent whatever types <i>find </i>was called with, just as the variables <i>first</i>, <i>last</i>, and <i>T</i> represent the values that <i>find</i> was called with. Pursuing this analogy further: If you call a function twice, its arguments need not have the same values both times. Similarly, if you call <i>find</i> twice, you need not call it with the same types both times. The C++ compiler will automatically create as many instances of <i>find</i> as necessary. </p>

<p>This process of template instantiation takes place at compile time; it does not involve any run-time dispatching, and it does not incur any run-time overhead. If you call <i>find</i> once with arguments of type <i>int*</i> and once with arguments of type <i>char*</i>, then it is as if you had written two versions of <i>find</i> and included both of them in your program. </p>

<h3>Iterators</h3>

<p><i>find</i> is clearly more general than <i>find1</i>: <i>find1</i>'s first two arguments must be of type <i>int*</i>, while <i>find</i>'s first two arguments may be of any pointer type. However, <i>find</i> is more general than may immediately be apparent. In C, operators like * are defined only for a fixed set of built-in types: If <i>x</i> is of type <i>struct X</i>, then in C, an expression like <i>*x</i> is meaningless. In C++, however, this restriction has been removed. In C++, you can overload operators on user-defined types. The expression <i>*x</i> is a syntactic convenience, equivalent to calling an ordinary function. (Specifically, it is equivalent to calling a member function named <i>X::operator*()</i>.) </p>

<p>C++'s <i>Iostream</i> library is the most familiar example of operator overloading: The expression <i>cout &lt;&lt; x</i> means to write the value of <i>x</i> to a stream. Operator overloading also enables "smart pointer" classes -- objects that are similar to pointers but that have some additional or alternate functionality. </p>

<p><i>find</i>, then, may be used not only with pointers, but also with any type that "looks like" a pointer -- any type that provides the same sort of operations that pointers do. It may, for example, be used to find an element in a linked list of nodes: All that is necessary is a class that has a single data member, a pointer <i>p</i> to the current node, and a member function <i>operator++()</i> that performs the operation <i>p = p-&gt;next</i>. If <i>operator++()</i> is declared to be inline, then using <i>find</i> should be no less efficient than writing a loop and stepping through the list by hand.</p>

<p>What is significant about <i>find</i> -- what makes it a truly generic algorithm -- is that it does not assume any specific representation for the data it operates on: It only relies on an interface for stepping through and examining elements. This interface could have involved functions with names like <i>get()</i>, <i>set()</i>, and <i>next()</i>. In the STL, however, the interface was instead chosen to be that of pointer operations, partly for the sake of familiarity, but, more importantly, to make it possible to use <i>find</i> with ordinary, unmodified pointers. Even in an age of fancy classes and data structures, pointers still matter! </p>

<p>At this point, however, all this talk about the interface that <i>find</i> uses has been vague. Unless you are specific about an interface, it is useless to say that you are programming to that interface. The interface is implicit in <a href="9708a.htm#l2">Listing Two</A>, and in <a name="rf1"><a href="9708af1.htm">Figure 1</A> it is made explicit. </p>

<p>All of the requirements in <a href="9708af1.htm">Figure 1</A>, except the fourth, deal specifically with the type <i>InputIterator</i>. The fourth expresses a relationship between the two types <i>InputIterator</i> and <i>T</i>. This suggests a different way of expressing <i>find</i>'s type requirements: dividing them into the requirements on <i>InputIterator</i>, the requirements on <i>T</i>, and the requirements that involve both template parameters. </p>

<p>The requirement on <i>T</i> is simply that equality is defined on objects of type <i>T</i>. The requirements on <i>InputIterator</i>, however, are more interesting. <a href="9708af1.htm">Figure 1</A> only describes four requirements on the type <i>InputIterator</i>. That is, <i>find</i> does not rely on the entire set of pointer operations, but only on an extremely restricted and stylized subset. </p>

<p>This interface is significant because <i>find</i> is not the only algorithm that relies on it; restrictive as it is, it is sufficient for many different algorithms. We call this set of requirements a "concept" -- in this case, the "Input Iterator" concept. If a type satisfies all of these requirements, we say it is a "model" of that concept. </p>

<p>The STL defines other Iterator concepts in addition to Input Iterator: It is possible to express <i>find</i> solely in terms of the operations listed in the Input Iterator requirements, but other algorithms, such as <i>sort</i>, cannot be expressed in terms of such a minimal set of operations. Sorting a range of elements requires being able to modify the element that an iterator points to, and it requires arbitrary access to elements, instead of purely sequential access; that is, it requires operations like <i>*p = x </i>and <i>*(p + n)</i>. The Input Iterator concept includes neither of those operations, but a different iterator concept -- Random Access Iterator -- includes both. </p>

<p>The relationship between Input Iterator and Random Access Iterator is essentially hierarchical: If a type <i>I</i> is a model of Random Access Iterator, then it must also be a model of Input Iterator. This is not the hierarchy of class inheritance, however, since neither Input Iterator nor Random Access Iterator is a class. It is a hierarchy of concepts, and we use the term "refinement" to describe it.</p>

<p>In addition to these two Iterator concepts, the STL includes: Forward Iterator, a refinement of Input Iterator and Output Iterator; Bidirectional Iterator, a refinement of Forward Iterator; and Random Access Iterator, a refinement of Bidirectional Iterator.</p>

<h3>Containers</h3>

<p>Generic algorithms naturally lead to the iterator concepts; the next step is to provide a set of types that model those concepts. We already have iterators that traverse built-in C arrays -- pointers. An obvious generalization is to provide additional data structures, then provide iterators that traverse those new data structures. </p>

<p>The STL defines several concepts that describe data-structure requirements, the most general of which is Container. All STL Container classes are models of Container, so, as in the case of Iterators, the basic Container concept provides as minimal an interface as possible.</p>

<p>All STL containers do two basic things. First, they contain elements. Containers always "own" the objects they contain, just as C arrays do. When an array is destroyed, all of the elements in the array are also destroyed; the same is true of any type that models Container. Second, an STL Container provides iterators that point to its elements. Algorithms access those Iterators using the member functions <i>begin()</i> and <i>end()</i>. If <i>X</i> is a model of Container and <i>x</i> is of type <i>X</i>, then an algorithm that proceeds from <i>x.begin()</i> up to (but not including) <i>x.end()</i> will pass through each of <i>x</i>'s elements exactly once. </p>

<p>In principle, the Container interface need not include anything more than that. For convenience, however, it is actually slightly richer. For example, it also includes the member function <i>size()</i>. Strictly speaking, <i>size()</i> is redundant, since the size of a container <i>x</i> is just the distance between the iterators <i>x.begin()</i> and <i>x.end()</i>. </p>

<p>Container is a very general concept: Almost any user-defined data structure that contains a homogeneous collection of objects can be defined so that it models Container. All of the container classes in the STL, however, are models of either Sequence or Associative Container, both of which are refinements of Container. </p>

<p>A Sequence is a dynamically sized Container: It permits insertion, modification, and erasure of elements at any position, and it automatically performs any necessary memory management. An Associative Container is also dynamically sized, but it does not permit unrestricted insertion and erasure. Instead, it provides an efficient mechanism for finding an element in terms of some key. </p>

<p>Both Sequences and Associative Containers are familiar ideas (although possibly under different names) from other programming languages and other C++ libraries. STL Containers differ from their predecessors, however, in two ways. First, Containers are models of generic concepts; this makes it possible to write an algorithm solely in terms of (say) the Sequence interface, without needing to know whether the algorithm's argument is a <i>vector </i>or a <i>deque. </i></p>

<p>Second, and more important, STL Containers provide only a minimal set of operations for manipulating their elements. The operation of a linear search, for example, is not a member function. Instead, it has been factored out into the stand-alone algorithm <i>find</i>. This means that there is no need to rewrite a linear search for every new container class: The existing STL algorithm <i>find</i> will work with any class that conforms to the Container interface and that provides iterators that conform to the Input Iterator interface. </p>

<p>It is the idea of writing algorithms in terms of concepts, rather than as member functions of Container classes, that enables interoperability between existing components and new components. </p>

<h3>Function Objects and Adapters </h3>

<p>Many algorithms can be written solely in terms of containers and iterators. Sometimes, however, this is still not enough for full generality. Again, consider the problem of a linear search. While the algorithm <i>find</i> can be used to find the first integer in a range that is equal to 18, it can't be used to find the first integer that is less than zero. The most general statement of the problem of linear search is finding the first element that satisfies some condition; <i>find</i>, however, only deals with the special case where that condition happens to be equality. </p>

<p><i>find</i> is parameterized by the type of the object being searched for, and by the way that these objects are organized into a range. The way to make it more general is to parameterize it, additionally, by the condition we are searching for. </p>

<p>In C, you would make one of <i>find</i>'s arguments a function pointer, but in C++ (see <a name="rl3"><a href="9708a.htm#l3">Listing Three</A>) there is a better way. The template parameter <i>Predicate</i> represents a new concept. <i>Predicate</i> is a model of Predicate, a kind of "function object" -- any object that can be called as if it were a function (specifically, anything for which the function call operation, <i>operator()()</i>, is defined. <i>operator()()</i>, like other operators, can be overloaded). </p>

<p>How can you use <i>find_if</i> to find the first negative element in a <i>vector&lt;int&gt;</i>? The most obvious way is to write a function <i>negative </i>that takes a single element of type <i>int</i> and returns a <i>bool</i>. This function would be used as: <i>find_if(V.begin(), V.end(), negative);</i>.</p>

<p>The third argument is of type <i>bool (*)(int)</i>, which is a model of Predicate. Using <i>find_if</i> in this manner is straightforward, but unnecessarily cumbersome: It is always better to reuse code than to rewrite it, and using an algorithm shouldn't require writing special-purpose "glue" functions. </p>

<p>The STL includes several predefined Function Objects; one is the template struct <i>less&lt;T&gt;</i>, which takes two arguments of type <i>T</i> and returns <i>true </i>if the first argument is less than the second. This is not the sort of Function Object we need (<i>find_if</i> requires a function object that takes a single argument), but it can be used as follows: <i>find_if(V.begin(), V.end(), bind2nd(less&lt;int&gt;(), 0));</i>.</p>

<p>bind2nd is an example of an adapter: something that converts one interface to another. In this case, <i>bind2nd</i>'s first argument is a Function Object that takes two arguments, and <i>bind2nd</i>'s return value is a Function Object that takes a single argument. The return value is a Function Object <i>F</i> with the property that <i>F(n)</i> is equivalent to <i>less&lt;int&gt;()(n,0)</i>. </p>

<p>The notion of converting one interface into another applies to many sorts of interfaces, not just Function Objects. In addition to Function-Object adapters, the STL also includes Iterator adapters and Container adapters. </p>

<h3>Documenting the STL</h3>

<p>The STL is organized around concepts: The most important property of any type, whether it is an Iterator, Container, or Function Object, is how it fits in to the STL's conceptual hierarchy. Similarly, one of the most important properties of any STL algorithm is the set of the permissible types of its arguments. This is especially important when writing new algorithms and data structures, since the STL guarantees interoperability of components if, and only if, the types model the appropriate concepts. </p>

<p>Imagine a language that supports concepts directly. In this hypothetical language, just as a variable is declared to be of some specified type, a type could be declared to be a model of some specified concept. This language isn't C++, though. There is no way to declare, in C++, that a concept name like <i>InputIterator</i> stands for a specific set of requirements: The template parameters in <a href="9708a.htm#l3">Listing Three</A> are named <i>InputIterator</i> and <i>Predicate,</i> but these names are not special to the compiler. The compiler has no way of knowing that a template parameter must satisfy the <i>InputIterator</i> requirements just because it is called <i>InputIterator</i>. </p>

<p>Concepts are just as real a part of the STL as classes, but they cannot be expressed within the C++ language. Since concepts can exist solely as part of the documentation, the documentation must, to some extent, take the place of code. This places unusual burdens on the documentation. An example of how to document a generic library is the hypertext documentation included with the SGI Standard Template Library (available at http://www.sgi.com/Technology/STL/). </p>

<p>The documentation of each generic algorithm and generic class describes which concept each template parameter must model. The page that documents <i>find_if</i>, for example, says that its template parameters must be models of, respectively, Input Iterator and Predicate, and it has hyperlinks to the pages that document those two concepts.</p>

<p>Fundamentally, documenting a concept means describing the properties that a type must have if it is to be a model of the concept; the central part of this description is a list of valid expressions involving that type. This list must also describe any other types that are mentioned in these expressions. If <i>X</i> is a model of Input Iterator, for example, then some of the expressions in the Input Iterator requirements involve not just <i>X</i> but also <i>X</i>'s value type. Finally, since STL concepts form a hierarchy, each concept's documentation also specifies which concept or concepts it is a refinement of. </p>

<h3>Algorithmic Improvements</h3>

<p>The reference manual for the original "STL" (A.A. Stepanov and M. Lee, "The Standard Template Library." Hewlett-Packard technical report HPL-95-11(R.1), 1995) describes 67 generic algorithms. The SGI STL documents three algorithms, <i>uninitialized_copy</i>, <i>uninitialized_fill</i>, and <i>uninitialized_fill_n</i>, that were present but undocumented in the HP implementation. It also adds five completely new algorithms: <i>iota</i>, <i>is_sorted</i>, <i>is_heap</i>, <i>random_sample</i>, and <i>random_sample_n</i>. </p>

<p>The first three of these new algorithms are simple, but nevertheless useful: <i>iota</i> fills a range with consecutively ascending numbers, and <i>is_sorted</i> and <i>is_heap</i> test, respectively, whether a range is sorted in ascending order and whether it satisfies the heap condition. The latter is particularly important because the STL contains several algorithms that operate only on valid heaps: <i>is_heap</i> makes it possible to verify that a range satisfies these algorithms' preconditions. </p>

<p>The algorithms <i>random_sample</i> and <i>random_sample_n</i> are complementary to the algorithm <i>random_shuffle</i> from the original STL. <i>random_shuffle</i> randomly rearranges a range of elements. This is a common operation. Another common operation, however, is selecting an unbiased sample of <i>m</i> elements from an input range of <i>N</i> elements. One way to obtain an unbiased sample is to permute the input range with <i>random_shuffle</i>, then copy the first <i>m</i> elements. However, this method isn't always possible (what if the input range is immutable?). Even when it is possible, it is extremely wasteful. <i>random_sample</i> and <i>random_sample_n</i> implement unbiased random selection directly and efficiently. </p>

<p>In addition to the new algorithms, the SGI STL contains a major improvement in the <i>sort</i> algorithm. The original STL implemented <i>sort</i> in terms of quicksort. This was a reasonable choice: Quicksort is widely used, and it is one of the best general-purpose sorting algorithms. Quicksort's average run time is O(<i>N</i> <i>log</i> <i>N</i>). In this it is not unusual (heapsort and mergesort, for example, are also O(<i>N</i> <i>log</i> <i>N</i>)), but quicksort can be implemented with an extremely simple inner loop, and is thus significantly faster than other O(<i>N</i> <i>log</i> <i>N</i>) methods. </p>

<p>Despite this, quicksort has a serious flaw: It is fast on average, but its worst-case behavior is poor. For certain input sequences, quicksort becomes quadratic -- its average complexity is O(<i>N</i> <i>log</i> <i>N</i>), but its worst-case complexity is O(<i>N</i><sup>2</sup>). Na&iuml;ve implementations of quicksort, in fact, are quadratic when the input range is already sorted -- an important special case. The original HP implementation used the "median of three" improvement, which means that it exhibited quadratic behavior for different (and presumably less common) input sequences, but the danger of quadratic behavior was still present. </p>

<p>The SGI STL implements <i>sort</i> in terms of "Introsort," rather than quicksort. Introsort, developed by D.R. Musser, is similar to quicksort. It has an equally simple inner loop, and is as fast as quicksort for almost all input sequences; it is never more than a few percent slower. Introsort, however, has the property that its complexity is always O(<i>N</i> <i>log</i> <i>N</i>). Unlike quicksort, introsort is suitable for applications where it is important to have a guaranteed upper bound on complexity. </p>

<p>Several other algorithms, including <i>copy</i> and <i>lexicographical_compare</i>, have been tuned for better performance. By far the most important algorithmic improvement, however, is the new implementation of <i>sort</i>. </p>

<h3>New Container Classes </h3>

<p>The original STL had seven Container classes: <i>vector</i>, <i>list</i>, <i>deque</i>, <i>set</i>, <i>map</i>, <i>multiset</i>, and <i>multimap</i>. The first three of these are Sequences, and the latter four are Associative Containers. </p>

<p>While it is correct to call <i>set, map, multiset,</i> and <i>multimap</i> Associative Containers (all four classes are models of the concept Associative Container), it is also misleading. They are actually a special kind of Associative Container: They are all models of the concept Sorted Associative Container, which is a refinement of Associative Container. Every Associative Container associates values with keys, and provides an efficient way of finding a value given its key. Sorted Associative Containers, however, have the additional property that their elements are always sorted by key in ascending order. </p>

<p>Sorted Associative Containers are useful, and the invariant of ascending order is sometimes important. Associative Containers that are not sorted, however, are also useful, and their absence from the original STL was a serious omission. The SGI STL has four additional Container classes -- <i>hash_set</i>, <i>hash_map</i>, <i>hash_multiset</i>, and <i>hash_multimap</i> -- that are models of Associative Container, but not of Sorted Associative Container. </p>

<p>The new Associative Containers are based on hash tables. The hash function (a function object) is a template parameter; the default is the function object <i>hash&lt;T&gt;</i>, which is defined for all integral types and for <i>char*</i>. <a name="rl4"><a href="9708a.htm#l4">Listing Four</A> shows how a hash table can be used. </p>

<p>The main reason for using a <i>hash_map</i> instead of a <i>map</i> is efficiency. The performance of hash tables depends on the hash function; with a reasonable choice of hash function, a <i>hash_map</i> is, on average, several times faster than a <i>map</i>. </p>

<p>Another major omission from the original STL was singly linked lists. The STL class <i>list</i> is doubly linked: Each node has a link both to its successor and its predecessor. Again, there is no denying that doubly linked lists are useful. Because <i>list</i> is doubly linked, <i>list</i>'s iterators are models of Bidirectional Iterator -- they can be decremented as well as incremented. This makes <i>list</i> more flexible than if it were singly linked, since some algorithms require the ability to step backwards.</p>

<p>As every Lisp programmer knows, however, singly linked lists are perfectly adequate for many purposes. And in those cases where a singly linked list is adequate, using a doubly linked list is a mistake. Doubly linked lists use more memory than singly linked lists (one additional pointer per node), and operations that modify the list structure are slower. Inserting or erasing a node in a doubly linked list requires twice as many pointer assignments as performing the same operation in a singly linked list. </p>

<p>Both singly and doubly linked lists are important data structures. The SGI STL includes both the doubly linked list class <i>list</i> and the singly linked list class <i>slist</i>. </p>

<h3>Thread Safety </h3>

<p>Threads are not part of the C++ language: The draft C++ standard says nothing at all about threads or concurrency. Nevertheless, most modern C++ programs run in multithreaded environments; multiprocessor systems, where each thread could potentially run on a different CPU, are becoming common. (This is an especially important issue for SGI, since most of SGI's recent products are multiprocessor systems.) </p>

<p>The danger inherent in multithreaded programs is that a data structure can be put in an inconsistent state if two different threads try to modify it simultaneously. The solution is well known: If any data structure is shared between two threads, then each thread must acquire a lock before it modifies the data and must release the lock afterward. As far as the STL is concerned, the question is simply how much of this synchronization mechanism should be implemented in library code and how much should be left to the user. </p>

<p>One option that seems attractive is to have the library handle all concurrency issues automatically, and to leave nothing at all to the user. So, for example, two threads could both insert elements into the same map, and the library would automatically perform the necessary locking and serialization so that no two insertions happened simultaneously. </p>

<p>It's entirely possible to write such a library; the only problem is that nobody would want it. First, even in multithreaded programs, many Containers simply don't need to be shared between threads. A particular <i>vector </i>might, for example, store information that only a single thread needs to access. In an implementation that automatically managed concurrency, however, there would be overhead associated with every use of each Container, regardless of whether that Container is actually shared. This overhead is substantial: Every member function, including trivial one-line inline member functions, would have to acquire and release a lock. Since lock acquisition is expensive on most operating systems, this could lead to programs that run an order of magnitude slower. </p>

<p>Second, even for programs that do need to share Containers between threads, automatic locking by Containers' member functions is the wrong way to do it. The problems are apparent even in a simple example like <i>V[1]=V[0];</i>. If the library did automatic locking, then it would acquire a lock for <i>V, </i>read the value in <i>V[0]</i>, release the lock, acquire a new lock, write the value in to <i>V[1]</i>, and then release the second lock. This is both inefficient and unreliable because it acquires two locks instead of one, and unreliable because <i>V</i> might be modified in between the release of the first lock and the acquisition of the second. </p>

<p>It is impossible for a library to guarantee that programs that use it will manage concurrency correctly; a thread-safe library is one that makes it possible for users to write thread-safe programs. That is, if a program is written so that no thread tries to use an STL Container object at the same moment that another thread is modifying it, then the library must guarantee that the program will behave correctly. </p>

<p>This is not as trivial a condition as it might seem. It means that the implementation of STL Containers must not involve any objects that are shared between two different containers, unless those shared objects are protected by explicit locking within the library. The HP STL does not satisfy this condition: It contains unprotected shared data, and it is therefore not thread safe. In several places, this use of shared memory is unnecessary. </p>

<p>First, three of the STL algorithms (<i>stable_sort</i>, <i>stable_partition</i>, and <i>inplace_merge</i>) require temporary auxiliary storage; the HP STL used a single global buffer for auxiliary storage, which meant that all three of these algorithms were unreliable in multithreaded programs. In the SGI STL, that global buffer has been replaced by dynamically allocated memory; this has no measurable effect on the speed of those algorithms, but makes it possible to use them safely in multithreaded programs. </p>

<p>Second, the STL's Sorted Associative Containers (<i>set</i>,<i> map</i>, <i>multiset</i>, and <i>multimap</i>) are implemented in terms of red-black trees. Red-black trees need some way to represent a nonexistent node -- the child of a node that has no children. The most straightforward representation (the one found in both the HP STL and <i>Introduction to Algorithms</i>, by T.H. Cormen, C.E. Leiserson, and R.L. Rivest, MIT Press, 1990) is to use a special sentinel node. This representation makes the code that rebalances trees somewhat simpler than it would be otherwise. Unfortunately, it also means that the red-black trees in the HP STL are not thread safe. This sentinel node is shared between every tree of the same type, and the rebalancing code uses the sentinel to store temporary bookkeeping information. Two different trees, running in two different threads, could interfere with each other disastrously. </p>

<p>The SGI STL eliminates this possibility by replacing the sentinel node with a null pointer. This requires modifications to all of the operations that rebalance the tree, and the new code is more complicated than the old. As it happens, though, the new code also turns out to be slightly faster. </p>

<p>Finally, there is one important area where shared data cannot be avoided -- memory allocation. </p>

<h3>Memory Allocation </h3>

<p>C++ programs that use many small dynamically allocated objects should not allocate them by calling <i>new</i> for each object. Consider, for example, the STL Container <i>list</i>. A <i>list</i> consists of many list nodes, each of which points to its predecessor and to its successor. As <a name="rl5"><a href="9708a.htm#l5">Listing Five</A> shows, <i>list</i> requires a new node for each new element; this new node is returned by <i>list</i>'s private member function <i>get_node</i>. How should <i>get_node</i> be implemented? </p>

<p>It would be inefficient to call <i>new</i> each time a new node is requested. It would waste space, since the run-time system must keep track of each chunk of memory allocated by <i>new</i>, and it would be unnecessarily slow, since <i>new</i> is typically an expensive operation. The solution to this problem has been known for years, and is discussed, among other places, in <i>The C++ Programming Language</i>, Second Edition, by Bjarne Stroustrup (Addison-Wesley, 1991). A program that needs to allocate many small nodes should manage its own specialized memory pool: It should use <i>new</i> or <i>malloc</i> only to obtain large chunks of memory, and should allocate the nodes from that pool rather than directly from the heap. Most STL implementations use some variation of this optimization. The details, however, are crucial both for thread safety and for efficient memory usage. The important issues are how many memory pools there are, and which part of the library is responsible for maintaining them and obtaining nodes from them. </p>

<p>One possibility would be for each <i>list</i> object to maintain its own memory pool. A <i>list</i> might, for example, automatically allocate enough space for a thousand nodes as it is created. The advantages of this scheme are obvious: It is simple, fast, and, since it involves no data shared between multiple objects, is inherently thread safe. The disadvantage is equally obvious: It wastes an enormous amount of memory, since every <i>list, </i>even one with very few elements, must maintain a large pool. </p>

<p>A more realistic implementation is for the <i>list</i> class, rather than each <i>list</i> object, to maintain a memory pool. Every object of class <i>list&lt;int&gt;</i> shares one pool of nodes, every object of class <i>list&lt;double&gt;</i> shares another pool, and so on. <a name="rl6"><a href="9708a.htm#l6">Listing Six</A> shows the implementation of <i>get_node</i> using this scheme. <i>get_node</i> returns a node from the pool, unless the pool is empty; if it is empty, then <i>get_node</i> calls <i>add_new_buffer</i>, which uses a "page allocator" to obtain a new block of memory. The page allocator, in turn, calls <i>new</i> or <i>malloc</i>. </p>

<p>The page-allocator scheme is adequate, and is, in fact, used in the original HP implementation of the STL. However, it suffers from two defects. First, it can lead to memory fragmentation. A program with many different instantiations of Container templates will waste a great deal of memory. Second, the implementation of <i>get_node</i> in <a href="9708a.htm#l6">Listing Six</A> is not thread safe, since every object of type <i>list&lt;T&gt;</i> shares the same pool. Modifying it to be thread safe wouldn't be particularly straightforward, especially since the equivalent function in every other Container class would also have to be modified.</p>

<p>Fundamentally, both of these defects result from the fact that the process of allocating a new node is divided between the <i>list'</i>s page allocator and the <i>list </i>itself. The solution, then, is to replace the page allocator with a "node allocator" -- an allocator that both obtains blocks of memory from the operating system, and manages pools of nodes. As <a name="rl7"><a href="9708a.htm#l7">Listing Seven</A> shows, using node allocators is far less complicated than using page allocators. The implementation of <i>get_node</i> in <a href="9708a.htm#l7">Listing Seven</A> does nothing more than request a new node from the allocator.</p>

<p>The node-allocator scheme clearly prevents memory fragmentation. The pool of free nodes is maintained by the allocator, rather than by the <i>list</i>, so the pool is shared between every Container class that uses the allocator. There is a single pool, rather than one for every Container type. </p>

<p>Thread safety is still an issue, since node allocators do not eliminate shared data: Every Container must be able to access the pool of free nodes. This access, however, is always through the node allocator. The free-memory pool is the only shared data in the library, and only the node allocator accesses the pool directly, so no library component (other than the node allocator) need concern itself with acquiring and releasing locks. </p>

<p>Finally, since only the allocator explicitly manages concurrency, it is possible to provide an elegant way for programs with only a single thread to avoid the overhead of thread safety. Container classes are parameterized by their allocators -- one of a Container's template parameters is its allocator type. The default allocator is thread safe, but the library also contains a faster allocator, <i>single_client_alloc</i>, that is suitable for single-threaded programs. </p>

<h3>The Future </h3>

<p>The STL is not merely a collection of containers and algorithms, but a conceptual framework for fundamental algorithms and data structures. Extensibility has always been a central design goal of the STL. The SGI Standard Template Library is a crucial first step toward this goal, and serves as a model for extending the STL. But there are still entire categories of fundamental algorithms that have not yet been addressed. Some of the most important omissions are graph algorithms, pattern matching, multidimensional data structures, and persistence. </p>

<p>SGI will continue to extend and enhance the STL, and will serve as a clearinghouse for suitable components that others wish to contribute. The STL will not merely be a static body of code, but will be a growing collection of efficient and interoperable software components. </p>
<HR>
<H4><a name="l1">Listing One</H4>

<pre>int* find1(int* first, int* last, int value) { 
   while (first != last &amp;&amp; *first != value) 
      ++first; 
   return first; 
} 
</pre>
<P>
<a href="#rl1">Back to Article</A>
</P>
<H4><a name="l2">Listing Two</H4>

<pre>template &lt;class InputIterator, class T&gt; InputIterator find(InputIterator first, InputIterator last, const T&amp; value) 
{ 
   while (first != last &amp;&amp; *first != value) 
     ++first; 
   return first; 
} 
</pre>
<P>
<a href="#rl2">Back to Article</A>
</P>
<H4><a name="l3">Listing Three </H4>

<pre>template &lt;class InputIterator, class Predicate&gt; InputIterator find_if(InputIterator first,InputIterator last,Predicate pred) 
{ 
   while (first != last &amp;&amp; !pred(*first)) 
       ++first; 
   return first; 
} 
</pre>
<P>
<a href="#rl3">Back to Article</A>
</P>
<H4><a name="l4">Listing Four</H4>

<pre>#include &lt;hash_map.h&gt; #include &lt;stdio.h&gt; 
struct eqstr { 
   bool operator()(const char* s1, const char* s2) const { 
     return strcmp(s1, s2) == 0; 
   } 
}; 
int main() 
{ 
   hash_map&lt;char*, int, hash&lt;char*&gt;, eqstr&gt; days; 
   days["January"] = 31; 
   days["February"] = 28; 
   days["March"] = 31; 
   days["April"] = 30; 
   days["May"] = 31; 
   days["June"] = 30; 
   printf("%s has %d days\n", "March", days["March"]); 
   return 0; 
} 
</pre>
<P>
<a href="#rl4">Back to Article</A>
</P>
<H4><a name="l5">Listing Five </H4>

<pre>iterator insert(iterator position, const T&amp; x) {   link_type tmp = get_node(); 
  construct(&amp;((*tmp ).dat a), x); 
  (*tmp).next = position.node; 
  (*tmp).prev = (*position.node).prev; 
  (*(link_type((*position.node).prev))).next = tmp; 
  (*position.node).prev = tmp; 
  ++length; 
  return tmp; 
} 
</pre>
<P>
<a href="#rl5">Back to Article</A>
</P>
<H4><a name="l6">Listing Six</H4>

<pre>link_type get_node() {   link_type tmp = free_list; 
  return free_list 
      ? (free_list = (link_type)(free_l ist- &gt;next ), tmp) 
      : (next_avail == last ? (add_new_buffer(), next_avail++) 
                              : next_avail++); } 
</pre>
<P>
<a href="#rl6">Back to Article</A>
</P>
<H4><a name="l7">Listing Seven</H4>

<pre>link_type get_node() {    return list_node_allocator::allocate( ); 
} 
</pre>
<P>
<a href="#rl7">Back to Article</A>
</P>

<p><b>DDJ</b></p>

<HR><I>Copyright &copy; 1997, Dr. Dobb's Journal</I><BR>

</BODY>
</html>
