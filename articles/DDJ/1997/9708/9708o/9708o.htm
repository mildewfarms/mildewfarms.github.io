<html>
<META NAME="year" CONTENT="1997">
<head>
<title>Dr. Dobb's Journal August 1997: ATL and the <i>IUnknown</i> Interface</title>
</head>

<body bgcolor="FFFFFF">
<!--Copyright &#169; Dr. Dobb's Journal-->
<h1>ATL and the <i>IUnknown</i> Interface</h1>

<p><i>Dr. Dobb's Journal</i> August 1997
</p>
<h3>By George Shepherd and Scot Wingo</h3>

<I>Scot is a cofounder of Stingray Software. He can be contacted at ScotWi@aol.com. George is a senior computer scientist with DevelopMentor and can be contacted at 70023.1000@compuserve.com. They are the coauthors of MFC Internals (Addison-Wesley, 1996).</I>

<hr>

<p>COM is like a beautiful, ever-blossoming flower whose seed is the <i>IUnknown</i> interface. Once you grasp fully the intent behind the <i>IUnknown</i> interface, you understand how one of the most important features of COM lies in its extensibility, or the ability of a client to widen the connection to an object arbitrarily through <i>QueryInterface</i>. As an object implementor, this gives you tremendous flexibility for pinning as much or as little functionality on an object as you'd like. In addition to <i>QueryInterface</i>, <i>IUnknown</i>'s <i>AddRef</i> and <i>Release</i> functions are a reasonable way to control an object's lifetime. </p>

<p>Unfortunately, the complex morass of details necessary to get COM objects up and running often overshadows the fundamental beauty of COM. For example, implementing COM classes involves writing a great deal of code that remains the same from one class implementation to another. <i>IUnknown</i> implementations are generally the same for every COM class you encounter -- the main difference between them is the interfaces exposed by each class. But just as you no longer need to understand assembly language to get software working these days, pretty soon, you'll no longer need to understand all the nuances of <i>IUnknown</i> and COM to get your COM-based software up and running. We're not quite there yet, but the Active Template Library (ATL) from Microsoft represents a great first step in that direction.</p>

<p>This month we'll take a look at the heart of ATL, including its support for multithreading and its various implementations of <i>IUnknown</i>.</p>

<h3>ATL Basics</h3>

<p>If you've experimented at all with ATL, you've seen how it simplifies the process of implementing COM classes. The tool support is very good -- it's almost as easy to develop COM classes using the new version of Visual C++ as it is to create MFC-based programs. Just use AppWizard to create a new ATL-based class. However, instead of using ClassWizard (as you would to handle messages and add dialog-box member variables), ATL employs ClassView for adding new functions to the interfaces, then simply fills them in within the C++ code generated by ClassView. AppWizard generates all the necessary code for implementing your class, including an implementation of <i>IUnknown</i>, a server module to house your COM class, and a class object that implements <i>IClassFactory</i>. </p>

<p>Writing COM objects this way is certainly more convenient than most other methods. But just what is happening when you press those buttons? Understanding how ATL works is important if you want to extend your ATL-based COM classes and servers much beyond what AppWizard and ClassView provide. For example, ATL provides support for advanced interface techniques like tear-off interfaces. Unfortunately, there's no Wizard option for implementing a tear-off interface. Even though ATL supports it, you've got to do a little work by hand. Understanding how ATL implements <i>IUnknown</i> is very helpful in this situation.</p>

<p>Let's start by looking at a minimal COM class. Using the Insert|New ATL Object menu to generate an ATL-based COM class yields the class in <a name="rl1"><a href="9708o.htm#l1">Listing One</A> While this is ordinary vanilla C++ source code, it does differ from normal C++ source code for implementing a COM object in several ways. For example, while many COM class implementations derive strictly from COM interfaces, this COM class derives from several templates. In addition, this C++ class uses several odd-looking macros. As we examine the code, we'll look at ATL's implementation of <i>IUnknown</i>, as well as a few other interesting topics like a technique for managing vtable bloat and an uncommon use for templates. We'll begin  by looking at the first symbol in the wizard-generated code ATL_NO_VTABLE.</p>

<h3>Managing VTABLE Bloat</h3>

<p>COM interfaces are easily expressed in C++ as pure abstract base classes. Writing COM classes using multiple inheritance (there are other ways to write COM classes) is merely a matter of adding the COM interface base classes to your inheritance list and implementing the union of all the functions. Of course, this means that the memory footprint of your COM class will include four bytes of <i>vptr</i> overhead for each interface implemented by your class. That's not a big deal if you have only a few interfaces and your C++ class hierarchy isn't that deep, but more interfaces and a deeper hierarchy will add overhead. ATL provides a way to cut down on some of this overhead. ATL defines the symbol <i>#define ATL_NO_VTABLE __declspec(novtable)</i>. </p>

<p>Using ATL_NO_VTABLE prevents an object's <i>vtable</i> pointer (<i>vptr</i>) from being initialized in the constructor. That way the linker eliminates the vtable and all the functions pointed to by the vtable for that class. This can lower the size of your COM object somewhat, provided the most-derived class does not use the <i>novtable declspec</i>. You'll notice the size difference in classes with large derivation lists. There's one caveat: Calling virtual functions from the constructor of any object that uses this <i>declspec</i> is unsafe (because the <i>vptr</i> is uninitialized). </p>

<p>The next line in the class shows that <i>CDefault</i> derives from <i>CComObjectRootEx</i>. This is where we get to ATL's version of <i>IUnknown</i>. </p>

<h3>ATL's <i>IUnknown</i>: <i>CComObjectRootEx</i></h3>

<p>While <i>CComObjectRootEx</i> isn't quite at the top of the ATL hierarchy, it's pretty close. The actual base class for COM objects in ATL is a class named <i>CComObjectRootBase</i> (both these classes are found in ATLCOM.H). Looking at <i>CComObjectRootBase</i> reveals the code you might expect for a C++-based COM class. <i>CComObjectRootBase</i> includes a DWORD member named <i>m_dwRef</i> for reference counting. You'll also see <i>OuterAddRef</i>, <i>OuterRelease</i>, and <i>OuterQueryInterface</i> to support COM aggregation and tear-off interfaces. Looking at <i>CComObjectRootEx</i> reveals <i>InternalAddRef</i>, <i>InternalRelease</i>, and <i>InternalQueryInterface</i> for performing the regular native reference counting and <i>QueryInterface</i> mechanisms for class instances with object identity. </p>

<p>Notice that <a href="9708o.htm#l1">Listing One</A> shows <i>CDefault</i> derived from <i>CComObjectRootEx</i> and that <i>CComObjectRoot</i> is a parameterized template class. Take a moment to examine <a name="rl2"><a href="9708o.htm#l2">Listing Two</A>, which shows the definition of <i>CComObjectRootEx</i>.</p>

<p><i>CComObjectRootEx</i> is a template class that varies given the kind of threading model class passed in as the template parameter. In fact, ATL supports several threading models: Single Threaded Apartments (STAs), Multi Threaded Apartments (MTAs), and Free Threading. ATL includes three preprocessor symbols for selecting the various default threading models for your project. </p>

<p>Defining the preprocessor symbol _ATL_SINGLE_THREADED changes the default threading model to support only one STA-based thread. This option is useful for out-of-process servers that don't create any extra threads. Because the server supports only one thread, ATL's global state may remain unprotected by critical sections, so the server is more efficient. However, the downside is that your server may support only one thread. Defining _ATL_APARTMENT_THREADED for the preprocessor causes the default threading model to support multiple STA-based threads. This is useful for apartment model in-process servers (servers supporting the "ThreadingModel=Apartment" key). Because a server employing this threading model can support multiple threads, ATL protects its global state using critical sections. Finally, defining the _ATL_FREE_ THREADED preprocessor symbol creates servers compatible with any threading environment. That is, ATL protects its global state using critical sections and each object in the server will have its own critical sections to maintain data safety. </p>

<p>These preprocessor symbols merely determine which threading class to plug into <i>CComObjectRootEx</i> as a template parameter. ATL provides three threading model classes. The classes provide support for the most efficient yet thread-safe behavior for COM classes within each of the three aforementioned contexts. The three classes are <i>CComMultiThreadModel</i>, <i>CComSingleThreadModel</i>, and <i>CComMultiThreadModelNoCS</i>. <a name="rl3"><a href="9708o.htm#l3">Listing Three</A> shows these three classes. </p>

<p>Notice that each of these classes exports two static functions, <i>Increment</i> and <i>Decrement,</i> and various aliases for critical sections. </p>

<p>CComMultiThreadModel and <i>CComMultiThreadModelNoCS</i> both implement <i>Increment</i> and <i>Decrement</i> using the thread safe Win32 <i>InterlockedIncrement</i> and <i>InterlockedDecrement</i> functions. <i>CComSingleThreadModel</i> implements <i>Increment</i> and <i>Decrement</i> using the more conventional ++ and --operators. </p>

<p>In addition to implementing incrementing and decrementing differently, the three threading models manage critical sections differently. ATL provides wrappers for two critical sections -- a <i>CComCriticalSection</i> (which is a plain wrapper around the Win32 critical section API) and <i>CComAutoCriticalSection</i> (same as <i>CComCriticalSection,</i> but it automatically initializes and cleans up critical sections). ATL also defines a fake critical section that has the same binary signature as the other critical section classes, but which doesn't do anything. As you can see from the class definitions, <i>CComMultiThreadModel</i> uses real critical sections, while <i>CComMultiThreadModelNoCS</i> and <i>CComSingleThreadModel</i> use the no-op fake critical sections. </p>

<p>So now the minimal ATL class definition makes a bit more sense. Take another look at <a href="9708o.htm#l1">Listings One</A> and Two. <i>CComObjectRootEx</i> takes a thread model class whenever you define it. <i>CDefault</i> is defined using the <i>CComSingleThreadModel</i> class, so it uses the <i>CComSingleThreadModel</i> methods for incrementing and decrementing as well as the fake no-op critical sections. Thus <i>CDefault</i> uses the most efficient behavior, as it doesn't need to worry about protecting data. However, you're not stuck with that model. For example, if you want to make <i>CDefault</i> safe for any threading environment, simply redefine <i>CDefault</i> to derive from <i>CComObjectRootEx</i> using <i>CComMultiThreadModel</i> as the template parameter. <i>AddRef</i> and <i>Release</i> calls are automatically mapped to the correct <i>Increment</i> and <i>Decrement</i> functions.</p>

<p>So in ATL, the class you use when declaring <i>CComObjectRootEx</i> in your hierarchy list determines which version of <i>AddRef</i> and <i>Release</i> to use, as well as whether to use real or no-op critical sections for data protection. That takes care of <i>IUnknown</i> and reference counting in ATL. The next part of <i>IUnknown</i> to tackle is <i>QueryInterface</i>. </p>

<h3>ATL and <i>QueryInterface</i></h3>

<p>It looks as though ATL took a cue from MFC for implementing <i>QueryInterface</i>. ATL uses a lookup table for implementing <i>QueryInterface</i> just like MFC's version. Take a look at the middle of <i>CDefault</i>'s definition -- you'll see a construct based on macros called the "interface map." ATL's interface maps constitute its <i>QueryInterface</i> mechanism.</p>

<p><i>QueryInterface</i> is used by clients to arbitrarily widen the connection to an object. That is, when a client needs a new interface, it calls <i>QueryInterface</i> through an existing interface. The object then looks at the name of the requested interface and compares that name to all the interfaces implemented by the object. If the object implements the interface, the object hands the interface back to the client. Otherwise, <i>QueryInterface</i> returns an error indicating no interface was found. </p>

<p>Traditional <i>QueryInterface</i> implementations usually consist of a long <i>if-then</i> statement. For example, a standard implementation of <i>QueryInterface</i> for a multiple-inheritance COM class might look like the one in <a name="rl4"><a href="9708o.htm#l4">Listing Four</A>. As you'll see, ATL uses a lookup table instead of the conventional <i>if-then</i> statement.</p>

<p>ATL's lookup table begins with a macro named BEGIN_COM_MAP. <a name="rl5"><a href="9708o.htm#l5">Listing Five</A> shows BEGIN_COM_MAP in the raw. Each class that uses ATL for implementing <i>IUnknown</i> specifies an interface map to provide to <i>InternalQueryInterface</i>. ATL's interface maps consist of structures containing interface ID (GUID)/DWORD/function pointer tuples. <a name="rl6"><a href="9708o.htm#l6">Listing Six</A> shows the type named _ATL_INTMAP_ENTRY, which contains these tuples.</p>

<p>The first field is the interface ID (a GUID) and the second field indicates what action to take when the interface is queried. There are three ways to interpret the third member. If <i>pFunc</i> is equal to the constant _ATL_SIMPLEMAPENTRY (the value 1), then <i>dw</i> is an offset into the object. If <i>pFunc</i> is non-NULL but not equal to 1, then <i>pFunc</i> indicates a function to be called when the interface is queried. If <i>pFunc</i> is NULL, then the entry indicates the end of the <i>QueryInterface</i> lookup table.</p>

<p>Notice that <i>CDefault</i> uses COM_INTERFACE_ENTRY. This is the interface map entry for regular interfaces. <a name="rl7"><a href="9708o.htm#l7">Listing Seven</A> is the raw macro. COM_INTERFACE_ENTRY fills the _ATL_INTMAP_ENTRY structure with the interface's GUID (notice the token pasting operator -- ##). In addition, notice how <i>offsetofclass</i> casts the <i>this</i> pointer to the right kind of interface and fills the <i>dw</i> member with that value. Finally, COM_INTERFACE_ENTRY fills the last field with _ATL_SIMPLEMAPENTRY to indicate that <i>dw</i> points to an offset into the class.</p>

<p>For example, the interface map for <i>CDefault</i> looks like <a name="rl8"><a href="9708o.htm#l8">Listing Eight</A> after the preprocessor is done with it. If you look near the middle of <a href="9708o.htm#l5">Listing Five</A>, you'll see that <i>CComObjectRootEx</i>'s implementation of <i>InternalQueryInterface</i> uses the <i>_GetEntries</i> function as the second parameter. <i>CComObjectRootEx::InternalQueryInterface</i> uses a global ATL function named <i>AtlInternalQueryInterface</i> to look up the interface in the map. <i>AtlInternalQueryInterface</i> simply walks the map trying to find the interface.</p>

<p>In addition to COM_INTERFACE_ENTRY, ATL includes 16 other macros for implementing other composition techniques ranging from tear-off interfaces to COM aggregation.</p>

<h3>Conclusion</h3>

<p>ATL is handy because it does away with some of the drudgery of repeatedly implementing <i>IUnknown</i>. Just as MFC gives you a way out of writing the same <i>GetMessage..DispatchMessage</i> loop and gigantic switch statement, ATL provides all the COM boilerplate code you need to implement efficient and appropriately thread-safe COM classes </p>

<p>This month, we looked at ATL's implementation of <i>IUnknown</i> and saw that ATL uses templates to provide versions of <i>AddRef</i> and <i>Release</i> with varying degrees of thread safety. In addition, we saw that ATL uses a <i>QueryInterface</i> mechanism similar to the one MFC uses. However, ATL's lookup table is much more flexible than MFC's because you can compose your COM classes using a wide variety of techniques. In the coming months, we'll examine such topics as ATL's support for Class Objects (the classes that implement <i>IClassFactory</i>), ATL's tear off interfaces, and ATL and aggregation.</p>
<HR>
<H4><a name="l1">Listing One</H4>

<pre>class ATL_NO_VTABLE CDefault :    public CComObjectRootEx&lt;CComSingleThreadModel&gt;,
   public CComCoClass&lt;CDefault, &amp;CLSID_Default&gt;,
   public IDispatchImpl&lt;IDefault, &amp;IID_IDefault, &amp;LIBID_ATLTESTLib&gt;
{
public:
   CDefault() {
   }
DECLARE_REGISTRY_RESOURCEID(IDR_DEFAULT)
BEGIN_COM_MAP(CDefault)
   COM_INTERFACE_ENTRY(IDefault)
   COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()
// IDefault
public:
};
</pre>
<P>
<a href="#rl1">Back to Article</A>
</P>
<H4><a name="l2">Listing Two</H4>

<pre>template &lt;class ThreadModel&gt;class CComObjectRootEx : public CComObjectRootBase
{
public:
   typedef ThreadModel _ThreadModel;
   typedef _ThreadModel::AutoCriticalSection _CritSec;
<p></p>
   ULONG InternalAddRef() {
      return _ThreadModel::Increment(&amp;m_dwRef);
   }
   ULONG InternalRelease() {
      return _ThreadModel::Decrement(&amp;m_dwRef);
   }
   void Lock() {m_critsec.Lock();}
   void Unlock() {m_critsec.Unlock();}
private:
   _CritSec m_critsec;
};
</pre>
<P>
<a href="#rl2">Back to Article</A>
</P>
<H4><a name="l3">Listing Three</H4>

<pre>class CComMultiThreadModelNoCS{
public:
    static ULONG WINAPI Increment(LPLONG p) {return InterlockedIncrement(p);}
    static ULONG WINAPI Decrement(LPLONG p) {return InterlockedDecrement(p);}
    typedef CComFakeCriticalSection AutoCriticalSection;
    typedef CComFakeCriticalSection CriticalSection;
    typedef CComMultiThreadModelNoCS ThreadModelNoCS;
};
class CComMultiThreadModel
{
public:
    static ULONG WINAPI Increment(LPLONG p) {return InterlockedIncrement(p);}
    static ULONG WINAPI Decrement(LPLONG p) {return InterlockedDecrement(p);}
    typedef CComAutoCriticalSection AutoCriticalSection;
    typedef CComCriticalSection CriticalSection;
    typedef CComMultiThreadModelNoCS ThreadModelNoCS;
};
class CComSingleThreadModel
{
public:
    static ULONG WINAPI Increment(LPLONG p) {return ++(*p);}
    static ULONG WINAPI Decrement(LPLONG p) {return --(*p);}
    typedef CComFakeCriticalSection AutoCriticalSection;
    typedef CComFakeCriticalSection CriticalSection;
    typedef CComSingleThreadModel ThreadModelNoCS;
};
</pre>
<P>
<a href="#rl3">Back to Article</A>
</P>
<H4><a name="l4">Listing Four</H4>

<pre>Class CDefault : public IDispatch,                        IDefault {
   HRESULT QueryInterface(RIID riid, 
                          void** ppv) {
      if(riid == IID_IDispatch)
         *ppv = (IDispatch*) this;
      else if(riid == IID_IDefault)
         *ppv = (IDefault*) this;
      else {
         *ppv = 0;
         return E_NOINTERFACE;
      }
      ((IUnknown*)(*ppv))-&gt;AddRef();
      return NOERROR;
   } 
   // AddRef, Release, and other functions
}; 
</pre>
<P>
<a href="#rl4">Back to Article</A>
</P>
<H4><a name="l5">Listing Five</H4>

<pre>#define BEGIN_COM_MAP(x) public:   typedef x _ComMapClass; 
  static HRESULT WINAPI _Cache(void* pv,REFIID iid,void** ppvObject,DWORD dw){
     _ComMapClass* p = (_ComMapClass*)pv;
      p-&gt;Lock();
      HRESULT hRes = 
         CComObjectRootBase::_Cache(pv, iid, ppvObject, dw);
      p-&gt;Unlock();
      return hRes;
   }
   IUnknown* GetUnknown() { 
      _ASSERTE(_GetEntries()[0].pFunc == _ATL_SIMPLEMAPENTRY); 
      return (IUnknown*)((int)this+_GetEntries()-&gt;dw); 
   }
   HRESULT _InternalQueryInterface(REFIID iid, void** ppvObject) { 
      return InternalQueryInterface(this, _GetEntries(), iid, ppvObject); 
   } 
   const static _ATL_INTMAP_ENTRY* WINAPI _GetEntries() { 
      static const _ATL_INTMAP_ENTRY _entries[] = { 
                        DEBUG_QI_ENTRY(x)
   ...
   #define END_COM_MAP()   {NULL, 0, 0}};\
    return _entries;}
</pre>
<P>
<a href="#rl5">Back to Article</A>
</P>
<H4><a name="l6">Listing Six</H4>

<pre>struct _ATL_INTMAP_ENTRY {   const IID* piid;       
   DWORD dw;
   _ATL_CREATORARGFUNC* pFunc; 
}
</pre>
<P>
<a href="#rl6">Back to Article</A>
</P>
<H4><a name="l7">Listing Seven</H4>

<pre>#define offsetofclass(base,derived)((DWORD)(static_cast&lt;base*&gt;((derived*)8))-8)#define COM_INTERFACE_ENTRY(x)\
    {&amp;IID_##x, \
    offsetofclass(x, _ComMapClass), \
    _ATL_SIMPLEMAPENTRY},
</pre>
<P>
<a href="#rl7">Back to Article</A>
</P>
<H4><a name="l8">Listing Eight</H4>

<pre>const static _ATL_INTMAP_ENTRY* __stdcall _GetEntries() {   static const _ATL_INTMAP_ENTRY _entries[] = { 
    {&amp;IID_IDefault, 
    ((DWORD)(static_cast&lt;IDefault*&gt;((_ComMapClass*)8))-8),
    ((_ATL_CREATORARGFUNC*)1)},
    {&amp;IID_IDispatch, 
    ((DWORD)(static_cast&lt;IDispatch*&gt;((_ComMapClass*)8))-8), 
    ((_ATL_CREATORARGFUNC*)1)},
    {0, 0, 0}
  }; 
  return _entries;
}
</pre>
<P>
<a href="#rl8">Back to Article</A>
</P>

<p><b>DDJ</b></p>


<HR><I>Copyright &copy; 1997, Dr. Dobb's Journal</I><BR>

</BODY>
</html>
