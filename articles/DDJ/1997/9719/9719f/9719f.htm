<HTML><HEAD><TITLE>DDJ, Software Careers Fall 97: Wanted: Senior Java Programmers</TITLE></HEAD><body bgcolor="FFFFFF"><H1>Wanted: Senior Java Programmers</H1>Software Careers Fall 1997 <I>Dr. Dobb's Journal</I><H3><I>by Lefteris Kalamaras</I></H3><hr><I>Lefteris is the Java Development Leader for Euro Brokers Inc. He can be contacted at lefteris@ebi.com.</I><hr><IMG SRC="9719fins.gif"  ALIGN=LEFT HSPACE=10 VSPACE=10 ALT="Insert">I was the first person hired for my Java skills at the company I work for. Consequently, during the hiring process, the people I talked to relied upon my previous experience in the financial markets as a C++ programmer, and asked questions related to that field only. It worked for them (I am still here), but it was nevertheless a hit-or-miss situation. <p>It comes as no surprise, since Java is a still young language, that good Java programmers are hard to find and come at a premium (commanding salaries larger than those C++ programmers receive). The September 1996 issue of <I>Dr. Dobb's Journal</I> included a column by Al Stevens entitled "Wanted: Senior C++ Programmer." While Al made some good points about interviewing practices in general, the details of his column didn't help me, since I was looking for Java programmers. Still, Al's article provided a framework for zeroing in on the specifics of what "good" Java programmers should be comfortable with. This article shares the guidelines I've implemented. Hopefully, it will help both managers who want to hire good Java developers, but don't know what questions to ask; and developers looking for a dream job who aren't sure what to expect from interviews.<p>I have developed a set of questions for separating Java programmers into different knowledge levels. These guidelines are by no means set in stone. If you have any criticisms or comments about my plan, I'd love to hear from you.<p>The questions fall into four categories:<p><ul><li>The first category establishes whether applicants have a basic understanding of the language, and how Java relates to C++ and object-oriented programming practices.<li>The second category determines whether an applicant knows what a medium-sized application will require before it can be designed and implemented.<li>The third category determines whether the applicant has a well-rounded knowledge of Java, not only as an application development language, but also as an environment that interfaces with external components such as databases.<li>The fourth category is the "nerd" category. While there are no specific questions applicants can answer, this intangible category still provides a cushion of comfort.</ul>Good candidates will have r&eacute;sum&eacute;s that reflect previous work in Java. Because it's early in the life of Java, you'll be lucky to find programmers with "professional" Java programming experience. Consequently, workplace experience shouldn't yet be a prerequisite. Still, I consider candidates to be senior Java programmers if they can answer all the questions in the first and second categories, most of those in the third category, and perhaps one question from the fourth (as a bonus). Someone who doesn't quite succeed in the interview can still be considered a good (though not senior) Java programmer, but will likely need direct supervision and probably will take on a junior role.<p>I start by asking general questions about the person, based on the r&eacute;sum&eacute;, but I don't spend too much time on specifics. I do generally ask how a candidate liked his previous environment. <p>The general discussion will gradually lead to questions from the first category, which provide a means of moving on to more technical aspects of the interviewee's knowledge and abilities.<p><B>Category One: Basic Java Understanding<p>Q:</B> Apart from a Java background, do you know any C++ or have you been exposed to an object-oriented programming paradigm before?<p><B>A:</B> Yes.<p><p>Senior Java developers should have a solid background in object-oriented languages. C++ is the most common language in use today. If the person has a C++ background, I can move on to the second question:<p><p><B>Q:</B> Do you have an understanding of some of the differences and similarities between C++ and Java?<p><B>A:</B> Yes or No.<p><p>If the answer is "no," then right away we can start discussing some of the differences/similarities, providing points that give you a better understanding of the person's object-oriented background. I talk about some C++ points and try to get the person to tell me why they are similar (or different) to Java. For example, the easiest point is that C++ has a stand-alone <I>main</I> function. When I mention this, I expect the person to respond, "Oh, but in Java, <I>main</I> is part of a class." If they don't, I have an indication to a possibly significant problem. If they do, I can then ask what the signature of <I>main</I> is, in Java. (It's <I>public static void main (String[] args)</I>.)<p>If they have responded "yes," I ease them into describing some of the differences. Avoid a confrontational "list at least three examples." Applicants should have no problem coming up with similarities such as: Both are object-oriented languages, where classes and objects are the main tools for development; both have similar construction mechanisms (constructor for classes). Differences might include: Java does not make use of pointers anywhere, whereas C++ relies heavily on them; Java has garbage collection, C++ does not; there is no <I>delete()</I> method in Java (because of garbage collection and the absence of pointers); Java runs on a Virtual Machine; Java supports multithreading.<p><p><B>Q:</B> Do you recognize the distinctions between a Java application and Java applet?<p><B>A:</B> Yes.<p>There are three important points here:<p><ul><li>Java applications run standalone, applets run under a browser environment.<li>Java applications have a <I>main()</I> function, applets don't.<li>Java applications have no default security manager; applets have the browser's security manager and cannot perform functions such as file I/O.</ul>This is not an exhaustive list of differences, but it is an example of the main points the answer should include.<p><p><B>Q:</B> How big is an <I>int</I> in Java?<p><B>A:</B> An <I>int</I> is four bytes. Ranges are from -231 to 231-1. (Or from -2147483648 to 2147483647, but I digress...)<p>Knowing the size of an <I>int</I> means applicants have come across conversions from other types to <I>int</I>, or vice versa. A little depth is starting to show. Not knowing this is not necessarily terrible either, but it is useful information, since it allows programmers to be less wasteful when selecting the size of types they will use.<p><p><B>Q:</B> Can you give me an example of a default constructor in a simple class that extends the Vector class?<p>  <B>A:</B> Anything that will have at least the following:     <PRE>Class Vector1 extends Vector{...public Vector1(){        // implied call to super()}}</PRE>     This shows that the candidate knows about constructors in Java. They won't necessarily include the call to super(), since that call is implied, but you can ask them about it by saying something like "what is the sequence of code execution when the constructor is called?". They should respond by at least mentioning something about the super() implicit call.<p><B>Q:</B> What is the use of the Java "interface" facility and could you give an example?<p><B>A:</B> From the language specification:<p><p>An interface declaration introduces a new reference type whose members are constants and abstract methods. This type has no implementation, but otherwise unrelated classes can implement it by providing implementations for its abstract methods.<p><p>Java programs can use interfaces to make it unnecessary for related classes to share a common abstract superclass or to add methods to <I>Object</I>. In other words, an interface allows for abstracting methods and constants that would otherwise lead to unnecessary code repetition. It also provides a paradigm for replacing multiple inheritance (which is not implemented in Java).<p>The other hidden facility of an interface is that a variable whose declared type is an interface type may have as its value a reference to any object that is an instance of a class declared to implement the specified interface. That allows any class to become of the desired type, by implementing the methods declared in the interface. Applicants should be able to show a simple example that possibly uses an interface to allow callback mechanisms to come into play without knowing the class type at compile time.<p><B>Category Two: Intermediate Java Knowledge<p></B>Candidates should be warming up by now, and these questions will become tougher as the interview progresses.<p><p><B>Q:</B> Do you know what a race condition is? How do you guard against it?<p><B>A:</B> "I don't know," or "A race condition occurs when two threads are trying to modify the same data at the same time in such a way that the modification interferes with the logic of the thread. You guard against that by synchronizing the method that changes the data by using the 'synchronized' qualifier."<p><p>An "I don't know" answer is acceptable for the first part of the question only. Applicants may not have heard of the phrase, but they should be able to answer the second part after the race condition is described to them. Synchronization is a vital part of Java, since the language is inherently multithreaded. Any application that you'll develop, apart from simple ones, requires a good bit of multithreading.<p><B>Q:</B> What is an exception, and how do you implement exception handling in Java?<p><B>A:</B> An exception is a potential error condition that a method cannot anticipate and does not know how to handle, but instead needs to be passed to the caller of the function, who potentially knows what it means. Java implements exceptions by defining the <I>Exception</I> class and the <I>Throwable</I> class (and allowing them to be extended). The way to handle exceptions is to enclose methods that throw them into a try-catch block.<p><p><B>Q:</B> How can one write a thread in Java? How does a thread start? How does it end?<p><B>A:</B> There are two ways to use threads in Java. One way is to create a subclass of the <I>Thread</I> class, which belongs to the java.lang package. The other is to use the Java Runnable interface. The <I>Thread</I> class defines methods called <I>start()</I>, <I>run()</I>, and <I>stop()</I>, which need to be overridden to provide the desired functionality for the extended class. The Runnable interface is used when your class is already extending another class that is not part of the <I>Thread</I> hierarchy, so you wouldn't be able to extend it. It declares a <I>run()</I> method that you need to define to complete the class.<p><p><B>Q:</B> How do you handle a "mouse clicked" event in JDK 1.02? How would you handle it in JDK 1.1?<p><B>A:</B> In JDK 1.02, you'd need to override the <I>handleEvent(Event evt)</I> method; see Example 1(a). In JDK 1.1 (and later versions), assuming there was a button that users pressed by clicking on it with the mouse, the code would look like Example 1(b). <p>Don't forget to add the <I>implements ActionListener</I> part at the class declaration.<p><B>Category Three: Extended Java Knowledge<p></B>I usually take a short break before jumping into the third category. I've found that after the second category, having spent 30-45 minutes with the interviewee, I have an idea of what she will or will not be able to answer. This break serves as a way to see how candidates perform when they're a little more relaxed.<p><p><B>Q:</B> Have you worked with RMI (Remote Method Invocation) before? How much do you know about it?<p><B>A:</B> (Most often) No. But I do know that it is an API to allow a Java program running on one platform to invoke the methods of a Java program running on a different platform. It is used for distributed applications, either on a two-tier or a three-tier client-server paradigm.<p>RMI is so new that many applicants will not yet have worked with it. Of all the Java developers I know, most have read a bit about it, but never had a chance to use it. One friend of mine had the luxury of being taught at Harvard by Jim Waldo, and he did a project using RMI. This is unlikely of most candidates, so don't expect too much.<p>If, however, applicants start talking about it, I encourage them. It will show me how much they know about distributed computing, client-server methodologies, and the like. Even if a project's requirements today do not involve distributed computing, it is likely that they will in the near future (or they should, anyway).<p><br clear=all><table width=500 align=center border=1 cellpadding=4 cellspacing=0><tr><td><pre><b>(a)</b>  public handleEvent(Event evt)  {    if ( evt.id == Event.MOUSE_DOWN ) {      System.out.println("Mouse was clicked");    }  }<b>(b)</b>  Button b = new Button("Press Me");  b.addActionListener(this);   ...    Public viod actionPerformed(ActionEvent evt)  {    if ((Button) evt.getSource() == b)      System.out.plrintln("Button was pressed")  }</pre></td><tr><td bgcolor="#cccccc"><b>Example 1:</b> (a) Handling mouse clicks using JDK 1.02; (b) handling mouse clicks using JDK 1.1.</td></table><br clear=all>  <B>Q:</B> What is an alternative way of performing distributed computing?<p><B>A:</B> CORBA, RPC, (or DCOM, if they come from a Microsoft background). <p><p>CORBA is another big topic. If applicants start a conversation on CORBA, I ask a couple of questions about it. Such questions will help hash out whether or not they know about it, or have simply heard about it and are parroting the information. This will be very obvious when I ask:<p><p><B>Q:</B> What is the main difference between CORBA and RMI?<p><B>A:</B> Either "CORBA needs an ORB (Object Request Broker), whereas RMI doesn't," or "RMI runs only between Java programs, whereas CORBA can be run between Java, C++, or any other language implementation of an ORB."<p><p><B>Q:</B> What is a JAR file?<p><B>A:</B> It is a "Java ARchive File." It helps in speeding up the downloading of class files associated with applets. Applets frequently contain many class files, image files, and the like. With JAR files (a feature only available in the latest versions of the JDK 1.1 and above), you can package individual small files into one JAR file. This allows applets to only open one HTTP connection for the file, instead of the many HTTP connections required before, and it also provides a standard, convenient way to package JavaBeans.<p><p><B>Q:</B> What is JDBC? Where is it used?<p><B>A:</B> JDBC is the Java Database Connectivity API. It is the adaptation of Microsoft's ODBC Standard for Java. JDBC allows connectivity between Java programs and relational databases such as Microsoft SQL Server, Sybase SQL Server, Oracle, Informix, and the like. In fact, the claim is that any database that conforms to the ODBC Standard should be accessible to Java via JDBC, when the vendor implements the API for their server.<p><p><B>Q:</B> Can you describe an example of a database access function using JDBC?<p><B>A:</B> (Any sane person) No. I can instead look it up and do it for you from the book.<p><p>I would not expect most Java programmers to be able to recite how to perform a connect to a database server, retrieve data, and close the connection, off the top of their head. However, they should be familiar with what a SQL connection is, with SQL statements, with "commit transaction" and "rollback transaction," and so on. They should be able to go into some detail on SQL (if they have done that type of work before), but I don't hold it against them if they've never touched a database in their lives. They'll learn easily. <p><p><B>Q:</B> What is an "inner class"? Where would you use one?<p><B>A:</B> An inner class enables classes to be defined in any scope. Previously, Java supported only top-level classes, which had to be members of packages. Now the programmer can define inner classes as members within other classes-locally within a block of statements, or anonymously within an expression (see <I>Inside Java</I>, by Karanjit S. Siyan and James L. Weaver, New Riders, 1997).<p>The use of inner classes allows programmers to connect objects together, by directly using the methods and variables they need. <p><B>Category Four: "I like Klingon Opera and Wear Pointy Ears"<p></B>If I've gotten this far, I'm pretty much assured that the person in front of me knows his stuff. Now, if I want to see whether I can stump the interviewee, I'll ask:<p><B>Q:</B> How much do you know about bytecodes? Have you ever debugged an application for which you had no source code and had to rely on bytecode?<p><B>A:</B> If the answer is even remotely close to an affirmative, I know the person is enthusiastic about Java and will be a good fit, technically.<p><p><B>Q:</B> When does garbage collection occur? What is the priority for the garbage collection thread?<p><B>A:</B> The Java run-time environment has a garbage collector that periodically frees the memory used by objects that are no longer needed. The Java garbage collector is a mark-sweep garbage collector that scans Java's dynamic memory areas for objects, marking those that are referenced. After all possible paths to objects are investigated, those objects that are not marked (that is, not referenced) are known to be garbage and are collected. (A more complete description of Java's garbage-collection algorithm might be "a compacting, mark-sweep collector with some conservative scanning.") The garbage collector runs in a low priority thread and runs both synchronously and asynchronously depending on the situation and the system on which Java is running. The garbage collector runs synchronously when the system runs out of memory or in response to a request from a Java program. Your Java program can ask the garbage collector to run at any time by calling <I>System.gc()</I>.<p>On systems that allow the Java run time to note when a thread has begun and to interrupt another thread (such as Windows 95/NT), the Java garbage collector runs asynchronously when the system is idle. As soon as another thread becomes active, the garbage collector is asked to get to a consistent state and then terminate.<p>The priority of the garbage collection thread is set to NORM_PRIORITY-1 in the current version of the JDK.<p><p><B>Q:</B> Can you name a couple of differences between various Java platform implementations?<p><B>A:</B> There are none. Or, at least, there should not be any. <p><p>This is a bit of a tricky question, what I was really looking for is any knowledge of JDK bugs that are manifested only on some of the implementations. Such bugs include (from the Javasoft web site):<p><ul><li>Solaris. Enter/exit events not delivered to other components during a drag operation (they are on Win32).<li><I>java.awt.Frame.setResizable(false)</I> does not have any effect on Solaris.<li>Key events aren't sent to Canvas instances in Win32.</ul><B>Conclusion<p></B>The interview is almost over by now, the applicant is probably mentally exhausted. They have certainly learned a lot. Hopefully, I've given them pointers to read about the parts they didn't know. As the interviewer, I'm evaluating how I feel about their personality and ability to work under pressure. Their Java skills might be lacking, but that's not as important as their ability to learn and assimilate what they will be taught. Remember that a good senior Java programmer is hard to find. I may ask them to come back to talk again. That should be a chance for them to impress me by showing me they've read up on the questions they couldn't answer before. I expect that from applicants, since it shows eagerness to work.<p>Now comes the hard part of my job: Convincing the management that they have to pay the premium for the Java programmer when they're used to the salaries they pay for senior C++ programmers. <p><p><b>DDJ</b></BODY></HTML>