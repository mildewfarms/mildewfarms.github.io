<html>
<META NAME="year" CONTENT="1997">
<head>
<title>Dr. Dobb's Journal March 1997: Letters</title>
</head>

<body bgcolor="FFFFFF">
<!--Copyright &#169; Dr. Dobb's Journal-->
<H1>Letters</H1>
<HR>
<h3>Beyond Programming</h3>

<p>Dear <i>DDJ,</i></p>

<p>Thanks to Phil Mitchell for his "Programmers Bookshelf" review of my book <i>Beyond Programming</i> (<i>DDJ</i>, August 1996). I was very much impressed with his description of my work with TEDIUM. He clearly understood what I was (am?) doing; I'm not sure I could have described it better myself. I'm sorry he didn't like the first eight chapters, but I'm not surprised. They were written for an academic audience, which -- in my experience at least -- seems to have a limited understanding of these ideas beyond the buzz-word level. Thus, I plead guilty to "arid," but I hope not "superficial." </p>

<p>Regarding Phil's comments on SEE, I elected not to comment on what I consider to be software development in the old paradigm. The thrust of the book was to be [focused] on how we ought to develop software in the future. My impressions of much of the SEE work is that the concern here is on improving how we do it now. Therefore, evaluations of other people's work would be unfair in that I believe that they are addressing a different problem. </p>

<P>
Bruce I. Blum<br>
Columbia, Maryland
</P>

<h3>Packet Realities</h3>

<p>Dear <i>DDJ</i>,</p>

<p>I was sitting here "training" (that is, perusing the January 1997 <i>DDJ</i> while chewing lunch) and, upon reading Jonathan Erickson's editorial, wondered if ISDN "alters communication by breaking information into packets for transmission" as the SPA's remarkably self-serving explanation would have it of TCP/IP. ISDN digitizes voice; so, if I get a nasty phone call on my ISDN line, I can sue Bell Atlantic as the "publisher," right? Yeah, right.</p>

<P>
Christopher C. Reed<br>
Christopher.C.Reed@m1.irs.gov
</P>

<p>Dear <i>DDJ</i>,</p>

<p>If, as Jonathan Erickson says in his January 1997 editorial, the SPA bases its stance on the fact that ISPs (and the Internet) break data into packets and reassemble it for presentation, then I think the SPA should receive some quick education on how the current "analog" telephone system works in this country. In a nutshell, at the central-office switch (the one on the other end of the wires coming out the back of your phone) your phone conversation is converted from an analog signal into a stream of digital packets which are (likely) intermixed with packets from other, concurrent users of the system, transmitted digitally across a wide-area network, and reassembled into an analog signal at the receiving end. Remarkable similarity to the SPA's characterization of the Internet, no?</p>

<P>
Theodore A. Jump<br>
tjump@spgs.com 
</P>

<h3>HATs Off</h3>

<p>Dear <i>DDJ</i>,</p>

<p>After reading Edward Sitarski's September 1996 "Algorithm Alley" on hashed array trees, I'd like to say there is good news -- it's possible to use <i>malloc</i>/<i>realloc</i>/<i>free</i> routines in C++ and still have a constructor/destructor called. It's 100 percent portable, legal, and exhibits good style. The trick is that it's possible to call the constructor/destructor of an already allocated memory block. <a name="re1"><a href="9703pe1.htm">Example 1</A>, for instance, has zero overhead and is simple and portable. So, this HAT class is absolutely obsolete.</p>

<P>
Poul A. Costinsky <br>
poul@wizsoft.com
</P>

<h3></h3>

<p><i>Ed responds:</i> Poul, Thanks for your feedback. I have to admit that I was not aware of the trick that you brought up in your letter. However, I would like to bring a counter example to your attention where your method will not work. This counter-example would make it inappropriate to use your method in a general-purpose C++ template toolkit, as it can cause dangling pointers and memory corruption.</p>

<p>The root of the problem is that the call to <i>realloc</i> will eventually move your array of objects in memory. This is a violation of encapsulation that some objects may never recover from, especially objects that have pointers to internal fields. Consider the class in <a name="re2"><a href="9703pe2.htm">Example 2</A>, which uses a sentinal element to avoid special-case comparisons to speed up doubly linked list manipulations.</p>

<p>Clearly, if <i>realloc</i> moves this object in memory by byte copying, there is no way that the values of "head" and "tail" will be updated, and they will now be "dangling." At the very least, this means that the <i>isEmpty()</i> member function will no longer work properly, since the address of the sentinal field has changed. Worse, a modification to head or tail will now corrupt memory.</p>

<p>This problem will happen anytime an object has a pointer to an internal field. True, this is not an extremely common case, but it does show that your method is unfortunately <i>not</i> 100 percent portable, legal, and in good programming style. Isn't it always time bombs like this that seem to show up just before a release?</p>

<p>Perhaps HATs are a useful and 100 percent reliable alternative to variable length arrays after all.</p>

<p><i>Poul then responds:</i> Ed, you're right that <i>realloc</i> can move the memory chunk. The immediate solution I use isn't portable, but Win32 specific -- I'm using local heaps, and <i>LocalHeapRealloc</i> has a flag preventing moving memory.</p>

<p>Another point: I never use things like a pointer to an internal field. I think it's a dirty trick, so my personal definition of good style remains consistent.</p>

<p>You're right that HATs support this approach, so they may be useful for somebody.</p>

<h3></h3>

<p>Inventing the Computer</p>

<p>Dear <i>DDJ</i>,</p>

<p>I would like to comment on the letter from Phil Mitchell in the July 1996 <i>DDJ</i> concerning the invention of the computer.</p>

<p>I think it is unfair to bend historical facts only because they happened in the wrong land at the wrong time. Konrad Zuse was the creator of the world's first fully automatic, program-controlled, and freely programmable -- with binary floating-point arithmetic -- working computer. This machine, the Z3, was in operation in 1941. Zuse's diaries from 1937 already contain advanced ideas as stored programs and  parallel execution of operations, although these concepts were not realized. The Z3 was destroyed during the Second World War, but a reconstruction is shown in the Deutsche Museum in Munich. I don't  think that anybody who has actually seen the machine would call it a "calculator" (in a discriminating way) instead of a "computer."</p>

<P>
Bernd Warmer<br>
Aachen, Germany<br>
100621.263@compuserve.com
</P>

<h3></h3>

<p>Year 2000</p>

<p>Dear <i>DDJ</i>,</p>

<p>I am maintaining a list of articles about the year-2000 or century problem in CompuServe's PCPROG forum (YR2000.TXT, library 13). In addition to your "Tick, Tick, Tick" editorial (<i>DDJ</i>, June 1996), which I am including in the next revision of the file, I have thus far found 17 articles on the problem in major newspapers, computer magazines, and business journals.</p>

<p>I disagree that the cost of modifying programs to be "year-2000 compliant" can be measured in terms of the number of lines in a program. Instead, notice that year data do not appear randomly throughout a program. They can only enter at fixed points (user input, data files, and the like) and then flow from these lines to other lines.  A programmer can trace year-data flow to a subset of program lines and then needs to check or modify only those lines. (The only complication is that some languages allow aliases that are hard to detect. For example, variables can be renamed when Fortran common blocks are included into other routines.) As a result, a million-line program may require no more effort to fix than a thousand-line program.</p>

<p>As for solving the century problem, one must, of course, decide to represent years using either two or four digits. If four digits are used, the task is done once input years are converted to four-digit numbers. If, instead, two-digit years are used, then the program must convert years to four digits for each year-related calculation and change these calculations so that they expect four-digit inputs. More details are in YR2000.TXT.</p>

<P>
David Wincelberg<br>
71573.1023@compuserve.com 
</P>

<p><b>DDJ</b></p>
<HR><I>Copyright &copy; 1997, Dr. Dobb's Journal</I><BR>

</BODY>
</html>
