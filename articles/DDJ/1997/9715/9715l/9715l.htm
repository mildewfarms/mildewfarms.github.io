<html>
<META NAME="year" CONTENT="1997">
<head>
<title>Dr. Dobb's Sourcebook May/June 1997: Editorial</title>
</head>

<body bgcolor="FFFFFF">
<!--Copyright &#169; Dr. Dobb's Journal-->
<h1>The Pressing Need for Live Data</h1>
<hr>
<p>Face it, John von Neumann was a bright guy. Early in this century, he invented something that today seems too obvious to have been invented at all. In essence, he invented Java. Not literally, of course, but his notion of "stored program" is the fundamental insight that makes live data possible.</p>

<p>In case your history is a bit rough, here's the short version: The first electronic computers were "programmed" by plugging-in wires to specify the successive steps of a computation. Von Neumann's insight was that these instructions could be stored as data. Without this insight, program loaders, compilers, and debuggers are all impossible, since they assume that programs are data.</p>

<p>The converse is equally true: All data is program. A GIF file is really just a sequence of instructions for creating an image. Like the wave/particle duality in modern physics, the ideas of "data" and "program" aren't intrinsic, but depend purely on your viewpoint. There are lots of good examples of this duality. A PostScript document is simultaneously program and data. Many illustration and graphics programs prepend a fixed PostScript header to their data. If you have the program, you can extract and alter the data directly, but even if you don't, you can still use the data in important ways.</p>

<p>Developers are doing similar things with Java bytecode. By prepending a piece of Java bytecode to data, a word processor file becomes viewable and usable even without the program that created it. With Java Virtual Machines being built into desktop operating systems (like MacOS, OS/2, AIX, and Solaris), it's possible to store application data as minimally usable, stand-alone Java bytecode applications.</p>

<p>This development might hold a key to the file format Tower of Babel. We're all tired of installing new viewer applications for almost every web site we visit. The viewer may be free, but it's still annoying. The idea that such viewers might get installed for us -- as with ActiveX -- gives me the willies. (No, digital signatures aren't a silver bullet -- they don't prevent someone from robbing you blind, nor can they catch the thief afterward.) Also, I use too many different operating systems to trust that a suitable viewer will be available for whichever one I'm using at a given time.</p>

<p>Live data should especially appeal to database developers. While characters, numbers, and dates may have sufficed for the past, today's databases are being asked to store video, audio, and even more fantastic kinds of data. Storing such data as uninterpreted "blobs" (binary large objects) is a disaster in the making. An essential part of the database schema (how to interpret a piece of data) is no longer part of the database, but is instead buried in the program that uses the database. If someone hands you a database full of blobs, there's little you can do.</p>

<p>In essence, live data boils down to good object-oriented design. The original premise of the object paradigm is that data should be opaque -- you don't manipulate data, you ask it to manipulate itself. So far, this has been applied almost exclusively to application data stored in memory. When you apply this idea to audio clips in a database or word processing documents on the network, you have live data.</p>

<p>Ultimately, live data could vastly simplify computing. To view a document, double-click it; if you lack the application, the document can display itself. Sure, there will always be programs that help you manipulate the document, but they shouldn't be required for the most minimal uses.</p>

<p>I'm not raving about Java bytecode specifically. I'd prefer something more textual, but I'm practical, and Java bytecode will work. Standardization is the important issue, and that's still a long way off for Java. Worse, the Java language (the least important part of the Java suite) will probably be standardized before the bytecode and libraries are considered.</p>

<p>Admittedly, this whole idea is futuristic. Java is still experiencing growing pains, and the alternatives are even further behind. But von Neumann's insight is too important; we can't yet afford to take it for granted.</p>

<p>--Tim Kientzle</p>


</body>
</html>
