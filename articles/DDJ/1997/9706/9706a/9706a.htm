<html>
<META NAME="year" CONTENT="1997">
<head>
<title>Dr. Dobb's Journal June 1997: Literate Programming and Code Reuse</title>
</head>

<body bgcolor="FFFFFF">
<!--Copyright &#169; Dr. Dobb's Journal-->
<h1>Literate Programming and Code Reuse</h1>

<p><i>Dr. Dobb's Journal</i> June 1997
</p>
<h2>Combining literate programming with a macro processor yields a powerful reuse mechanism</h2>

<h3>By Sverre Hendseth</h3>

<I>Sverre is software manager at TTS Automation in Bergen, Norway, and can be reached at Sverre.Hendseth@tts-automation.no. TTS makes robot production systems for the shipyard industry.</I>

<hr>

<p>The term "Literate Programming" describes the concept of mixing code and documentation introduced by Donald Knuth. The original system, "WEB system of structured documentation," was developed to provide the basis for the documentation/implementation of the TeX and MetaFont programs (see Knuth's "Literate Programming," Center for the Study of Language and Information (CSLI) Lecture notes number 27, 1992). WEB consists of two filters working on WEB source code; Tangle extracts compilable Pascal code, while Weave extracts the TeX-based documentation of the program. </p>

<p>In this article, I'll look at ways in which literate programming helps you reorganize the layout of a program. When given the freedom to structure program layout as you wish, you tend to group parts of the code differently than as dictated by the language or compiler. Rather than grouping all public-function declarations of a C++ class together in the public section of the class, for instance, you might group each function declaration with the corresponding function implementation. I'll also examine how some of these new groups of code can be parameterized into reusable macros with the help of a simple macro processor. Specifically, I'll show how the application of design patterns such as Singleton and State from <i>Design Patterns: Elements of Reusable Object-Oriented Software</i>, by Erich Gamma et al. (Addison-Wesley, 1995), can be supported by such macros.</p>

<p>This article is a literate program in itself. The first part (available electronically; see "Availability," page 3) documents and implements a set of reusable macros, while the last part is an example of how these macros are used. Extracted C++ code from the example section of this article is presented in <a name="rl1"><a href="9706a.htm#l1">Listings One</A> and Two The tools and techniques described in this article have been used daily at TTS Automation for the past year and a half for the development of our offline robot programming systems.</p>

<h3>The CLiP System for Literate Programming</h3>

<p>The CLiP program (which was developed by E.W. van Ammers and M.R. Kramer and is available at ftp://sun01.info.wau.nl/clip/ for DOS, VMS, and UNIX) reads any number of ASCII files that have been extracted from documents that contain the program code and documentation (written with a word processor). From these, CLiP (short for "Code from Literate Programming") generates corresponding "source" files. Since CLiP is language independent, source files, make files, scripts/batch files, test data and the like can be generated from the same document(s). </p>

<p>Two terms are central to understanding CLiP:</p>

<p>1.	A "stub" is a piece of text (code) copied to the output file. It is enclosed in the document with lines like: </p>

<BLOCKQUOTE><p><PRE>/*** &lt;Name of Stub&gt; ***/</PRE> </p>
</BLOCKQUOTE>
<p>	and </p>

<BLOCKQUOTE><p><PRE>/*** End of &lt;Name of Stub&gt; ***/</PRE></p>
</BLOCKQUOTE>
<p>2.	A "slot" is a special line that can occur inside of any stub. It looks like the opening line of a stub and serves as a placeholder for the stub with the same name. The slot line will be replaced by the contents of this stub in the output file.</p>

<p>Both stubs and slots can have option specifiers prefixed with "#". The most important stub option is <i>#file</i>. The file stub has no stub name, but its contents are copied to the specified file:</p>

<BLOCKQUOTE><p><PRE>/*** #file "extract.bat" #comment off ***/
rem Run the macro processor 
clipprep c:\litprog\litprog.txt &gt;tmp.txt
rem Run CLiP
clp_env . . clp tmp.txt/*** End of File ***/</PRE></p>
</BLOCKQUOTE>

<p>The #comment option turns on or off comments generated by CLiP. The stub option #quick indicates that the stub is ended by the next blank line rather than the "End of" line.</p>

<p>The most frequently used slot option is <i>#multiple</i> (<i>#mult</i>), which allows more than one stub to be substituted for the slot. The <i>#optional</i> (<i>#opt</i>) slot option suppresses the warning if there is no stub to fit in a slot.</p>

<p>Stubs can come in any order in the CLiP source file. In a C++ class definition, for example, the member function declaration and its definition can be written in the same section. Alternatively, a data member declaration, its initialization in the constructor, the corresponding statements in the copy constructor and assignment operator, its access functions, and its destruction in the class's destructor can be placed in the same section of the source file. <a name="rl3"><a href="9706a.htm#l3">Listing Three</A> is a CLiP source file with the corresponding generated code. </p>

<p>When given the freedom to reorganize the layout of a program like this, it becomes apparent that structures -- other than those traditionally thought of as reusable -- repeat themselves. These range from trivialities like source file and class layout via member-variable handling, to complex design patterns like those described in <i>Design Patterns</i> or Jim Coplien's <i>Advanced C++: Programming Styles and Idioms</i> (Addison-Wesley, 1994).</p>

<h3>The Macro Preprocessor</h3>

<p>To enable reuse of these structures, you need a macro processor. The one I use, CLiPPrep (which is also available electronically), is a filter, expanding macros of the forms:</p>

<ul>
<li>Parameterless macro <BR>
<PRE>%MacroName</PRE>
<li>Macro call with parameters<BR>
<PRE>%MacroName(par1,par2,par3)</PRE>
</ul>

<p>The macro call will be substituted by the macro's body. A macro parameter in this form may contain any characters except "," and ")". If these characters are needed in the parameter, you must enclose the parameter with named brackets of the form <i>%x{</i> and <i>%x}</i>, where <i>x</i> can be any letter or digit, or can be omitted. These brackets must be matched and may not contain any closing brackets with the same name. This is a legal macro call:</p>

<BLOCKQUOTE><PRE><p>%OneParameterMacro(%a{
This parameter may contain ',' and ')'
It also contains three EndOfLines.
%a})</p></PRE>
</BLOCKQUOTE>

<p>One of the predefined macros is <i>DefMacro</i>, which registers a new macro. It takes at least two parameters, the first being the macro name, and the last the macro body. The optional middle parameters are the parameter names of the new macro. These are referenced from the macro body like parameterless macros.</p>

<p>Below is a macro that defines the layout of a C++ class declaration. A class has a name and may inherit another class. I assume only public and nonmultiple inheritance to keep the examples simple. </p>

<BLOCKQUOTE><PRE><p>%DefMacro(<b>Class</b>,class,baseClass,%{
class %class %If(%baseClass,: public %baseClass,){
public:
 /*** %class public props #mult #opt ***/
protected:
 /*** %class protected props #mult #opt ***/
private:
 /*** %class private props #mult #opt ***/
};
%})</p></PRE>
</BLOCKQUOTE>

<p><i>If</i> is a predefined macro that evaluates to one out of two bodies depending on whether or not its first parameter is the empty string. The call <i>%Class(CMyClass,CObject)</i> expands to:</p>

<BLOCKQUOTE><PRE><p>class CMyClass : public CObject {
public:
 /*** CMyClass public props #mult #opt ***/
protected:
 /*** CMyClass protected props #mult #opt ***/
private:
 /*** CMyClass private props #mult #opt ***/
};</p></PRE>
</BLOCKQUOTE>

<p>The class's properties will be filled in by stubs elsewhere in the document. </p>

<h3>Reusing the Repeating Structures</h3>

<p>Before describing how design patterns are supported, I need to define two more macros.</p>

<p><i>DefineClass</i> defines corresponding header and implementation files for a class, using the previous <i>Class</i> macro for the class declaration itself. It takes the filename base, class name, and base class name as parameters. The header file contains one slot for <i>include</i>s, one for declarations, and the class declaration itself -- everything surrounded by an <i>#ifndef</i> statement. The implementation file includes the corresponding header file and has a slot for its own <i>include</i>s<i>,</i> and a slot for the implementation itself:</p>

<BLOCKQUOTE><PRE><p>%DefMacro(<b>DefineClass</b>,file,class,baseClass,%a{
%%% <i>Make the header file
</i>/*** #file "%file.hpp" #comment off ***/
#ifndef INCLUDE_%file
#define INCLUDE_%file
/*** %class header includes #mult #opt ***/
/*** %class declarations #mult #opt ***/
%Class(%class,%baseClass)
#endif
/*** End Of File ***/</p>
</PRE>
</BLOCKQUOTE>

<BLOCKQUOTE><PRE><p>%%% <i>Now for the implementation file</i>
/*** #file "%file.cpp" #comment off ***/
#include "%file.hpp"
/*** %class implementation includes #mult #opt ***/
/*** %class implementation #mult #opt ***/
/*** End Of File ***/
%a})</p>
</PRE>
</BLOCKQUOTE>

<p>The second basic macro is the member function. A member function is contained in a class and has a name, access (public, protected, private), parameters, return value, possibly a type modifier (virtual or static), and body. Again, to keep the example simple, I ignore pure virtual functions, overloading, default values of parameters, <i>const</i> functions, and the like. The macro puts the function declaration into the correct slot in the class declaration, and the function implementation into the implementation file, opening a "&lt;functionName&gt; actions" slot for the function body:</p>

<PRE><BLOCKQUOTE><p>%DefMacro(<b>Method</b>,class,scope,typeMod,type,name,pars,
%a{
%%% <i>Make the prototype 
</i>/*** %class %scope props ***/
%typeMod %type %name (%pars);
/*** End of %class %scope props ***/
%%% <i>Make the definition</i>
/*** %class implementation ***/
%type
%class::%name (%pars){
 /*** %class::%name actions #mult #opt ***/
}
/*** End of %class implementation ***/
%a})</p>
</BLOCKQUOTE></PRE>

<h3>The Singleton Pattern</h3>

<p>By protecting the constructor and letting all access to the object go through a static member function, the Singleton pattern ensures that there is only one instance of a class created. The following macro adds a private constructor to the class, a private static object pointer to the single instance of the class, and a static public member function <i>Instance()</i> that returns the instance pointer, if necessary, after creating the object. </p>

<BLOCKQUOTE><PRE><p>%DefMacro(<i>MakeSingleton</i>,class,
%a{
%%% <i>The private constructor</i>
%Method(%class,private,,,%class,)
%%% <i>The static instance pointer</i>
/*** %class private props ***/
static %class * m_instance;
/*** End of %class private props ***/
%%% <i>...and its definition</i>
/*** %class implementation ***/
%class * %class::m_instance = NULL;
/*** End of %class implementation ***/
%%% <i>The Instance() function</i>
%Method(%class,public,static,%class *,Instance,)
%%% <i>and its body</i>
/*** %class::Instance actions ***/
if(m_instance == NULL){
 m_instance = new %class;
}
return m_instance;
/*** End of %class::Instance actions ***/
%a})</p>
</PRE>
</BLOCKQUOTE>

<p>This is a simple macro to build; it adds a set of features to an already existing class. <a name="rl4"><a href="9706a.htm#l4">Listing Four</A> is the result of the two macro calls, partly evaluated by CLiP:</p>

<BLOCKQUOTE><PRE><p>%DefineClass(mysing,CMySingleton,)
%MakeSingleton(CMySingleton) </p>
</PRE>
</BLOCKQUOTE>

<h3>The Abstract Base Class </h3>

<p>When you have several classes that should implement the same interface, or if you want to achieve a proper division between interface and implementation for one class in C++, you define the interface as an abstract base class (ABC) which the implementation classes inherit. I will describe a variant of this structure where the subclasses are declared in the implementation file of the base class; that is, they are completely invisible from the client side. Instances of these classes might, for example, be created through static functions in the abstract base class.</p>

<p>This is more a feature of the C++ language than an idiom or design pattern, but it occurs frequently and contains features coded in its layout (the concrete classes are invisible because they are declared in the implementation file). Macros can also help ensure consistency between the base class and concrete classes. Therefore, this structure is a good candidate to implement as a reusable macro. <a name="rl5"><a href="9706a.htm#l5">Listing Five</A> presents the layout of the header and implementation file. </p>

<p>Four macros describe this structure:</p>

<p>1.	<i>ABC(class)</i> prepares the given class as an abstract base class, giving it a virtual destructor and partitioning the implementation file:</p>

<BLOCKQUOTE><PRE><p>%DefMacro(<i>ABC</i>,class,%{
%%% <i>The virtual destructor</i>
%Method(%class,public,virtual,,~%class,)</p>
</PRE>
<PRE><p>%%% <i>The slot for the sub-class declarations</i>
/*** %class implementation ***/
/*** %class derived classes #mult #opt ***/
/*** %class child implementations #mult #opt ***/
/*** End of %class implementation ***/
%})</p>
</PRE>
</BLOCKQUOTE>

<p>2.	<i>ABCMethod(class,returnType,name,parameters)</i> adds the specified method to the interface as a pure virtual function and remembers (defines as macros) the return value and parameters:</p>

<BLOCKQUOTE><PRE><p>%DefMacro(<i>ABCMethod</i>,class,type,name,pars,%{
%%% <i>Define the method</i>
/*** %class public props ***/
virtual %type %name (%pars) = 0;
/*** End of %class public props ***/
%%% <i>Remember the return type and parameters.</i>
%DefMacro(%name ReturnType,%type)
%DefMacro(%name Parameters,%pars)
%})</p>
</PRE>
</BLOCKQUOTE>

<p>3.	<i>ABCDerivedClass(baseClass,class)</i> defines an implementation class inheriting the <i>ABC</i> and defines the slot for its implementation:</p>

<BLOCKQUOTE><PRE><p>%DefMacro(<i>ABCDerivedClass</i>,baseClass,class,%a{
%%% <i>The subClass</i>
/*** %baseClass derived classes ***/
%Class(%class,%baseClass)
/*** End of %baseClass derived classes ***/</p>
</PRE>
</BLOCKQUOTE>

<BLOCKQUOTE><PRE><p>%%% <i>Make the slot for the sub-class implementation</i>
/*** %baseClass child implementations ***/
/*** %class implementation #mult #opt ***/
/*** End of %baseClass child implementations ***/
%a})</p>
</PRE>
</BLOCKQUOTE>

<p>4.	<i>ABCDerivedClassMethod(class,name)</i> looks up the stored return value and the parameters of the method and defines them in the class:</p>

<BLOCKQUOTE><PRE><p>%DefMacro(<b>ABCDerivedClassMethod</b>,class,name,
%x{
%Method(%class,public,virtual,
 %{%Eval(%% %name ReturnType)%},%name,
 %{%Eval(%% %name Parameters)%})
%x})</p>
</PRE>
</BLOCKQUOTE>

<p>The <i>Eval</i> macro takes one parameter and evaluates it one extra time, and the "%%" constellation evaluates to a single "%".</p>

<p>Remember that function bodies, member variables, helper functions, and the like are added to the classes in the normal manner, using the <i>Method</i> macro or writing stubs that fit in the appropriate slots.</p>

<h3>The State Pattern </h3>

<p>You can organize the state-dependent behavior of a class, (the "context") by forwarding requests for this behavior to a contained instance of a <i>State</i> class. This <i>State</i> class is an abstract base class and the instance variable is changed to point to different implementations for different states. Here, I'll describe a variant of this pattern, where the state objects do not have data members. The context's "this" pointer can, however, be passed with every function call to the state objects so that they can access the context's data if necessary. The concrete state classes are thereby modeled as Singletons. This pattern is divided into two macros:</p>

<p>1.	<i>AddState(contextClass,stateId)</i> adds a state variable to the context class and defines the state ABC. It remembers the context class corresponding to the <i>stateId</i> (<i>sId</i>). The state class name is chosen to be the <i>stateId</i> prefixed by "C":</p>

<BLOCKQUOTE><PRE><p>%DefMacro(<b>AddState</b>,context,sId,
%{
%%% <i>Define the State Base Class in the </i>
%%% <i>implementation file of the context.</i>
/*** %context implementation ***/
%Class(C%sId,)
/*** C%sId implementation #mult #opt ***/
/*** End of %context implementation ***/
%%% <i>Make it an ABC</i>
%ABC(C%sId)
%%% <i>We have to declare it.</i>
/*** %context Declarations ***/
class C%sId;
/*** End of %context Declarations ***/</p>
</PRE>
</BLOCKQUOTE>

<BLOCKQUOTE><PRE><p>%%% <i>Making the variable</i>
/*** %context private props ***/
C%sId * m_%sId;
/*** End of %context private props ***/</p>
</PRE>
</BLOCKQUOTE>

<BLOCKQUOTE><PRE><p>%%% <i>Remember the context corresponding to the sId</i>
%DefMacro(%sId Context,%context)
%})</p>
</PRE>
</BLOCKQUOTE>

<p>2.	<i>DefineState(sId,stateName)</i> defines a class that inherits the state base class. It calls <i>ABCDerivedClass</i> and makes it a Singleton. It is also a friend of the context. </p>

<BLOCKQUOTE><PRE><p>%DefMacro(<b>DefineState</b>,sId,name,%a{
%ABCDerivedClass(C%sId,%name)
%MakeSingleton(%name)
/*** %Eval(%% %sId Context) public props ***/
friend class %name;
/*** End of %Eval(%% %sId Context) public props ***/
%a})</p>
</PRE>
</BLOCKQUOTE>

<p>The macros <i>ABCMethod</i> and <i>ABCDerivedClassMethod</i> are used to add methods to the interface and to the concrete states. </p>

<h3>Using the Macros</h3>

<p>Assume that, up to this point, this article is in a separate file and is maintained as a reusable module. The text is included in this section by the macro processor's <i>Include(fileName)</i> macro. The code generated from this part of the article is presented in <a href="9706a.htm#l1">Listings One</A> and Two.</p>

<p>Assume an application comprised of a number of geometric entity classes that know how to draw themselves as wireframes, in terms of functions offered by the CGl class. The entity instances may be ordered hierarchically in that more-primitive or lower-level entities may be a part of a higher-level entity. </p>

<p>The CGl class makes the interface to the OpenGL graphics library and implements the functions relating to color control. Consequently, you want the following functionality:</p>

<ul>
<li>If an entity does not set the color before issuing drawing commands, it should be drawn in the current color (that is, the color set by its parent entity).   <li>A parent entity should be able to override the color commands of its subobjects.
  <li>When highlighting an entity, all subentities should also be drawn in the highlight color, overriding their color commands.
  <li>When doing dummy draws not shown on the screen (picking or collecting statistics, for instance), color commands should be ignored.
</ul>

<p>The functions <i>PushColor</i>, <i>PopColor</i>, <i>LockColor</i>, and <i>UnlockColor</i> perform these tasks. Each works differently, depending on whether the color is in the state "Locked" or "Normal". </p>

<p>I'll start by defining the CGl class, states, and interface functions:</p>

<BLOCKQUOTE><PRE><p>%DefineClass(glclass,CGl,CObject)
%%% <i>Add Some Includes</i>
/*** CGl header includes ***/
#include &lt;afxwin.h&gt;
#include &lt;gl.h&gt;
#include "ccolor.hpp"
/*** End of CGl header includes ***/
%%% <i>Add the state variable and the states</i>
%AddState(CGl,ColorMode)
%DefineState(ColorMode,CLocked)
%DefineState(ColorMode,CNormal)
%%% <i>Then the four methods</i>
%ABCMethod(CColorMode,void,<b>PushColor</b>,%{
 CGl * pC,
 const CColor &amp; color
%})
%ABCMethod(CColorMode,void,<b>PopColor</b>,CGl * pC)
%ABCMethod(CColorMode,void,<b>LockColor</b>,CGl * pC)
%ABCMethod(CColorMode,void,<b>UnlockColor</b>,CGl * pC)</p>
</PRE>
</BLOCKQUOTE>

<p>The start state must be set. Since the constructor of CGl is not already defined, you must do that too:</p>

<BLOCKQUOTE><PRE><p>%Method(CGl,public,,<b>,CGl</b>,)</p>
</PRE>
</BLOCKQUOTE>

<BLOCKQUOTE><PRE><p>/*** CGl::CGl actions #quick ***/
m_ColorMode = CNormal::Instance();</p>
</PRE>
</BLOCKQUOTE>

<p>Use the following code to keep track of a stack of colors, and the number of times <i>LockColor</i> is called:</p>

<BLOCKQUOTE><PRE><p>/*** CGl private props #quick ***/
int lockLevel;
CObList colorList; // Used for implementing a stack</p>
</PRE>
</BLOCKQUOTE>

<p><i>PushColor</i> and <i>PopColor</i> do nothing in Locked mode, but must maintain the stack of colors and set the current color in Normal mode:</p>

<BLOCKQUOTE><PRE><p>%ABCDerivedClassMethod(CLocked,PushColor)
%ABCDerivedClassMethod(CLocked,PopColor)</p>

<p>%ABCDerivedClassMethod(CNormal,PushColor)
/*** <b>CNormal::PushColor</b> actions #quick ***/
pC-&gt;colorList.AddHead(new CColor(color));
glColor3d(color.R(),color.G(),color.B());</p>

<p>%ABCDerivedClassMethod(CNormal,PopColor)
/*** <b>CNormal::PopColor</b> actions #quick ***/
delete pC-&gt;colorList.RemoveHead();
CColor * pColor = (CColor *) pC-&gt;colorList.GetHead();
glColor3d(pColor-&gt;R(),pColor-&gt;G(),pColor-&gt;B());</p>
</PRE>
</BLOCKQUOTE>

<p><i>LockColor</i> switches modes and initiates the <i>lockLevel</i> to 1 (if in Normal mode) and increments the <i>lockLevel</i> (if in Locked mode):</p>

<BLOCKQUOTE><PRE><p>%ABCDerivedClassMethod(CNormal,LockColor)
/*** CNormal::LockColor actions #quick ***/
pC-&gt;lockLevel = 1;
pC-&gt;m_ColorMode = CLocked::Instance();</p>
</PRE>
</BLOCKQUOTE>

<BLOCKQUOTE><PRE><p>%ABCDerivedClassMethod(CLocked,LockColor)
/*** CLocked::LockColor actions #quick ***/
pC-&gt;lockLevel++;</p>
</PRE>
</BLOCKQUOTE>

<p><i>UnlockColor</i> should decrement the <i>lockLevel</i> and change mode if it reaches zero while in Locked mode, and assert if in Normal mode:</p>

<PRE><p>%ABCDerivedClassMethod(CNormal,UnlockColor)
/*** CNormal::UnlockColor actions #quick ***/
ASSERT(0);</p>

<BLOCKQUOTE><p>%ABCDerivedClassMethod(CLocked,UnlockColor)
/*** CLocked::UnlockColor actions #quick ***/
pC-&gt;lockLevel--;
if(pC-&gt;lockLevel == 0){
 pC-&gt;m_ColorMode = CNormal::Instance();
}</p>
</PRE>
</BLOCKQUOTE>

<p>Now you need to to reflect these functions out to the <i>CGl</i> class:</p>

<BLOCKQUOTE><PRE><p>%Method(CGl,public,,void,<b>PushColor</b>,const CColor &amp; c)
/*** CGl::PushColor actions #quick ***/
m_ColorMode-&gt;PushColor(this,c);</p>

<p>%Method(CGl,public,,void,<b>PopColor</b>,)
/*** CGl::PopColor actions #quick ***/
m_ColorMode-&gt;PopColor(this);</p>

<p>%Method(CGl,public,,void,<b>LockColor</b>,)
/*** CGl::LockColor actions #quick ***/
m_ColorMode-&gt;LockColor(this);</p>

<p>%Method(CGl,public,,void,<b>UnlockColor</b>,)
/*** CGl::UnlockColor actions #quick ***/
m_ColorMode-&gt;UnlockColor(this);</p>
</PRE>
</BLOCKQUOTE>

<h3>Conclusion</h3>

<p>Traditional drawbacks to literate programming include: </p>

<ul>
  <li>Increased "distance" between the file you are creating and the results of compilation/testing. This is an inconvenience if your programming style includes frequent compilation.
  <li>Less powerful version control if you save source as a binary file (as with most modern word processors). 
  <li>Loss of IDE features.
</ul>

<p>Still, you get a system that encourages and enables good source-code documentation and intuitive layout.</p>

<p>The concept of combining a macro processor with literate programming is very expressive. For C++, it surpasses the expressiveness of templates. It is also applicable to most other programming languages. Weaknesses are mainly related to the correctness of the extraction. For example, even if you incorrectly name a stub, you may not get a warning, and the resulting modules may still compile. </p>

<p>For more information on literate programming, see the comp.programming.literate FAQ at ftp://ftp.th-darmstadt.de/ pub/programming/literate-programming and the author's home page at http://home.sol.no/tts/sh. </p>

<p><b>DDJ</b></p>


<H4><a name="l1">Listing One</H4>

<pre>#ifndef INCLUDE_glclass#define INCLUDE_glclass
#include &lt;afxwin.h&gt;
#include &lt;gl.h&gt;
#include "ccolor.hpp"
class CColorMode;
<p></p>
class CGl: public CObject{
public:
  friend class CLocked;
  friend class CNormal;
    CGl();
   void PushColor(const CColor &amp; c);
   void PopColor();
   void LockColor();
   void UnlockColor();
protected:
private:
  CColorMode * m_ColorMode;
  int lockLevel;
  CObList colorList; // Used for implementing a stack
};
#endif
</pre>
<P>
<a href="#rl1">Back to Article</A>
</P>
<H4><a name="l2">Listing Two</H4>

<pre>#include "glclass.hpp"<p></p>
class CColorMode{
public:
  virtual  ~CColorMode();
  virtual void PushColor(
    CGl * pC,
    const CColor &amp; color
  ) = 0;
  virtual void PopColor(CGl * pC) = 0;
  virtual void LockColor(CGl * pC) = 0;
  virtual void UnlockColor(CGl * pC) = 0;
protected:
private:
};
CColorMode::~CColorMode(){
}
class CLocked: public CColorMode{
public:
  static CLocked* Instance();
  virtual void PushColor(
    CGl * pC,
    const CColor &amp; color
  );
  virtual void PopColor(CGl * pC);
  virtual void LockColor(CGl * pC);
  virtual void UnlockColor(CGl * pC);
protected:
private:
    CLocked();
  static CLocked* m_instance;
};
class CNormal: public CColorMode{
public:
  static CNormal* Instance();
  virtual void PushColor(
    CGl * pC,
    const CColor &amp; color
  );
  virtual void PopColor(CGl * pC);
  virtual void LockColor(CGl * pC);
  virtual void UnlockColor(CGl * pC);
protected:
private:
    CNormal();
  static CNormal* m_instance;
};
CLocked::CLocked(){
}
CLocked* CLocked::m_instance = NULL;
CLocked*
CLocked::Instance(){
  if(m_instance == NULL){
    m_instance = new CLocked;
  }
  return m_instance;
}
void
CLocked::PushColor(
  CGl * pC,
  const CColor &amp; color
){
}
void
CLocked::PopColor(CGl * pC){
}
void
CLocked::LockColor(CGl * pC){
  pC-&gt;lockLevel++;
}
void
CLocked::UnlockColor(CGl * pC){
  pC-&gt;lockLevel--;
  if(pC-&gt;lockLevel == 0){
    pC-&gt;m_ColorMode = CNormal::Instance();
  }
}
CNormal::CNormal(){
}
CNormal* CNormal::m_instance = NULL;
CNormal*
CNormal::Instance(){
  if(m_instance == NULL){
    m_instance = new CNormal;
  }
  return m_instance;
}
void
CNormal::PushColor(
  CGl * pC,
  const CColor &amp; color
){
  pC-&gt;colorList.AddHead(new CColor(color));
  glColor3d(color.R(),color.G(),color.B());
}
void
CNormal::PopColor(CGl * pC){
  delete pC-&gt;colorList.RemoveHead();
  CColor * pColor = (CColor *) pC-&gt;colorList.GetHead();
  glColor3d(pColor-&gt;R(),pColor-&gt;G(),pColor-&gt;B());
}
void
CNormal::LockColor(CGl * pC){
  pC-&gt;lockLevel = 1;
  pC-&gt;m_ColorMode = CLocked::Instance();
}
void
CNormal::UnlockColor(CGl * pC){
  ASSERT(0);
}
CGl::CGl(){
  m_ColorMode = CNormal::Instance();
}
void
CGl::PushColor(const CColor &amp; c){
  m_ColorMode-&gt;PushColor(this,c);
}
void
CGl::PopColor(){
  m_ColorMode-&gt;PopColor(this);
}
void
CGl::LockColor(){
  m_ColorMode-&gt;LockColor(this);
}
void
CGl::UnlockColor(){
  m_ColorMode-&gt;UnlockColor(this);
}
</pre>
<P>
<a href="#rl2">Back to Article</A>
</P>
<H4><a name="l3">Listing Three </H4>

<pre>----- ccolor.doc ----------------A class that stores the RGB values of a color.
/*** #file "ccolor.hpp" #comment off ***/
class CColor: public CObject {
public: 
  /*** CColor public props #mult #opt ***/
private: 
  /*** CColor private props #mult #opt***/
};
/*** End of File ***/
<p></p>
The data members:
/*** CColor private props #quick ***/
int m_r; int m_g; int m_b;
<p></p>
We need a constructor that allows setting these;
/*** CColor public props #quick ***/
CColor(int r,int g,int b);
<p></p>
/*** CColor public props #quick ***/
int R()const;int G()const;int B()const;
--------------------------
<p></p>
----- ccolor.hpp ---------------
class CColor: public CObject {
public:
  CColor(int r,int g,int b);
  int R();int G();int B();
private:
  int m_r; int m_g; int m_b;
};
--------------------------
</pre>
<P>
<a href="#rl3">Back to Article</A>
</P>
<H4><a name="l4">Listing Four</H4>

<pre>----- mysing.hpp: ----------#ifndef INCLUDE_mysing
#define INCLUDE_mysing
<p></p>
/*** CMySingleton header includes #mult #opt ***/
/*** CMySingleton declarations #mult #opt ***/
class CMySingleton{
public:
  static CMySingleton* Instance();
  /*** CMySingleton public props #mult #opt ***/
protected:
  /*** CMySingleton protected props #mult #opt ***/
private:
  CMySingleton();
  static CMySingleton* m_instance;
  /*** CMySingleton private props #mult #opt ***/
};
#endif
-------------------------
<p></p>
----- mysing.cpp: ----------
#include "mysing.hpp"
/*** CMySingleton implementation includes #mult #opt ***/
<p></p>
CMySingleton::CMySingleton(){
  /*** CMySingleton::CMySingleton actions #mult #opt ***/
}
CMySingleton* CMySingleton::m_instance = NULL;
<p></p>
CMySingleton*
CMySingleton::Instance(){
  if(m_instance == NULL){
    m_instance = new CMySingleton;
  }
  return m_instance;
}
/*** CMySingleton implementation #mult #opt ***/
-------------------------
</pre>
<P>
<a href="#rl4">Back to Article</A>
</P>
<H4><a name="l5">Listing Five</H4>

<pre>----- myabc.hpp: ----------#ifndef INCLUDE_myabc
#define INCLUDE_myabc
<p></p>
/*** CABC header includes #mult #opt ***/
/*** CABC declarations #mult #opt ***/
class CABC{
public:
  virtual  ~CABC();
  /*** CABC public props #mult #opt ***/
protected:
  /*** CABC protected props #mult #opt ***/
private:
  /*** CABC private props #mult #opt ***/
};
#endif
-------------------------
<p></p>
----- myabc.cpp: ----------
#include "myabc.hpp"
/*** CABC implementation includes #mult #opt ***/
CABC::~CABC(){
}
/*** CABC derived classes #mult #opt ***/
/*** CABC child implementations #mult #opt ***/
/*** CABC implementation #mult #opt ***/
-------------------------
</pre>
<P>
<a href="#rl5">Back to Article</A>
</P>

<HR><I>Copyright &copy; 1997, Dr. Dobb's Journal</I><BR>

</BODY>
</html>
