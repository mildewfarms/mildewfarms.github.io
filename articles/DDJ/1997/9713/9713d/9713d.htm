<html>
<META NAME="year" CONTENT="1997">
<head>
<title>Dr. Dobb's Sourcebook January/February 1997: The Phantom Programming Language</title>
</head>

<body bgcolor="FFFFFF">
<!--Copyright &#169; Dr. Dobb's Journal-->
<h1>The Phantom Programming Language</h1>

<p><i>Dr. Dobb's Sourcebook</i> January/February 1997
</p>
<h2>An interpreted language for distributed programming</h2>

<h3>By Antony Courtney</h3>

<I>Antony is a consulting engineer with Eclipse Technical Group where he is doing research on mobile computing and replicated storage systems. He can be contacted at antony@apocalypse.org.</I>

<hr>

<p>Phantom is an interpreted language designed to address many of the problems that arise when developing large-scale, interactive, distributed applications such as conferencing systems, multiplayer games, or collaborative work tools.</p>

<p>Programmers faced with writing such applications must address fundamental issues of distribution, scale, concurrency, extensibility, and user interface. Many of these issues recur in every distributed, interactive application, making it desirable to provide a common, portable infrastructure for developing these applications. Without an adequate support infrastructure, you get bogged down in the details of complex state management, concurrency issues, and moving bits from place to place, instead of focusing on the target application domain. Phantom is an attempt to remedy this situation by providing an interpreted language and run-time environment that supports flexible, transparent, and secure distribution of both program code and data, while providing enough modern programming language features to support large-scale application development. The interpreter for Phantom is implemented entirely in ANSI C for portability, and may be extended with C procedures using the interpreter's foreign function interface.</p>

<p>For the language's distributed programming features, Phantom uses the distributed lexical scoping semantics of Obliq. Distributed lexical scoping provides transparent access to program code and data from remote sites, while still providing strong network security guarantees. For programmers already familiar with languages such as safe-Tcl or Java, in which the run-time environment supports mobile code (transmission of executable code across computer networks), distributed lexical scoping is of interest because it cleanly integrates run-time support for mobile code with the programming language concepts of higher-order functions and lexical scoping rules.</p>

<p>The language itself is based on a safe, extended subset of Modula-3. Modula-3 was selected as a starting point for Phantom because it provides a number of powerful language features (such as threads, garbage collection, and exception handling), and because its type system provides the level of detail required to automatically convert program values into a canonical form suitable for transmission across a network.</p>

<p>However, Phantom is not Modula-3. Phantom does not provide Modula-3's general-purpose reference types, partially opaque subtypes, or generic modules. Phantom replaces Modula-3's array types with dynamically sized lists, supports slice indexing notation, includes general-purpose higher-order functions and lambda expressions, and provides for type-safe implicit declarations. Phantom also integrates Modula-3's thread model more fully into the language core, including mutex, condition, and thread as predefined types, along with built-in wait, signal, and fork primitives. As a syntactic matter, Phantom uses lower-case keywords, in an attempt to make it clear to programmers that Phantom is not simply a Modula-3 subset.</p>

<p>I developed the Phantom interpreter on a Dell Dimension XPS 90 running Linux 1.2.7. It is also known to run on SunOS 4.1.3. The alpha release is a 2-MB compressed tar file that expands to 10 MB. You will need about 20 MB of disk space to build the interpreter. It's big because it includes versions of the pthreads, Tcl, and Tk libraries. For information on availability of the interpreter, see the Phantom home page at http:// www .apocalypse.org/pub/u/antony/phantom/phantom.html.</p>

<h3>A Prime Numbers Sieve Example</h3>

<p>To get a taste for the Phantom language, consider <a name="rl1"><a href="9713d.htm#l1">Listing One</A> which implements a prime numbers sieve, and prints all prime numbers between 1 and the constant size. <a href="9713d.htm#l1">Listing One</A> illustrates the syntax and most of the basic features of the language. The program consists of a single module that imports two interfaces (<i>stdio</i> and <i>fmt</i>), declares a constant (<i>size</i>) and a procedure (<i>filter</i>), and has a mainline consisting of a statement list. When the interpreter is invoked on the file containing this module, execution proceeds by executing the statements in the mainline.</p>

<p>The mainline constructs a list of integers in the range 0 to <i>size, </i>and assigns this list to the variable <i>sieve. </i>All primes are then "filtered" from the sieve by the subsequent <i>for </i>loop, which iterates over each prime in the sieve, calling the procedure <i>filter </i>for each successive prime. Finally, the results are displayed by iterating over the sieve once more, and printing each nonzero integer remaining in the list.</p>

<p>Note in <a href="9713d.htm#l1">Listing One</A> that there are no explicit variable declarations in the mainline. In Phantom, it is not necessary to declare a local variable prior to its use in a statement block. The first assignment to an undeclared identifier (in an assignment statement or <i>for</i> loop) will declare that variable in the local scope, with a type derived from the expression on the right side of the assignment statement. All subsequent references to the identifier in the statement block will be type checked against this automatically derived type. Such type-safe implicit declarations allow Phantom programs to retain the safety guarantees provided by static typing, without the syntactic overhead of declaring each variable prior to use. (Explicit variable declarations may still be provided -- for example, there is a declaration for the local variable <i>prime </i>of procedure <i>filter</i> -- in which case the type given in the explicit declaration is used for type checking.)</p>

<p>Also note in <a href="9713d.htm#l1">Listing One</A> that, in the formal parameter list of the <i>filter </i>procedure, there are no "mode" specifiers to indicate which parameters are passed by value and which are passed by reference. Instead, <i>filter </i>makes use of the call-by-object-reference semantics of Phantom. In call-by-object-reference, certain types (objects, lists, and thread primitives) are always passed by reference, and values of all other types are always passed by value. In this example, these semantics ensure that changes that <i>filter </i>makes to its formal parameter <i>sieve </i>are visible to the caller.</p>

<h3>Higher-Order Functions</h3>

<p>Phantom procedures are first-class values; procedures may be assigned to variables, passed as parameters, and returned from other procedures, just like other fundamental language types. (In Phantom, functions are just procedures that return a value. Hence, the terms "higher-order function" and "higher-order procedure" are used interchangeably.)</p>

<p>For example, consider <a name="rl2"><a href="9713d.htm#l2">Listing Two</A>, which assigns a procedure <i>incr()</i> to a variable, and passes that variable as a parameter to the procedure <i>apply()</i>, which has a first formal parameter (<i>func</i>) that is a procedure. This program produces the output:</p>

<blockquote><p>
value of x is: 5</p>
<p>
value of x after apply: 15</p>
</blockquote>

<p>In <a href="9713d.htm#l2">Listing Two</A>, the variable <i>x</i> is declared with module-level scope. Thus, the use of identifier <i>x</i> in procedure <i>incr </i>refers to the same variable <i>x</i> used in the mainline.</p>


<p><b>Lambda Expressions.</b> Phantom provides for the dynamic creation of anonymous (unnamed) higher-order functions through the use of lambda expressions. Lambda expressions are modeled after the construct of the same name that appears in nearly all dialects of Lisp (Scheme, for instance).</p>

<p>A lambda expression consists of the keyword <i>lambda</i> followed by a procedure signature (in the same form as a procedure declaration), followed by the body of the lambda enclosed in braces. Braces are used to delimit the body of lambda expressions because they are slightly less verbose than the usual <i>begin</i> and <i>end</i> delimiters used for ordinary procedures.</p>

<p>To illustrate the use of lambda expressions in <a href="9713d.htm#l2">Listing Two</A>, you could entirely eliminate the definition of <i>incr</i>, and replace the assignment <i>myfunc:=incr;</i> in the mainline with <i>myfunc:=lambda (amount:int) {x:=x+amount; };.</i></p>

<p>Lambda expressions are particularly useful in situations where the body of the function is extremely small. In such cases, lambda expressions eliminate the need to give the function an artificial "name," and also improve readability, since the code for the function appears explicitly in the context where it is used.</p>

<p>Higher-Order Functions and Nested Scopes. At run time, Phantom procedures are represented as true closures. A closure is simply a pair consisting of:</p>

<ul>
  <li>A representation of the code in the body of the procedure. This could be either a direct representation as source-code text, or some internal representation such as a parse-tree or bytecodes for a virtual machine.
  <li>An environment that maps all free variable identifiers appearing in the procedure to their corresponding storage locations.
</ul>

<p>Using closures to represent higher-order functions ensures that higher-order functions have an intuitive and well-defined meaning, even in the presence of nested scopes. To illustrate this point, consider <a name="rl3"><a href="9713d.htm#l3">Listing Three</A>, which produces the output:</p>

<blockquote><p>
g() called, x = 10</p>
<p>
after incr(), x = 15</p>
<p>g() returning...</p>

<p>
after incr(), x = 32</p>
</blockquote>

<p>In <a href="9713d.htm#l3">Listing Three</A>, the mainline assigns to variable <i>f </i>the result of calling function <i>g()</i>. The function <i>g()</i> declares a local variable <i>x</i>, and a local (internal) procedure <i>incr()</i>. <i>incr()</i> increments <i>x</i> by the amount given in its argument. The reference to <i>x</i> in <i>incr()</i> refers to the variable <i>x</i> in <i>incr</i>'s surrounding scope (the scope of <i>g</i>).</p>

<p>When <i>g()</i> is called, it allocates storage for a fresh copy of local variable <i>x</i>, and initializes <i>x</i> to the value 10. Next, <i>g()</i> prints the value of <i>x</i>, invokes <i>incr()</i> with the argument 5, and returns the function <i>incr</i> as its result.</p>

<p>After <i>g()</i> returns, the closure for <i>incr</i> is assigned to variable <i>f</i> of the mainline. This closure contains the code for the body of <i>incr</i>, as well as an environment for execution of <i>incr</i>. This environment contains a reference to the variable <i>x</i>, taken from <i>incr</i>'s surrounding scope. Note that this closure retains a reference to <i>x</i>, even though <i>x</i> was allocated as a local variable of procedure <i>g</i>, and <i>g</i> is no longer active. </p>

<p>Finally, the procedure variable <i>f</i> is passed to <i>apply()</i>, along with the argument 17. When <i>apply()</i> executes, it indirectly calls the closure for <i>incr</i>, passing 17 as an argument. Since the environment part of the closure retains a binding to the original location allocated for <i>x</i> (which currently holds the value 15), the call to <i>apply()</i> results in updating <i>x</i> to the value 32, and printing this result.</p>

<p>Most traditional imperative programming languages provide some support for higher-order functions, but do not provide higher-order functions with the level of generality found in Phantom or other symbolic programming languages (such as Scheme). C allows function pointers but does not provide for nested scopes or anonymous higher-order functions. Modula-3 provides nested scopes, but limits their use in higher-order functions by only permitting procedures at the outermost scope level to be assigned to variables or passed as parameters. These languages impose these limitations in order to enable the run-time optimization of allocating local variables in an "activation record" created on the run-time stack when the procedure is called, and destroyed when the procedure returns.</p>

<p>Phantom does not store local variables in an activation record because, as this example illustrates, the provision of general higher-order functions with nested scopes may result in a variable being accessed after the call (in which the variable is created) has returned. In this example, the local variable <i>x</i> of <i>g()</i> is accessed from within the body of <i>incr()</i>, and <i>incr()</i> is called indirectly after the call to procedure <i>g()</i> returns. Instead of using activation records, Phantom generates fresh heap locations for each local variable of a procedure, and this storage is only reclaimed (by the garbage collector) when the location becomes unreachable.</p>

<h3>Object Model</h3>

<p>Phantom supports object-oriented programming, in a manner similar to Modula-3. Phantom objects have attributes (containing state information), methods (for performing operations), and support single inheritance. Phantom uses a class-based object model (rather than prototypes, as in Obliq or Self).</p>

<p>Objects are the focus of communication in Phantom. A Phantom program will generally make its services available to other programs by registering object values with a name service -- a Phantom application server that maps string names to network addresses of Phantom objects.</p>

<p>Recall that Phantom uses call-by-object-reference semantics. This has an important property when passing object values to Phantom programs at remote sites: Objects are never implicitly migrated to remote sites as the result of an assignment, procedure call, or return statement. Instead, the object remains stationary and a network reference is passed to the remote site. If migration of objects across sites is required, it must be performed explicitly by the programmer. While this violates location transparency to some degree, we feel that only the programmer can make reasonable decisions about when and where to migrate objects.</p>

<h3>Distribution Model</h3>

<p>The Phantom distribution model (see <a name="rf1"><a href="9713df1.htm">Figure 1</A>) borrows heavily from the distributed lexical scoping semantics of Obliq. A network connects a number of sites. A site is an invocation of the Phantom interpreter on some host machine. It has a site address that uniquely identifies the site throughout the network. In the current implementation, a site address is simply a pair consisting of the IP address and port number of a TCP socket owned by the interpreter process. A host running a multitasking operating system may contain several sites (corresponding to multiple invocations of the Phantom interpreter).</p>

<p>Within a site, the interpreter maintains a single memory space for the program it is executing. This memory space contains a number of locations. Each location has a location address that uniquely identifies the location within the interpreter's memory space, and holds a value.</p>

<p>Each Phantom program executes as a number of threads within the interpreter. Threads are provided through a library that implements the POSIX pthreads specification. Two data structures are associated with each thread:</p>

<p>A representation of the program code that the thread is executing. In the current implementation, the interpreter uses a sequence of bytecodes for a virtual stack machine for this purpose.</p>

<p>An environment that maps every variable or constant identifier appearing in the Phantom program to a global location address. A global location address is a pair consisting of a site address and a location address within the memory space of that site.</p>

<p>The Phantom interpreter uses environments to provide transparent distribution for Phantom programs. Each statement in a Phantom program may make reference to constant and variable identifiers. As the interpreter executes a statement, it uses the program's current environment to map these identifiers to their corresponding global location addresses. The interpreter then performs the appropriate operation on each location, according to the defined semantics of the language. If the global location address refers to a location within the local interpreter's memory space, the operation is performed directly by the interpreter. If, however, the global location address refers to a location in the memory space of another site, the interpreter sends a request to the remote site and asks it to perform the given operation.</p>

<h3>A Sample Distributed Application</h3>

<p><a name="rl4"><a href="9713d.htm#l4">Listings Four</A>, <a href="9713d.htm#l5">Five</A>, and <a href="9713d.htm#l6">Six</A> illustrate how the interpreter and run time provide Phantom's distributed semantics (and also illustrate the basic techniques for developing dynamically extensible, distributed, interactive applications in Phantom). There are two programs presented. <a href="9713d.htm#l4">Listing Four</A> is an interface that is used by both the client and the server. <a name="rl5"><a href="9713d.htm#l5">Listing Five</A> is a generic client program (such as might be launched as an "external viewer" from a web browser). <a name="rl6"><a href="9713d.htm#l6">Listing Six</A> is an application-specific server with which the client can communicate.</p>

<p>The generic client uses the information in a URL to obtain a reference to a remote application server. Once the client has obtained a reference to the application server, it obtains an autonomous agent from the server: a higher-order procedure received from the remote site that the client executes locally.</p>

<p>The "Hello" server is as an example of an application-specific server. It accepts requests from clients and returns an agent to each client. This agent creates an instance of an interactive "hello world" object at the client's site.</p>

<p>The general-purpose client could be invoked using a command line such as:</p>

<blockquote><p>
$ phi AppClient phi://server.host.name/ HelloServer</p>
</blockquote><p>which starts the Phantom interpreter (phi) executing the module AppClient (the name of the client program) with the URL for the Hello server as a command-line argument available to the client. The agent obtained from the Hello server creates a window on the client's display; see <a name="rf2"><a href="9713df2.htm">Figure 2</A>.</p>

<p>All user-interface events for this window are handled by code for the agent executed at the client site. When users press the Hello button, the agent responds by printing the message "Hello, World" to its output stream. When users press the Quit button, the agent returns control to the client program, which then exits.</p>

<p>While simple, this example illustrates most of the important features of the application domain for which Phantom was designed. This example is both distributed and interactive, the client is dynamically extensible, and all interactive UI events are handled at the client site. These same principles apply to other, more sophisticated applications in the target domain.</p>

<h3>Application-Server Interface</h3>

<p>An application server makes its services available to clients by registering an instance of an <i>AppServer.T</i> object with a name server. The <i>AppServer.T</i> type is implemented by every application-specific server, and is also known to the generic client. This shared interface (see <a href="9713d.htm#l4">Listing Four</A>) defines two types: <i>AppServer.Agent</i> (describing the type of the agent given to the client for local execution) and <i>AppServer.T</i> (the abstract type of an application server). The generic client obtains an agent from an application server by first obtaining a reference to an <i>AppServer.T</i> (using the name service), and then invoking its <i>generate_agent()</i> method. Application-specific servers are implemented by creating subtypes of <i>AppServer.T</i>.</p>

<p>Procedures are first-class types in Phantom, and may be assigned to variables, passed as parameters, and returned from procedures, just like values of other fundamental language types. In this example, the type <i>Agent</i> is declared as a procedure taking two parameters (that must be supplied by the client). Such parameters represent the services that an execution site (the client) makes available to agents received from across the network. In a more general interface, such services would encapsulate all of the local resources the execution site is willing to provide to the agent: a local audio service, a 3-D rendering service, and so on. For simplicity, the only services provided to agents in this example are I/O streams for reading/writing messages.</p>

<h3>Ownership and Access Control</h3>

<p>The <i>generate_agent()</i> method of type <i>T</i> has a name, a procedure signature, and a permissions specification (given by <i>perm x</i> following the signature). Permissions specifications are used to set the access-control properties of attributes and methods.</p>

<p>Each Phantom object is stored in the memory space of an interpreter that communicates with other interpreters across a network. Each object has an owner, represented at run time as a <i>sys.user</i> object corresponding to the user who started the interpreter containing the object.</p>

<p>The permissions specification specifies what operations on the object may be performed by users other than the owner. An operation on an object by a user other than the owner happens when the interpreter receives a request from a Phantom program running on a different site.</p>

<p>Each permissions specification consists of a bitmask of the three permission bits <i>r</i>, <i>w</i>, and <i>x</i>, corresponding to read, write, and execute permission, respectively. (The <i>r</i> and <i>w</i> bits apply only to attributes, and the <i>x</i> bit applies only to methods.) If no permissions specification is given for an attribute or method, the default is that all permission bits are turned off.</p>

<p>In the current example, the <i>generate_ agent()</i> method of <i>AppServer.T</i> has its <i>x</i> bit set in the permissions specification to allow clients at remote sites to invoke this method.</p>

<h3>Client Program</h3>

<p>The client program (<a href="9713d.htm#l5">Listing Five</A>) is straightforward: It obtains the global location address of an <i>AppServer.T</i> object from the name service (defined in the interface <i>ns</i>) using the application's URL, invokes the <i>generate_agent()</i> method of the server to obtain an agent, and executes the agent locally, supplying the standard I/O streams of the client as the parameters to the agent.</p>

<p><a href="9713d.htm#l5">Listing Five</A> works as follows: First, the program calls <i>urllib.parse()</i> to parse the URL given by <i>urlstring</i>. In this example, <i>urlstring</i> is given as a constant; in practice it would use a command-line argument. The procedure <i>urllib.parse()</i> returns the URL as a record with separate protocol, host, and path fields. Next, the client attempts to contact a Phantom name server running on the host given in the URL, using the procedure <i>ns.find()</i>. The <i>ns </i>module and interface is part of the standard Phantom library. The name-server object is located on a local or remote site using a well-known TCP port. The variable identifier <i>name_server</i> is assigned the global location address of the name-server object, returned from the call to <i>ns.find()</i>. Any subsequent operation on the identifier <i>name_server</i> is forwarded transparently by the interpreter to the name-server object, which performs the operation and returns the result.</p>

<p>Next, the <i>lookup()</i> method is invoked on the <i>name_server</i> object to obtain a reference to the application server, using the pathname part of the URL ("HelloServer" in this example). The <i>lookup()</i> method returns its result as type <i>any; </i>the statement following the lookup performs a type-safe run-time type conversion using <i>narrow()</i> to convert this value to an object reference of the appropriate type. After the client performs the <i>lookup()</i> operation, the name server is no longer involved in the communication between the client and the server; it just provides a mechanism for bootstrapping the connection between them. Once the client has a reference to the remote <i>AppServer.T</i> object, operations can be performed on the object reference in the same manner as with the <i>name_ server</i> object; the language run time handles any network communication required.</p>

<p>Next, the client invokes the <i>generate_ agent()</i> method of the <i>app_server</i> to obtain an agent for local execution. Since the value returned from <i>generate_agent()</i> is a procedure, this will result in obtaining the closure for the procedure from the application server. This closure will be dynamically loaded into the memory space of the client, and the variable <i>local_ agent</i> will refer to the closure. The semantics of transmitting closures across sites ensures that this is a safe operation: The code in a closure received from a remote site and executed locally cannot gain unauthorized access to any local resources.</p>

<p>Finally, the client invokes <i>local_agent</i>, passing the standard I/O streams of the client program as parameters. Thus, the client has no information about specific applications hardcoded into it, but dynamically obtains application-specific behavior by obtaining a closure from the server. This generic client program could be used without modification as a client for any application-specific server.</p>

<p>The client wraps the entire body of its mainline in a <i>try-except</i> statement, to catch some of the exceptions that may be raised in the process of obtaining the application-specific agent, and reports these as errors to the user. More sophisticated error-recovery mechanisms could be implemented using this facility.</p>

<h3>Server Program</h3>

<p>The application-specific server (<a href="9713d.htm#l6">Listing Six</A>) is a "Hello, World" server. It returns to clients an agent that, when executed at the client site, creates a graphical, interactive "Hello, World" window on the client's display. The agent uses the library interface between Phantom and the Tk toolkit to implement the GUI for the agent.</p>

<p>The server defines the type <i>ServerImpl</i> as a subtype of <i>AppServer.T</i>. This is a common technique in Phantom: An object type appearing in an interface will describe the external view presented to clients, and a subtype will be used to implement the application-specific server.</p>

<p><a href="9713d.htm#l6">Listing Six</A> is implemented as follows: First, the actual server object is implemented as a subtype of the object type <i>AppServer.T</i>. The subtype (<i>ServerImpl</i>) does not add any attributes or methods to <i>AppServer.T</i>, it simply overrides the <i>generate_agent()</i> method of <i>AppServer.T</i>. Hence, the body of the <i>ServerImpl</i> is empty, since it does not have any specific attributes or methods, and, in Phantom, method overrides are not stated explicitly in the object type.</p>

<p>Next, the application server defines the object type <i>Hello</i> as a subtype of <i>Tk.Frame</i>. No instance of this type is ever created at the server site; instead, an instance of it is created at the client site by the application-specific agent. When the agent is transmitted from the server to the client, all information about types used within the agent is transmitted across the network and reconstructed at the client site. For object types, this includes both the information necessary to construct instances of the type, and the code for any methods. Note that a type may refer to other types in its definition, and types may be recursive. The run time will transmit all necessary type information, including information about types referenced indirectly or recursively.</p>

<p>The agent returned to clients is the procedure <i>client_agent()</i> defined in the <i>generate_agent()</i> method of <i>ServerImpl</i>. The <i>client_agent()</i> procedure, executed at the client site, creates a new instance of type <i>Hello</i> at the client site, and invokes the <i>main_loop()</i> method of <i>Hello</i> to process GUI events that happen in this object. The <i>main_loop()</i> method of <i>Hello</i> is inherited from <i>Tk.Frame</i>, the parent type of <i>Hello</i>.</p>

<p>Finally, the mainline of <i>HelloServer</i> creates a new instance of <i>ServerImpl, </i>and registers this with the local name server. When the Phantom interpreter is invoked to run the server application, it would be invoked with the <i>-noexit</i> option, to ensure that the interpreter does not exit after initialization, but instead waits idly for requests from remote sites.</p>

<h3>Semantics of Procedure Transmission</h3>

<p>In Phantom, a higher-order procedure is stored as a closure containing the code for the procedure as well as an environment that maps free identifiers appearing in the procedure to their corresponding storage locations. These storage locations are, in fact, global location addresses. Using global location addresses in closures gives higher-order procedures an intuitive and secure meaning in a distributed context; see <a name="rf3"><a href="9713df3.htm">Figure 3</A>.</p>

<p>Transmitting the environment along with the code for the procedure preserves the correct lexical scoping semantics when the procedure is executed at the remote site. When the procedure body makes reference to a free identifier, the binding to the global location address ensures that the operation is performed on the location where the identifier was bound originally.</p>

<p>The "Hello, World" example illustrates a limited case of transmitting procedures across sites. In that example, the procedure that is transmitted to the client site as the application-specific agent has no free variable identifiers. That is, the procedure <i>client_agent()</i> does not refer to any variables from its enclosing scope. This is an example of a "disconnected" agent: All information needed to execute the procedure at the client site can be encapsulated in the code of the closure, and the closure's environment will be empty. Although <i>client_agent()</i> does refer to types (such as the <i>Hello</i> object type) from enclosing scopes, this type information is transmitted to the client site as part of the code of <i>client_agent()</i>'s closure.</p>

<p>If the body of <i>client_agent()</i> made reference to a variable in its surrounding scope, the environment of the closure transmitted to the client would contain a binding to the location of the variable at the server site. This would have the effect of creating a "connected" agent: one that carries its network connections with it. This facility could be used to create a distributed multiplayer game, for example. The agent transmitted to the client could simply invoke operations on an object (representing the opposing player) declared in one of the agent's enclosing scopes. Any time the agent (executing at the client site) performed such an operation, the client run time would use the environment transmitted with the agent to forward the operation to the site where the object resides. </p>

<h3>Security Considerations</h3>

<p>Phantom's distribution model raises a number of interesting security issues. The most important issue has to do with the ability to send code across sites: The language and run time must provide strong guarantees about the safety of executing code received from a potentially untrustworthy server.</p>

<p>The language and run-time environment must guarantee that program code received from a remote site and executed locally will not have access to any local resources that could not have been accessed via RPC from the remote site.</p>

<p>Phantom makes this guarantee through adherence to lexical scoping in the context of distribution and higher-order functions. In practical terms, the implementation guarantees lexical scoping by passing a set of bindings for all free identifiers along with the code for a procedure. When an interpreter receives a procedure from a remote site, it can perform a single, static check to ensure that all free identifiers in the code for the procedure have a corresponding entry in the set of bindings received with the procedure. If any free identifier does not have a corresponding binding, the interpreter will abort the operation requested by the remote site and return a security-violation exception.</p>

<p>The language has no general-purpose pointer types. This is crucial to security. Eliminating general-purpose pointers ensures that the only way a procedure can refer to resources outside the body of the procedure is through free identifiers. Since the implementation ensures that free identifiers are handled through strict lexical scoping, executing procedures received from remote sites is guaranteed secure; there is simply no mechanism for the procedure to gain unauthorized access to any local resources.</p>

<h3>Current Status</h3>

<p>Currently, a prototype interpreter exists for the Phantom language core. The interpreter supports all of the basic features in the language, including static typing, type-safe implicit declarations, objects, interfaces, threads, exceptions, garbage collection, dynamically sized lists, and higher-order functions, and includes a library interface to the Tk toolkit. A number of demonstration programs have been written in Phantom. The initial results are limited but encouraging: The language's Modula-3 heritage affords it a number of powerful features, while still maintaining overall coherence and simplicity. The implementation of the networking subsystem in the interpreter required for distribution support is not complete.</p>

<h3>Acknowledgment</h3>

<p>Special thanks to David Abrahamson, Luca Cardelli, Dan Connolly, Bill Janssen, Danny Keogan, Ciaran McHale, Killian Murphy, and Brendan Tangney, who read drafts of earlier versions of the language report and this paper, and provided valuable feedback on the exposition and language design.</p>

<p><b>DDJ</b></p>

<H4><a name="l1">Listing One</H4>

<pre>(* primes.pm -- a simple primes numbers sieve in Phantom *)module primes;
<p></p>
import stdio, fmt;
const
   size = 5000;
(* filter out all multiples of n from sieve *)
proc filter(n: int; sieve: list&lt;int&gt;)
var
   prime:=n;
begin
   n:=n+prime;
   while n &lt; len(sieve) do
      sieve[n]:=0;
      n:=n+prime;
   end;
end;
begin
  (* construct the initial (unfiltered) sieve *)
  sieve:=[0..size];
<p></p>
  (* filter out all primes from sieve *)
  for prime in sieve do
    if prime &gt; 1 then
       filter(prime,sieve);
    end;
  end;
  (* and display the results *)
  for i:=2 to last(sieve) do
     if sieve[i] # 0 then
       stdio.puts(fmt.fint(sieve[i]) @ "\n");
     end;
  end;
end primes.
<p></p>
</pre>
<P>
<a href="#rl1">Back to Article</A>
</P>
<H4><a name="l2">Listing Two</H4>

<pre>module simplehigher;import stdio,fmt;
var
  x: int:=0;
proc incr(amount: int)
begin
  x:=x+amount;
end;
proc apply(func: proc(v: int); arg: int)
begin
  func(arg);
end;
begin
  x:=5;
  stdio.puts("value of x is: " @ fmt.fint(x) @ "\n");
  myfunc:=incr;     (* assign incr to procedure variable myfunc *)
  apply(myfunc,10); (* pass procedure as a parameter *)
  stdio.puts("value of x after apply: " @ fmt.fint(x) @ "\n");
end simplehigher.
<p></p>
</pre>
<P>
<a href="#rl2">Back to Article</A>
</P>
<H4><a name="l3">Listing Three</H4>

<pre>(* higher.pm -- an example that illustrates higher-order functions, * nested scopes, and scope escapement
 *)
module higher;
import stdio, fmt;
(* g() returns its internally-nested procedure, incr() to the caller; as
 * a result, incr is said to "escape its scope".
 *)
proc g(): proc (v: int)
  var
    x := 10;
  proc incr(y: int)
  begin
    x:=x+y;
    stdio.puts("after incr(), x = " @ fmt.fint(x) @ "\n");
  end;
begin
  stdio.puts("g() called, x = " @ fmt.fint(x) @ "\n");
  incr(5);
  stdio.puts("g() returning...\n");
  return incr;
end;
proc apply(p: proc(arg: int); v: int)
begin
  p(v);
end;
begin
  f:=g();
  apply(f,17);
end higher.
<p></p>
</pre>
<P>
<a href="#rl3">Back to Article</A>
</P>
<H4><a name="l4">Listing Four</H4>

<pre>interface AppServer;import rd, wr;
(* An Agent is simply a procedure executed at the client site *)
type Agent = proc (istrm: rd.T; ostrm: wr.T);
<p></p>
(* AppServer.T -- an application server *)
type T=object (serialized, protected)
methods
  (* generate a new agent for execution at the client *)
  generate_agent(): Agent perm x;
end;
end AppServer.
<p></p>
</pre>
<P>
<a href="#rl4">Back to Article</A>
</P>
<H4><a name="l5">Listing Five</H4>

<pre>(* AppClient.pm -- implementation of a general-purpose network client *)module AppClient;
import AppServer, Tk, stdio, ns, sys, urllib;
const
  urlstring = "phi://server.host.name/HelloServer";
begin
  try
    url:=urllib.parse(urlstring);
    name_server:=ns.find(url.host);
    app_ref:=name_server.lookup(url.path);
    app_server:=narrow(app_ref, AppServer.T);
    (* obtain the agent from the server *)
    local_agent:=app_server.generate_agent();
    (* and execute the agent locally *)
    local_agent(stdio.stdin,stdio.stdout);
  except
    urllib.malformed =&gt;
         stdio.stderr.puts("error: malformed URL: " @ urlstring @ "\n");
  | sys.narrow_failure =&gt;
         stdio.stderr.puts("error: URL does not refer to an AppServer\n");
  | ns.not_available =&gt;
          stdio.stderr.puts("error: could not contact name server at host " @
                            url.host @ "\n");
  | ns.unknown_service =&gt;
          stdio.stderr.puts("error: application " @ url.path @
                            " not registered with nameserver.\n");
  end;
end AppClient.
<p></p>
</pre>
<P>
<a href="#rl5">Back to Article</A>
</P>
<H4><a name="l6">Listing Six</H4>

<pre>module HelloServer;import AppServer, Tk, rd, wr, ns, stdio;
(* ServerImpl is the type of the "hello" application server; implemented as a
 * subtype of AppServer.T
 *)
type ServerImpl=AppServer.T object
end;
(* Hello is the object type instantiated at the client site *)
type Hello=Tk.Frame object
   quit: Tk.Button;
   msg: Tk.Button;
   wstrm: wr.T;     (* stream on which to write messages *)
methods
   CreateWidgets();
   say_hi();
end;
(* methods of Hello: *)
proc Hello.CreateWidgets(self: Hello)
begin
  self.quit:=new(Tk.Button,
                  master:=self,
                  text:="Quit",
                  fg:="red",
                  command:=lambda () { self.exit(); });
  self.quit.pack(side:=Tk.left);
  self.msg:=new(Tk.Button,
                 master:=self,
                 text:="Hello",
                 command:=lambda () { self.say_hi(); });
   self.msg.pack(side:=Tk.left);
end;
(* init() method -- called automatically to initialize new instances *)
proc Hello.init(self: Hello)
begin
  Tk.Frame.init(self); (* call super-class init method *)
  self.pack();
  self.CreateWidgets();
end;
proc Hello.say_hi(self: Hello)
begin
  self.wstrm.puts("Hello, world!\n");
end;
(* methods of Hello Server: *)
proc ServerImpl.generate_agent(self: ServerImpl): AppServer.Agent
 (* client_agent() is the procedure returned by generate_agent() and
  * executed at the client site
  *)
 proc client_agent(istrm: rd.T; ostrm: wr.T)
 begin
   hello_app:=new(Hello,
                  wstrm:=ostrm);
   hello_app.main_loop();
 end;
begin
  return client_agent;
end;
begin
  (* create an instance of the server, and register it with the local name
   * service
   *)
  hello_server:=new(ServerImpl);
  name_server:=ns.find();
  name_server.register("HelloServer",hello_server);
end HelloServer.
</pre>
<P>
<a href="#rl6">Back to Article</A>
</P>



</body>
</html>
