<HTML>
<META NAME="year" CONTENT="1989">
<HEAD>

<TITLE>DEC89: AN OBJECT-ORIENTED LOGIC SIMULATOR</TITLE></HEAD>
<body bgcolor="FFFFFF">
<h1>AN OBJECT-ORIENTED LOGIC SIMULATOR<a name="0267_0003"><a name="0267_0003"></h1><P>
<h2><a name="0267_0001"><a name="0267_0000">Wire-wrapping and breadboarding made easy</h2><P>
<h3>Kenneth E. Ayers</h3><P>
<p><i><a name="0267_0002"><a name="0267_0000">Ken Ayers is a self-educated software engineer.  He is currently employed by Industrial Data Technologies of Westerville, Ohio.  His interests include computer graphics, machine intelligence, and OOP systems.  He can be reached at 7825 Larchwood St., Dublin, OH 43017.</i></p><hr><P>
As a bench technician in a research and development laboratory, my primary job was to build prototype circuits with digital logic devices, and to make sure that the prototypes worked.<P>
After migrating into the world of software, I saw no reason why my computer could not simulate those same digital logic circuits.  When I discovered object-oriented programming, I became more and more convinced that it was both possible and practical.<P>
The project, which I named LogicLab, was intended from the start to simulate not just logic devices, but the complete bench environment.  LogicLab was required to provide the simulated equivalent of four aspects of that environment:<P>
<ol>1.     A well-stocked parts cabinet containing standard integrated circuit (IC) devices (74LSOO, and so forth);</ol><P>
<ol>2.     A method to connect the pins of the ICs together (commonly called a &quot;breadboarding system&quot;);</ol><P>
<ol>3.     A source of signals (clocks, pulses, switches, and so on) that could be used to simulate inputs to the circuit;</ol><P>
<ol>4.     A logic analyzer that I could use to monitor the activity within my circuit for debugging purposes.</ol><P>
At first glance, these four simulations appear simple.  If implemented properly, they would indeed emulate the workbench environment.  But when these simulations were expanded to the level of detail required for an effective implementation, the task seemed overwhelming.<P>
I had previously considered tackling this project with a combination of C and assembly language, and estimated that the time required to produce a prototype in those languages would be about 8 to 12 months.  When I used Smalltalk to write LogicLab, I had a working version of the project in roughly 100 hours!  I spent much of that time learning to use the incredibly complete environment provided with Smalltalk/V.  The environment includes more than 100 classes and some 2000 methods, and source code is provided for everything (except the compiler itself!).  After building the prototype, I invested another 150 (or so) hours on the project in order to give LogicLab a major overhaul that improved both performance and the user interface.<P>
<h3><a name="0267_0004">A Glance Inside LogicLab<a name="0267_0004"></h3><P>
The heart of LogicLab -- the simulation kernel -- is shown in <a href="8912f.htm#0267_0009">Listing One</A> (page 130).  The system also includes more than 20 object classes.  Nearly all of these object classes correspond directly to real-life counterparts on the design bench.  Some of the typical simulated devices are a toggle switch (<a href="8912f.htm#0267_000b">Listing Two</A>, page 136), a pulser switch (<a href="8912f.htm#0267_000d">Listing Three</A>, page 136), and a logic device <a href="8912f.htm#0267_000f">Listing Four</A>, page 137).  Other simulated devices include buttons, switches, logic probes, input signals, a logic analyzer, and an assortment of logic devices. A list of the class hierarchy for LogicLab is given in <a href="8912f.htm#0267_0005">Figure 1</A>. <a href="19890269.htm">Figure 2</A> shows a typical display produced by LogicLab's logic analyzer.<P>
<h4><a name="0267_0005"><a name="0267_0005"><B>Figure 1:</B> LogicLab's class hierarchy</h4><P>
<pre>
  Object
    Button
       MomentaryActionButton
    ButtonPanel
    VariableMenu
    EmptyMenu

    TimeInterval
    LogicNode
    LogicProbe

       LogicComponent
          LogicDevice
             N74LS00

          LogicSignal
             ClockInput
             ConstantInput

          LogicSwitch
             PulserSwitch
             ToggleSwitch

    LogicAnalyzer
    LogicLab</pre><P>
<P>
LogicLab is organized into two discrete application phases.  The first phase is the breadboard.  In this phase, the user installs devices into the circuit and makes the connections between pins.  This process is very similar to the process of wire-wrapping, and is driven by a series of pop-up menus and prompts for device names and pin numbers.<P>
The second application phase in LogicLab is the logic analyzer.  In a hardware workbench environment, the logic analyzer is used as a testing and debugging tool.  The logic analyzer has a number of probes (LogicLab's logic analyzer has eight probes) that can be connected to various points in the circuit (usually to pins on ICs).  While the circuit is operating, the logic analyzer records and displays the states monitored by each probe.  The output is a timing diagram that illustrates the relationships between signals in the circuit.  A technician uses this information to determine if the circuit is functioning properly.  If the circuit is not functioning properly, this information is used to identify where a problem (a bug!) might be found.<P>
Because LogicLab is a simulation, the process of using the logic analyzer is handled a little bit differently than in a hardware circuit.  LogicLab simulates time in discrete steps.  In essence, LogicLab examines all of the IC input pins and calculates the corresponding output states.  After LogicLab completes the calculation, it pretends that one nanosecond (a billionth of a second) has passed, and then repeats the process.<P>
Between nanoseconds, LogicLab performs housekeeping chores -- such as updating the timebase, recording the states at the probes, and updating the timing diagram display.<P>
<h3><a name="0267_0006">The State Connection<a name="0267_0006"></h3><P>
One object class -- the LogicNode class -- performs the majority of the work during a simulation.  This class simulates the electrical connections within a circuit.  Each pin of a simulated logic device (most devices have 14, 16, or more pins) is associated with a LogicNode; each input signal has a LogicNode; and the private data for each switch or push-button device includes a LogicNode.<P>
The LogicNode class is a good example to use for demonstrating the close correspondence between physical objects and their software counterparts.  <a href="1989026a.htm">Figure 3</A> shows the conceptual organization of pins on an IC.<P>
A characteristic of hardware logic devices is that a change in an input signal requires a finite amount of time before the corresponding change appears at the output.  This delay is known as the &quot;propagation delay.&quot;  The length of the propagation delay is determined by examining the specifications (data sheets) for a particular type of device.<P>
In a hardware logic device, the propagation delay occurs within the logic elements (transistors, diodes, and so forth) inside the device.  Because of different signal path lengths within an IC, the propagation delay at an output can often differ, based upon which input signal is present.  (For example, in a typical flip-flop, the delay from the reset input to the data output is different than the delay from the clock input to the data output.)<P>
To accommodate this phenomenon, I have modeled the propagation delay as an integral part of the electrical connection rather than as a part of the device.  When a new IC object is created, each of its pins is assigned a delay value by the initialization method for that device class.<P>
Each LogicNode maintains a record of both its internal and its external state.  In this case, the &quot;external state&quot; is the (high or low) state that actually appears at the pin of the device.  The &quot;internal state&quot; is the state that is present at the logical elements of the device.  Each LogicNode also keeps a record of its most recent internal state.  This extra state record is essential to the simulation of edge-triggered devices, such as flip-flops and counters.<P>
In the case of LogicNodes that are associated with output pins, a change in the internal state (as the result of a logical computation) triggers a propagation delay counter.  If the internal and external states are still different when the counter reaches zero, the internal state appears at the output -- that is, the internal state's value is stored in the node's external state variable.  During each simulation cycle, an output state is broadcast to all other nodes to which that node is connected.<P>
This brings us to another point.  An isolated IC pin is of little use.  An IC pin must be connected to other pins, input signals, or output devices in order to perform a useful function.  Each of LogicLab's simulated pins maintains a list of the other LogicNodes that form its connection chain.  The node's private data contains the identity of its successor and its predecessor nodes.  This information allows an output pin to access all of the input pins that are affected by the output pin's signal.<P>
<a href="8912f.htm#0267_0011">Listing Five</A> (page 138) is the source code for the output method implemented in the LogicNode class.  This method detects changes in the node's internal state, times the propagation delay, and broadcasts the current external state along the node's connection chain.  The output method is invoked at each simulation cycle, once per simulated nanosecond.<P>
<h3><a name="0267_0007">Putting It All Together<a name="0267_0007"></h3><P>
Ultimately, LogicLab simulates a circuit.  Somewhere along the line, it must simulate logic devices.  <a href="8912f.htm#0267_0013">Listing Six</A> (page 138) is the simulation method found in the class N74LS00.  A hardware 74LS00 device is commonly known as a &quot;Quad 2-Input NAND gate.&quot; This name indicates that a single IC in this device contains four logic gates.  The output of each gate is determined by logically ANDing tow inputs and then negating that operation -- hence the name &quot;NOT-AND,&quot; or &quot;NAND.&quot;<P>
The primary characteristic of this type of gate, which is exploited by the simulation, is that its output is low only when both inputs are high.<P>
In LogicLab, one of the variables in each logic device is an array of LogicNodes.  In <a href="8912f.htm#0267_0013">Listing Six</A>, the statement (pins at: 1) isHigh fetches the LogicNode from the first element of the device's pins array.  The message isHigh is then sent to that LogicNode.  In response to the isHigh message, the LogicNode returns either a true or false value, depending upon whether the node's internal state is high or low.<P>
Most simple logic gates can be simulated in a similar manner.  More complex functions, such as flip-flops and counters, can also be simulated in the same general way as long as you recognize that latched devices must remember their previous state between simulation cycles.<P>
As a test of LogicLab's ability to simulate an actual circuit, I breadboarded the simple divide-by-three counter shown in <a href="1989026b.htm">Figure 4</A>.  The timing diagram that is expected for this circuit is shown below the schematic.  Compare this timing diagram to the timing diagram in <a href="1989026c.htm">Figure 2</A>, which was produced by LogicLab's simulation of the circuit.  The primary difference between the two timing diagrams is the length of the propagation delays between inputs and outputs.<P>
<h3><a name="0267_0008">Objects Pay Big Dividends<a name="0267_0008"></h3><P>
This project demonstrated to me, beyond any doubt, the value of using an object-oriented programming system to construct a simulation.  The ability to construct objects by using their physical counterparts as models meant that I was able to work within a familiar framework -- I already knew the relationships between logic devices, signals, logic probes, and analyzers. Smalltalk let me express those relationships essentially intact.  Other languages would have required me to translate those relationships into a more rigid and less expressive form. Smalltalk's integrated, fully interactive development environment also assisted me at every step and let me produce the prototype with relative ease.<P>
The only drawback to Smalltalk is its performance.  Not only is Smalltalk an interpreted language, but the overhead associated with message sends inflicts a significant penalty upon run-time performance.  The end result is that LogicLab requires approximately one second of real time for every ten nanoseconds of simulated time.  Blazing speed is not this simulator's claim to fame!  But the slow run-time performance is easily overlooked, once you've experienced firsthand the ease with which Smalltalk lets you transform ideas into functional extensions of the environment itself.<P>

_AN OBJECT-ORIENTED LOGIC SIMULATOR_
by Kenneth E. Ayers

<a name="0267_0009"><a name="0267_0009">
<a name="0267_000a"></pre><B>[LISTING ONE]</B><pre><a name="0267_000a">

Object subclass: #LogicLab
  instanceVariableNames:
    'devices signals switches clashes changed topPane analyzer breadboard
                                               listSelector currentComponent '
  classVariableNames: ''
  poolDictionaries:
    'FunctionKeys CharacterConstants ' !

!LogicLab class methods !
description
         &quot;Answer a String describing the
         application and version.&quot;
      ^'LogicLab (Version 1.0 -- 06/26/88)'.!
new
        &quot;Answer an initialized LogicLab application.&quot;
    | logicLab |
    logicLab := super new.
    logicLab initialize.
    ^logicLab.! !

!LogicLab methods !
addComponent: aComponent
           &quot;Add aComponent to the circuit description.
         If there is an error, answer nil;  otherwise
         answer aComponent.&quot;
    | name |
       name := aComponent name.
    name size == 0
         ifTrue: [
           &quot;
                User is installing -- get a name.
            &quot;
         name := self getNewName.
          name isNil
            ifTrue: [^nil].
          aComponent name: name]
        ifFalse: [
           &quot;
                A name has been supplied -- this implies
                that the component is being installed from
                a file.  Need to check for a clash with
                an existing name.
            &quot;
          ((self componentNamed: name) isNil)
          ifFalse: [
                &quot;
                        Had a name clash -- get a synonym
                        from the user and stash both of them
                        away in the clashes table.  Then
                        rename the component.
                    &quot;
                 name := self getNewName.
                name isNil
               ifTrue: [^nil].
              clashes
                 at: aComponent name
                    put: name.
              aComponent name: name]].
    changed := true.
    aComponent isDevice
           ifTrue:  [devices add: aComponent]
     ifFalse: [
           aComponent isSignal
           ifTrue:  [signals add: aComponent]
             ifFalse: [
                switches add: aComponent.
                analyzer isNil
                   ifFalse: [analyzer addSwitch: aComponent]]].
    ^aComponent.!
allNames
      &quot;Answer an array of all of the
         names of installed components.&quot;
    ^((self deviceNames), (self signalNames), (self switchNames)).!
analyzer: aModel
       &quot;Set the LogicAnalyzer Application model
         to aModel.&quot;
       analyzer := aModel.!
breadboardList
         &quot;Answer an array of strings according to the
         current list selector.&quot;
    listSelector isNil
           ifTrue: [listSelector := #listDevices].
      ^(self perform: listSelector).!
breadboardMenu
           &quot;Private -- answer the menu that processes
         breadboard functions.&quot;
    MenuPosition := Cursor position.
    ^(Menu
          labels: ('Load\Save\Erase\List\',
                 'Install\Connect\Remove\Disconnect\',
               'Simulate\',
            'Quit') withCrs
      lines: #(4 8 9)
     selectors: #(load     save     erase   list
               install  connect  remove  disconnect
                run
                quit)).!
changed
     &quot;Answer true if the circuit has changed.&quot;
    ^changed.!
changed: aBoolean
     &quot;Set the circuit-changed flag to aBoolean.&quot;
    changed := aBoolean.!
close
      &quot;Close the LogicLab breadboarding window.&quot;
    topPane dispatcher deactivateWindow closeWindow.!
closeIt
        &quot;Close the breadboard application window.&quot;
    self close.!
componentNamed: aName
           &quot;Answer the component (device, signal, or switch)
         whose name is aName.  If no component can be found
         answer nil.&quot;
    | realName |
    realName := aName.
      clashes isNil
           ifFalse: [
         (clashes includesKey: aName)
          ifTrue:  [realName := clashes at: aName]].
    devices do: [:aDevice|
         (aDevice name = realName)
           ifTrue: [^aDevice]].
      signals do: [:aSignal|
        (aSignal name = realName)
         ifTrue: [^aSignal]].
    switches do: [:aSwitch|
        (aSwitch name = realName)
          ifTrue: [^aSwitch]].
     ^nil.!
componentTypeMenu: selectorArray
           &quot;Answer a user-selected action for a
         component type.&quot;
    ^((Menu
           labels: 'Device\Signal\Switch' withCrs
         lines: #()
           selectors: selectorArray) popUpAt: MenuPosition).!
connect
        &quot;Make a user-specified connection.&quot;
    | from to |
    from := self getNode.
    from isNil
     ifTrue: [^nil].
    to := self getNode.
       to isNil
       ifTrue: [^nil].
    from connect: to.
       changed := true.
    currentComponent := from model.
      listSelector := #listComponentConnections.
    breadboard update.!
description
          &quot;Answer a string with a description of the receiver.&quot;
    ^(self class description).!
deviceNames
         &quot;Answer a collection of all of the
         names of installed devices.&quot;
    | list |
    list := OrderedCollection new: (devices size).
    devices  do: [:aDevice| list add: aDevice name].
      ^list.!
devices
        &quot;Answer the list of installed devices.&quot;
       ^devices.!
disconnect
           &quot;Remove a user-specified connection.&quot;
    | node |
    node := self getNode.
    node isNil
           ifTrue: [^nil].
      node disconnect.
    changed := true.
      currentComponent := node model.
    listSelector := #listComponentConnections.
       breadboard update.!
erase
       &quot;After user-verification, erase
         the circuit description.&quot;
    Cursor offset: MenuPosition.
    (self verify: 'Erase circuit description?')
       ifFalse: [^nil].
    self eraseCircuit.
    listSelector := #listDevices.
    changed := true.
      breadboard update.!
eraseCircuit
     &quot;Erase the circuit description.&quot;
    devices  do: [:aDevice|
        self removeComponent: aDevice].
    signals  do: [:aSignal|
          self removeComponent: aSignal].
     switches do: [:aSwitch|
        self removeComponent: aSwitch].
       self initialize.!
getExistingComponent
        &quot;Answer a user-specified component.&quot;
    | name component reply list |
     name := self getName.
      name isNil
        ifTrue: [^nil].
    component := self componentNamed: name.
      component isNil
     ifFalse: [^component].
       Cursor offset: MenuPosition.
       (Menu message:
         (name, ' not installed -- select from list?')) isNil
     ifTrue: [^nil].
    Cursor offset: MenuPosition.
    reply := self componentTypeMenu:
                 #(deviceNames signalNames switchNames).
       Cursor offset: MenuPosition.
       reply isNil
          ifTrue: [^nil].
     list := self perform: reply.
     (list size == 0)
     ifTrue: [
          Menu message: 'None installed'.
          Cursor offset: MenuPosition.
          ^nil].
       name := VariableMenu selectFrom: list.
    name isNil
           ifTrue: [^nil].
      name := list at: name.
    ^(self componentNamed: name).!
getExistingName
     &quot;Answer a user-specified name of
         an existing component.&quot;
    | component |
    component := self getExistingComponent.
     component isNil
        ifTrue: [^nil].
       ^(component name).!
getFile
         &quot;Answer a FileStream for a
         user-specified filename.&quot;
    | name |
     name := self getFilename.
    name isNil
        ifTrue: [^nil].
       ^(File pathName: name).!
getFilename
          &quot;Answer a user-specified filename.&quot;
    | name |
     Cursor offset: MenuPosition.
     name :=
        Prompter
         prompt: 'Enter filename'
            default: ''.
    Cursor offset: MenuPosition.
    ^name.!
getName
          &quot;Answer a user-specified name.&quot;
     | name |
    Cursor offset: MenuPosition.
    name :=
        Prompter
            prompt: 'Enter component name'
           default: ''.
      Cursor offset: MenuPosition.
      ^name.!
getNewName
       &quot;Answer a user-specified name for
         a new component.&quot;
      | name |
    Cursor offset: MenuPosition.
    name :=
         Prompter
          prompt: 'Enter name for new component'
            default: ''.
       Cursor offset: MenuPosition.
       name isNil
         ifTrue: [^nil].
    [(self componentNamed: name) isNil]
       whileFalse: [
         name :=
            Prompter
                prompt: 'Name exists -- enter NEW name'
                default: name.
         Cursor offset: MenuPosition.
         name isNil
               ifTrue: [^nil]].
      ^name.!
getNode
        &quot;Answer a user-specified LogicNode.&quot;
    | component |
     component := self getExistingComponent.
    component isNil
       ifTrue: [^nil].
    ^(component getNode).!
initialize
          &quot;Private -- initialize a new
         LogicLab application.&quot;
    devices  := OrderedCollection new.
       signals  := OrderedCollection new.
     switches := OrderedCollection new.
    changed := true.!
install
           &quot;Install a user-specified component.&quot;
    | component |
     component := LogicComponent install.
     component isNil
        ifTrue: [^nil].
       self addComponent: component.
    listSelector := self listSelectorFor: component.
    breadboard update.
    ^component.!
installClassFrom: aStream
       &quot;Install a LogicComponent subclass
         whose name is the next word on aStream.&quot;
      | className |
       className := aStream nextWord.
    (Smalltalk includesKey: className asSymbol)
        ifFalse: [
          self error: ('Class: ', className, ' not installed')].!
installComponentFrom: aStream
      &quot;Install a LogicComponent instance
         whose name is the next word on aStream.&quot;
     | className class component |
      className := aStream nextWord.
    class := LogicComponent classNamed: className.
    class isNil
     ifTrue: [
          self error: ('Unknown class: ', className).
         ^nil].
    component := class new installFrom: aStream.
    component isNil
          ifTrue: [^nil].
     ^(self addComponent: component).!
installConnectionFrom: aStream
        &quot;Install a connection from aStream.&quot;
    | fromName from toName to fromNode toNode |
    fromName := aStream nextWord.
    from := self componentNamed: fromName.
      from isNil
        ifTrue: [
          self error: ('Unknown component: ', fromName).
            ^nil].
    fromNode := from getNodeFrom: aStream.
    fromNode isNil
         ifTrue: [
           self error: ('Unknown node on: ', fromName).
           ^nil].
    toName := aStream nextWord.
       to := self componentNamed: toName.
     to isNil
     ifTrue: [
          self error: ('Unknown component: ', toName).
          ^nil].
    toNode := to getNodeFrom: aStream.
    toNode isNil
      ifTrue: [
           self error: ('Unknown node on: ', toName).
         ^nil].
    ^(fromNode connect: toNode).!
installFrom: aStream
        &quot;Load a circuit from the description
         on aStream.&quot;
    | keyWord |
    clashes := Dictionary new.
      [(aStream atEnd)
      or: [(keyWord := aStream nextWord) isNil]]
        whileFalse: [
         keyWord = 'LOAD'
              ifTrue:  [
                 self installClassFrom: aStream]
           ifFalse: [
                 keyWord = 'INSTALL'
                 ifTrue:  [
                    self installComponentFrom: aStream]
                  ifFalse: [
                     keyWord = 'CONNECT'
                        ifTrue:  [
                           self installConnectionFrom: aStream]
                          ifFalse: [
                        self error:
                            ('Unknown command: ',
                              keyWord)]]]].
      clashes release.
    clashes := nil.!
list
      &quot;Process a user-specified list request.&quot;
    | selection |
    selection :=
       (Menu
         labels: ('Components\Connections\',
                  'Circuit Description') withCrs
          lines: #()
         selectors: #(listComponents
                      listConnections
                      listCircuit))
         popUpAt: MenuPosition.
    selection isNil
          ifTrue: [^nil].
     listSelector := selection.
    breadboard update.!
listCircuit
         &quot;Answer a collection of strings with
         the circuit description.&quot;
    | name stream list |
    CursorManager execute change.
    name := 'logiclab.tmp'.
       stream := File pathName: name.
    list := OrderedCollection new.
    stream
         nextPutAll: '****  Circuit Description  ****';
       cr;
          cr.
    self storeOn: stream.
    stream flush.
    stream position: 0.
    [stream atEnd]
        whileFalse: [list add: stream nextLine].
    stream close.
     File remove: name.
    CursorManager normal change.
    ^list.!
listComponentConnections
          &quot;Answer a collection of strings listing
         the connection chain(s) for the
         'currentComponent'.&quot;
    currentComponent isNil
        ifTrue:  [^#()]
       ifFalse: [
          ^(#('****  Connection List  ****' ' '),
              currentComponent connectionList)].!
listComponents
         &quot;Answer a collection of strings containing
         a list of installed components.&quot;
    | selection |
    selection :=
     self componentTypeMenu:
             #(listDevices listSignals listSwitches).
    selection isNil
       ifTrue: [^#()].
    ^(self perform: selection).!
listConnections
     &quot;Answer a collection of strings listing
         the connection chain(s) for a
         user-specified component.&quot;
    | component |
    component := self getExistingComponent.
     component isNil
        ifTrue: [^#()].
       currentComponent := component.
    ^self listComponentConnections.!
listContaining: aComponent
           &quot;Answer the list (devices, signals, or switches)
         that includes aComponent.&quot;
    (devices includes: aComponent)
        ifTrue: [^devices].
       (signals includes: aComponent)
     ifTrue: [^signals].
    ^switches.!
listDevices
          &quot;Answer a collection of strings containing
         a list of all the installed devices.&quot;
      | size list |
       size := devices size.
    size == 0
         ifTrue: [^#('No devices installed')].
    size := size + 1.
       list := OrderedCollection new: size.
       list add: 'DEVICES'.
       devices do: [:aDevice| list add: ('  ', (aDevice identify))].
    ^list.!
listSelectorFor: aComponent
          &quot;Answer the list selector method used
         to produce the list for aComponent's type.&quot;
       aComponent isDevice
          ifTrue: [^#listDevices].
      aComponent isSignal
         ifTrue: [^#listSignals].
     ^#listSwitches.!
listSignals
        &quot;Answer a collection of strings containing
         a list of all the installed input signals.&quot;
    | size list |
    size := signals size.
    size == 0
     ifTrue: [^#('No signals installed')].
      size := size + 1.
    list := OrderedCollection new: size.
    list add: 'SIGNALS'.
    signals do: [:aSignal| list add: ('  ', (aSignal identify))].
    ^list.!
listSwitches
       &quot;Answer a collection of strings containing
         a list of all the installed swithces.&quot;
    | size list |
     size := switches size.
       size == 0
        ifTrue: [^#('No switches installed')].
    size := size + 1.
       list := OrderedCollection new: size.
       list add: 'SWITHCES'.
    switches do: [:aSwitch| list add: ('  ', (aSwitch identify))].
    ^list.!
load
     &quot;Load a circuit description from
         a user-specified file.&quot;
    | file |
     file := self getFile.
      file isNil
        ifTrue: [^nil].
    self installFrom: file.
      listSelector := #listDevices.
       breadboard update.!
noDelay
         &quot;Setup all components to ignore
         propagation delays.&quot;
    signals  do: [:signal| signal noDelay].
    switches do: [:switch| switch noDelay].
       devices  do: [:device| device noDelay].!
noMenu
     &quot;Private -- answer an empty menu.&quot;
    ^(EmptyMenu new).!
open
         &quot;Open the Breadboard and Analyzer windows.&quot;
    | size position |
     size := (Display boundingBox extent * 3) // 4.
       position := Display boundingBox center - (size // 2).
    topPane :=
          TopPane new
         label: ((self class description),
                    ' -- Breadboard');
         model: self;
         menu: #noMenu;
          yourself.
       topPane addSubpane:
          (breadboard := ListPane new
         name: #breadboardList;
           model: self;
           menu: #breadboardMenu;
          change: #doNothing:;
          framingRatio: (0 @ 0 extent: 1 @ 1)).
      topPane reframe: (position extent: size).
    topPane dispatcher openWindow scheduleWindow.!
quit
     &quot;Quit this LogicLab.&quot;
      (self verify: 'Quit this LogicLab?')
          ifFalse: [^nil].
      self eraseCircuit.
    signals := switches := devices := nil.
      analyzer isNil
        ifFalse: [
          analyzer closeWindow.
           analyzer := nil].
    breadboard dispatcher deactivateWindow closeWindow.
       Scheduler systemDispatcher redraw.
     Scheduler resume.!
remove
     &quot;Remove a user-specified component.&quot;
     | component |
      component := self getExistingComponent.
    component isNil
        ifTrue: [^nil].
    changed := true.
       listSelector := self listSelectorFor: component.
    self removeComponent: component.
       breadboard update.!
removeComponent: aComponent
     &quot;Remove aComponent from the circuit.&quot;
      analyzer isNil
        ifFalse: [analyzer removeComponent: aComponent].
    (self listContaining: aComponent) remove: aComponent.
    aComponent remove.!
reset
         &quot;Reset all components.&quot;
    signals     do: [:signal| signal reset].
     switches do: [:switch| switch reset].
      devices  do: [:device| device reset].!
restoreDelay
        &quot;Setup all components to use
         propagation delays.&quot;
     signals  do: [:signal| signal restoreDelay].
     switches do: [:switch| switch restoreDelay].
     devices  do: [:device| device restoreDelay].!
resume
        &quot;Resume the breadboarding application
         after running the simulation.&quot;
    Cursor offset: breadboard frame center.
    topPane dispatcher scheduleWindow.!
run
         &quot;Invoke the LogicAnalyzer to run the simulation.&quot;
      analyzer isNil
        ifTrue: [
         analyzer := LogicAnalyzer new.
           analyzer openOn: self]
         ifFalse: [analyzer activate].!
save
           &quot;Store the circuit description in
         a user-specified file.&quot;
    | file |
    file := self getFile.
     file isNil
       ifTrue: [^nil].
    CursorManager execute change.
    self storeOn: file.
    file
      flush;
        close.
      CursorManager normal change.!
selectName
     &quot;Answer a user-selected name from a list
         of the names of installed components.&quot;
    | names index |
    names := self allNames.
      (names size == 0)
       ifTrue: [^nil].
    index := VariableMenu selectFrom: names.
      index isNil
         ifTrue: [^nil].
    ^(names at: index).!
signalNames
           &quot;Answer a collection of all of the
         names of installed signals.&quot;
      | list |
    list := OrderedCollection new: (signals size).
    signals     do: [:aSignal| list add: aSignal name].
    ^list.!
signals
      &quot;Answer the list of installed signals.&quot;
    ^signals.!
simulate
           &quot;Simulate one pseudo-time interval.&quot;
    signals  do: [:signal| signal simulate].
       switches do: [:switch| switch simulate].
    devices  do: [:device| device simulate].!
storeClassesOn: aStream
           &quot;Write a record of each component class
         used by the circuit on aStream.&quot;
       | classes |
      classes := Set new.
     devices  do: [:aDevice| classes add: aDevice class].
     signals  do: [:aSignal| classes add: aSignal class].
     switches do: [:aSwitch| classes add: aSwitch class].
     classes do: [:aClass|
          aStream
          nextPutAll: ('LOAD ', (aClass name));
           cr].!
storeComponentsFrom: aCollection on: aStream
       &quot;Write a record of each logic component from
         aCollection installed in the circuit on aStream.&quot;
    aCollection do: [:aComponent|
      aStream nextPutAll: 'INSTALL '.
     aComponent storeOn: aStream.
         aStream cr].!
storeConnectionsOn: aStream
         &quot;Write a record of each connection
         in the circuit on aStream.&quot;
    devices  do: [:aDevice| aDevice storeConnectionsOn: aStream].
    signals     do: [:aSignal| aSignal storeConnectionsOn: aStream].
     switches do: [:aSwitch| aSwitch storeConnectionsOn: aStream].
      devices  do: [:aDevice| aDevice unMark].
    signals  do: [:aSignal| aSignal unMark].
      switches do: [:aSwitch| aSwitch unMark].!
storeDevicesOn: aStream
      &quot;Write a record of each logic device
         installed in the circuit on aStream.&quot;
    self storeComponentsFrom: devices on: aStream.!
storeOn: aStream
           &quot;Write a description of the circuit on
         aStream in a form that can be recovered
         by the 'installOn:' method.&quot;
    self
      storeClassesOn: aStream;
      storeDevicesOn: aStream;
      storeSignalsOn: aStream;
      storeSwitchesOn: aStream;
       storeConnectionsOn: aStream.!
storeSignalsOn: aStream
           &quot;Write a record of each logic signal
         installed in the circuit on aStream.&quot;
    self storeComponentsFrom: signals on: aStream.!
storeSwitchesOn: aStream
        &quot;Write a record of each logic switch
         installed in the circuit on aStream.&quot;
      self storeComponentsFrom: switches on: aStream.!
switches
      &quot;Answer the list of installed switches.&quot;
    ^switches.!
switchNames
        &quot;Answer a collection of all of the
         names of installed swithces.&quot;
    | list |
    list := OrderedCollection new: (switches size).
    switches     do: [:aSwitch| list add: aSwitch name].
    ^list.!
verify: aPrompt
      &quot;Ask the user to verify some condition.&quot;
    Cursor offset: MenuPosition.
    ^((Menu message: aPrompt) notNil).! !





<a name="0267_000b"><a name="0267_000b">
<a name="0267_000c"></pre><B>[LISTING TWO]</B><pre><a name="0267_000c">

LogicSwitch subclass: #ToggleSwitch
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: '' !

!ToggleSwitch class methods !

type
        &quot;Answer a string with the receiver's type.&quot;
    ^'Toggle Switch'.! !
!ToggleSwitch methods !
identify
        &quot;Answer a string identifying the receiver.&quot;
    ^((self name),
        ' (', (self type), ')').!
push: aButton
        &quot;Simulate pushing a toggle switch by
         inverting its state.&quot;
    node invert.
    node isHigh
        ifTrue:  [aButton lampOn]
        ifFalse: [aButton lampOff].
    (model isNil or: [changeSelector isNil])
        ifFalse: [model perform: changeSelector].!
reset
        &quot;Reset the receiver.&quot;
    button isNil
        ifFalse: [
            node isHigh
                ifTrue:  [button lampOn]
                ifFalse: [button lampOff]].!
simulate
        &quot;Simulate a toggle switch.&quot;
    node output.! !





<a name="0267_000d"><a name="0267_000d">
<a name="0267_000e"></pre><B>[LISTING THREE]</B><pre><a name="0267_000e">

LogicSwitch subclass: #PulserSwitch
  instanceVariableNames:
    'rest time timer '
  classVariableNames: ''
  poolDictionaries: '' !

!PulserSwitch class methods !

type
        &quot;Answer a string with the receiver's type.&quot;
    ^'Pulser'.! !
!PulserSwitch methods !
identify
        &quot;Answer a string identifying the receiver.&quot;
    ^((self name),
        ' (', (self type), ' -- ',
            (LogicNode
                statePrintString: (LogicNode not: rest)), ': ',
            (TimeInterval timePrintString: time), ')').!
initialize
        &quot;Initialize a new PulserSwitch.&quot;
    super initialize.
    rest := false.
    time := timer := 0.!

install
        &quot;Answer the receiver with user-specified
         rest state and pulse time.&quot;
    rest := LogicNode getState.     &quot;User will select pulse state&quot;
    rest isNil
        ifTrue: [^super release].
    rest := LogicNode not: rest.
    time := TimeInterval getTimeFor: 'pulse'.
    time isNil
        ifTrue: [^super release].
    ^self.!
installFrom: aStream
        &quot;Answer a new PulserSwitch initialized with
         parameters read from aStream.&quot;
    super installFrom: aStream.
    rest := LogicNode stateNamed: aStream nextWord.
    node state: rest.
    time  := aStream nextWord asInteger.
    ^self.!
push: aButton
        &quot;Simulate pushing a Pulser Switch.&quot;
    timer == 0
        ifTrue: [node state: (LogicNode not: rest)].
    timer := time.
    node isHigh
        ifTrue:  [aButton lampOn]
        ifFalse: [aButton lampOff].
    (model isNil or: [changeSelector isNil])
        ifFalse: [model perform: changeSelector].!
reset
        &quot;Reset the receiver's state to its resting
         state and its timer to zero.&quot;
    node state: rest.
    timer := 0.
    button isNil
        ifFalse: [
            node isHigh
                ifTrue:  [button lampOn]
                ifFalse: [button lampOff]].!
simulate
        &quot;Simulate a Pulser Switch.&quot;
    timer == 0
        ifTrue: [
            node state: rest.
            button isNil
                ifFalse: [
                    node isHigh
                        ifTrue:  [button lampOn]
                        ifFalse: [button lampOff]]]
        ifFalse: [timer := timer - 1].
    node output.!
storeOn: aStream
        &quot;Store a record of the receiver on aStream.&quot;
    super storeOn: aStream.
    aStream
        nextPutAll: (' ',
                        (LogicNode statePrintString: rest), ' ',
                        (time printString)).! !




<a name="0267_000f"><a name="0267_000f">
<a name="0267_0010"></pre><B>[LISTING FOUR]</B><pre><a name="0267_0010">

LogicDevice subclass: #N74LS00
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: '' !

!N74LS00 class methods !
description
        &quot;Answer a string with a description
         of the receiver's function.&quot;
    ^'Quad 2-input NAND gate'.!
type
        &quot;Answer a string with the receiver's type.&quot;
    ^'74LS00'.! !
!N74LS00 methods !
initialize
        &quot;Private -- initialize the propagation delays
         for a new 74LS00 LogicDevice.&quot;
    super
        initialize;
        initializeDelays:
            #(  5  5 10    5  5 10    0
               10  5  5   10  5  5    0 ).!
simulate
        &quot;Simulate a 74LS00 device.&quot;
    ((pins at: 1) isHigh and: [(pins at: 2) isHigh])
        ifTrue:  [(pins at: 3) output: false]
        ifFalse: [(pins at: 3) output: true].
    ((pins at: 4) isHigh and: [(pins at: 5) isHigh])
        ifTrue:  [(pins at: 6) output: false]
        ifFalse: [(pins at: 6) output: true].
    ((pins at: 10) isHigh and: [(pins at: 9) isHigh])
        ifTrue:  [(pins at: 8) output: false]
        ifFalse: [(pins at: 8) output: true].
    ((pins at: 13) isHigh and: [(pins at: 12) isHigh])
        ifTrue:  [(pins at: 11) output: false]
        ifFalse: [(pins at: 11) output: true].! !





<a name="0267_0011"><a name="0267_0011">
<a name="0267_0012"></pre><B>[LISTING FIVE]</B><pre><a name="0267_0012">

output: aState

        &quot;Generate aState as an output from the node.&quot;

    old := int.
    int := aState.
    int == ext
        ifTrue: [
            &quot;State is stable&quot;
            timer := 0.
            ^self outputToConnections].
    &quot;State has changed&quot;
    timer == 0
        ifTrue: [
            &quot;No delay in progress -- initiate prop delay&quot;
            delay == 0
                ifTrue: [
                    &quot;No delay -- just change state&quot;
                    ext := int]
                ifFalse: [
                    &quot;Arm delay timer&quot;
                    timer := delay].
            ^self outputToConnections].
    &quot;Propagation delay in progress&quot;
    timer := timer - 1.
    timer == 0
        ifTrue: [
            &quot;Timer has expired -- update state&quot;
            ext := int].
    self outputToConnections.




<a name="0267_0013"><a name="0267_0013">
<a name="0267_0014"></pre><B>[LISTING SIX]</B><pre><a name="0267_0014">

simulate

        &quot;Simulate a 74LS00 device.&quot;

    ((pins at: 1) isHigh and: [(pins at: 2) isHigh])
        ifTrue:  [(pins at: 3) output: false]
        ifFalse: [(pins at: 3) output: true].
    ((pins at: 4) isHigh and: [(pins at: 5) isHigh])
        ifTrue:  [(pins at: 6) output: false]
        ifFalse: [(pins at: 6) output: true].
    ((pins at: 10) isHigh and: [(pins at: 9) isHigh])
        ifTrue:  [(pins at: 8) output: false]
        ifFalse: [(pins at: 8) output: true].
    ((pins at: 13) isHigh and: [(pins at: 12) isHigh])
        ifTrue:  [(pins at: 11) output: false]
        ifFalse: [(pins at: 11) output: true].






<P>
<P>
</pre><HR><P>Copyright &copy; 1989, <I>Dr. Dobb's Journal</I></P></BODY></HTML>
