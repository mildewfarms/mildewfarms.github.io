<HTML>
<META NAME="year" CONTENT="1989">
<HEAD>

<TITLE>OCT89: FINITE STATE MACHINES FOR XMODEM</TITLE></HEAD>
<body bgcolor="FFFFFF">
<h1>FINITE STATE MACHINES FOR XMODEM<a name="01ff_0003"><a name="01ff_0003"></h1><P>
<h2><a name="01ff_0001"><a name="01ff_0000">FSMs are one way to cope with the chaos of communications</h2><P>
 This article contains the following executables: SMITH.ARC<P>
<h3>Donald W. Smith</h3><P>
<p><i><a name="01ff_0002"><a name="01ff_0000">Don is a senior course developer and instructor for Wide Area Network Systems at Tandem Computers, Inc.  He has been programming micros since CP/M days and has been programming in C since 1985.  He can be contacted at 7029 Via Del Rio, San Jose, CA 95139 or on CompuServe: 76515,3406.</i></p><hr><P>
Even though my coworkers often refer to me as a &quot;Commie,&quot; I don't take offense because my specialty is data communications and networking, an area of computer science that is often overlooked in favor of more stimulating topics such as compiler technology.  But what we Commies do and what compiler writers do aren't that much different, particularly because we share an important tool called &quot;finite state automata&quot; (FSA).  The main difference between what they do and what we do is where we get our events.  Compiler events come from source code files (text tokens), while most communication events come from another computer, or from strange things in between.<P>
This article presents a more generalized description of FSA, one in which data structures and code are used to implement XModem, a well-understood communications protocol, using a technique that is general enough to be implemented with just about any other protocol as well.  The goal here is to explain how to use standard C language constructs to write dependable, maintainable programs using finite state machines (FSM).  The applications include other communications protocols, realtime data acquisition, or just about anything with a fairly predictable flow of events.<P>
<h3><a name="01ff_0004">Lexical Analyzers and Such<a name="01ff_0004"></h3><P>
The Unix environment provides a number of specialized tools, YACC (yet another compiler compiler) and LEX (a lexical analyzer), for instance, that are designed to maintain the sanity of compiler writers.  YACC utilizes grammatical rules that can have associated actions.  YACC can be adapted to generate FSM-type machines, but requires that you learn &quot;yet another set of syntax.&quot;  (YASS?)<P>
Other utilities have also appeared to generate FSM code.  They are all valid techniques, if the tool is well understood by developers as well as maintainers.  But all require an extra level of &quot;indirection&quot; in the coding process to learn a specialized tool.  The technique I examine in this article does not use smoke screens or mirrors and requires only a standard C compiler.<P>
<h3><a name="01ff_0005">Finite State Basics<a name="01ff_0005"></h3><P>
Finite state machines are directed graphs where nodes are called states, and arcs are actions (or transitions).  Each state includes a well-defined set of events.  There must be an action and a next state defined for each event, even if the action is a null action.  Events drive the machine from state to state.  Once a good starting state is established and an initial event has come in, the machine is off and running.<P>
<h3><a name="01ff_0006">State Diagrams<a name="01ff_0006"></h3><P>
State diagrams are often used to document state machines.  <a href="19890201.htm">Figure 1</A> is the state diagram for XModem receive.  The receive machine (<a href="19890202.htm">Figure 2</A>) uses a total of four states (the circles), with a maximum of four events each.  As the number of events increases, the state diagrams sacrifice some attractiveness.  The final state (Exit) is used only to help human readers; it does not respond to events, and is not included in the diagram.  Each event directs the machine to an action, illustrated by a box with rounded corners.  All actions in this example are passed parameters, which are usually #defines and are shown in parentheses.  Some actions are shared by multiple events, for instance, Frame_Wait(RESEND).  Unfortunately, there is no &quot;Industry Standard&quot; state diagram for the XModem protocol.  (Ward Christensen isn't the only one who forgot this step.  But then again, CP/M machines didn't do graphics well.)  The state diagram in <a href="19890203.htm">Figure 1</A> is exceptionally short and sweet because the protocol is simple.<P>
<h3><a name="01ff_0007">Coding Technique<a name="01ff_0007"></h3><P>
There are many ways to implement finite state machines.  One method, using a precompiler (similar to LEX and YACC), adds an extra layer of syntax on top of the source code to identify states, events and actions.  Remember, FSA are normally a compiler writer's game.  What could be more natural than yet another language?  The output C code is often strewn with labels and GOTOs, which are not part of my structured programming vocabulary.<P>
It is also possible to limit the number of global variables (thus, side effects) when hand coding state machine logic.  This provides stand-alone send and receive modules that share a short list of external variables.  A short list of global variables in each module is declared static, to prevent them from slipping past the guards at the file door.<P>
The C language provides the data type of pointer to function that is as flexible as using GOTOs and labels, but also provides a series of advantages, such as that parameters can be passed, values can be returned, and block structuring maintained.<P>
<h3><a name="01ff_0008">Static Tables<a name="01ff_0008"></h3><P>
Data structures may be initialized with anything that is a constant at compile time.  Function pointers and pointers to variable locations fully qualify, but the contents of variables do not.<P>
XMRECV (see <a href="8910d.htm#01ff_0017">Listing Three</A>) shows the initialized state table using function pointers to actions (A_...).  The parameter field is defined as an int.  This int parameter conveniently accommodates pointers to anywhere in the small model.<P>
Most state machines use actions that are inherently simple, and rely on entry points (labels) to prevent duplication of code.  This technique uses standard functions for actions which naturally take parameters.  This code requires all functions to accept a single int parameter, due to the struct used for the state table.  Other parameter types are casted to int as required.<P>
Unfortunately, this technique is not universally portable.  For example, if pointers occupy more than the size of an int, a larger data type should be substituted to hold them.<P>
<h3><a name="01ff_0009">Code Walkthrough<a name="01ff_0009"></h3><P>
The FSM presented here consists of five modules.  <a href="8910d.htm#01ff_0013">Listing One</A>  CTERM.H, and <a href="8910d.htm#01ff_0015">Listing Two</A>, COMMN.H, define the system.  Most of my discussion, however, will concentrate on the short &quot;main loop&quot; of the XMRECV.C file in <a href="8910d.htm#01ff_0017">Listing Three</A>.  The same technique is also used in the XMSEND.C module <a href="8910d.htm#01ff_0019">Listing Four</A>) but refers to a different state table.  The action functions speak for themselves and illustrate the XModem protocol, which has been done before.  CTERM1.C, <a href="8910d.htm#01ff_001b">Listing Five</A>, is a terminal emulator that demonstrates the use of state machine driven communications protocols using the C language.  Use makect1 in <a href="8910d.htm#01ff_001d">Listing Six</A> to compile CTERM1.C.<P>
The story normally starts in terminal mode.  To receive a file, press the PgDn key to get into the xmodem_recv() module.  Note that the mode variable is set to M_XRecv on the way out of terminal mode.  The initial action of A_Prep_Recv() returns the first event and, hopefully, a valid file name.  A while (mode == M_XRecv) loop takes control until something good (or really bad) happens.<P>
Within the while loop, a copy of the event is made for future reference.  (Sort of like saving yesterday's newspaper, right?) Then a pointer is set up for easier access to the current state table entry (cur_entry).  The current state and event of the state machine is then traced, if tracing was enabled at compile time.  The predefined action to execute is determined then called, passing the appropriate parameter.  Notice that the event variable is filled with the return value from the function call to new_action( ).  Before leaving, the system determines a new current state from the next_state field of the state table.<P>
In this case, the user should be presented with the opportunity to abort at any time.  The routine keyfun() provides this capability, without allowing the dreaded ^C (Control-C) display or program termination.  Programs that alter interrupt vectors should not abort without putting things back the way they were.  One single character is defined to be the escape character (default is ESC) that takes you out of the M_XRecv via a call to the action A_Recv_End().<P>
This code could be tighter and run faster, but a few extra variables help follow the action and keep the code more readable.  Hopefully, smart compilers will use registers where possible anyway.<P>
<h3><a name="01ff_000a">Designing States<a name="01ff_000a"></h3><P>
One of the most challenging aspects of designing good state machines is determining how many states there should be.  There are no hard and fast rules.  This is one of those areas of &quot;fuzzy logic&quot; that intelligent humans were built to handle.  The goal is to define states where only a limited number of events can occur.  That number is up to the designer, but normally should not exceed ten.<P>
It is easier to define the structure to hold the initialized state table if all states have the same number of valid events.  It could be an interesting exercise for the reader to design a state table with a variable number of events for each state.<P>
The following are a few notes to keep in mind while determining how many states to define:<P>
<ul>
<li>Use a flowchart of tasks to help derive the state diagram</li>
<li>keep the main path clean (as few states/actions as possible)</li>
<li>decide which return value means &quot;All's Well.&quot;  Maybe O?</li>
</ul>
<h3><a name="01ff_000b">Actions and Reactions<a name="01ff_000b"></h3><P>
Actions are functions that do work and return events.  Most actions normally do not call other actions and perform fairly simple tasks.  It is often necessary to maintain some idea of context between calls.  For example, the A_Frame_Wait action maintains internal (static) counters for retries while waiting for a response to a control character sent (Ack, Nak, and so on).<P>
Remember that states do no work.  (The Governor of California would probably take exception to my last statement, but then I'd have been quoted out of context.)  Actions are where the actual work is done.<P>
The action Validate() probably does the most work in the receive logic.  It updates the screen's packet counter and waits for the interrupt handler to finish receiving the frame.  It then checks the packet header and the packet CRC/Checksum, and finally writes the packet data to disk if all is well.  Validate() also has the authority to advance the (file) global packet counter (pkt) before returning 0, if all is well.<P>
Some protocol purists may notice that it is possible to tolerate more than a one-second delay between characters.  But some networks in use today cannot always guarantee such a luxury.  Validate() returns a TIMEOUT only after two successive one-second time-outs. Remember that we already have seen the SOH, and should not need to wait much longer.<P>
XModem uses a fixed frame size, which differs significantly from other common protocols. Protocols with an ETX (end of text) signifying the end of a variable size frame, should use another state (and action) to receive the frame before validating.  It is too slow to wait for a deadline and start looking backwards.  <a href="8910d.htm#01ff_000c">Table 1</A> shows a trace of a successful receive of three record files while <a href="8910d.htm#01ff_000d">Table 2</A> lists the three states involved in receiving a packet.<P>
<h4><a name="01ff_000c"><a name="01ff_000c"><B>Table 1:</B> A trace of successful receive</h4><P>
<pre>
  The three states involved in receiving a packet
  _________________________________________________

  State:   Init_Recv, Event: 0, Note:  fname O.K
  State:    Incoming, Event: 2, Note:    timeout
  State:    Incoming, Event: 2, Note:    timeout
  State:    Incoming, Event: 0, Note:    got one
  State:  First_What, Event: 0, Note:    got SOH
  State:   De_Pktize, Event: 0, Note:     pkt OK
  State:    Incoming, Event: 0, Note:    got one
  State:  First_What, Event: 0, Note:    got SOH
  State:   De_Pktize, Event: 0, Note:     pkt OK
  State:    Incoming, Event: 0, Note:    got one
  State:  First_What, Event: 0, Note:    got SOH
  State:   De_Pktize, Event: 0, Note:     pkt OK
  State:    Incoming, Event: 0, Note:    got one
  State:  First_What, Event: 2, Note:    got EOT</pre><P>
<P>
<h4><a name="01ff_000d"><a name="01ff_000d"><B>Table 2:</B> States in motion</h4><P>
<pre>
  The three states involved in receiving a packet are:
  ________________________________________________________________
   1. Incoming:     Waiting for the first character.
                    Decodes the response from Frame_Wait(INIT).
                    Normally calls Which_Ctrl() action.

    2. First_What:  Decodes the response from Which_Ctrl() action based on
                     first character (SOH, CAN, EOT or ???)
                    Normally calls Validate() action.

    3. De-Pktize:   Decodes the response from Validate() action.
                    Normally calls Frame_Wait(NEXT) is all is well.
</pre><P>
<h3><a name="01ff_000e">Layers and Levels<a name="01ff_000e"></h3><P>
The OSI Reference model seems to have been described in every publication in the world.  The goal is to provide inter-computer networking.  Computers not only can communicate, but also share resources with other types of machines.  They can be connected directly, or across a network of conforming machines.<P>
The XModem protocol is not a good example of a layered protocol.  It is a point-to-point file transfer protocol that requires operator intervention at both ends; crude, but functional.  In OSI terms, XModem provides mostly layer 2 (link layer) services, skips layers 3 through 6, and provides a single service of layer 7 FTAM.<P>
A good example of layering in use today is X.25.  The link layer uses HDLC (high-level data link control) and is defined by a set of state diagrams between neighbors.  The network layer provides routing services in complex networks, and communicates with peer network layers in distant machines.<P>
Individual layers should be implemented as separate state machines.  If the same program handles more than one layer, a mechanism to communicate between layers is required.  The lower layers are given precedence when a queue of events has built up.  In this case, &quot;it&quot; rolls uphill!<P>
<h3><a name="01ff_000f">Implementing a Protocol<a name="01ff_000f"></h3><P>
The first step to implementing a communications protocol is to gain a good understanding of how it works.  Many are well documented, but some require the source code to unravel nuances like time-outs and recovery techniques.  Some proprietary protocols must be &quot;reverse engineered&quot; using data line monitors and specialized tools.<P>
The next step is to break the communications protocol down into layers, and then to define states within layers.  An outliner (with hierarchies of text) can help to develop the states, events, and next states.  A few walk throughs can really pay off as this step is being finalized.<P>
Validate the machine against &quot;script&quot; files of events.  Stub out the actions and read events from a script file.  A good trace facility can record the route taken through the machine. The trace output can be compared to what was expected from the script file.  New states or events can be added here without great difficulty, if necessary.<P>
Then it is time to actually code the actions.  It is amazing how quickly this can flow, given a good low-level library and proven state machines.  By this time, the responsibilities of each action should be fairly well understood.  Remember, actions are simply functions that return events!<P>
The final step takes at least two computers.  Always validate the protocol against the best implementation available.  The closer to the source, the better the copy.<P>
<h3><a name="01ff_0010">Conclusion<a name="01ff_0010"></h3><P>
A friend of mine who has been on the &quot;bleeding edge&quot; of computer science, implementing business solutions for years, seems to thrive on the ordeal.  After years in other areas of computer science, he made the conversion to communications.  When asked why, he simply replied, &quot;Because comm is where the chaos is!&quot;<P>
Commies are no different from other programmers.  Code words line Ack, Nak, and CRC are used to scare bright, young talent away from the field.  The perfect protocol has yet to be written; or if it has, it isn't in the public domain ... yet!<P>
<h3><a name="01ff_0011">Bibliography<a name="01ff_0011"></h3><P>
Donald Berryman, &quot;Implementing Standard Communications Protocols in C,&quot; The C Users Journal, vol. 3, no. 1.<P>
ISO, &quot;Reference Model for Open Systems Interconnection,&quot; ISO 7498.<P>
Joe Campbell, C Programmers Guide to Serial Communications, Howard W. Sams &amp; Co., Indianapolis, Ind.: 1987.<P>
Donald Kranz, &quot;Christensen Protocols in C,&quot; Doctor Dobb's Journal (June 1985).<P>
Kent Williams, &quot;State Machines in C,&quot; Computer Language magazine (February 1986).<P>
<h3><a name="01ff_0012">Availability<a name="01ff_0012"></h3><P>
All source code for articles in this issue is available on a single disk.  To order, send $14.95 (Calif. residents add sales tax) to Dr. Dobb's Journal, 501 Galveston Dr., Redwood City, CA 94063, or call 800-356-2002 (from inside Calif.) or 800-533-4372 (from outside Calif.).  Please specify the issue number and format (MS-DOS, Macintosh, Kaypro).<P>

_Finite State Machines for XModem_
by Donald W. Smith


<a name="01ff_0013"><a name="01ff_0013">
<a name="01ff_0014"></pre><B>[LISTING ONE]</B><pre><a name="01ff_0014">

/*  CTERM.H   defines for CTERMx series. */

#define BUFSIZE     128
#define DISKREAD    (BUFSIZE * 40)

/* some ASCII defines */
#define SOH         0x01        /* start of header */
#define EOT         0x04        /* end of transmission */
#define ACK         0x06        /* positive acknowledgement */
#define BS          0x08        /* backspace */
#define CR          0x0D        /* Carriage Return */
#define NAK         0x15        /* Negative acknowledgement */
#define CAN         0x18        /* Cancel */
#define EoF         0x1A        /* End of File (used for name) */
#define ESC         0x1B        /* ASCII escape key */
#define CRC         0x43        /* ASCII 'C' (CRC mode request) */
#define BADNAME     0x75        /* Received bad name checksum */
#define TIMEOUT     -1          /* for state machine logic */

static char *SPEED_LIST[] =
 {   &quot;50&quot;,   &quot;75&quot;,  &quot;110&quot;,  &quot;135&quot;,  &quot;150&quot;,  &quot;300&quot;,  &quot;600&quot;,  &quot;1200&quot;,
   &quot;1800&quot;, &quot;2000&quot;, &quot;2400&quot;, &quot;3600&quot;, &quot;4800&quot;, &quot;7200&quot;, &quot;9600&quot;, &quot;19200&quot;,
   &quot;28800&quot;, &quot;38400&quot;, &quot;57600&quot; };

static int SPEED_VALS[] =
 {   50,   75,  110,  135,  150,  300,  600,  1200,
   1800, 2000, 2400, 3600, 4800, 7200, 9600, 19200,
   28800, 38400, 57600,  0 };  /* zero for anchor */

static char *PARITY_LIST[] =
 { &quot;NONE&quot;, &quot;NONE&quot;, &quot;ODD&quot;, &quot;EVEN&quot;, };    /* matches L_CTRL p_enable + p_even */

static char *STOP_LIST[] =
 { &quot;ONE&quot;, &quot;TWO&quot; };                      /* matches L_CTRL p_two_stops */

static char *BITS_LIST[] =
 { &quot;FIVE&quot;, &quot;SIX&quot;, &quot;SEVEN&quot;, &quot;EIGHT&quot; };

/* Define some common values for the lctrl bit fields */
#define ate1none   0x03;
#define sev1even   0x1A;

typedef int (*action)();      /* action is a pointer to a function */

struct event_entry {
   char comment[20];      /* for commented reading and tracing capability */
   action act;            /* pointer to action function */
   int param;             /* parameter to pass to function */
   enum send_state next_state;  /* from an enumerated list of states */
  };

/* The following enumeration is used in all modules */
enum modes { M_Cmd, M_Term, M_Config, M_XSend, M_XRecv };

/* This struct maps the data packets for the protocol */
typedef struct pkt {
  unsigned char soh;
  unsigned char pkt;
  unsigned char pkt_cmp;
  unsigned char data[BUFSIZE];
  unsigned char crc1;
  unsigned char crc2;
} XPKT;

/*  Defines used for keyfun(). - Map exactly to BIOS intr 16h 0 and 1 */
#define KEYHIT     1
#define READNEXT   0
#define BIOS_KEY 0x16        /* for int86 call for keyboard interrupt */

/* The following defines are used to map scan codes for f keys and specials */
#define HOME 0x4700
#define PGUP 0x4900
#define END  0x4F00
#define PGDN 0x5100
#define INS  0x5200
#define DEL  0x5300
#define CBRK 0x0000      /* Book says 0x5400.  I see 0x0000 */







<a name="01ff_0015"><a name="01ff_0015">
<a name="01ff_0016"></pre><B>[LISTING TWO]</B><pre><a name="01ff_0016">

#define PORT  2              /* currently a define 12/16/88 */
#define NAMESIZE   24        /* Used by xmsend and recv */
#define TXTRIES     5        /* Transmit retries */
#define RXTRIES    10        /* Receive retries */

/* Parameters to pass to Send Action Make_Pkt and Recv Action Frame_Wait */
#define RESEND      0
#define INIT        1
#define NEXT        2

/*  The following declaration is used to pass config info to Config_Comm().  */
typedef struct {     /* Map to UART Line Control bits */
        unsigned wlen      : 2;       /* Word length - 5 */
        unsigned two_stops : 1;       /* 1: Two stops,   0: One stop */
        unsigned parity    : 2;       /* 00, 01: NONE, 10 ODD, 11 EVEN */
        unsigned p_stuck   : 1;       /* 1: Stuck,       0: Normal */
        unsigned set_break : 1;       /* 1: Send break   0: Stop break */
        unsigned div_latch : 1;       /* 1: See divisors 0: See data bytes */
        unsigned           : 8;
      } L_CTRL;

  typedef union {
        unsigned char lctrl;
        L_CTRL lbits;
      } U_BITS;

  typedef struct
    {
      unsigned speed;       /* value from atoi() of value from speed array */
      U_BITS ubits;
    } S_INIT;






<a name="01ff_0017"><a name="01ff_0017">
<a name="01ff_0018"></pre><B>[LISTING THREE]</B><pre><a name="01ff_0018">

/* XMRECV.C:  Xmodem receive state machine processing */

#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;
#include &lt;string.h&gt;
#include &quot;cterm.h&quot;     /* common defines and structs for cterm */
#include &quot;commn.h&quot;                  /* brings in S_INIT struct */

enum recv_state
  { S_Init_Recv, S_Incoming, S_First_What, S_DePktize, S_Exit };

#define TRACE 1       /* to turn on state machine tracing */
/* #define SMTRACE 1 */
#ifdef SMTRACE
static char *state_list[] =
  {&quot;Init_Recv&quot;, &quot;Incoming&quot;, &quot;First_What&quot;, &quot;De-Pktize&quot;, &quot;Exit&quot;};
#endif

#define RECV_EVENTS    4         /* # of events per RECV state */

/* Variables local to this file only */
static char r_fname[NAMESIZE+1]; /* name of file to open */
static FILE *r_fptr = NULL;      /* file pointer or number to use */
static int sohor = SOH;          /* location to store first char of pkt hdr */

static int pkt = 1;               /* expected packet number */
static S_INIT prev_conf;          /* save prev (parity) conf */
static int virgin = 1;            /* 0 = beyond initial NAK stage */

/* EXTERNAL variables */
extern int comport;                /* which comm port to use (from CTERM) */
extern int crc;                    /* flag for CRC (!0) or checksum  (0) */
extern unsigned crcaccum;          /* from xmutil */
extern unsigned char checksum;     /* ditto */
extern S_INIT cur_config;          /* from CTERM.  For timeout calc */
extern enum modes mode;            /* ditto  term mode or... */
extern int eschar;                 /* ditto   escape character variable */
extern int keyfun(int);            /* ditto  BIOS keyboard I/O */
extern unsigned int fgetsnn(FILE *, char *, int);

/* Messages posted by A_Recv_End */
/*  If declared as char *user_msg, can't be used in state table.
 *  No variables allowed.  But this way creates constants! */
extern char user_msg[];
extern char cancel[];
extern char badwrite[];
extern char eof_msg[];
extern char giveup[];
extern char badcomm[];

/************  Receive Actions: ********************/

/* ----- A_Prep_Recv: Prompts for file to receive, attempts open.
 *   Returns: 0 if O.K., 1 if open fails, 2 is user abort.     */
A_Prep_Recv( char *fname )
{
  int retval;

  fputs(&quot;\n Please Input file name to receive: &quot;,stdout);
  fgetsnn (stdin, fname, NAMESIZE );
  if ( (fname[0] == eschar) || (fname[0] == '\0') )
    return(2);
  if ( (r_fptr = fopen (fname, &quot;wb&quot;)) == NULL ) {
    printf(&quot;\n Cannot open %s.  Try again.\n&quot;, fname);
    return(1);
  }

  prev_conf = cur_config;                 /* save entry config */
  cur_config.ubits.lctrl = ate1none;      /* Force things to 8/1/N */
  Config_Comm( comport, cur_config );

  eat_noise();                  /* clear out any garbage from buffer */
  return(0);
}

/* ----- A_Frame_Wait: Send a ctrl char, wait for reply.  -------
 *   Returns: 0: OK, 1: comm error, 2: timeout, 3: no retries. */
A_Frame_Wait(int which)
{
  char inch;
  int errval;                       /* returned from reads and writes */
  int numread = 1;
  static int passes;                /* give up after 10 retries */
  static char last;
  int retval = 0;                   /* Running value to return */

  if (virgin)  {                    /* Waiting for first answer to NAK */
    switch (which) {
      case INIT:   crc = 0;         /* Go for CRC first -- fallthru will flip */
                   passes = RXTRIES;
                   pkt = 1;         /* Initialize to first expected pkt num */
      case RESEND: crc = !crc;      /* flip global flag */
                   last = (crc == 0) ? NAK : CRC;
                   break;
      default:     retval = 3;      /* Should not occur... but */
    }
  }
  else {                            /* Not virgin.  Normal Retry logic */
    switch (which) {
      case NEXT:   last = ACK;
                   passes = RXTRIES;
                   break;
      case RESEND: if (passes-- == 0) {
                     last = CAN;
                     retval = 3;
                     passes = RXTRIES;      /* Reset to default */
                   }
                   else
                     last = NAK;
                   break;
     default:      retval = 3;      /* An ounce of prevention */
    }
  }

  errval = writecomm( &amp;last, 1);
  if (errval != 0)
    return(1);             /* Get out now! */

  eat_noise();             /* clear out any garbage */

  if (retval != 3) {
    errval = read_comm( &amp;numread, &amp;inch, 10000 );
    if (errval == TIMEOUT)
      return (2);
    else {                                  /* Got a live one! */
      sohor = inch;                         /* set global */
      if ( (virgin) &amp;&amp; (inch == SOH) ) {    /* We're rolling! */
        printf(&quot;\n\nReceiving file %s using %s.\n&quot;,
                         r_fname,(crc == 0) ? &quot;CheckSum&quot; : &quot;CRC&quot; );
        fputs(&quot;\nAwaiting packet # 0001&quot;,stdout);
        virgin = 0;                         /* flip the local flag */
      }
    }
  }
  return(retval);
}

/* ----- A_Which_Ctrl:  Parses first char received. -------------
 *  Returns:  0: SOH, 1: CAN, 2: EOT, 3: unexpected (junk)     */
A_Which_Ctrl(char *lead)
{
  switch (*lead) {
    case SOH:  return(0);
    case CAN:  return(1);
    case EOT:  return(2);
    default:   return(3);
  }
}

/* ----- CRC_Good:  Calculates the CRC/Checksum. ----------------
 * Returns:  0 if OK, 2 if error                               */
CRC_Good(char *buf, int crcflag, unsigned char crchi, unsigned char crclo)
{
  register int i;

  crcaccum = 0;  /* zero out global crc and checksum value */
  checksum = 0;

  for (i = 0; i &lt; BUFSIZE; i++, buf++)
    updcrc(*buf);
  updcrc(0);                     /* Xmodem deviant CRC calc */
  updcrc(0);

  if (crcflag == 0) {
    if (crchi != checksum)
      return(2);
  }
  else {
    if ( (crclo + ( crchi &lt;&lt; 8)) != crcaccum )
      return(2);
  }
  return(0);
}

/* ----- Action Validate: After SOH, validates the xmodem header.
 * Returns: 0: OK, 1: bad header, 2: bad CRC, 3: char timeout. */
A_Validate(int *crcflag )
{
  int retval;
  int readnum = (*crcflag == 0) ? 131 : 132; /* pass to read_comm */
  int togo    = readnum;                     /* if partial, running count */
  int msecs;                                 /* how long to wait */
  XPKT r_pkt;                                /* packet receive buffer */
  unsigned char *diskbuf = (unsigned char *) &amp;r_pkt.data;
  unsigned char *curptr  = (char *) &amp;r_pkt.pkt;   /* Rem: got SOH already */
  long frame_bits = ( (BUFSIZE + 3) * 10 *1000L );

  printf(&quot;\b\b\b\b%4d&quot;,pkt);        /* Allow up to 9999 frames */

  while (readnum != 0) {
    msecs =  (int)( frame_bits / (long)cur_config.speed );
    delay(msecs);                     /* Let the interrupt handler work */
    retval  = read_comm( &amp;readnum, curptr, msecs );
    curptr  = curptr + readnum;       /* adjust curptr to next avail loc */
    readnum = (togo -= readnum);      /* adjust BOTH to remainder of pkt */

    if (retval == TIMEOUT) {          /* Give it one more second if short */
      togo = 1;                       /* prep togo for 1 char read test */
      retval = read_comm( &amp;togo, curptr, 1000);
      if (retval == TIMEOUT)          /* Bad news.  Dead line */
        return(3);
      curptr++;                       /* recovered!   adjust and try again */
      togo = --readnum;
    }
    frame_bits = togo * 10;           /* Adjust by bits per character */
  }

  if (~r_pkt.pkt != r_pkt.pkt_cmp) {
    return(1);
  }
  if ( r_pkt.pkt != (pkt % 256) )
    if ( r_pkt.pkt == ( (pkt - 1) &amp; 0xFF )  ) {
      return(0);            /* duplicate packet!  Ack and ignore */
    }
    else
      return(1);        /* Nak and retry.. probably useless but... */

  retval = CRC_Good(diskbuf, *crcflag, r_pkt.crc1, r_pkt.crc2);
  if (retval != 0) {
    return(2);
  }

  fwrite(diskbuf, BUFSIZE, 1, r_fptr);
  pkt++;
  return (0);
}

/* ----- Action EatRest: Eats the rest of a packet. ---------- */
A_EatRest(int calories)
{
  int toeat = calories;
  int retval = 0;
  long frame_bits;
  char junkbuf[BUFSIZE + 4];

  if (calories &gt; BUFSIZE)
    calories = BUFSIZE + 4;
  frame_bits = ( calories * 10 * 1000L);
  delay( (unsigned)(frame_bits/(long)cur_config.speed) + 500 );

  while (retval != TIMEOUT) {
    retval = read_comm( &amp;toeat, junkbuf, 1000);
    toeat = 1;
  }
  retval = A_Frame_Wait(RESEND);
  return(retval);
}

/* ----- Action Recv_End: Only way out of Recv state machine.  */
A_Recv_End ( char *reason )
{
  char eotc = ACK;             /* just in case we really Receive the file */

  if (r_fptr != NULL) {        /* Did we even get started??? */
    if (reason != eof_msg) {   /* Started, but bad news during xfer */
      eotc = CAN;
      unlink(r_fname);         /* deletes the old file */
    }
    fclose(r_fptr);
    writecomm(&amp;eotc, 1);
    Config_Comm( comport, prev_conf );   /* Put whatever parity back in */
  }

  printf(&quot;\n *** Ending session.  %s.\a\n&quot;,reason);

  virgin = 1;
  mode = M_Cmd;
  return (RECV_EVENTS - 1);   /* last event always has next state S_Exit */
}

/************  R E C E I V E    S T A T E    T A B L E  ****************/
 struct event_entry recv_machine[(int)S_Exit][RECV_EVENTS] =
 { /* S_Init_Recv */
   { {  &quot;fname O.K&quot;  , A_Frame_Wait   , INIT         , S_Incoming      },
     {  &quot;fname bad&quot;  , A_Prep_Recv    , (int)r_fname , S_Init_Recv     },
     {  &quot;user abort&quot; , A_Recv_End     , (int)user_msg, S_Exit          },
     {  &quot;comm error&quot; , A_Recv_End     , (int)badcomm , S_Exit          } },
   /* S_Incoming */
   { {  &quot;got one&quot;    , A_Which_Ctrl   , (int)&amp;sohor  , S_First_What    },
     {  &quot;comm error&quot; , A_Recv_End     , (int)badcomm , S_Exit          },
     {  &quot;timeout&quot;    , A_Frame_Wait   , RESEND       , S_Incoming      },
     {  &quot;no retries&quot; , A_Recv_End     , (int)giveup  , S_Exit          } },
   /* S_First_What */
   { {  &quot;got SOH&quot;    , A_Validate     , (int)&amp;crc    , S_DePktize      },
     {  &quot;got CAN&quot;    , A_Recv_End     , (int)cancel  , S_Exit          },
     {  &quot;got EOT&quot;    , A_Recv_End     , (int)eof_msg , S_Exit          },
     {  &quot;got junk!&quot;  , A_EatRest      , BUFSIZE      , S_Incoming      } },
   /* S_DePktize */
   { {  &quot;pkt OK&quot;     , A_Frame_Wait   , NEXT         , S_Incoming      },
     {  &quot;bad hdr&quot;    , A_EatRest      , BUFSIZE      , S_Incoming      },
     {  &quot;bad CRC&quot;    , A_Frame_Wait   , RESEND       , S_Incoming      },
     {  &quot;timeout&quot;    , A_Frame_Wait   , RESEND       , S_Incoming      } }
 };


/* -------------- Xmodem Receive state machine --------------- */
xmodem_recv()
{
   char inkey;                     /* place for user to abort */
   int  event;                     /* event returned from action */
   int  prevent;                   /* previous event */
   struct event_entry *cur_entry;  /* pointer to current row/col of sm */
   action new_action;              /* next action to perform */
   enum send_state cur_state  = S_Init_Recv;

   event = A_Prep_Recv(r_fname);

   while (mode == M_XRecv)
   {
     prevent = event;      /* save the previous event for next state */
     cur_entry = &amp;recv_machine[(int)cur_state][event];

#ifdef SMTRACE
     printf(&quot;State: %16s, Event: %2d, Note: %20s\n&quot;,
          state_list[(int)cur_state], event, cur_entry-&gt;comment );
#endif

     /* Based on the current state and event, execute action(param) */
     new_action = cur_entry-&gt;act;
     event = new_action(cur_entry-&gt;param);
     cur_state  = recv_machine[(int)cur_state][prevent].next_state;

     if ( keyfun(KEYHIT) ) {
       inkey = (char) keyfun(READNEXT);    /* Truncate to key only */
       if (inkey == eschar)
         A_Recv_End(user_msg);
     }
   }
   return (0);
}






<a name="01ff_0019"><a name="01ff_0019">
<a name="01ff_001a"></pre><B>[LISTING FOUR]</B><pre><a name="01ff_001a">

/* XMSEND.C   Xmodem Send state machine processing.   */

#include &lt;conio.h&gt;        /* for putch call */
#include &lt;ctype.h&gt;
#include &lt;io.h&gt;           /* for filelength call */
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &quot;cterm.h&quot;
#include &quot;commn.h&quot;    /* brings in S_INIT struct and defines */

enum send_state
 { S_Init_Send, S_Sync_Wait, S_Make_Pkt, S_Send_Pkt, S_Data_Response, S_Exit };

#ifdef TRACE
char *state_list[] =
  {&quot;Init_Send&quot;, &quot;Sync_Wait&quot;, &quot;Make_Pkt&quot;, &quot;Send_Pkt&quot;, &quot;Data_Response&quot;, &quot;Exit&quot;};
#endif

#define SEND_EVENTS    4      /* number of events handled per send state */

/* Variables local to this file only */
static char s_fname[NAMESIZE+1];     /* name of file to open */
static FILE *s_fptr = NULL;         /* file pointer or number to use */
static XPKT s_pkt;                   /* packet to send */
static S_INIT prev_conf;        /* saves previous bits, parity during xfer */

/* EXTERNAL variables and functions */
extern int comport;                /* which comm port to use (from CTERM) */
extern unsigned crcaccum;          /* from xmutil */
extern unsigned char checksum;     /* ditto */
extern int crc;                    /* ditto */
extern S_INIT cur_config;          /* from CTERMx.  For send time calc */
extern int eschar;                 /* ditto   escape character variable */
extern enum modes mode;            /* ditto   term mode or... */
extern int keyfun(int);            /* ditto   BIOS call to keyboard */

/*  If declared as char *user_msg, can't be used in state table.
 *  No variables allowed.  But this way creates constants! */
extern char user_msg[];
extern char nonak[];
extern char cancel[];
extern char badread[];
extern char eof_msg[];
extern char giveup[];

/************  Send Actions: ********************/

/* ----- A_Get_Fname:  Prompts for file to transmit, opens. -----
 * Returns: 0: OK, 1: open failed, 2: user abort. ------------ */
A_Get_Fname( char *fname )
{
  long fbytes;
  int  frecs;
  int  fsecs;

  printf(&quot;\n Please Input file name to transmit: &quot;);
  fgetsnn (stdin, fname, NAMESIZE );
  if ( (fname[0] == eschar) || (fname[0] == '\0') )
    return(2);
  if ( (s_fptr = fopen (fname, &quot;rb&quot;)) == NULL ) {
    printf(&quot;\n Cannot open %s.  Try again.\n&quot;, fname);
    return(1);
  }
  fbytes = filelength( fileno(s_fptr) );
  frecs = (  (fbytes / BUFSIZE) + ( (fbytes % BUFSIZE == 0) ? 0 : 1 )  );
  /* The following adds time for turn around (ACK/NAK), but no errors */
  fsecs = (int) ( (fbytes * 10) / (cur_config.speed / 2 ) );

  printf(&quot;\n File %s: %4d records, est. min:sec  %3d:%2d at %d bps.\n&quot;,
              fname, frecs, fsecs / 60, fsecs % 60, cur_config.speed  );

  prev_conf = cur_config;                 /* save entry config */
  cur_config.ubits.lctrl = ate1none;      /* Force things to 8/1/N */
  Config_Comm( comport, cur_config );

  eat_noise();        /* Clear out any garbage in the input queue */
  return(0);
}

/* ----- A_Init_Wait: Waits for initial sync character. ---------
 *  Returns: The value returned from A_Wait().                 */
A_Init_Wait(int expected)
{
  static int tries  =  2;   /* try initial CRC, then once more */
  static int passes = 10;   /* give up after 10 junk reads */
  static int last;
  int retval;

  switch(expected) {
    case CRC:  last = CRC;     /* If we really want CRC... */
               break;
    case NAK:  last = NAK;     /* or if we only want Checksum */
               break;
    case NEXT: if (--tries == 0) {     /* want to switch? */
                 last = (last == CRC) ? NAK : CRC;
                 tries = 2;
               }
  }
  printf(&quot;\rAwaiting %s...&quot;,(last == CRC) ? &quot;CRC&quot; : &quot;NAK&quot;);
  retval = A_Wait(last);
  if (retval != 0) {
    if (passes-- == 0)
      return(3);           /* cancelled */
    else
     return(retval);
  }

  passes = 10;                      /* reset passes counter */
  crc = (last == CRC) ? 1 : 0;
  return(retval);
}

/* ------ A_Wait:  Waits for appropriate time for a character.
 * Returns: 0: match, 1: if other, 2: timeout, 3: cancel.      */
A_Wait( int expected)
{
  char inch;
  int errval;
  int numread = 1;
  int retval = 0;

  errval = read_comm( &amp;numread, &amp;inch, (expected == SOH) ?  1000 : 10000 );
  if ( numread &gt; 0 ) {
    if (inch == (char) expected)
      retval = 0;
    else retval = (inch == CAN) ? 3 : 1 ;
  }
  else
   if (errval == TIMEOUT)
     retval = 2;

  return (retval);
}

/* ----- Action Make_Pkt: Reads from disk, formats packet. -----
 * Returns:  0: OK, 1: disk trouble, 2: EOF found.            */
A_Make_Pkt(int which )
{
  register int i;
  int errval;
  unsigned int lo_crc;
  static int pkt;
  static unsigned char *diskbuf = (unsigned char *) &amp;s_pkt.data;
  static unsigned char *curptr;   /* where are we now? */

  crcaccum = 0;  /* zero out global crc and checksum value */
  checksum = 0;

  for (curptr = diskbuf, i = 0; i &lt; BUFSIZE; i++, curptr++) {
    if ( (errval = getc(s_fptr)) == EOF )
      break;
    *curptr = errval;
    updcrc(errval);
  }
  if (i == 0)
    return(2);                   /* That's all folks! */

  for ( ; i &lt; BUFSIZE; i++, curptr++) {    /* Zero fill the rest of packet */
    *curptr = 0;
    updcrc(0);
  }

  if (which == INIT) {
    printf(&quot;\n\nSending file %s using %s.\n&quot;,
                        s_fname,(crc == 0) ? &quot;CheckSum&quot; : &quot;CRC&quot;);
    pkt = 1;
  }
  else pkt = (++pkt % 256);

  s_pkt.soh     = SOH;
  s_pkt.pkt     = pkt;
  s_pkt.pkt_cmp = ~pkt;
  updcrc(0);     /* finish off xmodem variation */
  updcrc(0);
  lo_crc = crcaccum;
  if (crc != 0) {
    s_pkt.crc1 = (crcaccum &gt;&gt; 8);    /* high byte first */
    s_pkt.crc2 = lo_crc;
  }
  else
    s_pkt.crc1 = checksum;

  return (0);
}

/* ----- Action Send_Pkt: Send a packet out the comm port. ------
 * Returns:  0: OK, 1: write err, 2: no retries, 3: cancelled  */
A_Send_Pkt( int why )
{
  static int retries = TXTRIES; /* If not general, make a global table */
  int errval;

  switch (why) {
    case NEXT:    retries = TXTRIES;
                  putch('.');         /* show we are making progress */
                  break;
    case NAK:
    case TIMEOUT:
    case RESEND:  --retries;
                  putch('R');
  }

  if (!retries) {
    retries = TXTRIES;
    return (2);
  }

  errval = writecomm( (char *) &amp;s_pkt, (crc != 0) ? 133 : 132 );
  if (errval)
    return(1);

  eat_noise();            /* clear out any garbage */
  return (0);
}

/* ----- Action Send_End:  Only way out of the Send state. --- */
A_Send_End ( char *reason )
{
  char eotc = EOT;             /* just in case we really transmit the file */
  int notdone = 1;             /* have we received an ACK to our EOT? */
  int eotries = 10;            /* Should be enough for most */

  if (s_fptr != NULL) {        /* Did we even get started??? */
    if (reason != eof_msg) {   /* Started, but bad news */
      eotc = CAN;
      writecomm(&amp;eotc, 1);
    }
    else                       /* eof = We did it!  Send our EOT and get out */
      while ( (notdone != 0) &amp;&amp; (eotries--) ) {
        writecomm(&amp;eotc, 1);
        notdone = A_Wait(ACK);
      }
    fclose(s_fptr);
    Config_Comm( comport, prev_conf );   /* Put whatever parity back in */
  }

  printf(&quot;\n *** Ending session.  %s.\a\n&quot;,reason);

  mode = M_Cmd;
  return (SEND_EVENTS - 1);    /* last event always has next state S_Exit */
}

/***************  S E N D   S T A T E    T A B L E  *******************/
 struct event_entry send_machine[(int)S_Exit][SEND_EVENTS] =
 { /* S_Init_Send */
   { {  &quot;fname O.K&quot;  , A_Init_Wait    , CRC          , S_Sync_Wait     },
     {  &quot;fname bad&quot;  , A_Get_Fname    , (int)s_fname , S_Init_Send     },
     {  &quot;user abort&quot; , A_Send_End     , (int)user_msg, S_Exit          },
     {  &quot;no retries&quot; , A_Send_End     , (int)nonak   , S_Exit          } },
   /* S_Sync_Wait */
   { {  &quot;in sync&quot;    , A_Make_Pkt     , INIT         , S_Make_Pkt      },
     {  &quot;unexpected&quot; , A_Init_Wait    , NEXT         , S_Sync_Wait     },
     {  &quot;timeout&quot;    , A_Init_Wait    , CRC          , S_Sync_Wait     },
     {  &quot;cancelled&quot;  , A_Send_End     , (int)cancel  , S_Exit          } },
   /* S_Make_Pkt */
   { {  &quot;pkt ready&quot;  , A_Send_Pkt     , NEXT         , S_Send_Pkt },
     {  &quot;bad disk?&quot;  , A_Send_End     , (int)badread , S_Exit          },
     {  &quot;done!&quot;      , A_Send_End     , (int)eof_msg , S_Exit          },
     {  &quot;trouble!&quot;   , A_Send_End     , (int)giveup  , S_Exit          } },
   /* S_Send_Pkt */
   { {  &quot;sent O.K.&quot;  , A_Wait         , ACK          , S_Data_Response },
     {  &quot;comm error&quot; , A_Send_Pkt     , RESEND       , S_Send_Pkt      },
     {  &quot;no retries&quot; , A_Send_End     , (int)giveup  , S_Exit          },
     {  &quot;cancelled&quot;  , A_Send_End     , (int)cancel  , S_Exit          } },
   /* S_Data_Response */
   { {  &quot;ack rcvd.&quot;  , A_Make_Pkt     , NEXT         , S_Make_Pkt      },
     {  &quot;not ack&quot;    , A_Send_Pkt     , NAK          , S_Send_Pkt      },
     {  &quot;timeout&quot;    , A_Send_Pkt     , TIMEOUT      , S_Send_Pkt      },
     {  &quot;cancelled&quot;  , A_Send_End     , (int)cancel  , S_Exit          } }
 };


/*  -------------------- Send state machine ------------------ */
xmodem_send()
{
   char inkey;                     /* In case the user wants to abort */
   int  event;                     /* event returned from action */
   int  prevent;                   /* previous event */
   struct event_entry *cur_entry;  /* pointer to current row/col of sm */
   action new_action;              /* next action to perform */
   enum send_state cur_state  = S_Init_Send;

   event = A_Get_Fname(s_fname);

   while (mode == M_XSend) {
     prevent = event;      /* save the previous event for next state */
     cur_entry = &amp;send_machine[(int)cur_state][event];

#ifdef TRACE
     printf(&quot;State: %16s, Event: %2d, Note: %20s\n&quot;,
          state_list[(int)cur_state], event, cur_entry-&gt;comment );
#endif

     /* Based on the current state and event, execute action(param) */
     new_action = cur_entry-&gt;act;
     event = new_action(cur_entry-&gt;param);
     cur_state  = send_machine[(int)cur_state][prevent].next_state;

     if ( keyfun(KEYHIT) ) {            /* from CTERM */
       inkey = (char) keyfun(READNEXT); /* Truncate high order */
       if (inkey == eschar)
         A_Send_End(user_msg);
     }
   }
   return (0);
}







<a name="01ff_001b"><a name="01ff_001b">
<a name="01ff_001c"></pre><B>[LISTING FIVE]</B><pre><a name="01ff_001c">

/* CTERM1.C  by Donald W. Smith.  CIS 76515,3406.
 *    A minimal terminal emulator to demonstrate the use of state
 *  machine driven communications protocols using the C language.
 *  Use makect1. to compile. */

#define VERSION fputs(&quot;\n\t CTERM 1.11:  4/26/89 DWS\n\n&quot;,stdout)
#define BUFLEN   200
#define LINELEN  80   /* Max user input length.  Lots of slack */

#include &lt;conio.h&gt;
#include &lt;ctype.h&gt;              /* for Turbo C is... functions */
#include &lt;dos.h&gt;
#include &lt;process.h&gt;                      /* For system() call */
#include &lt;signal.h&gt;          /* Ctrl-C and Ctrl-Break handling */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;                       /* For system() call */
#include &quot;cterm.h&quot;                 /* defines for cterm series */
#include &quot;commn.h&quot;        /* defines shared by myint and cterm */
#include &quot;getargs.h&quot;                     /* for getargs access */

#define CMDDIM(x)   (sizeof(x)/sizeof(x[0]))

/* --------- GLOBALS ------------------  */
enum modes mode = M_Cmd;                 /* Term, Config, etc. */
char            inbuf[BUFLEN+1];
char            outbuf[LINELEN+1];    /* Used for short output */
S_INIT          cur_config = {1200};    /* Current port config */
int             comport = 1;       /* Current comm port number */
int             bbsmode = 0;     /* BBS (8,1,N) or T16 (7,1,E) */
int             eschar  = ESC;    /* keyboard escape character */
FILE           *cap_fptr;         /* file ptr for capture file */
static union    REGS rg;                  /* used for keyfun() */

/* ---------- External variables -------------- */
extern  unsigned _heaplen = 4096;     /* TurboC 1.5 and above  */

/* ---------- External routines ----------- */
/* -- From myint -- */
extern void     Config_Comm( int port, S_INIT conf );
extern S_INIT   Get_Conf( int port );
extern int      incomm();
extern int      Inst_IH(void interrupt (*faddr)(), int comnum);
extern int      Remove_IH();
extern int      writecomm(unsigned char *buf, int len);
extern int      xmit_break();
/* -- from xmutil -- */
extern int           read_comm(int *num, char *buf, int wait);
/* -- from object only files -- */
extern int getargs( int, char**, ARG *, int, int (*usage)() );

ARG Argtab[] = {
  {  'b', BOOLEAN,  &amp;bbsmode,    &quot;BBS mode (8,1,N) vs. T16)&quot; },
  {  'c', INTVAR,   &amp;comport,           &quot;1 = COM1, 2 = COM2&quot; },
  {  'e', INTVAR,   &amp;eschar,            &quot;Escape char (0x..)&quot; },
  {  's', INTVAR,   &amp;cur_config.speed,        &quot;speed in bps&quot; } };

/* ----- fgetsnn:  Gets a line from file, replacing \n with NULL.
 *       Return # chars, or EOF                                */
int fgetsnn(FILE *fp, char *s, int size)
{
  register int i;
  int c;

  for (i = 0; (i &lt; size-1)             &amp;&amp;
              (c = fgetc(fp)) != EOF   &amp;&amp;
              (c != '\n')                 ; ++i)
    s[i] = c;
  s[i] = '\0';
  if (c == EOF)
    return(EOF);

  return(i);
}

/* ----- capture_sw:  Enables saving sessions to (PC) disc. -----
 *  Returns:  0 O.K.  1 if open fails, 2 if ESC hit.           */
int capture_sw()
{
  static char cap_fname[NAMESIZE + 1] = &quot;capture.fil&quot;;
  char cap_temp[NAMESIZE + 1];
  static int cap_sw = 0;              /* capture on/off switch */

  if (cap_sw == 0) {              /* Open the file for capture */
    fprintf(stdout,&quot;\n Capture to file &lt;%s&gt; or : &quot;,cap_fname);
    fgetsnn (stdin, cap_temp, NAMESIZE );
    if (cap_temp[0] == eschar)
      return(2);
    if (cap_temp[0] != '\0')
      strncpy(cap_fname, cap_temp, NAMESIZE);
    if ( (cap_fptr = fopen (cap_fname, &quot;a+t&quot;)) == NULL ) {
      printf(&quot;\n Cannot open %s.  Try again.\n&quot;, cap_fname);
      return(1);
    }
    cap_sw = 1;
  }
  else {       /* we are already capturing.  Close and get out */
    fclose( cap_fptr );
    cap_sw = 0;
  }
  return(0);
}

/* ----- keyfun:  Use to call BIOS keyboard input services ------
 *  Use instead of keypressed and bioskey to prevent DOS ^C's. */
int keyfun(int serv)
{
  rg.h.ah = serv;
  int86(BIOS_KEY, &amp;rg, &amp;rg);
  if (serv == KEYHIT)
    return ((rg.x.flags &amp; 0x40) == 0);
  else
    return (rg.x.ax);
}

/* ----- term:  Emulates a dumb terminal. -------------------- */
void term()
{
  register int i;
  int  keyin;                   /* Key = scan code + ASCII val */
  char gochar;
  int redd;
  int ret_code,
      wait_ret;
  char *tail = inbuf;              /* for tail of input buffer */
  static int cap_flag = 0;        /* Is capture turned on now? */

  while (mode == M_Term) {
    redd = BUFLEN / 2;               /* Go for half at a time. */
    ret_code = read_comm (&amp;redd, inbuf, 10);       /* 10 msecs */
    if ( (ret_code != 0) &amp;&amp; (ret_code != TIMEOUT) )
      fprintf (stderr, &quot;read_comm error %x\n&quot;, ret_code );

    if ( redd &gt; 0 ) {                /* Reading was productive */
      tail[redd] = 0;                          /* plant a null */

      for ( i = 0; i &lt; redd; i++) {      /* check for specials */
        if ( isprint( gochar = inbuf[i] &amp; 0x7F) ||  /* zero hi */
           (    isspace(gochar)               ) ||  /* CR,LF.. */
                gochar == BS                           ) {
           putch(gochar);
           if (cap_flag)
             fputc(gochar, cap_fptr);
        }   /* printable test */
      }   /* for loop */
    }   /* end if reading was productive */

    if ( keyfun(KEYHIT) ) {
      keyin = keyfun(READNEXT);    /* Retrieve Scan Code + Key */
      gochar = keyin &amp; 0xFF;                      /* truncates */
      if (gochar == 0) {          /* Function key or a special */
        switch (keyin) {
          case PGUP: mode = M_XSend;
                     xmodem_send();
                     mode = M_Term;
                     break;
          case PGDN: mode = M_XRecv;
                     xmodem_recv();
                     mode = M_Term;
                     break;
          case CBRK: xmit_break();
                     break;
          case INS:  if (capture_sw() == 0)
                       cap_flag = !cap_flag;
          default:   break;
        }
      }
      else {         /* Some plain old ascii character came in */
        if ( gochar != eschar ) {
          outbuf[0] = gochar;
          writecomm(outbuf, 1);
        }
        else                                 /* ESCAPE entered */
          mode = M_Cmd;                 /* leave terminal mode */
      }
    }  /* end if keypressed */
  }    /*  while mode = M_Term */
  return;
}

/* ----- off_to_dos: Prompts for command to pass to dos. ----- */
void off_to_dos()
{
  char buf[LINELEN];

  fputs(&quot;\nInput DOS Command (CR returns to menu)\nDOS&gt;&quot;,stdout);

  while ( fgetsnn(stdin, buf, LINELEN) ) {  /* &gt; 1 means got 1 */
    system(buf);
    fputs(&quot;\nDOS&gt;&quot;,stdout);
  }
}

/* ----- config:  Prompts for new config (speed or default).-- */
void config()
{
  S_INIT work;
  char *cptr;
  char buf[LINELEN];
  unsigned inval;
  int inlen;
  int i = 0;

  work = Get_Conf(comport);             /* a struct assignment */

  fputs(&quot;\n Current config shows:\n&quot;, stdout);

  printf(&quot;%5u, parity %s, %s stops, %d bits/char.\n&quot;,
    work.speed,
    PARITY_LIST[work.ubits.lbits.parity],
    STOP_LIST[work.ubits.lbits.two_stops],
    work.ubits.lbits.wlen + 5);

  fputs(&quot;0 = T16 ( 7, 1, Even )\n&quot;, stdout);
  fputs(&quot;1 = BBS ( 8, 1, None )\n&quot;, stdout);
  fputs(&quot;other = new speed value\n&quot;, stdout);

  inlen = fgetsnn(stdin, buf, LINELEN);   /* Got one parameter */
  if (inlen &gt; 0) {
    inval = atoi(buf);
    if (inval == 0) {
      work.ubits.lctrl = sev1even;                 /* 7,1,EVEN */
      bbsmode = 0;
    }
    if (inval == 1) {
      work.ubits.lctrl = ate1none;                 /* 8,1,NONE */
      bbsmode = 1;
    }
    if (inval &gt; 1) {
      while ( SPEED_VALS[i] &amp;&amp; SPEED_VALS[i] != inval )
        i++;
      if (SPEED_VALS[i] == 0)
        printf(&quot;\n Speed %d unavailable.\n&quot;,inval);
      else {   /* found a valid new speed */
        work.speed = inval;
      }
    }
    Config_Comm(comport, work);
    cur_config = work;                  /* Publish the results */
  }
  else
    fputs(&quot;\n Exiting Config mode.\n&quot;,stdout);

  if ( inlen == (LINELEN - 1) )
    while (fgetc(stdin) != EOF)     /* Purge garbage in buffer */
      ;

  mode = M_Cmd;
}


/* ----- prompt_wait: Prompts with string, parses command. ------
 * Returns: The (int) index number of the command entered.     */
prompt_wait ( char *prompt, char *cmds[], int n, int help  )
{
  char buffer[LINELEN];    /* used by fgetsnn */
  int i = 0;

  while (i == 0) {              /* Don't bite on CR only input */
    printf(&quot;\n%s&quot;,prompt);
    i   = fgetsnn(stdin, buffer, LINELEN );
  }

  if ( i == (LINELEN - 1) )
    while (fgetc(stdin) != EOF)     /* Purge garbage in buffer */
      ;

  for ( i = 0 ; i &lt; n ; i++ )
    if ( *cmds[i] == toupper(buffer[0]) )  /* Match first char */
      return(i);
  return (help);           /* not found... return help default */
}

/* ----- main_help:  Shows canned help message --------------- */
void main_help()
{
static char *details[] =
  { &quot;Config  : Set up comm parameters.\n&quot;,
    &quot;Dos,    : Calls DOS with commands.\n&quot;,
    &quot;Help,   : See this help info.\n&quot;,
    &quot;Quit    : Exit program.\n&quot;,
    &quot;Rcvx,   : Receive file using Xmodem.\n&quot;,
    &quot;Sendx,  : Send file using Xmodem.\n&quot;,
    &quot;Term,   : Dumb terminal mode.\n&quot;        };

  register int i;

  fputs(&quot;\n Valid commands are:\n&quot;,stdout);
  for (i = 0 ; i &lt; CMDDIM(details) ; i++)
    printf(&quot;%s&quot;,details[i]);
}

/* ----- main_menu:  Prompts for input, dispatches if valid -- */
void main_menu()
{
  static char *prompt     = &quot;CTERM&gt;&quot;;
  static char *maincmds[] =
    { &quot;CONFIG&quot;,
      &quot;DOS&quot;,
      &quot;HELP&quot;,             /* used for default below (index 2 ) */
      &quot;QUIT&quot;,
      &quot;RCVX&quot;,
      &quot;SENDX&quot;,
      &quot;TERM&quot;   };

  while (mode == M_Cmd) {
    switch ( prompt_wait(prompt, maincmds, CMDDIM(maincmds), 2 ))
    {
       case 0:  mode = M_Config;
                config();
                break;
       case 1:  off_to_dos();
                break;
       case 2:  main_help();
                break;
       case 3:  printf(&quot;\n *** Closing Comm port %d.&quot;, comport);
                close_comm();
                exit(1);
       case 4:  mode = M_XRecv;
                xmodem_recv();
                fputs(&quot;\nReturned from xmodem recv!\n&quot;,stdout);
                break;
       case 5:  mode = M_XSend;
                xmodem_send();
                fputs(&quot;\nReturned from xmodem send!\n&quot;,stdout);
                break;
       case 6:  mode = M_Term;
                eat_noise();
                term();
                break;
       default: main_help();
    }  /* end switch */
  }  /* end while */
}

/* ----- Catch_23:  Traps ^C + ^Break during user I/O. ------- */
void Catch_23()
{
  signal(SIGINT, Catch_23);      /*  Re-install self each time */
  return;
}

/* ----- Catch_24:  Traps Disk (Abort, Retry, Fail?) errors -- */
int Catch_24(int errval, int ax, int bp, int si)
{
  char msg[25];
  int drive;

  if (ax &lt; 0) {          /* device error */
    bdosptr( 0x09, &quot;device error$&quot;, 0);
    hardretn(-1);
  }

  drive = (ax &amp; 0x00FF);
  sprintf(msg, &quot;disc error on drive %c $&quot;, 'A' + drive);
  bdosptr( 0x09, msg, 0);
  hardretn(2);
}

/* ----- usage:  Give user quick help before exit. ----------- */
usage()
{
  printf(&quot;\n Defaults: T16, 1200 bps, 8,1,NONE, COM1, ESC.\n&quot;);
}

/* ----- main:  Gets the ball rolling!  ---------------------- */
main( int argc, char *argv[] )
{
  int error;

  VERSION;
  signal(SIGINT, Catch_23);
  harderr(Catch_24);

  argc = getargs( argc, argv, Argtab, CMDDIM(Argtab), usage );

  error = init_comm(comport, bbsmode);
  if (error != 0) {
    fprintf(stderr,&quot;\n *** Comm Port %d Init FAILED!&quot;,comport);
    return(2);
  }

  fprintf(stderr,&quot;\n *** Comm Port %d Init O.K. *** &quot;, comport);
  main_menu();
  return(1);
}






<a name="01ff_001d"><a name="01ff_001d">
<a name="01ff_001e"></pre><B>[LISTING SIX]</B><pre><a name="01ff_001e">

#Make file for cterm series Turbo C.  1/23/89 DWS
#3/20/89:  Added getargs and stoi (.obj only) from Holub
#use Make -fmakect1
#Small memory model
MDL = s
LIB = c:\turboc\lib

#implicit rules
# To add debug info: TCC (-v), TLINK (/v)
.c.obj:
   tcc -c -m$(MDL) $&lt;

#explicit rules
cterm1.exe: commint.obj xmsend.obj xmrecv.obj xmutil.obj cterm1.obj
     tlink  ..\lib\c0s cterm1 xmsend xmrecv xmutil commint getargs stoi, \
     cterm1, , ..\lib\cs

xmsend.obj:  xmsend.c  cterm.h  commn.h

xmrecv.obj:  xmrecv.c  cterm.h  commn.h

commint.obj: commint.c          commn.h  commint.h

xmutil.obj:  xmutil.c  cterm.h  commn.h  commint.h

cterm1.obj:  cterm1.c  cterm.h  commn.h

#end makefile






<P>
<P>
</pre><HR><P>Copyright &copy; 1989, <I>Dr. Dobb's Journal</I></P></BODY></HTML>
