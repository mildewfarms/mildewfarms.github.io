<HTML>
<META NAME="year" CONTENT="1989">
<HEAD>

<TITLE>MAR89: C PROGRAMMING</TITLE></HEAD>
<body bgcolor="FFFFFF">
<h1>C PROGRAMMING<a name="00a0_0003"><a name="00a0_0003"></h1><P>
<h2><a name="00a0_0001"><a name="00a0_0000">TINYCOMM Begets SMALLCOM</h2><P>
<h3>Al Stevens</h3><P>
<a name="00a0_0002"><a name="00a0_0000">Last month we added functions to our library of C tools to support serial ports and modems and explained --ever so briefly --the basics of serial communications.  To illustrate the use of those tools and principles, we built a communications program called TINYCOMM. That program uses none of the window, menu, and help functions from our ongoing library collection.  Its presentation was focused instead on a terse demonstration of the use of the serial and modem functions.  This month the TINYCOMM program spawns an offspring that is named SMALLCOM and that uses the window, menu, and data entry tools from earlier columns to support the user interface.  SMALLCOM has more of the features found in a commercial communications program --features, such as uploading and downloading files, a serial port configuration file that can be changed from the program, an editor, hooks for a phone directory and scripts, hooks for file transfer protocols and automatic recognition of, and reaction to, the Hayes modem result codes.<P>
<h3><a name="00a0_0004">SMALLCOM Source Code<a name="00a0_0004"></h3><P>
The listings for SMALLCOM are <a href="8903j.htm#00a0_000e">Listing One</A>, smallcom.c, page 131, <a href="8903j.htm#00a0_0010">Listing Two</A>, smallcom.prj, page 136, <a href="8903j.htm#00a0_0013">Listing Three</A>, smallcom.mak, page 136, and <a href="8903j.htm#00a0_0015">Listing Four</A>, smallcom.lnk, page 136.  Smallcom.c is the source code for the program.  In addition, you will need most of the library source programs published in this column since September when the project began. Smallcom.prj is the Turbo C project make file for building the program from the Turbo C environment.  Set the compact memory model and define these global macros either as #define statements in window.h or within the Compiler Defines option (Alt-O/C/D) of the Turbo C environment as shown here:<P>
<pre>  TURBOC=1;MSOFT=2;COMPILER=TURBOC</pre><P>
Smallcom.mak and smallcom.lnk are the Microsoft C make file and linker command file to build the program.  They assume that Microsoft C is in the DOS execution path, that the MSC libraries are in the \LIB subdirectory, and that the LIB and INCLUDE environment variables are properly set.<P>
<h3><a name="00a0_0005">Hooks<a name="00a0_0005"></h3><P>
Earlier I mentioned hooks in the program.  These hooks will be used in the coming months to add a phone directory, on-line service scripts, and XModem and Kermit file transfer protocols.  The hooks are function pointers that initially have NULL values.  As we add features, we will initialize the function pointers with the addresses of the functions for the features we want to add.  This hooking technique allows us to plan for expansion while preserving most of the existing code.<P>
The phone directory hook is executed by the directory menu selection.  The script processor hook is executed when an originating call makes connection with the remote processor.  We will decide later what a script process really is.  For now it is enough to know that when we need one, it will be there when the call goes through.  Scripts are typically related to specific online services, so SMALLCOM will associate scripts with phone numbers in the directory.  The file transfer protocol hooks occur at two levels.  The higher hook is a call to a function that will allow the user to select a protocol for an upload or download.  The address of the function will be in the select_transfer_protocol function pointer hook.  That function must return a subscript into an array of function pointers and will be provided later.  There is an array for uploads called up_protocol and one for downloads called down_protocol.  These two arrays will contain the addresses of the functions that implement the various protocols.  The first entries in both arrays are the addresses of the ASCII protocol functions, which are included in this first edition of SMALLCOM.  Others will be added later.<P>
<h3><a name="00a0_0006">More Communications Processes<a name="00a0_0006"></h3><P>
To use the modem in ways needed for SMALLCOM, we must change its initialization string from the value used last month.  Modify the INITMODEM definition in modem.h to this value:<P>
<pre>AT&amp;C1E-0M1S7=60S11=55V1X3S0=0\r</pre><P>
Look now at the end of <a href="8903j.htm#00a0_000e">Listing One</A>, smallcom.c.  There are some additional functions for managing the modem and serial port.  These functions were not needed in last month's TINYCOMM program.  You might want to move them into serial.c and modem.c as appropriate.  I will explain those functions here.<P>
The testcarrier function uses the carrier macro to see if the modem has lost the carrier detect signal.  By testing this signal, the program can determine that the remote processor has disconnected.  First, though, you must configure your modem for normal operation of the carrier detect signal.  Many modems will optionally assert this signal at all times regardless of the connection.  See if your modem has a dip switch to turn the signal off and use that as the default option.  Remember, not all modems are alike, and not everyone will have their modems set up the same.<P>
The waitforconnect function is used when the program is waiting for an incoming call or waiting for an originating call to be answered.  When an incoming call occurs, the function can sense the baud rate of the caller and adjust the local-baud rate accordingly.  This process is made possible by the result codes returned by the modem when it makes the connection.<P>
The waitforconnect function calls the waitforresult function, which waits for and returns the modem's result code.  The modem returns CONNECT, CONNECT 1200, or CONNECT 2400 strings depending on the caller's baud rate.  For an originated call, the modem will return NO CARRIER if the called party answers without a carrier detect signal or NO ANSWER if the called party does not answer.  The waitforresult function translates these strings into integer result codes.<P>
The waitforresult function calls the general-purpose waitforstring function.  This function will be important to us later when we get into script processing.  You pass this function the address of an array of characters, each of which points to a string.  The function watches the serial input stream to see if the stream matches any of the strings, and returns the offset of the matching string or -1 if the TIMEOUT value elapses before any match occurs.  This use of the waitforstring function uses an array of pointers to the modem's result codes. waitforstring allows you to use the backslash as a wild card character in the string arguments.<P>
<h3><a name="00a0_0007">Help Windows<a name="00a0_0007"></h3><P>
In December we introduced help windows into our tool collection and illustrated their use by including the feature in the TWRP tiny word processor.  Help windows are recorded in a file named by the load_help function and identified by help window mnemonics found in the data-entry screen FIELD structures --the MENU structures --and the calls to the set_help function.  SMALLCOM includes these mnemonics, but I am not publishing the text for the help windows.  There is nothing more to be learned from more help text, so they would only serve to use up valuable space in the magazine.  You can customize new help windows to your preference, or you can omit them.  SMALLCOM includes most of TWRP as its integrated editor, so you can copy December's twrp.hlp to a file you will name smallcom.hlp and add SMALLCOM-specific help windows to it.  The mnemonics are found in the source code in smallcom.c.<P>
<h3><a name="00a0_0008">Configuration File<a name="00a0_0008"></h3><P>
When SMALLCOM is run, it looks for a file named smallcom.cfg.  If that file exists, SMALLCOM reads its contents into the variables that specify the default serial port and modem parameters -- which port is being used, the parity, the number of stop bits, the word length, the baud rate, whether pulse or tone dialing is to be used, and what the default phone number is for calls originated by SMALLCOM.  If the file does not exist, the program uses the values coded into those variables when SMALLCOM was compiled.  The SMALLCOM menu bar includes a pop-down menu that allows you to change all but the phone number and to write everything including the phone number to a new copy of the configuration file.  As things stand right now, that allows you to configure everything except the phone number.<P>
<h3><a name="00a0_0009">The SMALLCOM Screen Format<a name="00a0_0009"></h3><P>
SMALLCOM provides a large window for showing the text passed between processors and uses the menu manager software from our window library.  The menu bar at the top of the screen has selections named &quot;File,&quot; &quot;Connect,&quot; &quot;Parameters,&quot; &quot;Editor,&quot; and &quot;Directory.&quot; You can get to one of these selections by pressing F10 and using the right and left arrow keys to move back and forth among the pop-down menus, or you can press the Alt key along with the first letter of the selection you want.  The &quot;File,&quot; &quot;Connect,&quot; and &quot;Parameters&quot; selections pop-down menus for further selections.  The &quot;Editor&quot; and &quot;Directory&quot; selections light up the selection on the menu bar and let you press Enter to execute the text editor or phone directory.  The bottom of the screen has a status bar that shows what is going on.  The &quot;On/Off Line&quot; message tells if you are connected to a remote computer.  The &quot;Direct&quot; message says you have selected a direct, null-modem connection.  If you are logging text, the &quot;Logging&quot; message appears.  If you are in the modem's answer mode waiting for a call, the &quot;Answering&quot; message appears.  While you are uploading or downloading a file the &quot;Uploading&quot; or &quot;Downloading&quot; message appears with as much of the file's path and name as can fit on the status bar.  The current phone number -- the one that will be dialed by the &quot;Place Call&quot; selection on the &quot;Connect&quot; menu -- is shown.<P>
The &quot;Parameters&quot; pop-down menu allows you to set and change the serial port and modem parameters.  Their initial values are recorded in the smallcom.cfg file.  You use the Enter key to step through the valid settings for each parameter.  Any changes you make on the menu are in effect for as long as the program is running.  If you use the &quot;Write Parameters&quot; selection, the current settings are written to the smallcom.cfg file and will be the default values the next time you run the program.<P>
You cannot communicate through SMALLCOM until you have connected with another computer.  The other computer can be running SMALLCOM, it can be an online service or bulletin board system, or it can be a different communications program such as Procomm.  The &quot;Connect&quot; pop-down menu has selections for making and breaking connections.  When you select &quot;Place Call,&quot; SMALLCOM dials the current phone number (shown in the status line at the bottom of the screen on the right side) and waits for the remote computer to answer.  The &quot;Answer Call&quot; selection puts the modem into answer mode.  When a call comes in, the modem will answer the phone and return a status message that tells the baud rate of the caller.  The &quot;Hang Up&quot; selection breaks the connection.  The &quot;Direct Connection&quot; command assumes that the connection is direct with a null modem cable and no modem commands are involved.<P>
Once one of these connections has been made, the cursor is in the data window, and you can type messages and read the messages that arrive from the remote computer.  You can use the &quot;File&quot; pop-down menu to upload and download files and to turn the system log on and off.  The system log is a file named smallcom.log that records everything sent and received by the program.  If smallcom.log exists when you turn the option on, new text is appended to the file.<P>
<h3><a name="00a0_000a">Echoes<a name="00a0_000a"></h3><P>
When two computers converse across phone lines, one of them has placed a call and the other has answered.  The two roles are somewhat different.  The caller will expect the called system to echo any characters that the caller sends and will not display characters locally as they are being typed.  The called system does not expect the caller to echo and thus displays its own characters as they are typed.  Therefore, SMALLCOM must remember whether it originated or answered the call and not echo or echo accordingly.  (An echo is the return of the character just received.  I derived this behavior empirically by observing the behavior of other communications programs.)  If you call a computer and upload a text file, the answering computer will echo each character because it does not know that you are not typing.  If, however, the called computer is told to download the file, it does not echo the characters you sent, because it assumes that a file transfer is underway.  These are the rules that SMALLCOM obeys.  Therefore, if the called computer is downloading and the caller is typing, the caller will not display the characters on its screen because no echo is being sent.  Conversely, if the caller is uploading and the called system is not downloading, the text is displayed at both locations during the transfer.  If the caller is uploading and the called system downloading, neither computer displays the text.  When you select the &quot;Direct Connection&quot; mode, each computer displays its own keystrokes and does not echo anything back to the other. Confused?  So was I when I worked all this out.<P>
In communication jargon these procedures are called half and full duplex transmissions, and some communications programs let you configure for one or the other.  My objective was to let the program determine the proper mode based on its recognition of the circumstances at hand.<P>
These echo problems pertain to typing, and they pertain as well to the ASCII file-transfer protocol because that protocol looks to the receiver just like typing.  If you don't tell the other computer that you are sending a file, it doesn't see any difference.  The ASCII transfer protocol is usually used to send text messages that were prepared off line, but it can also be used to upload files that do not have critical content.  When you do that, the receiving program knows a file transfer is in progress because you tell it to download a file.  When we get into the binary file-transfer protocols, no such echo concerns will bother us because both computers must be fully aware of what is going on.<P>
<h3><a name="00a0_000b">Editor<a name="00a0_000b"></h3><P>
The editor selection on the menu bar calls the SMALLCOM text editor, which is an integrated version of the TWRP tiny word processor from December.  All the TWRP commands are available, and you can edit a text file of up to 800 lines.  You can call this editor while you are on or off line.  It can be used to browse messages that you downloaded or to compose answers. Usually you will use it while you are off line to save connect charges.<P>
<h3><a name="00a0_000c">Phone Directory<a name="00a0_000c"></h3><P>
If you select the directory entry on the SMALLCOM menu bar, nothing happens because that feature is stubbed out for now with a NULL in its hook function pointer.  Next month we will add the phone directory.  It will allow to add, change, and delete entries and select an entry as the current one to be dialed.  Until we have that feature, you must hard-code the phone number into the PHONENO string in February's modem.c.<P>
<h3><a name="00a0_000d">Discussions with Readers<a name="00a0_000d"></h3><P>
Some readers find time to write me at the magazine or leave messages for me on CompuServe. (My CIS ID is 71101,1262.)  When a reader's question or comment raises an issue or provokes a thought that might interest others, I will address it here.<P>
A reader asked why I was reinventing the wheel.  Why another window package, another help package, another menu manager, another editor, another communications program?  Why any of this indeed?  My answer to him was that the point of the &quot;C Programming&quot; column project is first to bring to you, the readers-at-large, a collection of C language tools that you can use in your applications, and second show by example how these tools are programmed in C.  I am not trying to replace any programs that you might already be using, programs that do all and more of what this software does.  If all you want is what Procomm does, you should get Procomm.  It's a good program, and it costs much less than the time you will devote working with and learning the software tools in this column.  If, on the other hand, you want to learn how programs like Procomm are developed and, at the same time, collect the tools that go into such developments, then you are in the right place.  Such lessons and software tool collections are the backbone of this column and are consistent with the 12-year legacy of DDJ.<P>
One reader cleverly matched one of my crotchets with one of my programs and suggested I practice what I preach.  Being neither preacher nor teacher, I practice what I practice and offer those practices as examples of things that might benefit programmers.  Sometimes my programming practices stray from the disciplines held by the distant gurus as proper programming habits.  Sometimes I violate my own rules to get the job done.  I do not attach as well to dogmatism as I do to pragmatism.<P>

_C PROGRAMMING COLUMN_
by Al Stevens

<a name="00a0_000e"><a name="00a0_000e">
<a name="00a0_000f"></pre><B>[LISTING ONE]</B><pre><a name="00a0_000f">

/* ------ smallcom.c ---------- */
#include &lt;conio.h&gt;
#include &lt;stdio.h&gt;
#include &lt;mem.h&gt;
#include &lt;string.h&gt;
#include &lt;ctype.h&gt;
#include &lt;dos.h&gt;
#include &lt;stdlib.h&gt;
#include &quot;window.h&quot;
#include &quot;editor.h&quot;
#include &quot;menu.h&quot;
#include &quot;entry.h&quot;
#include &quot;serial.h&quot;
#include &quot;modem.h&quot;
#include &quot;help.h&quot;

#define ANSWERTIMEOUT 60
#define MAXSTRINGS 15
#define carrier() (inp(MODEMSTATUS) &amp; 0x80)
#define LOGFILE  &quot;smallcom.log&quot;
#define HELPFILE &quot;smallcom.hlp&quot;
#define CFGFILE  &quot;smallcom.cfg&quot;
#define ALT_P 153
#define ALT_C 174
#define CTRL_C 3
#define WILDCARD '?'
static union REGS rg;
static FILE *logfp, *uploadfp, *downloadfp, *cfg;
static int running=1,connected,answering,savebaud;
int filecount;
extern int direct_connection, TIMEOUT, inserting;
extern char spaces[];
extern struct wn wkw;
extern MENU *mn;
/* ---------- prototypes ----------- */
void fileedit(char *);
static void displaycount(void);
static void smallmenu(int);
static void logserial(int);
static int upload(int, int);
static int download(int, int);
static int call(int, int);
static int directory(int, int);
static int comeditor(int, int);
static answer(int, int);
static directcon(int, int);
static int loginput(int, int);
static int hangup(int, int);
static int quit(int, int);
static int prm(int, int);
static void loadp(void);
static int savep(int, int);
static void set_parameters(void);
static int get_filename(char *);
static void notice(char *);
static void statusline(void);
static void putch_window(int);
void upload_ASCII(FILE *);
void download_ASCII(FILE *);
int keyhit(void);
char *prompt_line(char *, int, char *);
void reset_prompt(char *, int);
static int testcarrier(void);
static int waitforconnect(void);
static void initcom(void);
int waitforresult(void);
int waitforstring(char **, int, int);
static void waitforcall(void);
static void resetline(void);
/* ------- the hook to the phone directory ---------- */
static void (*phone_directory)(void) = NULL;
/* ------- the hook to script processors ---------- */
void (*script_processor)(void); /* filled in by directory */
/* ------- hooks to file transfer protocols --------- */
static int (*select_transfer_protocol)(void) = NULL;
/* ----- up to five upload function pointers ----- */
static void (*up_protocol[5])(FILE *file_pointer) = {
    upload_ASCII, NULL, NULL, NULL, NULL
};
/* ----- up to five download function pointers ----- */
static void (*down_protocol[5])(FILE *file_pointer) = {
    download_ASCII, NULL, NULL, NULL, NULL
};
/* --------- Files menu ------------ */
static char *fselcs[] = {
    &quot;Log Input On/Off&quot;,
    &quot;Upload a File&quot;,
    &quot;Download a File&quot;,
    &quot;Quit&quot;,
    NULL
};
static char *fhelps[] = {&quot;log&quot;,&quot;upload&quot;,&quot;download&quot;,&quot;quitcom&quot;};
/* ----------- Connect menu -------------- */
static char *cselcs[] = {
    &quot;Place Call&quot;,
    &quot;Answer Call&quot;,
    &quot;Hang up&quot;,
    &quot;Direct Connection&quot;,
    NULL
};
static char *chelps[] = {&quot;call&quot;,&quot;answer&quot;,&quot;hangup&quot;,&quot;direct&quot;};
/* ---------- Parameters menu --------------- */
static char *pselcs[] = {
    &quot;Com Port:                       &quot;,
    &quot;Baud Rate:                      &quot;,
    &quot;Data Bits:                      &quot;,
    &quot;Stop Bit(s):                    &quot;,
    &quot;Parity:                         &quot;,
    &quot;Mode of Dialing:                &quot;,
    &quot;Write Parameters&quot;,
    NULL
};
static char *phelps[] = {&quot;port&quot;,&quot;baud&quot;,&quot;wordlen&quot;,&quot;stopbits&quot;,
                         &quot;parity&quot;,&quot;dialmode&quot;,&quot;writecfg&quot;};
/* ---------- menu selection function tables ----------- */
static int (*ffuncs[])() = {loginput,upload,download,quit};
static int (*cfuncs[])() = {call,answer,hangup,directcon};
static int (*pfuncs[])() = {prm,prm,prm,prm,prm,prm,savep};
static int (*efuncs[])() = {comeditor};
static int (*dfuncs[])() = {directory};
/* ------ horizontal prompt messages ---------- */
char fdesc[]=&quot;Message File Operations&quot;;
char cdesc[]=&quot;Connections to Remote Processor&quot;;
char pdesc[]=&quot;Set Communications Parameters for Program Start&quot;;
char edesc[]=&quot;Edit a Text File&quot;;
char ddesc[]=&quot;The SMALLCOM Telephone Directory&quot;;
/* ------- horizontal menu bar ----------- */
static MENU cmn [] = {
   {&quot;File&quot;,       fdesc, fselcs, fhelps, &quot;ludq&quot;,    ffuncs, 0},
   {&quot;Connect&quot;,    cdesc, cselcs, chelps, &quot;pahd&quot;,    cfuncs, 0},
   {&quot;Parameters&quot;, pdesc, pselcs, phelps, &quot;cbdspmw&quot;, pfuncs, 0},
   {&quot;Editor&quot;,     edesc, NULL,   NULL,   &quot;e&quot;,       efuncs, 0},
   {&quot;Directory&quot;,  ddesc, NULL,   NULL,   &quot;d&quot;,       dfuncs, 0},
   {NULL}
};
/* ------ filename data entry template and buffer ------- */
static char filename[65], filemask[65];
static FIELD fn_template[] = {
    {2,14,1,filename,filemask,NULL},
    {0}
};
/* ------ modem result codes ------- */
static char *results[] = {
    &quot;\r\nOK\r\n&quot;,
    &quot;\r\nCONNECT\r\n&quot;,
    &quot;\r\nRING\r\n&quot;,
    &quot;\r\nNO CARRIER\r\n&quot;,
    &quot;\r\nERROR\r\n&quot;,
    &quot;\r\nCONNECT 1200\r\n&quot;,
    &quot;\r\nNO DIALTONE\r\n&quot;,
    &quot;\r\nBUSY\r\n&quot;,
    &quot;\r\nNO ANSWER\r\n&quot;,
    &quot;\r\n\r\n&quot;,
    &quot;\r\nCONNECT 2400\r\n&quot;,
    NULL
};
extern int COMPORT,PARITY,STOPBITS,WORDLEN,BAUD;
extern char DIAL[], PHONENO[];
/* ================ MAIN ================== */
void main(void)
{
    int c;
    char *mb;
    inserting = FALSE;
    load_help(HELPFILE);
    loadp();
    savebaud = BAUD;
    set_parameters();
    clear_screen();
    mb = display_menubar(cmn);
    establish_window(1,2,80,24,TEXTFG,TEXTBG,TRUE);
    statusline();
    initcom();
    gotoxy(2,2);
    while (running) {
        set_help(&quot;smallcom&quot;);
        testcarrier();
        if (keyhit())   {
            switch (c = getkey())  {
                case F10:   smallmenu(0); break;
                case ALT_F: smallmenu(1); break;
                case ALT_C: smallmenu(2); break;
                case ALT_P: smallmenu(3); break;
                case ALT_E: smallmenu(4); break;
                case ALT_D: smallmenu(5); break;
                case CTRL_C:clear_window();
                            wkw.wx = wkw.wy = 0;
                            gotoxy(2,2);
                            break;
                case ESC:   quit(1,1);
                            break;
                default:    if (!(c &amp; 0x80) &amp;&amp; connected)    {
                                if (answering
                                        || direct_connection)
                                    logserial(c=='\r'?'\n':c);
                                writecomm(c);
                                if (c == '\r')
                                    writecomm('\n');
                            }
                            break;
            }
        }
        if (input_char_ready()) {
            logserial(c = readcomm());
            if (answering)
                writecomm(c);
        }
    }
    if (connected)
        hangup(1,1);
    release_modem();
    restore_menubar(mb);
    delete_window();
    clear_screen();
}
/* ---------- execute the SMALLCOM menu --------- */
static void smallmenu(int n)
{
    window(1,25,80,25);
    gotoxy(1,1);
    cprintf(spaces);
    putch(' ');
    current_window();
    menu_select(cmn, n);
    set_parameters();
    statusline();
    gotoxy(wkw.wx+2, wkw.wy+2);
}
/* ------ Call menu command ------ */
static int call(hs, vs)
{
    if (!connected) {
        notice(&quot;Dialing&quot;);
        placecall();
        sleep(4);
        delete_window();
        if ((connected = waitforconnect()) == FALSE)    {
            statusline();
            initmodem();
        }
        else if (script_processor)
            (*script_processor)();
    }
    return TRUE;
}
/* --------- Direct Connection menu command --------- */
static int directcon(hs, vs)
{
    direct_connection ^= 1;
    connected |= direct_connection;
    return TRUE;
}
/* ------- Hangup menu command ------- */
static int hangup(hs, vs)
{
    if (connected)  {
        notice(&quot;Hanging up&quot;);
        resetline();
        delete_window();
    }
    return TRUE;
}
/* --------- Quit menu command --------- */
static int quit(hs, vs)
{
    int c = 0;
    notice(&quot;Exit to DOS?  &quot;);
    c = getkey();
    delete_window();
    running = (tolower(c) != 'y');
    return TRUE;
}
/* -------- Log Input menu command -------- */
static int loginput(hs, vs)
{
    if (logfp == NULL)
        logfp = fopen(LOGFILE, &quot;ab&quot;);
    else    {
        fclose(logfp);
        logfp = NULL;
    }
    return TRUE;
}
/* ---------- Upload file menu command ---------- */
static int upload(hs, vs)
{
    int pr = 0;
    if (!connected) {
        error_message(&quot;Not connected&quot;);
        return FALSE;
    }
    if (uploadfp == NULL)   {
        setmem(filename, sizeof filename - 1, ' ');
        setmem(filemask, sizeof filemask - 1, '_');
        if (get_filename(&quot; Upload what file? &quot;) != ESC) {
            if ((uploadfp = fopen(filename, &quot;rb&quot;)) == NULL)
                error_message(&quot;Cannot open file&quot;);
            else    {
                statusline();
                if (select_transfer_protocol)
                    pr = (*select_transfer_protocol)();
                (*up_protocol[pr])(uploadfp);
                fclose(uploadfp);
                uploadfp = NULL;
            }
        }
    }
    return TRUE;
}
/* ------ upload a file with ASCII transfer protocol ----- */
void upload_ASCII(FILE *fp)
{
    int c;
    while ((c = fgetc(fp)) != EOF)  {
        writecomm(c);
        displaycount();
        if (input_char_ready())
            logserial(readcomm());
        if (keyhit())
            if (getch() == ESC)
                break;
        if (!testcarrier())
            break;
    }
    filecount = 0;
    if (connected)
        writecomm(EOF);
}
/* ---------- Download file menu command ---------- */
static int download(hs, vs)
{
    int pr = 0, save_timeout;
    if (!connected) {
        error_message(&quot;Not connected&quot;);
        return FALSE;
    }
    setmem(filename, sizeof filename - 1, ' ');
    setmem(filemask, sizeof filemask - 1, '_');
    if (get_filename(&quot; Download what file? &quot;) != ESC) {
        downloadfp = fopen(filename, &quot;wb&quot;);
        statusline();
        if (select_transfer_protocol)
            pr = (*select_transfer_protocol)();
        save_timeout = TIMEOUT;
        TIMEOUT = 60;
        (*down_protocol[pr])(downloadfp);
        TIMEOUT = save_timeout;
        fclose(downloadfp);
        downloadfp = NULL;
    }
    return TRUE;
}
/* ----- download a file with ASCII transfer protocol ----- */
void download_ASCII(FILE *fp)
{
    int c = 0;
    while (TRUE)    {
        if (keyhit())   {
            if ((c = getkey()) == ESC)
                break;
            writecomm(c);
            if (!answering)
                logserial(readcomm());
        }
        c = readcomm() &amp; 127;
        if (c == 0 || c == 0x7f)
            break;
        fputc(c, fp);
        displaycount();
        if (!testcarrier())
            break;
    }
}
/* --- echo modem input and write to the log if selected --- */
static void logserial(int c)
{
    putch_window(c);
    if (logfp)
        fputc(c, logfp);
}
/* -------- read a file name ------------- */
static int get_filename(char *ttl)
{
    int rtn;
    establish_window(1,23,80,25,ENTRYFG,ENTRYBG,TRUE);
    window_title(ttl);
    gotoxy(3,2);
    cputs(&quot;File name:&quot;);
    rtn = data_entry(fn_template, TRUE, 1);
    delete_window();
    return rtn;
}
/* -------- small message ------------ */
static void notice(char *s)
{
    int lf = (80-strlen(s))/2-1;
    int rt = lf+strlen(s)+2;
    establish_window(lf,11,rt,13,HELPFG,HELPBG,TRUE);
    gotoxy(2,2);
    cputs(s);
}
/* ---- comm and modem parameter menu commands ----- */
static int prm(hs, vs)
{
    switch (vs) {
        case 1: COMPORT ^= 3;       /* flip between 1 and 2 */
                break;
        case 2: BAUD *= 2;          /* 110,150,300,  */
                if (BAUD == 220)    /* 600,1200,2400 */
                    BAUD = 150;
                if (BAUD == 4800)
                    BAUD = 110;
                break;
        case 3: WORDLEN ^= 0xf;     /* flip between 7 and 8 */
                break;
        case 4: STOPBITS ^= 3;      /* flip between 1 and 2 */
                break;
        case 5: if (++PARITY == 3)  /* 0, 1, 2              */
                    PARITY = 0;
                break;
        case 6: DIAL[3] = DIAL[3] == 'T' ? 'P' : 'T';
                break;
        default:
                break;
    }
    set_parameters();
    return FALSE;
}
/* ------ post the parameters into the menu display ------- */
static void set_parameters(void)
{
    static char *pars[] = {&quot;None&quot;, &quot; Odd&quot;, &quot;Even&quot;};
    static char *mode[] = {&quot;Pulse&quot;, &quot; Tone&quot;};
    pselcs[0][strlen(pselcs[0])-1] = '0' + COMPORT;
    sprintf(&amp;pselcs[1][strlen(pselcs[1])-4],&quot;%4d&quot;,BAUD);
    pselcs[2][strlen(pselcs[2])-1] = '0' + WORDLEN;
    pselcs[3][strlen(pselcs[3])-1] = '0' + STOPBITS;
    sprintf(&amp;pselcs[4][strlen(pselcs[4])-4],&quot;%s&quot;,pars[PARITY]);
    sprintf(&amp;pselcs[5][strlen(pselcs[5])-5],&quot;%s&quot;,
        mode[DIAL[3]=='T']);
}
/* ------- load the configuration file ---------- */
static void loadp(void)
{
    if ((cfg = fopen(CFGFILE, &quot;r&quot;)) != NULL)    {
        fscanf(cfg,&quot;%d %d %d %d %d %c %s&quot;,
        &amp;COMPORT,&amp;PARITY,&amp;STOPBITS,&amp;WORDLEN,&amp;BAUD,&amp;DIAL[3],
            &amp;PHONENO[0]);
        fclose(cfg);
    }
}
/* ---------- Write Parameters menu command ---------- */
static int savep(hs, vs)
{
    cfg = fopen(CFGFILE, &quot;w&quot;);
    fprintf(cfg, &quot;%d %d %d %d %d %c %s&quot;,
        COMPORT,PARITY,STOPBITS,WORDLEN,BAUD,DIAL[3],PHONENO);
    fclose(cfg);
    initcom();
    return FALSE;
}
/* --------- Editor menu command --------------- */
static int comeditor(hs, vs)
{
    extern int MAXLINES, inserting;
    MAXLINES = 800;
    mn = NULL;
    fileedit(&quot;&quot;);
    inserting = FALSE;
    insert_line();
    return TRUE;
}
/* --------- Directory menu command --------------- */
static int directory(hs, vs)
{
    if (phone_directory)    {
        mn = NULL;
        (*phone_directory)();
    }
    return TRUE;
}
/* ----------- display a status line ----------- */
static void statusline(void)
{
    char stat[81];
    static char *st = NULL;
    sprintf(stat,
        &quot; %s Line %s %s %s %-12.12s       %-14.14s F10:Menu&quot;,
        (connected            ? &quot; On&quot;         : &quot;Off&quot;),
        (direct_connection    ? &quot;Direct&quot;      : &quot;      &quot;),
        (logfp                ? &quot;Logging&quot;     : &quot;       &quot;),
        ((answering &amp; !connected)
                              ? &quot;Answering  &quot; :
         uploadfp             ? &quot;Uploading  &quot; :
         downloadfp           ? &quot;Downloading&quot; : &quot;           &quot;),
        (uploadfp||downloadfp ? filename      : &quot; &quot;),
         *PHONENO ? PHONENO : &quot;No Phone #&quot;);
    st = prompt_line(stat, 25, st);
}
/* ------- write the file count into the status line ------- */
static void displaycount(void)
{
    filecount++;
    if ((filecount % 10) == 0)  {
        window(1,25,80,25);
        textcolor(MENUFG);
        textbackground(MENUBG);
        gotoxy(50,1);
        cprintf(&quot;%5d&quot;, filecount);
        current_window();
        gotoxy(wkw.wx+2, wkw.wy+2);
    }
}
/* ----- write a one-liner prompt saving video memory ----- */
char *prompt_line(char *s, int y, char *t)
{
    if (t == NULL)
        if ((t = malloc(160)) != NULL)
            gettext(1,y,80,y,t);
    window(1,y,80,y);
    textcolor(MENUFG);
    textbackground(MENUBG);
    gotoxy(1,1);
    cprintf(spaces);
    putch(' ');
    gotoxy(1,1);
    cprintf(s);
    current_window();
    return t;
}
/* ------- reset the one-liner prompt line --------- */
void reset_prompt(char *s, int y)
{
    puttext(1,y,80,y,s);
    free(s);
}
/* -------- write a character to the user's window -------- */
static void putch_window(int c)
{
    gotoxy(wkw.wx+2, wkw.wy+2);
    switch (c)  {
        case '\t':  while (wkw.wx % 4)
                        putch_window(' ');
                    break;
        case '\b':  if (wkw.wx)
                        --wkw.wx;
                    break;
        default:    putch(c);
                    wkw.wx++;
                    if (wkw.wx &lt; wkw.wd-2)
                        break;
        case '\n':  if (wkw.wy &lt; wkw.ht-1)
                        wkw.wy++;
                    else    {
                        scroll_window(1);
                        writeline(2, wkw.wy+2, spaces+1);
                    }
        case '\r':  wkw.wx = 0;
                    break;
    }
    gotoxy(wkw.wx+2, wkw.wy+2);
}
/* ------------ wait for a call ------------ */
static void waitforcall(void)
{
    answercall();
    if ((connected = answering = waitforconnect()) == FALSE) {
        statusline();
        initmodem();
    }
}
/* ---- wait for a line connection, reset baud rate ---- */
static int waitforconnect(void)
{
    extern int BAUD;
    int baud = 0;
    while (baud == 0)
        switch (waitforresult())    {
            case 1:     baud = 300;  break; /* CONNECT       */
            case 5:     baud = 1200; break; /* CONNECT 1200  */
            case 10:    baud = 2400; break; /* CONNECT 2400  */
            case 0:                         /* OK            */
            case 2:     break;              /* RING          */
            case 3:                         /* NO CARRIER    */
            case 4:                         /* ERROR         */
            case 7:                         /* BUSY          */
            case 8:                         /* NO ANSWER     */
            case -1:    baud = -1;   break; /* time-out      */
            default:    break;              /* anything else */
        }
    if (baud != -1 &amp;&amp; baud != BAUD) {
        savebaud = BAUD;
        BAUD = baud;
        initcomport();
    }
    return (baud != -1);
}
/* ---- wait for a modem result (0-10). -1 if timed out ---- */
int waitforresult(void)
{
    return waitforstring(results, ANSWERTIMEOUT, 0);
}
/* --------- wait for a string from the serial port -------- */
int waitforstring(char *tbl[], int wait, int wildcard)
{
    int c, i, done = FALSE;
    char *sr[MAXSTRINGS];
    for (i = 0; tbl[i] != NULL; i++)
        sr[i] = tbl[i];
    while (!done)   {
        set_timer(wait);
        while (!input_char_ready()) {
            if (timed_out())
                return -1;
            if (keyhit())
                if ((c = getkey()) == ESC)
                    return -1;
        }
        logserial(c = readcomm());
        for (i = 0; tbl[i] != NULL; i++)    {
            if (c==*(sr[i]) ||
                   (wildcard &amp;&amp; *(sr[i])==wildcard))   {
                if (*(++(sr[i])) == '\0')   {
                    done = TRUE;
                    break;
                }
            }
            else
                sr[i] = tbl[i];
        }
    }
    return i;
}
/* ----- initialize from serial and modem parameters ----- */
static void initcom(void)
{
    notice(&quot;Initializing Modem&quot;);
    initmodem();
    delete_window();
}
/* ----- test carrier detect -------- */
static int testcarrier(void)
{
    if (!direct_connection &amp;&amp; connected &amp;&amp; carrier() == FALSE)
        resetline();
    return connected;
}
/* ------ disconnect and reestablish the serial port ------ */
static void resetline(void)
{
    answering = connected = FALSE;
    statusline();
    disconnect();
    BAUD = savebaud;
    initcomport();
}
/* --------- answer a call ----------- */
static int answer(hs, vs)
{
    answering = 1;
    statusline();
    gotoxy(wkw.wx+2, wkw.wy+2);
    waitforcall();
    return TRUE;
}
#if COMPILER==TURBOC
/* --------- use bios to test for a keystroke -------- */
int keyhit(void)
{
    rg.h.ah = 1;
    int86(0x16, &amp;rg, &amp;rg);
    return ((rg.x.flags &amp; 0x40) == 0);
}
#endif
</pre>

<P>

<a name="00a0_0010"><a name="00a0_0010">
<a name="00a0_0011"><B><H3>[LISTING TWO]</H3></B><pre><a name="00a0_0011">

smallcom (serial.h,modem.h,editor.h,window.h,menu.h,entry.h,help.h)
editshel (editor.h, menu.h, entry.h, help.h, window.h)
editor (editor.h, window.h)
help (help.h, window.h)
modem (serial.h, modem.h)
serial (serial.h)
entry (entry.h, window.h)
menu (menu.h, window.h)
window (window.h)

</PRE>
<P>


<a name="00a0_0013">
<a name="00a0_0012"><a name="00a0_0012">
<a name="00a0_0013"></pre><B><H3>[LISTING THREE]</H3></B><pre>

#
#  SMALLCOM.MAK: make file for SMALLCOM.EXE with Microsoft C/MASM
#

.c.obj:
    cl /DMSOFT=1 /DTURBOC=2 /DCOMPILER=MSOFT -c -W3 -Gs -AC $*.c

smallcom.obj : smallcom.c serial.h modem.h menu.h entry.h \
                help.h window.h

modem.obj : modem.c serial.h modem.h

serial.obj : serial.c serial.h

entry.obj : entry.c entry.h window.h

menu.obj : menu.c menu.h window.h

help.obj : help.c help.h window.h

editshel.obj : editshel.c editor.h menu.h entry.h help.h \
                window.h

editor.obj : editor.c editor.h window.h

window.obj : window.c window.h

microsft.obj : microsft.c

vpeek.obj : vpeek.asm
    masm /MX vpeek;

keyhit.obj : keyhit.asm
    masm /MX keyhit;

smallcom.exe : smallcom.obj modem.obj serial.obj editor.obj \
              editshel.obj entry.obj menu.obj help.obj \
              window.obj keyhit.obj vpeek.obj microsft.obj
    link @smallcom.lnk

</PRE><P>





<a name="00a0_0015">
<a name="00a0_0014"><a name="00a0_0014">
<a name="00a0_0015"><B><H3>[LISTING FOUR]</H3></B><pre>
<PRE>
smallcom+
modem+
serial+
entry+
menu+
editor+
editshel+
help+
window+
vpeek+
keyhit+
microsft
smallcom
nul
\lib\clibce


</PRE>

<P>
<P>
</pre><HR><P>Copyright &copy; 1989, <I>Dr. Dobb's Journal</I></P></BODY></HTML>
