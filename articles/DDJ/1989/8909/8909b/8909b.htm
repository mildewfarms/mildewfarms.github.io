<HTML>
<META NAME="year" CONTENT="1989">
<HEAD>

<TITLE>SEP89: SIMULATED ANNEALING</TITLE></HEAD>
<body bgcolor="FFFFFF">
<h1>SIMULATED ANNEALING<a name="01b5_0003"><a name="01b5_0003"></h1><P>
<h2><a name="01b5_0001"><a name="01b5_0000">This algorithm may be one of the best solutions to the problem of combinatorial optimization</h2><P>
<h3>Michael P. McLaughlin</h3><P>
<p><i><a name="01b5_0002"><a name="01b5_0000">Dr. McLaughlin is a member of the technical staff, Air Transportation Systems, for Mitre Corp.  He can be reached at 1740 Westwind Way, McLean, VA 22102.</i></p><hr><P>
In science and engineering, it is a truism that, in any real system, everything is connected.  Indeed, you could do far worse than to define science as the search for such connections.  Scientists accorded the highest esteem, those names nearly everyone knows, are generally individuals whose insight allowed them either to forge links between a large number of separate concepts or to find a connection that no one had suspected.<P>
Occasionally, something similar happens on a smaller scale.  This article concerns the application of statistical mechanics to the solution of a difficult problem in computer science.  The problem is combinatorial optimization; the technique is called &quot;simulated annealing.&quot;<P>
Combinatorial optimization is the task of taking a finite number of indivisible &quot;objects&quot; and arranging them in a configuration that is &quot;best&quot; according to some stipulated criteria. For instance, how should 15 swimmers be selected from a team of 30, for an upcoming meet, if no one is allowed to enter more than one event?  Or how should aircraft, preparing to land, be sequenced in order to minimize delays?  What is the best routing for a telephone call from Boston to San Francisco at any given moment?  What is the best parse for a given English-language sentence?  What these and similar problems have in common are 1. an extremely large number of discrete choices, 2. a complicated set of optimizing criteria and 3. numerous constraints.  In such circumstances, simulated annealing has proven to be an excellent tool for seeking out the best solution.<P>
Simulated annealing is a relatively new form of stochastic search, familiar primarily to VLSI chip designers.  As you can imagine, determining the best geometrical arrangement for thousands of circuits is a formidable task.  To take an oversimplified example, suppose you have to partition 1000 circuits into five regions on a microchip.  Further suppose that permutations within a region do not matter and that every chip configuration can be given a numerical score ased upon an appropriate set of (possibly conflicting) criteria.  Prior to assessing constraints on placement, you have five choices for each circuit for a total of 5<sup>1000</sup> (about 10<sup>699</sup>) configurations.<P>
With numbers such as these, it really doesn't matter what kind of computer is available; checking each possibility is out of the question.  Nevertheless, the task remains and neither guessing nor giving up are viable options.  An answer is usually found with the help of a little computer assistance, often using simulated annealing.  Before looking at the usefulness of this simulated annealing, however, let's examine its main competitor.<P>
<h3><a name="01b5_0004">The Greedy Algorithm<a name="01b5_0004"></h3><P>
Perhaps the simplest general method for trying to locate a global optimum (maximum or minimum) in a discrete space is a technique often referred to as the &quot;greedy&quot; algorithm.  Described in English, it goes something like this:<P>

<ol><li>You randomize the starting configuration.
<li>If possible, you find a better configuration by making repeated (usually random) changes to the current configuration.
<li>Make this better configuration the current one, then go back to step 2.
<li>If a better configuration is not found after a reasonable amount of effort, conclude that you have obtained a local optimum.  Save it in the variable OPTIMUM.
<li>Repeat from step 1, replacing OPTIMUM if appropriate, until your patience or computing resources are exhausted.  Hope that the final value of OPTIMUM is global.</ol>

Until you try a few experiments with this algorithm on large problems with known answers, there is a strong temptation to believe that it might actually  work.  However, unless the size of the problem (the number of elements to be configured) is small or the configuration space exceptionally smooth, the chances of finding a global optimum in this fashion are remote.<P>
The deficiencies of the greedy algorithm are not obscure.  Imagine a mountain goat traipsing about the Rocky Mountains looking for the deepest valley (where the best grass is).  This goat is very hungry (greedy?) and, consequently, never takes an upward step.  Unless the goat starts out on a smooth slope of the deepest valley, it will never reach that valley but will, instead, come to a dead end in some higher valley, that is, in a local minimum, which may be much higher than the global minimum.  Moreover, a space as rough as the Rockies contains thousands of valleys, some only a few feet deep, and repeating the exercise (step 5, above) may yield improvement but probably not the best result.<P>
<h3><a name="01b5_0005">A Great Deal of Difficulty<a name="01b5_0005"></h3><P>
The difficulties of combinatorial optimization can be illustrated in the game of poker solitaire where the object is to rearrange the 25 cards of the tableau, like that in <a href="198901b7.htm">Figure 1</A>, so that the 12 hands of straight poker formed from the 5 rows, 5 columns, and 2 diagonals give the highest total score.  Various scoring schemes are popular, but I shall use the one listed in <a href="8909b.htm#01b5_0006">Table 1</A> in which each hand of a pair or better has a value inversely proportional to its probability in a standard deck, normalized to that of a single pair.  All hands of a given type (for example, full house) are considered equal, and an ace can be high or low.<P>
<h4><a name="01b5_0006"><a name="01b5_0006"><B>Table 1:</B> Scoring table</h4><P>
<pre>
  Hand                  Score
  ---------------------------

  Straight flush       27,456

  Four of a kind        1,760

  Full house              293

  Flush                   215

  Straight                108

  Three of a kind          20

  Two pair                  9

  Pair                      1</pre><P>
<P>
Compared to the task of optimizing circuit placement on a microchip, this is a small problem indeed.  There are only 25! (about 10<sup>25</sup>) configurations and even fewer if symmetry (rotations, reflections, and so on) is taken into account.  Nevertheless, this is such a huge number that, even if a computer could evaluate a million configurations per second without repetition, the execution time required to test all of them would be comparable to the present age of the universe.  To accommodate this situation, both simulated annealing and the greedy algorithm employ stochastic techniques, evaluating only a fraction of the possible configurations.  Consequently, these algorithms provide no absolute guarantee that they will find the global optimum every time.  For large problems, it is usually sufficient that a technique provides a reasonable chance of coming close to the global optimum nearly every time.  Then, a few runs will yield as good an answer as you are likely to require.<P>
The tableau in <a href="198901b8.htm">Figure 1</A> contains 7 pairs for a score of 7, although there are obviously 4 aces and 4 kings, so it is reasonable to expect that a good score would be at least 4000.  Finding a really high score is not easy, however.  The 12 poker hands are tightly interlocked, and even a small change in configuration can result in a drastic change in score.  This is another way of saying that the configuration space is very rough.  Informal experiments have shown it to be more than a match for a human player, and it provides a good test for any combinatorial optimization technique.<P>
<h3><a name="01b5_0007">Simulated Annealing<a name="01b5_0007"></h3><P>
The term annealing originally referred to a process employed in the fabrication of objects constructed of metal or glass.  When these materials are shaped, small, often microscopic, regions of stress develop in response to deformations at the atomic level and cause the object to be prone to fracture.  Annealing corrects this defect.<P>
From a chemical standpoint, regions of stress have relatively high energy and thus are &quot;almost fractured&quot; already.  An object would be more stable (of lower energy) if the stress were absent.  However, atoms and molecules in a solid at room temperature do not have enough energy, on average, to move about and relieve the stress.  (If they did, the object wouldn't be very solid.)  When an object is annealed, it is first heated enough to provide the constituent atoms with sufficient energy to relax any stress but not enough to initiate melting.  It is then cooled very slowly.  During the cooling phase, the atoms are gradually &quot;frozen&quot; in place.  If the annealing is done properly, the resulting object will be without stress.  If the cooling is too rapid, there will be insufficient time for the atomic structure to relax completely, and the object will end up with excess energy and fracture too easily.<P>
In simulated annealing, score is associated with energy such that minimizing the energy means optimizing the score.  In the poker solitaire example, high score signifies low energy. The tableau in <a href="198901b9.htm">Figure 1</A> can be thought of as a collection of &quot;atoms&quot; frozen into a configuration that has too much energy.  Proceeding with this analogy, the tableau may be subjected to simulated annealing by raising its &quot;temperature&quot; until it is almost &quot;melted,&quot; then cooling it slowly until it is again &quot;frozen.&quot;  Although the connection between real and simulated annealing appears to be little more than a metaphor, this system (25 playing cards) responds in the same way as does a physical system -- and with the same results.<P>
<a href="8909b.htm#01b5_0012">More Details.</A><P>
In any physical system, the average &lt;/entry&gt; energy, &lt;E&gt;, of the constituent atoms is a function of the absolute temperature, T.  As the temperature of a system decreases, the average energy of its atoms also decreases.  A typical cooling curve is shown in <a href="198901ba.htm">Figure 2</A>.  The slope of this curve, d&lt;E&gt;/dT, is the heat capacity, C, of the system.  In regions where the curve is steep, the heat capacity is high. This usually indicates a phase change -- water into ice, for example.  Quite often, these regions also display large values of C/T.  This quantity is equal to dS/dT, the rate of change of entropy, S, with temperature, which is related to a change in the orderliness of the atoms.  Therefore, regions of a cooling curve that are steep usually imply a significant reconfiguration of the atoms (or molecules) at the corresponding temperatures.  In an annealing process where temperature is being regulated, you would have to slow down the cooling in such regions in order to allow the atoms time to rearrange themselves and to permit their average energy to decrease gradually.  Annealing works best when this is done.<P>
Simulated annealing also produces cooling curves much like that of <a href="198901bb.htm">Figure 2</A>.  In fact, the literature of simulated annealing demonstrates that these analogies run very deep and it is not at all easy to decide just where to draw the line between metaphor and methodology.<P>
<h3><a name="01b5_0008">The Connection<a name="01b5_0008"></h3><P>
The logical link between combinatorial optimization and annealing is the Boltzmann distribution, one of the basic laws of statistical mechanics.  Up to now, I've referred to the average energy of a collection of atoms.  In most large populations, there is significant variation from individual to individual.  So it is with atoms and molecules.  They are constantly moving, and their mutual collisions result in continual transfers of energy from one atom (or molecule) to another.  Much of the science of statistical mechanics involves techniques for extracting macroscopic properties of a system from the collective behavior of enormous numbers of atoms and molecules.  This information may be obtained, to a large extent, by determining how energy is partitioned among the atoms and molecules making up the sample.<P>
At any temperature, there are generally more atoms at lower energies than at higher energies.  The Boltzmann distribution, (see <a href="8909b.htm#01b5_0009">Example 1</A>, equation 1) describes the relative number of atoms (or molecules) populating any two energy states, E<sub>hi</sub> &gt; E<sub>lo</sub>, at some temperature, T, where N<sub>x</sub> is the number of atoms with energy E<sub>x</sub>, T is the absolute temperature (degrees Kelvin), and k is Boltzmann's constant.  When equation 1 is adapted to the problem of combinatorial optimization, the constant is ignored, energy is equated to score (cost), and the left-hand side of equation 1 is interpreted as a probability.  Simulated annealing uses such probabilities to direct a stochastic search of the configuration space by employing equation 2, <a href="8909b.htm#01b5_0009">Example 1</A> where S<sub>x</sub> is a score and T is a scaling factor.<P>
<h4><a name="01b5_0009"><a name="01b5_0009"><B>Example 1:</B> The Boltzmann distribution in chemistry and computer science</h4><P>
<pre>
  Equation 1: N <sub>hi</sub>/N <sub>lo</sub> = exp ((E <sub>lo</sub>-E <sub>hi</sub>)/kT)
 Equation 2: Prob (accept worse score) = exp ((S <sub>lo</sub>-S <sub>hi</sub>)/T)</pre><P>
<P>
In other words, you construct a new configuration at random and determine its score.  If this score is at least as good as that of the current configuration, then the old configuration is forgotten and the new configuration becomes the current configuration, as in the greedy algorithm.  If the new score is worse (here, lower), however, then equation 2 is used to generate the probability of accepting the new configuration anyhow.  A uniform random number in the interval (0,1) is then generated, and if it is less than the probability computed with equation 2, the new configuration is made the current configuration.  The net effect is to allow the system to extricate itself from local optima (that is, to let the goat climb uphill sometimes).<P>
As equation 2 suggests, choosing a worse configuration is a function of temperature.  The higher the temperature, the higher the &quot;energy&quot; of the system.  The higher the energy of the system, the more readily it will do the work of moving in an unfavorable direction -- just like real atoms and molecules.  As the temperature decreases, however, any given expenditure of energy becomes less likely.  Consequently, simulated annealing automatically adapts to the magnitude of the features of a good configuration.  The most profitable features are found first and the smaller, more subtle, features later.  Starting with the tableau in <a href="198901bc.htm">Figure 1</A>, simulated annealing first finds the four kings and four aces.  If the temperature is very high, these features may be forgotten from time to time, but as the temperature decreases, eventually they are frozen into every acceptable tableau.  As the temperature continues to fall, hands of lower and lower scores are successively frozen until, finally, the entire tableau is frozen.  Simulated annealing is terminated at this point.<P>
It is clear that the annealing schedule -- the program for reducing the temperature -- is critical; a large drop in temperature at the wrong time may freeze in undesirable features. (Ideally, all reconfigurations should be reversible.) The annealing schedule answers the following four questions:<P>
<ol>1.     What should be the value of the starting temperature?</ol><P>
<ol>2.     When should the temperature be changed?</ol><P>
<ol>3.     How should the temperature be changed?</ol><P>
<ol>4.     When should the search be stopped?</ol><P>
A quick-and-dirty procedure is to pick a starting temperature high enough so that virtually all scores are deemed acceptable, hold that and each successive temperature for (100*SIZE) reconfigurations or (10*SIZE) successful reconfigurations, whichever comes first, then decrease the temperature by a constant factor -- for example, T(new) = 0.9*T(old) -- stopping when T reaches some very low value (say, 0.1).  Such a schedule is often employed for an exploratory run on a new problem in order to determine the shape of the cooling curve.  Given the cooling curve, you can then create a proper annealing schedule by arranging for the temperature to decrease most slowly where the curve is steepest.<P>
<h3><a name="01b5_000a">Implementation Details<a name="01b5_000a"></h3><P>
The ANNEAL.C program (see <a href="8909b.htm#01b5_0016">Listing One</A>) addresses both the poker solitaire problem and computes the average and standard deviation of the scores accepted at any temperature.  These statistics help in answering the questions posed above.<P>
To choose a starting temperature, begin by picking one that seems high relative to the scores expected and run the program for that temperature only.  There should be very few reconfigurations rejected.  After equilibrium is reached at this temperature (see below), statistics will be output, one of which is SIGMA, the standard deviation of the acceptable scores.  As the temperature approaches infinity, SIGMA approaches SIGMA(inf), the standard deviation of a large set of random configurations.  Set the starting temperature equal to 20*SIGMA(inf).<P>
There is no point in trying further reconfigurations at a given temperature once a system has reached thermal equilibrium.  (The method used here for recognizing equilibrium is adapted from a procedure published by Huang, Romeo, and Sangiovanni-Vincentelli.)<P>
ANNEAL.C keeps track of the number of reconfigurations accepted (nsuccesses) and rejected (nfailures) at a given temperature as well as the number of acceptable scores less than or more than SIGMA/2 from the average acceptable score (incount and outcount, respectively).  The code in <a href="8909b.htm#01b5_0018">Listing Two</A> is then used to decide whether or not equilibrium has been reached.  (Uppercase variables are parameters.)<P>
Once equilibrium has been established, the temperature is decreased, provided that the current configuration has a score no worse than SIGMA/2 from the average score.  The temperature is not changed until this is true.  The idea is to avoid transmitting a poor outlier to a new, lower temperature.  As shown, there is no explanation for delaying the transition to a lower temperature.<P>
The simplest and most flexible method for computing a new temperature is to use a table, matched to the cooling curve, listing the desired sequence of temperature ratios, T(new)/T(old), and the temperatures at which they take effect.  Typically, these ratios fall in the range (0.5, 1.0).  ANNEAL.C permits up to ten values for these ratios in addition to the initial value.  <a href="8909b.htm#01b5_000b">Table 2</A> gives the actual ratios used in this example.&lt;/entry&gt;<P>
<h4><a name="01b5_000b"><a name="01b5_000b"><B>Table 2:</B> Temperature ratios</h4><P>
<pre>
  Temperature       t_ratio
   Less Than
  -------------------------

       --             0.7
      360             0.8
      215             0.7
       85             0.8
       60             0.9
       30             0.95
       15             0.9
        7             0.8
        3             0.7
        0             0.7</pre><P>
<P>
The configuration is considered frozen if, at equilibrium, the largest single change in score observed at the current temperature is equal to the difference between the best and worst scores at this temperature.  This is taken to indicate that all accessible scores are of comparable value and there is no further need for simulated annealing.  In ANNEAL.C, this test is carried out only after the temperature reaches a preset limit, t_low.  As a failsafe, another parameter, t_min, is stipulated as the temperature at which the configuration is always assumed to be frozen.  Once the configuration is frozen, it is &quot;quenched&quot; by setting the temperature equal to zero (greedy algorithm).<P>
In the interest of expediency, the best configuration found is always remembered separately from the current configuration.  Ideally, the final configuration should be the best.  This is often not the case, however.  At the end of the program, this best-found configuration is also quenched.<P>
<h3><a name="01b5_000c">Giant Steps and Baby Steps<a name="01b5_000c"></h3><P>
Although a proper annealing schedule is crucial to the success of simulated annealing, there is another consideration that is nearly as important --namely, the manner in which you make a random change to the current configuration.  This is true for simulated annealing and, to a lesser extent, for the greedy algorithm.  To find a global optimum, any search technique must be able to access the entire configuration space.  To do this effectively requires both &quot;giant steps&quot; and &quot;baby steps,&quot; the former for moving quickly to a distant part of the space and the latter for fine-tuning.<P>
In this example, baby steps are easy -- just interchange two cards.  This is the smallest reconfiguration possible.  Finding good giant steps is much more difficult.  Of course, you could simply execute several baby steps at once but experience shows that this strategy yields poor results.  One reason is that, in making a giant step, it is essential to retain as much of the current score as possible.  At moderate to low temperatures, any arbitrary giant step would almost certainly cause a substantial worsening of the score and the new configuration would simply be rejected.  All rejected moves are wasted and an efficient algorithm must try to keep such moves to a minimum.<P>
In ANNEAL.C, a giant step consists of interchanging 2 of the 12 hands of the tableau, selected at random from a uniform distribution.  A baby step, on the other hand, is implemented using a &quot;rotation.&quot;  A random integer in the range [2,5] is chosen from an exponential distribution (see <a href="8909b.htm#01b5_000d"> Table 3</A>).  This number of cards is then selected from the tableau using a uniform distribution.  The first card selected is temporarily set aside and the resulting hole filled with card number 2, and so on.  The last hole is filled with card number 1.  The ratio of giant steps to baby steps is a parameter, exg_cutoff, here set equal to 0.2.  Using only giant steps or baby steps generally gives poor performance.&lt;/entry&gt;<P>
<h4><a name="01b5_000d"><a name="01b5_000d"><B>Table 3:</B> Rotation distribution</h4><P>
<pre>
    # of Cards      Probability
    to Rotate
  -----------------------------

        2             0.33333
        3             0.27018
        4             0.21899
        5             0.17750</pre><P>
<P>
<h3><a name="01b5_000e">Experimental Results<a name="01b5_000e"></h3><P>
Simulated annealing and the greedy algorithm are both stochastic techniques.  Therefore, they do not give the same results every time.  The proper way to evaluate a stochastic technique is to apply it several times and determine its average behavior (actually, its behavior distribution).  One of the reasons such a small example was chosen for this article was precisely to allow such a test to be done in a reasonable amount of time.<P>
The simulated annealing algorithm was carried out 30 times, starting with the tableau in <a href="198901bd.htm">Figure 1</A> each time, using a random-number generator with a period much longer than that required by the experiment.  The greedy algorithm was then applied to the same tableau for the same amount of CPU time.  Apart from the rule for accepting or rejecting a new configuration, the two programs are essentially identical.  In particular, all the relevant parameter values are the same (see A.DAT, <a href="8909b.htm#01b5_001a"> Listing Three</A>).  The best result from either technique is a score of 4516 (see <a href="198901be.htm">Figure 3</A>).  This apparent optimum, found once by the greedy algorithm and twice by simulated annealing, is degenerate (that is, there are several tableaux with this score, which are not symmetry-related).  The distribution of results for simulated annealing is shown in <a href="198901bf.htm">Figure 4</A> and that for the greedy algorithm in <a href="198901c0.htm">Figure 5</A>.<P>
The number of iterations used to generate <a href="198901c1.htm">Figure 4</A> and <a href="198901c2.htm">Figure 5</A> should be enough to give an approximate indication of the average performance of the two techniques.  No serious attempt was made to find the combination of parameters that would optimize the simulated annealing results because this would have constituted a bias against the greedy algorithm and such a combination would have applied too specifically to this particular initial tableau.  The parameter values in A.DAT appear to be adequate for the poker solitaire problem in general although the annealing schedule will have to be altered when the cards are changed, especially if the new initial tableau can produce a straight flush (see accompanying box).  For other combinatorial optimization problems, both the parameter values and the annealing schedule will have to be changed.  The big questions, of course, are, &quot;Does simulated annealing work?&quot; and &quot;Is it worth the effort?&quot;  Taken together, the results shown in <a href="198901c3.htm">Figure 4</A>  and <a href="198901c4.htm">Figure 5</A> suggest that simulated annealing is definitely worth the effort.  Although you could argue that, given equal amounts of computation time, both techniques find what appears to be the global optimum, this would be overly simplistic.  For stochastic techniques, the important criterion is their average behavior.&lt;/entry&gt;<P>
<a href="8909b.htm#01b5_0014">More Details.</A><P>
For this example, the probability that any given iteration of the greedy algorithm yields a score greater than or equal to the average simulated annealing result is 6/1583.  Thus, 183 iterations of the greedy algorithm afford a 50 percent chance of doing at least as well as simulated annealing (607 iterations for a 90 percent chance).  The greedy algorithm, however, converges only 53 times faster in this example than does simulated annealing.  Clearly, there is a higher payoff with simulated annealing.<P>
<h3><a name="01b5_000f">Final Thoughts<a name="01b5_000f"></h3><P>
Although I've compared simulated annealing to the well-known greedy algorithm, it would be incorrect to suggest that the latter is the only alternative.  Recently, neural networks and various genetic algorithms have been applied to combinatorial optimization problems with some success.  If the problems are small enough, then classical integer programming techniques (that is, branch-and-bound) may also prove fruitful.  Moreover, when evaluating the material presented here, there are several points to bear in mind.  First, not every application of simulated annealing will exhibit better performance than a greedy algorithm to the extent observed in this case, so you should not extrapolate too much from this single example.<P>
Another important consideration is that simulated annealing is very time-consuming, and almost any serious application of this sort is best written in assembly language.  The program ANNEAL.C was coded in C solely in the interests of pedagogy and portability.<P>
Finally, both algorithms described in this article are stochastic in nature.  Even though the tableau in <a href="198901c5.htm">Figure 1</A> was subjected to hundreds of simulated annealing runs, there is still no guarantee that the optimum found is, in fact, the global optimum.  It's possible that there exists a tableau with a score greater than 4516 but that the path through the configuration space leading to it is so narrow that even the millions of reconfigurations carried out are insufficient to find it.<P>
In this regard, it's interesting that all the tableaus found having scores of 4516 contained only 11 scoring hands, not 12.  This being the case, there may be &quot;room&quot; for an even higher score.  Better yet, what if a 13th hand were defined, consisting of the 4 corners plus the center card.  Would there be any point in adding the extra degree of freedom?  This intriguing thought is left as an exercise for DDJ readers.<P>
<h3><a name="01b5_0010">Bibliography<a name="01b5_0010"></h3><P>
Huang, M. D.; Romeo, F.; and Sangiovanni-Vincentelli, S. &quot;An Efficient Cooling Schedule for Simulated Annealing.&quot;  Proc. Int. Conf. Computer-Aided Design (ICCAD86) (1986): 381 - 384.<P>
Kirkpatrick, S.; Gelatt, C. D. Jr.; and Vecchi, M. P. &quot;Optimization by Simulated Annealing.&quot;  Science, vol. 220, no. 4598 (1983): 671 - 680.<P>
Metropolis, N.; Rosenbluth, A;, Rosenbluth, M;, Teller, A;, and Teller, E.  &quot;Equations of State Calculations by Fast Computing Machines.&quot; J. Chemical Physics, vol. 21 (1953): 1087 - 1091.<P>
Nash, L.K. Elements of Statistical Thermodynamics.  Reading, Mass.: Addison-Wesley, 1968.<P>
Press, W. H.; Flannery, B. P.; Teukolsky, S. A.; and Vetterling, W. T.  Numerical Recipes, The Art of Scientific Computing.  New York: Cambridge University Press, 1986: 326 - 334.<P>
Sechen, C. and Sangiovanni-Vincentelli, A. &quot;TimberWolf 3.2: A New Standard Cell Placement and Global Routing Package.&quot; Proc. 23rd Design Automation Conf. (1986): 432 - 439.<P>
<h3><a name="01b5_0011">Availability<a name="01b5_0011"></h3><P>
All source code for articles in this issue is available on a single disk.  To order, send $14.95 (Calif. residents add sales tax) to Dr. Dobb's Journal, 501 Galveston Dr., Redwood City, CA 94063, or call 800-356-2002 (from inside Calif.) or 800-533-4372 (from outside Calif.).  Please specify the issue number and format (MS-DOS, Macintosh, Kaypro).&lt;/entry&gt;<P>
<h3><a name="01b5_0012"><a name="01b5_0012"><a name="01b5_0013">ANNEAL.C Data Structures, Functions, and Variables<a name="01b5_0013"></h3><P>
The playing cards are represented as 2-byte integers.  The card values, 2 to Ace (high), are coded as the numbers 2 to 14 and the suits {spades, hearts, diamonds, clubs} are coded as {2048, 1024, 512, 256}, respectively.  The tableau is intrinsically a two-dimensional array but is implemented as a one-dimensional array to avoid the computational burden of double indexing (see HAND[12][5] below).  ANNEAL.C ignores the symmetry of the tableau with respect to the scoring function because it is, computationally, more trouble than it is worth.<P>
rand1( ) -- takes a 31-bit integer, SEED, and returns another one.  This generator yields a full-cycle sequence without repeating any numbers.<P>
uni(z) -- returns a double-precision float in the range (O,z) via rand1( ).<P>
initialize( ) -- reads in the starting data from A.DAT and sets up the data structures, and so on.<P>
init( ) -- resets a number of global counters and variables, chiefly to aid in the collection of the statistics necessary to detect equilibrium.<P>
get_new_temperature( ) --computes a temperature ratio, if necessary, and a new temperature (see Table 2).<P>
check_equilibrium( ) -- uses the code given in the article to detect the equilibrium point.<P>
update( ) -- computes those statistics, which need not be found until equilibrium has been achieved.  (see SCALE).<P>
selectwr( ) -- is a general routine to perform N selections without replacement.<P>
reconfigure(direction) -- makes a new configuration, or restores the tableau to its previous configuration if the last move was rejected.  (Typically, more than 90 percent of the reconfigurations are rejected.)  This routine uses giant steps or baby steps.<P>
get_score(crds) -- is called by evaluate1( ) and returns the score of a single hand as defined in HAND[12][5].<P>
evaluate1( ) -- passes each hand, one by one, to get_score(crds) and tallies up the total SCOR (which becomes the current SCORE, if the reconfiguration is accepted).  Along with rand1( ) and reconfigure( ), the functions evaluate1( ) and get_score( ) are all written in MC68020 assembly language in the working code.  This code runs at a speed of approximately 2035 attempted reconfigurations/sec. on an AMIGA 1000 equipped with a 68020/68881 chip set, plus 32-bit RAM (a standard Amiga, executing ANNEAL.C, does 70/sec.), and finishes an average simulated annealing run in less than 3 minutes with the results as shown in Figure 4.  Without this sort of speed, the long series of experiments needed to obtain good parameter values, and to compare with the greedy algorithm, would have required more patience than this author has ever possessed.<P>
decide( ) -- answers the question &quot;To accept or not to accept?&quot; and uses the formula shown Example 1, equation 2.  It also accumulates statistics like INCOUNT and OUTCOUNT that must be computed at every move.<P>
report( ) -- produces the output statistics and the final tableaux.<P>
try_new_temperature( ) -- is a calling function that uses a newly computed temperature.  It also checks that the tableau passed on to a new temperature is not a low outlier.<P>
main( ) -- q.v.  HAND[12][5] -- stipulates the 12 hands (5 cards each) in the TABLEAU and describes the various hands in terms of the appropriate indices of TABLEAU.<P>
PARTITION[6], OVERLAP[66], HEX [12], CINDEX[25] -- are used to generate a new configuration.  PARTITION implements Table 3 in long integers (pre-multiplied by MODULUS).  OVERLAP is a triangular array giving the index, in TABLEAU, of the intersection of two HANDs (-1 if no overlap).  HINDEX and CINDEX are arrays used to perform selection without replacement and to remember those selections should the new configuration be rejected.<P>
SCORES[18] -- is an implementation of Table 1.  After evaluate1( ) has determined the index to SCORES, SCOR is assigned the corresponding value.<P>
TEMPERATURE, T_LOW, T_MIN --is the scaling factor.  T_LOW is the temperature below, which the tableau can be tested to see if it is FROZEN or not.  If the temperature ever goes below T_MIN, the tableau is automatically FROZEN.<P>
AVG_SCORE, SIGMA -- are the average and standard deviation of the scores of all the tableaux accepted at the current temperature.<P>
SCALE -- is a typical SCORE when the temperature is getting cold.  This variable has no function in the algorithm per se, but is incorporated so that SIGMA may be computed using single-precision arithmetic.  (This is especially important in the absence of a floating-point chip.)  By subtracting off a good score before accumulating the square-of-the-score, the number of digits to be squared is reduced.  If this is not done, then a single-precision number will lose too much precision at a time in the annealing process when the average-of-the-squares and the square-of-the-average are nearly equal.  When this happens, it is possible to get SIGMA = 0 erroneously.  This has a deleterious effect on the program.<P>
T_RATIO -- T(new)/T(old).  The initial value (here, 0.7) and 10 other values are listed in A.DAT.<P>
EXG_CUTOFF -- is the ratio Prob (giant step)/Prob(baby step).<P>
SUCC_MIN, INCOUNT_LIMIT, OUT-COUNT_LIMIT, FIRST_LIMIT, ULTIMATE_LIMIT -- are parameters used to determine the equilibrium point.<P>
-- M.M.<P>
<P>
<h3><a name="01b5_0014"><a name="01b5_0014"><a name="01b5_0015">Cellular Automata: A New Way of Simulation<a name="01b5_0015"></h3><P>
<pre>Jean F. Coppola and Dr. Francis T. Marchese</pre><P>
Jean Coppola is a master's degree student in computer science and Dr.  Francis Marchese is an associate professor in the computer science department at Pace University.  They can be reached at Pace University, 1 Pace Plaza, New York, NY 10038.<P>
In the annealing process, glass, certain metals, and alloys are heated and cooled in a controlled way to allow the atoms to arrange themselves into a stable state.  Normally, the process of annealing is simulated by means of a set of complex differential equations. Alternatively, annealing can be simulated by an intuitively simpler method known as &quot;cellular automata.&quot;<P>
Cellular automata are discrete dynamical systems in which the behavior of the system as a whole is defined in terms of a set of local rules.  The simplest and best-known cellular automata is the game of LIFE conceived by John Conway in the early 1970s.  LIFE is a computer simulation that consists of a grid of cells upon which a collection of creatures are born, live and die.  The life/death process is governed by a neighborhood rule that defines the behavior of any creature at any cell located in terms of the behavior of its neighbors.  This is a significant concept because it implies that for collective systems, no member of that collection of entities (or creatures) can exist independently of the rest.  Moreover, the rules that govern the system as a whole are only the rules of the local neighborhoods.  Hence, for example, in a two-dimensional life game consisting of a 100 x 150 grid, the rules are only defined for each local 3 x 3 matrix!  Even though this is the case, the complexity of the life process produced can be quite profound.<P>
As a result, cellular automata has been applied in areas such as physics, chemistry, and computer science.  For example, particle dynamics, galactic evolution, molecular kinetics, or parallel distributed processing are all fields where local laws dictate global behavior.  At Pace University, we've applied cellular automata to the real-time study of the dynamics of crystal growth.  Because of the large number of local interactions that must be accommodated in these simulations, even a mainframe cannot provide the computing power required for real-time visualization.  However, assisting in the simulations, is an IBM PC-compatible, high-performance hardware option called CAM-6 (Cellular Automata Machine) that runs under MS-DOS.  CAM-6 is a special-purpose coprocessor designed specifically for cellular automata simulations by researchers at the MIT Laboratory for computer science.  Its pipelined architecture allows software to run at speeds comparable to that of a CRAY-1, therefore allowing the CAM board to update and display a 256 x 256 array of cells 1/60 of a second, thus producing real-time animation.  Each cell in CAM is represented by a pixel, and cells can assume 1 of 16 possible states signified by 16 different colors.<P>
The CAM-6 machine is programmable in a high-level language called &quot;CAM Forth,&quot; a special version of Forth-83.  Because Forth was originally developed for real-time applications and meets the demands of cellular automata by its code efficiency.<P>
We have used this combination of hardware and software to simulate crystal growth. Presently, we wish to discover the local rules which govern the growth of sodium chloride (common table salt).  This is accomplished by programming neighborhoods that work with the four major neighbors on all the planes.  The difficult part in programming &quot;rules&quot; is keeping in mind that one cannot change the state of a neighbor but only the cell currently in question.  For example, you cannot indicate if a cell has three or more neighbors at state 1, and turn all neighbors at state 0 to 1.  Therefore, programming has to be done around this constraint, which at times can be extremely difficult.  We have also simulated complex solid liquid equilibria.  This involved programming minor neighborhoods which allowed states to be compared from a second CAM machine that was programmed as a random noise generator.<P>
By watching and studying these simulations, we hope to gain insight into the synthesis of crystals and fundamental patterns of molecular growth.  The models of cellular automata could one day be a major breakthrough in the understanding of nature's rules, which in turn could affect every aspect of life.<P>
<pre></pre><P>
<P>
--J.C., F.T.M.<P>


_SIMULATED ANNEALING_
by Michael P. McLaughlin

<a name="01b5_0016"><a name="01b5_0016">
<a name="01b5_0017"></pre><B>[LISTING ONE]</B><pre><a name="01b5_0017">

/* ANNEAL.C -- Author: Dr. Michael P. McLaughlin
*/
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;

#define ABS(x) ((x&lt;0)?(-(x)):(x))
#define BOOLEAN int
#define TRUE 1
#define FALSE 0
#define FORWARD 1
#define BACK 0

struct cardtype {
   char card[3];
   int code;
   } cards[25];
float ratios[10][2];
int tableau[25],best_tableau[25];
float temperature,best_temperature,t_low,t_min,t_ratio;
long seed,score,best_score,tot_successes,tot_failures,scor,exg_cutoff,
     report_time,report_interval,modulus = 2147483399,step = 1;
int next;
BOOLEAN equilibrium,frozen = FALSE,quench=FALSE,final=FALSE;

/* variables needed to assess equilibrium */
float totscore,totscore2,avg_score,sigma,half_sigma,score_limit;
long bscore,wscore,max_change,nsuccesses,nfailures,scale,
     incount,outcount;
int incount_limit,outcount_limit,succ_min,first_limit,ultimate_limit;

/* poker hands in tableau */
int hand[12][5] = {0,1,2,3,4,      /* rows */
                   5,6,7,8,9,
                   10,11,12,13,14,
                   15,16,17,18,19,
                   20,21,22,23,24,
                   0,5,10,15,20,   /* columns */
                   1,6,11,16,21,
                   2,7,12,17,22,
                   3,8,13,18,23,
                   4,9,14,19,24,
                   0,6,12,18,24,   /* diagonals */
                   4,8,12,16,20};
                /* 0,4,12,20,24     = corners */

long rand1()
/* Get uniform 31-bit integer -- Ref. CACM, June 1988, pg. 742 */
{
   register long k;
   k = seed/52774;
   seed = 40692*(seed-k*52774)-k*3791;
   if (seed &lt; 0)
      seed += modulus;
   return(seed);
}
double uni(z)
int z;
{
   return((double) z*rand1()/modulus);
}
void initialize()
/* Set up entire simulated annealing run. */
{
   char label[20];
   double exgc;
   register i;
   FILE *fp;
   fp = fopen(&quot;a.dat&quot;,&quot;r&quot;);
   fscanf(fp,&quot;%f %s\n&quot;,&amp;temperature,label);
   fscanf(fp,&quot;%f %s\n&quot;,&amp;t_low,label);
   fscanf(fp,&quot;%f %s\n&quot;,&amp;t_min,label);
   fscanf(fp,&quot;%f %s\n&quot;,&amp;avg_score,label);
   fscanf(fp,&quot;%ld %s\n&quot;,&amp;scale,label);
   fscanf(fp,&quot;%f %s\n&quot;,&amp;t_ratio,label);
   fscanf(fp,&quot;%f %s\n&quot;,&amp;sigma,label);
   fscanf(fp,&quot;%lf %s\n&quot;,&amp;exgc,label);
   fscanf(fp,&quot;%d %s\n&quot;,&amp;succ_min,label);
   fscanf(fp,&quot;%d %s\n&quot;,&amp;incount_limit,label);
   fscanf(fp,&quot;%d %s\n&quot;,&amp;outcount_limit,label);
   fscanf(fp,&quot;%d %s\n&quot;,&amp;first_limit,label);
   fscanf(fp,&quot;%d %s\n&quot;,&amp;ultimate_limit,label);
   fscanf(fp,&quot;%ld %s\n&quot;,&amp;report_interval,label);
   fscanf(fp,&quot;%ld %s\n&quot;,&amp;seed,label);
   half_sigma = 0.5*sigma; report_time = report_interval;
   score_limit = 20; exg_cutoff = modulus*exgc;
   for (i=0;i&lt;10;i++)
      fscanf(fp,&quot;%f %f\n&quot;,&amp;ratios[i][0],&amp;ratios[i][1]);
   for (i=0;i&lt;25;i++) {
      fscanf(fp,&quot;%d %s\n&quot;,&amp;cards[i].code,cards[i].card);
      tableau[i] = cards[i].code;
   }
   fclose(fp);
   printf(&quot;                   TOTAL     TOTAL  CURRENT AVERAGE\n&quot;);
   printf(&quot;STEP TEMPERATURE SUCCESSES FAILURES  SCORE   SCORE &quot;);
   printf(&quot; SIGMA\n\n&quot;);
}
void init()
/* set up for new temperature */
{
   nsuccesses = 0; nfailures = 0; equilibrium = FALSE; incount = 0;
   outcount = 0; bscore = 0; wscore = 100000; max_change = 0;
   totscore = 0; totscore2 = 0;
   if (temperature &lt; t_min)
      frozen = TRUE;
}
void get_new_temperature()
{
   if (temperature &lt; ratios[next][0]) {
      t_ratio = ratios[next][1];
      next++;
   }
   temperature = t_ratio*temperature;
}
void check_equilibrium()
/* Determine whether equilibrium has been reached. */
{
   if ((nsuccesses+nfailures) &gt; ultimate_limit)
      equilibrium = TRUE;
   else if (nsuccesses &gt;= succ_min) {
      if (incount &gt; incount_limit)
         equilibrium = TRUE;
      else {
         if (outcount &gt; outcount_limit) {
            if (nsuccesses &gt; first_limit)
               equilibrium = TRUE;
            else {
               incount = 0;
               outcount = 0;
            }
         }
      }
   }
}
void update()
/* Compute statistics, etc. */
{
   float ascore,s;
   if (nsuccesses &gt; 0) {
      ascore = totscore/nsuccesses;
      avg_score = ascore+scale;
      s = totscore2/nsuccesses-ascore*ascore;
      if (s &gt; 0.0) {
         sigma = sqrt(s); half_sigma = 0.5*sigma;
         score_limit = avg_score-half_sigma;
      }
   }
   if ((temperature &lt; t_low)&amp;&amp;((bscore-wscore) == max_change))
      frozen = TRUE;
}
void selectwr(array,mode,nchoices)
/* Select from array without replacement. */
int *array,mode,nchoices;
{
   int i,temp,size,index;
   size = mode==1 ? 12 : 25;
   for (i=0;i&lt;nchoices;i++) {
      index = uni(size);
      temp = array[--size];
      array[size] = array[index];
      array[index] = temp;
   }
}
void reconfigure(direction)
/* If direction is FORWARD, make a new move; if it is BACK, restore
   the tableau to its previous configuration. */
int direction;
{
   static long partition[6] = {0,0,715827799,1296031795,1766307855,
                               2147483400};
   static int hindex[12] = {0,1,2,3,4,5,6,7,8,9,10,11};
   static int cindex[25] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,
                            14,15,16,17,18,19,20,21,22,23,24};
   static int overlap[66] = {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,5,10,15,
                             20,1,6,11,16,21,-1,2,7,12,17,22,-1,-1,3,
                             8,13,18,23,-1,-1,-1,4,9,14,19,24,-1,-1,-1,
                             -1,0,6,12,18,24,0,6,12,18,24,4,8,12,16,20,
                             20,16,12,8,4,12};
   static int mode,nchoices,common,last;   /* remember changes */
   int temp,hi,lo,i,j,k;
   if (direction == FORWARD) {
      if (rand1() &lt; exg_cutoff) {   /* giant step */
         mode = 1; nchoices = 2;
         selectwr(hindex,mode,nchoices);
         hi = hindex[11]; lo = hindex[10];   /* order hand indices */
         if (hi &lt; lo) {
            hi = lo;
            lo = hindex[11];
         }
         common = overlap[hi*(hi-1)/2+lo];   /* triangular matrix */
      }
      else {   /* baby step */
         mode = 0; nchoices = 2;
         rand1();   /* How many cards to rotate? */
         while (seed &gt; partition[nchoices])
            nchoices++;
         selectwr(cindex,mode,nchoices);
         temp = tableau[cindex[24]];   /* rotate forward */
         for (i=1,j=24;i&lt;nchoices;i++,j--)
            tableau[cindex[j]] = tableau[cindex[j-1]];
         tableau[cindex[j]] = temp;
         last = j;
      }
   }
   if (mode == 1) {   /* swapping hands is symmetrical */
      register first,second,c;
      first = hindex[11]; second = hindex[10];
      k = (common&lt;0) ? 5 : 4;
      for (c=0,i=0,j=0;c&lt;k;c++,i++,j++) {
         if (hand[first][i] == common)
            i++;
         if (hand[second][j] == common)
            j++;
         temp = tableau[hand[first][i]];
         tableau[hand[first][i]] = tableau[hand[second][j]];
         tableau[hand[second][j]] = temp;
      }
   }
   else if (direction == BACK) {   /* rotation is not */
      temp = tableau[cindex[last]];
      for (i=1,j=last;i&lt;nchoices;i++,j++)
         tableau[cindex[j]] = tableau[cindex[j+1]];
      tableau[cindex[24]] = temp;
   }
}
long get_score(crds)
/* Return score of one hand. */
int *crds;
{
   static long scores[18] = {0,1,1,20,1,9,20,1760,1,9,9,
                             293,20,293,1760,108,215,27456};
   int flush,i,index = 0;
   flush = crds[0]&amp;crds[1]&amp;crds[2]&amp;crds[3]&amp;crds[4]&amp;0xff00;
   for (i=0;i&lt;5;i++)
      crds[i] = crds[i]&amp;0xff;   /* ignore suits */
   {
      register b,k,t;   /* sort cards from high to low */
      for (b=4;b&gt;0;b--)
         for (k=0;k&lt;b;k++)
            if (crds[k] &lt; crds[k+1]) {
               t = crds[k];
               crds[k] = crds[k+1];
               crds[k+1] = t;
            }
   }
   if (!flush) {   /* multiple cards ? */
      if (crds[0] == crds[1]) index += 8;
      if (crds[1] == crds[2]) index += 4;
      if (crds[2] == crds[3]) index += 2;
      if (crds[3] == crds[4]) index += 1;
   }
   if (!index) {   /* straight ? */
      if (((crds[0]-crds[4]) == 4)||((crds[0] == 14)&amp;&amp;(crds[1] == 5)))
         index = 15;
      if (flush)
         index = (index == 15) ? 17 : 16;
   }
   return(scores[index]);
}
long evaluate1()
/* Return total score of tableau (no corners). */
{
   int temp[5],h,c;
   long scr = 0;
   for (h=0;h&lt;12;h++) {   /* h&lt;13 for corners */
      for (c=0;c&lt;5;c++)
         temp[c] = tableau[hand[h][c]];
      scr += get_score(temp);
   }
   return(scr);
}
void decide()
/* Either accept new configuration or restore old configuration */
{
   float pdt1,pdt2,sscor;
   long s;
   BOOLEAN acceptable = FALSE;
   scor = evaluate1();
   if (scor &gt;= score) {
      if (scor &gt; best_score) {
         register i;
         best_score = scor;
         best_temperature = temperature;
         for (i=0;i&lt;25;i++)
            best_tableau[i] = tableau[i];
      }
      acceptable = TRUE;
   }
   else if (temperature &gt; 0.0) {   /* uphill movement? */
      if (uni(1) &lt; exp((scor-score)/temperature))   /* Equation 2 */
         acceptable = TRUE;
   }
   if (acceptable) {   /* statistics, etc. */
      s = ABS(score-scor);
      if (s &gt; max_change)
         max_change = s;
      score = scor;
      sscor = scor-scale;   /* to aid precision of sigma */
      totscore += sscor;
      totscore2 += sscor*sscor;
      nsuccesses++;
      if (ABS(avg_score-score) &lt; half_sigma)
         incount++;
      else
         outcount++;
      if (score &gt; bscore)   /* maximization */
         bscore = score;
      else if (score &lt; wscore)
         wscore = score;
   }
   else {   /* unacceptable */
      reconfigure(BACK);
      nfailures++;
   }
}
void report()
{
   tot_successes += nsuccesses; tot_failures += nfailures;
   printf(&quot;%3ld %10.1f %9ld %9ld %7ld %7.0f  %5.1f\n&quot;,step,temperature,
          tot_successes,tot_failures,score,avg_score,sigma);
   report_time += report_interval;
   if (frozen) {
      int temp[25],k,kk;
      register i,j;
      BOOLEAN ok;
      if (final)
         printf(&quot;\nFINAL -- &quot;);
      else if (quench)
         printf(&quot;\nQUENCH -- &quot;);
      else
         printf(&quot;\nFROZEN -- &quot;);
      printf(&quot;BEST SCORE = %5ld  BEST TEMPERATURE = %5.1f\n\n&quot;,
              best_score,best_temperature);
      for (i=0;i&lt;25;i++) {
         k = best_tableau[i];
         j = 0;
         ok = FALSE;
         while (!ok) {
            if (cards[j].code == k) {
               temp[i] = j;
               ok = TRUE;
            }
            else j++;
         }
      }
      for (i=0;i&lt;25;i+=5) {
         for (j=i;j&lt;(i+5);j++) {
            k = 4-strlen(cards[temp[j]].card);
            for (kk=0;kk&lt;k;kk++) printf(&quot; &quot;);
            printf(&quot;%s&quot;,cards[temp[j]].card);
         }
         printf(&quot;\n&quot;);
      }
      printf(&quot;\n&quot;);
   }
}
void try_new_temperature()
{
   init();
   while (!equilibrium) {
      reconfigure(FORWARD);
      decide();
      check_equilibrium();
   }
   update();
   if (!quench) {   /* ratchet */
      while ((float) score &lt; score_limit) {   /* maximization */
         reconfigure(FORWARD);
         decide();
      }
   }
}
main()
{
   initialize();
   while (!frozen) {
      try_new_temperature();
      update();
      if ((step == report_time)||(frozen))
         report();
      step++;
      if (temperature &gt; 0.0)
         get_new_temperature();
   }
/* Quench frozen configuration. */
   temperature = 0;
   quench = TRUE;
   try_new_temperature();
   update();
   report();
   step++;
/* Quench best configuration (rarely useful). */
   {
      register i;
      final = TRUE;
      for (i=0;i&lt;25;i++)
         tableau[i] = best_tableau[i];
   }
   try_new_temperature();
   update();
   report();
   printf(&quot;SEED = %ld\n&quot;,seed);   /* seed of next run */
}






<a name="01b5_0018"><a name="01b5_0018">
<a name="01b5_0019"></pre><B>[LISTING TWO]</B><pre><a name="01b5_0019">

     if ((nsuccesses+nfailures) &gt; ULTIMATE_LIMIT)
       equilibrium = true;
     else if (nsuccesses &gt;= SUCC_MIN) {
       if (incount &gt; INCOUNT_LIMIT)
        equilibrium = true;
       else {
        if (outcount &gt; OUTCOUNT_LIMIT) {
         if (nsuccesses &gt; FIRST_LIMIT)
          equilibrium = true;
         else {
          incount = 0;
          outcount = 0;
         }
        }
       }
     }





<a name="01b5_001a"><a name="01b5_001a">
<a name="01b5_001b"></pre><B>[LISTING THREE]</B><pre><a name="01b5_001b">

2150 temperature
1.5 t_low
0.1 t_min
40 avg_score
4400 scale
0.7 t_ratio
150 sigma
0.2 exg_cutoff
200 succ_min
250 incount_limit
400 outcount_limit
2700 first_limit
10000 ultimate_limit
1 report_interval
1234567890 seed
360 0.8
215 0.7
85 0.8
60 0.9
30 0.95
15 0.9
7 0.8
3 0.7
0 0.7
0 0.7
1032 8H
2061 KS
270 AC
526 AD
522 10D
1029 5H
265 9C
1035 JH
1037 KH
525 KD
515 3D
263 7C
2058 10S
2062 AS
518 6D
1036 QH
267 JC
259 3C
2053 5S
269 KC
520 8D
1028 4H
1038 AH
519 7D
1026 2H



[EXAMPLE 1]

Equation 1:  N /su/hi//N /su/lo/ = exp((E lo-E hi)/kT)

Equation 2:  Prob(accept worse score) = exp((S /su/lo/ -S /su/hi/)/T)


Example 1: Equations that describe the Boltzman distribution





<P>
<P>
</pre><HR><P>Copyright &copy; 1989, <I>Dr. Dobb's Journal</I></P></BODY></HTML>
