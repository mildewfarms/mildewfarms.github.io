<HTML>
<META NAME="year" CONTENT="1989">
<HEAD>

<TITLE>SP 89: GUEST EDITORIAL</TITLE></HEAD>
<body bgcolor="FFFFFF">
<h1>GUEST EDITORIAL<a name="029c_0003"><a name="029c_0003"></h1><P>
<h2><a name="029c_0001"><a name="029c_0000">Yesterday, Today, and Tomorrow</h2><P>
<h3>Scott Robert Ladd</h3><P>
<a name="029c_0002"><a name="029c_0000">It has been an honor and a privilege to be involved in the production of this issue of Dr. Dobb's Journal.  DDJ has always been a resource for C programmers, and it is only fitting that it produces an issue devoted to the future of C.  I think you'll find that the variety of articles in this issue reflect the myriad uses of C you'll find today and tomorrow.<P>
C was born in the 1970s, matured during the 1980s, and is headed for an even better future in the 1990s.  Going from an obscure systems programming language at AT&amp;T, C has grown to be a premiere language for the development of sophisticated applications on nearly every hardware platform.  C is not a static language; the original Kernighan and Ritchie C has evolved into ANSI C and C++.  The world of programming changes so often that a language cannot remain unchanged and still be viable over the long term.<P>
Where to go from here?  C++ is an obvious answer; while several other object-oriented variants of C exist (that is, Objective C, C_talk), none of them have garnered the following C++ has.  C++ does have faults and detractors -- but what language doesn't?  C++ offers what C programmers have always liked: Freedom of expression.  An idea central to both C and C++ is that the programmer knows how to program, and the compiler should not stand in the way.  As with any other form of creativity, programming is best done when the tools being used have few limitations.<P>
The eventual success of C++ depends on many things.  Probably C++'s biggest fault is the lack of a standard object class library.  Smalltalk and other &quot;pure&quot; object-oriented languages provide a cornucopia of classes for everything from linked lists to windowing and graphics. These built-in classes provide more than program building blocks: They show a programmer how object-oriented programming should be done.  Historically, languages without standard libraries (such as Modula-2) have suffered in the marketplace.  If AT&amp;T does not address this need, then those of us who use C++ must work together to build publicly-available standard libraries.<P>
In spite of C++, C will continue to be a popular programming language.  Once the ANSI standard is finalized, new directions for C include the development of standards for mathematical extensions and international markets.  An ANSI subcommittee is working on the former, and an ISO committee is developing the latter.  As the requirements of programmers change, so will C.<P>
Another change we can expect will occur in the programming environment.  Just as the days of card punches and batch compiles have passed, so too will our current system of compile/edit/debug be replaced.  Working with C++ has shown that the current programming environment is too limited for sophisticated software development.  New tools are needed to help us understand, design, document, and debug our programs.<P>
You can already see the germination of some of these capabilities, with the introduction of integrated environments and sophisticated debuggers.  However, these tools are often slow, cumbersome, and lack the &quot;power&quot; expert programmers want.  Also, the best programmers tend to be very particular about the way their tools work, particularly when it comes to editors.<P>
One concept that interests me is that of development environments where individual development applications are linked together via intelligent interfaces.  We talk about integrating data bases, communications, and word processing for users, by using operating environments that allow interapplication communication.  The same thing can be done with a program development environment, where CASE tools, editors, compilers, and debuggers can be linked together to form an integrated environment.  It would be even better if programmers could mix and choose components of the system, integrating their favorite tools to make a customized environment.<P>
No matter what the future of programming holds, you can rest assured that C and its derivatives will continue to be a part of that future.  And DDJ will be there, every step of the way.<P>
<P>
<P>
</pre><HR><P>Copyright &copy; 1989, <I>Dr. Dobb's Journal</I></P></BODY></HTML>
