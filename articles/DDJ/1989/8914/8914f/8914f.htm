<HTML>
<META NAME="year" CONTENT="1989">
<HEAD>

<TITLE>SP 89: AUTOMATIC MODULE CONTROL REVISITED</TITLE></HEAD>
<body bgcolor="FFFFFF">
<h1>AUTOMATIC MODULE CONTROL REVISITED<a name="02a9_0003"><a name="02a9_0003"></h1><P>
<h2><a name="02a9_0001"><a name="02a9_0000">Adding power to an already powerful documenting utility</h2><P>
 This article contains the following listings: POOLE_CP.ARC<P>
<h3>Ron Winter</h3><P>
<p><i><a name="02a9_0002"><a name="02a9_0000">Ron is a faithful Dr. Dobb's subscriber, and has been a microcomputer aficionado for many years.  He is a software engineer at SPEX in Edison, N.J.  You can contact him at P.O. Box 4143, Metuchen, N.J. 08840.</i></p><hr><P>
This article is a follow up to Stewart Nutter's article &quot;An Aid To Documenting C,&quot; DDJ, August 1988.  In that article, Stewart presented a printer program he called cp (for C printer), which allowed programmers to document C source-code modules.  When I first saw the program, I realized that it addressed my needs in a general way, but as presented the program was just not sufficient.<P>
After entering the source as printed (and adding a few missing ++s and fixing a few other minor typos) I got cp to run.  Two things struck me immediately: Lowercase ls as variables are amazingly similar to 1s in small type, and the program crashed when I gave my target program as input!  By this time my curiosity was sufficiently aroused, so I decided I had better understand the program before changing it too much, or it might never work.<P>
What appeared to be a simple task became instead a small research project into the C language.  It is amazing how much C code you can write without really understanding why C is the way it is.  The process of correcting the code so that it would follow the rules of a C compiler and linker helped me understand the role of functions, and brought me a deeper understanding of computer languages and an appreciation for what they do.  Nevertheless, you usually only go far enough to get the job done.  In the case of cp, I realized that if I went much further, the program would start to become a compiler!  That's a thought I try not to consider too seriously.<P>
<h3><a name="02a9_0004">Rewriting Without Rewriting<a name="02a9_0004"></h3><P>
When I began rewriting Stewart's original program, all of my prejudices and preferences in style came to bear upon the code in a fit of global search and replacements.  My own C style is &quot;pascalean&quot; in indenting and braces, with highly descriptive functions and variable names, especially globals.<P>
Every function in the original program is in my own version of cp, but the names have been changed to make them a little clearer (at least to me).  Some new functions have been added. Function declarations are included, and two new files were added: cpbuild.c and cpinput.c. cpbuild.c contains all the code needed by the original function xref( ).  The second file, cpinput c, handles the prompting and parameter parsing that the program does at start-up.<P>
My cp program consists of the following files: CPHEADER.H, the header file (<a href="8914f.htm#02a9_000d">Listing One</A>, page 73); CP.C, the main source file (<a href="8914f.htm#02a9_000f">Listing Two</A>, page 73); CPINPUT.C, the command-line parser (<a href="8914f.htm#02a9_0011">Listing Three</A> , page 78); CP BUILD.C, the front-end section of the program (<a href="8914f.htm#02a9_0013">Listing Four</A>, page 79); CPFUNCTS.C, the back-end section (<a href="8914f.htm#02a9_0015">Listing Five</A>, page 83); CP, the make file (<a href="8914f.htm#02a9_0017">Listing Six</A>, page 85); and CPLIST, the input file to execute the program on itself (<a href="8914f.htm#02a9_0019">Listing Seven</A>, page 85).<P>
The make file now uses the /packcode directive in the linker command.  This allows me to make all the functions &quot;near,&quot; even in different files in large model programs, as long as the code size is less than a segment.  The effect is to have the speed and size of a small model program with respect to the code.  The arguments to the program are much the same as they were in the original program.  Some new parameters are: n for normal (as opposed to IBM) character graphics, f for size of called function array, l for library call statistics, q for quiet mode, d to show declarations and definitions on the console as they are found, h to show more help than is shown when cp is executed with no arguments, and x to show some technical information.  The program now can take uppercase or lowercase parameters with either the &quot;-&quot; or &quot;/&quot; switch character.<P>
<a href="198902ab.htm">Figure 1</A> shows a sample printout of the the cp program; <a href="8914f.htm#02a9_0006">Figure 2</A> shows a portion of a typical report the program produces.<P>
<h3><a name="02a9_0005">Repairing the Algorithms<a name="02a9_0005"></h3><P>
A minor deficiency of the original code is that it incorrectly assumes that a function definition ends with a new line.  A more correct algorithm scans forward from possible identifiers; if an open parenthesis is found, it then scans for the matching close parenthesis and checks the next non-white character.  As in &quot;Find That Function!&quot; by Marvin Hymowech (also in August 1988), the key is to note that if this next character is a comma or semicolon, a declaration or prototype has been found.  In either ANSI style or standard C, definitions have either an open brace or variable declaration(s) following the close parenthesis.<P>
I had to overcome two major deficiencies in the original code.  The first was the lack of treatment of static functions.  The second was the way leading comments were stored.  In the original code, the strdup( ) was not checked for failure at the end of the function xref( ), so it crashed on my large program.  I made a minor change to the program that dressed up the form of the tree-structured output.  The connecting lines did not stop when there was nothing underneath to connect them to.  Finally, I added a toggle for IBM character graphics to draw the tree in fine style.<P>
I discovered that you must really understand what constitutes a correct C program first before you can parse it for function definitions and function calls.  The scanner, called getnext( ) in the original, incorrectly scanned quoted (&quot;) strings and pound sign (#) statements.  They both allow the line continuation form of backslash followed immediately by a new line.  Also, comments are considered white space in a #statement construction.  The function is now called get_to_next_possible_token( ), and it handles these situations correctly.<P>
<h4><a name="02a9_0006"><a name="02a9_0006"><B>Figure 2:</B> Sample report from the cp program</h4><P>
<pre>
  Function Index:
  function                                     in file        references
  ______________________________________________________________________

  static allocate_arrays                       cp.c           1
            binary_search_sorted_data_base     cpfuncts.c     4
            build_box_parts                    cpfuncts.c     1
  static build_records_from_list               cp.c           1
            build_the_data_base                cpbuild.c      1
  static bump_line_count                       cp.c           29
            check_for_new_page                 cpfuncts.c     4
  static count_all_defined_references          cp.c           1
  static deallocate_arrays                     cp.c           1
  static do_top_of_page                        cp.c           7
            doprint                            cpfuncts.c     3
  static draw_output_block                     cpfuncts.c     4
  static get_chars                             cpbuild.c      6
  static get_to_next_possible_token            cpbuild.c      4
  static initialize_globals                    cp.c           1
  static is_legal_identifier_character         cpbuild.c      1
  main                                         cp.c           1
  static mark_as_static                        cpbuild.c      1
            nasty                              cpinput.c      1
  process_arguments                            cpinput.c      1
  static recursion_check                       cpfuncts.c     1
  scan_for_static_or_global                    cpfuncts.c     2
  static setpage                               cpfuncts.c     3
  static show_files_leading_comments           cp.c           1
  static show_function_relationships           cp.c           1
  static show_library_functions                cp.c           1
  static show_line_and_byte_counts             cp.c           1
  static show_page_references                  cp.c           1
  static show_sorted_function_list             cp.c           1
  static show_unused_if_any                    cp.c           1
  static sort_the_data_base_array              cp.c           1
            tab_to_left_margin                 cpfuncts.c     9
  static test_and_add                          cpbuild.c      1
  static unget_chars                           cpbuild.c      8
  Un-used function list:                       -cpfuncts.c
  static stop
</pre><P>
<P>
I corrected the treatment of static functions.  First, you have to recognize them, and then mark them when they are entered into the data base.  It is also necessary to mark them in the called-function list with their file name, if they are called at any time in the file under analysis.  In C, you can have many functions with the same name in a program, as long as only one of them is not static and each is in a different file.  This requires a change to the way the defined function call count is done and the way the output tree is checked.  Basically, the binary search of the sorted data base must be called with the understanding that there might be more than one defined function with the same name.  If the called function is in a different file from the defined function and the defined function is static, it should not match.  You must search adjacent names in the ASCII sorted list for a called function that is (first) static in the defined functions file, (second) not static and in any file, else it must be a library function.  This also reflects upon the recursion check.  All of these issues are addressed in the new version of the program.  A function is recursive if it calls a function with the same name (perhaps through other functions) and the test checks that the file name associated with the called function is the same as the file name of the calling function.  This avoids the trap of function x() say in file 1, calling function y() in file 2, and y() calling static function x( ) in file 2.  The original code would say incorrectly that function x() was recursive.<P>
<a href="8914f.htm#02a9_0007">More Details.</A><P>
<a name="02a9_0007">*<a name="02a9_0007"><P>
<h3><a name="02a9_0008">A Few Extras<a name="02a9_0008"></h3><P>
The point of making the called function array programmable is to allow you to shrink its storage requirements and thus allow the program to run in less memory.  This allows the program to be launched with impunity from within editors, TSRs, Windows, DESQ-view, and so on.<P>
As stated in the code comments, this program will not see the relationship between functions when they are called indirectly via pointers to functions.  Also, functions in the body of a #define will be missed.  Code in both #if and #else will also be scanned, possibly noting more function calls and perhaps even getting out of sync with respect to opening and closing braces.  This may be annoying but as long as you are aware of it, I don't think it's too serious.  If needed, you could pass the source through the preprocessor first before processing it with cp.<P>
The code now catches all of the initial comments in a file.  I am not sure what it did in the original code.  The temporary buffer for it is 3K.  Compile it bigger if you wish.  The look-ahead buffer that scans between matching parentheses in a function declaration or definition is the manifest constant c_line_length, which is set to 512.  If you are even more verbose in your style than I am, you may want to make this larger (a co-worker of mine is, so his is 2048!).  The called function array size is the number of unique functions per function definition for all function definitions in the program, so the number of function calls can exceed this number.  These arrays are mallocd so that if they need to exceed a full segment, one only has to change the malloc()s to halloc()s, the associated free()s to hfree()s, and then the really tedious part, chasing all associated global and local variables (usually pointers to these arrays) and changing all their definitions to huge, such as some_type *some_type_pointer to some_type huge*some_type_pointer.  A large model recompile is all that is required.  This is all Microsoft C 5.x specific talk, though I assume similar constructs exist in other Cs on the IBM PC/XT/AT platform.  I would expect these huge arrays are not needed until one must analyze a really large C program, perhaps something on the order of 1-2-3 release 3!<P>
<h3><a name="02a9_0009">The Loose Ends<a name="02a9_0009"></h3><P>
The parser still worries me.  It catches all the stuff I have thrown at it, but because I am still not sure how it works (!), I feel that it may still have some black holes.  I can't follow its execution by looking at it; I just go on faith.  The next version will probably return a space for any white space character.  That is, put the white space testing into get_to_next_possible-token().  This should clean up build_the_data_base() a little.<P>
I would like to contemplate the data structures a little and perhaps come up with something a little less ugly than what exists now, especially the structure elements that mark statics. There must be a neater way of doing this.  You may want to add yet another input toggle to plot unused functions.  This is useful in a C program that uses pointers to functions.  You may not be able to see who calls the function, but you can plot it anyway.<P>
For those of you with really big programs, you could go to halloc() for the arrays.  After qualifying the declarations of pointers with the huge attribute, a large model recompile is all that is required to allow arrays larger than the 64K limit imposed by malloc().<P>
Two more items complete the wish list.  The first is hooking in the page linker to the library calls in doprint() so that a cross reference to library calls may be generated.  The last is to sort the defined functions on entry rather than at the end.  This would free up run-time dynamic memory and would not create a significant time penalty; in fact, it might actually speed things up!<P>
<h3><a name="02a9_000a">Late Additions<a name="02a9_000a"></h3><P>
At the request of a co-worker (yes, the same one!) the input buffer for the input file name list was extended from 20 bytes to 128 bytes.  Apparently his sources were really scattered about his directory tree, and so some of his pathnames were quite long, hence the change to the buffer size.  A small change was also made to allow an optional string following each input file pathname.  This string is atoi()d, and if it is not 0, it is added to the tree structure defining box and added as a column in the sorted function list.  Its intended usage is the overlay number of the function.  Overlays are the trick that allows you to write code and .exe files that may wildly exceed 640K or whatever your memory space is.  This is yet another argument to the program, its default is off.  The reason for this is to study the program flow of the tree diagram to check for one overlay, calling another in order to prevent thrashing in a loop, speeding up execution by combining them into one overlay and so on.<P>
I imagine other uses could be put into this extra information, the interpretation is up to the user.  The same (!)  co-worker also asked that the unused function list be sorted by filename.  Yes, he had a lot of them!  Because the sorting routine was already in place for the used functions, it was simple enough to clone it into the unused list display function.<P>
<h3><a name="02a9_000b">Last Words<a name="02a9_000b"></h3><P>
I trust that more C wizards will pop up and carry this ball a little further.  I only carried it as far as I needed for my purposes.  The C program that cp is now maintaining is over 4.2 million bytes, over 117,000 lines, 198 files, uses 993 defined functions called 4600 times, with 192 library functions called 3118 times!  As you can imagine, this program does a wonderful job at wearing out printers!  Thanks to Stewart for the great idea and for doing all the initial dirty work.<P>
<h3><a name="02a9_000c">C Printer for VMS and Unix<a name="02a9_000c"></h3><P>
Kevin E. Poole<P>
Kevin is a software design engineer on the Boeing automated software engineering (BASE) project.  The BASE project increases quality and productivity in the development of embedded computer software.  The capabilities presented in the article are part of the BASE documentation production system.  Kevin can be contacted at 14424 34th Ave. S., #2, Seattle, WA 98168.<P>
I modified Ron Winter's PC/MS-DOS C Printer Utility (CP), presented in the accompanying article, to run on two additional operating systems: VAX VMS and VAX Unix.  The modifications are divided into four sets of steps: The first set involves creating the makefiles, the second set involves modifying the C source code, the third involves compiling and running the new CP, and the fourth set provides two optional enhancements to CP.  The listings in my version were developed using DEC VAX VMS 5.1-1 and DEC VAX Unix BSD 4.3.<P>
Creating the makefiles<P>
Step 1: An MMS utility description file was created for the VMS operating system, as shown in <a href="8914f.htm#02a9_001b">Listing One</A> (page 86).<P>
Step 2: The make utility makefile shown in <a href="8914f.htm#02a9_001d">Listing Two</A> (page 86) was created for the Unix operating system.<P>
Step 3: CP uses command-line options, so the following line should be added to the VMS login.com file to create a foreign command to run CP:<P>
<pre>  CP == &quot;$DEVICE:[YOUR_            ACCOUNT .CP]CP.EXE&quot;</pre><P>
Step 4: Because the C Printer executable is called &quot;cp,&quot; it was necessary to change it to something else so that it would not be confused with the Unix cp command.  CP (printed in bold in my <a href="8914f.htm#02a9_001d">Listing Two</A>) was changed to mycp.  You can name it whatever you like.<P>
Modifying the C Code<P>
Because of space constraints, the entire source code for the VMS and the Unix version of the cp program are not included with this article.  Instead, I've provided code that should be inserted into Ron's program, as well as code that should replace portions of his listings. Ron's listings will be prefaced by the letters &quot;RW&quot; (<a href="8914f.htm#02a9_000d">RW-Listing One</A>, for example) so as not to be confused with the listings in this article.  However, the complete system is available on the DDJ listings disk, the DDJ Forum on CompuServe, and on the DDJ Listing Service.<P>
Step 1: Define one constant per operating system using C preprocessor #define commands.  These constants are used in conjunction with the #if and #endif structures to surround code that is to be conditionally compiled.  The lines in <a href="8914f.htm#02a9_001f">Listing Three</A> (page 86) should be inserted into <a href="8914f.htm#02a9_000d">RW-Listing One</A> between lines 3 and 4.<P>
Step 2: The Microsoft C function declarations contain the reserved word &quot;near,&quot; which is not supported by VMS or Unix.  The function declaration blocks at the top of each source file ending in &quot;.c&quot; must be duplicated.  Surround one block with the #if MSDOS and #endif pair. Surround the other block with the #if VMS and #endif pair.  From the VMS block remove all instances of the &quot;near&quot; reserved word.  The lines in <a href="8914f.htm#02a9_0021">Listing Four</A>  (page 86) should replace lines 27 through 52 in <a href="8914f.htm#02a9_000f">RW-Listing Two</A>. The other source files must also be modified in this way.  The Unix compiler produces syntax errors on function declarations, so they were omitted.<P>
The Microsoft C function definitions also contain the reserved word &quot;near.&quot;  Function definitions containing the &quot;near&quot; reserved word must be duplicated.  Remove the &quot;near&quot; reserved word from the duplicated definitions to support VMS and Unix.  Surround the original and duplicate definitions with the #if MSDOS, #elseif, and #endif structure as in <a href="8914f.htm#02a9_0023">Listing Five</A> (page 86), which replaces line 56 in <a href="8914f.htm#02a9_000f"> RW-Listing Two</A>.  All function definitions in source files ending in .c should be changed in this way.<P>
Step 3: Each compiler supplies a different set of include files.  Where the include file names are the same, the contents most often differ.  The lines in <a href="8914f.htm#02a9_001f">Listing Six</A> (page 86) replace lines 5 through 9 in <a href="8914f.htm#02a9_000d">RW-Listing One</A> and the lines in <a href="8914f.htm#02a9_0027">Listing Seven</A> (page 86) replace line 25 in <a href="8914f.htm#02a9_000f">RW-Listing Two</A> to make the necessary include-file modifications.<P>
Step 4: A few library functions in the MS-DOS version were not found in either of the VAX C libraries.  The strdup( ) function must be added to the code for VMS and Unix to duplicate the functionality of the missing library function.  The function in <a href="8914f.htm#02a9_0029">Listing Eight</A> (page 86) should be inserted between lines 824 and 825 in <a href="8914f.htm#02a9_000f"> RW-Listing Two</A>.<P>
The CP report header contains the current date and time that is provided by the MS-DOS _strdate() and _strtime() functions.  Although not in the same format, this information is provided by the time() and localtime() functions in VMS and Unix.  A new function was created for VMS and Unix using the appropriate library calls.  The MS-DOS code was moved into a function body and replaced by a call to the new function.  The function call in <a href="8914f.htm#02a9_002b">Listing Nine</A> (page 86) replaces lines 233 through 256 of <a href="8914f.htm#02a9_000f"> RW-Listing Two</A> and the functions in <a href="8914f.htm#02a9_002d">Listing Ten</A> (page 86) should be inserted between lines 210 and 211 in <a href="8914f.htm#02a9_000f">RW-Listing Two</A>.<P>
Step 5: The MS-DOS and VMS tolower() library function returns the lowercase equivalent of an uppercase character or the same character if it is already lowercase.  In Unix the function works the same if the character is uppercase, but it makes a lowercase character even lower, returning some character that is not a valid command-line option.  Replace line 93 in <a href="8914f.htm#02a9_0011">RW-Listing Three</A> with the code in <a href="8914f.htm#02a9_002f">Listing Eleven</A> (page 88), which uses the islower() function to check the case of a character and passes the character to the tolower() function only if it is uppercase.<P>
Step 6: CP directs output to the CRT by specifying that the outfile be &quot;CON.&quot;  On PC/MS-DOS, CON is a reserved system device and is therefore automatically assigned.  On VMS and Unix the code in <a href="8914f.htm#02a9_0031">Listing Twelve</A> (page 88) must replace line 850 in <a href="8914f.htm#02a9_000f">RW-Listing Two</A> to facilitate this option.<P>
Step 7: The Unix C compiler detected an error that neither the Microsoft nor the VMS compiler found.  Replace line 868 in <a href="8914f.htm#02a9_000f">RW-Listing Two</A> with the line in <a href="8914f.htm#02a9_0033">Listing Thirteen</A> to remove the use of a variable called &quot;errno&quot; that was used but never declared and could cause a run-time error.<P>
Step 8: Memory size limitations are not a concern on the virtual machines for the requirements of the C printer.  Replace lines 95, 117, 140, 163, 188 in <a href="8914f.htm#02a9_000f">RW-Listing Two</A> with the line in <a href="8914f.htm#02a9_0035">Listing Fourteen</A> (page 88) to use the MS-DOS constant to inhibit CP's byte limit errors on VMS and Unix.<P>
Compiling and Running CP<P>
Step 1: After completing the steps required to modify the C source code, the code can be compiled on all of the supported operating systems using the make utilities and files.<P>
Step 2: CP does not interpret C preprocessor directives, so compile the code with the C preprocessor and then run CP on the preprocessed code.  <a href="8914f.htm#02a9_0037">Listings Fifteen</A> (page 88) and <a href="8914f.htm#02a9_0039">Sixteen</A> (page 88) contain the commands needed to run the C preprocessor on the CP source files on VMS and Unix, respectively.<P>
Step 3: The cp.cpi file shown in <a href="8914f.htm#02a9_003b">Listing Seventeen</A> (page 88) must be used as the list file to run CP on the preprocessed source code.  If run on VMS or Unix, the -n option should be used to suppress IBM-type graphics characters in the output.<P>
Enhancing CP<P>
The following enhancements to the C Printer were developed to support the construction of design documents for software created by The Boeing Company.<P>
Step 1: Path names can be very long in hierarchical directory structures, so it is necessary to modify CP in order that it will accept these long names in its list file.  Insert the line in <a href="8914f.htm#02a9_003d">Listing Eighteen</A> (page 88) between lines 18 and 19 of <a href="8914f.htm#02a9_000d">RW-Listing One</A> and change the value of the LEN_FILE constant to the maximum size needed.<P>
The rest of the changes needed are made by replacing line 262 of <a href="8914f.htm#02a9_000f"> RW-Listing Two</A> with the code in <a href="8914f.htm#02a9_003f">Listing Nineteen</A> (page 88) and line 270 of <a href="8914f.htm#02a9_000f">RW-Listing Two</A> with the code in <a href="8914f.htm#02a9_0041"> Listing Twenty</A> (page 88).<P>
Step 2: When using long file names, the boxes that are displayed by CP get overrun.  The b option has been added to CP to allow the size of the box to be varied at run time.  See <a href="8914f.htm#02a9_0041">Listings Twenty-One through Twenty-Nine</A> (pages 88-89) for the code and instructions needed to implement this option.  The bounds-checking values (<a href="8914f.htm#02a9_0051">Listings Twenty-Eight</A> and <a href="8914f.htm#02a9_0053">Twenty-Nine</A>) and the default value (<a href="8914f.htm#02a9_004b">Listing Twenty-Five</A>) can be changed to suit your needs.  <a href="8914f.htm#02a9_004f">Listing Twenty-Seven</A> will correct two errors with the help screen that were most likely inadvertently left out of the original program.  Due to lack of space, the details of the code will not be discussed.  If you have any questions about this option or about any aspect of the C Printer write me at the address given at the beginning of this article.<P>

_AN AID TO DOCUMENTING C REVISITED_
by Ron Winter

<a name="02a9_000d"><a name="02a9_000d">
<a name="02a9_000e"></pre><B>[LISTING ONE]</B><pre><a name="02a9_000e">

/*********************************************************************
                                  cpheader.h
 *********************************************************************/

#include &lt;malloc.h&gt;
#include &lt;conio.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

#define  Max_unget_buffer        20000
#define  Max_general_buffers     3000
#define  MAX_functions           5000
/* #define  Max_functions           4000 */
#define  Max_defined_functions   1400
#define  Max_files               1400
#define  Max_Recursion           50

#define  false       0
#define  true        1
#define  completed   2

#define  Escape      0x1b
#define  Control_z   0x1a

/*********************************************************************/
typedef struct the_Pages
   {
   int               on_this_page;
   struct the_Pages  *next_page_ptr;
   }linked_pages_list;
/**********************************************************************/
typedef struct
   {
   char              *functions_name;
   char              *its_filename;
   int               is_referenced;
   int               static_function;
   }function_type;
/**********************************************************************/
typedef struct
   {
   char              *source_filename;
   char              *source_file_comment;
   unsigned int      line_count;
   long              size;
   }file_record_type;
/**********************************************************************/
typedef struct                   /* this is the main data base record */
   {
   file_record_type  *file_record_ptr;
   char              *defined_function;
   function_type     *ptr_to_function_table;
   int               number_of_function_calls;
   linked_pages_list *ptr_to_page_list;
   int               number_of_references;
   int               static_definition;
   int               overlay_number;
   }data_base_record_type;
/**********************************************************************/

#if MAIN != 0
/***********************************************************************/

function_type              /* 6 */
   **sorted_called_list_ptrs,
   *function_list,
   *function_list_ptr;
int
   Max_functions,
   count_of_functions = 0;
/********************************/
file_record_type           /* 14 */
   *file_record_array,
   *file_record_array_ptr;
int
   count_of_source_files = 0;
/********************************/
data_base_record_type      /* 20 */
   *data_base_array,
   *data_base_array_ptr,
   **array_of_unused_ptrs_to_records,
   **array_of_ptrs_to_records;
int
   count_of_valid_records = 0;
/********************************/

char *recursion_array[ Max_Recursion ];
int recursion_depth = 0;

char nesting_display_buffer[ Max_general_buffers ];

char target[ 40 ] = &quot;main&quot;;
FILE *output = NULL;

char push_buffer[ Max_unget_buffer ] = { 0, 0, 0, 0 };
char *push_buffer_ptr;

char file_comment_buffer[ Max_general_buffers ];
int first_comment;

int effective_width;

int
   page = 1,
   line = 0,
   defined_page_width =    80,
   defined_page_length =   60,
   defined_left_margin =   1,
   defined_right_margin =  1,
   stats_only =      false,
   g_lib_flag =      false,
   g_comment_flag =  false,
   g_dec_def_flag =  false,
   g_help_flag =     false,
   ibm_flag =        true,
   g_quiet_flag =    false,
   g_tech_flag =     false,
   g_ov_flag =       false,
   g_un_flag =       false,
   target_flag =     false;
int top_of_form_done;
char title[] =
/*       mm/dd/yy0 hh:mm:ss0 */
      { &quot;                    C PRINTER - (c) 1987, 1988 rev. 1.3&quot; };

/********************************************************************/

#else
/*********************************************************************/

extern function_type
   **sorted_called_list_ptrs,
   *function_list,
   *function_list_ptr;
extern file_record_type
   *file_record_array,
   *file_record_array_ptr;
extern data_base_record_type
   *data_base_array,
   *data_base_array_ptr,
   **array_of_unused_ptrs_to_records,
   **array_of_ptrs_to_records;
extern char *recursion_array[ ];
extern int
   count_of_valid_records,
   Max_functions,
   count_of_functions,
   count_of_source_files;
extern int page, line, recursion_depth;
extern int first_comment;
extern char nesting_display_buffer[ ];
extern char top_bottom_line_of_box[ ];
extern FILE *output;
extern char push_buffer[ ];
extern char *push_buffer_ptr;
extern char file_comment_buffer[ ];
extern int defined_page_width;
extern int defined_page_length;
extern int defined_left_margin;
extern int defined_right_margin;
extern int effective_width;
extern char target[ ];
extern int
   stats_only,
   g_lib_flag,
   g_comment_flag,
   g_dec_def_flag,
   g_help_flag,
   ibm_flag,
   g_quiet_flag,
   g_tech_flag,
   g_ov_flag,
   g_un_flag,
   target_flag;
extern int top_of_form_done;
extern char title[];
/*********************************************************************/

#endif
/**********************************************************************/




<a name="02a9_000f"><a name="02a9_000f">
<a name="02a9_0010"></pre><B>[LISTING TWO]</B><pre><a name="02a9_0010">

/*********************************************************************
                                     cp.c

static void near bump_line_count( void );
static void near do_top_of_page( void );
static void near deallocate_arrays( void );
static void near allocate_arrays( void );
static void near initialize_globals( void );
static void near build_records_from_list( FILE * );
static void near sort_the_data_base_array( void );
static void near count_all_defined_references( void );
static void near show_function_relationships( void );
static void near show_line_and_byte_counts( void );
static void near show_sorted_function_list( void );
static void near show_page_references( void );
static void near show_unused_if_any( );
static void near show_library_functions( void );
static void near show_files_leading_comments( );
       int       main( int, char ** );

 **************************************************************************/

#define  MAIN  1
#include &quot;cpheader.h&quot;
#include &quot;time.h&quot;

extern int  near binary_search_sorted_data_base( char * );
extern void near build_box_parts( int );
extern int  near build_the_data_base( char *, char * );
extern void near check_for_new_page( void );
extern int  near doprint( int );
extern void near nasty( int );
extern void near process_arguments( int, int, char **, int );
extern void near scan_for_static_or_global( int *, int, char *, char * );
extern void near tab_to_left_margin( FILE * );

static void near allocate_arrays( void );
static void near build_records_from_list( FILE * );
static void near bump_line_count( void );
static void near count_all_defined_references( void );
static void near deallocate_arrays( void );
static void near do_top_of_page( void );
static void near initialize_globals( void );
static void near show_files_leading_comments( void );
static void near show_function_relationships( void );
static void near show_library_functions( void );
static void near show_line_and_byte_counts( void );
static void near show_page_references( void );
static void near show_sorted_function_list( void );
static void near show_unused_if_any( void );
static void near sort_the_data_base_array( void );
       int       main( int, char ** );

/***************************************************************************/

static void near bump_line_count( )
{
top_of_form_done = false;
++line;
check_for_new_page();
tab_to_left_margin( output );
}
/***************************************************************************/
static void near do_top_of_page( )
{
if( !top_of_form_done )
   {
   top_of_form_done = true;
   line = 9999;
   check_for_new_page();
   tab_to_left_margin( output );
   }
}
/***************************************************************************/
static void near deallocate_arrays( )
{
if( function_list )
   free( function_list );
if( file_record_array )
   free( file_record_array );
if( data_base_array )
   free( data_base_array );
if( sorted_called_list_ptrs )
   free( sorted_called_list_ptrs );
if( array_of_ptrs_to_records )
   free( array_of_ptrs_to_records );
}
/***************************************************************************/

static void near allocate_arrays( )
{
unsigned long length;

length = (unsigned long)Max_functions * sizeof( function_type );
if( length &gt; 65535 )
   {
   (void)printf( &quot;too many called functions ( go to huge model code )\n&quot; );
   exit( 1 );
   }
else
   if(
      !( function_list =
         (function_type *)malloc( (unsigned int)length )
       )
     )
      {
      (void)printf( &quot;No room for function_list\n&quot; );
      exit( 1 );
      }
   else
      {
      if( !g_quiet_flag &amp;&amp; g_tech_flag )
         (void)printf( &quot;function list = %lu bytes long\n&quot;, length );
      }

length = (unsigned long)Max_files * sizeof( file_record_type );
if( length &gt; 65535 )
   {
   (void)printf( &quot;too many files ( go to huge model code )\n&quot; );
   exit( 1 );
   }
else
   if(
      !( file_record_array =
         (file_record_type *)malloc( (unsigned int)length )
       )
     )
      {
      (void)printf( &quot;No room for file_record_array\n&quot; );
      exit( 1 );
      }
   else
      {
      if( !g_quiet_flag &amp;&amp; g_tech_flag )
         (void)printf( &quot;file record array = %lu bytes long\n&quot;, length );
      }

length =
   (unsigned long)Max_defined_functions * sizeof( data_base_record_type );
if( length &gt; 65535 )
   {
   (void)printf( &quot;too many defined functions ( go to huge model code )\n&quot; );
   exit( 1 );
   }
else
   if(
      !( data_base_array =
         (data_base_record_type *)malloc( (unsigned int)length )
       )
     )
      {
      (void)printf( &quot;No room for data_base_array\n&quot; );
      exit( 1 );
      }
   else
      {
      if( !g_quiet_flag &amp;&amp; g_tech_flag )
         (void)printf( &quot;data base array = %lu bytes long\n&quot;, length );
      }

length =
   (unsigned long)Max_defined_functions * sizeof( data_base_record_type * );
if( length &gt; 65535 )
   {
   (void)printf(
            &quot;too many defined functions pointers( go to huge model code )\n&quot;
               );
   exit( 1 );
   }
else
   if(
      !( array_of_ptrs_to_records =
         (data_base_record_type **)malloc( (unsigned int)length )
       )
     )
      {
      (void)printf( &quot;No room for *array_of_ptrs_to_records\n&quot; );
      exit( 1 );
      }
   else
      {
      if( !g_quiet_flag &amp;&amp; g_tech_flag )
         (void)printf( &quot;array of ptrs to data base = %lu bytes long\n&quot;,
                        length );
      }

length = (unsigned long)Max_functions * sizeof( function_type * );
if( length &gt; 65535 )
   {
   (void)printf(
      &quot;too many called function ptrs ( go to huge model code )\n&quot;
               );
   exit( 1 );
   }
else
   if(
      !( sorted_called_list_ptrs =
            (function_type **)malloc( (unsigned int)length )
       )
     )
      {
      (void)printf( &quot;No room for ptr function_list\n&quot; );
      exit( 1 );
      }
   else
      {
      if( !g_quiet_flag &amp;&amp; g_tech_flag )
         (void)printf( &quot;sorted called list ptrs = %lu bytes long\n&quot;, length );
      }
}
/***************************************************************************/

static void near initialize_globals( )
{
int i;
char *cp;

function_list_ptr = function_list;
data_base_array_ptr = data_base_array;
file_record_array_ptr = file_record_array;

for( i = 0; i &lt; Max_Recursion; ++i )
   recursion_array[ i ] = NULL;
build_box_parts( ibm_flag );
effective_width =             /******** set global output width ***********/
   defined_page_width - defined_left_margin - defined_right_margin;
if( effective_width &lt; 40 )
   {
   (void)printf( &quot;\nThe page width is too narrow( needs &gt; 40 ).&quot; );
   exit( 1 );
   }

cp = &amp;title[ 0 ];    /* insert date and nice time into title */
(void)_strdate( cp );
title[ 8 ] = ' ';
cp = &amp;title[ 10 ];
(void)_strtime( cp );

title[ 15 ] = ' ';   /* knock off seconds */
title[ 16 ] = ' ';   /* put am, pm here */
title[ 17 ] = 'm';
title[ 18 ] = ' ';

i = atoi( &amp;title[ 10 ] );  /* f/ military to civilian time */
title[ 16 ] = ( i &lt; 12 )? (char)'a': (char)'p';

if( i == 0 )
   i = 12;
if( i &gt;= 13 )
   i -= 12;

(void)sprintf( &amp;title[ 10 ], &quot;%2d&quot;, i );
title[ 12 ] = ':';

if( title[ 10 ] == '0' )
   title[ 10 ] = ' ';
}
/***********************************************************************/
static void near build_records_from_list( stream )
FILE  *stream;
{
char input_list_filename[ 129 ], input_line[ 129 ], overlay_number[ 129 ];
int l;

while( !feof( stream ) )
   {
   input_list_filename[ 0 ] = '\0';
   input_line[ 0 ] = '\0';
   overlay_number[ 0 ] = '\0';
   fgets( input_line, 128, stream );   /* ends at \n or eof */

   if(
      ( l = strlen( input_line ) ) &gt; 1    /* ie not nul string */
     )
      {
      if( input_line[ l - 1 ] == '\n' )
         input_line[ l - 1 ] = '\0';

      l = sscanf( input_line, &quot; %s %s &quot;,
                  input_list_filename, overlay_number
                );
      if( !g_quiet_flag &amp;&amp; g_tech_flag )
         {
         (void)printf( &quot;pathname = %s &quot;, input_list_filename );
         if( l )
            (void)printf( &quot;overlay # = %s &quot;, overlay_number );
         }
      (void)build_the_data_base( input_list_filename, overlay_number );
      }
   }
}
/***************************************************************************/

static void near sort_the_data_base_array( )
{
int i, still_sorting_flag;

for( i = 0, data_base_array_ptr = data_base_array;
     i &lt; count_of_valid_records;
     ++i
   )
   array_of_ptrs_to_records[ i ] = data_base_array_ptr++;

if( !g_quiet_flag )
   {
   (void)printf( &quot;\n\nSorting the function list...\n&quot; );
   (void)printf( &quot; of %d functions\n&quot;, count_of_valid_records );
   }
still_sorting_flag = true;
while( still_sorting_flag )
   {
   still_sorting_flag = false;
   if( !g_quiet_flag )
      {
      (void)printf( &quot;.&quot; );
      }
   for( i = 0; i &lt; count_of_valid_records - 1; ++i )
      {
      if( strcmp( array_of_ptrs_to_records[ i ]-&gt;defined_function,
                  array_of_ptrs_to_records[ i + 1 ]-&gt;defined_function ) &gt; 0 )
         {
         still_sorting_flag = true;
         data_base_array_ptr = array_of_ptrs_to_records[ i ];
         array_of_ptrs_to_records[ i ] = array_of_ptrs_to_records[ i + 1 ];
         array_of_ptrs_to_records[ i + 1 ] = data_base_array_ptr;
         }
      }
   }
}
/************************************************************************/

static void near count_all_defined_references()
{
register int count;
int found;
register function_type *f_list_ptr;

f_list_ptr = function_list;         /* the full list */

for( count = 0; count &lt; count_of_functions; ++count )
   {
   found = binary_search_sorted_data_base( f_list_ptr-&gt;functions_name );
   if( found &gt;= 0 )
      scan_for_static_or_global( &amp;found,
                                 f_list_ptr-&gt;static_function,
                                 f_list_ptr-&gt;functions_name,
                                 f_list_ptr-&gt;its_filename
                               );
   if( found &gt;= 0 )
      array_of_ptrs_to_records[ found ]-&gt;number_of_references +=
         f_list_ptr-&gt;is_referenced;
   ++f_list_ptr;        /* for all defined functions */
   }
if( !g_quiet_flag &amp;&amp; g_dec_def_flag )
   (void)printf( &quot;\n&quot; );
}
/***************************************************************************/

static void near show_function_relationships( )
{
int found;
int record_index;

found = binary_search_sorted_data_base( target );/* w/o knowing filename */
                  /* note if static, will find random one if more than */
                  /* one with same name */
if( found &gt;= 0 )
   {
   recursion_depth = 0;
   if( !g_quiet_flag )
      {
      (void)printf( &quot;Checking for usage...\n&quot; );
      }
   count_all_defined_references();
   nesting_display_buffer[ 0 ] = '\0';
   if( !g_quiet_flag )
      {
      (void)printf( &quot;Starting the printout...\n&quot; );
      }
   if( !target_flag )               /* main is only called once */
      array_of_ptrs_to_records[ found ]-&gt;number_of_references = 1;
   line = 0;
   if( !stats_only )
      {
      (void)doprint( found );       /* of target function */
      for( record_index = 0;
           record_index &lt; count_of_valid_records;
           ++record_index
         )
         {
         (void)fprintf( output, &quot;\n&quot; );
         ++line;
         if( array_of_ptrs_to_records[ record_index ]-&gt;number_of_references &gt;
             1
           )
            (void)doprint( record_index );
         }
      }
   }
else        /* cant find target */
   {
   (void)printf( &quot;cant find %s, exitting\n&quot;, target );
   exit( 1 );
   }
}
/***************************************************************************/

static void near show_line_and_byte_counts( )
{
long int total_byte_count;
long int total_line_count;
int i;

file_record_array_ptr = file_record_array;

do_top_of_page();
(void)fprintf( output, &quot;File statistics:\n&quot; );
bump_line_count();
total_byte_count = 0l;
total_line_count = 0l;
for( i = 0; i &lt; count_of_source_files; ++i )
   {
   (void)fprintf( output,
                  &quot;%-40s - %8u lines, %12ld bytes\n&quot;,
                  file_record_array_ptr-&gt;source_filename,
                  file_record_array_ptr-&gt;line_count,
                  file_record_array_ptr-&gt;size
                );
   bump_line_count();

   total_byte_count += file_record_array_ptr-&gt;size;
   total_line_count += file_record_array_ptr-&gt;line_count;
   ++file_record_array_ptr;
   }
(void)fputc( '\n', output );
bump_line_count();
(void)fprintf( output, &quot;Totals:\n&quot; );
bump_line_count();
/********                       &quot;%-40s - %8u lines, %12ld bytes\n&quot;, *******/
(void)fprintf( output, &quot;%4d files%-30s - %8ld lines, %12ld bytes\n&quot;,
               count_of_source_files, &quot; &quot;, total_line_count, total_byte_count
             );
bump_line_count();
(void)fputc( '\n', output );
bump_line_count();
(void)fprintf( output,
               &quot; %d defined functions found.\n&quot;, count_of_valid_records
             );
bump_line_count();
(void)fprintf( output, &quot;Averages:\n&quot; );
bump_line_count();
(void)fprintf( output,
               &quot;%6d lines/file, %6d functions/file, %6d lines/function\n&quot;,
               (int)( total_line_count / count_of_source_files ),
               (int)( count_of_valid_records / count_of_source_files ),
               (int)( total_line_count / count_of_valid_records )
             );
}
/***************************************************************************/

static void near show_sorted_function_list( )
{
int i, record_index;
long reference_total = 0;

do_top_of_page();

(void)fprintf( output, &quot;Function index:\n&quot; );
bump_line_count();

if( g_ov_flag )
   (void)fprintf( output, &quot;%-39s %-28s %s %s\n&quot;,
                  &quot;function&quot;, &quot;in file&quot;, &quot;ov#&quot;, &quot;refs&quot; );
else
   (void)fprintf( output, &quot;%-39s %-28s    %s\n&quot;,
                  &quot;function&quot;, &quot;in file&quot;, &quot;refs&quot; );

bump_line_count();

for( i = 0; i &lt; effective_width; ++i )
   (void)fputc( '_', output );
(void)fprintf( output, &quot;\n&quot; );
bump_line_count();

for( record_index = 0;
     record_index &lt; count_of_valid_records;
     ++record_index
   )
   {
   data_base_array_ptr = array_of_ptrs_to_records[ record_index ];
   if( data_base_array_ptr-&gt;number_of_references &gt; 0 )
      {
      if( g_ov_flag &amp;&amp; data_base_array_ptr-&gt;overlay_number )
         (void)fprintf( output, &quot;%-7s%-32s %-28s %3d %d\n&quot;,
                        ( data_base_array_ptr-&gt;static_definition )?
                        &quot;static&quot;: &quot;&quot;,
                        data_base_array_ptr-&gt;defined_function,
                  ( data_base_array_ptr-&gt;file_record_ptr )-&gt;source_filename,
                        data_base_array_ptr-&gt;overlay_number,
                        data_base_array_ptr-&gt;number_of_references
                      );
      else
         (void)fprintf( output, &quot;%-7s%-32s %-28s     %d\n&quot;,
                        ( data_base_array_ptr-&gt;static_definition )?
                        &quot;static&quot;: &quot;&quot;,
                        data_base_array_ptr-&gt;defined_function,
                  ( data_base_array_ptr-&gt;file_record_ptr )-&gt;source_filename,
                        data_base_array_ptr-&gt;number_of_references
                      );
      reference_total += (long)data_base_array_ptr-&gt;number_of_references;
      bump_line_count();
      }
   }
(void)fprintf( output, &quot;%-7s%-32s %-28s     %s\n&quot;,
               &quot; &quot;, &quot; &quot;, &quot; &quot;, &quot;____&quot;
             );
bump_line_count();
(void)fprintf( output, &quot;%-7s%-32s %-28s     %ld\n&quot;,
               &quot; &quot;, &quot; &quot;, &quot;total &quot;, reference_total
             );
bump_line_count();
}
/***************************************************************************/

static void near show_page_references( )
{
int pmax;          /* max x ref columns */
int i, pcnt;
linked_pages_list *p;

if( !stats_only &amp;&amp; ( defined_page_length &gt; 0 ) )
   {
   pmax = (int)( effective_width - 7 - 32 - 2 ) / 5;
   do_top_of_page();
   (void)fprintf( output, &quot;Function cross reference:\n&quot; );
   bump_line_count();

   for( i = 0; i &lt; count_of_valid_records; ++i )
      {
      data_base_array_ptr = array_of_ptrs_to_records[ i ];
      if( data_base_array_ptr-&gt;number_of_references &gt; 0 )
         {
         (void)fprintf( output, &quot;%-7s%-32s- &quot;,
                        ( data_base_array_ptr-&gt;static_definition )?
                        &quot;static&quot;: &quot;&quot;,
                        data_base_array_ptr-&gt;defined_function );
         p = data_base_array_ptr-&gt;ptr_to_page_list;
         if( p )
            {
            pcnt = 0;
            while( p-&gt;next_page_ptr )
               {
               (void)fprintf( output, &quot;%4d,&quot;, p-&gt;on_this_page );
               p = p-&gt;next_page_ptr;
               ++pcnt;
               if( pcnt &gt;= pmax )
                  {
                  (void)fputc( '\n', output );
                  bump_line_count();
                  (void)fprintf( output, &quot;%7s%32s  &quot;, &quot; &quot;, &quot; &quot; );
                  pcnt = 0;
                  }
               }
            (void)fprintf( output, &quot;%4d\n&quot;, p-&gt;on_this_page );
            }
         else
            (void)fprintf( output, &quot;\n&quot; );
         bump_line_count();
         }
      }
   }
}
/***************************************************************************/

static void near show_unused_if_any( )
{
int i, unused_count, unused_index, count, still_sorting_flag;
data_base_record_type **unused_list_ptr_ptr, *unused_list_ptr;

do_top_of_page();
(void)fprintf( output, &quot;Un-used function list:\n&quot; );
bump_line_count();

unused_count = 0;
for( i = 0; i &lt; count_of_valid_records; ++i )
   {
   data_base_array_ptr = array_of_ptrs_to_records[ i ];
   if( !data_base_array_ptr-&gt;number_of_references )
      {
      ++unused_count;
      if( !g_un_flag )
         {
         (void)fprintf( output,
                        &quot;%-7s%-32s- %-33s\n&quot;,
                        ( data_base_array_ptr-&gt;static_definition )?
                        &quot;static&quot;: &quot;&quot;,
                        data_base_array_ptr-&gt;defined_function,
                     ( data_base_array_ptr-&gt;file_record_ptr )-&gt;source_filename
                      );
         bump_line_count();
         }
      }
   }
if( g_un_flag )               /* show sorted */
   {
   if( unused_count )
      {
      if(
         !( array_of_unused_ptrs_to_records =
            (data_base_record_type **)malloc( (unsigned int)unused_count )
          )
        )
         (void)printf( &quot;No room for *array_of_unused_ptrs_to_records\n&quot; );
      else
         {
         unused_index = 0;
         for( i = 0; i &lt; count_of_valid_records; ++i )
            {
            data_base_array_ptr = array_of_ptrs_to_records[ i ];
            if( !data_base_array_ptr-&gt;number_of_references )
               {                    /* first just collect them */
               array_of_unused_ptrs_to_records[ unused_index++ ] =
                  data_base_array_ptr;
               }
            }                 /* so now there are unused_index of them */
         unused_list_ptr_ptr = array_of_unused_ptrs_to_records;
         still_sorting_flag = true;
         if( unused_count &gt; 1 )
            {
            while( still_sorting_flag )
               {
               still_sorting_flag = false;
               if( !g_quiet_flag &amp;&amp; g_tech_flag )
                  (void)printf( &quot;.%d   \r&quot;, count );
               for( count = 0; count &lt; unused_count - 1; ++count )
                  {
                  if( strcmp( unused_list_ptr_ptr[ count ]-&gt;
                              file_record_ptr-&gt;source_filename,
                              unused_list_ptr_ptr[ count + 1 ]-&gt;
                              file_record_ptr-&gt;source_filename
                            ) &gt; 0
                    )
                     {
                     still_sorting_flag = true;
                     unused_list_ptr = unused_list_ptr_ptr[ count ];
                     unused_list_ptr_ptr[ count ] =
                        unused_list_ptr_ptr[ count + 1 ];
                     unused_list_ptr_ptr[ count + 1 ] = unused_list_ptr;
                     }
                  }
               }
            }
         for( i = 0; i &lt; unused_count; ++i )
            {
            (void)fprintf( output,
                           &quot;%-7s%-32s- %-33s\n&quot;,
                           ( unused_list_ptr_ptr[ i ]-&gt;static_definition )?
                           &quot;static&quot;: &quot;&quot;,
                           unused_list_ptr_ptr[ i ]-&gt;defined_function,
               ( unused_list_ptr_ptr[ i ]-&gt;file_record_ptr )-&gt;source_filename
                         );
            bump_line_count();
            }
         }
      }
   }
if( !unused_count )
   {
   tab_to_left_margin( output );
   (void)fprintf( output, &quot;No un-used functions in the list.\n&quot; );
   bump_line_count();
   }
else
   {
   (void)fprintf( output, &quot;%-7s%-39s- %d\n&quot;, &quot;&quot;, &quot;totals&quot;, unused_count );
   bump_line_count();
   }
}
/************************************************************************/

static void near show_library_functions( )
{
register int count;
int found, total, still_sorting_flag, x_count, final_count, final_call;
function_type **f_list_ptr_ptr, *f_list_ptr;

if( g_lib_flag )
   {
   if( !g_quiet_flag &amp;&amp; g_tech_flag )
      (void)printf( &quot;collecting library functions...\n&quot; );
   do_top_of_page();
   (void)fprintf( output, &quot;Library functions:\n&quot; );
   bump_line_count();

   total = 0;
   f_list_ptr = function_list;
   for( count = 0; count &lt; count_of_functions; ++count )
      {
      if( !f_list_ptr-&gt;static_function )
         {
         if(
            ( found =
              binary_search_sorted_data_base( f_list_ptr-&gt;functions_name )
            ) &lt; 0
           )
            sorted_called_list_ptrs[ total++ ] = f_list_ptr;
         }
      ++f_list_ptr;        /* for all called functions */
      }

   if( !g_quiet_flag &amp;&amp; g_tech_flag )
      (void)printf( &quot;gathering identical library functions...\n&quot; );
   final_count = total;    /* number of calls to be collected and sorted */
   f_list_ptr_ptr = sorted_called_list_ptrs;
   for( count = 0; count &lt; ( total - 1 ); ++count )
      {
      for( x_count = count + 1; x_count &lt; total; ++x_count )
         {
         if( ( f_list_ptr_ptr[ count ]-&gt;functions_name[ 0 ] != '\0' ) &amp;&amp;
             !strcmp( f_list_ptr_ptr[ count ]-&gt;functions_name,
                      f_list_ptr_ptr[ x_count ]-&gt;functions_name )
           )
            {
            f_list_ptr_ptr[ count ]-&gt;is_referenced +=
               f_list_ptr_ptr[ x_count ]-&gt;is_referenced;
            f_list_ptr_ptr[ x_count ]-&gt;functions_name[ 0 ] = '\0';
            --final_count;
            }
         }
      }

   if( !g_quiet_flag &amp;&amp; g_tech_flag )
      {
      (void)printf( &quot;\nSorting the library function calls...\n&quot; );
      }

   f_list_ptr_ptr = sorted_called_list_ptrs;
   still_sorting_flag = true;
   while( still_sorting_flag )
      {
      still_sorting_flag = false;
      if( !g_quiet_flag &amp;&amp; g_tech_flag )
         (void)printf( &quot;.%d   \r&quot;, count );
      for( count = 0; count &lt; total - 1; ++count )
         {
         if( strcmp( f_list_ptr_ptr[ count ]-&gt;functions_name,
                     f_list_ptr_ptr[ count + 1 ]-&gt;functions_name ) &gt; 0 )
            {
            still_sorting_flag = true;
            f_list_ptr = f_list_ptr_ptr[ count ];
            f_list_ptr_ptr[ count ] = f_list_ptr_ptr[ count + 1 ];
            f_list_ptr_ptr[ count + 1 ] = f_list_ptr;
            }
         }
      }
   if( !g_quiet_flag &amp;&amp; g_tech_flag )
      (void)printf( &quot;\n&quot; );

   (void)fprintf( output, &quot;%-32s %-28s\n&quot;,
                  &quot;library function&quot;, &quot;calls&quot; );
   bump_line_count();

   for( count = 0; count &lt; effective_width; ++count )
      (void)fputc( '_', output );
   (void)fprintf( output, &quot;\n&quot; );
   bump_line_count();

   final_call = 0;
   f_list_ptr_ptr = sorted_called_list_ptrs;
   for( count = 0; count &lt; total; ++count )
      {
      if( ( *f_list_ptr_ptr )-&gt;functions_name[ 0 ] != '\0' )
         {
         (void)fprintf( output, &quot;%-32s %d\n&quot;,
                        ( *f_list_ptr_ptr )-&gt;functions_name,
                        ( *f_list_ptr_ptr )-&gt;is_referenced
                      );
         final_call += ( *f_list_ptr_ptr )-&gt;is_referenced;
         bump_line_count();
         }
      ++f_list_ptr_ptr;
      }
   (void)fprintf( output, &quot;Totals:\n&quot; );
   bump_line_count();
   (void)fprintf( output, &quot;%6d %-25s %d calls.\n&quot;,
                  final_count, &quot;library functions,&quot;, final_call
                );
   bump_line_count();
   }
}
/************************************************************************/

static void near show_files_leading_comments( )
{
int i;
char *cp;

if( g_comment_flag )
   {
   do_top_of_page();
   (void)fprintf( output, &quot;File comments:\n&quot; );
   bump_line_count();
   file_record_array_ptr = file_record_array;
   for( i = 0; i &lt; count_of_source_files; ++i )
      {
      (void)fprintf( output, &quot;%40s\n&quot;,
                     file_record_array_ptr-&gt;source_filename
                   );
      bump_line_count();
      cp = file_record_array_ptr-&gt;source_file_comment;
      while( *cp )
         {
         (void)fprintf( output, &quot;%c&quot;, *cp );
         if( *++cp == '\n' )
            {
            bump_line_count();
            }
         }
      ++file_record_array_ptr;
      do_top_of_page();          /* one page per comment at least */
      }
   }
}
/**********************************************************************/

int main( argc, argv )
char **argv;
int argc;
{
int   index, in_error = false, out_error = false;
FILE  *stream;

nasty( argc );

(void)printf( &quot;\ncp - ver. 1.3,  (C)1987, 1988  Stewart A. Nutter\n&quot; );
(void)printf( &quot;    extended and corrected by  Ron Winter\n&quot; );

index = 1;
if( !( stream = fopen( argv[ index ], &quot;rt&quot; ) ) )
   in_error = true;
else
   ++index;
if(
   ( argc &gt; index ) &amp;&amp;
   (
    ( argv[ index ][ 0 ] != '/' ) &amp;&amp; ( argv[ index ][ 0 ] != '-' )
   )
  )
   {
   output = fopen( argv[ 2 ], &quot;w+&quot; );     /******* wt+ &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; ******/
   ++index;
   }
else
   output = fopen( &quot;prn&quot;, &quot;w+&quot; );         /******** wt+ &lt;&lt;&lt;&lt;&lt;&lt; ********/

if( !output )
   out_error = true;

Max_functions = MAX_functions;
process_arguments( index, argc, argv, in_error || out_error );
if( in_error )
   {
   (void)printf( &quot;\n can't open input list %s\n&quot;, argv[ 1 ] );
   exit( 1 );
   }
if( out_error )
   {
   (void)printf( &quot;\n can't open output file, error %s\n&quot;, strerror( errno ) );
   exit( 1 );
   }
allocate_arrays( );
initialize_globals( );
(void)printf( &quot;\n&quot; );

build_records_from_list( stream );
sort_the_data_base_array( );
if( !g_quiet_flag )
   {
   (void)printf( &quot;\n&quot; );
   }
top_of_form_done = false;
show_function_relationships( );
show_page_references( );
show_line_and_byte_counts( );
show_sorted_function_list( );
show_unused_if_any( );
show_library_functions( );
show_files_leading_comments( );
deallocate_arrays( );

/************* done *****************/
(void)fprintf( output, &quot;%c&quot;, 0x0c );   /* ff */

return false;     /* ok */
}
/********************************************************************/





<a name="02a9_0011"><a name="02a9_0011">
<a name="02a9_0012"></pre><B>[LISTING THREE]</B><pre><a name="02a9_0012">

/***********************************************************************
                                   cpinput.c
       void near nasty( int );
       void near process_arguments( int, int, char **, int );
************************************************************************/
#define  MAIN  0
#include &quot;cpheader.h&quot;

       void near nasty( int );
       void near process_arguments( int, int, char **, int );
/************************************************************************/

void near nasty( argc )
int argc;
{
if( argc &lt; 2 )
   {
   (void)printf( &quot;\ncp listfile [ outfile ] [\n&quot; );
   (void)printf(
   &quot;     /p:nn /w:nn /m:nn /r:nn /t:main /f:nnnn\n&quot;
               );
   (void)printf(
   &quot;     /l /n /s /q /d /c /h /x\n&quot;
               );
   (void)printf(   &quot;                        ]\n\n&quot; );
   (void)printf(
   &quot;     outfile            = prn\n&quot; );
   (void)printf(
   &quot;    p: page length      = %3d   [ 0, 50 -255 ]\n&quot;, defined_page_length
               );
   (void)printf(
   &quot;     w: page width      = %3d   [ 80 - 255 ]\n&quot;, defined_page_width
               );
   (void)printf(
   &quot;     m: left margin     = %2d    [ 0 - 30 ]\n&quot;, defined_left_margin
               );
   (void)printf(
   &quot;     r: right margin     = %2d    [ 0 - 30 ]\n&quot;, defined_right_margin
               );
   (void)printf(
   &quot;     t: target function  = %s\n&quot;, target
               );
   (void)printf(
   &quot;     f: # of function calls = %4d    [ 2 - 5461 ]\n&quot;, MAX_functions
               );
   (void)printf(
   &quot;     n: normal characters( ie not ibm character graphics )\n&quot;
               );
   (void)printf(
   &quot;     l  output library functions\n&quot;
               );
   (void)printf(
   &quot;     c  output file\'s 1st comment\n&quot;
               );
   (void)printf(
   &quot;     s  output statistics only\n&quot;
               );
   (void)printf(
   &quot;     d  show declarations and definitions\n&quot;
               );
   (void)printf(
   &quot;     o  show overlay information\n&quot;
               );
   (void)printf(
   &quot;     u  show unused sorted by filename\n&quot;
               );
   (void)printf(
   &quot;     q  show no messages\n&quot;
               );
   (void)printf(
   &quot;     h  show more help\n&quot;
               );
   (void)printf(
   &quot;     x  show tech info\n&quot;
               );

   (void)printf( &quot;\n&quot; );
   exit( 0 );
   }
}
/**********************************************************************/
void near process_arguments( index, argc, argv, an_error )
int index, argc, an_error;
char **argv;
{
char c;
int i, tmp;

for( i = index; i &lt; argc; ++i )
   {
   if( ( argv[ i ][ 0 ] == '/' ) || ( argv[ i ][ 0 ] == '-' ) )
      {
      c = (char)tolower( (int)argv[ i ][ 1 ] );
      switch( c )
         {
         case 'n':
            ibm_flag = ( ibm_flag )? false: true;
            break;
         case 'l':
            g_lib_flag = ( g_lib_flag )? false: true;
            break;
         case 'c':
            g_comment_flag = ( g_comment_flag )? false: true;
            break;
         case 'd':
            g_dec_def_flag = ( g_dec_def_flag )? false: true;
            break;
         case 's':
            stats_only = ( stats_only )? false: true;
            break;
         case 'q':
            g_quiet_flag = ( g_quiet_flag )? false: true;
            break;
         case 'o':
            g_ov_flag = true;
            break;
         case 'u':
            g_un_flag = true;
            break;
         case 'h':
            g_help_flag = true;
            break;
         case 'x':
            g_tech_flag = true;
            break;
         default:
          if( ( strlen( argv[ i ] ) &gt; 3 ) &amp;&amp; ( argv[ i ][ 2 ] == ':' ) )
              {
               tmp = atoi( &amp;argv[ i ][ 3 ] );
               switch( c )
                  {
                  case 'p':
                   if( ( ( 50 &lt; tmp ) &amp;&amp; ( tmp &lt; 256 ) ) || ( tmp == 0 ) )
                       defined_page_length = tmp;
                   break;
                  case 'm':
                     if( ( 0 &lt;= tmp ) &amp;&amp; ( tmp &lt;= 30 ) )
                        defined_left_margin = tmp;
                     break;
                  case 'r':
                     if( ( 0 &lt;= tmp ) &amp;&amp; ( tmp &lt;= 30 ) )
                        defined_right_margin = tmp;
                     break;
                  case 't':
                     (void)strcpy( target, &amp;argv[ i ][ 3 ] );
                     target_flag = true;
                     break;
                  case 'w':
                     if( ( 79 &lt; tmp ) &amp;&amp; ( tmp &lt; 256 ) )
                        defined_page_width = tmp;
                     break;
                  case 'f':
                     if( ( 1 &lt; tmp ) &amp;&amp; ( tmp &lt; 5462 ) )
                        Max_functions = tmp;
                     break;
                  default:
                     (void)printf(
                         &quot;\nUnknown argument character: %c, ignored!\n&quot;,
                           argv[ i ][ 1 ]
                              );
                     break;
                  }  /* end of switch on character after / or - */
               }     /* end of if :something */
            else
               (void)printf( &quot;\nMissing : for argument %s, ignored!\n&quot;,
                             argv[ i ] );
            break;
         }           /* end of switch on character after / or - */
      }              /* end of if / or - */
   else
      (void)printf( &quot;\nUnknown argument: %s, ignored!\n&quot;, argv[ i ] );
   }                 /* end of for loop on arguments */

if( g_tech_flag )
   {
   (void)printf( &quot;\n&quot; );
   (void)printf( &quot;Notes: 1. Max recursive function displacement of %d.\n&quot;,
                 Max_Recursion
               );
   (void)printf(
&quot;         2. Max # of unique function calls per defined function\n\
            for all defined functions is %d.\n&quot;,
   Max_functions );
   (void)printf( &quot;         3. Max # of defined functions is %d.\n&quot;,
      Max_defined_functions );
   (void)printf( &quot;\n&quot; );
   (void)printf( &quot;sizeof()\'s:\n&quot; );
   (void)printf(
&quot; function table = %u, contents = %u, data base = %u,\
 database = %u, lib = %u\n&quot;,
      sizeof( function_type ),
      sizeof( file_record_type ),
      sizeof( data_base_record_type ),
      sizeof( array_of_ptrs_to_records ),
      sizeof( sorted_called_list_ptrs )
               );
   (void)printf( &quot;\n&quot; );
   (void)printf(
   &quot;The program will tend to show certain \'c\' functions as unused.\n&quot; );
   (void)printf(
   &quot;1. defined functions assigned to declared pointers to function names\n&quot; );
   (void)printf(
   &quot;   and executed as pointers to those function names won't be seen.\n&quot; );
   (void)printf(
   &quot;2. #if(s) controlling the generation of code especially with\n&quot; );
   (void)printf(
   &quot;   braces( { } ) in the conditional code section will especially\n&quot; );
   (void)printf(
   &quot;   screw up if there is an #else code part.  This program will work\n&quot; );
   (void)printf(
   &quot;   on both code parts of the conditional and most probably get out\n&quot; );
   (void)printf(
   &quot;   of sync with the braces. One might do a preprocessor pass compile\n&quot; );
   (void)printf(
   &quot;   and heave it\'s output files as input files at this program.\n&quot; );
   (void)printf(
   &quot;3. #define(s) that expand to functions and call functions will also\n&quot; );
   (void)printf(
   &quot;   be neglected.  The preprocessor may be used as stated above.\n&quot; );
/******
   (void)printf(
   &quot;\n&quot; );
******/
   (void)printf( &quot;\n&quot; );
   }

if( g_help_flag )
   {
   (void)printf( &quot;\n&quot; );
   (void)printf(
   &quot;The listfile argument is an ascii text file containing the list of\n&quot;
               );
   (void)printf(
   &quot;filenames to process, one filename per line (optional overlay number.)\n&quot;
               );
   (void)printf(
   &quot;The output file may be a device or a filename. If there is no\n&quot;
               );
   (void)printf(
   &quot;output filename, \'prn\' is assumed. Note that one may put \'con\'\n&quot;
               );
   (void)printf(
   &quot;here and view the output of the program before printing or saving\n&quot;
               );
   (void)printf(
   &quot;to a filename.\n&quot;
               );
   (void)printf(
   &quot;Also note that the output filename and the input filenames in the\n&quot;
               );
   (void)printf(
   &quot;listfile may be full pathnames with drives and or paths.\n&quot;
               );
   (void)printf( &quot;/ arguments accept the alternate - form.\n&quot; );
   (void)printf( &quot;For example: cp x y -s, cp /h, cp x -x /d -t:junk\n&quot; );
   (void)printf( &quot;arguments may be in upper or lower case.\n&quot; );
   (void)printf( &quot;Note that the target function is case sensitive\n&quot; );
   (void)printf( &quot;since it is a \'c\' function name.\n&quot; );
   (void)printf( &quot;\n&quot; );
   }
if( an_error )
   {
   if( g_help_flag || g_tech_flag )
      exit( 0 );
   else
      (void)printf( &quot;Oops...&quot; );
   }
}
/***********************************************************************/





<a name="02a9_0013"><a name="02a9_0013">
<a name="02a9_0014"></pre><B>[LISTING FOUR]</B><pre><a name="02a9_0014">

/***************************************************************************
                                   cpbuild.c
static void near mark_as_static( function_type *, char*, int );
static int near  test_and_add( function_type *, char *, int );
static void near unget_chars( char );
static char near get_chars( FILE * );
static char near get_to_next_possible_token( FILE * );
static int near  is_legal_identifier_character( char );
       int near  build_the_data_base( char * );
***************************************************************************/

#define  MAIN  0
#include &quot;cpheader.h&quot;

       int near  build_the_data_base( char * );
static char near get_chars( FILE * );
static char near get_to_next_possible_token( FILE * );
static int near  is_legal_identifier_character( char );
static void near mark_as_static( function_type *, char*, int );
static int near  test_and_add( function_type *, char *, int );
static void near unget_chars( char );

/***************************************************************************/
static void near mark_as_static( ptr_to_function_list,
                                 name_of_static_function, count
                               )
char *name_of_static_function;
function_type *ptr_to_function_list;
int count;
{
int i;

for( i = 0; i &lt; count; ++i )
   {
   if(
      !strcmp( name_of_static_function, ptr_to_function_list-&gt;functions_name )
     )
      ptr_to_function_list-&gt;static_function = true;
   ++ptr_to_function_list;
   }
}
/***************************************************************************/
#define KEYS   7

static int near test_and_add( ptr_to_function_list, string, count )
function_type *ptr_to_function_list;
char *string;
int count;
{
int i, is_a_new_function_name;
static char *keywords[ KEYS ] =
   {  /* must catch do (void)printf, while(), else (void)... etc. ***/
   &quot;do&quot;, &quot;while&quot;, &quot;if&quot;, &quot;else&quot;, &quot;for&quot;, &quot;switch&quot;, &quot;return&quot;
   };

for( i = 0; ( i &lt; KEYS ) &amp;&amp; ( strcmp( string, keywords[ i ] ) != 0 ); ++i )
   ;
if( i &lt; KEYS )
   is_a_new_function_name = false;     /* ie a reserved word match */
else                                   /* is a function name */
   {
   for( i = 0; i &lt; count; ++i )
      {
      if( !strcmp( string, ptr_to_function_list-&gt;functions_name ) )
         {                       /* function name matches */
         if( !ptr_to_function_list-&gt;static_function )
            break;               /* and isn't static */
         else
            {
            if( !strcmp( ptr_to_function_list-&gt;its_filename,
                         file_record_array_ptr-&gt;source_filename
                      )
              )
               break;            /* only statics in same file match */
            }
         }
      ++ptr_to_function_list;
      }
   if( i == count )
      {                                /* new function name */
      is_a_new_function_name = true;   /* add function name to list */
      if( ( function_list_ptr-&gt;functions_name = strdup( string ) ) == NULL )
         {
         (void)fprintf( stderr, &quot;Ran out of memory.\n&quot; );
         exit( 1 );
         }
      function_list_ptr-&gt;static_function = false;
      function_list_ptr-&gt;its_filename =
         file_record_array_ptr-&gt;source_filename;
      function_list_ptr-&gt;is_referenced = 1;

      ++function_list_ptr;             /* point to next empty cell */
      ++count_of_functions;            /* increase current size */
      if( count_of_functions &gt; Max_functions )
         {
         (void)fprintf( stderr, &quot;Too many functions.\n&quot; );
         exit( 1 );
         }
      }
   else                                /* string already in function list */
      {
      is_a_new_function_name = false;
      ptr_to_function_list-&gt;is_referenced++;
      }
   }
return is_a_new_function_name;
}
/***************************************************************************/
static void near unget_chars( c )
char c;
{
if( ( push_buffer_ptr - push_buffer ) &lt; Max_unget_buffer )
   *push_buffer_ptr++ = c;
else
   {
   (void)fprintf( stderr, &quot;\nProgram syntax error:&quot; );
   (void)fprintf( stderr, &quot; Too many pushed characters.\n&quot; );
   exit( 1 );
   }
}
/***************************************************************************/
static char near get_chars( stream )
FILE * stream;
{
register char c;

if( push_buffer_ptr != push_buffer )
   c = *--push_buffer_ptr;
else
   {
   c = (char)fgetc( stream );
   if( c == EOF )
      c = Control_z;
   if( c == 0x0a )
      {
      file_record_array_ptr-&gt;line_count++;
      file_record_array_ptr-&gt;size++;           /* count the unseen &lt;cr&gt; */
      }
   file_record_array_ptr-&gt;size++;
   }
return c;
}
/***************************************************************************/
static char near get_to_next_possible_token( stream )
FILE *stream;
{
register char
   c;
char
   next_char_peek;
int
   done;

static int       /* the only apparent reason these are static is for speed */
   quotes_flag =           false,
   comment_flag =          false,
   escape_sequence_flag =  false,
   pound_sign_flag =       false,
   ascii_quote_flag =      false;
static int
   fp = 0;   /*****&lt;&lt;&lt;&lt;&lt; */
static char *cp;

done = false;
do {
   c = get_chars( stream );
   if( c != Control_z )
      {
      if( comment_flag )
         {
/**************************
   process /* comment sequence of characters
***************************/
         if( first_comment == true )
            {
            if( fp &lt; ( Max_general_buffers - 2 ) )
               {
               if(
                  ( c != '\n' ) &amp;&amp;
                  ( strlen( cp ) &lt; effective_width )
                 )
                  {
                  file_comment_buffer[ fp++ ] = c;
                  file_comment_buffer[ fp ] = '\0';
                  }
               else        /* c == \n or length &gt;= width */
                  {
                  file_comment_buffer[ fp++ ] = '\n';
                  file_comment_buffer[ fp ] = '\0';
                  cp = (char *)&amp;file_comment_buffer[ fp ];
                  if( c != '\n' )
                     {
                     file_comment_buffer[ fp++ ] = c;
                     file_comment_buffer[ fp ] = '\0';
                     }
                  }
               }
/*          else     /* 1st comment exceeds buffer */
            }        /* end of if first_comment == true */
         if( c == '*' )
            {
            next_char_peek = get_chars( stream );
            if( next_char_peek == '/' )          /* close comment */
               {
               comment_flag = false;
               unget_chars( ' ' );  /* comments are white space in 'c' */
               if( first_comment == true )
                  {
                  first_comment = completed;
                  fp = 0;
                  cp = (char *)&amp;file_comment_buffer[ fp ];
                  }
               }
            else        /* next_char_peek != '/' ie close comment */
               unget_chars( (char)next_char_peek );
            }  /* end of if c == '*' */
         }
      else     /* not /* */
         {
/**************************
   process \sequence character, hoping \&quot; \' \\ etc inside &quot; or '
***************************/
         if( escape_sequence_flag )
            escape_sequence_flag = false;
         else     /* not /*, not \ */
            {
/**************************
   process &quot; string sequence of characters
***************************/
            if( quotes_flag )
               {
               if( c == '\\' )                  /* check for \'\n' */
                  {
                  next_char_peek = get_chars( stream );
                  if( next_char_peek != '\n' )  /* so not \'\n' */
                     {
                     escape_sequence_flag = true;
                     unget_chars( (char)next_char_peek );
                     }
/*******          else                          /* \'\n' continuation */
                  }
               else                             /* not \ */
                  if( c == '\&quot;' )
                     quotes_flag = false;
               }
            else     /* not &quot;, not /*, not \ */
               {
/**************************
   process ' ascii character sequence
***************************/
               if( ascii_quote_flag )
                  {
                  if( c == '\\' )
                     escape_sequence_flag = true;
                  else
                     if( c == '\'' )
                        ascii_quote_flag = false;
                  }
               else  /* not ', not &quot;, not /*, not \ */
                  {
/**************************
   process # sequence of characters, ie #if, #define, etc.
   define causes code sequencing problems it would seem!
***************************/
                  if( pound_sign_flag )
                     {
                     if( c == '/' )       /* comments override #defines etc */
                        {
                        next_char_peek = get_chars( stream );
                        if( next_char_peek == '*' )
                           comment_flag = true;
                        else
                           unget_chars( (char)next_char_peek );
                        }
                     else
                        {
                        if( c == '\n' )
                           pound_sign_flag = false;
                        else                          /* c != \n */
                           {
                           if( c == '\\' )  /* check for \'\n' continuation */
                              {
                              next_char_peek = get_chars( stream );
                              if( next_char_peek != '\n' ) /* it aint \'\n' */
                                 unget_chars( (char)next_char_peek );
/*                            else              /* \'\n' means continue # */
                              }
                           }
                        }
                     }
                  else     /* not ', not #, not &quot;, not /*, not \ */
                     {
/**************************
   process anything else
***************************/
                     done = false;     /* assume a ' or &quot; or # or /* */
                     switch( c )
                        {
                        case '\&quot;':
                           quotes_flag = true;
                           break;
                        case '\'':
                           ascii_quote_flag = true;
                           break;
                        case '#':
                           pound_sign_flag = true;
                           break;
                        case '/':
                           next_char_peek = get_chars( stream );
                           if( next_char_peek == '*' )
                              {
                              comment_flag = true;
                              if( first_comment == false )
                                 {           /* the 1st comment of the file */
                                 first_comment = true;
                                 fp = 0;
                                 cp = (char *)&amp;file_comment_buffer[ fp ];
                                 }
                              }
                           else
                              {
                              unget_chars( (char)next_char_peek );
                              done = true;
                              }
                           break;
                        default:       /* a worthy character to return */
                           done = true;
                        }
                     }     /* end of else not ascii */
                  }        /* end of else not # */
               }           /* end of else not &quot; */
            }              /* end of else not /* */
         }                 /* end of else not \ */
      }                    /* end of if c != Control_z */
   }
while( !done &amp;&amp; ( c != Control_z ) );
if( c == Control_z )
   {
   ascii_quote_flag = false;
   pound_sign_flag = false;
   quotes_flag = false;
   escape_sequence_flag = false;
   comment_flag = false;
   fp = 0;
   }
return c;
}
/***************************************************************************/
static int near is_legal_identifier_character( c )
char c;
{
if(
   ( ( 'A' &lt;= c ) &amp;&amp; ( c &lt;= 'Z' ) ) ||
   ( ( 'a' &lt;= c ) &amp;&amp; ( c &lt;= 'z' ) ) ||
   ( ( '0' &lt;= c ) &amp;&amp; ( c &lt;= '9' ) ) ||
   ( c == '_')
  )
   return true;
else
   return false;
}
/***************************************************************************/
#define  C_line_length  512
#define  C_identifier_length  80

int near build_the_data_base( the_filename )
char * the_filename;
{
static char fake_comment[ ] = &quot;no room!&quot;;
int found_a_possible_function;
int brace_count, body_found;
int open_parenthesis, parenthesis_count;
int at_end_of_source_file;
int dummy_index, total_called_count;
int function_definition_flag, static_flag;
int analyze_buffer_flag = false;
char c;
char *function_name_buffer_ptr;
char function_name_buffer[ C_identifier_length ];
char look_ahead_buffer[ C_line_length + 1 ];
FILE *stream;
data_base_record_type *data_base_ptr, *starting_data_base_ptr;
function_type *starting_called_function_ptr;

if( !g_quiet_flag )
   {
   (void)printf( &quot;Processing file: %-12s\n&quot;, the_filename );
   }
if( !( stream = fopen( the_filename, &quot;r&quot; ) ) )  /***** rt &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; */
   {
   (void)printf( &quot;Cant open %s\n&quot;, the_filename );
   return -1;
   }

push_buffer_ptr = push_buffer;         /* reset input character stack */
                                       /* add file name to data base */
if( !( file_record_array_ptr-&gt;source_filename = strdup( the_filename ) ) )
   {
   (void)printf( &quot;Ran out of memory.\n&quot; );
   exit( 1 );
   }

starting_called_function_ptr = function_list_ptr;
starting_data_base_ptr = data_base_array_ptr; /* mark start of defined list */

look_ahead_buffer[ 0 ] = '\0';

first_comment = false;
file_comment_buffer[ 0 ] = '\0';

file_record_array_ptr-&gt;line_count = 0;  /* clear it's variables */
file_record_array_ptr-&gt;size = 0l;

function_name_buffer_ptr = function_name_buffer;
function_name_buffer[ 0 ] = '\0';

static_flag = false;
found_a_possible_function = false;
open_parenthesis = false;
body_found = false;

brace_count = 0;
parenthesis_count = 0;

at_end_of_source_file = false;
while( !at_end_of_source_file )
   {
   c = get_to_next_possible_token( stream );
   switch( c )
      {
      case '{':
         ++brace_count;
         break;
      case '}':
         --brace_count;
         break;
      case Control_z:
         at_end_of_source_file = true;
         analyze_buffer_flag = true;
         break;
      case '(':
         if( !open_parenthesis )
            ++open_parenthesis;
         analyze_buffer_flag = true;
         break;
      case ' ':                  /* this is where we eat white space */
      case '\v':
      case '\b':
      case '\f':
      case '\t':
      case '\r':
      case '\n':
         do {
            c = get_to_next_possible_token( stream );
            }
         while(
               ( c == '\f' ) || ( c == ' ' ) || ( c == '\v' ) ||
               ( c == '\b' ) || ( c == '\t' ) || ( c == '\r' ) ||
               ( c == '\n' )
              );
         unget_chars( c ); /* put next non white character back */

         if( c != '(' )
            analyze_buffer_flag = true;
/***     else  /* c == '(' and next pass will find it */
         break;
      default:
         if( is_legal_identifier_character( c ) )
            {                          /* it's a good identifier character */
            *function_name_buffer_ptr++ = c;
            *function_name_buffer_ptr = '\0';
            }
         else                          /* it aint, so toss it */
            {
            if( static_flag &amp;&amp; ( c == ';' ) )
               static_flag = false;
/*          if( c != '*' ) */
            analyze_buffer_flag = true;
            }
         break;
      }                    /* end of preliminary character parse */
/*****************
   start checking characters accumulated in function_name_buffer[]
******************/
   if( analyze_buffer_flag )
      {
      analyze_buffer_flag = false;
      if(
         function_name_buffer[ 0 ] &amp;&amp;        /* ie not null string */
         (                                   /* &amp; not number */
          ( function_name_buffer[ 0 ] &lt; '0' ) ||
          ( function_name_buffer[ 0 ] &gt; '9' )
         )
        )
         found_a_possible_function = true;
      else                                   /* it aint an identifier */
         {                                   /* so erase buffer */
         function_name_buffer_ptr = function_name_buffer;
         function_name_buffer[ 0 ] = '\0';
         if( static_flag &amp;&amp; ( c == ';' ) )
            static_flag = false;
         open_parenthesis = false;
         }
      }                       /* end of analyze_buffer_flag */
/*****************
   if function_name_buffer[] has legal function name, scan ahead
******************/
   if( found_a_possible_function )
      {
      found_a_possible_function = false;
      *function_name_buffer_ptr = '\0';   /* append nul char to end */
      if( !static_flag )                  /* don't retest if true */
         if( !strcmp( function_name_buffer, &quot;static&quot; ) )
            static_flag = true;
      if( open_parenthesis )
         {
         open_parenthesis = false;
         if( !brace_count )
            {                             /* ie outside any function body */
            parenthesis_count = 1;
            for( dummy_index = 0;
                 ( dummy_index &lt; C_line_length ) &amp;&amp; parenthesis_count;
                 ++dummy_index
               )
               {                          /* scan ahead for function() */
               c = get_to_next_possible_token( stream );
               if( c == Control_z )
                  break;            /* dummy_index not bumped */
               look_ahead_buffer[ dummy_index ] = c;
               look_ahead_buffer[ dummy_index + 1 ] = '\0';
               switch( c )
                  {
                  case '(':
                     ++parenthesis_count;
                     break;
                  case ')':
                     --parenthesis_count;
                     break;
                  }           /* dummy_index is bumped */
               }              /* end of for loop scanning for (...) */
            if( ( c == Control_z ) || ( !parenthesis_count ) )
               --dummy_index;
            function_definition_flag = false;
            for( ++dummy_index;
                 ( dummy_index &lt; C_line_length ) &amp;&amp; !function_definition_flag;
                 ++dummy_index
               )
               {                 /* what happens past (..) */
               c = get_to_next_possible_token( stream );
               if( c == Control_z )
                  break;            /* w/ function_definition_flag == false */
               look_ahead_buffer[ dummy_index ] = c;
               look_ahead_buffer[ dummy_index + 1 ] = '\0';
               switch( c )
                  {
                  case ' ':         /* this is where we eat white space */
                  case '\v':
                  case '\b':
                  case '\f':
                  case '\t':
                  case '\n':
                  case '\r':
                     break;
                  case '{':
                     ++body_found;
                     break;
                  case ';':
                  case ',':
                  case '(':            /* at (*)() type declaration */
                     if( !body_found )
                        {
                        function_definition_flag = true; /* declaration */
                        if( !g_quiet_flag )
                           {
                           if( g_dec_def_flag )
                              {
                              if( static_flag )
                                 (void)printf( &quot; static&quot; );
                              else
                                 (void)printf( &quot;       &quot; );
                              (void)printf( &quot; declaration &quot; );
                              (void)printf( &quot;%s(%s\n&quot;,
                                            function_name_buffer,
                                            look_ahead_buffer );
                              }
                           }
                        }
                     break;
                  default:          /* any other non white character means */
                     function_definition_flag = completed;
                     if( !g_quiet_flag )
                        {
                        if( g_dec_def_flag )
                           {
                           if( static_flag )
                              (void)printf( &quot;static &quot; );
                           else
                              (void)printf( &quot;       &quot; );
                           (void)printf( &quot;define &quot; );
                           }
                        }
                     break;
                  }           /* dummy_index is bumped */
               }              /* end of for loop parsing character after ) */
            body_found = false;
            if( function_definition_flag == false )
               {
               (void)printf( &quot;\nSyntax error: &quot; );
               (void)printf( &quot;Function description.\n&quot; );
               look_ahead_buffer[ dummy_index ] = '\0';
               (void)printf( &quot;\n%s\n&quot;, look_ahead_buffer );
               exit( 1 );
               }
            while( dummy_index )
               {                       /* put all characters after ( back */
               unget_chars( look_ahead_buffer[ dummy_index - 1 ] );
               --dummy_index;
               }
            if( function_definition_flag == completed )
               {
               if( !g_quiet_flag )
                  {
                  if( g_dec_def_flag )
                     (void)printf( &quot;%-40s\n&quot;, function_name_buffer );
                  }
/*******************
   this element can distinguish static functions
   in different files with the same name
 *******************/
               data_base_array_ptr-&gt;file_record_ptr = file_record_array_ptr;
               data_base_array_ptr-&gt;number_of_function_calls = 0;
               data_base_array_ptr-&gt;ptr_to_function_table = function_list_ptr;
               data_base_array_ptr-&gt;static_definition = static_flag;
               static_flag = false;

               if(
                  !( data_base_array_ptr-&gt;defined_function =
                     strdup( function_name_buffer )
                   )
                 )
                  {
                  (void)printf( &quot;\nRan out of memory( for strdup() ).&quot; );
                  exit( 1 );
                  }
               data_base_array_ptr-&gt;number_of_references = 0;
               data_base_array_ptr-&gt;ptr_to_page_list = NULL;

               data_base_ptr = data_base_array_ptr; /* save current pointer */
               ++data_base_array_ptr;                 /* next entry */
               ++count_of_valid_records;
               if( count_of_valid_records &gt; Max_defined_functions )
                  {
                  (void)printf( &quot;\nToo many new functions\n&quot; );
                  exit( 1 );
                  }
               }        /* end of function definition */
            static_flag = false;
            }
         else                    /* brace_count is not zero */
            {                    /* so inside a function */
            data_base_ptr-&gt;number_of_function_calls +=
               test_and_add( data_base_ptr-&gt;ptr_to_function_table,
                             function_name_buffer,
                             data_base_ptr-&gt;number_of_function_calls
                           );
            }
         look_ahead_buffer[ 0 ] = '\0';   /* reset tail buffer */
         static_flag = false;
         }                       /* end of parenthesis */
      function_name_buffer_ptr = function_name_buffer;   /* reset buffer */
      *function_name_buffer_ptr = '\0';
      }                    /* end of found_a_possible_function */
   }                       /* end of while !at_end_of_source_file */
(void)fclose( stream );
if( !g_quiet_flag )
   {
   (void)printf( &quot;\n&quot; );
   }

if(
   !( file_record_array_ptr-&gt;source_file_comment =
      strdup( file_comment_buffer )
    )
  )
    file_record_array_ptr-&gt;source_file_comment = fake_comment;

/***** mark called functions in list as static if in defined list *******/
total_called_count = 0;
data_base_ptr = starting_data_base_ptr;
while( data_base_ptr != data_base_array_ptr )
   {
   total_called_count += data_base_ptr-&gt;number_of_function_calls;
   ++data_base_ptr;
   }
data_base_ptr = starting_data_base_ptr;
while( data_base_ptr &lt; data_base_array_ptr )
   {
   if( data_base_ptr-&gt;static_definition )
      mark_as_static( starting_called_function_ptr,
                      data_base_ptr-&gt;defined_function,
                      total_called_count
                    );
   ++data_base_ptr;
   }
++file_record_array_ptr;      /* next file name entry */
++count_of_source_files;
if( count_of_source_files &gt;= Max_files )
   {
   (void)printf( &quot;\nError: too many files to process.\n&quot; );
   exit( 1 );
   }
return at_end_of_source_file;
}
/***************************************************************************/





<a name="02a9_0015"><a name="02a9_0015">
<a name="02a9_0016"></pre><B>[LISTING FIVE]</B><pre><a name="02a9_0016">

/***************************************************************************
                                  cpfuncts.c
       void near build_box_parts( int );
       void near tab_to_left_margin( FILE * );
static void near stop( void );
static void near setpage( data_base_record_type * );
static int  near recursion_check( char *, int );
       void near check_for_new_page( void );
static void near draw_output_block( char *, char *, char *,
                                    char *, int, int, int );
       int near  doprint( int );
       void near scan_for_static_or_global( int *, int, char *, char * );
       int near  binary_search_sorted_data_base( char * );

 ***************************************************************************/

#define  MAIN  0
#include &quot;cpheader.h&quot;

static char
   top_line_of_box[ 37 ], bottom_line_of_box[ 37 ],
   wall, ibm_line, bottom_attach,
   upper_left_corner, lower_left_corner,
   upper_right_corner, lower_right_corner,
   left_attach, right_attach;

static char *recursion_filename, *test_filename;
static int static_recursion;

       int near  binary_search_sorted_data_base( char * );
       void near build_box_parts( int );
       void near check_for_new_page( void );
       int near  doprint( int );
       void near scan_for_static_or_global( int *, int, char *, char * );
       void near tab_to_left_margin( FILE * );

static void near draw_output_block( char *, char *, char *,
                                    char *, int, int, int );
static int near  recursion_check( char *, int );
static void near stop( void );
static void near setpage( data_base_record_type * );

/***************************************************************************/
void near build_box_parts( is_ibm )
int is_ibm;
{
int i;

if( is_ibm )
   {
   wall =               '\xb3';
   ibm_line =           '\xc4';
   bottom_attach =      '\xc2';
   upper_left_corner =  '\xda';
   lower_left_corner =  '\xc0';
   upper_right_corner = '\xbf';
   lower_right_corner = '\xd9';
   left_attach =        '\xb4';
   right_attach =       '\xc3';
   }
else
   {
   wall =               '|';
   ibm_line =           '-';
   bottom_attach =      '+';
   upper_left_corner =  '+';
   lower_left_corner =  '+';
   upper_right_corner = '+';
   lower_right_corner = '+';
   left_attach =        '+';
   right_attach =       '+';
   }

top_line_of_box[ 0 ] = upper_left_corner;
bottom_line_of_box[ 0 ] = lower_left_corner;
for( i = 1; i &lt;= 34; ++i )
   {
   top_line_of_box[ i ] = ibm_line;
   bottom_line_of_box[ i ] = ibm_line;
   }
top_line_of_box[ i ] = upper_right_corner;
bottom_line_of_box[ i ] = lower_right_corner;
top_line_of_box[ ++i ] = '\0';
bottom_line_of_box[ i ] = '\0';
}
/***************************************************************************/
void near tab_to_left_margin( output )
FILE *output;
{
register int i;

for( i = 0; i &lt; defined_left_margin; ++i )
   (void)fputc( ' ', output );
}
/***************************************************************************/
static void near stop()
{
(void)printf( &quot;hello&quot; );
}
/***************************************************************************/
static void near setpage( data_base_ptr )
data_base_record_type *data_base_ptr;
{
linked_pages_list *page_list_ptr;

page_list_ptr = data_base_ptr-&gt;ptr_to_page_list;
if( page_list_ptr == NULL )
   {
   if(
      !( page_list_ptr =
         (linked_pages_list *)malloc( sizeof( linked_pages_list ) )
       )
     )
      {
      (void)fprintf( stderr, &quot;Ran out of memory for page # list.\n&quot; );
      exit( 1 );
      }

   data_base_ptr-&gt;ptr_to_page_list = page_list_ptr;
   }
else
   {
   while( page_list_ptr-&gt;next_page_ptr )
      page_list_ptr = page_list_ptr-&gt;next_page_ptr;

   if(
      !( page_list_ptr-&gt;next_page_ptr =
         (linked_pages_list *)malloc( sizeof( linked_pages_list ) )
       )
     )
      {
      (void)fprintf( stderr, &quot;Ran out of memory for page # list.\n&quot; );
      exit( 1 );
      }

   page_list_ptr = page_list_ptr-&gt;next_page_ptr;
   }
page_list_ptr-&gt;next_page_ptr = NULL;
page_list_ptr-&gt;on_this_page = page - 1;
}
/***************************************************************************/
static int near recursion_check( string, static_call )
char *string;
int static_call;
{
register char **recursion_array_ptr;

recursion_array_ptr = recursion_array;
if( static_recursion )
   {                             /* defined function is static */
   while(
         *recursion_array_ptr &amp;&amp; /* not null */
                                 /* and different function names */
         ( strcmp( *recursion_array_ptr, string ) ||
                                 /* or same function names and */
                                 /* in different files */
           strcmp( test_filename, recursion_filename )
         )
        )
   ++recursion_array_ptr;
   }
else
   {                             /* defined function is not static */
   while(
         *recursion_array_ptr &amp;&amp; /* not null &amp; */
                                 /* and different function names */
         ( strcmp( *recursion_array_ptr, string ) ||
                                 /* or same function names and */
           static_call           /* called is static */
         )
        )
      ++recursion_array_ptr;
   }
return ( *recursion_array_ptr )? true: false;
}
/***************************************************************************/
void near check_for_new_page()
{
int i;

if( defined_page_length == 0 &amp;&amp; line == 9999 )
   {
   (void)fprintf( output, &quot;\n\n\n\n&quot; );
   line = 0;
   }
else
   {
   if( defined_page_length != 0 )
      {
      if( line &gt; ( defined_page_length - 5 ) )
         {
         (void)fprintf( output, &quot;\f&quot; );
         line = 0;
         }
      if( line == 0 )
         {
         top_of_form_done = true;
         tab_to_left_margin( output );
         (void)fprintf( output, &quot;%s&quot;, title );
         for( i = strlen( title ); i &lt; ( effective_width - 10 ); ++i )
            (void)fputc( ' ', output );
         (void)fprintf( output, &quot;Page:%4d\n&quot;, page );
         tab_to_left_margin( output );
         for( i = 0; i &lt; effective_width; ++i )
            (void)fputc( '_', output );
         (void)fprintf( output, &quot;\n\n&quot; );
         line = 3;
         ++page;
         }
      }
   }
}
/***************************************************************************/
static void near draw_output_block( lead_in_string,
                                    name_of_function,
                                    description,
                                    name_of_file,
                                    either_count,
                                    tail_flag,
                                    kill_flag
                                  )
char *lead_in_string,
   *name_of_function,
   *description,
   *name_of_file;
int either_count, tail_flag, kill_flag;
{
unsigned int string_length;
static char alternate_lead_in[ 140 ];

/******* 1st line ***********************************************************/
tab_to_left_margin( output );
(void)fprintf( output, &quot;%s %s\n&quot;, lead_in_string, top_line_of_box );

/******* 2nd line ***********************************************************/
tab_to_left_margin( output );
string_length = strlen( lead_in_string );
if( string_length )        /******* ie not main or defined function box ***/
   {
   (void)strncpy( alternate_lead_in, lead_in_string, --string_length );
   alternate_lead_in[ string_length++ ] = '\0'; /* restore string_length */
   }
if( string_length )        /******* ie not main or defined function box ***/
   (void)fprintf( output, &quot;%s%c%c%c%-33s %c\n&quot;,
                  alternate_lead_in,
/***  if( kill_flag )      /****** last line to this box ******************/
/***  else                 /****** line continues downwards ***************/
                  ( kill_flag )? lower_left_corner: right_attach,
                  ibm_line, left_attach, name_of_function, wall );
else                       /****** main or defined box starting ***********/
   (void)fprintf( output,     &quot;%c%c%-33s %c\n&quot;,
                  ibm_line, left_attach, name_of_function, wall );

/******* 3rd line ***********************************************************/
tab_to_left_margin( output );
if( string_length-- )      /***** kill outside vertical line on last box ****/
   lead_in_string[ string_length++ ] = ( kill_flag )? (char)' ': wall;
(void)fprintf( output, &quot;%s %c%-20s %8s%3d  %c\n&quot;,
               lead_in_string, wall, description,
               name_of_file, either_count, wall );

/******* 4th line ***********************************************************/
tab_to_left_margin( output );
bottom_line_of_box[ 2 ] =  /******** if defined box has calls ***********/
   ( tail_flag &amp;&amp; either_count )? bottom_attach: ibm_line;
(void)fprintf( output, &quot;%s %s\n&quot;, lead_in_string, bottom_line_of_box );

line += 4;
top_of_form_done = false;
}
/***************************************************************************/
static char library_string[] = { &quot;(library)&quot; };
static char usage_string[] =   { &quot;Used=&quot; };
static char funct_string[] =   { &quot;Functs=&quot; };

int near doprint( index )
int index;
{
int
   loop_counter,
   max_count,
   starting_index,
   found,
   return_value;
data_base_record_type *record_ptr;
function_type *f_list_ptr;

static int kill_flag = false;

starting_index = index;
record_ptr = array_of_ptrs_to_records[ starting_index ];

recursion_array[ recursion_depth ] = record_ptr-&gt;defined_function;
if( !recursion_depth )
   {
   recursion_filename = record_ptr-&gt;file_record_ptr-&gt;source_filename;
                        /* add function to list for recursion check */
   static_recursion = record_ptr-&gt;static_definition;
   }
check_for_new_page();
setpage( array_of_ptrs_to_records[ starting_index ] );

return_value = page - 1;               /* must be a relic! */
                                       /* start w/ target function */
draw_output_block( nesting_display_buffer,
                   record_ptr-&gt;defined_function,
                   ( record_ptr-&gt;file_record_ptr )-&gt;source_filename,
                   funct_string,
                   record_ptr-&gt;number_of_function_calls,
                   true,
                   kill_flag
                 );

++recursion_depth;
                           /****   mystic width = 4 *****/
(void)strcat( nesting_display_buffer, &quot;   |&quot; );
nesting_display_buffer[ strlen( nesting_display_buffer ) - 1 ] = wall;

max_count = record_ptr-&gt;number_of_function_calls;
for( loop_counter = 0, f_list_ptr = record_ptr-&gt;ptr_to_function_table;
     loop_counter &lt; max_count;
     ++loop_counter, ++f_list_ptr
   )
   {
   kill_flag = ( loop_counter == ( max_count - 1 ) )? true: false;
   check_for_new_page();
                           /* is called function defined? */
   found = binary_search_sorted_data_base( f_list_ptr-&gt;functions_name );
   if( found &gt;= 0 )
      {
      scan_for_static_or_global( &amp;found,
                                 f_list_ptr-&gt;static_function,
                                 f_list_ptr-&gt;functions_name,
                                 f_list_ptr-&gt;its_filename
                               );

      }
   if( found &gt;= 0 )        /* yes */
      {
      test_filename = f_list_ptr-&gt;its_filename;
      if( recursion_check( f_list_ptr-&gt;functions_name,
                           f_list_ptr-&gt;static_function )
        )
         {
/*         tab_to_left_margin( output );
/*         (void)fprintf( output, &quot;%s\n&quot;, nesting_display_buffer ); */
         setpage( array_of_ptrs_to_records[ found ] );
/*         ++line; */
         top_of_form_done = false;
         draw_output_block( nesting_display_buffer,
                            f_list_ptr-&gt;functions_name,
                            &quot;(recursive)&quot;,
                            &quot;&quot;,
                            0,
                            false,
                            kill_flag
                          );
         }
      else        /* not recursive and found &gt;= 0 */
         {
         if( array_of_ptrs_to_records[ found ]-&gt;number_of_references == 1 )
            {                       /* got a new function */
/*            tab_to_left_margin( output );
/*            (void)fprintf( output, &quot;%s\n&quot;, nesting_display_buffer );
/*            ++line;
/*            top_of_form_done = false; */
            doprint( found );           /* used only once */
            }
         else
            {                       /* a previously defined function */
/*            tab_to_left_margin( output );
/*            (void)fprintf( output, &quot;%s\n&quot;, nesting_display_buffer ); */
            setpage( array_of_ptrs_to_records[ found ] );
/*            ++line;
/*            top_of_form_done = false; */
            draw_output_block( nesting_display_buffer,
                               f_list_ptr-&gt;functions_name,
                               &quot;(defined)&quot;,
                               usage_string,
                               f_list_ptr-&gt;is_referenced,
                               false,
                               kill_flag
                             );
            }
         }
      }
   else           /* found = -1 ie not defined means */
      {           /* a library function */
/*      tab_to_left_margin( output );
/*      (void)fprintf( output, &quot;%s\n&quot;, nesting_display_buffer );
/*      ++line;
/*      top_of_form_done = false; */
      draw_output_block( nesting_display_buffer,
                         f_list_ptr-&gt;functions_name,
                         library_string,
                         usage_string,
                         f_list_ptr-&gt;is_referenced,
                         false,
                         kill_flag
                       );
      }
   }           /* end of loop on all called functions */

                           /* remove function f/ recursion list */
recursion_array[ recursion_depth ] = NULL;
                           /****   mystic width = 4 *****/
nesting_display_buffer[ strlen( nesting_display_buffer ) - 4 ] = '\0';
--recursion_depth;
return return_value;
}
/***************************************************************************/
void near scan_for_static_or_global(
                              index_ptr, is_static, function_name, file_name
                                   )
int *index_ptr, is_static;
char *function_name, *file_name;
{
int index;

index = *index_ptr;
if( index )
   while( index-- )
      if( strcmp( function_name,
                  array_of_ptrs_to_records[ index ]-&gt;defined_function )
        )
         {
         ++index;       /* exit at last matching defined function */
         break;
         }
do {
   if(
      ( !is_static &amp;&amp; !array_of_ptrs_to_records[ index ]-&gt;static_definition
      ) ||
      ( is_static &amp;&amp;
        array_of_ptrs_to_records[ index ]-&gt;static_definition &amp;&amp;
        !strcmp( array_of_ptrs_to_records[ index ]-&gt;
                  file_record_ptr-&gt;source_filename,
                 file_name
               )
      )
     )
      break;
   }
while(
      ( ++index &lt; count_of_functions ) &amp;&amp;
      !strcmp( function_name,
               array_of_ptrs_to_records[ index ]-&gt;defined_function
             )
     );
if(
   ( index &gt;= count_of_functions ) ||
   strcmp( function_name, array_of_ptrs_to_records[ index ]-&gt;defined_function
         )
  )
   index = -1;
*index_ptr = index;
}
/***************************************************************************/
int near binary_search_sorted_data_base( key )
char *key;
{
int lo, hi, index;
int doesnt_match;

lo = 0;
hi = count_of_valid_records - 1;
index = ( hi - lo ) / 2;

while( true )
   {
   doesnt_match =
      strcmp( key, array_of_ptrs_to_records[ index ]-&gt;defined_function );
   if( !doesnt_match )        /* a match found at index */
      break;
   if( lo &gt;= hi )             /* no match found */
      {
      index = -1;
      break;
      }
   if( doesnt_match &lt; 0 )     /* key &lt; choice so go downwards */
      hi = index - 1;
   else                       /* key &gt; choice so go upwards */
      lo = index + 1;
   index = ( hi + lo ) / 2;   /* new choice */
   }
return index;
}
/***************************************************************************/





<a name="02a9_0017"><a name="02a9_0017">
<a name="02a9_0018"></pre><B>[LISTING SIX]</B><pre><a name="02a9_0018">

cp.obj : cp.c cpheader.h cp
        cl -AL -c cp.c

cpinput.obj : cpinput.c cpheader.h cp
        cl -AL -c cpinput.c

cpfuncts.obj : cpfuncts.c cpheader.h cp
        cl -AL -c cpfuncts.c

cpbuild.obj: cpbuild.c cpheader.h cp
        cl -AL cpbuild.c -c

cp.exe : cp.obj cpinput.obj cpfuncts.obj cpbuild.obj cp
        link cp+ cpinput+ cpbuild+ cpfuncts/packcode/st:16000,,cp;






<a name="02a9_0019"><a name="02a9_0019">
<a name="02a9_001a"></pre><B>[LISTING SEVEN]</B><pre><a name="02a9_001a">

cpheader.h
cp.c
cpbuild.c
cpfuncts.c
cpinput.c



===============================================================

_C PRINTER FOR VMS AND UNIX_
by Kevin E. Poole

SIDEBAR TO _AUTOMATIC MODULE CONTROL REVISITED_ BY RON WINTER


<a name="02a9_001b"><a name="02a9_001b">
<a name="02a9_001c"></pre><B>[LISTING ONE]</B><pre><a name="02a9_001c">

!
!  VAX/VMS MMS Description File
!
! DEFINITIONS:
H = cpheader.h
!
! CP
!
cp DEPENDS_ON cp.obj cpbuild.obj cpfuncts.obj cpinput.obj
   LINK/EXEC=cp cp.obj,cpbuild.obj,cpfuncts.obj,cpinput.obj
   PURGE *.obj, *.exe

cp.obj DEPENDS_ON $(H) cp.c
   cc cp.c

cpbuild.obj DEPENDS_ON $(H) cpbuild.c
   cc cpbuild.c

cpfuncts.obj DEPENDS_ON $(H) cpfuncts.c
   cc cpfuncts.c

cpinput.obj DEPENDS_ON $(H) cpinput.c
       cc cpinput.c





<a name="02a9_001d"><a name="02a9_001d">
<a name="02a9_001e"></pre><B>[LISTING TWO]</B><pre><a name="02a9_001e">

#
# VAX/Unix Makefile
#
# DEFINITIONS:
#
H = cpheader.h
#
# CP
#
cp : cp.o cpbuild.o cpfuncts.o cpinput.o
   cc -o cp cp.o cpbuild.o cpfuncts.o cpinput.o

cp.o : $H cp.c
   cc -c cp.c

cpbuild.o : $H cpbuild.c
   cc -c cpbuild.c

cpfuncts.o : $H cpfuncts.c
   cc -c cpfuncts.c

cpinput.o : $H cpinput.c
   cc -c cpinput.c





<a name="02a9_001f"><a name="02a9_001f">
<a name="02a9_0020"></pre><B>[LISTING THREE]</B><pre><a name="02a9_0020">

#define MSDOS 0    /* Set the appropriate constant */
#define VMS 0      /* to one (1) before compiling. */
#define UNIX 1      /* All others are zero (0)      */





<a name="02a9_0021"><a name="02a9_0021">
<a name="02a9_0022"></pre><B>[LISTING FOUR]</B><pre><a name="02a9_0022">

#if VMS
extern int  binary_search_sorted_data_base( char * );
extern void build_box_parts( int );
extern int  build_the_data_base( char * );
extern void check_for_new_page( void );
extern int  doprint( int );
extern void nasty( int );
extern void process_arguments( int, int, char **, int );
extern void scan_for_static_or_global( int *, int, char *, char * );
extern void tab_to_left_margin( FILE * );

static void allocate_arrays( void );
static void build_records_from_list( FILE * );
static void bump_line_count( void );
static void count_all_defined_references( void );
static void deallocate_arrays( void );
static void do_top_of_page( void );
static void initialize_globals( void );
static void show_files_leading_comments( void );
static void show_function_relationships( void );
static void show_library_functions( void );
static void show_line_and_byte_counts( void );
static void show_page_references( void );
static void show_sorted_function_list( void );
static void show_unused_if_any( void );
static void sort_the_data_base_array( void );
static char* strdup( char * );
static void timedate( char * );
       int  main( int, char ** );
#endif

#if MSDOS
extern int  near binary_search_sorted_data_base( char * );
extern void near build_box_parts( int );
extern int  near build_the_data_base( char * );
extern void near check_for_new_page( void );
extern int  near doprint( int );
extern void near nasty( int );
extern void near process_arguments( int, int, char **, int );
extern void near scan_for_static_or_global( int *, int, char *, char * );
extern void near tab_to_left_margin( FILE * );

static void near allocate_arrays( void );
static void near build_records_from_list( FILE * );
static void near bump_line_count( void );
static void near count_all_defined_references( void );
static void near deallocate_arrays( void );
static void near do_top_of_page( void );
static void near initialize_globals( void );
static void near show_files_leading_comments( void );
static void near show_function_relationships( void );
static void near show_library_functions( void );
static void near show_line_and_byte_counts( void );
static void near show_page_references( void );
static void near show_sorted_function_list( void );
static void near show_unused_if_any( void );
static void near sort_the_data_base_array( void );
static char* near strdup( char * );
static void near timedate( char * );
       int  near main( int, char ** );
#endif






<a name="02a9_0023"><a name="02a9_0023">
<a name="02a9_0024"></pre><B>[LISTING FIVE]</B><pre><a name="02a9_0024">

#if MSDOS
static void near bump_line_count( )
#else
static void bump_line_count( )
#endif





<a name="02a9_0025"><a name="02a9_0025">
<a name="02a9_0026"></pre><B>[LISTING SIX]</B><pre><a name="02a9_0026">

#if MSDOS
#include &lt;malloc.h&gt;
#include &lt;conio.h&gt;
#include &lt;stdlib.h&gt;
#endif

#include &lt;ctype.h&gt;  /* this is for the 'tolower' function */
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;






<a name="02a9_0027"><a name="02a9_0027">
<a name="02a9_0028"></pre><B>[LISTING SEVEN]</B><pre><a name="02a9_0028">

#if MSDOS
#include &quot;time.h&quot;
#else
#include &lt;time.h&gt;
#endif





<a name="02a9_0029"><a name="02a9_0029">
<a name="02a9_002a"></pre><B>[LISTING EIGHT]</B><pre><a name="02a9_002a">

#if !MSDOS
char *strdup(orig)
char *orig;
{
   char *ptr;

   ptr = (char *) malloc( (strlen(orig) * sizeof(char)) + 1);

   if(ptr != NULL)
   {
      strcpy(ptr,orig);
   }

   return(ptr);
}
#endif





<a name="02a9_002b"><a name="02a9_002b">
<a name="02a9_002c"></pre><B>[LISTING NINE]</B><pre><a name="02a9_002c">

   timedate(title);





<a name="02a9_002d"><a name="02a9_002d">
<a name="02a9_002e"></pre><B>[LISTING TEN]</B><pre><a name="02a9_002e">

/************************************************************/
#if !MSDOS
static void timedate(ret_time)
char *ret_time;
{
  struct tm *time_structure;
  int time_val, i;
  static char *hour[2] = {&quot;am&quot;,&quot;pm&quot;};
  char temp[19];

  time(&amp;time_val);
  time_structure = localtime(&amp;time_val);

  i = 0;
  if((time_structure-&gt;tm_hour &gt;= 12)&amp;&amp;(time_structure-&gt;tm_hour&lt;24)) i=1;

  if(time_structure-&gt;tm_hour &gt; 12)
      time_structure-&gt;tm_hour = (time_structure-&gt;tm_hour)-12;
  sprintf(temp,&quot;%d/%d/%d  %d:%02d %s&quot;,
              time_structure-&gt;tm_mon,
              time_structure-&gt;tm_mday,
              time_structure-&gt;tm_year,
              time_structure-&gt;tm_hour,
              time_structure-&gt;tm_min,
              hour[i]);
  i=0;
  while(temp[i]!='\0')
  {
     ret_time[i] = temp[i];
     i++;
  }
}
#endif

#if MSDOS
static void near timedate(ret_time)
char *ret_time;
{
  char *cp;
  int i;

  cp = &amp;ret_time[ 0 ];     /* insert date and nice time into ret_time */
  (void)_strdate( cp );
  ret_time[ 8 ] = ' ';
  cp = &amp;ret_time[ 10 ];
  (void)_strtime( cp );

  ret_time[ 15 ] = ' ';   /* knock off seconds */
  ret_time[ 16 ] = ' ';   /* put am, pm here */
  ret_time[ 17 ] = 'm';
  ret_time[ 18 ] = ' ';

  i = atoi( &amp;ret_time[ 10 ] );   /* f/ military to civilian time */
  ret_time[ 16 ] = ( i &lt; 12 )? (char)'a': (char)'p';

  if( i == 0 )
     i = 12;
  if( i &gt;= 13 )
     i -= 12;

  (void)sprintf( &amp;ret_time[ 10 ], &quot;%2d&quot;, i );
  ret_time[ 12 ] = ':';

  if( ret_time[ 10 ] == '0' )
     ret_time[ 10 ] = ' ';
}
#endif

/************************************************************/





<a name="02a9_002f"><a name="02a9_002f">
<a name="02a9_0030"></pre><B>[LISTING ELEVEN]</B><pre><a name="02a9_0030">

      if(islower((int)argv[i][1]))
    c = argv[i][1];
      else
    c = (char)tolower( (int)argv[ i ][ 1 ] );





<a name="02a9_0031"><a name="02a9_0031">
<a name="02a9_0032"></pre><B>[LISTING TWELVE]</B><pre><a name="02a9_0032">

   if( strcmp(argv[2],&quot;con&quot;) == 0)
      output = stderr;
   else
      output = fopen( argv[ 2 ], &quot;w+&quot; );     /******* wt+ &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; ******/






<a name="02a9_0033"><a name="02a9_0033">
<a name="02a9_0034"></pre><B>[LISTING THIRTEEN]</B><pre><a name="02a9_0034">

   (void)printf( &quot;\n can't open output file.\n&quot;);





<a name="02a9_0035"><a name="02a9_0035">
<a name="02a9_0036"></pre><B>[LISTING FOURTEEN]</B><pre><a name="02a9_0036">

if( (length &gt; 65535) &amp;&amp; (MSDOS) )





<a name="02a9_0037"><a name="02a9_0037">
<a name="02a9_0038"></pre><B>[LISTING FIFTEEN]</B><pre><a name="02a9_0038">

$ CC/PREPROCESS_ONLY CP.C
$ CC/PREPROCESS_ONLY CPBUILD.C
$ CC/PREPROCESS_ONLY CPINPUT.C
$ CC/PREPROCESS_ONLY CPFUNCTS.C
$ CC/PREPROCESS_ONLY CPHEADER.H





<a name="02a9_0039"><a name="02a9_0039">
<a name="02a9_003a"></pre><B>[LISTING SIXTEEN]</B><pre><a name="02a9_003a">

cc -E cp.c &gt;cp.i
cc -E cpbuild.c &gt;cpbuild.i
cc -E cpinput.c &gt;cpinput.i
cc -E cpfuncts.c &gt;cpfuncts.i
cc -E cpheader.h &gt;cpheader.i





<a name="02a9_003b"><a name="02a9_003b">
<a name="02a9_003c"></pre><B>[LISTING SEVENTEEN]</B><pre><a name="02a9_003c">

cp.i
cpinput.i
cpbuild.i
cpfuncts.i
cpheader.h






<a name="02a9_003d"><a name="02a9_003d">
<a name="02a9_003e"></pre><B>[LISTING EIGHTEEN]</B><pre><a name="02a9_003e">

#define  LEN_INFILE  256







<a name="02a9_003f"><a name="02a9_003f">
<a name="02a9_0040"></pre><B>[LISTING NINETEEN]</B><pre><a name="02a9_0040">

char input_list_filename[ LEN_INFILE ], input_line[ LEN_INFILE ];
char overlay_number[ LEN_INFILE ];





<a name="02a9_0041"><a name="02a9_0041">
<a name="02a9_0042"></pre><B>[LISTING TWENTY]</B><pre><a name="02a9_0042">

fgets( input_line, LEN_INFILE-1, stream );   /* ends at \n or eof */





<a name="02a9_0043"><a name="02a9_0043">
<a name="02a9_0044"></pre><B>[LISTING TWENTY-ONE]</B><pre><a name="02a9_0044">

Replaces line 20 of Listing Five

   *top_line_of_box, *bottom_line_of_box,





<a name="02a9_0045"><a name="02a9_0045">
<a name="02a9_0046"></pre><B>[LISTING TWENTY-TWO]</B><pre><a name="02a9_0046">

Replaces lines 73 thru 75 of Listing Five

if( !( top_line_of_box =(char *)malloc( defined_box_width * sizeof(char) ))
  )
{
   (void)fprintf( stderr, &quot;Ran out of memory for top line of box.\n&quot; );
   exit( 1 );
}

if( !( bottom_line_of_box =(char *)malloc( defined_box_width * sizeof(char) ))
  )
{
   (void)fprintf( stderr, &quot;Ran out of memory for bottom line of box.\n&quot; );
   exit( 1 );
}

top_line_of_box[ 0 ] = upper_left_corner;
bottom_line_of_box[ 0 ] = lower_left_corner;
for( i = 1; i &lt;= (defined_box_width - 3); ++i )





<a name="02a9_0047"><a name="02a9_0047">
<a name="02a9_0048"></pre><B>[LISTING TWENTY-THREE]</B><pre><a name="02a9_0048">

Replaces lines 215 and 216 of Listing Five

                name_of_file,
                description,






<a name="02a9_0049"><a name="02a9_0049">
<a name="02a9_004a"></pre><B>[LISTING TWENTY-FOUR]</B><pre><a name="02a9_004a">

Replaces lines 228 thru 274 of Listing Five

unsigned int string_length;
int x;
static char alternate_lead_in[ 140 ];

/******* 1st line *****************************************************/
tab_to_left_margin( output );
(void)fprintf( output, &quot;%s %s\n&quot;, lead_in_string, top_line_of_box );

/******* 2nd line ******************************************************/
tab_to_left_margin( output );
string_length = strlen( lead_in_string );
if( string_length )    /******* ie not main or defined function box ***/
   {
   (void)strncpy( alternate_lead_in, lead_in_string, --string_length );
   alternate_lead_in[ string_length++ ] = '\0'; /*restore string_length*/
   }
if( string_length )   /******* ie not main or defined function box ***/
   {
   if( g_ov_flag &amp;&amp; ov_num )
      {
      (void)fprintf( output, &quot;%s%c%c%c%s %3d&quot;,
           alternate_lead_in,
      /***  if( kill_flag )   /****** last line to this box ******************/
      /***  else         /****** line continues downwards ***************/
           ( kill_flag )? lower_left_corner: right_attach,
           ibm_line, left_attach, name_of_function, ov_num);
      for(x=strlen(name_of_function);x &lt; defined_box_width-7;x++)
    putc(' ',output);
      putc(wall,output);
      putc('\n',output);
      }
   else
      {
      (void)fprintf( output, &quot;%s%c%c%c%s    &quot;,
           alternate_lead_in,
      /***  if( kill_flag )   /****** last line to this box ******************/
      /***  else         /****** line continues downwards ***************/
           ( kill_flag )? lower_left_corner: right_attach,
           ibm_line, left_attach, name_of_function);
      for(x=strlen(name_of_function);x &lt; defined_box_width-7;x++)
    putc(' ',output);
      putc(wall,output);
      putc('\n',output);
      }
   }
else           /****** main or defined box starting ***********/
   {
   if( g_ov_flag &amp;&amp; ov_num )
      {
      (void)fprintf( output,    &quot;%c%c%s %3d&quot;,
           ibm_line, left_attach, name_of_function, ov_num);
      for(x=strlen(name_of_function);x &lt; defined_box_width-7;x++)
    putc(' ',output);
      putc(wall,output);
      putc('\n',output);
      }
   else
      {
      (void)fprintf( output,    &quot;%c%c%s    &quot;,
           ibm_line, left_attach, name_of_function);
      for(x=strlen(name_of_function);x &lt; defined_box_width-7;x++)
    putc(' ',output);
      putc(wall,output);
      putc('\n',output);
      }
   }
/******* 3rd line *****************************************************/
tab_to_left_margin( output );
if( string_length-- )    /** kill outside vertical line on last box **/
   lead_in_string[ string_length++ ] = ( kill_flag )? (char)' ': wall;
(void)fprintf( output, &quot;%s %c%s   %8s%3d&quot;,
          lead_in_string, wall,  name_of_file, description, either_count);
   for(x=strlen(name_of_file);x &lt; defined_box_width-17;x++) putc(' ',output);
   putc(wall,output);
   putc('\n',output);





<a name="02a9_004b"><a name="02a9_004b">
<a name="02a9_004c"></pre><B>[LISTING TWENTY-FIVE]</B><pre><a name="02a9_004c">

Insert between 109 and 110 of Listing One

   defined_box_width =      40,





<a name="02a9_004d"><a name="02a9_004d">
<a name="02a9_004e"></pre><B>[LISTING TWENTY-SIX]</B><pre><a name="02a9_004e">

Insert between 160 and 161 of Listing One

extern int defined_box_width;





<a name="02a9_004f"><a name="02a9_004f">
<a name="02a9_0050"></pre><B>[LISTING TWENTY-SEVEN]</B><pre><a name="02a9_0050">

Replaces lines 20 through 25 of Listing Three

    &quot;     /p:nn /w:nn /m:nn /r:nn /t:main /f:nnnn /b:nn\n&quot;
          );
   (void)printf(
   &quot;     /l /n /s /q /d /o /u /c /h /x\n&quot;
          );
   (void)printf(   &quot;                        ]\n&quot; );






<a name="02a9_0051"><a name="02a9_0051">
<a name="02a9_0052"></pre><B>[LISTING TWENTY-EIGHT]</B><pre><a name="02a9_0052">

Insert between 45 and 46 of Listing Three

   (void)printf(
   &quot;     b: width of func. box  = %2d    [ 20 - 255 ]\n&quot;, defined_box_width
          );





<a name="02a9_0053"><a name="02a9_0053">
<a name="02a9_0054"></pre><B>[LISTING TWENTY-NINE]</B><pre><a name="02a9_0054">

Insert between 155 and 156 of Listing Three


        case 'b':
           if( ( 20 &lt; tmp ) &amp;&amp; ( tmp &lt; 255 ) )
         defined_box_width = tmp;
           break;






<P>
<P>
</pre><HR><P>Copyright &copy; 1989, <I>Dr. Dobb's Journal</I></P></BODY></HTML>
