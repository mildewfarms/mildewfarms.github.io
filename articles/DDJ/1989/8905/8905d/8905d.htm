<HTML>
<META NAME="year" CONTENT="1989">
<HEAD>

<TITLE>MAY89: TAWK: A SIMPLE INTERPRETER IN C++</TITLE></HEAD>
<body bgcolor="FFFFFF">
<h1>TAWK: A SIMPLE INTERPRETER IN C++<a name="00f0_0003"><a name="00f0_0003"></h1><P>
<h2><a name="00f0_0001"><a name="00f0_0000">The data-encapsulation features of C++ prove useful when reading and writing records</h2><P>
<h3>Bruce Eckel</h3><P>
<p><i><a name="00f0_0002"><a name="00f0_0000">Bruce Eckel is a C++ consultant and owner of Eisys Consulting.  He has been writing for Micro Cornucopia for two and a half years.  This article is adapted from his book Using C++ (Osborne/ McGraw-Hill, 1989).  Bruce may be contacted at Eisys Consulting, 501 N. 36th St., Ste. 163, Seattle, WA 98103.</i></p><hr><P>
Most microcomputer database management systems (DBMSs) read and write records in a &quot;comma-separated ASCII&quot; format.  This is probably an artifact from the days when Basic (which uses that format) was the only common tongue on microcomputers.  Comma-separated ASCII files are useful not only because they allow the records from one DBMS to be moved to another, but also because they can be manipulated by using programming languages.<P>
While Basic automatically reads and writes these records, other languages must be programmed to do so.  In C++, this tedious task can be encapsulated into several classes; the user of the class doesn't need to worry about the details.  In the first part of this article, two classes are created.  The first, class field, reads a single quoted and comma-separated field and makes an object from that field.  The second, class csascii, opens a comma-separated ASCII file and reads records (as arrays of field objects) one at a time, until the file ends.  A simple application that uses the classes to search through a data-base file for a last name is presented.<P>
Database files must often be manipulated or output in an organized way as a &quot;report.&quot;  It becomes tedious and problematic to write and compile code for each different report since nonprogrammers must often design reports.  A common solution to a problem such as this is the creation of a &quot;scripting language&quot; specifically tailored to the task at hand.  The second part of this article is the creation of a simple language that outputs the records (to standard output) in a comma-separated ASCII file according to a script in a separate file.<P>
The program is called TAWK for &quot;tiny awk,&quot; since the problem it solves is vaguely reminiscent of the &quot;awk&quot; pattern-matching language found on Unix (versions have also been created for DOS).  It demonstrates one of the thornier problems in computer science: parsing and executing a programming language.  The data-encapsulation features of C++ prove most useful here, and a recursive-descent technique is used to read arbitrarily long fields and records.<P>
The code was developed and tested on a DOS system.  It compiles with Zortech C++ or the Glockenspiel/Advantage translator used with Microsoft C.  The programs should also work on Unix, because all library calls are ANSI C and the only class used that is not defined here is the streams class (which is included with every C++ package).  The simple screen-manipulation commands (clear screen, reverse video) assume an ANSI terminal or a PC with ANSI.SYS loaded.<P>
<h3><a name="00f0_0004">Object-Oriented Terminology<a name="00f0_0004"></h3><P>
When discussing object-oriented programming, it is helpful to review some of the terminology. Object-oriented programming means &quot;sending messages to objects.&quot;  In traditional languages, data is declared and functions act directly on the data.  In object-oriented programming, objects are created, messages are sent to the objects, and the objects decide what to do with the message (in other words, how to act on their internal data).<P>
An object is an entity with internal state (data) and external operations, called member functions in C++.  &quot;Sending a message&quot; means calling one of these member functions.<P>
An important reason for organizing a program into distinct objects is the concept of encapsulation.  When data is encapsulated in an object, it is hidden away (private) and can only be accessed by way of a clearly defined interface.  Only class member functions and friend functions may modify private data.  Data encapsulation can clarify code by combining data in a single package with specific legal operations (member functions).  Data encapsulation is also useful in preventing bugs -- a working class doesn't break simply because it is used in a new program.<P>
<h3><a name="00f0_0005">Virtual Functions<a name="00f0_0005"></h3><P>
Object-oriented purists will notice this program does not use late binding (by way of C++ virtual functions) and thus is not object-oriented in the Smalltalk sense.  When a message is sent to an object in Smalltalk, the object always decides what to do with the message (that is, the specific function to call) at run time, so the function address isn't bound to the function call until the call is actually made.  Because most compilers bind function calls during compilation, run-time binding is often called late binding.<P>
C++ always performs binding at compile time, unless the programmer specifically instructs the compiler to wait until run time by using the virtual keyword.  This feature allows subclasses (all inherited from the same base class) to have identical function calls that are executed differently.  A collection of generic objects (all of the same base class) can be maintained and all the &quot;legal&quot; messages for the base class may be sent to any of the objects in that collection.  The object figures out what to do with the message according to what specific subclass it is.  This is object-oriented programming in its true sense.<P>
Most problems can benefit from the data-encapsulation features of C++.  It seems, however, that not every problem demands virtual functions.  The project presented here is one of those cases.  For an example of the use of virtual functions, see my article &quot;Building MicroCAD&quot; in the November/December 1988 issue of Micro Cornucopia (also available as part of C++ source code library disk #1, available from Eisys Consulting for $15).<P>
<h3><a name="00f0_0006">Reading C++ Code<a name="00f0_0006"></h3><P>
If you are a C programmer, here's a simple way to think about C++ while you are reading the code for this article: Objects look like structures, with a few bells and whistles.  One bell is that you can hide some of the structure members--members are automatically hidden (private) unless you explicitly state they are public.  A whistle is the ability to include functions as members of the struct.  Members of a class (a user-defined type) are accessed just as you would access members of a struct--with a dot (or an arrow, if you have a pointer to an object).  One more whistle is that the programmer can define the way the objects are initialized (by using the constructor) when they come into scope, and cleaned up (by using the destructor) when they go out of scope.<P>
<a href="8905d.htm#00f0_0007">Example 1</A> shows a tiny class to introduce you to the basics of C++ programming.  class declarations are generally contained in header files with the extension .hxx.  Definitions are generally contained in files with the extension .cxx.  The AT&amp;T Unix C++ chose the unfortunate extension of .C for definitions, and .h for declarations.  This is fine on Unix, which is case-sensitive, but causes problems while in DOS.  Walter Bright's Zortech C++ compiler originally used .cpp.  He later modified it to allow .cxx, which is the style the Glockenspiel translator (previously marketed by Lifeboat as Advantage C++) uses.  I use the .cxx format because it works with both products.<P>
<h4><a name="00f0_0007"><a name="00f0_0007"><B>Example 1:</B> A C++ class</h4><P>
<pre>
  class tiny {
    // private stuff here (this is a comment)
    int i;
  public: // public stuff here:
   print () { // an &quot;in-line&quot; function
     printf (&quot;i = %d\n&quot;, i);
   }
   tiny (int j); // constructors have the class name
   tiny() {} // destructors use a tilde
  }; // classes end with a brace and a semicolon

  tiny::tiny (int j) { // non inline definition
    i = j;
  }

  main() {
    tiny A(2); // implicit constructor call
    // A.i = 30; // error! private member
    A.print (); // calling a member function
    // implicit destructor call at end of scope
    }</pre><P>
<P>
<h3><a name="00f0_0008">The Streams Class<a name="00f0_0008"></h3><P>
The streams class used here is an extremely useful class developed by Bjarne Stroustrup (the inventor of the language) to handle input/output.  It defaults to standard input and standard output (the cin and cout objects, automatically defined when you include the stream.hxx header file), but can also be used to read and write files.  A buffer can even be made into a stream object, and the same operations can be performed on that object.<P>
The most complete written reference available for the streams class is chapter 8 of Stroustrup's The C++ Programming Language (Addison-Wesley, 1986).  This chapter is not exactly an exhaustive example of streams.  One of the beauties of C++ is that you always have access to a description (often admittedly terse) of the operations available for that particular class -- the header file.  By studying the header file, you can often get ideas for new ways to use an object.  Zortech C++ also has library source code available, which includes valuable comments on the use of certain functions (that's how I figured out many features).<P>
Output in streams is accomplished with the operator you know from C as left shift.  C++ allows you to overload functions and operators to give them different meanings depending on their arguments.  When left shift is used with a stream object, it means &quot;put this stuff out to the stream.&quot;  <a href="8905d.htm#00f0_0009">Example 2</A> lists a short program to show the use of streams.  Notice how streams allow you to string together a series of output statements.<P>
<h4><a name="00f0_0009"><a name="00f0_0009"><B>Example 2:</B> The use of streams</h4><P>
<pre>
  # include &lt;stream.hxx&gt; // cout automatically defined
  main() {
    cout &lt;&lt; &quot;Hello, world!\n&quot; &lt;&lt; &quot;I am&quot;
         &lt;&lt; 6 &lt;&lt; &quot;today!\n&quot;;</pre><P>
<P>
<h3><a name="00f0_000a">Recursive Descent<a name="00f0_000a"></h3><P>
A recursive descent algorithm is useful if you don't know how long or complicated a statement will be when you start looking at it.  In programming languages, for example, recursive descent parsers are often used in expression evaluation, because expressions can contain other expressions.  In this project, the expressions aren't particularly complicated, but we don't know how long a string of text is going to be.<P>
A central function is used when scanning an expression using recursive descent.  This function munches along and absorbs input until it runs into a delimiter that indicates a change in the type of input (white space, for example, or a number).  At this point, it might call another function to eat the white space or to get a string of digits and turn it into a number.  Then, if the expression is finished, it will just return.  If the expression isn't finished (and here's the tricky part), it calls itself (that is, it recurses).  Every time it encounters a new expression within the one it's evaluating, it recurses to evaluate the expression.<P>
When solving more complex problems (such as a programming language), a set of functions is used.  Each function may call any of the others during expression evaluation.<P>
At some point, the evaluation must bottom out.  When this happens, the function performs some termination activities and then returns.  As the stack unwinds from all the recursive calls, the tail end of each function call performs some operation to store the information it was able to glean, and then it returns.  When the function finally completes, the expression has been evaluated.<P>
Recursive descent is used in three places in this project.  The field class, which creates an object containing a single quote-delimited field, has a recursive function field::getfield() (shown in <a href="8905d.htm#00f0_001b">Listing Two</A>) to read one character at a time, keeping track of the number of characters encountered, until the end of the field.  When the closing quotation mark is encountered, memory is allocated for exactly the right number of characters and the function returns.  As it unwinds, characters are placed in the object's data buffer.  Using recursive descent means no restrictions are imposed on the field size (other than stack space).<P>
The token class uses recursive descent in a more sophisticated way.  When a token object is created by handing it an input stream (by way of the constructor function token::token(istream &amp; input)), it reads the input stream until it has scanned a complete token.  When the constructor completes, a new token has been created.<P>
A token is a group of symbols that represent a single concept.  A C++ compiler uses a large number of tokens: { means begin a scope, for means start a for loop, foo means a variable. TAWK has a much smaller number of tokens.  All tokens in TAWK are delimited by the &quot;@&quot; sign, which starts a new command.  When &quot;@&quot; is encountered, it is pushed back onto the input stream (for use in the next token object) and the current token is completed.  The central recursive-descent function for token is token::get_token(), shown in <a href="8905d.htm#00f0_0025"> Listing Seven</A>.<P>
The class parse_array builds an array of tokens by recursively calling parse_array::build_array() (shown in <a href="8905d.htm#00f0_0025">Listing Seven</A>).  This function makes a new token, then looks at the token to decide what to do next.  The two programs (LOOKUP and TAWK) are built from several classes.  Each of these classes will be examined.<P>
<h3><a name="00f0_000b">The Class Field<a name="00f0_000b"></h3><P>
The declaration of the field class is shown in <a href="8905d.htm#00f0_0019">Listing One</A> and the definitions are in <a href="8905d.htm#00f0_001b">Listing Two</A>.  The field object doesn't control opening or closing files.  It is simply handed an istream from which it takes its input.  If it finds the end of input, it just makes an internal note (by setting its end_of_file flag) and returns.  It's up to the caller to check for end-of-file with the function field::eof().<P>
The operator&lt;&lt;() is overloaded so that a field object may be put to a stream output object. When this occurs, the data field is copied to the output.<P>
The field constructor field::field (istream &amp; instream) initializes all the variables to zero and sets the member istream * input equal to instream.  This allows field::getfield() to treat input as a global variable and to simply get the next character.  The last thing the constructor does is call the recursive-descent function field::getfield(), which recurses until it reaches the end of the field.  When the constructor finishes, the field is complete.<P>
The function field::getfield() reads a character from the input stream.  If it isn't an end-of-file character, it checks for terminators, which include a comma if not enclosed by quotation marks (determined by a special flag infield) or a carriage return, which delimits the entire record.  If no terminator is found, the function counts the current character and calls itself to get the next character.  If a terminator is found, memory is allocated to hold the string (using the C++ dynamic-memory allocation keyword new) and the string terminator \ 0 is inserted.  As the function returns from calling itself, each character is inserted, from right to left, into the buffer.<P>
Memory is not always allocated for a field.  The constructor for a field object sets the data pointer to zero.  If memory is never allocated, the destructor will delete a null pointer, which is defined to have no effect.<P>
<h3><a name="00f0_000c">The Class csascii<a name="00f0_000c"></h3><P>
The csascii (for comma-separated-AS-CII) class is shown in <a href="8905d.htm#00f0_001d">Listings Three</A> (the declaration) and <a href="8905d.htm#00f0_001f">Four</A> (the definition).  The constructor opens the input file, counts the number of fields in a record, and closes the file.  It then creates an array of pointers to field objects, reopens the file and reads in the first record.  Every time csascii::next() is called, a new record is read until the end of the file.<P>
The operator[]() is overloaded so the individual fields may be selected from each record. This function checks to ensure that the index is within bounds.<P>
The method of opening files should be examined here.  The line  istream   infile(new filebuf&gt;open (filename,                             input));  is a succinct way to create a buffer and open a file.  The new filebuf creates a filebuf object (necessary to open a file as an istream) on the free store and returns a pointer to this object.  The pointer is used to call a member function, filebuf::open().  The pointer is also handed to the constructor of istream to create an object called infile.<P>
This is a clever piece of code, and nice for quick programming -- I got it from the Glockenspiel/Advantage manual, so I suspect it's something John Carolan cooked up. Unfortunately, it isn't robust unless you know that the file exists.  If the file doesn't exist on DOS machines, the system locks up.<P>
A more robust way to open the files in this program is to replace the previous code with the code in <a href="8905d.htm#00f0_000d">Example 3</A>.  Notice that in csascii::csascii(), the file is closed implicitly by putting braces around the first clause in the constructor where the fields are counted.  When the istream object goes out of scope, the file is closed.  This is the only purpose for putting the braces there.  Anytime you want to control the destruction of a local variable, simply put it in braces.<P>
<h4><a name="00f0_000d"><a name="00f0_000d"><B>Example 3:</B> Opening files</h4><P>
<pre>
  &quot;Ball&quot;, &quot;Mike&quot;, &quot;Oregon Software C++ Compiler&quot;
  &quot;Bright&quot;, &quot;Walter&quot;, &quot;Zortech C++ Compiler&quot;
  &quot;Carolan&quot;, &quot;John&quot;, &quot;Glockenspiel C++ Translator&quot;
  &quot;Stroustrup&quot;, &quot;Bjarne&quot;, &quot;AT&amp;T, C++ Creator&quot;
  &quot;Tiemann&quot;, &quot;Michael&quot;, &quot;Free Software Foundation C++ Compiler&quot;</pre><P>
<P>
<h3><a name="00f0_000e">Testing Field and csascii<a name="00f0_000e"></h3><P>
<a href="8905d.htm#00f0_0021">Listing Five</A> is a short program to show the use of class csascii. The csascii object file is created by giving it the name of the comma-separated ASCII file PPQUICK.ASC. (See <a href="8905d.htm#00f0_000f">Example 4</A> for a sample file.)  Then the records are read one at a time and field 0 is compared to the first argument on the command line (presumably the last name of the persons in the database).  When a record is found, it is displayed on the screen (notice the use of the ANSI screen-control codes).  A flag called found is set to indicate the least one record is found.  When no more matches occur, the program knows to exit (it is assumed the file has been sorted by the database manager).<P>
<h4><a name="00f0_000f"><a name="00f0_000f"><B>Example 4:</B> A sample comma-separated ASCII file PPQUICK.ASC</h4><P>
<pre>
  filebuf fl;
  if (fl. open(argv [1], input) == 0) {
     cout &lt;&lt; &quot;cannot open&quot; &lt;&lt; argv[1] &lt;&lt; &quot;\n&quot;;
     exit (1);
  }
  istream infile (&amp;fl);</pre><P>
<P>
The ANSI C library function strcmp() has been used here for compatibility.  To ignore uppercase or lowercase in the comparisons, Microsoft C provides strcmpi() and Zortech provides strcmpl().<P>
Notice how easy it is to use a class once it has been created.  One of the advantages of C++ is the ease of use of library functions.  (That is, when library functions become available!)<P>
<h3><a name="00f0_0010">TAWK<a name="00f0_0010"></h3><P>
<a href="8905d.htm#00f0_0011">Table 1</A> provides the complete syntax for the TAWK language.  You can see that each TAWK conmmand consists of an &quot;@&quot; sign and a single character (in the case of @() and @&lt;&gt;, the commands are @( and @&lt; and the ) and &gt; are used by the function that reads the number, to find the end).<P>
<h4><a name="00f0_0011"><a name="00f0_0011"><B>Table 1:</B> The TAWK syntax</h4><P>
<pre>
  TAWK: A Tiny database processor, vaguely like AWK

  usage: tawk tawkfile csafile
  where: csafile contains comma-separated ASCII records.  Each field in a
         record is contained in quotes, and each record is delimited by a
         newline.  These are standard records that can be generated by the
         Basic language and most database management systems.

         tawkfile is a file that contains formatting commands.  Each
         record in the csafile is read and fields in the record are
         printed out according to the formatting commands in the
         tawkfile.  Everything in the tawkfile (characters, spaces,
         newlines) is printed literally except for the following:

         @(n)            Print field number n; @(3) prints field 3 of the
                         current record.  The first field in a record is
                         field 0.

         @&lt;n&gt;            Print an ascii character number n; @&lt;27&gt; prints
                         the escape character

         @!              This line is a comment until the end of the line

         @?nn@:          (then statements) @ (else statements) @.  An
                         if-then-else conditional.  If field nn is not
                         empty, the then statements are executed, otherwise
                         the else statements are executed.  A conditional
                         must have all three parts, but the statements may
                         be empty.  Conditionals can be nested.

         @Preamble or    When a tawkfile is begun, all statements until
         @P or @p        @main are considered to be part of the
                         preamble.  The preamble is only executed once, at
                         the beginning of the program.  The preamble must
                         be strictly text; it cannot contain field numbers
                         or conditionals.  The @preamble statement is
                         optional; @preamble is assumed until @main.

         @main           The main section is executed once for each record
         or @M or @m     in the  file.  All statements between
                         @main and @conclusion are part of the main.
                         section.  @main may contain field numbers and
                         conditionals.  The @main statement is required.

         @conclusion     The conclusion is executed after the last record
         or @C or @c     in the database file is read and the file is
                         closed. The conclusion,
                         like the preamble, may only contain text.  All
                         other characters on the same line as @preamble,
                         @main, or @conclusion are ignored.  The
                         @conclusion statement is required.

         @end            This must be at the end of the tawkfile

         @@              Print an @ sign

  Example tawkfile:
  @! A comment, which isn't printed
  @! The @preamble is optional, but promotes understanding
  @main

        This is field 1:@(1)
        This is field 10:@(10)
        @?4@:@(4) @Field 4 is empty @.
        print an escape: @&lt;27&gt;
        Re-generate comma-separated ASCII record:</pre><P>
<P>
The execution of a tawkscript parallels the compilation or interpretation of other programming languages.  The tawkscript is parsed into arrays of tokens when the program starts up.  An execution routine steps through the arrays and performs actions based on the tokens to run the tawkscript.<P>
<a href="8905d.htm#00f0_0023">Listing Six</A> is the declaration for class token and class parse_array.  <a href="8905d.htm#00f0_0025">Listing Seven</A> contains the definitions.  <a href="8905d.htm#00f0_0027">Listing Eight</A> is the main() function for TAWK.  In <a href="8905d.htm#00f0_0027">Listing Eight</A> the tawkscript is parsed into three different parse_arrays, one each for the @preamble, @main, and @conclusion.  These arrays are executed using the database file as input.<P>
<h3><a name="00f0_0012">The Class token<a name="00f0_0012"></h3><P>
Each token must be a particular type.  The kind of information a token contains depends on what type it is.  In TAWK, the possible token types are as follows: a field number (for printing out a field or testing if a field is empty in an if statement), a string (simple text including nonprintable characters), parts of a conditional statement (if, else, and endif), or a phase change (which indicates a transition from @preamble to @main or @main to @conclusion).  Because a phase change is never executed but is simply used to terminate the creation of a parse_array, it isn't a token in the same sense, but some form of communication was necessary and this seemed the cleanest.<P>
The different types of tokens and phases are enumerated in the tokentype and phase declarations.  The phase information is kept by the main program, but each token contains a tokentype identifier.  Because a token can never be a field number and a string at the same time, the data container in a token is combined into an anonymous union (which is like a regular union only it has no name).  The union is used to save space.<P>
A token also contains information about the level of the if statement.  Because if statements can be nested, each token that is an if, else, or endif must have information about the nesting level.  If the conditional evaluates to false (that is, the field is empty), the interpreter must hunt through tokens in the parse_array until it finds the else statement at the same level, and continue executing statements from there.<P>
While token::get_token() is performing its recursive-descent scanning, it calls several other functions, which are made private because they aren't needed by the user. token::get_next() gets a character and tests for end-of-file (which is an error condition, because an @end statement should always terminate the tawkfile).  token::get_value() is used for the @() and @&lt;&gt; statements.  token::dumpline() is called for comments.<P>
<a href="8905d.htm#00f0_0025">Listing Seven</A> starts with a number of global variables that are declared static.  This means they cannot be accessed outside the file (this use of the static keyword is called file static).  When the constructor is called, it establishes the source of input characters (token-stream), sets the length of the string (which has been read so far) to zero, and begins the descent by calling token::get_token().<P>
The following are three possibilities in token::get_token():<P>
<ol>1.     The next character in the input stream is an @ and the length is zero.  This means you are at the beginning of a command and the next character will determine what the command is.  In this case, a large switch statement is executed.</ol><P>
<ol>2.     The next character is an @ and the length is not zero.  This means you are in the middle of a string and a command is starting.  In this case, the @ is pushed back on the input stream (for use by the next token), space is allocated for the string, and the unwinding of the stack is started with a return.</ol><P>
<ol>3.     The next character is not an @.  This means it must be plain text.  In this case, token::get_token() calls itself to get more characters.</ol><P>
<h3><a name="00f0_0013">The Class parse_array<a name="00f0_0013"></h3><P>
The class parse_array is a container class, because it is only used to contain objects of another class (token).  There is no way to know how many tokens a parse_array will contain, so the recursive approach is used again.  The constructor initializes some variables and calls the recursive function parse_array::build_array(), which keeps getting tokens and calling itself until a phase change or the end of the input (an @end statement).  At this point, it allocates space to hold all the tokens (which it has been counting during the descent) and ascends, storing a token on each function return.<P>
The individual tokens in a parse_array can be selected by using brackets ([]) because the bracket operator has been overloaded in parse_array: :operator[]().  Because token has a stream function defined, tokens can be put directly to cout.<P>
<h3><a name="00f0_0014">Executing a TAWKscript<a name="00f0_0014"></h3><P>
<a href="8905d.htm#00f0_0027">Listing Eight</A> shows the main() function for TAWK.  After the command-line arguments are checked, the tawkfile is opened and three parse_arrays are created: one for the @preamble, one for @main, and one for the @conclusion.  The second command-line argument is used to create a csascii object.<P>
At the beginning and end of the script execution, the preamble and conclusion parse_arrays are simply sent to standard output (cout).   Because they can only contain text, no other action is necessary.<P>
The central loop executes the statements in the @main phase for each record the csascii object reads from the database file.  After a record is read, the type of each token in parse_array Amain is used in a switch statement to choose the proper action.  Strings are sent to cout and fieldnumbers send the selected field to cout.<P>
If an if statement, if the selected field is empty in the current record, the parse_array index is incremented until the else token at the same level is found.  If the field is not empty, no action is taken (the following statements are executed).  When an else is encountered, it means the if evaluated to true, so the else clause is skipped over until the endif of the same level is found.<P>
<a href="8905d.htm#00f0_0029">Listing Nine</A> is a make-file to make all the examples in this project.<P>
<h3><a name="00f0_0015">Example TAWKscripts<a name="00f0_0015"></h3><P>
<a href="8905d.htm#00f0_002b">Listings Ten</A> and <a href="8905d.htm#00f0_002d">Eleven</A> show examples of tawkscripts.  <a href="8905d.htm#00f0_002b">Listing Ten</A> reformats a file with six fields into one with five fields, combining the last two fields.  If both of the last two fields are not empty, a space is inserted between them.<P>
<a href="8905d.htm#00f0_002d">Listing Eleven</A> shows the usefulness of the preamble and conclusion.  It creates a tiny telephone list (which I carry in my wallet) on an HP LaserJet printer.  The preamble and conclusion are used to send special control codes to the printer. The use of nested if-then-else statements is shown here: If field 3 exists, it is printed followed by a carriage return and a test to see if field 4 exists, which is printed with a linefeed if it does (nothing happens if it isn't).  If field 3 doesn't exist, field 4 is tested and printed with a linefeed (otherwise only a linefeed is printed).  When everything is completed a reset is sent to the LaserJet.<P>
If you want a further challenge, try adding a goto system to TAWK.  You will need to create a label command and a goto command.  gotos can be executed from if-then-else statements.<P>
<h3><a name="00f0_0016">Conclusion<a name="00f0_0016"></h3><P>
The main() program for TAWK is actually quite small for what it does.  Because the details are hidden in the csascii and parse_array objects, you can imagine creating a much more sophisticated program without losing control of the complexity.  This is typical of C++. Indeed, it was designed to allow one programmer to handle the same amount of code that previously required several programmers.  The compiler supports the creation of large projects by hiding initialization and cleanup, and by enforcing the correct use of user-defined types.<P>
<h3><a name="00f0_0017">Availability<a name="00f0_0017"></h3><P>
All source code for articles in this issue is available on a single disk.  To order, send $14.95 (Calif. residents add sales tax) to Dr. Dobb's Journal, 501 Galveston Dr., Redwood City, CA 94063; or call 800-356-2002 (from inside Calif.) or 800-533-4372 (from outside Calif.).  Please specify the issue number and format (MS-DOS, Macintosh, Kaypro).<P>
<h3><a name="00f0_0018">Products Mentioned<a name="00f0_0018"></h3><P>
Zortech C++ -- Zortech Inc. 1165 Massachusetts Ave. Arlington, MA 02174 800-848-8408 $149.95<P>
Glockenspiel C++ -- Glockenspiel (Available for DOS and OS/2) 2 Haven Ave. Port Washington, NY 11050 800-462-4374 $495 Includes Glockenspiel C++ for DOS, Glockenspiel C++ for OS/2, CommonView for MS Windows, CommonView for OS/2 PM, and source code for CommonView.<P>
Microsoft C 5.1 --Microsoft (For use with the Glockenspiel translator.<P>
Discounts available from other retailers) Box 97017 Redmond, WA 98073-9717 206-882-8080 $450<P>


_TAWK, A Simple Interpreter in C++_
by Bruce Eckel

<a name="00f0_0019"><a name="00f0_0019">
<a name="00f0_001a"></pre><B>[LISTING ONE]</B><pre><a name="00f0_001a">


// FIELD.HXX: used by csascii class to build a single field.
// Fields are collected by csascii to create a record.
// by Bruce Eckel,
#include &lt;stream.hxx&gt;

class field { // one field in a comma-separated ASCII record
  istream * input; // where to get the data
  char * data;
  int length, fsize;
  int end_of_file;  // flag to indicate the end of file happened
  void getfield();  // recursive function to read in a field;
           // treats data, length &amp; input as globals
  int infield; // flag used by getfield() to determine whether
        // it's inside a quoted field
 public:
  field(istream &amp; instream);
  ~field();
  friend ostream&amp; operator&lt;&lt;(ostream &amp;s, field &amp; f) {
    s &lt;&lt; f.data;
    return s;
  }
  int eof() { return end_of_file; }  // to check for end
  int size() { return fsize;}
  int last_length() {return length; }
  char * string() { return data; }
};





<a name="00f0_001b"><a name="00f0_001b">
<a name="00f0_001c"></pre><B>[LISTING TWO]</B><pre><a name="00f0_001c">

// FIELD.CXX: definitions for class field
// A &quot;recursive descent&quot; scanning scheme is used because field
// length is always unknown.
// by Bruce Eckel
#include &quot;field.hxx&quot;

field::field(istream &amp; instream) {
  input = &amp;instream;
  length = 0;
  end_of_file = 0; // set flag to say &quot;we're not at the end&quot;
  infield = 0; // set flag to say &quot;we're not inside a field&quot;
  data = (char *)0; // to show no memory has been allocated
  getfield();  // recursively get characters until end of field
}

field::~field() {
  delete data;  // if no memory has been allocated,
  // data = (char *)0 so this will have no effect.
}

// A Comma-separated ASCII field is contained in quotes to allow
// commas within the field; these quotes must be stripped out
void field::getfield() {
  char c;
  // This happens when DEscending:
  if((input-&gt;get(c)).eof() ) {
    end_of_file++;  // just say we reached the end...
    return;
  }
  else  // watch out for the Unix vs. DOS LF/CR problem here:
    if (((c != ',') || infield) &amp;&amp; (c != '\n')) {
      if ( (c != '&quot;') &amp;&amp; (c != '\r')) // watch for quotes or CR
        length++;  // no quotes -- count this character
      else {
        if ( c == '&quot;')
          infield = !infield;  // if we weren't inside a field
          // and a quote was encountered, we are now inside
          // a field.  If we were inside a field and a quote
          // was found, we're out of the field.
        c = 0; // a quote or CR; mark it so it isn't included
      }
      getfield();  // recursively get characters in field
      // after returning from function call, we jump past
      // the following &quot;else&quot; part to finish the recursion
    }
    else { // This happens once, when the terminator is found:
      fsize = length;  // remember how long the string is
      data = new char[length + 1]; // space for null terminator
      data[length] = '\0';  // highest index is &quot;length&quot;
        // when you allocate an array of length + 1
      length--;  // notice we don't insert the delimiter
      // Now the first &quot;if&quot; statement evaluates to TRUE and
      // the function rises back up.
      return;
    }
  // This happens when Ascending:
  if ( c ) // if it wasn't a quote or CR,
    data[length--] = c;  // put chars in as we rise back up...
}





<a name="00f0_001d"><a name="00f0_001d">
<a name="00f0_001e"></pre><B>[LISTING THREE]</B><pre><a name="00f0_001e">

// CSASCII.HXX: class to manipulate comma-separated ASCII
// database files.
//by Bruce Eckel
#include &lt;stream.hxx&gt;
#include &quot;field.hxx&quot;

class csascii {  // manipulates comma-separated ascii files,
// generated by most database management systems (generated and
// used by the BASIC programming language).  Each field
// is separated by a comma; records are separated by newlines.
  int fieldcount;
  field ** data; // an array to hold the entire record
  istream * datafile; // file with comma separated ASCII input
  int readrecord(); // private function to read a record
 public:
  csascii( char * filename );  // Open file, get first record
  ~csascii(); // destructor
  int next(); // get next record, return 0 when EOF
  field &amp; operator[](int index); // select a field
  int number_of_fields() { return fieldcount; }
};





<a name="00f0_001f"><a name="00f0_001f">
<a name="00f0_0020"></pre><B>[LISTING FOUR]</B><pre><a name="00f0_0020">

// CSASCII.CXX: function definitions for comma-separated
// ascii database manipulation class
// by Bruce Eckel,
#include &quot;csascii.hxx&quot;

int csascii::readrecord() {
  for (int fieldnum = 0; fieldnum &lt; fieldcount; fieldnum++ ) {
    data[fieldnum] = new field(*datafile);
    if (data[fieldnum]-&gt;eof()) return 0;
  }
  return 1;
}

csascii::csascii( char * filename ) {
  char c;
  fieldcount = 0;
  int quote = 0;
  // first, determine the number of fields in a record:
  {
    // See text for dangers of opening files this way:
    istream infile(new filebuf-&gt;open(filename, input));
    while(infile.get(c), c != '\n') {
      // keep track of being inside a quoted string:
      if (c == '&quot;') quote = !quote;
      // fields are delimited by unquoted commas:
      if ( c == ',' &amp;&amp; !quote)
        fieldcount++;
    }
  }  // infile goes out of scope; file closed
  fieldcount++; // last field terminated by newline, not comma
  // an array of field pointers:
  data = new field * [ fieldcount ];
  // re-open at start; dynamically allocate so it isn't scoped:
  datafile = new istream(new filebuf-&gt;open(filename, input));
  readrecord();
}

csascii::~csascii() {
  delete data;
  delete datafile; // calls istream destructor to close file
}

int csascii::next() {
  for (int i = 0; i &lt; fieldcount; i++ )
    delete data[i];  // free all the data storage
  return readrecord(); // 0 when end of file
}

field &amp; csascii::operator[](int index) {
  if (index &gt;= fieldcount) {
    cerr &lt;&lt; &quot;index too large for number of fields in record\n&quot;;
    exit(1);
  }
  return *(data[index]);
}





<a name="00f0_0021"><a name="00f0_0021">
<a name="00f0_0022"></pre><B>[LISTING FIVE]</B><pre><a name="00f0_0022">

// LOOKUP.CXX: simple use of csascii to find name in a database
// by Bruce Eckel,
#include &quot;csascii.hxx&quot;
#include &lt;string.h&gt;

main(int argc, char ** argv) {
  if (argc &lt; 2) {
    cerr &lt;&lt; &quot;usage: lookup lastname\n&quot;;
    exit(1);
  }
  // This puts the database file in the root directory:
  csascii file(&quot;\\ppquick.asc&quot;); // create object &amp; open file
  int found = 0;  // indicates one record was found
  do {
    if (strcmp(file[0].string(),argv[1]) == 0) {
      found++;  // found one.  File is sorted, so if we stop
      // finding them, quit instead of wasting time.
      cout &lt;&lt; chr(27) &lt;&lt; &quot;[2J&quot;; // ANSI clear screen
      for (int i = 0; i &lt; file.number_of_fields(); i++)
        cout &lt;&lt; file[i] &lt;&lt; &quot;\n&quot;;
      cout &lt;&lt; chr(27) &lt;&lt; &quot;[7m&quot; &lt;&lt; &quot;press any key&quot; &lt;&lt;
        chr(27) &lt;&lt; &quot;[0m&quot;;
      if( getch() == 27) break;
    }  else if (found) exit(0);  // quit if that was the last
  } while (file.next());
}





<a name="00f0_0023"><a name="00f0_0023">
<a name="00f0_0024"></pre><B>[LISTING SIX]</B><pre><a name="00f0_0024">


// PARSE.HXX: class to parse a tawk script file.  Creates
// a structure which can be used at run-time to &quot;execute&quot;
// the tawk script.
// by Bruce Eckel,
#include &lt;stream.hxx&gt;

// types of tokens the scanner can find:
enum tokentype {
  fieldnumber, string, if_, else_, endif_, phase_change
};

// preamble and conclusion of the tawk script are only executed
// once, while main is executed once for every data record
enum phase { preamble, tmain, conclusion};

class token {
  tokentype ttype;
  union {  // an &quot;anonymous union&quot;
    int fieldnum;  // if type is a fieldnumber
    unsigned char * literal; // if type is a string
  };
  int if_level;  // if this is an if_, then_, or else_
  // private functions:
  void get_token();  // recursive descent scanner
  // Functions to help in scanning:
  void getnext(char &amp; c); // used by get_token();
  unsigned char get_value(char delimiter, char * msg);
  void dumpline(); // for @! comments
  void error(char * msg = &quot;&quot;, char * msg2 = &quot;&quot;);
 public:
  token(istream &amp; input);
  ~token();
  friend ostream &amp; operator&lt;&lt;(ostream &amp;s, token &amp;t);
  int field_number() { return fieldnum; }
  int token_type() { return ttype; }
  int nesting_level() { return if_level;}
};

// The following is called a &quot;container class,&quot; since its sole
// purpose is to hold a list of objects (tokens, in this case):
class parse_array {
  token ** tokenarray; // an array of token pointers
  istream * parse_stream;
  int token_count;
  int end; // the size of the array
  phase p_section; // of the program (preamble, etc.)
  void build_array(); // another recursive function
 public:
  parse_array(istream &amp; input);
  ~parse_array();
  int size() { return end; } // how big is it?
  token &amp; operator[](int index); // select a token
  phase section() { return p_section; }
};





<a name="00f0_0025"><a name="00f0_0025">
<a name="00f0_0026"></pre><B>[LISTING SEVEN]</B><pre><a name="00f0_0026">

// PARSE.CXX: class parse function definitions
// by Bruce Eckel,
#include &quot;csascii.hxx&quot;
#include &quot;parse.hxx&quot;
#include &lt;ctype.h&gt;
#include &lt;stdlib.h&gt;

// The following are &quot;file static,&quot; which means no one outside
// this file can know about them.  This is the meaning when a
// global variable is declared &quot;static.&quot;
static istream * tokenstream;
static int length; // to remember size of string
static int line_number = 1;  // line counting for errors
static int if_counter = 0; // monitors &quot;if&quot; statement nesting
static phase program_section = preamble;  // ... until @main
static int end_of_file = 0; // zero means not end of file

token::token(istream &amp; input) {
  // initialize values and start the descent
  tokenstream = &amp;input;
  length = 0;
  get_token();  // recursively get characters to end of token
}

token::~token() { // delete heap if any has been allocated:
  if (ttype == string)
    delete literal;
}

void token::error(char * msg, char * msg2) {
  cerr &lt;&lt; &quot;token error on line &quot; &lt;&lt; line_number &lt;&lt; &quot;: &quot; &lt;&lt;
      msg &lt;&lt; &quot; &quot; &lt;&lt; msg2 &lt;&lt; &quot;\n&quot;;
  exit(1);
}

ostream &amp; operator&lt;&lt;(ostream &amp;s, token &amp;t) {
  switch (t.ttype) {
    case string:
      s &lt;&lt; (char *)t.literal;
      break;
    case fieldnumber: // only for testing
      s &lt;&lt; &quot; fieldnumber: &quot; &lt;&lt; t.fieldnum &lt;&lt; &quot;\n&quot;;
  }
  return s;
}

// Get a character from the tokenstream, checking for
// end-of-file and newlines
void token::getnext(char &amp; c) {
  if(end_of_file)
    error(&quot;attempt to read after @end statement\n&quot;,
       &quot;missing @conclusion ?&quot;);
  if((tokenstream-&gt;get(c)).eof() )
    error(&quot;@end statement missing&quot;);
  if (c == '\n')
    line_number++; // keep track of the line count
}

// See text for description of tokens
void token::get_token() {
  char c;
  // This happens when DEscending:
  getnext(c);
  if ( c == '@') {
    if (length == 0) { // length 0 means start of token
      getnext(c);
      switch(c) {
        case '!': // comment line
          dumpline(); // dump the comment
          get_token(); // get a real token
          break;
        case 'p' : case 'P' : // preamble statement
          if ( program_section != preamble )
            error(&quot;only one preamble allowed&quot;);
          dumpline(); // just for looks, ignore it
          get_token(); // get a real token
          break;
        case 'm' : case 'M' : // start of main loop
          dumpline(); // toss rest of line
          program_section = tmain;
          ttype = phase_change;
          return; // very simple token
        case 'c' : case 'C' : // start conclusion
          dumpline();
          program_section = conclusion;
          ttype = phase_change;
          return; // very simple token
        case 'e' : case 'E': // end statement
          end_of_file++;  // set flag
          ttype = fieldnumber; // so destructor doesn't
                    // delete free store for this token.
          if (if_counter)
            error(&quot;unclosed 'if' statement(s)&quot;);
          return;
        case '(' :
          if ( program_section == preamble ||
            program_section == conclusion )
           error(&quot;@() not allowed in preamble or conclusion&quot;);
          fieldnum = get_value(')',&quot;@()&quot;);
          ttype = fieldnumber;
          // This is a complete token, so quit
          return;
        case '&lt;' :
          c = get_value('&gt;',&quot;@&lt;&gt;&quot;);
          length++;
          get_token(); // get more...
          break;
        case '?' : // beginning of an &quot;if&quot; statement
          if ( program_section == preamble ||
            program_section == conclusion )
           error(&quot;@? not allowed in preamble or conclusion&quot;);
          fieldnum = get_value('@',&quot;@?@&quot;);
          ttype = if_;
          getnext(c);  // just eat the colon
          if(c != ':')
            error(&quot;@? must be followed by @: (then)&quot;);
          if_level = ++if_counter;  // for nesting
          return;
        case '~' : // the &quot;else&quot; part of an &quot;if&quot; statement
          ttype = else_;
          if_level = if_counter;
          return;
        case '.' : // &quot;endif&quot; terminator of an &quot;if&quot; statement
          ttype = endif_;
          if_level = if_counter--;
          if(if_counter &lt; 0)
            error(&quot;incorrect nesting of if-then-else clauses&quot;);
          return;
        case '@' : // two '@' in a row mean print an '@'
          length++;  // just leave '@' as the value of c
          get_token();
          break;
        default:
          error(&quot;'@' must be followed by:&quot;,
          &quot;'(', '&lt;', '?',':','~','.','p','m','c' or '@'&quot;);
      }
    } else { // an '@' in the middle of a string; terminate
      // the string.  Putback() is part of the stream class.
      // It is only safe to put one character back on the input
      tokenstream-&gt;putback(c); // to be used by the next token
      // allocate space, put the null in and return up the stack
      literal = new unsigned char[length + 1]; // space for '\0'
      literal[length--] = '\0'; // string delimiter
      ttype = string; // what kind of token this is
      return; // back up the stack
    }
  } else { // not an '@', must be plain text
    length++;
    get_token();
  }
  // This occurs on the &quot;tail&quot; of the recursion:
  literal[length--] = c;  // put chars in as we rise back up...
}

// This function is used by get_token when it encounters a @(
// or a @&lt; to get a number until it finds &quot;delimiter.&quot;
// If an error occurs, msg is used to notify the user what
// kind of statement it is.
unsigned char token::get_value(char delimiter, char * msg) {
  char c;
  char buf[5];
  int i = 0;
  while(getnext(c), c != delimiter) {
    if (!isdigit(c))
      error(&quot;must use only digits inside&quot;, msg);
    buf[i++] = c;
  }
  buf[i] = 0;
  return atoi(buf);
}

void token::dumpline() { // called when '@!' encountered
  char c;
  while(getnext(c), c != '\n')
    ; // just eat characters until newline
}

// Since there's no way to know how big a parse_array is
// going to be until the entire tawkfile has been tokenized,
// the recursive approach is again used:

parse_array::parse_array(istream &amp; input) {
  parse_stream = &amp;input;
  token_count = 0;
  p_section = program_section; // so we know at run-time
  build_array();
}

void parse_array::build_array() {
  token * tk = new token(*parse_stream);
  if( ! end_of_file &amp;&amp; tk-&gt;token_type() != phase_change) {
    // normal token, not end of file or phase change:
    token_count++;
    // recursively get tokens until eof or phase change:
    build_array();
  } else { // end of file or phase change
    // only done once per object:
    // allocate memory and return up the stack
    tokenarray = new token * [end = token_count];
    if(token_count) token_count--; // only if non-zero
    return;
  }
  tokenarray[token_count--] = tk;  // performed on the &quot;tail&quot;
}


parse_array::~parse_array() {
  for (int i = 0; i &lt; end; i++)
    delete tokenarray[i];
  delete tokenarray;
}

token &amp; parse_array::operator[](int index) {
  if ( index &gt;= end ) {
    cerr &lt;&lt; &quot;parse_array error: index &quot; &lt;&lt; index
      &lt;&lt; &quot; out of bounds\n&quot;;
    exit(1);
  }
  return *tokenarray[index];
}





<a name="00f0_0027"><a name="00f0_0027">
<a name="00f0_0028"></pre><B>[LISTING EIGHT]</B><pre><a name="00f0_0028">

// TAWK.CXX: parses a tawk script and reads an ascii file;
// generates results according to the tawk script.
// by Bruce Eckel,
#include &quot;csascii.hxx&quot;
#include &quot;parse.hxx&quot;

main (int argc, char * argv[]) {
  int screen = 0;  // flag set true if screen output desired
  if (argc &lt; 3) {
    cerr &lt;&lt; &quot;usage: tawk tawkfile datafile\n&quot; &lt;&lt;
        &quot;trailing -s pages output to screen&quot;;
    exit(1);
  }
  if (argc == 4) {
    if (argv[3][0] != '-') {
      cerr &lt;&lt; &quot;must use '-' before trailing flag\n&quot;;
      exit(1);
    } else
    if (argv[3][1] != 's') {
      cerr &lt;&lt; &quot;'s' is only trailing flag allowed&quot;;
      exit(1);
    } else
      screen++; // set screen output flag true
  }
  istream tawkfile(new filebuf-&gt;open(argv[1], input));
  parse_array Apreamble(tawkfile);  // the @preamble
  parse_array Amain(tawkfile);  // the @main section
  parse_array Aconclusion(tawkfile); // the @conclusion
  csascii datafile(argv[2]); // make a comma-separated ASCII
                             // object from the second arg
  // ------ @preamble  ------
  for (int i = 0; i &lt; Apreamble.size(); i++)
    cout &lt;&lt; Apreamble[i]; // preamble can only contain strings
  if(screen) {
    // ANSI reverse video sequence:
    cout &lt;&lt; chr(27) &lt;&lt; &quot;[7m&quot; &lt;&lt; &quot;press any key&quot; &lt;&lt;
      chr(27) &lt;&lt; &quot;[0m&quot;;
    getch();
  }
  // ------ The Central Loop (@main) -------
  do {  // for each record in the data file
    if(screen) cout &lt;&lt; chr(27) &lt;&lt; &quot;[2J&quot;; // ANSI clear screen
    for(int i = 0; i &lt; Amain.size(); i++) {
      switch(Amain[i].token_type()) {
        case fieldnumber:
          cout &lt;&lt; datafile[Amain[i].field_number()];
          break;
        case string:
          cout &lt;&lt; Amain[i];
          break;
        case if_:
          int fn = Amain[i].field_number();
          if (datafile[fn].size() == 0) { // conditional false
            int level = Amain[i].nesting_level();
            // find the &quot;else&quot; statement on the same level:
            while ( !(Amain[i].token_type() == else_
                &amp;&amp; Amain[i].nesting_level() == level))
                  i++;
          } // conditional true -- just continue
          break;
        case else_: // an &quot;if&quot; conditional was true so skip
          // all the statements in the &quot;else&quot; clause
          int level = Amain[i].nesting_level();
          // find the &quot;endif&quot; statement on the same level:
          while ( !(Amain[i].token_type() == endif_
              &amp;&amp; Amain[i].nesting_level() == level))
                i++;
          break;
        case endif_: // after performing the &quot;else&quot; clause
          break; // ignore it; only used to find the end
          // of the conditional when &quot;if&quot; is true.
        default: // should never happen (caught in parsing)
          cerr &lt;&lt; &quot;unknown statement encountered at run-time\n&quot;;
          exit(1);
      }
    }
    if(screen) {
      cout &lt;&lt; chr(27) &lt;&lt; &quot;[7m&quot; &lt;&lt;
        &quot;press a key (ESC quits)&quot; &lt;&lt; chr(27) &lt;&lt; &quot;[0m&quot;;
      if( getch() == 27) break;
    }
  } while (datafile.next()); // matches do { ...
  //  ------ @conclusion ------
  for ( i = 0; i &lt; Aconclusion.size(); i++)
    cout &lt;&lt; Aconclusion[i]; //conclusion contains only strings
}





<a name="00f0_0029"><a name="00f0_0029">
<a name="00f0_002a"></pre><B>[LISTING NINE]</B><pre><a name="00f0_002a">

# makefile for tawk.exe &amp; lookup.exe
# Zortech C++:
CPP = ztc
# Glockenspiel C++ w/ MSC 4:
#CPP = ccxx !4

all: tawk.exe lookup.exe

tawk.exe : tawk.obj parse.obj csascii.obj field.obj
        $(CPP)  tawk.obj parse.obj csascii.obj field.obj

lookup.exe : lookup.cxx csascii.obj field.obj
        $(CPP) lookup.cxx csascii.obj field.obj

tawk.obj : tawk.cxx parse.hxx csascii.hxx field.hxx
        $(CPP)  -c tawk.cxx

parse.obj : parse.cxx parse.hxx
        $(CPP)  -c parse.cxx

csascii.obj : csascii.cxx csascii.hxx field.hxx
        $(CPP)  -c csascii.cxx

field.obj : field.cxx field.hxx
        $(CPP)  -c field.cxx






<a name="00f0_002b"><a name="00f0_002b">
<a name="00f0_002c"></pre><B>[LISTING TEN]</B><pre><a name="00f0_002c">

@! REFORM.TWK
@! A tawk script to reformat a comma-separated ASCII file
@! with 6 fields.  This creates a new CS-ASCII file with
@! fields 4 and 5 combined.
@main
&quot;@(0)&quot;,&quot;@(1)&quot;,&quot;@(2)&quot;,&quot;@(3)&quot;,&quot;@(4)@?4@: @~@.@(5)&quot;
@conclusion
@end





<a name="00f0_002d"><a name="00f0_002d">
<a name="00f0_002e"></pre><B>[LISTING ELEVEN]</B><pre><a name="00f0_002e">


@! WALLET.TWK
@! Tawkfile to create a tiny phone listing for a wallet
@! on a Hewlett-Packard Laserjet-compatible printer
@! From a comma-separated ASCII file generated by a DBMS
@preamble
@&lt;27&gt;&amp;l5C@! approximately 10 lines per inch
@&lt;27&gt;(s16.66H@! small typeface, built into Laserjet
@main
@! last, first, (area code) phone1
@(0),@(1)(@(2))@?3@:@(3)
@ phone2, if it exists
@?4@:@(4)
@~@.@~@?4@:@(4)
@~
@.@.@conclusion
@&lt;27&gt;E @! Reset the Laserjet
@end

[EXAMPLE 1]

class tiny {
  // private stuff here (this is a comment)
  int i;
 public: // public stuff here:
  print() { // an &quot;in-line&quot; function
    printf(&quot;i = %d\n&quot;,i);
  }
  tiny(int j); // constructors have the class name
  ~tiny() {} // destructors use a tilde
};  // classes end with a brace and a semicolon

tiny::tiny(int j) { // non inline definition
  i = j;
}

main() {
  tiny A(2);  // implicit constructor call
  // A.i = 30; // error! private member
  A.print(); // calling a member function
  // implicit destructor call at end of scope
}





[EXAMPLE 2]


#include &lt;stream.hxx&gt; // cout automatically defined
main() {
  cout &lt;&lt; &quot;Hello, world!\n&quot; &lt;&lt; &quot;I am &quot;
       &lt;&lt; 6 &lt;&lt; &quot;today!\n&quot;;
}




[EXAMPLE 3]

filebuf f1;
if (f1.open(argv[1],input) == 0) {
  cout &lt;&lt; &quot;cannot open &quot; &lt;&lt; argv[1] &lt;&lt; &quot;\n&quot;;
  exit(1);
}
istream infile(&amp;f1);



[EXAMPLE 4]


&quot;Ball&quot;,&quot;Mike&quot;,&quot;Oregon Software C++ Compiler&quot;
&quot;Bright&quot;,&quot;Walter&quot;,&quot;Zortech C++ Compiler&quot;
&quot;Carolan&quot;,&quot;John&quot;,&quot;Glockenspiel C++ Translator&quot;
&quot;Stroustrup&quot;,&quot;Bjarne&quot;,&quot;AT&amp;T, C++ Creator&quot;
&quot;Tiemann&quot;,&quot;Michael&quot;,&quot;Free Software Foundation C++ Compiler&quot;





<P>
<P>
</pre><HR><P>Copyright &copy; 1989, <I>Dr. Dobb's Journal</I></P></BODY></HTML>
