<html><head><title>Mar00: Java Q&A</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Can You Write  NT Services in Java?</h1><p><i>Dr. Dobb's Journal</i> March 2000</p><h3>By Mike Jennings</h3><I>Mike is an independent consultant/developer in Victoria, BC. He can be reached at mjenning@islandnet.com.</I><hr><p>A service in Windows NT (or "daemon" in UNIX parlance) is a program that runs in the background to do a specific task. Typically, NT services do not interact directly with users, but instead perform a regularly scheduled task (such as automated file transfers or backups) or interact with client applications via the network (such as a web or ftp server).</p><p>After writing numerous NT services for clients in C++, I wondered if it is possible to write an NT service in Java. I was partly motivated by the prospect of not having to be so vigilant about memory management (an important issue for continuously running programs), since Java has automatic memory management (garbage collection). Just as attractive was the idea that any service I wrote in Java would -- almost by definition -- be able to run on any computer. </p><DDJADVERTISEMENT INLINE><p>Since Java is completely object oriented, I developed an object-oriented service framework in C++, so that I could easily map C++ service objects to a Java interface using the Java Native Interface (JNI). The source code for the service framework, along with an example service written using it, is available electronically; see "Resource Center," page 7.</p><h3>NT Services</h3><p>Because a service performs a unique task for a computer, there will only be one instance of the program running on a given computer (although services often spin off many threads to handle client requests).</p><p>An application can contain one or more services. For each service in the app, there must be a name unique to the service ("FTP," for instance) and a corresponding <i>ServiceMain</i> function. When an application containing one or more services is started by the operating system, it passes to the OS a list of the names of all of the services it supports along with the corresponding <i>ServiceMain</i> function of each service.</p><p>A <i>ServiceMain</i> function can have any name, but must be declared as in <A NAME="rl1"><A HREF="#l1">Listing One</A>. The first argument to the <i>ServiceMain</i> function is always the name of the service. The remaining arguments are optional and can be specified under the services applet in Control Panel.</p><p>The way in which this list of services and their associated <i>ServiceMain</i>s are passed to the OS is via the Win32 API call <i>StartServiceCtrlDispatcher(SERVICE_TABLE_ENTRY *list);</i>, where SERVICE_TABLE _ENTRY is a structure containing a pointer to a NULL terminated string containing the name of the service and another pointer that points to that service's <i>ServiceMain</i> function. The last entry in the list is followed by a SERVICE_TABLE_ENTRY whose members are all zero. Once <i>StartServiceCtrlDispatcher</i> is called by the app, the OS spins off a thread for each service specified in the list and calls each service's <i>ServiceMain</i> from each thread.</p><p>Inside each service's <i>ServiceMain</i>, a service registers a handler function for that service by calling <i>RegisterServiceCtrlHandler</i>, and passing it the name of the service and the address of the handler function. <i>RegisterServiceCtrlHandler</i> returns a service status handle, which is a handle that the service uses to refer to itself when it notifies the operating system of its current status (starting up, stopping, paused, and so on). The handler function can have any name, but must be declared, as in <A NAME="rl2"><A HREF="#l2">Listing Two</A>.</p><p>The OS calls a service's <i>Handler</i> function when it wants it to stop, pause, or continue. The action that the OS wants the service to take is passed as the signal parameter to <i>Handler</i>. The service then notifies the operating system of its current state using its service status handle.</p><h3>An Object-Oriented Framework</h3><p>An object-oriented service framework has distinct advantages over basic Win32 functions. First of all, Win32 requires you to identify at compile time the number of services and their names. A framework lets you determine at run time the number of services to be managed. Second, using a framework, you can abstract the details of the underlying operating system to allow future porting to different operating systems. Finally, you can represent each service as a single instance of an abstract subclass.</p><p>If you think of a service as an object, then there is a natural mapping between a service's name (which is unique) and a service object. I used the Standard Template Library (STL) map template to declare a global object that represents this mapping; see <A NAME="rl3"><A HREF="#l3">Listing Three</A>.</p><p>Since each service's <i>ServiceMain</i> is passed the service name as its first argument, you can register a single <i>ServiceMain</i> for all services and use the first argument and the <i>name_to_service</i> object to find the service object that corresponds to the <i>ServiceMain</i> call. Having a single <i>ServiceMain</i> function frees you from having to add or change a separate <i>ServiceMain</i> for each service that is added or changed.</p><p>So far, the implementation is fairly clean, but there is a problem with the <i>Handler</i> function. There is no additional identifying information passed to a <i>Handler</i> (like the service name) that you can use to resolve to which service a signal is being sent. This presents a problem, especially if you do not know until run time how many services you will be running.</p><p>To solve this problem, I first imagined what form I wanted <i>Handler</i> to take. I decided on the declaration in <A NAME="rl4"><A HREF="#l4">Listing Four</A>, which let me use the <i>servicename</i> parameter with the <i>name_to_service</i> object to find the service object for which the signal is meant. The approach I finally chose was to declare a structure called NAMEANDHANDLER that contains three pointers, one of which points to a <i>Handler</i>. I then declared an array of NAMEANDHANDLER structures, with the first structure's handler pointer initialized to point to a function called <i>Handler0</i>, the second pointing to <i>Handler1</i>, the third pointing to <i>Handler2</i>, and so on. <i>Handlern</i> calls a single <i>Handler</i>, passing it members of the <i>n</i>th entry in the NAMEANDHANDLER array.</p><p>By including a pointer to a service object in the NAMEANDHANDLER structure that gets initialized to zero, you can obtain a <i>Handler</i> for a service inside <i>ServiceMain</i> by:</p><p>1. Going through the array of NAMEANDHANDLER structures until you find one that isn't used yet (that is, the service pointer of the structure is still NULL).</p><p>2. Obtaining the address of the <i>Handler</i> function from the handler pointer of the structure.</p><p>3. Registering <i>Handler</i> with the operating system.</p><p>4. Setting the service pointer of NAMEANDHANDLER to the service object you are registering.</p><p>5. Saving the status handle returned from the <i>RegisterServiceCtrlHandler</i> in the NAMEANDHANDLER structure.</p><h3>The Service Interface</h3><p>Each signal that the OS sends to a service (pause, continue, stop, shutdown, interrogate) can be mapped to a corresponding method in the framework's service (<i>TryToPause</i>, <i>TryToContinue</i>, <i>TryToStop</i>, <i>TryToShutdown</i>, <i>TryToGetStatus</i>). I use the word "try" in the names of each of these methods because the operating system's request that a service do a particular action does not guarantee that the action will be successful. When the operating system sends a signal to a service, that service must respond by calling <i>SetServiceStatus</i>, passing its status handle as the first parameter and the address of a SERVICE_STATUS structure as the second parameter. By setting combinations of bitfields and predefined constants in SERVICE_STATUS, a service responds to a signal from the OS by notifying the OS of any change in its state.</p><p>To abstract further, I encapsulate the interplay between the status handle, SERVICE_STATUS structure, and <i>SetServiceStatus</i> into a single object called <i>TServiceController</i>. The constructor for <i>TServiceController</i> is passed a status handle that it saves as a private member. The public methods exposed by <i>TServiceController</i> are in <A NAME="rl5"><A HREF="#l5">Listing Five</A>.</p><p>These methods set the appropriate bitfields and integer constants in a SERVICE_STATUS structure and make the underlying call to <i>SetServiceStatus</i>. This effectively abstracts the communication with the operating system that the service must perform. Each <i>TryToxxx</i> function is passed a pointer to a <i>TServiceController</i> object, which it uses to notify the OS of any change in its status. I call the service object <i>TService</i>, and its <i>TryToxxx</i> public methods are in <A NAME="rl6"><A HREF="#l6">Listing Six</A>.</p><p>Instead of saving a status handle in the NAMEANDHANDLER structure, I store a pointer to a new instance of a <i>TServiceController</i> function. Each <i>Handlern</i> calls the global <i>Handler</i> function with a pointer to a <i>TServiceController</i> object, a pointer to a <i>TService</i> object, and an integer representing the signal with which the <i>Handlern</i> was first called.</p><p>Depending on the value of the integer signal it was passed, <i>Handler</i> contains a switch statement that calls one of the <i>TryToxxx</i> methods in the <i>TService</i> object passing it the pointer to the <i>TServiceController</i> object.</p><p>Since the OS never gives a start signal to a service, but instead calls its <i>ServiceMain</i> to start it, I added a <i>TryToStart</i> function for consistency. The <i>TryToStart</i> returns True if the service has successfully started. It must call the <i>ServiceStarted</i> method of the <i>TServiceController</i> object before it returns True to indicate that it has started.</p><p>The complete definition of the abstract <i>TService</i> class is in <A NAME="rl7"><A HREF="#l7">Listing Seven</A>.</p><h3><i>ServiceMain</i> Revisited</h3><p>Earlier, I described how <i>ServiceMain</i> obtains a handler for a function. After <i>ServiceMain</i> obtains this handler, it does the following:</p><p></p><p>1. Uses the status handle to create a new instance of a <i>TServiceController</i> object.</p><p>2. Sets the <i>servicecontroller</i> pointer in the NAMEANDHANDLER structure to the newly created <i>TServiceController</i> object.</p><p>3. Calls the <i>ParseCommandLine</i> method of the <i>TService</i> object, passing it the parameters with which <i>ServiceMain</i> was called.</p><p>4. Calls the <i>TryToStart</i> method of the <i>TService</i> object, if <i>TryToStart</i> returns True, then calls the <i>ServiceMain</i> method of the <i>TService</i> object.</p><p></p><p>Because you can now hook up a service handler function with a <i>TService</i> object at run time, all you need to implement one or more services to an application is some way of passing a list of <i>TService</i>-derived objects to the framework. Since each <i>TService</i>- derived object implements <i>ServiceName</i> and <i>DisplayName</i> methods, the same list of <i>TService</i>-derived objects can be used to install or remove a list of services.</p><p>The service framework contains a reference to <i>service_vector GetServices(int argc,char *arg[]);</i>, where <i>service_vector</i> is defined as <i>typedef vector&lt;TService *&gt; service_vector;</i>. To implement one or more services in a single application, an app using this framework simply needs to implement the <i>GetServices</i> function. The application-supplied <i>GetServices</i> acts as a service factory, instantiating all of the service objects and returning them in an STL vector.</p><p>Many implementations of NT services use a second installer application that registers (or removes) the NT service app with the OS. To simplify the deployment of an NT service app, the task of registering or removing a service can be accomplished by the service application itself by the use of command-line switches. When the OS loads an executable containing one or more services, it does not pass the executable a command line; instead, each service gets its own command line when <i>ServiceMain</i> gets invoked. Therefore, when a service application is invoked with a command line, it can assume that it is not being invoked as a service. A service application can then use command-line switches to install or remove all of the services it contains. This removes the need for a second application that registers the service EXE with the OS.</p><p>The entry point into the service framework is defined as <i>void smain(int argc, char * arg[]);</i>. The <i>smain</i> function obtains a list of <i>TService</i> objects from <i>GetServices</i> and parses any arguments passed to it in the argument <i>vector arg[]</i>. If one of the arguments is "/install" (or "/remove"), it registers (or removes) each service with the OS. If no arguments are passed to <i>smain</i>, it assumes that it is being run as a service and proceeds accordingly.</p><p>The code for the service framework is in two files called "service.cpp" and "service.h." To create an NT service application using this framework, you simply <i>#include </i>"service.h" in your (console) application, write your own <i>GetServices</i>, and call <i>smain</i> with the same arguments with which <i>main </i>was called after doing any initialization the application may need.</p><h3>Java Service Framework</h3><p>Designing an equivalent object model for services in Java is relatively straightforward. I transform the <i>TService</i> abstract base class into a Java interface, as in <A NAME="rl8"><A HREF="#l8">Listing Eight</A>. I call the interface the more UNIX-like <i>JDaemon</i>, instead of a more NT-like name. A library of objects implementing the <i>JDaemon</i> interface could just as easily be controlled from a Java-based control panel as the Windows NT control panel. <A NAME="rl9"><A HREF="#l9">Listing Nine</A> is the equivalent Java interface to the <i>TServiceController</i> class.</p><p><A NAME="rl10"><A HREF="#l10">Listing Ten</A> (SampleDaemon) is an example of a simple service written in Java. SampleDaemon writes "hello" to System.out every half of a second when it is started. This code can be used as a starting point for more sophisticated Java services such as a web server or a sendmail daemon. Once all the supporting framework code is in place, writing a service or daemon in Java becomes a fairly simple task. You can concentrate on the actual tasks performed by the service and do not have to concern yourself with the OS-specific details.</p><p>To enable a Java-based service to communicate with the OS, I use JNI, which enables a Java program to communicate with natively compiled code, such as a DLL on a Windows platform, or shared library (.so) under UNIX. To declare a native method in Java, a class simply uses the native keyword in the declaration of a class method. For example, <i>public native boolean foo(int bar);</i> declares a native method called "<i>foo"</i> that takes a single integer as a parameter and returns a Boolean result. The body of the method is not defined because the method is implemented in native code.</p><p>For native methods to work correctly, the Java interpreter needs some way of knowing the address of the compiled function that corresponds to each declared native method. This can be accomplished in one of two ways:</p><ul>  <li>A Java class uses the <i>System.loadLibrary()</i> call to load a shared library (.so or .dll) that contains the native methods. The Java interpreter then examines the functions exported from the shared library and resolves native methods according to the names of the exported functions. A utility called javah that comes with the JDK generates the appropriate function name for a Java native method.  <li>An application that uses the Java interpreter can register native methods with the Java run time directly before invoking any Java methods.</ul><p>The first technique is more common because it lets you call native methods with their code without first having to write an app that loads the Java run-time engine. However, the second technique is preferable to the first when an app must load the Java interpreter itself.</p><p>Java programs can call compiled functions using native methods, but for a compiled function to call a Java method, it must use a subset of JNI called the "Java Invocation Interface." Using the invocation interface, a compiled function can create new Java objects, invoke their methods, and inspect their members. The program java.exe is an example of a C/C++ program that uses the Invocation API to call a static method of a class whose name (as well as classpath information, and the like) is supplied on the command line.</p><p>When an application uses the Invocation API, instances of Java objects are represented as opaque handles of type <i>job</i>ject. To call a method of a Java object, an application must first obtain the ID of the method it wants to call. Once the method ID for an object is obtained, it can then be used to call that particular method on any instance of the object.</p><h3>Tying Together C++ and Java Objects</h3><p>The glue that binds the C++ service framework to the Java service framework is the Java class <i>NTServiceController</i>, whose declaration is in <A NAME="rl11"><A HREF="#l11">Listing Eleven</A>.</p><p>The pointer member of the <i>NTServiceController</i> class is actually used as a pointer to a <i>TServiceController</i> C++ object. When one of <i>NTServiceController</i>'s native methods is invoked, the native method casts the pointer member to a (<i>TServiceController </i>*) and calls the corresponding method in <i>TServiceController</i>. <A NAME="rl12"><A HREF="#l12">Listing Twelve</A> is the implementation of the native method <i>daemonStarting</i>.</p><p>The C++ object that communicates with both the C++ service framework and a Java class implementing the <i>JDaemon</i> interface is called <i>TJavaService</i>, which is derived from <i>TService</i> so that it can communicate with the service framework. It also contains two <i>jobject</i> handles that point to instances of <i>JDaemon</i> and <i>NTServiceController</i> Java objects.</p><p>When the <i>TryToStart</i> method of the <i>TJavaService</i> object is called, it calls the <i>setPointer</i> method of the <i>NTServiceController</i> object, passing it the address of the <i>TServiceController</i> object passed to the <i>TryToStart</i> method. It then calls the <i>tryToStart</i> method of the <i>JDaemon</i> Java object. When the <i>tryToStart</i> method of the Java object implementing the <i>JDaemon</i> interface calls one of the methods of the <i>NTServiceController</i>, the native code that gets invoked can then obtain the pointer to the <i>TServiceController</i> and call its corresponding method. The same applies for all the other <i>TryToxxx</i> functions.</p><h3>The JavaService Utility</h3><p>The end results is the JavaService utility, which uses the NT service framework with Sun's Java Runtime Interpreter (although the code could be modified to use another run-time interpreter) and three supporting Java classes to let you write an NT service in Java and start/stop it from the Windows control panel.</p><p>To use it, you:</p><p>1. Create one or more Java objects that implement the <i>JDaemon</i> interface.</p><p>2. Bundle the objects together with the <i>JDaemon</i>, <i>JDaemonController</i>, and <i>NTServiceController</i> class files into a single JAR file called "Javaservice.jar."</p><p>3. Put the names of each fully qualified class name in separate lines in a file called "javaservice.list."</p><p>4. Place javaservice.exe, javaservice.jar, and javaservice.list in the same directory.</p><p>5. From a command prompt, install the services with: "javaservice /install."</p><p>6. To remove the services, at a command prompt type "javaservice /remove."</p><p></p><p>The names of the services should be listed under Control Panel|Services. You can then use the Start/Stop buttons in the control panel to start or stop the service(s).</p><p>As a convenience, javaservice redirects System.out to a file called javaservice.out and System.err to the javaservice.err file. This enables a simplistic form of logging for each service.</p><h3>Conclusion</h3><p>The javaservice program lets you write a Windows NT service entirely in Java, and control and monitor it like any other native NT service. In the course of developing the javaservice program, I developed a C++ object-oriented framework for Windows NT services that has proved to be extremely useful in its own right. In the future, I hope to mimic the functionality of NT's service control manager in Java so that you could write a service/daemon entirely in Java and control and manage that service on any OS without changing a single line of code.</p><p></p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>void _stdcall ServiceMain(int argc,char **args)</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>void _stdcall Handler(int signal)</pre><P><A HREF="#rl2">Back to Article</A></P><H4><A NAME="l3">Listing Three</H4><pre>typedef map&lt;string,TService *&gt; string_service_map;string_service_map name_to_service;</pre><P><A HREF="#rl3">Back to Article</A></P><H4><A NAME="l4">Listing Four</H4><pre>void PreferredHandler(char *servicename,int signal);</pre><P><A HREF="#rl4">Back to Article</A></P><H4><A NAME="l5">Listing Five</H4><pre>bool ServiceStarting(DWORD checkpoint,DWORD wait_hint);bool ServiceStopping(DWORD checkpoint,DWORD wait_hint);bool ServiceStarted();bool ServiceStopped();bool ServiceNothingInteresting();</pre><P><A HREF="#rl5">Back to Article</A></P><H4><A NAME="l6">Listing Six</H4><pre>virtual bool TryToStart(TServiceController *controller)=0;virtual void TryToStop(TServiceController *controller)=0;virtual void TryToPause(TServiceController *controller)=0;virtual void TryToContinue(TServiceController *controller)=0;virtual void TryToShutdown(TServiceController *controller)=0;virtual void TryToGetStatus(TServiceController *controller)=0;</pre><P><A HREF="#rl6">Back to Article</A></P><H4><A NAME="l7">Listing Seven</H4><pre>class TService{public:virtual string ServiceName()=0;virtual string DisplayName()=0;virtual string_vector DependentServices()=0;// parse any command-line parameters passed to the servicevirtual void ParseCommandLine(int argc,char **args)=0;// try to start the service, returns true if service has been initialized // properly. If it returns true, then main will be calledvirtual bool TryToStart(TServiceController *controller)=0;// main method returns when service has stoppedvirtual void ServiceMain()=0;virtual void TryToStop(TServiceController *controller)=0;virtual void TryToPause(TServiceController *controller)=0;virtual void TryToContinue(TServiceController *controller)=0;virtual void TryToShutdown(TServiceController *controller)=0;virtual void TryToGetStatus(TServiceController *controller)=0;virtual ~TService() {}};</pre><P><A HREF="#rl7">Back to Article</A></P><H4><A NAME="l8">Listing Eight</H4><pre>public interface JDaemon{public String getDaemonName();public String getDisplayName();public String[] getDependentDaemons();public void parseCommandLine(String[] args);// returns true if we were able to startpublic boolean tryToStart(JDaemonController c);public void main(); // called when service is runningpublic boolean tryToStop(JDaemonController c);public boolean tryToPause(JDaemonController c);public boolean tryToContinue(JDaemonController c);public boolean tryToShutdown(JDaemonController c);public boolean tryToGetStatus(JDaemonController c);}</pre><P><A HREF="#rl8">Back to Article</A></P><H4><A NAME="l9">Listing Nine</H4><pre>public interface JDaemonController{public boolean daemonStarting(int checkpoint,int wait_hint);public boolean daemonStopping(int checkpoint,int wait_hint);public boolean daemonStarted();public boolean daemonStopped();public boolean daemonNothingInteresting();}</pre><P><A HREF="#rl9">Back to Article</A></P><H4><A NAME="l10">Listing Ten</H4><pre>public class SampleDaemon implements JDaemon{boolean running=false;public SampleDaemon()  {  }public String getDaemonName()  {    return "SampleDaemon";  }public String getDisplayName()  {    return "SimpleJavaService";  }public String[] getDependentDaemons()  {    return null;  }public void parseCommandLine(String[] args)  {  }public boolean tryToStart(JDaemonController c)  {    c.daemonStarting(1,500); // starting in less than 500 milliseconds    running=true;    c.daemonStarted();    return true;  }public void main()  {    int i=0;    while(running)      {        try          {            Thread.currentThread().sleep(500);            System.out.println("hello "+i);            i++;          }        catch(InterruptedException ie)          {          }        }  }public boolean tryToStop(JDaemonController c)  {    c.daemonStopping(1,500);    running=false;    return c.daemonStopped();  }public boolean tryToPause(JDaemonController c)  {    return c.daemonNothingInteresting();  }public boolean tryToContinue(JDaemonController c)  {    return c.daemonNothingInteresting();  }public boolean tryToShutdown(JDaemonController c)  {    return c.daemonNothingInteresting();  }public boolean tryToGetStatus(JDaemonController c)  {    return c.daemonNothingInteresting();  }}</pre><P><A HREF="#rl10">Back to Article</A></P><H4><A NAME="l11">Listing Eleven</H4><pre>public class NTServiceController implements JDaemonController{int pointer;public NTServiceController()  {    pointer=0;  }public void setPointer(int p) {pointer=p;}public int getPointer() {return pointer;}public native boolean daemonStarting(int checkpoint,int wait_hint);public native boolean daemonStopping(int checkpoint,int wait_hint);public native boolean daemonStarted();public native boolean daemonStopped();public native boolean daemonNothingInteresting();}</pre><P><A HREF="#rl11">Back to Article</A></P><H4><A NAME="l12">Listing Twelve</H4><pre>JNIEXPORT jboolean JNICALL    NTServiceController_daemonStarting  (JNIEnv *env,jobject jcontroller,jint checkpoint,jint wait_hint){TServiceController *sc=(TServiceController *)    env-&gt;CallIntMethod(jcontroller,ntscm_getPointer);return sc-&gt;ServiceStarting(checkpoint,wait_hint);}</pre><P><A HREF="#rl12">Back to Article</A></P></body></html>