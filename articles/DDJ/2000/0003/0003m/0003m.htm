<html><head><title>Mar00: Algorithm Alley</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>An <i>N*logN</i> Adaptive Group Sort Algorithm</h1><p><i>Dr. Dobb's Journal</i> March 2000</p><h3>By Mingfu Gong</h3><p>Group sorting algorithms are well-suited applications where recursion is either not allowed or inefficient. In group sorting algorithms (such as the Shell Sort; see "A High-speed Sorting Procedure," by Donald L. Shell, <i>Communications of the ACM</i>, July, 1959), individual groups are sorted for each of a given group number. As the group number decreases to 1, the array becomes fully sorted. Two issues can affect the efficiency of group sorting routines:</p><p></p><DDJADVERTISEMENT INLINE><ul>  <li>Individual groups often don't need to be fully sorted during the process, so fully sorting a group may move an element away from the location where it should be.  <li>The new group number should be selected in such a way that each old group will spread among new groups. For example, by decreasing the group number by half each time, you could end up with the worst-case running time <i>O(N**</i>2<i>)</i> for an array with size <i>N=</i>2<i>**M</i>.</ul><p>To improve the efficiency of group sorting, the Adaptive Group Sort (AGS) algorithm (see <A NAME="rl1"><A HREF="#l1">Listing One</A>) uses an "approaching sorting" methodology to improve sorting efficiency. AGS is an <i>O(N*logN)</i> sorting algorithm with O(1) auxiliary space requirements. Theoretically, AGS's flat structure makes it easier to be optimized than, say, QuickSort, and is ideal for many embedded-system applications. When running against the IBM AIX system call <i>qsort()</i>, for instance, AGS is about 2 times faster than <i>qsort()</i> when compiled with optimizing turned on (it is about 20 percent slower than <i>qsort()</i> when compiled without optimization). <A NAME="rl1"><A HREF="#l1">Listing One</A> implements the AGS algorithm for an <i>array[]</i> with size <i>N </i>and the group number decreasing rate (GNDR)=<i>N</i>1/<i>N</i>2 (<i>N</i>2&gt;<i>N</i>1). In this case, for each given <i>numGroup</i> in <i>gsort1()</i>, all groups go through a bidirectional bubble sort once. After this bidirectional processing, each group approaches being a sorted group, but may not be fully sorted.</p><p>Because each group may not be fully sorted as the group number decreases to 1, the array itself may not be fully sorted. Consequently, you may need to repeatedly loop through the group sort until <i>array[]</i> is fully sorted. In <i>gsort1()</i>, <i>isSortedArray()</i> is called after each group sort loop to make sure that <i>gsort1()</i> produces a fully sorted array.</p><p>Clearly, the running time of <i>gsort1()</i> with returned value <i>gLoop</i> is less than optimal. For instance, in <A NAME="re1"><A HREF="0003me1.htm">Example 1</A>, where <i>gLoop</i> is the number of <i>gsort</i> loops, the source of inefficiency is the overhead caused by <i>isSortedArray()</i> the group sort running time. Since <i>gLoop</i> depends on GNDR being in a reasonable range, <i>gLoop</i> will be a limited number.</p><p>After the first AGS loop in <i>gsort1()</i>, <i>array[]</i> is closer to being fully sorted. Consequently, it is not necessary for <i>numGroup</i> to start from <i>N</i> after the first loop. In <i>gsort2()</i> (see <A NAME="rl2"><A HREF="#l2">Listing Two</A>), however, <i>maxNumGroup</i> is set to <i>log(N)</i> after the first AGS loop. Also, the variables <i>divider</i> and <i>oldDivider</i> calculate <i>numGroup</i> so that <i>gsort2()</i> can work for any given <i>N</i>.</p><p>A preprocess <i>for</i> loop is used to reduce the number of swaps in <i>gsort2()</i> with the cost of O(<i>N</i>). Furthermore, <i>isSortedArray(array,N)</i> is called before the AGS loop, which results in O(<i>N</i>) running time for some arrays. <A NAME="re2"><A HREF="0003me2.htm">Example 2</A> is <i>gsort2()</i> running time with the returned value of <i>gLoop</i>.</p><p>In the worst-case bidirectional bubble-sort loop, an element may swap only once to the correct direction. This gives GNDR a low boundary for AGS in <i>gsort1()</i> and <i>gsort2()</i>. GNDR=1/2 is excluded from <A NAME="re3"><A HREF="0003me3.htm">Example 3</A> because of regrouping. The upper boundary of <i>N</i>1/<i>N</i>2 in <A NAME="re3"><A HREF="0003me3.htm">Example 3</A> is set to 2/3 because the running time both in <A NAME="re1"><A HREF="0003me1.htm">Examples 1</A> and <A NAME="re2"><A HREF="0003me2.htm">2</A> is proportional of 1/<i>log</i>(<i>N</i>2/<i>N</i>1), although <i>N</i>1/<i>N</i>2 can be any value between 1/2 and 1 for <i>gsort2()</i>.</p><p><A NAME="rt1"><A HREF="0003mt1.htm">Table 1</A> lists the statistic test results of <i>gsort2()</i> for different GNDRs and array sizes. <A NAME="rl5"><A HREF="#l5">Listing Five</A> is the program that performed this analysis. Each <i>N </i>and GNDR were tested with 100 random data series. As <A NAME="rt1"><A HREF="0003mt1.htm">Table 1</A> shows, <i>gsort2()</i> gives consistent <i>N*logN</i> comparing and swapping costs. However, AGS has the minimum swapping cost for GNDR=2/3. As GNDR decreases, comparing cost <i>K</i> decreases and swapping cost <i>S</i> increases. Based on the data swapping cost, you can optimize GNDR to get the minimum sorting time.</p><p><i>gsort2()</i> efficiency can be improved by resetting GNDR to 2/3 when step <i>&lt; log(N)</i> at the first AGS loop; see <i>gsort3()</i> in <A NAME="rl3"><A HREF="#l3">Listing Three</A>. <A NAME="rt2"><A HREF="0003mt2.htm">Table 2</A> shows <i>gsort3()</i> test results. Comparing <A NAME="rt1"><A HREF="0003mt1.htm">Table 1</A> with <A NAME="rt2"><A HREF="0003mt2.htm">Table 2</A>, you can see a consistent improvement of swapping costs for all GNDR&lt;2/3. Comparing cost <i>K</i> depends on <i>gLoop</i> improvement.</p><p>In short, the GNDR parameter gives choices for optimizing AGS for certain data constraints. GNDR=2/3 is suitable for data with high swapping costs, while GNDR =5/9 is good for general uses. It's hard to give a straight answer about the worst running time for AGS. The best estimation about AGS is between <i>O(N*logN)</i> and <i>O(N*logN*logN)</i>. <A NAME="rl4"><A HREF="#l4">Listing Four</A> is a template version of <i>gsort3()</i>, which is more general but could run much slower compared to a similar C/C++ version.</p><h3>Acknowledgment</h3><p>Special thanks to Dr. Gary Laison of Saint Joseph's University for the discussions on sorting algorithms.</p><p></p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>// adaptive group sort - 1: running time &lt;= gLoop*N/2 + //                                     2*gLoop*N*log(N)/log(N2/N1).long gsort1(long *array, long N, long N1, long N2) {       long numGroup; // number of groups       long gLoop = 0; // number of AGS loops       do { // AGS loop         numGroups = N ;         while (numGroups &gt; 1) { // group-sort loop           // update numGroup           numGroup = numGroup * N1 / N2;           for (i = 0; i &lt; N-numGroup; i++) { //bidirectional bubble-sort loop              cmprSwap2(array[i], array[i+numGroup]);              cmprSwap2(array[N-1-i-numGroup], array[N-1-i]);           }        }        gLoop++;      } while (!isSortedArray(array, N));      return gLoop;}</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>//adaptive group sort - 2:  running time &lt;= (gLoop+2)*N/2 + //              2*N*log(N)/log(N2/N1) + 2*(gLoop-1)*N*log(log(N))/log(N2/N1).long gsort2(long *array, long N, long N1, long N2) {       long maxNumGroup; // maximum group number       long numGroup; // number of groups       long divider;  // to calculate numGroup       long oldDivider; // to calculate numGroup       long gLoop = 0; // number of AGS loops       long i;       // pre-process to reduce number of swaps;       maxNumGroup = N / 2;       for ( i = 0; i &lt; maxNumGroup; i++ ) {           cmprSwap2(array[i], array[N-1-i]);       }       maxNumGroup = N;       while (!isSortedArray(array, N)) { // AGS loop            gLoop++;            numGroups = maxNumGroup;            oldDivider = divider = 1;            while (numGroups &gt; 1) { // group-sort loop                // update numGroup                divider = divider * N2 / N1;                if (divider == oldDivider) divider++;                oldDivider = divider;                numGroup = maxNumGroup / divider;                if (0 == numGroup) numGroup = 1;                for (i = 0; i &lt; N - numGroup; i++) { // bidirectional                                                      //    bubble-sort loop                    cmprSwap2(array[i], array[i+numGroup]);                    cmprSwap2(array[N-1-i-numGroup], array[N-1-i]);                }           }           maxNumGroup = log(N); //reset maxNumGroup;      }      return gLoop;}</pre><P><A HREF="#rl2">Back to Article</A></P><H4><A NAME="l3">Listing Three</H4><pre>//adaptive group sort - 3long gsort2(long *array, long N, long N1, long N2) {       long maxNumGroup; // maximum group number       long numGroup; // number of groups       long divider;  // to calculate numGroup       long oldDivider; // to calculate numGroup       long gLoop = 0; // number of AGS loops       long i;       // pre-process to reduce number of swaps;       maxNumGroup = N / 2;       for ( i = 0; i &lt; maxNumGroup; i++ ) {           cmprSwap2(array[i], array[N-1-i]);       }       maxNumGroup = N;       while (!isSortedArray(array, N)) { // AGS loop            gLoop++;            numGroups = maxNumGroup;            oldDivider = divider = 1;            while (numGroups &gt; 1) { // group-sort loop                // update numGroup                divider = divider * N2 / N1;                if (divider == oldDivider) divider++;                oldDivider = divider;                numGroup = maxNumGroup / divider;                if (0 == numGroup) numGroup = 1;                if (numGroup &lt; 2*log(N)) { //reset GNDR                      N1 = 2; N2 = 3;                }                for (i = 0; i &lt; N - numGroup; i++) { // bidirectional                                                      //    bubble-sort loop                    cmprSwap2(array[i], array[i+numGroup]);                    cmprSwap2(array[N-1-i-numGroup], array[N-1-i]);                }           }           maxNumGroup = log(N); //reset maxNumGroup;      }      return gLoop;}</pre><P><A HREF="#rl3">Back to Article</A></P><H4><A NAME="l4">Listing Four</H4><pre>// similar interface as qsort(); Depends on compiler, template normally//                                    slower than simular C/C++ functions.template &lt;class T&gt; void gsort(T *array, int arraySize,                             int (*ComparisonPointer)(const T*, const T*)){    T tmp;    int maxStep;         // maximum group number    int step;            // number of groups    int divider;         // to calculate step    int oldDivider;      // to calculate step    int logN;    int i, j;    int N1, N2;    boolean firstSet = TRUE;    if (NULL == array || 1 &gt;= arraySize ) return;    if (sizeof(T) &gt;= 8) { //set GNDR by swaping cost.        N1 = 2; N2 = 3;    } else {        N1 = 5; N2 = 9;    }    // pre-processing;    maxStep = arraySize / 2;    for (i = 0, j = arraySize-1; i &lt; maxStep; i++, j--) {        if (ComparisonPointer(&amp;array[i], &amp;array[j]) &gt; 0) {          tmp = array[i];          array[i] = array[j];          array[j] = tmp;        }    }    if (2 == arraySize)  return;    logN = (int) (log((double)arraySize));    if (logN &lt; 2) logN = 2;    maxStep = arraySize;    while (TRUE) { //AGS loop;        for (i = arraySize - 2; i &gt;= 0; i--) { //isSortedArray();          if (ComparisonPointer(&amp;array[i], &amp;array[i+1]) &gt; 0) break;        }        if (0 &gt;= i) break; // is sorted array;        step = maxStep;        oldDivider = divider = 1;        while (step &gt; 1) { // group-sort loop;          divider = (divider * N2) / N1;          if (divider == oldDivider) divider++;          oldDivider = divider;          step = maxStep / divider;          if (firstSet &amp;&amp; step &lt;= 2*logN) { // reset GNDR = 2/3            firstSet = FALSE;            N1 = 2; N2 = 3;          }          if (0 == step) step = 1;          for (i = 0, j = arraySize-1; j &gt;= step; i++, j--)                                  // bidirection bubble-sort for each group;            if (ComparisonPointer(&amp;array[i], &amp;array[i+step]) &gt; 0) {              tmp = array[i];              array[i] = array[i+step];              array[i+step] = tmp;            }            if (ComparisonPointer(&amp;array[j-step], &amp;array[j]) &gt; 0) {              tmp = array[j-step];              array[j-step] = array[j];              array[j] = tmp;            }          }        }        maxStep = logN;    }}</pre><P><A HREF="#rl4">Back to Article</A></P><H4><A NAME="l5">Listing Five</H4><pre>//################################################################// Test program for Adaptive Group Sort (AGS) algorithm statistic analysis.// 05/04/98 M. Gong - initial code.//################################################################long gsort2(long *array, long arraySize, long n1, long n2);long gsort3(long *array, long arraySize, long n1, long n2);//static long numCmpr, numSwap;//static short cmprSwap2(long &amp;smaller, long &amp;larger);static short isSortedArray(long *array, long arraySize);static void biDirectionGroupSort(long *array,                                long arraySize, long step, long loops);//for teststatic void initArray(long *array, long N);static void swap(long &amp;l1, long &amp;l2);int main(int argc, char **argv);//int main(int argc, char **argv){    long minloop, maxloop, avrloop;    long mincmpr, maxcmpr;    long minswap, maxswap;    double avrswap, avrcmpr;    long gsortLoops;    double avrf, minf, maxf;    double loopf;    double nlogn;    double logN;    long n1, n2;    long seed1, seed2, arraySize, n;    long *array = NULL;    if (argc &lt;6) {            printf("usage: %s arraySize seedStart seedEnd n1 n2\n", argv[0]);            return FALSE;    }    arraySize = atoi(argv[1]);    seed1 = atoi(argv[2]);    seed2 = atoi(argv[3]);    n1 = atoi(argv[4]);    n2 = atoi(argv[5]);    logN = log((double)arraySize) / log(2.0);    if (seed1 &gt; seed2) swap(seed1, seed2);    printf("****** adaptive group sort: numCmpr = K * N * log2(N);                                         numSwap = S * N * log2(N);\n");    printf(" seed1 = %d; seed2 = %d; N = %d; n1 = %d; n2 = %d;               log2(N) = %.3f;\n", seed1, seed2, arraySize, n1, n2, logN);    minloop = 0x7FFFFFFF; maxloop = 0; avrloop = 0;    mincmpr = 0x7FFFFFFF; maxcmpr = 0, avrcmpr = 0;    minswap = 0x7FFFFFFF; maxswap = 0; avrswap = 0;    array = new long[arraySize];    if (NULL == array) return FALSE;    for(n = seed1; n &lt;= seed2; n++) {            numCmpr = 0; numSwap = 0;            srand(n);            initArray(array,arraySize);            gsortLoops = gsort2((long*)array, arraySize, n1, n2);            if (minloop &gt; gsortLoops) minloop = gsortLoops;            if (maxloop &lt; gsortLoops) maxloop = gsortLoops;            avrloop += gsortLoops;            if (mincmpr &gt; numCmpr) mincmpr = numCmpr;            if (maxcmpr &lt; numCmpr) maxcmpr = numCmpr;            avrcmpr += ((float) numCmpr) / (float)(seed2 - seed1 +1);            if (minswap &gt; numSwap) minswap = numSwap;            if (maxswap &lt; numSwap) maxswap = numSwap;            avrswap += ((float) numSwap) / (float)(seed2 - seed1 +1);    }    loopf = (double) (seed2 - seed1 +1);    nlogn = logN * ((double)arraySize);    avrf= ((double)avrloop) / loopf;    printf("\tmin : max : average loop = %d : %d :                                      %.3f\n", minloop, maxloop, avrf);    avrf = avrcmpr / nlogn;    minf = ((double)mincmpr) / nlogn;    maxf = ((double)maxcmpr) / nlogn;    printf("\tmin : max : average K = %.3f : %.3f :                                       %.3f\n", minf, maxf, avrf);    avrf = avrswap / nlogn;    minf = ((double)minswap) / nlogn;    maxf = ((double)maxswap) / nlogn;    printf("\tmin : max : average S = %.3f : %.3f :                                       %.3f\n", minf, maxf, avrf);    delete [] array;    return TRUE;}//static void initArray(long *array, long N){    long i;    for (i = 0; i &lt; N; i++) {            array[i] = (long) rand();    }}//static void swap(long &amp;l1, long &amp;l2){    long tmp = l1;    l1 = l2; l2 = tmp;}//reset maxStep = logN after the first AGS loop;long gsort2(long *array, long arraySize, long N1, long N2){    long maxStep;    // maximum group number    long step;       // number of groups    long divider;    // to calculate step    long oldDivider; // to calculate step    long i;    long gsortloops = 0;    long logN;    if (1 &gt;= arraySize) return 0;    if (2 == arraySize) {            cmprSwap2(array[0], array[1]);            return 0;    }    if (N1 &gt; N2) swap(N1, N2);    else if (N1 == N2) {            N1 = 2; N2 = 3;    }    maxStep = arraySize / 2;    for (i = 0; i &lt; maxStep; i++) { // pre-processing            cmprSwap2(array[i], array[arraySize-1-i]);    }    logN = (long) (log((double)arraySize));    maxStep = arraySize;    while (!isSortedArray(array, arraySize)) { // AGS Loop        step = maxStep;        oldDivider = divider = 1;        while (step &gt; 1) { // group-sort loop                divider = (divider * N2) / N1;                if (divider == oldDivider) divider++;                oldDivider = divider;                step = maxStep / divider;                if (0 == step) step = 1;                biDirectionGroupSort(array, arraySize, step, 0);        }        gsortloops++;        maxStep = logN;        if (maxStep &lt; 2) maxStep = 2;    }    return gsortloops;}//reset maxStep = logN after the first AGS loop;//reset GNDR to 2/3 when step &lt; logN;long gsort3(long *array, long arraySize, long N1, long N2){    long maxStep; // maximum group number    long step; // number of groups    long divider; // to calculate step    long oldDivider; // to calculate step    long i;    long gsortloops = 0;    long logN;    if (1 &gt;= arraySize) return 0;    if (2 == arraySize) {            cmprSwap2(array[0], array[1]);            return 0;    }    if (N1 &gt; N2) swap(N1, N2);    else if (N1 == N2) {            N1 = 2; N2 = 3;    }    maxStep = arraySize / 2;    for (i = 0; i &lt; maxStep; i++) { // pre-processing            cmprSwap2(array[i], array[arraySize-1-i]);    }    logN = (long) (log((double)arraySize));    maxStep = arraySize;    while (!isSortedArray(array, arraySize)) { // AGS Loop            step = maxStep;            oldDivider = divider = 1;            while (step &gt; 1) { // group-sort loop                    divider = (divider * N2) / N1;                    if (divider == oldDivider) divider++;                    oldDivider = divider;                    step = maxStep / divider;                    if (step &lt;= 2*logN) { // reset GNDR = 2/3                            N1 = 2; N2 = 3;                    }                    if (0 == step) step = 1;                    biDirectionGroupSort(array, arraySize, step, 0);            }            gsortloops++;            maxStep = logN;            if (maxStep &lt; 2) maxStep = 2;    }    return gsortloops;}//bidirection bubble-sort for each groupstatic void biDirectionGroupSort(long *array, long arraySize, long step,long loops){    long i;    long maxIndex, lastIndex;    lastIndex = arraySize - 1;    maxIndex = arraySize - step - loops;    for (i = loops; i &lt; maxIndex; i++) { // bi-directional group sort            cmprSwap2(array[i], array[i+step]);            cmprSwap2(array[lastIndex-i-step], array[lastIndex-i]);    }}//return TRUE if swappedstatic short cmprSwap2(long &amp;smaller, long &amp;larger){    numCmpr++;    if (smaller &gt; larger) {            long tmp = smaller;            smaller = larger;            larger = tmp;            numSwap++;            return 1;    }    return 0;}//return TRUE if array is sortedstatic short isSortedArray(long *array, long arraySize){    arraySize--;    for (long i = 0; i &lt; arraySize; i++) {            if (cmprSwap2(array[i], array[i+1]) &gt; 0) return 0;    }    return 1;}</pre><P><A HREF="#rl5">Back to Article</A></P></body></html>