<html><head><title>Jun00: XML, Reflective Pattern Matching, and Java</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>XML, Reflective Pattern Matching, and Java</h1><p><i>Dr. Dobb's Journal</i> June 2000</p><h2>Designing with  flexibility in mind</h2><h3>By Andrew Dwelly</h3><I>Andy is a computer consultant who lives on Guernsey in the Channel Islands. He can be contacted at andy@cedillasoft.com.</I><hr><p>Every so often, a small project becomes a victim of its own success -- and becomes a big project. On these occasions, the architecture may need a rethink if the original design can't cope with the extra requirements expansion brings in its wake. This happened to me last year while working on Marius, a set of programs that takes an XML source document containing Java code fragments and explanatory text (see my article "Java, XML, &amp; Literate Programming" <i>DDJ</i>, February 2000). One of the programs, Comb, extracts Java and reassembles it into files that can be compiled. The other, Weave, creates an HTML version of the source document that is easy to read.</p><p>At the end of that article, I mentioned that it would be nice to be able to vary the style of the HTML output to fit in with existing web sites. It was at this point that I ran into trouble. Both Comb and Weave had been written using recursive descent, a common and simple technique for working with trees. Unfortunately, this meant that the output of Weave could only be changed by making large-scale modifications to the program. Worse than this, coping with a variety of output formats was completely infeasible. Something new was needed.</p><DDJADVERTISEMENT INLINE><p>Recursive descent makes a depth-first traversal of the tree output by the XML parser, taking actions based on the next node of the tree and where you are in the program. For example, suppose you are processing a document constructed according to a DTD containing <A NAME="re1"><A HREF="0006de1.htm">Example 1</A> that represents the log of a tollbooth on a bridge. It says that a RECORD tag with a DATE attribute contains zero or more CAR or VAN tags, and that VAN and CAR tags contain zero or more passengers. (I am distinguishing between passengers and drivers here.) <A NAME="re2"><A HREF="0006de2.htm">Example 2</A> is a typical record file, in which a car containing two passengers was followed by a van containing one. </p><h3>DOM and Recursive Descent</h3><p>Most XML parsers produce trees conforming to the Document Object Model (DOM) from the W3C. This model contains three interfaces that get used a great deal when processing XML. The Node interface represents a node on a parse tree and contains methods for finding other nodes, such as the <i>getFirstChild()</i> method that finds the first child of a node, if there is one.</p><p>Node is extended by the Element interface that represents an XML tag; it contains methods such as <i>getAttribute()</i> for discovering the value of an attribute in a tag, such as the DATE attribute in the RECORD tag in <A NAME="re2"><A HREF="0006de2.htm">Example 2</A>. It also contains a <i>getTagName()</i> method for discovering the name of a tag. Finally, Node is also extended by Text, which represents character data; its <i>getData()</i> method can be used to get the string of data.</p><p>If you wanted to write a program to count the number of passengers in cars and you had parsed the document into a tree of DOM nodes using an XML parser, you could write something like <A NAME="rl1"><A HREF="#l1">Listing One</A>. The <i>processRecord()</i> method takes an element that is the root of the tree of nodes. Each of its child nodes is checked to see whether it is a CAR tag; if it is, it is passed onto the <i>processCar()</i> method. This method counts each of the child nodes. Because the DTD only permits PASSENGER tags inside children, it simply counts nodes without checking their name.</p><p>In the past, I've used recursive descent without a second thought, but in fact it's a way of programming that sits uncomfortably with object-oriented languages. It's tightly coupled to the DTD. If the DTD is complicated, the code to process it will be, too. There's also a strong coupling between the various methods as methods call other methods in the class to process subparts of the DOM tree, and it makes inheritance hard to use. These factors make the code brittle and unable to easily cope with change -- which is exactly the problem I had with Weave. </p><h3>Pattern Matching with <i>Hex</i></h3><p>An alternative to processing trees with recursive descent is to use pattern matching. This is available in some declarative languages such as Prolog or Miranda, but not directly built into Java. However, Java does have another powerful facility -- Reflection -- which can be used to add pattern matching in a simplified form. After a number of experiments, I came up with <i>Hex</i>. To use it, you supply another class called the "delegate" that contains a series of actions in the form of methods named according to a special convention. <i>Hex</i> traverses the DOM tree in depth-first order and, when it recognizes a combination of tags for which there is a matching method in the delegate, it calls the method. <A NAME="rl2"><A HREF="#l2">Listing Two</A> is another class that counts the number of passengers in cars on the toll bridge.</p><p>The <i>setHex()</i> method is required to implement the <i>Hex</i> interface. The <i>Hex</i> class uses this to pass a reference to the delegate so that the delegate can call some special methods in <i>Hex</i> for control purposes. The other method, <i>prePASSENGER_ CAR()</i> is called by <i>Hex</i> whenever a PASSENGER tag is encountered inside a CAR tag during the depth first traversal. <i>Hex</i> passes the matching element as a parameter as you commonly need to do various things based on the value of the attributes of the tag. </p><p>When <i>Hex</i> arrives at a new node, it attempts to find a matching action in the delegate, starting with the strongest pattern that takes the current node and all of its ancestors into account. If it fails to find this, it then looks for a pattern matching the current node and all ancestors except the root, then all ancestors except the root and the root's child, and so on. Finding a match in the delegate causes the match to be executed, then <i>Hex</i> moves onto the next node. If it finds no matches it moves silently onto the next node. Consider the typical record file in <A NAME="re2"><A HREF="0006de2.htm">Example 2</A> that's represented as the tree of DOM Elements. In  <A NAME="rf1"><A HREF="0006df1.htm">Figure 1</A>, <i>Hex</i> traverses from A to L. At position A, it looks for the <i>preRECORD()</i> method in the delegate. At position B, it looks for <i>preCAR_RECORD()</i> and if it does not find that, it looks for <i>preCAR()</i>. At C, it looks for <i>prePASSENGER_CAR_ RECORD()</i>, then <i>prePASSENGER_CAR()</i>, then <i>prePASSENGER()</i>. At D, the behavior changes slightly. <i>Hex</i> also matches against <i>post </i>methods that are called after a node and its children have been processed. At D, it looks for <i>postPASSENGER_CAR_RECORD()</i>, then <i>postPASSENGER_CAR()</i>, and then <i>postPASSENGER()</i>.</p><p>Position E is treated like C, and F is treated like D. Then, at G, the <i>post </i>methods are tried for the CAR tag -- <i>postCAR_RECORD()</i>, then <i>postCAR()</i>. At position H, <i>Hex</i> tries <i>preVAN_RECORD()</i>; if it does not find that, it then tries <i>preVAN()</i>. <i>Hex</i> carries on in this fashion until it reaches position L, at which point it tries <i>postRECORD()</i> before halting.</p><p>The point of having both "pre" and "post" pattern matches is that transforming XML often involves doing something both before and after an element has been processed. For example, you could transform the file into English text using <A NAME="rl3"><A HREF="#l3">Listing Three</A>. Running this against <A NAME="re2"><A HREF="0006de2.htm">Example 2</A> produces:</p><blockquote><p>On 03/03/1999</p><p>A car with 2 passengers.</p><p>A van with 1 passengers.</p></blockquote><p><i>Hex</i> also works with <i>Text, </i>the other sort of node that commonly appears in DOM trees. A piece of XML, such as <i>&lt;form&gt;This is text&lt;/form&gt;</i>, is represented in DOM as in <A NAME="rf2"><A HREF="0006df2.htm">Figure 2</A>. When a text node is encountered, <i>Hex</i> looks for a method with a name starting with <i>prePCDATA_</i> with the rest of the name constructed as before. In this case, you would look for a method called <i>prePCDATA_ form</i> and if it was not discovered in the delegate, <i>Hex</i> would look for a method called <i>prePCDATA</i>. Similarly, matches beginning <i>postPCDATA_form </i>will be searched for afterwards. However, <i>Hex</i> hands a match a different set of parameters. A complete match is handed the contents of the <i>Text </i>node as a string, the <i>Text </i>node itself, and the <i>Element </i>node that is its immediate ancestor; for example, <i>public void prePCDATA_form(String content, Text text, Element element)</i>. The reason for this is that processing such a <i>Text </i>node will almost certainly require the actual string contents, and may well need values of the attributes that can be obtained from the <i>Element </i>reference. The <i>Text </i>node itself is available in case its contents need to be changed.</p><p>It's often helpful to be able to process an XML document in multiple passes; for example, when converting XML to HTML. For display purposes, you may have to output a set of links representing a table of contents, prior to outputting the rest of the HTML. The easy solution is to process the XML in two passes, gathering data for the table of contents in the first pass, and outputting both the table and the rest of the HTML in the second.</p><p><i>Hex</i> handles this by allowing a mode string to be set and exposing a method <i>redoFromStart()</i>. Once the mode string has been set, only patterns starting with "preXXX" and "postXXX" (where XXX is the mode string) will be matched. For example, suppose you want to extend the previous example to output the total number of passengers prior to printing out the details of every car and van. <A NAME="rl4"><A HREF="#l4">Listing Four</A> is one possible solution. Running this against <A NAME="re2"><A HREF="0006de2.htm">Example 2</A> produces:</p><blockquote><p>On 03/03/1999</p><p>There were 3 passengers in total.</p><p>A car with 2 passengers.</p><p>A van with 1 passengers.</p></blockquote><p><i>Hex</i> has some obvious advantages over recursive descent -- it tends to produce smaller classes because the delegate does not need to include the loops and conditionals that navigate recursive descent through the nodes. My experiments show that this typically saves around 20 percent of the code.</p><p>The actions in the delegate are independent from each other, unlike the methods in a class implementing recursive descent. This gives two advantages. First, each action stands alone and can be understood without referring to the other methods. Second, it is possible to use inheritance effectively. Suppose you wish to extend the <i>CarCountingDelegate</i> in <A NAME="rl2"><A HREF="#l2">Listing Two</A> to count cars and vans. <A NAME="rl5"><A HREF="#l5">Listing Five</A>, for instance, counts cars and vans. However, extending the recursive descent-based <i>Process</i> class (<A NAME="rl1"><A HREF="#l1">Listing One</A>) is not so simple. Not only will another <i>processVan()</i> method analogous to the existing <i>processCar()</i> be required, the <i>processRecord()</i> method will also have to be completely replaced -- as it needs to call both of the other two methods.</p><p>A delegate is not strongly coupled to the DTD. If the DTD is varied slightly, the delegate can often be left unchanged. This is in strong contrast to recursive descent, which is so tightly coupled to the DTD it almost invariably has to change -- even if the modification to the DTD is small. For example, suppose the tollbooth DTD is extended so that CAR tags also contain PET tags that record when the family dog came along for the ride.</p><blockquote><p>&lt;!ELEMENT CAR ((PASSENGER|PET)*)&gt;</p><p>&lt;!ELEMENT PET EMPTY&gt;</p></blockquote><p>The <i>Hex</i> delegates all still work, but the <i>Process</i> class will have to be rewritten.</p><p><i>Hex</i> works using Java Reflection, from which I took the name "Reflective Pattern Matching" for this technique. Reflection is the ability to find out facts about objects at run time (for more information on reflection, see "Java Reflection," by Paul Tremblett, <i>DDJ</i>, January 1998). In particular, <i>Hex</i> uses it to find out the names of all the methods in a delegate and see if any of these methods can be construed as an action. This is done when an object of the <i>Hex</i> class is constructed:</p><blockquote><p>Hexable delegate = new CarCounting					Delegate();</p><p>Hex hex = new Hex(delegate);</p></blockquote><p>Basically, this means it looks for methods that begin with "pre" or "post" in the delegate. It also performs a useful optimization at this stage by working out how many tags are in the longest pattern. It's obviously pointless trying to match a pattern containing three tags when the longest pattern contains only two. It also calls the <i>setHex()</i> method in the delegate, which is the method the delegate must have to satisfy the requirements of the <i>Hexable </i>interface. Then, given some tree of DOM nodes in a variable <i>doc</i>, you start the processing with <i>hex.process(doc);</i>.</p><p><i>Hex</i> exposes methods such as <i>redoFromStart()</i> that cause the processing to start again, usually after changing the mode string. This can be called at any time during processing and since the depth first traversal is recursive this means that the stack has to be unwound back to the starting state. I did this by making the <i>redoFromStart()</i> method throw a special exception that is actually caught in <i>Hex</i>'s <i>process()</i> method. It's declared as an extension of <i>RunTimeException</i>, so that the throw need not be declared in the delegate. It also avoids cluttering up the <i>Hex</i> code with a series of conditionals to see if the delegate wishes to restart the processing, which makes <i>Hex</i> more efficient. However, it's a very unusual control method, coming perilously close to an abuse of Java's exception system, and it means that any code immediately after the call of <i>redoFromStart()</i> will never be executed.</p><p>The <i>Hex</i> class occupies around 7 KB in compiled form and is available under the Gnu General public License from http://www.cedillasoft.com/.</p><h3>Alternatives to <i>Hex</i></h3><p>Although the pattern matching available in <i>Hex</i> is relatively simple, it is powerful enough to perform some very sophisticated processing of XML documents. But it can't do everything; it doesn't pattern match against attribute values and it can't recognize if sets of tags that occur one after the other are significant. To do this, you need a more powerful pattern-matching system, and the W3C organization has XSL, which does all this and more. XSL uses a set of patterns described in a special format, and a program called an "XSL processor" to process a DOM tree against them. A highly recommended open-source XSL processor is SAXON, available with extensive documentation at http://users .iclway.co.uk/mhkay/saxon/index.html. </p><h3>Conclusion</h3><p><i>Hex</i> was written in response to a specific need I had in the Marius project, which was to gain more flexibility and maintainability in the processing of XML documents. However, I now use it in a number of places in the Marius programs and it has evolved over its lifetime to become more practical. It packs a great deal of power into a small class and you will find that it handles all but the most complicated processing tasks.</p><p></p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>public class Process {    public int count = 0;    public processRecord(Element root) {        Element next = root.getFirstChild();        while (next != null) {            String name = next.getTagName();            if (name.equals("CAR") {                processCar(next);            }            next = (Element)next.getNextSibling();        }    }    public processCar(Element car) {    Element next = car.getFirstChild();    while (next != null) {        count++;        next = (Element)next.getNextSibling();     }}</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>public class CarCountingDelegate implements Hexable {    public int count = 0;    private Hex hex;    public void setHex(Hex hex) {        this.hex = hex;    }    public void prePASSENGER_CAR(Element element) {        count++;    }}</pre><P><A HREF="#rl2">Back to Article</A></P><H4><A NAME="l3">Listing Three</H4><pre>public class RecordToEnglishDelegate implements Hexable {    int count = 0;    Hex hex;    public void setHex(Hex hex) {        this.hex = hex;    }    public void preRECORD(Element element) {        String date = element.getAttribute("DATE");        System.out.println("On " + date);    }    public void preCAR(Element element) {        System.out.print("A car with ");    }    public void postCAR(Element element) {        System.out.println(count + " passengers.");        count = 0;    }    public void preVAN(Element element) {        System.out.print("A van with ");    }    public void postVAN(Element element) {        System.out.println(count + " passengers.");        count = 0;    }    public void prePASSENGER(Element element) {        count++;    }}</pre><P><A HREF="#rl3">Back to Article</A></P><H4><A NAME="l4">Listing Four</H4><pre>public class RecordToEnglishDelegate2 implements Hexable {    int count = 0;    Hex hex;    public void setHex(Hex hex) {        this.hex = hex;    }    public void preRECORD(Element element) {        String date = element.getAttribute("DATE");        System.out.println("On " + date);    }    public void prePASSENGER(Element element) {        count++;    }    public void postRECORD(Element element) {        System.out.println("There were " + count + " passengers in total.");        count = 0;        hex.setMode("pass2");        hex.redoFromStart();    }    public void prepass2CAR(Element element) {        System.out.print("A car with ");    }    public void postpass2CAR(Element element) {        System.out.println(count + " passengers.");        count = 0;    }    public void prepass2VAN(Element element) {        System.out.print("A van with ");    }    public void postpass2VAN(Element element) {        System.out.println(count + " passengers.");        count = 0;    }    public void prepass2PASSENGER(Element element) {        count++;    }}</pre><P><A HREF="#rl4">Back to Article</A></P><H4><A NAME="l5">Listing Five</H4><pre>public class CarVanCounter extends CarCountingDelegate {    public int vanCount = 0;    public void prePASSENGER_VAN(Element element) {        vanCount++;    }}</pre><P><A HREF="#rl5">Back to Article</A></P></body></html>