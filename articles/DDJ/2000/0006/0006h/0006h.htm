<html><head><title>Jun00: Java Custom Class Loaders</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>Java Custom Class Loaders</h1><p><i>Dr. Dobb's Journal</i> June 2000</p><h2>Java and small devices</h2><h3>By Brian Roelofs</h3><I>Brian is a client applications engineer for emWare, where he writes Java front-end applications for controlling and managing EMIT-enabled embedded devices. He can be contacted at broelofs@emware.com.</I><hr><p>Ordinarily, Java classes are stored in files or as part of a Java archive (JAR file) and are loaded into your programs by the Java VM (system-class loader). You are responsible for making sure the class or JAR files are located some place that is accessible to the Java VM or to your browser. Java takes care of loading and linking the classes into your program.</p><p>Relying on the Java VM to load classes is okay as long as a file system is available to store the classes and Java can access the class files. But what about storing classes some place other than in files? One of the great design features of Java is it doesn't limit you to storing classes in files. You can create your own class loader to read and load classes into the Java VM from any data source. This is a very powerful concept. There are some interesting things that can be done once you start to consider places other than files to store classes. Classes can be stored in common devices, a database, or in a class server, and then loaded dynamically when needed. In this age of mobile computing, using classes from a wide variety of sources should become common.</p><DDJADVERTISEMENT INLINE><p>What led me to investigate how to create a custom class loader was the need to store Java classes on devices too small to support a Java VM but accessible through the EMIT device-networking software from emWare (the company I work for). EMIT is emWare's embedded software for network-enabling small devices. Many of these devices use 8-bit microcontrollers and don't have the resources to run a Java VM. In many cases, it is cost prohibitive to add the resources needed to run Java. EMIT provides network access for this class of embedded microcontrollers.</p><p>Even though a small device can't run a Java program, it is capable of storing the program needed for its operation. This program can be read from the device (via EMIT) and loaded into a Java VM running on some larger platform that is connected to the device. The device could then be controlled by running the program that was obtained from the device itself. In this way, the device becomes self describing. The program needed to use (or configure) the device is obtained from the device. Because the device is available on a network, the Java code required to use the device can be transferred to any device on the network that is capable of running Java. Without installing any software, you could control a wide range of devices from anywhere on a network.</p><h3>How to Do It</h3><p>Although the idea of creating a custom class loader sounds mysterious, it is surprisingly straightforward. Here, I provide an overview of a custom class loader for Java 1.1. Custom class loaders for Java 1.2 are a little different, and I'll point out those differences in this article. Class loaders written for Java 1.1 are<b> </b>compatible with Java 1.2. </p><p>To create a custom class loader, you: </p><p>1. Extend the class <i>java.lang.ClassLoader</i>. This extension will need a method capable of reading the raw class data into a byte array.</p><p>2. Override the method <i>ClassLoader.loadClass</i>. Within <i>loadClass</i>, read in the raw class data and call the method <i>ClassLoader.defineClass </i>to transform the raw data into a Java class in the VM.</p><p>3. To load a class, call the <i>loadClass</i> method of your <i>ClassLoader</i> extension.</p><p>4. To create a new instance of the class you loaded, call its <i>newInstance</i> method. </p><p>You now have a new instance of a class that was loaded from a source you defined. Overall, the process is simple and elegant (as opposed to COM), but there are some important details to know to make it all work.</p><ul>  <li>In general, an applet can't create a class loader. The reason is security. Actually, an applet can instantiate its own class loader if the applet is digitally signed and gets permission. Using digitally signed applets is beyond the scope of this article.  <li>The class to be loaded must contain a public constructor that takes no parameters; for example, <i>public MyClass() {}</i>.   <li>A custom class loader is responsible for loading all the classes required by any class you specifically load. The required classes are all the parent classes, interfaces, and any classes instantiated by the class you are loading. Loading the required classes is handled differently in Java 1.1 and 1.2. In Java 1.1, the custom class loader is responsible for making the appropriate calls to the parent class loader to first search the class cache, and if that fails, it must ask the system loader to handle loading the class. If these actions fail, then the custom class loader is responsible for handling the class.   <li>	   In Java 1.2, the custom class loader is only responsible for loading the class requested and not all the classes required by the requested class. Methods in the class <i>ClassLoader </i>handle loading any required classes and call the subclass to load the requested class.   <li>Your class loader should be instantiated only once in your program. Instantiate and assign the class loader to a field within your application class or some other variable whose life time is the length of your program. The class loader maintains a cache of the classes that are loaded. If the class loader is instantiated whenever you need it, the caching mechanism will not work. Classes needed more than once will be read from their source instead of being created from the class cache. This could really slow things down.</ul><h3>The Example</h3><p>The example application displays a frame with a single button. Clicking the Load Classes button causes the sample classes to be loaded and executed. Each click of the Load Classes button toggles between using the Java 1.1 and Java 1.2 class loader; see <A NAME="rf1"><A HREF="0006hf1.htm">Figure 1</A>. The application writes messages to the console showing which classes are being loaded, which class loader was used (system versus the custom loaders), and the execution of the sample classes created by the custom loaders. <A NAME="rl1"><A HREF="#l1">Listing One</A>, the application output, shows the console output. It's interesting to watch a class loading sequence. You can see all the classes required by either of the sample classes by watching the loading sequence.</p><p>For the sake of this article, the custom class loader simply loads classes from files. This isn't that useful (since the Java system already does it), but using files is an easy way to demonstrate how a class loader works without worrying about how to store and retrieve the raw class data. Once you have a basic class loader, you can customize it to load the raw class data from all sorts of places. In fact, I have used a custom class loader to load classes from a board containing a Hitachi H8 microcontroller enabled with EMIT. I also plan on storing classes into a database.</p><p>The custom class loader consists of a number of files, including: <i>CustomClassLoader.java</i>, the Java 1.1 class loader (also compatible with Java 1.2); <i>CustomLoader2.java</i>, the Java 1.2 class loader; <i>DeviceController.java</i>, a sample class to be loaded and executed; <i>SimpleSquare .java</i>, a sample class to be loaded and executed; <i>DeviceControls.java</i>, the interface for using the <i>DeviceController</i> class; and Frame1.java, the driver application. All of these files are available electronically; see "Resource Center," page 5.</p><h3>Using the Loaded Classes</h3><p>There is, however, a major hurdle to using a class obtained through a custom class loader: How are instances of the class used by the program that needs it? This problem is a little tricky because the usual approach won't work. You simply can't load the class, cast it to the appropriate class type, and use it.</p><blockquote><p>MyClass newClass = (MyClass) custom-     Loader.loadClass ("MyClass") ; // no good</p></blockquote><p>This doesn't work (a <i>ClassNotFoundException</i> is thrown) because of the references in the code to our new class <i>MyClass</i>. To load a class containing this line of code, the Java VM will need to load the class <i>MyClass </i>in order to resolve the class references. Because this class is not available to the Java VM (only a custom loader can get it), this doesn't work.</p><p>Even if you put the class file for <i>MyClass </i>somewhere the Java VM can find (which will allow you to successfully build the code) your program will stop at this line of code with a <i>ClassCastException</i> error. Huh? The reason this second effort doesn't work is classes loaded from two separate class loaders are considered different types and are not assignment compatible. This is true if both class loaders read the same byte array from the same file (or other source). You can prove this another way by using the <i>instanceof</i> operator to test the classes separately. For this test to work, you must first comment out the line in the method <i>loadClass </i>within CustomClassLoader.java that calls the system loader to load the class. If this change isn't made, the class loader will actually use the system to load the class instead of performing the load itself, which will defeat the test.</p><blockquote><p>// newClass = findSystemClass(name);     // ask the system loader to load the class</p></blockquote><p>See <A NAME="rl2"><A HREF="#l2">Listing Two</A>. The variable <i>theSame</i> will be false. </p><p>So how do you use a class if you can't refer to it in your program without first having the class around? And don't try to cheat by building your program using the class file for <i>MyClass</i>, and then removing it when you're ready to run the program. You will get the program to build, but as soon as the Java VM attempts to load the program and encounters a reference to <i>MyClass</i>, the VM will attempt to load <i>MyClass</i> and fail. Remember, Java is a very dynamic and strongly typed language.</p><p>To follow are three solutions to solving the chicken-and-egg problem of using classes created by a custom class loader. The first is to extend an existing Java class. The second solution is to create an interface that is implemented by the class to be handled by the custom loader. The third approach is to use the reflection API to operate the classes handled by the custom class loader.</p><h3>Extend an Existing Java Class</h3><p><A NAME="rl3"><A HREF="#l3">Listing Three</A> is SimpleSquare.java, a sample class that extends <i>Canvas</i> to draw a red square by setting the color and size of the <i>Canvas</i> and letting the inherited methods do the rest. When the class <i>SimpleSquare</i> is loaded, it is cast to a <i>Canvas</i> and not to a <i>SimpleSquare</i> that wouldn't work. This new <i>Canvas</i> can be used like any other <i>Canvas</i>. It is simply added to a frame so it can be displayed (see <i>Frame1.LoadButton_ActionPerformed</i> within <i>Frame1.java</i>; available electronically). This approach works because <i>SimpleSquare</i> is a <i>Canvas</i>, and <i>Canvas</i> is an existing class within the Java VM. Remember though, within the code that uses <i>SimpleSquare</i>, you are limited to using only those methods of the class <i>Canvas</i> and its ancestors. Methods within <i>SimpleSquare</i> are still free to call any methods within <i>SimpleSquare</i> and not just those inherited from <i>Canvas</i>.</p><p>This approach can work well for graphics and interface elements. Because new graphics and interface classes are created by extending existing ones and overriding the appropriate methods, there are no compile-time or run-time problems.</p><h3>Creating an Interface Wrapper </h3><p>What do you do when you want to load a class that doesn't inherit from an existing class in Java? For example, I've created a device controller class and want to store that class on the device itself. When the device comes online, I will use my class loader to retrieve this device controller class. My device controller class, however, doesn't inherit from an existing Java class; see DeviceController.java (available electronically).</p><p>In this situation, I can use an interface to act as a wrapper for the device control class. This interface exposes only those methods that need to be called from the program using the device control class. The interface methods are implemented within my device control class. The class file for the wrapper interface is provided to the Java VM where the program using the device control class will be running. DeviceControls.java (available electronically) shows the interface and <i>Frame1 .LoadButton_ActionPerformed</i> shows its usage.</p><p>This technique is just a variation of using an existing Java class. The difference is I am responsible for creating the interface for my device control class instead of relying on an existing Java class. I also must add my interface to the Java VM by copying the class file to a location that is within the VM's class path. An abstract class could also be used in this situation. The abstract class becomes the existing class in the Java VM from which your loaded classes inherit.</p><h3>Using Reflection</h3><p>Using reflection is the most generalized and difficult solution. The idea is this: Get the class name and then, based on the class, call methods in the loaded class using the reflection API. Using reflection, you don't need an interface for the classes you load. You can also call any method in the classes you load (provided they are public and there aren't any other security restrictions), but you will have to write code to examine those classes and call the methods via reflection; see <i>Frame1.useReflection</i> (available electronically). This is a lot of work. Also, it doesn't skirt the problem of having to install a class in the Java VM that will be responsible for loading and using the classes you have stored elsewhere. Reflection should be used only as a last resort if there is a situation that can't be handled with an interface. Using an interface to operate the classes you load is much simpler than using reflection and, for the most part, accomplishes the same thing.</p><h3>Java 1.2</h3><p>Creating a class loader for Java 1.2 is a little different than 1.1. Instead of overriding <i>ClassLoader.loadClass</i>, a new method named <i>findClass</i> is overridden. In <i>findClass</i> all you have to do is read and define your class. You are freed from the responsibility of having to call other methods to search for a class within the the class cache and the system before loading the class yourself. In Java 1.2, <i>ClassLoader.loadClass</i> performs the required calls for you and only calls your subclasses <i>findClass</i> method when the requested class wasn't found in the system. Sun calls this new technique "delegation" because the responsibility for loading the class is first delegated to the parent class. This approach should make custom class loaders more reliable because you don't have to worry about searching the system before loading a class yourself. This technique only works with Java 1.2, so if you have a need to remain compatible with Java 1.1, stick with the previously described approach; see CustomLoader2.java (available electronically). </p><h3>Don't Believe Everything You Read</h3><p>There are places in the Javadoc documentation concerning the class <i>ClassLoader</i> that are incorrect. This makes figuring out what you need to do confusing. Here are the mistakes I found: </p><ul>  <li>Java 1.1 API. The Javadoc page shows subclasses of <i>ClassLoader</i> are responsible for maintaining their own cache for the classes they load. This is not the case. The base class <i>ClassLoader</i> has its own cache (a <i>Hashtable</i>) and adds classes to this cache when you call <i>ClassLoader.defineClass</i>. The cache is searched when you call <i>ClassLoader .findLoadedClass</i>.  <li>Java 1.2 API. The Javadoc page shows the method <i>ClassLoader.findClass</i> calling <i>ClassLoader.loadClassData</i> to read the class data. Unfortunately, <i>loadClassData</i> doesn't exist. Subclasses of <i>ClassLoader</i> should just override <i>findClass</i> to load the data and define the class. The comments in the source code for <i>ClassLoader</i> are wrong. You have to look at the source to figure this out.</ul><h3>Conclusion </h3><p>There are several areas concerning class loaders that I haven't mentioned here. Security, of course, is important. Class loaders are constrained by the Security Manager and if you want to use a custom class from within an applet, the applet must be signed and get permission to create a class loader. Also, loading other types of data needed by Java programs to run (sounds, graphics, and the like) is also the responsibility of a class loader. Data other than classes are collectively known as resources (not to be confused with resources on the Windows or Macintosh platforms) and are handled in much the same way as loading a class. See the documentation of <i>ClassLoader.getResource</i> for more details.</p><p>Using custom class loaders creates new possibilities for dynamic applications. Applications don't need to be constrained by the classes that are immediately available to the VM. An application can search for the classes it needs from a variety of sources. I expect to see applications in the future using classes from a variety of sources such as embedded devices, servers, and databases.</p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>-----------------------------------------------------------java.lang.ClassNotFoundException: mypackage.SimpleSquarejava.lang.ClassNotFoundException: mypackage.DeviceControllerClass java.awt.Canvas loaded by the system loaderClass mypackage.SimpleSquare loaded by CustomClassLoaderClass java.lang.Object loaded by the system loaderClass DeviceControls loaded by the system loaderClass mypackage.DeviceController loaded by CustomClassLoaderClass java.lang.Throwable loaded by the system loaderClass java.awt.Rectangle loaded by the system loaderClass java.awt.Component loaded by the system loaderClass java.awt.Color loaded by the system loaderClass java.lang.System loaded by the system loaderClass java.io.PrintStream loaded by the system loaderDevice is now onGetting device powerBattery Power = 10Calling onOff() and getBatterPower() using reflectionDevice is now onGetting device power-----------------------------------------------------------java.lang.ClassNotFoundException: mypackage.SimpleSquarejava.lang.ClassNotFoundException: mypackage.DeviceControllerLoading class mypackage.SimpleSquareLoading class java.awt.CanvasClass mypackage.SimpleSquare loaded by CustomLoader2Loading class mypackage.DeviceControllerLoading class java.lang.ObjectLoading class DeviceControlsClass mypackage.DeviceController loaded by CustomLoader2Loading class java.lang.ThrowableLoading class java.awt.RectangleLoading class java.awt.ComponentLoading class java.awt.ColorLoading class java.lang.SystemLoading class java.io.PrintStreamDevice is now onGetting device powerBattery Power = 10Calling onOff() and getBatterPower() using reflectionDevice is now onGetting device power</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>/* Test a class loaded by the class loader against the same class loaded by the system */Class  loadedClass  =  customLoader.loadClass("MyClass");MyClass             vmClass = new MyClass();  // MyClass loaded by Java boolean             theSame = vmClass.isInstance(loadedClass);System.out.println("Are the classes the same? " + theSame);</pre><P><A HREF="#rl2">Back to Article</A></P><H4><A NAME="l3">Listing Three</H4><pre>package mypackage;import java.awt.*;/* A real simple Canvas class to test with our class loader.SimpleSquare appears as a red square. */public class SimpleSquare extends java.awt.Canvas{    public SimpleSquare()    {        this.setBounds( new Rectangle( 10, 30, 50, 50) );        this.setBackground(Color.red);    }}</pre><P><A HREF="#rl3">Back to Article</A></P></body></html>