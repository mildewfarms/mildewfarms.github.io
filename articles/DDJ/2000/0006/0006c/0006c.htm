<html><head><title>Jun00: State Patterns  & C++</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>State Patterns  &amp; C++</h1><p><i>Dr. Dobb's Journal</i> June 2000</p><h2>When objects need to change their behavior</h2><h3>By Julian Macri</h3><I>Julian develops Java applications to support securities trading. He can be contacted at luvmusic@alum.mit.edu.</I><hr><p>In object-oriented design, objects can modify their behavior based on the current state of their attributes. The State pattern (see <i>Design Patterns: Elements of Reusable Object-Oriented Software</i>, by Erich Gamma, et al., Addison-Wesley, 1994) abstracts the ability for an object to change its behavior. For any class that has state-dependent behavior, a separate class hierarchy can be created representing the various states that the subject class can have.</p><p>In this article, I'll present two ways the State design pattern can be implemented in C++:</p><DDJADVERTISEMENT INLINE><ul>  <li>A delegation model, where the context object (the object that has state-dependent behavior) delegates the handling of a state-dependent message to its state object. The state object performs the appropriate action and changes the context's state, if necessary. This delegation implementation is the suggested implementation in <i>Design Patterns</i>.   <li>The checker implementation, where all behavior is kept in the context class, but the state class hierarchy offers a set of checker methods that respond true or false based on the current state. Based on these checker methods, the context object performs the appropriate action.</ul><p>To illustrate how you can use these two implementations, I present an automatic-teller machine (ATM) program that lets users deposit money into an account, withdraw money from it, or ask the account to pay interest (6.5 percent in this example). The rules for an account are such that it bears interest only if the balance is greater than or equal to some minimum balance ($500.00, in this case). Also, if the balance is less than the minimum balance, then all deposits and withdrawals will result in a transaction fee being charged against the account (the transaction fee is $1.00). One unique feature of this account is that it allows the account holder to overdraw on it; thereby allowing the balance to go negative. Once it is negative, the account holder is not allowed to withdraw any more until enough deposits are made to make the balance positive again.</p><h3>The Delegation Implementation</h3><p>In <A NAME="rf1"><A HREF="0006cf1.htm">Figure 1</A>, which is a static model of the delegation implementation, a relationship exists between an <i>Account</i> and a <i>State</i>. <i>State</i> contains all the attributes of <i>Account</i> (in this case, the balance). <A NAME="rl1"><A HREF="#l1">Listing One</A> contains the definition for class <i>State</i>. Not only does <i>State</i> contain its context's attributes, but it also has reference to its context, which, in our example, is an <i>Account</i> object. The <i>State</i> class also provides the <i>deposit(amount)</i> and <i>withdraw(amount)</i> methods because they do have specific abstract behavior (see <A NAME="rl2"><A HREF="#l2">Listing Two</A>). Both of these methods adjust the balance accordingly, but then they call the <i>transitionState()</i> function, which is specified as a pure virtual function. All derived classes must implement this function. This is where the derived classes will contain their specific rules for determining when an account transitions from one state to another, and cause the state transition to occur. </p><p>The <i>State</i> class also specifies the <i>payInterest()</i> method as a pure virtual function because the function of paying interest is very specific to the concrete class.  </p><p><i>State</i>, which is an abstract class, has three classes derived from it. The following classes (see <A NAME="rl3"><A HREF="#l3">Listing Three</A>) represent the three states that an <i>Account</i> can have: <i>InterestBearingState</i>, <i>NonInterestBearingState</i>, and <i>OverdrawnState</i>. <i>InterestBearingState</i> inherits the <i>deposit(amount)</i> and <i>withdraw(amount)</i> methods. <A NAME="rl4"><A HREF="#l4">Listing Four</A> is an implementation of the <i>payInterest()</i> function as well as the <i>transitionState()</i> function (both specified as pure virtual functions in class <i>State</i>). <i>transitionState()</i> determines what the new state should be, if a state change is necessary, and tells its context (the account) to change state.</p><p>The <i>NonInterestBearingState</i> class definition (see <A NAME="rl3"><A HREF="#l3">Listing Three</A>) overrides the <i>deposit(amount)</i> and <i>withdraw(amount)</i> methods. <A NAME="rl5"><A HREF="#l5">Listing Five</A> shows that both methods first deduct a transaction fee from the balance, then invoke the respective <i>deposit(amount)</i> or <i>withdraw(amount)</i> function in the base class <i>State</i>. They both also tell the user that a transaction fee was charged.</p><p>OverdrawnState is derived from <i>NonInterestBearingState</i> because it is a special case of a noninterest-bearing account. Like a noninterest-bearing account, an overdrawn account does not pay interest, it charges a transaction fee and allows deposits to be made. The only exception, or specialization, is that overdrawn accounts do not allow withdrawals to be made. In this example, <i>OverdrawnState</i> overrides the <i>withdraw(amount)</i> method, disallowing the withdrawal and instead telling users that the withdrawal is not permitted (see <A NAME="rl6"><A HREF="#l6">Listing Six</A>).</p><p><i>NonInterestBearingState</i> and <i>OverdrawnState</i> both provide implementations for the <i>transitionState()</i> function (see <A NAME="rl5"><A HREF="#l5">Listings Five</A> and Six, respectively).</p><p>How does the account fit into all of this?  <A NAME="rl7"><A HREF="#l7">Listing Seven</A> shows the definition for the <i>Account</i> class. The methods <i>deposit(amount)</i>, <i>withdraw(amount)</i>, <i>payInterest()</i>, and <i>balance()</i> all delegate their implementations to the account's current state object. Depending on the current state object, these functions will behave differently. As you can see, the <i>Account</i> class is very light in code. Its largest function is the <i>changeState(newState)</i> method which cleanly sets its <i>_state</i> instance variable while deleting the previous state object.</p><p><A NAME="rl8"><A HREF="#l8">Listing Eight</A> is a program that creates an <i>account </i>object and allows a user to make deposits, withdrawals, and to ask for interest payment. <A NAME="rl9"><A HREF="#l9">Listing Nine</A> is sample output of this program.</p><h3>The Checker Implementation</h3><p>In the checker implementation, the <i>context </i>class still contains all the main logic, while its state hierarchy contains very thin classes that respond to various checker methods. In this example, <i>State</i> and its derived classes (see <A NAME="rf2"><A HREF="0006cf2.htm">Figure 2</A> and <A NAME="rl10"><A HREF="#l10">Listing Ten</A>) all respond to <i>isInterestBearing()</i>, <i>isNotInterestBearing()</i>, <i>isOverdrawn()</i>, <i>isNotOverdrawn()</i>, <i>requiresTransactionFee()</i>, and <i>doesNotRequireTransactionFee()</i>. The positive methods (<i>isInterestBearing()</i>, <i>isOverdrawn()</i>, and <i>requiresTransactionFee()</i>) are declared as pure virtual functions in <i>State</i>. The negative methods (<i>isNotInterestBearing()</i>, <i>isNotOverdrawn()</i>, and <i>doesNotRequireTransactionFee()</i>), provided for readability, simply return the Boolean opposite of the positive methods.</p><p>Once the state hierarchy and its checker methods have been implemented, the <i>Account</i> class can be developed. <A NAME="rl11"><A HREF="#l11">Listing Eleven</A> contains the definition for the class. You will see that <i>withdraw(amount)</i> and <i>payInterest()</i> ask its current state checker questions to determine how to behave. For example, in <i>payInterest()</i>, if the state is interest bearing, then interest is paid; otherwise, the message is displayed to users indicating that it is a noninterest-bearing account. Similarly, the <i>withdraw(amount)</i> method checks its state to determine if the account is overdrawn.</p><p>An event trigger and handling scheme is used to determine state transitions. Two possible events can happen to an <i>Account</i> object: Its balance can change and its state can change. The setter for the balance sets the <i>_balance</i> instance variable, then triggers the BALANCE_CHANGED event. Similarly, the setter for the state sets the <i>_state</i> instance variable and then triggers the STATE_CHANGED event. In the <i>event(event)</i> method in <A NAME="rl12"><A HREF="#l12">Listing Twelve</A>, different behaviors and state transitions can occur as the result of an event. If the balance has changed, then the current state may be asked some questions. For example, the state is asked if a transaction fee is required. If so, then the transaction fee is deducted from the balance (the instance variable is directly modified; otherwise, another BALANCE_CHANGED event would be triggered) and users are notified. Next, the state transition rules come into effect. Depending on the current balance and the current state's responses to various checker methods, the account changes to a new state. A STATE_CHANGED event is handled by asking the state object if the account is overdrawn. If so, users are notified of this. This will only occur when the account's state changes to <i>OverdrawnState,</i> which is the desired behavior.</p><p>Once again, refer to <A NAME="rl8"><A HREF="#l8">Listing Eight</A> for the ATM main program. Executing this code using the check implementation will result in the same behavior and output as for the delegation implementation.</p><h3>State as Singleton</h3><p>Performance overhead can be a concern for both implementations. If a context object can go through many state transitions, then a run-time overhead will be paid because of the construction and destruction of <i>state </i>objects. One solution is to make the various <i>state </i>classes Singletons. In the checker implementation, this is simple because none of the <i>state </i>classes contain instance variables. In the delegation implementation, <i>Account </i>would have to keep its own <i>_balance</i> instance variable. <i>State</i> would have no instance variables. Each method that the state hierarchy has would require an extra parameter, where the <i>context </i>object could pass itself in by reference (<i>deposit(amount, context)</i>, <i>withdraw(amount, context)</i>, and <i>payInterest(c</i>ontext), for instance); thereby eliminating the need for the <i>_context</i> instance variable.</p><h3>Conclusion</h3><p>Both approaches to the State design patterns have their pros and cons. In the delegation implementation, the state class hierarchy contains and implements the state-dependent attributes and methods of its <i>context </i>class. This usually results in the <i>context </i>class being very thin. The state hierarchy also contains and implements the rules for any state transitions. The checker implementation instead keeps the bulk of the code in the <i>context </i>class.  </p><p>The delegation implementation results in slightly more code to maintain but, in terms of complexity, it is a matter of opinion which is more complex. The checker implementation keeps all the code for any one method in one place, thereby allowing a programmer to concisely see all the different code paths for that method. The delegation implementation, on the other hand, spreads code across multiple classes. Although it is more difficult to see all the various code paths, it makes it easier to understand each individual code path because they aren't cluttered by large groups of <i>if-then-else</i> constructs. My recommendation is to use the checker implementation for classes that contain a small set of states. If you design classes that can go through many different possible states and, therefore, could have many different state-dependent behaviors, the delegation implementation is probably the better way to go.</p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>/***** (State class definition) ****************/class Account;class State{  friend class Account;  public:    static State * InitialState(Account * account);    static double CurrentMinimumBalance()    {         /* CODE THAT OBTAINS CURRENT MIN BALANCE FROM SOME DATABASE */      return CURRENT_MIN_BALANCE;    };  private:    Account * _context;    double    _balance;  protected:    Account * context() const {return _context;};    void      context(Account * newAccount) {_context = newAccount;};    double  balance() const {return _balance;};    void    balance(double newBalance) {_balance = newBalance;};    virtual State * transitionState() = 0;  public:    virtual void deposit(double amount);    virtual void withdraw(double amount);    virtual void payInterest() = 0;  public:    State(Account * account, double balance)      : _context(account),        _balance(balance)    {};    State(const State * source)     : _context(source-&gt;context()),       _balance(source-&gt;balance())    {};};</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>/************** (State class method code) ***************//************ class State **********************/State * State::InitialState(Account * account){  return new NonInterestBearingState(account, 0.0);}void State::deposit(double amount){  this-&gt;balance(this-&gt;balance() + amount);  this-&gt;transitionState();}void State::withdraw(double amount){  this-&gt;balance(this-&gt;balance() - amount);  this-&gt;transitionState();}</pre><P><A HREF="#rl2">Back to Article</A></P><H4><A NAME="l3">Listing Three</H4><pre>/*************** (Concrete state classes) *************/class InterestBearingState : public State{  public:    static double CurrentRate()    {         /* CODE THAT OBTAINS CURRENT RATE FROM SOME DATABASE */      return CURRENT_RATE;    };  protected:    virtual State * transitionState();  public:    virtual void payInterest();  public:    InterestBearingState(Account * account, double balance)      : State(account, balance)    {};    InterestBearingState(const State * source)      : State(source)    {};};class NonInterestBearingState : public State{  public:    static double CurrentTransactionFee()    {         /* CODE THAT OBTAINS CURRENT TRANSACTION FEE FROM SOME DATABASE */      return CURRENT_TRANSACTION_FEE;    };  protected:    virtual State * transitionState();  public:    virtual void deposit(double amount);    virtual void withdraw(double amount);    virtual void payInterest();  public:    NonInterestBearingState(Account * account, double balance)      : State(account, balance)    {};    NonInterestBearingState(const State * source)      : State(source)    {};};class OverdrawnState : public NonInterestBearingState{  protected:    void sendNoticeToAccountHolder()    {         /* PRINT OUT AND MAIL A NOTICE INDICATING ACCOUNT OVERDRAWN */      cout &lt;&lt; "YOUR ACCOUNT IS OVERDRAWN" &lt;&lt; endl;    };  protected:    virtual State * transitionState();  public:    virtual void withdraw(double amount);  public:    OverdrawnState(Account * account, double balance)      : NonInterestBearingState(account, balance)    {      this-&gt;sendNoticeToAccountHolder();    };    OverdrawnState(const State * source)      : NonInterestBearingState(source)    {      this-&gt;sendNoticeToAccountHolder();    };};</pre><P><A HREF="#rl3">Back to Article</A></P><H4><A NAME="l4">Listing Four</H4><pre>/*************** (InterestBearingState methods) ********************/State * InterestBearingState::transitionState(){  if (this-&gt;context()-&gt;balance() &lt; 0)    this-&gt;context()-&gt;changeState(new OverdrawnState(this));  else    if (this-&gt;context()-&gt;balance() &lt; State::CurrentMinimumBalance())      this-&gt;context()-&gt;changeState(new NonInterestBearingState(this));  return this-&gt;context()-&gt;state();}void InterestBearingState::payInterest(){  this-&gt;balance(this-&gt;balance() * (1 + this-&gt;CurrentRate()));  this-&gt;transitionState();}</pre><P><A HREF="#rl4">Back to Article</A></P><H4><A NAME="l5">Listing Five</H4><pre>/****************** (NonInterestBearingState methods) *******************/State * NonInterestBearingState::transitionState(){  if (this-&gt;context()-&gt;balance() &lt; 0)    this-&gt;context()-&gt;changeState(new OverdrawnState(this));  else    if (this-&gt;context()-&gt;balance() &gt;= State::CurrentMinimumBalance())      this-&gt;context()-&gt;changeState(new InterestBearingState(this));  return this-&gt;context()-&gt;state();}void NonInterestBearingState::payInterest(){      /* PAY NO INTEREST AT ALL */  cout &lt;&lt; "THIS ACCOUNT IS CURRENTLY NOT EARNING INTEREST" &lt;&lt; endl;}void NonInterestBearingState::deposit(double amount){      /* Charge the transaction fee and then deposit */  this-&gt;balance(this-&gt;balance() - this-&gt;CurrentTransactionFee());  this-&gt;State::deposit(amount);  cout &lt;&lt; "A TRANSACTION FEE WAS CHARGED" &lt;&lt; endl;}void NonInterestBearingState::withdraw(double amount){      /* Charge the transaction fee and then withdraw */  this-&gt;balance(this-&gt;balance() - this-&gt;CurrentTransactionFee());  this-&gt;State::withdraw(amount);  cout &lt;&lt; "A TRANSACTION FEE WAS CHARGED" &lt;&lt; endl;}</pre><P><A HREF="#rl5">Back to Article</A></P><H4><A NAME="l6">Listing Six</H4><pre>/***************** (OverdrawnState methods) **************/State * OverdrawnState::transitionState(){  if (this-&gt;context()-&gt;balance() &gt;= State::CurrentMinimumBalance())    this-&gt;context()-&gt;changeState(new InterestBearingState(this));  else    if (this-&gt;context()-&gt;balance() &gt;= 0)      this-&gt;context()-&gt;changeState(new NonInterestBearingState(this));  return this-&gt;context()-&gt;state();}void OverdrawnState::withdraw(double amount){      /* DO NOT ALLOW THEM TO WITHDRAW MORE MONEY */  cout &lt;&lt; "YOU ARE NOT ALLOWED TO WITHDRAW FROM AN OVERDRAWN ACCOUNT" &lt;&lt; endl;}</pre><P><A HREF="#rl6">Back to Article</A></P><H4><A NAME="l7">Listing Seven</H4><pre>/**************** (Account class definition) **********/#include "state.h"class Account{  friend class State;  friend class InterestBearingState;  friend class NonInterestBearingState;  friend class OverdrawnState;  private:    State * _state;  protected:    State *  state() const {return _state;};    void     state(State * newState) {_state = newState;};    void changeState(State * newState)    {      if (newState != this-&gt;state())      {        delete this-&gt;state();        this-&gt;state(newState);      }    };  public:    double balance()    {      return this-&gt;state()-&gt;balance();    };    void deposit(double amount)    {      this-&gt;state()-&gt;deposit(amount);    };    void withdraw(double amount)    {      this-&gt;state()-&gt;withdraw(amount);    };    void payInterest()    {      this-&gt;state()-&gt;payInterest();    };  public:    Account()      : _state(State::InitialState(this))    {};    virtual ~Account()    {      delete this-&gt;state();    };};</pre><P><A HREF="#rl7">Back to Article</A></P><H4><A NAME="l8">Listing Eight</H4><pre>/************** (atm.C) ************/#include "account.h"#include "iostream.h"#include "iomanip.h"int main(){  char   option;  double amount;  int    quit = 0;  Account account;  cout &lt;&lt; "WELCOME TO JULIAN'S BANK" &lt;&lt; endl;  cout &lt;&lt; "========================" &lt;&lt; endl;  while (!quit)  {    cout &lt;&lt; endl &lt;&lt; "Do you want to (d)eposit,(w)ithdraw, earn (i)nterest,                                                      or (q)uit? " &lt;&lt; flush;    cin &gt;&gt; option;    cout &lt;&lt; setiosflags(ios::fixed) &lt;&lt; setprecision(2);    switch (option)    {      case 'd' :      case 'D' :           cout &lt;&lt; "Deposit amount = " &lt;&lt; flush;           cin &gt;&gt; amount;           account.deposit(amount);           cout &lt;&lt; "Balance = $" &lt;&lt; account.balance() &lt;&lt; endl;           break;      case 'w' :      case 'W' :           cout &lt;&lt; "Withdrawal amount = " &lt;&lt; flush;           cin &gt;&gt; amount;           account.withdraw(amount);           cout &lt;&lt; "Balance = $" &lt;&lt; account.balance() &lt;&lt; endl;           break;      case 'i' :      case 'I' :           account.payInterest();           cout &lt;&lt; "Balance = $" &lt;&lt; account.balance() &lt;&lt; endl;           break;      case 'q' :      case 'Q' :           quit = 1;           break;    }  }  return 0;}</pre><P><A HREF="#rl8">Back to Article</A></P><H4><A NAME="l9">Listing Nine</H4><pre>/***************** (Program output) ******************/[ric1:macri]/u/macri/article/code1 &gt;&gt; atmWELCOME TO JULIAN'S BANK========================Do you want to (d)eposit,(w)ithdraw, earn (i)nterest, or (q)uit? dDeposit amount = 1000A TRANSACTION FEE WAS CHARGEDBalance = $999.00Do you want to (d)eposit,(w)ithdraw, earn (i)nterest, or (q)uit? iBalance = $1063.94Do you want to (d)eposit,(w)ithdraw, earn (i)nterest, or (q)uit? dDeposit amount = 500Balance = $1563.94Do you want to (d)eposit,(w)ithdraw, earn (i)nterest, or (q)uit? wWithdrawal amount = 1250Balance = $313.93Do you want to (d)eposit,(w)ithdraw, earn (i)nterest, or (q)uit? iTHIS ACCOUNT IS CURRENTLY NOT EARNING INTERESTBalance = $313.93Do you want to (d)eposit,(w)ithdraw, earn (i)nterest, or (q)uit? wWithdrawal amount = 500YOUR ACCOUNT IS OVERDRAWNA TRANSACTION FEE WAS CHARGEDBalance = $-187.07Do you want to (d)eposit,(w)ithdraw, earn (i)nterest, or (q)uit? wWithdrawal amount = 200YOU ARE NOT ALLOWED TO WITHDRAW FROM AN OVERDRAWN ACCOUNTBalance = $-187.07Do you want to (d)eposit,(w)ithdraw, earn (i)nterest, or (q)uit? dDeposit amount = 1000A TRANSACTION FEE WAS CHARGEDBalance = $811.94Do you want to (d)eposit,(w)ithdraw, earn (i)nterest, or (q)uit? q[ric1:macri]/u/macri/article/code1 &gt;&gt;</pre><P><A HREF="#rl9">Back to Article</A></P><H4><A NAME="l10">Listing Ten</H4><pre>/****************** (State class definition) *********************/class State{  public:    static State * InitialState();  public:    virtual int isOverdrawn() = 0;    int isNotOverdrawn() {return !this-&gt;isOverdrawn();};    virtual int isInterestBearing() = 0;    int isNotInterestBearing() {return !this-&gt;isInterestBearing();};    virtual int requiresTransactionFee() = 0;    int doesNotRequireTransactionFee() {return                                     !this-&gt;requiresTransactionFee();};};class InterestBearingState : public State{  public:    virtual int isOverdrawn()            {return 0;};    virtual int isInterestBearing()      {return 1;};    virtual int requiresTransactionFee() {return 0;};};class NonInterestBearingState : public State{  public:    virtual int isOverdrawn()            {return 0;};    virtual int isInterestBearing()      {return 0;};    virtual int requiresTransactionFee() {return 1;};};class OverdrawnState : public NonInterestBearingState{  public:    virtual int isOverdrawn() {return 1;};};</pre><P><A HREF="#rl10">Back to Article</A></P><H4><A NAME="l11">Listing Eleven</H4><pre>/***************** (Account class definition) *****************/#include "state.h"#include "iostream.h"class Account{  public:    static double CurrentRate();    static double CurrentMinimumBalance();    static double CurrentTransactionFee();  protected:    enum EVENT    {      BALANCE_CHANGED,      STATE_CHANGED    };  private:    double  _balance;    State * _state;  protected:    void event(EVENT event);    State *   state() const {return _state;};    void state(State * newState)    {      _state = newState;      this-&gt;event(STATE_CHANGED);    };    void changeState(State * newState)    {      if (newState != this-&gt;state())      {        delete this-&gt;state();        this-&gt;state(newState);      }    };    void balance(double newBalance)    {      _balance = newBalance;      this-&gt;event(BALANCE_CHANGED);    };    void sendNoticeToAccountHolder()    {         /* PRINT OUT AND MAIL A NOTICE INDICATING ACCOUNT OVERDRAWN */      cout &lt;&lt; "YOUR ACCOUNT IS OVERDRAWN" &lt;&lt; endl;    };  public:    double balance() { return _balance; };    void deposit(double amount)    {      this-&gt;balance(this-&gt;balance() + amount);    };    void withdraw(double amount)    {      if (this-&gt;state()-&gt;isNotOverdrawn())        this-&gt;balance(this-&gt;balance() - amount);      else        cout &lt;&lt; "YOU ARE NOT ALLOWED TO WITHDRAW FROM                                         AN OVERDRAWN ACCOUNT" &lt;&lt; endl;    };    void payInterest()    {      if (this-&gt;state()-&gt;isInterestBearing())        this-&gt;balance(this-&gt;balance() * (1 + Account::CurrentRate()));      else        cout &lt;&lt; "THIS ACCOUNT IS CURRENTLY NOT EARNING INTEREST" &lt;&lt; endl;    };  public:    Account()      : _state(State::InitialState()),        _balance(0)    {};    virtual ~Account()    {      delete this-&gt;state();    };};</pre><P><A HREF="#rl11">Back to Article</A></P><H4><A NAME="l12">Listing Twelve</H4><pre>/**************** (Account methods) ***************/#include "account.h"const double CURRENT_RATE            = 0.065;const double CURRENT_MIN_BALANCE     = 500.00;const double CURRENT_TRANSACTION_FEE = 1.00;double Account::CurrentRate(){         /* CODE THAT OBTAINS CURRENT RATE FROM SOME DATABASE */  return CURRENT_RATE;}double Account::CurrentMinimumBalance(){         /* CODE THAT OBTAINS CURRENT MIN BALANCE FROM SOME DATABASE */  return CURRENT_MIN_BALANCE;}double Account::CurrentTransactionFee(){         /* CODE THAT OBTAINS CURRENT FEE FROM SOME DATABASE */  return CURRENT_TRANSACTION_FEE;}void Account::event(EVENT event){  switch (event)  {    case BALANCE_CHANGED :           if (this-&gt;state()-&gt;requiresTransactionFee())           {                  /* Set the instance variable directly because*/                  /* we don't want to trigger another event.   */             _balance -= Account::CurrentTransactionFee();             cout &lt;&lt; "A TRANSACTION FEE WAS CHARGED" &lt;&lt; endl;           }           if (this-&gt;balance() &lt; 0)           {             if (this-&gt;state()-&gt;isNotOverdrawn())               this-&gt;changeState(new OverdrawnState());           }           else if (this-&gt;balance() &lt; Account::CurrentMinimumBalance())           {             if (this-&gt;state()-&gt;isInterestBearing() ||                 this-&gt;state()-&gt;isOverdrawn())               this-&gt;changeState(new NonInterestBearingState());           }           else           {             if (this-&gt;state()-&gt;isNotInterestBearing())               this-&gt;changeState(new InterestBearingState());           }           break;    case STATE_CHANGED :           if (this-&gt;state()-&gt;isOverdrawn())             this-&gt;sendNoticeToAccountHolder();           break;  }}</pre><P><A HREF="#rl12">Back to Article</A></P></body></html>