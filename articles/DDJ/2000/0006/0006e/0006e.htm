<html><head><title>Jun00: An Object-Oriented  UI for Perl</title></head><body BGCOLOR="#ffffff" LINK="#0000ff" VLINK="#330066" ALINK="#ff0000" TEXT="#000000"><!--Copyright &#169; Dr. Dobb's Journal--><h1>An Object-Oriented  UI for Perl</h1><p><i>Dr. Dobb's Journal</i> June 2000</p><h2>Don't overlook  Perl's OO features</h2><h3>By Robert Kiesling</h3><I>Robert is maintainer of the Linux FAQ on the Internet. He can be contacted at rkiesling@mainmatter.com.</I><hr><p>While much has been written about Perl's capabilities as a glue language for system programming, its semantic capabilities and interpreted nature make it an ideal candidate for object-oriented programming, too. Yet Perl's object-oriented features are often overlooked, partly because the language does not require their use, and also because the language's command-line user interface does not encourage programmers to view the language in terms of objects.</p><p>If you work with OO languages, you are likely accustomed to user-interface objects (class browsers and text workspaces) written in the language itself, which highlight the object-oriented features of the language's internal structures. However, neither browser nor workspace are part of the standard Perl distribution. In this article, I'll show one way that Perl's features can provide subclass inheritance and methods that access an object's data, and how they contribute to Perl's usefulness in object-oriented projects.</p><DDJADVERTISEMENT INLINE><p>There are many features that a graphical workspace could have. The Workspace.pm module (available electronically; see "Resource Center," page 5) presented here implements only a few of them. Instead of relying on Perl's text-mode UI facilities, the Workspace.pm module relies on Perl/TK, a package of C and Perl libraries that provide an API for the Tk GUI library (http://www .cpan.org/).</p><p>Again, Perl does not enforce object-oriented programming techniques, and common Perl data types such as scalars and hashes do not belong to a class hierarchy. Formal class membership is declared with the Perl keyword <i>ISA</i>. In the case of a Workspace, I declare it to be a subclass of a Perl/Tk text widget with the declaration:</p><blockquote><p>@ISA = qw(Tk::TextUndo);</p></blockquote><p><A NAME="rl1"><A HREF="#l1">Listing One</A> is the object class hierarchy for a Workspace. Subclasses are separated by double colons. By convention, Perl classes conform to the hierarchy of their source files in a directory structure, but again, this is not strictly necessary.</p><p>Another keyword for specifying class membership is <i>bless</i>, which identifies an object as an instance of a class. Objects are typically <i>bless</i>ed into a class in the constructor. Constructor functions in Perl are often named <i>new</i>, but, as with many other features of the language, Perl does not enforce this convention. However, when instantiating classes, PerlTk uses the <i>Construct</i> widget declaration, and looks for the <i>Class::new function</i> when a widget is instantiated. <A NAME="rl2"><A HREF="#l2">Listing Two</A> shows the global class declarations and part of the <i>Workspace</i> constructor.</p><p>The <i>bless</i> function uses the class of the object that called the constructor to identify the instance. In Perl, <i>shift</i> returns the first argument that is passed to the function from the argument list and increments the head of the list to point to the next argument. The keyword <i>self</i> refers to the object itself. Almost universally, objects are Perl hash tables, because they lend themselves to random-access referencing.</p><p>Perl does not enforce the use of methods to access instance variable data, and in the constructor itself, you access the data directly. The statement:</p><blockquote><p>$self -&gt; {window} -&gt; {parent} = $self</p></blockquote><p>requires some explanation. Generally, the parent of a window object is used for sub-widgets. Here, however, you use the variable to refer to the complete object. The reference is useful when writing callback functions because often the window widget receives a user input event, such as a resize or move event from the window manager, but the <i>Workspace</i> object must process the event.</p><p>You can access the object's data directly within the Workspace.pm module itself, but other objects might need to use methods to access the data. This selection would depend on how difficult it would be to implement the reference, and how well behaved you would like the object to be. In any event, instance methods are not difficult to write. This is the method to set or retrieve the <i>Workspace</i>'s <i>Window</i> object:</p><blockquote><p>sub window {</p><p>    my $self = shift;</p><p>    if (@_) { $self -&gt; {window} = shift }</p><p>    return $self -&gt; {window}</p><p>}</p></blockquote><p>Using a method, any object can retrieve a <i>Workspace</i>'s text, as in:</p><blockquote><p>$text = $workspace -&gt; window -&gt; Get('1.0', 			        end);</p></blockquote><p>The <i>Get</i> method is used by many widgets, and the return value and arguments differ depending on the type of object; that is, a <i>Listbox</i> requires a numeric index, while a <i>Text</i> widget requires line and character-within-line information.</p><h3>Perl/Tk</h3><p>You can delay event binding nearly until run time, associating events like keystrokes with methods only if the run-time state of the object calls for it. Although the keystroke shortcuts for the menu functions are hard-coded, it would be a simple matter to include them in the text itself to be evaluated at run time, using Perl's <i>eval</i> function. This binding can be performed on all instances of the class, or on a per-object basis if desired.</p><h3>Interfacing Perl and Tk</h3><p>The interface that Perl/Tk presents to you relies on Perl's object-oriented programming features also. Each Tk widget is a subclass of the <i>Tk</i> class. <i>Widget</i>, <i>MainWindow</i>, <i>Wm</i> (window manager), and <i>Image</i>, have their own <i>constructor</i>, <i>class</i>, and <i>instance</i> methods. However, many of the classes are interdependent, and objects can be created to handle special events. The main user-interface widgets in the Perl/Tk widget hierarchy are shown in <A NAME="rl3"><A HREF="#l3">Listing Three</A>. In this implementation, the class hierarchy corresponds to the subdirectory hierarchy where Perl/Tk is installed (/usr/lib/perl5/ site_perl/ by default).</p><p>The Tk class provides services to the widgets through the <i>MainWindow</i> object that include event handling and user input binding. Each application must have a <i>MainWindow</i> object, at least, because the class receives event messages from the system.</p><h3>The Event Loop</h3><p>A call to the <i>MainLoop</i> function begins the actual program execution. This function is the standard entry point to the Perl/Tk kernel. Perl/Tk also has methods that allow user-defined events, such as key bindings and window callbacks.</p><p>In addition to functions called when users select a menu item, virtual callbacks allow the environment to communicate with the workspace with relative ease. For example, the workspace can record the window size and store the window geometry for use the next time it is opened. First, it is necessary to create the event binding, as in <A NAME="rl4"><A HREF="#l4">Listing Four</A>. The <i>bind</i> methods of the <i>TextUndo</i> and <i>MainWindow</i> classes are equivalent from the workspace's perspective -- all widgets use the same binding function of the PerlTk object superclass, but it is the <i>MainWindow</i> object that receives resizing events, called <i>Configure</i> events, from the X display server. Therefore, you want to bind the event to the display window widget. Perl/Tk provides a parameterized calling protocol between objects and the environment using the <i>Ev()</i> function call. Once you have bound the workspace method <i>ws_save_ size</i> to the event, the code for the method (<A NAME="rl5"><A HREF="#l5">Listing Five</A>) is straightforward. The only caveat is that you need to distinguish a <i>Configure</i> event that is received by the <i>Tk::MainWindow</i> object as opposed to the <i>Tk::TextUndo</i> object, due to the text widget's ability to process <i>Configure</i> events also.</p><h3>Implementing the Workspace Object</h3><p>Creating a workspace object is also straightforward: A call to the <i>Workspace:: create</i> function writes a template file with the name of the Workspace. The template contains only the label for the Workspace text, and the function calls that are strictly necessary at run time. The Workspace .pm library module contains most of the code that need not be part of the <i>Workspace</i> object itself. <A NAME="rl6"><A HREF="#l6">Listing Six</A> is the default <i>Workspace</i> object. I chose the dimensions to approximate an 80&times;24 character display, and to bless the <i>Workspace </i>as its own class, due to the design of the Perl/Tk interface, so that the <i>Workspace</i> would appear on the display under its name, instead of the generic name "Workspace."</p><p>The methods that access the Perl/Tk widgets use the same conventions as the Workspace.pm methods, because, again, the Perl objects that communicate with the Tk display library are implemented as hash table data.</p><h3>Using the Filesystem  as Persistent Memory</h3><p>Several Perl library modules exist that store objects as persistent memory in the filesystem. Their intended applications are for well-defined database objects. The <i>Workspace</i> object is only an elementary implementation for storing text data -- much more work could be done to store text format codes, hyperlinks, display parameters, and version information, for example.</p><p>Again, it would be possible, in some future version, to provide fields within the data, specified in Perl, and bound at run time. For the present, the <i>Workspace</i>s can import and export plain ASCII text. <A NAME="rl7"><A HREF="#l7">Listing Seven</A> shows the function used to export text, which can be called as a function from within the library code itself, or as a method from an external object. Another way the current <i>Workspace</i> implementation communicates with the environment is through the X clipboard. In this implementation, the standard <i>Cut</i>, <i>Copy</i>, and <i>Paste</i> functions are provided. It would be easy to extend the clipboard functions to provide yet another form of persistent memory, as appropriate for the X display server. <A NAME="rl8"><A HREF="#l8">Listing Eight</A> is an abbreviated method that pastes text into the workspace from the clipboard. Much more work can be done with the X clipboard because the X protocol allows for multiple selections, as described in the X11 ICCCM specification.</p><p>Provided that you can delay the binding of events to <i>Workspace</i> functions as close as possible to run time, you can maintain much of the flexibility in the <i>Workspace</i> specification that is inherent in the Perl language.</p><p><b>DDJ</b></p><H4><A NAME="l1">Listing One</H4><pre>Tk::WidgetTk::TextUndoTk::Workspace</pre><P><A HREF="#rl1">Back to Article</A></P><H4><A NAME="l2">Listing Two</H4><pre>@ISA = qw(Tk::TextUndo);Construct Tk::Widget `Workspace';sub new {    my $proto = shift;    my $class = ref( $proto ) || $proto;    my $self = {        window =&gt; new MainWindow,        textspace =&gt; undef,        name =&gt; ((@_)?@_:'Workspace'),        textfont =&gt; $defaulttextfont,        # default is approximate width and height of 80x24 char. text widget        width =&gt; $w,        height =&gt; $h,        filemenu =&gt; undef,        editmenu =&gt; undef,        helpmenu =&gt; undef,        menubar =&gt; undef,        text =&gt; []                   # The text itself.        };    bless($self, $class);    $self -&gt; {window} -&gt; {parent} = $self; ... etc. ...}</pre><P><A HREF="#rl2">Back to Article</A></P><H4><A NAME="l3">Listing Three</H4><pre>Tk     Derived           Debug           DirList           FloatEntry (Also derives from Entry)           MenuBar (Also derives from Menu)           OptionMenu (Also derives from Menubutton)     DragDrop     DropSite     Widget          Button               RadioButton          Canvas                  Checkbutton          CmdLine (resource)          ColorSelect          Entry          Frame                Adjuster                        BrowseEntry                LabFrame                LabRadioButton                Tiler                  Font          HList          Label          ListBox          MenuButton          Message          NBFrame               Notebook          Scale          Scrollbar          TList          Table          Text               TextUndo                    *Workspace*          TixGrid          Toplevel               Balloon               Dialog                    msgBox               DialogBox (also inherits from Frame)                       ErrorDialog               FBox (File selection dialog)               FileSelect               IconList     MainWindow     Text          ROText     Image          Bitmap          Photo                Animation          Pixmap     Wm (Window manager)          Menu</pre><P><A HREF="#rl3">Back to Article</A></P><H4><A NAME="l4">Listing Four</H4><pre> ($self -&gt; window) -&gt; SUPER::bind($self -&gt; window, `&lt;Configure&gt;',                                     [\&amp;ws_save_size, Ev(`W'),                                      Ev(`h'), Ev(`w'),                                      Ev(`x'), Ev(`y')]);</pre><P><A HREF="#rl4">Back to Article</A></P><H4><A NAME="l5">Listing Five</H4><pre>sub ws_save_size {     my $self = shift;     my $widget = shift;    my $height = shift;    my $width = shift;    # We need to do this because TextUndo subclasses MainWindow,    # and both of them send Configure messages.    if ( $self =~ /Tk::TextUndo/ ) {return;}     # We have to ref the parent widget directly because     # MainWindows don't define a parent widget value.    $self -&gt; {parent} -&gt; ws_width($width);    $self -&gt; {parent} -&gt; ws_height($height);}</pre><P><A HREF="#rl5">Back to Article</A></P><H4><A NAME="l6">Listing Six</H4><pre>#!/usr/bin/perlmy $text='';my $h='351';my $w='565';my $name='';use Tk::Workspace;:Workspace);use strict;use Tk;use FileHandle;use Env qw(HOME);my $workspace = Tk::Workspace -&gt; new;$workspace -&gt; name($name);$workspace -&gt; menubar -&gt; pack (-anchor =&gt; 'w', -fill =&gt; 'x');$workspace -&gt; textspace -&gt; insert ( 'end', $text );$workspace -&gt; textspace -&gt; pack;bless($workspace,ref('Tk::Workspace'));$workspace -&gt; bind;$workspace -&gt; window -&gt; geometry( $w . 'x' . $h );MainLoop;</pre><P><A HREF="#rl6">Back to Article</A></P><H4><A NAME="l7">Listing Seven</H4><pre>sub ws_export {    my $self = shift;    my $filedialog;    my $filename;    my $filename;    my $fh = new IO::File;    $filedialog = ($self -&gt; {window})                -&gt; FileSelect ( -directory =&gt; `.' );    $filename = $filedialog -&gt; Show;    $fh -&gt; open( "+&gt; $filename" ) or &amp;filenotfound( $self );    print $fh ($self -&gt; {textspace}) -&gt; get( `1.0', `end' );    close $fh;}</pre><P><A HREF="#rl7">Back to Article</A></P><H4><A NAME="l8">Listing Eight</H4><pre>sub ws_paste {    my $self = shift;    my $selection;    my $point;     $selection = ($self -&gt; {textspace}) -&gt; clipboardGet;    $point = ($self -&gt; {textspace}) -&gt; index("insert");    ($self -&gt; {textspace}) -&gt; insert( $point, $selection);    return $selection;}</pre><P><A HREF="#rl8">Back to Article</A></P></body></html>